<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/762011">
    <body>
      <group id="762011">
        <trans-unit id="fafcd2951a6c9ab9c6c43e67c5a38264f0cdd84a" translate="yes" xml:space="preserve">
          <source>... the loop unexpectedly outputs &quot;i is 5&quot; five times:</source>
          <target state="translated">... 루프가 예기치 않게 &quot;i is 5&quot;를 다섯 번 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6d871bd011c025ac22e1d36c547f25316c14c79d" translate="yes" xml:space="preserve">
          <source>... the output remains unchanged as long as we stick with &lt;code&gt;let&lt;/code&gt;.  In contrast, if we had used &lt;code&gt;var i&lt;/code&gt; instead:</source>
          <target state="translated">... &lt;code&gt;let&lt;/code&gt; 을 사용 하는 한 출력은 변경되지 않습니다. 반대로, 만약 우리가 대신 &lt;code&gt;var i&lt;/code&gt; 를 사용했다면 :</target>
        </trans-unit>
        <trans-unit id="43c75a7895bae9f2274a20daccd9c56125f42242" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;This table&lt;/a&gt; on Wikipedia shows which browsers support Javascript 1.7.</source>
          <target state="translated">Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;의이 표&lt;/a&gt; 는 Javascript 1.7을 지원하는 브라우저를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0191d36331a7f5a9e5755b19f3d7de9c667f7b49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;My value: 3&lt;/code&gt; was output to console each time &lt;code&gt;funcs[j]();&lt;/code&gt; was invoked since anonymous functions were bound to the same variable.</source>
          <target state="translated">&lt;code&gt;My value: 3&lt;/code&gt; &lt;code&gt;funcs[j]();&lt;/code&gt; 매번 콘솔에 3 이 출력되었습니다 . 익명 함수가 동일한 변수에 바인드 된 이후 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="ccc17ff02fbc922f367c8a5b47195617bb23fb48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is a signal that the identifier won&amp;rsquo;t be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 식별자가 재 할당되지 않음을 나타내는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="3308d036748c8401176277b68520b6bab4436169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is quite similar to &lt;code&gt;let&lt;/code&gt;&amp;mdash;it's block-scoped and has TDZ. There are, however, two things which are different.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 &lt;code&gt;let&lt;/code&gt; 과 매우 유사합니다. 블록 범위이며 TDZ가 있습니다. 그러나 다른 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="893fb0337fbc6374457738790cc8786afc01cbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is block scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 는 블록 범위입니다.</target>
        </trans-unit>
        <trans-unit id="0935015189555bca81712e46368bff07cdd2ad82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.</source>
          <target state="translated">폐쇄와 관련된 문제를 피하기 위해 사용할 수도 있습니다. 아래 예제와 같이 오래된 참조를 유지하는 대신 새로운 가치를 결속시킵니다.</target>
        </trans-unit>
        <trans-unit id="7da55d0ae5cba83af8d9bcddc15fbe75a305d540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; in the loop can &lt;strong&gt;re-binds it&lt;/strong&gt; to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,</source>
          <target state="translated">루프에서 루프를 반복 &lt;strong&gt;할&lt;/strong&gt; 때마다 루프를 &lt;strong&gt;다시 바인딩 할&lt;/strong&gt; 수 있으므로 이전 루프 반복의 끝에서 값을 다시 할당해야합니다. 치다,</target>
        </trans-unit>
        <trans-unit id="898943cc10dae9aa57654db408d0e9820a07b17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is interesting, because it allows us to do something like this:</source>
          <target state="translated">우리가 다음과 같이 할 수 있기 때문에 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="b00d42e90d9ff28c2ca17f2066eab4ca296f8fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are &lt;em&gt;easy to use&lt;/em&gt; with closures (they do not cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;race conditions&lt;/a&gt;).</source>
          <target state="translated">변수를 클로저와 함께 &lt;em&gt;사용하기 쉽게하십시오&lt;/em&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;경쟁 조건을&lt;/a&gt; 유발하지 않음).</target>
        </trans-unit>
        <trans-unit id="0af3806742f2c2f6ebb22613b4d0219aa7071dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a &lt;code&gt;ReferenceError&lt;/code&gt;. Variable said to be in &quot;temporal dead zone&quot; from the start of the block until the initialization is processed.</source>
          <target state="translated">정의가 평가 될 때까지 변수를 초기화하지 마십시오. 초기화하기 전에 액세스하면 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생 합니다. 변수는 블록의 시작부터 초기화가 처리 될 때까지 &quot;임시 데드 존&quot;에 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="65ff7d9e010e2ad54c26d0e0600b56ceeb93776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only usable in lines of code that occur &lt;em&gt;after&lt;/em&gt; the variable is declared (even though &lt;a href=&quot;/questions/33198849&quot;&gt;they are hoisted&lt;/a&gt;!).</source>
          <target state="translated">변수가 선언 된 &lt;em&gt;후에&lt;/em&gt; 발생하는 코드 행에서만 변수를 사용할 수 &lt;code&gt;let&lt;/code&gt; 하십시오 ( &lt;a href=&quot;/questions/33198849&quot;&gt;호이스트 된&lt;/a&gt; 경우에도).</target>
        </trans-unit>
        <trans-unit id="3ec2a907ce0b2eb98081f72a00f994a218703a4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only visible in their &lt;em&gt;nearest enclosing&lt;/em&gt; block (&lt;code&gt;{ ... }&lt;/code&gt;).</source>
          <target state="translated">변수는 &lt;em&gt;가장 가까운 둘러싸는&lt;/em&gt; 블록 ( &lt;code&gt;{ ... }&lt;/code&gt; )에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93fc717aea1571de33197157899b7efda524d39d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables cannot be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">변수는 전역 적으로 액세스 할 수 없으므로 &lt;code&gt;window&lt;/code&gt; 객체에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c36689eca346124e71af49608677b1a82b86f74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables don't get hoisted:</source>
          <target state="translated">변수가 게양되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="ca400981a08e8a909a0c3b4d1745acd5f90a1658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables may not be redeclared by a subsequent &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 변수는 후속 &lt;code&gt;var&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 에 의해 다시 선언되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5bdfd10726565f7599def5824126d5b88cbe29b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; works very much like &lt;code&gt;var&lt;/code&gt;. The main difference is that the scope of a &lt;code&gt;var&lt;/code&gt; variable is the entire enclosing function</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 와 매우 유사 &lt;code&gt;let&lt;/code&gt; 작동합니다. 가장 큰 차이점은 &lt;code&gt;var&lt;/code&gt; 변수의 범위가 전체 둘러싸는 함수라는 것입니다</target>
        </trans-unit>
        <trans-unit id="4a7e5a7da596e5ed599f94db730395d7fcdafdec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, is a signal that the variable may be reassigned, such as a
  counter in a loop, or a value swap in an algorithm. It also signals
  that the variable will be used only in the block it&amp;rsquo;s defined in,
  which is not always the entire containing function.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 은 루프의 카운터 또는 알고리즘의 값 스왑과 같이 변수가 재 할당 될 수 있다는 신호입니다. 또한 변수가 정의 된 블록에서만 사용된다는 신호를 보냅니다. 항상 전체 포함 함수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d7ac1ca1e5aa7a427f93aec2df1994a143404d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.</source>
          <target state="translated">ES5의 &lt;code&gt;var&lt;/code&gt; 및 변수에는 함수 범위가 있으므로 변수는 함수 자체가 아닌 함수 내에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="948a7ff5506461094cf4291aab6e19dc898ba6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is global scope (hoist-able) variable.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 는 전역 범위 (호이스트 가능) 변수입니다.</target>
        </trans-unit>
        <trans-unit id="5cfeb8565d205ecaa6279727ad54117c2209b10f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is now the weakest signal available when you define a variable
  in JavaScript. The variable may or may not be reassigned, and the
  variable may or may not be used for an entire function, or just for
  the purpose of a block or loop.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 는 이제 JavaScript에서 변수를 정의 할 때 사용 가능한 가장 약한 신호입니다. 변수는 재 할당되거나 재 할당되지 않을 수 있으며, 변수는 전체 기능 또는 블록 또는 루프의 목적으로 사용될 수도 있고 사용되지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbca8b19e8de6aba37b90ff0fc91b6e4429a273d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of &lt;code&gt;var&lt;/code&gt; for exports may be supplanted if &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; migrates out of transpiler space and into the core language.</source>
          <target state="translated">루프 (# 5)에서 클로저를 사용할 때 또는 코드에서 외부에서 볼 수있는 전역 변수를 선언 할 때 단일 바인딩 효과를 원한다면 &lt;code&gt;var&lt;/code&gt; 가 여전히 유용 할 수 있습니다 (# 4). &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; 가 트랜스 파일러 공간에서 핵심 언어로 마이그레이션되는 경우 내보내기 에 &lt;code&gt;var&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e636d2a81e1a762020c4f5c3744c8e65bfdd0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; variables can be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 변수는 전역 적으로 액세스 할 수 없으므로 &lt;code&gt;window&lt;/code&gt; 객체에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b28054bd2387937ff823de5e92e8d087509275" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;let&lt;/code&gt; will &lt;strong&gt;not hoist&lt;/strong&gt; to the entire scope of the block they appear in. By contrast, &lt;code&gt;var&lt;/code&gt; could hoist as below.&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; 블록이 표시되는 전체 범위를 &lt;strong&gt;끌어 올리지 마십시오&lt;/strong&gt; . 반대로 &lt;code&gt;var&lt;/code&gt; 는 다음과 같이 들어 올릴 수 있습니다. &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="8e5e8a4029ba67276f8775f560d25040ee366e1d" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;strong&gt;Variable Not Hoisting&lt;/strong&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;strong&gt;게양하지 않는 변수&lt;/strong&gt; &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;(*) 전역 및 기능 범위 변수는 JavaScript 변수가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;들어&lt;/strong&gt;&lt;/a&gt; 있기 때문에 선언되기 전에 초기화 및 사용할 수 있습니다.&lt;/em&gt; 이것은 선언이 항상 범위의 맨 위에 있다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b8a45f3633696567dffb096c46db365f09dc340f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(**) Block scoped variables are not hoisted&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(**) 블록 범위 변수는 게양되지 않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a92f025526fcf6fd0e31e3883a2c0ce413ea45b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. No use outside nearest enclosing block:&lt;/strong&gt;
This block of code will throw a reference error because the second use of &lt;code&gt;x&lt;/code&gt; occurs outside of the block where it is declared with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;1. 가장 가까운 엔 클로징 블록 외부에서 사용하지 않음 :&lt;/strong&gt; 이 코드 블록은 &lt;code&gt;x&lt;/code&gt; 로 두 번째 사용이 &lt;code&gt;let&lt;/code&gt; 으로 선언 된 블록 외부에서 발생하기 때문에 참조 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a1a3f78207be8aa46a711328247e402fe16ff7e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. No use before declaration:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 신고 전 사용 금지 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ebde23d0d3b7756808c6cc91ba63eefcda7c222" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. No redeclaration:&lt;/strong&gt;
The following code demonstrates that a variable declared with &lt;code&gt;let&lt;/code&gt; may not be redeclared later:</source>
          <target state="translated">&lt;strong&gt;3. 재 선언 없음 :&lt;/strong&gt; 다음 코드는 &lt;code&gt;let&lt;/code&gt; 으로 선언 된 변수가 나중에 재 선언되지 않을 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3452dda34e6fe8760767335a5682fa96d4f633dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Globals not attached to &lt;code&gt;window&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4. &lt;code&gt;window&lt;/code&gt; 첨부되지 않은 전역 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="117009c83c2e98d0a5ff10f1606e8d479850f1f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. Easy use with closures:&lt;/strong&gt;
Variables declared with &lt;code&gt;var&lt;/code&gt; do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable &lt;code&gt;i&lt;/code&gt; has at different points in time:</source>
          <target state="translated">&lt;strong&gt;5. 클로저로 쉽게 사용 :&lt;/strong&gt; &lt;code&gt;var&lt;/code&gt; 로 선언 된 변수는 루프 내 클로저에서 잘 작동하지 않습니다. 다음은 변수 &lt;code&gt;i&lt;/code&gt; 가 다른 시점에있는 일련의 값을 출력하는 간단한 루프입니다.</target>
        </trans-unit>
        <trans-unit id="335cb1cc283f4951de3aa9563124b1b1306cd973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;let&lt;/code&gt; loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;루프 &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0320f62c5e659472d8791116df2b4f5d9063ed90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db7c704eb200ce249efd68f6671cae57bf115cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example2:&lt;/strong&gt;
In my second example  instead of using &lt;code&gt;var&lt;/code&gt; keyword in my conditional block I declare &lt;code&gt;myvar&lt;/code&gt; using &lt;code&gt;let&lt;/code&gt; keyword . Now when I call &lt;code&gt;myfunc&lt;/code&gt;  I get two different outputs: &lt;code&gt;myvar=20&lt;/code&gt; and &lt;code&gt;myvar=10&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 2 :&lt;/strong&gt; 조건부 블록에서 &lt;code&gt;var&lt;/code&gt; 키워드를 사용하는 대신 두 번째 예에서는 &lt;code&gt;let&lt;/code&gt; keyword를 사용하여 &lt;code&gt;myvar&lt;/code&gt; 을 선언합니다. 이제 &lt;code&gt;myfunc&lt;/code&gt; 을 호출하면 &lt;code&gt;myvar=20&lt;/code&gt; 과 &lt;code&gt;myvar=10&lt;/code&gt; 의 두 가지 출력이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="58d9ac26bea11358be0d1cbdd9e321d3ba6df33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Garbage Collection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가비지 콜렉션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a1048de1a3b6080b858a1b2bef0918699edce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you want to know more continue reading below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 알고 싶다면 아래에서 계속 읽으십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9c088750dbff02fab5817dc280550e5285cea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is a teaching example intended to demonstrate the &lt;code&gt;var&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 루프에서 &lt;code&gt;var&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; 동작을 보여주고 이해하기 쉬운 함수 클로저를 사용하기위한 교시 예제입니다. 이것은 숫자를 추가하는 끔찍한 방법입니다. 그러나 익명 함수 클로저에서 데이터를 캡처하는 일반적인 기술은 실제 상황에서는 다른 상황에서 발생할 수 있습니다. YMMV.</target>
        </trans-unit>
        <trans-unit id="9e6852a37a94e37e3dd905af9505c512854ba77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; 을 사용할 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fafd358dad99127a17812d83d6ef193969ca8ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; 를 사용할 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd31b31858145616de45d3f80da7fc9d141990c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;언제 &lt;code&gt;var&lt;/code&gt; 이상 사용해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48515bd6359d686dcff1143b76e99f026ba355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; 을 사용할 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bff2ad0c04ac8dd4df0359c5f2b7c4f5886e344c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; 를 사용할 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="227b64041df706bf182aba5ae5ebd33a97ed7e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;let&lt;/strong&gt; allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the &lt;strong&gt;var&lt;/strong&gt; keyword, which defines a variable globally, or locally to an entire function regardless of block scope.</source>
          <target state="translated">범위가 제한된 변수를 변수가 사용 된 블록, 명령문 또는 표현식으로 선언 할 수 있습니다. 이것은 블록 범위와 상관없이 변수를 전체적으로 또는 전체적으로 로컬로 정의하는 &lt;strong&gt;var&lt;/strong&gt; 키워드와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fab33e848b5ad8bcc20091c62c722cbb817e51ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var variables are global&lt;/strong&gt; and can be accessed basically everywhere, while &lt;strong&gt;let variables are not global&lt;/strong&gt; and only exist until a closing parenthesis kills them.</source>
          <target state="translated">&lt;strong&gt;var 변수는 전역 변수이며&lt;/strong&gt; 기본적으로 모든 곳에서 액세스 할 수 있지만 &lt;strong&gt;변수는 전역&lt;/strong&gt; &lt;strong&gt;변수가 아니며&lt;/strong&gt; 닫는 괄호로 묶을 때까지만 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="db1da9a09bc08d7f8e50d60ea6a55e8863b78c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;let&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; 변수 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29624d341db7c739c0aa200fbd55251cca369e02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;var&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; 변수 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2946b23215e7bb86a85f078731e677392102c35a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Tested in Chrome and Firefox 50)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Chrome 및 Firefox 50에서 테스트)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="aac30eb1359108b02f390fbbab8124c9183cc1f9" translate="yes" xml:space="preserve">
          <source>A general workaround is to wrap this in an anonymous function and pass &lt;code&gt;i&lt;/code&gt; as an argument. Such issues can also be avoided now by using &lt;code&gt;let&lt;/code&gt; instead &lt;code&gt;var&lt;/code&gt; as shown in the code below.</source>
          <target state="translated">일반적인 해결 방법은 이것을 익명 함수로 감싸고 &lt;code&gt;i&lt;/code&gt; 를 인수로 전달하는 것입니다. 아래 코드와 같이 &lt;code&gt;let&lt;/code&gt; 대신 &lt;code&gt;var&lt;/code&gt; 을 사용하면 이러한 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="170078ca21bcbd02b1a827e5fbf53f3ea80c3232" translate="yes" xml:space="preserve">
          <source>A variable declared with &lt;code&gt;let&lt;/code&gt; in the global scope (which is code that is not in a function) doesn't get added as a property on the global &lt;code&gt;window&lt;/code&gt; object. For example (this code is in global scope):</source>
          <target state="translated">전역 범위에서 &lt;code&gt;let&lt;/code&gt; 으로 선언 된 변수 (함수에없는 코드)는 전역 &lt;code&gt;window&lt;/code&gt; 객체의 속성으로 추가되지 않습니다. 예를 들어 (이 코드는 전역 범위에 있습니다) :</target>
        </trans-unit>
        <trans-unit id="5f3e410272543a521cf9f1d7d1742e67dea8dc1b" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;let&lt;/code&gt; statement is only known in &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;the block&lt;/strong&gt;&lt;/a&gt; it is defined in, from the moment it is defined onward. &lt;em&gt;(**)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문을 사용하여 정의 된 변수는 정의 된 순간부터 정의 된 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;블록&lt;/strong&gt;&lt;/a&gt; 에서만 알 수 있습니다. &lt;em&gt;(**)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09c9ab8e2032dd446f087702839d7b2ed4396ea6" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;var&lt;/code&gt; statement is known throughout &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; it is defined in, from the start of the function. &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 문을 사용하여 정의 된 변수 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;는 함수&lt;/strong&gt;&lt;/a&gt; 시작부터 정의 된 &lt;strong&gt;함수&lt;/strong&gt; 전체 &lt;strong&gt;에&lt;/strong&gt; 알려져 있습니다. &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab370464f56e00eeb5cfc62076a9464592135e2" translate="yes" xml:space="preserve">
          <source>Actually, Per @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;Both &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; are hoisted&lt;/a&gt;.</source>
          <target state="translated">실제로, @@ Bergi 당 &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt; &lt;code&gt;var&lt;/code&gt; 와 &lt;code&gt;let&lt;/code&gt; 은 모두 게양&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c89fecc35a8d73707d226f6f0b6a82d6dab14eb" translate="yes" xml:space="preserve">
          <source>Also don't forget it's ECMA6 feature, so it's not fully supported yet, so it's better always transpiles it to ECMA5 using Babel etc... for more info about visit &lt;a href=&quot;https://babeljs.io&quot;&gt;babel website&lt;/a&gt;</source>
          <target state="translated">또한 ECMA6 기능을 잊지 마십시오. 아직 완벽하게 지원되지는 않으므로 &lt;a href=&quot;https://babeljs.io&quot;&gt;babel 웹 사이트&lt;/a&gt; 방문에 대한 자세한 내용은 Babel 등을 사용하여 ECMA5로 항상 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">또한 블록 범위 변수는 게양되지 않았기 때문에 선언되기 전에 알 수 없습니다. 또한 동일한 블록 내에서 동일한 블록 범위 변수를 다시 선언 할 수 없습니다. 이렇게하면 블록 범위 변수가 전역 또는 기능 범위 변수보다 오류가 덜 발생합니다.이 변수는 게양되어 여러 선언의 경우 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c17b26bc3e4c8d3adc5ae1acfc117828aa6be96" translate="yes" xml:space="preserve">
          <source>And, finally, when it comes to the Execution Context, variables defined with var will be attached to the 'this' object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.</source>
          <target state="translated">마지막으로 실행 컨텍스트와 관련하여 var로 정의 된 변수는 'this'객체에 첨부됩니다. 전역 실행 컨텍스트에서는 브라우저의 창 개체가됩니다. let 또는 const의 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71e68652a5ed74f047c3ac12095f037358e5e5ec" translate="yes" xml:space="preserve">
          <source>Another difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is variables with declared with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't get hoisted&lt;/strong&gt;. An example is the best way to illustrate this behavior:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 와 &lt;code&gt;let&lt;/code&gt; 의 또 다른 차이점은 let 으로 선언 된 변수가 &lt;strong&gt;게양되지 않습니다&lt;/strong&gt; . 이 동작을 설명하는 가장 좋은 방법은 예입니다.</target>
        </trans-unit>
        <trans-unit id="35c52610045a80e7c59b43f1379714d89e0d6bc4" translate="yes" xml:space="preserve">
          <source>As mentioned above:</source>
          <target state="translated">앞에서 말했다시피:</target>
        </trans-unit>
        <trans-unit id="249700b45578552db048d92af8fa978c2eefd5b3" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;code&gt;var j&lt;/code&gt; variable is still having a value outside of the for loop scope (Block Scope), but the &lt;code&gt;let i&lt;/code&gt; variable is undefined outside of the for loop scope.</source>
          <target state="translated">보시다시피 &lt;code&gt;var j&lt;/code&gt; 변수는 여전히 for 루프 범위 (블록 범위) 외부에 값이 있지만, &lt;code&gt;let i&lt;/code&gt; 변수는 for 루프 범위 외부에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7def6645f985de2714bbee9073b7e35ce60ba9a" translate="yes" xml:space="preserve">
          <source>At the top level (outside of a function)</source>
          <target state="translated">최상위 수준 (함수 외부)</target>
        </trans-unit>
        <trans-unit id="d2da2ac1a0c2449a02f42f9a07db9b2ad3e838df" translate="yes" xml:space="preserve">
          <source>At the top level of programs and functions, &lt;strong&gt;let&lt;/strong&gt;, unlike &lt;strong&gt;var&lt;/strong&gt;, does not create a property on the global object. For example:</source>
          <target state="translated">&lt;strong&gt;var&lt;/strong&gt; 과 달리 프로그램과 함수의 최상위 수준에서는 전역 객체에 속성을 만들지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71df1ae66b61d0ab2fcbac24f66a246ff268b703" translate="yes" xml:space="preserve">
          <source>At the top level, &lt;code&gt;let&lt;/code&gt;, unlike &lt;code&gt;var&lt;/code&gt;, does not create a property on the global object:</source>
          <target state="translated">최상위 레벨에서 &lt;code&gt;let&lt;/code&gt; 은 &lt;code&gt;var&lt;/code&gt; 와 달리 전역 객체에 대한 속성을 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eeb6d3d38965924988affed9792df84c51af2547" translate="yes" xml:space="preserve">
          <source>At the top level, variables declared using &lt;code&gt;let&lt;/code&gt; don't create properties on the global object.</source>
          <target state="translated">최상위 수준을 사용하여 선언 된 변수는 전역 객체에 대한 속성을 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="515fa9e7c373ec2c33005604de0e7089c2d08190" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;let&lt;/code&gt; create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">a) 이니셜 라이저 표현식 b) 각 반복 (이전에는 증분 표현식을 평가하기위한)에 대한 이름으로 새 어휘 환경을 작성 &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;하십시오&lt;/a&gt; . 자세한 내용은 여기에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45b1a72deb4126ce6786cb6bf76705a80fcbb65a" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;the temporal dead zone&lt;/a&gt;, variables declared using &lt;code&gt;let&lt;/code&gt; can't be accessed before they are declared. Attempting to do so throws an error.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;일시적인 데드 존&lt;/a&gt; 때문에 &lt;code&gt;let&lt;/code&gt; 을 사용하여 선언 된 변수는 선언하기 전에 액세스 할 수 없습니다. 그렇게하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">블록 범위</target>
        </trans-unit>
        <trans-unit id="e40b499735af8fc0820476d34a1c0c219c1fd209" translate="yes" xml:space="preserve">
          <source>Block scope of &lt;code&gt;let&lt;/code&gt; is useful relates to closures and garbage collection to reclaim memory. Consider,</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 의 블록 범위는 메모리를 회수하기위한 클로저 및 가비지 수집과 관련이 있습니다. 치다,</target>
        </trans-unit>
        <trans-unit id="6f29a62d2c8cafbe524c685a3421672ea1015266" translate="yes" xml:space="preserve">
          <source>Code above demonstrates a classic JavaScript closure problem. Reference to the &lt;code&gt;i&lt;/code&gt; variable is being stored in the click handler closure, rather than the actual value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">위 코드는 전형적인 JavaScript 클로저 문제를 보여줍니다. &lt;code&gt;i&lt;/code&gt; 변수에 대한 참조는 실제 &lt;code&gt;i&lt;/code&gt; 값이 아닌 클릭 핸들러 클로저에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9e5c12eac220cda3fddead583cc6b0243277fa9e" translate="yes" xml:space="preserve">
          <source>Consequently, &lt;code&gt;let&lt;/code&gt; variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.</source>
          <target state="translated">따라서 큰 프로그램에서 사용하거나 독립적으로 개발 된 프레임 워크를 새롭고 예기치 않은 방식으로 결합 할 때 변수가 문제를 일으킬 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f7261ea8dc8387f9126baa8bab22723bda98c65e" translate="yes" xml:space="preserve">
          <source>Creating global object property</source>
          <target state="translated">전역 객체 속성 생성</target>
        </trans-unit>
        <trans-unit id="a994290f95e1773d69448109bc715c0ac56c270d" translate="yes" xml:space="preserve">
          <source>Don't let this happen to you. Use a linter.</source>
          <target state="translated">이런 일이 일어나지 않도록하십시오. 린터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bff237a3f67a2949d7f6e1f89d92205c1c43fd88" translate="yes" xml:space="preserve">
          <source>During the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised.</source>
          <target state="translated">실행 컨텍스트의 생성 단계 동안 var, let 및 const는 주어진 실행 컨텍스트의 변수 환경에서 정의되지 않은 값으로 변수를 메모리에 저장합니다. 차이점은 실행 단계에 있습니다. var에 정의 된 변수에 값을 할당하기 전에 reference를 사용하면 정의되지 않습니다. 예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b7177a34d2d0cacb674f1aac574068a765ae834" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;the &lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;은 &lt;code&gt;let&lt;/code&gt; 문을&lt;/a&gt; 도입 했습니다 .</target>
        </trans-unit>
        <trans-unit id="5cf86ea0199cf2cb7ab1e4b859d6da9f7e8d3b80" translate="yes" xml:space="preserve">
          <source>ES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.</source>
          <target state="translated">또한 ES6에는 변수 선언을위한 const 키워드가 도입되었습니다. const도 블록 범위입니다. let과 const의 차이점은 const 변수를 이니셜 라이저를 사용하여 선언해야한다는 점입니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15fdc50ddc49f97069f55a0d0f0fb021296b8c98" translate="yes" xml:space="preserve">
          <source>ES6 introduced two new keyword(&lt;strong&gt;let&lt;/strong&gt; and &lt;strong&gt;const&lt;/strong&gt;) alternate to &lt;strong&gt;var&lt;/strong&gt;.</source>
          <target state="translated">ES6는 &lt;strong&gt;var&lt;/strong&gt; 대신 새로운 두 키워드 ( &lt;strong&gt;let&lt;/strong&gt; 과 &lt;strong&gt;const&lt;/strong&gt; )를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="fe55c1d6e2b8dc0fe7f0925eac13a3c7b9627f4c" translate="yes" xml:space="preserve">
          <source>Every single click handler will refer to the same object because there&amp;rsquo;s only one counter object which holds 6 so you get six on each click.</source>
          <target state="translated">모든 단일 클릭 핸들러는 6을 보유하는 카운터 오브젝트가 하나만 있으므로 각 클릭마다 6 개를 가져 오기 때문에 동일한 오브젝트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">이 답변을 읽을 당시의 &lt;code&gt;let&lt;/code&gt; 문을 지원하는 브라우저에 대한 최신 개요는 &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;이 &lt;code&gt;Can I Use&lt;/code&gt; 페이지를 참조하십시오&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2bcc0766379cd75d853f8179072c502df585067" translate="yes" xml:space="preserve">
          <source>Function VS block scope:</source>
          <target state="translated">기능 VS 블록 범위 :</target>
        </trans-unit>
        <trans-unit id="44d7d3e4ae1a64d1cd2bf70aad9d679aa794df08" translate="yes" xml:space="preserve">
          <source>Getter and setter with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; : getter 및 setter :</target>
        </trans-unit>
        <trans-unit id="8ba873db511f120d8b04390f9365a000776baab4" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; doesn't get attached to &lt;code&gt;window&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;let&lt;/code&gt; 이 &lt;code&gt;window&lt;/code&gt; 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f8c6d41af972292b69739e49d1923eaf7ba5d69" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; variables are not added to the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">전역 &lt;code&gt;let&lt;/code&gt; 변수는 전역 &lt;code&gt;window&lt;/code&gt; 객체에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50ef81d10d2ac6892f207cc0aa959a31a393eb97" translate="yes" xml:space="preserve">
          <source>Here is an example for the difference between the two (support just started for chrome):</source>
          <target state="translated">다음은이 둘의 차이점에 대한 예입니다 (Chrome에 대한 지원 시작).</target>
        </trans-unit>
        <trans-unit id="e80f82c5146fe3bdfce30d25078c548bf9fd7946" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;explanation of the &lt;code&gt;let&lt;/code&gt; keyword&lt;/a&gt; with some examples.</source>
          <target state="translated">다음 &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;은 &lt;code&gt;let&lt;/code&gt; 키워드&lt;/a&gt; 에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="baf1aac8fe97893d9e8a5cc925df180108e841e0" translate="yes" xml:space="preserve">
          <source>Here's an example to add on to what others have already written. Suppose you want to make an array of functions, &lt;code&gt;adderFunctions&lt;/code&gt;, where each function takes a single Number argument and returns the sum of the argument and the function's index in the array. Trying to generate &lt;code&gt;adderFunctions&lt;/code&gt; with a loop using the &lt;code&gt;var&lt;/code&gt; keyword won't work the way someone might na&amp;iuml;vely expect:</source>
          <target state="translated">다음은 다른 사람들이 이미 작성한 내용을 추가하는 예입니다. &lt;code&gt;adderFunctions&lt;/code&gt; 함수의 배열을 만들고 싶다고 가정합니다. 여기서 각 함수는 단일 숫자 인수를 사용하고 인수와 함수의 색인의 합계를 배열로 리턴합니다. &lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 루프로 &lt;code&gt;adderFunctions&lt;/code&gt; 을 생성하려고하면 누군가가 순진하게 기대하는 방식으로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">여기서 변수 &lt;code&gt;j&lt;/code&gt; 는 첫 번째 for 루프에서만 알려져 있지만 이전과 이후는 알 수 없습니다. 그러나 변수 &lt;code&gt;i&lt;/code&gt; 는 전체 기능으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bcaf634e9dbfa99922f815d7eb0b950882fbc2c" translate="yes" xml:space="preserve">
          <source>Hoisting</source>
          <target state="translated">Hoisting</target>
        </trans-unit>
        <trans-unit id="a4b770c91602cb7a14569eb1fadf17b154c46e1d" translate="yes" xml:space="preserve">
          <source>Hoisting is not supported using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 을 사용하여 게양이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">브라우저 지원을 추적하는 방법</target>
        </trans-unit>
        <trans-unit id="02950dbbb2895580e2f47482bfdc271d60612939" translate="yes" xml:space="preserve">
          <source>However it's worth noting that &lt;code&gt;let&lt;/code&gt; is only a part of newer Javascript implementations and has varying degrees of &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;browser support&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;let&lt;/code&gt; 은 최신 Javascript 구현의 일부일 뿐이며 다양한 &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;브라우저 지원&lt;/a&gt; 수준을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a64dc9831d45af781fdad2758e3129f38608db33" translate="yes" xml:space="preserve">
          <source>However, replace &lt;code&gt;var&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">그러나 &lt;code&gt;var&lt;/code&gt; 를 &lt;code&gt;let&lt;/code&gt; 으로 바꾸 십시오.</target>
        </trans-unit>
        <trans-unit id="1942516de816b1215bfb3f885b92dce215fe8c87" translate="yes" xml:space="preserve">
          <source>However, the block scope can make this huge data structure to garbage collected.</source>
          <target state="translated">그러나 블록 범위는이 거대한 데이터 구조를 가비지 수집으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="210d598d2aa5b2252eb617a5677124f67bcfd03e" translate="yes" xml:space="preserve">
          <source>However, we can try again using the &lt;code&gt;let&lt;/code&gt; keyword:</source>
          <target state="translated">그러나 &lt;code&gt;let&lt;/code&gt; 키워드를 사용하여 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a13c0910c0809caa265aa5d59b7303182a3e913" translate="yes" xml:space="preserve">
          <source>However, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:</source>
          <target state="translated">그러나 let 또는 const로 선언 된 변수는 선언 될 때까지 참조 할 수 없습니다. 선언하기 전에 사용하려고하면 실행 컨텍스트의 실행 단계에서 예외가 발생합니다. 이제 변수는 실행 컨텍스트의 생성 단계에 의해 여전히 메모리에 남아 있지만 엔진에서 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="73b04d7e63d97817ad43a04a297f8ccd6b791760" translate="yes" xml:space="preserve">
          <source>I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.</source>
          <target state="translated">사람들은 다른 언어, Java, C # 등과 같은 JavaScript에서 비슷한 범위를 갖도록 let을 사용하기 시작할 것이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="60ed5394ff0a30a2c778db05382fc4f19f7dea8c" translate="yes" xml:space="preserve">
          <source>I think the terms and most of the examples are a bit overwhelming,
The main issue i had personally with the difference is understanding what a &quot;Block&quot; is.
At some point i realized, a block would be any curly brackets except for &lt;code&gt;IF&lt;/code&gt; statement.
an opening bracket &lt;code&gt;{&lt;/code&gt; of a function or loop will define a new block, anything defined with &lt;code&gt;let&lt;/code&gt; within it, will not be available after the closing bracket &lt;code&gt;}&lt;/code&gt; of the same thing (function or loop);
With that in mind, it was easier to understand:</source>
          <target state="translated">나는 용어와 대부분의 예제가 약간 압도적이라고 생각한다. 내가 개인적으로 차이점을 가지고 있었던 주요 문제는 &quot;블록&quot;이 무엇인지 이해하는 것이다. 어느 시점에서, 블록은 &lt;code&gt;IF&lt;/code&gt; 문을 제외하고 중괄호가 될 것입니다. 함수 나 루프의 여는 괄호 &lt;code&gt;{&lt;/code&gt; 는 새로운 블록을 정의 할 것이며, 그 안에 &lt;code&gt;let&lt;/code&gt; 으로 정의 된 것은 똑같은 것 (함수 또는 루프)의 닫는 괄호 뒤에 사용할 수 없습니다; 이를 염두에두고 이해하기가 더 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="652bcdb1cb95ff704c8f7f92231e2c819a6a619e" translate="yes" xml:space="preserve">
          <source>I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment).</source>
          <target state="translated">실행 컨텍스트가이 모든 것에서 중요하기 때문에 이러한 키워드를 실행 컨텍스트에 연결하려고합니다. 실행 컨텍스트에는 작성 단계와 실행 단계의 두 단계가 있습니다. 또한 각 실행 컨텍스트에는 가변 환경 및 외부 환경 (Lexical Environment)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="347c3b7704d41b142c7558f9df8c366aaa5c3ca9" translate="yes" xml:space="preserve">
          <source>I've heard it that it's described as a &quot;local&quot; variable, but I'm still not quite sure how it behaves differently than the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">나는 그것이 &quot;local&quot;변수라고 묘사되어 있다고 들었지만, 여전히 그것이 &lt;code&gt;var&lt;/code&gt; 키워드와 어떻게 다르게 행동하는지는 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64f2d3dd931f8ac221f076d6aee461fa2e268f7" translate="yes" xml:space="preserve">
          <source>If I read the specs right then &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;thankfully&lt;/strong&gt; can also be leveraged to avoid &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;self invoking functions&lt;/a&gt; used to simulate private only members - &lt;em&gt;a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone's desire for semantics, so stop using it. /rant&lt;/em&gt;</source>
          <target state="translated">사양을 올바르게 읽으면 개인적으로 만 멤버를 시뮬레이션하는 데 사용되는 &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;자체 호출 기능&lt;/a&gt; 을 피하기 위해 &lt;strong&gt;감사하게도&lt;/strong&gt; 활용할 수 있습니다- &lt;em&gt;코드 가독성을 낮추고 디버깅을 복잡하게 만드는 인기있는 디자인 패턴-만족스러운 경우를 제외하고는 실제 코드 보호 또는 기타 이점을 추가하지 않습니다. 의미론에 대한 누군가의 욕망은 사용을 중단하십시오.&lt;/em&gt; &lt;em&gt;/ rant&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efbed4ca5ff07a30fe5d1a50e4502bdb347bc1c0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.</source>
          <target state="translated">루프에서 &lt;code&gt;var&lt;/code&gt; 대신 &lt;code&gt;let&lt;/code&gt; 대신 let 을 사용하면 각 반복마다 새로운 변수가 생깁니다. 즉, 루프 내부에서 클로저를 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17145a9a9f46d1b105d7a4debb8d941ee248c402" translate="yes" xml:space="preserve">
          <source>If you want to have an immutable object, you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;&lt;code&gt;Object.freeze()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">불변의 객체를 가지려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt; &lt;code&gt;Object.freeze()&lt;/code&gt; &lt;/a&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">클라이언트 측 JavaScript 코드를 작성 중이고 트랜스 파일러를 사용하지 않는 경우 브라우저 지원을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">클라이언트 측 JavaScript 코드를 작성하고 &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur 쉘 스크립트&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; 과 같은 노드 기반 변환기를 사용하는 경우 &lt;code&gt;let&lt;/code&gt; 문을 안전하게 사용할 수 있습니다. 브라우저는 변환 된 코드에 대해서만 알기 때문에 성능 단점이 제한되어야합니다.</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">클라이언트 측 JavaScript 코드를 작성하고 &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; 과 같은 브라우저 기반 변환기를 사용하는 경우 &lt;code&gt;let&lt;/code&gt; 문을 안전하게 사용할 수 있지만 코드는 성능 측면에서 최적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">서버 측 JavaScript 코드 ( &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; )를 작성하는 경우 &lt;code&gt;let&lt;/code&gt; 문을 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc03d4531fe0bd76ba607e1e4e7d663c32df226" translate="yes" xml:space="preserve">
          <source>In JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">JavaScript에서는 종종 변수가 생성 될 때보 다 훨씬 나중에 변수를 사용합니다. &lt;code&gt;setTimeout&lt;/code&gt; 에 전달 된 클로저를 사용하여 출력을 지연시켜이를 보여줄 때 :</target>
        </trans-unit>
        <trans-unit id="7c9021c4e7876355e1fc36b9e227cb4de4425b66" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; parses and runs without throwing any exceptions.</source>
          <target state="translated">반대로 &lt;code&gt;var&lt;/code&gt; 와 동일한 예제는 예외를 throw하지 않고 구문 분석하고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="177519e8851b8c0bb348adf315a0cf3831599c1d" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; works.</source>
          <target state="translated">반대로 &lt;code&gt;var&lt;/code&gt; 와 동일한 예제가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dc8dcbdd636f8cb50991ca75851fcac1be59e3c5" translate="yes" xml:space="preserve">
          <source>In my both examples I have a function &lt;code&gt;myfunc&lt;/code&gt;. &lt;code&gt;myfunc&lt;/code&gt; contains a variable &lt;code&gt;myvar&lt;/code&gt; equals to 10. 
In my first example  I check   if &lt;code&gt;myvar&lt;/code&gt; equals to 10 (&lt;code&gt;myvar==10&lt;/code&gt;) . If yes, I agian declare  a variable  &lt;code&gt;myvar&lt;/code&gt; (now I have two myvar variables)using &lt;code&gt;var&lt;/code&gt; keyword and assign it a new value (20). In next line I  print its value on my console.  After the conditional block I again print the value of &lt;code&gt;myvar&lt;/code&gt; on my console. If you look at the output of &lt;code&gt;myfunc&lt;/code&gt;,   &lt;code&gt;myvar&lt;/code&gt; has value equals to 20.</source>
          <target state="translated">두 예제 모두에서 &lt;code&gt;myfunc&lt;/code&gt; 함수가 있습니다. &lt;code&gt;myfunc&lt;/code&gt; 는 &lt;code&gt;myvar&lt;/code&gt; 가 10 인 변수를 포함합니다. 첫 번째 예에서 &lt;code&gt;myvar&lt;/code&gt; 가 10 ( &lt;code&gt;myvar==10&lt;/code&gt; )인지 확인합니다. 그렇다면 agian은 &lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 변수 &lt;code&gt;myvar&lt;/code&gt; (이제 두 개의 myvar 변수가 있음)를 선언하고 새로운 값을 할당합니다 (20). 다음 줄에서는 콘솔에 값을 인쇄합니다. 조건부 블록 후에 다시 콘솔에 &lt;code&gt;myvar&lt;/code&gt; 값을 인쇄합니다. &lt;code&gt;myfunc&lt;/code&gt; 의 출력을 보면 &lt;code&gt;myvar&lt;/code&gt; 의 값은 20입니다.</target>
        </trans-unit>
        <trans-unit id="d3eb240300b8d3cf3894acb662d9d55b4c3eeb9c" translate="yes" xml:space="preserve">
          <source>In practice, there are a number of useful consequences of the difference in scope:</source>
          <target state="translated">실제로 범위 차이로 인해 여러 가지 유용한 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="041cfe51d16fc06e7a90d0fdd25ff09d8de80054" translate="yes" xml:space="preserve">
          <source>In strict mode, &lt;code&gt;var&lt;/code&gt; will let you re-declare the same variable in the same scope while &lt;code&gt;let&lt;/code&gt; raises a SyntaxError.</source>
          <target state="translated">엄격 모드에서 &lt;code&gt;var&lt;/code&gt; 를 사용하면 동일한 범위에서 동일한 변수를 다시 선언 할 &lt;code&gt;let&lt;/code&gt; 있고 SyntaxError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="deb3d336c8ca38ed2c8a72be4787d1e826efc9a7" translate="yes" xml:space="preserve">
          <source>Initializer is required</source>
          <target state="translated">이니셜 라이저가 필요합니다</target>
        </trans-unit>
        <trans-unit id="6d007cc06c89e6bed5f7c97dc75f829442633823" translate="yes" xml:space="preserve">
          <source>Inside a block</source>
          <target state="translated">블록 내부</target>
        </trans-unit>
        <trans-unit id="d187aaa9dbe696be70ed4733de46de8f53018d1e" translate="yes" xml:space="preserve">
          <source>Inside a function</source>
          <target state="translated">함수 내부</target>
        </trans-unit>
        <trans-unit id="6a19a43ce4368f97cd87fe72619ae5cd48410ed3" translate="yes" xml:space="preserve">
          <source>Inside a function (but outside of a block), &lt;code&gt;let&lt;/code&gt; has the same scope as &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">함수 내부 (하지만 블록 외부)는 &lt;code&gt;var&lt;/code&gt; 와 동일한 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b31aad9d36743f490f94cc21d201edada256344c" translate="yes" xml:space="preserve">
          <source>Inside a loop</source>
          <target state="translated">루프 내부</target>
        </trans-unit>
        <trans-unit id="5f706b419d5afb2010d5c584c5073222be04bf3b" translate="yes" xml:space="preserve">
          <source>Is it safe to use &lt;code&gt;let&lt;/code&gt; today?</source>
          <target state="translated">오늘 &lt;code&gt;let&lt;/code&gt; 을 사용해도 안전한가요?</target>
        </trans-unit>
        <trans-unit id="2efd347d2f42601723d5af3a50c4b497df93e4c1" translate="yes" xml:space="preserve">
          <source>It also appears that, at least in Visual Studio 2015, TypeScript 1.5, &quot;var&quot; allows multiple declarations of the same variable name in a block, and &quot;let&quot; doesn't.</source>
          <target state="translated">또한 적어도 Visual Studio 2015, TypeScript 1.5에서 &quot;var&quot;은 블록에 동일한 변수 이름을 여러 번 선언 할 수 있지만 &quot;let&quot;은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5baa9813fadf06ec260f1610e850a5668ce5695e" translate="yes" xml:space="preserve">
          <source>Loops with closures</source>
          <target state="translated">클로저가있는 루프</target>
        </trans-unit>
        <trans-unit id="c0b7662f52c683b4a21a90043d995802030c5bd1" translate="yes" xml:space="preserve">
          <source>Main difference is scoping rules. Variables declared by &lt;code&gt;var&lt;/code&gt; keyword are scoped to the immediate function body (hence the function scope) while &lt;code&gt;let&lt;/code&gt; variables are scoped to the immediate &lt;em&gt;enclosing&lt;/em&gt; block denoted by &lt;code&gt;{ }&lt;/code&gt; (hence the block scope).</source>
          <target state="translated">주요 차이점은 범위 지정 규칙입니다. &lt;code&gt;var&lt;/code&gt; 키워드로 선언 된 변수는 직접 함수 본문 (따라서 함수 범위)에 범위가 지정되는 반면 &lt;code&gt;let&lt;/code&gt; 변수는 &lt;code&gt;{ }&lt;/code&gt; (블록 범위)로 표시되는 즉시 &lt;em&gt;둘러싸는&lt;/em&gt; 블록에 범위가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="99fbe1720bf011da269b2cac5512d7c3963a6968" translate="yes" xml:space="preserve">
          <source>May the following two functions show the difference:</source>
          <target state="translated">다음 두 함수가 차이점을 보여주기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="63a3dc65c2f80ebaced4b3a1a62910c1da24fc2b" translate="yes" xml:space="preserve">
          <source>No re-assigning</source>
          <target state="translated">재 할당 없음</target>
        </trans-unit>
        <trans-unit id="39c7b7a1ef0ba49851ad5dfe7bd9144cb18d52c7" translate="yes" xml:space="preserve">
          <source>No re-declaring</source>
          <target state="translated">다시 선언하지 않음</target>
        </trans-unit>
        <trans-unit id="39c9178c32e097fcac397a91d250592e73365258" translate="yes" xml:space="preserve">
          <source>Note that it doesn't mean that the value is immutable. Its properties still can be changed.</source>
          <target state="translated">값이 변경 불가능하다는 의미는 아닙니다. 여전히 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a83e225fb411474c8b9361c4b05f98a38f3643" translate="yes" xml:space="preserve">
          <source>Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don't.</source>
          <target state="translated">Mozilla 및 Chrome 브라우저 만 지원합니다. IE, Safari 및 잠재적으로 다른 사람들은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96df0ec4b6def0a95acbbc1f79135059a56fd9f0" translate="yes" xml:space="preserve">
          <source>Now I think there is better scoping of variables to a block of statements using &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;let&lt;/code&gt; 을 사용하여 문장 블록에 변수 범위를 더 잘 지정한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="39076c4b7441e59ed2d91b8abe7ca8c4659cb0d2" translate="yes" xml:space="preserve">
          <source>Now, image mixing the two behaviors and you'll probably see why it's not recommended to mix the newer &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; with the older &lt;code&gt;var&lt;/code&gt; in the same script. Doing so can result is some spectacularly confusing code.</source>
          <target state="translated">이제 두 가지 동작을 이미지로 혼합하면 동일한 스크립트에서 최신 &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 를 이전 &lt;code&gt;var&lt;/code&gt; 와 혼합하지 않는 것이 좋습니다. 그렇게하면 결과적으로 혼란스러운 코드가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2795ed8b2631b7e1915cc52073b53be8af53e9" translate="yes" xml:space="preserve">
          <source>Only counts [0, 1].</source>
          <target state="translated">[0, 1] 만 계산합니다.</target>
        </trans-unit>
        <trans-unit id="efcf7de8b6bfc89725e070a6351b838be2c76f1b" translate="yes" xml:space="preserve">
          <source>People had to create immediately invoked functions to capture correct value from the loops but that was also hairy.</source>
          <target state="translated">사람들은 루프에서 올바른 값을 캡처하기 위해 즉시 호출 된 함수를 만들어야했지만 머리카락도 많았습니다.</target>
        </trans-unit>
        <trans-unit id="2f5f2be0ca83a657f2ffc3bfa218814a5981da32" translate="yes" xml:space="preserve">
          <source>People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.</source>
          <target state="translated">JavaScript의 범위 지정에 대해 명확하게 이해하지 못하는 사람들은 실수를 일찍 저 지르 곤했습니다.</target>
        </trans-unit>
        <trans-unit id="285dc513fb5c7a7fc0e6eb93a0290e0641276542" translate="yes" xml:space="preserve">
          <source>Previously there were only two scopes in JavaScript, i.e. functional and global. With '&lt;code&gt;let&lt;/code&gt;' keyword JavaScript has now introduced &lt;code&gt;block-level&lt;/code&gt; variables.</source>
          <target state="translated">이전에는 JavaScript에서 기능과 전역의 두 가지 범위 만있었습니다. ' &lt;code&gt;let&lt;/code&gt; '키워드를 사용하면 JavaScript에서 &lt;code&gt;block-level&lt;/code&gt; 변수가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="25b58933661327228329508e8c2cf1090c0253a0" translate="yes" xml:space="preserve">
          <source>Refer to &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth: let and const&lt;/a&gt;&lt;/em&gt; to understand it better.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth : let 및 const&lt;/a&gt;&lt;/em&gt; 를 참조하여 더 잘 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">범위 지정 규칙</target>
        </trans-unit>
        <trans-unit id="382bd8420b6d01443a65704ab49145af79643941" translate="yes" xml:space="preserve">
          <source>See '&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Emulating private interfaces&lt;/a&gt;'</source>
          <target state="translated">' &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;개인 인터페이스 에뮬레이션&lt;/a&gt; '을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9199fa6dee3c3db69201fd546b73324ee92bb5fc" translate="yes" xml:space="preserve">
          <source>See my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.</source>
          <target state="translated">아래의 예를보고 lion (let) 변수가 두 console.logs에서 어떻게 다르게 작동하는지 참고하십시오. 두 번째 console.log에서 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="ce14680b0e5afa36020ec40b287ff3cdba706e04" translate="yes" xml:space="preserve">
          <source>So the difference is very simple i.e its scope.</source>
          <target state="translated">따라서 그 차이는 매우 간단합니다. 즉 범위입니다.</target>
        </trans-unit>
        <trans-unit id="38c778b9cbefb5fbaad00a515fa6b89ce13a738d" translate="yes" xml:space="preserve">
          <source>Some hacks with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 으로 해킹하기 :</target>
        </trans-unit>
        <trans-unit id="789fd33b37de1fced25ba88ee426bb6b49dcd4f3" translate="yes" xml:space="preserve">
          <source>Some people would argue that in the future we'll ONLY use let statements and that var statements will become obsolete. JavaScript guru &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Kyle Simpson&lt;/strong&gt;&lt;/a&gt; wrote &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;a very elaborate article on why he believes that won't be the case&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 사람들은 미래에 let 문만 사용할 것이며 var 문은 더 이상 사용되지 않을 것이라고 주장합니다. 자바 스크립트 전문가 &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;카일 심슨 (Kyle Simpson)&lt;/strong&gt;&lt;/a&gt; 은 &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;왜 그렇지 않다고 믿는지에 대해 매우 정교한 기사를&lt;/strong&gt;&lt;/a&gt; 썼습니다.</target>
        </trans-unit>
        <trans-unit id="33a132a545bee29b8dcb5ddcc302b7c8534a609b" translate="yes" xml:space="preserve">
          <source>Specifically, this outputs:</source>
          <target state="translated">구체적으로 다음과 같이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="c20042f3ec22b168b4441982da162a8418abc98a" translate="yes" xml:space="preserve">
          <source>Take a look at this example from &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;another stackoverflow question&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;다른 stackoverflow 질문&lt;/a&gt; 에서이 예제를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="d2a5704984a4447527354be4a00cc8b22ced40f5" translate="yes" xml:space="preserve">
          <source>Temporal dead zone</source>
          <target state="translated">일시적 데드 존</target>
        </trans-unit>
        <trans-unit id="a6c1c3dc63d914749b6854d3ab11a3b569eada69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;click&lt;/code&gt; handler callback does not need the &lt;code&gt;hugeData&lt;/code&gt; variable at all. Theoretically, after &lt;code&gt;process(..)&lt;/code&gt; runs, the huge data structure &lt;code&gt;hugeData&lt;/code&gt; could be garbage collected. However, it's possible that some JS engine will still have to keep this huge structure, since the &lt;code&gt;click&lt;/code&gt; function has a closure over the entire scope.</source>
          <target state="translated">&lt;code&gt;click&lt;/code&gt; 핸들러 콜백에는 &lt;code&gt;hugeData&lt;/code&gt; 변수가 전혀 필요하지 않습니다. 이론적으로 &lt;code&gt;process(..)&lt;/code&gt; 가 실행 된 후 &lt;code&gt;hugeData&lt;/code&gt; 구조체 hugeData 는 가비지 수집 될 수 있습니다. 그러나 &lt;code&gt;click&lt;/code&gt; 기능이 전체 범위에 걸쳐 폐쇄되어 있기 때문에 일부 JS 엔진은 여전히이 거대한 구조를 유지해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="264885cd88282bf28a8225c70ff7599f6d3df455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gfoo&lt;/code&gt;, defined by &lt;code&gt;let&lt;/code&gt; initially is in the &lt;strong&gt;global scope&lt;/strong&gt;, and when we declare &lt;code&gt;gfoo&lt;/code&gt; again inside the &lt;code&gt;if clause&lt;/code&gt; its &lt;strong&gt;&lt;em&gt;scope changed&lt;/em&gt;&lt;/strong&gt; and when a new value is assigned to the variable inside that scope it &lt;strong&gt;does not affect&lt;/strong&gt; the global scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 에 의해 처음 정의 된 &lt;code&gt;gfoo&lt;/code&gt; 는 &lt;strong&gt;전역 범위&lt;/strong&gt; 에 있으며 &lt;code&gt;if clause&lt;/code&gt; 에서 &lt;code&gt;gfoo&lt;/code&gt; 를 다시 선언 하면 해당 &lt;strong&gt;&lt;em&gt;범위가 변경&lt;/em&gt;&lt;/strong&gt; 되고 해당 &lt;strong&gt;&lt;em&gt;범위&lt;/em&gt;&lt;/strong&gt; 내의 변수에 새 값이 할당되면 전역 범위에 &lt;strong&gt;영향을 미치지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="87b7ba6b84d1c61150fc37bf6a8f3727f5c2d5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword attaches the variable declaration to the scope of whatever block (commonly a &lt;code&gt;{ .. }&lt;/code&gt; pair) it's contained in. In other words,&lt;code&gt;let&lt;/code&gt; implicitly hijacks any block's scope for its variable declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 키워드는 변수 선언을 포함하는 모든 블록 (일반적으로 &lt;code&gt;{ .. }&lt;/code&gt; 쌍)의 범위에 변수 선언을 첨부합니다. 즉, 변수 선언을 위해 블록의 범위를 암시 적으로 빼냅니다.</target>
        </trans-unit>
        <trans-unit id="78af92108bc96e8a42084047aaf363842f3b377a" translate="yes" xml:space="preserve">
          <source>The accepted answer is missing a point:</source>
          <target state="translated">수락 된 답변에 요점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="073b339db7edb1c2e2e81ea60ac755f69153f037" translate="yes" xml:space="preserve">
          <source>The below shows how 'let' and 'var' are different in the scope:</source>
          <target state="translated">아래는 'let'과 'var'이 범위에서 어떻게 다른지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4d9ba873fd7a30468256474a7c4d6e16988d829d" translate="yes" xml:space="preserve">
          <source>The below table summarize the difference between var, let and const</source>
          <target state="translated">아래 표는 var, let 및 const의 차이점을 요약 한 것입니다</target>
        </trans-unit>
        <trans-unit id="00a031e0941465964589ed342dbcebaa59ee6085" translate="yes" xml:space="preserve">
          <source>The difference is in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;scope&lt;/a&gt; of the variables declared with each.</source>
          <target state="translated">차이점은 각각 선언 된 변수의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;범위&lt;/a&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="58bbbdd4908ae3e2d249c1fbdc5b3f5b43c376b1" translate="yes" xml:space="preserve">
          <source>The difference is scoping. &lt;code&gt;var&lt;/code&gt; is scoped to the nearest &lt;strong&gt;function
  block&lt;/strong&gt; and &lt;code&gt;let&lt;/code&gt; is scoped to the &lt;strong&gt;nearest enclosing block&lt;/strong&gt;, which
  can be smaller than a function block. Both are global if outside any
  block.Lets see an example:</source>
          <target state="translated">차이점은 범위입니다. &lt;code&gt;var&lt;/code&gt; 는 가장 가까운 &lt;strong&gt;기능 블록&lt;/strong&gt; 으로 범위가 지정되고 &lt;code&gt;let&lt;/code&gt; 은 &lt;strong&gt;가장 가까운 둘러싸는 블록으로&lt;/strong&gt; 범위가 지정되며 기능 블록보다 작을 수 있습니다. 블록 외부에있는 경우 둘 다 전역입니다.</target>
        </trans-unit>
        <trans-unit id="a2047a53cae852bc9bd4d5726d86bf1abdab5907" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is that variables declared with &lt;code&gt;var&lt;/code&gt; are &lt;strong&gt;function scoped&lt;/strong&gt;. Whereas functions declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt;. For example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 와 &lt;code&gt;let&lt;/code&gt; 의 주요 차이점은 var로 선언 된 &lt;code&gt;var&lt;/code&gt; 는 &lt;strong&gt;함수 범위&lt;/strong&gt; 입니다. &lt;code&gt;let&lt;/code&gt; 으로 선언 된 함수는 &lt;strong&gt;블록 범위&lt;/strong&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d162e4b209b454c9dcdb65956e1046635e203a9" translate="yes" xml:space="preserve">
          <source>The main difference is the &lt;strong&gt;scope&lt;/strong&gt; difference, while &lt;strong&gt;let&lt;/strong&gt; can be only available inside the &lt;strong&gt;scope&lt;/strong&gt; it's declared, like in for loop, &lt;strong&gt;var&lt;/strong&gt; can be accessed outside the loop for example. From the documentation in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (examples also from MDN):</source>
          <target state="translated">주요 차이점은 &lt;strong&gt;범위&lt;/strong&gt; 차이이며, for 루프에서와 같이 선언 된 &lt;strong&gt;범위&lt;/strong&gt; 내에서만 사용할 수 있으며 &lt;strong&gt;var&lt;/strong&gt; 는 루프 외부에서 액세스 할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; 설명서 (예 : MDN) :</target>
        </trans-unit>
        <trans-unit id="9f7f9f1e0a48709104afca6e8067da28df678148" translate="yes" xml:space="preserve">
          <source>The process above doesn't generate the desired array of functions because &lt;code&gt;i&lt;/code&gt;'s scope extends beyond the iteration of the &lt;code&gt;for&lt;/code&gt; block in which each function was created. Instead, at the end of the loop, the &lt;code&gt;i&lt;/code&gt; in each function's closure refers to &lt;code&gt;i&lt;/code&gt;'s value at the end of the loop (1000) for every anonymous function in &lt;code&gt;adderFunctions&lt;/code&gt;. This isn't what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of &lt;code&gt;i&lt;/code&gt;, the mutation will affect all the &lt;code&gt;adderFunctions&lt;/code&gt;.</source>
          <target state="translated">위의 프로세스는 &lt;code&gt;i&lt;/code&gt; 의 범위가 각 함수가 작성된 &lt;code&gt;for&lt;/code&gt; 블록의 반복을 넘어 확장되기 때문에 원하는 함수 배열을 생성하지 않습니다. 대신 루프의 끝에서 각 함수의 닫힘에있는 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;adderFunctions&lt;/code&gt; 의 모든 익명 함수에 대해 루프 끝의 i 값 (1000)을 나타냅니다 . 이것은 우리가 원하는 것이 아닙니다. 이제 우리는 정확히 같은 동작을 가진 1000 개의 서로 다른 함수 배열을 메모리에 갖습니다. 그리고 나중에 &lt;code&gt;i&lt;/code&gt; 값을 업데이트하면 돌연변이가 모든 &lt;code&gt;adderFunctions&lt;/code&gt; 에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="3451295aef647a9eb92f4f38d933a0e2d080e7e1" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;let&lt;/code&gt; keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.</source>
          <target state="translated">키워드가 언어에 도입 된 이유는 함수 범위이기 때문에 혼란스럽고 JavaScript의 주요 버그 소스 중 하나였습니다.</target>
        </trans-unit>
        <trans-unit id="11b109d5b87133e7c9f78aaa1557423809cb31f7" translate="yes" xml:space="preserve">
          <source>The restrictions imposed by &lt;code&gt;let&lt;/code&gt; reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;reachability&lt;/a&gt;(helping with reclaiming unused memory).</source>
          <target state="translated">변수의 가시성을 줄이고 예상치 못한 이름 충돌이 조기에 발견 될 가능성을 높이는 제한 사항 이를 통해 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;도달 가능성을&lt;/a&gt; 포함하여 변수를 추적하고 추론하기가 더 쉬워집니다 (미사용 메모리를 되 찾는 데 도움이 됨).</target>
        </trans-unit>
        <trans-unit id="e0d2bb460f6b296bc8aef7ab3dd6effc0df6f796" translate="yes" xml:space="preserve">
          <source>The second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.</source>
          <target state="translated">let의 두 번째 기능은 블록 범위를 소개한다는 것입니다. 블록은 중괄호로 정의됩니다. 함수 블록, if 블록, 블록 등을 예로들 수 있습니다. 블록 내부에 let을 사용하여 변수를 선언하면 변수는 블록 내부에서만 사용할 수 있습니다. 실제로 for 루프 내에서와 같이 블록이 실행될 때마다 메모리에 새 변수가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f0009b35b2bce48e37552dc2d483b1c142ec7b1e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences &amp;mdash; &lt;code&gt;let&lt;/code&gt; scoping behaves more like variable scoping does in more or less any other languages.</source>
          <target state="translated">몇 가지 미묘한 차이점이 있습니다. 범위 지정은 다른 언어의 변수 범위 지정과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="582e7ce54a6962d9d96e460cfe6b27fdb7eed8a5" translate="yes" xml:space="preserve">
          <source>There are still some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 을 전혀 지원하지 않는 일부 브라우저가 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ee4cc384a25d5e3ddde3e6500df25636cdfd4ce" translate="yes" xml:space="preserve">
          <source>This article clearly defines the difference between var, let and const</source>
          <target state="translated">이 기사는 var, let 및 const의 차이점을 명확하게 정의합니다.</target>
        </trans-unit>
        <trans-unit id="556d5253d7e385c3f1d2c5b84329a06bb16d69f7" translate="yes" xml:space="preserve">
          <source>This block of code will throw a &lt;code&gt;ReferenceError&lt;/code&gt; before the code can be run because &lt;code&gt;x&lt;/code&gt; is used before it is declared:</source>
          <target state="translated">이 코드 블록은 &lt;code&gt;x&lt;/code&gt; 가 선언되기 전에 사용되기 때문에 코드를 실행하기 전에 &lt;code&gt;ReferenceError&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="25d7860a8b2663b86949e7ca85dafff841362dba" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;let&lt;/code&gt;, for every loop iteration the variable is scoped and has its own copy.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 을 사용할 때 모든 루프 반복에 대해 변수의 범위가 지정되고 자체 사본이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1edd9ce9f172dbb4d4b3887bc51fb5cf6e0bb712" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;var&lt;/code&gt;, for every loop iteration the variable is scoped and has shared copy.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 를 사용할 때 모든 루프 반복에 대해 변수의 범위가 지정되고 공유 사본이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a216ad59073ea6bd11a79ebc083a96139dca03f7" translate="yes" xml:space="preserve">
          <source>This time, &lt;code&gt;i&lt;/code&gt; is rebound on each iteration of the &lt;code&gt;for&lt;/code&gt; loop. Each function now keeps the value of &lt;code&gt;i&lt;/code&gt; at the time of the function's creation, and &lt;code&gt;adderFunctions&lt;/code&gt; behaves as expected.</source>
          <target state="translated">이번에는 &lt;code&gt;for&lt;/code&gt; 루프가 반복 될 때마다 리바운드됩니다. 각 함수는 이제 함수 생성시 &lt;code&gt;i&lt;/code&gt; 의 값을 유지하며 &lt;code&gt;adderFunctions&lt;/code&gt; 는 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">이것은 :</target>
        </trans-unit>
        <trans-unit id="5dd7645a6d40c190e66e82b7ca6d2962889cfe89" translate="yes" xml:space="preserve">
          <source>This won't generate a compile error:</source>
          <target state="translated">컴파일 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d36477f33831b971d8bfc3e95c1e4d91bef92cb1" translate="yes" xml:space="preserve">
          <source>To have a complete understanding of the 'let' keyword, &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;
ES6: &amp;lsquo;let&amp;rsquo; keyword to declare variable in JavaScript&lt;/a&gt;&lt;/em&gt; will help.</source>
          <target state="translated">'let'키워드를 완전히 이해하려면 &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;ES6 : JavaScript에서 변수를 선언하는 'let'키워드&lt;/a&gt;&lt;/em&gt; 가 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="798cc826b7c6eca17f20ac9967ed751d475d3bfa" translate="yes" xml:space="preserve">
          <source>To understand the difference, consider the following code:</source>
          <target state="translated">차이점을 이해하려면 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b18d3db48c6c605af5cb1ff84864472fd83e2a" translate="yes" xml:space="preserve">
          <source>Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it's safe to use the &lt;code&gt;let&lt;/code&gt; statement. The answer to that question depends on your environment:</source>
          <target state="translated">그러나 오늘날에는 그렇지 않습니다. 사실, &lt;code&gt;let&lt;/code&gt; 문을 사용하는 것이 안전한지 실제로 자문 해보아야합니다. 해당 질문에 대한 답변은 환경에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cf0bd12b27a5d6ae801ae06ca45ff4d909c5e11f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. &lt;code&gt;var&lt;/code&gt; can be used when you want a global variable explicitly to be on the &lt;code&gt;window&lt;/code&gt; object (always consider carefully if this is really necessary).</source>
          <target state="translated">간단하게 범위가 지정되므로 &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; 를 사용하십시오. 이는 많은 변수를 처리 할 때 발생할 수있는 잠재적 인 이름 충돌을 줄입니다. &lt;code&gt;var&lt;/code&gt; 는 전역 변수를 명시 적으로 &lt;code&gt;window&lt;/code&gt; 객체에 배치하려고 할 때 사용할 수 있습니다 (실제로 필요한 경우 항상 신중하게 고려하십시오).</target>
        </trans-unit>
        <trans-unit id="447b7b7549292e2e8a35c8c418af427a8697661b" translate="yes" xml:space="preserve">
          <source>Variable declared using &lt;code&gt;const&lt;/code&gt; can't be re-assigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 를 사용하여 선언 된 변수는 재 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea2f7a7e35f707d8856cdb8cb5665c534077fffb" translate="yes" xml:space="preserve">
          <source>Variables declared by &lt;strong&gt;let&lt;/strong&gt; have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, &lt;strong&gt;let&lt;/strong&gt; works very much like &lt;strong&gt;var&lt;/strong&gt;. The main difference is that the scope of a &lt;strong&gt;var&lt;/strong&gt; variable is the entire enclosing function:</source>
          <target state="translated">&lt;strong&gt;let에&lt;/strong&gt; 의해 선언 된 변수는 포함 된 하위 블록뿐만 아니라 자신이 정의 된 블록을 해당 범위로 갖습니다. 이런 식으로 &lt;strong&gt;var&lt;/strong&gt; 과 매우 유사 &lt;strong&gt;하게&lt;/strong&gt; 작동합니다. 가장 큰 차이점은 &lt;strong&gt;var&lt;/strong&gt; 변수의 범위가 전체 둘러싸는 함수라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac8b214aec9424ef9fffbc10e806c9b68d0341c2" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;let&lt;/code&gt; inside a block can't be accessed outside that block.</source>
          <target state="translated">블록 내부에서 &lt;code&gt;let&lt;/code&gt; 을 사용하여 선언 된 변수는 해당 블록 외부에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b32e0f62bb42b1453a0aa34a0c6ccac71e925fd" translate="yes" xml:space="preserve">
          <source>Variables declared using the &lt;code&gt;let&lt;/code&gt; keyword are block-scoped, which means that they are available only in the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;block&lt;/a&gt; in which they were declared.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 키워드를 사용하여 선언 된 변수는 블록 범위이므로 선언 된 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;블록&lt;/a&gt; 에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86c41ca6962411581269ba19972206be437465f2" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;let&lt;/code&gt; in loops can be referenced only inside that loop.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; in 루프로 선언 된 변수는 해당 루프 내에서만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b328fafa53d71ac4b0917bba556f26a497d46ea3" translate="yes" xml:space="preserve">
          <source>What are the differences? When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">차이점은 무엇입니까? 언제 &lt;code&gt;var&lt;/code&gt; 이상 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="62485fc832e025ecfaffbb9e9fa16598e466214c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;var&lt;/code&gt; 의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ba36ff7094458ce1f2d89aff408961ca118f85f3" translate="yes" xml:space="preserve">
          <source>What's the difference between using “let” and “var”</source>
          <target state="translated">&quot;let&quot;과 &quot;var&quot;의 차이점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="b646d47d71c5ed2befdf512e42079703b478e4c5" translate="yes" xml:space="preserve">
          <source>When the first function &lt;code&gt;testVar&lt;/code&gt; gets called the variable foo, declared with &lt;code&gt;var&lt;/code&gt;, is still accessible outside the &lt;code&gt;if&lt;/code&gt; statement. This variable &lt;code&gt;foo&lt;/code&gt; would be available &lt;strong&gt;everywhere&lt;/strong&gt; within the scope of the &lt;code&gt;testVar&lt;/code&gt;&lt;strong&gt;function&lt;/strong&gt;.</source>
          <target state="translated">첫 번째 함수 &lt;code&gt;testVar&lt;/code&gt; 가 호출 될 때 &lt;code&gt;var&lt;/code&gt; 로 선언 된 변수 foo는 &lt;code&gt;if&lt;/code&gt; 문 외부에서 여전히 액세스 할 수 있습니다. 이 변수 &lt;code&gt;foo&lt;/code&gt; 는 &lt;code&gt;testVar&lt;/code&gt; &lt;strong&gt;함수&lt;/strong&gt; 의 범위 내 &lt;strong&gt;어디에서나&lt;/strong&gt; 사용할 수 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d1e9bfedfc5565d2a134910beb552ddd3db5af" translate="yes" xml:space="preserve">
          <source>When the second function &lt;code&gt;testLet&lt;/code&gt; gets called the variable bar, declared with &lt;code&gt;let&lt;/code&gt;, is only accessible inside the &lt;code&gt;if&lt;/code&gt; statement. Because variables declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt; (where a block is the code between curly brackets e.g &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt;, &lt;code&gt;function{}&lt;/code&gt;).</source>
          <target state="translated">두 번째 함수 &lt;code&gt;testLet&lt;/code&gt; 이 get으로 선언 된 변수 막대를 호출하면 &lt;code&gt;if&lt;/code&gt; 문 내에서만 액세스 할 수 있습니다. &lt;code&gt;let&lt;/code&gt; 으로 선언 된 변수는 &lt;strong&gt;블록 범위가 지정&lt;/strong&gt; 되므로 &lt;strong&gt;블록&lt;/strong&gt; 은 중괄호 사이의 코드입니다 (예 : &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt; , &lt;code&gt;function{}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763c20e32aedaf10fa2547617925238345016332" translate="yes" xml:space="preserve">
          <source>When used inside a block, let limits the variable's scope to that block. Note the difference between &lt;strong&gt;var&lt;/strong&gt; whose scope is inside the function where it is declared.</source>
          <target state="translated">블록 안에서 사용될 때 변수의 범위를 해당 블록으로 제한하십시오. 범위가 선언 된 함수 내에 범위가있는 &lt;strong&gt;var&lt;/strong&gt; 의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="61cd92a023d0a31f010a274ec7d86e10c5421fb8" translate="yes" xml:space="preserve">
          <source>When you need a block level deceleration you can go with let and const
  instead of var.</source>
          <target state="translated">블록 레벨 감속이 필요한 경우 var 대신 let 및 const를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a368a87210137edc166a614258cbe6102456562" translate="yes" xml:space="preserve">
          <source>Whereas</source>
          <target state="translated">Whereas</target>
        </trans-unit>
        <trans-unit id="0fe1d7ee87c3a04d0ac51238b917cc2c9c89c5d5" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;hfoo&lt;/code&gt;, defined by &lt;code&gt;var&lt;/code&gt; is initially in the &lt;strong&gt;global scope&lt;/strong&gt;, but again when we declare it inside the &lt;code&gt;if clause&lt;/code&gt;, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 에 의해 정의 된 &lt;code&gt;hfoo&lt;/code&gt; 는 처음에 &lt;strong&gt;전역 범위&lt;/strong&gt; 에있는 반면, &lt;code&gt;if clause&lt;/code&gt; 에서 선언 할 때 전역 범위 hfoo를 고려하지만 var가 다시 선언하는 데 사용되었습니다. 그리고 우리가 그 값을 다시 할당 할 때 우리는 전역 범위 hfoo도 영향을 받는다는 것을 알 수 있습니다. 이것이 주요 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="e3e6995ec39780a0e837123289821ba1329d357a" translate="yes" xml:space="preserve">
          <source>Which results in counting [0, 7].</source>
          <target state="translated">계산 결과는 [0, 7]입니다.</target>
        </trans-unit>
        <trans-unit id="3708d68bf42f4db9fe994838852e9983033235ad" translate="yes" xml:space="preserve">
          <source>While variables declared with &lt;code&gt;var&lt;/code&gt; keyword are &quot;hoisted&quot; to the top of the block which means they are accessible in their enclosing scope even before they are declared:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드로 선언 된 변수는 블록 상단에 &quot;상승&quot;되어 있지만 선언하기 전에도 포함 범위에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b01fae36659f37d265b081743cc0dc35597443" translate="yes" xml:space="preserve">
          <source>With a variable defined with var, if the Engine cannot find the variable in the current Execution Context's Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment's Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const.</source>
          <target state="translated">var로 정의 된 변수를 사용하면 엔진이 현재 실행 컨텍스트의 변수 환경에서 변수를 찾을 수 없으면 범위 체인 (외부 환경)으로 이동하여 변수에 대한 외부 환경의 변수 환경을 확인합니다. 찾을 수 없으면 스코프 체인을 계속 검색합니다. let과 const는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="627826fe97bef52b6bbf6053deb38913659b0bdd" translate="yes" xml:space="preserve">
          <source>With this approach errors present in JavaScript are getting removed.</source>
          <target state="translated">이 접근 방식으로 JavaScript에 존재하는 오류가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c3c2f48f1eb008d449f48eb15990b4f6e424e20b" translate="yes" xml:space="preserve">
          <source>You always must specify a value when declaring a variable using &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 를 사용하여 변수를 선언 할 때는 항상 값을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0790cbb95ab5ec73d3e6258998a0a7ad3095843b" translate="yes" xml:space="preserve">
          <source>You can't declare the same variable multiple times using &lt;code&gt;let&lt;/code&gt;. You also can't declare a variable using &lt;code&gt;let&lt;/code&gt; with the same identifier as another variable which was declared using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 을 사용하여 동일한 변수를 여러 번 선언 할 수 없습니다. &lt;code&gt;var&lt;/code&gt; 를 사용하여 선언 된 다른 변수와 동일한 식별자를 사용하여 &lt;code&gt;let&lt;/code&gt; 을 사용하여 변수를 선언 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2fce063a96f03a5121674374be0af6b8b24bce2" translate="yes" xml:space="preserve">
          <source>e.g. It scopes to the enclosing block, They don't exist before they're declared, etc.</source>
          <target state="translated">예를 들어, 그것은 블록을 둘러싸고, 선언되기 전에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d313532c8abb336dd50ad99fcaa46af296c26e1d" translate="yes" xml:space="preserve">
          <source>let is a part of es6. These functions will explain the difference in easy way.</source>
          <target state="translated">let은 es6의 일부입니다. 이러한 기능을 통해 차이점을 쉽게 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ef6b5ab2d1b894e89fcae400b0537fb9a8b5ce" translate="yes" xml:space="preserve">
          <source>let vs var. It's all about &lt;strong&gt;scope&lt;/strong&gt;.</source>
          <target state="translated">let vs var. &lt;strong&gt;범위&lt;/strong&gt; 에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c278d52dd0385cbf90b767810934740d91018546" translate="yes" xml:space="preserve">
          <source>one of the most famous interview questions on scope also can suffice the exact use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; as below;</source>
          <target state="translated">범위에서 가장 유명한 인터뷰 질문 중 하나는 다음과 같이 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;var&lt;/code&gt; 의 정확한 사용으로 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d408aaa5a340d732402a346a7f915ed8a3d8a04" translate="yes" xml:space="preserve">
          <source>test.js</source>
          <target state="translated">test.js</target>
        </trans-unit>
        <trans-unit id="b8ffef03491342b55d430f0b8e5920b4a84fcdb6" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't&lt;/strong&gt; get hoisted:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 변수는 게양 &lt;strong&gt;되지 않습니다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c588190991c2844f3923ec38efe295f544b19b2e" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;do&lt;/strong&gt; get hoisted:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 변수는 게양됩니다 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
