<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/762011">
    <body>
      <group id="762011">
        <trans-unit id="fafcd2951a6c9ab9c6c43e67c5a38264f0cdd84a" translate="yes" xml:space="preserve">
          <source>... the loop unexpectedly outputs &quot;i is 5&quot; five times:</source>
          <target state="translated">...петля неожиданно 5 раз выдает &quot;i is 5&quot;:</target>
        </trans-unit>
        <trans-unit id="6d871bd011c025ac22e1d36c547f25316c14c79d" translate="yes" xml:space="preserve">
          <source>... the output remains unchanged as long as we stick with &lt;code&gt;let&lt;/code&gt;.  In contrast, if we had used &lt;code&gt;var i&lt;/code&gt; instead:</source>
          <target state="translated">... вывод остается неизменным, пока мы придерживаемся &lt;code&gt;let&lt;/code&gt; . Напротив, если бы мы использовали вместо этого &lt;code&gt;var i&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43c75a7895bae9f2274a20daccd9c56125f42242" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;This table&lt;/a&gt; on Wikipedia shows which browsers support Javascript 1.7.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;Эта таблица&lt;/a&gt; в Википедии показывает, какие браузеры поддерживают Javascript 1.7.</target>
        </trans-unit>
        <trans-unit id="0191d36331a7f5a9e5755b19f3d7de9c667f7b49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;My value: 3&lt;/code&gt; was output to console each time &lt;code&gt;funcs[j]();&lt;/code&gt; was invoked since anonymous functions were bound to the same variable.</source>
          <target state="translated">&lt;code&gt;My value: 3&lt;/code&gt; &lt;code&gt;funcs[j]();&lt;/code&gt; на консоль каждый раз, когда funcs [j] (); был вызван, поскольку анонимные функции были связаны с одной и той же переменной.</target>
        </trans-unit>
        <trans-unit id="ccc17ff02fbc922f367c8a5b47195617bb23fb48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is a signal that the identifier won&amp;rsquo;t be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; является сигналом того, что идентификатор не будет переназначен.</target>
        </trans-unit>
        <trans-unit id="3308d036748c8401176277b68520b6bab4436169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is quite similar to &lt;code&gt;let&lt;/code&gt;&amp;mdash;it's block-scoped and has TDZ. There are, however, two things which are different.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; очень похож на &lt;code&gt;let&lt;/code&gt; - это блок-область и имеет TDZ. Однако есть две разные вещи.</target>
        </trans-unit>
        <trans-unit id="893fb0337fbc6374457738790cc8786afc01cbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is block scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; это область видимости блока.</target>
        </trans-unit>
        <trans-unit id="0935015189555bca81712e46368bff07cdd2ad82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; также может использоваться, чтобы избежать проблем с замыканиями. Он связывает свежую ценность, а не сохраняет старую ссылку, как показано в примерах ниже.</target>
        </trans-unit>
        <trans-unit id="7da55d0ae5cba83af8d9bcddc15fbe75a305d540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; in the loop can &lt;strong&gt;re-binds it&lt;/strong&gt; to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; в цикле может &lt;strong&gt;повторно привязать его&lt;/strong&gt; к каждой итерации цикла, убедившись, что ему присвоено значение с конца предыдущей итерации цикла. Рассматривать,</target>
        </trans-unit>
        <trans-unit id="898943cc10dae9aa57654db408d0e9820a07b17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is interesting, because it allows us to do something like this:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; это интересно, потому что это позволяет нам делать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="b00d42e90d9ff28c2ca17f2066eab4ca296f8fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are &lt;em&gt;easy to use&lt;/em&gt; with closures (they do not cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;race conditions&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; переменные &lt;em&gt;легко использовать&lt;/em&gt; с замыканиями (они не вызывают &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;условий гонки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0af3806742f2c2f6ebb22613b4d0219aa7071dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a &lt;code&gt;ReferenceError&lt;/code&gt;. Variable said to be in &quot;temporal dead zone&quot; from the start of the block until the initialization is processed.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; переменные не инициализируются до тех пор, пока их определение не будет оценено. Доступ к ним до инициализации приводит к &lt;code&gt;ReferenceError&lt;/code&gt; . Считается, что переменная находится в &amp;laquo;временной мертвой зоне&amp;raquo; от начала блока до обработки инициализации.</target>
        </trans-unit>
        <trans-unit id="65ff7d9e010e2ad54c26d0e0600b56ceeb93776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only usable in lines of code that occur &lt;em&gt;after&lt;/em&gt; the variable is declared (even though &lt;a href=&quot;/questions/33198849&quot;&gt;they are hoisted&lt;/a&gt;!).</source>
          <target state="translated">переменные &lt;code&gt;let&lt;/code&gt; могут использоваться только в строках кода, которые появляются &lt;em&gt;после того,&lt;/em&gt; как переменная объявлена ​​(даже если &lt;a href=&quot;/questions/33198849&quot;&gt;они подняты&lt;/a&gt; !).</target>
        </trans-unit>
        <trans-unit id="3ec2a907ce0b2eb98081f72a00f994a218703a4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only visible in their &lt;em&gt;nearest enclosing&lt;/em&gt; block (&lt;code&gt;{ ... }&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; переменные видны только в &lt;em&gt;ближайшем окружающем их&lt;/em&gt; блоке ( &lt;code&gt;{ ... }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="93fc717aea1571de33197157899b7efda524d39d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables cannot be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; переменные не могут быть доступны в объекте &lt;code&gt;window&lt;/code&gt; потому что они не могут быть доступны глобально.</target>
        </trans-unit>
        <trans-unit id="5c36689eca346124e71af49608677b1a82b86f74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables don't get hoisted:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; переменные не поднимаются:</target>
        </trans-unit>
        <trans-unit id="ca400981a08e8a909a0c3b4d1745acd5f90a1658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables may not be redeclared by a subsequent &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">переменные &lt;code&gt;let&lt;/code&gt; не могут быть повторно объявлены последующим &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5bdfd10726565f7599def5824126d5b88cbe29b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; works very much like &lt;code&gt;var&lt;/code&gt;. The main difference is that the scope of a &lt;code&gt;var&lt;/code&gt; variable is the entire enclosing function</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; работает очень похоже на &lt;code&gt;var&lt;/code&gt; . Основное различие заключается в том, что область действия переменной &lt;code&gt;var&lt;/code&gt; - это вся включающая функция</target>
        </trans-unit>
        <trans-unit id="4a7e5a7da596e5ed599f94db730395d7fcdafdec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, is a signal that the variable may be reassigned, such as a
  counter in a loop, or a value swap in an algorithm. It also signals
  that the variable will be used only in the block it&amp;rsquo;s defined in,
  which is not always the entire containing function.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; - это сигнал о том, что переменная может быть переназначена, например, счетчик в цикле или обмен значениями в алгоритме. Это также сигнализирует о том, что переменная будет использоваться только в блоке, в котором она определена, что не всегда является всей содержащей функцией.</target>
        </trans-unit>
        <trans-unit id="d7ac1ca1e5aa7a427f93aec2df1994a143404d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; и variable в ES5 имеют области действия в функциях, что означает, что переменные действительны внутри функции, а не вне самой функции.</target>
        </trans-unit>
        <trans-unit id="948a7ff5506461094cf4291aab6e19dc898ba6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is global scope (hoist-able) variable.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; - глобальная переменная области видимости.</target>
        </trans-unit>
        <trans-unit id="5cfeb8565d205ecaa6279727ad54117c2209b10f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is now the weakest signal available when you define a variable
  in JavaScript. The variable may or may not be reassigned, and the
  variable may or may not be used for an entire function, or just for
  the purpose of a block or loop.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; теперь является самым слабым сигналом, доступным при определении переменной в JavaScript. Переменная может быть или не быть переназначена, и переменная может или не может использоваться для всей функции, или просто для цели блока или цикла.</target>
        </trans-unit>
        <trans-unit id="fbca8b19e8de6aba37b90ff0fc91b6e4429a273d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of &lt;code&gt;var&lt;/code&gt; for exports may be supplanted if &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; migrates out of transpiler space and into the core language.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; может быть полезен, если вы уверены, что хотите использовать эффект одиночного связывания при использовании замыкания в цикле (# 5) или для объявления внешне видимых глобальных переменных в вашем коде (# 4). Использование &lt;code&gt;var&lt;/code&gt; для экспорта может быть заменено, если &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; перемещается из пространства транспортера в основной язык.</target>
        </trans-unit>
        <trans-unit id="0e636d2a81e1a762020c4f5c3744c8e65bfdd0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; variables can be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">Переменные &lt;code&gt;var&lt;/code&gt; могут быть доступны в объекте &lt;code&gt;window&lt;/code&gt; потому что они не могут быть доступны глобально.</target>
        </trans-unit>
        <trans-unit id="f7b28054bd2387937ff823de5e92e8d087509275" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;let&lt;/code&gt; will &lt;strong&gt;not hoist&lt;/strong&gt; to the entire scope of the block they appear in. By contrast, &lt;code&gt;var&lt;/code&gt; could hoist as below.&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; будет &lt;strong&gt;поднимать&lt;/strong&gt; весь объем блока, в котором они появляются. В отличие от этого, &lt;code&gt;var&lt;/code&gt; может подниматься, как показано ниже. &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="8e5e8a4029ba67276f8775f560d25040ee366e1d" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;strong&gt;Variable Not Hoisting&lt;/strong&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;strong&gt;Переменная не поднимается&lt;/strong&gt; &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;(*) Глобальные и функциональные переменные могут быть инициализированы и использованы до того, как объявлены, потому что переменные JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;подняты&lt;/strong&gt;&lt;/a&gt; .&lt;/em&gt; Это означает, что объявления всегда находятся на вершине области видимости.</target>
        </trans-unit>
        <trans-unit id="b8a45f3633696567dffb096c46db365f09dc340f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(**) Block scoped variables are not hoisted&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(**) Переменные области видимости не отображаются&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a92f025526fcf6fd0e31e3883a2c0ce413ea45b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. No use outside nearest enclosing block:&lt;/strong&gt;
This block of code will throw a reference error because the second use of &lt;code&gt;x&lt;/code&gt; occurs outside of the block where it is declared with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;1. Не использовать вне ближайшего окружающего блока:&lt;/strong&gt; этот блок кода выдаст опорную ошибку, потому что второе использование &lt;code&gt;x&lt;/code&gt; происходит за пределами блока, где оно объявлено с помощью &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1a3f78207be8aa46a711328247e402fe16ff7e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. No use before declaration:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Не использовать до объявления:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ebde23d0d3b7756808c6cc91ba63eefcda7c222" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. No redeclaration:&lt;/strong&gt;
The following code demonstrates that a variable declared with &lt;code&gt;let&lt;/code&gt; may not be redeclared later:</source>
          <target state="translated">&lt;strong&gt;3. Без повторного объявления:&lt;/strong&gt; следующий код демонстрирует, что переменная, объявленная с помощью &lt;code&gt;let&lt;/code&gt; , не может быть повторно объявлена ​​позднее:</target>
        </trans-unit>
        <trans-unit id="3452dda34e6fe8760767335a5682fa96d4f633dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Globals not attached to &lt;code&gt;window&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4. Глобалы, не прикрепленные к &lt;code&gt;window&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="117009c83c2e98d0a5ff10f1606e8d479850f1f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. Easy use with closures:&lt;/strong&gt;
Variables declared with &lt;code&gt;var&lt;/code&gt; do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable &lt;code&gt;i&lt;/code&gt; has at different points in time:</source>
          <target state="translated">&lt;strong&gt;5. Простота использования с замыканиями:&lt;/strong&gt; переменные, объявленные с помощью &lt;code&gt;var&lt;/code&gt; , плохо работают с замыканиями внутри циклов. Вот простой цикл, который выводит последовательность значений переменной &lt;code&gt;i&lt;/code&gt; в разные моменты времени:</target>
        </trans-unit>
        <trans-unit id="335cb1cc283f4951de3aa9563124b1b1306cd973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;let&lt;/code&gt; loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; петли&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0320f62c5e659472d8791116df2b4f5d9063ed90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db7c704eb200ce249efd68f6671cae57bf115cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example2:&lt;/strong&gt;
In my second example  instead of using &lt;code&gt;var&lt;/code&gt; keyword in my conditional block I declare &lt;code&gt;myvar&lt;/code&gt; using &lt;code&gt;let&lt;/code&gt; keyword . Now when I call &lt;code&gt;myfunc&lt;/code&gt;  I get two different outputs: &lt;code&gt;myvar=20&lt;/code&gt; and &lt;code&gt;myvar=10&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Пример 2:&lt;/strong&gt; Во втором примере вместо использования ключевого слова &lt;code&gt;var&lt;/code&gt; в моем условном блоке я объявляю &lt;code&gt;myvar&lt;/code&gt; с помощью ключевого слова &lt;code&gt;let&lt;/code&gt; . Теперь, когда я вызываю &lt;code&gt;myfunc&lt;/code&gt; , я получаю два разных вывода: &lt;code&gt;myvar=20&lt;/code&gt; и &lt;code&gt;myvar=10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d9ac26bea11358be0d1cbdd9e321d3ba6df33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Garbage Collection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вывоз мусора&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a1048de1a3b6080b858a1b2bef0918699edce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you want to know more continue reading below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если вы хотите узнать больше, продолжайте читать ниже&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9c088750dbff02fab5817dc280550e5285cea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is a teaching example intended to demonstrate the &lt;code&gt;var&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ.&lt;/strong&gt; Это обучающий пример, предназначенный для демонстрации поведения &lt;code&gt;var&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; в циклах и с замыканиями функций, которые также легко понять. Это был бы ужасный способ добавить цифры. Но общий метод сбора данных в анонимных замыканиях функций может встречаться в реальном мире в других контекстах. YMMV.</target>
        </trans-unit>
        <trans-unit id="9e6852a37a94e37e3dd905af9505c512854ba77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;При использовании &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fafd358dad99127a17812d83d6ef193969ca8ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;При использовании &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd31b31858145616de45d3f80da7fc9d141990c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Когда следует использовать over &lt;code&gt;var&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48515bd6359d686dcff1143b76e99f026ba355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;При использовании &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bff2ad0c04ac8dd4df0359c5f2b7c4f5886e344c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;При использовании &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="227b64041df706bf182aba5ae5ebd33a97ed7e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;let&lt;/strong&gt; allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the &lt;strong&gt;var&lt;/strong&gt; keyword, which defines a variable globally, or locally to an entire function regardless of block scope.</source>
          <target state="translated">Позволяет вам объявлять переменные, ограниченные по объему блоком, оператором или выражением, в котором они используются. Это отличается от ключевого слова &lt;strong&gt;var&lt;/strong&gt; , которое определяет переменную глобально или локально для всей функции независимо от области видимости блока.</target>
        </trans-unit>
        <trans-unit id="fab33e848b5ad8bcc20091c62c722cbb817e51ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var variables are global&lt;/strong&gt; and can be accessed basically everywhere, while &lt;strong&gt;let variables are not global&lt;/strong&gt; and only exist until a closing parenthesis kills them.</source>
          <target state="translated">&lt;strong&gt;Переменные var являются глобальными&lt;/strong&gt; и могут быть доступны практически везде, хотя &lt;strong&gt;пусть переменные не являются глобальными&lt;/strong&gt; и существуют только до тех пор, пока закрывающая скобка не убьет их.</target>
        </trans-unit>
        <trans-unit id="db1da9a09bc08d7f8e50d60ea6a55e8863b78c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;let&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;переменные с &lt;code&gt;let&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29624d341db7c739c0aa200fbd55251cca369e02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;var&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;переменные с переменной &lt;code&gt;var&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2946b23215e7bb86a85f078731e677392102c35a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Tested in Chrome and Firefox 50)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Проверено в Chrome и Firefox 50)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="aac30eb1359108b02f390fbbab8124c9183cc1f9" translate="yes" xml:space="preserve">
          <source>A general workaround is to wrap this in an anonymous function and pass &lt;code&gt;i&lt;/code&gt; as an argument. Such issues can also be avoided now by using &lt;code&gt;let&lt;/code&gt; instead &lt;code&gt;var&lt;/code&gt; as shown in the code below.</source>
          <target state="translated">Общий обходной путь - обернуть это в анонимную функцию и передать &lt;code&gt;i&lt;/code&gt; в качестве аргумента. Таких проблем можно также избежать, используя &lt;code&gt;let&lt;/code&gt; вместо &lt;code&gt;var&lt;/code&gt; , как показано в коде ниже.</target>
        </trans-unit>
        <trans-unit id="170078ca21bcbd02b1a827e5fbf53f3ea80c3232" translate="yes" xml:space="preserve">
          <source>A variable declared with &lt;code&gt;let&lt;/code&gt; in the global scope (which is code that is not in a function) doesn't get added as a property on the global &lt;code&gt;window&lt;/code&gt; object. For example (this code is in global scope):</source>
          <target state="translated">Переменная, объявленная с помощью &lt;code&gt;let&lt;/code&gt; в глобальной области видимости (то есть код, который отсутствует в функции), не добавляется в качестве свойства объекта глобального &lt;code&gt;window&lt;/code&gt; . Например (этот код находится в глобальной области видимости):</target>
        </trans-unit>
        <trans-unit id="5f3e410272543a521cf9f1d7d1742e67dea8dc1b" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;let&lt;/code&gt; statement is only known in &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;the block&lt;/strong&gt;&lt;/a&gt; it is defined in, from the moment it is defined onward. &lt;em&gt;(**)&lt;/em&gt;</source>
          <target state="translated">Переменная, определенная с помощью оператора &lt;code&gt;let&lt;/code&gt; , известна только в &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;том блоке, в котором&lt;/strong&gt;&lt;/a&gt; она определена, с момента ее определения. &lt;em&gt;(**)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09c9ab8e2032dd446f087702839d7b2ed4396ea6" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;var&lt;/code&gt; statement is known throughout &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; it is defined in, from the start of the function. &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">Переменная, определенная с помощью оператора &lt;code&gt;var&lt;/code&gt; , известна во всей &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;функции, в которой&lt;/strong&gt;&lt;/a&gt; она определена, с самого начала функции. &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab370464f56e00eeb5cfc62076a9464592135e2" translate="yes" xml:space="preserve">
          <source>Actually, Per @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;Both &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; are hoisted&lt;/a&gt;.</source>
          <target state="translated">На самом деле, Per @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;оба &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; подняты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c89fecc35a8d73707d226f6f0b6a82d6dab14eb" translate="yes" xml:space="preserve">
          <source>Also don't forget it's ECMA6 feature, so it's not fully supported yet, so it's better always transpiles it to ECMA5 using Babel etc... for more info about visit &lt;a href=&quot;https://babeljs.io&quot;&gt;babel website&lt;/a&gt;</source>
          <target state="translated">Также не забывайте, что это функция ECMA6, поэтому она еще не полностью поддерживается, поэтому лучше всегда переносить ее на ECMA5 с помощью Babel и т. Д. ... для получения дополнительной информации о посещении &lt;a href=&quot;https://babeljs.io&quot;&gt;веб-сайта babel&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">Кроме того,следует учитывать,что переменные в блочном пространстве не известны до их объявления,так как они не поднимаются.Вы также не имеете права передекларировать одну и ту же переменную в пределах одного и того же блока.Это делает блок-скопированные переменные менее склонными к ошибкам,чем глобальные или функционально скопированные переменные,которые поднимаются и не производят ошибок в случае множественных деклараций.</target>
        </trans-unit>
        <trans-unit id="1c17b26bc3e4c8d3adc5ae1acfc117828aa6be96" translate="yes" xml:space="preserve">
          <source>And, finally, when it comes to the Execution Context, variables defined with var will be attached to the 'this' object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.</source>
          <target state="translated">И,наконец,когда дело доходит до контекста выполнения,переменные,определенные с помощью var,будут прикреплены к объекту 'this'.В глобальном контексте выполнения,это будет объект окна в браузерах.Это не случай let или const.</target>
        </trans-unit>
        <trans-unit id="71e68652a5ed74f047c3ac12095f037358e5e5ec" translate="yes" xml:space="preserve">
          <source>Another difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is variables with declared with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't get hoisted&lt;/strong&gt;. An example is the best way to illustrate this behavior:</source>
          <target state="translated">Еще одно различие между &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; - переменные с объявленным с &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;, не поднимаются&lt;/strong&gt; . Пример - лучший способ проиллюстрировать это поведение:</target>
        </trans-unit>
        <trans-unit id="35c52610045a80e7c59b43f1379714d89e0d6bc4" translate="yes" xml:space="preserve">
          <source>As mentioned above:</source>
          <target state="translated">Как упоминалось выше:</target>
        </trans-unit>
        <trans-unit id="249700b45578552db048d92af8fa978c2eefd5b3" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;code&gt;var j&lt;/code&gt; variable is still having a value outside of the for loop scope (Block Scope), but the &lt;code&gt;let i&lt;/code&gt; variable is undefined outside of the for loop scope.</source>
          <target state="translated">Как видите, переменная &lt;code&gt;var j&lt;/code&gt; по-прежнему имеет значение вне области цикла for (Block Scope), но переменная &lt;code&gt;let i&lt;/code&gt; не определена вне области цикла for.</target>
        </trans-unit>
        <trans-unit id="d7def6645f985de2714bbee9073b7e35ce60ba9a" translate="yes" xml:space="preserve">
          <source>At the top level (outside of a function)</source>
          <target state="translated">На верхнем уровне (вне функции)</target>
        </trans-unit>
        <trans-unit id="d2da2ac1a0c2449a02f42f9a07db9b2ad3e838df" translate="yes" xml:space="preserve">
          <source>At the top level of programs and functions, &lt;strong&gt;let&lt;/strong&gt;, unlike &lt;strong&gt;var&lt;/strong&gt;, does not create a property on the global object. For example:</source>
          <target state="translated">На верхнем уровне программ и функций &lt;strong&gt;пусть&lt;/strong&gt; , в отличие от &lt;strong&gt;var&lt;/strong&gt; , не создается свойство глобального объекта. Например:</target>
        </trans-unit>
        <trans-unit id="71df1ae66b61d0ab2fcbac24f66a246ff268b703" translate="yes" xml:space="preserve">
          <source>At the top level, &lt;code&gt;let&lt;/code&gt;, unlike &lt;code&gt;var&lt;/code&gt;, does not create a property on the global object:</source>
          <target state="translated">На верхнем уровне &lt;code&gt;let&lt;/code&gt; , в отличие от &lt;code&gt;var&lt;/code&gt; , не создает свойства глобального объекта:</target>
        </trans-unit>
        <trans-unit id="eeb6d3d38965924988affed9792df84c51af2547" translate="yes" xml:space="preserve">
          <source>At the top level, variables declared using &lt;code&gt;let&lt;/code&gt; don't create properties on the global object.</source>
          <target state="translated">На верхнем уровне переменные, объявленные с помощью &lt;code&gt;let&lt;/code&gt; , не создают свойств для глобального объекта.</target>
        </trans-unit>
        <trans-unit id="515fa9e7c373ec2c33005604de0e7089c2d08190" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;let&lt;/code&gt; create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;let&lt;/code&gt; создадим новую лексическую среду с этими именами для а) выражения инициализатора б) каждой итерации (прежде всего для вычисления выражения приращения), &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;здесь&lt;/a&gt; есть больше подробностей.</target>
        </trans-unit>
        <trans-unit id="45b1a72deb4126ce6786cb6bf76705a80fcbb65a" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;the temporal dead zone&lt;/a&gt;, variables declared using &lt;code&gt;let&lt;/code&gt; can't be accessed before they are declared. Attempting to do so throws an error.</source>
          <target state="translated">Из-за &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;временной мертвой зоны&lt;/a&gt; переменные, объявленные с использованием &lt;code&gt;let&lt;/code&gt; , не могут быть доступны до их объявления. Попытка сделать это выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Блочный прицел</target>
        </trans-unit>
        <trans-unit id="e40b499735af8fc0820476d34a1c0c219c1fd209" translate="yes" xml:space="preserve">
          <source>Block scope of &lt;code&gt;let&lt;/code&gt; is useful relates to closures and garbage collection to reclaim memory. Consider,</source>
          <target state="translated">Область действия блока &lt;code&gt;let&lt;/code&gt; полезна, связана с замыканиями и сборкой мусора для освобождения памяти. Рассматривать,</target>
        </trans-unit>
        <trans-unit id="6f29a62d2c8cafbe524c685a3421672ea1015266" translate="yes" xml:space="preserve">
          <source>Code above demonstrates a classic JavaScript closure problem. Reference to the &lt;code&gt;i&lt;/code&gt; variable is being stored in the click handler closure, rather than the actual value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Код выше демонстрирует классическую проблему закрытия JavaScript. Ссылка на переменную &lt;code&gt;i&lt;/code&gt; хранится в закрытии обработчика щелчка, а не на фактическое значение &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5c12eac220cda3fddead583cc6b0243277fa9e" translate="yes" xml:space="preserve">
          <source>Consequently, &lt;code&gt;let&lt;/code&gt; variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.</source>
          <target state="translated">Следовательно, &lt;code&gt;let&lt;/code&gt; переменные с меньшей вероятностью будут вызывать проблемы при использовании в больших программах или когда независимо разработанные структуры объединяются новыми и неожиданными способами.</target>
        </trans-unit>
        <trans-unit id="f7261ea8dc8387f9126baa8bab22723bda98c65e" translate="yes" xml:space="preserve">
          <source>Creating global object property</source>
          <target state="translated">Создание глобального свойства объекта</target>
        </trans-unit>
        <trans-unit id="a994290f95e1773d69448109bc715c0ac56c270d" translate="yes" xml:space="preserve">
          <source>Don't let this happen to you. Use a linter.</source>
          <target state="translated">Не позволяй этому случиться с тобой.Используй подкладку.</target>
        </trans-unit>
        <trans-unit id="bff237a3f67a2949d7f6e1f89d92205c1c43fd88" translate="yes" xml:space="preserve">
          <source>During the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised.</source>
          <target state="translated">На этапе создания контекста выполнения var,let и const будет по-прежнему хранить свою переменную в памяти с неопределенным значением в переменной окружения данного контекста выполнения.Разница заключается в фазе выполнения.Если вы используете ссылку на переменную,определенную с помощью var до того,как ей присвоено значение,она будет просто неопределенной.Исключение не будет поднято.</target>
        </trans-unit>
        <trans-unit id="2b7177a34d2d0cacb674f1aac574068a765ae834" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;the &lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 6 представил &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;оператор &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cf86ea0199cf2cb7ab1e4b859d6da9f7e8d3b80" translate="yes" xml:space="preserve">
          <source>ES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.</source>
          <target state="translated">ES6 также вводит ключевое слово const для объявления переменных.const также является блоком scoped.Разница между allow и const заключается в том,что переменные const должны быть объявлены с помощью инициализатора,иначе это спровоцирует ошибку.</target>
        </trans-unit>
        <trans-unit id="15fdc50ddc49f97069f55a0d0f0fb021296b8c98" translate="yes" xml:space="preserve">
          <source>ES6 introduced two new keyword(&lt;strong&gt;let&lt;/strong&gt; and &lt;strong&gt;const&lt;/strong&gt;) alternate to &lt;strong&gt;var&lt;/strong&gt;.</source>
          <target state="translated">ES6 представил два новых ключевых слова ( &lt;strong&gt;let&lt;/strong&gt; и &lt;strong&gt;const&lt;/strong&gt; ), альтернативных &lt;strong&gt;var&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fe55c1d6e2b8dc0fe7f0925eac13a3c7b9627f4c" translate="yes" xml:space="preserve">
          <source>Every single click handler will refer to the same object because there&amp;rsquo;s only one counter object which holds 6 so you get six on each click.</source>
          <target state="translated">Каждый обработчик одного клика будет ссылаться на один и тот же объект, потому что есть только один встречный объект, который содержит 6, поэтому вы получаете шесть на каждый клик.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Актуальный обзор того, какие браузеры поддерживают оператор &lt;code&gt;let&lt;/code&gt; на момент прочтения этого ответа, см. &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt; &lt;code&gt;Can I Use&lt;/code&gt; странице &amp;laquo; Могу ли я использовать&amp;raquo;&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2bcc0766379cd75d853f8179072c502df585067" translate="yes" xml:space="preserve">
          <source>Function VS block scope:</source>
          <target state="translated">Функция VS блок область действия:</target>
        </trans-unit>
        <trans-unit id="44d7d3e4ae1a64d1cd2bf70aad9d679aa794df08" translate="yes" xml:space="preserve">
          <source>Getter and setter with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">Метод получения и установки с помощью &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ba873db511f120d8b04390f9365a000776baab4" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; doesn't get attached to &lt;code&gt;window&lt;/code&gt;:</source>
          <target state="translated">Глобальный &lt;code&gt;let&lt;/code&gt; не привязывается к &lt;code&gt;window&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f8c6d41af972292b69739e49d1923eaf7ba5d69" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; variables are not added to the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">Глобальные переменные &lt;code&gt;let&lt;/code&gt; не добавляются в объект глобального &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ef81d10d2ac6892f207cc0aa959a31a393eb97" translate="yes" xml:space="preserve">
          <source>Here is an example for the difference between the two (support just started for chrome):</source>
          <target state="translated">Вот пример разницы между ними (поддержка только что запущена для хрома):</target>
        </trans-unit>
        <trans-unit id="e80f82c5146fe3bdfce30d25078c548bf9fd7946" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;explanation of the &lt;code&gt;let&lt;/code&gt; keyword&lt;/a&gt; with some examples.</source>
          <target state="translated">Вот &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;объяснение ключевого слова &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; с некоторыми примерами.</target>
        </trans-unit>
        <trans-unit id="baf1aac8fe97893d9e8a5cc925df180108e841e0" translate="yes" xml:space="preserve">
          <source>Here's an example to add on to what others have already written. Suppose you want to make an array of functions, &lt;code&gt;adderFunctions&lt;/code&gt;, where each function takes a single Number argument and returns the sum of the argument and the function's index in the array. Trying to generate &lt;code&gt;adderFunctions&lt;/code&gt; with a loop using the &lt;code&gt;var&lt;/code&gt; keyword won't work the way someone might na&amp;iuml;vely expect:</source>
          <target state="translated">Вот пример, чтобы добавить к тому, что уже написали другие. Предположим, вы хотите создать массив функций &lt;code&gt;adderFunctions&lt;/code&gt; , где каждая функция принимает один аргумент Number и возвращает сумму аргумента и индекс функции в массиве. Попытка сгенерировать &lt;code&gt;adderFunctions&lt;/code&gt; с помощью цикла с использованием ключевого слова &lt;code&gt;var&lt;/code&gt; не будет работать так, как кто-то может наивно ожидать:</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">Здесь мы видим, что наша переменная &lt;code&gt;j&lt;/code&gt; известна только в первом цикле for, но не до и после. Тем не менее, наша переменная &lt;code&gt;i&lt;/code&gt; известна во всей функции.</target>
        </trans-unit>
        <trans-unit id="7bcaf634e9dbfa99922f815d7eb0b950882fbc2c" translate="yes" xml:space="preserve">
          <source>Hoisting</source>
          <target state="translated">Hoisting</target>
        </trans-unit>
        <trans-unit id="a4b770c91602cb7a14569eb1fadf17b154c46e1d" translate="yes" xml:space="preserve">
          <source>Hoisting is not supported using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">Подъем не поддерживается с помощью &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">Как отслеживать поддержку браузера</target>
        </trans-unit>
        <trans-unit id="02950dbbb2895580e2f47482bfdc271d60612939" translate="yes" xml:space="preserve">
          <source>However it's worth noting that &lt;code&gt;let&lt;/code&gt; is only a part of newer Javascript implementations and has varying degrees of &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;browser support&lt;/a&gt;.</source>
          <target state="translated">Однако стоит отметить, что &lt;code&gt;let&lt;/code&gt; является лишь частью более новых реализаций Javascript и имеет различную степень &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;поддержки браузера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a64dc9831d45af781fdad2758e3129f38608db33" translate="yes" xml:space="preserve">
          <source>However, replace &lt;code&gt;var&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Однако замените &lt;code&gt;var&lt;/code&gt; на &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1942516de816b1215bfb3f885b92dce215fe8c87" translate="yes" xml:space="preserve">
          <source>However, the block scope can make this huge data structure to garbage collected.</source>
          <target state="translated">Однако блок-объект может превратить эту огромную структуру данных в мусор.</target>
        </trans-unit>
        <trans-unit id="210d598d2aa5b2252eb617a5677124f67bcfd03e" translate="yes" xml:space="preserve">
          <source>However, we can try again using the &lt;code&gt;let&lt;/code&gt; keyword:</source>
          <target state="translated">Однако мы можем повторить попытку, используя ключевое слово &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a13c0910c0809caa265aa5d59b7303182a3e913" translate="yes" xml:space="preserve">
          <source>However, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:</source>
          <target state="translated">Однако,вы не можете ссылаться на переменную,объявленную с помощью allow или const,пока она не будет объявлена.Если вы попытаетесь использовать ее до того,как она будет объявлена,то исключение будет поднято во время фазы выполнения контекста выполнения.Теперь переменная все еще будет в памяти,благодаря фазе создания контекста выполнения,но движок не позволит вам ее использовать:</target>
        </trans-unit>
        <trans-unit id="73b04d7e63d97817ad43a04a297f8ccd6b791760" translate="yes" xml:space="preserve">
          <source>I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.</source>
          <target state="translated">Я думаю,что люди начнут использовать let после этого,так что у них будет такая же область применения JavaScript,как и у других языков,Java,C#,и т.д..</target>
        </trans-unit>
        <trans-unit id="60ed5394ff0a30a2c778db05382fc4f19f7dea8c" translate="yes" xml:space="preserve">
          <source>I think the terms and most of the examples are a bit overwhelming,
The main issue i had personally with the difference is understanding what a &quot;Block&quot; is.
At some point i realized, a block would be any curly brackets except for &lt;code&gt;IF&lt;/code&gt; statement.
an opening bracket &lt;code&gt;{&lt;/code&gt; of a function or loop will define a new block, anything defined with &lt;code&gt;let&lt;/code&gt; within it, will not be available after the closing bracket &lt;code&gt;}&lt;/code&gt; of the same thing (function or loop);
With that in mind, it was easier to understand:</source>
          <target state="translated">Я думаю, что термины и большинство примеров немного ошеломляют. Основная проблема, с которой я столкнулся лично, - это понимание, что такое &amp;laquo;Блок&amp;raquo;. В какой-то момент я понял, что блоком будут любые фигурные скобки, кроме оператора &lt;code&gt;IF&lt;/code&gt; . открывающая скобка &lt;code&gt;{&lt;/code&gt; функции или цикла определит новый блок, все, что определено с помощью &lt;code&gt;let&lt;/code&gt; внутри него, не будет доступно после закрывающей скобки &lt;code&gt;}&lt;/code&gt; того же самого элемента (функции или цикла); Имея это в виду, было легче понять:</target>
        </trans-unit>
        <trans-unit id="652bcdb1cb95ff704c8f7f92231e2c819a6a619e" translate="yes" xml:space="preserve">
          <source>I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment).</source>
          <target state="translated">Я хочу связать эти ключевые слова с Контекстом выполнения,потому что Контекст выполнения важен во всем этом.Контекст выполнения имеет две фазы:фазу создания и фазу выполнения.Кроме того,каждый контекст выполнения имеет переменное окружение и внешнее окружение (его лексическое окружение).</target>
        </trans-unit>
        <trans-unit id="347c3b7704d41b142c7558f9df8c366aaa5c3ca9" translate="yes" xml:space="preserve">
          <source>I've heard it that it's described as a &quot;local&quot; variable, but I'm still not quite sure how it behaves differently than the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">Я слышал, что она описывается как &amp;laquo;локальная&amp;raquo; переменная, но я все еще не совсем уверен, как она ведет себя иначе, чем ключевое слово &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a64f2d3dd931f8ac221f076d6aee461fa2e268f7" translate="yes" xml:space="preserve">
          <source>If I read the specs right then &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;thankfully&lt;/strong&gt; can also be leveraged to avoid &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;self invoking functions&lt;/a&gt; used to simulate private only members - &lt;em&gt;a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone's desire for semantics, so stop using it. /rant&lt;/em&gt;</source>
          <target state="translated">Если я читаю спецификации правильно, то, к &lt;strong&gt;счастью,&lt;/strong&gt; можно также использовать возможности, чтобы избежать &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;самовозвратных функций,&lt;/a&gt; используемых для имитации закрытых элементов - &lt;em&gt;популярный шаблон проектирования, который уменьшает читабельность кода, усложняет отладку, не добавляет никакой реальной защиты кода или других преимуществ - кроме, возможно, удовлетворительного чье-то желание семантики, так что прекратите его использовать.&lt;/em&gt; &lt;em&gt;/ напыщенная&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efbed4ca5ff07a30fe5d1a50e4502bdb347bc1c0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.</source>
          <target state="translated">Если вы используете в цикле &lt;code&gt;let&lt;/code&gt; вместо &lt;code&gt;var&lt;/code&gt; , с каждой итерацией вы получаете новую переменную. Это означает, что вы можете безопасно использовать замыкание внутри цикла.</target>
        </trans-unit>
        <trans-unit id="17145a9a9f46d1b105d7a4debb8d941ee248c402" translate="yes" xml:space="preserve">
          <source>If you want to have an immutable object, you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;&lt;code&gt;Object.freeze()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите иметь неизменный объект, вы должны использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt; &lt;code&gt;Object.freeze()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">Если вы пишете JavaScript-код на клиентской стороне и не используете транспайлер,то вам необходимо учесть поддержку браузера.</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">Если вы пишете код JavaScript на стороне клиента и используете транспортер на основе Node (например, &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;скрипт оболочки traceur&lt;/strong&gt;&lt;/a&gt; или &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; ), вы можете смело использовать оператор &lt;code&gt;let&lt;/code&gt; . А поскольку ваш браузер будет знать только о переданном коде, недостатки производительности должны быть ограничены.</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">Если вы пишете код JavaScript на стороне клиента и используете браузер-транспортер (например, &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; или &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; ), вы можете смело использовать оператор &lt;code&gt;let&lt;/code&gt; , однако ваш код, вероятно, будет не оптимальным с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">Если вы пишете код JavaScript на стороне сервера ( &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ), вы можете смело использовать оператор &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfc03d4531fe0bd76ba607e1e4e7d663c32df226" translate="yes" xml:space="preserve">
          <source>In JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">В JavaScript мы часто используем переменные значительно позже, чем когда они создаются. Когда мы продемонстрируем это путем задержки вывода с закрытием, переданным в &lt;code&gt;setTimeout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c9021c4e7876355e1fc36b9e227cb4de4425b66" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; parses and runs without throwing any exceptions.</source>
          <target state="translated">Напротив, тот же самый пример с &lt;code&gt;var&lt;/code&gt; анализирует и запускает без исключения.</target>
        </trans-unit>
        <trans-unit id="177519e8851b8c0bb348adf315a0cf3831599c1d" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; works.</source>
          <target state="translated">Напротив, тот же пример с &lt;code&gt;var&lt;/code&gt; работает.</target>
        </trans-unit>
        <trans-unit id="dc8dcbdd636f8cb50991ca75851fcac1be59e3c5" translate="yes" xml:space="preserve">
          <source>In my both examples I have a function &lt;code&gt;myfunc&lt;/code&gt;. &lt;code&gt;myfunc&lt;/code&gt; contains a variable &lt;code&gt;myvar&lt;/code&gt; equals to 10. 
In my first example  I check   if &lt;code&gt;myvar&lt;/code&gt; equals to 10 (&lt;code&gt;myvar==10&lt;/code&gt;) . If yes, I agian declare  a variable  &lt;code&gt;myvar&lt;/code&gt; (now I have two myvar variables)using &lt;code&gt;var&lt;/code&gt; keyword and assign it a new value (20). In next line I  print its value on my console.  After the conditional block I again print the value of &lt;code&gt;myvar&lt;/code&gt; on my console. If you look at the output of &lt;code&gt;myfunc&lt;/code&gt;,   &lt;code&gt;myvar&lt;/code&gt; has value equals to 20.</source>
          <target state="translated">В обоих моих примерах у меня есть функция &lt;code&gt;myfunc&lt;/code&gt; . &lt;code&gt;myfunc&lt;/code&gt; содержит переменную &lt;code&gt;myvar&lt;/code&gt; ,равную 10. В моем первом примере я проверяю, равно ли &lt;code&gt;myvar&lt;/code&gt; 10 ( &lt;code&gt;myvar==10&lt;/code&gt; ). Если да, я объявляю переменную &lt;code&gt;myvar&lt;/code&gt; (теперь у меня есть две переменные myvar), используя ключевое слово &lt;code&gt;var&lt;/code&gt; , и присваиваю ей новое значение (20). В следующей строке я печатаю его значение на моей консоли. После условного блока я снова печатаю значение &lt;code&gt;myvar&lt;/code&gt; на моей консоли. Если вы посмотрите на вывод &lt;code&gt;myfunc&lt;/code&gt; , &lt;code&gt;myvar&lt;/code&gt; имеет значение, равное 20.</target>
        </trans-unit>
        <trans-unit id="d3eb240300b8d3cf3894acb662d9d55b4c3eeb9c" translate="yes" xml:space="preserve">
          <source>In practice, there are a number of useful consequences of the difference in scope:</source>
          <target state="translated">На практике разница в масштабах имеет ряд полезных последствий:</target>
        </trans-unit>
        <trans-unit id="041cfe51d16fc06e7a90d0fdd25ff09d8de80054" translate="yes" xml:space="preserve">
          <source>In strict mode, &lt;code&gt;var&lt;/code&gt; will let you re-declare the same variable in the same scope while &lt;code&gt;let&lt;/code&gt; raises a SyntaxError.</source>
          <target state="translated">В строгом режиме &lt;code&gt;var&lt;/code&gt; позволит вам повторно объявить одну и ту же переменную в той же области, в то время как &lt;code&gt;let&lt;/code&gt; вызывает SyntaxError.</target>
        </trans-unit>
        <trans-unit id="deb3d336c8ca38ed2c8a72be4787d1e826efc9a7" translate="yes" xml:space="preserve">
          <source>Initializer is required</source>
          <target state="translated">Требуется инициализатор</target>
        </trans-unit>
        <trans-unit id="6d007cc06c89e6bed5f7c97dc75f829442633823" translate="yes" xml:space="preserve">
          <source>Inside a block</source>
          <target state="translated">Внутри блока</target>
        </trans-unit>
        <trans-unit id="d187aaa9dbe696be70ed4733de46de8f53018d1e" translate="yes" xml:space="preserve">
          <source>Inside a function</source>
          <target state="translated">Внутри функции</target>
        </trans-unit>
        <trans-unit id="6a19a43ce4368f97cd87fe72619ae5cd48410ed3" translate="yes" xml:space="preserve">
          <source>Inside a function (but outside of a block), &lt;code&gt;let&lt;/code&gt; has the same scope as &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Внутри функции (но вне блока) область &lt;code&gt;let&lt;/code&gt; имеет ту же область, что и &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31aad9d36743f490f94cc21d201edada256344c" translate="yes" xml:space="preserve">
          <source>Inside a loop</source>
          <target state="translated">Внутри петли</target>
        </trans-unit>
        <trans-unit id="5f706b419d5afb2010d5c584c5073222be04bf3b" translate="yes" xml:space="preserve">
          <source>Is it safe to use &lt;code&gt;let&lt;/code&gt; today?</source>
          <target state="translated">Безопасно ли использовать сегодня?</target>
        </trans-unit>
        <trans-unit id="2efd347d2f42601723d5af3a50c4b497df93e4c1" translate="yes" xml:space="preserve">
          <source>It also appears that, at least in Visual Studio 2015, TypeScript 1.5, &quot;var&quot; allows multiple declarations of the same variable name in a block, and &quot;let&quot; doesn't.</source>
          <target state="translated">Также оказывается,что,по крайней мере,в Visual Studio 2015,TypeScript 1.5,&quot;var&quot; позволяет несколько объявлений одного и того же имени переменной в блоке,а &quot;let&quot;-нет.</target>
        </trans-unit>
        <trans-unit id="5baa9813fadf06ec260f1610e850a5668ce5695e" translate="yes" xml:space="preserve">
          <source>Loops with closures</source>
          <target state="translated">Петли с затворами</target>
        </trans-unit>
        <trans-unit id="c0b7662f52c683b4a21a90043d995802030c5bd1" translate="yes" xml:space="preserve">
          <source>Main difference is scoping rules. Variables declared by &lt;code&gt;var&lt;/code&gt; keyword are scoped to the immediate function body (hence the function scope) while &lt;code&gt;let&lt;/code&gt; variables are scoped to the immediate &lt;em&gt;enclosing&lt;/em&gt; block denoted by &lt;code&gt;{ }&lt;/code&gt; (hence the block scope).</source>
          <target state="translated">Основное отличие заключается в правилах определения объема. Переменные, объявленные ключевым словом &lt;code&gt;var&lt;/code&gt; , попадают в область непосредственного тела функции (отсюда область действия функции), а переменные &lt;code&gt;let&lt;/code&gt; - в область непосредственного &lt;em&gt;включения,&lt;/em&gt; обозначенную &lt;code&gt;{ }&lt;/code&gt; (отсюда область действия блока).</target>
        </trans-unit>
        <trans-unit id="99fbe1720bf011da269b2cac5512d7c3963a6968" translate="yes" xml:space="preserve">
          <source>May the following two functions show the difference:</source>
          <target state="translated">Пусть следующие две функции покажут разницу:</target>
        </trans-unit>
        <trans-unit id="63a3dc65c2f80ebaced4b3a1a62910c1da24fc2b" translate="yes" xml:space="preserve">
          <source>No re-assigning</source>
          <target state="translated">Нет перепрофилирования</target>
        </trans-unit>
        <trans-unit id="39c7b7a1ef0ba49851ad5dfe7bd9144cb18d52c7" translate="yes" xml:space="preserve">
          <source>No re-declaring</source>
          <target state="translated">Никаких повторных деклараций</target>
        </trans-unit>
        <trans-unit id="39c9178c32e097fcac397a91d250592e73365258" translate="yes" xml:space="preserve">
          <source>Note that it doesn't mean that the value is immutable. Its properties still can be changed.</source>
          <target state="translated">Обратите внимание,что это не значит,что значение незыблемо.Его свойства все еще могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="f3a83e225fb411474c8b9361c4b05f98a38f3643" translate="yes" xml:space="preserve">
          <source>Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don't.</source>
          <target state="translated">Обратите внимание,что его поддерживают только браузеры Mozilla и Chrome.IE,Safari и,возможно,другие нет.</target>
        </trans-unit>
        <trans-unit id="96df0ec4b6def0a95acbbc1f79135059a56fd9f0" translate="yes" xml:space="preserve">
          <source>Now I think there is better scoping of variables to a block of statements using &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">Теперь я думаю, что есть лучшая область видимости переменных для блока операторов, использующего &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39076c4b7441e59ed2d91b8abe7ca8c4659cb0d2" translate="yes" xml:space="preserve">
          <source>Now, image mixing the two behaviors and you'll probably see why it's not recommended to mix the newer &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; with the older &lt;code&gt;var&lt;/code&gt; in the same script. Doing so can result is some spectacularly confusing code.</source>
          <target state="translated">Теперь смешайте два поведения, и вы, вероятно, поймете, почему не рекомендуется смешивать более новые &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; со старыми &lt;code&gt;var&lt;/code&gt; в одном и том же сценарии. Это может привести к некоторому удивительно запутанному коду.</target>
        </trans-unit>
        <trans-unit id="8c2795ed8b2631b7e1915cc52073b53be8af53e9" translate="yes" xml:space="preserve">
          <source>Only counts [0, 1].</source>
          <target state="translated">Считается только [0,1].</target>
        </trans-unit>
        <trans-unit id="efcf7de8b6bfc89725e070a6351b838be2c76f1b" translate="yes" xml:space="preserve">
          <source>People had to create immediately invoked functions to capture correct value from the loops but that was also hairy.</source>
          <target state="translated">Людям приходилось сразу же создавать вызываемые функции для захвата корректных значений из циклов,но это тоже было волосато.</target>
        </trans-unit>
        <trans-unit id="2f5f2be0ca83a657f2ffc3bfa218814a5981da32" translate="yes" xml:space="preserve">
          <source>People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.</source>
          <target state="translated">Люди с непонятным пониманием области применения JavaScript,которые раньше ошибались.</target>
        </trans-unit>
        <trans-unit id="285dc513fb5c7a7fc0e6eb93a0290e0641276542" translate="yes" xml:space="preserve">
          <source>Previously there were only two scopes in JavaScript, i.e. functional and global. With '&lt;code&gt;let&lt;/code&gt;' keyword JavaScript has now introduced &lt;code&gt;block-level&lt;/code&gt; variables.</source>
          <target state="translated">Ранее в JavaScript было только две области действия: функциональная и глобальная. С помощью ключевого слова &lt;code&gt;let&lt;/code&gt; в JavaScript появились переменные &lt;code&gt;block-level&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="25b58933661327228329508e8c2cf1090c0253a0" translate="yes" xml:space="preserve">
          <source>Refer to &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth: let and const&lt;/a&gt;&lt;/em&gt; to understand it better.</source>
          <target state="translated">Обратитесь к &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth: пусть и const,&lt;/a&gt;&lt;/em&gt; чтобы понять это лучше.</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">Основные положения</target>
        </trans-unit>
        <trans-unit id="382bd8420b6d01443a65704ab49145af79643941" translate="yes" xml:space="preserve">
          <source>See '&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Emulating private interfaces&lt;/a&gt;'</source>
          <target state="translated">Смотрите &amp;laquo; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Эмуляция частных интерфейсов&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9199fa6dee3c3db69201fd546b73324ee92bb5fc" translate="yes" xml:space="preserve">
          <source>See my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.</source>
          <target state="translated">Смотрите мой пример ниже,и обратите внимание на то,как переменная lion (let)действует по-разному в двух консольных логах;она выходит из-под контроля во 2-м консольном лог-файле.</target>
        </trans-unit>
        <trans-unit id="ce14680b0e5afa36020ec40b287ff3cdba706e04" translate="yes" xml:space="preserve">
          <source>So the difference is very simple i.e its scope.</source>
          <target state="translated">Так что разница очень проста,т.е.ее масштабы.</target>
        </trans-unit>
        <trans-unit id="38c778b9cbefb5fbaad00a515fa6b89ce13a738d" translate="yes" xml:space="preserve">
          <source>Some hacks with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">Некоторые взломы с &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="789fd33b37de1fced25ba88ee426bb6b49dcd4f3" translate="yes" xml:space="preserve">
          <source>Some people would argue that in the future we'll ONLY use let statements and that var statements will become obsolete. JavaScript guru &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Kyle Simpson&lt;/strong&gt;&lt;/a&gt; wrote &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;a very elaborate article on why he believes that won't be the case&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Некоторые люди утверждают, что в будущем мы будем использовать ТОЛЬКО операторы let, а операторы var станут устаревшими. Гуру JavaScript &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Кайл Симпсон&lt;/strong&gt;&lt;/a&gt; написал &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;очень сложную статью о том, почему он считает, что это не так&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33a132a545bee29b8dcb5ddcc302b7c8534a609b" translate="yes" xml:space="preserve">
          <source>Specifically, this outputs:</source>
          <target state="translated">В частности,это выходит:</target>
        </trans-unit>
        <trans-unit id="c20042f3ec22b168b4441982da162a8418abc98a" translate="yes" xml:space="preserve">
          <source>Take a look at this example from &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;another stackoverflow question&lt;/a&gt;:</source>
          <target state="translated">Взгляните на этот пример из &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;другого вопроса stackoverflow&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d2a5704984a4447527354be4a00cc8b22ced40f5" translate="yes" xml:space="preserve">
          <source>Temporal dead zone</source>
          <target state="translated">Временно мертвая зона</target>
        </trans-unit>
        <trans-unit id="a6c1c3dc63d914749b6854d3ab11a3b569eada69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;click&lt;/code&gt; handler callback does not need the &lt;code&gt;hugeData&lt;/code&gt; variable at all. Theoretically, after &lt;code&gt;process(..)&lt;/code&gt; runs, the huge data structure &lt;code&gt;hugeData&lt;/code&gt; could be garbage collected. However, it's possible that some JS engine will still have to keep this huge structure, since the &lt;code&gt;click&lt;/code&gt; function has a closure over the entire scope.</source>
          <target state="translated">&lt;code&gt;hugeData&lt;/code&gt; обработчика щелчков вообще не нужна переменная largeData . Теоретически, после &lt;code&gt;hugeData&lt;/code&gt; &lt;code&gt;process(..)&lt;/code&gt; огромная структура данных огромный_данных может быть собрана сборщиком мусора. Тем не менее, возможно, что некоторый движок JS все еще должен будет сохранять эту огромную структуру, поскольку функция &lt;code&gt;click&lt;/code&gt; имеет замыкание по всей области видимости.</target>
        </trans-unit>
        <trans-unit id="264885cd88282bf28a8225c70ff7599f6d3df455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gfoo&lt;/code&gt;, defined by &lt;code&gt;let&lt;/code&gt; initially is in the &lt;strong&gt;global scope&lt;/strong&gt;, and when we declare &lt;code&gt;gfoo&lt;/code&gt; again inside the &lt;code&gt;if clause&lt;/code&gt; its &lt;strong&gt;&lt;em&gt;scope changed&lt;/em&gt;&lt;/strong&gt; and when a new value is assigned to the variable inside that scope it &lt;strong&gt;does not affect&lt;/strong&gt; the global scope.</source>
          <target state="translated">&lt;code&gt;gfoo&lt;/code&gt; , определенный с помощью &lt;code&gt;let&lt;/code&gt; initial , находится в &lt;strong&gt;глобальной области видимости&lt;/strong&gt; , и когда мы снова объявляем &lt;code&gt;gfoo&lt;/code&gt; в &lt;code&gt;if clause&lt;/code&gt; его &lt;strong&gt;&lt;em&gt;область видоизменяется,&lt;/em&gt;&lt;/strong&gt; и когда новое значение присваивается переменной внутри этой области видимости, это &lt;strong&gt;не влияет&lt;/strong&gt; на глобальную область видимости.</target>
        </trans-unit>
        <trans-unit id="87b7ba6b84d1c61150fc37bf6a8f3727f5c2d5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword attaches the variable declaration to the scope of whatever block (commonly a &lt;code&gt;{ .. }&lt;/code&gt; pair) it's contained in. In other words,&lt;code&gt;let&lt;/code&gt; implicitly hijacks any block's scope for its variable declaration.</source>
          <target state="translated">Ключевое слово &lt;code&gt;let&lt;/code&gt; присоединяет объявление переменной к области действия любого блока (обычно пары &lt;code&gt;{ .. }&lt;/code&gt; ), в котором он содержится. Другими словами, &lt;code&gt;let&lt;/code&gt; неявно перехватывает область действия любого блока для его объявления переменной.</target>
        </trans-unit>
        <trans-unit id="78af92108bc96e8a42084047aaf363842f3b377a" translate="yes" xml:space="preserve">
          <source>The accepted answer is missing a point:</source>
          <target state="translated">Принятый ответ не имеет смысла:</target>
        </trans-unit>
        <trans-unit id="073b339db7edb1c2e2e81ea60ac755f69153f037" translate="yes" xml:space="preserve">
          <source>The below shows how 'let' and 'var' are different in the scope:</source>
          <target state="translated">Ниже показано,как 'let' и 'var' различаются в области видимости:</target>
        </trans-unit>
        <trans-unit id="4d9ba873fd7a30468256474a7c4d6e16988d829d" translate="yes" xml:space="preserve">
          <source>The below table summarize the difference between var, let and const</source>
          <target state="translated">В нижеследующей таблице приведена краткая информация о разнице между var,let и const</target>
        </trans-unit>
        <trans-unit id="00a031e0941465964589ed342dbcebaa59ee6085" translate="yes" xml:space="preserve">
          <source>The difference is in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;scope&lt;/a&gt; of the variables declared with each.</source>
          <target state="translated">Разница заключается в &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;объеме&lt;/a&gt; переменных, объявленных с каждой.</target>
        </trans-unit>
        <trans-unit id="58bbbdd4908ae3e2d249c1fbdc5b3f5b43c376b1" translate="yes" xml:space="preserve">
          <source>The difference is scoping. &lt;code&gt;var&lt;/code&gt; is scoped to the nearest &lt;strong&gt;function
  block&lt;/strong&gt; and &lt;code&gt;let&lt;/code&gt; is scoped to the &lt;strong&gt;nearest enclosing block&lt;/strong&gt;, which
  can be smaller than a function block. Both are global if outside any
  block.Lets see an example:</source>
          <target state="translated">Разница в том, &lt;code&gt;var&lt;/code&gt; ограничен ближайшим &lt;strong&gt;функциональным блоком,&lt;/strong&gt; а &lt;code&gt;let&lt;/code&gt; ограничен &lt;strong&gt;ближайшим включающим блоком&lt;/strong&gt; , который может быть меньше функционального блока. Оба являются глобальными, если находятся вне какого-либо блока. Давайте посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="a2047a53cae852bc9bd4d5726d86bf1abdab5907" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is that variables declared with &lt;code&gt;var&lt;/code&gt; are &lt;strong&gt;function scoped&lt;/strong&gt;. Whereas functions declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt;. For example:</source>
          <target state="translated">Основное различие между &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; заключается в том, что переменные, объявленные с помощью &lt;code&gt;var&lt;/code&gt; , являются &lt;strong&gt;областью видимости функции&lt;/strong&gt; . В то время как функции, объявленные с помощью &lt;code&gt;let&lt;/code&gt; , имеют &lt;strong&gt;область видимости&lt;/strong&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8d162e4b209b454c9dcdb65956e1046635e203a9" translate="yes" xml:space="preserve">
          <source>The main difference is the &lt;strong&gt;scope&lt;/strong&gt; difference, while &lt;strong&gt;let&lt;/strong&gt; can be only available inside the &lt;strong&gt;scope&lt;/strong&gt; it's declared, like in for loop, &lt;strong&gt;var&lt;/strong&gt; can be accessed outside the loop for example. From the documentation in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (examples also from MDN):</source>
          <target state="translated">Основным отличием является различие в &lt;strong&gt;объеме&lt;/strong&gt; , хотя &lt;strong&gt;let&lt;/strong&gt; может быть доступен только внутри объявленной области, как, например, в цикле for, к &lt;strong&gt;var&lt;/strong&gt; можно получить доступ, например, вне цикла. Из документации в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (примеры также из MDN):</target>
        </trans-unit>
        <trans-unit id="9f7f9f1e0a48709104afca6e8067da28df678148" translate="yes" xml:space="preserve">
          <source>The process above doesn't generate the desired array of functions because &lt;code&gt;i&lt;/code&gt;'s scope extends beyond the iteration of the &lt;code&gt;for&lt;/code&gt; block in which each function was created. Instead, at the end of the loop, the &lt;code&gt;i&lt;/code&gt; in each function's closure refers to &lt;code&gt;i&lt;/code&gt;'s value at the end of the loop (1000) for every anonymous function in &lt;code&gt;adderFunctions&lt;/code&gt;. This isn't what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of &lt;code&gt;i&lt;/code&gt;, the mutation will affect all the &lt;code&gt;adderFunctions&lt;/code&gt;.</source>
          <target state="translated">Процесс выше не генерирует желаемый массив функций, потому что область действия &lt;code&gt;i&lt;/code&gt; выходит за рамки итерации блока &lt;code&gt;for&lt;/code&gt; , в котором была создана каждая функция. Вместо этого в конце цикла &lt;code&gt;i&lt;/code&gt; в закрытии каждой функции ссылается на значение &lt;code&gt;i&lt;/code&gt; в конце цикла (1000) для каждой анонимной функции в &lt;code&gt;adderFunctions&lt;/code&gt; . Это совсем не то, что мы хотели: у нас теперь есть массив из 1000 различных функций в памяти с точно таким же поведением. И если мы впоследствии обновим значение &lt;code&gt;i&lt;/code&gt; , мутация повлияет на все функции &lt;code&gt;adderFunctions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3451295aef647a9eb92f4f38d933a0e2d080e7e1" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;let&lt;/code&gt; keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.</source>
          <target state="translated">Причина, по которой ключевое слово &lt;code&gt;let&lt;/code&gt; было введено в язык, заключалась в том, что область действия функций сбивает с толку и является одним из основных источников ошибок в JavaScript.</target>
        </trans-unit>
        <trans-unit id="11b109d5b87133e7c9f78aaa1557423809cb31f7" translate="yes" xml:space="preserve">
          <source>The restrictions imposed by &lt;code&gt;let&lt;/code&gt; reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;reachability&lt;/a&gt;(helping with reclaiming unused memory).</source>
          <target state="translated">Ограничения, налагаемые &lt;code&gt;let&lt;/code&gt; , уменьшают видимость переменных и увеличивают вероятность того, что неожиданные конфликты имен будут обнаружены на ранней стадии. Это облегчает отслеживание и анализ переменных, включая их &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;достижимость&lt;/a&gt; (помогая восстановить неиспользуемую память).</target>
        </trans-unit>
        <trans-unit id="e0d2bb460f6b296bc8aef7ab3dd6effc0df6f796" translate="yes" xml:space="preserve">
          <source>The second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.</source>
          <target state="translated">Второй особенностью пусть будет то,что она вводит блок-объект.Блоки определяются фигурными скобками.Примеры включают в себя функциональные блоки,если блоки,то для блоков и т.д.Когда вы объявляете переменную,имеющую пустую строку внутри блока,переменная доступна только внутри блока.Фактически,каждый раз,когда блок выполняется,например,внутри цикла for,он будет создавать новую переменную в памяти.</target>
        </trans-unit>
        <trans-unit id="f0009b35b2bce48e37552dc2d483b1c142ec7b1e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences &amp;mdash; &lt;code&gt;let&lt;/code&gt; scoping behaves more like variable scoping does in more or less any other languages.</source>
          <target state="translated">Есть некоторые тонкие различия - &lt;code&gt;let&lt;/code&gt; видимости ведет себя больше как переменная область видимости в более или менее любых других языках.</target>
        </trans-unit>
        <trans-unit id="582e7ce54a6962d9d96e460cfe6b27fdb7eed8a5" translate="yes" xml:space="preserve">
          <source>There are still some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">Есть еще некоторые браузеры, которые вообще не поддерживают &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4ee4cc384a25d5e3ddde3e6500df25636cdfd4ce" translate="yes" xml:space="preserve">
          <source>This article clearly defines the difference between var, let and const</source>
          <target state="translated">Эта статья четко определяет разницу между var,let и const</target>
        </trans-unit>
        <trans-unit id="556d5253d7e385c3f1d2c5b84329a06bb16d69f7" translate="yes" xml:space="preserve">
          <source>This block of code will throw a &lt;code&gt;ReferenceError&lt;/code&gt; before the code can be run because &lt;code&gt;x&lt;/code&gt; is used before it is declared:</source>
          <target state="translated">Этот блок кода выдаст &lt;code&gt;ReferenceError&lt;/code&gt; до того, как код может быть запущен, потому что &lt;code&gt;x&lt;/code&gt; используется до его объявления:</target>
        </trans-unit>
        <trans-unit id="25d7860a8b2663b86949e7ca85dafff841362dba" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;let&lt;/code&gt;, for every loop iteration the variable is scoped and has its own copy.</source>
          <target state="translated">Это связано с тем, что при использовании &lt;code&gt;let&lt;/code&gt; для каждой итерации цикла переменная находится в области видимости и имеет свою собственную копию.</target>
        </trans-unit>
        <trans-unit id="1edd9ce9f172dbb4d4b3887bc51fb5cf6e0bb712" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;var&lt;/code&gt;, for every loop iteration the variable is scoped and has shared copy.</source>
          <target state="translated">Это связано с тем, что при использовании &lt;code&gt;var&lt;/code&gt; для каждой итерации цикла переменная находится в области видимости и имеет общую копию.</target>
        </trans-unit>
        <trans-unit id="a216ad59073ea6bd11a79ebc083a96139dca03f7" translate="yes" xml:space="preserve">
          <source>This time, &lt;code&gt;i&lt;/code&gt; is rebound on each iteration of the &lt;code&gt;for&lt;/code&gt; loop. Each function now keeps the value of &lt;code&gt;i&lt;/code&gt; at the time of the function's creation, and &lt;code&gt;adderFunctions&lt;/code&gt; behaves as expected.</source>
          <target state="translated">На этот раз &lt;code&gt;i&lt;/code&gt; возвращаюсь на каждой итерации цикла &lt;code&gt;for&lt;/code&gt; . Каждая функция теперь сохраняет значение &lt;code&gt;i&lt;/code&gt; во время ее создания, а &lt;code&gt;adderFunctions&lt;/code&gt; работает так, как ожидается.</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">Это будет:</target>
        </trans-unit>
        <trans-unit id="5dd7645a6d40c190e66e82b7ca6d2962889cfe89" translate="yes" xml:space="preserve">
          <source>This won't generate a compile error:</source>
          <target state="translated">Это не спровоцирует ошибку компиляции:</target>
        </trans-unit>
        <trans-unit id="d36477f33831b971d8bfc3e95c1e4d91bef92cb1" translate="yes" xml:space="preserve">
          <source>To have a complete understanding of the 'let' keyword, &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;
ES6: &amp;lsquo;let&amp;rsquo; keyword to declare variable in JavaScript&lt;/a&gt;&lt;/em&gt; will help.</source>
          <target state="translated">Чтобы получить полное представление о ключевом слове let, &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;поможет&lt;/a&gt;&lt;/em&gt; ключевое слово &lt;em&gt;ES6: let для объявления переменной в JavaScript&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="798cc826b7c6eca17f20ac9967ed751d475d3bfa" translate="yes" xml:space="preserve">
          <source>To understand the difference, consider the following code:</source>
          <target state="translated">Чтобы понять разницу,рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="b6b18d3db48c6c605af5cb1ff84864472fd83e2a" translate="yes" xml:space="preserve">
          <source>Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it's safe to use the &lt;code&gt;let&lt;/code&gt; statement. The answer to that question depends on your environment:</source>
          <target state="translated">Сегодня, однако, это определенно не так. На самом деле нам нужно спросить себя, безопасно ли использовать оператор &lt;code&gt;let&lt;/code&gt; . Ответ на этот вопрос зависит от вашей среды:</target>
        </trans-unit>
        <trans-unit id="cf0bd12b27a5d6ae801ae06ca45ff4d909c5e11f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. &lt;code&gt;var&lt;/code&gt; can be used when you want a global variable explicitly to be on the &lt;code&gt;window&lt;/code&gt; object (always consider carefully if this is really necessary).</source>
          <target state="translated">Используйте &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; всякий раз, когда можете, потому что это просто более определенная область. Это уменьшает потенциальные конфликты именования, которые могут возникнуть при работе с большим количеством переменных. &lt;code&gt;var&lt;/code&gt; можно использовать, если вы хотите, чтобы глобальная переменная явно находилась в объекте &lt;code&gt;window&lt;/code&gt; (всегда тщательно продумывайте, действительно ли это необходимо).</target>
        </trans-unit>
        <trans-unit id="447b7b7549292e2e8a35c8c418af427a8697661b" translate="yes" xml:space="preserve">
          <source>Variable declared using &lt;code&gt;const&lt;/code&gt; can't be re-assigned.</source>
          <target state="translated">Переменная, объявленная с использованием &lt;code&gt;const&lt;/code&gt; , не может быть переназначена.</target>
        </trans-unit>
        <trans-unit id="ea2f7a7e35f707d8856cdb8cb5665c534077fffb" translate="yes" xml:space="preserve">
          <source>Variables declared by &lt;strong&gt;let&lt;/strong&gt; have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, &lt;strong&gt;let&lt;/strong&gt; works very much like &lt;strong&gt;var&lt;/strong&gt;. The main difference is that the scope of a &lt;strong&gt;var&lt;/strong&gt; variable is the entire enclosing function:</source>
          <target state="translated">Переменные, объявленные с помощью &lt;strong&gt;let,&lt;/strong&gt; имеют в качестве области действия блок, в котором они определены, а также в любых вложенных субблоках. Таким образом, &lt;strong&gt;пусть&lt;/strong&gt; работает очень похоже на &lt;strong&gt;var&lt;/strong&gt; . Основное отличие состоит в том, что область действия переменной &lt;strong&gt;var&lt;/strong&gt; - это вся включающая функция:</target>
        </trans-unit>
        <trans-unit id="ac8b214aec9424ef9fffbc10e806c9b68d0341c2" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;let&lt;/code&gt; inside a block can't be accessed outside that block.</source>
          <target state="translated">Переменные, объявленные с использованием &lt;code&gt;let&lt;/code&gt; внутри блока, не могут быть доступны вне этого блока.</target>
        </trans-unit>
        <trans-unit id="2b32e0f62bb42b1453a0aa34a0c6ccac71e925fd" translate="yes" xml:space="preserve">
          <source>Variables declared using the &lt;code&gt;let&lt;/code&gt; keyword are block-scoped, which means that they are available only in the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;block&lt;/a&gt; in which they were declared.</source>
          <target state="translated">Переменные, объявленные с использованием ключевого слова &lt;code&gt;let&lt;/code&gt; , имеют вид блока, что означает, что они доступны только в &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;блоке,&lt;/a&gt; в котором они были объявлены.</target>
        </trans-unit>
        <trans-unit id="86c41ca6962411581269ba19972206be437465f2" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;let&lt;/code&gt; in loops can be referenced only inside that loop.</source>
          <target state="translated">На переменные, объявленные с помощью циклов &lt;code&gt;let&lt;/code&gt; in, можно ссылаться только внутри этого цикла.</target>
        </trans-unit>
        <trans-unit id="b328fafa53d71ac4b0917bba556f26a497d46ea3" translate="yes" xml:space="preserve">
          <source>What are the differences? When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">В чем различия? Когда следует использовать over &lt;code&gt;var&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="62485fc832e025ecfaffbb9e9fa16598e466214c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">В чем разница между &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;var&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="ba36ff7094458ce1f2d89aff408961ca118f85f3" translate="yes" xml:space="preserve">
          <source>What's the difference between using “let” and “var”</source>
          <target state="translated">В чем разница между использованием &quot;let&quot; и &quot;var&quot;.</target>
        </trans-unit>
        <trans-unit id="b646d47d71c5ed2befdf512e42079703b478e4c5" translate="yes" xml:space="preserve">
          <source>When the first function &lt;code&gt;testVar&lt;/code&gt; gets called the variable foo, declared with &lt;code&gt;var&lt;/code&gt;, is still accessible outside the &lt;code&gt;if&lt;/code&gt; statement. This variable &lt;code&gt;foo&lt;/code&gt; would be available &lt;strong&gt;everywhere&lt;/strong&gt; within the scope of the &lt;code&gt;testVar&lt;/code&gt;&lt;strong&gt;function&lt;/strong&gt;.</source>
          <target state="translated">Когда первая функция &lt;code&gt;testVar&lt;/code&gt; вызывается, переменная foo, объявленная с помощью &lt;code&gt;var&lt;/code&gt; , все еще доступна вне оператора &lt;code&gt;if&lt;/code&gt; . Эта переменная &lt;code&gt;foo&lt;/code&gt; будет доступна &lt;strong&gt;везде&lt;/strong&gt; в рамках &lt;strong&gt;функции&lt;/strong&gt; &lt;code&gt;testVar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d1e9bfedfc5565d2a134910beb552ddd3db5af" translate="yes" xml:space="preserve">
          <source>When the second function &lt;code&gt;testLet&lt;/code&gt; gets called the variable bar, declared with &lt;code&gt;let&lt;/code&gt;, is only accessible inside the &lt;code&gt;if&lt;/code&gt; statement. Because variables declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt; (where a block is the code between curly brackets e.g &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt;, &lt;code&gt;function{}&lt;/code&gt;).</source>
          <target state="translated">Когда &lt;code&gt;testLet&lt;/code&gt; вторая функция testLet, переменная bar, объявленная с помощью &lt;code&gt;let&lt;/code&gt; , становится доступной только внутри оператора &lt;code&gt;if&lt;/code&gt; . Поскольку переменные, объявленные с помощью &lt;code&gt;let&lt;/code&gt; , имеют &lt;strong&gt;область видимости блока&lt;/strong&gt; (где блок - это код в фигурных скобках, например, &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt; , &lt;code&gt;function{}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763c20e32aedaf10fa2547617925238345016332" translate="yes" xml:space="preserve">
          <source>When used inside a block, let limits the variable's scope to that block. Note the difference between &lt;strong&gt;var&lt;/strong&gt; whose scope is inside the function where it is declared.</source>
          <target state="translated">При использовании внутри блока let ограничивает область действия переменной этим блоком. Обратите внимание на разницу между &lt;strong&gt;var&lt;/strong&gt; , область действия которого находится внутри функции, в которой она объявлена.</target>
        </trans-unit>
        <trans-unit id="61cd92a023d0a31f010a274ec7d86e10c5421fb8" translate="yes" xml:space="preserve">
          <source>When you need a block level deceleration you can go with let and const
  instead of var.</source>
          <target state="translated">Когда вам нужно замедление уровня блока,вы можете использовать let и const вместо var.</target>
        </trans-unit>
        <trans-unit id="6a368a87210137edc166a614258cbe6102456562" translate="yes" xml:space="preserve">
          <source>Whereas</source>
          <target state="translated">Whereas</target>
        </trans-unit>
        <trans-unit id="0fe1d7ee87c3a04d0ac51238b917cc2c9c89c5d5" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;hfoo&lt;/code&gt;, defined by &lt;code&gt;var&lt;/code&gt; is initially in the &lt;strong&gt;global scope&lt;/strong&gt;, but again when we declare it inside the &lt;code&gt;if clause&lt;/code&gt;, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference.</source>
          <target state="translated">Принимая во внимание, что &lt;code&gt;hfoo&lt;/code&gt; , определенный &lt;code&gt;var&lt;/code&gt; , изначально находится в &lt;strong&gt;глобальной области видимости&lt;/strong&gt; , но, опять же, когда мы объявляем его внутри предложения &lt;code&gt;if clause&lt;/code&gt; , он рассматривает глобальную область действия hfoo, хотя var снова использовался для его объявления. И когда мы переназначаем его значение, мы видим, что глобальная область действия hfoo также затронута. Это основная разница.</target>
        </trans-unit>
        <trans-unit id="e3e6995ec39780a0e837123289821ba1329d357a" translate="yes" xml:space="preserve">
          <source>Which results in counting [0, 7].</source>
          <target state="translated">Что приводит к счету [0,7].</target>
        </trans-unit>
        <trans-unit id="3708d68bf42f4db9fe994838852e9983033235ad" translate="yes" xml:space="preserve">
          <source>While variables declared with &lt;code&gt;var&lt;/code&gt; keyword are &quot;hoisted&quot; to the top of the block which means they are accessible in their enclosing scope even before they are declared:</source>
          <target state="translated">В то время как переменные, объявленные с ключевым словом &lt;code&gt;var&lt;/code&gt; , &amp;laquo;подняты&amp;raquo; в верхнюю часть блока, что означает, что они доступны в своей области охвата даже до того, как они объявлены:</target>
        </trans-unit>
        <trans-unit id="b0b01fae36659f37d265b081743cc0dc35597443" translate="yes" xml:space="preserve">
          <source>With a variable defined with var, if the Engine cannot find the variable in the current Execution Context's Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment's Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const.</source>
          <target state="translated">С переменной,определенной с помощью var,если движок не может найти переменную в текущем окружении переменной контекста выполнения,то он пойдет вверх по цепочке scope (Внешнее окружение)и проверит для переменной Внешнее окружение переменной.Если он не может найти ее там,то продолжит поиск в Scope Chain.Это не так в случае с Allow и const.</target>
        </trans-unit>
        <trans-unit id="627826fe97bef52b6bbf6053deb38913659b0bdd" translate="yes" xml:space="preserve">
          <source>With this approach errors present in JavaScript are getting removed.</source>
          <target state="translated">При таком подходе ошибки,присутствующие в JavaScript,удаляются.</target>
        </trans-unit>
        <trans-unit id="c3c2f48f1eb008d449f48eb15990b4f6e424e20b" translate="yes" xml:space="preserve">
          <source>You always must specify a value when declaring a variable using &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">Вы всегда должны указывать значение при объявлении переменной с помощью &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0790cbb95ab5ec73d3e6258998a0a7ad3095843b" translate="yes" xml:space="preserve">
          <source>You can't declare the same variable multiple times using &lt;code&gt;let&lt;/code&gt;. You also can't declare a variable using &lt;code&gt;let&lt;/code&gt; with the same identifier as another variable which was declared using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Вы не можете объявить одну и ту же переменную несколько раз, используя &lt;code&gt;let&lt;/code&gt; . Вы также не можете объявить переменную, используя &lt;code&gt;let&lt;/code&gt; с тем же идентификатором, что и другая переменная, которая была объявлена ​​с помощью &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2fce063a96f03a5121674374be0af6b8b24bce2" translate="yes" xml:space="preserve">
          <source>e.g. It scopes to the enclosing block, They don't exist before they're declared, etc.</source>
          <target state="translated">Например,он охватывает ограждающий блок,их не существует до объявления,и т.д.</target>
        </trans-unit>
        <trans-unit id="d313532c8abb336dd50ad99fcaa46af296c26e1d" translate="yes" xml:space="preserve">
          <source>let is a part of es6. These functions will explain the difference in easy way.</source>
          <target state="translated">давайте будем частью 6-го сезона.Эти функции легко объяснят разницу.</target>
        </trans-unit>
        <trans-unit id="c0ef6b5ab2d1b894e89fcae400b0537fb9a8b5ce" translate="yes" xml:space="preserve">
          <source>let vs var. It's all about &lt;strong&gt;scope&lt;/strong&gt;.</source>
          <target state="translated">пусть против вар. Все дело в &lt;strong&gt;сфере&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c278d52dd0385cbf90b767810934740d91018546" translate="yes" xml:space="preserve">
          <source>one of the most famous interview questions on scope also can suffice the exact use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; as below;</source>
          <target state="translated">один из самых известных вопросов об интервью также может быть достаточным для точного использования &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;var&lt;/code&gt; , как показано ниже;</target>
        </trans-unit>
        <trans-unit id="2d408aaa5a340d732402a346a7f915ed8a3d8a04" translate="yes" xml:space="preserve">
          <source>test.js</source>
          <target state="translated">test.js</target>
        </trans-unit>
        <trans-unit id="b8ffef03491342b55d430f0b8e5920b4a84fcdb6" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't&lt;/strong&gt; get hoisted:</source>
          <target state="translated">переменные с &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;not&lt;/strong&gt; получить:</target>
        </trans-unit>
        <trans-unit id="c588190991c2844f3923ec38efe295f544b19b2e" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;do&lt;/strong&gt; get hoisted:</source>
          <target state="translated">Переменные с переменной &lt;strong&gt;действительно&lt;/strong&gt; поднимаются:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
