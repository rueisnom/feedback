<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1887097">
    <body>
      <group id="1887097">
        <trans-unit id="784ca4d89f40759259eb634137d78b2eb572edaf" translate="yes" xml:space="preserve">
          <source>(Background: I have some experience implementing C and C++ compilers.)</source>
          <target state="translated">(Antecedentes:Tengo cierta experiencia en la implementación de compiladores C y C++.)</target>
        </trans-unit>
        <trans-unit id="bd9ef556311be517a525bb3524ed59007934b5f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof x&lt;/code&gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a &lt;code&gt;sizeof&lt;/code&gt;-expression at runtime.</source>
          <target state="translated">&lt;code&gt;sizeof x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no es siempre una constante de tiempo de compilaci&amp;oacute;n; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el compilador a veces debe generar c&amp;oacute;digo para evaluar un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; expresi&amp;oacute;n en tiempo de ejecuci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7dd54a911c89231a7841010f0dc0907da5aa8a08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update: It did not make it into C++14.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Actualizaci&amp;oacute;n: no lleg&amp;oacute; a C ++ 14.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7eff072167bda04c186c36234a3426822f1ecf7" translate="yes" xml:space="preserve">
          <source>A good blog post that hits many of these same points is &lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&quot;Legitimate Use of Variable Length Arrays&quot;&lt;/a&gt; (Chris Wellons, 2019-10-27).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una buena publicaci&amp;oacute;n de blog que alcanza muchos de estos mismos puntos es &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Uso leg&amp;iacute;timo de matrices de longitud variable&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (Chris Wellons, 2019-10-27).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10d6a21bb53b190c7591942063680aa1e2b5e04" translate="yes" xml:space="preserve">
          <source>Allowing two-dimensional VLAs (&lt;code&gt;int A[x][y]&lt;/code&gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Permitir VLA bidimensionales ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[x][y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) requiri&amp;oacute; una nueva sintaxis para declarar funciones que toman VLA 2D como par&amp;aacute;metros: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0df2d17c8e3e4ce8e39e408df55ebd969517f123" translate="yes" xml:space="preserve">
          <source>Apparently in &lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;C99&lt;/a&gt; the following syntax is valid:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aparentemente en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la siguiente sintaxis es v&amp;aacute;lida:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f54311051e5aef26e0c96d5f655fda12ee6e7f5" translate="yes" xml:space="preserve">
          <source>Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).</source>
          <target state="translated">Matrices como ésta son parte de C99,pero no del estándar C++.Como otros han dicho,un vector siempre es una solución mucho mejor,que es probablemente la razón por la que las matrices de tamaño variable no están en el estándar C++(o en el propuesto C++0x).</target>
        </trans-unit>
        <trans-unit id="06b95a46628b5fa3ceb1519d192f271c27836750" translate="yes" xml:space="preserve">
          <source>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (&lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; or &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully &lt;em&gt;this&lt;/em&gt; answer gives you a good idea of why C99-style VLAs were &lt;strong&gt;not&lt;/strong&gt; a good fit for C++ &amp;mdash; and not really even a good fit for C99. ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como todos los dem&amp;aacute;s respondedores ya lo han se&amp;ntilde;alado, C ++ proporciona muchos mecanismos de asignaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: unique_ptr &amp;lt;int []&amp;gt; A = new int [n];&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; siendo el obvias) cuando realmente quiere transmitir la idea &quot;No tengo idea de la cantidad de RAM que podr&amp;iacute;a necesitar&quot;. Y C ++ proporciona un ingenioso modelo de manejo de excepciones para lidiar con la situaci&amp;oacute;n inevitable de que la cantidad de RAM que necesita es mayor que la cantidad de RAM que tiene. Pero es de esperar que &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;esta&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; respuesta le d&amp;eacute; una buena idea de por qu&amp;eacute; los VLA de estilo C99 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no se&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ajustaban bien a C ++, y ni siquiera se ajustaban bien a C99. ;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4409ffad589b749dae53fad479eb3a17e0038fa" translate="yes" xml:space="preserve">
          <source>BTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;comp.std.c++&lt;/a&gt; is the place to go to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por cierto, para preguntas sobre &quot;por qu&amp;eacute;&quot; el est&amp;aacute;ndar C ++ es como es, el grupo de noticias moderado Usenet &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comp.std.c ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es el lugar al que debe dirigirse.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a620acbc347ecec3c138d2d3ca0dbed0284b793a" translate="yes" xml:space="preserve">
          <source>Basically, C++ is moving in the direction of pushing more and more decisions into &lt;em&gt;compile-time&lt;/em&gt;: template code generation, &lt;code&gt;constexpr&lt;/code&gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally &lt;em&gt;compile-time&lt;/em&gt; decisions (e.g. &lt;code&gt;sizeof&lt;/code&gt;) into the &lt;em&gt;runtime&lt;/em&gt;. With this in mind, does it really even make sense to expend any effort &lt;em&gt;trying&lt;/em&gt; to integrate C99-style VLAs into C++?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B&amp;aacute;sicamente, C ++ se mueve en la direcci&amp;oacute;n de empujar m&amp;aacute;s y m&amp;aacute;s decisiones en &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo de compilaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : generaci&amp;oacute;n de c&amp;oacute;digo de plantilla, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;evaluaci&amp;oacute;n de la funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , etc. Mientras tanto, C99 estaba ocupado empujando &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;decisiones de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo de compilaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tradicionalmente &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(por ejemplo, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) en el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo de ejecuci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Con esto en mente, &amp;iquest;realmente tiene sentido gastar alg&amp;uacute;n esfuerzo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tratando&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de integrar VLA de estilo C99 en C ++?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5380f57134755717cd1c2a14e436a8f87d84912f" translate="yes" xml:space="preserve">
          <source>Being allocated on the stack implies that it will automatically be freed when the stack unwinds.</source>
          <target state="translated">Estar asignado en la pila implica que se liberará automáticamente cuando la pila se desenrolle.</target>
        </trans-unit>
        <trans-unit id="3b6e50a6540998dfdf1bd5337908c87ec9472523" translate="yes" xml:space="preserve">
          <source>C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for &lt;code&gt;new&lt;/code&gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the &lt;code&gt;new&lt;/code&gt; operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los CLA VLA podr&amp;iacute;an proporcionar un peque&amp;ntilde;o beneficio al poder crear arreglos peque&amp;ntilde;os sin desperdiciar espacio o llamar a los constructores para elementos no utilizados, pero introducir&amp;aacute;n cambios bastante grandes en el sistema de tipos (debe poder especificar tipos dependiendo de los valores de tiempo de ejecuci&amp;oacute;n) a&amp;uacute;n no existe en C ++ actual, a excepci&amp;oacute;n de los &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; especificadores de tipo de operador, pero se tratan especialmente, de modo que el tiempo de ejecuci&amp;oacute;n no escapa al alcance del &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; operador).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be03536da2738f7ab85762b2cd2586b270bc45b5" translate="yes" xml:space="preserve">
          <source>C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.</source>
          <target state="translated">El C99 permite el VLA.Y pone algunas restricciones sobre cómo declarar el VLA.Para más detalles,consulte el 6.7.5.2 de la norma.C++no permite el AVA.Pero g++lo permite.</target>
        </trans-unit>
        <trans-unit id="ff06bf861788256153b9aa642197bf2b5cc9e3d4" translate="yes" xml:space="preserve">
          <source>Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.</source>
          <target state="translated">Editar:Se puede crear un vector que utilice un asignador de pila (allocate),ya que el asignador es un parámetro de plantilla.</target>
        </trans-unit>
        <trans-unit id="f5bf5e1a7099d677043a8233206392681c482fe3" translate="yes" xml:space="preserve">
          <source>For more on the topic, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;N3810 &quot;Alternatives for Array Extensions&quot;&lt;/a&gt;, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish &lt;em&gt;syntax&lt;/em&gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el tema, consulte &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810 &quot;Alternativas para extensiones de matriz&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , documento de Bjarne Stroustrup de octubre de 2013 sobre VLA. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El punto de vista de Bjarne es muy diferente al m&amp;iacute;o; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810 se centra m&amp;aacute;s en encontrar una buena &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sintaxis&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ish de C ++ &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para las cosas y en desalentar el uso de matrices en bruto en C ++, mientras que me concentr&amp;eacute; m&amp;aacute;s en las implicaciones para la metaprogramaci&amp;oacute;n y el sistema de tipos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No s&amp;eacute; si considera las implicaciones de metaprogramaci&amp;oacute;n / sistema de tipos resueltas, solucionables o simplemente sin inter&amp;eacute;s.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb2d1834d43cb060504a5afff92b3f0a0bed81ab" translate="yes" xml:space="preserve">
          <source>Functionality can be emulated with other C++ constructs</source>
          <target state="translated">La funcionalidad puede ser emulada con otras construcciones de C++</target>
        </trans-unit>
        <trans-unit id="68da06e3377221e5de796920784d7792915f6b43" translate="yes" xml:space="preserve">
          <source>Hairy for compiler vendors to implement</source>
          <target state="translated">Peludo para que los vendedores de compiladores lo implementen</target>
        </trans-unit>
        <trans-unit id="482371147860afa9336450d7edcf30d7034eb677" translate="yes" xml:space="preserve">
          <source>I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good. The argument is, if you know the size beforehand, you can use a static array. And if you don't know the size beforehand, you will write unsafe code.</source>
          <target state="translated">Estoy de acuerdo con las personas que parecen estar de acuerdo en que tener que crear un gran conjunto potencial en la pila,que por lo general tiene poco espacio disponible,no es bueno.El argumento es que,si conoces el tamaño de antemano,puedes usar una matriz estática.Y si no sabes el tamaño de antemano,escribirás un código inseguro.</target>
        </trans-unit>
        <trans-unit id="2a5812f28b35bcb48f76c49d410771ce71507939" translate="yes" xml:space="preserve">
          <source>I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).</source>
          <target state="translated">Tengo una solución que realmente me funcionó.No quería asignar memoria por la fragmentación en una rutina que debía ejecutarse muchas veces.La respuesta es extremadamente peligrosa,así que úsala bajo tu propio riesgo,pero aprovecha el ensamblaje para reservar espacio en la pila.Mi ejemplo a continuación utiliza un ensamblaje de caracteres (obviamente otra variable de tamaño requeriría más memoria).</target>
        </trans-unit>
        <trans-unit id="b6d7e46d378f04d1801a2f622b99ad73ae0868e1" translate="yes" xml:space="preserve">
          <source>I haven't used C very much in the last few years. When I read &lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;this question&lt;/a&gt; today I came across some C syntax which I wasn't familiar with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No he usado mucho C en los &amp;uacute;ltimos a&amp;ntilde;os. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando le&amp;iacute; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;esta pregunta&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hoy me encontr&amp;eacute; con una sintaxis de C con la que no estaba familiarizado.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e816f117cd47a20e41b1c7e0c81387cbf2ad034" translate="yes" xml:space="preserve">
          <source>I think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I'm working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.</source>
          <target state="translated">Creo que el C++es tan inseguro en sí mismo que el argumento de &quot;tratar de no añadir más características inseguras&quot; no es muy fuerte.Por otro lado,como C++es posiblemente la característica más eficiente del lenguaje de programación en tiempo de ejecución,lo que lo hace más útil siempre:La gente que escribe programas de rendimiento crítico usará en gran medida C++,y necesita el mayor rendimiento posible.Mover cosas del montón a la pila es una de esas posibilidades.Reducir el número de bloques de heap es otra.Permitir a los VLA como miembros del objeto sería una forma de lograrlo.Estoy trabajando en tal sugerencia.Es un poco complicada de implementar,es cierto,pero parece bastante factible.</target>
        </trans-unit>
        <trans-unit id="40cb19fb71abfcdc362b9ffad13d776256923c2a" translate="yes" xml:space="preserve">
          <source>I'm not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn't standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It's been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.</source>
          <target state="translated">No estoy diciendo que nunca sea necesario empujar buffers de tamaño variable en la pila de la cpu.Honestamente me sorprendí cuando descubrí que esto no era estándar,ya que ciertamente parece que el concepto encaja lo suficientemente bien en el lenguaje.Para mí,sin embargo,los requisitos de &quot;tamaño variable&quot; y &quot;deben estar físicamente ubicados en la pila de la computadora personal&quot; nunca se han unido.Se trata de la velocidad,así que hice mi propia especie de &quot;pila paralela para los búferes de datos&quot;.</target>
        </trans-unit>
        <trans-unit id="806120e29434febd69a611cfa95daf050d1eb4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; weren't a compile-time constant (i.e., if &lt;code&gt;A&lt;/code&gt; were of variably modified type), then what on earth would be the type of &lt;code&gt;S&lt;/code&gt;? Would &lt;code&gt;S&lt;/code&gt;'s type &lt;em&gt;also&lt;/em&gt; be determined only at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no fuera una constante de tiempo de compilaci&amp;oacute;n (es decir, si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; fuera de tipo variable), &amp;iquest;cu&amp;aacute;l ser&amp;iacute;a el tipo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El tipo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tambi&amp;eacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se determinar&amp;iacute;a solo en tiempo de ejecuci&amp;oacute;n?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cadc77c8df74681009ecd04756ffc8902be079f" translate="yes" xml:space="preserve">
          <source>If you know the value at compile time you can do the following:</source>
          <target state="translated">Si conoces el valor en el momento de la compilación puedes hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="25cbd3dd21b283ae2f9d4eaa0a15a55aaabe20ce" translate="yes" xml:space="preserve">
          <source>In my own work, I've realized that every time I've wanted something like variable-length automatic arrays or alloca(), I didn't really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn't incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.</source>
          <target state="translated">En mi propio trabajo,me he dado cuenta de que cada vez que he querido algo como los arreglos automáticos de longitud variable o alloca(),no me importaba que la memoria estuviera físicamente ubicada en la pila de la cpu,sólo que viniera de algún asignador de la pila que no incurriera en viajes lentos al montón general.Así que tengo un objeto por hilo que posee alguna memoria desde la que puede empujar búferes de tamaño variable.En algunas plataformas permito que esto crezca vía mmu.Otras plataformas tienen un tamaño fijo (normalmente acompañado de una pila de cpu de tamaño fijo también porque no hay mmu).Una plataforma con la que trabajo (una consola de juegos portátil)tiene muy poca pila de cpu de todos modos porque reside en una memoria escasa y rápida.</target>
        </trans-unit>
        <trans-unit id="dd33745a32bdd5211fb2c5127b3c9b5f90a18898" translate="yes" xml:space="preserve">
          <source>Incompatible with some other part of the standard</source>
          <target state="translated">Incompatible con alguna otra parte del estándar</target>
        </trans-unit>
        <trans-unit id="5ac82eedd3f1200472c3eaba3833822cef86f433" translate="yes" xml:space="preserve">
          <source>It would be less useful in C++ anyway since we already have &lt;code&gt;std::vector&lt;/code&gt; to fill this role.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ser&amp;iacute;a menos &amp;uacute;til en C ++ de todos modos ya que ya tenemos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para cumplir este rol.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1581697271897ae6f955195983b3d11f133f2094" translate="yes" xml:space="preserve">
          <source>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an &lt;em&gt;arbitrarily large&lt;/em&gt; chunk of your stack. This is a &lt;em&gt;guaranteed&lt;/em&gt; stack-overflow and crash. (Anytime you declare &lt;code&gt;int A[n]&lt;/code&gt;, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;&lt;code&gt;n&lt;/code&gt; is definitely less than 1000 here&quot;, then you would just declare &lt;code&gt;int A[1000]&lt;/code&gt;. Substituting the 32-bit integer &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;1000&lt;/code&gt; is an admission that you have no idea what the behavior of your program ought to be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Menos importante en el mundo de C ++, pero extremadamente importante para el p&amp;uacute;blico objetivo de programadores de sistemas integrados de C, declarar un VLA significa cortar una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;porci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;arbitrariamente grande&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de su pila. Este es un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;desbordamiento de pila y un bloqueo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;garantizados&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . (Cada vez que declara &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , est&amp;aacute; afirmando impl&amp;iacute;citamente que tiene 2GB de pila de sobra. Despu&amp;eacute;s de todo, si sabe que &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es definitivamente menos de 1000 aqu&amp;iacute;&quot;, entonces simplemente declarar&amp;iacute;a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[1000]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Sustituir el n&amp;uacute;mero entero de 32 bits &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; por &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es admitir que no tiene idea de cu&amp;aacute;l deber&amp;iacute;a ser el comportamiento de su programa).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee478ffe7976d42688d8d55133a37aa8d78e1076" translate="yes" xml:space="preserve">
          <source>Looking at the discussion at &lt;code&gt;comp.std.c++&lt;/code&gt; it's clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It's certainly not obvious that a &lt;code&gt;std::vector&lt;/code&gt; is always a better solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mirando la discusi&amp;oacute;n en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;comp.std.c++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , est&amp;aacute; claro que esta pregunta es bastante controvertida con algunos nombres muy pesados ​​en ambos lados del argumento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ciertamente no es obvio que un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; siempre es una mejor soluci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d23541f85918fecd18aed7850a8f1c9c8290f19" translate="yes" xml:space="preserve">
          <source>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does&amp;hellip; but we've really started to rely on it in ways that C has not. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bien, pasemos ahora a hablar de C ++. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En C ++, tenemos la misma fuerte distinci&amp;oacute;n entre &quot;sistema de tipos&quot; y &quot;sistema de valores&quot; que C89 ... pero realmente hemos comenzado a confiar en &amp;eacute;l de formas que C no tiene. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ca739bf4aeb3b4982657bdd41b8fe9da6e94f45" translate="yes" xml:space="preserve">
          <source>Quick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.</source>
          <target state="translated">Nota rápida:Como se menciona en la página del hombre de Mac OS X para alloca(3),&quot;La función alloca()depende de la máquina y del compilador;se desaconseja su uso&quot;.Para que lo sepas.</target>
        </trans-unit>
        <trans-unit id="0e01ae80eca7726229f2af01f30f85a0011eb6a9" translate="yes" xml:space="preserve">
          <source>Seems it will be available in C++14:</source>
          <target state="translated">Parece que estará disponible en C++14:</target>
        </trans-unit>
        <trans-unit id="78b81ae2a7303fc5a23e553399b0905f9a785f46" translate="yes" xml:space="preserve">
          <source>Some potential reasons:</source>
          <target state="translated">Algunas razones potenciales:</target>
        </trans-unit>
        <trans-unit id="50eaf2461e5452bc32e18c3f4b245aeca3694981" translate="yes" xml:space="preserve">
          <source>The C++ standard states that array size must be a constant expression (8.3.4.1).</source>
          <target state="translated">La norma C++establece que el tamaño del conjunto debe ser una expresión constante (8.3.4.1).</target>
        </trans-unit>
        <trans-unit id="655fdfc4e1350fd04dedffef0af28d6ff24f2e3e" translate="yes" xml:space="preserve">
          <source>The compiler must generate code for some instantiation of &lt;code&gt;myfunc&lt;/code&gt;. What should that code look like? How can we statically generate that code, if we don't know the type of &lt;code&gt;A1&lt;/code&gt; at compile time?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El compilador debe generar c&amp;oacute;digo para alguna instanciaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo deber&amp;iacute;a ser ese c&amp;oacute;digo? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo podemos generar est&amp;aacute;ticamente ese c&amp;oacute;digo, si no conocemos el tipo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en tiempo de compilaci&amp;oacute;n?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="847c10687fcd80e916d369da37b004d639c21542" translate="yes" xml:space="preserve">
          <source>The dangers here are many but I'll explain a few:
1. Changing the variable size half way through would kill the stack position
2. Overstepping the array bounds would destroy other variables and possible code
3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).
4. Compiler specific (may have trouble moving between compilers).  I haven't tried so I really don't know.</source>
          <target state="translated">Los peligros aquí son muchos,pero explicaré algunos:1.Cambiar el tamaño variable a mitad de camino mataría la posición de la pila 2.Si se sobrepasan los límites de la matriz,se destruirían otras variables y el posible código 3.Esto no funciona en una construcción de 64 bits...se necesita un ensamblaje diferente para esa (pero una macro podría resolver ese problema).4.Específico del compilador (puede tener problemas para moverse entre compiladores).No lo he intentado así que realmente no lo sé.</target>
        </trans-unit>
        <trans-unit id="ffdfec5bfb16136c85636bab88bfef33b85826e8" translate="yes" xml:space="preserve">
          <source>The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.</source>
          <target state="translated">La memoria será asignada en el montón,pero esto tiene sólo un pequeño inconveniente de rendimiento.Además,es prudente no asignar grandes bloques de datos en la pila,ya que es bastante limitada en tamaño.</target>
        </trans-unit>
        <trans-unit id="69ed5f106cde9304603393d4b69ea6fbaecdca3c" translate="yes" xml:space="preserve">
          <source>The slices, rows and columns will also potentially be spread all over memory.</source>
          <target state="translated">Las rebanadas,filas y columnas también se extenderán potencialmente por toda la memoria.</target>
        </trans-unit>
        <trans-unit id="75337abd29d36b2aeb6bdec77608f4f9ddbc9d82" translate="yes" xml:space="preserve">
          <source>There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.</source>
          <target state="translated">Hay situaciones en las que la asignación de memoria de pila es muy costosa en comparación con las operaciones realizadas.Un ejemplo es la matemática matricial.Si trabajas con matrices pequeñas,digamos de 5 a 10 elementos,y haces mucha aritmética,la sobrecarga de malloc será realmente significativa.Al mismo tiempo,hacer que el tamaño sea una constante de tiempo de compilación parece muy derrochador e inflexible.</target>
        </trans-unit>
        <trans-unit id="2d9540c95adf01bfe96108186fa43c95f4aed84b" translate="yes" xml:space="preserve">
          <source>There recently was a discussion about this kicked off in usenet: &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;Why no VLAs in C++0x&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Recientemente se discuti&amp;oacute; sobre esto en usenet: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Por qu&amp;eacute; no hay VLA en C ++ 0x&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="420e9d809f5e55e35af61e0458dc9062b1a84947" translate="yes" xml:space="preserve">
          <source>This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?</source>
          <target state="translated">Esto parece ser una característica bastante útil.¿Hubo alguna vez una discusión acerca de agregarlo al estándar C++,y si es así,por qué se omitió?</target>
        </trans-unit>
        <trans-unit id="3681bd7c879cf246e529cb1459aabbd71d7929c7" translate="yes" xml:space="preserve">
          <source>This was considered for inclusion in C++/1x, &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;but was dropped&lt;/a&gt; (this is a correction to what I said earlier).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se consider&amp;oacute; para su inclusi&amp;oacute;n en C ++ / 1x, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pero se descart&amp;oacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (esto es una correcci&amp;oacute;n de lo que dije anteriormente).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c5efb0ed4cfdb41bfe29546748a6ee08ea79f76" translate="yes" xml:space="preserve">
          <source>Use std::vector for this. For example:</source>
          <target state="translated">Use std::vector para esto.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4dc64eaed80a49209b7212897182856b464ff4d2" translate="yes" xml:space="preserve">
          <source>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</source>
          <target state="translated">Los arreglos de longitud variable en el C99 fueron básicamente un error.Para poder soportar los VLA,el C99 tuvo que hacer las siguientes concesiones al sentido común:</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">¿Qué hay de esto?</target>
        </trans-unit>
        <trans-unit id="57a287a958e4cca4d33101677876891076290e24" translate="yes" xml:space="preserve">
          <source>Why aren't variable-length arrays part of the C++ standard</source>
          <target state="translated">¿Por qué los arreglos de longitud variable no son parte del estándar C++</target>
        </trans-unit>
        <trans-unit id="fbf2b06494f2d7238597a77fef7d9a9871f70987" translate="yes" xml:space="preserve">
          <source>Worse, what if it turns out at runtime that &lt;code&gt;n1 != n2&lt;/code&gt;, so that &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt;? In that case, the call to &lt;code&gt;myfunc&lt;/code&gt;&lt;strong&gt;shouldn't even compile&lt;/strong&gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Peor a&amp;uacute;n, &amp;iquest;qu&amp;eacute; pasa si en tiempo de ejecuci&amp;oacute;n resulta que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n1 != n2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , de modo que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? En ese caso, la llamada a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ni siquiera deber&amp;iacute;a compilarse&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &amp;iexcl;porque la deducci&amp;oacute;n del tipo de plantilla deber&amp;iacute;a fallar! &amp;iquest;C&amp;oacute;mo podr&amp;iacute;amos emular ese comportamiento en tiempo de ejecuci&amp;oacute;n?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c57bc85dabed67fd51c3d2de29053b72562c2e1" translate="yes" xml:space="preserve">
          <source>Yes, of course I realize that in the toy example one could use &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;S&amp;iacute;, por supuesto, me doy cuenta de que en el ejemplo del juguete uno podr&amp;iacute;a usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, pero esto asigna memoria del mont&amp;oacute;n y no de la pila. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y si quiero una matriz multidimensional como:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0835518093c390c7915b0891f2f795ec06ad215" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;std::vector&lt;/code&gt;, but it is not quite the same, as it uses dynamic memory, and making it use one's own stack-allocator isn't exactly easy (alignment is an issue, too). It also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;C++ Dynamic Array&lt;/a&gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it's not going to be part of C++0x, as far as I know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero no es exactamente lo mismo, ya que usa memoria din&amp;aacute;mica, y hacer que use el propio asignador de pila no es exactamente f&amp;aacute;cil (la alineaci&amp;oacute;n tambi&amp;eacute;n es un problema). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tampoco resuelve el mismo problema, porque un vector es un contenedor redimensionable, mientras que los VLA son de tama&amp;ntilde;o fijo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La propuesta de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ Dynamic Array&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene la intenci&amp;oacute;n de introducir una soluci&amp;oacute;n basada en biblioteca, como alternativa a un VLA basado en lenguaje. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, no ser&amp;aacute; parte de C ++ 0x, que yo sepa.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee49e1beb61b1f02cbef2c02b8330c97d6649909" translate="yes" xml:space="preserve">
          <source>You could always use alloca() to allocate memory on the stack at runtime, if you wished:</source>
          <target state="translated">Siempre puedes usar alloca()para asignar memoria en la pila en tiempo de ejecución,si lo deseas:</target>
        </trans-unit>
        <trans-unit id="bf51f2d5a13b6be238f5a5ebdba02e8e898f9f44" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;vector&lt;/code&gt; version becomes pretty clumsy:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;versi&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; ial se&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; vuelve bastante torpe:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
