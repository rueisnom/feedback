<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1887097">
    <body>
      <group id="1887097">
        <trans-unit id="784ca4d89f40759259eb634137d78b2eb572edaf" translate="yes" xml:space="preserve">
          <source>(Background: I have some experience implementing C and C++ compilers.)</source>
          <target state="translated">(Справочная информация:У меня есть некоторый опыт применения компиляторов Си и Си++).</target>
        </trans-unit>
        <trans-unit id="bd9ef556311be517a525bb3524ed59007934b5f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof x&lt;/code&gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a &lt;code&gt;sizeof&lt;/code&gt;-expression at runtime.</source>
          <target state="translated">&lt;code&gt;sizeof x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше не всегда является константой времени компиляции; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;компилятор должен иногда генерировать код, чтобы оценить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выражения во время выполнения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7dd54a911c89231a7841010f0dc0907da5aa8a08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update: It did not make it into C++14.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обновление: это не сделало это в C ++ 14.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7eff072167bda04c186c36234a3426822f1ecf7" translate="yes" xml:space="preserve">
          <source>A good blog post that hits many of these same points is &lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&quot;Legitimate Use of Variable Length Arrays&quot;&lt;/a&gt; (Chris Wellons, 2019-10-27).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хорошим постом в блоге, который затрагивает многие из этих пунктов, является &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Законное использование массивов переменной длины&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (Chris Wellons, 2019-10-27).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10d6a21bb53b190c7591942063680aa1e2b5e04" translate="yes" xml:space="preserve">
          <source>Allowing two-dimensional VLAs (&lt;code&gt;int A[x][y]&lt;/code&gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Разрешение двумерных VLA ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[x][y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) требовало нового синтаксиса для объявления функций, которые принимают 2D VLA в качестве параметров: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0df2d17c8e3e4ce8e39e408df55ebd969517f123" translate="yes" xml:space="preserve">
          <source>Apparently in &lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;C99&lt;/a&gt; the following syntax is valid:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Видимо в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; действует следующий синтаксис:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f54311051e5aef26e0c96d5f655fda12ee6e7f5" translate="yes" xml:space="preserve">
          <source>Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).</source>
          <target state="translated">Массивы,подобные этому,являются частью С99,но не входят в стандартный С++.Как говорили другие,вектор всегда является гораздо лучшим решением,поэтому,вероятно,массивы переменного размера не входят в стандарт С++(или в предлагаемый стандарт С++0x).</target>
        </trans-unit>
        <trans-unit id="06b95a46628b5fa3ceb1519d192f271c27836750" translate="yes" xml:space="preserve">
          <source>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (&lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; or &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully &lt;em&gt;this&lt;/em&gt; answer gives you a good idea of why C99-style VLAs were &lt;strong&gt;not&lt;/strong&gt; a good fit for C++ &amp;mdash; and not really even a good fit for C99. ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как любой другой отвечающему уже отмечалось, C ++ предоставляет множество механизмов кучного распределения ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; являющийся очевидные), когда вы действительно хотите передать идею &amp;laquo;я понятия не имею, сколько ОЗУ мне может понадобиться&amp;raquo;. А C ++ предоставляет изящную модель обработки исключений для работы с неизбежной ситуацией, когда объем необходимой вам оперативной памяти больше, чем у вас. Но, надеюсь, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этот&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ответ дает вам хорошее представление о том, почему VLA в стиле C99 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; очень подходят для C ++ - и даже не совсем подходят для C99. ;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4409ffad589b749dae53fad479eb3a17e0038fa" translate="yes" xml:space="preserve">
          <source>BTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;comp.std.c++&lt;/a&gt; is the place to go to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кстати, для вопросов о том, &amp;laquo;почему&amp;raquo; стандарт C ++ такой, какой есть, модерируемая группа новостей Usenet &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comp.std.c ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это то место, куда можно обратиться.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a620acbc347ecec3c138d2d3ca0dbed0284b793a" translate="yes" xml:space="preserve">
          <source>Basically, C++ is moving in the direction of pushing more and more decisions into &lt;em&gt;compile-time&lt;/em&gt;: template code generation, &lt;code&gt;constexpr&lt;/code&gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally &lt;em&gt;compile-time&lt;/em&gt; decisions (e.g. &lt;code&gt;sizeof&lt;/code&gt;) into the &lt;em&gt;runtime&lt;/em&gt;. With this in mind, does it really even make sense to expend any effort &lt;em&gt;trying&lt;/em&gt; to integrate C99-style VLAs into C++?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По сути, C ++ движется в направлении внедрения все большего количества решений во время &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;компиляции&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : генерация кода шаблона, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; функции &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constexpr&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и так далее. Тем временем C99 был занят внедрением традиционных &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;решений &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;времени компиляции&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) во время &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;выполнения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Имея это в виду, действительно ли он даже имеет &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;смысл затрачивать никаких усилий , &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пытаясь&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; интегрировать Власа C99 стиле в C ++?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5380f57134755717cd1c2a14e436a8f87d84912f" translate="yes" xml:space="preserve">
          <source>Being allocated on the stack implies that it will automatically be freed when the stack unwinds.</source>
          <target state="translated">Распределение на стеке подразумевает,что он автоматически освобождается при разматывании стека.</target>
        </trans-unit>
        <trans-unit id="3b6e50a6540998dfdf1bd5337908c87ec9472523" translate="yes" xml:space="preserve">
          <source>C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for &lt;code&gt;new&lt;/code&gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the &lt;code&gt;new&lt;/code&gt; operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VLA C99 могли бы обеспечить небольшое преимущество, заключающееся в возможности создания небольших массивов без потери пространства или вызова конструкторов для неиспользуемых элементов, но они будут вносить довольно большие изменения в систему типов (необходимо иметь возможность указывать типы в зависимости от значений времени выполнения - это еще не существует в текущем C ++, за исключением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; спецификаторов типов операторов, но они обрабатываются специально, так что время выполнения не выходит за рамки действия &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; оператора).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be03536da2738f7ab85762b2cd2586b270bc45b5" translate="yes" xml:space="preserve">
          <source>C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.</source>
          <target state="translated">C99 позволяет VLA.И это накладывает некоторые ограничения на то,как декларировать VLA.Подробности см.в 6.7.5.2 стандарта.C++запрещает VLA.Но g++позволяет.</target>
        </trans-unit>
        <trans-unit id="ff06bf861788256153b9aa642197bf2b5cc9e3d4" translate="yes" xml:space="preserve">
          <source>Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.</source>
          <target state="translated">Правка:Можно создать вектор,использующий аллокатор стека (alloca),поскольку аллокатор является шаблонным параметром.</target>
        </trans-unit>
        <trans-unit id="f5bf5e1a7099d677043a8233206392681c482fe3" translate="yes" xml:space="preserve">
          <source>For more on the topic, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;N3810 &quot;Alternatives for Array Extensions&quot;&lt;/a&gt;, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish &lt;em&gt;syntax&lt;/em&gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для получения дополнительной информации по этой теме см. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810 &amp;laquo;Альтернативы для расширений массивов&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , документ Bjarne Stroustrup за октябрь 2013 года о VLA. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;POV Бьярне очень отличается от моего; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810 больше фокусируется на поиске хорошего &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синтаксиса синтаксиса&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C ++ &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;для вещей и на препятствовании использованию сырых массивов в C ++, тогда как я сосредоточился больше на последствиях для метапрограммирования и системы типов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я не знаю, считает ли он последствия метапрограммирования / системы типов решенными, разрешимыми или просто неинтересными.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb2d1834d43cb060504a5afff92b3f0a0bed81ab" translate="yes" xml:space="preserve">
          <source>Functionality can be emulated with other C++ constructs</source>
          <target state="translated">Функциональность может быть эмулирована другими конструкциями С++</target>
        </trans-unit>
        <trans-unit id="68da06e3377221e5de796920784d7792915f6b43" translate="yes" xml:space="preserve">
          <source>Hairy for compiler vendors to implement</source>
          <target state="translated">Волосы для производителей компиляторов для реализации</target>
        </trans-unit>
        <trans-unit id="482371147860afa9336450d7edcf30d7034eb677" translate="yes" xml:space="preserve">
          <source>I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good. The argument is, if you know the size beforehand, you can use a static array. And if you don't know the size beforehand, you will write unsafe code.</source>
          <target state="translated">Я согласен с теми людьми,которые,кажется,согласны с тем,что создание потенциального большого массива на стеке,в котором обычно мало места,не очень хорошо.Аргумент заключается в том,что если вы заранее знаете размер,вы можете использовать статический массив.А если не знать заранее размер,то можно написать опасный код.</target>
        </trans-unit>
        <trans-unit id="2a5812f28b35bcb48f76c49d410771ce71507939" translate="yes" xml:space="preserve">
          <source>I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).</source>
          <target state="translated">У меня есть решение,которое на самом деле сработало.Я не хотел выделять память из-за фрагментации на рутине,которая должна была выполняться много раз.Ответ чрезвычайно опасен,поэтому используйте его на свой страх и риск,но он использует сборку для резервирования места на стеке.В моем примере ниже используется символьный массив (очевидно,что другая переменная размера потребует больше памяти).</target>
        </trans-unit>
        <trans-unit id="b6d7e46d378f04d1801a2f622b99ad73ae0868e1" translate="yes" xml:space="preserve">
          <source>I haven't used C very much in the last few years. When I read &lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;this question&lt;/a&gt; today I came across some C syntax which I wasn't familiar with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я не очень много использовал C в последние несколько лет. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда я прочитал &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этот вопрос&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сегодня, я столкнулся с синтаксисом Си, который мне не был знаком.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e816f117cd47a20e41b1c7e0c81387cbf2ad034" translate="yes" xml:space="preserve">
          <source>I think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I'm working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.</source>
          <target state="translated">Я думаю,что C++настолько опасен сам по себе,что аргумент &quot;постарайтесь не добавлять больше опасных функций&quot; не очень сильный.С другой стороны,поскольку Си++,пожалуй,является наиболее эффективным языком программирования во время выполнения программы,это делает его более полезным всегда:Люди,которые пишут критичные к производительности программы,в значительной степени используют Си++,и им нужна максимальная производительность.Одной из таких возможностей является перенос материала из кучи в стек.Сокращение количества блоков кучи-это еще одна возможность.Разрешение VLA в качестве членов объектов-один из способов достичь этого.Я работаю над таким предложением.Реализовать его,конечно,немного сложно,но,кажется,вполне выполнимо.</target>
        </trans-unit>
        <trans-unit id="40cb19fb71abfcdc362b9ffad13d776256923c2a" translate="yes" xml:space="preserve">
          <source>I'm not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn't standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It's been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.</source>
          <target state="translated">Я не говорю,что нажимать буферы переменного размера на стек процессора никогда не нужно.Честно говоря,я был удивлен,когда обнаружил,что это не является стандартом,так как,конечно,кажется,что концепция достаточно хорошо вписывается в язык.Для меня,однако,требования &quot;переменного размера&quot; и &quot;должен быть физически расположен на стеке процессора&quot; никогда не складывались вместе.Дело было в скорости,поэтому я сделал свой собственный &quot;параллельный стек для буферов данных&quot;.</target>
        </trans-unit>
        <trans-unit id="806120e29434febd69a611cfa95daf050d1eb4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; weren't a compile-time constant (i.e., if &lt;code&gt;A&lt;/code&gt; were of variably modified type), then what on earth would be the type of &lt;code&gt;S&lt;/code&gt;? Would &lt;code&gt;S&lt;/code&gt;'s type &lt;em&gt;also&lt;/em&gt; be determined only at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если бы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не было константой времени компиляции (т. Е. Если бы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имел переменно модифицированный тип), то что на земле было бы типом &lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Будет ли &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тип &lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;также&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; определяться только во время выполнения?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cadc77c8df74681009ecd04756ffc8902be079f" translate="yes" xml:space="preserve">
          <source>If you know the value at compile time you can do the following:</source>
          <target state="translated">Если вы знаете значение во время компиляции,вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="25cbd3dd21b283ae2f9d4eaa0a15a55aaabe20ce" translate="yes" xml:space="preserve">
          <source>In my own work, I've realized that every time I've wanted something like variable-length automatic arrays or alloca(), I didn't really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn't incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.</source>
          <target state="translated">В моей собственной работе я понял,что каждый раз,когда я хотел что-то вроде автоматических массивов переменной длины или аллока(),меня не волновало,что память физически располагалась на стеке процессора,только то,что она поступала от какого-то аллокатора стека,который не медленно перемещался в общую кучу.Так что у меня есть per-thread объект,который владеет некоторой памятью,из которой он может использовать буферы размером с переменную pushpop.На некоторых платформах я позволяю этому расти через mmu.Другие платформы имеют фиксированный размер (обычно сопровождается фиксированным размером стека процессора,а также потому,что нет mmu).Одна платформа,с которой я работаю (портативная игровая консоль)имеет драгоценный небольшой стек процессора в любом случае,потому что она находится в дефиците,быстрая память.</target>
        </trans-unit>
        <trans-unit id="dd33745a32bdd5211fb2c5127b3c9b5f90a18898" translate="yes" xml:space="preserve">
          <source>Incompatible with some other part of the standard</source>
          <target state="translated">Несовместимый с другой частью стандарта.</target>
        </trans-unit>
        <trans-unit id="5ac82eedd3f1200472c3eaba3833822cef86f433" translate="yes" xml:space="preserve">
          <source>It would be less useful in C++ anyway since we already have &lt;code&gt;std::vector&lt;/code&gt; to fill this role.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В любом случае это было бы менее полезно в C ++, так как у нас уже есть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для выполнения этой роли.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1581697271897ae6f955195983b3d11f133f2094" translate="yes" xml:space="preserve">
          <source>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an &lt;em&gt;arbitrarily large&lt;/em&gt; chunk of your stack. This is a &lt;em&gt;guaranteed&lt;/em&gt; stack-overflow and crash. (Anytime you declare &lt;code&gt;int A[n]&lt;/code&gt;, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;&lt;code&gt;n&lt;/code&gt; is definitely less than 1000 here&quot;, then you would just declare &lt;code&gt;int A[1000]&lt;/code&gt;. Substituting the 32-bit integer &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;1000&lt;/code&gt; is an admission that you have no idea what the behavior of your program ought to be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Менее важно в мире C ++, но чрезвычайно важно для целевой аудитории программистов встраиваемых систем на C, объявление VLA означает разбрасывание &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;произвольно большого&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; куска вашего стека. Это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;гарантированное&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; переполнение стека и сбой. (Каждый раз, когда вы объявляете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вы неявно утверждаете, что у вас есть 2 ГБ стека для резервирования. В конце концов, если вы знаете, что &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; здесь определенно меньше 1000&amp;raquo;), вы просто объявляете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[1000]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Замена 32-битного целого числа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это признание того, что вы понятия не имеете, каким должно быть поведение вашей программы.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee478ffe7976d42688d8d55133a37aa8d78e1076" translate="yes" xml:space="preserve">
          <source>Looking at the discussion at &lt;code&gt;comp.std.c++&lt;/code&gt; it's clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It's certainly not obvious that a &lt;code&gt;std::vector&lt;/code&gt; is always a better solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Глядя на обсуждение на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;comp.std.c++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; становится ясно, что этот вопрос довольно спорный с некоторыми очень тяжелыми именами по обе стороны аргумента. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, не очевидно, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; всегда является лучшим решением.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d23541f85918fecd18aed7850a8f1c9c8290f19" translate="yes" xml:space="preserve">
          <source>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does&amp;hellip; but we've really started to rely on it in ways that C has not. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хорошо, теперь давайте перейдем к разговору о C ++. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C ++ мы имеем такое же сильное различие между &amp;laquo;системой типов&amp;raquo; и &amp;laquo;системой ценностей&amp;raquo;, как в C89&amp;hellip; но мы действительно начали полагаться на него так, как это не делает C. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ca739bf4aeb3b4982657bdd41b8fe9da6e94f45" translate="yes" xml:space="preserve">
          <source>Quick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.</source>
          <target state="translated">Краткое примечание:Как упоминалось в man-странице Mac OS X для alloca(3),&quot;Функция alloca()зависит от машины и компилятора;ее использование не поощряется&quot;.К вашему сведению.</target>
        </trans-unit>
        <trans-unit id="0e01ae80eca7726229f2af01f30f85a0011eb6a9" translate="yes" xml:space="preserve">
          <source>Seems it will be available in C++14:</source>
          <target state="translated">Похоже,он будет доступен на C++14:</target>
        </trans-unit>
        <trans-unit id="78b81ae2a7303fc5a23e553399b0905f9a785f46" translate="yes" xml:space="preserve">
          <source>Some potential reasons:</source>
          <target state="translated">Некоторые потенциальные причины:</target>
        </trans-unit>
        <trans-unit id="50eaf2461e5452bc32e18c3f4b245aeca3694981" translate="yes" xml:space="preserve">
          <source>The C++ standard states that array size must be a constant expression (8.3.4.1).</source>
          <target state="translated">В стандарте языка Си++указано,что размер массива должен быть константным выражением (8.3.4.1).</target>
        </trans-unit>
        <trans-unit id="655fdfc4e1350fd04dedffef0af28d6ff24f2e3e" translate="yes" xml:space="preserve">
          <source>The compiler must generate code for some instantiation of &lt;code&gt;myfunc&lt;/code&gt;. What should that code look like? How can we statically generate that code, if we don't know the type of &lt;code&gt;A1&lt;/code&gt; at compile time?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Компилятор должен сгенерировать код для некоторой реализации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как должен выглядеть этот код? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как мы можем статически сгенерировать этот код, если мы не знаем тип &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; во время компиляции?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="847c10687fcd80e916d369da37b004d639c21542" translate="yes" xml:space="preserve">
          <source>The dangers here are many but I'll explain a few:
1. Changing the variable size half way through would kill the stack position
2. Overstepping the array bounds would destroy other variables and possible code
3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).
4. Compiler specific (may have trouble moving between compilers).  I haven't tried so I really don't know.</source>
          <target state="translated">Опасностей здесь много,но я объясню несколько:1.Изменение переменного размера наполовину убило бы положение стека 2.Пересечение границ массива уничтожит другие переменные и возможный код 3.В 64-битной сборке это не работает...для этого нужна другая сборка (но макрос может решить эту проблему).4.Специфика компилятора (могут возникнуть проблемы при переходе между компиляторами).Я не пытался,поэтому не знаю.</target>
        </trans-unit>
        <trans-unit id="ffdfec5bfb16136c85636bab88bfef33b85826e8" translate="yes" xml:space="preserve">
          <source>The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.</source>
          <target state="translated">Память будет выделяться на кучу,но это задерживает лишь небольшой недостаток производительности.Кроме того,разумно не выделять большие блоки данных на стеке,так как он достаточно ограничен по размеру.</target>
        </trans-unit>
        <trans-unit id="69ed5f106cde9304603393d4b69ea6fbaecdca3c" translate="yes" xml:space="preserve">
          <source>The slices, rows and columns will also potentially be spread all over memory.</source>
          <target state="translated">Фрагменты,строки и столбцы также потенциально будут распределены по всей памяти.</target>
        </trans-unit>
        <trans-unit id="75337abd29d36b2aeb6bdec77608f4f9ddbc9d82" translate="yes" xml:space="preserve">
          <source>There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.</source>
          <target state="translated">Бывают ситуации,когда выделение кучевой памяти очень дорого по сравнению с выполняемыми операциями.Примером может служить матричная математика.Если вы работаете с маленькими матрицами,скажем,от 5 до 10 элементов и делаете много арифметики,то накладные расходы malloc будут действительно значительными.В то же время делать размер константы времени компиляции кажется очень расточительным и негибким.</target>
        </trans-unit>
        <trans-unit id="2d9540c95adf01bfe96108186fa43c95f4aed84b" translate="yes" xml:space="preserve">
          <source>There recently was a discussion about this kicked off in usenet: &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;Why no VLAs in C++0x&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Недавно в usenet началось обсуждение этого вопроса: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;почему в C ++ 0x нет VLA&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="420e9d809f5e55e35af61e0458dc9062b1a84947" translate="yes" xml:space="preserve">
          <source>This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?</source>
          <target state="translated">Это кажется довольно полезной функцией.Обсуждалось ли когда-нибудь добавление ее в стандарт C++,и если да,то почему она была пропущена?</target>
        </trans-unit>
        <trans-unit id="3681bd7c879cf246e529cb1459aabbd71d7929c7" translate="yes" xml:space="preserve">
          <source>This was considered for inclusion in C++/1x, &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;but was dropped&lt;/a&gt; (this is a correction to what I said earlier).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это рассматривалось для включения в C ++ / 1x, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;но было исключено&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (это исправление к тому, что я сказал ранее).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c5efb0ed4cfdb41bfe29546748a6ee08ea79f76" translate="yes" xml:space="preserve">
          <source>Use std::vector for this. For example:</source>
          <target state="translated">Используйте для этого std::vector.Например:</target>
        </trans-unit>
        <trans-unit id="4dc64eaed80a49209b7212897182856b464ff4d2" translate="yes" xml:space="preserve">
          <source>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</source>
          <target state="translated">Массивы переменной длины в C99 были,по сути,ошибкой.Чтобы поддержать VLA,C99 должен был пойти на следующие уступки здравому смыслу:</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">А как насчет этого:</target>
        </trans-unit>
        <trans-unit id="57a287a958e4cca4d33101677876891076290e24" translate="yes" xml:space="preserve">
          <source>Why aren't variable-length arrays part of the C++ standard</source>
          <target state="translated">Почему массивы переменной длины не являются частью стандарта C++</target>
        </trans-unit>
        <trans-unit id="fbf2b06494f2d7238597a77fef7d9a9871f70987" translate="yes" xml:space="preserve">
          <source>Worse, what if it turns out at runtime that &lt;code&gt;n1 != n2&lt;/code&gt;, so that &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt;? In that case, the call to &lt;code&gt;myfunc&lt;/code&gt;&lt;strong&gt;shouldn't even compile&lt;/strong&gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хуже того, что если во время выполнения окажется, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n1 != n2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , так что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? В этом случае вызов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не должен даже компилироваться&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , потому что вывод типа шаблона должен завершиться ошибкой! Как мы можем подражать этому поведению во время выполнения?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c57bc85dabed67fd51c3d2de29053b72562c2e1" translate="yes" xml:space="preserve">
          <source>Yes, of course I realize that in the toy example one could use &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Да, конечно, я понимаю, что в игрушечном примере можно использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, но это выделяет память из кучи, а не из стека. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И если я хочу многомерный массив, как:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0835518093c390c7915b0891f2f795ec06ad215" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;std::vector&lt;/code&gt;, but it is not quite the same, as it uses dynamic memory, and making it use one's own stack-allocator isn't exactly easy (alignment is an issue, too). It also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;C++ Dynamic Array&lt;/a&gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it's not going to be part of C++0x, as far as I know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но это не совсем то же самое, поскольку он использует динамическую память, и заставить его использовать собственный распределитель стека не совсем легко (выравнивание также является проблемой). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это также не решает ту же проблему, потому что вектор является контейнером с изменяемым размером, тогда как VLA имеют фиксированный размер. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предложение &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ Dynamic Array&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предназначено для представления решения на основе библиотеки, как альтернативы VLA на основе языка. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако, насколько я знаю, он не будет частью C ++ 0x.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee49e1beb61b1f02cbef2c02b8330c97d6649909" translate="yes" xml:space="preserve">
          <source>You could always use alloca() to allocate memory on the stack at runtime, if you wished:</source>
          <target state="translated">При желании вы всегда можете использовать функцию alloca()для выделения памяти на стеке во время выполнения:</target>
        </trans-unit>
        <trans-unit id="bf51f2d5a13b6be238f5a5ebdba02e8e898f9f44" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;vector&lt;/code&gt; version becomes pretty clumsy:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; версия становится довольно неуклюжи:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
