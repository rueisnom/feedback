<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1887097">
    <body>
      <group id="1887097">
        <trans-unit id="784ca4d89f40759259eb634137d78b2eb572edaf" translate="yes" xml:space="preserve">
          <source>(Background: I have some experience implementing C and C++ compilers.)</source>
          <target state="translated">(背景:CやC++コンパイラの実装経験があります)</target>
        </trans-unit>
        <trans-unit id="bd9ef556311be517a525bb3524ed59007934b5f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof x&lt;/code&gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a &lt;code&gt;sizeof&lt;/code&gt;-expression at runtime.</source>
          <target state="translated">&lt;code&gt;sizeof x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、常にコンパイル時の定数ではなくなりました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラーは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、実行時に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -expression &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を評価するコードを生成する必要がある場合があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7dd54a911c89231a7841010f0dc0907da5aa8a08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update: It did not make it into C++14.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更新：C ++ 14には含まれていません。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7eff072167bda04c186c36234a3426822f1ecf7" translate="yes" xml:space="preserve">
          <source>A good blog post that hits many of these same points is &lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&quot;Legitimate Use of Variable Length Arrays&quot;&lt;/a&gt; (Chris Wellons, 2019-10-27).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらの同じ点の多くに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当てはまる&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;優れたブログ投稿は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「可変長配列の正当な使用」です&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Chris Wellons、2019-10-27）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10d6a21bb53b190c7591942063680aa1e2b5e04" translate="yes" xml:space="preserve">
          <source>Allowing two-dimensional VLAs (&lt;code&gt;int A[x][y]&lt;/code&gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2次元VLA（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[x][y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を許可&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するには、2D VLAをパラメーターとして受け取る関数を宣言するための新しい構文が必要でした：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0df2d17c8e3e4ce8e39e408df55ebd969517f123" translate="yes" xml:space="preserve">
          <source>Apparently in &lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;C99&lt;/a&gt; the following syntax is valid:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どうやら&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99では&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次の構文が有効です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f54311051e5aef26e0c96d5f655fda12ee6e7f5" translate="yes" xml:space="preserve">
          <source>Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).</source>
          <target state="translated">このような配列は C99 の一部ではありますが、標準 C++の一部ではありません。他の人が言っているように、ベクトルは常にはるかに良い解決策です。</target>
        </trans-unit>
        <trans-unit id="06b95a46628b5fa3ceb1519d192f271c27836750" translate="yes" xml:space="preserve">
          <source>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (&lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; or &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully &lt;em&gt;this&lt;/em&gt; answer gives you a good idea of why C99-style VLAs were &lt;strong&gt;not&lt;/strong&gt; a good fit for C++ &amp;mdash; and not really even a good fit for C99. ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他のすべての回答者がすでに指摘したように、C ++は多くのヒープ割り当てメカニズム（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;てい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明白なもの）「本当にどれだけのRAMが必要かわからない」という考えを本当に伝えたいとき。また、C ++は、必要なRAMの量がRAMの量よりも多いという避けられない状況に対処するための、洗練された例外処理モデルを提供します。しかし、うまくいけば、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回答は、C99スタイルのVLAが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;適さ&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なかっ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;理由、およびC99に実際には適さ&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なかっ&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;理由についての良い考えを提供します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 ;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4409ffad589b749dae53fad479eb3a17e0038fa" translate="yes" xml:space="preserve">
          <source>BTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;comp.std.c++&lt;/a&gt; is the place to go to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ところで、C ++標準が「なぜ」であるかについての質問については、モデレートされたUsenetニュースグループ&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comp.std.c ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にアクセスしてください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a620acbc347ecec3c138d2d3ca0dbed0284b793a" translate="yes" xml:space="preserve">
          <source>Basically, C++ is moving in the direction of pushing more and more decisions into &lt;em&gt;compile-time&lt;/em&gt;: template code generation, &lt;code&gt;constexpr&lt;/code&gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally &lt;em&gt;compile-time&lt;/em&gt; decisions (e.g. &lt;code&gt;sizeof&lt;/code&gt;) into the &lt;em&gt;runtime&lt;/em&gt;. With this in mind, does it really even make sense to expend any effort &lt;em&gt;trying&lt;/em&gt; to integrate C99-style VLAs into C++?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本的に、C ++は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テンプレートコードの生成や&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数の評価など、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイル時の&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;決定をますますプッシュする方向に向かっ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ています。その間、C99は従来の&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイル時の&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;決定（たとえば&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;）を&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ランタイムに&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プッシュ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のに忙しかった&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これを念頭に置いて、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99スタイルのVLAをC ++に統合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しよ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;うと&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するあらゆる努力を費やすことは本当に意味があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ますか？&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5380f57134755717cd1c2a14e436a8f87d84912f" translate="yes" xml:space="preserve">
          <source>Being allocated on the stack implies that it will automatically be freed when the stack unwinds.</source>
          <target state="translated">スタックに割り当てられているということは、スタックの巻き戻し時に自動的に解放されることを意味します。</target>
        </trans-unit>
        <trans-unit id="3b6e50a6540998dfdf1bd5337908c87ec9472523" translate="yes" xml:space="preserve">
          <source>C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for &lt;code&gt;new&lt;/code&gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the &lt;code&gt;new&lt;/code&gt; operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 VLAは、スペースを無駄にしたり、未使用の要素のコンストラクターを呼び出したりせずに小さな配列を作成できるという小さな利点を提供できますが、型システムにかなり大きな変更をもたらします（ランタイム値に応じて型を指定できる必要があります-これ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演算子の型指定子&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を除いて、現在のC ++にはまだ存在しませんが、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらは特別に扱われるため、実行時の可能性は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演算子の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スコープをエスケープしません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be03536da2738f7ab85762b2cd2586b270bc45b5" translate="yes" xml:space="preserve">
          <source>C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.</source>
          <target state="translated">C99ではVLAを許可しています。また、VLAの宣言方法にはいくつかの制限があります。詳細は標準規格の6.7.5.2を参照してください。C++はVLAを禁止しています。しかし、g++では許可されています。</target>
        </trans-unit>
        <trans-unit id="ff06bf861788256153b9aa642197bf2b5cc9e3d4" translate="yes" xml:space="preserve">
          <source>Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.</source>
          <target state="translated">編集:allocatorはテンプレートパラメータなので、スタックアロケータ(alloca)を使用したベクターを作成することができます。</target>
        </trans-unit>
        <trans-unit id="f5bf5e1a7099d677043a8233206392681c482fe3" translate="yes" xml:space="preserve">
          <source>For more on the topic, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;N3810 &quot;Alternatives for Array Extensions&quot;&lt;/a&gt;, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish &lt;em&gt;syntax&lt;/em&gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このトピックの詳細については、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VLA&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に関する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bjarne Stroustrupの2013年10月の論文、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810「Alternatives for Array Extensions」を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BjarneのPOVは私のものとは非常に異なります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、物事に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;適したC ++風の&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;構文&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;見つけることに重点を置き、C ++ &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で生の配列を使用しないようにすることに重点を置いていますが、メタプログラミングと型システムへの影響に重点を置いています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;彼がメタプログラミング/タイプシステムの影響を解決、解決可能、または単に興味がないと見なしているかどうかはわかりません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb2d1834d43cb060504a5afff92b3f0a0bed81ab" translate="yes" xml:space="preserve">
          <source>Functionality can be emulated with other C++ constructs</source>
          <target state="translated">機能は、他の C++コンストラクトでエミュレートできます。</target>
        </trans-unit>
        <trans-unit id="68da06e3377221e5de796920784d7792915f6b43" translate="yes" xml:space="preserve">
          <source>Hairy for compiler vendors to implement</source>
          <target state="translated">コンパイラベンダが実装するのは難しい</target>
        </trans-unit>
        <trans-unit id="482371147860afa9336450d7edcf30d7034eb677" translate="yes" xml:space="preserve">
          <source>I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good. The argument is, if you know the size beforehand, you can use a static array. And if you don't know the size beforehand, you will write unsafe code.</source>
          <target state="translated">私は、スタック上に潜在的に大きな配列を作成しなければならないことに同意しているように見える人たちに同意します。議論は、事前にサイズがわかっていれば、静的な配列を使うことができるということです。そして、事前にサイズがわからなければ、安全ではないコードを書くことになります。</target>
        </trans-unit>
        <trans-unit id="2a5812f28b35bcb48f76c49d410771ce71507939" translate="yes" xml:space="preserve">
          <source>I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).</source>
          <target state="translated">実際に私のために機能した解決策があります。何度も実行する必要のあるルーチンで断片化しているため、メモリを確保したくなかったのです。この答えは非常に危険なので、自己責任で使用してください。以下の私の例は文字配列を使用しています(明らかに他のサイズの変数はより多くのメモリを必要とします)。</target>
        </trans-unit>
        <trans-unit id="b6d7e46d378f04d1801a2f622b99ad73ae0868e1" translate="yes" xml:space="preserve">
          <source>I haven't used C very much in the last few years. When I read &lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;this question&lt;/a&gt; today I came across some C syntax which I wasn't familiar with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここ数年はCをあまり使っていません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今日&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この質問&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を読んだとき、私&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は知らないC構文に出くわしました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e816f117cd47a20e41b1c7e0c81387cbf2ad034" translate="yes" xml:space="preserve">
          <source>I think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I'm working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.</source>
          <target state="translated">私は、C++はそれ自体が非常に安全ではないと思うので、「これ以上安全ではない機能を追加しないようにしよう」という議論はあまり強くありません。一方で、C++は間違いなく最も実行効率の高いプログラミング言語であるため、それをさらに向上させる機能は常に有用です。パフォーマンスが重要なプログラムを書く人は、大部分が C++を使うでしょうし、できるだけ多くのパフォーマンスを必要とします。ヒープからスタックへの移動はそのような可能性の 1 つです。ヒープブロックの数を減らすこともその一つです。VLAをオブジェクトのメンバとして許可することは、これを達成するための一つの方法でしょう。私はそのような提案に取り組んでいます。確かに実装するには少し複雑ですが、かなり実行可能なように思えます。</target>
        </trans-unit>
        <trans-unit id="40cb19fb71abfcdc362b9ffad13d776256923c2a" translate="yes" xml:space="preserve">
          <source>I'm not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn't standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It's been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.</source>
          <target state="translated">可変サイズのバッファをCPUスタックにプッシュすることが決して必要ないと言っているわけではありません。正直なところ、これが標準ではないことを知ったときは驚きました。しかし私にとっては、「可変サイズ」と「物理的に CPU スタック上になければならない」という要件が一緒になったことはありませんでした。速度を重視していたので、「データバッファ用の並列スタック」のようなものを自分で作ってみました。</target>
        </trans-unit>
        <trans-unit id="806120e29434febd69a611cfa95daf050d1eb4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; weren't a compile-time constant (i.e., if &lt;code&gt;A&lt;/code&gt; were of variably modified type), then what on earth would be the type of &lt;code&gt;S&lt;/code&gt;? Would &lt;code&gt;S&lt;/code&gt;'s type &lt;em&gt;also&lt;/em&gt; be determined only at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がコンパイル時定数ではなかった&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（つまり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が可変的に変更された型であった&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）、いったい&lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の型は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;何でしょうか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;う&lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のタイプは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一の実行時に決定すること？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cadc77c8df74681009ecd04756ffc8902be079f" translate="yes" xml:space="preserve">
          <source>If you know the value at compile time you can do the following:</source>
          <target state="translated">コンパイル時に値がわかっている場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="25cbd3dd21b283ae2f9d4eaa0a15a55aaabe20ce" translate="yes" xml:space="preserve">
          <source>In my own work, I've realized that every time I've wanted something like variable-length automatic arrays or alloca(), I didn't really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn't incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.</source>
          <target state="translated">私自身の仕事では、可変長の自動配列や alloca()のようなものが欲しいと思うたびに、メモリが物理的に CPU スタック上にあるかどうかは気にしていませんでした。そこで私は、可変サイズのバッファをプッシュポップできるメモリを所有するスレッドごとのオブジェクトを持っています。いくつかのプラットフォームでは、私はこれを mmu 経由で成長させることを許可しています。他のプラットフォームでは、サイズが固定されています(mmuがないので、通常は固定サイズのCPUスタックを伴っています)。私が使用しているあるプラットフォーム(携帯ゲーム機)では、CPUスタックの数が非常に少ないのですが、これは、希少で高速なメモリに存在しているからです。</target>
        </trans-unit>
        <trans-unit id="dd33745a32bdd5211fb2c5127b3c9b5f90a18898" translate="yes" xml:space="preserve">
          <source>Incompatible with some other part of the standard</source>
          <target state="translated">規格の他の部分との互換性がない</target>
        </trans-unit>
        <trans-unit id="5ac82eedd3f1200472c3eaba3833822cef86f433" translate="yes" xml:space="preserve">
          <source>It would be less useful in C++ anyway since we already have &lt;code&gt;std::vector&lt;/code&gt; to fill this role.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とにかく、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この役割を満たすために&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を既に持っているので、C ++ではあまり役に立ちません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1581697271897ae6f955195983b3d11f133f2094" translate="yes" xml:space="preserve">
          <source>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an &lt;em&gt;arbitrarily large&lt;/em&gt; chunk of your stack. This is a &lt;em&gt;guaranteed&lt;/em&gt; stack-overflow and crash. (Anytime you declare &lt;code&gt;int A[n]&lt;/code&gt;, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;&lt;code&gt;n&lt;/code&gt; is definitely less than 1000 here&quot;, then you would just declare &lt;code&gt;int A[1000]&lt;/code&gt;. Substituting the 32-bit integer &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;1000&lt;/code&gt; is an admission that you have no idea what the behavior of your program ought to be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++の世界ではそれほど重要ではありませんが、組み込みシステムプログラマーのCの対象読者にとって非常に重要です。VLAを宣言すること&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、スタックの&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意の大きな&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;チャンクを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;選択することを意味し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。これは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保証された&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スタックオーバーフローとクラッシュです。 （&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を宣言するときは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に、2GBのスタックがあることを暗黙的に主張しています。結局のところ、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで「&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は間違いなく1000未満&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」とわかっている&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[1000]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;宣言するだけです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。32ビット整数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;置き換えること&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、プログラムの動作がどうあるべきかがわからないことを認めています。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee478ffe7976d42688d8d55133a37aa8d78e1076" translate="yes" xml:space="preserve">
          <source>Looking at the discussion at &lt;code&gt;comp.std.c++&lt;/code&gt; it's clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It's certainly not obvious that a &lt;code&gt;std::vector&lt;/code&gt; is always a better solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;comp.std.c++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;での&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;議論を見ると、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この質問が議論の両側にある非常にヘビーな名前でかなり物議を醸していることは明らかです。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が常に優れたソリューション&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であることは明らかではありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d23541f85918fecd18aed7850a8f1c9c8290f19" translate="yes" xml:space="preserve">
          <source>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does&amp;hellip; but we've really started to rely on it in ways that C has not. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;では、C ++の話に移りましょう。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++では、「型システム」と「値システム」はC89と同じように強力に区別されていますが、Cにはない方法で実際にそれに依存し始めています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例えば：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ca739bf4aeb3b4982657bdd41b8fe9da6e94f45" translate="yes" xml:space="preserve">
          <source>Quick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.</source>
          <target state="translated">クイックメモ:Mac OS X の alloca(3)の man ページで述べられているように、&quot;alloca()関数はマシンとコンパイラに依存しています。これだけは知っておいてください。</target>
        </trans-unit>
        <trans-unit id="0e01ae80eca7726229f2af01f30f85a0011eb6a9" translate="yes" xml:space="preserve">
          <source>Seems it will be available in C++14:</source>
          <target state="translated">C++14で利用できるようになるようです。</target>
        </trans-unit>
        <trans-unit id="78b81ae2a7303fc5a23e553399b0905f9a785f46" translate="yes" xml:space="preserve">
          <source>Some potential reasons:</source>
          <target state="translated">いくつかの潜在的な理由。</target>
        </trans-unit>
        <trans-unit id="50eaf2461e5452bc32e18c3f4b245aeca3694981" translate="yes" xml:space="preserve">
          <source>The C++ standard states that array size must be a constant expression (8.3.4.1).</source>
          <target state="translated">C++標準では、配列のサイズは定数式でなければならないとされています(8.3.4.1)。</target>
        </trans-unit>
        <trans-unit id="655fdfc4e1350fd04dedffef0af28d6ff24f2e3e" translate="yes" xml:space="preserve">
          <source>The compiler must generate code for some instantiation of &lt;code&gt;myfunc&lt;/code&gt;. What should that code look like? How can we statically generate that code, if we don't know the type of &lt;code&gt;A1&lt;/code&gt; at compile time?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラーは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インスタンス化のためのコードを生成する必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのコードはどのように見えるべきですか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイル時&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のタイプがわからない場合、どのようにしてそのコードを静的に生成でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ますか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="847c10687fcd80e916d369da37b004d639c21542" translate="yes" xml:space="preserve">
          <source>The dangers here are many but I'll explain a few:
1. Changing the variable size half way through would kill the stack position
2. Overstepping the array bounds would destroy other variables and possible code
3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).
4. Compiler specific (may have trouble moving between compilers).  I haven't tried so I really don't know.</source>
          <target state="translated">ここでの危険性はたくさんありますが、いくつか説明します。1.1.変数のサイズを途中で変更するとスタックの位置が死んでしまう 2.2.配列の境界を超えると、他の変数や可能性のあるコードが破壊されてしまう 3.これは 64 ビットビルドでは動作しません...そのためには別のアセンブリが必要です (ただし、マクロで解決できるかもしれません)。4.4.コンパイラ固有の問題 (コンパイラ間の移動に問題があるかもしれません)。試していないのでよくわかりません。</target>
        </trans-unit>
        <trans-unit id="ffdfec5bfb16136c85636bab88bfef33b85826e8" translate="yes" xml:space="preserve">
          <source>The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.</source>
          <target state="translated">メモリはヒープ上に割り当てられますが、これは小さな性能上の欠点しかありません。さらに、大きなデータブロックはスタックに割り当てない方が賢明です。</target>
        </trans-unit>
        <trans-unit id="69ed5f106cde9304603393d4b69ea6fbaecdca3c" translate="yes" xml:space="preserve">
          <source>The slices, rows and columns will also potentially be spread all over memory.</source>
          <target state="translated">また、スライス、行、列は、潜在的にメモリ上に広がっているでしょう。</target>
        </trans-unit>
        <trans-unit id="75337abd29d36b2aeb6bdec77608f4f9ddbc9d82" translate="yes" xml:space="preserve">
          <source>There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.</source>
          <target state="translated">ヒープメモリの割り当てが、実行される操作に比べて非常に高価な状況があります。例としては、行列計算があります。5 から 10 の要素のような小さな行列を扱い、多くの演算を行う場合、malloc のオーバーヘッドは非常に大きなものになります。同時に、サイズをコンパイル時の定数にすることは非常に無駄が多く、柔軟性に欠けるように思えます。</target>
        </trans-unit>
        <trans-unit id="2d9540c95adf01bfe96108186fa43c95f4aed84b" translate="yes" xml:space="preserve">
          <source>There recently was a discussion about this kicked off in usenet: &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;Why no VLAs in C++0x&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最近のUsenetで幕を開けたこのことについて議論がありました：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なぜC ++ 0xの中にいないのVLA&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="420e9d809f5e55e35af61e0458dc9062b1a84947" translate="yes" xml:space="preserve">
          <source>This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?</source>
          <target state="translated">これはかなり便利な機能のように思えます。C++標準に追加することについての議論はありましたか?</target>
        </trans-unit>
        <trans-unit id="3681bd7c879cf246e529cb1459aabbd71d7929c7" translate="yes" xml:space="preserve">
          <source>This was considered for inclusion in C++/1x, &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;but was dropped&lt;/a&gt; (this is a correction to what I said earlier).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはC ++ / 1xに含まれると考えられていまし&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たが、削除されました&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（これは、私が以前言ったことに対する修正です）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c5efb0ed4cfdb41bfe29546748a6ee08ea79f76" translate="yes" xml:space="preserve">
          <source>Use std::vector for this. For example:</source>
          <target state="translated">これには std::vector を使用します。例えば</target>
        </trans-unit>
        <trans-unit id="4dc64eaed80a49209b7212897182856b464ff4d2" translate="yes" xml:space="preserve">
          <source>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</source>
          <target state="translated">C99の可変長配列は基本的には失敗でした。VLAをサポートするために、C99では以下のような常識的な譲歩をしなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">これはどうなんだ?</target>
        </trans-unit>
        <trans-unit id="57a287a958e4cca4d33101677876891076290e24" translate="yes" xml:space="preserve">
          <source>Why aren't variable-length arrays part of the C++ standard</source>
          <target state="translated">可変長配列が C++標準の配列に含まれていないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="fbf2b06494f2d7238597a77fef7d9a9871f70987" translate="yes" xml:space="preserve">
          <source>Worse, what if it turns out at runtime that &lt;code&gt;n1 != n2&lt;/code&gt;, so that &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt;? In that case, the call to &lt;code&gt;myfunc&lt;/code&gt;&lt;strong&gt;shouldn't even compile&lt;/strong&gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さらに悪いことに、実行時に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n1 != n2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と判明し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;て、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どうなるでしょうか。その場合、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テンプレートタイプの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は失敗するはずなので、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;myfunc&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の呼び出し&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はcompile&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であってはなりません！実行時にその動作をどのようにエミュレートできますか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c57bc85dabed67fd51c3d2de29053b72562c2e1" translate="yes" xml:space="preserve">
          <source>Yes, of course I realize that in the toy example one could use &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はい、もちろん、おもちゃの例では&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用できることを認識してい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、しかしこれはスタックからではなくヒープからメモリを割り当てます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、私が次のような多次元配列が必要な場合：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0835518093c390c7915b0891f2f795ec06ad215" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;std::vector&lt;/code&gt;, but it is not quite the same, as it uses dynamic memory, and making it use one's own stack-allocator isn't exactly easy (alignment is an issue, too). It also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;C++ Dynamic Array&lt;/a&gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it's not going to be part of C++0x, as far as I know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、動的メモリを使用するため、まったく同じではありません。独自のスタックアロケータを使用するのは簡単ではありません（配置も問題です）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VLAは固定サイズですが、ベクトルはサイズ変更可能なコンテナーであるため、同じ問題は解決しません。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++動的配列の&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提案は、VLAベースの言語に代わるものとして、ライブラリベースのソリューションを紹介することを意図しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、私の知る限り、C ++ 0xの一部にはなりません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee49e1beb61b1f02cbef2c02b8330c97d6649909" translate="yes" xml:space="preserve">
          <source>You could always use alloca() to allocate memory on the stack at runtime, if you wished:</source>
          <target state="translated">必要であれば、常に alloca()を使用して実行時にスタック上のメモリを確保することができます。</target>
        </trans-unit>
        <trans-unit id="bf51f2d5a13b6be238f5a5ebdba02e8e898f9f44" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;vector&lt;/code&gt; version becomes pretty clumsy:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バージョンはかなり不器用次のようになります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
