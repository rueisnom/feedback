<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1887097">
    <body>
      <group id="1887097">
        <trans-unit id="784ca4d89f40759259eb634137d78b2eb572edaf" translate="yes" xml:space="preserve">
          <source>(Background: I have some experience implementing C and C++ compilers.)</source>
          <target state="translated">(背景:我有一些C和C++编译器的实现经验)</target>
        </trans-unit>
        <trans-unit id="bd9ef556311be517a525bb3524ed59007934b5f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof x&lt;/code&gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a &lt;code&gt;sizeof&lt;/code&gt;-expression at runtime.</source>
          <target state="translated">&lt;code&gt;sizeof x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再总是编译时常量；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器有时必须&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在运行时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生成代码以评估&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -expression。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7dd54a911c89231a7841010f0dc0907da5aa8a08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update: It did not make it into C++14.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更新：它没有进入C ++ 14。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7eff072167bda04c186c36234a3426822f1ecf7" translate="yes" xml:space="preserve">
          <source>A good blog post that hits many of these same points is &lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&quot;Legitimate Use of Variable Length Arrays&quot;&lt;/a&gt; (Chris Wellons, 2019-10-27).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个很好的博客文章也提到了很多相同的问题，例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;合法使用可变长度数组&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Chris Wellons，2019-10-27）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10d6a21bb53b190c7591942063680aa1e2b5e04" translate="yes" xml:space="preserve">
          <source>Allowing two-dimensional VLAs (&lt;code&gt;int A[x][y]&lt;/code&gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许二维VLA（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[x][y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）需要一种新的语法来声明将2D VLA作为参数的函数：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0df2d17c8e3e4ce8e39e408df55ebd969517f123" translate="yes" xml:space="preserve">
          <source>Apparently in &lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;C99&lt;/a&gt; the following syntax is valid:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显然，在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以下语法有效：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f54311051e5aef26e0c96d5f655fda12ee6e7f5" translate="yes" xml:space="preserve">
          <source>Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).</source>
          <target state="translated">像这样的数组是C99中的一部分,但不是标准C++的一部分。正如其他人所说,向量总是一个更好的解决方案,这可能就是为什么可变大小的数组不在C++标准中(或在建议的C++0x标准中)。</target>
        </trans-unit>
        <trans-unit id="06b95a46628b5fa3ceb1519d192f271c27836750" translate="yes" xml:space="preserve">
          <source>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (&lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; or &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully &lt;em&gt;this&lt;/em&gt; answer gives you a good idea of why C99-style VLAs were &lt;strong&gt;not&lt;/strong&gt; a good fit for C++ &amp;mdash; and not really even a good fit for C99. ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如其他答复者已经指出的那样，C ++提供了很多堆分配机制（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是显而易见的），当您真正想传达&amp;ldquo;我不知道我可能需要多少RAM&amp;rdquo;的想法时。 C ++提供了一个漂亮的异常处理模型来处理不可避免的情况，即所需的RAM数量大于所需的RAM数量。但是希望&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案可以使您很好地理解为什么C99样式的VLA &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;适合C ++，甚至不适合C99。 ;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4409ffad589b749dae53fad479eb3a17e0038fa" translate="yes" xml:space="preserve">
          <source>BTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;comp.std.c++&lt;/a&gt; is the place to go to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺便说一句，对于&amp;ldquo;为什么&amp;rdquo;使用C ++标准的问题，经过审核的Usenet新闻组&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comp.std.c ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是您可以去的地方。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a620acbc347ecec3c138d2d3ca0dbed0284b793a" translate="yes" xml:space="preserve">
          <source>Basically, C++ is moving in the direction of pushing more and more decisions into &lt;em&gt;compile-time&lt;/em&gt;: template code generation, &lt;code&gt;constexpr&lt;/code&gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally &lt;em&gt;compile-time&lt;/em&gt; decisions (e.g. &lt;code&gt;sizeof&lt;/code&gt;) into the &lt;em&gt;runtime&lt;/em&gt;. With this in mind, does it really even make sense to expend any effort &lt;em&gt;trying&lt;/em&gt; to integrate C99-style VLAs into C++?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本上，C ++朝着将越来越多的决策推向&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译时&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的方向发展&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：模板代码生成，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数评估等。同时，C99忙于将传统的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译时&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;决策（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）推入&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运行时&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。考虑到这一点，它真的甚至是有意义的花费任何力气&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;试图&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以C99风格VLAS整合到C ++？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5380f57134755717cd1c2a14e436a8f87d84912f" translate="yes" xml:space="preserve">
          <source>Being allocated on the stack implies that it will automatically be freed when the stack unwinds.</source>
          <target state="translated">被分配到堆栈上意味着,当堆栈解锁时,它将被自动释放。</target>
        </trans-unit>
        <trans-unit id="3b6e50a6540998dfdf1bd5337908c87ec9472523" translate="yes" xml:space="preserve">
          <source>C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for &lt;code&gt;new&lt;/code&gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the &lt;code&gt;new&lt;/code&gt; operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 VLA可以提供一个小的好处，即能够创建小的数组而不会浪费空间或为未使用的元素调用构造函数，但是它们会给类型系统带来相当大的变化（您需要能够根据运行时值指定类型-这除了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符类型说明符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;外，当前的C ++中尚不存在该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式，但是对它们进行了特殊处理，以使运行时不会脱离&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的范围&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be03536da2738f7ab85762b2cd2586b270bc45b5" translate="yes" xml:space="preserve">
          <source>C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.</source>
          <target state="translated">C99允许VLA。而且它对如何声明VLA做了一些限制。详情请参考标准的6.7.5.2。C++不允许VLA。但g++允许。</target>
        </trans-unit>
        <trans-unit id="ff06bf861788256153b9aa642197bf2b5cc9e3d4" translate="yes" xml:space="preserve">
          <source>Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.</source>
          <target state="translated">编辑:你可以创建一个使用堆栈分配器(alloca)的向量,因为分配器是一个模板参数。</target>
        </trans-unit>
        <trans-unit id="f5bf5e1a7099d677043a8233206392681c482fe3" translate="yes" xml:space="preserve">
          <source>For more on the topic, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;N3810 &quot;Alternatives for Array Extensions&quot;&lt;/a&gt;, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish &lt;em&gt;syntax&lt;/em&gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关该主题的更多信息，请参见&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bjarne Stroustrup在2013年10月发布的有关VLA的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810&amp;ldquo;数组扩展的替代方案&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bjarne的POV与我的有很大不同。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810更着重于&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为事物&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;找到良好的C ++ ish &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并阻止在C ++中使用原始数组，而我更着重于元编程和类型系统的含义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不知道他是否认为元编程/类型系统的含义已解决，可解决或仅无趣。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb2d1834d43cb060504a5afff92b3f0a0bed81ab" translate="yes" xml:space="preserve">
          <source>Functionality can be emulated with other C++ constructs</source>
          <target state="translated">功能性可以用其他C++构造来模拟。</target>
        </trans-unit>
        <trans-unit id="68da06e3377221e5de796920784d7792915f6b43" translate="yes" xml:space="preserve">
          <source>Hairy for compiler vendors to implement</source>
          <target state="translated">为编译器供应商实现</target>
        </trans-unit>
        <trans-unit id="482371147860afa9336450d7edcf30d7034eb677" translate="yes" xml:space="preserve">
          <source>I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good. The argument is, if you know the size beforehand, you can use a static array. And if you don't know the size beforehand, you will write unsafe code.</source>
          <target state="translated">我同意那些似乎认为必须在堆栈上创建一个潜在的大数组的人的观点,因为堆栈上通常只有很少的空间,这并不是什么好事。论点是,如果你事先知道大小,你可以使用静态数组。而如果你事先不知道大小,你就会写出不安全的代码。</target>
        </trans-unit>
        <trans-unit id="2a5812f28b35bcb48f76c49d410771ce71507939" translate="yes" xml:space="preserve">
          <source>I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).</source>
          <target state="translated">我有一个解决方案,实际上对我来说是有效的。我不想在一个需要多次运行的例程上因为碎片化而分配内存。这个答案是非常危险的,所以使用它要冒着风险,但它利用了汇编的优势,在堆栈上预留空间。我下面的例子使用了一个字符数组(显然其他大小的变量需要更多的内存)。</target>
        </trans-unit>
        <trans-unit id="b6d7e46d378f04d1801a2f622b99ad73ae0868e1" translate="yes" xml:space="preserve">
          <source>I haven't used C very much in the last few years. When I read &lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;this question&lt;/a&gt; today I came across some C syntax which I wasn't familiar with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在过去的几年中，我很少使用C。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今天，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当我阅读&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此问题时&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，遇到了一些我不熟悉的C语法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e816f117cd47a20e41b1c7e0c81387cbf2ad034" translate="yes" xml:space="preserve">
          <source>I think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I'm working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.</source>
          <target state="translated">我认为,C++本身就是如此不安全,所以 &quot;尽量不要增加更多不安全的功能 &quot;的论点并不十分有力。另一方面,由于C++可以说是运行时效率最高的编程语言,这使得它更多的功能总是有用的。编写性能关键程序的人在很大程度上会使用C++,他们需要尽可能多的性能。把东西从堆上移到堆上就是这样一种可能。减少堆块的数量是另一种。允许VLAs作为对象成员,是实现这个目标的一种方法。我正在研究这样一个建议。诚然,实现起来有点复杂,但似乎是可以做到的。</target>
        </trans-unit>
        <trans-unit id="40cb19fb71abfcdc362b9ffad13d776256923c2a" translate="yes" xml:space="preserve">
          <source>I'm not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn't standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It's been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.</source>
          <target state="translated">我并不是说把可变大小的缓冲区推到cpu堆栈上永远不需要。老实说,当我发现这并不是标准的时候,我很惊讶,因为这个概念似乎已经很好地融入了语言中。但对我来说,&quot;可变大小 &quot;和 &quot;必须位于cpu堆栈上 &quot;这两个要求从来没有出现过。这一直是关于速度的问题,所以我自己做了一种 &quot;数据缓冲区的并行堆栈&quot;。</target>
        </trans-unit>
        <trans-unit id="806120e29434febd69a611cfa95daf050d1eb4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; weren't a compile-time constant (i.e., if &lt;code&gt;A&lt;/code&gt; were of variably modified type), then what on earth would be the type of &lt;code&gt;S&lt;/code&gt;? Would &lt;code&gt;S&lt;/code&gt;'s type &lt;em&gt;also&lt;/em&gt; be determined only at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是编译时常量（即，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是可变修饰类型），那么&lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型到底是什么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是否&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅在运行时确定&lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cadc77c8df74681009ecd04756ffc8902be079f" translate="yes" xml:space="preserve">
          <source>If you know the value at compile time you can do the following:</source>
          <target state="translated">如果你在编译的时候知道这个值,你可以做以下操作。</target>
        </trans-unit>
        <trans-unit id="25cbd3dd21b283ae2f9d4eaa0a15a55aaabe20ce" translate="yes" xml:space="preserve">
          <source>In my own work, I've realized that every time I've wanted something like variable-length automatic arrays or alloca(), I didn't really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn't incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.</source>
          <target state="translated">在我自己的工作中,我意识到每次我想要的东西,比如可变长度的自动数组或 alloca(),我并不关心内存是否物理上位于 cpu 堆上,只关心它来自于某个堆栈分配器,而不是在一般堆上产生缓慢的跳转。所以我有一个每线程对象,它拥有一些内存,可以从中推送可变大小的缓冲区。在某些平台上,我允许通过mmu来增长。其他平台有一个固定的大小(通常伴随着一个固定大小的cpu堆,因为没有mmu)。我工作的一个平台(一个掌上游戏机)的CPU堆栈很少,因为它是在稀缺的快速内存中。</target>
        </trans-unit>
        <trans-unit id="dd33745a32bdd5211fb2c5127b3c9b5f90a18898" translate="yes" xml:space="preserve">
          <source>Incompatible with some other part of the standard</source>
          <target state="translated">与标准的某些其他部分不兼容</target>
        </trans-unit>
        <trans-unit id="5ac82eedd3f1200472c3eaba3833822cef86f433" translate="yes" xml:space="preserve">
          <source>It would be less useful in C++ anyway since we already have &lt;code&gt;std::vector&lt;/code&gt; to fill this role.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论如何，由于我们已经有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来填补这个角色&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，所以在C ++中反而会有用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1581697271897ae6f955195983b3d11f133f2094" translate="yes" xml:space="preserve">
          <source>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an &lt;em&gt;arbitrarily large&lt;/em&gt; chunk of your stack. This is a &lt;em&gt;guaranteed&lt;/em&gt; stack-overflow and crash. (Anytime you declare &lt;code&gt;int A[n]&lt;/code&gt;, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;&lt;code&gt;n&lt;/code&gt; is definitely less than 1000 here&quot;, then you would just declare &lt;code&gt;int A[1000]&lt;/code&gt;. Substituting the 32-bit integer &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;1000&lt;/code&gt; is an admission that you have no idea what the behavior of your program ought to be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++世界中不太重要，但对于C的嵌入式系统程序员的目标受众来说极为重要，声明VLA意味着砍断&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的堆栈中&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大块。这是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保证的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;堆栈溢出和崩溃。 （每当您声明&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您都在隐式声明您有2GB的可用堆栈空间。毕竟，如果您知道&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里肯定小于1000&amp;rdquo;，则只需声明&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[1000]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用32位整数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示您不知道程序的行为是什么。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee478ffe7976d42688d8d55133a37aa8d78e1076" translate="yes" xml:space="preserve">
          <source>Looking at the discussion at &lt;code&gt;comp.std.c++&lt;/code&gt; it's clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It's certainly not obvious that a &lt;code&gt;std::vector&lt;/code&gt; is always a better solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看一下&lt;/font&gt;&lt;/font&gt; &lt;code&gt;comp.std.c++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上的讨论，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很明显这个问题引起了很大的争议，在参数的两边都有一些重量级的名字。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显然，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总是更好的解决方案。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d23541f85918fecd18aed7850a8f1c9c8290f19" translate="yes" xml:space="preserve">
          <source>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does&amp;hellip; but we've really started to rely on it in ways that C has not. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好的，让我们现在开始讨论C ++。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++中，我们在&amp;ldquo;类型系统&amp;rdquo;和&amp;ldquo;值系统&amp;rdquo;之间有着与C89相同的强烈区分&amp;hellip;&amp;hellip;但是我们实际上已经开始以C所没有的方式来依赖它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ca739bf4aeb3b4982657bdd41b8fe9da6e94f45" translate="yes" xml:space="preserve">
          <source>Quick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.</source>
          <target state="translated">快速说明:正如在Mac OS X的alloca(3)的man page中提到的,&quot;alloca()函数依赖于机器和编译器;不建议使用它。&quot; 只是为了让你知道。</target>
        </trans-unit>
        <trans-unit id="0e01ae80eca7726229f2af01f30f85a0011eb6a9" translate="yes" xml:space="preserve">
          <source>Seems it will be available in C++14:</source>
          <target state="translated">看来它将在C++14中可用。</target>
        </trans-unit>
        <trans-unit id="78b81ae2a7303fc5a23e553399b0905f9a785f46" translate="yes" xml:space="preserve">
          <source>Some potential reasons:</source>
          <target state="translated">一些潜在的原因:</target>
        </trans-unit>
        <trans-unit id="50eaf2461e5452bc32e18c3f4b245aeca3694981" translate="yes" xml:space="preserve">
          <source>The C++ standard states that array size must be a constant expression (8.3.4.1).</source>
          <target state="translated">C++标准规定,数组大小必须是一个常量表达式(8.3.4.1)。</target>
        </trans-unit>
        <trans-unit id="655fdfc4e1350fd04dedffef0af28d6ff24f2e3e" translate="yes" xml:space="preserve">
          <source>The compiler must generate code for some instantiation of &lt;code&gt;myfunc&lt;/code&gt;. What should that code look like? How can we statically generate that code, if we don't know the type of &lt;code&gt;A1&lt;/code&gt; at compile time?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器必须为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某些实例生成代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该代码应该是什么样的？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在编译时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不知道&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型，该如何静态生成该代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="847c10687fcd80e916d369da37b004d639c21542" translate="yes" xml:space="preserve">
          <source>The dangers here are many but I'll explain a few:
1. Changing the variable size half way through would kill the stack position
2. Overstepping the array bounds would destroy other variables and possible code
3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).
4. Compiler specific (may have trouble moving between compilers).  I haven't tried so I really don't know.</source>
          <target state="translated">这里的危险有很多,但我解释几个。1.半途改变变量的大小会杀死堆栈位置 2.超越数组界限会破坏其他变量和可能的代码 3.这在64位构建中是行不通的...........需要不同的程序集(但宏可能会解决这个问题)。4.4.特定于编译器(可能在不同的编译器之间移动可能会有问题)。我没有试过,所以真的不知道。</target>
        </trans-unit>
        <trans-unit id="ffdfec5bfb16136c85636bab88bfef33b85826e8" translate="yes" xml:space="preserve">
          <source>The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.</source>
          <target state="translated">内存将被分配到堆上,但这只是一个小小的性能缺点。此外,最好不要在堆上分配大的数据块,因为它的大小相当有限。</target>
        </trans-unit>
        <trans-unit id="69ed5f106cde9304603393d4b69ea6fbaecdca3c" translate="yes" xml:space="preserve">
          <source>The slices, rows and columns will also potentially be spread all over memory.</source>
          <target state="translated">切片、行和列也将有可能遍布内存。</target>
        </trans-unit>
        <trans-unit id="75337abd29d36b2aeb6bdec77608f4f9ddbc9d82" translate="yes" xml:space="preserve">
          <source>There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.</source>
          <target state="translated">有些情况下,分配堆内存与执行的操作相比是非常昂贵的。一个例子是矩阵数学。如果你处理小的矩阵,比如说5到10个元素的小矩阵,并进行大量的运算,那么malloc开销就会非常大。同时,将大小作为编译时间的常数似乎是非常浪费和不灵活的。</target>
        </trans-unit>
        <trans-unit id="2d9540c95adf01bfe96108186fa43c95f4aed84b" translate="yes" xml:space="preserve">
          <source>There recently was a discussion about this kicked off in usenet: &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;Why no VLAs in C++0x&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最近在usenet中开始了对此的讨论：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么C ++ 0x中没有VLA&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="420e9d809f5e55e35af61e0458dc9062b1a84947" translate="yes" xml:space="preserve">
          <source>This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?</source>
          <target state="translated">这似乎是一个非常有用的功能。有没有讨论过将其添加到C++标准中,如果有,为什么会被省略?</target>
        </trans-unit>
        <trans-unit id="3681bd7c879cf246e529cb1459aabbd71d7929c7" translate="yes" xml:space="preserve">
          <source>This was considered for inclusion in C++/1x, &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;but was dropped&lt;/a&gt; (this is a correction to what I said earlier).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑将其包含在C ++ / 1x中，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但被删除了&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（这是我之前所说的更正）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c5efb0ed4cfdb41bfe29546748a6ee08ea79f76" translate="yes" xml:space="preserve">
          <source>Use std::vector for this. For example:</source>
          <target state="translated">使用 std::::向量。例如:</target>
        </trans-unit>
        <trans-unit id="4dc64eaed80a49209b7212897182856b464ff4d2" translate="yes" xml:space="preserve">
          <source>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</source>
          <target state="translated">C99中的可变长度数组基本上是一个误区。为了支持可变长度阵列,C99不得不对常识做出以下让步:</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">那这个呢?</target>
        </trans-unit>
        <trans-unit id="57a287a958e4cca4d33101677876891076290e24" translate="yes" xml:space="preserve">
          <source>Why aren't variable-length arrays part of the C++ standard</source>
          <target state="translated">为什么可变长度数组不是C++标准的一部分?</target>
        </trans-unit>
        <trans-unit id="fbf2b06494f2d7238597a77fef7d9a9871f70987" translate="yes" xml:space="preserve">
          <source>Worse, what if it turns out at runtime that &lt;code&gt;n1 != n2&lt;/code&gt;, so that &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt;? In that case, the call to &lt;code&gt;myfunc&lt;/code&gt;&lt;strong&gt;shouldn't even compile&lt;/strong&gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更糟糕的是，如果在运行时发现&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n1 != n2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么&lt;/font&gt;&lt;/font&gt; &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;怎样？在这种情况下，对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的调用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;甚至都不应编译&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因为模板类型推导应该失败！我们如何在运行时模拟这种行为？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c57bc85dabed67fd51c3d2de29053b72562c2e1" translate="yes" xml:space="preserve">
          <source>Yes, of course I realize that in the toy example one could use &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是的，我当然知道在玩具示例中可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但这会从堆而不是堆栈分配内存。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我想要像这样的多维数组：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0835518093c390c7915b0891f2f795ec06ad215" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;std::vector&lt;/code&gt;, but it is not quite the same, as it uses dynamic memory, and making it use one's own stack-allocator isn't exactly easy (alignment is an issue, too). It also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;C++ Dynamic Array&lt;/a&gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it's not going to be part of C++0x, as far as I know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但它并不完全相同，因为它使用动态内存，并且使其使用自己的堆栈分配器并非易事（对齐也是一个问题）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它还不能解决相同的问题，因为矢量是可调整大小的容器，而VLA是固定大小的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++动态阵列&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提议旨在介绍文库的基于溶液，作为替代基于VLA的语言。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，据我所知，它不会成为C ++ 0x的一部分。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee49e1beb61b1f02cbef2c02b8330c97d6649909" translate="yes" xml:space="preserve">
          <source>You could always use alloca() to allocate memory on the stack at runtime, if you wished:</source>
          <target state="translated">如果你愿意,你可以在运行时使用 alloca()来分配内存。</target>
        </trans-unit>
        <trans-unit id="bf51f2d5a13b6be238f5a5ebdba02e8e898f9f44" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;vector&lt;/code&gt; version becomes pretty clumsy:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;版本变得很笨拙：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
