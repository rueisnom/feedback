<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1887097">
    <body>
      <group id="1887097">
        <trans-unit id="784ca4d89f40759259eb634137d78b2eb572edaf" translate="yes" xml:space="preserve">
          <source>(Background: I have some experience implementing C and C++ compilers.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(배경 : C 및 C ++ 컴파일러 구현 경험이 있습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd9ef556311be517a525bb3524ed59007934b5f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof x&lt;/code&gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a &lt;code&gt;sizeof&lt;/code&gt;-expression at runtime.</source>
          <target state="translated">&lt;code&gt;sizeof x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 더 이상 항상 컴파일 타임 상수가 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러는 때때로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -expression &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을 평가하는 코드를 생성해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7dd54a911c89231a7841010f0dc0907da5aa8a08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update: It did not make it into C++14.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;업데이트 : C ++ 14로 만들지 않았습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7eff072167bda04c186c36234a3426822f1ecf7" translate="yes" xml:space="preserve">
          <source>A good blog post that hits many of these same points is &lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&quot;Legitimate Use of Variable Length Arrays&quot;&lt;/a&gt; (Chris Wellons, 2019-10-27).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이와 같은 여러 가지 요점을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다루는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좋은 블로그 게시물은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;가변 길이 배열의 합법적 사용&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (Chris Wellons, 2019-10-27)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10d6a21bb53b190c7591942063680aa1e2b5e04" translate="yes" xml:space="preserve">
          <source>Allowing two-dimensional VLAs (&lt;code&gt;int A[x][y]&lt;/code&gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2 차원 VLA ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[x][y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )를 허용하려면 2D VLA를 매개 변수로 사용하는 함수를 선언하는 새로운 구문이 필요했습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0df2d17c8e3e4ce8e39e408df55ebd969517f123" translate="yes" xml:space="preserve">
          <source>Apparently in &lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;C99&lt;/a&gt; the following syntax is valid:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;분명히 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서는 다음 구문이 유효합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f54311051e5aef26e0c96d5f655fda12ee6e7f5" translate="yes" xml:space="preserve">
          <source>Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이와 같은 배열은 C99의 일부이지만 표준 C ++의 일부는 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 사람들이 말했듯이 벡터는 항상 훨씬 나은 솔루션이므로 가변 크기 배열이 C ++ standatrd (또는 제안 된 C ++ 0x 표준)에없는 이유 일 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="06b95a46628b5fa3ceb1519d192f271c27836750" translate="yes" xml:space="preserve">
          <source>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (&lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; or &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully &lt;em&gt;this&lt;/em&gt; answer gives you a good idea of why C99-style VLAs were &lt;strong&gt;not&lt;/strong&gt; a good fit for C++ &amp;mdash; and not really even a good fit for C99. ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 모든 응답자가 이미 지적한 바와 같이, C가 ++ 힙 할당 메커니즘을 많이 (제공 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인 &quot;내가 필요로하는 RAM의 양을 모른다&quot;는 아이디어를 실제로 전달하고 싶을 때 그리고 C ++은 필요한 RAM의 양이 RAM의 양보다 큰 불가피한 상황을 처리하기위한 멋진 예외 처리 모델을 제공합니다. 그러나이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;답변 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C99 스타일 VLA가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에 적합 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이유와 C99에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;적합 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않은&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이유에 대한 좋은 아이디어를 제공하기를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바랍니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. ;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4409ffad589b749dae53fad479eb3a17e0038fa" translate="yes" xml:space="preserve">
          <source>BTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;comp.std.c++&lt;/a&gt; is the place to go to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BTW, C ++ 표준이 &quot;이유&quot;인 방식에 대한 질문에 대해서는 검토 된 Usenet 뉴스 그룹 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comp.std.c ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a620acbc347ecec3c138d2d3ca0dbed0284b793a" translate="yes" xml:space="preserve">
          <source>Basically, C++ is moving in the direction of pushing more and more decisions into &lt;em&gt;compile-time&lt;/em&gt;: template code generation, &lt;code&gt;constexpr&lt;/code&gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally &lt;em&gt;compile-time&lt;/em&gt; decisions (e.g. &lt;code&gt;sizeof&lt;/code&gt;) into the &lt;em&gt;runtime&lt;/em&gt;. With this in mind, does it really even make sense to expend any effort &lt;em&gt;trying&lt;/em&gt; to integrate C99-style VLAs into C++?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 C ++은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;템플릿 코드 생성, &lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 함수 평가 등과 같이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;점점 더 많은 의사 결정을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 추진하는 방향으로 나아가고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다. 한편, C99는 전통적으로 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 결정 (예 : &lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; )을 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추진하는 데 바빴습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이를 염두에두고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 스타일 VLA를 C ++에 통합 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하려는 노력&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기울이는 것이 합리적 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일까요?&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5380f57134755717cd1c2a14e436a8f87d84912f" translate="yes" xml:space="preserve">
          <source>Being allocated on the stack implies that it will automatically be freed when the stack unwinds.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스택에 할당된다는 것은 스택이 풀릴 때 스택이 자동으로 해제됨을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b6e50a6540998dfdf1bd5337908c87ec9472523" translate="yes" xml:space="preserve">
          <source>C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for &lt;code&gt;new&lt;/code&gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the &lt;code&gt;new&lt;/code&gt; operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 VLA는 공간을 낭비하거나 사용하지 않는 요소에 대해 생성자를 호출하지 않고도 작은 배열을 만들 수 있다는 작은 이점을 제공 할 수 있지만 유형 시스템에 약간의 변경이 발생할 수 있습니다 (런타임 값에 따라 유형을 지정할 수 있어야 함). &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 유형 지정자를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제외하고 현재 C ++에는 아직 존재하지 않지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임 처리가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 범위를 벗어나지 않도록 특별히 처리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be03536da2738f7ab85762b2cd2586b270bc45b5" translate="yes" xml:space="preserve">
          <source>C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99는 VLA를 허용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 VLA를 선언하는 방법에 대한 제한이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 내용은 표준 6.7.5.2를 참조하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++은 VLA를 허용하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 g ++은 허용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff06bf861788256153b9aa642197bf2b5cc9e3d4" translate="yes" xml:space="preserve">
          <source>Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집 : 할당자는 템플릿 매개 변수이므로 스택 할당 자 (alloca)를 사용하는 벡터를 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5bf5e1a7099d677043a8233206392681c482fe3" translate="yes" xml:space="preserve">
          <source>For more on the topic, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;N3810 &quot;Alternatives for Array Extensions&quot;&lt;/a&gt;, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish &lt;em&gt;syntax&lt;/em&gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 주제에 대한 자세한 내용은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Vjar에 대한&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Bjarne Stroustrup의 2013 년 10 월 백서 인 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810 &quot;어레이 확장을위한 대안&quot;을&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bjarne의 POV는 나와 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N3810은 사물에 대한 좋은 C ++ ish &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구문&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;찾고 C ++ &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 raw arrays를 사용하지 않는 데 중점을 두는 반면 메타 프로그래밍 및 형식 시스템에 대한 의미에 더 중점을 두었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그가 메타 프로그래밍 / 유형 시스템의 함의를 풀거나 해결할 수 있거나 단순히 흥미롭지 않은 것으로 간주하는지 모르겠습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb2d1834d43cb060504a5afff92b3f0a0bed81ab" translate="yes" xml:space="preserve">
          <source>Functionality can be emulated with other C++ constructs</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 C ++ 구문으로 기능을 에뮬레이션 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68da06e3377221e5de796920784d7792915f6b43" translate="yes" xml:space="preserve">
          <source>Hairy for compiler vendors to implement</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러 공급 업체가 구현하기에 적합&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="482371147860afa9336450d7edcf30d7034eb677" translate="yes" xml:space="preserve">
          <source>I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good. The argument is, if you know the size beforehand, you can use a static array. And if you don't know the size beforehand, you will write unsafe code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 사용 가능한 공간이 거의없는 스택에서 잠재적으로 큰 배열을 작성하는 것이 좋지 않다는 데 동의하는 사람들에 동의합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인수는 크기를 미리 알고 있다면 정적 배열을 사용할 수 있다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;미리 크기를 모르면 안전하지 않은 코드를 작성합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a5812f28b35bcb48f76c49d410771ce71507939" translate="yes" xml:space="preserve">
          <source>I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 나를 위해 일한 해결책이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 번 실행 해야하는 루틴에서 조각화로 인해 메모리를 할당하고 싶지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;답은 매우 위험하므로 위험 부담으로 사용하되 스택의 공간을 확보하기 위해 어셈블리를 활용하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 예제는 문자 배열을 사용합니다 (확실히 다른 크기의 변수에는 더 많은 메모리가 필요합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b6d7e46d378f04d1801a2f622b99ad73ae0868e1" translate="yes" xml:space="preserve">
          <source>I haven't used C very much in the last few years. When I read &lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;this question&lt;/a&gt; today I came across some C syntax which I wasn't familiar with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지난 몇 년 동안 C를 많이 사용하지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오늘 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 읽으면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;익숙하지 않은 C 구문을 발견했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e816f117cd47a20e41b1c7e0c81387cbf2ad034" translate="yes" xml:space="preserve">
          <source>I think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I'm working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 자체는 안전하지 않다고 생각하여 &quot;안전하지 않은 기능을 더 추가하지 마십시오&quot;라는 주장은 그다지 강력하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 C ++은 런타임에 가장 효율적인 프로그래밍 언어 기능이므로 항상 유용합니다. 성능이 중요한 프로그램을 작성하는 사람들은 C ++을 많이 사용하므로 가능한 한 많은 성능이 필요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;힙에서 스택으로 물건을 옮기는 것이 그러한 가능성 중 하나입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;힙 블록 수를 줄이는 것도 또 다른 방법입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VLA를 객체 멤버로 허용하면이를 달성 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 그런 제안을하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 구현하기는 다소 복잡하지만 상당히 가능해 보입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40cb19fb71abfcdc362b9ffad13d776256923c2a" translate="yes" xml:space="preserve">
          <source>I'm not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn't standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It's been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가변 크기의 버퍼를 CPU 스택에 밀어 넣을 필요가 없다고 말하는 것은 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;솔직히 말해서 이것이 표준이 아니라는 것을 알았을 때 놀랐습니다. 개념이 언어에 잘 맞는 것처럼 보입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래도 &quot;가변 크기&quot;와 &quot;CPU 스택에 물리적으로 위치해야합니다&quot;라는 요구 사항은 결코 합쳐지지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속도에 관한 것이었기 때문에 필자가 직접 &quot;데이터 버퍼에 대한 병렬 스택&quot;을 만들었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="806120e29434febd69a611cfa95daf050d1eb4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; weren't a compile-time constant (i.e., if &lt;code&gt;A&lt;/code&gt; were of variably modified type), then what on earth would be the type of &lt;code&gt;S&lt;/code&gt;? Would &lt;code&gt;S&lt;/code&gt;'s type &lt;em&gt;also&lt;/em&gt; be determined only at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 컴파일 타임 상수가 아닌 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(즉, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 가변적으로 수정 된 유형 인 경우) 지구상에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 유형은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;겠습니까 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;S&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 유형은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 실행시에 결정된다?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cadc77c8df74681009ecd04756ffc8902be079f" translate="yes" xml:space="preserve">
          <source>If you know the value at compile time you can do the following:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임에 값을 알고 있으면 다음을 수행 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25cbd3dd21b283ae2f9d4eaa0a15a55aaabe20ce" translate="yes" xml:space="preserve">
          <source>In my own work, I've realized that every time I've wanted something like variable-length automatic arrays or alloca(), I didn't really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn't incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 자신의 작업에서 가변 길이 자동 배열이나 alloca ()와 같은 것을 원할 때마다 메모리가 실제로 CPU 스택에 위치하고 있다는 것을 신경 쓰지 않았다는 것을 깨달았습니다. 일반 힙으로의 느린 트립을 발생시키지 않은 일부 스택 할당 자. 그래서 가변 크기의 버퍼를 푸시 / 팝 할 수있는 메모리를 소유 한 스레드 당 객체가 있습니다. 일부 플랫폼에서는 mmu를 통해 이것이 커질 수 있습니다. 다른 플랫폼의 크기는 고정되어 있습니다 (일반적으로 mmu가 없기 때문에 고정 크기 CPU 스택과 함께 제공됨). 내가 작업하는 하나의 플랫폼 (휴대용 게임 콘솔)에는 어쨌든 빠른 메모리에 있기 때문에 귀중한 작은 CPU 스택이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd33745a32bdd5211fb2c5127b3c9b5f90a18898" translate="yes" xml:space="preserve">
          <source>Incompatible with some other part of the standard</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표준의 다른 부분과 호환되지 않습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ac82eedd3f1200472c3eaba3833822cef86f433" translate="yes" xml:space="preserve">
          <source>It would be less useful in C++ anyway since we already have &lt;code&gt;std::vector&lt;/code&gt; to fill this role.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 역할을 수행하기 위해 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이미 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 있기 때문에 어쨌든 C ++에서는 유용하지 않습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1581697271897ae6f955195983b3d11f133f2094" translate="yes" xml:space="preserve">
          <source>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an &lt;em&gt;arbitrarily large&lt;/em&gt; chunk of your stack. This is a &lt;em&gt;guaranteed&lt;/em&gt; stack-overflow and crash. (Anytime you declare &lt;code&gt;int A[n]&lt;/code&gt;, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;&lt;code&gt;n&lt;/code&gt; is definitely less than 1000 here&quot;, then you would just declare &lt;code&gt;int A[1000]&lt;/code&gt;. Substituting the 32-bit integer &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;1000&lt;/code&gt; is an admission that you have no idea what the behavior of your program ought to be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;덜 중요한 것은 C ++ 세계 있지만 받기를 갈망 VLA 수단 선언, 임베디드 시스템 프로그래머 C의 타겟 고객을위한 매우 중요한에서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임의의 큰&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 당신의 스택의 덩어리를. 이것은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보장 된&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스택 오버플로 및 충돌입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 선언 할 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때마다 2GB의 여유 공간이 있다고 암시 적으로 주장합니다. 결국 &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 확실히 1000보다 작습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;를 알고 있으면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int A[1000]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 선언하면됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 32 비트 정수 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; 으로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대체하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램의 동작이 무엇인지 모를 수 있습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee478ffe7976d42688d8d55133a37aa8d78e1076" translate="yes" xml:space="preserve">
          <source>Looking at the discussion at &lt;code&gt;comp.std.c++&lt;/code&gt; it's clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It's certainly not obvious that a &lt;code&gt;std::vector&lt;/code&gt; is always a better solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;comp.std.c++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 토론을 보면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문은 논쟁의 양쪽에 매우 무거운 이름이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;붙어&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있어 논란의 여지가 있습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 항상 더 나은 솔루션 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이라는 것은 확실하지 않습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d23541f85918fecd18aed7850a8f1c9c8290f19" translate="yes" xml:space="preserve">
          <source>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does&amp;hellip; but we've really started to rely on it in ways that C has not. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자 이제 C ++에 대해 이야기하도록하겠습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에서, 우리는 C89가하는 &quot;유형 시스템&quot;과 &quot;가치 시스템&quot;사이에 동일한 차이점이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들면 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ca739bf4aeb3b4982657bdd41b8fe9da6e94f45" translate="yes" xml:space="preserve">
          <source>Quick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빠른 참고 사항 : alloca (3)에 대한 Mac OS X 매뉴얼 페이지에서 언급 한 바와 같이, &quot;alloca () 함수는 기계 및 컴파일러에 따라 다르며 사용이 권장되지 않습니다.&quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알다시피&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e01ae80eca7726229f2af01f30f85a0011eb6a9" translate="yes" xml:space="preserve">
          <source>Seems it will be available in C++14:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 14에서 사용할 수있는 것 같습니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78b81ae2a7303fc5a23e553399b0905f9a785f46" translate="yes" xml:space="preserve">
          <source>Some potential reasons:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 가지 잠재적 인 이유 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50eaf2461e5452bc32e18c3f4b245aeca3694981" translate="yes" xml:space="preserve">
          <source>The C++ standard states that array size must be a constant expression (8.3.4.1).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 표준에 따르면 배열 크기는 상수 식 (8.3.4.1)이어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="655fdfc4e1350fd04dedffef0af28d6ff24f2e3e" translate="yes" xml:space="preserve">
          <source>The compiler must generate code for some instantiation of &lt;code&gt;myfunc&lt;/code&gt;. What should that code look like? How can we statically generate that code, if we don't know the type of &lt;code&gt;A1&lt;/code&gt; at compile time?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인스턴스화를위한 코드를 생성해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 코드는 어떻게 생겼습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형을 모른다면 어떻게 정적으로 코드를 생성 할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="847c10687fcd80e916d369da37b004d639c21542" translate="yes" xml:space="preserve">
          <source>The dangers here are many but I'll explain a few:
1. Changing the variable size half way through would kill the stack position
2. Overstepping the array bounds would destroy other variables and possible code
3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).
4. Compiler specific (may have trouble moving between compilers).  I haven't tried so I really don't know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에 많은 위험이 있지만 몇 가지를 설명 할 것입니다. 1. 변수 크기를 절반으로 변경하면 스택 위치가 종료됩니다. 빌드 ... 그것에 대해 다른 어셈블리가 필요합니다 (그러나 매크로는 그 문제를 해결할 수 있습니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4. 컴파일러에 따라 다릅니다 (컴파일러 간 이동에 문제가있을 수 있음). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 시도하지 않았으므로 나는 정말로 모른다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffdfec5bfb16136c85636bab88bfef33b85826e8" translate="yes" xml:space="preserve">
          <source>The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리는 힙에 할당되지만 작은 성능 저하 만 보유합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한, 크기가 다소 제한되어 있으므로 스택에 큰 데이터 블록을 할당하지 않는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="69ed5f106cde9304603393d4b69ea6fbaecdca3c" translate="yes" xml:space="preserve">
          <source>The slices, rows and columns will also potentially be spread all over memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;슬라이스, 행 및 열도 메모리 전체에 분산 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75337abd29d36b2aeb6bdec77608f4f9ddbc9d82" translate="yes" xml:space="preserve">
          <source>There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;힙 메모리 할당이 수행되는 작업과 비교하여 비용이 많이 드는 상황이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 행렬 수학이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작은 행렬로 5 ~ 10 개의 요소를 사용하고 많은 산술을 수행하는 경우 malloc 오버 헤드가 실제로 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동시에 크기를 컴파일 시간을 일정하게 만드는 것은 매우 낭비적이고 유연하지 않은 것처럼 보입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d9540c95adf01bfe96108186fa43c95f4aed84b" translate="yes" xml:space="preserve">
          <source>There recently was a discussion about this kicked off in usenet: &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;Why no VLAs in C++0x&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최근 유즈넷에서 쫓겨 이에 대한 토론이 있었다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 C + +0 없음 블라스&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="420e9d809f5e55e35af61e0458dc9062b1a84947" translate="yes" xml:space="preserve">
          <source>This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 매우 유용한 기능인 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 표준에 추가하는 것에 대한 토론이 있었습니까? 그렇다면 왜 생략 되었습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3681bd7c879cf246e529cb1459aabbd71d7929c7" translate="yes" xml:space="preserve">
          <source>This was considered for inclusion in C++/1x, &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;but was dropped&lt;/a&gt; (this is a correction to what I said earlier).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 C ++ / 1x에 포함될 것으로 간주 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되었지만 삭제되었습니다&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (이것은 내가 이전에 말한 것에 대한 수정입니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c5efb0ed4cfdb41bfe29546748a6ee08ea79f76" translate="yes" xml:space="preserve">
          <source>Use std::vector for this. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 위해 std :: vector를 사용하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들면 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dc64eaed80a49209b7212897182856b464ff4d2" translate="yes" xml:space="preserve">
          <source>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99의 가변 길이 배열은 기본적으로 잘못된 단계였습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VLA를 지원하기 위해 C99는 상식적으로 다음과 같은 양보를해야했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">이건 어때?</target>
        </trans-unit>
        <trans-unit id="57a287a958e4cca4d33101677876891076290e24" translate="yes" xml:space="preserve">
          <source>Why aren't variable-length arrays part of the C++ standard</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가변 길이 배열이 C ++ 표준의 일부가 아닌 이유&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbf2b06494f2d7238597a77fef7d9a9871f70987" translate="yes" xml:space="preserve">
          <source>Worse, what if it turns out at runtime that &lt;code&gt;n1 != n2&lt;/code&gt;, so that &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt;? In that case, the call to &lt;code&gt;myfunc&lt;/code&gt;&lt;strong&gt;shouldn't even compile&lt;/strong&gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나쁜 것은 런타임에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n1 != n2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? 이 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;템플릿 유형 공제가 실패하므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;myfunc&lt;/code&gt; 에&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 호출 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 컴파일되지&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 않아야합니다! 런타임에 어떻게 그 동작을 에뮬레이트 할 수 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c57bc85dabed67fd51c3d2de29053b72562c2e1" translate="yes" xml:space="preserve">
          <source>Yes, of course I realize that in the toy example one could use &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 장난감 예제에서는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;int&amp;gt; values(m);&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 스택이 아닌 힙에서 메모리를 할당합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 다음과 같은 다차원 배열을 원한다면 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0835518093c390c7915b0891f2f795ec06ad215" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;std::vector&lt;/code&gt;, but it is not quite the same, as it uses dynamic memory, and making it use one's own stack-allocator isn't exactly easy (alignment is an issue, too). It also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;C++ Dynamic Array&lt;/a&gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it's not going to be part of C++0x, as far as I know.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용할 수는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 동적 메모리를 사용하므로 고유 한 스택 할당기를 사용하는 것은 쉽지 않습니다 (정렬도 문제입니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;벡터는 크기 조정이 가능한 컨테이너이고 VLA는 고정 크기이므로 동일한 문제를 해결하지 못합니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 동적 배열&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 제안은 VLA 기반 언어에 대한 대안으로, 라이브러리 기반 솔루션을 소개하기위한 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 내가 아는 한 C ++ 0x의 일부는 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee49e1beb61b1f02cbef2c02b8330c97d6649909" translate="yes" xml:space="preserve">
          <source>You could always use alloca() to allocate memory on the stack at runtime, if you wished:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원하는 경우 런타임에 alloca ()를 사용하여 스택에 메모리를 할당 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf51f2d5a13b6be238f5a5ebdba02e8e898f9f44" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;vector&lt;/code&gt; version becomes pretty clumsy:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 버전은 꽤 서투른된다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
