<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1817792">
    <body>
      <group id="1817792">
        <trans-unit id="cfd30f7039826be63e4b6a3c5bfcb1de442aff43" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but at the time of writing, it is some distance beyond the bleeding edge for browser support.</source>
          <target state="translated">&amp;hellip; 그러나 글을 쓰는 시점에서 브라우저 지원을위한 최첨단을 벗어난 거리입니다.</target>
        </trans-unit>
        <trans-unit id="407ed6a05587d34adfc62e13d2c7581f19e9ddb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/Types/#jQuery&quot;&gt;&lt;strong&gt;$()&lt;/strong&gt; or jQuery()&lt;/a&gt;: DOM element.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/Types/#jQuery&quot;&gt;&lt;strong&gt;$ ()&lt;/strong&gt; 또는 jQuery ()&lt;/a&gt; : DOM 요소.</target>
        </trans-unit>
        <trans-unit id="48db37a8d0a9b127a2f7a5a9e02bd47efd360bfd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/css/#css2&quot;&gt;.&lt;strong&gt;css&lt;/strong&gt;&lt;/a&gt;: Set one or more CSS properties for the set of matched elements.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/css/#css2&quot;&gt;.&lt;/a&gt; &lt;strong&gt;css&lt;/strong&gt; : 일치하는 요소 집합에 대해 하나 이상의 CSS 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="75e7927b9566ce6bd718571221a8e19eb49ccf96" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/find/&quot;&gt;.&lt;strong&gt;find&lt;/strong&gt;&lt;/a&gt;: Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/find/&quot;&gt;.&lt;/a&gt; &lt;strong&gt;find&lt;/strong&gt; : 현재 일치하는 요소 집합에서 각 요소의 자손을 가져와 선택기, jQuery 객체 또는 요소로 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="8d311dec0c9ffe26c57e1d991ac5a86500c0a3ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/parents/&quot;&gt;.&lt;strong&gt;parents&lt;/strong&gt;&lt;/a&gt;: Get the immediately preceding sibling of each element in the set of matched elements. If a selector is provided, it retrieves the previous sibling only if it matches that selector (filters the results to only include the listed elements/selectors).</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/parents/&quot;&gt;.&lt;/a&gt; &lt;strong&gt;부모&lt;/strong&gt; : 일치하는 요소 집합에서 각 요소의 바로 이전 형제를 가져옵니다. 선택기가 제공되면 해당 선택기와 일치하는 경우에만 이전 형제를 검색합니다 (목록에있는 요소 / 선택기 만 포함하도록 결과를 필터링 함).</target>
        </trans-unit>
        <trans-unit id="08ecad35fbab8b5e681a1477564edd0f2d0ee919" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://drafts.csswg.org/selectors-4/#relational&quot;&gt;Selectors level 4 introduces &lt;code&gt;:has()&lt;/code&gt;&lt;/a&gt; (previously the subject indicator &lt;code&gt;!&lt;/code&gt;) which will allow you to select a previous sibling with:</source>
          <target state="translated">&lt;a href=&quot;https://drafts.csswg.org/selectors-4/#relational&quot;&gt;선택기 레벨 4에는 &lt;code&gt;:has()&lt;/code&gt; &lt;/a&gt; (이전 제목 표시기 &lt;code&gt;!&lt;/code&gt; ) 가 도입되어 다음 과 같은 이전 형제를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c357fe7705c3417a859eaeabc538a7cb2284380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is the &lt;em&gt;any&lt;/em&gt; previous sibling selector (opposite of &lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 이전의 형제 선택기입니다 ( &lt;code&gt;~&lt;/code&gt; 의 반대)</target>
        </trans-unit>
        <trans-unit id="ed595455871545edca70be20be7efc07d20cc069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; is for the next sibling. Is there an equivalent for the previous
  sibling?</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 는 다음 형제 자매입니다. 이전 형제와 동등한 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="2f01423323702105439497e1c1b1f5d8a4578966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; is the &lt;em&gt;immediate&lt;/em&gt; subsequent sibling selector</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 는 &lt;em&gt;바로&lt;/em&gt; 후속 형제 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="94c29eabcf56b07996e3c04cee5016c0b6b57491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.any-previous:hover ! div&lt;/code&gt; selects any previous &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.any-previous:hover ! div&lt;/code&gt; div 는 이전 div를 선택합니다</target>
        </trans-unit>
        <trans-unit id="c8e28436ba5f1efcd8efa165ba47d3e251d9ba3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.any-subsequent:hover ~ div&lt;/code&gt; selects any subsequent &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.any-subsequent:hover ~ div&lt;/code&gt; 는 모든 후속 &lt;code&gt;div&lt;/code&gt; 를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e22f1f4ce5332c6c4d74834c3f051b795a416ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.immediate-previous:hover ? div&lt;/code&gt; selects the immediate previous &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.immediate-previous:hover ? div&lt;/code&gt; div 는 직전의 div를 선택합니다</target>
        </trans-unit>
        <trans-unit id="dcc37d93e8f59249a257da2bc655302e547e6940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.immediate-subsequent:hover + div&lt;/code&gt; selects the immediate subsequent &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.immediate-subsequent:hover + div&lt;/code&gt; 는 즉시 후속 &lt;code&gt;div&lt;/code&gt; 를 선택합니다</target>
        </trans-unit>
        <trans-unit id="3b0910f8c897e49b7c54ad2f06472848fb9d8227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; is the &lt;em&gt;immediate&lt;/em&gt; previous sibling selector (opposite of &lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; &lt;em&gt;직전의&lt;/em&gt; 형제 선택기입니다 ( &lt;code&gt;+&lt;/code&gt; 의 반대)</target>
        </trans-unit>
        <trans-unit id="0dee39345cc6ee1279934352bcdade2c20b08a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float-right&lt;/code&gt;&lt;em&gt;+&lt;/em&gt; inverse the order of HTML elements</source>
          <target state="translated">&lt;code&gt;float-right&lt;/code&gt; &lt;em&gt;+&lt;/em&gt; HTML 요소의 순서를 반대로</target>
        </trans-unit>
        <trans-unit id="a1da221ab5c3c8b901ce1eb61884ddc4fe922545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; is the &lt;em&gt;any&lt;/em&gt; subsequent sibling selector</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 는 후속 형제 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="768eb8921a37f993d92f5a0ef2bfd879be384f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;&lt;em&gt;Next siblings&lt;/em&gt; operator:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; &lt;em&gt;다음 형제&lt;/em&gt; 연산자 :</target>
        </trans-unit>
        <trans-unit id="b45ad163a8651c34a0d16d8e3b362d9b76693378" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;sub&gt;(emphasis added)&lt;/sub&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;sub&gt;(강조 추가)&lt;/sub&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="665e55d598d2c11ce4bb90a276830bf6f0fde666" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'll focus on flexbox in the examples below, but the same concepts apply to Grid.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;아래 예제에서는 flexbox에 중점을 두지 만 동일한 개념이 Grid에도 적용됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52a133130a0d198eae4a4b7c47737e1a8e62f4d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3. Flex Item Z-Ordering&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3.&lt;/strong&gt; &lt;strong&gt;플렉스 아이템 Z 주문&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32158f358671818399bba29dbf2c3ba4ab6fc268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.4. Display Order: the &lt;code&gt;order&lt;/code&gt; property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.4.&lt;/strong&gt; &lt;strong&gt;주문 표시 : &lt;code&gt;order&lt;/code&gt; 속성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6853f54f67919916de40ab32c854f669cb4c3c30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.4. Z-axis Ordering: the &lt;code&gt;z-index&lt;/code&gt; property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.4.&lt;/strong&gt; &lt;strong&gt;Z 축 순서 : &lt;code&gt;z-index&lt;/code&gt; 속성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83b05dfec3718db0552391149c0e3d7bda0c2c75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;9.9.1 Specifying the stack level: the &lt;code&gt;z-index&lt;/code&gt;
  property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스택 레벨 지정 : &lt;code&gt;z-index&lt;/code&gt; 속성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b5bfef254b9205245032da598adfe5fc3f90e42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01195ef0b572066871d7b5aad840247fb5f2ad5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;...and voil&amp;agrave;! A previous sibling selector is born (or at least simulated).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;... 그리고!&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;이전 형제 선택기가 생성되었습니다 (또는 적어도 시뮬레이션).&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a2de40614250939e1ac2028b79c2f603e140dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Applies to:      positioned elements&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;적용 대상 : 위치 지정된 요소&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="106af0ab2a1746027aea14ca5280bdf5ceef5300" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;The &lt;code&gt;z-index&lt;/code&gt; Myth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;z-index&lt;/code&gt; 신화&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54a6fe3317e75fae016e1ae7d0ef63443ca1c7a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of &quot;previous sibling selectors&quot; created with the flex &lt;code&gt;order&lt;/code&gt; property.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flex &lt;code&gt;order&lt;/code&gt; 속성으로 작성된 &quot;이전 형제 선택기&quot;의 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5d9c630b449804340bc41d05ef058ebd4817f77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With flexbox, a previous sibling selector can be simulated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flexbox를 사용하면 이전 형제 선택기를 시뮬레이션 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d1b833d633fafc0324f01aebae36d3b39fe40f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Working Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작업 예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9446e60594ae9c87ddb1b319e8f4165d0296891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery Reference Docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery 참조 문서 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37825b906e4a796703b6c32120b0fdcf3c0e47fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jsFiddle&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jsFiddle&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8920f7186483b1f6b58964d259171e0a79ef8336" translate="yes" xml:space="preserve">
          <source>A Side Note &amp;ndash; Two Outdated Beliefs about CSS</source>
          <target state="translated">참고 사항 &amp;ndash; CSS에 대한 오래된 신념</target>
        </trans-unit>
        <trans-unit id="3e2877a374953df7fad662b9e45ca3eb44a50e16" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://www.w3.org/TR/css3-grid-layout/#order-property&quot;&gt;&lt;code&gt;order&lt;/code&gt; in the CSS Grid Layout spec&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/css3-grid-layout/#order-property&quot;&gt;CSS Grid Layout 사양의 &lt;code&gt;order&lt;/code&gt; &lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1a6ee2a76673c38a3c832b48af895c00c9068dbb" translate="yes" xml:space="preserve">
          <source>And the cascade goes only 1 direction: down.</source>
          <target state="translated">그리고 계단식은 한 방향으로 만 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa4888cf695ea35fd3afd3a8aa1b9b775054ed" translate="yes" xml:space="preserve">
          <source>And, again, I was unable to add &lt;code&gt;.companies&lt;/code&gt; any higher up in the HTML.  That part of the HTML was written externally, and wrapped our code.</source>
          <target state="translated">그리고 다시, HTML에서 &lt;code&gt;.companies&lt;/code&gt; 를 더 이상 추가 할 수 없었습니다. HTML의 해당 부분은 외부에서 작성되었으며 코드를 감쌌습니다.</target>
        </trans-unit>
        <trans-unit id="0ddfcaa1ef0aa8a7c6b06221a8232b25f9c2ae0c" translate="yes" xml:space="preserve">
          <source>Another flexbox solution</source>
          <target state="translated">또 다른 flexbox 솔루션</target>
        </trans-unit>
        <trans-unit id="48b3c005d9f4850b15a789fb78db521746377c4f" translate="yes" xml:space="preserve">
          <source>Another long-standing belief has been that &lt;code&gt;z-index&lt;/code&gt; works only on positioned elements.</source>
          <target state="translated">또 다른 오랜 믿음은 &lt;code&gt;z-index&lt;/code&gt; 은 위치 지정된 요소에서만 작동한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1cf713b92555463ebe5217207e6aafa0eb082552" translate="yes" xml:space="preserve">
          <source>As described above, this belief is not entirely true. A previous sibling selector can be simulated in CSS using the flex &lt;code&gt;order&lt;/code&gt; property.</source>
          <target state="translated">위에서 설명한 것처럼이 믿음은 전적으로 사실이 아닙니다. flex &lt;code&gt;order&lt;/code&gt; 속성을 사용하여 CSS에서 이전 형제 선택자를 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="229f35a08548eaf6783204176f701b3d33a4f629" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/14469950/5411817&quot;&gt;this answer by Mike Brant&lt;/a&gt;,
the following jQuery snippet could help.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14469950/5411817&quot;&gt;Mike Brant의 답변에&lt;/a&gt; 따라 다음 jQuery 스 니펫이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed4d744f4bf8170a78c74aa2fd88d744fdae3bb" translate="yes" xml:space="preserve">
          <source>But I could &lt;em&gt;not&lt;/em&gt; select only &lt;code&gt;#full-width&lt;/code&gt;s that &lt;em&gt;proceeded&lt;/em&gt;&lt;code&gt;.companies&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;.companies&lt;/code&gt; 을 &lt;em&gt;진행 한&lt;/em&gt; &lt;code&gt;#full-width&lt;/code&gt; 만 선택할 수 &lt;em&gt;없었&lt;/em&gt; 습니다 .</target>
        </trans-unit>
        <trans-unit id="90417dea6720e12f30caa00950383afb1b63b2ab" translate="yes" xml:space="preserve">
          <source>But with jQuery, I &lt;em&gt;can&lt;/em&gt; select the required &lt;code&gt;#full-width&lt;/code&gt;s, then assign the appropriate style:</source>
          <target state="translated">그러나 jQuery를 사용하면 필요한 &lt;code&gt;#full-width&lt;/code&gt; 를 선택한 다음 적절한 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45eedda9c8d9f5b1c7f441ae4f3042455cca6f6b" translate="yes" xml:space="preserve">
          <source>CSS Selector for selecting an element that comes BEFORE another element?</source>
          <target state="translated">다른 요소보다 먼저 나오는 요소를 선택하기위한 CSS 선택기?</target>
        </trans-unit>
        <trans-unit id="c18f2079c9555b512b0d479beb14f33298d17728" translate="yes" xml:space="preserve">
          <source>CSS select previous sibling</source>
          <target state="translated">CSS는 이전 형제를 선택합니다</target>
        </trans-unit>
        <trans-unit id="c5b96b2421df977be54b8afa143635de349ecc67" translate="yes" xml:space="preserve">
          <source>CSS selector for next and previous elements</source>
          <target state="translated">다음 및 이전 요소를위한 CSS 선택기</target>
        </trans-unit>
        <trans-unit id="39aa2b07f090994b1230fd897c096b82e0b8f70d" translate="yes" xml:space="preserve">
          <source>CSS selector to get preceding sibling</source>
          <target state="translated">선행 형제를 얻는 CSS 선택기</target>
        </trans-unit>
        <trans-unit id="2a9aeb746a06e0844284ee2d4008adbf2fd73b36" translate="yes" xml:space="preserve">
          <source>CSS:</source>
          <target state="translated">CSS:</target>
        </trans-unit>
        <trans-unit id="6173ca19b1a4be22f0ba5a87c6612fc158b212fd" translate="yes" xml:space="preserve">
          <source>CSS: select previous sibling</source>
          <target state="translated">CSS : 이전 형제 선택</target>
        </trans-unit>
        <trans-unit id="fadb864e568c5d11ae0d18b81383e48b964113f2" translate="yes" xml:space="preserve">
          <source>Change color of sibling elements on hover using CSS</source>
          <target state="translated">CSS를 사용하여 호버에서 형제 요소의 색상 변경</target>
        </trans-unit>
        <trans-unit id="94a5ad82bf1f904bbeafcb20ec770fd553af2dda" translate="yes" xml:space="preserve">
          <source>Computed value:     as specified</source>
          <target state="translated">계산 된 값 : 지정된대로</target>
        </trans-unit>
        <trans-unit id="9806c929f4fbf2b2374b544d0132be7fc35b2911" translate="yes" xml:space="preserve">
          <source>Consider the &lt;code&gt;order&lt;/code&gt; property of flex and grid layouts.</source>
          <target state="translated">플렉스 및 그리드 레이아웃의 &lt;code&gt;order&lt;/code&gt; 속성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="40d5acc4ac4669c9e11b503fb48cf1ec26dce199" translate="yes" xml:space="preserve">
          <source>Depending on your exact objective, there is a way to achieve the usefulness of a parent selector without using one (even if one were to exist)...</source>
          <target state="translated">정확한 목표에 따라 하나를 사용하지 않고 부모 선택기의 유용성을 얻을 수있는 방법이 있습니다 (존재하더라도).</target>
        </trans-unit>
        <trans-unit id="2e976a9b0921bc45e45f2900c57e6179424e3373" translate="yes" xml:space="preserve">
          <source>Effectively, &quot;previous sibling&quot; has been selected via jQuery.</source>
          <target state="translated">효과적으로, &quot;이전 형제&quot;는 jQuery를 통해 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="02caa7b6173db637f5c2e48b1d62c59d7e3222d3" translate="yes" xml:space="preserve">
          <source>Elements that are &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#painting&quot;&gt;&lt;strong&gt;&lt;em&gt;flex items&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://drafts.csswg.org/css-grid/#z-order&quot;&gt;&lt;strong&gt;&lt;em&gt;grid items&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; can create stacking contexts even when &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#painting&quot;&gt;&lt;strong&gt;&lt;em&gt;플렉스 항목&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://drafts.csswg.org/css-grid/#z-order&quot;&gt;&lt;strong&gt;&lt;em&gt;격자 항목 인&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; 요소는 &lt;code&gt;position&lt;/code&gt; 가 &lt;code&gt;static&lt;/code&gt; 경우에도 스태킹 컨텍스트를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="912849c376dc7a8f86c6418763561e232f09e8df" translate="yes" xml:space="preserve">
          <source>Finally, it assigns a new CSS (&lt;code&gt;width&lt;/code&gt;) value to the resulting element.</source>
          <target state="translated">마지막으로 결과 요소에 새로운 CSS ( &lt;code&gt;width&lt;/code&gt; ) 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="051a837d3891413abfe10ed1070fe8215902c21e" translate="yes" xml:space="preserve">
          <source>Flex items are, by default, displayed and laid out in the same order as they appear in the source document. The 
  &lt;code&gt;order&lt;/code&gt; property can be used to change this ordering.</source>
          <target state="translated">Flex 항목은 기본적으로 소스 문서에 나타나는 순서대로 표시되고 배치됩니다. &lt;code&gt;order&lt;/code&gt; 속성을 사용하여이 순서를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb22e87d22421d730f517d61fc95824612e817ff" translate="yes" xml:space="preserve">
          <source>Flex items paint exactly the same as inline blocks, except that order-modified document order is used in place of raw 
  document order, and &lt;code&gt;z-index&lt;/code&gt; values other than &lt;code&gt;auto&lt;/code&gt; create a stacking context even if &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Flex 항목은 순서가 수정 된 문서 순서가 원시 문서 순서 대신 사용되고 &lt;code&gt;auto&lt;/code&gt; 이외의 &lt;code&gt;z-index&lt;/code&gt; 값이 &lt;code&gt;position&lt;/code&gt; 가 &lt;code&gt;static&lt;/code&gt; 경우에도 스태킹 컨텍스트를 생성한다는 점을 제외하면 인라인 블록과 정확히 동일하게 페인트됩니다.</target>
        </trans-unit>
        <trans-unit id="b71f41ee4b8948e2ef97dc6eaec690a10c7079de" translate="yes" xml:space="preserve">
          <source>Flexbox is shattering long-held beliefs about CSS.</source>
          <target state="translated">Flexbox는 CSS에 대한 오랜 믿음을 산산조각 내고 있습니다.</target>
        </trans-unit>
        <trans-unit id="959c2ad7e3f03ec94a998bb6e74820a21dce5afc" translate="yes" xml:space="preserve">
          <source>From the flexbox spec:</source>
          <target state="translated">flexbox 사양에서 :</target>
        </trans-unit>
        <trans-unit id="281ae36016b5df798237abd85199faff72bacd6c" translate="yes" xml:space="preserve">
          <source>HTML:
    
        
             
             
             
             
             
        
        (40)</source>
          <target state="translated">HTML : (40)</target>
        </trans-unit>
        <trans-unit id="4068e6a84eaf79e682a75e47116c93a658eb970d" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of &lt;code&gt;z-index&lt;/code&gt; working on non-positioned flex items: &lt;a href=&quot;https://jsfiddle.net/m0wddwxs/&quot;&gt;https://jsfiddle.net/m0wddwxs/&lt;/a&gt;</source>
          <target state="translated">다음은 위치가 지정되지 않은 플렉스 항목에서 작동하는 &lt;code&gt;z-index&lt;/code&gt; 의 데모입니다. &lt;a href=&quot;https://jsfiddle.net/m0wddwxs/&quot;&gt;https://jsfiddle.net/m0wddwxs/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ede26c3272eca67058c5c4a741b5f5420eec6dd" translate="yes" xml:space="preserve">
          <source>Here's the full code:</source>
          <target state="translated">전체 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91833c79413fd07372f4a33eb8350490dbb11ae4" translate="yes" xml:space="preserve">
          <source>Hope it helps someone.</source>
          <target state="translated">그것이 누군가를 돕기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="00f8058d0dcf0e7a2d3b1ed93e6c2dc0869b7d2a" translate="yes" xml:space="preserve">
          <source>How to add styling to active input's previous sibling using CSS only</source>
          <target state="translated">CSS 만 사용하여 활성 입력의 이전 형제에 스타일을 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="7aaf9dfcdb948d52cf26522a6afb4dbc69de2344" translate="yes" xml:space="preserve">
          <source>How to affect other elements when a div is hovered</source>
          <target state="translated">div를 가리킬 때 다른 요소에 영향을 미치는 방법</target>
        </trans-unit>
        <trans-unit id="0d8f70e7ad320c862ea828321d87c91c61ed07bc" translate="yes" xml:space="preserve">
          <source>How to select the previous sibling using selenium css syntax</source>
          <target state="translated">셀레늄 CSS 구문을 사용하여 이전 형제를 선택하는 방법</target>
        </trans-unit>
        <trans-unit id="edde16975af4c3f91926ae4ab528a19e13d1638b" translate="yes" xml:space="preserve">
          <source>However, if you are able to add &lt;strong&gt;JavaScript&lt;/strong&gt; to your page, a little bit of &lt;strong&gt;jQuery&lt;/strong&gt; could get you to your end goal.</source>
          <target state="translated">그러나 페이지에 &lt;strong&gt;JavaScript&lt;/strong&gt; 를 추가 할 수 있으면 약간의 &lt;strong&gt;jQuery&lt;/strong&gt; 가 최종 목표를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1acf1134953119f55a775a44bb0634b7ef15a1f0" translate="yes" xml:space="preserve">
          <source>However, in the &lt;strong&gt;axe&lt;/strong&gt; CSS post-processor library, there are &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; previous sibling selectors&lt;/em&gt;:</source>
          <target state="translated">그러나 &lt;strong&gt;ax&lt;/strong&gt; CSS 포스트 프로세서 라이브러리에는 &lt;strong&gt;&lt;em&gt;2 개의&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;이전 형제 선택기가 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="86caa6bdc362ff8eaa7d03615f8d8811870000f5" translate="yes" xml:space="preserve">
          <source>I found a way to style all previous siblings (opposite of &lt;code&gt;~&lt;/code&gt;) that may work depending on what you need.</source>
          <target state="translated">필요한 것에 따라 작동 할 수있는 모든 이전 형제 ( &lt;code&gt;~&lt;/code&gt; 반대) 스타일을 지정하는 방법을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="6bd7bc412ee50b933334dc0e025771a9a14db374" translate="yes" xml:space="preserve">
          <source>I had a similar problem and found out that all problem of this nature can be solved as follows:</source>
          <target state="translated">비슷한 문제가 있었고이 성격의 모든 문제를 다음과 같이 해결할 수 있음을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="eab5cd63e9e3e19eaf186d4e85865aaff9d7de65" translate="yes" xml:space="preserve">
          <source>I had control of all the HTML under &lt;code&gt;.companies&lt;/code&gt;, but could not alter any of the HTML above it.</source>
          <target state="translated">&lt;code&gt;.companies&lt;/code&gt; 에서 모든 HTML을 제어 할 수 있었지만 그 위에있는 HTML을 변경할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="090d3b447a141fd56eaee940ec7c0b3c9181252e" translate="yes" xml:space="preserve">
          <source>I had the same question, but then I had a &quot;duh&quot; moment.   Instead of writing</source>
          <target state="translated">나는 같은 질문을했지만 &quot;duh&quot;순간을 가졌다. 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="dcdbf832ffc8960412f46127139613b7788265e1" translate="yes" xml:space="preserve">
          <source>I needed a solution to select the previous sibling tr. I came up with this solution using React and Styled-components. This is not my exact solution (This is from memory, hours later). I know there is a flaw in the setHighlighterRow function.</source>
          <target state="translated">이전 형제 tr을 선택하는 솔루션이 필요했습니다. React 및 Styled 구성 요소를 사용 하여이 솔루션을 생각해 냈습니다. 이것은 내 정확한 해결책이 아닙니다 (몇 시간 후에 메모리에서 온 것입니다). setHighlighterRow 함수에 결함이 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef5fd2bd284dea941940014eb44dd99e73a46d05" translate="yes" xml:space="preserve">
          <source>I realize that the original question was a CSS question so this answer is probably completely irrelevant, but other Javascript users may stumble on the question via search like I did.</source>
          <target state="translated">원래 질문은 CSS 질문 이므로이 답변은 완전히 관련이 없지만 다른 Javascript 사용자는 내가했던 것처럼 검색을 통해 질문에 걸려 넘어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13fe1d484840b69d747494ca988cef005264e7cc" translate="yes" xml:space="preserve">
          <source>I'm using FontAwesome in this example and swapping between the unicodes of fa-star-o and fa-star
&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;http://fortawesome.github.io/Font-Awesome/&lt;/a&gt;</source>
          <target state="translated">이 예제에서 FontAwesome을 사용하고 fa-star-o와 fa-star의 유니 코드 사이를 교환하고 있습니다 &lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;http://fortawesome.github.io/Font-Awesome/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e718f5646afda421ef33270aaf412d5fe58f945f" translate="yes" xml:space="preserve">
          <source>If you know the exact position an &lt;code&gt;:nth-child()&lt;/code&gt;-based exclusion of all following siblings would work.</source>
          <target state="translated">정확한 위치를 알고 있으면 다음 형제 자매의 &lt;code&gt;:nth-child()&lt;/code&gt; 기반 제외가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="79c501d695c28ba90a85b59b704d657bef33509c" translate="yes" xml:space="preserve">
          <source>In conventional CSS, there is &lt;strong&gt;no previous sibling selector&lt;/strong&gt;.</source>
          <target state="translated">기존 CSS &lt;strong&gt;에는 이전 형제 선택기&lt;/strong&gt; 가 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="51c49ae56e89555fda5525ce78e016d4a9960577" translate="yes" xml:space="preserve">
          <source>In fact, the most current version of the spec &amp;ndash; the &lt;a href=&quot;https://drafts.csswg.org/css2/visuren.html#propdef-z-index&quot;&gt;W3C Editor's Draft&lt;/a&gt; &amp;ndash; still asserts this to be true:</source>
          <target state="translated">사실, 최신 버전의 사양 인 &lt;a href=&quot;https://drafts.csswg.org/css2/visuren.html#propdef-z-index&quot;&gt;W3C Editor 's Draft&lt;/a&gt; 는 여전히 이것이 사실이라고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="c1614e8db35c84f7389f93ed6ae211115f938273" translate="yes" xml:space="preserve">
          <source>In my case I was looking to find a way to select a DIV with the id &lt;code&gt;#full-width&lt;/code&gt;, but ONLY if it had a (indirect) descendant DIV with the class of &lt;code&gt;.companies&lt;/code&gt;.</source>
          <target state="translated">필자의 경우 ID가 &lt;code&gt;#full-width&lt;/code&gt; 인 DIV를 선택하는 방법을 찾고 있었지만 &lt;code&gt;.companies&lt;/code&gt; 클래스의 (간접) 자손 DIV가있는 경우에만.</target>
        </trans-unit>
        <trans-unit id="2fe2536c1eacf4a1a05311c9729aa249a76be838" translate="yes" xml:space="preserve">
          <source>In my case, I wanted a primarily CSS 5-star rating system. I would need to color (or swap the icon of) the previous stars. By floating each element right, I am essentially getting the same effect (the html for the stars thus must be written 'backwards').</source>
          <target state="translated">제 경우에는 주로 CSS 5 성급 등급 시스템을 원했습니다. 이전 별의 색상을 지정하거나 아이콘을 바꿔야합니다. 각 요소를 올바르게 플로팅하면 본질적으로 동일한 효과가 나타납니다 (별표의 html은 '뒤로'로 작성해야 함).</target>
        </trans-unit>
        <trans-unit id="248d5f16812a94c0896fd71081300c46b317e6b7" translate="yes" xml:space="preserve">
          <source>In particular, the flex &lt;code&gt;order&lt;/code&gt; property can move elements around the screen.</source>
          <target state="translated">특히 flex &lt;code&gt;order&lt;/code&gt; 속성은 화면 주위에서 요소를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8efd7365dcd78f460f2e36c60a2e4b618e07fb8" translate="yes" xml:space="preserve">
          <source>In reality, however, this information is obsolete and inaccurate.</source>
          <target state="translated">그러나 실제로이 정보는 더 이상 사용되지 않으며 부정확합니다.</target>
        </trans-unit>
        <trans-unit id="2fd90fb4157d1e9c3cb82e78b72caf02e01264c9" translate="yes" xml:space="preserve">
          <source>In the example below:</source>
          <target state="translated">아래 예에서 :</target>
        </trans-unit>
        <trans-unit id="5c3dfe0de7d1bc518306aa10258d1c13f54861f3" translate="yes" xml:space="preserve">
          <source>Inherited:      no</source>
          <target state="translated">상속 : 아니오</target>
        </trans-unit>
        <trans-unit id="3000181e0628e7643bd8adee4c6849bd29ea5b9b" translate="yes" xml:space="preserve">
          <source>Initial:    auto</source>
          <target state="translated">초기 : 자동</target>
        </trans-unit>
        <trans-unit id="48aae125c6273372fc204836e6350a2e37f3be5c" translate="yes" xml:space="preserve">
          <source>Is there a “previous sibling” selector</source>
          <target state="translated">&quot;이전 형제&quot;선택기가 있습니까</target>
        </trans-unit>
        <trans-unit id="9be9d437f0dfb6899a9700afc7c6af5f0d9ebc59" translate="yes" xml:space="preserve">
          <source>Is there an equivalent for the previous sibling?</source>
          <target state="translated">이전 형제와 동등한 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="68b4de53a6017d1e28b25a9e348ee280f2caa4ae" translate="yes" xml:space="preserve">
          <source>JSFiddle: &lt;a href=&quot;http://jsfiddle.net/andrewleyva/88j0105g/&quot;&gt;http://jsfiddle.net/andrewleyva/88j0105g/&lt;/a&gt;</source>
          <target state="translated">JSFiddle : &lt;a href=&quot;http://jsfiddle.net/andrewleyva/88j0105g/&quot;&gt;http://jsfiddle.net/andrewleyva/88j0105g/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02c3528b037f688712d83f406ccbb1cfec5c20c2" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of links and when hovering on one, all the previous ones should turn red. You can do it like this:</source>
          <target state="translated">링크 목록이 있고 하나를 가리키면 이전의 모든 링크가 빨간색으로 바뀌어야한다고 가정 해 봅시다. 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="9437ceed3329cdf77b8d382349418ba82d6804b0" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;ul&lt;/code&gt; a flex container.</source>
          <target state="translated">&lt;code&gt;ul&lt;/code&gt; 을 플렉스 컨테이너로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b889c73d1be01b47f80ae16c97e8e4ca2fb402b9" translate="yes" xml:space="preserve">
          <source>Media:      visual</source>
          <target state="translated">미디어 : 시각</target>
        </trans-unit>
        <trans-unit id="3bc97b7eba79269b952d0d89cd932fa205b3222e" translate="yes" xml:space="preserve">
          <source>No, there is no &quot;previous sibling&quot; selector.</source>
          <target state="translated">아니요, &quot;이전 형제&quot;선택기가 없습니다.</target>
        </trans-unit>
        <trans-unit id="06523e089f48369a43a839a5578b36a3dff2c2ba" translate="yes" xml:space="preserve">
          <source>No. It is not possible via CSS. It takes the &quot;Cascade&quot; to heart ;-).</source>
          <target state="translated">아니요. CSS를 통해서는 불가능합니다. &quot;캐스케이드&quot;를 생각 나게한다 ;-).</target>
        </trans-unit>
        <trans-unit id="8c00c220dbd31f27615214a55bdebafb9b9301d2" translate="yes" xml:space="preserve">
          <source>Now, use the &lt;code&gt;.css&lt;/code&gt; function to pass in your CSS new values for that element.</source>
          <target state="translated">이제 &lt;code&gt;.css&lt;/code&gt; 함수를 사용하여 해당 요소의 CSS 새 값을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="648457847b306355248f81e8054a176758693c6b" translate="yes" xml:space="preserve">
          <source>Obviously this matches &quot;x&quot; instead of &quot;y&quot;, but it answers the &quot;is there a match?&quot; question, and simple DOM traversal may get you to the right element more efficiently than looping in javascript.</source>
          <target state="translated">분명히 이것은 &quot;y&quot;대신 &quot;x&quot;와 일치하지만 &quot;일치합니까?&quot; 질문과 간단한 DOM 순회는 자바 스크립트에서 반복하는 것보다 올바른 요소로보다 효율적으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15de0eca38d6ad16eebdf50299f9363d30dc7a2d" translate="yes" xml:space="preserve">
          <source>On a related note, &lt;code&gt;~&lt;/code&gt; is for general successor sibling (meaning the element comes after this one, but not necessarily immediately after) and is a CSS3 selector. &lt;code&gt;+&lt;/code&gt; is for next sibling and is CSS2.1.</source>
          <target state="translated">관련 메모에서 &lt;code&gt;~&lt;/code&gt; 는 일반적인 후속 형제 (요소가이 요소 뒤에 오는 것을 의미하지만 반드시 직후는 아님)를위한 것이며 CSS3 선택기입니다. &lt;code&gt;+&lt;/code&gt; 는 다음 형제를위한 것이며 CSS2.1입니다.</target>
        </trans-unit>
        <trans-unit id="a75a09fb96d32623c76fedce272a3f203462aaec" translate="yes" xml:space="preserve">
          <source>OnMouseOver a row will set the row index to state, and rerender the previous row with a new background color</source>
          <target state="translated">OnMouseOver 행은 행 인덱스를 state로 설정하고 이전 행을 새로운 배경색으로 다시 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="68a7635b24a97f76bb9ebc1cbe012194bf82823d" translate="yes" xml:space="preserve">
          <source>One such belief is that &lt;a href=&quot;https://stackoverflow.com/a/10006328/3597276&quot;&gt;&lt;strong&gt;a previous sibling selector is not possible in CSS&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 믿음 중 하나 &lt;a href=&quot;https://stackoverflow.com/a/10006328/3597276&quot;&gt;&lt;strong&gt;는 CSS에서 이전 형제 선택기가 불가능하다는 것입니다&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea475966115fbffc1211959ca65e05ecdb8f7fa7" translate="yes" xml:space="preserve">
          <source>Or I could select &lt;code&gt;.companies&lt;/code&gt; that only followed a &lt;code&gt;#full-width&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;#full-width&lt;/code&gt; 만 따르는 &lt;code&gt;.companies&lt;/code&gt; 를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a8ac81b3400af06c7cc81e6077f2d0fc74b0486" translate="yes" xml:space="preserve">
          <source>Parent with &lt;code&gt;direction: rtl;&lt;/code&gt; + inverse the order of inner elements</source>
          <target state="translated">&lt;code&gt;direction: rtl;&lt;/code&gt; 부모 : rtl; + 내부 요소의 순서를 반대로</target>
        </trans-unit>
        <trans-unit id="e20b56b4243462d32777361ea6e24f9a73aaf5f4" translate="yes" xml:space="preserve">
          <source>Percentages:    N/A</source>
          <target state="translated">백분율 : N / A</target>
        </trans-unit>
        <trans-unit id="4ddf62b2329b83ab800d77bbeccd01a350dd2c7f" translate="yes" xml:space="preserve">
          <source>Previous adjacent selector in CSS</source>
          <target state="translated">CSS의 이전 인접 선택기</target>
        </trans-unit>
        <trans-unit id="1f32fd13429c7ba13ea2351ea2bb3a24954b169f" translate="yes" xml:space="preserve">
          <source>Reverse the order of siblings in the mark-up.</source>
          <target state="translated">마크 업에서 형제의 순서를 반대로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8f7e94d1cf379df4a82d4c27c7dac3111a469db4" translate="yes" xml:space="preserve">
          <source>STEPS</source>
          <target state="translated">STEPS</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">우리가 가지고 있다고합시다.</target>
        </trans-unit>
        <trans-unit id="f82c3fbbc6d8a3c6cd5e5d1cf2400a349b7b74f7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#adjacent-sibling-combinators&quot;&gt;Adjacent sibling combinator&lt;/a&gt; from &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/&quot;&gt;Selectors Level 3&lt;/a&gt; and &lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors&quot;&gt;5.7 Adjacent sibling selectors&lt;/a&gt; from &lt;a href=&quot;http://www.w3.org/TR/CSS21/cover.html#minitoc&quot;&gt;Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/css3-selectors/&quot;&gt;선택기 레벨 3의&lt;/a&gt; &lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors&quot;&gt;인접 형제 결합기&lt;/a&gt; 및 5.7 &lt;a href=&quot;http://www.w3.org/TR/CSS21/cover.html#minitoc&quot;&gt;Cascading Style Sheets 레벨 2 개정 1 (CSS 2.1) 사양의&lt;/a&gt; 인접 형제 선택기 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b32df97065887792fc54ce0bd0085574a236ced" translate="yes" xml:space="preserve">
          <source>Select previous siblings on hover</source>
          <target state="translated">호버에서 이전 형제 선택</target>
        </trans-unit>
        <trans-unit id="b8802af3c25aab2b10973154bd80f5d4a28fbeb3" translate="yes" xml:space="preserve">
          <source>Select the preceding sibling of an element in CSS using selectors</source>
          <target state="translated">선택기를 사용하여 CSS에서 요소의 이전 형제를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="3f69e926c961d47d6b8bf4edd9ada01387a1af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; property controls the order in which flex items appear within the flex container, by assigning them to ordinal groups. It takes a single &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; value, which specifies which ordinal group the flex item 
  belongs to.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 속성은 플렉스 항목을 순서 그룹에 할당하여 플렉스 컨테이너 내에 표시되는 순서를 제어합니다. 플렉스 항목이 속하는 서수 그룹을 지정하는 단일 &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bee636d2e47bd8d9ebd01557931b7587b00a7e8a" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;order&lt;/code&gt; value for all flex items is 0.</source>
          <target state="translated">모든 플렉스 아이템의 초기 &lt;code&gt;order&lt;/code&gt; 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="1f84bcdbeb978aab5a1803803dd526d2abe73d82" translate="yes" xml:space="preserve">
          <source>The painting order of grid items is exactly the same as inline blocks, except that order-modified document order is 
  used in place of raw document order, and &lt;code&gt;z-index&lt;/code&gt; values other than &lt;code&gt;auto&lt;/code&gt; create a stacking context even if 
  &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">그리드 항목의 페인팅 순서는 인라인 블록과 정확히 동일합니다. 단, 원본 수정 순서 대신 주문 수정 문서 순서가 사용되고 &lt;code&gt;position&lt;/code&gt; 가 &lt;code&gt;static&lt;/code&gt; 경우에도 &lt;code&gt;auto&lt;/code&gt; 이외의 &lt;code&gt;z-index&lt;/code&gt; 값은 스택 컨텍스트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="427e7f7201e462d2988b2f979cbd84408150c14d" translate="yes" xml:space="preserve">
          <source>The plus sign (&lt;code&gt;+&lt;/code&gt;) is for the next sibling.</source>
          <target state="translated">더하기 부호 ( &lt;code&gt;+&lt;/code&gt; )는 다음 형제를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a504da474de17cf78a56f80874e1f7160a2eff59" translate="yes" xml:space="preserve">
          <source>Then it &quot;backtracks&quot; to select all the previous &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;s from that set of &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;s.</source>
          <target state="translated">그런 다음 &quot;backtracks&quot;하여 해당 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 세트에서 이전 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 를 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="998b5fdf1840ef4280f75ef69d0cab0498e6fb8a" translate="yes" xml:space="preserve">
          <source>Then it uses &lt;code&gt;.parents&lt;/code&gt; to &quot;backtrack&quot; and select ALL parents of &lt;code&gt;.companies&lt;/code&gt;,</source>
          <target state="translated">그런 다음 &lt;code&gt;.parents&lt;/code&gt; 를 사용하여 &quot;역 추적&quot;하고 &lt;code&gt;.companies&lt;/code&gt; 의 모든 부모를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f86be13dd4259c6e46b8a5e0c9eec5da827d2688" translate="yes" xml:space="preserve">
          <source>Then you use jQuery to re-write the DOM (CSS) for your element.</source>
          <target state="translated">그런 다음 jQuery를 사용하여 요소의 DOM (CSS)을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f5ec78f818e941a2192daf69266fbc4682f676e" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; subsequent sibling selectors&lt;/em&gt; in conventional CSS:</source>
          <target state="translated">기존 CSS에는 &lt;strong&gt;&lt;em&gt;2 개의&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;후속 형제 선택기&lt;/em&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="481d7edcc0194f06e2e87c4622cd3df70b606c45" translate="yes" xml:space="preserve">
          <source>There is no &quot;previous&quot; sibling selector unfortunately, but you can &lt;em&gt;possibly&lt;/em&gt; still get the same effect by using positioning (e.g. float right). It depends on what you are trying to do.</source>
          <target state="translated">불행히도 &quot;이전&quot;형제 선택기는 없지만 포지셔닝 (예 : 오른쪽 플로트)을 사용하여 동일한 효과를 얻을 수 &lt;em&gt;있습니다&lt;/em&gt; . 당신이하려는 일에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b6eeb31b47d9993da80a332e6a18ebd9b2ffe6" translate="yes" xml:space="preserve">
          <source>There is no official way to do that at the moment but you can use a little trick to achieve this ! Remember that it is experimental and it has some limitation ...
(check &lt;a href=&quot;http://fmbip.com/litmus/&quot;&gt;this link&lt;/a&gt; if you worries about navigator compatibility )</source>
          <target state="translated">현재 공식적인 방법은 없지만 약간의 트릭을 사용하여 이것을 달성 할 수 있습니다! 그것은 실험적이며 약간의 한계가 있음을 기억하십시오 ... (네비게이터 호환성에 대해 걱정한다면 &lt;a href=&quot;http://fmbip.com/litmus/&quot;&gt;이 링크를&lt;/a&gt; 확인하십시오)</target>
        </trans-unit>
        <trans-unit id="45b35f90fcdcabc6a74055eb084b276d13094e30" translate="yes" xml:space="preserve">
          <source>This finds all &lt;code&gt;#full-width .companies&lt;/code&gt;, and selects just those &lt;code&gt;.companies&lt;/code&gt;, similar to how selectors are used to target specific elements in standard in CSS.</source>
          <target state="translated">이것은 모든 &lt;code&gt;#full-width .companies&lt;/code&gt; 를 찾고 CSS의 표준에서 특정 요소를 대상으로 선택하는 데 셀렉터를 사용하는 것과 유사한 &lt;code&gt;.companies&lt;/code&gt; 만 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ca872b70b4139c1dd2fb6a771206f43e4b169e1c" translate="yes" xml:space="preserve">
          <source>This first selects all &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;s that immediately follow a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 바로 뒤에 오는 모든 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="74496773ae4f698f108b0c2c81194fcf66a99f32" translate="yes" xml:space="preserve">
          <source>This is the same for pseudo classes</source>
          <target state="translated">이것은 의사 클래스와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="780f7784d75a1253b4979a5ed18f418476e2e415" translate="yes" xml:space="preserve">
          <source>This sets all anchor links to have 15px margin on the top and resets it back to 0 for those with no UL elements (or other tags) inside LIs.</source>
          <target state="translated">그러면 모든 앵커 링크가 상단에 15px의 여백을 갖도록 설정하고 LI 내부에 UL 요소 (또는 다른 태그)가없는 링크의 경우 0으로 다시 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d693c780f30dd4ef25beb759926f543600b69fa2" translate="yes" xml:space="preserve">
          <source>Thus I could select ALL &lt;code&gt;#full-width&lt;/code&gt;s.</source>
          <target state="translated">따라서 모든 &lt;code&gt;#full-width&lt;/code&gt; 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c603a250e4ca71f19cd8ea72a8ecb969a8783120" translate="yes" xml:space="preserve">
          <source>To say this belief is widespread would be an understatement. Here's a sampling of related questions on Stack Overflow alone:</source>
          <target state="translated">이 믿음이 널리 퍼져 있다고 말하는 것은 과소 평가 일 것이다. 다음은 스택 오버플로에만 관련된 질문에 대한 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="1d3701e331dc8b27252466a97f77b8a75a27c8dd" translate="yes" xml:space="preserve">
          <source>Two &lt;em&gt;tricks&lt;/em&gt;. Basically inverting the HTML order of your desired elements in HTML and using</source>
          <target state="translated">두 가지 &lt;em&gt;요령&lt;/em&gt; . 기본적으로 HTML에서 원하는 요소의 HTML 순서를 반전시키고</target>
        </trans-unit>
        <trans-unit id="da5a01f69e0f0a6401c48450d762ea9e3ca49bb7" translate="yes" xml:space="preserve">
          <source>Use a sibling selector to target Element A  (&lt;code&gt;~&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; will do) .</source>
          <target state="translated">형제 선택기를 사용하여 요소 A를 대상으로합니다 ( &lt;code&gt;~&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 가 수행함).</target>
        </trans-unit>
        <trans-unit id="6418531d3667fddb681489113d747c5a42f51833" translate="yes" xml:space="preserve">
          <source>Use the flex &lt;code&gt;order&lt;/code&gt; property to restore the order of siblings on the visual display.</source>
          <target state="translated">flex &lt;code&gt;order&lt;/code&gt; 속성을 사용하여 시각적 디스플레이에서 형제 순서를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="668d622c2d0c54db3e9364afa53203471e4c680a" translate="yes" xml:space="preserve">
          <source>Value:      auto |  | inherit</source>
          <target state="translated">값 : 자동 | | 상속</target>
        </trans-unit>
        <trans-unit id="102c966d2e7899f01b11a9c146510d6e9c5569df" translate="yes" xml:space="preserve">
          <source>What can we do to make the Socks block (including sock colours) stand out visually using spacing?</source>
          <target state="translated">간격을 사용하여 양말 블록 (양말 색상 포함)을 눈에 띄게 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="20dc3d5b8b33b8fca560d792ef4e22c80f9162be" translate="yes" xml:space="preserve">
          <source>What does exist:</source>
          <target state="translated">존재하는 것 :</target>
        </trans-unit>
        <trans-unit id="88536aa66c898bfb53c491477414c9d560627da3" translate="yes" xml:space="preserve">
          <source>What would be nice but doesn't exist:</source>
          <target state="translated">좋은 것이지만 존재하지 않는 것 :</target>
        </trans-unit>
        <trans-unit id="9ec5485132671fdd7692fc8455d289a7863233f3" translate="yes" xml:space="preserve">
          <source>What you can do is use a CSS3 selector : the pseudo classe called &lt;code&gt;nth-child()&lt;/code&gt;</source>
          <target state="translated">당신이 할 수있는 일은 CSS3 선택기를 사용하는 것입니다 : &lt;code&gt;nth-child()&lt;/code&gt; 라는 의사 클래스</target>
        </trans-unit>
        <trans-unit id="0077a584a44ef74fce634034afa28323a805771d" translate="yes" xml:space="preserve">
          <source>Which does the same.</source>
          <target state="translated">어느 것도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4e1cb73736ecd6fc6afeba8df7ddf1a7664dd27b" translate="yes" xml:space="preserve">
          <source>Which would select all &lt;code&gt;li&lt;/code&gt;s before the 3rd (e.g. 1st and 2nd). But, in my opinion this looks ugly and has a very tight usecase.</source>
          <target state="translated">어느 것이 3 일 전에 모든 것을 선택할 것인가 (예 : 1, 2). 그러나 제 생각에는 이것이 추악하게 보이고 매우 엄격한 유스 케이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="45ee67100ba9b556b21767275c4bde54ec9eeb16" translate="yes" xml:space="preserve">
          <source>Working sample:</source>
          <target state="translated">작업 샘플 :</target>
        </trans-unit>
        <trans-unit id="66d88363dd000457d2bb258b0c3eaee69b3c4440" translate="yes" xml:space="preserve">
          <source>You also could select the nth-child right-to-left:</source>
          <target state="translated">오른쪽에서 왼쪽으로 n 번째 자식을 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e505512adaaefac12cb8dfb4e4b5aec4195707b3" translate="yes" xml:space="preserve">
          <source>You can use inverse the order of elements in HTML. Then besides using &lt;code&gt;order&lt;/code&gt; as in &lt;a href=&quot;https://stackoverflow.com/a/36118012/1548895&quot;&gt;Michael_B's answer&lt;/a&gt; you can use &lt;code&gt;flex-direction: row-reverse;&lt;/code&gt; or &lt;code&gt;flex-direction: column-reverse;&lt;/code&gt; depending on your layout.</source>
          <target state="translated">HTML에서 요소의 순서를 반대로 사용할 수 있습니다. 그런 다음 &lt;a href=&quot;https://stackoverflow.com/a/36118012/1548895&quot;&gt;Michael_B의 답변&lt;/a&gt; 과 같이 &lt;code&gt;order&lt;/code&gt; 를 사용하는 것 외에도 &lt;code&gt;flex-direction: row-reverse;&lt;/code&gt; 사용할 수 있습니다 . row-reverse; 또는 &lt;code&gt;flex-direction: column-reverse;&lt;/code&gt; 레이아웃에 따라</target>
        </trans-unit>
        <trans-unit id="31081519188f312b812b83b2662058b5c0332726" translate="yes" xml:space="preserve">
          <source>You can use jQuery's &lt;code&gt;find&lt;/code&gt; to perform a &quot;look-ahead&quot; on your target element/class/id, then backtrack to select your target.</source>
          <target state="translated">jQuery의 &lt;code&gt;find&lt;/code&gt; 를 사용하여 대상 요소 / 클래스 / ID에서 &quot;look-ahead&quot;를 수행 한 다음 역 추적하여 대상을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ed017ad0628647ce91c95dd3dc32a10897cc88" translate="yes" xml:space="preserve">
          <source>You can use the two &lt;em&gt;axe&lt;/em&gt; selectors: &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">두 개의 &lt;em&gt;도끼&lt;/em&gt; 선택기를 사용할 수 있습니다 : &lt;code&gt;!&lt;/code&gt; 그리고 &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb21234bc02fdf5666dacb9aa976128fdeb19663" translate="yes" xml:space="preserve">
          <source>You can't select previous elements based on the classes of the next elements</source>
          <target state="translated">다음 요소의 클래스를 기반으로 이전 요소를 선택할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="e3492e80ff1d5c3f8706aa88636dc1da749a151c" translate="yes" xml:space="preserve">
          <source>You want element A to turn red when element B is hovered.</source>
          <target state="translated">요소 B를 가리키면 요소 A가 빨간색으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="85ffd51008e5a489e4ee779532037b307b4eac6e" translate="yes" xml:space="preserve">
          <source>and this way you'll be able to style your current, previous items(all items overridden with current and next items) and your next items.</source>
          <target state="translated">이렇게하면 현재, 이전 항목 (현재 및 다음 항목으로 재정의 된 모든 항목) 및 다음 항목의 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933ae2578114986f2c3a8596b7d13190700e396c" translate="yes" xml:space="preserve">
          <source>but filters those results to keep only &lt;code&gt;#fill-width&lt;/code&gt; elements, so that in the end,</source>
          <target state="translated">하지만 결과를 필터링하여 &lt;code&gt;#fill-width&lt;/code&gt; 요소 만 유지하므로 결국</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="6ea161043c0ed0ac22c49aa54e64e97c531e53e3" translate="yes" xml:space="preserve">
          <source>give all your items a style.</source>
          <target state="translated">모든 아이템에 스타일을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="b02dd7feb3f9788f8c896ddf58c5c6a59c775d85" translate="yes" xml:space="preserve">
          <source>give next items a style using + or ~.</source>
          <target state="translated">다음 항목에 + 또는 ~를 사용하여 스타일을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ffbd2de2c8f0124e30c2c0ad91fd3faa4d399fb6" translate="yes" xml:space="preserve">
          <source>give your selected item a style.</source>
          <target state="translated">선택한 항목에 스타일을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7003ceafdf0fa186aaeed2ac77400fb27b3f0ff9" translate="yes" xml:space="preserve">
          <source>it only selects a &lt;code&gt;#full-width&lt;/code&gt; element if it has a &lt;code&gt;.companies&lt;/code&gt; class descendant.</source>
          <target state="translated">&lt;code&gt;.companies&lt;/code&gt; 클래스 자손이있는 경우 &lt;code&gt;#full-width&lt;/code&gt; 요소 만 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
