<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1817792">
    <body>
      <group id="1817792">
        <trans-unit id="cfd30f7039826be63e4b6a3c5bfcb1de442aff43" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but at the time of writing, it is some distance beyond the bleeding edge for browser support.</source>
          <target state="translated">&amp;hellip;但是在撰写本文时，它离浏览器支持的极限还有一段距离。</target>
        </trans-unit>
        <trans-unit id="407ed6a05587d34adfc62e13d2c7581f19e9ddb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/Types/#jQuery&quot;&gt;&lt;strong&gt;$()&lt;/strong&gt; or jQuery()&lt;/a&gt;: DOM element.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/Types/#jQuery&quot;&gt;&lt;strong&gt;$（）&lt;/strong&gt;或jQuery（）&lt;/a&gt; ：DOM元素。</target>
        </trans-unit>
        <trans-unit id="48db37a8d0a9b127a2f7a5a9e02bd47efd360bfd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/css/#css2&quot;&gt;.&lt;strong&gt;css&lt;/strong&gt;&lt;/a&gt;: Set one or more CSS properties for the set of matched elements.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/css/#css2&quot;&gt;。&lt;/a&gt; &lt;strong&gt;css&lt;/strong&gt; ：为匹配的元素集设置一个或多个CSS属性。</target>
        </trans-unit>
        <trans-unit id="75e7927b9566ce6bd718571221a8e19eb49ccf96" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/find/&quot;&gt;.&lt;strong&gt;find&lt;/strong&gt;&lt;/a&gt;: Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/find/&quot;&gt;。&lt;/a&gt; &lt;strong&gt;find&lt;/strong&gt; ：获取当前匹配元素集中每个元素的后代，并通过选择器，jQuery对象或元素进行过滤。</target>
        </trans-unit>
        <trans-unit id="8d311dec0c9ffe26c57e1d991ac5a86500c0a3ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/parents/&quot;&gt;.&lt;strong&gt;parents&lt;/strong&gt;&lt;/a&gt;: Get the immediately preceding sibling of each element in the set of matched elements. If a selector is provided, it retrieves the previous sibling only if it matches that selector (filters the results to only include the listed elements/selectors).</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/parents/&quot;&gt;。&lt;/a&gt; &lt;strong&gt;parent&lt;/strong&gt; ：获取匹配元素集中每个元素的前一个同级。 如果提供了选择器，则仅当它与选择器匹配时才检索先前的同级（将结果筛选为仅包括列出的元素/选择器）。</target>
        </trans-unit>
        <trans-unit id="08ecad35fbab8b5e681a1477564edd0f2d0ee919" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://drafts.csswg.org/selectors-4/#relational&quot;&gt;Selectors level 4 introduces &lt;code&gt;:has()&lt;/code&gt;&lt;/a&gt; (previously the subject indicator &lt;code&gt;!&lt;/code&gt;) which will allow you to select a previous sibling with:</source>
          <target state="translated">&lt;a href=&quot;https://drafts.csswg.org/selectors-4/#relational&quot;&gt;选择器级别4引入了 &lt;code&gt;:has()&lt;/code&gt; &lt;/a&gt; （以前为subject指示器 &lt;code&gt;!&lt;/code&gt; ），它将允许您使用以下选项选择先前的同级：</target>
        </trans-unit>
        <trans-unit id="7c357fe7705c3417a859eaeabc538a7cb2284380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is the &lt;em&gt;any&lt;/em&gt; previous sibling selector (opposite of &lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 是&lt;em&gt;任何&lt;/em&gt;先前的同级选择器（ &lt;code&gt;~&lt;/code&gt; 对面）</target>
        </trans-unit>
        <trans-unit id="ed595455871545edca70be20be7efc07d20cc069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; is for the next sibling. Is there an equivalent for the previous
  sibling?</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 是下一个兄弟姐妹。 以前的兄弟姐妹有同等学历吗？</target>
        </trans-unit>
        <trans-unit id="2f01423323702105439497e1c1b1f5d8a4578966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; is the &lt;em&gt;immediate&lt;/em&gt; subsequent sibling selector</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 是&lt;em&gt;紧随&lt;/em&gt;其后的同级选择器</target>
        </trans-unit>
        <trans-unit id="94c29eabcf56b07996e3c04cee5016c0b6b57491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.any-previous:hover ! div&lt;/code&gt; selects any previous &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.any-previous:hover ! div&lt;/code&gt; div选择任何先前的 &lt;code&gt;div&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8e28436ba5f1efcd8efa165ba47d3e251d9ba3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.any-subsequent:hover ~ div&lt;/code&gt; selects any subsequent &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.any-subsequent:hover ~ div&lt;/code&gt; 选择任何后续的 &lt;code&gt;div&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22f1f4ce5332c6c4d74834c3f051b795a416ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.immediate-previous:hover ? div&lt;/code&gt; selects the immediate previous &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.immediate-previous:hover ? div&lt;/code&gt; div选择前一个 &lt;code&gt;div&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcc37d93e8f59249a257da2bc655302e547e6940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.immediate-subsequent:hover + div&lt;/code&gt; selects the immediate subsequent &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.immediate-subsequent:hover + div&lt;/code&gt; 选择直接的后续 &lt;code&gt;div&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b0910f8c897e49b7c54ad2f06472848fb9d8227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; is the &lt;em&gt;immediate&lt;/em&gt; previous sibling selector (opposite of &lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 是前一个前一个兄弟选择器（ &lt;code&gt;+&lt;/code&gt; 的对面）</target>
        </trans-unit>
        <trans-unit id="0dee39345cc6ee1279934352bcdade2c20b08a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float-right&lt;/code&gt;&lt;em&gt;+&lt;/em&gt; inverse the order of HTML elements</source>
          <target state="translated">&lt;code&gt;float-right&lt;/code&gt; &lt;em&gt;+&lt;/em&gt;反转HTML元素的顺序</target>
        </trans-unit>
        <trans-unit id="a1da221ab5c3c8b901ce1eb61884ddc4fe922545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; is the &lt;em&gt;any&lt;/em&gt; subsequent sibling selector</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 是&lt;em&gt;任何&lt;/em&gt;后续的同级选择器</target>
        </trans-unit>
        <trans-unit id="768eb8921a37f993d92f5a0ef2bfd879be384f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;&lt;em&gt;Next siblings&lt;/em&gt; operator:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; &lt;em&gt;下一个兄弟姐妹&lt;/em&gt;运算符：</target>
        </trans-unit>
        <trans-unit id="b45ad163a8651c34a0d16d8e3b362d9b76693378" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;sub&gt;(emphasis added)&lt;/sub&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;sub&gt;（添加了重点）&lt;/sub&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="665e55d598d2c11ce4bb90a276830bf6f0fde666" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'll focus on flexbox in the examples below, but the same concepts apply to Grid.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;在下面的示例中，我将重点介绍flexbox，但是相同的概念也适用于Grid。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52a133130a0d198eae4a4b7c47737e1a8e62f4d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3. Flex Item Z-Ordering&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3。&lt;/strong&gt; &lt;strong&gt;弹性项目Z排序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32158f358671818399bba29dbf2c3ba4ab6fc268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.4. Display Order: the &lt;code&gt;order&lt;/code&gt; property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.4。&lt;/strong&gt; &lt;strong&gt;显示订单： &lt;code&gt;order&lt;/code&gt; 属性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6853f54f67919916de40ab32c854f669cb4c3c30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.4. Z-axis Ordering: the &lt;code&gt;z-index&lt;/code&gt; property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.4。&lt;/strong&gt; &lt;strong&gt;Z轴排序： &lt;code&gt;z-index&lt;/code&gt; 属性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83b05dfec3718db0552391149c0e3d7bda0c2c75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;9.9.1 Specifying the stack level: the &lt;code&gt;z-index&lt;/code&gt;
  property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;9.9.1指定堆栈级别： &lt;code&gt;z-index&lt;/code&gt; 属性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b5bfef254b9205245032da598adfe5fc3f90e42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01195ef0b572066871d7b5aad840247fb5f2ad5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;...and voil&amp;agrave;! A previous sibling selector is born (or at least simulated).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;...和瞧！&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;先前的同级选择器已出生（或至少已模拟）。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a2de40614250939e1ac2028b79c2f603e140dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Applies to:      positioned elements&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;适用于：定位元素&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="106af0ab2a1746027aea14ca5280bdf5ceef5300" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;The &lt;code&gt;z-index&lt;/code&gt; Myth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;z-index&lt;/code&gt; 神话&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54a6fe3317e75fae016e1ae7d0ef63443ca1c7a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of &quot;previous sibling selectors&quot; created with the flex &lt;code&gt;order&lt;/code&gt; property.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用flex &lt;code&gt;order&lt;/code&gt; 属性创建的&amp;ldquo;上一个同级选择器&amp;rdquo;的示例。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5d9c630b449804340bc41d05ef058ebd4817f77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With flexbox, a previous sibling selector can be simulated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用flexbox，可以模拟先前的同级选择器。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d1b833d633fafc0324f01aebae36d3b39fe40f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Working Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;工作示例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9446e60594ae9c87ddb1b319e8f4165d0296891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery Reference Docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery参考文档：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37825b906e4a796703b6c32120b0fdcf3c0e47fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jsFiddle&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jsFiddle&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8920f7186483b1f6b58964d259171e0a79ef8336" translate="yes" xml:space="preserve">
          <source>A Side Note &amp;ndash; Two Outdated Beliefs about CSS</source>
          <target state="translated">旁注&amp;ndash;关于CSS的两个过时的信念</target>
        </trans-unit>
        <trans-unit id="3e2877a374953df7fad662b9e45ca3eb44a50e16" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://www.w3.org/TR/css3-grid-layout/#order-property&quot;&gt;&lt;code&gt;order&lt;/code&gt; in the CSS Grid Layout spec&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://www.w3.org/TR/css3-grid-layout/#order-property&quot;&gt;CSS Grid Layout规范中的 &lt;code&gt;order&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a6ee2a76673c38a3c832b48af895c00c9068dbb" translate="yes" xml:space="preserve">
          <source>And the cascade goes only 1 direction: down.</source>
          <target state="translated">而级联只有一个方向:向下。</target>
        </trans-unit>
        <trans-unit id="82fa4888cf695ea35fd3afd3a8aa1b9b775054ed" translate="yes" xml:space="preserve">
          <source>And, again, I was unable to add &lt;code&gt;.companies&lt;/code&gt; any higher up in the HTML.  That part of the HTML was written externally, and wrapped our code.</source>
          <target state="translated">同样，我无法在HTML的更高处添加 &lt;code&gt;.companies&lt;/code&gt; 。 HTML的那部分是外部编写的，并包装了我们的代码。</target>
        </trans-unit>
        <trans-unit id="0ddfcaa1ef0aa8a7c6b06221a8232b25f9c2ae0c" translate="yes" xml:space="preserve">
          <source>Another flexbox solution</source>
          <target state="translated">另一个灵活箱解决方案</target>
        </trans-unit>
        <trans-unit id="48b3c005d9f4850b15a789fb78db521746377c4f" translate="yes" xml:space="preserve">
          <source>Another long-standing belief has been that &lt;code&gt;z-index&lt;/code&gt; works only on positioned elements.</source>
          <target state="translated">另一个长期存在的信念是 &lt;code&gt;z-index&lt;/code&gt; 仅适用于定位的元素。</target>
        </trans-unit>
        <trans-unit id="1cf713b92555463ebe5217207e6aafa0eb082552" translate="yes" xml:space="preserve">
          <source>As described above, this belief is not entirely true. A previous sibling selector can be simulated in CSS using the flex &lt;code&gt;order&lt;/code&gt; property.</source>
          <target state="translated">如上所述，这种信念并不完全正确。 可以使用flex &lt;code&gt;order&lt;/code&gt; 属性在CSS中模拟先前的同级选择器。</target>
        </trans-unit>
        <trans-unit id="229f35a08548eaf6783204176f701b3d33a4f629" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/14469950/5411817&quot;&gt;this answer by Mike Brant&lt;/a&gt;,
the following jQuery snippet could help.</source>
          <target state="translated">根据&lt;a href=&quot;https://stackoverflow.com/a/14469950/5411817&quot;&gt;Mike Brant的回答&lt;/a&gt; ，以下jQuery代码段可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="3ed4d744f4bf8170a78c74aa2fd88d744fdae3bb" translate="yes" xml:space="preserve">
          <source>But I could &lt;em&gt;not&lt;/em&gt; select only &lt;code&gt;#full-width&lt;/code&gt;s that &lt;em&gt;proceeded&lt;/em&gt;&lt;code&gt;.companies&lt;/code&gt;.</source>
          <target state="translated">但是我&lt;em&gt;不能&lt;/em&gt;仅选择&lt;em&gt;继续执行&lt;/em&gt; &lt;code&gt;.companies&lt;/code&gt; 的 &lt;code&gt;#full-width&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90417dea6720e12f30caa00950383afb1b63b2ab" translate="yes" xml:space="preserve">
          <source>But with jQuery, I &lt;em&gt;can&lt;/em&gt; select the required &lt;code&gt;#full-width&lt;/code&gt;s, then assign the appropriate style:</source>
          <target state="translated">但是使用jQuery，我&lt;em&gt;可以&lt;/em&gt;选择所需的 &lt;code&gt;#full-width&lt;/code&gt; ，然后分配适当的样式：</target>
        </trans-unit>
        <trans-unit id="45eedda9c8d9f5b1c7f441ae4f3042455cca6f6b" translate="yes" xml:space="preserve">
          <source>CSS Selector for selecting an element that comes BEFORE another element?</source>
          <target state="translated">用于选择一个元素在另一个元素之前的CSS选择器?</target>
        </trans-unit>
        <trans-unit id="c18f2079c9555b512b0d479beb14f33298d17728" translate="yes" xml:space="preserve">
          <source>CSS select previous sibling</source>
          <target state="translated">CSS选择上一个兄弟姐妹</target>
        </trans-unit>
        <trans-unit id="c5b96b2421df977be54b8afa143635de349ecc67" translate="yes" xml:space="preserve">
          <source>CSS selector for next and previous elements</source>
          <target state="translated">下一个和上一个元素的CSS选择器</target>
        </trans-unit>
        <trans-unit id="39aa2b07f090994b1230fd897c096b82e0b8f70d" translate="yes" xml:space="preserve">
          <source>CSS selector to get preceding sibling</source>
          <target state="translated">用CSS选择器获取前面的兄弟姐妹。</target>
        </trans-unit>
        <trans-unit id="2a9aeb746a06e0844284ee2d4008adbf2fd73b36" translate="yes" xml:space="preserve">
          <source>CSS:</source>
          <target state="translated">CSS:</target>
        </trans-unit>
        <trans-unit id="6173ca19b1a4be22f0ba5a87c6612fc158b212fd" translate="yes" xml:space="preserve">
          <source>CSS: select previous sibling</source>
          <target state="translated">CSS:选择以前的兄弟姐妹</target>
        </trans-unit>
        <trans-unit id="fadb864e568c5d11ae0d18b81383e48b964113f2" translate="yes" xml:space="preserve">
          <source>Change color of sibling elements on hover using CSS</source>
          <target state="translated">使用CSS改变悬停时兄弟姐妹元素的颜色</target>
        </trans-unit>
        <trans-unit id="94a5ad82bf1f904bbeafcb20ec770fd553af2dda" translate="yes" xml:space="preserve">
          <source>Computed value:     as specified</source>
          <target state="translated">计算值:根据规定</target>
        </trans-unit>
        <trans-unit id="9806c929f4fbf2b2374b544d0132be7fc35b2911" translate="yes" xml:space="preserve">
          <source>Consider the &lt;code&gt;order&lt;/code&gt; property of flex and grid layouts.</source>
          <target state="translated">考虑flex和grid布局的 &lt;code&gt;order&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="40d5acc4ac4669c9e11b503fb48cf1ec26dce199" translate="yes" xml:space="preserve">
          <source>Depending on your exact objective, there is a way to achieve the usefulness of a parent selector without using one (even if one were to exist)...</source>
          <target state="translated">根据你的具体目标,有一种方法可以实现不使用亲选器的实用性(即使有亲选器也可以).....</target>
        </trans-unit>
        <trans-unit id="2e976a9b0921bc45e45f2900c57e6179424e3373" translate="yes" xml:space="preserve">
          <source>Effectively, &quot;previous sibling&quot; has been selected via jQuery.</source>
          <target state="translated">实际上,通过jQuery选择了 &quot;以前的兄弟姐妹&quot;。</target>
        </trans-unit>
        <trans-unit id="02caa7b6173db637f5c2e48b1d62c59d7e3222d3" translate="yes" xml:space="preserve">
          <source>Elements that are &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#painting&quot;&gt;&lt;strong&gt;&lt;em&gt;flex items&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://drafts.csswg.org/css-grid/#z-order&quot;&gt;&lt;strong&gt;&lt;em&gt;grid items&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; can create stacking contexts even when &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">即使 &lt;code&gt;position&lt;/code&gt; 为 &lt;code&gt;static&lt;/code&gt; ，作为&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#painting&quot;&gt;&lt;strong&gt;&lt;em&gt;弹性项目&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;或&lt;a href=&quot;https://drafts.csswg.org/css-grid/#z-order&quot;&gt;&lt;strong&gt;&lt;em&gt;网格项目的&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;元素也可以创建堆叠上下文。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="912849c376dc7a8f86c6418763561e232f09e8df" translate="yes" xml:space="preserve">
          <source>Finally, it assigns a new CSS (&lt;code&gt;width&lt;/code&gt;) value to the resulting element.</source>
          <target state="translated">最后，它为结果元素分配一个新的CSS（ &lt;code&gt;width&lt;/code&gt; ）值。</target>
        </trans-unit>
        <trans-unit id="051a837d3891413abfe10ed1070fe8215902c21e" translate="yes" xml:space="preserve">
          <source>Flex items are, by default, displayed and laid out in the same order as they appear in the source document. The 
  &lt;code&gt;order&lt;/code&gt; property can be used to change this ordering.</source>
          <target state="translated">默认情况下，弹性项目的显示和布局方式与它们在源文档中显示的顺序相同。 &lt;code&gt;order&lt;/code&gt; 属性可用于更改此顺序。</target>
        </trans-unit>
        <trans-unit id="fb22e87d22421d730f517d61fc95824612e817ff" translate="yes" xml:space="preserve">
          <source>Flex items paint exactly the same as inline blocks, except that order-modified document order is used in place of raw 
  document order, and &lt;code&gt;z-index&lt;/code&gt; values other than &lt;code&gt;auto&lt;/code&gt; create a stacking context even if &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Flex项的绘制与内联块完全相同，不同之处在于，使用经顺序修改的文档顺序代替原始文档顺序，并且即使 &lt;code&gt;position&lt;/code&gt; 为 &lt;code&gt;static&lt;/code&gt; ,除 &lt;code&gt;auto&lt;/code&gt; 创建堆叠上下文之外的 &lt;code&gt;z-index&lt;/code&gt; 值也会自动创建。</target>
        </trans-unit>
        <trans-unit id="b71f41ee4b8948e2ef97dc6eaec690a10c7079de" translate="yes" xml:space="preserve">
          <source>Flexbox is shattering long-held beliefs about CSS.</source>
          <target state="translated">Flexbox打破了人们长期以来对CSS的固有观念。</target>
        </trans-unit>
        <trans-unit id="959c2ad7e3f03ec94a998bb6e74820a21dce5afc" translate="yes" xml:space="preserve">
          <source>From the flexbox spec:</source>
          <target state="translated">从flexbox的规格来看。</target>
        </trans-unit>
        <trans-unit id="281ae36016b5df798237abd85199faff72bacd6c" translate="yes" xml:space="preserve">
          <source>HTML:
    
        
             
             
             
             
             
        
        (40)</source>
          <target state="translated">HTML。(40)</target>
        </trans-unit>
        <trans-unit id="4068e6a84eaf79e682a75e47116c93a658eb970d" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of &lt;code&gt;z-index&lt;/code&gt; working on non-positioned flex items: &lt;a href=&quot;https://jsfiddle.net/m0wddwxs/&quot;&gt;https://jsfiddle.net/m0wddwxs/&lt;/a&gt;</source>
          <target state="translated">这是 &lt;code&gt;z-index&lt;/code&gt; 在未定位的弹性项目上工作的演示： &lt;a href=&quot;https://jsfiddle.net/m0wddwxs/&quot;&gt;https&lt;/a&gt; : //jsfiddle.net/m0wddwxs/</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="4ede26c3272eca67058c5c4a741b5f5420eec6dd" translate="yes" xml:space="preserve">
          <source>Here's the full code:</source>
          <target state="translated">这里是完整的代码。</target>
        </trans-unit>
        <trans-unit id="91833c79413fd07372f4a33eb8350490dbb11ae4" translate="yes" xml:space="preserve">
          <source>Hope it helps someone.</source>
          <target state="translated">希望能帮助到大家。</target>
        </trans-unit>
        <trans-unit id="00f8058d0dcf0e7a2d3b1ed93e6c2dc0869b7d2a" translate="yes" xml:space="preserve">
          <source>How to add styling to active input's previous sibling using CSS only</source>
          <target state="translated">如何仅使用CSS为活动输入的前一个兄弟姐妹添加样式设计</target>
        </trans-unit>
        <trans-unit id="7aaf9dfcdb948d52cf26522a6afb4dbc69de2344" translate="yes" xml:space="preserve">
          <source>How to affect other elements when a div is hovered</source>
          <target state="translated">当一个DIV被悬停时,如何影响其他元素?</target>
        </trans-unit>
        <trans-unit id="0d8f70e7ad320c862ea828321d87c91c61ed07bc" translate="yes" xml:space="preserve">
          <source>How to select the previous sibling using selenium css syntax</source>
          <target state="translated">如何使用selenium css语法选择上一个兄弟姐妹?</target>
        </trans-unit>
        <trans-unit id="edde16975af4c3f91926ae4ab528a19e13d1638b" translate="yes" xml:space="preserve">
          <source>However, if you are able to add &lt;strong&gt;JavaScript&lt;/strong&gt; to your page, a little bit of &lt;strong&gt;jQuery&lt;/strong&gt; could get you to your end goal.</source>
          <target state="translated">但是，如果您能够将&lt;strong&gt;JavaScript&lt;/strong&gt;添加到页面中，则使用&lt;strong&gt;jQuery&lt;/strong&gt;可以使您达到最终目标。</target>
        </trans-unit>
        <trans-unit id="1acf1134953119f55a775a44bb0634b7ef15a1f0" translate="yes" xml:space="preserve">
          <source>However, in the &lt;strong&gt;axe&lt;/strong&gt; CSS post-processor library, there are &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; previous sibling selectors&lt;/em&gt;:</source>
          <target state="translated">但是，在&lt;strong&gt;ax&lt;/strong&gt; CSS后处理器库中，有&lt;strong&gt;&lt;em&gt;两个&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;以前的兄弟选择器&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="86caa6bdc362ff8eaa7d03615f8d8811870000f5" translate="yes" xml:space="preserve">
          <source>I found a way to style all previous siblings (opposite of &lt;code&gt;~&lt;/code&gt;) that may work depending on what you need.</source>
          <target state="translated">我找到了一种样式来设置所有以前的兄弟姐妹（与 &lt;code&gt;~&lt;/code&gt; 相对）的方法，具体取决于您的需要。</target>
        </trans-unit>
        <trans-unit id="6bd7bc412ee50b933334dc0e025771a9a14db374" translate="yes" xml:space="preserve">
          <source>I had a similar problem and found out that all problem of this nature can be solved as follows:</source>
          <target state="translated">我也遇到过类似的问题,发现这种性质的问题都可以解决,如下图所示。</target>
        </trans-unit>
        <trans-unit id="eab5cd63e9e3e19eaf186d4e85865aaff9d7de65" translate="yes" xml:space="preserve">
          <source>I had control of all the HTML under &lt;code&gt;.companies&lt;/code&gt;, but could not alter any of the HTML above it.</source>
          <target state="translated">我可以控制 &lt;code&gt;.companies&lt;/code&gt; 下的所有HTML，但无法更改其上方的任何HTML。</target>
        </trans-unit>
        <trans-unit id="090d3b447a141fd56eaee940ec7c0b3c9181252e" translate="yes" xml:space="preserve">
          <source>I had the same question, but then I had a &quot;duh&quot; moment.   Instead of writing</source>
          <target state="translated">我也有同样的问题,但后来我有了一个 &quot;duh &quot;的瞬间。我不写了,而是写了</target>
        </trans-unit>
        <trans-unit id="dcdbf832ffc8960412f46127139613b7788265e1" translate="yes" xml:space="preserve">
          <source>I needed a solution to select the previous sibling tr. I came up with this solution using React and Styled-components. This is not my exact solution (This is from memory, hours later). I know there is a flaw in the setHighlighterRow function.</source>
          <target state="translated">我需要一个解决方案来选择前一个兄弟姐妹的tr。我用React和Styled-components想出了这个解决方案。这不是我的确切解决方案(这是从记忆中得出的,几个小时后)。我知道setHighlighterRow函数有一个缺陷。</target>
        </trans-unit>
        <trans-unit id="ef5fd2bd284dea941940014eb44dd99e73a46d05" translate="yes" xml:space="preserve">
          <source>I realize that the original question was a CSS question so this answer is probably completely irrelevant, but other Javascript users may stumble on the question via search like I did.</source>
          <target state="translated">我知道最初的问题是一个CSS问题,所以这个答案可能完全不相关,但是其他的Javascript用户可能会像我一样,通过搜索找到这个问题。</target>
        </trans-unit>
        <trans-unit id="13fe1d484840b69d747494ca988cef005264e7cc" translate="yes" xml:space="preserve">
          <source>I'm using FontAwesome in this example and swapping between the unicodes of fa-star-o and fa-star
&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;http://fortawesome.github.io/Font-Awesome/&lt;/a&gt;</source>
          <target state="translated">我在此示例中使用FontAwesome，并在fa-star-o和fa-star的unicode之间交换&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;http://fortawesome.github.io/Font-Awesome/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e718f5646afda421ef33270aaf412d5fe58f945f" translate="yes" xml:space="preserve">
          <source>If you know the exact position an &lt;code&gt;:nth-child()&lt;/code&gt;-based exclusion of all following siblings would work.</source>
          <target state="translated">如果您知道确切位置，则可以使用基于 &lt;code&gt;:nth-child()&lt;/code&gt; 的方式排除以下所有同级物品。</target>
        </trans-unit>
        <trans-unit id="79c501d695c28ba90a85b59b704d657bef33509c" translate="yes" xml:space="preserve">
          <source>In conventional CSS, there is &lt;strong&gt;no previous sibling selector&lt;/strong&gt;.</source>
          <target state="translated">在常规CSS中， &lt;strong&gt;没有先前的兄弟选择器&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="51c49ae56e89555fda5525ce78e016d4a9960577" translate="yes" xml:space="preserve">
          <source>In fact, the most current version of the spec &amp;ndash; the &lt;a href=&quot;https://drafts.csswg.org/css2/visuren.html#propdef-z-index&quot;&gt;W3C Editor's Draft&lt;/a&gt; &amp;ndash; still asserts this to be true:</source>
          <target state="translated">实际上，该规范的最新版本&amp;ndash; &lt;a href=&quot;https://drafts.csswg.org/css2/visuren.html#propdef-z-index&quot;&gt;W3C编辑器的草案&lt;/a&gt; &amp;ndash;仍然认为这是正确的：</target>
        </trans-unit>
        <trans-unit id="c1614e8db35c84f7389f93ed6ae211115f938273" translate="yes" xml:space="preserve">
          <source>In my case I was looking to find a way to select a DIV with the id &lt;code&gt;#full-width&lt;/code&gt;, but ONLY if it had a (indirect) descendant DIV with the class of &lt;code&gt;.companies&lt;/code&gt;.</source>
          <target state="translated">就我而言，我正在寻找一种方法来选择ID为 &lt;code&gt;#full-width&lt;/code&gt; 的DIV，但仅当它具有 &lt;code&gt;.companies&lt;/code&gt; 类的（间接）后代DIV 时才可以 。</target>
        </trans-unit>
        <trans-unit id="2fe2536c1eacf4a1a05311c9729aa249a76be838" translate="yes" xml:space="preserve">
          <source>In my case, I wanted a primarily CSS 5-star rating system. I would need to color (or swap the icon of) the previous stars. By floating each element right, I am essentially getting the same effect (the html for the stars thus must be written 'backwards').</source>
          <target state="translated">在我的情况下,我想要一个主要是CSS的5星评级系统。我需要给之前的星星涂上颜色(或交换图标)。通过将每一个元素向右浮动,我基本上得到了相同的效果(因此星星的html必须 &quot;倒着写&quot;)。</target>
        </trans-unit>
        <trans-unit id="248d5f16812a94c0896fd71081300c46b317e6b7" translate="yes" xml:space="preserve">
          <source>In particular, the flex &lt;code&gt;order&lt;/code&gt; property can move elements around the screen.</source>
          <target state="translated">特别是，flex &lt;code&gt;order&lt;/code&gt; 属性可以使元素在屏幕上移动。</target>
        </trans-unit>
        <trans-unit id="a8efd7365dcd78f460f2e36c60a2e4b618e07fb8" translate="yes" xml:space="preserve">
          <source>In reality, however, this information is obsolete and inaccurate.</source>
          <target state="translated">但在现实中,这种信息是过时的,不准确的。</target>
        </trans-unit>
        <trans-unit id="2fd90fb4157d1e9c3cb82e78b72caf02e01264c9" translate="yes" xml:space="preserve">
          <source>In the example below:</source>
          <target state="translated">在下面的例子中。</target>
        </trans-unit>
        <trans-unit id="5c3dfe0de7d1bc518306aa10258d1c13f54861f3" translate="yes" xml:space="preserve">
          <source>Inherited:      no</source>
          <target state="translated">继承人:没有</target>
        </trans-unit>
        <trans-unit id="3000181e0628e7643bd8adee4c6849bd29ea5b9b" translate="yes" xml:space="preserve">
          <source>Initial:    auto</source>
          <target state="translated">首字母:自动</target>
        </trans-unit>
        <trans-unit id="48aae125c6273372fc204836e6350a2e37f3be5c" translate="yes" xml:space="preserve">
          <source>Is there a “previous sibling” selector</source>
          <target state="translated">是否有 &quot;以前的兄弟姐妹 &quot;选择器?</target>
        </trans-unit>
        <trans-unit id="9be9d437f0dfb6899a9700afc7c6af5f0d9ebc59" translate="yes" xml:space="preserve">
          <source>Is there an equivalent for the previous sibling?</source>
          <target state="translated">前面的兄弟姐妹是否有等价物?</target>
        </trans-unit>
        <trans-unit id="68b4de53a6017d1e28b25a9e348ee280f2caa4ae" translate="yes" xml:space="preserve">
          <source>JSFiddle: &lt;a href=&quot;http://jsfiddle.net/andrewleyva/88j0105g/&quot;&gt;http://jsfiddle.net/andrewleyva/88j0105g/&lt;/a&gt;</source>
          <target state="translated">JSFiddle： &lt;a href=&quot;http://jsfiddle.net/andrewleyva/88j0105g/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/andrewleyva/88j0105g/</target>
        </trans-unit>
        <trans-unit id="02c3528b037f688712d83f406ccbb1cfec5c20c2" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of links and when hovering on one, all the previous ones should turn red. You can do it like this:</source>
          <target state="translated">比方说你有一个链接列表,在一个链接上徘徊时,前面的链接都应该变成红色。你可以这样做。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="9437ceed3329cdf77b8d382349418ba82d6804b0" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;ul&lt;/code&gt; a flex container.</source>
          <target state="translated">使 &lt;code&gt;ul&lt;/code&gt; 为flex容器。</target>
        </trans-unit>
        <trans-unit id="b889c73d1be01b47f80ae16c97e8e4ca2fb402b9" translate="yes" xml:space="preserve">
          <source>Media:      visual</source>
          <target state="translated">媒体:视觉</target>
        </trans-unit>
        <trans-unit id="3bc97b7eba79269b952d0d89cd932fa205b3222e" translate="yes" xml:space="preserve">
          <source>No, there is no &quot;previous sibling&quot; selector.</source>
          <target state="translated">不,没有 &quot;以前的兄弟姐妹 &quot;选择器。</target>
        </trans-unit>
        <trans-unit id="06523e089f48369a43a839a5578b36a3dff2c2ba" translate="yes" xml:space="preserve">
          <source>No. It is not possible via CSS. It takes the &quot;Cascade&quot; to heart ;-).</source>
          <target state="translated">不,这是不可能通过CSS来实现的。它把 &quot;Cascade &quot;放在心上;-)。</target>
        </trans-unit>
        <trans-unit id="8c00c220dbd31f27615214a55bdebafb9b9301d2" translate="yes" xml:space="preserve">
          <source>Now, use the &lt;code&gt;.css&lt;/code&gt; function to pass in your CSS new values for that element.</source>
          <target state="translated">现在，使用 &lt;code&gt;.css&lt;/code&gt; 函数为该元素传递CSS新值。</target>
        </trans-unit>
        <trans-unit id="648457847b306355248f81e8054a176758693c6b" translate="yes" xml:space="preserve">
          <source>Obviously this matches &quot;x&quot; instead of &quot;y&quot;, but it answers the &quot;is there a match?&quot; question, and simple DOM traversal may get you to the right element more efficiently than looping in javascript.</source>
          <target state="translated">很明显,这样匹配的是 &quot;x &quot;而不是 &quot;y&quot;,但它回答了 &quot;有匹配吗?&quot;的问题,简单的DOM遍历可能会比在javascript中循环更有效地找到正确的元素。</target>
        </trans-unit>
        <trans-unit id="15de0eca38d6ad16eebdf50299f9363d30dc7a2d" translate="yes" xml:space="preserve">
          <source>On a related note, &lt;code&gt;~&lt;/code&gt; is for general successor sibling (meaning the element comes after this one, but not necessarily immediately after) and is a CSS3 selector. &lt;code&gt;+&lt;/code&gt; is for next sibling and is CSS2.1.</source>
          <target state="translated">与此相关的是， &lt;code&gt;~&lt;/code&gt; 用于一般后继兄弟（意味着该元素在此之后，但不一定紧随其后），并且是CSS3选择器。 &lt;code&gt;+&lt;/code&gt; 是下一个兄弟姐妹，是CSS2.1。</target>
        </trans-unit>
        <trans-unit id="a75a09fb96d32623c76fedce272a3f203462aaec" translate="yes" xml:space="preserve">
          <source>OnMouseOver a row will set the row index to state, and rerender the previous row with a new background color</source>
          <target state="translated">OnMouseOver会将行的索引设置为状态,并以新的背景颜色重新渲染上一行。</target>
        </trans-unit>
        <trans-unit id="68a7635b24a97f76bb9ebc1cbe012194bf82823d" translate="yes" xml:space="preserve">
          <source>One such belief is that &lt;a href=&quot;https://stackoverflow.com/a/10006328/3597276&quot;&gt;&lt;strong&gt;a previous sibling selector is not possible in CSS&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">一个这样的信念是， &lt;a href=&quot;https://stackoverflow.com/a/10006328/3597276&quot;&gt;&lt;strong&gt;在CSS中不可能有以前的兄弟选择器&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea475966115fbffc1211959ca65e05ecdb8f7fa7" translate="yes" xml:space="preserve">
          <source>Or I could select &lt;code&gt;.companies&lt;/code&gt; that only followed a &lt;code&gt;#full-width&lt;/code&gt;.</source>
          <target state="translated">或者，我可以选择仅跟随 &lt;code&gt;#full-width&lt;/code&gt; 的 &lt;code&gt;.companies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a8ac81b3400af06c7cc81e6077f2d0fc74b0486" translate="yes" xml:space="preserve">
          <source>Parent with &lt;code&gt;direction: rtl;&lt;/code&gt; + inverse the order of inner elements</source>
          <target state="translated">家长 &lt;code&gt;direction: rtl;&lt;/code&gt; +反转内部元素的顺序</target>
        </trans-unit>
        <trans-unit id="e20b56b4243462d32777361ea6e24f9a73aaf5f4" translate="yes" xml:space="preserve">
          <source>Percentages:    N/A</source>
          <target state="translated">百分比。不适用</target>
        </trans-unit>
        <trans-unit id="4ddf62b2329b83ab800d77bbeccd01a350dd2c7f" translate="yes" xml:space="preserve">
          <source>Previous adjacent selector in CSS</source>
          <target state="translated">CSS中的上一个相邻选择器</target>
        </trans-unit>
        <trans-unit id="1f32fd13429c7ba13ea2351ea2bb3a24954b169f" translate="yes" xml:space="preserve">
          <source>Reverse the order of siblings in the mark-up.</source>
          <target state="translated">将标记中的兄弟姐妹的顺序颠倒过来。</target>
        </trans-unit>
        <trans-unit id="8f7e94d1cf379df4a82d4c27c7dac3111a469db4" translate="yes" xml:space="preserve">
          <source>STEPS</source>
          <target state="translated">STEPS</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">说我们有。</target>
        </trans-unit>
        <trans-unit id="f82c3fbbc6d8a3c6cd5e5d1cf2400a349b7b74f7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#adjacent-sibling-combinators&quot;&gt;Adjacent sibling combinator&lt;/a&gt; from &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/&quot;&gt;Selectors Level 3&lt;/a&gt; and &lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors&quot;&gt;5.7 Adjacent sibling selectors&lt;/a&gt; from &lt;a href=&quot;http://www.w3.org/TR/CSS21/cover.html#minitoc&quot;&gt;Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification&lt;/a&gt;.</source>
          <target state="translated">请参见&lt;a href=&quot;http://www.w3.org/TR/css3-selectors/&quot;&gt;选择器级别3&lt;/a&gt;和&lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors&quot;&gt;5.7的相邻同级组合器，&lt;/a&gt;以及&lt;a href=&quot;http://www.w3.org/TR/CSS21/cover.html#minitoc&quot;&gt;级联样式表2修订版1（CSS 2.1）规范中的&lt;/a&gt; 相邻同级选择器 。</target>
        </trans-unit>
        <trans-unit id="4b32df97065887792fc54ce0bd0085574a236ced" translate="yes" xml:space="preserve">
          <source>Select previous siblings on hover</source>
          <target state="translated">悬停选择以前的兄弟姐妹</target>
        </trans-unit>
        <trans-unit id="b8802af3c25aab2b10973154bd80f5d4a28fbeb3" translate="yes" xml:space="preserve">
          <source>Select the preceding sibling of an element in CSS using selectors</source>
          <target state="translated">在CSS中使用selectors选择一个元素的前一个元素的兄弟姐妹。</target>
        </trans-unit>
        <trans-unit id="3f69e926c961d47d6b8bf4edd9ada01387a1af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; property controls the order in which flex items appear within the flex container, by assigning them to ordinal groups. It takes a single &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; value, which specifies which ordinal group the flex item 
  belongs to.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 属性通过将伸缩项目分配给顺序组来控制伸缩项目在伸缩容器中的显示顺序。 它采用单个 &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; 值，该值指定弹性项目所属的顺序组。</target>
        </trans-unit>
        <trans-unit id="bee636d2e47bd8d9ebd01557931b7587b00a7e8a" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;order&lt;/code&gt; value for all flex items is 0.</source>
          <target state="translated">所有弹性商品的初始 &lt;code&gt;order&lt;/code&gt; 值为0。</target>
        </trans-unit>
        <trans-unit id="1f84bcdbeb978aab5a1803803dd526d2abe73d82" translate="yes" xml:space="preserve">
          <source>The painting order of grid items is exactly the same as inline blocks, except that order-modified document order is 
  used in place of raw document order, and &lt;code&gt;z-index&lt;/code&gt; values other than &lt;code&gt;auto&lt;/code&gt; create a stacking context even if 
  &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">网格项目的绘制顺序与嵌入式块完全相同，不同之处在于，使用顺序修改后的文档顺序代替原始文档顺序，并且即使 &lt;code&gt;position&lt;/code&gt; 为 &lt;code&gt;static&lt;/code&gt; ， &lt;code&gt;z-index&lt;/code&gt; 值也会 &lt;code&gt;auto&lt;/code&gt; 创建堆叠上下文，而不是自动创建堆叠上下文。</target>
        </trans-unit>
        <trans-unit id="427e7f7201e462d2988b2f979cbd84408150c14d" translate="yes" xml:space="preserve">
          <source>The plus sign (&lt;code&gt;+&lt;/code&gt;) is for the next sibling.</source>
          <target state="translated">加号（ &lt;code&gt;+&lt;/code&gt; ）用于下一个兄弟姐妹。</target>
        </trans-unit>
        <trans-unit id="a504da474de17cf78a56f80874e1f7160a2eff59" translate="yes" xml:space="preserve">
          <source>Then it &quot;backtracks&quot; to select all the previous &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;s from that set of &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;s.</source>
          <target state="translated">然后，它&amp;ldquo;回溯&amp;rdquo;以从该组 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 中选择所有先前的 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998b5fdf1840ef4280f75ef69d0cab0498e6fb8a" translate="yes" xml:space="preserve">
          <source>Then it uses &lt;code&gt;.parents&lt;/code&gt; to &quot;backtrack&quot; and select ALL parents of &lt;code&gt;.companies&lt;/code&gt;,</source>
          <target state="translated">然后，它使用 &lt;code&gt;.parents&lt;/code&gt; 进行&amp;ldquo;回溯&amp;rdquo;并选择 &lt;code&gt;.companies&lt;/code&gt; 的所有父项 ，</target>
        </trans-unit>
        <trans-unit id="f86be13dd4259c6e46b8a5e0c9eec5da827d2688" translate="yes" xml:space="preserve">
          <source>Then you use jQuery to re-write the DOM (CSS) for your element.</source>
          <target state="translated">然后用jQuery为你的元素重写DOM(CSS)。</target>
        </trans-unit>
        <trans-unit id="9f5ec78f818e941a2192daf69266fbc4682f676e" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; subsequent sibling selectors&lt;/em&gt; in conventional CSS:</source>
          <target state="translated">常规CSS中有&lt;strong&gt;&lt;em&gt;2个&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;后续的同级选择器&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="481d7edcc0194f06e2e87c4622cd3df70b606c45" translate="yes" xml:space="preserve">
          <source>There is no &quot;previous&quot; sibling selector unfortunately, but you can &lt;em&gt;possibly&lt;/em&gt; still get the same effect by using positioning (e.g. float right). It depends on what you are trying to do.</source>
          <target state="translated">不幸的是，没有&amp;ldquo;上一个&amp;rdquo;同级选择器，但是通过使用定位（例如，向右浮动），您仍然可以得到相同的效果。 这取决于您要执行的操作。</target>
        </trans-unit>
        <trans-unit id="03b6eeb31b47d9993da80a332e6a18ebd9b2ffe6" translate="yes" xml:space="preserve">
          <source>There is no official way to do that at the moment but you can use a little trick to achieve this ! Remember that it is experimental and it has some limitation ...
(check &lt;a href=&quot;http://fmbip.com/litmus/&quot;&gt;this link&lt;/a&gt; if you worries about navigator compatibility )</source>
          <target state="translated">目前尚无官方方法可以执行此操作，但是您可以使用一些技巧来实现此目的！ 请记住，这是实验性的，并且有一定的局限性...（如果您担心导航器的兼容性，请查看&lt;a href=&quot;http://fmbip.com/litmus/&quot;&gt;此链接&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="45b35f90fcdcabc6a74055eb084b276d13094e30" translate="yes" xml:space="preserve">
          <source>This finds all &lt;code&gt;#full-width .companies&lt;/code&gt;, and selects just those &lt;code&gt;.companies&lt;/code&gt;, similar to how selectors are used to target specific elements in standard in CSS.</source>
          <target state="translated">这将查找所有 &lt;code&gt;#full-width .companies&lt;/code&gt; ，并仅选择那些 &lt;code&gt;.companies&lt;/code&gt; ，类似于使用选择器定位CSS标准中的特定元素的方式。</target>
        </trans-unit>
        <trans-unit id="ca872b70b4139c1dd2fb6a771206f43e4b169e1c" translate="yes" xml:space="preserve">
          <source>This first selects all &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;s that immediately follow a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这首先选择紧跟 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 的所有 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; &amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="74496773ae4f698f108b0c2c81194fcf66a99f32" translate="yes" xml:space="preserve">
          <source>This is the same for pseudo classes</source>
          <target state="translated">这对于伪类也是一样的</target>
        </trans-unit>
        <trans-unit id="780f7784d75a1253b4979a5ed18f418476e2e415" translate="yes" xml:space="preserve">
          <source>This sets all anchor links to have 15px margin on the top and resets it back to 0 for those with no UL elements (or other tags) inside LIs.</source>
          <target state="translated">这将所有的锚点链接设置为顶部有15px的边距,而对于那些没有UL元素(或其他标签)的锚点链接,则将其重置为0。</target>
        </trans-unit>
        <trans-unit id="d693c780f30dd4ef25beb759926f543600b69fa2" translate="yes" xml:space="preserve">
          <source>Thus I could select ALL &lt;code&gt;#full-width&lt;/code&gt;s.</source>
          <target state="translated">因此，我可以选择ALL &lt;code&gt;#full-width&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c603a250e4ca71f19cd8ea72a8ecb969a8783120" translate="yes" xml:space="preserve">
          <source>To say this belief is widespread would be an understatement. Here's a sampling of related questions on Stack Overflow alone:</source>
          <target state="translated">要说这种信念是普遍存在的,那就太轻描淡写了。下面仅就Stack Overflow上的相关问题做个示例。</target>
        </trans-unit>
        <trans-unit id="1d3701e331dc8b27252466a97f77b8a75a27c8dd" translate="yes" xml:space="preserve">
          <source>Two &lt;em&gt;tricks&lt;/em&gt;. Basically inverting the HTML order of your desired elements in HTML and using</source>
          <target state="translated">两个&lt;em&gt;招&lt;/em&gt; 。 基本上反转所需元素在HTML中的HTML顺序并使用</target>
        </trans-unit>
        <trans-unit id="da5a01f69e0f0a6401c48450d762ea9e3ca49bb7" translate="yes" xml:space="preserve">
          <source>Use a sibling selector to target Element A  (&lt;code&gt;~&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; will do) .</source>
          <target state="translated">使用同级选择器将元素A作为目标（ &lt;code&gt;~&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; 可以）。</target>
        </trans-unit>
        <trans-unit id="6418531d3667fddb681489113d747c5a42f51833" translate="yes" xml:space="preserve">
          <source>Use the flex &lt;code&gt;order&lt;/code&gt; property to restore the order of siblings on the visual display.</source>
          <target state="translated">使用flex &lt;code&gt;order&lt;/code&gt; 属性可以恢复视觉显示中的兄弟姐妹顺序。</target>
        </trans-unit>
        <trans-unit id="668d622c2d0c54db3e9364afa53203471e4c680a" translate="yes" xml:space="preserve">
          <source>Value:      auto |  | inherit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c966d2e7899f01b11a9c146510d6e9c5569df" translate="yes" xml:space="preserve">
          <source>What can we do to make the Socks block (including sock colours) stand out visually using spacing?</source>
          <target state="translated">怎么做才能让袜子块(包括袜子颜色)在视觉上用间距突出?</target>
        </trans-unit>
        <trans-unit id="20dc3d5b8b33b8fca560d792ef4e22c80f9162be" translate="yes" xml:space="preserve">
          <source>What does exist:</source>
          <target state="translated">有什么存在。</target>
        </trans-unit>
        <trans-unit id="88536aa66c898bfb53c491477414c9d560627da3" translate="yes" xml:space="preserve">
          <source>What would be nice but doesn't exist:</source>
          <target state="translated">有什么东西会很好,但不存在。</target>
        </trans-unit>
        <trans-unit id="9ec5485132671fdd7692fc8455d289a7863233f3" translate="yes" xml:space="preserve">
          <source>What you can do is use a CSS3 selector : the pseudo classe called &lt;code&gt;nth-child()&lt;/code&gt;</source>
          <target state="translated">您可以使用CSS3选择器：称为 &lt;code&gt;nth-child()&lt;/code&gt; 的伪类。</target>
        </trans-unit>
        <trans-unit id="0077a584a44ef74fce634034afa28323a805771d" translate="yes" xml:space="preserve">
          <source>Which does the same.</source>
          <target state="translated">这一点是一样的。</target>
        </trans-unit>
        <trans-unit id="4e1cb73736ecd6fc6afeba8df7ddf1a7664dd27b" translate="yes" xml:space="preserve">
          <source>Which would select all &lt;code&gt;li&lt;/code&gt;s before the 3rd (e.g. 1st and 2nd). But, in my opinion this looks ugly and has a very tight usecase.</source>
          <target state="translated">它将选择第3个（例如第1个和第2个）之前的所有 &lt;code&gt;li&lt;/code&gt; 。 但是，在我看来，这看起来很丑陋，并且用例非常紧凑。</target>
        </trans-unit>
        <trans-unit id="45ee67100ba9b556b21767275c4bde54ec9eeb16" translate="yes" xml:space="preserve">
          <source>Working sample:</source>
          <target state="translated">工作样本:</target>
        </trans-unit>
        <trans-unit id="66d88363dd000457d2bb258b0c3eaee69b3c4440" translate="yes" xml:space="preserve">
          <source>You also could select the nth-child right-to-left:</source>
          <target state="translated">你也可以从右至左选择第n个孩子。</target>
        </trans-unit>
        <trans-unit id="e505512adaaefac12cb8dfb4e4b5aec4195707b3" translate="yes" xml:space="preserve">
          <source>You can use inverse the order of elements in HTML. Then besides using &lt;code&gt;order&lt;/code&gt; as in &lt;a href=&quot;https://stackoverflow.com/a/36118012/1548895&quot;&gt;Michael_B's answer&lt;/a&gt; you can use &lt;code&gt;flex-direction: row-reverse;&lt;/code&gt; or &lt;code&gt;flex-direction: column-reverse;&lt;/code&gt; depending on your layout.</source>
          <target state="translated">您可以使用相反的HTML元素顺序。 然后除了像&lt;a href=&quot;https://stackoverflow.com/a/36118012/1548895&quot;&gt;Michael_B的答案&lt;/a&gt;那样使用 &lt;code&gt;order&lt;/code&gt; 之外，还可以使用 &lt;code&gt;flex-direction: row-reverse;&lt;/code&gt; 或 &lt;code&gt;flex-direction: column-reverse;&lt;/code&gt; 根据您的布局。</target>
        </trans-unit>
        <trans-unit id="31081519188f312b812b83b2662058b5c0332726" translate="yes" xml:space="preserve">
          <source>You can use jQuery's &lt;code&gt;find&lt;/code&gt; to perform a &quot;look-ahead&quot; on your target element/class/id, then backtrack to select your target.</source>
          <target state="translated">您可以使用jQuery的 &lt;code&gt;find&lt;/code&gt; 在目标元素/类/ id上执行&amp;ldquo;前瞻&amp;rdquo;，然后回溯以选择目标。</target>
        </trans-unit>
        <trans-unit id="75ed017ad0628647ce91c95dd3dc32a10897cc88" translate="yes" xml:space="preserve">
          <source>You can use the two &lt;em&gt;axe&lt;/em&gt; selectors: &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">您可以使用两个&lt;em&gt;斧头&lt;/em&gt;选择器： 和 &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb21234bc02fdf5666dacb9aa976128fdeb19663" translate="yes" xml:space="preserve">
          <source>You can't select previous elements based on the classes of the next elements</source>
          <target state="translated">你不能根据下一个元素的类来选择前一个元素</target>
        </trans-unit>
        <trans-unit id="e3492e80ff1d5c3f8706aa88636dc1da749a151c" translate="yes" xml:space="preserve">
          <source>You want element A to turn red when element B is hovered.</source>
          <target state="translated">你希望元素A在元素B被盘旋时变成红色。</target>
        </trans-unit>
        <trans-unit id="85ffd51008e5a489e4ee779532037b307b4eac6e" translate="yes" xml:space="preserve">
          <source>and this way you'll be able to style your current, previous items(all items overridden with current and next items) and your next items.</source>
          <target state="translated">这样,你就可以把当前、上一个项目(所有项目都用当前和下一个项目覆盖)和下一个项目的样式。</target>
        </trans-unit>
        <trans-unit id="933ae2578114986f2c3a8596b7d13190700e396c" translate="yes" xml:space="preserve">
          <source>but filters those results to keep only &lt;code&gt;#fill-width&lt;/code&gt; elements, so that in the end,</source>
          <target state="translated">但对这些结果进行过滤以仅保留 &lt;code&gt;#fill-width&lt;/code&gt; 元素，因此最后，</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="6ea161043c0ed0ac22c49aa54e64e97c531e53e3" translate="yes" xml:space="preserve">
          <source>give all your items a style.</source>
          <target state="translated">给你的所有物品增添风格。</target>
        </trans-unit>
        <trans-unit id="b02dd7feb3f9788f8c896ddf58c5c6a59c775d85" translate="yes" xml:space="preserve">
          <source>give next items a style using + or ~.</source>
          <target state="translated">用+或~来给下一个项目做一个样式。</target>
        </trans-unit>
        <trans-unit id="ffbd2de2c8f0124e30c2c0ad91fd3faa4d399fb6" translate="yes" xml:space="preserve">
          <source>give your selected item a style.</source>
          <target state="translated">给你所选的物品赋予风格。</target>
        </trans-unit>
        <trans-unit id="7003ceafdf0fa186aaeed2ac77400fb27b3f0ff9" translate="yes" xml:space="preserve">
          <source>it only selects a &lt;code&gt;#full-width&lt;/code&gt; element if it has a &lt;code&gt;.companies&lt;/code&gt; class descendant.</source>
          <target state="translated">如果它具有 &lt;code&gt;.companies&lt;/code&gt; 类后代，则仅选择 &lt;code&gt;#full-width&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
