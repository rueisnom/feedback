<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1817792">
    <body>
      <group id="1817792">
        <trans-unit id="cfd30f7039826be63e4b6a3c5bfcb1de442aff43" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but at the time of writing, it is some distance beyond the bleeding edge for browser support.</source>
          <target state="translated">&amp;hellip;しかし、これを書いている時点では、ブラウザサポートの最先端をいくらか超えています。</target>
        </trans-unit>
        <trans-unit id="407ed6a05587d34adfc62e13d2c7581f19e9ddb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/Types/#jQuery&quot;&gt;&lt;strong&gt;$()&lt;/strong&gt; or jQuery()&lt;/a&gt;: DOM element.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/Types/#jQuery&quot;&gt;&lt;strong&gt;$（）&lt;/strong&gt;またはjQuery（）&lt;/a&gt; ：DOM要素。</target>
        </trans-unit>
        <trans-unit id="48db37a8d0a9b127a2f7a5a9e02bd47efd360bfd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/css/#css2&quot;&gt;.&lt;strong&gt;css&lt;/strong&gt;&lt;/a&gt;: Set one or more CSS properties for the set of matched elements.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/css/#css2&quot;&gt;。&lt;/a&gt; &lt;strong&gt;css&lt;/strong&gt; ：一致する要素のセットに1つ以上のCSSプロパティを設定します。</target>
        </trans-unit>
        <trans-unit id="75e7927b9566ce6bd718571221a8e19eb49ccf96" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/find/&quot;&gt;.&lt;strong&gt;find&lt;/strong&gt;&lt;/a&gt;: Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/find/&quot;&gt;。&lt;/a&gt; &lt;strong&gt;find&lt;/strong&gt; ：セレクター、jQueryオブジェクト、または要素によってフィルター処理された、一致する要素の現在のセット内の各要素の子孫を取得します。</target>
        </trans-unit>
        <trans-unit id="8d311dec0c9ffe26c57e1d991ac5a86500c0a3ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/parents/&quot;&gt;.&lt;strong&gt;parents&lt;/strong&gt;&lt;/a&gt;: Get the immediately preceding sibling of each element in the set of matched elements. If a selector is provided, it retrieves the previous sibling only if it matches that selector (filters the results to only include the listed elements/selectors).</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/parents/&quot;&gt;。&lt;/a&gt; &lt;strong&gt;parents&lt;/strong&gt; ：一致する要素のセット内の各要素の直前の兄弟を取得します。 セレクターが提供されている場合、そのセレクターに一致する場合にのみ、前の兄弟を取得します（リストされた要素/セレクターのみが含まれるように結果をフィルタリングします）。</target>
        </trans-unit>
        <trans-unit id="08ecad35fbab8b5e681a1477564edd0f2d0ee919" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://drafts.csswg.org/selectors-4/#relational&quot;&gt;Selectors level 4 introduces &lt;code&gt;:has()&lt;/code&gt;&lt;/a&gt; (previously the subject indicator &lt;code&gt;!&lt;/code&gt;) which will allow you to select a previous sibling with:</source>
          <target state="translated">&lt;a href=&quot;https://drafts.csswg.org/selectors-4/#relational&quot;&gt;セレクターレベル4では、 &lt;code&gt;:has()&lt;/code&gt; &lt;/a&gt; （以前はサブジェクトインジケーター &lt;code&gt;!&lt;/code&gt; ）が導入されています。</target>
        </trans-unit>
        <trans-unit id="7c357fe7705c3417a859eaeabc538a7cb2284380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is the &lt;em&gt;any&lt;/em&gt; previous sibling selector (opposite of &lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 以前の兄弟セレクター（ &lt;code&gt;~&lt;/code&gt; 反対）</target>
        </trans-unit>
        <trans-unit id="ed595455871545edca70be20be7efc07d20cc069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; is for the next sibling. Is there an equivalent for the previous
  sibling?</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; は次の兄弟用です。 前の兄弟に相当するものはありますか？</target>
        </trans-unit>
        <trans-unit id="2f01423323702105439497e1c1b1f5d8a4578966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; is the &lt;em&gt;immediate&lt;/em&gt; subsequent sibling selector</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; は&lt;em&gt;直後&lt;/em&gt;の兄弟セレクター</target>
        </trans-unit>
        <trans-unit id="94c29eabcf56b07996e3c04cee5016c0b6b57491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.any-previous:hover ! div&lt;/code&gt; selects any previous &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.any-previous:hover ! div&lt;/code&gt; divは前のdivを選択します</target>
        </trans-unit>
        <trans-unit id="c8e28436ba5f1efcd8efa165ba47d3e251d9ba3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.any-subsequent:hover ~ div&lt;/code&gt; selects any subsequent &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.any-subsequent:hover ~ div&lt;/code&gt; を選択します</target>
        </trans-unit>
        <trans-unit id="e22f1f4ce5332c6c4d74834c3f051b795a416ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.immediate-previous:hover ? div&lt;/code&gt; selects the immediate previous &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.immediate-previous:hover ? div&lt;/code&gt; divは直前のdivを選択します</target>
        </trans-unit>
        <trans-unit id="dcc37d93e8f59249a257da2bc655302e547e6940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.immediate-subsequent:hover + div&lt;/code&gt; selects the immediate subsequent &lt;code&gt;div&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.immediate-subsequent:hover + div&lt;/code&gt; は直後のdivを選択します</target>
        </trans-unit>
        <trans-unit id="3b0910f8c897e49b7c54ad2f06472848fb9d8227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; is the &lt;em&gt;immediate&lt;/em&gt; previous sibling selector (opposite of &lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; &lt;em&gt;直前の&lt;/em&gt;兄弟セレクター（ &lt;code&gt;+&lt;/code&gt; の反対）</target>
        </trans-unit>
        <trans-unit id="0dee39345cc6ee1279934352bcdade2c20b08a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float-right&lt;/code&gt;&lt;em&gt;+&lt;/em&gt; inverse the order of HTML elements</source>
          <target state="translated">&lt;code&gt;float-right&lt;/code&gt; &lt;em&gt;+&lt;/em&gt; HTML要素の順序を逆にする</target>
        </trans-unit>
        <trans-unit id="a1da221ab5c3c8b901ce1eb61884ddc4fe922545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; is the &lt;em&gt;any&lt;/em&gt; subsequent sibling selector</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; は後続の兄弟セレクターです</target>
        </trans-unit>
        <trans-unit id="768eb8921a37f993d92f5a0ef2bfd879be384f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;&lt;em&gt;Next siblings&lt;/em&gt; operator:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; &lt;em&gt;次の兄弟&lt;/em&gt;演算子：</target>
        </trans-unit>
        <trans-unit id="b45ad163a8651c34a0d16d8e3b362d9b76693378" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;sub&gt;(emphasis added)&lt;/sub&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;sub&gt;（強調を追加）&lt;/sub&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="665e55d598d2c11ce4bb90a276830bf6f0fde666" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'll focus on flexbox in the examples below, but the same concepts apply to Grid.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;以下の例ではflexboxに焦点を当てますが、同じ概念がグリッドにも適用されます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52a133130a0d198eae4a4b7c47737e1a8e62f4d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3. Flex Item Z-Ordering&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3。&lt;/strong&gt; &lt;strong&gt;フレックスアイテムのZオーダー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32158f358671818399bba29dbf2c3ba4ab6fc268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.4. Display Order: the &lt;code&gt;order&lt;/code&gt; property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.4。&lt;/strong&gt; &lt;strong&gt;表示順序： &lt;code&gt;order&lt;/code&gt; プロパティ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6853f54f67919916de40ab32c854f669cb4c3c30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.4. Z-axis Ordering: the &lt;code&gt;z-index&lt;/code&gt; property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.4。&lt;/strong&gt; &lt;strong&gt;Z軸の順序： &lt;code&gt;z-index&lt;/code&gt; プロパティ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83b05dfec3718db0552391149c0e3d7bda0c2c75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;9.9.1 Specifying the stack level: the &lt;code&gt;z-index&lt;/code&gt;
  property&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;9.9.1スタックレベルの指定： &lt;code&gt;z-index&lt;/code&gt; プロパティ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b5bfef254b9205245032da598adfe5fc3f90e42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01195ef0b572066871d7b5aad840247fb5f2ad5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;...and voil&amp;agrave;! A previous sibling selector is born (or at least simulated).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;...そしてほら！&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;以前の兄弟セレクターが生まれました（または少なくともシミュレーションされます）。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a2de40614250939e1ac2028b79c2f603e140dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Applies to:      positioned elements&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;適用対象：配置された要素&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="106af0ab2a1746027aea14ca5280bdf5ceef5300" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;The &lt;code&gt;z-index&lt;/code&gt; Myth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;z-index&lt;/code&gt; 神話&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54a6fe3317e75fae016e1ae7d0ef63443ca1c7a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of &quot;previous sibling selectors&quot; created with the flex &lt;code&gt;order&lt;/code&gt; property.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flex &lt;code&gt;order&lt;/code&gt; プロパティで作成された「以前の兄弟セレクター」の例。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5d9c630b449804340bc41d05ef058ebd4817f77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With flexbox, a previous sibling selector can be simulated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;フレックスボックスを使用すると、以前の兄弟セレクターをシミュレートできます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d1b833d633fafc0324f01aebae36d3b39fe40f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Working Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9446e60594ae9c87ddb1b319e8f4165d0296891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery Reference Docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQueryリファレンスドキュメント：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37825b906e4a796703b6c32120b0fdcf3c0e47fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jsFiddle&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jsFiddle&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8920f7186483b1f6b58964d259171e0a79ef8336" translate="yes" xml:space="preserve">
          <source>A Side Note &amp;ndash; Two Outdated Beliefs about CSS</source>
          <target state="translated">サイドノート&amp;ndash; CSSに関する2つの時代遅れの信念</target>
        </trans-unit>
        <trans-unit id="3e2877a374953df7fad662b9e45ca3eb44a50e16" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://www.w3.org/TR/css3-grid-layout/#order-property&quot;&gt;&lt;code&gt;order&lt;/code&gt; in the CSS Grid Layout spec&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/css3-grid-layout/#order-property&quot;&gt;CSSグリッドレイアウト仕様の &lt;code&gt;order&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="1a6ee2a76673c38a3c832b48af895c00c9068dbb" translate="yes" xml:space="preserve">
          <source>And the cascade goes only 1 direction: down.</source>
          <target state="translated">そして、カスケードは1つの方向にしか行きません。</target>
        </trans-unit>
        <trans-unit id="82fa4888cf695ea35fd3afd3a8aa1b9b775054ed" translate="yes" xml:space="preserve">
          <source>And, again, I was unable to add &lt;code&gt;.companies&lt;/code&gt; any higher up in the HTML.  That part of the HTML was written externally, and wrapped our code.</source>
          <target state="translated">また、HTMLの上位に &lt;code&gt;.companies&lt;/code&gt; を追加できませんでした。 HTMLのその部分は外部で記述され、コードをラップしました。</target>
        </trans-unit>
        <trans-unit id="0ddfcaa1ef0aa8a7c6b06221a8232b25f9c2ae0c" translate="yes" xml:space="preserve">
          <source>Another flexbox solution</source>
          <target state="translated">別のフレックスボックスソリューション</target>
        </trans-unit>
        <trans-unit id="48b3c005d9f4850b15a789fb78db521746377c4f" translate="yes" xml:space="preserve">
          <source>Another long-standing belief has been that &lt;code&gt;z-index&lt;/code&gt; works only on positioned elements.</source>
          <target state="translated">もう1つの長年の信念は、 &lt;code&gt;z-index&lt;/code&gt; が配置された要素でのみ機能するというものです。</target>
        </trans-unit>
        <trans-unit id="1cf713b92555463ebe5217207e6aafa0eb082552" translate="yes" xml:space="preserve">
          <source>As described above, this belief is not entirely true. A previous sibling selector can be simulated in CSS using the flex &lt;code&gt;order&lt;/code&gt; property.</source>
          <target state="translated">上記のように、この信念は完全に真実ではありません。 以前の兄弟セレクターは、CSSでflex &lt;code&gt;order&lt;/code&gt; プロパティを使用してシミュレートできます。</target>
        </trans-unit>
        <trans-unit id="229f35a08548eaf6783204176f701b3d33a4f629" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/14469950/5411817&quot;&gt;this answer by Mike Brant&lt;/a&gt;,
the following jQuery snippet could help.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14469950/5411817&quot;&gt;Mike Brantによるこの回答に&lt;/a&gt;基づいて、以下のjQueryスニペットが役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="3ed4d744f4bf8170a78c74aa2fd88d744fdae3bb" translate="yes" xml:space="preserve">
          <source>But I could &lt;em&gt;not&lt;/em&gt; select only &lt;code&gt;#full-width&lt;/code&gt;s that &lt;em&gt;proceeded&lt;/em&gt;&lt;code&gt;.companies&lt;/code&gt;.</source>
          <target state="translated">しかし、 &lt;code&gt;.companies&lt;/code&gt; に &lt;em&gt;進む&lt;/em&gt; &lt;code&gt;#full-width&lt;/code&gt; のみを選択すること&lt;em&gt;は&lt;/em&gt;でき&lt;em&gt;ません&lt;/em&gt; でした 。</target>
        </trans-unit>
        <trans-unit id="90417dea6720e12f30caa00950383afb1b63b2ab" translate="yes" xml:space="preserve">
          <source>But with jQuery, I &lt;em&gt;can&lt;/em&gt; select the required &lt;code&gt;#full-width&lt;/code&gt;s, then assign the appropriate style:</source>
          <target state="translated">しかしjQueryでは、必要な &lt;code&gt;#full-width&lt;/code&gt; を選択してから、適切なスタイルを割り当てる&lt;em&gt;ことができ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="45eedda9c8d9f5b1c7f441ae4f3042455cca6f6b" translate="yes" xml:space="preserve">
          <source>CSS Selector for selecting an element that comes BEFORE another element?</source>
          <target state="translated">別の要素の前に来る要素を選択するためのCSSセレクタ?</target>
        </trans-unit>
        <trans-unit id="c18f2079c9555b512b0d479beb14f33298d17728" translate="yes" xml:space="preserve">
          <source>CSS select previous sibling</source>
          <target state="translated">CSS は前の兄弟を選択します。</target>
        </trans-unit>
        <trans-unit id="c5b96b2421df977be54b8afa143635de349ecc67" translate="yes" xml:space="preserve">
          <source>CSS selector for next and previous elements</source>
          <target state="translated">次の要素と前の要素のための CSS セレクタ</target>
        </trans-unit>
        <trans-unit id="39aa2b07f090994b1230fd897c096b82e0b8f70d" translate="yes" xml:space="preserve">
          <source>CSS selector to get preceding sibling</source>
          <target state="translated">前の兄弟を取得するためのCSSセレクタ</target>
        </trans-unit>
        <trans-unit id="2a9aeb746a06e0844284ee2d4008adbf2fd73b36" translate="yes" xml:space="preserve">
          <source>CSS:</source>
          <target state="translated">CSS:</target>
        </trans-unit>
        <trans-unit id="6173ca19b1a4be22f0ba5a87c6612fc158b212fd" translate="yes" xml:space="preserve">
          <source>CSS: select previous sibling</source>
          <target state="translated">CSS:前の兄弟を選択</target>
        </trans-unit>
        <trans-unit id="fadb864e568c5d11ae0d18b81383e48b964113f2" translate="yes" xml:space="preserve">
          <source>Change color of sibling elements on hover using CSS</source>
          <target state="translated">CSS を使用してホバー時の兄弟要素の色を変更する</target>
        </trans-unit>
        <trans-unit id="94a5ad82bf1f904bbeafcb20ec770fd553af2dda" translate="yes" xml:space="preserve">
          <source>Computed value:     as specified</source>
          <target state="translated">計算値:指定された通り</target>
        </trans-unit>
        <trans-unit id="9806c929f4fbf2b2374b544d0132be7fc35b2911" translate="yes" xml:space="preserve">
          <source>Consider the &lt;code&gt;order&lt;/code&gt; property of flex and grid layouts.</source>
          <target state="translated">フレックスレイアウトとグリッドレイアウトの &lt;code&gt;order&lt;/code&gt; プロパティを検討します。</target>
        </trans-unit>
        <trans-unit id="40d5acc4ac4669c9e11b503fb48cf1ec26dce199" translate="yes" xml:space="preserve">
          <source>Depending on your exact objective, there is a way to achieve the usefulness of a parent selector without using one (even if one were to exist)...</source>
          <target state="translated">あなたの正確な目的に応じて、親セレクタを使わずに(存在していたとしても)親セレクタの有用性を実現する方法があります...</target>
        </trans-unit>
        <trans-unit id="2e976a9b0921bc45e45f2900c57e6179424e3373" translate="yes" xml:space="preserve">
          <source>Effectively, &quot;previous sibling&quot; has been selected via jQuery.</source>
          <target state="translated">実質的には「前の兄弟」がjQuery経由で選択されています。</target>
        </trans-unit>
        <trans-unit id="02caa7b6173db637f5c2e48b1d62c59d7e3222d3" translate="yes" xml:space="preserve">
          <source>Elements that are &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#painting&quot;&gt;&lt;strong&gt;&lt;em&gt;flex items&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://drafts.csswg.org/css-grid/#z-order&quot;&gt;&lt;strong&gt;&lt;em&gt;grid items&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; can create stacking contexts even when &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#painting&quot;&gt;&lt;strong&gt;&lt;em&gt;フレックスアイテム&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;または&lt;a href=&quot;https://drafts.csswg.org/css-grid/#z-order&quot;&gt;&lt;strong&gt;&lt;em&gt;グリッドアイテムである&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;要素は、 &lt;code&gt;position&lt;/code&gt; が &lt;code&gt;static&lt;/code&gt; 場合でもスタックコンテキストを作成できます。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="912849c376dc7a8f86c6418763561e232f09e8df" translate="yes" xml:space="preserve">
          <source>Finally, it assigns a new CSS (&lt;code&gt;width&lt;/code&gt;) value to the resulting element.</source>
          <target state="translated">最後に、結果の要素に新しいCSS（ &lt;code&gt;width&lt;/code&gt; ）値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="051a837d3891413abfe10ed1070fe8215902c21e" translate="yes" xml:space="preserve">
          <source>Flex items are, by default, displayed and laid out in the same order as they appear in the source document. The 
  &lt;code&gt;order&lt;/code&gt; property can be used to change this ordering.</source>
          <target state="translated">Flexアイテムは、デフォルトでは、ソースドキュメントに表示されるのと同じ順序で表示およびレイアウトされます。 &lt;code&gt;order&lt;/code&gt; プロパティを使用して、この順序を変更できます。</target>
        </trans-unit>
        <trans-unit id="fb22e87d22421d730f517d61fc95824612e817ff" translate="yes" xml:space="preserve">
          <source>Flex items paint exactly the same as inline blocks, except that order-modified document order is used in place of raw 
  document order, and &lt;code&gt;z-index&lt;/code&gt; values other than &lt;code&gt;auto&lt;/code&gt; create a stacking context even if &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Flexアイテムは、インラインブロックとまったく同じように描画されますが、生のドキュメントの順序の代わりに順序変更されたドキュメントの順序が使用され、 &lt;code&gt;position&lt;/code&gt; が &lt;code&gt;static&lt;/code&gt; であっても、 &lt;code&gt;auto&lt;/code&gt; 以外の &lt;code&gt;z-index&lt;/code&gt; 値によってスタッキングコンテキストが作成されます 。</target>
        </trans-unit>
        <trans-unit id="b71f41ee4b8948e2ef97dc6eaec690a10c7079de" translate="yes" xml:space="preserve">
          <source>Flexbox is shattering long-held beliefs about CSS.</source>
          <target state="translated">Flexbox は CSS に関する長年の思い込みを打ち砕いています。</target>
        </trans-unit>
        <trans-unit id="959c2ad7e3f03ec94a998bb6e74820a21dce5afc" translate="yes" xml:space="preserve">
          <source>From the flexbox spec:</source>
          <target state="translated">フレックスボックスの仕様から</target>
        </trans-unit>
        <trans-unit id="281ae36016b5df798237abd85199faff72bacd6c" translate="yes" xml:space="preserve">
          <source>HTML:
    
        
             
             
             
             
             
        
        (40)</source>
          <target state="translated">HTMLです。(40)</target>
        </trans-unit>
        <trans-unit id="4068e6a84eaf79e682a75e47116c93a658eb970d" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of &lt;code&gt;z-index&lt;/code&gt; working on non-positioned flex items: &lt;a href=&quot;https://jsfiddle.net/m0wddwxs/&quot;&gt;https://jsfiddle.net/m0wddwxs/&lt;/a&gt;</source>
          <target state="translated">次に、配置されていないflexアイテムで動作する &lt;code&gt;z-index&lt;/code&gt; のデモを示し&lt;a href=&quot;https://jsfiddle.net/m0wddwxs/&quot;&gt;ます。https&lt;/a&gt; ： //jsfiddle.net/m0wddwxs/</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">一例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="4ede26c3272eca67058c5c4a741b5f5420eec6dd" translate="yes" xml:space="preserve">
          <source>Here's the full code:</source>
          <target state="translated">ここにフルコードがあります。</target>
        </trans-unit>
        <trans-unit id="91833c79413fd07372f4a33eb8350490dbb11ae4" translate="yes" xml:space="preserve">
          <source>Hope it helps someone.</source>
          <target state="translated">誰かのお役に立てれば幸いです。</target>
        </trans-unit>
        <trans-unit id="00f8058d0dcf0e7a2d3b1ed93e6c2dc0869b7d2a" translate="yes" xml:space="preserve">
          <source>How to add styling to active input's previous sibling using CSS only</source>
          <target state="translated">CSSのみでアクティブ入力の前の兄弟にスタイリングを追加する方法</target>
        </trans-unit>
        <trans-unit id="7aaf9dfcdb948d52cf26522a6afb4dbc69de2344" translate="yes" xml:space="preserve">
          <source>How to affect other elements when a div is hovered</source>
          <target state="translated">div がホバーされたときに他の要素に影響を与える方法</target>
        </trans-unit>
        <trans-unit id="0d8f70e7ad320c862ea828321d87c91c61ed07bc" translate="yes" xml:space="preserve">
          <source>How to select the previous sibling using selenium css syntax</source>
          <target state="translated">selenium cssの構文を使用して前の兄弟を選択する方法</target>
        </trans-unit>
        <trans-unit id="edde16975af4c3f91926ae4ab528a19e13d1638b" translate="yes" xml:space="preserve">
          <source>However, if you are able to add &lt;strong&gt;JavaScript&lt;/strong&gt; to your page, a little bit of &lt;strong&gt;jQuery&lt;/strong&gt; could get you to your end goal.</source>
          <target state="translated">ただし、ページに&lt;strong&gt;JavaScript&lt;/strong&gt;を追加できる場合は、少しの&lt;strong&gt;jQueryで&lt;/strong&gt;最終目標を達成できます。</target>
        </trans-unit>
        <trans-unit id="1acf1134953119f55a775a44bb0634b7ef15a1f0" translate="yes" xml:space="preserve">
          <source>However, in the &lt;strong&gt;axe&lt;/strong&gt; CSS post-processor library, there are &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; previous sibling selectors&lt;/em&gt;:</source>
          <target state="translated">ただし、 &lt;strong&gt;ax&lt;/strong&gt; CSSポストプロセッサライブラリには、 &lt;em&gt;以前の&lt;/em&gt; &lt;strong&gt;&lt;em&gt;2つの&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;兄弟セレクタがあり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="86caa6bdc362ff8eaa7d03615f8d8811870000f5" translate="yes" xml:space="preserve">
          <source>I found a way to style all previous siblings (opposite of &lt;code&gt;~&lt;/code&gt;) that may work depending on what you need.</source>
          <target state="translated">以前のすべての兄弟（ &lt;code&gt;~&lt;/code&gt; 反対）をスタイルする方法を見つけました。</target>
        </trans-unit>
        <trans-unit id="6bd7bc412ee50b933334dc0e025771a9a14db374" translate="yes" xml:space="preserve">
          <source>I had a similar problem and found out that all problem of this nature can be solved as follows:</source>
          <target state="translated">私も同じような問題を抱えていたのですが、このような性質の問題はすべて以下のように解決できることがわかりました。</target>
        </trans-unit>
        <trans-unit id="eab5cd63e9e3e19eaf186d4e85865aaff9d7de65" translate="yes" xml:space="preserve">
          <source>I had control of all the HTML under &lt;code&gt;.companies&lt;/code&gt;, but could not alter any of the HTML above it.</source>
          <target state="translated">私は &lt;code&gt;.companies&lt;/code&gt; の下のすべてのHTMLを制御できましたが、その上のHTMLを変更することはできませんでした。</target>
        </trans-unit>
        <trans-unit id="090d3b447a141fd56eaee940ec7c0b3c9181252e" translate="yes" xml:space="preserve">
          <source>I had the same question, but then I had a &quot;duh&quot; moment.   Instead of writing</source>
          <target state="translated">私も同じ質問をしたのですが、その時に「えっ」と思った瞬間がありました。を書くのではなく</target>
        </trans-unit>
        <trans-unit id="dcdbf832ffc8960412f46127139613b7788265e1" translate="yes" xml:space="preserve">
          <source>I needed a solution to select the previous sibling tr. I came up with this solution using React and Styled-components. This is not my exact solution (This is from memory, hours later). I know there is a flaw in the setHighlighterRow function.</source>
          <target state="translated">私は前の兄弟のtrを選択するソリューションが必要でした。私はReactとStyled-componentsを使ってこのソリューションを思いつきました。これは私の正確なソリューションではありません(これは数時間後の記憶からです)。私はsetHighlighterRow関数に欠陥があることを知っています。</target>
        </trans-unit>
        <trans-unit id="ef5fd2bd284dea941940014eb44dd99e73a46d05" translate="yes" xml:space="preserve">
          <source>I realize that the original question was a CSS question so this answer is probably completely irrelevant, but other Javascript users may stumble on the question via search like I did.</source>
          <target state="translated">元の質問はCSSの質問だったので、この回答はおそらく全く関係ないと思いますが、他のJavascriptユーザーは私がしたように検索でつまずくかもしれません。</target>
        </trans-unit>
        <trans-unit id="13fe1d484840b69d747494ca988cef005264e7cc" translate="yes" xml:space="preserve">
          <source>I'm using FontAwesome in this example and swapping between the unicodes of fa-star-o and fa-star
&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;http://fortawesome.github.io/Font-Awesome/&lt;/a&gt;</source>
          <target state="translated">この例では、FontAwesomeを使用しており、fa-star-oとfa-starのユニコードを交換しています&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;http://fortawesome.github.io/Font-Awesome/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e718f5646afda421ef33270aaf412d5fe58f945f" translate="yes" xml:space="preserve">
          <source>If you know the exact position an &lt;code&gt;:nth-child()&lt;/code&gt;-based exclusion of all following siblings would work.</source>
          <target state="translated">正確な位置がわかっている場合は、後続のすべての兄弟の &lt;code&gt;:nth-child()&lt;/code&gt; ベースの除外が機能します。</target>
        </trans-unit>
        <trans-unit id="79c501d695c28ba90a85b59b704d657bef33509c" translate="yes" xml:space="preserve">
          <source>In conventional CSS, there is &lt;strong&gt;no previous sibling selector&lt;/strong&gt;.</source>
          <target state="translated">従来のCSSでは、 &lt;strong&gt;以前の兄弟セレクター&lt;/strong&gt;はあり&lt;strong&gt;ません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="51c49ae56e89555fda5525ce78e016d4a9960577" translate="yes" xml:space="preserve">
          <source>In fact, the most current version of the spec &amp;ndash; the &lt;a href=&quot;https://drafts.csswg.org/css2/visuren.html#propdef-z-index&quot;&gt;W3C Editor's Draft&lt;/a&gt; &amp;ndash; still asserts this to be true:</source>
          <target state="translated">実際、最新バージョンの仕様（ &lt;a href=&quot;https://drafts.csswg.org/css2/visuren.html#propdef-z-index&quot;&gt;W3C Editor's Draft）&lt;/a&gt;では、これが真実であると主張しています。</target>
        </trans-unit>
        <trans-unit id="c1614e8db35c84f7389f93ed6ae211115f938273" translate="yes" xml:space="preserve">
          <source>In my case I was looking to find a way to select a DIV with the id &lt;code&gt;#full-width&lt;/code&gt;, but ONLY if it had a (indirect) descendant DIV with the class of &lt;code&gt;.companies&lt;/code&gt;.</source>
          <target state="translated">私の場合、idが &lt;code&gt;#full-width&lt;/code&gt; の DIVを選択する方法を探していましたが、 &lt;code&gt;.companies&lt;/code&gt; のクラスを持つ（間接的な）子孫DIVがある場合のみです。</target>
        </trans-unit>
        <trans-unit id="2fe2536c1eacf4a1a05311c9729aa249a76be838" translate="yes" xml:space="preserve">
          <source>In my case, I wanted a primarily CSS 5-star rating system. I would need to color (or swap the icon of) the previous stars. By floating each element right, I am essentially getting the same effect (the html for the stars thus must be written 'backwards').</source>
          <target state="translated">私の場合、私は主にCSSの5つ星評価システムが欲しかった。前の星の色を変える(またはアイコンを入れ替える)必要があります。各要素を右にフローティングすることで、基本的に同じ効果を得ることができます(星のhtmlは「逆」に書かなければなりません)。</target>
        </trans-unit>
        <trans-unit id="248d5f16812a94c0896fd71081300c46b317e6b7" translate="yes" xml:space="preserve">
          <source>In particular, the flex &lt;code&gt;order&lt;/code&gt; property can move elements around the screen.</source>
          <target state="translated">特に、フレックス &lt;code&gt;order&lt;/code&gt; プロパティは、要素を画面内で移動できます。</target>
        </trans-unit>
        <trans-unit id="a8efd7365dcd78f460f2e36c60a2e4b618e07fb8" translate="yes" xml:space="preserve">
          <source>In reality, however, this information is obsolete and inaccurate.</source>
          <target state="translated">しかし、実際には、この情報は陳腐で不正確です。</target>
        </trans-unit>
        <trans-unit id="2fd90fb4157d1e9c3cb82e78b72caf02e01264c9" translate="yes" xml:space="preserve">
          <source>In the example below:</source>
          <target state="translated">下の例では</target>
        </trans-unit>
        <trans-unit id="5c3dfe0de7d1bc518306aa10258d1c13f54861f3" translate="yes" xml:space="preserve">
          <source>Inherited:      no</source>
          <target state="translated">継承:なし</target>
        </trans-unit>
        <trans-unit id="3000181e0628e7643bd8adee4c6849bd29ea5b9b" translate="yes" xml:space="preserve">
          <source>Initial:    auto</source>
          <target state="translated">イニシャル:オート</target>
        </trans-unit>
        <trans-unit id="48aae125c6273372fc204836e6350a2e37f3be5c" translate="yes" xml:space="preserve">
          <source>Is there a “previous sibling” selector</source>
          <target state="translated">前の兄弟」セレクターはありますか?</target>
        </trans-unit>
        <trans-unit id="9be9d437f0dfb6899a9700afc7c6af5f0d9ebc59" translate="yes" xml:space="preserve">
          <source>Is there an equivalent for the previous sibling?</source>
          <target state="translated">前の兄弟に相当するものはありますか?</target>
        </trans-unit>
        <trans-unit id="68b4de53a6017d1e28b25a9e348ee280f2caa4ae" translate="yes" xml:space="preserve">
          <source>JSFiddle: &lt;a href=&quot;http://jsfiddle.net/andrewleyva/88j0105g/&quot;&gt;http://jsfiddle.net/andrewleyva/88j0105g/&lt;/a&gt;</source>
          <target state="translated">JSFiddle： &lt;a href=&quot;http://jsfiddle.net/andrewleyva/88j0105g/&quot;&gt;http&lt;/a&gt; ://jsfiddle.net/andrewleyva/88j0105g/</target>
        </trans-unit>
        <trans-unit id="02c3528b037f688712d83f406ccbb1cfec5c20c2" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of links and when hovering on one, all the previous ones should turn red. You can do it like this:</source>
          <target state="translated">リンクのリストを持っていて、その上にカーソルを置くと、前のリンクがすべて赤くなります。このようにすることができます。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="9437ceed3329cdf77b8d382349418ba82d6804b0" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;ul&lt;/code&gt; a flex container.</source>
          <target state="translated">&lt;code&gt;ul&lt;/code&gt; をflexコンテナにします。</target>
        </trans-unit>
        <trans-unit id="b889c73d1be01b47f80ae16c97e8e4ca2fb402b9" translate="yes" xml:space="preserve">
          <source>Media:      visual</source>
          <target state="translated">メディア:ビジュアル</target>
        </trans-unit>
        <trans-unit id="3bc97b7eba79269b952d0d89cd932fa205b3222e" translate="yes" xml:space="preserve">
          <source>No, there is no &quot;previous sibling&quot; selector.</source>
          <target state="translated">いや、「前の兄弟」のセレクターはありません。</target>
        </trans-unit>
        <trans-unit id="06523e089f48369a43a839a5578b36a3dff2c2ba" translate="yes" xml:space="preserve">
          <source>No. It is not possible via CSS. It takes the &quot;Cascade&quot; to heart ;-).</source>
          <target state="translated">いや、CSS経由では無理です。カスケード」を心得ています。)</target>
        </trans-unit>
        <trans-unit id="8c00c220dbd31f27615214a55bdebafb9b9301d2" translate="yes" xml:space="preserve">
          <source>Now, use the &lt;code&gt;.css&lt;/code&gt; function to pass in your CSS new values for that element.</source>
          <target state="translated">次に、 &lt;code&gt;.css&lt;/code&gt; 関数を使用して、その要素のCSS新しい値を渡します。</target>
        </trans-unit>
        <trans-unit id="648457847b306355248f81e8054a176758693c6b" translate="yes" xml:space="preserve">
          <source>Obviously this matches &quot;x&quot; instead of &quot;y&quot;, but it answers the &quot;is there a match?&quot; question, and simple DOM traversal may get you to the right element more efficiently than looping in javascript.</source>
          <target state="translated">これは明らかに &quot;y&quot; ではなく &quot;x&quot; にマッチしますが、&quot;マッチはあるのか?&quot; という質問に答えてくれますし、シンプルな DOM トラバーサルは javascript でループするよりも効率的に正しい要素にたどり着けるかもしれません。</target>
        </trans-unit>
        <trans-unit id="15de0eca38d6ad16eebdf50299f9363d30dc7a2d" translate="yes" xml:space="preserve">
          <source>On a related note, &lt;code&gt;~&lt;/code&gt; is for general successor sibling (meaning the element comes after this one, but not necessarily immediately after) and is a CSS3 selector. &lt;code&gt;+&lt;/code&gt; is for next sibling and is CSS2.1.</source>
          <target state="translated">関連する注記では、 &lt;code&gt;~&lt;/code&gt; は一般的な後続の兄弟（要素がこの要素の後に来るが、必ずしも直後ではない）を表し、CSS3セレクターです。 &lt;code&gt;+&lt;/code&gt; は次の兄弟用で、CSS2.1です。</target>
        </trans-unit>
        <trans-unit id="a75a09fb96d32623c76fedce272a3f203462aaec" translate="yes" xml:space="preserve">
          <source>OnMouseOver a row will set the row index to state, and rerender the previous row with a new background color</source>
          <target state="translated">OnMouseOver 行をマウスオーバーすると、行のインデックスが状態に設定され、前の行が新しい背景色で再描画されます。</target>
        </trans-unit>
        <trans-unit id="68a7635b24a97f76bb9ebc1cbe012194bf82823d" translate="yes" xml:space="preserve">
          <source>One such belief is that &lt;a href=&quot;https://stackoverflow.com/a/10006328/3597276&quot;&gt;&lt;strong&gt;a previous sibling selector is not possible in CSS&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">そのような信念の1つは&lt;a href=&quot;https://stackoverflow.com/a/10006328/3597276&quot;&gt;&lt;strong&gt;、以前の兄弟セレクターはCSSでは不可能であるというもの&lt;/strong&gt;&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ea475966115fbffc1211959ca65e05ecdb8f7fa7" translate="yes" xml:space="preserve">
          <source>Or I could select &lt;code&gt;.companies&lt;/code&gt; that only followed a &lt;code&gt;#full-width&lt;/code&gt;.</source>
          <target state="translated">または、 &lt;code&gt;#full-width&lt;/code&gt; のみに続いている &lt;code&gt;.companies&lt;/code&gt; を選択することもできます。</target>
        </trans-unit>
        <trans-unit id="8a8ac81b3400af06c7cc81e6077f2d0fc74b0486" translate="yes" xml:space="preserve">
          <source>Parent with &lt;code&gt;direction: rtl;&lt;/code&gt; + inverse the order of inner elements</source>
          <target state="translated">&lt;code&gt;direction: rtl;&lt;/code&gt; 持つ親：rtl; +内部要素の順序を逆にする</target>
        </trans-unit>
        <trans-unit id="e20b56b4243462d32777361ea6e24f9a73aaf5f4" translate="yes" xml:space="preserve">
          <source>Percentages:    N/A</source>
          <target state="translated">割合。NA</target>
        </trans-unit>
        <trans-unit id="4ddf62b2329b83ab800d77bbeccd01a350dd2c7f" translate="yes" xml:space="preserve">
          <source>Previous adjacent selector in CSS</source>
          <target state="translated">CSSの前の隣接セレクタ</target>
        </trans-unit>
        <trans-unit id="1f32fd13429c7ba13ea2351ea2bb3a24954b169f" translate="yes" xml:space="preserve">
          <source>Reverse the order of siblings in the mark-up.</source>
          <target state="translated">マークアップの兄弟の順番を逆にする。</target>
        </trans-unit>
        <trans-unit id="8f7e94d1cf379df4a82d4c27c7dac3111a469db4" translate="yes" xml:space="preserve">
          <source>STEPS</source>
          <target state="translated">STEPS</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">あると言ってくれ</target>
        </trans-unit>
        <trans-unit id="f82c3fbbc6d8a3c6cd5e5d1cf2400a349b7b74f7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#adjacent-sibling-combinators&quot;&gt;Adjacent sibling combinator&lt;/a&gt; from &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/&quot;&gt;Selectors Level 3&lt;/a&gt; and &lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors&quot;&gt;5.7 Adjacent sibling selectors&lt;/a&gt; from &lt;a href=&quot;http://www.w3.org/TR/CSS21/cover.html#minitoc&quot;&gt;Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/css3-selectors/&quot;&gt;セレクターレベル3の&lt;/a&gt; &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#adjacent-sibling-combinators&quot;&gt;隣接兄弟コンビ&lt;/a&gt; ネーターおよび&lt;a href=&quot;http://www.w3.org/TR/CSS21/cover.html#minitoc&quot;&gt;カスケードスタイルシートレベル2リビジョン1（CSS 2.1）仕様の&lt;/a&gt; &lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors&quot;&gt;隣接兄弟セレクター5.7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4b32df97065887792fc54ce0bd0085574a236ced" translate="yes" xml:space="preserve">
          <source>Select previous siblings on hover</source>
          <target state="translated">ホバーで前の兄弟を選択</target>
        </trans-unit>
        <trans-unit id="b8802af3c25aab2b10973154bd80f5d4a28fbeb3" translate="yes" xml:space="preserve">
          <source>Select the preceding sibling of an element in CSS using selectors</source>
          <target state="translated">CSS の要素の前の兄弟をセレクタを使って選択します。</target>
        </trans-unit>
        <trans-unit id="3f69e926c961d47d6b8bf4edd9ada01387a1af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; property controls the order in which flex items appear within the flex container, by assigning them to ordinal groups. It takes a single &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; value, which specifies which ordinal group the flex item 
  belongs to.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; プロパティは、フレックスコンテナー内に表示されるフレックスアイテムの順序を、それらを序数グループに割り当てることによって制御します。 単一の &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; 値を使用して、フレックスアイテムが属する序数グループを指定します。</target>
        </trans-unit>
        <trans-unit id="bee636d2e47bd8d9ebd01557931b7587b00a7e8a" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;order&lt;/code&gt; value for all flex items is 0.</source>
          <target state="translated">すべてのフレックスアイテムの初期 &lt;code&gt;order&lt;/code&gt; 値は0です。</target>
        </trans-unit>
        <trans-unit id="1f84bcdbeb978aab5a1803803dd526d2abe73d82" translate="yes" xml:space="preserve">
          <source>The painting order of grid items is exactly the same as inline blocks, except that order-modified document order is 
  used in place of raw document order, and &lt;code&gt;z-index&lt;/code&gt; values other than &lt;code&gt;auto&lt;/code&gt; create a stacking context even if 
  &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">グリッドアイテムの描画順序はインラインブロックとまったく同じですが、生のドキュメントの順序の代わりに順序が変更されたドキュメントの順序が使用され、 &lt;code&gt;position&lt;/code&gt; が &lt;code&gt;static&lt;/code&gt; の場合でも &lt;code&gt;auto&lt;/code&gt; 以外の &lt;code&gt;z-index&lt;/code&gt; 値によってスタックコンテキストが作成されます 。</target>
        </trans-unit>
        <trans-unit id="427e7f7201e462d2988b2f979cbd84408150c14d" translate="yes" xml:space="preserve">
          <source>The plus sign (&lt;code&gt;+&lt;/code&gt;) is for the next sibling.</source>
          <target state="translated">正符号（ &lt;code&gt;+&lt;/code&gt; ）は次の兄弟を表します。</target>
        </trans-unit>
        <trans-unit id="a504da474de17cf78a56f80874e1f7160a2eff59" translate="yes" xml:space="preserve">
          <source>Then it &quot;backtracks&quot; to select all the previous &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;s from that set of &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;s.</source>
          <target state="translated">次に、「バックトラック」して、その &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; のセットから以前のすべての &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="998b5fdf1840ef4280f75ef69d0cab0498e6fb8a" translate="yes" xml:space="preserve">
          <source>Then it uses &lt;code&gt;.parents&lt;/code&gt; to &quot;backtrack&quot; and select ALL parents of &lt;code&gt;.companies&lt;/code&gt;,</source>
          <target state="translated">次に、 &lt;code&gt;.parents&lt;/code&gt; を使用して「バックトラック」し、 &lt;code&gt;.companies&lt;/code&gt; のすべての親を選択します。</target>
        </trans-unit>
        <trans-unit id="f86be13dd4259c6e46b8a5e0c9eec5da827d2688" translate="yes" xml:space="preserve">
          <source>Then you use jQuery to re-write the DOM (CSS) for your element.</source>
          <target state="translated">そして、jQueryを使って要素のDOM(CSS)を書き直します。</target>
        </trans-unit>
        <trans-unit id="9f5ec78f818e941a2192daf69266fbc4682f676e" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; subsequent sibling selectors&lt;/em&gt; in conventional CSS:</source>
          <target state="translated">従来のCSSには、 &lt;strong&gt;&lt;em&gt;2つの&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;後続の兄弟セレクター&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="481d7edcc0194f06e2e87c4622cd3df70b606c45" translate="yes" xml:space="preserve">
          <source>There is no &quot;previous&quot; sibling selector unfortunately, but you can &lt;em&gt;possibly&lt;/em&gt; still get the same effect by using positioning (e.g. float right). It depends on what you are trying to do.</source>
          <target state="translated">残念ながら、「以前の」兄弟セレクターは&lt;em&gt;あり&lt;/em&gt;ませんが、位置付けを使用することで、同じ効果を得ることができます（例：float right）。 それはあなたが何をしようとしているのかに依存します。</target>
        </trans-unit>
        <trans-unit id="03b6eeb31b47d9993da80a332e6a18ebd9b2ffe6" translate="yes" xml:space="preserve">
          <source>There is no official way to do that at the moment but you can use a little trick to achieve this ! Remember that it is experimental and it has some limitation ...
(check &lt;a href=&quot;http://fmbip.com/litmus/&quot;&gt;this link&lt;/a&gt; if you worries about navigator compatibility )</source>
          <target state="translated">現時点では正式な方法はありませんが、少しトリックを使用してこれを実現できます。 これは実験的なものであり、いくつかの制限があることを忘れないでください...（ナビゲーターの互換性が心配な場合は、 &lt;a href=&quot;http://fmbip.com/litmus/&quot;&gt;このリンクを&lt;/a&gt;確認してください）</target>
        </trans-unit>
        <trans-unit id="45b35f90fcdcabc6a74055eb084b276d13094e30" translate="yes" xml:space="preserve">
          <source>This finds all &lt;code&gt;#full-width .companies&lt;/code&gt;, and selects just those &lt;code&gt;.companies&lt;/code&gt;, similar to how selectors are used to target specific elements in standard in CSS.</source>
          <target state="translated">これにより、すべての &lt;code&gt;#full-width .companies&lt;/code&gt; が検出され 、それらの &lt;code&gt;.companies&lt;/code&gt; のみが選択されます。これは、CSSの標準でセレクターを使用して特定の要素をターゲットにする方法と同様です。</target>
        </trans-unit>
        <trans-unit id="ca872b70b4139c1dd2fb6a771206f43e4b169e1c" translate="yes" xml:space="preserve">
          <source>This first selects all &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;s that immediately follow a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">まず、 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; の直後に続くすべての &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="74496773ae4f698f108b0c2c81194fcf66a99f32" translate="yes" xml:space="preserve">
          <source>This is the same for pseudo classes</source>
          <target state="translated">これは疑似クラス</target>
        </trans-unit>
        <trans-unit id="780f7784d75a1253b4979a5ed18f418476e2e415" translate="yes" xml:space="preserve">
          <source>This sets all anchor links to have 15px margin on the top and resets it back to 0 for those with no UL elements (or other tags) inside LIs.</source>
          <target state="translated">これはすべてのアンカーリンクのマージンを15pxに設定し、LIの中にUL要素(または他のタグ)がない場合は0に戻します。</target>
        </trans-unit>
        <trans-unit id="d693c780f30dd4ef25beb759926f543600b69fa2" translate="yes" xml:space="preserve">
          <source>Thus I could select ALL &lt;code&gt;#full-width&lt;/code&gt;s.</source>
          <target state="translated">したがって、すべての &lt;code&gt;#full-width&lt;/code&gt; を選択できます。</target>
        </trans-unit>
        <trans-unit id="c603a250e4ca71f19cd8ea72a8ecb969a8783120" translate="yes" xml:space="preserve">
          <source>To say this belief is widespread would be an understatement. Here's a sampling of related questions on Stack Overflow alone:</source>
          <target state="translated">このような考えが広まっていると言っても過言ではないでしょう。ここでは、Stack Overflowだけでも関連する質問のサンプルを紹介します。</target>
        </trans-unit>
        <trans-unit id="1d3701e331dc8b27252466a97f77b8a75a27c8dd" translate="yes" xml:space="preserve">
          <source>Two &lt;em&gt;tricks&lt;/em&gt;. Basically inverting the HTML order of your desired elements in HTML and using</source>
          <target state="translated">2つの&lt;em&gt;トリック&lt;/em&gt; 。 基本的に、HTML内の目的の要素のHTML順序を逆にして使用する</target>
        </trans-unit>
        <trans-unit id="da5a01f69e0f0a6401c48450d762ea9e3ca49bb7" translate="yes" xml:space="preserve">
          <source>Use a sibling selector to target Element A  (&lt;code&gt;~&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; will do) .</source>
          <target state="translated">兄弟セレクターを使用して、要素Aをターゲットにします（ &lt;code&gt;~&lt;/code&gt; または &lt;code&gt;+&lt;/code&gt; でできます）。</target>
        </trans-unit>
        <trans-unit id="6418531d3667fddb681489113d747c5a42f51833" translate="yes" xml:space="preserve">
          <source>Use the flex &lt;code&gt;order&lt;/code&gt; property to restore the order of siblings on the visual display.</source>
          <target state="translated">flex &lt;code&gt;order&lt;/code&gt; プロパティを使用して、ビジュアルディスプレイ上の兄弟の順序を復元します。</target>
        </trans-unit>
        <trans-unit id="668d622c2d0c54db3e9364afa53203471e4c680a" translate="yes" xml:space="preserve">
          <source>Value:      auto |  | inherit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c966d2e7899f01b11a9c146510d6e9c5569df" translate="yes" xml:space="preserve">
          <source>What can we do to make the Socks block (including sock colours) stand out visually using spacing?</source>
          <target state="translated">間隔を利用してソックスブロック(ソックスカラーを含む)を視覚的に目立たせるためにはどうすればいいのか?</target>
        </trans-unit>
        <trans-unit id="20dc3d5b8b33b8fca560d792ef4e22c80f9162be" translate="yes" xml:space="preserve">
          <source>What does exist:</source>
          <target state="translated">存在するもの。</target>
        </trans-unit>
        <trans-unit id="88536aa66c898bfb53c491477414c9d560627da3" translate="yes" xml:space="preserve">
          <source>What would be nice but doesn't exist:</source>
          <target state="translated">嬉しいけど存在しないもの。</target>
        </trans-unit>
        <trans-unit id="9ec5485132671fdd7692fc8455d289a7863233f3" translate="yes" xml:space="preserve">
          <source>What you can do is use a CSS3 selector : the pseudo classe called &lt;code&gt;nth-child()&lt;/code&gt;</source>
          <target state="translated">あなたができることはCSS3セレクターを使うことです： &lt;code&gt;nth-child()&lt;/code&gt; と呼ばれる疑似クラス</target>
        </trans-unit>
        <trans-unit id="0077a584a44ef74fce634034afa28323a805771d" translate="yes" xml:space="preserve">
          <source>Which does the same.</source>
          <target state="translated">どっちも同じだ</target>
        </trans-unit>
        <trans-unit id="4e1cb73736ecd6fc6afeba8df7ddf1a7664dd27b" translate="yes" xml:space="preserve">
          <source>Which would select all &lt;code&gt;li&lt;/code&gt;s before the 3rd (e.g. 1st and 2nd). But, in my opinion this looks ugly and has a very tight usecase.</source>
          <target state="translated">これにより、3番目より前のすべての &lt;code&gt;li&lt;/code&gt; が選択されます（1番目と2番目など）。 しかし、私の意見では、これは醜く見え、非常にタイトなユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="45ee67100ba9b556b21767275c4bde54ec9eeb16" translate="yes" xml:space="preserve">
          <source>Working sample:</source>
          <target state="translated">ワーキングサンプル。</target>
        </trans-unit>
        <trans-unit id="66d88363dd000457d2bb258b0c3eaee69b3c4440" translate="yes" xml:space="preserve">
          <source>You also could select the nth-child right-to-left:</source>
          <target state="translated">N番目の子を右から左に選択することもできます。</target>
        </trans-unit>
        <trans-unit id="e505512adaaefac12cb8dfb4e4b5aec4195707b3" translate="yes" xml:space="preserve">
          <source>You can use inverse the order of elements in HTML. Then besides using &lt;code&gt;order&lt;/code&gt; as in &lt;a href=&quot;https://stackoverflow.com/a/36118012/1548895&quot;&gt;Michael_B's answer&lt;/a&gt; you can use &lt;code&gt;flex-direction: row-reverse;&lt;/code&gt; or &lt;code&gt;flex-direction: column-reverse;&lt;/code&gt; depending on your layout.</source>
          <target state="translated">HTMLでは要素の順序を逆にすることができます。 次に、 &lt;a href=&quot;https://stackoverflow.com/a/36118012/1548895&quot;&gt;Michael_Bの回答の&lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; を使用する以外に、 &lt;code&gt;flex-direction: row-reverse;&lt;/code&gt; 使用できます。 または &lt;code&gt;flex-direction: column-reverse;&lt;/code&gt; あなたのレイアウトに応じて。</target>
        </trans-unit>
        <trans-unit id="31081519188f312b812b83b2662058b5c0332726" translate="yes" xml:space="preserve">
          <source>You can use jQuery's &lt;code&gt;find&lt;/code&gt; to perform a &quot;look-ahead&quot; on your target element/class/id, then backtrack to select your target.</source>
          <target state="translated">jQueryの &lt;code&gt;find&lt;/code&gt; を使用して、ターゲット要素/クラス/ IDで「先読み」を実行し、バックトラックしてターゲットを選択できます。</target>
        </trans-unit>
        <trans-unit id="75ed017ad0628647ce91c95dd3dc32a10897cc88" translate="yes" xml:space="preserve">
          <source>You can use the two &lt;em&gt;axe&lt;/em&gt; selectors: &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">2つの&lt;em&gt;ax&lt;/em&gt;セレクターを使用できます &lt;code&gt;!&lt;/code&gt; そして &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb21234bc02fdf5666dacb9aa976128fdeb19663" translate="yes" xml:space="preserve">
          <source>You can't select previous elements based on the classes of the next elements</source>
          <target state="translated">次の要素のクラスに基づいて前の要素を選択できない</target>
        </trans-unit>
        <trans-unit id="e3492e80ff1d5c3f8706aa88636dc1da749a151c" translate="yes" xml:space="preserve">
          <source>You want element A to turn red when element B is hovered.</source>
          <target state="translated">要素Bがホバーされたときに要素Aが赤くなるようにしたい。</target>
        </trans-unit>
        <trans-unit id="85ffd51008e5a489e4ee779532037b307b4eac6e" translate="yes" xml:space="preserve">
          <source>and this way you'll be able to style your current, previous items(all items overridden with current and next items) and your next items.</source>
          <target state="translated">とすることで、現在のアイテム、前のアイテム(現在のアイテムと次のアイテムで上書きされるすべてのアイテム)、そして次のアイテムをスタイル化することができます。</target>
        </trans-unit>
        <trans-unit id="933ae2578114986f2c3a8596b7d13190700e396c" translate="yes" xml:space="preserve">
          <source>but filters those results to keep only &lt;code&gt;#fill-width&lt;/code&gt; elements, so that in the end,</source>
          <target state="translated">しかし、これらの結果をフィルタリングして &lt;code&gt;#fill-width&lt;/code&gt; 要素のみを保持するため、最終的には、</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="6ea161043c0ed0ac22c49aa54e64e97c531e53e3" translate="yes" xml:space="preserve">
          <source>give all your items a style.</source>
          <target state="translated">すべてのアイテムにスタイルを与える</target>
        </trans-unit>
        <trans-unit id="b02dd7feb3f9788f8c896ddf58c5c6a59c775d85" translate="yes" xml:space="preserve">
          <source>give next items a style using + or ~.</source>
          <target state="translated">を使って次の項目にスタイルを与えます。</target>
        </trans-unit>
        <trans-unit id="ffbd2de2c8f0124e30c2c0ad91fd3faa4d399fb6" translate="yes" xml:space="preserve">
          <source>give your selected item a style.</source>
          <target state="translated">選択したアイテムにスタイルを与えます。</target>
        </trans-unit>
        <trans-unit id="7003ceafdf0fa186aaeed2ac77400fb27b3f0ff9" translate="yes" xml:space="preserve">
          <source>it only selects a &lt;code&gt;#full-width&lt;/code&gt; element if it has a &lt;code&gt;.companies&lt;/code&gt; class descendant.</source>
          <target state="translated">&lt;code&gt;.companies&lt;/code&gt; クラスの子孫がある場合にのみ、 &lt;code&gt;#full-width&lt;/code&gt; 要素を選択します。</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
