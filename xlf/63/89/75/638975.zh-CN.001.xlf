<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/638975">
    <body>
      <group id="638975">
        <trans-unit id="bc8e6136e072b2abfb8adef6e30999e9e042e820" translate="yes" xml:space="preserve">
          <source>(beware the &lt;a href=&quot;http://www.zsh.org/mla/workers/2016/msg01696.html&quot;&gt;&lt;code&gt;$errnos&lt;/code&gt; support was broken with some versions of &lt;code&gt;zsh&lt;/code&gt; when built with recent versions of &lt;code&gt;gcc&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">（请注意， &lt;a href=&quot;http://www.zsh.org/mla/workers/2016/msg01696.html&quot;&gt;在使用最新版本的 &lt;code&gt;gcc&lt;/code&gt; 构建时，某些版本的 &lt;code&gt;zsh&lt;/code&gt; 破坏&lt;/a&gt;了 &lt;code&gt;$errnos&lt;/code&gt; 支持 ）。</target>
        </trans-unit>
        <trans-unit id="49cfe2cf225677fb886734cdbf78716ab509d7a2" translate="yes" xml:space="preserve">
          <source>... any other reason why the &lt;code&gt;stat()&lt;/code&gt; system call may fail.</source>
          <target state="translated">... &lt;code&gt;stat()&lt;/code&gt; 系统调用可能失败的任何其他原因。</target>
        </trans-unit>
        <trans-unit id="91884e45fee51897dabcbdbf064619ebcb11c8f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-G filename set-group-id&lt;/code&gt; - True if file exists and is set-group-id</source>
          <target state="translated">&lt;code&gt;-G filename set-group-id&lt;/code&gt; id-如果文件存在且为set-group-id，则为true</target>
        </trans-unit>
        <trans-unit id="b8e4eadeaa305a5433101605ade893597cbf0128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-G filename&lt;/code&gt; - Check if file exists and is owned by effective group ID</source>
          <target state="translated">&lt;code&gt;-G filename&lt;/code&gt; -检查文件是否存在并由有效组ID拥有</target>
        </trans-unit>
        <trans-unit id="68d8bee3ff35904f4d870023dbe0840f4557917f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-L filename&lt;/code&gt; - Symbolic link</source>
          <target state="translated">&lt;code&gt;-L filename&lt;/code&gt; -符号链接</target>
        </trans-unit>
        <trans-unit id="4a8aafa773c49d568bc407503f656a379f8ceae7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-O filename&lt;/code&gt; - True if file exists and is owned by the effective user id</source>
          <target state="translated">&lt;code&gt;-O filename&lt;/code&gt; -如果文件存在且由有效用户ID拥有，则为True</target>
        </trans-unit>
        <trans-unit id="31c83a67086e0527fd616dc6d72263186d95a56d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-S filename&lt;/code&gt; - Check if file is socket</source>
          <target state="translated">&lt;code&gt;-S filename&lt;/code&gt; -检查文件是否为套接字</target>
        </trans-unit>
        <trans-unit id="302b757de5cf4452e5c74f4ae35ff19feeb55520" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-b filename&lt;/code&gt; - Block special file</source>
          <target state="translated">&lt;code&gt;-b filename&lt;/code&gt; -阻止特殊文件</target>
        </trans-unit>
        <trans-unit id="706a7991f26ab8414b9638549ba6cec9c514024a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-c filename&lt;/code&gt; - Special character file</source>
          <target state="translated">&lt;code&gt;-c filename&lt;/code&gt; -特殊字符文件</target>
        </trans-unit>
        <trans-unit id="650808b779a7dc6daaf427d3fbc5b7b727f15a25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-d directoryname&lt;/code&gt; - Check for directory Existence</source>
          <target state="translated">&lt;code&gt;-d directoryname&lt;/code&gt; -检查目录是否存在</target>
        </trans-unit>
        <trans-unit id="7706025c21745bf16cbb325a866bb74ba42b5f5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-e filename&lt;/code&gt; - Check for file existence, regardless of type (node, directory, socket, etc.)</source>
          <target state="translated">&lt;code&gt;-e filename&lt;/code&gt; -检查文件是否存在，与类型（节点，目录，套接字等）无关</target>
        </trans-unit>
        <trans-unit id="d8508950c2eb73319607e7584dfd20662eea097f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-f filename&lt;/code&gt; - Check for regular file existence not a directory</source>
          <target state="translated">&lt;code&gt;-f filename&lt;/code&gt; -检查常规文件是否存在而不是目录</target>
        </trans-unit>
        <trans-unit id="287b50b3e03c05b3245006bafa666b64642b5392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-k filename&lt;/code&gt; - Sticky bit</source>
          <target state="translated">&lt;code&gt;-k filename&lt;/code&gt; -粘性位</target>
        </trans-unit>
        <trans-unit id="b81d6851420cf7a75a0f7a6a83b71eaf7475795e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-r filename&lt;/code&gt; - Check if file is a readable</source>
          <target state="translated">&lt;code&gt;-r filename&lt;/code&gt; -检查文件是否可读</target>
        </trans-unit>
        <trans-unit id="fd6a171f95022e193d144be42352ec5b8719066a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-s filename&lt;/code&gt; - Check if file is nonzero size</source>
          <target state="translated">&lt;code&gt;-s filename&lt;/code&gt; -检查文件是否为非零大小</target>
        </trans-unit>
        <trans-unit id="95e5771c316836b61a617a7d2d3ab258c625ad41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-u filename&lt;/code&gt; - Check if file set-user-id bit is set</source>
          <target state="translated">&lt;code&gt;-u filename&lt;/code&gt; -检查是否设置了文件set-user-id位</target>
        </trans-unit>
        <trans-unit id="79eb2b5e4ec5d0e4e5b05e1c80fc21a7ac8473ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-w filename&lt;/code&gt; - Check if file is writable</source>
          <target state="translated">&lt;code&gt;-w filename&lt;/code&gt; -检查文件是否可写</target>
        </trans-unit>
        <trans-unit id="997cd23661ac164bd3efebf21b338bda61035c7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-x filename&lt;/code&gt; - Check if file is executable</source>
          <target state="translated">&lt;code&gt;-x filename&lt;/code&gt; -检查文件是否可执行</target>
        </trans-unit>
        <trans-unit id="73c7386c05533d3a25dc3b525ec9bc944099f003" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bash File Testing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Bash文件测试&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4a2b9d31592469480366ccd5feff9290579fb450" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to use:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何使用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d5f0248d6fab0a241ecc8407dea610d319183fe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test expression&lt;/em&gt; can be negated by using the &lt;code&gt;!&lt;/code&gt; operator</source>
          <target state="translated">可以使用 &lt;code&gt;!&lt;/code&gt; 来否定&lt;em&gt;测试表达式&lt;/em&gt; 。 算子</target>
        </trans-unit>
        <trans-unit id="e77443e278e15fb751365b0da4b69bbf50834224" translate="yes" xml:space="preserve">
          <source>Act on the result of the test being negative (&lt;code&gt;||&lt;/code&gt; instead of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;):</source>
          <target state="translated">对测试结果为负（ &lt;code&gt;||&lt;/code&gt; 代替 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ）采取行动：</target>
        </trans-unit>
        <trans-unit id="e0be58f7bcfbfe46fa6604c8fde4ea8db56fb24e" translate="yes" xml:space="preserve">
          <source>All the tests below apply to regular files, directories, and symlinks:</source>
          <target state="translated">下面的所有测试都适用于普通文件、目录和symlinks。</target>
        </trans-unit>
        <trans-unit id="af1d486fa488e5db8918ce2f13f005e3a79873e6" translate="yes" xml:space="preserve">
          <source>Also, it's possible that the file is a broken symbolic link, or a non-regular file, like e.g. a socket, device or fifo. For example, to add a check for broken symlinks:</source>
          <target state="translated">另外,也有可能是破损的符号链接,或者是非规则文件,如套接字、设备或fifo等。例如,要添加一个检查破损的符号链接。</target>
        </trans-unit>
        <trans-unit id="d3db2d2c309dc64be354b90b7fb8295262a1d041" translate="yes" xml:space="preserve">
          <source>At least &lt;code&gt;ls&lt;/code&gt; tells me it's not because the file doesn't exist that it fails. It's because it can't tell whether the file exists or not. The &lt;code&gt;[&lt;/code&gt; command just ignored the problem.</source>
          <target state="translated">至少 &lt;code&gt;ls&lt;/code&gt; 告诉我这不是因为文件不存在而导致失败。 这是因为它无法确定文件是否存在。 &lt;code&gt;[&lt;/code&gt; 命令只是忽略了该问题。</target>
        </trans-unit>
        <trans-unit id="29a139e569d273270cbac7865b4381dbe07b8163" translate="yes" xml:space="preserve">
          <source>Example script:</source>
          <target state="translated">脚本示例。</target>
        </trans-unit>
        <trans-unit id="c528a7c08467622a604fee3f7f6fc710c147abd5" translate="yes" xml:space="preserve">
          <source>For a couple of commands, like I would do in a script:</source>
          <target state="translated">对于几个命令,就像我在脚本中会做的那样。</target>
        </trans-unit>
        <trans-unit id="b08fd5a694224aa8fa9137aaf6c03c139f844ff6" translate="yes" xml:space="preserve">
          <source>How do I tell if a regular file does not exist in Bash</source>
          <target state="translated">如何判断Bash中的正则文件不存在?</target>
        </trans-unit>
        <trans-unit id="335ad444ebc317fd9346d412498e06c15fa575d3" translate="yes" xml:space="preserve">
          <source>However if it returns &lt;em&gt;false&lt;/em&gt; (or if &lt;code&gt;[ ! -f &quot;$file&quot; ]&lt;/code&gt; or &lt;code&gt;! [ -f &quot;$file&quot; ]&lt;/code&gt; return true), there are many different possibilities:</source>
          <target state="translated">但是，如果返回&lt;em&gt;false&lt;/em&gt; （或者 &lt;code&gt;[ ! -f &quot;$file&quot; ]&lt;/code&gt; 或 &lt;code&gt;! [ -f &quot;$file&quot; ]&lt;/code&gt; 返回true），则存在许多不同的可能性：</target>
        </trans-unit>
        <trans-unit id="fce581d3a5af0870b6b12a958b89b3d28a1a1c23" translate="yes" xml:space="preserve">
          <source>I prefer to do the following one-liner, in &lt;a href=&quot;http://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; shell compatible format:</source>
          <target state="translated">我更喜欢使用&lt;a href=&quot;http://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; Shell兼容格式的以下单行代码：</target>
        </trans-unit>
        <trans-unit id="b220c21992990a3f3d48b869baf1da8c649268bc" translate="yes" xml:space="preserve">
          <source>I've used the following script to see if a file exists:</source>
          <target state="translated">我用了下面的脚本来查看文件是否存在。</target>
        </trans-unit>
        <trans-unit id="1b95e20e1d7aea92af48e5a942fb361a07e3e396" translate="yes" xml:space="preserve">
          <source>If filename doesn't exit, the output will be</source>
          <target state="translated">如果文件名没有退出,则输出为</target>
        </trans-unit>
        <trans-unit id="f11025afe2d273d8f16cbceb6ddaf5f41e238697" translate="yes" xml:space="preserve">
          <source>If you want to check for file and folder both, then use &lt;code&gt;-e&lt;/code&gt; option instead of &lt;code&gt;-f&lt;/code&gt;. &lt;code&gt;-e&lt;/code&gt; returns true for regular files, directories, socket, character special files, block special files etc.</source>
          <target state="translated">如果要同时检查文件和文件夹，请使用 &lt;code&gt;-e&lt;/code&gt; 选项而不是 &lt;code&gt;-f&lt;/code&gt; 。 &lt;code&gt;-e&lt;/code&gt; 对于常规文件，目录，套接字，字符特殊文件，块特殊文件等返回true。</target>
        </trans-unit>
        <trans-unit id="5e86e7f04862bf79a289d49c85c753d4340f7855" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;test&lt;/code&gt; instead of &lt;code&gt;[]&lt;/code&gt;, then you can use &lt;code&gt;!&lt;/code&gt; to get the negation:</source>
          <target state="translated">如果要使用 &lt;code&gt;test&lt;/code&gt; 代替 &lt;code&gt;[]&lt;/code&gt; ，则可以使用 &lt;code&gt;!&lt;/code&gt; 得到否定：</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="41e58725f85ecce33ced7fc34811b09e6767ce1d" translate="yes" xml:space="preserve">
          <source>In short, it should be:</source>
          <target state="translated">简而言之,应该是。</target>
        </trans-unit>
        <trans-unit id="9c0bf12c5634037e1e2167931fe76a37b2b3a795" translate="yes" xml:space="preserve">
          <source>It's worth mentioning that if you need to execute a single command you can abbreviate</source>
          <target state="translated">值得一提的是,如果你需要执行一条命令,可以将其缩写为</target>
        </trans-unit>
        <trans-unit id="76f568a13675ac90d315970c14d26be9a65e844f" translate="yes" xml:space="preserve">
          <source>Like in (if you have command &quot;test&quot;):</source>
          <target state="translated">如在(如果你有命令 &quot;测试&quot;)。</target>
        </trans-unit>
        <trans-unit id="78660dc191e5bfd854b0cdc7d460466de844a9c5" translate="yes" xml:space="preserve">
          <source>Negate the exit status with bash (no other answer has said this):</source>
          <target state="translated">用bash否定退出状态(其他答案都没有说过)。</target>
        </trans-unit>
        <trans-unit id="0b1ee41c70efd7b8127abf7df611db160091e378" translate="yes" xml:space="preserve">
          <source>Negate the test inside the test command &lt;code&gt;[&lt;/code&gt; (that is the way most answers before have presented):</source>
          <target state="translated">否定测试命令中的测试 &lt;code&gt;[&lt;/code&gt; （这是以前大多数答案提出的方式）：</target>
        </trans-unit>
        <trans-unit id="dba3a264141a3b85bde4d159044253b3b157f0ba" translate="yes" xml:space="preserve">
          <source>Note: ( ... ) runs in a subshell, { ... ;} runs in the same shell. &lt;strike&gt;The curly bracket notation works in bash only.&lt;/strike&gt;</source>
          <target state="translated">注意：（...）在子shell中运行，{...;}在同一shell中运行。 &lt;strike&gt;大括号表示法仅适用于bash。&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="e6db86224faae005a30dc3119d6f9ee181f72cbe" translate="yes" xml:space="preserve">
          <source>Once I started doing this, I rarely use the fully typed syntax anymore!!</source>
          <target state="translated">一旦我开始这样做,我就很少再使用完全打字的语法了!</target>
        </trans-unit>
        <trans-unit id="f073ccaadb2fceb76730c765e76f59b37c6cdb13" translate="yes" xml:space="preserve">
          <source>Only:</source>
          <target state="translated">Only:</target>
        </trans-unit>
        <trans-unit id="2aee5d3c0dfc54192d126273e9c8fcdeacbb94fd" translate="yes" xml:space="preserve">
          <source>Or written in a slightly different way:</source>
          <target state="translated">或者写的方式稍有不同。</target>
        </trans-unit>
        <trans-unit id="c59bcfcadf347bcef6662efea119e3a1dd603884" translate="yes" xml:space="preserve">
          <source>Or you could use:</source>
          <target state="translated">或者你可以用。</target>
        </trans-unit>
        <trans-unit id="b681174dcf16fa028b98972fcda06e4e4ece49d1" translate="yes" xml:space="preserve">
          <source>Or, presing all together:</source>
          <target state="translated">或者说,预演都在一起。</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="53185fe259d3b62c7272a04245357e9b9903e2b8" translate="yes" xml:space="preserve">
          <source>So if &lt;code&gt;[ -f &quot;$file&quot; ]&lt;/code&gt; returns true, you can tell the file does exist and is a regular file or a symlink eventually resolving to a regular file (or at least it was at the time of the &lt;code&gt;stat()&lt;/code&gt;).</source>
          <target state="translated">因此，如果 &lt;code&gt;[ -f &quot;$file&quot; ]&lt;/code&gt; 返回true，则可以判断该文件确实存在，并且是最终解析为常规文件的常规文件或符号链接（或者至少是在 &lt;code&gt;stat()&lt;/code&gt; 时 ）。</target>
        </trans-unit>
        <trans-unit id="dfacb2a7723ca8df6b9c9459e412d490138aefef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://man7.org/linux/man-pages/man1/test.1.html&quot;&gt;test&lt;/a&gt; command (&lt;code&gt;[&lt;/code&gt; here) has a &quot;not&quot; logical operator which is the exclamation point (similar to many other languages). Try this:</source>
          <target state="translated">&lt;a href=&quot;http://man7.org/linux/man-pages/man1/test.1.html&quot;&gt;测试&lt;/a&gt;命令（ &lt;code&gt;[&lt;/code&gt; 这里）有一个&amp;ldquo; not&amp;rdquo;逻辑运算符，它是感叹号（类似于许多其他语言）。 尝试这个：</target>
        </trans-unit>
        <trans-unit id="470371220474fc2d22f45344600c5e6d1def786d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ -e &quot;$file&quot; ]&lt;/code&gt; test can also be done with &lt;code&gt;ls -Ld -- &quot;$file&quot; &amp;gt; /dev/null&lt;/code&gt;. In that case, &lt;code&gt;ls&lt;/code&gt; will tell you why the &lt;code&gt;stat()&lt;/code&gt; failed, though the information can't easily be used programmatically:</source>
          <target state="translated">&lt;code&gt;[ -e &quot;$file&quot; ]&lt;/code&gt; 测试也可以通过 &lt;code&gt;ls -Ld -- &quot;$file&quot; &amp;gt; /dev/null&lt;/code&gt; 。 在这种情况下， &lt;code&gt;ls&lt;/code&gt; 会告诉您 &lt;code&gt;stat()&lt;/code&gt; 失败的原因，尽管该信息无法轻松地以编程方式使用：</target>
        </trans-unit>
        <trans-unit id="06d0456f73f1dc8cf7c38d400eb9d2c39cb743bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; thing may count too. It worked for me (based on &lt;em&gt;&lt;a href=&quot;http://www.cyberciti.biz/faq/unix-linux-test-existence-of-file-in-bash/&quot;&gt;Bash Shell: Check File Exists or Not&lt;/a&gt;&lt;/em&gt;):</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 东西也可能算在内。 它对我&lt;em&gt;&lt;a href=&quot;http://www.cyberciti.biz/faq/unix-linux-test-existence-of-file-in-bash/&quot;&gt;有用&lt;/a&gt;&lt;/em&gt; （基于&lt;em&gt;Bash Shell：检查文件是否存在&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b8fae368fa4ea0f61a7dc2e4f52d05aceb92a1e5" translate="yes" xml:space="preserve">
          <source>The recommendation is usually to have the tested variable surrounded by double quotation marks:</source>
          <target state="translated">建议通常是用双引号包围被测变量。</target>
        </trans-unit>
        <trans-unit id="31029287294111d9a307abd12f418ba68f82f36b" translate="yes" xml:space="preserve">
          <source>The relevant man page is &lt;code&gt;man test&lt;/code&gt; or, equivalently, &lt;code&gt;man [&lt;/code&gt; -- or &lt;code&gt;help test&lt;/code&gt; or &lt;code&gt;help [&lt;/code&gt; for the built-in bash command.</source>
          <target state="translated">相关的手册页是 &lt;code&gt;man test&lt;/code&gt; 或等效的 &lt;code&gt;man [&lt;/code&gt; -或 &lt;code&gt;help test&lt;/code&gt; 或 &lt;code&gt;help [&lt;/code&gt; 用于内置的bash命令。</target>
        </trans-unit>
        <trans-unit id="dd5fb9efe2797d2cb3843775c28afb82fa19620b" translate="yes" xml:space="preserve">
          <source>The simplest way</source>
          <target state="translated">最简单的方法</target>
        </trans-unit>
        <trans-unit id="f9cbc2247db5ed5a6bfc103baf7bc72ee420f6b2" translate="yes" xml:space="preserve">
          <source>There are three distinct ways to do this:</source>
          <target state="translated">这有三种不同的方法。</target>
        </trans-unit>
        <trans-unit id="d56e252a4ad4aeb99d5476f068039566e2ffab84" translate="yes" xml:space="preserve">
          <source>This code also working .</source>
          <target state="translated">这个代码也可以用。</target>
        </trans-unit>
        <trans-unit id="8b423e26acdaee95eacb2f78be6511fc7f3cefa7" translate="yes" xml:space="preserve">
          <source>This looks silly (IMO), don't use it unless your code has to be portable to the Bourne shell (like the &lt;code&gt;/bin/sh&lt;/code&gt; of Solaris 10 or earlier) that lacked the pipeline negation operator (&lt;code&gt;!&lt;/code&gt;):</source>
          <target state="translated">这看起来很愚蠢（IMO），除非您的代码必须可移植到缺少管道求反运算符（ &lt;code&gt;!&lt;/code&gt; ）的Bourne shell（如Solaris 10或更早版本的 &lt;code&gt;/bin/sh&lt;/code&gt; ）中，否则不要使用它：</target>
        </trans-unit>
        <trans-unit id="a99a50fa0e5dc45440805d65a9a1e9c8ee7c2368" translate="yes" xml:space="preserve">
          <source>This shell script also works for finding a file in a directory:</source>
          <target state="translated">这个shell脚本也适用于查找目录中的文件。</target>
        </trans-unit>
        <trans-unit id="e74b0fb1294e87c07a83af2e3a8273b63dc98000" translate="yes" xml:space="preserve">
          <source>To know for sure that the file doesn't exist, we'd need the &lt;code&gt;stat()&lt;/code&gt; system call to return with an error code of &lt;code&gt;ENOENT&lt;/code&gt; (&lt;code&gt;ENOTDIR&lt;/code&gt; tells us one of the path components is not a directory is another case where we can tell the file doesn't exist by that path). Unfortunately the &lt;code&gt;[&lt;/code&gt; command doesn't let us know that. It will return false whether  the error code is ENOENT, EACCESS (permission denied), ENAMETOOLONG or anything else.</source>
          <target state="translated">要确定文件不存在，我们需要 &lt;code&gt;stat()&lt;/code&gt; 系统调用以错误代码 &lt;code&gt;ENOENT&lt;/code&gt; 返回（ &lt;code&gt;ENOTDIR&lt;/code&gt; 告诉我们其中一个路径组件不是目录，这是另一种情况，我们可以知道该路径不存在该文件）。 不幸的是 &lt;code&gt;[&lt;/code&gt; 命令没有让我们知道这一点。 无论错误代码是ENOENT，EACCESS（拒绝权限），ENAMETOOLONG或其他任何内容，它都将返回false。</target>
        </trans-unit>
        <trans-unit id="d1de0f23755111518fc5983d9f9885979cfe46bc" translate="yes" xml:space="preserve">
          <source>To reverse a test, use &quot;!&quot;.
That is equivalent to the &quot;not&quot; logical operator in other languages. Try this:</source>
          <target state="translated">要反转一个测试,可以使用&quot;!&quot;。这相当于其他语言中的 &quot;not &quot;逻辑运算符。试试这个。</target>
        </trans-unit>
        <trans-unit id="a80ad89216e3d4ebc6511bd89e3aa365b0043de2" translate="yes" xml:space="preserve">
          <source>To test file existence, the parameter can be any one of the following:</source>
          <target state="translated">为了测试文件的存在,参数可以是以下任何一个。</target>
        </trans-unit>
        <trans-unit id="7f0ed1b0626fd3d5e6afabc2385743712beaed4f" translate="yes" xml:space="preserve">
          <source>What's the correct syntax to use if I only want to check if the file does &lt;strong&gt;not&lt;/strong&gt; exist?</source>
          <target state="translated">如果我只想检查文件是否&lt;strong&gt;不&lt;/strong&gt;存在，使用的正确语法是什么？</target>
        </trans-unit>
        <trans-unit id="50e0b96810bf59cffc70c089d9719e9e19d74392" translate="yes" xml:space="preserve">
          <source>Which looks shorter like this:</source>
          <target state="translated">哪一个看起来像这样短一点</target>
        </trans-unit>
        <trans-unit id="83b66effddbee5ff44e20faa784ae5ea39c54de0" translate="yes" xml:space="preserve">
          <source>Which may be written (using then &quot;and&quot; operator: &amp;amp;&amp;amp;) as:</source>
          <target state="translated">可以这样写（使用&amp;ldquo; and&amp;rdquo;运算符：&amp;amp;&amp;amp;）：</target>
        </trans-unit>
        <trans-unit id="be15ce48728db5b7ba85487823fd8c7c133f0591" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;zsh&lt;/code&gt; shell, you can query the error code with the &lt;code&gt;$ERRNO&lt;/code&gt; special variable after the failing &lt;code&gt;[&lt;/code&gt; command, and decode that number using the &lt;code&gt;$errnos&lt;/code&gt; special array in the &lt;code&gt;zsh/system&lt;/code&gt; module:</source>
          <target state="translated">使用 &lt;code&gt;zsh&lt;/code&gt; shell，您可以在 &lt;code&gt;[&lt;/code&gt; 命令 &lt;code&gt;$ERRNO&lt;/code&gt; 后使用$ ERRNO特殊变量查询错误代码，并使用 &lt;code&gt;zsh/system&lt;/code&gt; 模块中的 &lt;code&gt;$errnos&lt;/code&gt; 特殊数组对该数字进行解码：</target>
        </trans-unit>
        <trans-unit id="db13585a52bd8fa944d5252a08d6693e1ca18fed" translate="yes" xml:space="preserve">
          <source>You can also group multiple commands in the one liner</source>
          <target state="translated">你也可以在一个内衬中对多个命令进行分组。</target>
        </trans-unit>
        <trans-unit id="fc5e54f4c9f2681608006b5b631799b3d6de7e32" translate="yes" xml:space="preserve">
          <source>You can do this:</source>
          <target state="translated">你可以这样做。</target>
        </trans-unit>
        <trans-unit id="d81d1360a14c77a3fc42de628403ed4d9a2aae4b" translate="yes" xml:space="preserve">
          <source>You can negate an expression with &quot;!&quot;:</source>
          <target state="translated">你可以用&quot;!&quot;来否定一个表达式。</target>
        </trans-unit>
        <trans-unit id="2aa87abd813fa3905e7264af677be5c6347b0265" translate="yes" xml:space="preserve">
          <source>You should be careful about running &lt;code&gt;test&lt;/code&gt; for an unquoted variable, because it might produce unexpected results:</source>
          <target state="translated">您应该对未加引号的变量进行 &lt;code&gt;test&lt;/code&gt; ，因为它可能会产生意外结果：</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="2050ec9dc2bb9a845a29eb100d726ccd39cd0694" translate="yes" xml:space="preserve">
          <source>sometimes it may be handy to use &amp;amp;&amp;amp; and || operators.</source>
          <target state="translated">有时使用&amp;amp;&amp;amp;和||可能很方便 操作员。</target>
        </trans-unit>
        <trans-unit id="6beb4edeb3b1fbf88b5d23ccd0651bac34ab61fc" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;[&lt;/code&gt; command does a &lt;code&gt;stat()&lt;/code&gt; (not &lt;code&gt;lstat()&lt;/code&gt;) system call on the path stored in &lt;code&gt;$file&lt;/code&gt; and returns &lt;em&gt;true&lt;/em&gt; if that system call succeeds and the type of the file as returned by &lt;code&gt;stat()&lt;/code&gt; is &quot;&lt;em&gt;regular&lt;/em&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 命令在 &lt;code&gt;$file&lt;/code&gt; 存储的路径上执行 &lt;code&gt;stat()&lt;/code&gt; （不是 &lt;code&gt;lstat()&lt;/code&gt; ）系统调用，如果该系统调用成功并且 &lt;code&gt;stat()&lt;/code&gt; 返回的文件类型为&amp;ldquo; &lt;em&gt;常规&lt;/em&gt; &amp;rdquo;，则返回&lt;em&gt;true&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="6367a1ed4f917b401d7486d46eeff9a3a9c52af2" translate="yes" xml:space="preserve">
          <source>the file doesn't exist</source>
          <target state="translated">文件不存在</target>
        </trans-unit>
        <trans-unit id="75b776b66389c005a2a892f0121bc0114fb6803a" translate="yes" xml:space="preserve">
          <source>the file exists but is not a &lt;em&gt;regular&lt;/em&gt; file (could be a device, fifo, directory, socket...)</source>
          <target state="translated">该文件存在但不是&lt;em&gt;常规&lt;/em&gt;文件（可以是设备，FIFO，目录，套接字...）</target>
        </trans-unit>
        <trans-unit id="67b250dfdae452cdcbd998185fd5039ba80ef811" translate="yes" xml:space="preserve">
          <source>the file exists but that path to access it is too long</source>
          <target state="translated">文件存在,但访问路径过长</target>
        </trans-unit>
        <trans-unit id="c0456ac07869d3e67ae45f89dea1f5fe55c40f42" translate="yes" xml:space="preserve">
          <source>the file exists but you don't have search permission to the parent directory</source>
          <target state="translated">文件存在,但你没有父目录的搜索权限。</target>
        </trans-unit>
        <trans-unit id="354a20559207231f267ed555280e565f3a81ad4c" translate="yes" xml:space="preserve">
          <source>the file is a symlink to a regular file, but you don't have search permission to some of the directories involved in the resolution of the symlink.</source>
          <target state="translated">该文件是一个指向普通文件的symlink,但你没有搜索权限,在解析symlink中涉及的一些目录。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
