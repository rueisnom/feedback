<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/6319146">
    <body>
      <group id="6319146">
        <trans-unit id="73df4e1cfb97a0cf2c29a8c07e2bb86731b5d146" translate="yes" xml:space="preserve">
          <source>&quot;When you are talking about splitting
  [code] across different cores that's
  in the standard, we are talking about
  the memory model. We are going to
  optimize it without breaking the
  following assumptions people are going
  to make in the code,&quot; &lt;strong&gt;Sutter&lt;/strong&gt; said.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Когда вы говорите о разделении [кода] по различным ядрам, которые есть в стандарте, мы говорим о модели памяти. Мы собираемся оптимизировать ее, не нарушая следующие предположения, которые люди собираются сделать в коде&amp;raquo;, - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сказал &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Саттер&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d15a3a1c7c247d44171f5a6070b968d22cecb393" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;This article&lt;/a&gt; (by &lt;strong&gt;Gavin Clarke&lt;/strong&gt; who quotes &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/strong&gt;) says that,</source>
          <target state="translated">&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта статья&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Гэвин Кларк,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которая цитирует &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Херба Саттера&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) говорит, что&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="731c13310aa9d76029890ec2d9fe270b4e77f4e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Relaxed&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;weak&lt;/em&gt;&lt;/strong&gt; memory consistency models are motivated by the fact that most memory orderings in strong models are unnecessary. If a thread updates ten data items and then a synchronization flag, programmers usually do not care if the data items are updated in order with respect to each other but only that all data items are updated before the flag is updated (usually implemented using FENCE instructions). Relaxed models seek to capture this increased ordering flexibility and preserve only the orders that programmers &amp;ldquo;&lt;em&gt;require&lt;/em&gt;&amp;rdquo; to get both higher performance and correctness of SC. For example, in certain architectures, FIFO write buffers are used by each core to hold the results of committed (retired) stores before writing the results to the caches. This optimization enhances performance but violates SC. The write buffer hides the latency of servicing a store miss. Because stores are common, being able to avoid stalling on most of them is an important benefit. For a single-core processor, a write buffer can be made architecturally invisible by ensuring that a load to address A returns the value of the most recent store to A even if one or more stores to A are in the write buffer. This is typically done by either bypassing the value of the most recent store to A to the load from A, where &amp;ldquo;most recent&amp;rdquo; is determined by program order, or by stalling a load of A if a store to A is in the write buffer. When multiple cores are used, each will have its own bypassing write buffer. Without write buffers, the hardware is SC, but with write buffers, it is not, making write buffers architecturally visible in a multicore processor.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Расслабленные&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; слабые&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; модели согласованности памяти мотивируются тем фактом, что большинство упорядочений памяти в сильных моделях не нужны. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если поток обновляет десять элементов данных, а затем флаг синхронизации, программисты обычно не заботятся о том, обновляются ли элементы данных по порядку относительно друг друга, а только о том, что все элементы данных обновляются до обновления флага (обычно реализуются с использованием инструкций FENCE). ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Расслабленные модели стремятся использовать эту повышенную гибкость заказов и сохранять только те заказы, которые &amp;laquo;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; требуются&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; программистам&amp;raquo;.&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;rdquo;, Чтобы получить как более высокую производительность, так и правильность СЦ Например, в определенных архитектурах буферы записи FIFO используются каждым ядром для хранения результатов подтвержденных (удаленных) хранилищ перед записью результатов в кэши. Эта оптимизация повышает производительность, но нарушает СЦ. Буфер записи скрывает задержку обслуживания пропуска магазина. Поскольку магазины являются обычным делом, возможность избежать остановки на большинстве из них является важным преимуществом. Для одноядерного процессора буфер записи можно сделать архитектурно невидимым, гарантируя, что загрузка по адресу A возвращает значение самого последнего хранилища в A, даже если одно или несколько хранилищ в A находятся в буфере записи. Обычно это делается путем обхода значения самого последнего хранилища для A до загрузки из A, где &amp;laquo;самый последний&amp;raquo; определяется порядком программы,или путем остановки загрузки A, если хранилище для A находится в буфере записи. Когда используется несколько ядер, у каждого будет свой обходной буфер записи. Без буферов записи аппаратное обеспечение - это SC, но с буферами записи - нет, что делает архитектурно видимые буферы записи в многоядерном процессоре.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a24014293b7e7f3c3957b75dbba2b33ce19b2765" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is now a multiple-year old question, but being very popular, it's worth mentioning a fantastic resource for learning about the C++11 memory model. I see no point in summing up his talk in order to make this yet another full answer, but given this is the guy who actually wrote the standard, I think it's well worth watching the talk.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь это вопрос нескольких лет, но, будучи очень популярным, стоит упомянуть фантастический ресурс для изучения модели памяти C ++ 11. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я не вижу смысла подводить итоги его выступления, чтобы дать ему еще один полный ответ, но, учитывая, что это парень, который на самом деле написал стандарт, я думаю, что стоит посмотреть этот разговор.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fea15c028fa16edd68a84950f92fa70a42f3fac8" translate="yes" xml:space="preserve">
          <source>Although to be frank, unless you are an expert and working on some serious low-level code, you should probably stick to mutexes and condition variables.  That's what I intend to do.</source>
          <target state="translated">Хотя,честно говоря,если вы не эксперт и не работаете над каким-нибудь серьезным низкоуровневым кодом,вам,вероятно,следует придерживаться мьютексов и условных переменных.Это то,что я собираюсь сделать.</target>
        </trans-unit>
        <trans-unit id="3ad19cd05e2aca3350a1896cdfb856a60997442f" translate="yes" xml:space="preserve">
          <source>As I don't know how the internals of multi-threading work, and what memory model means in general, please help me understand these concepts. :-)</source>
          <target state="translated">Так как я не знаю,как работает внутренняя часть многопоточности,и что вообще означает модель памяти,пожалуйста,помогите мне разобраться в этих понятиях.:-)</target>
        </trans-unit>
        <trans-unit id="73edd169fb02675391ad1960b83d93b7512986a3" translate="yes" xml:space="preserve">
          <source>As unintuitive as it seams at first, &lt;code&gt;data1&lt;/code&gt; and &lt;code&gt;data2&lt;/code&gt; need to be &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt;.  If they are not atomic, then they could be read (in &lt;code&gt;reader()&lt;/code&gt;) at the exact same time as they are written (in &lt;code&gt;writer()&lt;/code&gt;).  According to the C++ memory model, this is a race &lt;em&gt;even if &lt;code&gt;reader()&lt;/code&gt; never actually uses the data&lt;/em&gt;.  In addition, if they are not atomic, then the compiler can cache the first read of each value in a register.  Obviously you wouldn't want that... you want to re-read in each iteration of the &lt;code&gt;while&lt;/code&gt; loop in &lt;code&gt;reader()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как бы интуитивно это ни казалось на первый &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;data1&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должны быть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Если они не являются атомарными, то они могут быть прочитаны (в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) в то же самое время, что и написаны (в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writer()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). Согласно модели памяти C ++, это гонка, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;даже если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; никогда не использует данные&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Кроме того, если они не являются атомарными, то компилятор может кэшировать первое чтение каждого значения в регистре. Очевидно , что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вы не хотели бы, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что ... вы хотите , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы перечитать в каждой итерации в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; петли в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4a622ff9ae0214ed05a333e5d2cd4c3f0640dc8" translate="yes" xml:space="preserve">
          <source>Because cache coherence and memory consistency are sometimes confused, it is instructive to also have this quote:</source>
          <target state="translated">Поскольку когерентность кэша и согласованность памяти иногда путают,поучительно также иметь эту цитату:</target>
        </trans-unit>
        <trans-unit id="934437c0109e42d4fd367073bdd77200fe18bf44" translate="yes" xml:space="preserve">
          <source>But with C++11, you can write this:</source>
          <target state="translated">Но с C++11,вы можете написать это:</target>
        </trans-unit>
        <trans-unit id="c3419e7bfb7b912c1de58267196ef1715f03d520" translate="yes" xml:space="preserve">
          <source>C and C++ used to be defined by an execution trace of a well formed program.</source>
          <target state="translated">Раньше С и С++определялись по трассе выполнения хорошо сформированной программы.</target>
        </trans-unit>
        <trans-unit id="f714f1f168010e0e48c54ceb767d70850b43f535" translate="yes" xml:space="preserve">
          <source>C++ programmers used to develop multi-threaded applications even before, so how does it matter if it's POSIX threads, or Windows threads, or C++11 threads? What are the benefits? I want to understand the low-level details.</source>
          <target state="translated">Раньше программисты на С++разрабатывали многопоточные приложения,так какое значение имеют POSIX-потоки,Windows-потоки или C++11-потоки? Каковы преимущества? Я хочу разобраться в деталях низкого уровня.</target>
        </trans-unit>
        <trans-unit id="c804136fc25fd72d45e9ed77db0496ceaaa13a5e" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model, but what exactly does that mean? And how is it going to affect C++ programming?</source>
          <target state="translated">На C++11 была введена стандартизированная модель памяти,но что это значит? И как это повлияет на программирование на Си++?</target>
        </trans-unit>
        <trans-unit id="b31ce9265efcb7ae003d188e0fcacad2174b4301" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model. What does it mean? And how is it going to affect C++ programming</source>
          <target state="translated">На C++11 была представлена стандартизированная модель памяти.Что это значит? И как это повлияет на программирование на Си++.</target>
        </trans-unit>
        <trans-unit id="1071914933f07012e3e0261ffb0513754c189cf3" translate="yes" xml:space="preserve">
          <source>Code Gen &amp;amp; Performance: x86/x64, IA64, POWER, ARM</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код Gen &amp;amp; Performance: x86 / x64, IA64, POWER, ARM&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70cb8dd903b1de610462040edfa72807d0c75c0f" translate="yes" xml:space="preserve">
          <source>Consider the following example, where a pair of global variables are accessed concurrently by two threads:</source>
          <target state="translated">Рассмотрим следующий пример,когда к паре глобальных переменных одновременно обращаются два потока:</target>
        </trans-unit>
        <trans-unit id="5e777ba92d2f70816c7b8e0a710d0cd2e088bf50" translate="yes" xml:space="preserve">
          <source>Continuing with our mental picture, the SWMR invariant corresponds to the physical requirement that there be at most one particle located at any one location but there can be an unlimited number of observers of any location.</source>
          <target state="translated">Продолжая нашу ментальную картину,инвариант SWMR соответствует физическому требованию,чтобы в любой точке находилась не более одной частицы,но могло быть неограниченное количество наблюдателей в любой точке.</target>
        </trans-unit>
        <trans-unit id="1ccda8a650443d20e5e10efff7eff75f39de7479" translate="yes" xml:space="preserve">
          <source>Finally, if you just need to keep particular loads and stores in order, you can write:</source>
          <target state="translated">Наконец,если вам просто нужно держать определенные грузы и магазины в порядке,вы можете писать:</target>
        </trans-unit>
        <trans-unit id="95b21e94883bf869fa456f6fee7bcd0aede60da8" translate="yes" xml:space="preserve">
          <source>First, you have to learn to think like a Language Lawyer.</source>
          <target state="translated">Сначала ты должен научиться думать,как юрист по языку.</target>
        </trans-unit>
        <trans-unit id="f764c87baa07b4d9b69d806e43e35de480f00596" translate="yes" xml:space="preserve">
          <source>For a shared memory machine, the memory consistency model defines the architecturally visible behavior of its memory system. The correctness criterion for a single processor core partitions behavior between &amp;ldquo;&lt;em&gt;one correct result&lt;/em&gt;&amp;rdquo; and &amp;ldquo;&lt;em&gt;many incorrect alternatives&lt;/em&gt;&amp;rdquo;. This is because the processor&amp;rsquo;s architecture mandates that the execution of a thread transforms a given input state into a single well-defined output state, even on an out-of-order core. Shared memory consistency models, however, concern the loads and stores of multiple threads and usually allow &lt;em&gt;many correct executions&lt;/em&gt; while disallowing many (more) incorrect ones. The possibility of multiple correct executions is due to the ISA allowing multiple threads to execute concurrently, often with many possible legal interleavings of instructions from different threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для машины с общей памятью модель согласованности памяти определяет архитектурно видимое поведение ее системы памяти. Критерий корректности поведения разделений ядра одного процессора между &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;одним правильным результатом&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; и &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;многими неправильными альтернативами&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;. Это связано с тем, что архитектура процессора требует, чтобы выполнение потока преобразовывало заданное входное состояние в одно четко определенное выходное состояние, даже на ядре не в порядке. Однако модели согласованности совместно используемой памяти относятся к нагрузкам и хранилищам нескольких потоков и обычно допускают &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;много правильных выполнений.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не допуская много (больше) неправильных. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Возможность многократного правильного выполнения обусловлена ​​тем, что ISA позволяет одновременно выполнять несколько потоков, часто с множеством возможных законных чередований инструкций из разных потоков.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3a3531d42219943e36c390c1d09394dda7f26" translate="yes" xml:space="preserve">
          <source>For languages not specifying a memory model, you are writing code for the language &lt;em&gt;and&lt;/em&gt; the memory model specified by the processor architecture. The processor may choose to re-order memory accesses for performance. So, &lt;strong&gt;if your program has data races&lt;/strong&gt; (a data race is when it's possible for multiple cores / hyper-threads to access the same memory concurrently) then your program is not cross platform because of its dependence on the processor memory model. You may refer to the Intel or AMD software manuals to find out how the processors may re-order memory accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для языков, не определяющих модель памяти, вы пишете код для языка &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; модели памяти, определенных архитектурой процессора. Процессор может выбрать изменение порядка доступа к памяти для повышения производительности. Таким образом, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если ваша программа использует гонки данных&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (гонка данных - это когда несколько ядер / гиперпотоков могут одновременно обращаться к одной и той же памяти), то ваша программа не является кроссплатформенной из-за своей зависимости от модели памяти процессора. Вы можете обратиться к руководствам по программному обеспечению Intel или AMD, чтобы узнать, как процессоры могут изменить порядок доступа к памяти.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ef316ccb8a21361d46e5437050816b42e490adc" translate="yes" xml:space="preserve">
          <source>For more on this stuff, see &lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подробнее об этом см. В &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этом блоге&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e122e719b66a5aaf1016dc68677fa81a7da2c2fe" translate="yes" xml:space="preserve">
          <source>Herb Sutter has a three hour long talk about the C++11 memory model titled &quot;atomic&amp;lt;&amp;gt; Weapons&quot;, available on the Channel9 site - &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;part 2&lt;/a&gt;. The talk is pretty technical, and covers the following topics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Херб Саттер в течение трех часов рассказывает о модели памяти C ++ 11 под названием &amp;laquo;Атомное &amp;lt;&amp;gt; оружие&amp;raquo;, доступной на сайте Channel9 - &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;часть 1&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;часть 2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Доклад довольно технический и охватывает следующие темы:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acbd5686848a17d66430beecce776f2956fd0ca0" translate="yes" xml:space="preserve">
          <source>I also get this feeling that the C++11 memory model is somehow related to C++11 multi-threading support, as I often see these two together. If it is, how exactly? Why should they be related?</source>
          <target state="translated">У меня также возникает ощущение,что модель памяти C++11 каким-то образом связана с поддержкой многопоточности C++11,так как я часто вижу их вместе.Если это так,то как именно? Почему они должны быть связаны?</target>
        </trans-unit>
        <trans-unit id="eb879d24c026ac0b51a220b545aa9383dafc4341" translate="yes" xml:space="preserve">
          <source>I will just give the analogy with which I understand memory consistency models (or memory models, for short). It is inspired by Leslie Lamport's seminal paper &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot;&lt;/a&gt;.
The analogy is apt and has fundamental significance, but may be overkill for many people. However, I hope it provides a mental image (a pictorial representation) that facilitates reasoning about memory consistency models.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я просто приведу аналогию, с которой я понимаю модели согласованности памяти (или модели памяти, для краткости). Он основан на оригинальной работе Лесли Лэмпорта &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Время, часы и порядок событий в распределенной системе&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Аналогия уместна и имеет фундаментальное значение, но может быть излишней для многих людей. Тем не менее, я надеюсь, что это обеспечивает мысленный образ (графическое представление), который облегчает рассуждения о моделях согласованности памяти.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7217b726fd9359150a03a385521e0a936659d192" translate="yes" xml:space="preserve">
          <source>If you use mutexes to protect all your data, you really shouldn't need to worry. Mutexes have always provided sufficient ordering and visibility guarantees.</source>
          <target state="translated">Если вы используете мьютексы для защиты всех ваших данных,вам действительно не стоит беспокоиться.Мутексы всегда обеспечивали достаточную гарантию заказа и видимости.</target>
        </trans-unit>
        <trans-unit id="e79392e298c7995c33512b2d46cc65f4371d276e" translate="yes" xml:space="preserve">
          <source>In C++11 memory model, a similar mechanism (the acquire-release consistency model) is used to establish these &lt;strong&gt;&lt;em&gt;local causality relations&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В модели памяти C ++ 11 аналогичный механизм (модель согласованности получения-выпуска) используется для установления этих &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;локальных причинно-следственных связей&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="262aafb7f2b604061a913423a9ba782f8c49b7c8" translate="yes" xml:space="preserve">
          <source>In relativity, some order is restored to the seemingly chaotic picture of partially ordered events, since the only temporal ordering that all observers agree on is the ordering among &amp;ldquo;timelike&amp;rdquo; events (i.e., those events that are in principle connectible by any particle going slower than the speed of light in a vacuum). Only the timelike related events are invariantly ordered.
&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;Time in Physics, Craig Callender&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В теории относительности некоторый порядок восстанавливается в, казалось бы, хаотической картине частично упорядоченных событий, поскольку единственное временное упорядочение, с которым согласны все наблюдатели, это упорядочение среди &amp;laquo;подобных времени&amp;raquo; событий (то есть тех событий, которые в принципе связаны с любой частицей, движущейся медленнее чем скорость света в вакууме). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Только связанные с временем события инвариантно упорядочены. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Время в физике, Крейг Каллендер&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ec3ce667f63e7bf2272ca76f9d4e2f94f0cc855" translate="yes" xml:space="preserve">
          <source>In relaxed memory models, each thread will slice up address-space-time in its own way, the only restriction being that slices of each thread shall not cross each other because all threads must agree on the history of every individual memory location (of course, slices of different threads may, and will, cross each other). There is no universal way to slice it up (no privileged foliation of address-space-time). Slices do not have to be planar (or linear). They can be curved and this is what can make a thread read values written by another thread out of the order they were written in. Histories of different memory locations may slide (or get stretched) arbitrarily relative to each other &lt;strong&gt;&lt;em&gt;when viewed by any particular thread&lt;/em&gt;&lt;/strong&gt;. Each thread will have a different sense of which events (or, equivalently, memory values) are simultaneous. The set of events (or memory values) that are simultaneous to one thread are not simultaneous to another. Thus, in a relaxed memory model, all threads still observe the same history (i.e., sequence of values) for each memory location. But they may observe different memory images (i.e., combinations of values of all memory locations). Even if two different memory locations are written by the same thread in sequence, the two newly written values may be observed in different order by other threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В моделях с расслабленной памятью каждый поток будет разделять адресное пространство-время по-своему, единственное ограничение состоит в том, что срезы каждого потока не должны пересекаться друг с другом, потому что все потоки должны согласовать историю каждой отдельной области памяти (конечно, , кусочки разных нитей могут пересекаться друг с другом). Не существует универсального способа его разрезать (нет привилегированного расслоения адрес-пространство-время). Ломтики не должны быть плоскими (или линейными). Они могут быть изогнуты, и это может заставить поток читать значения, записанные другим потоком, в том порядке, в котором они были записаны. Истории различных областей памяти могут произвольно скользить (или растягиваться) относительно друг друга &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;при просмотре любым конкретным потоком.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, Каждый поток будет по-разному понимать, какие события (или, что эквивалентно, значения памяти) являются одновременными. Набор событий (или значений памяти), которые являются одновременными для одного потока, не являются одновременными для другого. Таким образом, в модели с расслабленной памятью все потоки все еще наблюдают одну и ту же историю (то есть последовательность значений) для каждой ячейки памяти. Но они могут наблюдать разные образы памяти (т. Е. Комбинации значений всех областей памяти). Даже если две разные ячейки памяти записаны одним и тем же потоком последовательно, два вновь записанных значения могут наблюдаться в другом порядке другими потоками.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7b6248a1c3792a0a57715e16d30ffb4cda796" translate="yes" xml:space="preserve">
          <source>Interestingly, Microsoft compilers for C++ have acquire / release semantics for volatile which is a C++ extension to deal with the lack of a memory model in C++ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&lt;/a&gt;. However, given that Windows runs on x86 / x64 only, that's not saying much (Intel and AMD memory models make it easy and efficient to implement acquire / release semantics in a language).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Интересно, что компиляторы Microsoft для C ++ имеют семантику приобретения / выпуска для volatile, которое является расширением C ++ для решения проблемы отсутствия модели памяти в C ++ &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs .80) .aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако, учитывая, что Windows работает только на x86 / x64, это мало что говорит (модели памяти Intel и AMD позволяют легко и эффективно реализовать семантику получения / выпуска на языке).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b69141b6b87da624d79fe320205b2eafd77d0cd" translate="yes" xml:space="preserve">
          <source>It is also not sufficient to make them &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; and access them with &lt;code&gt;memory_order_relaxed&lt;/code&gt;.  The reason for this is that the reads of seq (in &lt;code&gt;reader()&lt;/code&gt;) only have &lt;em&gt;acquire&lt;/em&gt; semantics.  In simple terms, if X and Y are memory accesses, X precedes Y, X is not an acquire or release, and Y is an acquire, then the compiler can reorder Y before X.  If Y was the second read of seq, and X was a read of data, such a reordering would break the lock implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Также недостаточно сделать их &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и получить к ним доступ с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Причина этого заключается в том, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что читает НомерСтарт (в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) только &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ACQuire&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; семантика. Проще говоря, если X и Y являются обращениями к памяти, X предшествует Y, X не является приобретением или выпуском, а Y является приобретением, то компилятор может изменить порядок Y до X. Если Y был вторым чтением seq, и X при чтении данных такое переупорядочение нарушило бы реализацию блокировки.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4cb6b422f1ed052e081abd1a922b9c939b53705" translate="yes" xml:space="preserve">
          <source>It means that the standard now defines multi-threading, and it defines what happens in the context of multiple threads. Of course, people used varying implementations, but that's like asking why we should have a &lt;code&gt;std::string&lt;/code&gt; when we could all be using a home-rolled &lt;code&gt;string&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что стандарт теперь определяет многопоточность и определяет, что происходит в контексте нескольких потоков. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, люди использовали разные реализации, но это все равно, что спрашивать, почему у нас должен быть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда мы все можем использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; home-roll &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf7bf69c37f5d8acf1f675cbf5d973de38aee0ad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s view the histories of all memory locations in a space-time diagram in which the horizontal axis represents the address space (i.e., each memory location is represented by a point on that axis) and the vertical axis represents time (we will see that, in general, there is not a universal notion of time). The history of values held by each memory location is, therefore, represented by a vertical column at that memory address. Each value change is due to one of the threads writing a new value to that location. By a &lt;strong&gt;&lt;em&gt;memory image&lt;/em&gt;&lt;/strong&gt;, we will mean the aggregate/combination of values of all memory locations observable &lt;strong&gt;&lt;em&gt;at a particular time&lt;/em&gt;&lt;/strong&gt; by &lt;strong&gt;&lt;em&gt;a particular thread&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Давайте посмотрим историю всех областей памяти на диаграмме пространства-времени, в которой горизонтальная ось представляет адресное пространство (т. Е. Каждая область памяти представлена ​​точкой на этой оси), а вертикальная ось представляет время (мы увидим, что в общем нет единого понятия времени). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому история значений, хранящихся в каждой ячейке памяти, представлена ​​вертикальным столбцом по этому адресу памяти. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каждое изменение значения происходит из-за того, что один из потоков записывает новое значение в это место. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;образу памяти&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , мы будем понимать совокупность / сочетание значений всех ячеек памяти , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;наблюдаемых &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в конкретный момент времени&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;определенной теме&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5038877da11870fb6cdddb43d3f02bea0be31a6c" translate="yes" xml:space="preserve">
          <source>Meaning that these language definitions make no sense at all as no logical method to mix these two approaches. In particular, destruction of a mutex or atomic variable is not well defined.</source>
          <target state="translated">Это означает,что эти языковые определения вообще не имеют смысла,так как не существует логического метода смешивания этих двух подходов.В частности,уничтожение мьютекса или атомной переменной не имеет четкого определения.</target>
        </trans-unit>
        <trans-unit id="fc353f0c4cd5ae6fd4f656b568ee12c3c0fe26db" translate="yes" xml:space="preserve">
          <source>Now they are half defined by an execution trace of a program, and half a posteriori by many orderings on synchronisation objects.</source>
          <target state="translated">Теперь они наполовину определяются трассой выполнения программы,наполовину апостериори-множеством ордеров на объектах синхронизации.</target>
        </trans-unit>
        <trans-unit id="a9fb8f5a58585401803bbffc20531bf50cb296b8" translate="yes" xml:space="preserve">
          <source>Now things get much more interesting.  First of all, the behavior here is &lt;em&gt;defined&lt;/em&gt;.  Thread 2 could now print &lt;code&gt;0 0&lt;/code&gt; (if it runs before Thread 1), &lt;code&gt;37 17&lt;/code&gt; (if it runs after Thread 1), or &lt;code&gt;0 17&lt;/code&gt; (if it runs after Thread 1 assigns to x but before it assigns to y).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь все становится намного интереснее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Прежде всего, поведение здесь &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;определено&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поток 2 теперь может печатать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (если он выполняется до потока 1), &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (если он выполняется после потока 1) или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (если он выполняется после того, как поток 1 назначает x, но до того, как он назначает y).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8c1321d1abad5b016bf122fc4fda3ae6e01ace9" translate="yes" xml:space="preserve">
          <source>Now, if you used atomics, or lock-free algorithms, you need to think about the memory model. The memory model describes precisely when atomics provide ordering and visibility guarantees, and provides portable fences for hand-coded guarantees.</source>
          <target state="translated">Теперь,если вы использовали атомику или алгоритмы lock-free,вам нужно подумать о модели памяти.Модель памяти точно описывает,когда атомика обеспечивает гарантии заказа и видимости,а также предоставляет портативные ограждения для ручных гарантий.</target>
        </trans-unit>
        <trans-unit id="eee5a298db9fd75c07be2a97a1f2cd772c53c044" translate="yes" xml:space="preserve">
          <source>Now, on a modern CPU, ensuring sequential consistency can be expensive.  In particular, the compiler is likely to emit full-blown memory barriers between every access here.  But if your algorithm can tolerate out-of-order loads and stores; i.e., if it requires atomicity but not ordering; i.e., if it can tolerate &lt;code&gt;37 0&lt;/code&gt; as output from this program, then you can write this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь на современном процессоре обеспечение последовательной согласованности может быть дорогостоящим. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В частности, компилятор, вероятно, будет создавать полноценные барьеры памяти между каждым доступом здесь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но если ваш алгоритм может терпеть неупорядоченные загрузки и хранения; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;т.е. если это требует атомарности, но не упорядоченности; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то есть, если он может терпеть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как вывод из этой программы, то вы можете написать это:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afbc13c7de8832aebd18cbbb2425e879034c8384" translate="yes" xml:space="preserve">
          <source>Of course, if the only outputs you want to see are &lt;code&gt;0 0&lt;/code&gt; or &lt;code&gt;37 17&lt;/code&gt;, you can just wrap a mutex around the original code.  But if you have read this far, I bet you already know how that works, and this answer is already longer than I intended :-).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, если вы хотите видеть только &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вы можете просто обернуть мьютекс вокруг исходного кода. Но если вы прочитали это далеко, держу пари, вы уже знаете, как это работает, и этот ответ уже дольше, чем я предполагал :-).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68874039d4d2159d92f53eba89bd0c6425b0ef3b" translate="yes" xml:space="preserve">
          <source>Of course, you can write multi-threaded code in practice for particular concrete systems &amp;ndash; like pthreads or Windows.  But there is no &lt;em&gt;standard&lt;/em&gt; way to write multi-threaded code for C++98/C++03.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, вы можете написать многопоточный код на практике для конкретных конкретных систем, таких как pthreads или Windows. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но не существует &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;стандартного&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; способа написания многопоточного кода для C ++ 98 / C ++ 03.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8435b89912ba1ee2404f40a7e7f7c76f17be4d3" translate="yes" xml:space="preserve">
          <source>Optimizations, Races, and the Memory Model</source>
          <target state="translated">Оптимизации,гонки и модель памяти</target>
        </trans-unit>
        <trans-unit id="cc6f83f22e321f881624f0112b2350e6a011d9b4" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; How: Mutexes, Atomics, and/or Fences</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Порядок - Как: Мьютексы, Атомика и / или Заборы&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d394933e2ba8b9e6307eee9284401ab051f6b9a" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; What: Acquire and Release</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Заказ - что: приобретать и выпускать&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bfcf5ca2e968cb080e4e46edc82078a505a9d92" translate="yes" xml:space="preserve">
          <source>Other Restrictions on Compilers and Hardware</source>
          <target state="translated">Другие ограничения на компиляторы и аппаратное обеспечение</target>
        </trans-unit>
        <trans-unit id="dd65ea6941c8d670b393810b2c47552d6cf25df8" translate="yes" xml:space="preserve">
          <source>Previously, atomics would be done using compiler intrinsics, or some higher level library. Fences would have been done using CPU-specific instructions (memory barriers).</source>
          <target state="translated">Раньше атомика делалась с использованием intrinsics компилятора или какой-нибудь библиотеки более высокого уровня.Заборы должны были выполняться с использованием специфических для ЦПУ инструкций (барьеров памяти).</target>
        </trans-unit>
        <trans-unit id="2e56b625d9ce23edadcdce014336b90a101f8934" translate="yes" xml:space="preserve">
          <source>Quoting from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Цитата из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Учебник по согласованности памяти и согласованности кэша&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb9db0f94440715855f11a33ea0a95909964dfda" translate="yes" xml:space="preserve">
          <source>Readers familiar with Einstein&amp;rsquo;s &lt;strong&gt;Special Theory of Relativity&lt;/strong&gt; will notice what I am alluding to. Translating Minkowski&amp;rsquo;s words into the memory models realm: address space and time are shadows of address-space-time. In this case, each observer (i.e., thread) will project shadows of events (i.e., memory stores/loads) onto his own world-line (i.e., his time axis) and his own plane of simultaneity (his address-space axis). Threads in the C++11 memory model correspond to &lt;strong&gt;&lt;em&gt;observers&lt;/em&gt;&lt;/strong&gt; that are moving relative to each other in special relativity. Sequential consistency corresponds to the &lt;strong&gt;Galilean space-time&lt;/strong&gt; (i.e., all observers agree on one absolute order of events and a global sense of simultaneity).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Читатели, знакомые со &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Специальной теорией относительности Эйнштейна&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , заметят то, на что я намекаю. Перевод слов Минковского в царство моделей памяти: адресное пространство и время являются тенями адресного пространства-времени. В этом случае каждый наблюдатель (т. Е. Поток) будет проецировать тени событий (т. Е. Память хранит / загружает) на свою собственную мировую линию (т. Е. На свою временную ось) и свою собственную плоскость одновременности (свою ось адресного пространства). , Потоки в модели памяти C ++ 11 соответствуют &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;наблюдателям&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которые движутся относительно друг друга в специальной теории относительности. Последовательная согласованность соответствует &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;галилеевому пространству-времени&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (т. Е. Все наблюдатели соглашаются в одном абсолютном порядке событий и общем смысле одновременности).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a133e211f7560a29b9da4d6be92f2a22755b5da2" translate="yes" xml:space="preserve">
          <source>Relaxed Atomics</source>
          <target state="translated">расслабленная атомика</target>
        </trans-unit>
        <trans-unit id="957e61e62046dd3ea5b6cfe1f86136d6473da53c" translate="yes" xml:space="preserve">
          <source>So, bottom line. Mutexes are great, and C++11 standardizes them. But sometimes for performance reasons you want lower-level primitives (e.g., the classic &lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;double-checked locking pattern&lt;/a&gt;).  The new standard provides high-level gadgets like mutexes and condition variables, and it also provides low-level gadgets like atomic types and the various flavors of memory barrier.  So now you can write sophisticated, high-performance concurrent routines entirely within the language specified by the standard, and you can be certain your code will compile and run unchanged on both today's systems and tomorrow's.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, суть. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мьютексы великолепны, и C ++ 11 их стандартизирует. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но иногда по соображениям производительности вам нужны низкоуровневые примитивы (например, классический &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;шаблон блокировки с двойной проверкой&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Новый стандарт предоставляет высокоуровневые гаджеты, такие как мьютексы и условные переменные, а также низкоуровневые гаджеты, такие как атомарные типы и различные варианты барьера памяти. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что теперь вы можете писать сложные, высокопроизводительные параллельные процедуры полностью на языке, указанном в стандарте, и вы можете быть уверены, что ваш код будет компилироваться и выполняться без изменений как в сегодняшних, так и в завтрашних системах.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76ca6da28f8d79dbdb145dfa98920e0946014d84" translate="yes" xml:space="preserve">
          <source>Store-store reordering may happen if a core has a non-FIFO write buffer that lets stores depart in a different order than the order in which they entered. This might occur if the first store misses in the cache while the second hits or if the second store can coalesce with an earlier store (i.e., before the first store). Load-load reordering may also happen on dynamically-scheduled cores that execute instructions out of program order. That can behave the same as reordering stores on another core (Can you come up with an example interleaving between two threads?). Reordering an earlier load with a later store (a load-store reordering) can cause many incorrect behaviors, such as loading a value after releasing the lock that protects it (if the store is the unlock operation). Note that store-load reorderings may also arise due to local bypassing in the commonly implemented FIFO write buffer, even with a core that executes all instructions in program order.</source>
          <target state="translated">Переупорядочивание магазинов может произойти,если ядро имеет буфер записи,отличный от буфера записи FIFO,который позволяет магазинам отправляться в порядке,отличном от того,в каком они были введены.Это может произойти,если первый магазин пропустит в кэше во время второго попадания,или если второй магазин может объединиться с более ранним магазином (т.е.до первого магазина).Переупорядочивание нагрузки также может происходить на динамически планируемых ядрах,которые выполняют инструкции вне порядка программы.Это может вести себя так же,как и переупорядочивание хранилищ на другом ядре (Можете придумать пример чередования между двумя потоками?).Переупорядочивание более ранней загрузки с более поздним хранилищем (переупорядочивание хранилища)может привести к многочисленным некорректным действиям,таким как загрузка значения после освобождения защищающего его замка (если хранилище является операцией разблокировки).Обратите внимание,что переупорядочивание загрузки магазина также может возникать из-за локального обхода в общедоступном буфере записи FIFO,даже если ядро выполняет все инструкции в программном порядке.</target>
        </trans-unit>
        <trans-unit id="452c86d05004baf5f9579835c1ee31f42e9f5ebb" translate="yes" xml:space="preserve">
          <source>That global memory order can vary from one run of the program to another and may not be known beforehand. The characteristic feature of SC is the set of horizontal slices in the address-space-time diagram representing &lt;strong&gt;&lt;em&gt;planes of simultaneity&lt;/em&gt;&lt;/strong&gt; (i.e., memory images). On a given plane, all of its events (or memory values) are simultaneous. There is a notion of &lt;em&gt;Absolute Time&lt;/em&gt;, in which all threads agree on which memory values are simultaneous. In SC, at every time instant, there is only one memory image shared by all threads. That's, at every instant of time, all processors agree on the memory image (i.e., the aggregate content of memory). Not only does this imply that all threads view the same sequence of values for all memory locations, but also that all processors observe the same &lt;em&gt;combinations of values&lt;/em&gt; of all variables. This is the same as saying all memory operations (on all memory locations) are observed in the same total order by all threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот глобальный порядок памяти может варьироваться от одного запуска программы к другому и может быть неизвестен заранее. Характерной особенностью SC является набор горизонтальных срезов на диаграмме адрес-пространство-время, представляющих &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;плоскости одновременности&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (т. Е. Изображения памяти). На данной плоскости все его события (или значения памяти) являются одновременными. Существует понятие &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;абсолютного времени&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , в котором все потоки соглашаются, какие значения памяти являются одновременными. В SC в каждый момент времени существует только один образ памяти, общий для всех потоков. То есть в каждый момент времени все процессоры согласовывают образ памяти (т. Е. Совокупное содержимое памяти). Это означает не только то, что все потоки просматривают одинаковую последовательность значений для всех областей памяти, но и то, что все процессоры наблюдают одинаково&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;комбинации значений&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; всех переменных. Это то же самое, что сказать, что все операции с памятью (во всех ячейках памяти) наблюдаются в одном и том же общем порядке всеми потоками.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d61648d21c81fd8a8c43e5576aa0e6b82a4218f" translate="yes" xml:space="preserve">
          <source>The C++ specification does not make reference to any particular compiler, operating system, or CPU.  It makes reference to an &lt;em&gt;abstract machine&lt;/em&gt; that is a generalization of actual systems.  In the Language Lawyer world, the job of the programmer is to write code for the abstract machine; the job of the compiler is to actualize that code on a concrete machine.  By coding rigidly to the spec, you can be certain that your code will compile and run without modification on any system with a compliant C++ compiler, whether today or 50 years from now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Спецификация C ++ не содержит ссылки на какой-либо конкретный компилятор, операционную систему или процессор. Он ссылается на &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;абстрактную машину,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которая является обобщением реальных систем. В мире Language Lawyer работа программиста заключается в написании кода для абстрактной машины; Задача компилятора - реализовать этот код на конкретной машине. Жестко программируя спецификацию, вы можете быть уверены, что ваш код будет компилироваться и выполняться без изменений в любой системе с совместимым компилятором C ++, будь то сегодня или через 50 лет.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d29c58cddb456581d9728a1ab2e5337bca78fb3" translate="yes" xml:space="preserve">
          <source>The above answers get at the most fundamental aspects of the C++ memory model.  In practice, most uses of &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &quot;just work&quot;, at least until the programmer over-optimizes (e.g., by trying to relax too many things).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Приведенные выше ответы касаются самых фундаментальных аспектов модели памяти C ++. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На практике большинство применений &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;laquo;просто работают&amp;raquo;, по крайней мере, пока программист не выполнит чрезмерную оптимизацию (например, пытаясь ослабить слишком много вещей).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7d00aae881b6e2acf7384c58de1730263886b2d" translate="yes" xml:space="preserve">
          <source>The abstract machine in C++11 is multi-threaded by design.  It also has a well-defined &lt;em&gt;memory model&lt;/em&gt;; that is, it says what the compiler may and may not do when it comes to accessing memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Абстрактная машина в C ++ 11 является многопоточной по своему дизайну. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он также имеет четко определенную &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;модель памяти&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то есть он говорит, что компилятор может и не может делать, когда дело доходит до доступа к памяти.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7f894cea908d237d3941c58a3365a1963366b6e" translate="yes" xml:space="preserve">
          <source>The abstract machine in the C++98/C++03 specification is fundamentally single-threaded.  So it is not possible to write multi-threaded C++ code that is &quot;fully portable&quot; with respect to the spec.  The spec does not even say anything about the &lt;em&gt;atomicity&lt;/em&gt; of memory loads and stores or the &lt;em&gt;order&lt;/em&gt; in which loads and stores might happen, never mind things like mutexes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Абстрактная машина в спецификации C ++ 98 / C ++ 03 принципиально однопоточная. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому невозможно написать многопоточный код C ++, который является &amp;laquo;полностью переносимым&amp;raquo; по отношению к спецификации. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Спецификация даже не говорит ничего об &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;атомарности&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; загрузки и хранения памяти или о &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;порядке,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в котором могут происходить загрузки и хранения, не &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;говоря уже о &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;мьютексах.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4baedfd0f1527134631c5de1c75f35afd5945f2" translate="yes" xml:space="preserve">
          <source>The intuitive (and most restrictive) memory model is sequential consistency (SC) in which a multithreaded execution should look like an interleaving of the sequential executions of each constituent thread, as if the threads were time-multiplexed on a single-core processor.</source>
          <target state="translated">Интуитивно понятной (и наиболее ограничительной)моделью памяти является последовательная согласованность (SC),при которой многопоточное выполнение должно выглядеть как чередование последовательных запусков каждого составного потока,как если бы потоки были многопоточными на одноядерном процессоре.</target>
        </trans-unit>
        <trans-unit id="754d4bff03e3971b47d96374564e1cbbaae1e141" translate="yes" xml:space="preserve">
          <source>The last issue is that it might be unnatural to make the &lt;code&gt;data&lt;/code&gt; variables atomic.  If you can't in your code, then you need to be very careful, because casting from non-atomic to atomic is only legal for primitive types.  C++20 is supposed to add &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt;, which will make this problem easier to resolve.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Последняя проблема заключается в том, что неестественно делать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;переменные &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; атомарными. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не можете сделать это в своем коде, тогда вам нужно быть очень осторожным, потому что приведение от неатомарного к атомарному разрешено только для примитивных типов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C ++ 20 предполагается добавить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что облегчит решение этой проблемы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfd6846aacd447221a1a226955bb117560edf61a" translate="yes" xml:space="preserve">
          <source>The memory model means that C++ code
  now has a standardized library to call
  regardless of who made the compiler
  and on what platform it's running.
  There's a standard way to control how
  different threads talk to the
  processor's memory.</source>
          <target state="translated">Модель памяти означает,что Си++код теперь имеет стандартизированную библиотеку для вызова вне зависимости от того,кто создал компилятор и на какой платформе он запущен.Существует стандартный способ управления тем,как различные потоки взаимодействуют с памятью процессора.</target>
        </trans-unit>
        <trans-unit id="0e82744a21c2c2bfb15618db64d694bdd7c9e7e9" translate="yes" xml:space="preserve">
          <source>The more modern the CPU, the more likely this is to be faster than the previous example.</source>
          <target state="translated">Чем современнее процессор,тем больше вероятность того,что он будет быстрее,чем в предыдущем примере.</target>
        </trans-unit>
        <trans-unit id="1f139b606c7fb2fc6086b230c6282ff5ce683f53" translate="yes" xml:space="preserve">
          <source>The paper gives a few solutions.  The one with the best performance today is probably the one that uses an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_relaxed&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; the second read of the seqlock.  In the paper, it's Figure 6.  I'm not reproducing the code here, because anyone who has read this far really ought to read the paper.  It is more precise and complete than this post.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В статье дается несколько решений. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вероятно, лучшая производительность сегодня - та, которая использует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_thread_fence&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перед&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вторым чтением seqlock. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В статье это рисунок 6. Я не воспроизводю код здесь, потому что любой, кто прочитал это далеко, действительно должен прочитать статью. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он более точный и полный, чем этот пост.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8ce878fb4b44eaa5f2ed3bf4b3939bc5a23cc2b" translate="yes" xml:space="preserve">
          <source>The resemblance between memory models and special relativity stems from the fact that both define a partially-ordered set of events, often called a causal set. Some events (i.e., memory stores) can affect (but not be affected by) other events. A C++11 thread (or observer in physics) is no more than a chain (i.e., a totally ordered set) of events (e.g., memory loads and stores to possibly different addresses).</source>
          <target state="translated">Сходство между моделями памяти и особой относительности связано с тем,что обе модели определяют частично упорядоченный набор событий,часто называемый причинно-следственным набором.Некоторые события (т.е.хранилища памяти)могут влиять (но не могут быть затронуты)на другие события.Поток С++11 (или наблюдатель в физике)-это не более чем цепочка (т.е.полностью упорядоченное множество)событий (например,загрузка и хранение памяти по возможно разным адресам).</target>
        </trans-unit>
        <trans-unit id="88614ce284b9f9ee72002ba72a19fbcc1fb2fe6e" translate="yes" xml:space="preserve">
          <source>The talk doesn't elaborate on the API, but rather on the reasoning, background, under the hood and behind the scenes (did you know relaxed semantics were added to the standard only because POWER and ARM do not support synchronized load efficiently?).</source>
          <target state="translated">В разговоре речь идет не об API,а о рассуждениях,фонах,под капотом и за кулисами (знаете ли вы,что расслабленная семантика была добавлена к стандарту только потому,что POWER и ARM не поддерживают синхронизированную нагрузку эффективно?)</target>
        </trans-unit>
        <trans-unit id="46e71907ae6df91d5f8c4646edd42cd31a4d2600" translate="yes" xml:space="preserve">
          <source>There is one place where mistakes are still common: &lt;em&gt;sequence locks&lt;/em&gt;.  There is an excellent and easy-to-read discussion of the challenges at &lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/a&gt;.  Sequence locks are appealing because the reader avoids writing to the lock word.  The following code is based on Figure 1 of the above technical report, and it highlights the challenges when implementing sequence locks in C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть одно место, где ошибки все еще распространены: &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;блокировки последовательности&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; проведено отличное и удобное для чтения обсуждение проблем &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Блокировки последовательности привлекательны, потому что читатель избегает записи в слово блокировки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Следующий код основан на рисунке 1 приведенного выше технического отчета и освещает проблемы, возникающие при реализации блокировок последовательностей в C ++:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="961c454b5b699e3c67051c83eb5d379453c92717" translate="yes" xml:space="preserve">
          <source>This takes us back to the ordered loads and stores &amp;ndash; so &lt;code&gt;37 0&lt;/code&gt; is no longer a possible output &amp;ndash; but it does so with minimal overhead.  (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это возвращает нас к заказанным нагрузкам и хранилищам - так что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше не является возможным выходом - но это происходит с минимальными издержками. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(В этом тривиальном примере результат совпадает с последовательной последовательной последовательностью; в более крупной программе это не так).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e039b9566e8dfbf0f2a3944c91a446a0d3877578" translate="yes" xml:space="preserve">
          <source>To provide a definition of memory consistency and a motivation for abandoning SC, I will quote from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы дать определение согласованности памяти и мотивации отказа от SC, я приведу цитату из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Учебника по согласованию памяти и согласованности кэша&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf70e99ebffe9e92e5be11ffc6e48ebef4aad770" translate="yes" xml:space="preserve">
          <source>To summarize: even if you think you understand the C++ memory model, you should be very careful before rolling your own sequence locks.</source>
          <target state="translated">Подводя итог:даже если вы думаете,что понимаете модель памяти C++,вы должны быть очень осторожны перед тем,как выкатить свои собственные блокировки последовательности.</target>
        </trans-unit>
        <trans-unit id="5f2312cd34bd31141d0b81cd0bd16779840debfa" translate="yes" xml:space="preserve">
          <source>Under C++11, the result is Undefined Behavior, because loads and stores need not be atomic in general.  Which may not seem like much of an improvement...  And by itself, it's not.</source>
          <target state="translated">При C++11 результат-неопределенное поведение,потому что нагрузки и запасы не обязательно должны быть атомными в целом.Что может показаться несущественным улучшением...И само по себе это не так.</target>
        </trans-unit>
        <trans-unit id="b9f7556c864ccbfde77ebfd4adde349b5488e4fa" translate="yes" xml:space="preserve">
          <source>Under C++98/C++03, this is not even Undefined Behavior; the question itself is &lt;em&gt;meaningless&lt;/em&gt; because the standard does not contemplate anything called a &quot;thread&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C ++ 98 / C ++ 03 это даже не неопределенное поведение; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сам вопрос не имеет &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;смысла,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потому что стандарт не предусматривает ничего, что называется &amp;laquo;нить&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ce2b632d1c58188c735ed2a0e6024043931901f" translate="yes" xml:space="preserve">
          <source>Unlike consistency, &lt;strong&gt;&lt;em&gt;cache coherence&lt;/em&gt;&lt;/strong&gt; is neither visible to software nor required. Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system. Correct coherence ensures that a programmer cannot determine whether and where a system has caches by analyzing the results of loads and stores. This is because correct coherence ensures that the caches never enable new or different &lt;strong&gt;&lt;em&gt;functional&lt;/em&gt;&lt;/strong&gt; behavior (programmers may still be able to infer likely cache structure using &lt;strong&gt;&lt;em&gt;timing&lt;/em&gt;&lt;/strong&gt; information). The main purpose of cache coherence protocols is maintaining the single-writer-multiple-readers (SWMR) invariant for every memory location.
  An important distinction between coherence and consistency is that coherence is specified on a &lt;strong&gt;&lt;em&gt;per-memory location basis&lt;/em&gt;&lt;/strong&gt;, whereas consistency is specified with respect to &lt;strong&gt;&lt;em&gt;all&lt;/em&gt;&lt;/strong&gt; memory locations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В отличие от согласованности, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;согласованность кэша&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не видна программному обеспечению и не требуется. Согласованность стремится сделать кэши системы с общей памятью такими же функционально невидимыми, как кэши в одноядерной системе. Правильная согласованность гарантирует, что программист не сможет определить, есть ли у системы кеш-память, и анализировать результаты загрузки и сохранения. Это связано с тем, что правильная согласованность гарантирует, что кэши никогда не разрешают новое или другое &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функциональное&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поведение (программисты могут по-прежнему иметь возможность определять вероятную структуру кэша с использованием &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синхронизации&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Информация). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Основное назначение протоколов когерентности кэша заключается в поддержании инварианта &amp;laquo;единица записи-несколько читателей&amp;raquo; (SWMR) для каждой области памяти. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Важное различие между согласованностью и согласованностью заключается в том, что согласованность указывается для &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;каждой ячейки памяти&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , в то время как согласованность указывается для &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;всех&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; областей памяти.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfacfcd81cfcca293eba3cc7493531d81a4a1b4d" translate="yes" xml:space="preserve">
          <source>Very importantly, locks (and concurrency semantics with locking) are typically implemented in a cross platform way... So if you are using standard locks in a multithreaded program with no data races then you &lt;strong&gt;don't have to worry about cross platform memory models&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Очень важно, что блокировки (и семантика параллелизма с блокировкой) обычно реализуются кросс-платформенным способом ... Так что, если вы используете стандартные блокировки в многопоточной программе без гонок данных, вам &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не нужно беспокоиться о кроссплатформенных моделях памяти&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e4a2ca5a3d05ddfbe2b56ccb6104a75cae606ef" translate="yes" xml:space="preserve">
          <source>Well, I can &lt;em&gt;memorize&lt;/em&gt; this and similar paragraphs available online (as I've had my own memory model since birth :P) and can even post as an answer to questions asked by others, but to be honest, I don't exactly understand this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что ж, я могу &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;запомнить&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; этот и подобные параграфы, доступные онлайн (так как у меня была своя собственная модель памяти с рождения: P), и даже могу публиковать в качестве ответа на вопросы, заданные другими, но, честно говоря, я не совсем понимаю этот.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="956fcc4400c935b51349b1224fcb0216fed90fc4" translate="yes" xml:space="preserve">
          <source>What it cannot print is &lt;code&gt;37 0&lt;/code&gt;, because the default mode for atomic loads/stores in C++11 is to enforce &lt;em&gt;sequential consistency&lt;/em&gt;.  This just means all loads and stores must be &quot;as if&quot; they happened in the order you wrote them within each thread, while operations among threads can be interleaved however the system likes.  So the default behavior of atomics provides both &lt;em&gt;atomicity&lt;/em&gt; and &lt;em&gt;ordering&lt;/em&gt; for loads and stores.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он не может напечатать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , потому что режим по умолчанию для атомарных загрузок / хранилищ в C ++ 11 - обеспечить &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;последовательную согласованность&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Это просто означает, что все загрузки и хранилища должны быть &amp;laquo;такими, как если бы&amp;raquo; происходили в том порядке, в котором вы их записали в каждом потоке, а операции между потоками могут чередоваться, как нравится системе. Таким образом, стандартное поведение атома обеспечивает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;атомарность&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;порядок&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; загрузки и хранения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fd897db0b1892f92d3ac2bb9df198d5229ab212" translate="yes" xml:space="preserve">
          <source>What might Thread 2 output?</source>
          <target state="translated">Что может выдать Резьба 2?</target>
        </trans-unit>
        <trans-unit id="1798b5cddeecf3effcaf30a3ce667c57f5b3451d" translate="yes" xml:space="preserve">
          <source>When you're talking about POSIX threads or Windows threads, then this is a bit of an illusion as actually you're talking about x86 threads, as it's a hardware function to run concurrently. The C++0x memory model makes guarantees, whether you're on x86, or ARM, or &lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;MIPS&lt;/a&gt;, or anything else you can come up with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вы говорите о потоках POSIX или Windows, то это немного иллюзия, так как на самом деле вы говорите о потоках x86, поскольку это аппаратная функция для одновременного запуска. Модель памяти C ++ 0x дает гарантии, будь то x86, ARM, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MIPS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или что-то еще, что вы можете придумать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76cbbb6015ca76bb55e457fa170621f939633ebe" translate="yes" xml:space="preserve">
          <source>[Picture from Wikipedia]</source>
          <target state="translated">[Фотография из Википедии]</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
