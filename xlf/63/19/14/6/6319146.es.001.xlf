<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/6319146">
    <body>
      <group id="6319146">
        <trans-unit id="73df4e1cfb97a0cf2c29a8c07e2bb86731b5d146" translate="yes" xml:space="preserve">
          <source>&quot;When you are talking about splitting
  [code] across different cores that's
  in the standard, we are talking about
  the memory model. We are going to
  optimize it without breaking the
  following assumptions people are going
  to make in the code,&quot; &lt;strong&gt;Sutter&lt;/strong&gt; said.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Cuando se habla de dividir [el c&amp;oacute;digo] en diferentes n&amp;uacute;cleos que est&amp;aacute;n en el est&amp;aacute;ndar, estamos hablando del modelo de memoria. Vamos a optimizarlo sin romper los siguientes supuestos que la gente har&amp;aacute; en el c&amp;oacute;digo&quot;, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dijo &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sutter&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d15a3a1c7c247d44171f5a6070b968d22cecb393" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;This article&lt;/a&gt; (by &lt;strong&gt;Gavin Clarke&lt;/strong&gt; who quotes &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/strong&gt;) says that,</source>
          <target state="translated">&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este art&amp;iacute;culo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (por &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Gavin Clarke,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; quien cita a &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Herb Sutter&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) dice que,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="731c13310aa9d76029890ec2d9fe270b4e77f4e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Relaxed&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;weak&lt;/em&gt;&lt;/strong&gt; memory consistency models are motivated by the fact that most memory orderings in strong models are unnecessary. If a thread updates ten data items and then a synchronization flag, programmers usually do not care if the data items are updated in order with respect to each other but only that all data items are updated before the flag is updated (usually implemented using FENCE instructions). Relaxed models seek to capture this increased ordering flexibility and preserve only the orders that programmers &amp;ldquo;&lt;em&gt;require&lt;/em&gt;&amp;rdquo; to get both higher performance and correctness of SC. For example, in certain architectures, FIFO write buffers are used by each core to hold the results of committed (retired) stores before writing the results to the caches. This optimization enhances performance but violates SC. The write buffer hides the latency of servicing a store miss. Because stores are common, being able to avoid stalling on most of them is an important benefit. For a single-core processor, a write buffer can be made architecturally invisible by ensuring that a load to address A returns the value of the most recent store to A even if one or more stores to A are in the write buffer. This is typically done by either bypassing the value of the most recent store to A to the load from A, where &amp;ldquo;most recent&amp;rdquo; is determined by program order, or by stalling a load of A if a store to A is in the write buffer. When multiple cores are used, each will have its own bypassing write buffer. Without write buffers, the hardware is SC, but with write buffers, it is not, making write buffers architecturally visible in a multicore processor.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; modelos de consistencia de memoria&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; relajada&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; d&amp;eacute;bil&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;aacute;n motivados por el hecho de que la mayor&amp;iacute;a de los ordenamientos de memoria en modelos fuertes son innecesarios. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si un subproceso actualiza diez elementos de datos y luego un indicador de sincronizaci&amp;oacute;n, a los programadores generalmente no les importa si los elementos de datos se actualizan uno con respecto al otro, sino solo que todos los elementos de datos se actualizan antes de que se actualice el indicador (generalmente implementado usando las instrucciones de FENCE ) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los modelos relajados buscan capturar esta mayor flexibilidad de pedidos y preservar solo los pedidos que los programadores &quot;&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; requieren&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Para obtener un mayor rendimiento y correcci&amp;oacute;n de SC. Por ejemplo, en ciertas arquitecturas, cada n&amp;uacute;cleo utiliza las memorias intermedias de escritura FIFO para guardar los resultados de las tiendas comprometidas (retiradas) antes de escribir los resultados en los cach&amp;eacute;s. Esta optimizaci&amp;oacute;n mejora el rendimiento pero viola SC. El b&amp;uacute;fer de escritura oculta la latencia del servicio de una tienda perdida. Debido a que las tiendas son comunes, poder evitar el estancamiento en la mayor&amp;iacute;a de ellas es un beneficio importante. Para un procesador de un solo n&amp;uacute;cleo, un b&amp;uacute;fer de escritura se puede hacer arquitect&amp;oacute;nicamente invisible al garantizar que una carga a la direcci&amp;oacute;n A devuelva el valor del almac&amp;eacute;n m&amp;aacute;s reciente a A, incluso si uno o m&amp;aacute;s almacenes a A est&amp;aacute;n en el b&amp;uacute;fer de escritura. Esto normalmente se hace omitiendo el valor de la tienda m&amp;aacute;s reciente a A a la carga de A, donde &quot;m&amp;aacute;s reciente&quot; se determina por orden de programa,o deteniendo una carga de A si hay un almac&amp;eacute;n en A en el b&amp;uacute;fer de escritura. Cuando se utilizan m&amp;uacute;ltiples n&amp;uacute;cleos, cada uno tendr&amp;aacute; su propio b&amp;uacute;fer de escritura de derivaci&amp;oacute;n. Sin memorias intermedias de escritura, el hardware es SC, pero con las memorias intermedias de escritura, no lo es, lo que hace que las memorias intermedias de escritura sean arquitect&amp;oacute;nicamente visibles en un procesador multin&amp;uacute;cleo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a24014293b7e7f3c3957b75dbba2b33ce19b2765" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is now a multiple-year old question, but being very popular, it's worth mentioning a fantastic resource for learning about the C++11 memory model. I see no point in summing up his talk in order to make this yet another full answer, but given this is the guy who actually wrote the standard, I think it's well worth watching the talk.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta es ahora una pregunta de varios a&amp;ntilde;os, pero siendo muy popular, vale la pena mencionar un recurso fant&amp;aacute;stico para aprender sobre el modelo de memoria C ++ 11. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No veo ning&amp;uacute;n punto en resumir su charla para hacer que esta sea otra respuesta completa, pero dado que este es el tipo que realmente escribi&amp;oacute; el est&amp;aacute;ndar, creo que vale la pena ver la charla.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fea15c028fa16edd68a84950f92fa70a42f3fac8" translate="yes" xml:space="preserve">
          <source>Although to be frank, unless you are an expert and working on some serious low-level code, you should probably stick to mutexes and condition variables.  That's what I intend to do.</source>
          <target state="translated">Aunque para ser franco,a menos que seas un experto y trabajes en algún código de bajo nivel serio,probablemente deberías ceñirte a los mutex y a las variables de condición.Eso es lo que pretendo hacer.</target>
        </trans-unit>
        <trans-unit id="3ad19cd05e2aca3350a1896cdfb856a60997442f" translate="yes" xml:space="preserve">
          <source>As I don't know how the internals of multi-threading work, and what memory model means in general, please help me understand these concepts. :-)</source>
          <target state="translated">Como no sé cómo funcionan los internos del multihilo,y qué significa el modelo de memoria en general,por favor ayúdame a entender estos conceptos.:-)</target>
        </trans-unit>
        <trans-unit id="73edd169fb02675391ad1960b83d93b7512986a3" translate="yes" xml:space="preserve">
          <source>As unintuitive as it seams at first, &lt;code&gt;data1&lt;/code&gt; and &lt;code&gt;data2&lt;/code&gt; need to be &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt;.  If they are not atomic, then they could be read (in &lt;code&gt;reader()&lt;/code&gt;) at the exact same time as they are written (in &lt;code&gt;writer()&lt;/code&gt;).  According to the C++ memory model, this is a race &lt;em&gt;even if &lt;code&gt;reader()&lt;/code&gt; never actually uses the data&lt;/em&gt;.  In addition, if they are not atomic, then the compiler can cache the first read of each value in a register.  Obviously you wouldn't want that... you want to re-read in each iteration of the &lt;code&gt;while&lt;/code&gt; loop in &lt;code&gt;reader()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tan poco intuitivo como parece al principio, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; deben ser &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Si no son at&amp;oacute;micos, entonces podr&amp;iacute;an leerse (en el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) exactamente al mismo tiempo que est&amp;aacute;n escritos (en el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writer()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). De acuerdo con el modelo de memoria C ++, esta es una carrera &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;incluso si el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nunca usa los datos&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Adem&amp;aacute;s, si no son at&amp;oacute;micos, el compilador puede almacenar en cach&amp;eacute; la primera lectura de cada valor en un registro. Obviamente que no le gustar&amp;iacute;a que ... desea volver a leer en cada iteraci&amp;oacute;n del &lt;/font&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de bucle en el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4a622ff9ae0214ed05a333e5d2cd4c3f0640dc8" translate="yes" xml:space="preserve">
          <source>Because cache coherence and memory consistency are sometimes confused, it is instructive to also have this quote:</source>
          <target state="translated">Debido a que la coherencia del caché y la consistencia de la memoria a veces se confunden,es instructivo tener también esta cita:</target>
        </trans-unit>
        <trans-unit id="934437c0109e42d4fd367073bdd77200fe18bf44" translate="yes" xml:space="preserve">
          <source>But with C++11, you can write this:</source>
          <target state="translated">Pero con C++11,puedes escribir esto:</target>
        </trans-unit>
        <trans-unit id="c3419e7bfb7b912c1de58267196ef1715f03d520" translate="yes" xml:space="preserve">
          <source>C and C++ used to be defined by an execution trace of a well formed program.</source>
          <target state="translated">C y C++solían definirse por un rastro de ejecución de un programa bien formado.</target>
        </trans-unit>
        <trans-unit id="f714f1f168010e0e48c54ceb767d70850b43f535" translate="yes" xml:space="preserve">
          <source>C++ programmers used to develop multi-threaded applications even before, so how does it matter if it's POSIX threads, or Windows threads, or C++11 threads? What are the benefits? I want to understand the low-level details.</source>
          <target state="translated">Los programadores de C++solían desarrollar aplicaciones multi-hilo incluso antes,así que,¿qué importa si son hilos POSIX,o hilos de Windows,o hilos C++11? ¿Cuáles son los beneficios? Quiero entender los detalles de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="c804136fc25fd72d45e9ed77db0496ceaaa13a5e" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model, but what exactly does that mean? And how is it going to affect C++ programming?</source>
          <target state="translated">C++11 introdujo un modelo de memoria estandarizada,pero ¿qué significa eso exactamente? ¿Y cómo va a afectar a la programación de C++?</target>
        </trans-unit>
        <trans-unit id="b31ce9265efcb7ae003d188e0fcacad2174b4301" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model. What does it mean? And how is it going to affect C++ programming</source>
          <target state="translated">C++11 introdujo un modelo de memoria estandarizada.¿Qué significa esto? ¿Y cómo va a afectar a la programación de C++</target>
        </trans-unit>
        <trans-unit id="1071914933f07012e3e0261ffb0513754c189cf3" translate="yes" xml:space="preserve">
          <source>Code Gen &amp;amp; Performance: x86/x64, IA64, POWER, ARM</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;digo Gen &amp;amp; Performance: x86 / x64, IA64, POWER, ARM&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70cb8dd903b1de610462040edfa72807d0c75c0f" translate="yes" xml:space="preserve">
          <source>Consider the following example, where a pair of global variables are accessed concurrently by two threads:</source>
          <target state="translated">Consideremos el siguiente ejemplo,en el que un par de variables globales son accedidas simultáneamente por dos hilos:</target>
        </trans-unit>
        <trans-unit id="5e777ba92d2f70816c7b8e0a710d0cd2e088bf50" translate="yes" xml:space="preserve">
          <source>Continuing with our mental picture, the SWMR invariant corresponds to the physical requirement that there be at most one particle located at any one location but there can be an unlimited number of observers of any location.</source>
          <target state="translated">Continuando con nuestra imagen mental,la invariante de la ROE corresponde al requerimiento físico de que haya como máximo una partícula ubicada en cualquier lugar,pero puede haber un número ilimitado de observadores de cualquier lugar.</target>
        </trans-unit>
        <trans-unit id="1ccda8a650443d20e5e10efff7eff75f39de7479" translate="yes" xml:space="preserve">
          <source>Finally, if you just need to keep particular loads and stores in order, you can write:</source>
          <target state="translated">Finalmente,si sólo necesitas mantener en orden determinadas cargas y tiendas,puedes escribir:</target>
        </trans-unit>
        <trans-unit id="95b21e94883bf869fa456f6fee7bcd0aede60da8" translate="yes" xml:space="preserve">
          <source>First, you have to learn to think like a Language Lawyer.</source>
          <target state="translated">Primero,tienes que aprender a pensar como un Abogado del Lenguaje.</target>
        </trans-unit>
        <trans-unit id="f764c87baa07b4d9b69d806e43e35de480f00596" translate="yes" xml:space="preserve">
          <source>For a shared memory machine, the memory consistency model defines the architecturally visible behavior of its memory system. The correctness criterion for a single processor core partitions behavior between &amp;ldquo;&lt;em&gt;one correct result&lt;/em&gt;&amp;rdquo; and &amp;ldquo;&lt;em&gt;many incorrect alternatives&lt;/em&gt;&amp;rdquo;. This is because the processor&amp;rsquo;s architecture mandates that the execution of a thread transforms a given input state into a single well-defined output state, even on an out-of-order core. Shared memory consistency models, however, concern the loads and stores of multiple threads and usually allow &lt;em&gt;many correct executions&lt;/em&gt; while disallowing many (more) incorrect ones. The possibility of multiple correct executions is due to the ISA allowing multiple threads to execute concurrently, often with many possible legal interleavings of instructions from different threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para una m&amp;aacute;quina de memoria compartida, el modelo de consistencia de memoria define el comportamiento arquitect&amp;oacute;nicamente visible de su sistema de memoria. El criterio de correcci&amp;oacute;n para un comportamiento de particiones de n&amp;uacute;cleo de procesador &amp;uacute;nico entre &quot; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un resultado correcto&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; y &quot; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;muchas alternativas incorrectas&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;. Esto se debe a que la arquitectura del procesador exige que la ejecuci&amp;oacute;n de un subproceso transforme un estado de entrada dado en un solo estado de salida bien definido, incluso en un n&amp;uacute;cleo fuera de servicio. Sin embargo, los modelos de coherencia de memoria compartida se refieren a las cargas y almacenes de m&amp;uacute;ltiples subprocesos y generalmente permiten &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;muchas ejecuciones correctas.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mientras que rechaza muchos (m&amp;aacute;s) incorrectos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La posibilidad de m&amp;uacute;ltiples ejecuciones correctas se debe a que la ISA permite que m&amp;uacute;ltiples hilos se ejecuten simult&amp;aacute;neamente, a menudo con muchas posibles entrelazamientos legales de instrucciones de diferentes hilos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3a3531d42219943e36c390c1d09394dda7f26" translate="yes" xml:space="preserve">
          <source>For languages not specifying a memory model, you are writing code for the language &lt;em&gt;and&lt;/em&gt; the memory model specified by the processor architecture. The processor may choose to re-order memory accesses for performance. So, &lt;strong&gt;if your program has data races&lt;/strong&gt; (a data race is when it's possible for multiple cores / hyper-threads to access the same memory concurrently) then your program is not cross platform because of its dependence on the processor memory model. You may refer to the Intel or AMD software manuals to find out how the processors may re-order memory accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para los idiomas que no especifican un modelo de memoria, est&amp;aacute; escribiendo c&amp;oacute;digo para el idioma &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;y&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; el modelo de memoria especificado por la arquitectura del procesador. El procesador puede optar por reordenar los accesos a la memoria para el rendimiento. Entonces, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;si su programa tiene carreras de datos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (una carrera de datos es cuando es posible que m&amp;uacute;ltiples n&amp;uacute;cleos / hiperprocesos accedan simult&amp;aacute;neamente a la misma memoria), entonces su programa no es multiplataforma debido a su dependencia del modelo de memoria del procesador. Puede consultar los manuales del software Intel o AMD para averiguar c&amp;oacute;mo los procesadores pueden reordenar los accesos a la memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ef316ccb8a21361d46e5437050816b42e490adc" translate="yes" xml:space="preserve">
          <source>For more on this stuff, see &lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para m&amp;aacute;s informaci&amp;oacute;n sobre estas cosas, vea &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;esta publicaci&amp;oacute;n de blog&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e122e719b66a5aaf1016dc68677fa81a7da2c2fe" translate="yes" xml:space="preserve">
          <source>Herb Sutter has a three hour long talk about the C++11 memory model titled &quot;atomic&amp;lt;&amp;gt; Weapons&quot;, available on the Channel9 site - &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;part 2&lt;/a&gt;. The talk is pretty technical, and covers the following topics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Herb Sutter tiene una charla de tres horas sobre el modelo de memoria C ++ 11 titulado &quot;Armas at&amp;oacute;micas &amp;lt;&amp;gt;&quot;, disponible en el sitio Channel9 - &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;parte 1&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;parte 2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La charla es bastante t&amp;eacute;cnica y cubre los siguientes temas:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acbd5686848a17d66430beecce776f2956fd0ca0" translate="yes" xml:space="preserve">
          <source>I also get this feeling that the C++11 memory model is somehow related to C++11 multi-threading support, as I often see these two together. If it is, how exactly? Why should they be related?</source>
          <target state="translated">También tengo la sensación de que el modelo de memoria C++11 está relacionado de alguna manera con el soporte de multihilo C++11,ya que a menudo veo estos dos juntos.Si es así,¿cómo exactamente? ¿Por qué deberían estar relacionados?</target>
        </trans-unit>
        <trans-unit id="eb879d24c026ac0b51a220b545aa9383dafc4341" translate="yes" xml:space="preserve">
          <source>I will just give the analogy with which I understand memory consistency models (or memory models, for short). It is inspired by Leslie Lamport's seminal paper &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot;&lt;/a&gt;.
The analogy is apt and has fundamental significance, but may be overkill for many people. However, I hope it provides a mental image (a pictorial representation) that facilitates reasoning about memory consistency models.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo dar&amp;eacute; la analog&amp;iacute;a con la que entiendo los modelos de consistencia de memoria (o modelos de memoria, para abreviar). Est&amp;aacute; inspirado en el art&amp;iacute;culo seminal de Leslie Lamport &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . La analog&amp;iacute;a es adecuada y tiene un significado fundamental, pero puede ser exagerada para muchas personas. Sin embargo, espero que proporcione una imagen mental (una representaci&amp;oacute;n pict&amp;oacute;rica) que facilite el razonamiento sobre los modelos de consistencia de la memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7217b726fd9359150a03a385521e0a936659d192" translate="yes" xml:space="preserve">
          <source>If you use mutexes to protect all your data, you really shouldn't need to worry. Mutexes have always provided sufficient ordering and visibility guarantees.</source>
          <target state="translated">Si usas mutexes para proteger todos tus datos,no deberías preocuparte.Los mutexes siempre han proporcionado suficientes garantías de orden y visibilidad.</target>
        </trans-unit>
        <trans-unit id="e79392e298c7995c33512b2d46cc65f4371d276e" translate="yes" xml:space="preserve">
          <source>In C++11 memory model, a similar mechanism (the acquire-release consistency model) is used to establish these &lt;strong&gt;&lt;em&gt;local causality relations&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En el modelo de memoria C ++ 11, se utiliza un mecanismo similar (el modelo de coherencia de adquisici&amp;oacute;n-liberaci&amp;oacute;n) para establecer estas &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;relaciones de causalidad local&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="262aafb7f2b604061a913423a9ba782f8c49b7c8" translate="yes" xml:space="preserve">
          <source>In relativity, some order is restored to the seemingly chaotic picture of partially ordered events, since the only temporal ordering that all observers agree on is the ordering among &amp;ldquo;timelike&amp;rdquo; events (i.e., those events that are in principle connectible by any particle going slower than the speed of light in a vacuum). Only the timelike related events are invariantly ordered.
&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;Time in Physics, Craig Callender&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En la relatividad, se restablece cierto orden en la imagen aparentemente ca&amp;oacute;tica de eventos parcialmente ordenados, ya que el &amp;uacute;nico ordenamiento temporal en el que todos los observadores acuerdan es el ordenamiento entre eventos &quot;temporales&quot; (es decir, aquellos eventos que en principio son conectables por cualquier part&amp;iacute;cula que se vuelve m&amp;aacute;s lenta) que la velocidad de la luz en el vac&amp;iacute;o). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo los eventos relacionados con el tiempo se ordenan invariablemente. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tiempo en f&amp;iacute;sica, Craig Callender&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ec3ce667f63e7bf2272ca76f9d4e2f94f0cc855" translate="yes" xml:space="preserve">
          <source>In relaxed memory models, each thread will slice up address-space-time in its own way, the only restriction being that slices of each thread shall not cross each other because all threads must agree on the history of every individual memory location (of course, slices of different threads may, and will, cross each other). There is no universal way to slice it up (no privileged foliation of address-space-time). Slices do not have to be planar (or linear). They can be curved and this is what can make a thread read values written by another thread out of the order they were written in. Histories of different memory locations may slide (or get stretched) arbitrarily relative to each other &lt;strong&gt;&lt;em&gt;when viewed by any particular thread&lt;/em&gt;&lt;/strong&gt;. Each thread will have a different sense of which events (or, equivalently, memory values) are simultaneous. The set of events (or memory values) that are simultaneous to one thread are not simultaneous to another. Thus, in a relaxed memory model, all threads still observe the same history (i.e., sequence of values) for each memory location. But they may observe different memory images (i.e., combinations of values of all memory locations). Even if two different memory locations are written by the same thread in sequence, the two newly written values may be observed in different order by other threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En los modelos de memoria relajada, cada subproceso dividir&amp;aacute; la direcci&amp;oacute;n-espacio-tiempo a su manera, la &amp;uacute;nica restricci&amp;oacute;n es que los segmentos de cada subproceso no se cruzar&amp;aacute;n entre s&amp;iacute; porque todos los subprocesos deben coincidir en el historial de cada ubicaci&amp;oacute;n de memoria individual (por supuesto , las rebanadas de diferentes hilos pueden cruzarse y se cruzar&amp;aacute;n entre s&amp;iacute;). No hay una forma universal de dividirlo (no hay una foliaci&amp;oacute;n privilegiada de direcci&amp;oacute;n-espacio-tiempo). Los cortes no tienen que ser planos (o lineales). Pueden ser curvos y esto es lo que puede hacer que un hilo lea los valores escritos por otro hilo fuera del orden en que fueron escritos. Los historiales de diferentes ubicaciones de memoria pueden deslizarse (o estirarse) arbitrariamente entre s&amp;iacute; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cuando son vistos por cualquier hilo particular.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. Cada hilo tendr&amp;aacute; un sentido diferente de qu&amp;eacute; eventos (o, equivalentemente, valores de memoria) son simult&amp;aacute;neos. El conjunto de eventos (o valores de memoria) que son simult&amp;aacute;neos a un hilo no son simult&amp;aacute;neos a otro. Por lo tanto, en un modelo de memoria relajada, todos los hilos siguen observando el mismo historial (es decir, secuencia de valores) para cada ubicaci&amp;oacute;n de memoria. Pero pueden observar diferentes im&amp;aacute;genes de memoria (es decir, combinaciones de valores de todas las ubicaciones de memoria). Incluso si dos ubicaciones de memoria diferentes son escritas por el mismo hilo en secuencia, los dos valores reci&amp;eacute;n escritos pueden ser observados en otro orden por otros hilos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7b6248a1c3792a0a57715e16d30ffb4cda796" translate="yes" xml:space="preserve">
          <source>Interestingly, Microsoft compilers for C++ have acquire / release semantics for volatile which is a C++ extension to deal with the lack of a memory model in C++ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&lt;/a&gt;. However, given that Windows runs on x86 / x64 only, that's not saying much (Intel and AMD memory models make it easy and efficient to implement acquire / release semantics in a language).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Curiosamente, los compiladores de Microsoft para C ++ tienen una sem&amp;aacute;ntica de adquisici&amp;oacute;n / lanzamiento de vol&amp;aacute;til que es una extensi&amp;oacute;n de C ++ para tratar la falta de un modelo de memoria en C ++ &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs .80) .aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, dado que Windows solo se ejecuta en x86 / x64, eso no dice mucho (los modelos de memoria Intel y AMD hacen que sea f&amp;aacute;cil y eficiente implementar la sem&amp;aacute;ntica de adquisici&amp;oacute;n / lanzamiento en un idioma).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b69141b6b87da624d79fe320205b2eafd77d0cd" translate="yes" xml:space="preserve">
          <source>It is also not sufficient to make them &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; and access them with &lt;code&gt;memory_order_relaxed&lt;/code&gt;.  The reason for this is that the reads of seq (in &lt;code&gt;reader()&lt;/code&gt;) only have &lt;em&gt;acquire&lt;/em&gt; semantics.  In simple terms, if X and Y are memory accesses, X precedes Y, X is not an acquire or release, and Y is an acquire, then the compiler can reorder Y before X.  If Y was the second read of seq, and X was a read of data, such a reordering would break the lock implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tampoco es suficiente hacerlos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y acceder a ellos con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . La raz&amp;oacute;n de esto es que las lecturas de seq (en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) solo tienen &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sem&amp;aacute;ntica &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;adquirida&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . En t&amp;eacute;rminos simples, si X e Y son accesos de memoria, X precede a Y, X no es una adquisici&amp;oacute;n o liberaci&amp;oacute;n, e Y es una adquisici&amp;oacute;n, entonces el compilador puede reordenar Y antes de X. Si Y fue la segunda lectura de seq, y X era una lectura de datos, tal reordenamiento romper&amp;iacute;a la implementaci&amp;oacute;n del bloqueo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4cb6b422f1ed052e081abd1a922b9c939b53705" translate="yes" xml:space="preserve">
          <source>It means that the standard now defines multi-threading, and it defines what happens in the context of multiple threads. Of course, people used varying implementations, but that's like asking why we should have a &lt;code&gt;std::string&lt;/code&gt; when we could all be using a home-rolled &lt;code&gt;string&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Significa que el est&amp;aacute;ndar ahora define m&amp;uacute;ltiples subprocesos y define lo que sucede en el contexto de m&amp;uacute;ltiples subprocesos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por supuesto, la gente usaba diferentes implementaciones, pero eso es como preguntar por qu&amp;eacute; deber&amp;iacute;amos tener un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando todos podr&amp;iacute;amos estar usando una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;clase de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; inicio &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf7bf69c37f5d8acf1f675cbf5d973de38aee0ad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s view the histories of all memory locations in a space-time diagram in which the horizontal axis represents the address space (i.e., each memory location is represented by a point on that axis) and the vertical axis represents time (we will see that, in general, there is not a universal notion of time). The history of values held by each memory location is, therefore, represented by a vertical column at that memory address. Each value change is due to one of the threads writing a new value to that location. By a &lt;strong&gt;&lt;em&gt;memory image&lt;/em&gt;&lt;/strong&gt;, we will mean the aggregate/combination of values of all memory locations observable &lt;strong&gt;&lt;em&gt;at a particular time&lt;/em&gt;&lt;/strong&gt; by &lt;strong&gt;&lt;em&gt;a particular thread&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Veamos los historiales de todas las ubicaciones de memoria en un diagrama de espacio-tiempo en el que el eje horizontal representa el espacio de direcciones (es decir, cada ubicaci&amp;oacute;n de memoria est&amp;aacute; representada por un punto en ese eje) y el eje vertical representa el tiempo (veremos que, en general, no existe una noci&amp;oacute;n universal del tiempo). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El historial de valores que posee cada ubicaci&amp;oacute;n de memoria est&amp;aacute;, por lo tanto, representado por una columna vertical en esa direcci&amp;oacute;n de memoria. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cada cambio de valor se debe a que uno de los hilos escribe un nuevo valor en esa ubicaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por una &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;imagen de memoria&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , nos referiremos al agregado / combinaci&amp;oacute;n de valores de todas las ubicaciones de memoria observables &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;en un momento particular&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; por &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un hilo particular&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5038877da11870fb6cdddb43d3f02bea0be31a6c" translate="yes" xml:space="preserve">
          <source>Meaning that these language definitions make no sense at all as no logical method to mix these two approaches. In particular, destruction of a mutex or atomic variable is not well defined.</source>
          <target state="translated">Lo que significa que estas definiciones de lenguaje no tienen ningún sentido,ya que no hay un método lógico para mezclar estos dos enfoques.En particular,la destrucción de un mutex o una variable atómica no está bien definida.</target>
        </trans-unit>
        <trans-unit id="fc353f0c4cd5ae6fd4f656b568ee12c3c0fe26db" translate="yes" xml:space="preserve">
          <source>Now they are half defined by an execution trace of a program, and half a posteriori by many orderings on synchronisation objects.</source>
          <target state="translated">Ahora están definidos a medias por un rastro de ejecución de un programa,y a medias a posteriori por muchas órdenes sobre objetos de sincronización.</target>
        </trans-unit>
        <trans-unit id="a9fb8f5a58585401803bbffc20531bf50cb296b8" translate="yes" xml:space="preserve">
          <source>Now things get much more interesting.  First of all, the behavior here is &lt;em&gt;defined&lt;/em&gt;.  Thread 2 could now print &lt;code&gt;0 0&lt;/code&gt; (if it runs before Thread 1), &lt;code&gt;37 17&lt;/code&gt; (if it runs after Thread 1), or &lt;code&gt;0 17&lt;/code&gt; (if it runs after Thread 1 assigns to x but before it assigns to y).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora las cosas se ponen mucho m&amp;aacute;s interesantes. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En primer lugar, el comportamiento aqu&amp;iacute; est&amp;aacute; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;definido&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El subproceso 2 ahora podr&amp;iacute;a imprimir &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (si se ejecuta antes del subproceso 1), &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (si se ejecuta despu&amp;eacute;s del subproceso 1) o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (si se ejecuta despu&amp;eacute;s del subproceso 1 se asigna a x pero antes de que se asigne a y).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8c1321d1abad5b016bf122fc4fda3ae6e01ace9" translate="yes" xml:space="preserve">
          <source>Now, if you used atomics, or lock-free algorithms, you need to think about the memory model. The memory model describes precisely when atomics provide ordering and visibility guarantees, and provides portable fences for hand-coded guarantees.</source>
          <target state="translated">Ahora,si usas atómicas,o algoritmos sin cerraduras,tienes que pensar en el modelo de memoria.El modelo de memoria describe con precisión cuándo la atómica proporciona garantías de orden y visibilidad,y proporciona vallas portátiles para las garantías codificadas a mano.</target>
        </trans-unit>
        <trans-unit id="eee5a298db9fd75c07be2a97a1f2cd772c53c044" translate="yes" xml:space="preserve">
          <source>Now, on a modern CPU, ensuring sequential consistency can be expensive.  In particular, the compiler is likely to emit full-blown memory barriers between every access here.  But if your algorithm can tolerate out-of-order loads and stores; i.e., if it requires atomicity but not ordering; i.e., if it can tolerate &lt;code&gt;37 0&lt;/code&gt; as output from this program, then you can write this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, en una CPU moderna, garantizar la coherencia secuencial puede ser costoso. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En particular, es probable que el compilador emita barreras de memoria entre todos los accesos aqu&amp;iacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero si su algoritmo puede tolerar cargas y tiendas fuera de servicio; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir, si requiere atomicidad pero no ordenar; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir, si puede tolerar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como salida de este programa, entonces puede escribir esto:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afbc13c7de8832aebd18cbbb2425e879034c8384" translate="yes" xml:space="preserve">
          <source>Of course, if the only outputs you want to see are &lt;code&gt;0 0&lt;/code&gt; or &lt;code&gt;37 17&lt;/code&gt;, you can just wrap a mutex around the original code.  But if you have read this far, I bet you already know how that works, and this answer is already longer than I intended :-).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por supuesto, si las &amp;uacute;nicas salidas que desea ver son &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , puede envolver un mutex alrededor del c&amp;oacute;digo original. Pero si has le&amp;iacute;do hasta aqu&amp;iacute;, apuesto a que ya sabes c&amp;oacute;mo funciona, y esta respuesta ya es m&amp;aacute;s larga de lo que pretend&amp;iacute;a :-).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68874039d4d2159d92f53eba89bd0c6425b0ef3b" translate="yes" xml:space="preserve">
          <source>Of course, you can write multi-threaded code in practice for particular concrete systems &amp;ndash; like pthreads or Windows.  But there is no &lt;em&gt;standard&lt;/em&gt; way to write multi-threaded code for C++98/C++03.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por supuesto, puede escribir c&amp;oacute;digo multiproceso en la pr&amp;aacute;ctica para sistemas concretos particulares, como pthreads o Windows. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero no hay &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; forma &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;est&amp;aacute;ndar&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de escribir c&amp;oacute;digo multiproceso para C ++ 98 / C ++ 03.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8435b89912ba1ee2404f40a7e7f7c76f17be4d3" translate="yes" xml:space="preserve">
          <source>Optimizations, Races, and the Memory Model</source>
          <target state="translated">Optimizaciones,Razas y el Modelo de Memoria</target>
        </trans-unit>
        <trans-unit id="cc6f83f22e321f881624f0112b2350e6a011d9b4" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; How: Mutexes, Atomics, and/or Fences</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pedidos: c&amp;oacute;mo: mutexes, at&amp;oacute;micos y / o cercas&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d394933e2ba8b9e6307eee9284401ab051f6b9a" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; What: Acquire and Release</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pedidos - Qu&amp;eacute;: Adquirir y liberar&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bfcf5ca2e968cb080e4e46edc82078a505a9d92" translate="yes" xml:space="preserve">
          <source>Other Restrictions on Compilers and Hardware</source>
          <target state="translated">Otras restricciones sobre los compiladores y el hardware</target>
        </trans-unit>
        <trans-unit id="dd65ea6941c8d670b393810b2c47552d6cf25df8" translate="yes" xml:space="preserve">
          <source>Previously, atomics would be done using compiler intrinsics, or some higher level library. Fences would have been done using CPU-specific instructions (memory barriers).</source>
          <target state="translated">Anteriormente,la atómica se realizaba utilizando el compilador intrínseco,o alguna biblioteca de nivel superior.Las cercas se habrían hecho usando instrucciones específicas de la CPU (barreras de memoria).</target>
        </trans-unit>
        <trans-unit id="2e56b625d9ce23edadcdce014336b90a101f8934" translate="yes" xml:space="preserve">
          <source>Quoting from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cita de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Una cartilla sobre consistencia de memoria y coherencia de cach&amp;eacute;&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb9db0f94440715855f11a33ea0a95909964dfda" translate="yes" xml:space="preserve">
          <source>Readers familiar with Einstein&amp;rsquo;s &lt;strong&gt;Special Theory of Relativity&lt;/strong&gt; will notice what I am alluding to. Translating Minkowski&amp;rsquo;s words into the memory models realm: address space and time are shadows of address-space-time. In this case, each observer (i.e., thread) will project shadows of events (i.e., memory stores/loads) onto his own world-line (i.e., his time axis) and his own plane of simultaneity (his address-space axis). Threads in the C++11 memory model correspond to &lt;strong&gt;&lt;em&gt;observers&lt;/em&gt;&lt;/strong&gt; that are moving relative to each other in special relativity. Sequential consistency corresponds to the &lt;strong&gt;Galilean space-time&lt;/strong&gt; (i.e., all observers agree on one absolute order of events and a global sense of simultaneity).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los lectores familiarizados con la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Teor&amp;iacute;a especial de la relatividad de Einstein&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; notar&amp;aacute;n a qu&amp;eacute; me estoy refiriendo. Traduciendo las palabras de Minkowski en el reino de los modelos de memoria: el espacio de direcciones y el tiempo son sombras del espacio de direcciones-tiempo. En este caso, cada observador (es decir, hilo) proyectar&amp;aacute; sombras de eventos (es decir, almacenes / cargas de memoria) en su propia l&amp;iacute;nea mundial (es decir, su eje de tiempo) y su propio plano de simultaneidad (su eje de espacio de direcciones) . Los subprocesos en el modelo de memoria C ++ 11 corresponden a &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;observadores&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que se mueven entre s&amp;iacute; en una relatividad especial. La coherencia secuencial corresponde al &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;espacio-tiempo galileano&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (es decir, todos los observadores est&amp;aacute;n de acuerdo en un orden absoluto de eventos y un sentido global de simultaneidad).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a133e211f7560a29b9da4d6be92f2a22755b5da2" translate="yes" xml:space="preserve">
          <source>Relaxed Atomics</source>
          <target state="translated">Atómicas relajadas</target>
        </trans-unit>
        <trans-unit id="957e61e62046dd3ea5b6cfe1f86136d6473da53c" translate="yes" xml:space="preserve">
          <source>So, bottom line. Mutexes are great, and C++11 standardizes them. But sometimes for performance reasons you want lower-level primitives (e.g., the classic &lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;double-checked locking pattern&lt;/a&gt;).  The new standard provides high-level gadgets like mutexes and condition variables, and it also provides low-level gadgets like atomic types and the various flavors of memory barrier.  So now you can write sophisticated, high-performance concurrent routines entirely within the language specified by the standard, and you can be certain your code will compile and run unchanged on both today's systems and tomorrow's.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, el resultado final. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los mutexes son geniales y C ++ 11 los estandariza. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero a veces, por razones de rendimiento, desea primitivas de nivel inferior (por ejemplo, el cl&amp;aacute;sico &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;patr&amp;oacute;n de bloqueo de doble verificaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El nuevo est&amp;aacute;ndar proporciona dispositivos de alto nivel como mutexes y variables de condici&amp;oacute;n, y tambi&amp;eacute;n proporciona dispositivos de bajo nivel como tipos at&amp;oacute;micos y los diversos sabores de la barrera de la memoria. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, ahora puede escribir rutinas concurrentes sofisticadas y de alto rendimiento completamente dentro del lenguaje especificado por el est&amp;aacute;ndar, y puede estar seguro de que su c&amp;oacute;digo se compilar&amp;aacute; y se ejecutar&amp;aacute; sin cambios tanto en los sistemas de hoy como en los de ma&amp;ntilde;ana.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76ca6da28f8d79dbdb145dfa98920e0946014d84" translate="yes" xml:space="preserve">
          <source>Store-store reordering may happen if a core has a non-FIFO write buffer that lets stores depart in a different order than the order in which they entered. This might occur if the first store misses in the cache while the second hits or if the second store can coalesce with an earlier store (i.e., before the first store). Load-load reordering may also happen on dynamically-scheduled cores that execute instructions out of program order. That can behave the same as reordering stores on another core (Can you come up with an example interleaving between two threads?). Reordering an earlier load with a later store (a load-store reordering) can cause many incorrect behaviors, such as loading a value after releasing the lock that protects it (if the store is the unlock operation). Note that store-load reorderings may also arise due to local bypassing in the commonly implemented FIFO write buffer, even with a core that executes all instructions in program order.</source>
          <target state="translated">El reordenamiento de las tiendas puede ocurrir si un núcleo tiene un búfer de escritura no-FIFO que permite que las tiendas salgan en un orden diferente al orden en que entraron.Esto puede ocurrir si el primer almacén falla en la caché mientras que el segundo golpea o si el segundo almacén puede unirse a un almacén anterior (es decir,antes del primer almacén).El reordenamiento de la carga también puede ocurrir en núcleos programados dinámicamente que ejecutan instrucciones fuera del orden del programa.Eso puede comportarse de la misma manera que reordenar los almacenes en otro núcleo (¿se le ocurre un ejemplo de intercalación entre dos hilos?).Reordenar una carga anterior con un almacén posterior (un reordenamiento del almacén de carga)puede causar muchos comportamientos incorrectos,como cargar un valor después de liberar el bloqueo que lo protege (si el almacén es la operación de desbloqueo).Tenga en cuenta que los reordenamientos de carga de almacén también pueden surgir debido a la derivación local en el búfer de escritura FIFO comúnmente implementado,incluso con un núcleo que ejecute todas las instrucciones en orden de programa.</target>
        </trans-unit>
        <trans-unit id="452c86d05004baf5f9579835c1ee31f42e9f5ebb" translate="yes" xml:space="preserve">
          <source>That global memory order can vary from one run of the program to another and may not be known beforehand. The characteristic feature of SC is the set of horizontal slices in the address-space-time diagram representing &lt;strong&gt;&lt;em&gt;planes of simultaneity&lt;/em&gt;&lt;/strong&gt; (i.e., memory images). On a given plane, all of its events (or memory values) are simultaneous. There is a notion of &lt;em&gt;Absolute Time&lt;/em&gt;, in which all threads agree on which memory values are simultaneous. In SC, at every time instant, there is only one memory image shared by all threads. That's, at every instant of time, all processors agree on the memory image (i.e., the aggregate content of memory). Not only does this imply that all threads view the same sequence of values for all memory locations, but also that all processors observe the same &lt;em&gt;combinations of values&lt;/em&gt; of all variables. This is the same as saying all memory operations (on all memory locations) are observed in the same total order by all threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ese orden de memoria global puede variar de una ejecuci&amp;oacute;n del programa a otra y puede no conocerse de antemano. El rasgo caracter&amp;iacute;stico de SC es el conjunto de cortes horizontales en el diagrama de direcci&amp;oacute;n espacio-tiempo que representan &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;planos de simultaneidad&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (es decir, im&amp;aacute;genes de memoria). En un plano dado, todos sus eventos (o valores de memoria) son simult&amp;aacute;neos. Existe una noci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo absoluto&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , en la que todos los hilos acuerdan qu&amp;eacute; valores de memoria son simult&amp;aacute;neos. En SC, en cada instante, solo hay una imagen de memoria compartida por todos los hilos. Es decir, en cada instante de tiempo, todos los procesadores acuerdan la imagen de la memoria (es decir, el contenido agregado de la memoria). Esto no solo implica que todos los subprocesos ven la misma secuencia de valores para todas las ubicaciones de memoria, sino que todos los procesadores observan lo mismo&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;combinaciones de valores&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de todas las variables. Esto es lo mismo que decir que todas las operaciones de memoria (en todas las ubicaciones de memoria) se observan en el mismo orden total por todos los subprocesos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d61648d21c81fd8a8c43e5576aa0e6b82a4218f" translate="yes" xml:space="preserve">
          <source>The C++ specification does not make reference to any particular compiler, operating system, or CPU.  It makes reference to an &lt;em&gt;abstract machine&lt;/em&gt; that is a generalization of actual systems.  In the Language Lawyer world, the job of the programmer is to write code for the abstract machine; the job of the compiler is to actualize that code on a concrete machine.  By coding rigidly to the spec, you can be certain that your code will compile and run without modification on any system with a compliant C++ compiler, whether today or 50 years from now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La especificaci&amp;oacute;n C ++ no hace referencia a ning&amp;uacute;n compilador, sistema operativo o CPU en particular. Hace referencia a una &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;aacute;quina abstracta&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que es una generalizaci&amp;oacute;n de sistemas reales. En el mundo de Law Lawyer, el trabajo del programador es escribir c&amp;oacute;digo para la m&amp;aacute;quina abstracta; El trabajo del compilador es actualizar ese c&amp;oacute;digo en una m&amp;aacute;quina concreta. Al codificar r&amp;iacute;gidamente la especificaci&amp;oacute;n, puede estar seguro de que su c&amp;oacute;digo se compilar&amp;aacute; y ejecutar&amp;aacute; sin modificaciones en cualquier sistema con un compilador C ++ compatible, ya sea hoy o dentro de 50 a&amp;ntilde;os.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d29c58cddb456581d9728a1ab2e5337bca78fb3" translate="yes" xml:space="preserve">
          <source>The above answers get at the most fundamental aspects of the C++ memory model.  In practice, most uses of &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &quot;just work&quot;, at least until the programmer over-optimizes (e.g., by trying to relax too many things).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las respuestas anteriores llegan a los aspectos m&amp;aacute;s fundamentales del modelo de memoria C ++. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En la pr&amp;aacute;ctica, la mayor&amp;iacute;a de los usos de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;simplemente funcionan&quot;, al menos hasta que el programador optimiza en exceso (por ejemplo, tratando de relajar demasiadas cosas).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7d00aae881b6e2acf7384c58de1730263886b2d" translate="yes" xml:space="preserve">
          <source>The abstract machine in C++11 is multi-threaded by design.  It also has a well-defined &lt;em&gt;memory model&lt;/em&gt;; that is, it says what the compiler may and may not do when it comes to accessing memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La m&amp;aacute;quina abstracta en C ++ 11 es multiproceso por dise&amp;ntilde;o. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n tiene un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;modelo de memoria&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bien definido &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir, dice lo que el compilador puede y no puede hacer cuando se trata de acceder a la memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7f894cea908d237d3941c58a3365a1963366b6e" translate="yes" xml:space="preserve">
          <source>The abstract machine in the C++98/C++03 specification is fundamentally single-threaded.  So it is not possible to write multi-threaded C++ code that is &quot;fully portable&quot; with respect to the spec.  The spec does not even say anything about the &lt;em&gt;atomicity&lt;/em&gt; of memory loads and stores or the &lt;em&gt;order&lt;/em&gt; in which loads and stores might happen, never mind things like mutexes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La m&amp;aacute;quina abstracta en la especificaci&amp;oacute;n C ++ 98 / C ++ 03 es fundamentalmente de un solo subproceso. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, no es posible escribir c&amp;oacute;digo C ++ multiproceso que sea &quot;totalmente port&amp;aacute;til&quot; con respecto a la especificaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La especificaci&amp;oacute;n ni siquiera dice nada sobre la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;atomicidad&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de las cargas y las tiendas de memoria o el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;orden&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en que pueden ocurrir las cargas y las tiendas, no importa cosas como mutexes.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4baedfd0f1527134631c5de1c75f35afd5945f2" translate="yes" xml:space="preserve">
          <source>The intuitive (and most restrictive) memory model is sequential consistency (SC) in which a multithreaded execution should look like an interleaving of the sequential executions of each constituent thread, as if the threads were time-multiplexed on a single-core processor.</source>
          <target state="translated">El modelo de memoria intuitivo (y más restrictivo)es el de consistencia secuencial (SC),en el que una ejecución multihilo debería parecer una intercalación de las ejecuciones secuenciales de cada hilo constitutivo,como si los hilos estuvieran multiplexados en el tiempo en un procesador de un solo núcleo.</target>
        </trans-unit>
        <trans-unit id="754d4bff03e3971b47d96374564e1cbbaae1e141" translate="yes" xml:space="preserve">
          <source>The last issue is that it might be unnatural to make the &lt;code&gt;data&lt;/code&gt; variables atomic.  If you can't in your code, then you need to be very careful, because casting from non-atomic to atomic is only legal for primitive types.  C++20 is supposed to add &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt;, which will make this problem easier to resolve.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &amp;uacute;ltimo problema es que podr&amp;iacute;a no ser natural hacer que las &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;variables de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; at&amp;oacute;micas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si no puede en su c&amp;oacute;digo, entonces debe tener mucho cuidado, porque la conversi&amp;oacute;n de no at&amp;oacute;mico a at&amp;oacute;mico solo es legal para los tipos primitivos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se supone que C ++ 20 agrega &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , lo que facilitar&amp;aacute; la resoluci&amp;oacute;n de este problema.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfd6846aacd447221a1a226955bb117560edf61a" translate="yes" xml:space="preserve">
          <source>The memory model means that C++ code
  now has a standardized library to call
  regardless of who made the compiler
  and on what platform it's running.
  There's a standard way to control how
  different threads talk to the
  processor's memory.</source>
          <target state="translated">El modelo de memoria significa que el código C++tiene ahora una biblioteca estandarizada para llamar sin importar quién hizo el compilador y en qué plataforma se está ejecutando.Hay una forma estándar de controlar cómo diferentes hilos hablan a la memoria del procesador.</target>
        </trans-unit>
        <trans-unit id="0e82744a21c2c2bfb15618db64d694bdd7c9e7e9" translate="yes" xml:space="preserve">
          <source>The more modern the CPU, the more likely this is to be faster than the previous example.</source>
          <target state="translated">Cuanto más moderna sea la CPU,más probable es que sea más rápida que el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="1f139b606c7fb2fc6086b230c6282ff5ce683f53" translate="yes" xml:space="preserve">
          <source>The paper gives a few solutions.  The one with the best performance today is probably the one that uses an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_relaxed&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; the second read of the seqlock.  In the paper, it's Figure 6.  I'm not reproducing the code here, because anyone who has read this far really ought to read the paper.  It is more precise and complete than this post.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El art&amp;iacute;culo da algunas soluciones. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El que tiene el mejor rendimiento hoy es probablemente el que usa una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_thread_fence&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;antes de&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la segunda lectura del seqlock. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En el documento, es la Figura 6. No estoy reproduciendo el c&amp;oacute;digo aqu&amp;iacute;, porque cualquiera que haya le&amp;iacute;do hasta aqu&amp;iacute; realmente deber&amp;iacute;a leer el documento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es m&amp;aacute;s preciso y completo que este post.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8ce878fb4b44eaa5f2ed3bf4b3939bc5a23cc2b" translate="yes" xml:space="preserve">
          <source>The resemblance between memory models and special relativity stems from the fact that both define a partially-ordered set of events, often called a causal set. Some events (i.e., memory stores) can affect (but not be affected by) other events. A C++11 thread (or observer in physics) is no more than a chain (i.e., a totally ordered set) of events (e.g., memory loads and stores to possibly different addresses).</source>
          <target state="translated">El parecido entre los modelos de memoria y la relatividad especial se debe a que ambos definen un conjunto de eventos parcialmente ordenados,a menudo llamado conjunto causal.Algunos eventos (es decir,los almacenes de memoria)pueden afectar (pero no ser afectados por)otros eventos.Un hilo de C++11 (u observador en física)no es más que una cadena (es decir,un conjunto totalmente ordenado)de eventos (por ejemplo,cargas y almacenes de memoria a direcciones posiblemente diferentes).</target>
        </trans-unit>
        <trans-unit id="88614ce284b9f9ee72002ba72a19fbcc1fb2fe6e" translate="yes" xml:space="preserve">
          <source>The talk doesn't elaborate on the API, but rather on the reasoning, background, under the hood and behind the scenes (did you know relaxed semantics were added to the standard only because POWER and ARM do not support synchronized load efficiently?).</source>
          <target state="translated">La charla no se centra en la API,sino en el razonamiento,el fondo,bajo el capó y entre bastidores (¿sabías que la semántica relajada se añadió al estándar sólo porque POWER y ARM no soportan la carga sincronizada de forma eficiente?).</target>
        </trans-unit>
        <trans-unit id="46e71907ae6df91d5f8c4646edd42cd31a4d2600" translate="yes" xml:space="preserve">
          <source>There is one place where mistakes are still common: &lt;em&gt;sequence locks&lt;/em&gt;.  There is an excellent and easy-to-read discussion of the challenges at &lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/a&gt;.  Sequence locks are appealing because the reader avoids writing to the lock word.  The following code is based on Figure 1 of the above technical report, and it highlights the challenges when implementing sequence locks in C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay un lugar donde los errores siguen siendo comunes: &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bloqueos de secuencia&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay una discusi&amp;oacute;n excelente y f&amp;aacute;cil de leer sobre los desaf&amp;iacute;os en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los bloqueos de secuencia son atractivos porque el lector evita escribir en la palabra de bloqueo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El siguiente c&amp;oacute;digo se basa en la Figura 1 del informe t&amp;eacute;cnico anterior y destaca los desaf&amp;iacute;os al implementar bloqueos de secuencia en C ++:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="961c454b5b699e3c67051c83eb5d379453c92717" translate="yes" xml:space="preserve">
          <source>This takes us back to the ordered loads and stores &amp;ndash; so &lt;code&gt;37 0&lt;/code&gt; is no longer a possible output &amp;ndash; but it does so with minimal overhead.  (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto nos lleva de vuelta a las cargas y tiendas ordenadas, por lo que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no es una salida posible, pero lo hace con una sobrecarga m&amp;iacute;nima. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(En este ejemplo trivial, el resultado es el mismo que la consistencia secuencial completa; en un programa m&amp;aacute;s amplio, no lo ser&amp;iacute;a).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e039b9566e8dfbf0f2a3944c91a446a0d3877578" translate="yes" xml:space="preserve">
          <source>To provide a definition of memory consistency and a motivation for abandoning SC, I will quote from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para proporcionar una definici&amp;oacute;n de la coherencia de la memoria y una motivaci&amp;oacute;n para abandonar el SC, citar&amp;eacute; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Una introducci&amp;oacute;n a la coherencia de la memoria y la coherencia de la memoria cach&amp;eacute;&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf70e99ebffe9e92e5be11ffc6e48ebef4aad770" translate="yes" xml:space="preserve">
          <source>To summarize: even if you think you understand the C++ memory model, you should be very careful before rolling your own sequence locks.</source>
          <target state="translated">Para resumir:aunque creas que entiendes el modelo de memoria C++,debes tener mucho cuidado antes de rodar tus propios bloqueos de secuencia.</target>
        </trans-unit>
        <trans-unit id="5f2312cd34bd31141d0b81cd0bd16779840debfa" translate="yes" xml:space="preserve">
          <source>Under C++11, the result is Undefined Behavior, because loads and stores need not be atomic in general.  Which may not seem like much of an improvement...  And by itself, it's not.</source>
          <target state="translated">Bajo C++11,el resultado es Comportamiento indefinido,porque las cargas y los almacenes no tienen por qué ser atómicos en general.Lo cual puede no parecer una gran mejora...Y por sí misma,no lo es.</target>
        </trans-unit>
        <trans-unit id="b9f7556c864ccbfde77ebfd4adde349b5488e4fa" translate="yes" xml:space="preserve">
          <source>Under C++98/C++03, this is not even Undefined Behavior; the question itself is &lt;em&gt;meaningless&lt;/em&gt; because the standard does not contemplate anything called a &quot;thread&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bajo C ++ 98 / C ++ 03, esto ni siquiera es un comportamiento indefinido; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la pregunta en s&amp;iacute; misma no tiene &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sentido&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; porque el est&amp;aacute;ndar no contempla nada llamado &quot;hilo&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ce2b632d1c58188c735ed2a0e6024043931901f" translate="yes" xml:space="preserve">
          <source>Unlike consistency, &lt;strong&gt;&lt;em&gt;cache coherence&lt;/em&gt;&lt;/strong&gt; is neither visible to software nor required. Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system. Correct coherence ensures that a programmer cannot determine whether and where a system has caches by analyzing the results of loads and stores. This is because correct coherence ensures that the caches never enable new or different &lt;strong&gt;&lt;em&gt;functional&lt;/em&gt;&lt;/strong&gt; behavior (programmers may still be able to infer likely cache structure using &lt;strong&gt;&lt;em&gt;timing&lt;/em&gt;&lt;/strong&gt; information). The main purpose of cache coherence protocols is maintaining the single-writer-multiple-readers (SWMR) invariant for every memory location.
  An important distinction between coherence and consistency is that coherence is specified on a &lt;strong&gt;&lt;em&gt;per-memory location basis&lt;/em&gt;&lt;/strong&gt;, whereas consistency is specified with respect to &lt;strong&gt;&lt;em&gt;all&lt;/em&gt;&lt;/strong&gt; memory locations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A diferencia de la coherencia, la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;coherencia de la memoria cach&amp;eacute;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no es visible para el software ni es necesaria. Coherence busca hacer que las memorias cach&amp;eacute; de un sistema de memoria compartida sean funcionalmente invisibles como las memorias cach&amp;eacute; de un sistema de un solo n&amp;uacute;cleo. La coherencia correcta asegura que un programador no pueda determinar si un sistema tiene cach&amp;eacute;s y d&amp;oacute;nde lo hace analizando los resultados de cargas y almacenes. Esto se debe a que la coherencia correcta garantiza que los cach&amp;eacute;s nunca permitan un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comportamiento &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funcional&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nuevo o diferente &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(los programadores a&amp;uacute;n pueden inferir la estructura probable del cach&amp;eacute; usando el &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;informaci&amp;oacute;n). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El objetivo principal de los protocolos de coherencia de cach&amp;eacute; es mantener invariante el escritor &amp;uacute;nico-lectores m&amp;uacute;ltiples (SWMR) para cada ubicaci&amp;oacute;n de memoria. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una distinci&amp;oacute;n importante entre coherencia y consistencia es que la coherencia se especifica &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;por ubicaci&amp;oacute;n de memoria&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , mientras que la consistencia se especifica con respecto a &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;todas las&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ubicaciones de memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfacfcd81cfcca293eba3cc7493531d81a4a1b4d" translate="yes" xml:space="preserve">
          <source>Very importantly, locks (and concurrency semantics with locking) are typically implemented in a cross platform way... So if you are using standard locks in a multithreaded program with no data races then you &lt;strong&gt;don't have to worry about cross platform memory models&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Muy importante, los bloqueos (y la sem&amp;aacute;ntica de concurrencia con bloqueo) generalmente se implementan de forma multiplataforma ... Entonces, si est&amp;aacute; utilizando bloqueos est&amp;aacute;ndar en un programa multiproceso sin carreras de datos, entonces &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no tiene que preocuparse por los modelos de memoria multiplataforma&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e4a2ca5a3d05ddfbe2b56ccb6104a75cae606ef" translate="yes" xml:space="preserve">
          <source>Well, I can &lt;em&gt;memorize&lt;/em&gt; this and similar paragraphs available online (as I've had my own memory model since birth :P) and can even post as an answer to questions asked by others, but to be honest, I don't exactly understand this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bueno, puedo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;memorizar&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; este y otros p&amp;aacute;rrafos similares disponibles en l&amp;iacute;nea (ya que tengo mi propio modelo de memoria desde mi nacimiento: P) e incluso puedo publicar como respuesta a las preguntas formuladas por otros, pero para ser sincero, no entiendo exactamente esta.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="956fcc4400c935b51349b1224fcb0216fed90fc4" translate="yes" xml:space="preserve">
          <source>What it cannot print is &lt;code&gt;37 0&lt;/code&gt;, because the default mode for atomic loads/stores in C++11 is to enforce &lt;em&gt;sequential consistency&lt;/em&gt;.  This just means all loads and stores must be &quot;as if&quot; they happened in the order you wrote them within each thread, while operations among threads can be interleaved however the system likes.  So the default behavior of atomics provides both &lt;em&gt;atomicity&lt;/em&gt; and &lt;em&gt;ordering&lt;/em&gt; for loads and stores.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que no puede imprimir es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , porque el modo predeterminado para cargas / almacenes at&amp;oacute;micos en C ++ 11 es imponer &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una coherencia secuencial&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Esto solo significa que todas las cargas y los almacenes deben ser &quot;como si&quot; ocurrieran en el orden en que los escribi&amp;oacute; dentro de cada hilo, mientras que las operaciones entre hilos se pueden intercalar como quiera el sistema. Por lo tanto, el comportamiento predeterminado de los at&amp;oacute;micos proporciona tanto &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;atomicidad&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pedidos&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para cargas y tiendas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fd897db0b1892f92d3ac2bb9df198d5229ab212" translate="yes" xml:space="preserve">
          <source>What might Thread 2 output?</source>
          <target state="translated">¿Qué podría producir el Hilo 2?</target>
        </trans-unit>
        <trans-unit id="1798b5cddeecf3effcaf30a3ce667c57f5b3451d" translate="yes" xml:space="preserve">
          <source>When you're talking about POSIX threads or Windows threads, then this is a bit of an illusion as actually you're talking about x86 threads, as it's a hardware function to run concurrently. The C++0x memory model makes guarantees, whether you're on x86, or ARM, or &lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;MIPS&lt;/a&gt;, or anything else you can come up with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando habla de hilos POSIX o hilos de Windows, esto es una ilusi&amp;oacute;n, ya que en realidad se trata de hilos x86, ya que es una funci&amp;oacute;n de hardware que se ejecuta simult&amp;aacute;neamente. El modelo de memoria C ++ 0x ofrece garant&amp;iacute;as, ya sea que est&amp;eacute; en x86, o ARM, o &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MIPS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , o cualquier otra cosa que se le ocurra.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76cbbb6015ca76bb55e457fa170621f939633ebe" translate="yes" xml:space="preserve">
          <source>[Picture from Wikipedia]</source>
          <target state="translated">[Foto de Wikipedia]</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
