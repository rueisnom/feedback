<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/6319146">
    <body>
      <group id="6319146">
        <trans-unit id="73df4e1cfb97a0cf2c29a8c07e2bb86731b5d146" translate="yes" xml:space="preserve">
          <source>&quot;When you are talking about splitting
  [code] across different cores that's
  in the standard, we are talking about
  the memory model. We are going to
  optimize it without breaking the
  following assumptions people are going
  to make in the code,&quot; &lt;strong&gt;Sutter&lt;/strong&gt; said.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sutter&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;표준에있는 다른 코어에 [코드]를 분할하는 것에 대해 이야기 할 때 메모리 모델에 대해 이야기하고있다. 사람들이 코드에서 수행 할 다음 가정을 어 기지 않고 메모리 모델을 최적화 할 것&quot;이라고 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sutter&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 말했다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d15a3a1c7c247d44171f5a6070b968d22cecb393" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;This article&lt;/a&gt; (by &lt;strong&gt;Gavin Clarke&lt;/strong&gt; who quotes &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/strong&gt;) says that,</source>
          <target state="translated">&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 기사&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hub Sutter&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 인용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Gavin Clarke&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )는 다음과 같이 말합니다.&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="731c13310aa9d76029890ec2d9fe270b4e77f4e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Relaxed&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;weak&lt;/em&gt;&lt;/strong&gt; memory consistency models are motivated by the fact that most memory orderings in strong models are unnecessary. If a thread updates ten data items and then a synchronization flag, programmers usually do not care if the data items are updated in order with respect to each other but only that all data items are updated before the flag is updated (usually implemented using FENCE instructions). Relaxed models seek to capture this increased ordering flexibility and preserve only the orders that programmers &amp;ldquo;&lt;em&gt;require&lt;/em&gt;&amp;rdquo; to get both higher performance and correctness of SC. For example, in certain architectures, FIFO write buffers are used by each core to hold the results of committed (retired) stores before writing the results to the caches. This optimization enhances performance but violates SC. The write buffer hides the latency of servicing a store miss. Because stores are common, being able to avoid stalling on most of them is an important benefit. For a single-core processor, a write buffer can be made architecturally invisible by ensuring that a load to address A returns the value of the most recent store to A even if one or more stores to A are in the write buffer. This is typically done by either bypassing the value of the most recent store to A to the load from A, where &amp;ldquo;most recent&amp;rdquo; is determined by program order, or by stalling a load of A if a store to A is in the write buffer. When multiple cores are used, each will have its own bypassing write buffer. Without write buffers, the hardware is SC, but with write buffers, it is not, making write buffers architecturally visible in a multicore processor.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완화&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 되거나&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 약한&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메모리 일관성 모델은 강력한 모델에서 대부분의 메모리 순서가 불필요하다는 사실에 의해 동기가 부여됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드가 10 개의 데이터 항목을 업데이트 한 다음 동기화 플래그를 업데이트하는 경우 프로그래머는 일반적으로 데이터 항목이 서로 순서대로 업데이트되는지 신경 쓰지 않고 플래그가 업데이트되기 전에 모든 데이터 항목 만 업데이트되도록합니다 (일반적으로 FENCE 명령어를 사용하여 구현 됨) ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편안한 모델은 이러한 증가 된 주문 유연성을 포착하고 프로그래머가&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 요구&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 주문 만 보존하려고&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 합니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SC의 성능과 정확성을 모두 향상시킵니다. 예를 들어, 특정 아키텍처에서 FIFO 쓰기 버퍼는 각 코어에서 결과를 캐시에 기록하기 전에 커밋 된 (중지 된) 저장소의 결과를 보유하기 위해 사용됩니다. 이 최적화는 성능을 향상 시키지만 SC를 위반합니다. 쓰기 버퍼는 상점 누락 서비스 지연 시간을 숨 깁니다. 상점은 일반적이므로 대부분의 상점에서 실속을 피할 수 있다는 것이 중요한 이점입니다. 단일 코어 프로세서의 경우, A에 대한 하나 이상의 저장소가 쓰기 버퍼에 있더라도 주소 A에 대한로드가 최신 저장소의 값을 A로 리턴하도록하여 쓰기 버퍼를 구조적으로 보이지 않게 할 수 있습니다. 이는 일반적으로 가장 최근 상점의 값을 A로 우회하여 A에서로드로 우회하여 수행합니다. 여기서 &quot;가장 최근&quot;은 프로그램 순서에 따라 결정됩니다.또는 A에 대한 저장소가 쓰기 버퍼에있는 경우 A의로드를 중단합니다. 여러 개의 코어를 사용하는 경우 각 코어에는 자체 바이 패스 쓰기 버퍼가 있습니다. 쓰기 버퍼가 없으면 하드웨어는 SC이지만 쓰기 버퍼가 있으면 멀티 코어 프로세서에서 쓰기 버퍼를 구조적으로 볼 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a24014293b7e7f3c3957b75dbba2b33ce19b2765" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is now a multiple-year old question, but being very popular, it's worth mentioning a fantastic resource for learning about the C++11 memory model. I see no point in summing up his talk in order to make this yet another full answer, but given this is the guy who actually wrote the standard, I think it's well worth watching the talk.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 이제 몇 년 된 질문이지만 매우 인기가 있으므로 C ++ 11 메모리 모델에 대한 학습을위한 환상적인 리소스를 언급 할 가치가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 이것이 또 다른 완전한 답을 만들기 위해 그의 대화를 요약 할 필요는 없지만 이것이 실제로 표준을 작성한 사람이라면 대화를 볼 가치가 있다고 생각합니다.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fea15c028fa16edd68a84950f92fa70a42f3fac8" translate="yes" xml:space="preserve">
          <source>Although to be frank, unless you are an expert and working on some serious low-level code, you should probably stick to mutexes and condition variables.  That's what I intend to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;솔직하지만 전문가가 아니고 심각한 저수준 코드를 작성하지 않는 한 뮤텍스와 조건 변수를 고수해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 내가하려는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ad19cd05e2aca3350a1896cdfb856a60997442f" translate="yes" xml:space="preserve">
          <source>As I don't know how the internals of multi-threading work, and what memory model means in general, please help me understand these concepts. :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레딩의 내부 작동 방식과 일반적인 메모리 모델의 의미를 모르므로 이러한 개념을 이해하도록 도와주십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="73edd169fb02675391ad1960b83d93b7512986a3" translate="yes" xml:space="preserve">
          <source>As unintuitive as it seams at first, &lt;code&gt;data1&lt;/code&gt; and &lt;code&gt;data2&lt;/code&gt; need to be &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt;.  If they are not atomic, then they could be read (in &lt;code&gt;reader()&lt;/code&gt;) at the exact same time as they are written (in &lt;code&gt;writer()&lt;/code&gt;).  According to the C++ memory model, this is a race &lt;em&gt;even if &lt;code&gt;reader()&lt;/code&gt; never actually uses the data&lt;/em&gt;.  In addition, if they are not atomic, then the compiler can cache the first read of each value in a register.  Obviously you wouldn't want that... you want to re-read in each iteration of the &lt;code&gt;while&lt;/code&gt; loop in &lt;code&gt;reader()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처음에는 이음새 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 없어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직관적이지 않으므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이어야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. 그것들이 원자 적이 지 않다면, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것들이 쓰여진 것과 정확히 동시에 ( &lt;/font&gt; &lt;code&gt;writer()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;읽을 수 있습니다 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;). C ++ 메모리 모델에 따르면, &lt;/font&gt;&lt;em&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 실제로 data를 사용하지 &lt;/font&gt;&lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않더라도&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이것은 경쟁 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. 또한 원자가 아닌 경우 컴파일러는 레지스터에서 각 값의 첫 번째 읽기를 캐시 할 수 있습니다. 분명히 당신은 그것을 원하지 않을 것입니다 ... &lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 루프 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 각 반복에서 다시 읽으려고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4a622ff9ae0214ed05a333e5d2cd4c3f0640dc8" translate="yes" xml:space="preserve">
          <source>Because cache coherence and memory consistency are sometimes confused, it is instructive to also have this quote:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캐시 일관성과 메모리 일관성이 때때로 혼동되기 때문에 다음 인용문을 사용하는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="934437c0109e42d4fd367073bdd77200fe18bf44" translate="yes" xml:space="preserve">
          <source>But with C++11, you can write this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 C ++ 11을 사용하면 다음과 같이 작성할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3419e7bfb7b912c1de58267196ef1715f03d520" translate="yes" xml:space="preserve">
          <source>C and C++ used to be defined by an execution trace of a well formed program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C와 C ++는 잘 구성된 프로그램의 실행 추적에 의해 정의되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f714f1f168010e0e48c54ceb767d70850b43f535" translate="yes" xml:space="preserve">
          <source>C++ programmers used to develop multi-threaded applications even before, so how does it matter if it's POSIX threads, or Windows threads, or C++11 threads? What are the benefits? I want to understand the low-level details.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 프로그래머는 이전에도 멀티 스레드 응용 프로그램을 개발하는 데 사용되었으므로 POSIX 스레드, Windows 스레드 또는 C ++ 11 스레드의 경우 어떻게 중요합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;장점은 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;저수준 세부 사항을 이해하고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c804136fc25fd72d45e9ed77db0496ceaaa13a5e" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model, but what exactly does that mean? And how is it going to affect C++ programming?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11은 표준화 된 메모리 모델을 도입했지만 정확히 무엇을 의미합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 C ++ 프로그래밍에 어떤 영향을 미치나요?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31ce9265efcb7ae003d188e0fcacad2174b4301" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model. What does it mean? And how is it going to affect C++ programming</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11은 표준화 된 메모리 모델을 도입했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무슨 뜻인가요? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 C ++ 프로그래밍에 어떤 영향을 미치나요?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1071914933f07012e3e0261ffb0513754c189cf3" translate="yes" xml:space="preserve">
          <source>Code Gen &amp;amp; Performance: x86/x64, IA64, POWER, ARM</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드 생성 및 성능 : x86 / x64, IA64, POWER, ARM&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70cb8dd903b1de610462040edfa72807d0c75c0f" translate="yes" xml:space="preserve">
          <source>Consider the following example, where a pair of global variables are accessed concurrently by two threads:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의 스레드가 한 쌍의 전역 변수에 동시에 액세스하는 다음 예를 고려하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e777ba92d2f70816c7b8e0a710d0cd2e088bf50" translate="yes" xml:space="preserve">
          <source>Continuing with our mental picture, the SWMR invariant corresponds to the physical requirement that there be at most one particle located at any one location but there can be an unlimited number of observers of any location.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리의 정신적 그림으로 계속해서, SWMR 불변은 어느 한 위치에 최대 하나의 입자가 있어야하지만 어느 위치 에나 무제한의 관찰자가있을 수있는 물리적 요구 사항에 해당합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ccda8a650443d20e5e10efff7eff75f39de7479" translate="yes" xml:space="preserve">
          <source>Finally, if you just need to keep particular loads and stores in order, you can write:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 특정로드 및 스토어를 순서대로 유지해야하는 경우 다음과 같이 작성할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95b21e94883bf869fa456f6fee7bcd0aede60da8" translate="yes" xml:space="preserve">
          <source>First, you have to learn to think like a Language Lawyer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 언어 변호사처럼 생각하는 법을 배워야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f764c87baa07b4d9b69d806e43e35de480f00596" translate="yes" xml:space="preserve">
          <source>For a shared memory machine, the memory consistency model defines the architecturally visible behavior of its memory system. The correctness criterion for a single processor core partitions behavior between &amp;ldquo;&lt;em&gt;one correct result&lt;/em&gt;&amp;rdquo; and &amp;ldquo;&lt;em&gt;many incorrect alternatives&lt;/em&gt;&amp;rdquo;. This is because the processor&amp;rsquo;s architecture mandates that the execution of a thread transforms a given input state into a single well-defined output state, even on an out-of-order core. Shared memory consistency models, however, concern the loads and stores of multiple threads and usually allow &lt;em&gt;many correct executions&lt;/em&gt; while disallowing many (more) incorrect ones. The possibility of multiple correct executions is due to the ISA allowing multiple threads to execute concurrently, often with many possible legal interleavings of instructions from different threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공유 메모리 시스템의 경우 메모리 일관성 모델은 메모리 시스템의 구조적으로 보이는 동작을 정의합니다. 단일 프로세서 코어 파티션에 대한 정확성 기준은&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하나의 올바른 결과&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;와&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 잘못된 대안&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사이의 동작을 구분합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 프로세서의 아키텍처는 스레드의 실행이 특정 입력 상태를 비정규 코어에서도 단일의 잘 정의 된 출력 상태로 변환하도록 요구하기 때문입니다. 그러나 공유 메모리 일관성 모델은 여러 스레드의로드 및 저장과 관련이 있으며 일반적으로 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 올바른 실행을&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 허용 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 (더 많은) 잘못된 것들을 허용하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 번의 올바른 실행 가능성은 ISA가 여러 스레드를 동시에 실행할 수 있도록 허용하기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3a3531d42219943e36c390c1d09394dda7f26" translate="yes" xml:space="preserve">
          <source>For languages not specifying a memory model, you are writing code for the language &lt;em&gt;and&lt;/em&gt; the memory model specified by the processor architecture. The processor may choose to re-order memory accesses for performance. So, &lt;strong&gt;if your program has data races&lt;/strong&gt; (a data race is when it's possible for multiple cores / hyper-threads to access the same memory concurrently) then your program is not cross platform because of its dependence on the processor memory model. You may refer to the Intel or AMD software manuals to find out how the processors may re-order memory accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 모델을 지정하지 않은 언어의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 프로세서 아키텍처에서 지정한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언어 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;및&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메모리 모델에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대한 코드를 작성합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 프로세서는 성능을 위해 메모리 액세스를 재정렬하도록 선택할 수 있습니다. 따라서 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 데이터 레이스가있는 경우 (데이터 레이스가 여러 코어 / 하이 스레드가 동일한 메모리에 동시에 액세스 할 수있는 경우) 프로세서 메모리 모델에 의존하기 때문에 프로그램이 플랫폼을 넘어 가지 않습니다. 프로세서가 메모리 액세스 순서를 다시 지정할 수있는 방법을 알아 보려면 인텔 또는 AMD 소프트웨어 설명서를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ef316ccb8a21361d46e5437050816b42e490adc" translate="yes" xml:space="preserve">
          <source>For more on this stuff, see &lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 내용에 대한 자세한 내용은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 블로그 게시물을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e122e719b66a5aaf1016dc68677fa81a7da2c2fe" translate="yes" xml:space="preserve">
          <source>Herb Sutter has a three hour long talk about the C++11 memory model titled &quot;atomic&amp;lt;&amp;gt; Weapons&quot;, available on the Channel9 site - &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;part 2&lt;/a&gt;. The talk is pretty technical, and covers the following topics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Herb Sutter는 Channel9 사이트 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(1 &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에있는 &quot;atomic &amp;lt;&amp;gt; Weapons&quot;라는 C ++ 11 메모리 모델에 대해 3 시간 동안 긴 대화를 나누었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 대화는 매우 기술적이며 다음 주제를 다룹니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acbd5686848a17d66430beecce776f2956fd0ca0" translate="yes" xml:space="preserve">
          <source>I also get this feeling that the C++11 memory model is somehow related to C++11 multi-threading support, as I often see these two together. If it is, how exactly? Why should they be related?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 C ++ 11 메모리 모델이 C ++ 11 멀티 스레딩 지원과 관련이 있다는 느낌이 들었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇다면 얼마나 정확합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 관련되어야합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb879d24c026ac0b51a220b545aa9383dafc4341" translate="yes" xml:space="preserve">
          <source>I will just give the analogy with which I understand memory consistency models (or memory models, for short). It is inspired by Leslie Lamport's seminal paper &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot;&lt;/a&gt;.
The analogy is apt and has fundamental significance, but may be overkill for many people. However, I hope it provides a mental image (a pictorial representation) that facilitates reasoning about memory consistency models.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 일관성 모델 (또는 메모리 모델)을 이해하는 것과 유사합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Leslie Lamport의 주요 논문 인 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;분산 시스템에서 시간, 시계 및 이벤트 순서&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 영감을 얻었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비유는 적절하고 근본적인 의미가 있지만 많은 사람들에게 과잉 일 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 메모리 일관성 모델에 대한 추론을 용이하게하는 정신적 이미지 (그림 표현)를 제공하기를 바랍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7217b726fd9359150a03a385521e0a936659d192" translate="yes" xml:space="preserve">
          <source>If you use mutexes to protect all your data, you really shouldn't need to worry. Mutexes have always provided sufficient ordering and visibility guarantees.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뮤텍스를 사용하여 모든 데이터를 보호하는 경우 실제로 걱정할 필요가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뮤텍스는 항상 충분한 순서와 가시성을 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e79392e298c7995c33512b2d46cc65f4371d276e" translate="yes" xml:space="preserve">
          <source>In C++11 memory model, a similar mechanism (the acquire-release consistency model) is used to establish these &lt;strong&gt;&lt;em&gt;local causality relations&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 메모리 모델에서 이와 유사한 메커니즘 (구매 릴리스 일관성 모델)을 사용하여 이러한 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로컬 인과 관계&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 설정합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="262aafb7f2b604061a913423a9ba782f8c49b7c8" translate="yes" xml:space="preserve">
          <source>In relativity, some order is restored to the seemingly chaotic picture of partially ordered events, since the only temporal ordering that all observers agree on is the ordering among &amp;ldquo;timelike&amp;rdquo; events (i.e., those events that are in principle connectible by any particle going slower than the speed of light in a vacuum). Only the timelike related events are invariantly ordered.
&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;Time in Physics, Craig Callender&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상대성 이론에서, 모든 관찰자들이 동의하는 유일한 시간적 순서는 &quot;시간과 같은&quot;사건들 (즉, 원칙적으로 입자가 느리게 연결될 수있는 사건들)의 순서이기 때문에 일부 순서는 부분적으로 정렬 된 사건들의 겉보기에 혼란스러운 그림으로 복원된다 진공에서 빛의 속도보다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간 관련 이벤트 만 일정하게 정렬됩니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물리학, 크레이그 캘린더의 시간&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ec3ce667f63e7bf2272ca76f9d4e2f94f0cc855" translate="yes" xml:space="preserve">
          <source>In relaxed memory models, each thread will slice up address-space-time in its own way, the only restriction being that slices of each thread shall not cross each other because all threads must agree on the history of every individual memory location (of course, slices of different threads may, and will, cross each other). There is no universal way to slice it up (no privileged foliation of address-space-time). Slices do not have to be planar (or linear). They can be curved and this is what can make a thread read values written by another thread out of the order they were written in. Histories of different memory locations may slide (or get stretched) arbitrarily relative to each other &lt;strong&gt;&lt;em&gt;when viewed by any particular thread&lt;/em&gt;&lt;/strong&gt;. Each thread will have a different sense of which events (or, equivalently, memory values) are simultaneous. The set of events (or memory values) that are simultaneous to one thread are not simultaneous to another. Thus, in a relaxed memory model, all threads still observe the same history (i.e., sequence of values) for each memory location. But they may observe different memory images (i.e., combinations of values of all memory locations). Even if two different memory locations are written by the same thread in sequence, the two newly written values may be observed in different order by other threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완화 된 메모리 모델에서 각 스레드는 고유 한 방식으로 주소 공간 시간을 분할합니다. 모든 스레드가 모든 개별 메모리 위치의 히스토리에 동의해야하기 때문에 각 스레드의 슬라이스가 서로 교차하지 않아야한다는 유일한 제한 사항입니다 (물론 서로 다른 스레드의 조각이 서로 교차 할 수 있습니다. 그것을 분리하는 보편적 인 방법은 없습니다 (주소 공간 시간의 특권 한 잎이 없음). 슬라이스는 평면 (또는 선형) 일 필요는 없습니다. 그것들은 구부러 질 수 있으며 이것은 쓰레드가 쓰인 순서대로 다른 쓰레드에 의해 쓰인 값을 읽도록 만들 수있는 것입니다. 다른 메모리 위치의 히스토리는 &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특정 쓰레드에 의해 볼 때&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 서로에 대해 임의로 미끄러지거나 늘어날 수 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 스레드는 서로 다른 이벤트 (또는 동등하게 메모리 값)가 서로 다른 의미를 갖습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 스레드와 동시에 발생하는 이벤트 세트 (또는 메모리 값)는 다른 스레드와 동시에 발생하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서, 완화 된 메모리 모델에서, 모든 스레드는 여전히 각 메모리 위치에 대해 동일한 이력 (즉, 일련의 값)을 관찰합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 서로 다른 메모리 이미지 (즉, 모든 메모리 위치의 값 조합)를 관찰 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의 서로 다른 메모리 위치가 동일한 스레드에 의해 순차적으로 쓰여지더라도, 새로 작성된 두 개의 값은 다른 스레드에 의해 다른 순서로 관찰 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7b6248a1c3792a0a57715e16d30ffb4cda796" translate="yes" xml:space="preserve">
          <source>Interestingly, Microsoft compilers for C++ have acquire / release semantics for volatile which is a C++ extension to deal with the lack of a memory model in C++ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&lt;/a&gt;. However, given that Windows runs on x86 / x64 only, that's not saying much (Intel and AMD memory models make it easy and efficient to implement acquire / release semantics in a language).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;흥미롭게도 C ++ 용 Microsoft 컴파일러는 C ++에서 메모리 모델 부족을 처리하기위한 C ++ 확장 인 휘발성에 대한 의미를 획득 / 릴리스합니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://msdn.microsoft.com/ko-kr/library/12a04hfd(v=vs .80) .aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 Windows가 x86 / x64에서만 실행되므로 별다른 의미가 없습니다 (Intel 및 AMD 메모리 모델을 사용하면 언어로 획득 / 릴리스 의미론을 쉽고 효율적으로 구현할 수 있습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b69141b6b87da624d79fe320205b2eafd77d0cd" translate="yes" xml:space="preserve">
          <source>It is also not sufficient to make them &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; and access them with &lt;code&gt;memory_order_relaxed&lt;/code&gt;.  The reason for this is that the reads of seq (in &lt;code&gt;reader()&lt;/code&gt;) only have &lt;em&gt;acquire&lt;/em&gt; semantics.  In simple terms, if X and Y are memory accesses, X precedes Y, X is not an acquire or release, and Y is an acquire, then the compiler can reorder Y before X.  If Y was the second read of seq, and X was a read of data, such a reordering would break the lock implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것들을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 만들고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 액세스하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것만으로는 충분하지 않습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 그 이유는 seq ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 읽기는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의미를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;획득하기 때문&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. 간단히 말해서, X 및 Y가 메모리 액세스 인 경우 X가 Y보다 우선하고, X는 획득 또는 릴리스가 아니며, Y는 획득 인 경우 컴파일러는 X보다 먼저 Y를 다시 정렬 할 수 있습니다. Y가 seq의 두 번째 읽기 인 경우 X 데이터를 읽었으므로 이러한 재정렬은 잠금 구현을 중단시킵니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4cb6b422f1ed052e081abd1a922b9c939b53705" translate="yes" xml:space="preserve">
          <source>It means that the standard now defines multi-threading, and it defines what happens in the context of multiple threads. Of course, people used varying implementations, but that's like asking why we should have a &lt;code&gt;std::string&lt;/code&gt; when we could all be using a home-rolled &lt;code&gt;string&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 표준이 이제 멀티 스레딩을 정의하고 여러 스레드의 상황에서 발생하는 사항을 정의 함을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 사람들은 다양한 구현을 사용했지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모두 홈 롤링 &lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용할 수있을 때 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가져야하는지 묻는 것과 같습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf7bf69c37f5d8acf1f675cbf5d973de38aee0ad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s view the histories of all memory locations in a space-time diagram in which the horizontal axis represents the address space (i.e., each memory location is represented by a point on that axis) and the vertical axis represents time (we will see that, in general, there is not a universal notion of time). The history of values held by each memory location is, therefore, represented by a vertical column at that memory address. Each value change is due to one of the threads writing a new value to that location. By a &lt;strong&gt;&lt;em&gt;memory image&lt;/em&gt;&lt;/strong&gt;, we will mean the aggregate/combination of values of all memory locations observable &lt;strong&gt;&lt;em&gt;at a particular time&lt;/em&gt;&lt;/strong&gt; by &lt;strong&gt;&lt;em&gt;a particular thread&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가로축이 주소 공간을 나타내는 (즉, 각 메모리 위치는 해당 축의 한 점으로 표시됨) 세로축은 시간을 나타내는 시공간 다이어그램에서 모든 메모리 위치의 이력을 보도록하겠습니다. 일반적으로 보편적 인 시간 개념은 없습니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 각 메모리 위치에 보유 된 값의 히스토리는 해당 메모리 주소의 수직 열로 표시됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 값 변경은 스레드 중 하나가 해당 위치에 새 값을 작성하기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(A)에 의해 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 이미지&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 우리가 관찰 할 수있는 모든 메모리 위치의 값의 합계 / 조합을 의미합니다 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특정 시간에&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의해 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특정 스레드를&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5038877da11870fb6cdddb43d3f02bea0be31a6c" translate="yes" xml:space="preserve">
          <source>Meaning that these language definitions make no sense at all as no logical method to mix these two approaches. In particular, destruction of a mutex or atomic variable is not well defined.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 두 가지 접근 방식을 혼합하는 논리적 방법이 없기 때문에 이러한 언어 정의는 전혀 의미가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히, 뮤텍스 또는 원자 변수의 파괴는 잘 정의되어 있지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc353f0c4cd5ae6fd4f656b568ee12c3c0fe26db" translate="yes" xml:space="preserve">
          <source>Now they are half defined by an execution trace of a program, and half a posteriori by many orderings on synchronisation objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 프로그램의 실행 추적에 의해 절반이 정의되고 동기화 오브젝트에 대한 많은 순서로 절반이 정의됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9fb8f5a58585401803bbffc20531bf50cb296b8" translate="yes" xml:space="preserve">
          <source>Now things get much more interesting.  First of all, the behavior here is &lt;em&gt;defined&lt;/em&gt;.  Thread 2 could now print &lt;code&gt;0 0&lt;/code&gt; (if it runs before Thread 1), &lt;code&gt;37 17&lt;/code&gt; (if it runs after Thread 1), or &lt;code&gt;0 17&lt;/code&gt; (if it runs after Thread 1 assigns to x but before it assigns to y).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 상황이 훨씬 더 흥미로워집니다. 우선, 여기에 동작이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정의되어&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있습니다. 스레드 2는 이제 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (스레드 1 이전에 실행되는 경우), &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (스레드 1 이후에 실행되는 경우) 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (스레드 1이 x에 할당되었지만 y에 할당되기 전에 실행 된 경우)을 인쇄 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8c1321d1abad5b016bf122fc4fda3ae6e01ace9" translate="yes" xml:space="preserve">
          <source>Now, if you used atomics, or lock-free algorithms, you need to think about the memory model. The memory model describes precisely when atomics provide ordering and visibility guarantees, and provides portable fences for hand-coded guarantees.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 원자 또는 잠금없는 알고리즘을 사용했다면 메모리 모델에 대해 생각해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 모델은 원자가 주문 및 가시성을 보장하는 시점을 정확하게 설명하고 수작업으로 코드를 보장하는 휴대용 펜스를 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eee5a298db9fd75c07be2a97a1f2cd772c53c044" translate="yes" xml:space="preserve">
          <source>Now, on a modern CPU, ensuring sequential consistency can be expensive.  In particular, the compiler is likely to emit full-blown memory barriers between every access here.  But if your algorithm can tolerate out-of-order loads and stores; i.e., if it requires atomicity but not ordering; i.e., if it can tolerate &lt;code&gt;37 0&lt;/code&gt; as output from this program, then you can write this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 최신 CPU에서는 순차 일관성을 보장하는 데 많은 비용이들 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히, 컴파일러는 여기에서 모든 액세스 사이에 완전한 메모리 장벽을 방출 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 알고리즘이 비 순차적로드 및 저장을 허용 할 수있는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 원 자성이 필요하지만 순서는 필요하지 않은 경우; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 프로그램의 출력으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;견딜 수 있다면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같이 쓸 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afbc13c7de8832aebd18cbbb2425e879034c8384" translate="yes" xml:space="preserve">
          <source>Of course, if the only outputs you want to see are &lt;code&gt;0 0&lt;/code&gt; or &lt;code&gt;37 17&lt;/code&gt;, you can just wrap a mutex around the original code.  But if you have read this far, I bet you already know how that works, and this answer is already longer than I intended :-).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론보고자하는 유일한 출력이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인 경우 원래 코드를 뮤텍스로 감쌀 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 지금까지 읽었다면 어떻게 작동하는지 이미 알고 있으며이 답변은 이미 의도 한 것보다 깁니다. :-).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68874039d4d2159d92f53eba89bd0c6425b0ef3b" translate="yes" xml:space="preserve">
          <source>Of course, you can write multi-threaded code in practice for particular concrete systems &amp;ndash; like pthreads or Windows.  But there is no &lt;em&gt;standard&lt;/em&gt; way to write multi-threaded code for C++98/C++03.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 pthread 또는 Windows와 같은 특정 콘크리트 시스템에 실제로 다중 스레드 코드를 작성할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 / C ++ 03을위한 멀티 스레드 코드를 작성하는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표준&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 방법 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8435b89912ba1ee2404f40a7e7f7c76f17be4d3" translate="yes" xml:space="preserve">
          <source>Optimizations, Races, and the Memory Model</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최적화, 레이스 및 메모리 모델&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc6f83f22e321f881624f0112b2350e6a011d9b4" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; How: Mutexes, Atomics, and/or Fences</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주문 &amp;ndash; 방법 : 뮤텍스, 원자 및 / 또는 울타리&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d394933e2ba8b9e6307eee9284401ab051f6b9a" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; What: Acquire and Release</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주문 &amp;ndash; 무엇 : 획득 및 릴리스&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bfcf5ca2e968cb080e4e46edc82078a505a9d92" translate="yes" xml:space="preserve">
          <source>Other Restrictions on Compilers and Hardware</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러 및 하드웨어에 대한 기타 제한&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd65ea6941c8d670b393810b2c47552d6cf25df8" translate="yes" xml:space="preserve">
          <source>Previously, atomics would be done using compiler intrinsics, or some higher level library. Fences would have been done using CPU-specific instructions (memory barriers).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전에는 원자가 컴파일러 내장 함수 또는 일부 상위 레벨 라이브러리를 사용하여 수행되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;펜스는 CPU 관련 지침 (메모리 장벽)을 사용하여 수행되었을 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e56b625d9ce23edadcdce014336b90a101f8934" translate="yes" xml:space="preserve">
          <source>Quoting from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;메모리 일관성 및 캐시 일관성에 대한 입문서&quot;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 인용&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bb9db0f94440715855f11a33ea0a95909964dfda" translate="yes" xml:space="preserve">
          <source>Readers familiar with Einstein&amp;rsquo;s &lt;strong&gt;Special Theory of Relativity&lt;/strong&gt; will notice what I am alluding to. Translating Minkowski&amp;rsquo;s words into the memory models realm: address space and time are shadows of address-space-time. In this case, each observer (i.e., thread) will project shadows of events (i.e., memory stores/loads) onto his own world-line (i.e., his time axis) and his own plane of simultaneity (his address-space axis). Threads in the C++11 memory model correspond to &lt;strong&gt;&lt;em&gt;observers&lt;/em&gt;&lt;/strong&gt; that are moving relative to each other in special relativity. Sequential consistency corresponds to the &lt;strong&gt;Galilean space-time&lt;/strong&gt; (i.e., all observers agree on one absolute order of events and a global sense of simultaneity).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아인슈타인의 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특수 상대성 이론에&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 익숙한 독자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;들은 내가 암시하는 것을 알아 차릴 것입니다. Minkowski의 단어를 메모리 모델 영역으로 변환 : 주소 공간 및 시간은 주소 공간 시간의 그림자입니다. 이 경우 각 관찰자 (예 : 스레드)는 이벤트의 그림자 (예 : 메모리 저장소 /로드)를 자신의 월드 라인 (예 : 시간 축) 및 자체 동시 평면 (주소 공간 축)에 투영합니다. . C ++ 11 메모리 모델의 스레드는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특수 상대성 관계에서 서로에 대해 상대적으로 움직이는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;관찰자에&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해당합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 순차 일관성은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;갈릴리 언 시공간에&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해당합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(즉, 모든 관찰자는 하나의 절대적 순서의 이벤트와 글로벌 동시성에 동의합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a133e211f7560a29b9da4d6be92f2a22755b5da2" translate="yes" xml:space="preserve">
          <source>Relaxed Atomics</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편안한 원자&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="957e61e62046dd3ea5b6cfe1f86136d6473da53c" translate="yes" xml:space="preserve">
          <source>So, bottom line. Mutexes are great, and C++11 standardizes them. But sometimes for performance reasons you want lower-level primitives (e.g., the classic &lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;double-checked locking pattern&lt;/a&gt;).  The new standard provides high-level gadgets like mutexes and condition variables, and it also provides low-level gadgets like atomic types and the various flavors of memory barrier.  So now you can write sophisticated, high-performance concurrent routines entirely within the language specified by the standard, and you can be certain your code will compile and run unchanged on both today's systems and tomorrow's.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결론입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뮤텍스는 훌륭하고 C ++ 11은 그것들을 표준화합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 때때로 성능상의 이유로 하위 레벨 기본 요소 (예 : 클래식 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 검사 잠금 패턴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 원합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 표준은 뮤텍스 및 조건 변수와 같은 고급 가젯을 제공하며 원자 유형 및 다양한 메모리 장벽과 같은 하위 수준 가젯을 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 표준에 의해 지정된 언어 내에서 정교한 고성능 동시 루틴을 작성할 수 있으며 오늘날의 시스템과 내일의 코드에서 코드가 컴파일되고 변경되지 않을 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76ca6da28f8d79dbdb145dfa98920e0946014d84" translate="yes" xml:space="preserve">
          <source>Store-store reordering may happen if a core has a non-FIFO write buffer that lets stores depart in a different order than the order in which they entered. This might occur if the first store misses in the cache while the second hits or if the second store can coalesce with an earlier store (i.e., before the first store). Load-load reordering may also happen on dynamically-scheduled cores that execute instructions out of program order. That can behave the same as reordering stores on another core (Can you come up with an example interleaving between two threads?). Reordering an earlier load with a later store (a load-store reordering) can cause many incorrect behaviors, such as loading a value after releasing the lock that protects it (if the store is the unlock operation). Note that store-load reorderings may also arise due to local bypassing in the commonly implemented FIFO write buffer, even with a core that executes all instructions in program order.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코어에 비 FIFO 쓰기 버퍼가있어 저장소가 입력 한 순서와 다른 순서로 출발 할 수 있도록하면 저장소 저장소 순서가 바뀔 수 있습니다. 이는 두 번째 적중시 첫 번째 상점이 캐시에서 누락되거나 두 번째 상점이 이전 상점과 통합 될 수있는 경우 (즉, 첫 번째 상점 이전)에 발생할 수 있습니다. 로드 순서 재정렬은 프로그램 순서를 벗어난 명령을 실행하는 동적으로 예약 된 코어에서도 발생할 수 있습니다. 그것은 다른 코어에서 상점을 재정렬하는 것과 동일하게 작동 할 수 있습니다 (두 스레드 사이에 인터리빙 예제가있을 수 있습니까?). 이후의 저장소 (로드 저장소 순서 변경)로 이전로드를 다시 정렬하면 잠금을 해제 한 후 값을로드하는 등의 잘못된 동작 (예 : 저장소가 잠금 해제 작업 인 경우)이 발생할 수 있습니다.모든 명령을 프로그램 순서대로 실행하는 코어가 있더라도 일반적으로 구현되는 FIFO 쓰기 버퍼에서 로컬 바이 패스로 인해 저장소로드 재정렬이 발생할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="452c86d05004baf5f9579835c1ee31f42e9f5ebb" translate="yes" xml:space="preserve">
          <source>That global memory order can vary from one run of the program to another and may not be known beforehand. The characteristic feature of SC is the set of horizontal slices in the address-space-time diagram representing &lt;strong&gt;&lt;em&gt;planes of simultaneity&lt;/em&gt;&lt;/strong&gt; (i.e., memory images). On a given plane, all of its events (or memory values) are simultaneous. There is a notion of &lt;em&gt;Absolute Time&lt;/em&gt;, in which all threads agree on which memory values are simultaneous. In SC, at every time instant, there is only one memory image shared by all threads. That's, at every instant of time, all processors agree on the memory image (i.e., the aggregate content of memory). Not only does this imply that all threads view the same sequence of values for all memory locations, but also that all processors observe the same &lt;em&gt;combinations of values&lt;/em&gt; of all variables. This is the same as saying all memory operations (on all memory locations) are observed in the same total order by all threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 전역 메모리 순서는 프로그램 실행마다 다를 수 있으며 미리 알 수 없습니다. SC의 특징 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 동시&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;평면&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (즉, 메모리 이미지)을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나타내는 어드레스-스페이스-시간 다이어그램에서 수평 슬라이스 세트이다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 지정된 평면에서 모든 이벤트 (또는 메모리 값)가 동시에 발생합니다. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Absolute Time&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 개념은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 스레드가 어떤 메모리 값이 동시에 일치하는지 동의합니다. SC에서는 매 순간마다 모든 스레드가 공유하는 메모리 이미지가 하나만 있습니다. 즉, 모든 순간에 모든 프로세서가 메모리 이미지 (즉, 총 메모리 내용)에 동의합니다. 이것은 모든 스레드가 모든 메모리 위치에 대해 동일한 순서의 값을 볼뿐 아니라 모든 프로세서가 동일한 것을 관찰한다는 것을 의미합니다&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 변수 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 값 조합&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 이것은 모든 메모리 위치에서 모든 메모리 작업이 모든 스레드에 의해 동일한 총 순서로 관찰된다는 것과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d61648d21c81fd8a8c43e5576aa0e6b82a4218f" translate="yes" xml:space="preserve">
          <source>The C++ specification does not make reference to any particular compiler, operating system, or CPU.  It makes reference to an &lt;em&gt;abstract machine&lt;/em&gt; that is a generalization of actual systems.  In the Language Lawyer world, the job of the programmer is to write code for the abstract machine; the job of the compiler is to actualize that code on a concrete machine.  By coding rigidly to the spec, you can be certain that your code will compile and run without modification on any system with a compliant C++ compiler, whether today or 50 years from now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 사양은 특정 컴파일러, 운영 체제 또는 CPU를 참조하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제 시스템의 일반화 인 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추상 기계&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. 언어 변호사 세계에서 프로그래머의 임무는 추상 기계의 코드를 작성하는 것입니다. 컴파일러의 임무는 콘크리트 기계에서 해당 코드를 실현하는 것입니다. 사양을 엄격하게 코딩하면 코드가 현재 또는 50 년 이후에 호환되는 C ++ 컴파일러를 사용하는 시스템에서 수정없이 컴파일되고 실행될 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d29c58cddb456581d9728a1ab2e5337bca78fb3" translate="yes" xml:space="preserve">
          <source>The above answers get at the most fundamental aspects of the C++ memory model.  In practice, most uses of &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &quot;just work&quot;, at least until the programmer over-optimizes (e.g., by trying to relax too many things).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 답변은 C ++ 메모리 모델의 가장 기본적인 측면을 보여줍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;just just&quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 대부분의 사용은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최소한 프로그래머가 과도하게 최적화 될 때까지 (예를 들어, 너무 많은 것들을 이완 시키려고 시도 함).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7d00aae881b6e2acf7384c58de1730263886b2d" translate="yes" xml:space="preserve">
          <source>The abstract machine in C++11 is multi-threaded by design.  It also has a well-defined &lt;em&gt;memory model&lt;/em&gt;; that is, it says what the compiler may and may not do when it comes to accessing memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11의 추상 머신은 설계 상 다중 스레드입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 잘 정의 된 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 모델을 가지고 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 메모리에 액세스 할 때 컴파일러에서 수행 할 수있는 작업과 수행 할 수없는 작업을 나타냅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7f894cea908d237d3941c58a3365a1963366b6e" translate="yes" xml:space="preserve">
          <source>The abstract machine in the C++98/C++03 specification is fundamentally single-threaded.  So it is not possible to write multi-threaded C++ code that is &quot;fully portable&quot; with respect to the spec.  The spec does not even say anything about the &lt;em&gt;atomicity&lt;/em&gt; of memory loads and stores or the &lt;em&gt;order&lt;/em&gt; in which loads and stores might happen, never mind things like mutexes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 / C ++ 03 사양의 추상 머신은 기본적으로 단일 스레드입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 스펙과 관련하여 &quot;완전히 이식 가능한&quot;멀티 스레드 C ++ 코드를 작성할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스펙은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리로드 및 저장 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원 자성&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로드 및 저장이 발생할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;순서&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대해 아무 것도 말하지 않으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뮤텍스와 같은 것을 신경 쓰지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4baedfd0f1527134631c5de1c75f35afd5945f2" translate="yes" xml:space="preserve">
          <source>The intuitive (and most restrictive) memory model is sequential consistency (SC) in which a multithreaded execution should look like an interleaving of the sequential executions of each constituent thread, as if the threads were time-multiplexed on a single-core processor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직관적이고 가장 제한적인 메모리 모델은 멀티 스레드 실행이 마치 단일 코어 프로세서에서 스레드가 시간 멀티플렉싱 된 것처럼 각 구성 스레드의 순차적 실행 인터리빙처럼 보이는 순차 일관성 (SC)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="754d4bff03e3971b47d96374564e1cbbaae1e141" translate="yes" xml:space="preserve">
          <source>The last issue is that it might be unnatural to make the &lt;code&gt;data&lt;/code&gt; variables atomic.  If you can't in your code, then you need to be very careful, because casting from non-atomic to atomic is only legal for primitive types.  C++20 is supposed to add &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt;, which will make this problem easier to resolve.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막 문제는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;data&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 변수를 원자 적 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로 만드는 것이 부자연 스럽다는 것 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드를 사용할 수 없으면 원자가 아닌 원자에서 원자로 캐스트하는 것은 기본 유형에만 유효하기 때문에 매우주의해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 20은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 추가해야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하므로이&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 문제를 쉽게 해결할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfd6846aacd447221a1a226955bb117560edf61a" translate="yes" xml:space="preserve">
          <source>The memory model means that C++ code
  now has a standardized library to call
  regardless of who made the compiler
  and on what platform it's running.
  There's a standard way to control how
  different threads talk to the
  processor's memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 모델은 C ++ 코드에 컴파일러를 만든 사람과 실행중인 플랫폼에 관계없이 호출 할 표준화 된 라이브러리가 있음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 스레드가 프로세서의 메모리와 통신하는 방식을 제어하는 ​​표준 방법이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e82744a21c2c2bfb15618db64d694bdd7c9e7e9" translate="yes" xml:space="preserve">
          <source>The more modern the CPU, the more likely this is to be faster than the previous example.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최신 CPU 일수록 이전 예보다 더 빠를 가능성이 높습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f139b606c7fb2fc6086b230c6282ff5ce683f53" translate="yes" xml:space="preserve">
          <source>The paper gives a few solutions.  The one with the best performance today is probably the one that uses an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_relaxed&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; the second read of the seqlock.  In the paper, it's Figure 6.  I'm not reproducing the code here, because anyone who has read this far really ought to read the paper.  It is more precise and complete than this post.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 논문은 몇 가지 해결책을 제시합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오늘날 최고의 성능을 가진 것은 아마도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;seqlock의 두 번째 읽기 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전에 &lt;/font&gt;&lt;/em&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 함께 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_thread_fence&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하는 것일 것입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문서에서는 그림 6입니다.이 코드를 지금까지 읽은 사람은 실제로이 문서를 읽어야하기 때문에 코드를 재생산하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 게시물보다 더 정확하고 완벽합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8ce878fb4b44eaa5f2ed3bf4b3939bc5a23cc2b" translate="yes" xml:space="preserve">
          <source>The resemblance between memory models and special relativity stems from the fact that both define a partially-ordered set of events, often called a causal set. Some events (i.e., memory stores) can affect (but not be affected by) other events. A C++11 thread (or observer in physics) is no more than a chain (i.e., a totally ordered set) of events (e.g., memory loads and stores to possibly different addresses).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 모델과 특수 상대성 이론의 유사성은 둘 다 부분적으로 정렬 된 이벤트 세트를 종종 인과 세트라고 정의한다는 사실에서 비롯됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 이벤트 (예 : 메모리 저장소)는 다른 이벤트에 영향을 줄 수 있지만 영향을받지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 스레드 (또는 물리 관찰자)는 이벤트 (예 : 메모리로드 및 가능한 다른 주소에 저장)의 체인 (즉, 완전히 정렬 된 집합)에 지나지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88614ce284b9f9ee72002ba72a19fbcc1fb2fe6e" translate="yes" xml:space="preserve">
          <source>The talk doesn't elaborate on the API, but rather on the reasoning, background, under the hood and behind the scenes (did you know relaxed semantics were added to the standard only because POWER and ARM do not support synchronized load efficiently?).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 강의는 API에 대한 설명이 아니라 오히려 추론, 배경, 배경 및 배경 뒤에서 설명합니다 (POWER 및 ARM은 동기화 된로드를 효율적으로 지원하지 않기 때문에 완화 된 의미가 표준에 추가되었다는 것을 알고 있습니까?).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46e71907ae6df91d5f8c4646edd42cd31a4d2600" translate="yes" xml:space="preserve">
          <source>There is one place where mistakes are still common: &lt;em&gt;sequence locks&lt;/em&gt;.  There is an excellent and easy-to-read discussion of the challenges at &lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/a&gt;.  Sequence locks are appealing because the reader avoids writing to the lock word.  The following code is based on Figure 1 of the above technical report, and it highlights the challenges when implementing sequence locks in C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실수가 여전히 흔한 곳은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sequence locks&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 문제에 대한 훌륭하고 읽기 쉬운 토론이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 독자가 잠금 단어에 쓰지 않기 때문에 시퀀스 잠금이 매력적입니다. 다음 코드는 위 기술 보고서의 그림 1을 기반으로하며 C ++에서 시퀀스 잠금을 구현할 때의 문제를 강조합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="961c454b5b699e3c67051c83eb5d379453c92717" translate="yes" xml:space="preserve">
          <source>This takes us back to the ordered loads and stores &amp;ndash; so &lt;code&gt;37 0&lt;/code&gt; is no longer a possible output &amp;ndash; but it does so with minimal overhead.  (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이로 인해 주문 된로드 및 저장으로 되돌아 가게되므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 더 이상 가능한 출력이 아니지만 최소한의 오버 헤드로 수행됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(이 사소한 예에서 결과는 완전한 순차적 일관성과 동일하지만 더 큰 프로그램에서는 그렇지 않습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e039b9566e8dfbf0f2a3944c91a446a0d3877578" translate="yes" xml:space="preserve">
          <source>To provide a definition of memory consistency and a motivation for abandoning SC, I will quote from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 일관성에 대한 정의와 SC를 포기하는 동기를 제공하기 위해 &lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;메모리 일관성 및 캐시 일관성에 대한 입문서&quot;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 인용하겠습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf70e99ebffe9e92e5be11ffc6e48ebef4aad770" translate="yes" xml:space="preserve">
          <source>To summarize: even if you think you understand the C++ memory model, you should be very careful before rolling your own sequence locks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요약하자면, C ++ 메모리 모델을 이해한다고 생각하더라도 시퀀스 잠금을 롤링하기 전에 매우주의해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5f2312cd34bd31141d0b81cd0bd16779840debfa" translate="yes" xml:space="preserve">
          <source>Under C++11, the result is Undefined Behavior, because loads and stores need not be atomic in general.  Which may not seem like much of an improvement...  And by itself, it's not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11에서는로드 및 저장이 일반적으로 원자 일 필요가 없기 때문에 결과는 정의되지 않은 동작입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어느 정도 개선되지 않은 것처럼 보일 수 있습니다 ... 그리고 그 자체로는 그렇지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b9f7556c864ccbfde77ebfd4adde349b5488e4fa" translate="yes" xml:space="preserve">
          <source>Under C++98/C++03, this is not even Undefined Behavior; the question itself is &lt;em&gt;meaningless&lt;/em&gt; because the standard does not contemplate anything called a &quot;thread&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 / C ++ 03에서 이것은 정의되지 않은 동작도 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표준은 &quot;스레드&quot;라고 불리는 것을 고려하지 않기 때문에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;질문 자체는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의미&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ce2b632d1c58188c735ed2a0e6024043931901f" translate="yes" xml:space="preserve">
          <source>Unlike consistency, &lt;strong&gt;&lt;em&gt;cache coherence&lt;/em&gt;&lt;/strong&gt; is neither visible to software nor required. Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system. Correct coherence ensures that a programmer cannot determine whether and where a system has caches by analyzing the results of loads and stores. This is because correct coherence ensures that the caches never enable new or different &lt;strong&gt;&lt;em&gt;functional&lt;/em&gt;&lt;/strong&gt; behavior (programmers may still be able to infer likely cache structure using &lt;strong&gt;&lt;em&gt;timing&lt;/em&gt;&lt;/strong&gt; information). The main purpose of cache coherence protocols is maintaining the single-writer-multiple-readers (SWMR) invariant for every memory location.
  An important distinction between coherence and consistency is that coherence is specified on a &lt;strong&gt;&lt;em&gt;per-memory location basis&lt;/em&gt;&lt;/strong&gt;, whereas consistency is specified with respect to &lt;strong&gt;&lt;em&gt;all&lt;/em&gt;&lt;/strong&gt; memory locations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일관성과 달리 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캐시 일관성&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 소프트웨어에 표시되거나 필요하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일관성은 공유 메모리 시스템의 캐시를 단일 코어 시스템의 캐시처럼 기능적으로 보이지 않게하려고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;올바른 일관성은 프로그래머가로드 및 저장 결과를 분석하여 시스템에 캐시가 있는지 여부를 판별 할 수 없도록합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정확한 일관성은 캐시가 새로운 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기능&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이나 다른 &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기능적&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 동작을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가능하게하지 않기 때문입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(프로그래머는 여전히 &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;타이밍을&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하여 캐시 구조를 유추 할 수 있음)&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정보). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캐시 일관성 프로토콜의 주요 목적은 모든 메모리 위치에 대해 SWMR (Single-Writer-Multiple-Reader)을 유지하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일관성과 일관성 사이의 중요한 차이점은 일관성은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 당 위치별로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 지정되는 반면 일관성은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메모리 위치 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 관련하여 지정된다는 &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfacfcd81cfcca293eba3cc7493531d81a4a1b4d" translate="yes" xml:space="preserve">
          <source>Very importantly, locks (and concurrency semantics with locking) are typically implemented in a cross platform way... So if you are using standard locks in a multithreaded program with no data races then you &lt;strong&gt;don't have to worry about cross platform memory models&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매우 중요한 것은 잠금 (및 잠금 기능이있는 동시성 의미론)은 일반적으로 크로스 플랫폼 방식으로 구현됩니다. 따라서 데이터 레이스가없는 다중 스레드 프로그램에서 표준 잠금을 사용하는 경우 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;크로스 플랫폼 메모리 모델에 대해 걱정할 필요가 없습니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e4a2ca5a3d05ddfbe2b56ccb6104a75cae606ef" translate="yes" xml:space="preserve">
          <source>Well, I can &lt;em&gt;memorize&lt;/em&gt; this and similar paragraphs available online (as I've had my own memory model since birth :P) and can even post as an answer to questions asked by others, but to be honest, I don't exactly understand this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 나는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;온라인에서 사용할 수있는이 단락과 유사한 단락을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;암기&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할 수있다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(출생 후 내 자신의 기억 모델을 가지고 있기 때문에 : P) 심지어 다른 사람들이 질문 한 질문에 대한 답변으로 게시 할 수는 있지만 정직하게 이해하지 못한다. 이.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="956fcc4400c935b51349b1224fcb0216fed90fc4" translate="yes" xml:space="preserve">
          <source>What it cannot print is &lt;code&gt;37 0&lt;/code&gt;, because the default mode for atomic loads/stores in C++11 is to enforce &lt;em&gt;sequential consistency&lt;/em&gt;.  This just means all loads and stores must be &quot;as if&quot; they happened in the order you wrote them within each thread, while operations among threads can be interleaved however the system likes.  So the default behavior of atomics provides both &lt;em&gt;atomicity&lt;/em&gt; and &lt;em&gt;ordering&lt;/em&gt; for loads and stores.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11에서 원자로드 / 스토어의 기본 모드는 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;순차 일관성을 유지&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하기 때문에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인쇄 할 수없는 것은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. 이것은 모든로드와 저장소가 각 스레드 내에서 작성한 순서대로 &quot;있는 것처럼&quot;발생해야한다는 것을 의미하지만 스레드 간의 작업은 인터리브 될 수 있지만 시스템은 좋아합니다. 그래서 아토의 기본 동작은 모두 제공 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자성&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주문&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로드 및 저장에 대한합니다.&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fd897db0b1892f92d3ac2bb9df198d5229ab212" translate="yes" xml:space="preserve">
          <source>What might Thread 2 output?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 2가 무엇을 출력 할 수 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1798b5cddeecf3effcaf30a3ce667c57f5b3451d" translate="yes" xml:space="preserve">
          <source>When you're talking about POSIX threads or Windows threads, then this is a bit of an illusion as actually you're talking about x86 threads, as it's a hardware function to run concurrently. The C++0x memory model makes guarantees, whether you're on x86, or ARM, or &lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;MIPS&lt;/a&gt;, or anything else you can come up with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;POSIX 스레드 또는 Windows 스레드에 대해 이야기 할 때 이는 실제로 실행되는 하드웨어 기능이기 때문에 실제로 x86 스레드에 대해 이야기하는 것처럼 약간의 환상입니다. C ++ 0x 메모리 모델은 x86, ARM 또는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MIPS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 기타 모든 것을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보장합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76cbbb6015ca76bb55e457fa170621f939633ebe" translate="yes" xml:space="preserve">
          <source>[Picture from Wikipedia]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[위키 백과의 그림]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
