<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6319146">
    <body>
      <group id="6319146">
        <trans-unit id="73df4e1cfb97a0cf2c29a8c07e2bb86731b5d146" translate="yes" xml:space="preserve">
          <source>&quot;When you are talking about splitting
  [code] across different cores that's
  in the standard, we are talking about
  the memory model. We are going to
  optimize it without breaking the
  following assumptions people are going
  to make in the code,&quot; &lt;strong&gt;Sutter&lt;/strong&gt; said.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;当您谈论在标准中的不同内核之间拆分[代码]时，我们正在谈论内存模型。我们将对其进行优化，而不会破坏人们在代码中做出的以下假设，&amp;rdquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sutter&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;说。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d15a3a1c7c247d44171f5a6070b968d22cecb393" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;This article&lt;/a&gt; (by &lt;strong&gt;Gavin Clarke&lt;/strong&gt; who quotes &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/strong&gt;) says that,</source>
          <target state="translated">&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这篇文章&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（由&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加文&amp;middot;克拉克&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Gavin Clarke&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）引用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;赫伯&amp;middot;萨特&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）表示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="731c13310aa9d76029890ec2d9fe270b4e77f4e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Relaxed&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;weak&lt;/em&gt;&lt;/strong&gt; memory consistency models are motivated by the fact that most memory orderings in strong models are unnecessary. If a thread updates ten data items and then a synchronization flag, programmers usually do not care if the data items are updated in order with respect to each other but only that all data items are updated before the flag is updated (usually implemented using FENCE instructions). Relaxed models seek to capture this increased ordering flexibility and preserve only the orders that programmers &amp;ldquo;&lt;em&gt;require&lt;/em&gt;&amp;rdquo; to get both higher performance and correctness of SC. For example, in certain architectures, FIFO write buffers are used by each core to hold the results of committed (retired) stores before writing the results to the caches. This optimization enhances performance but violates SC. The write buffer hides the latency of servicing a store miss. Because stores are common, being able to avoid stalling on most of them is an important benefit. For a single-core processor, a write buffer can be made architecturally invisible by ensuring that a load to address A returns the value of the most recent store to A even if one or more stores to A are in the write buffer. This is typically done by either bypassing the value of the most recent store to A to the load from A, where &amp;ldquo;most recent&amp;rdquo; is determined by program order, or by stalling a load of A if a store to A is in the write buffer. When multiple cores are used, each will have its own bypassing write buffer. Without write buffers, the hardware is SC, but with write buffers, it is not, making write buffers architecturally visible in a multicore processor.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;宽松&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;弱的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存一致性模型是由以下事实引起的：强模型中的大多数内存排序都是不必要的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果一个线程先更新十个数据项，然后再更新一个同步标志，则程序员通常不在乎数据项是否相对于彼此依次更新，而只是在更新标志之前仅更新所有数据项（通常使用FENCE指令实现） ）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;宽松的模型试图捕获这种增加的排序灵活性，并仅保留程序员&amp;ldquo;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的订单&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;rdquo;，以获得更高的性能和SC的正确性。例如，在某些架构中，每个内核使用FIFO写缓冲区来保存已提交（已退休）存储的结果，然后再将结果写入高速缓存。此优化可提高性能，但会违反SC。写缓冲区隐藏了为存储未命中服务的等待时间。由于商店很常见，因此能够避免大多数商店停滞是一个重要的好处。对于单核处理器，通过确保对地址A的加载将最新存储的值返回到A，即使在A上有一个或多个存储，也可以使写缓冲区在体系结构上不可见。通常可以通过以下方式完成此操作：将最新存储的值绕过A到A的加载，其中&amp;ldquo;最新&amp;rdquo;由程序顺序确定，或者如果写入缓冲区中存储有A，则通过停止A的负载来完成。当使用多个内核时，每个内核都有自己的旁路写缓冲区。没有写缓冲区，硬件是SC，但是没有写缓冲区，则硬件使SC在多核处理器中在体系结构上可见。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a24014293b7e7f3c3957b75dbba2b33ce19b2765" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is now a multiple-year old question, but being very popular, it's worth mentioning a fantastic resource for learning about the C++11 memory model. I see no point in summing up his talk in order to make this yet another full answer, but given this is the guy who actually wrote the standard, I think it's well worth watching the talk.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个已有多年历史的问题，但是它非常受欢迎，值得一提的是一个很棒的资源，可以用来学习C ++ 11内存模型。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我想总结一下他的演讲以给出另一个完整的答案没有任何意义，但是鉴于这实际上是编写标准的人，我认为值得一听。&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fea15c028fa16edd68a84950f92fa70a42f3fac8" translate="yes" xml:space="preserve">
          <source>Although to be frank, unless you are an expert and working on some serious low-level code, you should probably stick to mutexes and condition variables.  That's what I intend to do.</source>
          <target state="translated">虽然老实说,除非你是个专家,而且是在处理一些严重的低级代码,否则你可能应该坚持使用mutexes和条件变量。这就是我打算做的事情。</target>
        </trans-unit>
        <trans-unit id="3ad19cd05e2aca3350a1896cdfb856a60997442f" translate="yes" xml:space="preserve">
          <source>As I don't know how the internals of multi-threading work, and what memory model means in general, please help me understand these concepts. :-)</source>
          <target state="translated">由于我不知道多线程的内部工作原理,也不知道内存模型是什么意思,请帮我理解这些概念。)</target>
        </trans-unit>
        <trans-unit id="73edd169fb02675391ad1960b83d93b7512986a3" translate="yes" xml:space="preserve">
          <source>As unintuitive as it seams at first, &lt;code&gt;data1&lt;/code&gt; and &lt;code&gt;data2&lt;/code&gt; need to be &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt;.  If they are not atomic, then they could be read (in &lt;code&gt;reader()&lt;/code&gt;) at the exact same time as they are written (in &lt;code&gt;writer()&lt;/code&gt;).  According to the C++ memory model, this is a race &lt;em&gt;even if &lt;code&gt;reader()&lt;/code&gt; never actually uses the data&lt;/em&gt;.  In addition, if they are not atomic, then the compiler can cache the first read of each value in a register.  Obviously you wouldn't want that... you want to re-read in each iteration of the &lt;code&gt;while&lt;/code&gt; loop in &lt;code&gt;reader()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;乍看起来似乎很不直观，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;data1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;data2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。如果它们不是原子的，则可以在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们被写入（在&lt;/font&gt; &lt;code&gt;writer()&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对其进行读取&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。根据C ++内存模型，&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使&lt;/font&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从未实际使用data&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这也是一场竞赛&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。另外，如果它们不是原子的，则编译器可以将每个值的第一次读取缓存在寄存器中。显然，您不希望...您希望&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;循环的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次迭代中重新读取&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4a622ff9ae0214ed05a333e5d2cd4c3f0640dc8" translate="yes" xml:space="preserve">
          <source>Because cache coherence and memory consistency are sometimes confused, it is instructive to also have this quote:</source>
          <target state="translated">因为缓存一致性和内存一致性有时会被混淆,所以这句话也是有指导意义的。</target>
        </trans-unit>
        <trans-unit id="934437c0109e42d4fd367073bdd77200fe18bf44" translate="yes" xml:space="preserve">
          <source>But with C++11, you can write this:</source>
          <target state="translated">但用C++11,你可以这样写。</target>
        </trans-unit>
        <trans-unit id="c3419e7bfb7b912c1de58267196ef1715f03d520" translate="yes" xml:space="preserve">
          <source>C and C++ used to be defined by an execution trace of a well formed program.</source>
          <target state="translated">C和C++过去是由一个好的程序的执行轨迹来定义的。</target>
        </trans-unit>
        <trans-unit id="f714f1f168010e0e48c54ceb767d70850b43f535" translate="yes" xml:space="preserve">
          <source>C++ programmers used to develop multi-threaded applications even before, so how does it matter if it's POSIX threads, or Windows threads, or C++11 threads? What are the benefits? I want to understand the low-level details.</source>
          <target state="translated">C++程序员在以前就已经习惯于开发多线程的程序,那么是POSIX线程,还是Windows线程,还是C++11线程又有什么关系呢?有什么好处呢?我想了解一下底层的细节。</target>
        </trans-unit>
        <trans-unit id="c804136fc25fd72d45e9ed77db0496ceaaa13a5e" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model, but what exactly does that mean? And how is it going to affect C++ programming?</source>
          <target state="translated">C++11引入了标准化的内存模型,但这究竟意味着什么?它又会对C++编程产生怎样的影响呢?</target>
        </trans-unit>
        <trans-unit id="b31ce9265efcb7ae003d188e0fcacad2174b4301" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model. What does it mean? And how is it going to affect C++ programming</source>
          <target state="translated">C++11引入了一个标准化的内存模型。它意味着什么?它又会对C++编程产生怎样的影响?</target>
        </trans-unit>
        <trans-unit id="1071914933f07012e3e0261ffb0513754c189cf3" translate="yes" xml:space="preserve">
          <source>Code Gen &amp;amp; Performance: x86/x64, IA64, POWER, ARM</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码生成和性能：x86 / x64，IA64，POWER，ARM&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70cb8dd903b1de610462040edfa72807d0c75c0f" translate="yes" xml:space="preserve">
          <source>Consider the following example, where a pair of global variables are accessed concurrently by two threads:</source>
          <target state="translated">考虑下面的例子,两个线程并发访问一对全局变量。</target>
        </trans-unit>
        <trans-unit id="5e777ba92d2f70816c7b8e0a710d0cd2e088bf50" translate="yes" xml:space="preserve">
          <source>Continuing with our mental picture, the SWMR invariant corresponds to the physical requirement that there be at most one particle located at any one location but there can be an unlimited number of observers of any location.</source>
          <target state="translated">继续我们的心智图,SWMR不变量对应于物理要求,即在任何一个地点最多只有一个粒子,但任何地点的观察者数量可以是无限的。</target>
        </trans-unit>
        <trans-unit id="1ccda8a650443d20e5e10efff7eff75f39de7479" translate="yes" xml:space="preserve">
          <source>Finally, if you just need to keep particular loads and stores in order, you can write:</source>
          <target state="translated">最后,如果你只是需要保持特定的负载和存储的顺序,你可以写。</target>
        </trans-unit>
        <trans-unit id="95b21e94883bf869fa456f6fee7bcd0aede60da8" translate="yes" xml:space="preserve">
          <source>First, you have to learn to think like a Language Lawyer.</source>
          <target state="translated">首先,你要学会像语言律师那样思考。</target>
        </trans-unit>
        <trans-unit id="f764c87baa07b4d9b69d806e43e35de480f00596" translate="yes" xml:space="preserve">
          <source>For a shared memory machine, the memory consistency model defines the architecturally visible behavior of its memory system. The correctness criterion for a single processor core partitions behavior between &amp;ldquo;&lt;em&gt;one correct result&lt;/em&gt;&amp;rdquo; and &amp;ldquo;&lt;em&gt;many incorrect alternatives&lt;/em&gt;&amp;rdquo;. This is because the processor&amp;rsquo;s architecture mandates that the execution of a thread transforms a given input state into a single well-defined output state, even on an out-of-order core. Shared memory consistency models, however, concern the loads and stores of multiple threads and usually allow &lt;em&gt;many correct executions&lt;/em&gt; while disallowing many (more) incorrect ones. The possibility of multiple correct executions is due to the ISA allowing multiple threads to execute concurrently, often with many possible legal interleavings of instructions from different threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于共享内存机器，内存一致性模型定义其内存系统在体系结构上可见的行为。单处理器内核的正确性标准将行为划分为&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个正确的结果&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;和&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;许多不正确的选择&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;之间。这是因为处理器的体系结构要求，即使在无序的内核上，线程的执行也可以将给定的输入状态转换为定义良好的单个输出状态。但是，共享内存一致性模型涉及多个线程的负载和存储，并且通常允许&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;许多正确的执行&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时禁止许多（更多）不正确的代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多次正确执行的可能性归因于ISA允许多个线程同时执行，并且通常可能对来自不同线程的指令进行许多合法的交织。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3a3531d42219943e36c390c1d09394dda7f26" translate="yes" xml:space="preserve">
          <source>For languages not specifying a memory model, you are writing code for the language &lt;em&gt;and&lt;/em&gt; the memory model specified by the processor architecture. The processor may choose to re-order memory accesses for performance. So, &lt;strong&gt;if your program has data races&lt;/strong&gt; (a data race is when it's possible for multiple cores / hyper-threads to access the same memory concurrently) then your program is not cross platform because of its dependence on the processor memory model. You may refer to the Intel or AMD software manuals to find out how the processors may re-order memory accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于未指定内存模型的语言，您正在为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;处理器架构指定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的语言&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存模型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。处理器可以选择重新排序内存访问以提高性能。因此，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您的程序存在数据&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;争用（数据争用是指多个内核/超线程有可能同时访问同一内存），则您的程序就不会跨平台，因为它依赖处理器内存模型。您可以参考Intel或AMD软件手册，以了解处理器如何重新排序内存访问。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ef316ccb8a21361d46e5437050816b42e490adc" translate="yes" xml:space="preserve">
          <source>For more on this stuff, see &lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关这些内容的更多信息，请参见此&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;博客文章&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e122e719b66a5aaf1016dc68677fa81a7da2c2fe" translate="yes" xml:space="preserve">
          <source>Herb Sutter has a three hour long talk about the C++11 memory model titled &quot;atomic&amp;lt;&amp;gt; Weapons&quot;, available on the Channel9 site - &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;part 2&lt;/a&gt;. The talk is pretty technical, and covers the following topics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Herb Sutter讨论了名为&amp;ldquo; atomic &amp;lt;&amp;gt;武器&amp;rdquo;的C ++ 11内存模型，长达三个小时，可以在Channel9网站上（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第1 &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;部分&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第2部分）获得&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该演讲非常技术性，涵盖以下主题：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acbd5686848a17d66430beecce776f2956fd0ca0" translate="yes" xml:space="preserve">
          <source>I also get this feeling that the C++11 memory model is somehow related to C++11 multi-threading support, as I often see these two together. If it is, how exactly? Why should they be related?</source>
          <target state="translated">我也有这种感觉,觉得C++11的内存模型和C++11的多线程支持有一定的关系,因为我经常看到这两者放在一起。如果是这样,那到底是怎样的关系?为什么要把它们联系在一起呢?</target>
        </trans-unit>
        <trans-unit id="eb879d24c026ac0b51a220b545aa9383dafc4341" translate="yes" xml:space="preserve">
          <source>I will just give the analogy with which I understand memory consistency models (or memory models, for short). It is inspired by Leslie Lamport's seminal paper &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot;&lt;/a&gt;.
The analogy is apt and has fundamental significance, but may be overkill for many people. However, I hope it provides a mental image (a pictorial representation) that facilitates reasoning about memory consistency models.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将提供一个类比，以了解内存一致性模型（或简称为内存模型）。它受到Leslie Lamport的开创性论文&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;分布式系统中的时间，时钟和事件排序&amp;rdquo;的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;启发&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这个比喻是恰当的，具有根本的意义，但对许多人来说可能是过大的杀伤力。但是，我希望它提供一种心理图像（图形表示形式），以促进有关内存一致性模型的推理。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7217b726fd9359150a03a385521e0a936659d192" translate="yes" xml:space="preserve">
          <source>If you use mutexes to protect all your data, you really shouldn't need to worry. Mutexes have always provided sufficient ordering and visibility guarantees.</source>
          <target state="translated">如果你使用Mutexes来保护你的所有数据,你真的不需要担心。Mutexes一直以来都提供了足够的排序和可视性保证。</target>
        </trans-unit>
        <trans-unit id="e79392e298c7995c33512b2d46cc65f4371d276e" translate="yes" xml:space="preserve">
          <source>In C++11 memory model, a similar mechanism (the acquire-release consistency model) is used to establish these &lt;strong&gt;&lt;em&gt;local causality relations&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++ 11内存模型中，使用类似的机制（获取-发布一致性模型）来建立这些&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;局部因果关系&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="262aafb7f2b604061a913423a9ba782f8c49b7c8" translate="yes" xml:space="preserve">
          <source>In relativity, some order is restored to the seemingly chaotic picture of partially ordered events, since the only temporal ordering that all observers agree on is the ordering among &amp;ldquo;timelike&amp;rdquo; events (i.e., those events that are in principle connectible by any particle going slower than the speed of light in a vacuum). Only the timelike related events are invariantly ordered.
&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;Time in Physics, Craig Callender&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相对而言，由于所有观察者都同意的唯一时间顺序是&amp;ldquo;类似时间的&amp;rdquo;事件之间的顺序（即，原则上可以被任何变慢的粒子连接的那些事件），因此将部分顺序恢复到看似混乱的部分顺序事件的画面上比真空中的光速）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅与时间相关的事件不变地排序。 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;物理时间，克雷格&amp;middot;卡伦德（Craig Callender）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ec3ce667f63e7bf2272ca76f9d4e2f94f0cc855" translate="yes" xml:space="preserve">
          <source>In relaxed memory models, each thread will slice up address-space-time in its own way, the only restriction being that slices of each thread shall not cross each other because all threads must agree on the history of every individual memory location (of course, slices of different threads may, and will, cross each other). There is no universal way to slice it up (no privileged foliation of address-space-time). Slices do not have to be planar (or linear). They can be curved and this is what can make a thread read values written by another thread out of the order they were written in. Histories of different memory locations may slide (or get stretched) arbitrarily relative to each other &lt;strong&gt;&lt;em&gt;when viewed by any particular thread&lt;/em&gt;&lt;/strong&gt;. Each thread will have a different sense of which events (or, equivalently, memory values) are simultaneous. The set of events (or memory values) that are simultaneous to one thread are not simultaneous to another. Thus, in a relaxed memory model, all threads still observe the same history (i.e., sequence of values) for each memory location. But they may observe different memory images (i.e., combinations of values of all memory locations). Even if two different memory locations are written by the same thread in sequence, the two newly written values may be observed in different order by other threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在宽松的内存模型中，每个线程将以自己的方式切分地址空间-时间，唯一的限制是每个线程的切面不得互相交叉，因为所有线程必须就每个单独的内存位置的历史达成共识（当然，不同线程的切片可能并且将彼此交叉）。没有通用的方式对其进行切片（没有特权的地址空间-时空组合）。切片不必是平面的（或线性的）。它们可以是弯曲的，这可以使一个线程以不同于其写入顺序的方式读取另一个线程写入的值。不同内存位置的历史记录&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在被任何特定线程查看时&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能会相对于彼此任意滑动（或拉伸）&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。每个线程对同时发生的事件（或等效地，内存值）有不同的理解。与一个线程同时发生的一组事件（或内存值）与另一个线程不同。因此，在宽松的内存模型中，所有线程对于每个内存位置仍然遵循相同的历史记录（即值的序列）。但是他们可能观察到不同的内存映像（即所有内存位置的值的组合）。即使同一线程按顺序写入两个不同的内存位置，其他线程也可能以不同的顺序观察到这两个新写入的值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7b6248a1c3792a0a57715e16d30ffb4cda796" translate="yes" xml:space="preserve">
          <source>Interestingly, Microsoft compilers for C++ have acquire / release semantics for volatile which is a C++ extension to deal with the lack of a memory model in C++ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&lt;/a&gt;. However, given that Windows runs on x86 / x64 only, that's not saying much (Intel and AMD memory models make it easy and efficient to implement acquire / release semantics in a language).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有趣的是，用于C ++的Microsoft编译器已经获取/发布了volatile语义，这是C ++的扩展，可以解决C ++中缺少内存模型的问题&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://msdn.microsoft.com/zh-cn/library/12a04hfd(v=vs .80）.aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，考虑到Windows仅在x86 / x64上运行，这并不能说明太多（Intel和AMD内存模型使以一种语言实现获取/发布语义变得容易且高效）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b69141b6b87da624d79fe320205b2eafd77d0cd" translate="yes" xml:space="preserve">
          <source>It is also not sufficient to make them &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; and access them with &lt;code&gt;memory_order_relaxed&lt;/code&gt;.  The reason for this is that the reads of seq (in &lt;code&gt;reader()&lt;/code&gt;) only have &lt;em&gt;acquire&lt;/em&gt; semantics.  In simple terms, if X and Y are memory accesses, X precedes Y, X is not an acquire or release, and Y is an acquire, then the compiler can reorder Y before X.  If Y was the second read of seq, and X was a read of data, such a reordering would break the lock implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使它们成为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问它们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也是不够的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。原因是seq的读取（在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）仅具有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获取&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语义。简单来说，如果X和Y是内存访问，X在Y之前，X不是获取或发布，并且Y是获取，那么编译器可以在X之前对Y进行重新排序。如果Y是seq的第二次读取，并且X如果是读取数据，那么这种重新排序将破坏锁的实现。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4cb6b422f1ed052e081abd1a922b9c939b53705" translate="yes" xml:space="preserve">
          <source>It means that the standard now defines multi-threading, and it defines what happens in the context of multiple threads. Of course, people used varying implementations, but that's like asking why we should have a &lt;code&gt;std::string&lt;/code&gt; when we could all be using a home-rolled &lt;code&gt;string&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着该标准现在定义了多线程，并且定义了在多线程的上下文中发生的情况。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，人们使用了不同的实现方式，但这就像在问为什么我们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都可以使用本地滚动的&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么我们应该有一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf7bf69c37f5d8acf1f675cbf5d973de38aee0ad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s view the histories of all memory locations in a space-time diagram in which the horizontal axis represents the address space (i.e., each memory location is represented by a point on that axis) and the vertical axis represents time (we will see that, in general, there is not a universal notion of time). The history of values held by each memory location is, therefore, represented by a vertical column at that memory address. Each value change is due to one of the threads writing a new value to that location. By a &lt;strong&gt;&lt;em&gt;memory image&lt;/em&gt;&lt;/strong&gt;, we will mean the aggregate/combination of values of all memory locations observable &lt;strong&gt;&lt;em&gt;at a particular time&lt;/em&gt;&lt;/strong&gt; by &lt;strong&gt;&lt;em&gt;a particular thread&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我们在时空图中查看所有存储位置的历史记录，其中水平轴表示地址空间（即，每个存储位置由该轴上的一个点表示），垂直轴表示时间（我们将看到，通常，没有普遍的时间概念）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，每个存储器位置保存的值的历史记录由该存储器地址处的垂直列表示。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次值更改都是由于其中一个线程将新值写入该位置而引起的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存储图像&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们将意味着所有的内存位置观察到的价值的总和/组合&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在特定的时间&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定线程&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5038877da11870fb6cdddb43d3f02bea0be31a6c" translate="yes" xml:space="preserve">
          <source>Meaning that these language definitions make no sense at all as no logical method to mix these two approaches. In particular, destruction of a mutex or atomic variable is not well defined.</source>
          <target state="translated">意味着这些语言的定义完全没有意义,因为没有逻辑上的方法来混合这两种方法。特别是对mutex或原子变量的销毁,没有很好的定义。</target>
        </trans-unit>
        <trans-unit id="fc353f0c4cd5ae6fd4f656b568ee12c3c0fe26db" translate="yes" xml:space="preserve">
          <source>Now they are half defined by an execution trace of a program, and half a posteriori by many orderings on synchronisation objects.</source>
          <target state="translated">现在它们一半是由程序的执行轨迹定义的,一半是由同步对象上的许多排序后定义的。</target>
        </trans-unit>
        <trans-unit id="a9fb8f5a58585401803bbffc20531bf50cb296b8" translate="yes" xml:space="preserve">
          <source>Now things get much more interesting.  First of all, the behavior here is &lt;em&gt;defined&lt;/em&gt;.  Thread 2 could now print &lt;code&gt;0 0&lt;/code&gt; (if it runs before Thread 1), &lt;code&gt;37 17&lt;/code&gt; (if it runs after Thread 1), or &lt;code&gt;0 17&lt;/code&gt; (if it runs after Thread 1 assigns to x but before it assigns to y).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在事情变得更加有趣了。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，在这里&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，线程2可以打印&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如果在线程1之前运行），&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如果在线程1之后运行）或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如果在线程1分配给x之后但在分配给y之后运行）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8c1321d1abad5b016bf122fc4fda3ae6e01ace9" translate="yes" xml:space="preserve">
          <source>Now, if you used atomics, or lock-free algorithms, you need to think about the memory model. The memory model describes precisely when atomics provide ordering and visibility guarantees, and provides portable fences for hand-coded guarantees.</source>
          <target state="translated">现在,如果你使用了原子学,或者说无锁算法,你需要考虑一下内存模型。存储器模型精确地描述了当原子学提供排序和可见性保证,并为手写保证提供了可移植的栅栏。</target>
        </trans-unit>
        <trans-unit id="eee5a298db9fd75c07be2a97a1f2cd772c53c044" translate="yes" xml:space="preserve">
          <source>Now, on a modern CPU, ensuring sequential consistency can be expensive.  In particular, the compiler is likely to emit full-blown memory barriers between every access here.  But if your algorithm can tolerate out-of-order loads and stores; i.e., if it requires atomicity but not ordering; i.e., if it can tolerate &lt;code&gt;37 0&lt;/code&gt; as output from this program, then you can write this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，在现代CPU上，确保顺序一致性可能很昂贵。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特别是，编译器很可能在每次访问之间发出完全成熟的内存屏障。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果您的算法可以容忍乱序的加载和存储；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即，如果它需要原子性但不需要排序；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即，如果它可以忍受&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该程序输出的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则可以编写以下代码：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afbc13c7de8832aebd18cbbb2425e879034c8384" translate="yes" xml:space="preserve">
          <source>Of course, if the only outputs you want to see are &lt;code&gt;0 0&lt;/code&gt; or &lt;code&gt;37 17&lt;/code&gt;, you can just wrap a mutex around the original code.  But if you have read this far, I bet you already know how that works, and this answer is already longer than I intended :-).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，如果要查看的唯一输出是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则只需将互斥体包装在原始代码周围即可。但是，如果您已经读了那么多书，我敢打赌，您已经知道它是如何工作的，并且这个答案已经比我打算的要长:-)。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68874039d4d2159d92f53eba89bd0c6425b0ef3b" translate="yes" xml:space="preserve">
          <source>Of course, you can write multi-threaded code in practice for particular concrete systems &amp;ndash; like pthreads or Windows.  But there is no &lt;em&gt;standard&lt;/em&gt; way to write multi-threaded code for C++98/C++03.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，您可以在实践中为特定的具体系统（例如pthread或Windows）编写多线程代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是没有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标准的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法可以为C ++ 98 / C ++ 03编写多线程代码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8435b89912ba1ee2404f40a7e7f7c76f17be4d3" translate="yes" xml:space="preserve">
          <source>Optimizations, Races, and the Memory Model</source>
          <target state="translated">优化、竞赛和内存模型</target>
        </trans-unit>
        <trans-unit id="cc6f83f22e321f881624f0112b2350e6a011d9b4" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; How: Mutexes, Atomics, and/or Fences</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;订购&amp;ndash;操作方式：互斥体，原子和/或栅栏&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d394933e2ba8b9e6307eee9284401ab051f6b9a" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; What: Acquire and Release</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;订购&amp;ndash;内容：获取并发布&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bfcf5ca2e968cb080e4e46edc82078a505a9d92" translate="yes" xml:space="preserve">
          <source>Other Restrictions on Compilers and Hardware</source>
          <target state="translated">对编译器和硬件的其他限制</target>
        </trans-unit>
        <trans-unit id="dd65ea6941c8d670b393810b2c47552d6cf25df8" translate="yes" xml:space="preserve">
          <source>Previously, atomics would be done using compiler intrinsics, or some higher level library. Fences would have been done using CPU-specific instructions (memory barriers).</source>
          <target state="translated">以前,原子学将使用编译器的内生函数,或一些更高级别的库来完成。栅栏将使用CPU专用指令(内存障碍)来完成。</target>
        </trans-unit>
        <trans-unit id="2e56b625d9ce23edadcdce014336b90a101f8934" translate="yes" xml:space="preserve">
          <source>Quoting from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;关于内存一致性和缓存一致性的入门&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb9db0f94440715855f11a33ea0a95909964dfda" translate="yes" xml:space="preserve">
          <source>Readers familiar with Einstein&amp;rsquo;s &lt;strong&gt;Special Theory of Relativity&lt;/strong&gt; will notice what I am alluding to. Translating Minkowski&amp;rsquo;s words into the memory models realm: address space and time are shadows of address-space-time. In this case, each observer (i.e., thread) will project shadows of events (i.e., memory stores/loads) onto his own world-line (i.e., his time axis) and his own plane of simultaneity (his address-space axis). Threads in the C++11 memory model correspond to &lt;strong&gt;&lt;em&gt;observers&lt;/em&gt;&lt;/strong&gt; that are moving relative to each other in special relativity. Sequential consistency corresponds to the &lt;strong&gt;Galilean space-time&lt;/strong&gt; (i.e., all observers agree on one absolute order of events and a global sense of simultaneity).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;熟悉爱因斯坦&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;狭义相对论的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;读者&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;会注意到我所暗示的内容。将Minkowski的话转化为内存模型领域：地址空间和时间是地址空间时间的影子。在这种情况下，每个观察者（即线程）将事件的阴影（即内存存储/加载）投影到他自己的世界线（即他的时间轴）和他自己的同时性平面（他的地址空间轴）上。 C ++ 11内存模型中的线程对应于&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以相对论彼此相对移动的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;观察者&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。顺序一致性对应于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;伽利略时空&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即所有观察者都同意一个绝对的事件顺序和全局的同时性）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a133e211f7560a29b9da4d6be92f2a22755b5da2" translate="yes" xml:space="preserve">
          <source>Relaxed Atomics</source>
          <target state="translated">松弛的原子力</target>
        </trans-unit>
        <trans-unit id="957e61e62046dd3ea5b6cfe1f86136d6473da53c" translate="yes" xml:space="preserve">
          <source>So, bottom line. Mutexes are great, and C++11 standardizes them. But sometimes for performance reasons you want lower-level primitives (e.g., the classic &lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;double-checked locking pattern&lt;/a&gt;).  The new standard provides high-level gadgets like mutexes and condition variables, and it also provides low-level gadgets like atomic types and the various flavors of memory barrier.  So now you can write sophisticated, high-performance concurrent routines entirely within the language specified by the standard, and you can be certain your code will compile and run unchanged on both today's systems and tomorrow's.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，底线。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;互斥体很棒，并且C ++ 11对其进行了标准化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是有时出于性能原因，您需要较低级别的基元（例如，经典的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;双重检查锁定模式&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新标准提供了诸如互斥锁和条件变量之类的高级小工具，还提供了诸如原子类型和各种不同的内存屏障之类的低级小工具。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，现在您可以完全使用标准指定的语言编写复杂的高性能并发例程，并且可以确定您的代码可以在当今和未来的系统上编译并保持不变。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76ca6da28f8d79dbdb145dfa98920e0946014d84" translate="yes" xml:space="preserve">
          <source>Store-store reordering may happen if a core has a non-FIFO write buffer that lets stores depart in a different order than the order in which they entered. This might occur if the first store misses in the cache while the second hits or if the second store can coalesce with an earlier store (i.e., before the first store). Load-load reordering may also happen on dynamically-scheduled cores that execute instructions out of program order. That can behave the same as reordering stores on another core (Can you come up with an example interleaving between two threads?). Reordering an earlier load with a later store (a load-store reordering) can cause many incorrect behaviors, such as loading a value after releasing the lock that protects it (if the store is the unlock operation). Note that store-load reorderings may also arise due to local bypassing in the commonly implemented FIFO write buffer, even with a core that executes all instructions in program order.</source>
          <target state="translated">如果一个内核有一个非FIFO写缓冲区,让存储空间以与进入的顺序不同的顺序离开,那么存储空间的重新排序可能会发生。如果第一个存储错过了缓存中的第一个存储,而第二个存储进入了缓存,或者第二个存储可以与更早的存储(即,在第一个存储之前)合并,就可能发生这种情况。负载重新排序也可能发生在动态调度的内核上,这些内核执行指令的顺序不符合程序顺序。这可能和在另一个内核上重新排序存储的行为是一样的(你能举出一个在两个线程之间交错的例子吗?用较早的加载与较晚的存储重新排序(加载-存储重排序)会导致许多不正确的行为,比如在释放保护值的锁后加载一个值(如果存储是解锁操作)。需要注意的是,即使是按照程序顺序执行所有指令的内核,也可能会因为常用的FIFO写缓冲区中的本地绕过而出现存储-加载重排序。</target>
        </trans-unit>
        <trans-unit id="452c86d05004baf5f9579835c1ee31f42e9f5ebb" translate="yes" xml:space="preserve">
          <source>That global memory order can vary from one run of the program to another and may not be known beforehand. The characteristic feature of SC is the set of horizontal slices in the address-space-time diagram representing &lt;strong&gt;&lt;em&gt;planes of simultaneity&lt;/em&gt;&lt;/strong&gt; (i.e., memory images). On a given plane, all of its events (or memory values) are simultaneous. There is a notion of &lt;em&gt;Absolute Time&lt;/em&gt;, in which all threads agree on which memory values are simultaneous. In SC, at every time instant, there is only one memory image shared by all threads. That's, at every instant of time, all processors agree on the memory image (i.e., the aggregate content of memory). Not only does this imply that all threads view the same sequence of values for all memory locations, but also that all processors observe the same &lt;em&gt;combinations of values&lt;/em&gt; of all variables. This is the same as saying all memory operations (on all memory locations) are observed in the same total order by all threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该全局内存顺序可以从程序的一次运行到另一次运行而有所不同，并且可能事先未知。 SC的特征是地址空间-时间图中的一组水平切片，它们表示&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时发生的平面&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即内存图像）。在给定平面上，其所有事件（或内存值）都是同时发生的。有一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绝对时间&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的概念&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其中所有线程都同意哪些内存值是同时的。在SC中，每时每刻只有一个内存映像被所有线程共享。也就是说，在每个时刻，所有处理器都在内存映像（即内存的聚合内容）上达成一致。这不仅意味着所有线程对于所有内存位置均查看相同的值序列，而且还意味着所有处理器均观察到相同的值。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有变量&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的值&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组合&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这与说所有线程以相同的总顺序观察所有内存操作（在所有内存位置）相同。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d61648d21c81fd8a8c43e5576aa0e6b82a4218f" translate="yes" xml:space="preserve">
          <source>The C++ specification does not make reference to any particular compiler, operating system, or CPU.  It makes reference to an &lt;em&gt;abstract machine&lt;/em&gt; that is a generalization of actual systems.  In the Language Lawyer world, the job of the programmer is to write code for the abstract machine; the job of the compiler is to actualize that code on a concrete machine.  By coding rigidly to the spec, you can be certain that your code will compile and run without modification on any system with a compliant C++ compiler, whether today or 50 years from now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++规范未引用任何特定的编译器，操作系统或CPU。它引用了&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;抽象机&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它是对实际系统的概括。在语言律师界，程序员的工作是为抽象机编写代码。编译器的工作是在具体机器上实现该代码。通过严格按照规范进行编码，您可以确定您的代码可以在没有兼容C ++编译器的任何系统上进行编译和运行，而无论是现在还是50年后。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d29c58cddb456581d9728a1ab2e5337bca78fb3" translate="yes" xml:space="preserve">
          <source>The above answers get at the most fundamental aspects of the C++ memory model.  In practice, most uses of &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &quot;just work&quot;, at least until the programmer over-optimizes (e.g., by trying to relax too many things).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的答案涉及C ++内存模型的最基本方面。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数用法都是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;正常工作&amp;rdquo;，至少直到程序员过度优化为止（例如，通过尝试放松太多事情）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7d00aae881b6e2acf7384c58de1730263886b2d" translate="yes" xml:space="preserve">
          <source>The abstract machine in C++11 is multi-threaded by design.  It also has a well-defined &lt;em&gt;memory model&lt;/em&gt;; that is, it says what the compiler may and may not do when it comes to accessing memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11中的抽象机在设计上是多线程的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它还具有定义明确的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存模型&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也就是说，它说明了在访问内存时编译器可能会做什么，可能不会做什么。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7f894cea908d237d3941c58a3365a1963366b6e" translate="yes" xml:space="preserve">
          <source>The abstract machine in the C++98/C++03 specification is fundamentally single-threaded.  So it is not possible to write multi-threaded C++ code that is &quot;fully portable&quot; with respect to the spec.  The spec does not even say anything about the &lt;em&gt;atomicity&lt;/em&gt; of memory loads and stores or the &lt;em&gt;order&lt;/em&gt; in which loads and stores might happen, never mind things like mutexes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 / C ++ 03规范中的抽​​象机基本上是单线程的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，不可能编写相对于规范&amp;ldquo;完全可移植&amp;rdquo;的多线程C ++代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;规范甚至没有说关于&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存加载和存储&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加载和存储可能发生&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺序的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;事情，不用管互斥锁之类的事情。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4baedfd0f1527134631c5de1c75f35afd5945f2" translate="yes" xml:space="preserve">
          <source>The intuitive (and most restrictive) memory model is sequential consistency (SC) in which a multithreaded execution should look like an interleaving of the sequential executions of each constituent thread, as if the threads were time-multiplexed on a single-core processor.</source>
          <target state="translated">直观的(也是最有限制的)内存模型是顺序一致性(SC),在这个模型中,多线程的执行看起来应该是每个组成线程的顺序执行的交错,就像线程在单核处理器上的时间复用一样。</target>
        </trans-unit>
        <trans-unit id="754d4bff03e3971b47d96374564e1cbbaae1e141" translate="yes" xml:space="preserve">
          <source>The last issue is that it might be unnatural to make the &lt;code&gt;data&lt;/code&gt; variables atomic.  If you can't in your code, then you need to be very careful, because casting from non-atomic to atomic is only legal for primitive types.  C++20 is supposed to add &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt;, which will make this problem easier to resolve.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最后一个问题是使&lt;/font&gt;&lt;/font&gt; &lt;code&gt;data&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量具有原子性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能是不自然的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您无法在代码中使用，则需要非常小心，因为从非原子转换为原子仅对原始类型合法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 20应该添加&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这将使此问题更易于解决。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfd6846aacd447221a1a226955bb117560edf61a" translate="yes" xml:space="preserve">
          <source>The memory model means that C++ code
  now has a standardized library to call
  regardless of who made the compiler
  and on what platform it's running.
  There's a standard way to control how
  different threads talk to the
  processor's memory.</source>
          <target state="translated">内存模型意味着C++代码现在有了一个标准化的库来调用,无论谁做的编译器和在什么平台上运行,都可以调用。有一种标准的方法来控制不同的线程如何与处理器的内存对话。</target>
        </trans-unit>
        <trans-unit id="0e82744a21c2c2bfb15618db64d694bdd7c9e7e9" translate="yes" xml:space="preserve">
          <source>The more modern the CPU, the more likely this is to be faster than the previous example.</source>
          <target state="translated">越是现代化的CPU,这就越有可能比前面的例子更快。</target>
        </trans-unit>
        <trans-unit id="1f139b606c7fb2fc6086b230c6282ff5ce683f53" translate="yes" xml:space="preserve">
          <source>The paper gives a few solutions.  The one with the best performance today is probably the one that uses an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_relaxed&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; the second read of the seqlock.  In the paper, it's Figure 6.  I'm not reproducing the code here, because anyone who has read this far really ought to read the paper.  It is more precise and complete than this post.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本文给出了一些解决方案。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今天性能最好的一个可能是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二次读取&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_thread_fence&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;memory_order_relaxed&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在本文中，它是图6。我在这里不重复代码，因为已经读过本文的人确实应该阅读本文。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它比这篇文章更加精确和完整。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8ce878fb4b44eaa5f2ed3bf4b3939bc5a23cc2b" translate="yes" xml:space="preserve">
          <source>The resemblance between memory models and special relativity stems from the fact that both define a partially-ordered set of events, often called a causal set. Some events (i.e., memory stores) can affect (but not be affected by) other events. A C++11 thread (or observer in physics) is no more than a chain (i.e., a totally ordered set) of events (e.g., memory loads and stores to possibly different addresses).</source>
          <target state="translated">记忆模型和特殊相对论之间的相似之处,源于两者都定义了一个部分有序的事件集,通常称为因果集。一些事件(即内存存储)可以影响(但不会受到)其他事件的影响。一个C++11线程(或物理学中的观察者)不过是一个事件(例如,内存加载和存储到可能不同的地址)的事件链(即完全有序的集)。</target>
        </trans-unit>
        <trans-unit id="88614ce284b9f9ee72002ba72a19fbcc1fb2fe6e" translate="yes" xml:space="preserve">
          <source>The talk doesn't elaborate on the API, but rather on the reasoning, background, under the hood and behind the scenes (did you know relaxed semantics were added to the standard only because POWER and ARM do not support synchronized load efficiently?).</source>
          <target state="translated">讲座并没有详细介绍API,而是讲了一下这个API的推理、背景、引擎盖下和幕后的情况(你知道放宽语义只是因为POWER和ARM不支持高效的同步加载,所以才会在标准中加入放宽语义吗?</target>
        </trans-unit>
        <trans-unit id="46e71907ae6df91d5f8c4646edd42cd31a4d2600" translate="yes" xml:space="preserve">
          <source>There is one place where mistakes are still common: &lt;em&gt;sequence locks&lt;/em&gt;.  There is an excellent and easy-to-read discussion of the challenges at &lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/a&gt;.  Sequence locks are appealing because the reader avoids writing to the lock word.  The following code is based on Figure 1 of the above technical report, and it highlights the challenges when implementing sequence locks in C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在一个地方，错误仍然很常见：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;序列锁&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf上&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关于挑战的精彩且易于阅读的讨论&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺序锁很吸引人，因为读者可以避免写入锁定字。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下代码基于上述技术报告的图1，并且突出显示了在C ++中实现序列锁时的挑战：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="961c454b5b699e3c67051c83eb5d379453c92717" translate="yes" xml:space="preserve">
          <source>This takes us back to the ordered loads and stores &amp;ndash; so &lt;code&gt;37 0&lt;/code&gt; is no longer a possible output &amp;ndash; but it does so with minimal overhead.  (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将我们带回到有序的装载和存储位置-因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再是可能的输出-但这样做的开销却很小。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（在这个简单的示例中，结果与成熟的顺序一致性相同；在较大的程序中，结果则不是。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e039b9566e8dfbf0f2a3944c91a446a0d3877578" translate="yes" xml:space="preserve">
          <source>To provide a definition of memory consistency and a motivation for abandoning SC, I will quote from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了提供内存一致性的定义和放弃SC的动机，我将引用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;内存一致性和缓存一致性入门&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf70e99ebffe9e92e5be11ffc6e48ebef4aad770" translate="yes" xml:space="preserve">
          <source>To summarize: even if you think you understand the C++ memory model, you should be very careful before rolling your own sequence locks.</source>
          <target state="translated">总结一下:即使你认为自己理解了C++内存模型,在滚动自己的序列锁之前,也要非常谨慎。</target>
        </trans-unit>
        <trans-unit id="5f2312cd34bd31141d0b81cd0bd16779840debfa" translate="yes" xml:space="preserve">
          <source>Under C++11, the result is Undefined Behavior, because loads and stores need not be atomic in general.  Which may not seem like much of an improvement...  And by itself, it's not.</source>
          <target state="translated">在C++11下,结果是Undefined Behavior,因为加载和存储不需要一般的原子性。这可能看起来并没有太大的改进......而就其本身而言,它并不是。</target>
        </trans-unit>
        <trans-unit id="b9f7556c864ccbfde77ebfd4adde349b5488e4fa" translate="yes" xml:space="preserve">
          <source>Under C++98/C++03, this is not even Undefined Behavior; the question itself is &lt;em&gt;meaningless&lt;/em&gt; because the standard does not contemplate anything called a &quot;thread&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++ 98 / C ++ 03下，这甚至不是&amp;ldquo;未定义行为&amp;rdquo;；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个问题本身是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有意义的，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为该标准并未考虑任何被称为&amp;ldquo;线程&amp;rdquo;的东西。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ce2b632d1c58188c735ed2a0e6024043931901f" translate="yes" xml:space="preserve">
          <source>Unlike consistency, &lt;strong&gt;&lt;em&gt;cache coherence&lt;/em&gt;&lt;/strong&gt; is neither visible to software nor required. Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system. Correct coherence ensures that a programmer cannot determine whether and where a system has caches by analyzing the results of loads and stores. This is because correct coherence ensures that the caches never enable new or different &lt;strong&gt;&lt;em&gt;functional&lt;/em&gt;&lt;/strong&gt; behavior (programmers may still be able to infer likely cache structure using &lt;strong&gt;&lt;em&gt;timing&lt;/em&gt;&lt;/strong&gt; information). The main purpose of cache coherence protocols is maintaining the single-writer-multiple-readers (SWMR) invariant for every memory location.
  An important distinction between coherence and consistency is that coherence is specified on a &lt;strong&gt;&lt;em&gt;per-memory location basis&lt;/em&gt;&lt;/strong&gt;, whereas consistency is specified with respect to &lt;strong&gt;&lt;em&gt;all&lt;/em&gt;&lt;/strong&gt; memory locations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与一致性不同，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存一致性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于软件既不可见也不是必需的。 Coherence试图使共享内存系统的缓存在功能上与单核系统中的缓存一样不可见。正确的一致性可确保程序员无法通过分析加载和存储的结果来确定系统是否以及在何处具有缓存。这是因为正确的一致性可确保高速缓存永远不会启用新的或不同的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行为（程序员可能仍能够使用&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时序&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来推断可能的高速缓存结构&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;信息）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;高速缓存一致性协议的主要目的是使每个存储位置的单写多读器（SWMR）保持不变。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一致性和一致性之间的重要区别是，一致性是在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个内存位置基础上&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定的，而一致性是在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存位置上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfacfcd81cfcca293eba3cc7493531d81a4a1b4d" translate="yes" xml:space="preserve">
          <source>Very importantly, locks (and concurrency semantics with locking) are typically implemented in a cross platform way... So if you are using standard locks in a multithreaded program with no data races then you &lt;strong&gt;don't have to worry about cross platform memory models&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非常重要的是，锁（以及带有锁的并发语义）通常是在跨平台的方式下实现的...因此，如果您在无数据竞争的多线程程序中使用标准锁，则&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不必担心跨平台内存模型&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e4a2ca5a3d05ddfbe2b56ccb6104a75cae606ef" translate="yes" xml:space="preserve">
          <source>Well, I can &lt;em&gt;memorize&lt;/em&gt; this and similar paragraphs available online (as I've had my own memory model since birth :P) and can even post as an answer to questions asked by others, but to be honest, I don't exactly understand this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好吧，我可以&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;记住&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这一段以及网上可以找到的类似段落（因为我自出生以来就有自己的记忆模型：P），甚至可以发布它作为对其他人提出的问题的答案，但是老实说，我并不完全理解这个。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="956fcc4400c935b51349b1224fcb0216fed90fc4" translate="yes" xml:space="preserve">
          <source>What it cannot print is &lt;code&gt;37 0&lt;/code&gt;, because the default mode for atomic loads/stores in C++11 is to enforce &lt;em&gt;sequential consistency&lt;/em&gt;.  This just means all loads and stores must be &quot;as if&quot; they happened in the order you wrote them within each thread, while operations among threads can be interleaved however the system likes.  So the default behavior of atomics provides both &lt;em&gt;atomicity&lt;/em&gt; and &lt;em&gt;ordering&lt;/em&gt; for loads and stores.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它不能打印的是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因为C ++ 11中原子加载/存储的默认模式是强制&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺序一致性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这只是意味着所有加载和存储必须&amp;ldquo;好像&amp;rdquo;它们按照您在每个线程中写入它们的顺序发生，而线程之间的操作可以交错，但是系统喜欢。所以原子能的默认行为，同时提供了&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排序&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的加载和存储。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fd897db0b1892f92d3ac2bb9df198d5229ab212" translate="yes" xml:space="preserve">
          <source>What might Thread 2 output?</source>
          <target state="translated">Thread 2可能输出什么?</target>
        </trans-unit>
        <trans-unit id="1798b5cddeecf3effcaf30a3ce667c57f5b3451d" translate="yes" xml:space="preserve">
          <source>When you're talking about POSIX threads or Windows threads, then this is a bit of an illusion as actually you're talking about x86 threads, as it's a hardware function to run concurrently. The C++0x memory model makes guarantees, whether you're on x86, or ARM, or &lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;MIPS&lt;/a&gt;, or anything else you can come up with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您谈论POSIX线程或Windows线程时，这实际上是您在谈论x86线程，这是一种错觉，因为它是同时运行的硬件功能。 C ++ 0x内存模型可以保证，无论您使用的是x86，ARM，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MIPS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还是其他任何东西。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76cbbb6015ca76bb55e457fa170621f939633ebe" translate="yes" xml:space="preserve">
          <source>[Picture from Wikipedia]</source>
          <target state="translated">[图片来自维基百科]</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
