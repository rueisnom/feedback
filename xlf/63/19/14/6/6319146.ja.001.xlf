<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/6319146">
    <body>
      <group id="6319146">
        <trans-unit id="73df4e1cfb97a0cf2c29a8c07e2bb86731b5d146" translate="yes" xml:space="preserve">
          <source>&quot;When you are talking about splitting
  [code] across different cores that's
  in the standard, we are talking about
  the memory model. We are going to
  optimize it without breaking the
  following assumptions people are going
  to make in the code,&quot; &lt;strong&gt;Sutter&lt;/strong&gt; said.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「標準にある異なるコア間で[コード]を分割することについて話しているときは、メモリモデルについて話している。人々がコードで行う次の仮定を壊すことなく、メモリモデルを最適化する」と&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sutter&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は述べた。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d15a3a1c7c247d44171f5a6070b968d22cecb393" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;This article&lt;/a&gt; (by &lt;strong&gt;Gavin Clarke&lt;/strong&gt; who quotes &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/strong&gt;) says that,</source>
          <target state="translated">&lt;a href=&quot;http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この記事&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Herb Sutter&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を引用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;している&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Gavin Clarke&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;よる）は、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="731c13310aa9d76029890ec2d9fe270b4e77f4e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Relaxed&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;weak&lt;/em&gt;&lt;/strong&gt; memory consistency models are motivated by the fact that most memory orderings in strong models are unnecessary. If a thread updates ten data items and then a synchronization flag, programmers usually do not care if the data items are updated in order with respect to each other but only that all data items are updated before the flag is updated (usually implemented using FENCE instructions). Relaxed models seek to capture this increased ordering flexibility and preserve only the orders that programmers &amp;ldquo;&lt;em&gt;require&lt;/em&gt;&amp;rdquo; to get both higher performance and correctness of SC. For example, in certain architectures, FIFO write buffers are used by each core to hold the results of committed (retired) stores before writing the results to the caches. This optimization enhances performance but violates SC. The write buffer hides the latency of servicing a store miss. Because stores are common, being able to avoid stalling on most of them is an important benefit. For a single-core processor, a write buffer can be made architecturally invisible by ensuring that a load to address A returns the value of the most recent store to A even if one or more stores to A are in the write buffer. This is typically done by either bypassing the value of the most recent store to A to the load from A, where &amp;ldquo;most recent&amp;rdquo; is determined by program order, or by stalling a load of A if a store to A is in the write buffer. When multiple cores are used, each will have its own bypassing write buffer. Without write buffers, the hardware is SC, but with write buffers, it is not, making write buffers architecturally visible in a multicore processor.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;緩和された、&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;弱い&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリ整合性モデルは、強力なモデルのほとんどのメモリ順序付けが不要であるという事実によって動機付けられています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スレッドが10個のデータ項目を更新してから同期フラグを更新する場合、プログラマーは通常、データ項目が互いに順番に更新されるかどうかは気にせず、フラグが更新される前にすべてのデータ項目が更新されることだけを考慮します（通常はFENCE命令を使用して実装されます） ）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リラックスしたモデルは、この増加した順序付けの柔軟性を獲得し、プログラマー&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が必要とする&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;順序のみを保持しようとし&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SCのより高いパフォーマンスと正確さの両方を実現します。たとえば、特定のアーキテクチャでは、FIFO書き込みバッファーが各コアで使用され、結果をキャッシュに書き込む前に、コミット（リタイア）されたストアの結果を保持します。この最適化はパフォーマンスを向上させますが、SCに違反します。書き込みバッファは、ストアミスの処理のレイテンシを隠します。店舗は一般的なものであるため、ほとんどの店舗でストールを回避できることは重要なメリットです。シングルコアプロセッサの場合、Aへの1つ以上のストアが書き込みバッファにある場合でも、アドレスAへのロードが最新のストアの値をAに返すようにすることで、書き込みバッファをアーキテクチャから見えなくすることができます。これは通常、Aへの最新のストアの値をAからのロードにバイパスすることによって行われます。「最新」はプログラムの順序によって決定されます。または、Aへのストアが書き込みバッファにある場合、Aのロードをストールする。複数のコアを使用する場合、それぞれに独自のバイパス書き込みバッファーがあります。書き込みバッファがない場合、ハードウェアはSCですが、書き込みバッファがある場合はそうではなく、マルチコアプロセッサでアーキテクチャ的に書き込みバッファを認識​​できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a24014293b7e7f3c3957b75dbba2b33ce19b2765" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is now a multiple-year old question, but being very popular, it's worth mentioning a fantastic resource for learning about the C++11 memory model. I see no point in summing up his talk in order to make this yet another full answer, but given this is the guy who actually wrote the standard, I think it's well worth watching the talk.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは数年前の質問ですが、非常に人気があるため、C ++ 11メモリモデルについて学ぶための素晴らしいリソースについて言及する価値があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もう1つの完全な答えを出すために彼の話を要約しても意味がありませんが、これは実際に標準を作成した人なので、話を見る価値は十分あると思います。&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fea15c028fa16edd68a84950f92fa70a42f3fac8" translate="yes" xml:space="preserve">
          <source>Although to be frank, unless you are an expert and working on some serious low-level code, you should probably stick to mutexes and condition variables.  That's what I intend to do.</source>
          <target state="translated">率直に言って、あなたが専門家であり、深刻な低レベルのコードに取り組んでいない限り、ミューテックスと条件変数に固執するべきでしょう。それが私がやろうとしていることです。</target>
        </trans-unit>
        <trans-unit id="3ad19cd05e2aca3350a1896cdfb856a60997442f" translate="yes" xml:space="preserve">
          <source>As I don't know how the internals of multi-threading work, and what memory model means in general, please help me understand these concepts. :-)</source>
          <target state="translated">マルチスレッドの内部がどうなっているのか、メモリモデルが一般的にどういう意味を持つのかがわからないので、これらの概念を理解するのに役立つようにしてください。)</target>
        </trans-unit>
        <trans-unit id="73edd169fb02675391ad1960b83d93b7512986a3" translate="yes" xml:space="preserve">
          <source>As unintuitive as it seams at first, &lt;code&gt;data1&lt;/code&gt; and &lt;code&gt;data2&lt;/code&gt; need to be &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt;.  If they are not atomic, then they could be read (in &lt;code&gt;reader()&lt;/code&gt;) at the exact same time as they are written (in &lt;code&gt;writer()&lt;/code&gt;).  According to the C++ memory model, this is a race &lt;em&gt;even if &lt;code&gt;reader()&lt;/code&gt; never actually uses the data&lt;/em&gt;.  In addition, if they are not atomic, then the compiler can cache the first read of each value in a register.  Obviously you wouldn't want that... you want to re-read in each iteration of the &lt;code&gt;while&lt;/code&gt; loop in &lt;code&gt;reader()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初は継ぎ目があるので直感的ではないので、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;data1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;data2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。それらがアトミックでない場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、それらが（&lt;/font&gt; &lt;code&gt;writer()&lt;/code&gt; で&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;書き込まれると同時に正確に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;読み取られる可能性があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 C ++メモリモデルによると、&lt;/font&gt;&lt;em&gt; &lt;code&gt;reader()&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が実際にデータを使用しない&lt;/font&gt;&lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合でも&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、これは競合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。さらに、それらがアトミックでない場合、コンパイラーは各値の最初の読み取りをレジスターにキャッシュできます。明らかに、あなたはそれを望まないでしょう... &lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; の &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;ループの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各反復で再読み取りする必要が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4a622ff9ae0214ed05a333e5d2cd4c3f0640dc8" translate="yes" xml:space="preserve">
          <source>Because cache coherence and memory consistency are sometimes confused, it is instructive to also have this quote:</source>
          <target state="translated">キャッシュコヒーレンスとメモリ一貫性が混同されることがあるので、この引用文も参考になります。</target>
        </trans-unit>
        <trans-unit id="934437c0109e42d4fd367073bdd77200fe18bf44" translate="yes" xml:space="preserve">
          <source>But with C++11, you can write this:</source>
          <target state="translated">しかし、C++11では、こんなことが書けます。</target>
        </trans-unit>
        <trans-unit id="c3419e7bfb7b912c1de58267196ef1715f03d520" translate="yes" xml:space="preserve">
          <source>C and C++ used to be defined by an execution trace of a well formed program.</source>
          <target state="translated">CやC++は、かつてはよくできたプログラムの実行トレースによって定義されていました。</target>
        </trans-unit>
        <trans-unit id="f714f1f168010e0e48c54ceb767d70850b43f535" translate="yes" xml:space="preserve">
          <source>C++ programmers used to develop multi-threaded applications even before, so how does it matter if it's POSIX threads, or Windows threads, or C++11 threads? What are the benefits? I want to understand the low-level details.</source>
          <target state="translated">C++プログラマは以前からマルチスレッドのアプリケーションを開発していたので、POSIXスレッドなのか、Windowsスレッドなのか、C++11スレッドなのかは関係ないのではないでしょうか?何かメリットがあるのか?低レベルなところを理解したい。</target>
        </trans-unit>
        <trans-unit id="c804136fc25fd72d45e9ed77db0496ceaaa13a5e" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model, but what exactly does that mean? And how is it going to affect C++ programming?</source>
          <target state="translated">C++11 では標準化されたメモリ モデルが導入されましたが、それは具体的にどのような意味を持つのでしょうか?また、それが C++プログラミングにどのような影響を与えるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b31ce9265efcb7ae003d188e0fcacad2174b4301" translate="yes" xml:space="preserve">
          <source>C++11 introduced a standardized memory model. What does it mean? And how is it going to affect C++ programming</source>
          <target state="translated">C++11では、標準化されたメモリモデルが導入されました。これは何を意味するのでしょうか?また、C++プログラミングにどのような影響があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="1071914933f07012e3e0261ffb0513754c189cf3" translate="yes" xml:space="preserve">
          <source>Code Gen &amp;amp; Performance: x86/x64, IA64, POWER, ARM</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コード生成とパフォーマンス：x86 / x64、IA64、POWER、ARM&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70cb8dd903b1de610462040edfa72807d0c75c0f" translate="yes" xml:space="preserve">
          <source>Consider the following example, where a pair of global variables are accessed concurrently by two threads:</source>
          <target state="translated">次の例では、グローバル変数のペアが 2 つのスレッドから同時にアクセスされる場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5e777ba92d2f70816c7b8e0a710d0cd2e088bf50" translate="yes" xml:space="preserve">
          <source>Continuing with our mental picture, the SWMR invariant corresponds to the physical requirement that there be at most one particle located at any one location but there can be an unlimited number of observers of any location.</source>
          <target state="translated">私たちの心の中のイメージを続けると、SWMR不変は、任意の場所に配置されている粒子が最大1つであるという物理的な要件に対応していますが、任意の場所の観測者の数は無制限に存在することができます。</target>
        </trans-unit>
        <trans-unit id="1ccda8a650443d20e5e10efff7eff75f39de7479" translate="yes" xml:space="preserve">
          <source>Finally, if you just need to keep particular loads and stores in order, you can write:</source>
          <target state="translated">最後に、特定の負荷や店舗を整理しておく必要があるだけならば、書いておきましょう。</target>
        </trans-unit>
        <trans-unit id="95b21e94883bf869fa456f6fee7bcd0aede60da8" translate="yes" xml:space="preserve">
          <source>First, you have to learn to think like a Language Lawyer.</source>
          <target state="translated">まずは、語学弁護士のような考え方を身につけることです。</target>
        </trans-unit>
        <trans-unit id="f764c87baa07b4d9b69d806e43e35de480f00596" translate="yes" xml:space="preserve">
          <source>For a shared memory machine, the memory consistency model defines the architecturally visible behavior of its memory system. The correctness criterion for a single processor core partitions behavior between &amp;ldquo;&lt;em&gt;one correct result&lt;/em&gt;&amp;rdquo; and &amp;ldquo;&lt;em&gt;many incorrect alternatives&lt;/em&gt;&amp;rdquo;. This is because the processor&amp;rsquo;s architecture mandates that the execution of a thread transforms a given input state into a single well-defined output state, even on an out-of-order core. Shared memory consistency models, however, concern the loads and stores of multiple threads and usually allow &lt;em&gt;many correct executions&lt;/em&gt; while disallowing many (more) incorrect ones. The possibility of multiple correct executions is due to the ISA allowing multiple threads to execute concurrently, often with many possible legal interleavings of instructions from different threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;共有メモリマシンの場合、メモリ整合性モデルは、アーキテクチャ上で認識可能なメモリシステムの動作を定義します。シングルプロセッサコアの正当性基準は、「&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1つの正しい結果&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」と「&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの誤った代替&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作を分割します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これは、プロセッサのアーキテクチャにより、スレッドの実行により、特定の入力状態が、順不同のコアであっても、明確に定義された単一の出力状態に変換されることが義務付けられているためです。ただし、共有メモリ整合性モデルは、複数のスレッドのロードとストアに関係し、通常は&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの正しい実行を&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能に&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの（より多くの）不正なものを許可しない。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;複数の正しい実行の可能性は、ISAが複数のスレッドを同時に実行することを可能にするためであり、多くの場合、異なるスレッドからの命令の多くの可能な合法的なインターリーブを伴います。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3a3531d42219943e36c390c1d09394dda7f26" translate="yes" xml:space="preserve">
          <source>For languages not specifying a memory model, you are writing code for the language &lt;em&gt;and&lt;/em&gt; the memory model specified by the processor architecture. The processor may choose to re-order memory accesses for performance. So, &lt;strong&gt;if your program has data races&lt;/strong&gt; (a data race is when it's possible for multiple cores / hyper-threads to access the same memory concurrently) then your program is not cross platform because of its dependence on the processor memory model. You may refer to the Intel or AMD software manuals to find out how the processors may re-order memory accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリモデルを指定していない言語の場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、プロセッサアーキテクチャで指定された&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;言語&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリモデルの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コードを記述&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しています。プロセッサは、パフォーマンスのためにメモリアクセスを並べ替えることを選択できます。したがって、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プログラムにデータの&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;競合がある場合（データの競合とは、複数のコア/ハイパースレッドが同じメモリに同時にアクセスできる場合）、プロセッサのメモリモデルに依存しているため、プログラムはクロスプラットフォームではありません。プロセッサがメモリアクセスを並べ替える方法については、IntelまたはAMDのソフトウェアマニュアルを参照してください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ef316ccb8a21361d46e5437050816b42e490adc" translate="yes" xml:space="preserve">
          <source>For more on this stuff, see &lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このことについて詳しくは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このブログ投稿を&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e122e719b66a5aaf1016dc68677fa81a7da2c2fe" translate="yes" xml:space="preserve">
          <source>Herb Sutter has a three hour long talk about the C++11 memory model titled &quot;atomic&amp;lt;&amp;gt; Weapons&quot;, available on the Channel9 site - &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;part 2&lt;/a&gt;. The talk is pretty technical, and covers the following topics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Herb Sutterは、「atomic &amp;lt;&amp;gt; Weapons」というタイトルのC ++ 11メモリモデルについて3時間の講演を行っており、Channel9サイト（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パート1&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パート2）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で入手できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;話はかなり技術的で、以下のトピックをカバーしています：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acbd5686848a17d66430beecce776f2956fd0ca0" translate="yes" xml:space="preserve">
          <source>I also get this feeling that the C++11 memory model is somehow related to C++11 multi-threading support, as I often see these two together. If it is, how exactly? Why should they be related?</source>
          <target state="translated">また、この 2 つが一緒になっているのをよく目にするので、C++11 のメモリ・モデルが C++11 のマルチスレッド・サポートに何らかの形で関連しているような気がします。もしそうだとしたら、具体的にはどのように関連しているのでしょうか?なぜ関連している必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="eb879d24c026ac0b51a220b545aa9383dafc4341" translate="yes" xml:space="preserve">
          <source>I will just give the analogy with which I understand memory consistency models (or memory models, for short). It is inspired by Leslie Lamport's seminal paper &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot;&lt;/a&gt;.
The analogy is apt and has fundamental significance, but may be overkill for many people. However, I hope it provides a mental image (a pictorial representation) that facilitates reasoning about memory consistency models.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は、メモリ一貫性モデル（またはメモリモデル、略して）を理解するための類似性を示します。これは、レスリーランポートの独創的な論文&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=359545.359563&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「Time、Clocks、and the Ordering of Events in a Distributed System」&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から発想を得たものです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。類推は適切であり、基本的な意味を持っていますが、多くの人々にとってやり過ぎかもしれません。ただし、メモリ整合性モデルについての推論を容易にするメンタルイメージ（画像表現）が提供されることを願っています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7217b726fd9359150a03a385521e0a936659d192" translate="yes" xml:space="preserve">
          <source>If you use mutexes to protect all your data, you really shouldn't need to worry. Mutexes have always provided sufficient ordering and visibility guarantees.</source>
          <target state="translated">すべてのデータを保護するためにミューテックスを使用する場合、本当に心配する必要はありません。ミューテックスは常に十分な順序と可視性の保証を提供してきました。</target>
        </trans-unit>
        <trans-unit id="e79392e298c7995c33512b2d46cc65f4371d276e" translate="yes" xml:space="preserve">
          <source>In C++11 memory model, a similar mechanism (the acquire-release consistency model) is used to establish these &lt;strong&gt;&lt;em&gt;local causality relations&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11メモリモデルでは、同様のメカニズム（取得とリリースの整合性モデル）を使用して、これらの&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ローカル因果関係&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を確立し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="262aafb7f2b604061a913423a9ba782f8c49b7c8" translate="yes" xml:space="preserve">
          <source>In relativity, some order is restored to the seemingly chaotic picture of partially ordered events, since the only temporal ordering that all observers agree on is the ordering among &amp;ldquo;timelike&amp;rdquo; events (i.e., those events that are in principle connectible by any particle going slower than the speed of light in a vacuum). Only the timelike related events are invariantly ordered.
&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;Time in Physics, Craig Callender&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相対性理論では、すべてのオブザーバーが同意する唯一の時間的順序が「時間的」イベント間の順序付けであるため、一部の順序付けられたイベントのカオスに見える順序にいくつかの順序が復元されます真空中の光速よりも）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;時系列の関連イベントのみが不変に順序付けられます。 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Time in Physics、Craig Callender&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ec3ce667f63e7bf2272ca76f9d4e2f94f0cc855" translate="yes" xml:space="preserve">
          <source>In relaxed memory models, each thread will slice up address-space-time in its own way, the only restriction being that slices of each thread shall not cross each other because all threads must agree on the history of every individual memory location (of course, slices of different threads may, and will, cross each other). There is no universal way to slice it up (no privileged foliation of address-space-time). Slices do not have to be planar (or linear). They can be curved and this is what can make a thread read values written by another thread out of the order they were written in. Histories of different memory locations may slide (or get stretched) arbitrarily relative to each other &lt;strong&gt;&lt;em&gt;when viewed by any particular thread&lt;/em&gt;&lt;/strong&gt;. Each thread will have a different sense of which events (or, equivalently, memory values) are simultaneous. The set of events (or memory values) that are simultaneous to one thread are not simultaneous to another. Thus, in a relaxed memory model, all threads still observe the same history (i.e., sequence of values) for each memory location. But they may observe different memory images (i.e., combinations of values of all memory locations). Even if two different memory locations are written by the same thread in sequence, the two newly written values may be observed in different order by other threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リラックスメモリモデルでは、各スレッドは独自の方法でアドレス空間時間をスライスします。唯一の制限は、すべてのスレッドが個々のメモリロケーションの履歴に同意する必要があるため、各スレッドのスライスが互いに交差しないことです（もちろん、異なるスレッドのスライスは互いに交差する可能性があります。それを切り分ける普遍的な方法はありません（アドレス空間時間の特権特権階層はありません）。スライスは平面（または線形）である必要はありません。それらは湾曲している可能性があり、これにより、スレッドは別のスレッドによって書き込まれた値とは異なる順序で値を読み取ることができます。&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定のスレッドから見ると&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、異なるメモリ位置の履歴が互いに相対的にスライドする（または伸びる）&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合があります。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。各スレッドは、どのイベント（または、同等に、メモリ値）が同時であるかについて異なる感覚を持っています。 1つのスレッドと同時に発生するイベント（またはメモリ値）のセットは、別のスレッドと同時に発生しません。したがって、緩和されたメモリモデルでは、すべてのスレッドが各メモリ位置の同じ履歴（つまり、値のシーケンス）を引き続き監視します。ただし、異なるメモリイメージ（つまり、すべてのメモリロケーションの値の組み合わせ）が観察される場合があります。 2つの異なるメモリロケーションが同じスレッドによって順番に書き込まれた場合でも、新しく書き込まれた2つの値は、他のスレッドによって異なる順序で観察される場合があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7b6248a1c3792a0a57715e16d30ffb4cda796" translate="yes" xml:space="preserve">
          <source>Interestingly, Microsoft compilers for C++ have acquire / release semantics for volatile which is a C++ extension to deal with the lack of a memory model in C++ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&lt;/a&gt;. However, given that Windows runs on x86 / x64 only, that's not saying much (Intel and AMD memory models make it easy and efficient to implement acquire / release semantics in a language).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;興味深いことに、C ++のMicrosoftコンパイラは、C ++のメモリモデルの欠如に対処するためのC ++拡張であるvolatileのセマンティクスを取得/解放します&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs .80）.aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、Windowsがx86 / x64でのみ実行されることを考えると、それほど多くはありません（IntelおよびAMDのメモリモデルにより、取得/解放のセマンティクスを言語で実装することが簡単かつ効率的になります）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b69141b6b87da624d79fe320205b2eafd77d0cd" translate="yes" xml:space="preserve">
          <source>It is also not sufficient to make them &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; and access them with &lt;code&gt;memory_order_relaxed&lt;/code&gt;.  The reason for this is that the reads of seq (in &lt;code&gt;reader()&lt;/code&gt;) only have &lt;em&gt;acquire&lt;/em&gt; semantics.  In simple terms, if X and Y are memory accesses, X precedes Y, X is not an acquire or release, and Y is an acquire, then the compiler can reorder Y before X.  If Y was the second read of seq, and X was a read of data, such a reordering would break the lock implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、それらを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;して、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; で&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アクセスするだけでは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不十分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。これは、seq（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;reader()&lt;/code&gt; での&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;読み取り&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;取得の&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;セマンティクス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しか持たない&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。簡単に言えば、XとYがメモリアクセスで、XがYに先行し、Xが取得または解放ではなく、Yが取得である場合、コンパイラはXの前にYを並べ替えることができます。Yがseqの2番目の読み取りで、Xデータの読み取りだったので、このような並べ替えはロックの実装を壊します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4cb6b422f1ed052e081abd1a922b9c939b53705" translate="yes" xml:space="preserve">
          <source>It means that the standard now defines multi-threading, and it defines what happens in the context of multiple threads. Of course, people used varying implementations, but that's like asking why we should have a &lt;code&gt;std::string&lt;/code&gt; when we could all be using a home-rolled &lt;code&gt;string&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、標準がマルチスレッドを定義し、マルチスレッドのコンテキストで何が起こるかを定義することを意味します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、人々はさまざまな実装を使用しましたが、それは、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてホームロールされた&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用できる&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のに、なぜ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が必要なのかと尋ねるようなもの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf7bf69c37f5d8acf1f675cbf5d973de38aee0ad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s view the histories of all memory locations in a space-time diagram in which the horizontal axis represents the address space (i.e., each memory location is represented by a point on that axis) and the vertical axis represents time (we will see that, in general, there is not a universal notion of time). The history of values held by each memory location is, therefore, represented by a vertical column at that memory address. Each value change is due to one of the threads writing a new value to that location. By a &lt;strong&gt;&lt;em&gt;memory image&lt;/em&gt;&lt;/strong&gt;, we will mean the aggregate/combination of values of all memory locations observable &lt;strong&gt;&lt;em&gt;at a particular time&lt;/em&gt;&lt;/strong&gt; by &lt;strong&gt;&lt;em&gt;a particular thread&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのメモリ位置の履歴を時空間図で表示してみましょう。横軸はアドレス空間を表し（つまり、各メモリ位置はその軸上の点で表されます）、縦軸は時間を表します（これを見てみましょう）一般に、時間の普遍的な概念はありません）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、各メモリ位置に保持されている値の履歴は、そのメモリアドレスの垂直列で表されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各値の変更は、スレッドの1つがその場所に新しい値を書き込んだことが原因です。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリイメージ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、我々は観測可能なすべてのメモリ位置の値の集計/組み合わせを意味します&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定の時間に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;することにより&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、特定のスレッドを&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5038877da11870fb6cdddb43d3f02bea0be31a6c" translate="yes" xml:space="preserve">
          <source>Meaning that these language definitions make no sense at all as no logical method to mix these two approaches. In particular, destruction of a mutex or atomic variable is not well defined.</source>
          <target state="translated">つまり、これらの言語の定義は、これら2つのアプローチを混ぜ合わせる論理的な方法がないため、全く意味がありません。特に、ミューテックスやアトミック変数の破壊は十分に定義されていません。</target>
        </trans-unit>
        <trans-unit id="fc353f0c4cd5ae6fd4f656b568ee12c3c0fe26db" translate="yes" xml:space="preserve">
          <source>Now they are half defined by an execution trace of a program, and half a posteriori by many orderings on synchronisation objects.</source>
          <target state="translated">現在、それらは半分はプログラムの実行トレースによって定義され、半分は同期オブジェクト上の多くの順序付けによって事後的に定義されています。</target>
        </trans-unit>
        <trans-unit id="a9fb8f5a58585401803bbffc20531bf50cb296b8" translate="yes" xml:space="preserve">
          <source>Now things get much more interesting.  First of all, the behavior here is &lt;em&gt;defined&lt;/em&gt;.  Thread 2 could now print &lt;code&gt;0 0&lt;/code&gt; (if it runs before Thread 1), &lt;code&gt;37 17&lt;/code&gt; (if it runs after Thread 1), or &lt;code&gt;0 17&lt;/code&gt; (if it runs after Thread 1 assigns to x but before it assigns to y).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今、物事はもっと面白くなります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まず、ここでの動作を&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定義し&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スレッド2は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（スレッド1の前に実行される場合）、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（スレッド1の後に実行される場合）、または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（スレッド1がxに割り当てられた後、yに割り当てられる前に実行される場合）を出力できるようになりました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8c1321d1abad5b016bf122fc4fda3ae6e01ace9" translate="yes" xml:space="preserve">
          <source>Now, if you used atomics, or lock-free algorithms, you need to think about the memory model. The memory model describes precisely when atomics provide ordering and visibility guarantees, and provides portable fences for hand-coded guarantees.</source>
          <target state="translated">さて、アトミック、つまりロックフリーアルゴリズムを使用した場合、メモリモデルについて考える必要があります。メモリモデルは、アノミクスが順序保証と可視性保証を提供する場合を正確に記述し、ハンドコードされた保証のためのポータブルなフェンスを提供します。</target>
        </trans-unit>
        <trans-unit id="eee5a298db9fd75c07be2a97a1f2cd772c53c044" translate="yes" xml:space="preserve">
          <source>Now, on a modern CPU, ensuring sequential consistency can be expensive.  In particular, the compiler is likely to emit full-blown memory barriers between every access here.  But if your algorithm can tolerate out-of-order loads and stores; i.e., if it requires atomicity but not ordering; i.e., if it can tolerate &lt;code&gt;37 0&lt;/code&gt; as output from this program, then you can write this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;現在、最新のCPUでは、シーケンシャルな一貫性を確保するためにコストがかかる可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特に、コンパイラは、ここでのすべてのアクセスの間に本格的なメモリバリアを生成する可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、アルゴリズムが順不同のロードとストアを許容できる場合。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、原子性が必要だが順序付けが不要な場合。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このプログラムからの出力として&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;許容できる場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、次のように記述できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afbc13c7de8832aebd18cbbb2425e879034c8384" translate="yes" xml:space="preserve">
          <source>Of course, if the only outputs you want to see are &lt;code&gt;0 0&lt;/code&gt; or &lt;code&gt;37 17&lt;/code&gt;, you can just wrap a mutex around the original code.  But if you have read this far, I bet you already know how that works, and this answer is already longer than I intended :-).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、見たい出力が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 17&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のみの場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、元のコードをミューテックスで囲むだけです。しかし、ここまで読んだことがあれば、それがどのように機能するかはすでにご存じでしょう。この回答は、私が意図したよりも長くなっています:-)。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68874039d4d2159d92f53eba89bd0c6425b0ef3b" translate="yes" xml:space="preserve">
          <source>Of course, you can write multi-threaded code in practice for particular concrete systems &amp;ndash; like pthreads or Windows.  But there is no &lt;em&gt;standard&lt;/em&gt; way to write multi-threaded code for C++98/C++03.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、pthreadやWindowsのような特定の具体的なシステム用のマルチスレッドコードを実際に書くこともできます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、C ++ 98 / C ++ 03のマルチスレッドコードを記述する&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;標準的な&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8435b89912ba1ee2404f40a7e7f7c76f17be4d3" translate="yes" xml:space="preserve">
          <source>Optimizations, Races, and the Memory Model</source>
          <target state="translated">最適化、レース、メモリモデル</target>
        </trans-unit>
        <trans-unit id="cc6f83f22e321f881624f0112b2350e6a011d9b4" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; How: Mutexes, Atomics, and/or Fences</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;順序&amp;ndash;方法：ミューテックス、アトミック、および/またはフェンス&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d394933e2ba8b9e6307eee9284401ab051f6b9a" translate="yes" xml:space="preserve">
          <source>Ordering &amp;ndash; What: Acquire and Release</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注文&amp;ndash;内容：取得およびリリース&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bfcf5ca2e968cb080e4e46edc82078a505a9d92" translate="yes" xml:space="preserve">
          <source>Other Restrictions on Compilers and Hardware</source>
          <target state="translated">コンパイラやハードウェアに関するその他の制限</target>
        </trans-unit>
        <trans-unit id="dd65ea6941c8d670b393810b2c47552d6cf25df8" translate="yes" xml:space="preserve">
          <source>Previously, atomics would be done using compiler intrinsics, or some higher level library. Fences would have been done using CPU-specific instructions (memory barriers).</source>
          <target state="translated">これまでのアトミックは、コンパイラの内部構造や、より高度なライブラリを使用して行われていました。フェンスはCPU固有の命令(メモリバリア)を使って行われていました。</target>
        </trans-unit>
        <trans-unit id="2e56b625d9ce23edadcdce014336b90a101f8934" translate="yes" xml:space="preserve">
          <source>Quoting from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「メモリの一貫性とキャッシュの一貫性に関する入門書」&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;からの引用&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bb9db0f94440715855f11a33ea0a95909964dfda" translate="yes" xml:space="preserve">
          <source>Readers familiar with Einstein&amp;rsquo;s &lt;strong&gt;Special Theory of Relativity&lt;/strong&gt; will notice what I am alluding to. Translating Minkowski&amp;rsquo;s words into the memory models realm: address space and time are shadows of address-space-time. In this case, each observer (i.e., thread) will project shadows of events (i.e., memory stores/loads) onto his own world-line (i.e., his time axis) and his own plane of simultaneity (his address-space axis). Threads in the C++11 memory model correspond to &lt;strong&gt;&lt;em&gt;observers&lt;/em&gt;&lt;/strong&gt; that are moving relative to each other in special relativity. Sequential consistency corresponds to the &lt;strong&gt;Galilean space-time&lt;/strong&gt; (i.e., all observers agree on one absolute order of events and a global sense of simultaneity).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アインシュタインの&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特殊相対性理論に&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;精通している読者&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、私がほのめかしていることに気づくでしょう。ミンコフスキーの言葉をメモリモデルの領域に翻訳する：アドレス空間と時間は、アドレス空間時間の影です。この場合、各オブザーバー（つまり、スレッド）は、イベント（つまり、メモリストア/ロード）の影を自分のワールドライン（つまり、時間軸）と自分の同時平面（彼のアドレス空間軸）に投影します。 。 C ++ 11メモリモデルのスレッドは、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特別な相対論で相互に移動している&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブザーバーに&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;対応し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ています。逐次一貫性は&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ガリレオ時空に&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;対応します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（つまり、すべてのオブザーバーはイベントの1つの絶対順序とグローバルな同時感覚に同意します）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a133e211f7560a29b9da4d6be92f2a22755b5da2" translate="yes" xml:space="preserve">
          <source>Relaxed Atomics</source>
          <target state="translated">リラックスアトミック</target>
        </trans-unit>
        <trans-unit id="957e61e62046dd3ea5b6cfe1f86136d6473da53c" translate="yes" xml:space="preserve">
          <source>So, bottom line. Mutexes are great, and C++11 standardizes them. But sometimes for performance reasons you want lower-level primitives (e.g., the classic &lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;double-checked locking pattern&lt;/a&gt;).  The new standard provides high-level gadgets like mutexes and condition variables, and it also provides low-level gadgets like atomic types and the various flavors of memory barrier.  So now you can write sophisticated, high-performance concurrent routines entirely within the language specified by the standard, and you can be certain your code will compile and run unchanged on both today's systems and tomorrow's.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、一番下の行。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ミューテックスは素晴らしいです、そしてC ++ 11はそれらを標準化します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、パフォーマンス上の理由から、低レベルのプリミティブが必要な場合があります（たとえば、従来の&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ダブルチェックロックパターン&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新しい標準は、ミューテックスや条件変数などの高レベルのガジェットを提供し、アトミックタイプやメモリバリアのさまざまなフレーバーなどの低レベルのガジェットも提供します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、標準で指定された言語内で完全に洗練された高性能コンカレントルーチンを記述できるようになり、コードが今日のシステムと明日のシステムの両方で変更されずにコンパイルおよび実行されることを確認できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76ca6da28f8d79dbdb145dfa98920e0946014d84" translate="yes" xml:space="preserve">
          <source>Store-store reordering may happen if a core has a non-FIFO write buffer that lets stores depart in a different order than the order in which they entered. This might occur if the first store misses in the cache while the second hits or if the second store can coalesce with an earlier store (i.e., before the first store). Load-load reordering may also happen on dynamically-scheduled cores that execute instructions out of program order. That can behave the same as reordering stores on another core (Can you come up with an example interleaving between two threads?). Reordering an earlier load with a later store (a load-store reordering) can cause many incorrect behaviors, such as loading a value after releasing the lock that protects it (if the store is the unlock operation). Note that store-load reorderings may also arise due to local bypassing in the commonly implemented FIFO write buffer, even with a core that executes all instructions in program order.</source>
          <target state="translated">コアに非FIFO書き込みバッファがあり、ストアが入った順番とは異なる順番で出発するようになっている場合、ストア・ストアの並び替えが発生する可能性があります。これは、最初のストアがキャッシュで失敗して2番目のストアがヒットした場合や、2番目のストアが以前のストアと合体した場合(つまり、最初のストアよりも前)に発生する可能性があります。負荷-負荷の再順序付けは、プログラムの順序から外れた命令を実行する動的にスケジュールされたコアでも発生する可能性があります。これは、別のコアでストアを並べ替えるのと同じ動作をすることができます (2 つのスレッド間のインターリーブの例を思いつくでしょうか?)。先にロードしたものを後のストアに並べ替える(ロード-ストアの並べ替え)と、値を保護するロックを解除した後に値をロードしてしまう(ストアがアンロック操作である場合)など、多くの不正な動作を引き起こす可能性があります。すべての命令をプログラム順に実行するコアであっても、一般的に実装されているFIFO書き込みバッファのローカルバイパスが原因でストアロードの再順序付けが発生する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="452c86d05004baf5f9579835c1ee31f42e9f5ebb" translate="yes" xml:space="preserve">
          <source>That global memory order can vary from one run of the program to another and may not be known beforehand. The characteristic feature of SC is the set of horizontal slices in the address-space-time diagram representing &lt;strong&gt;&lt;em&gt;planes of simultaneity&lt;/em&gt;&lt;/strong&gt; (i.e., memory images). On a given plane, all of its events (or memory values) are simultaneous. There is a notion of &lt;em&gt;Absolute Time&lt;/em&gt;, in which all threads agree on which memory values are simultaneous. In SC, at every time instant, there is only one memory image shared by all threads. That's, at every instant of time, all processors agree on the memory image (i.e., the aggregate content of memory). Not only does this imply that all threads view the same sequence of values for all memory locations, but also that all processors observe the same &lt;em&gt;combinations of values&lt;/em&gt; of all variables. This is the same as saying all memory operations (on all memory locations) are observed in the same total order by all threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このグローバルメモリの順序は、プログラムの実行ごとに異なる可能性があり、事前に把握されていない場合があります。 SCの特徴は&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、同時性のプレーン&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（つまり、メモリイメージ）を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表すアドレス空間時間ダイアグラムの水平スライスのセットです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。特定の平面では、そのイベント（またはメモリ値）はすべて同時に発生します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのスレッドがどのメモリ値が同時であるかについて合意する&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;絶対時間の&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;概念があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。 SCでは、常に、すべてのスレッドで共有されるメモリイメージは1つだけです。つまり、すべてのプロセッサが常に、メモリイメージ（つまり、メモリの総コンテンツ）に同意します。これは、すべてのスレッドがすべてのメモリ位置の同じ値のシーケンスを表示するだけでなく、すべてのプロセッサが同じ値を観察することを意味します&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての変数&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の値&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;組み合わせ&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これは、すべてのメモリー操作（すべてのメモリー位置）がすべてのスレッドによって同じ合計順序で観察されると言うのと同じです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d61648d21c81fd8a8c43e5576aa0e6b82a4218f" translate="yes" xml:space="preserve">
          <source>The C++ specification does not make reference to any particular compiler, operating system, or CPU.  It makes reference to an &lt;em&gt;abstract machine&lt;/em&gt; that is a generalization of actual systems.  In the Language Lawyer world, the job of the programmer is to write code for the abstract machine; the job of the compiler is to actualize that code on a concrete machine.  By coding rigidly to the spec, you can be certain that your code will compile and run without modification on any system with a compliant C++ compiler, whether today or 50 years from now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++仕様では、特定のコンパイラ、オペレーティングシステム、またはCPUについては言及していません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際のシステムを一般化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;した&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;抽象的なマシン&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照してい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。言語弁護士の世界では、プログラマーの仕事は抽象マシンのコードを書くことです。コンパイラの仕事は、そのコードを具体的なマシンで実現することです。仕様に厳密に準拠してコーディングすることにより、準拠しているC ++コンパイラを備えたシステムで、現在または50年後を問わず、コードを変更せずにコンパイルして実行することができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d29c58cddb456581d9728a1ab2e5337bca78fb3" translate="yes" xml:space="preserve">
          <source>The above answers get at the most fundamental aspects of the C++ memory model.  In practice, most uses of &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &quot;just work&quot;, at least until the programmer over-optimizes (e.g., by trying to relax too many things).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上記の答えは、C ++メモリモデルの最も基本的な側面を理解するためのものです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際には、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほとんどの使用は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、少なくともプログラマーが過度に最適化するまで（たとえば、あまりにも多くのものを緩和しようとすることによって）動作します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7d00aae881b6e2acf7384c58de1730263886b2d" translate="yes" xml:space="preserve">
          <source>The abstract machine in C++11 is multi-threaded by design.  It also has a well-defined &lt;em&gt;memory model&lt;/em&gt;; that is, it says what the compiler may and may not do when it comes to accessing memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11の抽象マシンは、設計によりマルチスレッド化されています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、明確に定義された&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリモデルがあり&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、メモリへのアクセスに関してコンパイラが実行できることとできないことを示しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7f894cea908d237d3941c58a3365a1963366b6e" translate="yes" xml:space="preserve">
          <source>The abstract machine in the C++98/C++03 specification is fundamentally single-threaded.  So it is not possible to write multi-threaded C++ code that is &quot;fully portable&quot; with respect to the spec.  The spec does not even say anything about the &lt;em&gt;atomicity&lt;/em&gt; of memory loads and stores or the &lt;em&gt;order&lt;/em&gt; in which loads and stores might happen, never mind things like mutexes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 / C ++ 03仕様の抽象マシンは、基本的にシングルスレッドです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、仕様に関して「完全に移植可能」なマルチスレッドC ++コードを作成することはできません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仕様では&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、メモリのロードとストアの&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アトミック性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、または&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ロードとストアが発生&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する順序&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;については何も言われておらず&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ミューテックスなどは気にしないでください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4baedfd0f1527134631c5de1c75f35afd5945f2" translate="yes" xml:space="preserve">
          <source>The intuitive (and most restrictive) memory model is sequential consistency (SC) in which a multithreaded execution should look like an interleaving of the sequential executions of each constituent thread, as if the threads were time-multiplexed on a single-core processor.</source>
          <target state="translated">直感的な(そして最も制限的な)メモリモデルはシーケンシャル一貫性(SC)で、マルチスレッド実行は、シングルコアプロセッサ上でスレッドが時間多重化されているかのように、各構成スレッドのシーケンシャル実行をインターリーブしているように見えなければなりません。</target>
        </trans-unit>
        <trans-unit id="754d4bff03e3971b47d96374564e1cbbaae1e141" translate="yes" xml:space="preserve">
          <source>The last issue is that it might be unnatural to make the &lt;code&gt;data&lt;/code&gt; variables atomic.  If you can't in your code, then you need to be very careful, because casting from non-atomic to atomic is only legal for primitive types.  C++20 is supposed to add &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt;, which will make this problem easier to resolve.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最後の問題は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;data&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変数をアトミック&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にすることは不自然かもしれないということ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コードに含めることができない場合は、非アトミックからアトミックへのキャストはプリミティブ型に対してのみ正当であるため、非常に注意する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 20は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、この問題の解決を容易にする&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_ref&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を追加する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことになっています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfd6846aacd447221a1a226955bb117560edf61a" translate="yes" xml:space="preserve">
          <source>The memory model means that C++ code
  now has a standardized library to call
  regardless of who made the compiler
  and on what platform it's running.
  There's a standard way to control how
  different threads talk to the
  processor's memory.</source>
          <target state="translated">メモリモデルとは、誰がコンパイラを作ったのか、どのプラットフォームで実行しているのかに関係なく、C++コードが標準化されたライブラリを呼び出すことができるようになったことを意味します。異なるスレッドがプロセッサのメモリとどのように通信するかを制御するための標準的な方法があります。</target>
        </trans-unit>
        <trans-unit id="0e82744a21c2c2bfb15618db64d694bdd7c9e7e9" translate="yes" xml:space="preserve">
          <source>The more modern the CPU, the more likely this is to be faster than the previous example.</source>
          <target state="translated">CPUが最新のものであればあるほど、先ほどの例よりも高速になる可能性が高い。</target>
        </trans-unit>
        <trans-unit id="1f139b606c7fb2fc6086b230c6282ff5ce683f53" translate="yes" xml:space="preserve">
          <source>The paper gives a few solutions.  The one with the best performance today is probably the one that uses an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_relaxed&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; the second read of the seqlock.  In the paper, it's Figure 6.  I'm not reproducing the code here, because anyone who has read this far really ought to read the paper.  It is more precise and complete than this post.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;紙はいくつかの解決策を提供します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今日最高のパフォーマンス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt; &lt;code&gt;memory_order_relaxed&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のは、seqlockの2回目の読み取りの&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;前に&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic_thread_fence&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;した&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;atomic_thread_fence&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用するものでしょう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この論文では、図6を示しています。ここまでのコードを再現しているわけではありません。これまで読んだことのある人なら誰でも、論文を読むべきです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この投稿よりも正確で完全です。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8ce878fb4b44eaa5f2ed3bf4b3939bc5a23cc2b" translate="yes" xml:space="preserve">
          <source>The resemblance between memory models and special relativity stems from the fact that both define a partially-ordered set of events, often called a causal set. Some events (i.e., memory stores) can affect (but not be affected by) other events. A C++11 thread (or observer in physics) is no more than a chain (i.e., a totally ordered set) of events (e.g., memory loads and stores to possibly different addresses).</source>
          <target state="translated">記憶モデルと特殊相対性理論の類似性は、両方とも部分的に順序づけられたイベントの集合を定義しているという事実に由来しており、しばしば因果集合と呼ばれる。一部のイベント(すなわちメモリストア)は、他のイベントに影響を与えることができます(ただし、影響を受けない)。C++11 スレッド(物理学ではオブザーバー)は、イベントの連鎖(完全に順序づけられた集合)にすぎません(例えば、異なるアドレスへのメモリ ロードやストアなど)。</target>
        </trans-unit>
        <trans-unit id="88614ce284b9f9ee72002ba72a19fbcc1fb2fe6e" translate="yes" xml:space="preserve">
          <source>The talk doesn't elaborate on the API, but rather on the reasoning, background, under the hood and behind the scenes (did you know relaxed semantics were added to the standard only because POWER and ARM do not support synchronized load efficiently?).</source>
          <target state="translated">このトークでは、APIについて詳しく説明するのではなく、その理由や背景、フードの下や舞台裏について説明しています(POWERやARMが同期負荷を効率的にサポートしていないために、リラックスセマンティクスが標準に追加されたことを知っていましたか?</target>
        </trans-unit>
        <trans-unit id="46e71907ae6df91d5f8c4646edd42cd31a4d2600" translate="yes" xml:space="preserve">
          <source>There is one place where mistakes are still common: &lt;em&gt;sequence locks&lt;/em&gt;.  There is an excellent and easy-to-read discussion of the challenges at &lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/a&gt;.  Sequence locks are appealing because the reader avoids writing to the lock word.  The following code is based on Figure 1 of the above technical report, and it highlights the challenges when implementing sequence locks in C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;間違いがまだよくある場所が1つあります。それは、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シーケンスロック&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に、課題に関する優れた読みやすいディスカッションがあり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シーケンスロックは、リーダーがロックワードへの書き込みを回避するため、魅力的です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次のコードは、上記のテクニカルレポートの図1に基づいており、C ++でシーケンスロックを実装する際の課題を強調しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="961c454b5b699e3c67051c83eb5d379453c92717" translate="yes" xml:space="preserve">
          <source>This takes us back to the ordered loads and stores &amp;ndash; so &lt;code&gt;37 0&lt;/code&gt; is no longer a possible output &amp;ndash; but it does so with minimal overhead.  (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、注文したロードとストアに戻ることができます。つまり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は可能な出力ではなくなりますが、オーバーヘッドは最小限に抑えられます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（この簡単な例では、結果は本格的な順次一貫性と同じです。大規模なプログラムでは、そうではありません。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e039b9566e8dfbf0f2a3944c91a446a0d3877578" translate="yes" xml:space="preserve">
          <source>To provide a definition of memory consistency and a motivation for abandoning SC, I will quote from &lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&quot;A Primer on Memory Consistency and Cache Coherence&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリの一貫性の定義とSCを放棄する動機を提供するために、&lt;/font&gt;&lt;a href=&quot;http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「メモリの一貫性とキャッシュの一貫性に関する入門書」&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から引用します&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf70e99ebffe9e92e5be11ffc6e48ebef4aad770" translate="yes" xml:space="preserve">
          <source>To summarize: even if you think you understand the C++ memory model, you should be very careful before rolling your own sequence locks.</source>
          <target state="translated">要約すると、C++のメモリモデルを理解していると思っていても、自分でシーケンスロックを転がす前には十分に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="5f2312cd34bd31141d0b81cd0bd16779840debfa" translate="yes" xml:space="preserve">
          <source>Under C++11, the result is Undefined Behavior, because loads and stores need not be atomic in general.  Which may not seem like much of an improvement...  And by itself, it's not.</source>
          <target state="translated">C++11 では、ロードとストアは一般的にアトミックである必要がないため、結果として未定義の動作となります。これはあまり改善されていないように見えるかもしれませんが...そして、それ自体はそうではありません。</target>
        </trans-unit>
        <trans-unit id="b9f7556c864ccbfde77ebfd4adde349b5488e4fa" translate="yes" xml:space="preserve">
          <source>Under C++98/C++03, this is not even Undefined Behavior; the question itself is &lt;em&gt;meaningless&lt;/em&gt; because the standard does not contemplate anything called a &quot;thread&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 / C ++ 03では、これは未定義の動作でさえありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;標準では「スレッド」と呼ばれるものは何も考慮されていないため&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、質問自体は&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ce2b632d1c58188c735ed2a0e6024043931901f" translate="yes" xml:space="preserve">
          <source>Unlike consistency, &lt;strong&gt;&lt;em&gt;cache coherence&lt;/em&gt;&lt;/strong&gt; is neither visible to software nor required. Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system. Correct coherence ensures that a programmer cannot determine whether and where a system has caches by analyzing the results of loads and stores. This is because correct coherence ensures that the caches never enable new or different &lt;strong&gt;&lt;em&gt;functional&lt;/em&gt;&lt;/strong&gt; behavior (programmers may still be able to infer likely cache structure using &lt;strong&gt;&lt;em&gt;timing&lt;/em&gt;&lt;/strong&gt; information). The main purpose of cache coherence protocols is maintaining the single-writer-multiple-readers (SWMR) invariant for every memory location.
  An important distinction between coherence and consistency is that coherence is specified on a &lt;strong&gt;&lt;em&gt;per-memory location basis&lt;/em&gt;&lt;/strong&gt;, whereas consistency is specified with respect to &lt;strong&gt;&lt;em&gt;all&lt;/em&gt;&lt;/strong&gt; memory locations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一貫性とは異なり、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;キャッシュの一貫性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はソフトウェアからは見えず、必須でもありません。 Coherenceは、共有メモリシステムのキャッシュをシングルコアシステムのキャッシュと同じように機能的に見えなくすることを目指しています。正しい一貫性により、プログラマーは、ロードとストアの結果を分析して、システムにキャッシュがあるかどうか、どこにキャッシュがあるかを判断できなくなります。これは、正しい一貫性により、キャッシュが新しいまたは異なる&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;機能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有効にしないことが保証されるためです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（プログラマーは、&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイミング&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用して、可能性のあるキャッシュ構造を推測できる場合があります&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情報）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;キャッシュコヒーレンスプロトコルの主な目的は、すべてのメモリの場所に対してシングルライターマルチプルリーダー（SWMR）を不変に維持することです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コヒーレンスと一貫性の重要な違いは、コヒーレンスは&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリロケーションごと&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に指定されるのに対し、一貫性は&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリロケーション&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に関して指定されること&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfacfcd81cfcca293eba3cc7493531d81a4a1b4d" translate="yes" xml:space="preserve">
          <source>Very importantly, locks (and concurrency semantics with locking) are typically implemented in a cross platform way... So if you are using standard locks in a multithreaded program with no data races then you &lt;strong&gt;don't have to worry about cross platform memory models&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非常に重要なことに、ロック（およびロックの同時実行セマンティクス）は通常、クロスプラットフォームの方法で実装されます...したがって、データ競合のないマルチスレッドプログラムで標準ロックを使用している場合は&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、クロスプラットフォームのメモリモデルについて心配する必要はありません。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e4a2ca5a3d05ddfbe2b56ccb6104a75cae606ef" translate="yes" xml:space="preserve">
          <source>Well, I can &lt;em&gt;memorize&lt;/em&gt; this and similar paragraphs available online (as I've had my own memory model since birth :P) and can even post as an answer to questions asked by others, but to be honest, I don't exactly understand this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さて、私は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これとオンラインで利用可能な同様の段落を&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;覚える&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できます（私は誕生時から自分の記憶モデルを持っていたので：P）、他の人からの質問への回答として投稿することもできますが、正直なところ、私は正確に理解できませんこの。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="956fcc4400c935b51349b1224fcb0216fed90fc4" translate="yes" xml:space="preserve">
          <source>What it cannot print is &lt;code&gt;37 0&lt;/code&gt;, because the default mode for atomic loads/stores in C++11 is to enforce &lt;em&gt;sequential consistency&lt;/em&gt;.  This just means all loads and stores must be &quot;as if&quot; they happened in the order you wrote them within each thread, while operations among threads can be interleaved however the system likes.  So the default behavior of atomics provides both &lt;em&gt;atomicity&lt;/em&gt; and &lt;em&gt;ordering&lt;/em&gt; for loads and stores.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11のアトミックロード/アトミックのデフォルトモードは&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シーケンシャルな整合性&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を強制するため、出力&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できないのは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;37 0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これは、すべてのロードとストアが、各スレッド内で書き込んだ順序で「あたかも」発生したかのいずれかである必要があることを意味しますが、システム間でスレッド間の操作をインターリーブできます。したがって、アトミックのデフォルトの動作は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ロードとストアの&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アトミック性&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;順序付けの&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;両方を提供&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fd897db0b1892f92d3ac2bb9df198d5229ab212" translate="yes" xml:space="preserve">
          <source>What might Thread 2 output?</source>
          <target state="translated">スレッド2は何を出力するかもしれませんか?</target>
        </trans-unit>
        <trans-unit id="1798b5cddeecf3effcaf30a3ce667c57f5b3451d" translate="yes" xml:space="preserve">
          <source>When you're talking about POSIX threads or Windows threads, then this is a bit of an illusion as actually you're talking about x86 threads, as it's a hardware function to run concurrently. The C++0x memory model makes guarantees, whether you're on x86, or ARM, or &lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;MIPS&lt;/a&gt;, or anything else you can come up with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;POSIXスレッドまたはWindowsスレッドについて話しているとき、これは実際にx86スレッドについて話しているように、これは少し幻想です。これは、同時に実行するハードウェア関数であるためです。 C ++ 0xメモリモデルは、x86、ARM、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MIPS_architecture&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MIPSの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いずれを使用していても、他に思いつくもの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を保証&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76cbbb6015ca76bb55e457fa170621f939633ebe" translate="yes" xml:space="preserve">
          <source>[Picture from Wikipedia]</source>
          <target state="translated">画像は「ウィキペディア」より</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
