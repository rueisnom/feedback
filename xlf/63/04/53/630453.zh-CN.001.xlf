<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/630453">
    <body>
      <group id="630453">
        <trans-unit id="0c058b89b3c60a0ba555a3620d744eb93c511f1a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH is the new primary HTTP method for updates&lt;/a&gt;&quot; explains it.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails：PATCH是用于更新的新的主要HTTP方法&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f74f51ed1b6ae265800adfcf8027c01c0018665f" translate="yes" xml:space="preserve">
          <source>10.4.10 409 Conflict</source>
          <target state="translated">10.4.10 409 冲突</target>
        </trans-unit>
        <trans-unit id="506fa830744fbb202514e4450da7b9fff37040d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; is designed to replace 2616 and in &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; describes the follow possible response for a POST</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;旨在替代2616，并在&lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;第4.3.3节中&lt;/a&gt;描述了POST的以下可能响应</target>
        </trans-unit>
        <trans-unit id="1a0c5e7063c7016b18d6c3928f19f62e9242e7e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;I wrote the following as part of another answer on SO regarding this&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;我写了以下内容作为对此的另一个答案的一部分&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="55aee01ee1d0f0416e9083e2d6f6557b9818cb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST /something&lt;/code&gt;: &quot;Take what I give you and put it anywhere you want under &lt;code&gt;/something&lt;/code&gt; as long as you give me its URL when you're done.&quot;</source>
          <target state="translated">&lt;code&gt;POST /something&lt;/code&gt; ：&amp;ldquo;接受我给您的东西，并将它放在 &lt;code&gt;/something&lt;/code&gt; 下您想要的任何地方，只要您在完成后给我其URL。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df611b43ba33bf88fde50464bfe23c704ed98e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST x&lt;/code&gt;: &quot;Store my content and give me an identifier that I can use to identify a resource (old or new) containing said content (possibly mixed with other content). Said resource should be identical or subordinate to that which &lt;code&gt;x&lt;/code&gt; identifies.&quot; &quot;&lt;em&gt;y&lt;/em&gt;'s resource is subordinate to &lt;em&gt;x&lt;/em&gt;'s resource&quot; is typically but not necessarily implemented by making &lt;em&gt;y&lt;/em&gt; a subpath of &lt;em&gt;x&lt;/em&gt; (e.g. &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; and &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt;) and modifying the representation(s) of &lt;em&gt;x&lt;/em&gt;'s resource to reflect the existence of a new resource, e.g. with a hyperlink to &lt;em&gt;y&lt;/em&gt;'s resource and some metadata. Only the latter is really essential to good design, as URLs are opaque in REST -- you're supposed to &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;use hypermedia&lt;/a&gt; instead of client-side URL construction to traverse the service anyways.</source>
          <target state="translated">&lt;code&gt;POST x&lt;/code&gt; ：&amp;ldquo;存储我的内容，并给我一个标识符，我可以用它来标识包含所述内容（可能与其他内容混合）的资源（旧的或新的）。所述资源应与 &lt;code&gt;x&lt;/code&gt; 标识的资源相同或从属。&amp;rdquo; &amp;ldquo; &lt;em&gt;y&lt;/em&gt;的资源从属于&lt;em&gt;x&lt;/em&gt;的资源&amp;rdquo;通常但不一定通过将&lt;em&gt;y&lt;/em&gt;设为&lt;em&gt;x&lt;/em&gt;的子路径（例如&lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; 和&lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt; ）并修改&lt;em&gt;x&lt;/em&gt;的表示形式来实现。的资源以反映新资源的存在，例如，具有指向&lt;em&gt;y&lt;/em&gt;的资源的超链接和一些元数据。 只有后者才是良好设计的真正必要条件，因为URL在REST中是不透明的-您应该&lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;使用超媒体&lt;/a&gt;而不是客户端URL构造来遍历服务。</target>
        </trans-unit>
        <trans-unit id="d458584efe00bde626b31645f1c9331669a393b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST&lt;/code&gt; means &quot;create new&quot; as in &quot;Here is the input for creating a user, create it for me&quot;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 的意思是&amp;ldquo;新建&amp;rdquo;，如&amp;ldquo;此处是创建用户的输入，请为我创建&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1a07f91414dd50cc7f1986ee5d6ee5a1fbee9ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; already exists): &quot;Take whatever you have at &lt;code&gt;/something&lt;/code&gt; and replace it with what I give you.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; （如果 &lt;code&gt;/something&lt;/code&gt; 已经存在）：&amp;ldquo;拿走 &lt;code&gt;/something&lt;/code&gt; 上的所有东西 ，然后用我给您的东西替换。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="46ab7ec42035f8ace3ccbdc9e29957431a709ad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; does not already exist): &quot;Take what I give you and put it at &lt;code&gt;/something&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; （如果 &lt;code&gt;/something&lt;/code&gt; 还不存在）：&amp;ldquo;拿走我给你的 &lt;code&gt;/something&lt;/code&gt; ，放在/ something上 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="8b19b9a7682dd06e6b9d4d9b60e4befaf7e822f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; does not identify a resource): &quot;Create a new resource containing my content and use &lt;code&gt;x&lt;/code&gt; to identify it.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; （如果 &lt;code&gt;x&lt;/code&gt; 不能标识资源）：&amp;ldquo;创建一个包含我的内容的新资源，并使用 &lt;code&gt;x&lt;/code&gt; 进行标识。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b7eeae57fac13ac526305058d9ec04d7f1c90069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; identifies a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;resource&lt;/a&gt;): &quot;Replace the content of the resource identified by &lt;code&gt;x&lt;/code&gt; with my content.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; （如果 &lt;code&gt;x&lt;/code&gt; 标识&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;资源&lt;/a&gt; ）：&amp;ldquo;用我的内容替换x标识的资源的内容。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="693d0f55f15f15a3670f566554ad630959a6464b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT&lt;/code&gt; means &quot;insert, replace if already exists&quot; as in &quot;Here is the data for user 5&quot;.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; 的意思是&amp;ldquo;插入，如果已经存在则替换&amp;rdquo;，如&amp;ldquo;这是用户5的数据&amp;rdquo;中所述。</target>
        </trans-unit>
        <trans-unit id="ba9411546a0e55dde6f6b3b345e14406853999d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;有些人可能会想到可以使用POST执行更新。&lt;/em&gt; &lt;em&gt;没有硬性规定使用哪个进行更新或使用哪个进行创建。&lt;/em&gt; &lt;em&gt;同样，这些都是惯例，从直觉上讲，我倾向于上述推理并遵循它。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="494905e8546c28f7ca25ed531d6f9532f60855f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;-- generic -- specific --&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;-通用-特定-&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24bd66f9b0232fdec5910e08746f4135f3abc5f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3.4.  PUT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3.4。&lt;/strong&gt; &lt;strong&gt;放&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f00078b6cfd30a400e58409eebd42604b45de8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一个例子：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b79f8a35030639797e581e3751e158add431466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Great both can be used, so which one should I use in my RESTful design:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;两者都可以使用，因此在RESTful设计中应该使用哪一个：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f204e179a99e4e4da9b046149c8fa27fab675704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Long Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;长答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ea66d061a28052dccef1603c0375aa549c7f0e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Longer Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更长的答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d19062995715b13929a5b7d5ad16cd259eea9489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; PUT需要一个需要更新的资源位置（已有资源），而POST则不需要。 因此，从直觉上讲，POST是用于创建新资源的，而PUT是更新现有资源所必需的。</target>
        </trans-unit>
        <trans-unit id="973a94f5bc8d247be1da5613a2678e40ad80ce20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;New answer (now that I understand REST better):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;新答案（现在我对REST有了更好的了解）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6eaec7db8eb07bc1a9853353813e5aacc4d8a7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; PUT has mostly been used to update resources (by replacing them in their entireties), but recently there is movement towards using PATCH for updating existing resources, as PUT specifies that it replaces the whole resource. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; PUT主要用于更新资源（通过整体替换资源），但是最近有一种趋势是使用PATCH更新现有资源，因为PUT指定它将替换整个资源。 &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f39f80f6a4493b75f71f2759494c67e2fe8499a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or you can do this&lt;/strong&gt;: consider your unsafe requests as ephemeral single-user resources (let's call them actions). Clients request a new &quot;action&quot; on a substantive resource with an empty POST to the resource. POST will be used only for this. Once safely in possession of the URI of the freshly minted action, the client PUTs the unsafe request to the action URI, &lt;em&gt;not the target resource&lt;/em&gt;. Resolving the action and updating the &quot;real&quot; resource is properly the job of your API, and is here decoupled from the unreliable network.</source>
          <target state="translated">&lt;strong&gt;或者，您可以这样做&lt;/strong&gt; ：将不安全的请求视为短暂的单用户资源（我们称其为操作）。 客户端请求对该实体资源执行新的&amp;ldquo;操作&amp;rdquo;，同时对该资源执行空POST。 POST仅用于此目的。 一旦安全地拥有了刚创建的动作的URI，客户端就会将不安全的请求放到动作URI， &lt;em&gt;而不是目标资源&lt;/em&gt; 。 解决该操作并更新&amp;ldquo;实际&amp;rdquo;资源完全是您API的工作，并且在这里与不可靠的网络分离。</target>
        </trans-unit>
        <trans-unit id="83d03f71c82f9f3e365473c2e90a536428e4a72f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer (might be easier to read)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;原始答案（可能更容易阅读）&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="fb16687bea1f8e2c7ffd77af09d8a11526e30bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overall:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overall:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fec18cd93d5bbce335b8a8b4685449de2c1a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PATCH&lt;/strong&gt; to a URL &lt;strong&gt;updates &lt;em&gt;part&lt;/em&gt; of the resource&lt;/strong&gt; at that client defined URL.</source>
          <target state="translated">对URL进行&lt;strong&gt;PATCH&lt;/strong&gt; &lt;strong&gt;更新会&lt;/strong&gt;在该客户端定义的URL上&lt;strong&gt;更新&lt;em&gt;部分&lt;/em&gt;资源&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e900f8bab5ad45a82b31d5c9e77eb8b842fb8fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST creates a child resource&lt;/strong&gt;, so POST to &lt;code&gt;/items&lt;/code&gt; creates a resources that lives under the &lt;code&gt;/items&lt;/code&gt; resource. 
Eg. &lt;code&gt;/items/1&lt;/code&gt;. Sending the same post packet twice will create two resources.</source>
          <target state="translated">&lt;strong&gt;POST创建一个子资源&lt;/strong&gt; ，因此POST到 &lt;code&gt;/items&lt;/code&gt; 创建一个位于 &lt;code&gt;/items&lt;/code&gt; 资源下的资源。 例如。 &lt;code&gt;/items/1&lt;/code&gt; 。 两次发送相同的邮包将创建两个资源。</target>
        </trans-unit>
        <trans-unit id="84cd833b3d09b3772c7c9b69992c06365b49d808" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;POST:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51d739446154fe4129eacba513d3e7c1cbc82d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; /items</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; /项目</target>
        </trans-unit>
        <trans-unit id="81f179204aeec70824672b29654dc73a5ef03745" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; You can think of something like &quot;INSERT INTO STUDENT(name, address) VALUES (&quot;abc&quot;, &quot;xyzzz&quot;);</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;您可以想到&amp;ldquo; INSERT INTO STUDENT（name，address）VALUES（&amp;ldquo; abc&amp;rdquo;，&amp;ldquo; xyzzz&amp;rdquo;）;</target>
        </trans-unit>
        <trans-unit id="d84ba3155ffa58932b6b44f1f889c414429f25ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; a resource into a collection</source>
          <target state="translated">将资源发布到集合中</target>
        </trans-unit>
        <trans-unit id="c6057b584edf3b882a3192b1dc61a689a17f508b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;是非幂等的，与执行一次相比，如果多次执行该操作，资源状态可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="fa11acc5dc60894a4a26cfcbe0027d32f1604de8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;PUT&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;应该用于创建资源，而&lt;strong&gt;PUT&lt;/strong&gt;应该用于修改资源</target>
        </trans-unit>
        <trans-unit id="83971fa0e325d0bc5650b7ff303b5ca7b5384576" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL &lt;strong&gt;creates a child resource&lt;/strong&gt; at a &lt;em&gt;server defined&lt;/em&gt; URL.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;到URL &lt;strong&gt;将&lt;/strong&gt;在&lt;em&gt;服务器定义&lt;/em&gt;的URL上&lt;strong&gt;创建子资源&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="39214825f7bf31755a7524b96e478ffac1270da2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL should be used to update or create a resource which is located at some other (&quot;subordinate&quot;) URL, or is not locatable via HTTP.</source>
          <target state="translated">到URL的&lt;strong&gt;POST&lt;/strong&gt;应该用于更新或创建位于其他URL（&amp;ldquo;从属&amp;rdquo;）的资源，或者不能通过HTTP定位的资源。</target>
        </trans-unit>
        <trans-unit id="906a2e1913665dd7ea341fe6a356f1a5db4491c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; updates a resource, adds a subsidiary resource, or causes a change.  A POST is not idempotent, in the way that &lt;code&gt;x++&lt;/code&gt; is not idempotent.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;更新资源，添加辅助资源或引起更改。 POST不是幂等的，因为 &lt;code&gt;x++&lt;/code&gt; 不是幂等的。</target>
        </trans-unit>
        <trans-unit id="1201fa44ed952a209bb94b60653ae5e6d12e8775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cb09efafb2a756a2c8c49fbf16fde25b499a6f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt;  /items/1234</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; /项目/ 1234</target>
        </trans-unit>
        <trans-unit id="04e6413418714eccb311ba8ccd68a6eb8397b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; You can think of similar to &quot;UPDATE STUDENT SET address = &quot;abc&quot; where id=&quot;123&quot;;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;您可以想到类似于&amp;ldquo; UPDATE STUDENT SET address =&amp;ldquo; abc&amp;rdquo;，其中id =&amp;ldquo; 123&amp;rdquo;;</target>
        </trans-unit>
        <trans-unit id="bac831f172bbd16f060e11a1fcf6a1142deebaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; a resource identified by collection/:id</source>
          <target state="translated">&lt;strong&gt;放置&lt;/strong&gt;由collection /：id标识的资源</target>
        </trans-unit>
        <trans-unit id="43e9659830aa7fe8a7b61df6c3d0f9fe51884752" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; implies putting a resource - completely replacing whatever is available at the given URL with a different thing.  By definition, a PUT is idempotent.  Do it as many times as you like, and the result is the same. &lt;code&gt;x=5&lt;/code&gt; is idempotent.  You can PUT a resource whether it previously exists, or not (eg, to Create, or to Update)!</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;意味着放置资源-用另一件事完全替换给定URL上可用的任何内容。 根据定义，PUT是幂等的。 进行多次，结果是相同的。 &lt;code&gt;x=5&lt;/code&gt; 是幂等的。 您可以放置​​一个资源，无论它先前是否存在（例如，创建或更新）！</target>
        </trans-unit>
        <trans-unit id="11d47c3923ae9d2cba6624010bda74e130873ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is for creating or replacing a resource at a &lt;strong&gt;URL known by the client&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;用于&lt;strong&gt;在客户端已知&lt;/strong&gt;的&lt;strong&gt;URL&lt;/strong&gt;处创建或替换资源。</target>
        </trans-unit>
        <trans-unit id="3fa7bf3d7c1668ea88085a1bf5c94b878a2e04e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;是幂等的，如果一次或多次执行相同的操作，则资源状态将相同。</target>
        </trans-unit>
        <trans-unit id="ad48efa009a26f69b5139207c4818699892b929a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; replaces the resource at the known url if it already exists, so sending the same request twice has no effect. In other words, &lt;strong&gt;calls to PUT are idempotent&lt;/strong&gt;.</source>
          <target state="translated">如果已存在，则&lt;strong&gt;PUT&lt;/strong&gt;将替换已知URL处的资源，因此两次发送相同的请求无效。 换句话说， &lt;strong&gt;对PUT的调用是幂等的&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="47297bbd78d247783bb6a9b461b4320abab889a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;POST&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">应该使用&lt;strong&gt;PUT&lt;/strong&gt;创建资源，并使用&lt;strong&gt;POST&lt;/strong&gt;修改资源</target>
        </trans-unit>
        <trans-unit id="2316d8434c10c4f7c6461cd73b5ad3a9c62ff074" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL &lt;strong&gt;creates/replaces the resource&lt;/strong&gt; in its entirety at the &lt;em&gt;client defined&lt;/em&gt; URL.</source>
          <target state="translated">&lt;strong&gt;放置&lt;/strong&gt;到URL &lt;strong&gt;会&lt;/strong&gt;在&lt;em&gt;客户端定义的&lt;/em&gt; URL上完整地&lt;strong&gt;创建/替换资源&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a47a55d20b6233f89d8f607db5f21886379877c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL should be used to update or create the resource that can be located at that URL.</source>
          <target state="translated">放置到URL的&lt;strong&gt;PUT&lt;/strong&gt;应该用于更新或创建可位于该URL的资源。</target>
        </trans-unit>
        <trans-unit id="0eb5b9e913c2e4810b9d275d9137826d6361fccb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post&lt;/strong&gt; on social media: when we post message, it creates new post.</source>
          <target state="translated">在社交媒体上发布：当我们发布消息时，它会创建新的帖子。</target>
        </trans-unit>
        <trans-unit id="c379deb81ec8171aeba8c48b33c76a4077d81ae5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put&lt;/strong&gt;(i.e. edit) for the message we already Posted.</source>
          <target state="translated">&lt;strong&gt;放入&lt;/strong&gt; （即编辑）我们已经发布的消息。</target>
        </trans-unit>
        <trans-unit id="42f2ab7a6f0ba70ad4633ee1aeb9c5617f17e37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replying with a status code of 409 Conflict is the correct recourse because&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;回复状态码为409冲突是正确的方法，因为&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="541c698af4296a2ac8f6dbcf007beace20e3289c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;简短答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7dee22b45482414ebaedf9e5284e4fb4d8d9302d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The decision of whether to use PUT or POST to create a resource on a server with an HTTP + REST API is based on who owns the URL structure.&lt;/strong&gt; Having the client know, or participate in defining, the URL struct is an unnecessary coupling akin to the undesirable couplings that arose from SOA. Escaping types of couplings is the reason REST is so popular. Therefore, &lt;strong&gt;the proper method to use is POST.&lt;/strong&gt; There are exceptions to this rule and they occur when the client wishes to retain control over the location structure of the resources it deploys. This is rare and likely means something else is wrong.</source>
          <target state="translated">&lt;strong&gt;是否使用PUT或POST在具有HTTP + REST API的服务器上创建资源的决定取决于谁拥有URL结构。&lt;/strong&gt; 让客户知道或参与定义URL结构是类似于SOA产生的不良耦合的不必要耦合。 转义类型是REST如此流行的原因。 因此，使用&lt;strong&gt;的正确方法是POST。&lt;/strong&gt; 该规则有一些例外，当客户端希望保留对其部署的资源的位置结构的控制权时，就会发生这些例外。 这种情况很少见，很可能意味着其他地方出了问题。</target>
        </trans-unit>
        <trans-unit id="52dde7c3fb20e3705b4cb8c6fdc0d421a3aa14d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018&lt;/strong&gt;: There is a case that can be made to avoid PUT. See &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;REST without PUT&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;2018年更新&lt;/strong&gt; ：可以避免使用PUT。 请参阅&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&amp;ldquo;不带PUT的REST&amp;rdquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ab5192fbe6cef7ceb3ab2181f51408e2e0392" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update based on release of RFC 7231 to Replace 2616&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基于RFC 7231版本的更新以替换2616&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="823a6eb1d93ecc4c59ea5a879b8110b0723a4c56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using POST to create resources comes with a design consideration because POST is not idempotent.&lt;/strong&gt; This means that repeating a POST several times does not guarantee the same behavior each time. &lt;strong&gt;This scares people into using PUT to create resources when they should not.&lt;/strong&gt; They know it's wrong (POST is for CREATE) but they do it anyway because they don't know how to solve this problem.  This concern is demonstrated in the following situation:</source>
          <target state="translated">&lt;strong&gt;使用POST创建资源具有设计上的考虑，因为POST不是幂等的。&lt;/strong&gt; 这意味着多次重复POST并不能保证每次都具有相同的行为。 &lt;strong&gt;这使人们在不应该使用PUT来创建资源时感到恐惧。&lt;/strong&gt; 他们知道这是错误的消息（POST用于CREATE），但是他们还是这样做，因为他们不知道如何解决此问题。 在以下情况下证明了这种担忧：</target>
        </trans-unit>
        <trans-unit id="f8352b060f3bd6bf9405565ea670a52e1a19ac89" translate="yes" xml:space="preserve">
          <source>A PUT doesn't need to be a create; the service could error if the resource isn't already created, but otherwise update it. Or vice versa -- it may create the resource, but not allow updates. The only thing required about PUT is that it points to a specific resource, and its payload is the representation of that resource. A successful PUT means (barring interference) that a GET would retrieve the same resource.</source>
          <target state="translated">PUT不需要是创建;如果资源还没有被创建,服务可能会出错,但会更新资源。反之亦然----它可能会创建资源,但不允许更新。PUT的唯一要求是它指向一个特定的资源,它的有效载荷是该资源的表示。一个成功的PUT意味着(排除干扰),一个GET将检索到相同的资源。</target>
        </trans-unit>
        <trans-unit id="0e9a6a3224dfefa9263f801580fea79e1034124c" translate="yes" xml:space="preserve">
          <source>A REST API must not define fixed resource names or hierarchies (an
  obvious coupling of client and server). Servers must have the freedom
  to control their own namespace. Instead, allow servers to instruct
  clients on how to construct appropriate URIs, such as is done in HTML
  forms and URI templates, by defining those instructions within media
  types and link relations. [Failure here implies that clients are
  assuming a resource structure due to out-of band information, such as
  a domain-specific standard, which is the data-oriented equivalent to
  RPC's functional coupling].</source>
          <target state="translated">REST API不能定义固定的资源名称或层次结构(客户端和服务器的明显耦合)。服务器必须有控制自己的命名空间的自由。相反,允许服务器通过在媒体类型和链接关系中定义这些指令,让服务器指示客户端如何构造合适的URI,比如在HTML表单和URI模板中就可以这样做。这里的失败意味着客户机由于带外信息而假定了一个资源结构,例如特定领域的标准,这相当于RPC的面向数据的功能耦合]。</target>
        </trans-unit>
        <trans-unit id="4eebc73de916b615d31b4a9c02c76f42d153bef9" translate="yes" xml:space="preserve">
          <source>A general advice is to use &lt;code&gt;POST&lt;/code&gt; when you need the server to be in control of &lt;code&gt;URL&lt;/code&gt; generation of your resources. Use &lt;code&gt;PUT&lt;/code&gt; otherwise.  Prefer &lt;code&gt;PUT&lt;/code&gt;  over &lt;code&gt;POST&lt;/code&gt;.</source>
          <target state="translated">一般建议是在需要服务器控制资源的 &lt;code&gt;URL&lt;/code&gt; 生成时使用 &lt;code&gt;POST&lt;/code&gt; 。 否则使用 &lt;code&gt;PUT&lt;/code&gt; 。 与 &lt;code&gt;POST&lt;/code&gt; 相比,首选 &lt;code&gt;PUT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46f192218c6e582580086317328dbf11d360983" translate="yes" xml:space="preserve">
          <source>A general rule: if you know the id or name of the item, use PUT. If you want the id or name of the item to be assigned by the receiving party, use POST.</source>
          <target state="translated">一般规则:如果你知道项目的id或名称,请使用PUT。如果你想让接收方指定物品的id或名称,请使用POST。</target>
        </trans-unit>
        <trans-unit id="8d80afd687e25858c217eccf9caa91d0cf98797f" translate="yes" xml:space="preserve">
          <source>A new method is necessary to improve interoperability and prevent
     errors.  The PUT method is already defined to overwrite a resource
     with a complete new body, and cannot be reused to do partial changes.
     Otherwise, proxies and caches, and even clients and servers, may get
     confused as to the result of the operation.  POST is already used but
     without broad interoperability (for one, there is no standard way to
     discover patch format support).  PATCH was mentioned in earlier HTTP
     specifications, but not completely defined.</source>
          <target state="translated">为了提高互操作性,防止出错,有必要使用一种新的方法。PUT方法已经被定义为用一个完整的新体覆盖一个资源,不能重复使用PUT方法来进行部分更改。否则,代理和缓存,甚至客户端和服务器都可能会对操作结果产生混淆。POST已经在使用,但没有广泛的互操作性(一是没有标准的方法发现补丁格式支持)。在早期的HTTP规范中提到了PATCH,但没有完全定义。</target>
        </trans-unit>
        <trans-unit id="d7612bc02c9fa195c518a31c5e2d100c9f1167a8" translate="yes" xml:space="preserve">
          <source>A response which contains the URL of the resource with the conflicting ID and the appropriate preconditions for the resource would provide &amp;ldquo;enough information for the user or user agent to fix the problem&amp;rdquo; which is the ideal case per RFC 2616.</source>
          <target state="translated">包含具有冲突ID的资源URL和资源适当先决条件的响应将提供&amp;ldquo;足够的信息供用户或用户代理解决问题&amp;rdquo;，这是RFC 2616的理想情况。</target>
        </trans-unit>
        <trans-unit id="0a5f004271832132b2407dff2153fd15001e9ee0" translate="yes" xml:space="preserve">
          <source>According to ME, real-life networks are unreliable. Requests timeout. Connections are reset. Networks go down for hours or days at a time. Trains go into tunnels with mobile users aboard. For any given request (as occasionally acknowledged in all this discussion) the request can fall in the water on its way, or the response can fall in the water on its way back. &lt;strong&gt;In these conditions, issuing PUT, POST and DELETE requests directly against substantive resources has always struck me as a little brutal and naive.&lt;/strong&gt;</source>
          <target state="translated">据我说，现实生活中的网络是不可靠的。 请求超时。 连接被重置。 网络一次会中断数小时或数天。 火车与移动用户一起进入隧道。 对于任何给定的请求（在所有本次讨论中都会偶尔承认），请求可能会顺其自然地掉入水中，或者响应可能会顺其自然地掉入水中。 &lt;strong&gt;在这种情况下，直接针对实质性资源发出PUT，POST和DELETE请求总是让我感到有些野蛮和天真。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44a64212bc466bad1c26da5cf30cd0ad13d5b0f6" translate="yes" xml:space="preserve">
          <source>According to the HTTP 1.1 specifications the GET, HEAD, DELETE, and PUT methods must be idempotent, and the POST method is not idempotent. That is to say that an operation is idempotent if it can be performed on a resource once or many times and always return the same state of that resource. Whereas a non idempotent operation can return a modified state of the resource from one request to another. Hence, in a non idempotent operation, there is no guarantee that one will receive the same state of a resource.</source>
          <target state="translated">根据HTTP 1.1规范,GET、HEAD、DELETE和PUT方法必须是idempototent的,而POST方法不是idempotent的。也就是说,如果一个操作可以在一个资源上执行一次或多次,并且总是返回该资源的相同状态,那么这个操作就是idempototent。而非idempototent操作则可以从一个请求到另一个请求返回资源的修改状态。因此,在非空性操作中,不能保证会收到资源的相同状态。</target>
        </trans-unit>
        <trans-unit id="263017c41745f1b94fb06cd0b37045f3eec4ef1a" translate="yes" xml:space="preserve">
          <source>According to the HTTP/1.1 Spec:</source>
          <target state="translated">根据HTTP1.1规范。</target>
        </trans-unit>
        <trans-unit id="99391b86ae4d4984d262f89901db8c15300e563f" translate="yes" xml:space="preserve">
          <source>According to this, you cannot send files or multipart data in the &lt;strong&gt;PUT&lt;/strong&gt; method</source>
          <target state="translated">因此，您无法使用&lt;strong&gt;PUT&lt;/strong&gt;方法发送文件或多部分数据</target>
        </trans-unit>
        <trans-unit id="400cd438f5e39bdc77550bfd923cf916451692bd" translate="yes" xml:space="preserve">
          <source>Additionally, and a bit more concisely, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 Section 4.3.4 PUT&lt;/a&gt; states (emphasis added),</source>
          <target state="translated">此外，更简洁一点的是&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231第4.3.4节PUT&lt;/a&gt;状态（添加了强调），</target>
        </trans-unit>
        <trans-unit id="18829b20b3b1624e09ed74c26fb7066a49e205d0" translate="yes" xml:space="preserve">
          <source>Analogy with database query</source>
          <target state="translated">与数据库查询进行类比</target>
        </trans-unit>
        <trans-unit id="1ecad98fe7923a037242a110b7abf85eb0ca5b54" translate="yes" xml:space="preserve">
          <source>Analogy:</source>
          <target state="translated">Analogy:</target>
        </trans-unit>
        <trans-unit id="cd8441cd54d554959dc0b978e4c1160125beaede" translate="yes" xml:space="preserve">
          <source>As for modifying the properties of the stream, you can do that with either PUT or POST. Basically, only use &quot;PUT&quot; when the operation is idempotent - otherwise use POST.</source>
          <target state="translated">至于修改流的属性,你可以用PUT或POST来完成。基本上,只有当操作是空投的时候才使用 &quot;PUT&quot;,否则就使用POST。</target>
        </trans-unit>
        <trans-unit id="1505fe853a030352c8bbf3a78d4f0ba03add0832" translate="yes" xml:space="preserve">
          <source>As such, numerous thorny problems go away. Repeated insert requests won't create duplicates, and we don't create the real resource until we're in possession of the data. (database columns can stay not-nullable). Repeated update requests won't hit incompatible states and won't overwrite subsequent changes. Clients can (re)fetch and seamlessy process the original confirmation for whatever reason (client crashed, response went missing, etc.).</source>
          <target state="translated">如此一来,无数棘手的问题就迎刃而解了。重复的插入请求不会产生重复,而且我们在拥有数据之前不会创建真正的资源。数据库中的列可以保持非空)。重复的更新请求不会碰到不兼容的状态,也不会覆盖后续的更改。客户端可以(重新)获取和无缝处理原始确认的原因(客户端崩溃、响应丢失等)。</target>
        </trans-unit>
        <trans-unit id="9269d826939b1ae8561cb8d676c6f19e2aeeeeb8" translate="yes" xml:space="preserve">
          <source>As your quote mentioned, you use PUT for creation of there is no resource assigned to an IRI, and you want to create a resource anyway. For example, &lt;code&gt;PUT /users/123/password&lt;/code&gt; usually replaces the old password with a new one, but you can use it to create a password if it does not exist already (for example, by freshly registered users or by restoring banned users).</source>
          <target state="translated">如您的报价所述，您使用PUT来创建没有分配给IRI的资源，并且无论如何都想要创建资源。 例如， &lt;code&gt;PUT /users/123/password&lt;/code&gt; 通常用新密码替换旧密码，但是如果尚不存在密码（例如，由新注册的用户或通过恢复被禁止的用户），则可以使用它来创建密码。</target>
        </trans-unit>
        <trans-unit id="678d1314d4c33bf4616bbffabc6f6412417d7408" translate="yes" xml:space="preserve">
          <source>At the risk of restating what has already been said, it seems important to remember that &lt;strong&gt;PUT&lt;/strong&gt; implies that the client controls what the &lt;em&gt;URL&lt;/em&gt; is going to end up being, when creating a resource. So part of the choice between &lt;strong&gt;PUT&lt;/strong&gt; and &lt;strong&gt;POST&lt;/strong&gt; is going to be about how much you can trust the client to provide correct, normalized &lt;em&gt;URL&lt;/em&gt; that are coherent with whatever your URL scheme is.</source>
          <target state="translated">冒着重述已经说过的风险的危险，重要的是要记住， &lt;strong&gt;PUT&lt;/strong&gt;暗示了客户端在创建资源时控制&lt;em&gt;URL&lt;/em&gt;最终将成为什么样的&lt;em&gt;URL&lt;/em&gt; 。 因此，在&lt;strong&gt;PUT&lt;/strong&gt;和&lt;strong&gt;POST&lt;/strong&gt;之间进行选择的一部分将是您可以信任客户端提供多少与您的URL方案一致的正确的，标准化的&lt;em&gt;URL&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd64c65270203c04e0ffe12619fc3c1cf5cb0838" translate="yes" xml:space="preserve">
          <source>At this point some people will argue that if &lt;em&gt;RESTful-URL's&lt;/em&gt; are used, the client does knows the URL of the resource and therefore a PUT is acceptable. After all, this is why canonical, normalized, Ruby on Rails, Django URLs are important, look at the Twitter API &amp;hellip; blah blah blah. Those people need to understand &lt;strong&gt;there is no such thing as a Restful-URL&lt;/strong&gt; and that &lt;strong&gt;Roy Fielding himself states that&lt;/strong&gt;:</source>
          <target state="translated">在这一点上，有人会争辩说，如果使用&lt;em&gt;RESTful-URL&lt;/em&gt; ，则客户端确实知道资源的URL，因此PUT是可接受的。 毕竟，这就是为什么规范，规范化，Ruby on Rails，Django URL很重要的原因，请看Twitter API&amp;hellip;&amp;hellip;等等等等。 那些人需要了解&lt;strong&gt;没有Restful-URL之类的东西&lt;/strong&gt; ， &lt;strong&gt;Roy Fielding自己指出&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="48ec0b3e3b0319156f9f91acfe20356337cec520" translate="yes" xml:space="preserve">
          <source>Based on the above idempotent definition, my take on using the HTTP PUT method versus using the HTTP POST method for REST services is:
Use the HTTP PUT method when:</source>
          <target state="translated">基于上述的idempototent定义,我对使用HTTP PUT方法与使用REST服务的HTTP POST方法的看法是。使用HTTP PUT方法的时候,使用HTTP PUT方法。</target>
        </trans-unit>
        <trans-unit id="625c633dc893bb8acf9969ce26d2c745e6ed5c5d" translate="yes" xml:space="preserve">
          <source>Because PUT and GET and DELETE refer to a resource, they are also by definition idempotent.</source>
          <target state="translated">因为PUT和GET和DELETE指的是一个资源,所以它们在定义上也是同位性的。</target>
        </trans-unit>
        <trans-unit id="33d0f759f56954a746edd3401e6d1ad592971425" translate="yes" xml:space="preserve">
          <source>Before telling me this is not RESTful, please consider the numerous ways in which REST principles are respected. Clients don't construct URLs. The API stays discoverable, albeit with a little change in semantics. HTTP verbs are used appropriately. If you think this is a huge change to implement, I can tell you from experience that it's not.</source>
          <target state="translated">在告诉我这不是RESTful之前,请考虑一下REST原则的众多方式。客户端不构造URL。API保持可发现性,尽管语义上有一点变化。合理地使用HTTP动词。如果你认为这是个巨大的改变,我可以根据经验告诉你,其实不然。</target>
        </trans-unit>
        <trans-unit id="241aa52fb81745d04b1069f6da972cd395e23c48" translate="yes" xml:space="preserve">
          <source>Best of all, we give sending and receiving applications a chance to link the uniquely identified action to uniqueness in their respective environments. And we can start to demand, and enforce!, responsible behaviour from clients: repeat your requests as much as you like, but don't go generating a new action until you're in possession of a definitive result from the existing one.</source>
          <target state="translated">最重要的是,我们给发送和接收应用提供了一个机会,让发送和接收应用在各自的环境中把唯一的动作与唯一性联系起来。而且我们可以开始要求,并强制执行!对客户负责任的行为:尽可能多地重复你的请求,但在你从现有的请求中获得明确的结果之前,不要去生成一个新的动作。</target>
        </trans-unit>
        <trans-unit id="b0bf6e9b80cf880bc4aee735753fe3f2ad23f833" translate="yes" xml:space="preserve">
          <source>Better is to choose between PUT and POST based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;idempotence&lt;/a&gt; of the action.</source>
          <target state="translated">更好的是根据操作的&lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;幂等&lt;/a&gt;性在PUT和POST之间进行选择。</target>
        </trans-unit>
        <trans-unit id="53c932206c69e73836ac721b4e0fe0b474be565c" translate="yes" xml:space="preserve">
          <source>Both PUT and POST can be used for creating.</source>
          <target state="translated">PUT和POST都可以用于创建。</target>
        </trans-unit>
        <trans-unit id="2997f210a9beea7a9cbb23843149e3c1e35aa1ed" translate="yes" xml:space="preserve">
          <source>Both are used for data transmission between client to server, but there are subtle differences between them, which are:</source>
          <target state="translated">两者都是用于客户端到服务器之间的数据传输,但两者之间有细微的区别,即。</target>
        </trans-unit>
        <trans-unit id="15b3b6388bc7e089c531c0bb3e2208420e07f69e" translate="yes" xml:space="preserve">
          <source>By this argument, PUT is for creating when you know the URL of the thing you will create. POST can be used to create when you know the URL of the &quot;factory&quot; or manager for the category of things you want to create.</source>
          <target state="translated">通过这个参数,PUT是在你知道你要创建的东西的URL时用于创建。当你知道你要创建的东西类别的 &quot;工厂 &quot;或管理器的URL时,可以使用POST来创建。</target>
        </trans-unit>
        <trans-unit id="c7c8d0b3ba4ea21e1913266949e8103ea15c06b3" translate="yes" xml:space="preserve">
          <source>Can &lt;strong&gt;only&lt;/strong&gt; be performed with PUT in the following way:</source>
          <target state="translated">&lt;strong&gt;只能&lt;/strong&gt;通过以下方式通过PUT执行：</target>
        </trans-unit>
        <trans-unit id="29d666e583f03fcf75786741bc1b0cab3486e6df" translate="yes" xml:space="preserve">
          <source>Can be performed with both PUT or POST in the following way:</source>
          <target state="translated">可以用PUT或POST两种方式进行。</target>
        </trans-unit>
        <trans-unit id="34e3815fe6dbc55d1a2ed6585c021c9fc37f549b" translate="yes" xml:space="preserve">
          <source>Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.</source>
          <target state="translated">案例1:当你在时间轴上发布东西时,是一个新的新条目。所以在这种情况下,他们使用的是POST方法,因为POST方法是非空穴来风。</target>
        </trans-unit>
        <trans-unit id="afe97da32ea658ba5cfa1f6a3af16660a6caad91" translate="yes" xml:space="preserve">
          <source>Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.</source>
          <target state="translated">情况2:如果你的朋友第一次对你的帖子发表评论,那也会在数据库中创建一个新的条目,所以使用的是POST方法。</target>
        </trans-unit>
        <trans-unit id="51c87be0979efc83a96ee19ed6970b9953da779d" translate="yes" xml:space="preserve">
          <source>Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*</source>
          <target state="translated">情况3:如果你的朋友编辑了他的评论,在这种情况下,他们有一个评论id,所以他们会更新一个现有的评论,而不是在数据库中创建一个新的条目。因此,对于这种类型的操作使用PUT方法,因为它是idempotent.*。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="b0e2937475fc503e223c56343b52c44da7a6fa27" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a PUT request. For
  example, if versioning were being used and the entity being PUT
  included changes to a resource which conflict with those made by an
  earlier (third-party) request, the server might use the 409 response
  to indicate that it can&amp;rsquo;t complete the request. In this case, the
  response entity would likely contain a list of the differences between
  the two versions in a format defined by the response Content-Type.</source>
          <target state="translated">响应PUT请求最有可能发生冲突。 例如，如果正在使用版本控制，并且正在PUT的实体包括对资源的更改，该更改与先前（第三方）请求所做的更改冲突，则服务器可能会使用409响应来指示它无法完成该请求。 在这种情况下，响应实体可能会以响应Content-Type定义的格式包含两个版本之间差异的列表。</target>
        </trans-unit>
        <trans-unit id="93b186070c96257e81f5f76dda28fe4aaa692252" translate="yes" xml:space="preserve">
          <source>Create:</source>
          <target state="translated">Create:</target>
        </trans-unit>
        <trans-unit id="17b1e45ff463141be485d41572191a7ed7413417" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;A&lt;/strong&gt; new resource under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;. Usually the identifier is returned by the server.</source>
          <target state="translated">在/ resources URI或&lt;strong&gt;collection&lt;/strong&gt;下创建&lt;strong&gt;一个&lt;/strong&gt;新资源。 通常，标识符由服务器返回。</target>
        </trans-unit>
        <trans-unit id="33e5496ae029f6fe64dd2213c64d6ba200b86f51" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;THE&lt;/strong&gt; new resource with &lt;strong&gt;newResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">在/ resources URI或&lt;strong&gt;collection&lt;/strong&gt;下使用&lt;strong&gt;newResourceId&lt;/strong&gt;作为标识符创建&lt;strong&gt;THE&lt;/strong&gt;新资源。</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="33ac997d5d937f49dfe9ade3e811b0f958a8e36d" translate="yes" xml:space="preserve">
          <source>Do not directly correlate and map CRUD operations to HTTP methods for REST services. The use of an HTTP PUT method versus an HTTP POST method should be based on the idempotent aspect of that operation. That is, if the operation is idempotent, then use the HTTP PUT method. If the operation is non idempotent, then use the HTTP POST method.</source>
          <target state="translated">不要将CRUD操作直接关联并映射到REST服务的HTTP方法上。HTTP PUT方法与HTTP POST方法的使用应该基于该操作的idempototent方面。也就是说,如果操作是idempototent的,就使用HTTP PUT方法。如果操作是非空性的,则使用HTTP POST方法。</target>
        </trans-unit>
        <trans-unit id="d370df4be6707296d029645b0b4712b06c53ef1c" translate="yes" xml:space="preserve">
          <source>Do you name your URL objects you create explicitly, or let the server decide? If you name them then use PUT.  If you let the server decide then use POST.</source>
          <target state="translated">你是明确地给你创建的URL对象命名,还是让服务器决定?如果你给它们命名,那就用PUT。如果你让服务器决定,那就用POST。</target>
        </trans-unit>
        <trans-unit id="58945bef9cdd3ff1a80ba82c0e9d1f5a2d0ee11b" translate="yes" xml:space="preserve">
          <source>Edit: One more thing -- a PUT can create, but if it does then the ID has to be a natural ID -- AKA an email address. That way when you PUT twice, the second put is an update of the first. This makes it &lt;em&gt;idempotent&lt;/em&gt;.</source>
          <target state="translated">编辑：还有一件事-PUT可以创建，但是如果这样做，则ID必须是自然ID-也就是电子邮件地址。 这样，当您两次输入PUT时，第二个Put就是对第一个Put的更新。 这使其成为&lt;em&gt;幂等的&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8ed4a1daabc4dbc57c02baa4ed3068d24acd58e8" translate="yes" xml:space="preserve">
          <source>For a new resource:</source>
          <target state="translated">对于一个新的资源。</target>
        </trans-unit>
        <trans-unit id="cff50999f4c249529ddc6e468c61561154669de5" translate="yes" xml:space="preserve">
          <source>For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.</source>
          <target state="translated">例如,当你想创建一个新的信息流时,你可以将其PUT到某个URL。但是,当你想把信息发布到现有的流中时,你可以把信息发布到它的URL。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f547ae451be4b97139f6676d6b8b56908850c325" translate="yes" xml:space="preserve">
          <source>For instance, it may not be a good idea to create credit card transactions with POST.</source>
          <target state="translated">例如,用POST创建信用卡交易可能不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="cc46f3f2f22617ca008bc0347b91c6bcc94f57de" translate="yes" xml:space="preserve">
          <source>For more information about this, read this &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;article&lt;/a&gt;.</source>
          <target state="translated">有关此的更多信息，请阅读&lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;本文&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd29602a6814d7031623e943eb9ad9b03163c44" translate="yes" xml:space="preserve">
          <source>From a REST architecture's point of view there is none that matters. We could have lived without PUT as well. But from a client developer's point of view it made his/her life a lot simpler.</source>
          <target state="translated">从REST架构的角度来看,没有一个是重要的。我们也可以不使用PUT。但从客户开发者的角度来看,它让她的生活简单了很多。</target>
        </trans-unit>
        <trans-unit id="e554373d4e3272bcfc25cfb1cdb1bc748dad0740" translate="yes" xml:space="preserve">
          <source>HTTP does nothing to ensure reliable completion of the request-response, and that's just fine because this is properly the job of network-aware applications. Developing such an application, you can jump through hoops to use PUT instead of POST, then more hoops to give a certain kind of error on the server if you detect duplicate requests. Back at the client, you then have to jump through hoops to interpret these errors, refetch, revalidate and repost.</source>
          <target state="translated">HTTP没有做任何事情来确保请求-响应的可靠完成,这很好,因为这恰恰是网络感知应用的工作。在开发这样的应用时,你可以通过跳转圈来使用PUT而不是POST,然后如果检测到重复的请求,你可以通过更多的跳转圈在服务器上给出某种错误。然后在客户端,你必须通过跳转来解释这些错误,重新取值,重新验证和重新发布。</target>
        </trans-unit>
        <trans-unit id="b3fde5b13baf7e698d819867af72294baf96853b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Spec</source>
          <target state="translated">HTTP1.1规格</target>
        </trans-unit>
        <trans-unit id="5307592ab464b1dfe31ceb63373b1f53680a6aa6" translate="yes" xml:space="preserve">
          <source>Header &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">标头 &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a656b7b969733403da8fb5e2a09bcb24ed7b14b0" translate="yes" xml:space="preserve">
          <source>Hence, create or update based on existence of the &lt;strong&gt;resource&lt;/strong&gt;.</source>
          <target state="translated">因此，根据&lt;strong&gt;资源的&lt;/strong&gt;存在来创建或更新。</target>
        </trans-unit>
        <trans-unit id="a09685c9924e957d538b394fd639ee93fed0a583" translate="yes" xml:space="preserve">
          <source>Hence, creates a new &lt;strong&gt;resource&lt;/strong&gt; on a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">因此，在&lt;strong&gt;collection&lt;/strong&gt;上创建一个新&lt;strong&gt;资源&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceaa5b7fc07bf5371832748f3289a7b2da4d980c" translate="yes" xml:space="preserve">
          <source>Here's a simple rule:</source>
          <target state="translated">这里有一个简单的规则。</target>
        </trans-unit>
        <trans-unit id="8d27a8aff43735751da6f6d2d0ed6614a7eecf8a" translate="yes" xml:space="preserve">
          <source>I hope this helps any Microsoft developers that read all comments with Amazon and Sun/Java website links.</source>
          <target state="translated">我希望这能帮助到任何微软的开发者,看了所有评论中的亚马逊和SunJava网站的链接。</target>
        </trans-unit>
        <trans-unit id="5ca6bb95d20fb75f5f126fd38d614ae6b08d4b81" translate="yes" xml:space="preserve">
          <source>I interpret this, and the idempotency requirements on PUT, to mean that:</source>
          <target state="translated">我的理解是,这一点,以及PUT上的同工不同酬要求是指:</target>
        </trans-unit>
        <trans-unit id="05235e2370ecb21ce9215b0f74750a3737456a63" translate="yes" xml:space="preserve">
          <source>I like this advice, from &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616's definition of PUT&lt;/a&gt;:</source>
          <target state="translated">我喜欢这个建议，来自&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616的PUT定义&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="47aada42c69dd7c0210a4f1845e6ab606520fa95" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;PUT&lt;/code&gt; for Merge and update like operations and use &lt;code&gt;POST&lt;/code&gt; for Insertions.</source>
          <target state="translated">我使用 &lt;code&gt;PUT&lt;/code&gt; 进行合并和更新操作，并使用 &lt;code&gt;POST&lt;/code&gt; 进行插入。</target>
        </trans-unit>
        <trans-unit id="b527f56fb4de9ec139a67d896e81802d54cd82a0" translate="yes" xml:space="preserve">
          <source>I will describe the conventions which I think are most widely used and are most useful:</source>
          <target state="translated">我将介绍一下我认为使用最广泛和最有用的公约。</target>
        </trans-unit>
        <trans-unit id="f9c0500253b27e41a2e9e90178c365ce2423d509" translate="yes" xml:space="preserve">
          <source>I'd like to add my &quot;pragmatic&quot; advice.  Use PUT when you know the &quot;id&quot; by which the object you are saving can be retrieved.  Using PUT won't work too well if you need, say, a database generated id to be returned for you to do future lookups or updates.</source>
          <target state="translated">我想补充一下我的 &quot;实用主义 &quot;建议。当你知道你要保存的对象的 &quot;id &quot;可以被检索时,使用PUT。如果你需要返回一个数据库生成的id,以便你将来进行查找或更新,那么使用PUT就不太奏效。</target>
        </trans-unit>
        <trans-unit id="66649e065e34c99642108c78cb23fe86c7332572" translate="yes" xml:space="preserve">
          <source>I'm going to land with the following:</source>
          <target state="translated">我将以以下几个方面来登陆。</target>
        </trans-unit>
        <trans-unit id="dc85f0689c0d90da1345182eb8a915a8e4dd3c43" translate="yes" xml:space="preserve">
          <source>If the ID is generated (a new employee ID, for example), then the second PUT with the same URL would create a new record, which violates the idempotent rule. In this case the verb would be POST, and the message (not resource) would be to create a resource using the values defined in this message.</source>
          <target state="translated">如果ID被生成了(例如一个新的员工ID),那么第二个具有相同URL的PUT将创建一个新的记录,这违反了idempotent规则。在这种情况下,动词将是POST,而消息(不是资源)将是使用该消息中定义的值创建一个资源。</target>
        </trans-unit>
        <trans-unit id="e269e8bb2d1ae96b4945fea0fb22c28a23aa1d25" translate="yes" xml:space="preserve">
          <source>If the URL is not yet created, you
  should not be using POST to create it
  while specifying the name.  This should
  result in a 'resource not found' error
  because &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; does not exist
  yet.  You should PUT the &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt;
  resource on the server first.</source>
          <target state="translated">如果尚未创建URL，则在指定名称时不应使用POST来创建URL。 这将导致&amp;ldquo;找不到资源&amp;rdquo;错误，因为 &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; 还不存在。 您应该先在服务器上放置 &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; 资源。</target>
        </trans-unit>
        <trans-unit id="19c462827f591bd8bec6f3f537b7b39215387f40" translate="yes" xml:space="preserve">
          <source>If the result of processing a POST would be equivalent to a
  representation of an existing resource, an origin server MAY redirect
  the user agent to that resource by sending a 303 (See Other) response
  with the existing resource's identifier in the Location field.  This
  has the benefits of providing the user agent a resource identifier
  and transferring the representation via a method more amenable to
  shared caching, though at the cost of an extra request if the user
  agent does not already have the representation cached.</source>
          <target state="translated">如果处理一个POST的结果相当于一个现有资源的表示,那么源服务器可以通过在位置字段中发送一个带着现有资源标识符的303(见其他)响应,将用户代理重定向到该资源。这样做的好处是为用户代理提供了一个资源标识符,并通过一种更适合于共享缓存的方法传输表示,不过如果用户代理还没有缓存表示,则需要付出额外的请求代价。</target>
        </trans-unit>
        <trans-unit id="558a879fdfc95da4b234bea22b5e49ef57224b98" translate="yes" xml:space="preserve">
          <source>If you are familiar with database operations,
there are</source>
          <target state="translated">如果你对数据库操作比较熟悉,有</target>
        </trans-unit>
        <trans-unit id="1d065776051b8ea3a055903bde387f8a311a6be4" translate="yes" xml:space="preserve">
          <source>If you go on and try something like this:</source>
          <target state="translated">如果你再去尝试一下这样的事情。</target>
        </trans-unit>
        <trans-unit id="0c6f7e90f3ea30966fd463c77a5a98203c024433" translate="yes" xml:space="preserve">
          <source>If you happen to have auto generated  URI's on your resource you can still use PUT by passing a generated URI (pointing to an empty resource) to the client.</source>
          <target state="translated">如果你的资源上有自动生成的URI,你仍然可以通过传递一个生成的URI(指向空的资源)给客户端来使用PUT。</target>
        </trans-unit>
        <trans-unit id="cd5ae750e099166d34c0aea0fb9b4fadd772975a" translate="yes" xml:space="preserve">
          <source>If you have any doubts about how to implement REST in HTTP, you can always take a look at the &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom Publication Protocol (AtomPub)&lt;/a&gt; specification. AtomPub is a standard for writing RESTful webservices with HTTP that was developed by many HTTP and REST luminaries, with some input from Roy Fielding, the inventor of REST and (co-)inventor of HTTP himself.</source>
          <target state="translated">如果您对如何在HTTP中实现REST存有疑问，可以随时查看&lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom发布协议（AtomPub）&lt;/a&gt;规范。 AtomPub是使用HTTP编写RESTful Web服务的标准，该标准是由许多HTTP和REST专家开发的，并且是REST的发明者和HTTP的（共同）发明者Roy Fielding的一些投入。</target>
        </trans-unit>
        <trans-unit id="ec654f9d869b9d4e7e967af9a0e460df87b82e2e" translate="yes" xml:space="preserve">
          <source>If you think you'll have huge amounts of data to store, let's talk volumes: a typical update confirmation is a fraction of a kilobyte. HTTP currently gives you a minute or two to respond definitively. Even if you only store actions for a week, clients have ample chance to catch up. If you have very high volumes, you may want a dedicated acid-compliant key value store, or an in-memory solution.</source>
          <target state="translated">如果你认为你会有海量的数据存储,那么我们来谈谈量:一个典型的更新确认是几千字节的几分之一。HTTP目前给你一两分钟的时间来确定响应。即使你只存储了一周的动作,客户有足够的机会赶上。如果你有非常高的话务量,你可能需要一个专门的符合酸的键值存储,或者是内存中的解决方案。</target>
        </trans-unit>
        <trans-unit id="5e3f77bd7d922a0787f75fec577234f6dce48c77" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;POST&lt;/strong&gt; method you can send body params in &lt;code&gt;form-data&lt;/code&gt;</source>
          <target state="translated">在&lt;strong&gt;POST&lt;/strong&gt;方法中，您可以在 &lt;code&gt;form-data&lt;/code&gt; 发送正文参数</target>
        </trans-unit>
        <trans-unit id="ae084cc36a47a0ae5ba94fddaf0353c8961a476b" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PUT&lt;/strong&gt; method you have to send body params in &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">在&lt;strong&gt;PUT&lt;/strong&gt;方法中，您必须以 &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; 发送身体参数</target>
        </trans-unit>
        <trans-unit id="9431cceefc51a270cdbc8ad21cfd20758abb6247" translate="yes" xml:space="preserve">
          <source>In REST, there's no such thing as a resource containing &quot;content&quot;. I refer as &quot;content&quot; to data that the service uses to render representations consistently. It typically consists of some related rows in a database or a file (e.g. an image file). It's up to the service to convert the user's content into something the service can use, e.g. converting a JSON payload into SQL statements.</source>
          <target state="translated">在REST中,没有包含 &quot;内容 &quot;的资源这样的东西。我所说的 &quot;内容 &quot;是指服务用来一致呈现表示的数据。它通常由数据库或文件(如图像文件)中的一些相关行组成。将用户的内容转换为服务可以使用的东西,例如将JSON有效载荷转换为SQL语句等,这取决于服务。</target>
        </trans-unit>
        <trans-unit id="258ba4ae5c03cdfdac38fed39baa86957f31d85a" translate="yes" xml:space="preserve">
          <source>In a single line, use &lt;strong&gt;POST&lt;/strong&gt; to add &lt;strong&gt;a new entry&lt;/strong&gt; in the database and &lt;strong&gt;PUT&lt;/strong&gt; to &lt;strong&gt;update&lt;/strong&gt; something in the database.</source>
          <target state="translated">在一行中，使用&lt;strong&gt;POST&lt;/strong&gt;在数据库中添加&lt;strong&gt;新条目&lt;/strong&gt; ，并使用&lt;strong&gt;PUT&lt;/strong&gt;在数据库中&lt;strong&gt;更新&lt;/strong&gt;某些内容。</target>
        </trans-unit>
        <trans-unit id="935d9d64a7b6c614a61126ee51efa95f2a005750" translate="yes" xml:space="preserve">
          <source>In a very simple way I'm taking the example of the Facebook timeline.</source>
          <target state="translated">用一个很简单的方法,我以Facebook的时间线为例。</target>
        </trans-unit>
        <trans-unit id="5796889f185413ae8caeb602438951b389d9b045" translate="yes" xml:space="preserve">
          <source>In addition to differences suggested by others, I want to add one more.</source>
          <target state="translated">除了别人建议的差异之外,我还想再补充一个。</target>
        </trans-unit>
        <trans-unit id="d0a40d3ab4c006f0fd0242d76461457c6d244bfe" translate="yes" xml:space="preserve">
          <source>In both cases, the request body contains the data for the resource to be created or updated. It should be obvious from the route names that POST is not idempotent (if you call it 3 times it will create 3 objects), but PUT is idempotent (if you call it 3 times the result is the same). PUT is often used for &quot;upsert&quot; operation (create or update), but you can always return a 404 error if you only want to use it to modify.</source>
          <target state="translated">在这两种情况下,请求体包含了要创建或更新资源的数据。从路由名称中应该可以明显看出,POST不是idempototent(如果你调用3次就会创建3个对象),但PUT是idempotent(如果你调用3次,结果是一样的)。PUT经常被用于 &quot;supert &quot;操作(创建或更新),但如果你只想用它来修改,总是会返回404错误。</target>
        </trans-unit>
        <trans-unit id="573cffeb2d758c1d002d1b38d8d410abd12cf26c" translate="yes" xml:space="preserve">
          <source>In both cases, these operations can be performed multiple times with the same results. That is the resource will not be changed by requesting the operation more than once. Hence, a true idempotent operation.
Use the HTTP POST method when:</source>
          <target state="translated">在这两种情况下,这些操作可以多次执行,结果相同。也就是说,不会因为多次请求操作而改变资源。因此,是真正的idempotent操作。使用HTTP POST方法的时候。</target>
        </trans-unit>
        <trans-unit id="cbfc88d28449849d5a03796a1b27b42013a1a384" translate="yes" xml:space="preserve">
          <source>In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an &quot;INSERT&quot; query.</source>
          <target state="translated">在POST的情况下,如果同一个查询被多次执行,那么数据库中的多个学生记录会被创建,每次执行INSERT查询时,数据库的状态都会发生变化。</target>
        </trans-unit>
        <trans-unit id="315a82166f32c0e6bdbe44329b3f92d7b32440b4" translate="yes" xml:space="preserve">
          <source>In fact, you might even be able to use AtomPub directly. While it came out of the blogging community, it is in no way restricted to blogging: it is a generic protocol for RESTfully interacting with arbitrary (nested) collections of arbitrary resources via HTTP. If you can represent your application as a nested collection of resources, then you can just use AtomPub and not worry about whether to use PUT or POST, what HTTP Status Codes to return and all those details.</source>
          <target state="translated">事实上,你甚至可以直接使用AtomPub。虽然它来自于博客社区,但它绝不仅限于博客:它是一个通用协议,通过HTTP与任意资源的任意(嵌套)集合进行REST交互。如果你可以将你的应用程序表示为一个嵌套的资源集合,那么你就可以直接使用AtomPub,而不用担心是使用PUT还是POST,返回什么HTTP状态码以及所有这些细节。</target>
        </trans-unit>
        <trans-unit id="4b6a091fc94c88da148a77392e516193f6f66982" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;POST&lt;/code&gt; is used to &lt;strong&gt;create&lt;/strong&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;POST&lt;/code&gt; 用于&lt;strong&gt;创建&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcfbe76fe288131ae25a4df6a695eb5ab43c9f7d" translate="yes" xml:space="preserve">
          <source>In practice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; that summarizes the best practices.</source>
          <target state="translated">在实践中，POST非常适合创建资源。 新创建资源的URL应该在Location响应头中返回。 PUT应该用于完全更新资源。 请理解，这些是设计RESTful API时的最佳实践。 这样的HTTP规范并不限制使用PUT / POST，而在创建/更新资源方面有一些限制。 请参阅&lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; ，其中总结了最佳做法。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">简而言之。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="f8f5b658f1ff8b04b3e81cc7e7976e9561692c82" translate="yes" xml:space="preserve">
          <source>It is true that the R(etrieve) and D(elete) of the CRUD operations can be mapped directly to the HTTP methods GET and DELETE respectively. However, the confusion lies in the C(reate) and U(update) operations. In some cases, one can use the PUT for a create while in other cases a POST will be required. The ambiguity lies in the definition of an HTTP PUT method versus an HTTP POST method.</source>
          <target state="translated">诚然,CRUD操作中的R(etrieve)和D(elete)分别可以直接映射到HTTP方法GET和DELETE上。但是,混淆的地方在于C(reate)和U(update)操作。在某些情况下,可以使用PUT来进行create,而在其他情况下,则需要使用POST。模糊的地方在于HTTP PUT方法和HTTP POST方法的定义。</target>
        </trans-unit>
        <trans-unit id="a419fc1de6f5fcd3ae809038b7b9a687efa1b1dd" translate="yes" xml:space="preserve">
          <source>It now may be tempting to simply return a 303 in the event that a POST is repeated. However, the opposite is true. Returning a 303 would only make sense if multiple create requests (creating different resources) return the same content. An example would be a &quot;thank you for submitting your request message&quot; that the client need not re-download each time. RFC 7231 still maintains in section 4.2.2 that POST is not to be idempotent and continues to maintain that POST should be used for create.</source>
          <target state="translated">现在,如果重复POST的情况下,可能会简单地返回一个303。然而,事实恰恰恰恰相反。只有当多个创建请求(创建不同的资源)返回相同的内容时,返回303才有意义。一个例子是 &quot;感谢你提交了请求消息&quot;,客户端不需要每次都重新下载。RFC 7231 在 4.2.2.2 节中仍然坚持认为 POST 不应该是 idempotent,并继续坚持 POST 应该用于 create。</target>
        </trans-unit>
        <trans-unit id="82a86d7eed2a55a644d7944a1404883b9ed82ac6" translate="yes" xml:space="preserve">
          <source>Let me highlight some important parts of the spec:</source>
          <target state="translated">让我强调一下规格中的一些重要部分。</target>
        </trans-unit>
        <trans-unit id="27175fcbf0cac61488369580d1a39f1dc721a45f" translate="yes" xml:space="preserve">
          <source>Let's be very clear and direct here. If you are a .NET developer working with Web API, the facts are (from the Microsoft API documentation),
&lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&lt;/a&gt;:</source>
          <target state="translated">让我们在这里非常清楚和直接。 如果您是使用Web API的.NET开发人员，则事实是（来自Microsoft API文档） &lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web -api-that-supports-crud-operations&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="857a3f4adc539ed4bbe21171ae40606e572a4ee6" translate="yes" xml:space="preserve">
          <source>Merge (Update if already existing, else insert)</source>
          <target state="translated">合并(如果已经存在,则更新,否则插入)</target>
        </trans-unit>
        <trans-unit id="d6917a3435aea050d9a0d15a35f97af6e01858e4" translate="yes" xml:space="preserve">
          <source>Most of the time, you will use them like this:</source>
          <target state="translated">大多数时候,你会这样使用它们。</target>
        </trans-unit>
        <trans-unit id="d61559b89b4cc3627f671076f6d46721d16134fc" translate="yes" xml:space="preserve">
          <source>Neither is quite right.</source>
          <target state="translated">都不太对。</target>
        </trans-unit>
        <trans-unit id="29c91aceaf4eab28f2f98e779bebb50691497adc" translate="yes" xml:space="preserve">
          <source>Note that POST &quot;creates&quot; a new element in the collection, and PUT &quot;replaces&quot; an element at a given URL, but it is a very common practice to use PUT for partial modifications, that is, use it only to update existing resources and only modify the included fields in the body (ignoring the other fields). This is technically incorrect, if you want to be REST-purist, PUT should replace the whole resource and you should use PATCH for the partial update. I personally don't care much as far as the behavior is clear and consistent across all your API endpoints.</source>
          <target state="translated">注意,POST在集合中 &quot;创建 &quot;一个新的元素,而PUT在给定的URL中 &quot;替换 &quot;一个元素,但是,使用PUT进行部分修改是非常常见的做法,也就是说,只用PUT来更新现有的资源,只修改正文中包含的字段(忽略其他字段)。这在技术上是不正确的,如果你想做REST-purist,PUT应该代替整个资源,而你应该使用PATCH来进行部分更新。我个人并不太在意,只要在你所有的API端点上的行为是明确的、一致的。</target>
        </trans-unit>
        <trans-unit id="aed489a86f6999b5a22f73530a241b671e75935e" translate="yes" xml:space="preserve">
          <source>Note that in this case the resource
  name is not specified, the new objects
  URL path would be returned to you.</source>
          <target state="translated">注意,在这种情况下,没有指定资源名称,新对象的URL路径将返回给你。</target>
        </trans-unit>
        <trans-unit id="d0190e7f10880e789af039b6a119817ade48d5dc" translate="yes" xml:space="preserve">
          <source>Note that the following is an error:</source>
          <target state="translated">注意,以下是一个错误。</target>
        </trans-unit>
        <trans-unit id="94ed497609bfa8317d3c8fed64915d395cd4506d" translate="yes" xml:space="preserve">
          <source>Note, however, that not all modern browsers support HTTP verbs other than GET or POST.</source>
          <target state="translated">但是,请注意,不是所有的现代浏览器都支持GET或POST以外的HTTP动词。</target>
        </trans-unit>
        <trans-unit id="3e324155fc5920c681ee3f3fe84a2ed08ebec851" translate="yes" xml:space="preserve">
          <source>Once you are using PUT you are refering to a &lt;strong&gt;resource&lt;/strong&gt; or single item, possibly inside a &lt;strong&gt;collection&lt;/strong&gt;. So when you say:</source>
          <target state="translated">使用PUT后，您将引用&lt;strong&gt;资源&lt;/strong&gt;或单个项目，可能在&lt;strong&gt;collection中&lt;/strong&gt; 。 所以当你说：</target>
        </trans-unit>
        <trans-unit id="c5516139d4acd3169adf148d2df83962379be2e8" translate="yes" xml:space="preserve">
          <source>Otherwise, use POST to initially create the object, and PUT to update the object:</source>
          <target state="translated">否则,用POST来初始创建对象,用PUT来更新对象。</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="4413fe84411cbdf88cfc031d8a1393f608c4e15e" translate="yes" xml:space="preserve">
          <source>POST as send mail in &lt;strong&gt;post&lt;/strong&gt; office.</source>
          <target state="translated">在&lt;strong&gt;邮局中&lt;/strong&gt;以发送邮件的形式&lt;strong&gt;发布&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e2c64ac62aa82754ed88cbebd18c452a61f35fc" translate="yes" xml:space="preserve">
          <source>POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing -- if you think about it, creating a new member of a collection is actually a special case of this kind of update, from the collection's perspective)</source>
          <target state="translated">POST也可以用于对现有对象的非空性更新(尤其是改变对象的一部分而不指定整个对象---如果你仔细想想,从集合的角度来看,创建一个新成员实际上就是这种更新的特殊情况</target>
        </trans-unit>
        <trans-unit id="7199a1f38c458034e4e9122d80a96f6d399a16c7" translate="yes" xml:space="preserve">
          <source>POST can perform the other three functions, but then the semantics of the request will be lost on the intermediaries such as caches and proxies. This also applies to providing security on the resource, since a post's URI doesn't necessarily indicate the resource it is applying to (it can though).</source>
          <target state="translated">POST可以执行其他三个功能,但这样一来,请求的语义就会在中间商(如缓存和代理)上失去了。这也适用于在资源上提供安全性,因为POST的URI不一定表明它所应用的资源(虽然可以)。</target>
        </trans-unit>
        <trans-unit id="a3841df602dc207eb894628e42ca39fa38600ef6" translate="yes" xml:space="preserve">
          <source>POST invalidates cached copies of the entire containing resource (better consistency)</source>
          <target state="translated">POST会使整个包含资源的缓存副本失效(一致性更好)。</target>
        </trans-unit>
        <trans-unit id="c22f736aab2b2863938a628162d88b4124790887" translate="yes" xml:space="preserve">
          <source>POST is basically a free form message, with its meaning being defined 'out of band'. If the message can be interpreted as adding a resource to a directory, that would be OK, but basically you need to understand the message you are sending (posting) to know what will happen with the resource.</source>
          <target state="translated">POST基本上是一个自由形式的消息,它的含义被定义为 &quot;带外&quot;。如果这个消息可以理解为向目录中添加一个资源,那就没问题,但基本上你需要了解你要发送的消息(POST),才能知道这个资源会发生什么。</target>
        </trans-unit>
        <trans-unit id="50e5624274970285a79a86def7e5f8ea14309ec5" translate="yes" xml:space="preserve">
          <source>POST is good for creating new objects under a collection (and create does not need to be idempotent)</source>
          <target state="translated">POST适合于在集合下创建新对象(而且create不需要idempotent)。</target>
        </trans-unit>
        <trans-unit id="a4348a436cd7cc96fdb0094e0c165b3beab9d039" translate="yes" xml:space="preserve">
          <source>POST is like posting a letter to a mailbox or posting an email to an email queue.
PUT is like when you put an object in a cubby hole or a place on a shelf (it has a known address).</source>
          <target state="translated">POST就像把一封信发到邮箱里,或者把一封邮件发到邮件队列中。PUT就像你把一个物体放在一个隔间洞或架子上的一个地方(它有一个已知的地址)。</target>
        </trans-unit>
        <trans-unit id="4db2a3f164214c5ab6b6162614daef8028ccda38" translate="yes" xml:space="preserve">
          <source>POST is not idempotent and the server &amp;hellip;</source>
          <target state="translated">POST不是幂等的，服务器&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="6bf075a0e5bf009d906f75d40d6c584b360d7cb7" translate="yes" xml:space="preserve">
          <source>POST is used to send data to server.</source>
          <target state="translated">POST是用来向服务器发送数据的。</target>
        </trans-unit>
        <trans-unit id="f6c4170f0e615f9fa2848d48db2ab50f375369c3" translate="yes" xml:space="preserve">
          <source>POST:</source>
          <target state="translated">POST:</target>
        </trans-unit>
        <trans-unit id="d18f4e998d15f0ab1bd153b920ca0c74bdfeff78" translate="yes" xml:space="preserve">
          <source>POSTing twice with the same data means create two identical users with different ids. PUTing twice with the same data creates the user the first and updates him to the same state the second time (no changes). Since you end up with the same state after a &lt;code&gt;PUT&lt;/code&gt; no matter how many times you perform it, it is said to be &quot;equally potent&quot; every time - idempotent. This is useful for automatically retrying requests. No more 'are you sure you want to resend' when you push the back button on the browser.</source>
          <target state="translated">使用相同数据两次发布意味着创建两个具有不同ID的相同用户。 使用相同的数据两次输入将首先创建用户，第二次将其更新为相同状态（无更改）。 由于无论执行多少次，您在 &lt;code&gt;PUT&lt;/code&gt; 之后都会处于相同的状态，因此每次都被称为&amp;ldquo;同等有效&amp;rdquo;-幂等。 这对于自动重试请求很有用。 按下浏览器上的&amp;ldquo;后退&amp;rdquo;按钮时，不再&amp;ldquo;确定要重新发送&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="0774c3d8f11a1777d7cca86a15dfce5e923b8427" translate="yes" xml:space="preserve">
          <source>PUT can also be used for create if and only if you allow the client to name the resource. But since REST clients aren't supposed to make assumptions about URL structure, this is less in the intended spirit of things.</source>
          <target state="translated">PUT也可以用于创建,如果并且只有当你允许客户端给资源起名字时,PUT才可以用于创建。但由于REST客户端不应该对URL结构做假设,所以这不太符合事物的本意。</target>
        </trans-unit>
        <trans-unit id="53edc2f185fb0dcf741606243cd7f49687d0ba85" translate="yes" xml:space="preserve">
          <source>PUT i.e. take and &lt;strong&gt;put&lt;/strong&gt; where it was.</source>
          <target state="translated">&lt;strong&gt;放置&lt;/strong&gt; ，即&lt;strong&gt;放在原&lt;/strong&gt;处。</target>
        </trans-unit>
        <trans-unit id="d17262b9924f1628e9bc6d1ceface83dc9e20080" translate="yes" xml:space="preserve">
          <source>PUT is good for updating existing objects (and update needs to be idempotent)</source>
          <target state="translated">PUT适合于更新现有对象(而且更新需要idempotent)。</target>
        </trans-unit>
        <trans-unit id="2528780fd61687817cc4d77380ca20d9c55d5327" translate="yes" xml:space="preserve">
          <source>PUT is idempotent, so if you PUT an object twice, it has no effect.  This is a nice property, so I would use PUT when possible.</source>
          <target state="translated">PUT是idempotent的,所以如果你把一个对象PUT两次,它就没有任何效果。这是一个不错的属性,所以在可能的情况下,我还是会使用PUT。</target>
        </trans-unit>
        <trans-unit id="f54bdf6757feb089a4b6dd6043ed5a3812f4c969" translate="yes" xml:space="preserve">
          <source>PUT is idempotent. You can send the request 100 times and it will not matter. POST is not idempotent. If you send the request 100 times, you'll get 100 emails or 100 letters in your postal box.</source>
          <target state="translated">PUT是无能的。你可以将请求发送100次,这并不重要。POST不是无能的。如果你发送了100次请求,你会收到100封邮件或100封信在你的邮政信箱里。</target>
        </trans-unit>
        <trans-unit id="7a94e837da966e20c0283efdebc7e6e8c4792dd1" translate="yes" xml:space="preserve">
          <source>PUT is less supported by e.g. Java ME, older browsers, firewalls</source>
          <target state="translated">如Java ME、老式浏览器、防火墙等,对PUT的支持较少。</target>
        </trans-unit>
        <trans-unit id="beb21b8c66904ea993c9a6028ecf712630358d0d" translate="yes" xml:space="preserve">
          <source>PUT is merely a statement of what content the service should, from now on, use to render representations of the resource identified by the client; POST is a statement of what content the service should, from now on, contain (possibly duplicated) but it's up to the server how to identify that content.</source>
          <target state="translated">PUT仅仅是一个声明,说明服务从现在开始应该用什么内容来呈现被客户机识别的资源的表示;POST是一个声明,说明服务从现在开始应该包含什么内容(可能是重复的),但如何识别这些内容取决于服务器。</target>
        </trans-unit>
        <trans-unit id="481e4b9e200d5c2fea82c751622373a2b6a00819" translate="yes" xml:space="preserve">
          <source>PUT is used to transfer state to the server</source>
          <target state="translated">PUT用于向服务器传输状态。</target>
        </trans-unit>
        <trans-unit id="bad5201391f46977a9f8deb44fc372a5bc244a21" translate="yes" xml:space="preserve">
          <source>PUT refers to a resource, identified by the URI. In this case, you are updating it. It is the part of the three verbs referring to resources -- delete and get being the other two.</source>
          <target state="translated">PUT指的是一个资源,由URI标识。在这种情况下,你是在更新它。它是三个动词中提到资源的部分 ----delete和get是另外两个。</target>
        </trans-unit>
        <trans-unit id="d444f457d29e103ad92323fcf2afb2424bd83004" translate="yes" xml:space="preserve">
          <source>PUT responses are not cacheable while POST ones are (Require Content-Location and expiration)</source>
          <target state="translated">PUT响应是不可缓存的,而POST响应是不可缓存的(需要内容位置和到期日)。</target>
        </trans-unit>
        <trans-unit id="15640c28b6c6596379e40a0e541c4b7183207d73" translate="yes" xml:space="preserve">
          <source>PUT vs. POST in REST</source>
          <target state="translated">REST中的PUT与POST</target>
        </trans-unit>
        <trans-unit id="ecd7c4f13506fe5521c5fe5e1b3db337ba4711ed" translate="yes" xml:space="preserve">
          <source>PUT:</source>
          <target state="translated">PUT:</target>
        </trans-unit>
        <trans-unit id="ecbeb70dff39883fdc79bab75f4eab0476369bf3" translate="yes" xml:space="preserve">
          <source>Performing a POST of data which has an ID which matches a resource already in the system is &amp;ldquo;a conflict with the current state of the resource.&amp;rdquo;</source>
          <target state="translated">对具有与系统中已有资源匹配的ID的数据执行POST是&amp;ldquo;与资源的当前状态冲突&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="55c27430d43b1ad1ac779b51ba33aaaa16817d5a" translate="yes" xml:space="preserve">
          <source>Prior to PUT, clients couldn't directly know the URL that the server generated or if all it had generated any or whether the data to be sent to the server is already updated or not. PUT relieved the developer of all these headaches. PUT is idempotent, PUT handles race conditions, and PUT lets the client choose the URL.</source>
          <target state="translated">在PUT之前,客户端无法直接知道服务器产生的URL,或者说它是否都产生了什么,或者说要发送给服务器的数据是否已经更新了。PUT为开发者解除了所有这些头疼的问题。PUT是idempotent的,PUT处理竞赛条件,PUT让客户端选择URL。</target>
        </trans-unit>
        <trans-unit id="500abc23a1f880a1d70f33cc1a5912ba903fcf59" translate="yes" xml:space="preserve">
          <source>REST is a &lt;em&gt;very&lt;/em&gt; high-level concept. In fact, it doesn't even mention HTTP at all!</source>
          <target state="translated">REST是一个&lt;em&gt;非常&lt;/em&gt;高级的概念。 实际上，它甚至根本没有提到HTTP！</target>
        </trans-unit>
        <trans-unit id="f3f878fdda60ba178358813e7e7547df7ca8bed3" translate="yes" xml:space="preserve">
          <source>RFC 5789 says about PATCH (since 1995):</source>
          <target state="translated">RFC 5789说的是PATCH(1995年以来)。</target>
        </trans-unit>
        <trans-unit id="2240960be744587b090255e994fafdd819cc51d2" translate="yes" xml:space="preserve">
          <source>Readers new to this topic will be struck by the endless discussion about what you &lt;em&gt;should&lt;/em&gt; do, and the relative absence of lessons from experience. The fact that REST is &quot;preferred&quot; over SOAP is, I suppose, a high-level learning from experience, but goodness we must have progressed from there? It's 2016. Roy's dissertation was in 2000. What have we developed? Was it fun? Was it easy to integrate with? To support? Will it handle the rise of smartphones and flaky mobile connections?</source>
          <target state="translated">对该主题不熟悉的读者将不知疲倦地讨论您&lt;em&gt;应&lt;/em&gt;该做什么，并且相对缺乏经验教训。 我想，REST是比SOAP更为&amp;ldquo;优选&amp;rdquo;的事实，这是对经验的高级学习，但是，天哪，我们一定已经取得了进步吗？ 是2016年。罗伊（Roy）的论文是2000年。我们开发了什么？ 它有趣吗？ 整合起来容易吗？ 支持？ 它能应付智能手机和不稳定的移动连接的兴起吗？</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="af48dc320f6330ed03797587a11eef43f0ec6f79" translate="yes" xml:space="preserve">
          <source>Remember, REST is a set of conventions and guidelines to keep your API simple. If you end up with a complicated work-around just to check the &quot;RESTfull&quot; box then you are defeating the purpose ;)</source>
          <target state="translated">请记住,REST是一套约定俗成的准则,让你的API简单化。如果你最终只是为了勾选 &quot;RESTfull &quot;框,就用了一个复杂的变通方法,那么你就违背了目的;)</target>
        </trans-unit>
        <trans-unit id="ee7cc50d6752f70e6ef133296cf031acbf88d94d" translate="yes" xml:space="preserve">
          <source>Ruby on Rails 4.0 will use the 'PATCH' method instead of PUT to do partial updates.</source>
          <target state="translated">Ruby on Rails 4.0将使用'PATCH'方法代替PUT来进行部分更新。</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="e1a55a92c976da44c042e91aaa4d8b45fd7ebc14" translate="yes" xml:space="preserve">
          <source>Simple rule of thumb: Use POST to create, use PUT to update.</source>
          <target state="translated">简单的经验法则。使用POST来创建,使用PUT来更新。</target>
        </trans-unit>
        <trans-unit id="563433492d9997914d4d5639b5bd77063df84eaa" translate="yes" xml:space="preserve">
          <source>Since the important part is for the client to understand the server has the resource and to take appropriate action. This is a &amp;ldquo;situation(s) where it is expected that the user might be able to resolve the conflict and resubmit the request.&amp;rdquo;</source>
          <target state="translated">由于重要的部分是让客户端了解服务器拥有的资源并采取适当的措施。 这是一个&amp;ldquo;期望用户可以解决冲突并重新提交请求的情况&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="214742f8ecec0788b74789ec5780c31fcabbb394" translate="yes" xml:space="preserve">
          <source>So you use POST and probably, but not necessary PUT for resource creation. You don't have to support both. For me POST is perfectly enough. So it is a design decision.</source>
          <target state="translated">所以你用POST和可能,但不一定要用PUT来创建资源。你不一定要支持这两种方式。对我来说,POST已经完全够用了。所以这是一个设计上的决定。</target>
        </trans-unit>
        <trans-unit id="312dad788b38db2f97ab20722cebe3f87855dfa4" translate="yes" xml:space="preserve">
          <source>So, which one should be used to create a resource? Or one needs to support both?</source>
          <target state="translated">那么,应该用哪一个来打造资源呢?还是一个需要同时支持两个?</target>
        </trans-unit>
        <trans-unit id="af333de22f5db2954bfe57966628566c2cb3ee43" translate="yes" xml:space="preserve">
          <source>So: To save an existing user, or one where the client generates the id and it's been verified that the id is unique:</source>
          <target state="translated">所以。要保存一个现有的用户,或者是客户端生成的id,并且已经验证过id是唯一的。</target>
        </trans-unit>
        <trans-unit id="a8710dbdab40fac5c2f6093ab0a397321add575c" translate="yes" xml:space="preserve">
          <source>Social Media/Network Analogy:</source>
          <target state="translated">社交媒体网络比喻。</target>
        </trans-unit>
        <trans-unit id="aa6e7d148420cbd536359dd8922d3a773a333631" translate="yes" xml:space="preserve">
          <source>Some considerations:</source>
          <target state="translated">一些考虑:</target>
        </trans-unit>
        <trans-unit id="f07350c10b92f7bbca1cebbb0c1aaadbf6301a75" translate="yes" xml:space="preserve">
          <source>Some other considerations:</source>
          <target state="translated">其他一些注意事项:</target>
        </trans-unit>
        <trans-unit id="1392b1cbf3bb0fbae1580de51f28c0eb49cc1f97" translate="yes" xml:space="preserve">
          <source>Spec:</source>
          <target state="translated">Spec:</target>
        </trans-unit>
        <trans-unit id="9d63a661c96623ad056cc93701a94dbcd5290eef" translate="yes" xml:space="preserve">
          <source>Step 6 is where people commonly get confused about what to do. However, there is no reason to create a kludge to solve this issue. Instead, HTTP can be used as specified in &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616&lt;/a&gt; and the server replies:</source>
          <target state="translated">步骤6是人们通常对要做的事情感到困惑的地方。 但是，没有理由创建一个解决方案来解决此问题。 相反，可以按照&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616中的&lt;/a&gt;指定使用HTTP，并且服务器会回复：</target>
        </trans-unit>
        <trans-unit id="b49764080a9692f4a67935d54ce3bb45209b490c" translate="yes" xml:space="preserve">
          <source>Student Id is auto generated.</source>
          <target state="translated">学生ID是自动生成的。</target>
        </trans-unit>
        <trans-unit id="aca4c099b5e77d0411d947634e38f0631bf9e86a" translate="yes" xml:space="preserve">
          <source>Successive delete requests can see and process the original confirmation, without hitting a 404 error. If things take longer than expected, we can respond provisionally, and we have a place where the client can check back for the definitive result. The nicest part of this pattern is its Kung-Fu (Panda) property. We take a weakness, the propensity for clients to repeat a request any time they don't understand the response, and turn it into &lt;em&gt;a strength&lt;/em&gt; :-)</source>
          <target state="translated">连续的删除请求可以查看并处理原始确认，而不会遇到404错误。 如果事情花的时间比预期的长，我们可以临时做出回应，我们可以为客户提供确定的结果。 这种模式最好的部分是其功夫（熊猫）属性。 我们有一个弱点，即客户倾向于在他们不了解响应的任何时候重复请求，然后将其转变&lt;em&gt;为优势&lt;/em&gt; ：-)</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="b9802a34f75ab08b9f79a147b7c88bf20e2dd462" translate="yes" xml:space="preserve">
          <source>Sure you &quot;can&quot; use &quot;POST&quot; to update, but just follow the conventions laid out for you with your given framework. In my case it is .NET / Web API, so &lt;strong&gt;PUT is for UPDATE&lt;/strong&gt; there is no debate.</source>
          <target state="translated">当然，您可以&amp;ldquo;使用&amp;rdquo; POST进行更新，但是只要遵循给定框架为您制定的约定即可。 就我而言，它是.NET / Web API，因此&lt;strong&gt;PUT用于UPDATE&lt;/strong&gt;无需争论。</target>
        </trans-unit>
        <trans-unit id="88f36ec6e839653d0f7569117f42e1085634abaa" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;PUT&lt;/code&gt; is used to &lt;strong&gt;create or update&lt;/strong&gt;.</source>
          <target state="translated">也就是说， &lt;code&gt;PUT&lt;/code&gt; 用于&lt;strong&gt;创建或更新&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6228527a9fe538603ee8860a20980509cae0390f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/strong&gt; method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the &lt;code&gt;Request-URI&lt;/code&gt; in the &lt;code&gt;Request-Line&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/strong&gt;方法用于请求源服务器接受请求中包含的实体作为 &lt;code&gt;Request-Line&lt;/code&gt; &lt;code&gt;Request-URI&lt;/code&gt; 标识的资源的新下属</target>
        </trans-unit>
        <trans-unit id="fbf25e1a44ff44b0b030b51303b10b2f4e6c0844" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/strong&gt; method requests that the enclosed entity be stored under the supplied &lt;code&gt;Request-URI&lt;/code&gt;. If the &lt;code&gt;Request-URI&lt;/code&gt; refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the &lt;code&gt;Request-URI&lt;/code&gt; does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/strong&gt;方法请求将包含的实体存储在提供的 &lt;code&gt;Request-URI&lt;/code&gt; 下 。 如果 &lt;code&gt;Request-URI&lt;/code&gt; 引用了已经存在的资源，则应将封闭的实体视为驻留在原始服务器上的实体的修改版本。 如果 &lt;code&gt;Request-URI&lt;/code&gt; 没有指向现有资源，并且请求用户代理能够将该URI定义为新资源，则原始服务器可以使用该URI创建资源。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="59c1ac24b7aebd8b407e3f0c9ff99488ea7968e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;POST&lt;/strong&gt; method is used to request that the origin server &lt;strong&gt;accept&lt;/strong&gt; the entity enclosed in the request as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; subordinate&lt;/strong&gt; of the resource identified by the Request-URI in the Request-Line</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;方法用于请求源服务器&lt;strong&gt;接受&lt;/strong&gt;请求中包含的实体作为请求行中Request-URI标识的资源的&lt;strong&gt;&lt;em&gt;新&lt;/em&gt;下属&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c563bf37c1b157d8576106b8f94786d60d4a88a8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;PUT&lt;/strong&gt; method requests that the enclosed entity be &lt;strong&gt;stored&lt;/strong&gt; under the supplied Request-URI. If the Request-URI refers to an &lt;strong&gt;already existing&lt;/strong&gt; resource, the enclosed entity SHOULD be considered as a &lt;strong&gt;modified version&lt;/strong&gt; of the one residing on the origin server. If the Request-URI does &lt;strong&gt;not point to an existing&lt;/strong&gt; resource, and that URI is &lt;strong&gt;capable&lt;/strong&gt; of being defined as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; resource&lt;/strong&gt; by the requesting user agent, the origin server can &lt;strong&gt;create&lt;/strong&gt; the resource with that URI.&quot;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;方法请求将封闭的实体&lt;strong&gt;存储&lt;/strong&gt;在提供的Request-URI下。 如果Request-URI引用了&lt;strong&gt;已经存在的&lt;/strong&gt;资源，则应将封闭的实体视为驻留在原始服务器上的实体的&lt;strong&gt;修改版本&lt;/strong&gt; 。 如果Request-URI &lt;strong&gt;没有指向现有&lt;/strong&gt;资源，并且请求用户代理&lt;strong&gt;能够&lt;/strong&gt;将该URI定义为&lt;strong&gt;&lt;em&gt;新&lt;/em&gt;资源&lt;/strong&gt; ，则原始服务器可以使用该URI &lt;strong&gt;创建&lt;/strong&gt;资源。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="59fcd39418146017bc9d79b2463c3bd0da6fb592" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
    &lt;code&gt;created&lt;/code&gt; or &lt;code&gt;replaced&lt;/code&gt; with the state defined by the representation
    enclosed in the request message payload.</source>
          <target state="translated">PUT方法请求 &lt;code&gt;created&lt;/code&gt; 目标资源的状态或 &lt;code&gt;replaced&lt;/code&gt; 为请求消息有效负载中包含的表示形式所定义的状态。</target>
        </trans-unit>
        <trans-unit id="e77dcb77c2b94fc15160e4b361047201bc47a791" translate="yes" xml:space="preserve">
          <source>The RFC reads like this:</source>
          <target state="translated">RFC是这样写的:</target>
        </trans-unit>
        <trans-unit id="2bf09923cd40e9a4020e710d08ab29ff70e0f921" translate="yes" xml:space="preserve">
          <source>The client POST a new resource to the server.</source>
          <target state="translated">客户端POST一个新资源到服务器。</target>
        </trans-unit>
        <trans-unit id="6d21b96b8e9dc8ceda9663e50081fd866f4a8784" translate="yes" xml:space="preserve">
          <source>The client does not have a URL for the resource (therefore PUT is not an option) and repeats the POST.</source>
          <target state="translated">客户端没有资源的URL(因此PUT不是一个选项)并重复POST。</target>
        </trans-unit>
        <trans-unit id="dab9c53b7a8f4efbb9c76b8f8b0c3647ff5ea29b" translate="yes" xml:space="preserve">
          <source>The client never receives the response.</source>
          <target state="translated">客户端从未收到回复。</target>
        </trans-unit>
        <trans-unit id="7e77aa23ca0f2f2521e9d88d6afd4e68b94dfbe8" translate="yes" xml:space="preserve">
          <source>The content type &quot;application/x-www-form-urlencoded&quot; is inefficient
  for sending large quantities of binary data or text containing
  non-ASCII characters. The content type &quot;multipart/form-data&quot; should be
  used for submitting forms that contain files, non-ASCII data, and
  binary data.</source>
          <target state="translated">内容类型 &quot;applicationx-www-form-urlencoded &quot;对于发送大量的二进制数据或包含非ASCII字符的文本来说效率不高。在提交包含文件、非ASCII数据和二进制数据的表单时,应使用 &quot;multipartform-data &quot;内容类型。</target>
        </trans-unit>
        <trans-unit id="c00e08de50ba7cbbdbcec8cf8cc194d4e2c70887" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</source>
          <target state="translated">POST和PUT请求的根本区别体现在Request-URI的不同含义。POST请求中的URI标识了将处理被包围的实体的资源。这个资源可能是一个接受数据的进程,一个通往其他协议的网关,或者是一个接受注释的独立实体。与此相反,PUT请求中的URI标识的是与请求一起被封存的实体----用户代理知道URI的目的是什么,服务器不能试图将请求应用到其他资源上。</target>
        </trans-unit>
        <trans-unit id="531d093617728697be6cb081a0052d11e9261dcc" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,</source>
          <target state="translated">POST和PUT请求的根本区别体现在Request-URI的不同含义。POST请求中的URI标识了将处理被包围的实体的资源。这个资源可能是一个接受数据的进程,一个通往其他协议的网关,或者是一个接受注释的独立实体。与此相反,PUT请求中的URI标识了与请求一起被包围的实体--用户代理知道URI的目的是什么,服务器不能试图将请求应用到其他资源上。如果服务器希望将请求应用到不同的URI上,那么服务器就不能尝试将请求应用到其他资源上。</target>
        </trans-unit>
        <trans-unit id="9a92f77699786e960e9bee1d8eacf143a2e57922" translate="yes" xml:space="preserve">
          <source>The idea of a &lt;em&gt;RESTful-URL&lt;/em&gt; is actually a violation of REST as the server is in charge of the URL structure and should be free to decide how to use it to avoid coupling. If this confuses you read about the significance of self discovery on API design.</source>
          <target state="translated">&lt;em&gt;RESTful-URL&lt;/em&gt;的想法实际上违反了REST，因为服务器负责URL结构，并且应该自由决定如何使用它来避免耦合。 如果这使您感到困惑，您将了解自我发现对API设计的重要性。</target>
        </trans-unit>
        <trans-unit id="08c88ada7f30da94a298cf8074dd8cb30fa5608e" translate="yes" xml:space="preserve">
          <source>The most important consideration is &lt;em&gt;reliability&lt;/em&gt;. If a POST message gets lost the state of the system is undefined. Automatic recovery is impossible. For PUT messages, the state is undefined only until the first successful retry.</source>
          <target state="translated">最重要的考虑因素是&lt;em&gt;可靠性&lt;/em&gt; 。 如果POST消息丢失，则系统状态不确定。 自动恢复是不可能的。 对于PUT消息，只有在第一次成功重试之前，状态才是未定义的。</target>
        </trans-unit>
        <trans-unit id="70a1801f56d9e3b89398dd57a765b43ab4ffd957" translate="yes" xml:space="preserve">
          <source>The relevant specification for PUT and POST is &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</source>
          <target state="translated">PUT和POST的相关规范是&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616&amp;sect;9.5ff。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5212416a9c7e401d69b6999879d0f06d6e6c6b8f" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
  state of the resource. This code is only allowed in situations where
  it is expected that the user might be able to resolve the conflict and
  resubmit the request. The response body SHOULD include enough</source>
          <target state="translated">由于与资源的当前状态冲突,请求无法完成。只有在预期用户能够解决冲突并重新提交请求的情况下,才允许使用此代码。响应体应该包括足够的</target>
        </trans-unit>
        <trans-unit id="d5fcf6a88ce59329f97adb1fc601b9b08db15db3" translate="yes" xml:space="preserve">
          <source>The semantics are supposed be different, in that &quot;PUT&quot;, like &quot;GET&quot; is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.</source>
          <target state="translated">语义应该是不同的,因为 &quot;PUT &quot;和 &quot;GET &quot;一样,应该是idempotent的--也就是说,你可以多次执行相同的PUT请求,结果就像你只执行一次一样。</target>
        </trans-unit>
        <trans-unit id="6497cf669dc224da5094578e5e54fa6ced3cdbc7" translate="yes" xml:space="preserve">
          <source>The server does the business, returns the response &lt;em&gt;and stores it against the agreed action URI&lt;/em&gt;. If anything goes wrong, the client repeats the request (natural behaviour!), and if the server has already seen it, it repeats the stored response &lt;em&gt;and does nothing else&lt;/em&gt;.</source>
          <target state="translated">服务器进行业务，返回响应&lt;em&gt;并将其存储在约定的操作URI中&lt;/em&gt; 。 如果发生任何错误，客户端将重复该请求（自然行为！），如果服务器已经看到请求，它将重复存储的响应， &lt;em&gt;并且不执行其他任何操作&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5da1be1c708bb16e849af08a7fb0aa8d0d4c1309" translate="yes" xml:space="preserve">
          <source>The server is unaware the client has not received the response.</source>
          <target state="translated">服务器没有意识到客户端没有收到响应。</target>
        </trans-unit>
        <trans-unit id="62a97e57f72e643adc7cc713734b78e46c053ea2" translate="yes" xml:space="preserve">
          <source>The server processes the request and sends a response.</source>
          <target state="translated">服务器处理请求并发送响应。</target>
        </trans-unit>
        <trans-unit id="ad17da286154778c13914cd41e9cf66091180592" translate="yes" xml:space="preserve">
          <source>There seems to always be some confusion as to when to use the HTTP POST versus the HTTP PUT method for REST services. Most developers will try to associate CRUD operations directly to HTTP methods. I will argue that this is not correct and one can not simply associate the CRUD concepts to the HTTP methods. That is:</source>
          <target state="translated">在REST服务中,何时使用HTTP POST方法与HTTP PUT方法相比,似乎总是会有一些困惑。大多数开发者会试图将CRUD操作直接与HTTP方法关联起来。我将认为这是不正确的,不能简单地将CRUD概念与HTTP方法关联起来。也就是说。</target>
        </trans-unit>
        <trans-unit id="7612d7c41fbfbe6d8a2310c67de97a21fbe00850" translate="yes" xml:space="preserve">
          <source>Therefore: &lt;strong&gt;PUT&lt;/strong&gt; is only a candidate for CREATE where the client already knows the url before the resource is created. Eg. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; as the title is used as the resource key</source>
          <target state="translated">因此：在创建资源之前， &lt;strong&gt;PUT&lt;/strong&gt;仅是CREATE的候选对象，在此客户端客户已经知道该URL。 例如。 &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; 作为标题用作资源密钥</target>
        </trans-unit>
        <trans-unit id="ea0f8ddfd30845a4b1c6a9e4d8ca5de38b2ab4ea" translate="yes" xml:space="preserve">
          <source>This forces the API to avoid state transition problems with multiple clients updating a single resource, and matches more nicely with event sourcing and CQRS. When the work is done asynchronously, POSTing the transformation and waiting for it to be applied seems appropriate.</source>
          <target state="translated">这迫使API避免了多个客户端更新单一资源的状态转换问题,并且与事件源和CQRS更匹配。当工作是异步完成的时候,POST发送转换并等待它被应用似乎是合适的。</target>
        </trans-unit>
        <trans-unit id="0d513503c5d27d970dedbc3a017aa5dfc6730d1b" translate="yes" xml:space="preserve">
          <source>This is what AtomPub has to say about resource creation (section 9.2):</source>
          <target state="translated">这是AtomPub关于资源创建的内容(9.2节)。</target>
        </trans-unit>
        <trans-unit id="db06c4e9bb7f4493ec87367452486878b32df472" translate="yes" xml:space="preserve">
          <source>This jibes with the other advice here, that PUT is best applied to resources that already have a name, and POST is good for creating a new object under an existing resource (and letting the server name it).</source>
          <target state="translated">这与这里的其他建议不谋而合,即PUT最好应用于已经有名字的资源,而POST则适合在现有资源下创建一个新对象(并让服务器为其命名)。</target>
        </trans-unit>
        <trans-unit id="329ccd5deda6ee5083da67216837de43b64d3560" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI of the Collection.</source>
          <target state="translated">要将成员添加到一个集合中,客户发送POST请求到集合的URI。</target>
        </trans-unit>
        <trans-unit id="8a44f83e9442ef60d290f2c8799f5cc060ff1e23" translate="yes" xml:space="preserve">
          <source>To overwrite an existing resource:</source>
          <target state="translated">要覆盖现有的资源。</target>
        </trans-unit>
        <trans-unit id="300c31c8ca811ac31b1e4b0cbcc5df25674e9c0e" translate="yes" xml:space="preserve">
          <source>To understand it we need to question why PUT was required, what were the problems PUT was trying to solve that POST couldn't.</source>
          <target state="translated">要理解它,我们需要质疑为什么需要PUT,PUT要解决的问题是什么,而POST无法解决的问题。</target>
        </trans-unit>
        <trans-unit id="2b77e3950318466e7b1306d760c2096fcdcc38f3" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URI): Generic Syntax and Semantics</source>
          <target state="translated">统一资源标识符(URI)。通用语法和语义</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="e2fbf38e05ed6d395ec7f6efdfd2ea298e430b2a" translate="yes" xml:space="preserve">
          <source>Updates the resource with &lt;strong&gt;existingResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">在/ resources URI或&lt;strong&gt;collection&lt;/strong&gt;下，以&lt;strong&gt;现存&lt;/strong&gt;资源为标识更新资源。</target>
        </trans-unit>
        <trans-unit id="f8079d8e5134eb77a5128a4f32d06200addab2ae" translate="yes" xml:space="preserve">
          <source>Use POST to create, and PUT to update. That's how Ruby on Rails is doing it, anyway.</source>
          <target state="translated">使用POST来创建,PUT来更新。反正Ruby on Rails就是这样做的。</target>
        </trans-unit>
        <trans-unit id="7e3328f33c6c2ad3028951ba9c219f5262089b33" translate="yes" xml:space="preserve">
          <source>Used to create a resource, or
  overwrite it.  While you specify the
  resources new URL.</source>
          <target state="translated">用于创建一个资源,或覆盖它。当你指定了资源的新URL时。</target>
        </trans-unit>
        <trans-unit id="caad456be6f2e43799931b874b916e57d669f040" translate="yes" xml:space="preserve">
          <source>Used to modify and update a resource</source>
          <target state="translated">用于修改和更新资源</target>
        </trans-unit>
        <trans-unit id="534d6f360955fe24940d916537fd5f5d03013712" translate="yes" xml:space="preserve">
          <source>Useful when a resource's URL is known</source>
          <target state="translated">当已知资源的URL时,可以使用</target>
        </trans-unit>
        <trans-unit id="87dffc568fb442d1ab8b5daa3edd8813475735c7" translate="yes" xml:space="preserve">
          <source>Useful when the resource's URL is
unknown</source>
          <target state="translated">当资源的URL未知时很有用</target>
        </trans-unit>
        <trans-unit id="d2f00b419fb58779569430425949be8c2946ab81" translate="yes" xml:space="preserve">
          <source>When dealing with REST and URI as general, you have &lt;strong&gt;generic&lt;/strong&gt; on the &lt;em&gt;left&lt;/em&gt; and &lt;strong&gt;specific&lt;/strong&gt; on the &lt;em&gt;right&lt;/em&gt;. The &lt;strong&gt;generics&lt;/strong&gt; are usually called &lt;strong&gt;collections&lt;/strong&gt; and the more &lt;strong&gt;specific&lt;/strong&gt; items can be called &lt;strong&gt;resource&lt;/strong&gt;. Note that a &lt;strong&gt;resource&lt;/strong&gt; can contain a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">一般情况下，在处理REST和URI时， &lt;em&gt;左侧&lt;/em&gt;是&lt;strong&gt;通用类&lt;/strong&gt; ， &lt;em&gt;右侧是&lt;/em&gt; &lt;strong&gt;特定类&lt;/strong&gt; 。 &lt;strong&gt;泛型&lt;/strong&gt;通常称为&lt;strong&gt;集合&lt;/strong&gt; ，更&lt;strong&gt;具体的&lt;/strong&gt;项目称为&lt;strong&gt;资源&lt;/strong&gt; 。 请注意， &lt;strong&gt;资源&lt;/strong&gt;可以包含&lt;strong&gt;集合&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="14ad7c96823b5a1d653bec9e758d08db87c5209c" translate="yes" xml:space="preserve">
          <source>When you POST to a resource at a particular URL, often you are posting a related piece of information to that URL. This implies that the resource at the URL already exists.</source>
          <target state="translated">当你POST到一个特定的URL上的资源时,通常你是在发布一个相关的信息到这个URL上。这意味着该URL上的资源已经存在。</target>
        </trans-unit>
        <trans-unit id="f6bf84ba90320cefe0d8fa5d18b1d11fe5272e46" translate="yes" xml:space="preserve">
          <source>When you PUT a resource at a particular URL what happens is that it should get saved at that URL, or something along those lines.</source>
          <target state="translated">当你把一个资源放在一个特定的URL上时,会发生的事情是,它应该被保存在这个URL上,或者是类似于这样的东西。</target>
        </trans-unit>
        <trans-unit id="03669db6e556a71ab819d40f836e5bd27373b8b6" translate="yes" xml:space="preserve">
          <source>When you can't fully trust the client to do the right thing, it would be 
more appropriate to use &lt;strong&gt;POST&lt;/strong&gt; to create a new item and then send the URL back to the client in the response.</source>
          <target state="translated">当您不能完全信任客户端做正确的事时，使用&lt;strong&gt;POST&lt;/strong&gt;创建新项目，然后在响应中将URL发送回客户端会更合适。</target>
        </trans-unit>
        <trans-unit id="22766c7cfca9b0f8a5c36dfb8f98f375b88a60a7" translate="yes" xml:space="preserve">
          <source>When you use POST you are &lt;strong&gt;always&lt;/strong&gt; refering to a &lt;strong&gt;collection&lt;/strong&gt;, so whenever you say:</source>
          <target state="translated">使用POST时，您&lt;strong&gt;总是&lt;/strong&gt;引用&lt;strong&gt;collection&lt;/strong&gt; ，因此无论何时您说：</target>
        </trans-unit>
        <trans-unit id="e380bb1d3e7c031588ca3a3c5bf3f6f0d241ddcf" translate="yes" xml:space="preserve">
          <source>Which is used is left up to you.  But just remember to use the right one depending on what object you are referencing in the request.</source>
          <target state="translated">使用哪一个是由你自己决定的。但只要记住,根据你在请求中引用的对象,使用正确的那一个就可以了。</target>
        </trans-unit>
        <trans-unit id="ebbb5885abc4335ac57b9aa863e7c08abfc8ea5e" translate="yes" xml:space="preserve">
          <source>Which means if you have to submit</source>
          <target state="translated">这意味着,如果你必须提交</target>
        </trans-unit>
        <trans-unit id="1e394f3df68b2548c835945807e40cf42b367d8e" translate="yes" xml:space="preserve">
          <source>While there is probably an agnostic way to describe these, it does seem to be conflicting with various statements from answers to websites.</source>
          <target state="translated">虽然可能有一种不可知论者的描述方式,但这似乎确实与网站的各种回答中的说法有冲突。</target>
        </trans-unit>
        <trans-unit id="a5bc20d2d4325f529ff7555db67ccca89565a4cd" translate="yes" xml:space="preserve">
          <source>Wikipedia - REST</source>
          <target state="translated">维基百科-REST</target>
        </trans-unit>
        <trans-unit id="386e23f3812d1bdded28437f31996a6a569b6fd3" translate="yes" xml:space="preserve">
          <source>With &amp;ldquo;REST without PUT&amp;rdquo; technique, the idea is that consumers are
  forced to post new 'nounified' request resources. As discussed
  earlier, changing a customer&amp;rsquo;s mailing address is a POST to a new
  &amp;ldquo;ChangeOfAddress&amp;rdquo; resource, not a PUT of a &amp;ldquo;Customer&amp;rdquo; resource with a
  different mailing address field value.</source>
          <target state="translated">使用&amp;ldquo;不带PUT的REST&amp;rdquo;技术，想法是消费者被迫发布新的&amp;ldquo;统一&amp;rdquo;请求资源。 如前所述，更改客户的邮寄地址是对新&amp;ldquo; ChangeOfAddress&amp;rdquo;资源的POST，而不是具有不同邮寄地址字段值的&amp;ldquo; Customer&amp;rdquo;资源的PUT。</target>
        </trans-unit>
        <trans-unit id="53a0df456d0b82cfb20df7d1c7dcda70c26fd29c" translate="yes" xml:space="preserve">
          <source>With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.</source>
          <target state="translated">使用POST,你可以有2个请求同时进来对一个URL进行修改,它们可能会更新对象的不同部分。</target>
        </trans-unit>
        <trans-unit id="bcec0b85a95c09c1d9aa73bbac93122064920f3c" translate="yes" xml:space="preserve">
          <source>With POST, you're posting to the address of the QUEUE or COLLECTION. With PUT, you're putting to the address of the ITEM.</source>
          <target state="translated">使用POST,你是把它发到QUUE或COLLECTION的地址。使用PUT,你是把它发到ITEM的地址。</target>
        </trans-unit>
        <trans-unit id="e394766f3d8f38a5425a15f2e94e15f94cff2588" translate="yes" xml:space="preserve">
          <source>With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.</source>
          <target state="translated">使用PUT,如果同一个查询被多次或一次执行,STUDENT表的状态不变。</target>
        </trans-unit>
        <trans-unit id="9f13e4060016ff9f870bc818b8b5bcb9592a2292" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;POST&lt;/code&gt; to example.com/users since you don't know the &lt;code&gt;URL&lt;/code&gt; of the user yet, you want the server to create it.</source>
          <target state="translated">由于您尚不知道用户的 &lt;code&gt;URL&lt;/code&gt; ，因此您将其发布到example.com/users，您希望服务器创建它。</target>
        </trans-unit>
        <trans-unit id="a3e29206f13fd7f313ac3a03984149fd94f809d9" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;PUT&lt;/code&gt; to example.com/users/id since you want to replace/create a &lt;em&gt;specific&lt;/em&gt; user.</source>
          <target state="translated">由于您要替换/创建&lt;em&gt;特定&lt;/em&gt;用户，因此将其 &lt;code&gt;PUT&lt;/code&gt; example.com/users/id。</target>
        </trans-unit>
        <trans-unit id="cd925494376cae5537a3d23703b024e74bd08383" translate="yes" xml:space="preserve">
          <source>You can find assertions on the web that say</source>
          <target state="translated">你可以在网上找到断言说</target>
        </trans-unit>
        <trans-unit id="deb01051624c8536f5e270d282325b0dbf3553ef" translate="yes" xml:space="preserve">
          <source>You can update or create a resource with PUT with the same object URL</source>
          <target state="translated">你可以用PUT更新或创建一个具有相同对象URL的资源。</target>
        </trans-unit>
        <trans-unit id="50c70a21ef7f357ae45ec172565f2b589fc30211" translate="yes" xml:space="preserve">
          <source>You could though do something like
  this to create a resources using POST:</source>
          <target state="translated">你可以用POST来创建一个资源。</target>
        </trans-unit>
        <trans-unit id="8dddfd0893267c4dc2c1565595682d6ee7fe0449" translate="yes" xml:space="preserve">
          <source>You do not need to support both PUT and POST.</source>
          <target state="translated">你不需要同时支持PUT和POST。</target>
        </trans-unit>
        <trans-unit id="1a70c96038989ab75bed3ead389a54345761a879" translate="yes" xml:space="preserve">
          <source>You have to ask &quot;what are you performing the action to?&quot; to distinguish what you should be using. Let's assume you're designing an API for asking questions.  If you want to use POST then you would do that to a list of questions. If you want to use PUT then you would do that to a particular question.</source>
          <target state="translated">你必须问 &quot;你执行的动作是为了什么?&quot;来区分你应该使用什么。假设你设计的是一个提问的API。如果你想使用POST,那么你会对问题列表执行。如果你想使用PUT,那么你就会对一个特定的问题进行操作。</target>
        </trans-unit>
        <trans-unit id="aab05f743ff11af397a41e6a50b339a3a9b253b8" translate="yes" xml:space="preserve">
          <source>You will quickly spot the similarity with promises: we create and return the placeholder for the result before doing anything. Also like a promise, an action can succeed or fail one time, but its result can be fetched repeatedly.</source>
          <target state="translated">你会很快发现它与承诺的相似之处:我们在做任何事情之前,先创建并返回结果的占位符。同样像承诺一样,一个动作可以一次成功或一次失败,但它的结果可以反复获取。</target>
        </trans-unit>
        <trans-unit id="f363cc5672437cee525e493743ecf9b56f18170d" translate="yes" xml:space="preserve">
          <source>files, non-ASCII data, and binary data</source>
          <target state="translated">文件、非ASCII数据和二进制数据。</target>
        </trans-unit>
        <trans-unit id="03d4991f0d2b56909a00a2c07cb0c98115001bed" translate="yes" xml:space="preserve">
          <source>information for the user to recognize the source of the conflict.
  Ideally, the response entity would include enough information for the
  user or user agent to fix the problem; however, that might not be
  possible and is not required.</source>
          <target state="translated">响应实体包括足够的信息,以便用户识别冲突源。理想的情况是,响应实体应包括足够的信息,让用户或用户代理解决这个问题;然而,这可能是不可能的,也不需要。</target>
        </trans-unit>
        <trans-unit id="a7cc393671d331a6f24f8870a93fd8292a27451f" translate="yes" xml:space="preserve">
          <source>it will work, but semantically you are saying that you want to add a resource to the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">它会起作用，但从语义上讲，您是在向&lt;em&gt;用户&lt;/em&gt; &lt;strong&gt;集合&lt;/strong&gt;下的&lt;em&gt;john&lt;/em&gt; &lt;strong&gt;集合&lt;/strong&gt;添加资源。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="d0b50e773f074b959f39222603c21bd08feff7c0" translate="yes" xml:space="preserve">
          <source>taken from &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Resource Modeling by Prakash Subramaniam of Thoughtworks&lt;/a&gt;</source>
          <target state="translated">摘自&lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API设计-Thoughtworks的Prakash Subramaniam编写的资源建模&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebe73780ee4475ed56cfa08985bac3ceeb53b38" translate="yes" xml:space="preserve">
          <source>the origin server can create the resource with that URI</source>
          <target state="translated">原点服务器可以用该URI创建资源</target>
        </trans-unit>
        <trans-unit id="c4c609ca0b9379838bc225c20d08b72b88e05939" translate="yes" xml:space="preserve">
          <source>you are posting a new user to the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">您正在将新用户发布到&lt;em&gt;用户&lt;/em&gt; &lt;strong&gt;集合&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1f3bfcffc130ebfe19bd9ae363ee7834942fb61" translate="yes" xml:space="preserve">
          <source>you are telling to the server update, or create if it doesn't exist, the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;resource&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">您要告诉服务器更新，或者在&lt;em&gt;用户&lt;/em&gt; &lt;strong&gt;集合&lt;/strong&gt;下创建&lt;em&gt;john&lt;/em&gt; &lt;strong&gt;资源&lt;/strong&gt; （如果不存在）。</target>
        </trans-unit>
        <trans-unit id="ac747133049c7cac58b2f01633f4d4824881c480" translate="yes" xml:space="preserve">
          <source>you should use &lt;strong&gt;POST&lt;/strong&gt; method</source>
          <target state="translated">您应该使用&lt;strong&gt;POST&lt;/strong&gt;方法</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
