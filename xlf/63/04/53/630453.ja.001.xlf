<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/630453">
    <body>
      <group id="630453">
        <trans-unit id="0c058b89b3c60a0ba555a3620d744eb93c511f1a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH is the new primary HTTP method for updates&lt;/a&gt;&quot; explains it.</source>
          <target state="translated">「 &lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails：PATCHは、更新のための新しい主要なHTTPメソッドです&lt;/a&gt; 」と説明しています。</target>
        </trans-unit>
        <trans-unit id="f74f51ed1b6ae265800adfcf8027c01c0018665f" translate="yes" xml:space="preserve">
          <source>10.4.10 409 Conflict</source>
          <target state="translated">10.4.10.10 409 コンフリクト</target>
        </trans-unit>
        <trans-unit id="506fa830744fbb202514e4450da7b9fff37040d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; is designed to replace 2616 and in &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; describes the follow possible response for a POST</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;は2616を置き換えるように設計されており、 &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;セクション4.3.3&lt;/a&gt;で、POSTの可能な応答について説明しています</target>
        </trans-unit>
        <trans-unit id="1a0c5e7063c7016b18d6c3928f19f62e9242e7e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;I wrote the following as part of another answer on SO regarding this&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;これに関するSOの別の回答の一部として、私は以下を書きました&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="55aee01ee1d0f0416e9083e2d6f6557b9818cb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST /something&lt;/code&gt;: &quot;Take what I give you and put it anywhere you want under &lt;code&gt;/something&lt;/code&gt; as long as you give me its URL when you're done.&quot;</source>
          <target state="translated">&lt;code&gt;POST /something&lt;/code&gt; ： &quot;私があなたに与えたものを取り、あなたが完了したときに私にそのURLを与えさえすれば、 &lt;code&gt;/something&lt;/code&gt; の下のどこにでも置きます。&quot;</target>
        </trans-unit>
        <trans-unit id="df611b43ba33bf88fde50464bfe23c704ed98e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST x&lt;/code&gt;: &quot;Store my content and give me an identifier that I can use to identify a resource (old or new) containing said content (possibly mixed with other content). Said resource should be identical or subordinate to that which &lt;code&gt;x&lt;/code&gt; identifies.&quot; &quot;&lt;em&gt;y&lt;/em&gt;'s resource is subordinate to &lt;em&gt;x&lt;/em&gt;'s resource&quot; is typically but not necessarily implemented by making &lt;em&gt;y&lt;/em&gt; a subpath of &lt;em&gt;x&lt;/em&gt; (e.g. &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; and &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt;) and modifying the representation(s) of &lt;em&gt;x&lt;/em&gt;'s resource to reflect the existence of a new resource, e.g. with a hyperlink to &lt;em&gt;y&lt;/em&gt;'s resource and some metadata. Only the latter is really essential to good design, as URLs are opaque in REST -- you're supposed to &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;use hypermedia&lt;/a&gt; instead of client-side URL construction to traverse the service anyways.</source>
          <target state="translated">&lt;code&gt;POST x&lt;/code&gt; ：「コンテンツを保存し、そのコンテンツを含む（古いまたは新しい）リソースを識別するために使用できる識別子を提供します（他のコンテンツと混合されている可能性があります。上記のリソースは、 &lt;code&gt;x&lt;/code&gt; が識別するものと同一または従属である必要があります。」 &quot; &lt;em&gt;y&lt;/em&gt;のリソースは&lt;em&gt;x&lt;/em&gt;のリソースに従属します&quot;は、通常、 &lt;em&gt;y&lt;/em&gt;を&lt;em&gt;xの&lt;/em&gt;サブパスにして（例&lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; および&lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt; ）、 &lt;em&gt;x&lt;/em&gt;の表現を変更することで実装されますが、必ずしもそうである必要はありませんs新しいリソースの存在を反映するリソース。たとえば、 &lt;em&gt;y&lt;/em&gt;のリソースへのハイパーリンクといくつかのメタデータ。 RESTではURLが不透明であるため、後者だけが優れた設計に不可欠です。サービスをトラバースするには、クライアント側のURL構築ではなく&lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;ハイパーメディア&lt;/a&gt;を使用することになっています 。</target>
        </trans-unit>
        <trans-unit id="d458584efe00bde626b31645f1c9331669a393b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST&lt;/code&gt; means &quot;create new&quot; as in &quot;Here is the input for creating a user, create it for me&quot;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; は、「ユーザーを作成するための入力です。ユーザーのために作成してください」のように、「新規作成」を意味します。</target>
        </trans-unit>
        <trans-unit id="1a07f91414dd50cc7f1986ee5d6ee5a1fbee9ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; already exists): &quot;Take whatever you have at &lt;code&gt;/something&lt;/code&gt; and replace it with what I give you.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; （ &lt;code&gt;/something&lt;/code&gt; が既に存在する場合）：「 &lt;code&gt;/something&lt;/code&gt; にあるものをすべて取り、それを私があなたに与えるもので置き換えます。」</target>
        </trans-unit>
        <trans-unit id="46ab7ec42035f8ace3ccbdc9e29957431a709ad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; does not already exist): &quot;Take what I give you and put it at &lt;code&gt;/something&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; （ &lt;code&gt;/something&lt;/code&gt; がまだ存在しない場合）：「私があなたに与えたものを取り、それを &lt;code&gt;/something&lt;/code&gt; に置きます。」</target>
        </trans-unit>
        <trans-unit id="8b19b9a7682dd06e6b9d4d9b60e4befaf7e822f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; does not identify a resource): &quot;Create a new resource containing my content and use &lt;code&gt;x&lt;/code&gt; to identify it.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; がリソースを識別しない場合）：「私のコンテンツを含む新しいリソースを作成し、 &lt;code&gt;x&lt;/code&gt; を使用してそれを識別します。」</target>
        </trans-unit>
        <trans-unit id="b7eeae57fac13ac526305058d9ec04d7f1c90069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; identifies a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;resource&lt;/a&gt;): &quot;Replace the content of the resource identified by &lt;code&gt;x&lt;/code&gt; with my content.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; が&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;リソースを&lt;/a&gt;識別する場合）：「 xで識別されるリソースのコンテンツを自分のコンテンツで置き換えます。」</target>
        </trans-unit>
        <trans-unit id="693d0f55f15f15a3670f566554ad630959a6464b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT&lt;/code&gt; means &quot;insert, replace if already exists&quot; as in &quot;Here is the data for user 5&quot;.</source>
          <target state="translated">「ここにユーザー5のデータがあります」のように、 &lt;code&gt;PUT&lt;/code&gt; は「挿入、既に存在する場合は置換する」を意味します。</target>
        </trans-unit>
        <trans-unit id="ba9411546a0e55dde6f6b3b345e14406853999d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;一部のユーザーは、POSTを使用して更新を実行できることを考え出します。&lt;/em&gt; &lt;em&gt;更新に使用するものや、作成に使用するものに厳密な規則はありません。&lt;/em&gt; &lt;em&gt;繰り返しになりますが、これらは慣例であり、直感的に、私は上記の推論に傾倒し、それに従います。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="494905e8546c28f7ca25ed531d6f9532f60855f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;-- generic -- specific --&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;-一般-特定-&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24bd66f9b0232fdec5910e08746f4135f3abc5f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3.4.  PUT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3.4。&lt;/strong&gt; &lt;strong&gt;プット&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f00078b6cfd30a400e58409eebd42604b45de8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b79f8a35030639797e581e3751e158add431466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Great both can be used, so which one should I use in my RESTful design:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;両方とも使用できるので、RESTfulな設計でどちらを使用すればよいですか。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f204e179a99e4e4da9b046149c8fa27fab675704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Long Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;長い答え：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ea66d061a28052dccef1603c0375aa549c7f0e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Longer Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;より長い答え：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d19062995715b13929a5b7d5ad16cd259eea9489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; PUTでは更新が必要なリソースの場所（既にリソース）が必要ですが、POSTでは必要ありません。 したがって、直感的には、POSTは新しいリソースの作成を目的としていますが、PUTは既存のリソースを更新するために必要です。</target>
        </trans-unit>
        <trans-unit id="973a94f5bc8d247be1da5613a2678e40ad80ce20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;New answer (now that I understand REST better):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;新しい答え（今はRESTをよく理解している）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6eaec7db8eb07bc1a9853353813e5aacc4d8a7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; PUT has mostly been used to update resources (by replacing them in their entireties), but recently there is movement towards using PATCH for updating existing resources, as PUT specifies that it replaces the whole resource. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; PUTは主に（リソース全体を置き換えることによって）リソースを更新するために使用されていましたが、PUTはリソース全体を置き換えることを指定しているため、最近は既存のリソースの更新にPATCHを使用する動きがあります。 &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f39f80f6a4493b75f71f2759494c67e2fe8499a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or you can do this&lt;/strong&gt;: consider your unsafe requests as ephemeral single-user resources (let's call them actions). Clients request a new &quot;action&quot; on a substantive resource with an empty POST to the resource. POST will be used only for this. Once safely in possession of the URI of the freshly minted action, the client PUTs the unsafe request to the action URI, &lt;em&gt;not the target resource&lt;/em&gt;. Resolving the action and updating the &quot;real&quot; resource is properly the job of your API, and is here decoupled from the unreliable network.</source>
          <target state="translated">&lt;strong&gt;または、これを行うことができ&lt;/strong&gt;ます。安全でないリクエストを一時的なシングルユーザーリソースと見なします（アクションと呼びましょう）。 クライアントは、リソースへの空のPOSTを使用して、実体リソースに対して新しい「アクション」を要求します。 POSTはこれにのみ使用されます。 新しく作成されたアクションのURIを安全に保持すると、クライアント&lt;em&gt;は、ターゲットリソース&lt;/em&gt;で&lt;em&gt;はなく、&lt;/em&gt;アクションURIに安全でない要求をPUTします。 アクションを解決して「実際の」リソースを更新することは、適切にAPIの仕事であり、ここでは信頼性の低いネットワークから切り離されています。</target>
        </trans-unit>
        <trans-unit id="83d03f71c82f9f3e365473c2e90a536428e4a72f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer (might be easier to read)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;元の回答（読みやすくなる場合があります）&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="fb16687bea1f8e2c7ffd77af09d8a11526e30bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overall:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overall:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fec18cd93d5bbce335b8a8b4685449de2c1a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PATCH&lt;/strong&gt; to a URL &lt;strong&gt;updates &lt;em&gt;part&lt;/em&gt; of the resource&lt;/strong&gt; at that client defined URL.</source>
          <target state="translated">URLへの&lt;strong&gt;PATCH&lt;/strong&gt;は、そのクライアント定義のURLで&lt;strong&gt;リソースの&lt;em&gt;一部&lt;/em&gt;を更新し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e900f8bab5ad45a82b31d5c9e77eb8b842fb8fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST creates a child resource&lt;/strong&gt;, so POST to &lt;code&gt;/items&lt;/code&gt; creates a resources that lives under the &lt;code&gt;/items&lt;/code&gt; resource. 
Eg. &lt;code&gt;/items/1&lt;/code&gt;. Sending the same post packet twice will create two resources.</source>
          <target state="translated">&lt;strong&gt;POSTは子リソースを作成する&lt;/strong&gt;ため、 &lt;code&gt;/items&lt;/code&gt; へのPOSTは &lt;code&gt;/items&lt;/code&gt; リソースの下にあるリソースを作成します。 例えば。 &lt;code&gt;/items/1&lt;/code&gt; 。 同じポストパケットを2回送信すると、2つのリソースが作成されます。</target>
        </trans-unit>
        <trans-unit id="84cd833b3d09b3772c7c9b69992c06365b49d808" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;POST:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51d739446154fe4129eacba513d3e7c1cbc82d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; /items</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; /アイテム</target>
        </trans-unit>
        <trans-unit id="81f179204aeec70824672b29654dc73a5ef03745" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; You can think of something like &quot;INSERT INTO STUDENT(name, address) VALUES (&quot;abc&quot;, &quot;xyzzz&quot;);</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; &quot;INSERT INTO STUDENT（name、address）VALUES（&quot; abc &quot;、&quot; xyzzz &quot;）;のようなものを考えることができます。</target>
        </trans-unit>
        <trans-unit id="d84ba3155ffa58932b6b44f1f889c414429f25ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; a resource into a collection</source>
          <target state="translated">リソースをコレクションに&lt;strong&gt;POST&lt;/strong&gt;する</target>
        </trans-unit>
        <trans-unit id="c6057b584edf3b882a3192b1dc61a689a17f508b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;はべき等ではないため、操作を1回実行する場合と比較して複数回実行すると、リソースの状態が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="fa11acc5dc60894a4a26cfcbe0027d32f1604de8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;PUT&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;を使用してリソースを作成し、 &lt;strong&gt;PUT&lt;/strong&gt;を使用してリソースを変更する必要があります</target>
        </trans-unit>
        <trans-unit id="83971fa0e325d0bc5650b7ff303b5ca7b5384576" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL &lt;strong&gt;creates a child resource&lt;/strong&gt; at a &lt;em&gt;server defined&lt;/em&gt; URL.</source>
          <target state="translated">URLへの&lt;strong&gt;POST&lt;/strong&gt;は、 &lt;em&gt;サーバー定義の&lt;/em&gt; URLに&lt;strong&gt;子リソース&lt;/strong&gt;を&lt;strong&gt;作成し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="39214825f7bf31755a7524b96e478ffac1270da2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL should be used to update or create a resource which is located at some other (&quot;subordinate&quot;) URL, or is not locatable via HTTP.</source>
          <target state="translated">URLへの&lt;strong&gt;POST&lt;/strong&gt;は、他の（「従属」）URLにあるリソース、またはHTTP経由で配置できないリソースを更新または作成するために使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="906a2e1913665dd7ea341fe6a356f1a5db4491c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; updates a resource, adds a subsidiary resource, or causes a change.  A POST is not idempotent, in the way that &lt;code&gt;x++&lt;/code&gt; is not idempotent.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;はリソースを更新するか、補助リソースを追加するか、または変更を引き起こします。 POSTは、 &lt;code&gt;x++&lt;/code&gt; がべき等ではないように、べき等ではありません。</target>
        </trans-unit>
        <trans-unit id="1201fa44ed952a209bb94b60653ae5e6d12e8775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cb09efafb2a756a2c8c49fbf16fde25b499a6f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt;  /items/1234</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; / items / 1234</target>
        </trans-unit>
        <trans-unit id="04e6413418714eccb311ba8ccd68a6eb8397b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; You can think of similar to &quot;UPDATE STUDENT SET address = &quot;abc&quot; where id=&quot;123&quot;;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; &quot;UPDATE STUDENT SET address =&quot; abc &quot;where id =&quot; 123 &quot;;と同様に考えることができます。</target>
        </trans-unit>
        <trans-unit id="bac831f172bbd16f060e11a1fcf6a1142deebaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; a resource identified by collection/:id</source>
          <target state="translated">collection /：idで識別されるリソースを&lt;strong&gt;PUT&lt;/strong&gt;します</target>
        </trans-unit>
        <trans-unit id="43e9659830aa7fe8a7b61df6c3d0f9fe51884752" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; implies putting a resource - completely replacing whatever is available at the given URL with a different thing.  By definition, a PUT is idempotent.  Do it as many times as you like, and the result is the same. &lt;code&gt;x=5&lt;/code&gt; is idempotent.  You can PUT a resource whether it previously exists, or not (eg, to Create, or to Update)!</source>
          <target state="translated">&lt;strong&gt;PUTは&lt;/strong&gt; 、リソースを配置することを意味します。つまり、指定されたURLで利用可能なものをすべて別のものに完全に置き換えます。 定義により、PUTはべき等です。 何度でも繰り返してください。結果は同じです。 &lt;code&gt;x=5&lt;/code&gt; はべき等です。 以前に存在したかどうかに関係なく、リソースをPUTできます（たとえば、作成または更新）。</target>
        </trans-unit>
        <trans-unit id="11d47c3923ae9d2cba6624010bda74e130873ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is for creating or replacing a resource at a &lt;strong&gt;URL known by the client&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;は&lt;strong&gt;、クライアントが認識&lt;/strong&gt;している&lt;strong&gt;URLで&lt;/strong&gt;リソースを作成または置換するため&lt;strong&gt;のものです&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fa7bf3d7c1668ea88085a1bf5c94b878a2e04e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.</source>
          <target state="translated">&lt;strong&gt;PUTはべき&lt;/strong&gt;等であり、同じ操作が1回または複数回実行された場合、リソースの状態は同じになります。</target>
        </trans-unit>
        <trans-unit id="ad48efa009a26f69b5139207c4818699892b929a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; replaces the resource at the known url if it already exists, so sending the same request twice has no effect. In other words, &lt;strong&gt;calls to PUT are idempotent&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;は既知のURLにあるリソースが既に存在する場合はそれを置き換えます。そのため、同じリクエストを2回送信しても効果はありません。 つまり、 &lt;strong&gt;PUTの呼び出しはべき等&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="47297bbd78d247783bb6a9b461b4320abab889a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;POST&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">リソースの作成には&lt;strong&gt;PUT&lt;/strong&gt;を使用し、リソースの変更には&lt;strong&gt;POST&lt;/strong&gt;を使用する必要があります</target>
        </trans-unit>
        <trans-unit id="2316d8434c10c4f7c6461cd73b5ad3a9c62ff074" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL &lt;strong&gt;creates/replaces the resource&lt;/strong&gt; in its entirety at the &lt;em&gt;client defined&lt;/em&gt; URL.</source>
          <target state="translated">URLへの&lt;strong&gt;PUT&lt;/strong&gt;は、 &lt;em&gt;クライアント定義の&lt;/em&gt; URLで&lt;strong&gt;リソース&lt;/strong&gt;全体を&lt;strong&gt;作成または置換し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9a47a55d20b6233f89d8f607db5f21886379877c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL should be used to update or create the resource that can be located at that URL.</source>
          <target state="translated">URLへの&lt;strong&gt;PUT&lt;/strong&gt;は、そのURLにあるリソースを更新または作成するために使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0eb5b9e913c2e4810b9d275d9137826d6361fccb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post&lt;/strong&gt; on social media: when we post message, it creates new post.</source>
          <target state="translated">ソーシャルメディアに投稿する：メッセージを投稿すると、新しい投稿が作成されます。</target>
        </trans-unit>
        <trans-unit id="c379deb81ec8171aeba8c48b33c76a4077d81ae5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put&lt;/strong&gt;(i.e. edit) for the message we already Posted.</source>
          <target state="translated">投稿済みのメッセージを入力（編集）します。</target>
        </trans-unit>
        <trans-unit id="42f2ab7a6f0ba70ad4633ee1aeb9c5617f17e37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replying with a status code of 409 Conflict is the correct recourse because&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;ステータスコード409 Conflictで返信するのは正しい理由&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="541c698af4296a2ac8f6dbcf007beace20e3289c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;簡潔な答え：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7dee22b45482414ebaedf9e5284e4fb4d8d9302d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The decision of whether to use PUT or POST to create a resource on a server with an HTTP + REST API is based on who owns the URL structure.&lt;/strong&gt; Having the client know, or participate in defining, the URL struct is an unnecessary coupling akin to the undesirable couplings that arose from SOA. Escaping types of couplings is the reason REST is so popular. Therefore, &lt;strong&gt;the proper method to use is POST.&lt;/strong&gt; There are exceptions to this rule and they occur when the client wishes to retain control over the location structure of the resources it deploys. This is rare and likely means something else is wrong.</source>
          <target state="translated">&lt;strong&gt;HTTP + REST APIを使用してサーバー上にリソースを作成するためにPUTまたはPOSTを使用するかどうかの決定は、URL構造の所有者に基づいています。&lt;/strong&gt; クライアントにURL構造体を知らせたり、定義に参加させたりすると、SOAから生じた望ましくない結合に似た不要な結合になります。 RESTが非常に人気がある理由は、カップリングのタイプを回避することです。 したがって、 &lt;strong&gt;使用する適切な方法はPOSTです。&lt;/strong&gt; このルールには例外があり、クライアントがデプロイするリソースのロケーション構造を引き続き制御したい場合に発生します。 これはまれであり、他の問題が発生している可能性があります。</target>
        </trans-unit>
        <trans-unit id="52dde7c3fb20e3705b4cb8c6fdc0d421a3aa14d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018&lt;/strong&gt;: There is a case that can be made to avoid PUT. See &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;REST without PUT&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;2018年更新&lt;/strong&gt; ：PUTを回避するためにできるケースがあります。 &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;「PUTなしのREST」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="018ab5192fbe6cef7ceb3ab2181f51408e2e0392" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update based on release of RFC 7231 to Replace 2616&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RFC 7231のリリースに基づいて2616を置き換えるように更新&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="823a6eb1d93ecc4c59ea5a879b8110b0723a4c56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using POST to create resources comes with a design consideration because POST is not idempotent.&lt;/strong&gt; This means that repeating a POST several times does not guarantee the same behavior each time. &lt;strong&gt;This scares people into using PUT to create resources when they should not.&lt;/strong&gt; They know it's wrong (POST is for CREATE) but they do it anyway because they don't know how to solve this problem.  This concern is demonstrated in the following situation:</source>
          <target state="translated">&lt;strong&gt;POSTはべき等ではないので、POSTを使用してリソースを作成する際には、設計上の考慮事項が伴います。&lt;/strong&gt; つまり、POSTを数回繰り返しても、毎回同じ動作が保証されるわけではありません。 &lt;strong&gt;これは、PUTを使用してリソースを作成する必要がない場合に人々を怖がらせます。&lt;/strong&gt; 彼らはそれが間違っていることを知っていますが（POSTはCREATEを意味します）、この問題を解決する方法がわからないため、とにかくそれを行います。 この問題は、次の状況で示されます。</target>
        </trans-unit>
        <trans-unit id="f8352b060f3bd6bf9405565ea670a52e1a19ac89" translate="yes" xml:space="preserve">
          <source>A PUT doesn't need to be a create; the service could error if the resource isn't already created, but otherwise update it. Or vice versa -- it may create the resource, but not allow updates. The only thing required about PUT is that it points to a specific resource, and its payload is the representation of that resource. A successful PUT means (barring interference) that a GET would retrieve the same resource.</source>
          <target state="translated">PUTはcreateである必要はありません。リソースがまだ作成されていない場合、サービスはエラーを出しますが、そうでなければ更新します。また、その逆もあります --リソースは作成されても更新は許可されません。PUTに必要なのは、特定のリソースを指し示すことと、そのペイロードがそのリソースの表現であることだけです。PUTが成功すると、(干渉を除いて)GETが同じリソースを取得することを意味します。</target>
        </trans-unit>
        <trans-unit id="0e9a6a3224dfefa9263f801580fea79e1034124c" translate="yes" xml:space="preserve">
          <source>A REST API must not define fixed resource names or hierarchies (an
  obvious coupling of client and server). Servers must have the freedom
  to control their own namespace. Instead, allow servers to instruct
  clients on how to construct appropriate URIs, such as is done in HTML
  forms and URI templates, by defining those instructions within media
  types and link relations. [Failure here implies that clients are
  assuming a resource structure due to out-of band information, such as
  a domain-specific standard, which is the data-oriented equivalent to
  RPC's functional coupling].</source>
          <target state="translated">REST API は、固定のリソース名や階層を定義してはいけません(クライアントとサーバーの明白な結合)。サーバーは、独自の名前空間を制御する自由を持たなければなりません。その代わりに、HTMLフォームやURIテンプレートで行われているように、メディアタイプやリンク関係の中でそれらの指示を定義することで、サーバーが適切なURIを構築する方法をクライアントに指示できるようにしてください。ここでの失敗は、クライアントがRPCの機能的結合と同等のデータ指向であるドメイン固有の標準などの規格外の情報のためにリソース構造を想定していることを暗示している]。</target>
        </trans-unit>
        <trans-unit id="4eebc73de916b615d31b4a9c02c76f42d153bef9" translate="yes" xml:space="preserve">
          <source>A general advice is to use &lt;code&gt;POST&lt;/code&gt; when you need the server to be in control of &lt;code&gt;URL&lt;/code&gt; generation of your resources. Use &lt;code&gt;PUT&lt;/code&gt; otherwise.  Prefer &lt;code&gt;PUT&lt;/code&gt;  over &lt;code&gt;POST&lt;/code&gt;.</source>
          <target state="translated">一般的なアドバイスは、サーバーがリソースの &lt;code&gt;URL&lt;/code&gt; 生成を制御する必要がある場合に &lt;code&gt;POST&lt;/code&gt; を使用することです。 それ以外の場合は &lt;code&gt;PUT&lt;/code&gt; を使用します。 &lt;code&gt;POST&lt;/code&gt; より &lt;code&gt;PUT&lt;/code&gt; を優先します。</target>
        </trans-unit>
        <trans-unit id="a46f192218c6e582580086317328dbf11d360983" translate="yes" xml:space="preserve">
          <source>A general rule: if you know the id or name of the item, use PUT. If you want the id or name of the item to be assigned by the receiving party, use POST.</source>
          <target state="translated">原則として、アイテムのIDや名前が分かっている場合はPUTを使用します。受信側でアイテムのIDや名前を指定したい場合はPOSTを使用します。</target>
        </trans-unit>
        <trans-unit id="8d80afd687e25858c217eccf9caa91d0cf98797f" translate="yes" xml:space="preserve">
          <source>A new method is necessary to improve interoperability and prevent
     errors.  The PUT method is already defined to overwrite a resource
     with a complete new body, and cannot be reused to do partial changes.
     Otherwise, proxies and caches, and even clients and servers, may get
     confused as to the result of the operation.  POST is already used but
     without broad interoperability (for one, there is no standard way to
     discover patch format support).  PATCH was mentioned in earlier HTTP
     specifications, but not completely defined.</source>
          <target state="translated">相互運用性を向上させ、エラーを防ぐために新しいメソッドが必要です。PUTメソッドは、リソースを完全な新しいボディで上書きするためにすでに定義されており、部分的な変更を行うために再利用することはできません。そうしないと、プロキシやキャッシュ、さらにはクライアントやサーバさえも、操作の結果として混乱してしまうかもしれません。POST は既に使われていますが、広範な相互運用性はありません (一つには、パッチフォーマットのサポートを発見する標準的な方法がありません)。PATCHは以前のHTTP仕様で言及されていましたが、完全には定義されていません。</target>
        </trans-unit>
        <trans-unit id="d7612bc02c9fa195c518a31c5e2d100c9f1167a8" translate="yes" xml:space="preserve">
          <source>A response which contains the URL of the resource with the conflicting ID and the appropriate preconditions for the resource would provide &amp;ldquo;enough information for the user or user agent to fix the problem&amp;rdquo; which is the ideal case per RFC 2616.</source>
          <target state="translated">競合するIDを持つリソースのURLとリソースの適切な前提条件を含む応答は、「ユーザーまたはユーザーエージェントが問題を修正するための十分な情報」を提供します。これは、RFC 2616による理想的なケースです。</target>
        </trans-unit>
        <trans-unit id="0a5f004271832132b2407dff2153fd15001e9ee0" translate="yes" xml:space="preserve">
          <source>According to ME, real-life networks are unreliable. Requests timeout. Connections are reset. Networks go down for hours or days at a time. Trains go into tunnels with mobile users aboard. For any given request (as occasionally acknowledged in all this discussion) the request can fall in the water on its way, or the response can fall in the water on its way back. &lt;strong&gt;In these conditions, issuing PUT, POST and DELETE requests directly against substantive resources has always struck me as a little brutal and naive.&lt;/strong&gt;</source>
          <target state="translated">MEによれば、実際のネットワークは信頼できません。 リクエストのタイムアウト。 接続がリセットされます。 ネットワークは一度に数時間または数日間ダウンします。 電車は、モバイルユーザーを乗せてトンネルに入ります。 特定の要求（この説明で時々認められるように）の場合、要求は途中で水に落ちるか、応答が途中で水に落ちることがあります。 &lt;strong&gt;これらの状況では、実質的なリソースに対して直接PUT、POST、およびDELETEリクエストを発行することは、常に私を少し残忍で素朴なものとして感じました。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44a64212bc466bad1c26da5cf30cd0ad13d5b0f6" translate="yes" xml:space="preserve">
          <source>According to the HTTP 1.1 specifications the GET, HEAD, DELETE, and PUT methods must be idempotent, and the POST method is not idempotent. That is to say that an operation is idempotent if it can be performed on a resource once or many times and always return the same state of that resource. Whereas a non idempotent operation can return a modified state of the resource from one request to another. Hence, in a non idempotent operation, there is no guarantee that one will receive the same state of a resource.</source>
          <target state="translated">HTTP 1.1 の仕様によると、GET,HEAD,DELETE,PUT メソッドはアイドエンプテントでなければならず、POST メソッドはアイドエンプテントではありません。つまり、ある操作がリソースに対して一度でも何度でも実行でき、常にそのリソースの同じ状態を返すことができれば、その操作はアイドempotentであると言えます。一方、非アイドエンプテントな操作は、あるリクエストから別のリクエストへの間に、リソースの変更された状態を返すことができます。したがって、非アイドエンプテント操作では、リソースの同じ状態を受け取るという保証はありません。</target>
        </trans-unit>
        <trans-unit id="263017c41745f1b94fb06cd0b37045f3eec4ef1a" translate="yes" xml:space="preserve">
          <source>According to the HTTP/1.1 Spec:</source>
          <target state="translated">HTTP1.1仕様によると</target>
        </trans-unit>
        <trans-unit id="99391b86ae4d4984d262f89901db8c15300e563f" translate="yes" xml:space="preserve">
          <source>According to this, you cannot send files or multipart data in the &lt;strong&gt;PUT&lt;/strong&gt; method</source>
          <target state="translated">これによると、 &lt;strong&gt;PUT&lt;/strong&gt;メソッドでファイルまたはマルチパートデータを送信することはできません</target>
        </trans-unit>
        <trans-unit id="400cd438f5e39bdc77550bfd923cf916451692bd" translate="yes" xml:space="preserve">
          <source>Additionally, and a bit more concisely, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 Section 4.3.4 PUT&lt;/a&gt; states (emphasis added),</source>
          <target state="translated">さらに、もう少し簡潔に説明すると、 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231セクション4.3.4 PUTに&lt;/a&gt;は次のように記載されています（強調が追加されています）。</target>
        </trans-unit>
        <trans-unit id="18829b20b3b1624e09ed74c26fb7066a49e205d0" translate="yes" xml:space="preserve">
          <source>Analogy with database query</source>
          <target state="translated">データベースクエリとの類推</target>
        </trans-unit>
        <trans-unit id="1ecad98fe7923a037242a110b7abf85eb0ca5b54" translate="yes" xml:space="preserve">
          <source>Analogy:</source>
          <target state="translated">Analogy:</target>
        </trans-unit>
        <trans-unit id="cd8441cd54d554959dc0b978e4c1160125beaede" translate="yes" xml:space="preserve">
          <source>As for modifying the properties of the stream, you can do that with either PUT or POST. Basically, only use &quot;PUT&quot; when the operation is idempotent - otherwise use POST.</source>
          <target state="translated">ストリームのプロパティを変更するには、PUTかPOSTのどちらかを使用します。基本的には、操作がアイドエンプテントな場合にのみ &quot;PUT&quot; を使用し、そうでない場合は POST を使用します。</target>
        </trans-unit>
        <trans-unit id="1505fe853a030352c8bbf3a78d4f0ba03add0832" translate="yes" xml:space="preserve">
          <source>As such, numerous thorny problems go away. Repeated insert requests won't create duplicates, and we don't create the real resource until we're in possession of the data. (database columns can stay not-nullable). Repeated update requests won't hit incompatible states and won't overwrite subsequent changes. Clients can (re)fetch and seamlessy process the original confirmation for whatever reason (client crashed, response went missing, etc.).</source>
          <target state="translated">このように、多くの厄介な問題は解決されます。挿入リクエストを繰り返しても重複は発生しませんし、データを手に入れるまでは真のリソースは作成しません(データベースのカラムは NULL ではない状態を保つことができます)。(データベースのカラムは NULL ではない状態を保つことができます)。更新要求を繰り返しても、互換性のない状態になることはありませんし、その後の変更を上書きすることもありません。クライアントは、何らかの理由(クライアントがクラッシュした、レスポンスが行方不明になった、など)で元の確認を(再)取得し、シームレスに処理することができます。</target>
        </trans-unit>
        <trans-unit id="9269d826939b1ae8561cb8d676c6f19e2aeeeeb8" translate="yes" xml:space="preserve">
          <source>As your quote mentioned, you use PUT for creation of there is no resource assigned to an IRI, and you want to create a resource anyway. For example, &lt;code&gt;PUT /users/123/password&lt;/code&gt; usually replaces the old password with a new one, but you can use it to create a password if it does not exist already (for example, by freshly registered users or by restoring banned users).</source>
          <target state="translated">あなたの引用が述べたように、IRIに割り当てられたリソースがないの作成にPUTを使用し、とにかくリソースを作成したいとします。 たとえば、 &lt;code&gt;PUT /users/123/password&lt;/code&gt; は通常、古いパスワードを新しいパスワードに置き換えますが、まだ存在しない場合は（たとえば、新しく登録されたユーザーまたは禁止されたユーザーを復元することによって）、パスワードを作成するために使用できます。</target>
        </trans-unit>
        <trans-unit id="678d1314d4c33bf4616bbffabc6f6412417d7408" translate="yes" xml:space="preserve">
          <source>At the risk of restating what has already been said, it seems important to remember that &lt;strong&gt;PUT&lt;/strong&gt; implies that the client controls what the &lt;em&gt;URL&lt;/em&gt; is going to end up being, when creating a resource. So part of the choice between &lt;strong&gt;PUT&lt;/strong&gt; and &lt;strong&gt;POST&lt;/strong&gt; is going to be about how much you can trust the client to provide correct, normalized &lt;em&gt;URL&lt;/em&gt; that are coherent with whatever your URL scheme is.</source>
          <target state="translated">すでに述べられていることを言い換えると、 &lt;strong&gt;PUT&lt;/strong&gt;はリソースを作成するときに、クライアントが&lt;em&gt;URLの&lt;/em&gt;最終的な内容を制御することを意味することを覚えておくことは重要なようです。 したがって、 &lt;strong&gt;PUT&lt;/strong&gt;と&lt;strong&gt;POSTの&lt;/strong&gt;間の選択の一部は、URLスキームが何であれ、首尾一貫した正規化された&lt;em&gt;URL&lt;/em&gt;を提供するためにクライアントをどれだけ信頼できるかについてです。</target>
        </trans-unit>
        <trans-unit id="cd64c65270203c04e0ffe12619fc3c1cf5cb0838" translate="yes" xml:space="preserve">
          <source>At this point some people will argue that if &lt;em&gt;RESTful-URL's&lt;/em&gt; are used, the client does knows the URL of the resource and therefore a PUT is acceptable. After all, this is why canonical, normalized, Ruby on Rails, Django URLs are important, look at the Twitter API &amp;hellip; blah blah blah. Those people need to understand &lt;strong&gt;there is no such thing as a Restful-URL&lt;/strong&gt; and that &lt;strong&gt;Roy Fielding himself states that&lt;/strong&gt;:</source>
          <target state="translated">この時点で、 &lt;em&gt;RESTful-URL&lt;/em&gt;が使用されている場合、クライアントはリソースのURLを知っているため、PUTが受け入れられると主張する人もい&lt;em&gt;ます&lt;/em&gt; 。 結局のところ、これが正規化されたRuby on Rails、DjangoのURLが重要である理由です。TwitterAPIを見てください。 これらの人々 &lt;strong&gt;は、Restful-URLのようなものはなく&lt;/strong&gt; 、 &lt;strong&gt;ロイフィールディング自身が次のように述べていること&lt;/strong&gt;を理解する必要があり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ec0b3e3b0319156f9f91acfe20356337cec520" translate="yes" xml:space="preserve">
          <source>Based on the above idempotent definition, my take on using the HTTP PUT method versus using the HTTP POST method for REST services is:
Use the HTTP PUT method when:</source>
          <target state="translated">上記のidempotentの定義に基づいて、RESTサービスでHTTP PUTメソッドを使用するのとHTTP POSTメソッドを使用するのでは、私の考えは次のようになります。HTTP PUT メソッドを使用するのは、次のような場合です。</target>
        </trans-unit>
        <trans-unit id="625c633dc893bb8acf9969ce26d2c745e6ed5c5d" translate="yes" xml:space="preserve">
          <source>Because PUT and GET and DELETE refer to a resource, they are also by definition idempotent.</source>
          <target state="translated">PUT、GET、DELETEはリソースを参照しているので、それらも定義上はidempotentです。</target>
        </trans-unit>
        <trans-unit id="33d0f759f56954a746edd3401e6d1ad592971425" translate="yes" xml:space="preserve">
          <source>Before telling me this is not RESTful, please consider the numerous ways in which REST principles are respected. Clients don't construct URLs. The API stays discoverable, albeit with a little change in semantics. HTTP verbs are used appropriately. If you think this is a huge change to implement, I can tell you from experience that it's not.</source>
          <target state="translated">これはRESTfulではないと言う前に、RESTの原則が尊重されている多くの方法を考えてみてください。クライアントは URL を構築しません。API は、セマンティクスが多少変更されても発見可能なままです。HTTP 動詞は適切に使用されます。これが実装する上で大きな変化だと思うなら、経験上、そうではないことを教えてあげることができます。</target>
        </trans-unit>
        <trans-unit id="241aa52fb81745d04b1069f6da972cd395e23c48" translate="yes" xml:space="preserve">
          <source>Best of all, we give sending and receiving applications a chance to link the uniquely identified action to uniqueness in their respective environments. And we can start to demand, and enforce!, responsible behaviour from clients: repeat your requests as much as you like, but don't go generating a new action until you're in possession of a definitive result from the existing one.</source>
          <target state="translated">何よりも優れているのは、アプリケーションを送信する側と受信する側に、一意に識別されたアクションをそれぞれの環境の一意性に結びつける機会を与えることです。そして、クライアントに責任ある行動を要求し、強制することができます:好きなだけリクエストを繰り返してください。</target>
        </trans-unit>
        <trans-unit id="b0bf6e9b80cf880bc4aee735753fe3f2ad23f833" translate="yes" xml:space="preserve">
          <source>Better is to choose between PUT and POST based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;idempotence&lt;/a&gt; of the action.</source>
          <target state="translated">より良いのは、アクションのべき&lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;等&lt;/a&gt;に基づいてPUTとPOSTのどちらかを選択することです。</target>
        </trans-unit>
        <trans-unit id="53c932206c69e73836ac721b4e0fe0b474be565c" translate="yes" xml:space="preserve">
          <source>Both PUT and POST can be used for creating.</source>
          <target state="translated">作成にはPUTとPOSTの両方を使用できます。</target>
        </trans-unit>
        <trans-unit id="2997f210a9beea7a9cbb23843149e3c1e35aa1ed" translate="yes" xml:space="preserve">
          <source>Both are used for data transmission between client to server, but there are subtle differences between them, which are:</source>
          <target state="translated">どちらもクライアントからサーバーへのデータ転送に使用されますが、両者には微妙な違いがあります。</target>
        </trans-unit>
        <trans-unit id="15b3b6388bc7e089c531c0bb3e2208420e07f69e" translate="yes" xml:space="preserve">
          <source>By this argument, PUT is for creating when you know the URL of the thing you will create. POST can be used to create when you know the URL of the &quot;factory&quot; or manager for the category of things you want to create.</source>
          <target state="translated">この引数で、PUTは作成するモノのURLがわかっているときに作成するためのものです。POSTは、作成したいモノのカテゴリの「工場」や「マネージャー」のURLがわかっているときに作成するためのものです。</target>
        </trans-unit>
        <trans-unit id="c7c8d0b3ba4ea21e1913266949e8103ea15c06b3" translate="yes" xml:space="preserve">
          <source>Can &lt;strong&gt;only&lt;/strong&gt; be performed with PUT in the following way:</source>
          <target state="translated">次の方法でPUTを使用して&lt;strong&gt;のみ&lt;/strong&gt;実行できます。</target>
        </trans-unit>
        <trans-unit id="29d666e583f03fcf75786741bc1b0cab3486e6df" translate="yes" xml:space="preserve">
          <source>Can be performed with both PUT or POST in the following way:</source>
          <target state="translated">以下のようにPUTとPOSTの両方で行うことができます。</target>
        </trans-unit>
        <trans-unit id="34e3815fe6dbc55d1a2ed6585c021c9fc37f549b" translate="yes" xml:space="preserve">
          <source>Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.</source>
          <target state="translated">ケース1:タイムラインに何かを投稿したとき、それは新鮮な新着エントリーです。このケースではPOSTメソッドは非親和性なのでPOSTメソッドを使用しています。</target>
        </trans-unit>
        <trans-unit id="afe97da32ea658ba5cfa1f6a3af16660a6caad91" translate="yes" xml:space="preserve">
          <source>Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.</source>
          <target state="translated">ケース2:友人があなたの投稿に初めてコメントした場合、それはまた、データベースに新しいエントリが作成されますので、POSTメソッドが使用されます。</target>
        </trans-unit>
        <trans-unit id="51c87be0979efc83a96ee19ed6970b9953da779d" translate="yes" xml:space="preserve">
          <source>Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*</source>
          <target state="translated">ケース3:友人がコメントを編集した場合、このケースではコメントIDを持っていたので、データベースに新しいエントリを作成する代わりに既存のコメントを更新します。したがって、このタイプの操作ではPUTメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="b0e2937475fc503e223c56343b52c44da7a6fa27" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a PUT request. For
  example, if versioning were being used and the entity being PUT
  included changes to a resource which conflict with those made by an
  earlier (third-party) request, the server might use the 409 response
  to indicate that it can&amp;rsquo;t complete the request. In this case, the
  response entity would likely contain a list of the differences between
  the two versions in a format defined by the response Content-Type.</source>
          <target state="translated">競合は、PUTリクエストへの応答で発生する可能性が最も高いです。 たとえば、バージョニングが使用されていて、PUTされるエンティティにリソースへの変更が含まれており、それが以前の（サードパーティ）リクエストによる変更と競合する場合、サーバーは409レスポンスを使用して、リクエストを完了できないことを示します。 。 この場合、応答エンティティには、2つのバージョンの違いのリストが、応答のContent-Typeで定義された形式で含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="93b186070c96257e81f5f76dda28fe4aaa692252" translate="yes" xml:space="preserve">
          <source>Create:</source>
          <target state="translated">Create:</target>
        </trans-unit>
        <trans-unit id="17b1e45ff463141be485d41572191a7ed7413417" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;A&lt;/strong&gt; new resource under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;. Usually the identifier is returned by the server.</source>
          <target state="translated">/ resources URIまたは&lt;strong&gt;コレクションの&lt;/strong&gt;下に新しいリソースを作成します。 通常、識別子はサーバーから返されます。</target>
        </trans-unit>
        <trans-unit id="33e5496ae029f6fe64dd2213c64d6ba200b86f51" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;THE&lt;/strong&gt; new resource with &lt;strong&gt;newResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">/ resources URIまたは&lt;strong&gt;collectionの&lt;/strong&gt;下に、識別子として&lt;strong&gt;newResourceId&lt;/strong&gt;を使用して新しいリソースを作成します。</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="33ac997d5d937f49dfe9ade3e811b0f958a8e36d" translate="yes" xml:space="preserve">
          <source>Do not directly correlate and map CRUD operations to HTTP methods for REST services. The use of an HTTP PUT method versus an HTTP POST method should be based on the idempotent aspect of that operation. That is, if the operation is idempotent, then use the HTTP PUT method. If the operation is non idempotent, then use the HTTP POST method.</source>
          <target state="translated">RESTサービスのためにCRUD操作を直接相関させてHTTPメソッドにマッピングしてはいけません。HTTP PUT メソッドと HTTP POST メソッドの使い分けは、その操作のアイドエンプテント性に基づいて行うべきです。つまり、操作がアイドエンプテントであれば、HTTP PUT メソッドを使用します。もし操作が偶数性を持たない場合は、HTTP POST メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="d370df4be6707296d029645b0b4712b06c53ef1c" translate="yes" xml:space="preserve">
          <source>Do you name your URL objects you create explicitly, or let the server decide? If you name them then use PUT.  If you let the server decide then use POST.</source>
          <target state="translated">作成した URL オブジェクトに明示的に名前を付けるのか、それともサーバに任せるのか?名前を付ける場合はPUTを使用します。サーバに決定させる場合は POST を使用します。</target>
        </trans-unit>
        <trans-unit id="58945bef9cdd3ff1a80ba82c0e9d1f5a2d0ee11b" translate="yes" xml:space="preserve">
          <source>Edit: One more thing -- a PUT can create, but if it does then the ID has to be a natural ID -- AKA an email address. That way when you PUT twice, the second put is an update of the first. This makes it &lt;em&gt;idempotent&lt;/em&gt;.</source>
          <target state="translated">編集：もう1つ、PUTで​​作成できますが、作成する場合は、IDを自然なIDにする必要があります。 このように、2回PUTすると、2番目の書き込みは最初の書き込みの更新になります。 これにより&lt;em&gt;べき等になり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8ed4a1daabc4dbc57c02baa4ed3068d24acd58e8" translate="yes" xml:space="preserve">
          <source>For a new resource:</source>
          <target state="translated">新しいリソースのために。</target>
        </trans-unit>
        <trans-unit id="cff50999f4c249529ddc6e468c61561154669de5" translate="yes" xml:space="preserve">
          <source>For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.</source>
          <target state="translated">例えば、新しいストリームを作成したいときは、いくつかの URL にそれを PUT することができます。しかし、既存のストリームにメッセージをPOSTしたい場合は、そのURLにPOSTします。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="f547ae451be4b97139f6676d6b8b56908850c325" translate="yes" xml:space="preserve">
          <source>For instance, it may not be a good idea to create credit card transactions with POST.</source>
          <target state="translated">例えば、POSTでクレジットカードの取引を作成するのは良くないかもしれません。</target>
        </trans-unit>
        <trans-unit id="cc46f3f2f22617ca008bc0347b91c6bcc94f57de" translate="yes" xml:space="preserve">
          <source>For more information about this, read this &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;article&lt;/a&gt;.</source>
          <target state="translated">詳細については、こちらの&lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;記事を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="6cd29602a6814d7031623e943eb9ad9b03163c44" translate="yes" xml:space="preserve">
          <source>From a REST architecture's point of view there is none that matters. We could have lived without PUT as well. But from a client developer's point of view it made his/her life a lot simpler.</source>
          <target state="translated">RESTアーキテクチャの観点から見れば、重要なことは何もありません。私たちはPUTがなくても生きていけたかもしれません。しかし、クライアント開発者の視点から見ると、それは彼女の人生をはるかにシンプルにしてくれました。</target>
        </trans-unit>
        <trans-unit id="e554373d4e3272bcfc25cfb1cdb1bc748dad0740" translate="yes" xml:space="preserve">
          <source>HTTP does nothing to ensure reliable completion of the request-response, and that's just fine because this is properly the job of network-aware applications. Developing such an application, you can jump through hoops to use PUT instead of POST, then more hoops to give a certain kind of error on the server if you detect duplicate requests. Back at the client, you then have to jump through hoops to interpret these errors, refetch, revalidate and repost.</source>
          <target state="translated">HTTP はリクエストとレスポンスの信頼性の高い完了を保証するものではありません。このようなアプリケーションを開発するには、POST の代わりにPUTを使用するための輪を飛び越えなければなりませんし、リクエストの重複を検出した場合には、サーバ上である種のエラーを出すための輪をさらに飛び越えなければなりません。クライアントに戻って、これらのエラーを解釈し、再取得し、再検証し、再投稿するためには、さらに多くの作業をしなければなりません。</target>
        </trans-unit>
        <trans-unit id="b3fde5b13baf7e698d819867af72294baf96853b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Spec</source>
          <target state="translated">HTTP1.1仕様</target>
        </trans-unit>
        <trans-unit id="5307592ab464b1dfe31ceb63373b1f53680a6aa6" translate="yes" xml:space="preserve">
          <source>Header &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">ヘッダー &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a656b7b969733403da8fb5e2a09bcb24ed7b14b0" translate="yes" xml:space="preserve">
          <source>Hence, create or update based on existence of the &lt;strong&gt;resource&lt;/strong&gt;.</source>
          <target state="translated">したがって、 &lt;strong&gt;リソースの&lt;/strong&gt;存在に基づいて作成または更新します。</target>
        </trans-unit>
        <trans-unit id="a09685c9924e957d538b394fd639ee93fed0a583" translate="yes" xml:space="preserve">
          <source>Hence, creates a new &lt;strong&gt;resource&lt;/strong&gt; on a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">したがって、 &lt;strong&gt;コレクションに&lt;/strong&gt;新しい&lt;strong&gt;リソース&lt;/strong&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="ceaa5b7fc07bf5371832748f3289a7b2da4d980c" translate="yes" xml:space="preserve">
          <source>Here's a simple rule:</source>
          <target state="translated">ここで簡単なルールを紹介します。</target>
        </trans-unit>
        <trans-unit id="8d27a8aff43735751da6f6d2d0ed6614a7eecf8a" translate="yes" xml:space="preserve">
          <source>I hope this helps any Microsoft developers that read all comments with Amazon and Sun/Java website links.</source>
          <target state="translated">私はこれがAmazonとSunJavaのウェブサイトのリンクですべてのコメントを読んでいるすべてのMicrosoftの開発者の助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="5ca6bb95d20fb75f5f126fd38d614ae6b08d4b81" translate="yes" xml:space="preserve">
          <source>I interpret this, and the idempotency requirements on PUT, to mean that:</source>
          <target state="translated">私はこれとPUTのidempotencyの要件はそういう意味だと解釈しています。</target>
        </trans-unit>
        <trans-unit id="05235e2370ecb21ce9215b0f74750a3737456a63" translate="yes" xml:space="preserve">
          <source>I like this advice, from &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616's definition of PUT&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616のPUTの定義&lt;/a&gt;から、私はこのアドバイスを気に入っています 。</target>
        </trans-unit>
        <trans-unit id="47aada42c69dd7c0210a4f1845e6ab606520fa95" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;PUT&lt;/code&gt; for Merge and update like operations and use &lt;code&gt;POST&lt;/code&gt; for Insertions.</source>
          <target state="translated">マージには &lt;code&gt;PUT&lt;/code&gt; を使用し、同様の操作を更新し、挿入には &lt;code&gt;POST&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="b527f56fb4de9ec139a67d896e81802d54cd82a0" translate="yes" xml:space="preserve">
          <source>I will describe the conventions which I think are most widely used and are most useful:</source>
          <target state="translated">私が最も広く使われていると思う、最も有用だと思われる規約を記載します。</target>
        </trans-unit>
        <trans-unit id="f9c0500253b27e41a2e9e90178c365ce2423d509" translate="yes" xml:space="preserve">
          <source>I'd like to add my &quot;pragmatic&quot; advice.  Use PUT when you know the &quot;id&quot; by which the object you are saving can be retrieved.  Using PUT won't work too well if you need, say, a database generated id to be returned for you to do future lookups or updates.</source>
          <target state="translated">私の &quot;実用的 &quot;なアドバイスを付け加えたいと思います。保存しようとしているオブジェクトが取得できる「id」がわかっている場合にPUTを使用してください。例えば、将来の検索や更新のためにデータベースで生成されたidを返す必要がある場合、PUTを使用してもあまりうまくはいきません。</target>
        </trans-unit>
        <trans-unit id="66649e065e34c99642108c78cb23fe86c7332572" translate="yes" xml:space="preserve">
          <source>I'm going to land with the following:</source>
          <target state="translated">で着地します。</target>
        </trans-unit>
        <trans-unit id="dc85f0689c0d90da1345182eb8a915a8e4dd3c43" translate="yes" xml:space="preserve">
          <source>If the ID is generated (a new employee ID, for example), then the second PUT with the same URL would create a new record, which violates the idempotent rule. In this case the verb would be POST, and the message (not resource) would be to create a resource using the values defined in this message.</source>
          <target state="translated">IDが生成された場合(例えば、新しい従業員ID)、同じURLを持つ2番目のPUTは新しいレコードを作成しますが、これはidempotentルールに違反します。この場合、動詞はPOSTとなり、メッセージは(リソースではなく)このメッセージで定義された値を使用してリソースを作成することになります。</target>
        </trans-unit>
        <trans-unit id="e269e8bb2d1ae96b4945fea0fb22c28a23aa1d25" translate="yes" xml:space="preserve">
          <source>If the URL is not yet created, you
  should not be using POST to create it
  while specifying the name.  This should
  result in a 'resource not found' error
  because &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; does not exist
  yet.  You should PUT the &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt;
  resource on the server first.</source>
          <target state="translated">URLがまだ作成されていない場合は、名前を指定するときにPOSTを使用して作成しないでください。 &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; がまだ存在しないため、これにより「リソースが見つかりません」エラーが発生します。 最初にサーバーの &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; リソースをPUTする必要があります。</target>
        </trans-unit>
        <trans-unit id="19c462827f591bd8bec6f3f537b7b39215387f40" translate="yes" xml:space="preserve">
          <source>If the result of processing a POST would be equivalent to a
  representation of an existing resource, an origin server MAY redirect
  the user agent to that resource by sending a 303 (See Other) response
  with the existing resource's identifier in the Location field.  This
  has the benefits of providing the user agent a resource identifier
  and transferring the representation via a method more amenable to
  shared caching, though at the cost of an extra request if the user
  agent does not already have the representation cached.</source>
          <target state="translated">POST処理の結果が既存のリソースの表現と同等である場合、オリジンサーバーは、 Locationフィールドに既存のリソースの識別子を持つ303(See Other)応答を送ることで、ユーザーエージェントをそのリソースにリダイレクトしてもよい[MAY]。これは、ユーザーエージェントにリソースの識別子を提供することと、共有キャッシングに より適した方法で表現を転送するという利点があるが、ユーザーエージェントがまだ 表現をキャッシュしていない場合、余分なリクエストが発生するという代償を 伴う。</target>
        </trans-unit>
        <trans-unit id="558a879fdfc95da4b234bea22b5e49ef57224b98" translate="yes" xml:space="preserve">
          <source>If you are familiar with database operations,
there are</source>
          <target state="translated">データベースの操作に慣れている方は、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="1d065776051b8ea3a055903bde387f8a311a6be4" translate="yes" xml:space="preserve">
          <source>If you go on and try something like this:</source>
          <target state="translated">続けていくと、こんな感じで試してみてください。</target>
        </trans-unit>
        <trans-unit id="0c6f7e90f3ea30966fd463c77a5a98203c024433" translate="yes" xml:space="preserve">
          <source>If you happen to have auto generated  URI's on your resource you can still use PUT by passing a generated URI (pointing to an empty resource) to the client.</source>
          <target state="translated">リソース上に自動生成された URI がある場合でも、生成された URI (空のリソースを指す)をクライアントに渡すことで PUT を使用することができます。</target>
        </trans-unit>
        <trans-unit id="cd5ae750e099166d34c0aea0fb9b4fadd772975a" translate="yes" xml:space="preserve">
          <source>If you have any doubts about how to implement REST in HTTP, you can always take a look at the &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom Publication Protocol (AtomPub)&lt;/a&gt; specification. AtomPub is a standard for writing RESTful webservices with HTTP that was developed by many HTTP and REST luminaries, with some input from Roy Fielding, the inventor of REST and (co-)inventor of HTTP himself.</source>
          <target state="translated">HTTPでRESTを実装する方法について疑問がある場合は、 &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom Publication Protocol（AtomPub）&lt;/a&gt;仕様をいつでも確認できます。 AtomPubは、RESTの発明者であり、HTTPの（共同）発明者であるRoy Fieldingからのいくつかの入力により、多くのHTTPとRESTの著名人によって開発されたHTTPでRESTful Webサービスを作成するための標準です。</target>
        </trans-unit>
        <trans-unit id="ec654f9d869b9d4e7e967af9a0e460df87b82e2e" translate="yes" xml:space="preserve">
          <source>If you think you'll have huge amounts of data to store, let's talk volumes: a typical update confirmation is a fraction of a kilobyte. HTTP currently gives you a minute or two to respond definitively. Even if you only store actions for a week, clients have ample chance to catch up. If you have very high volumes, you may want a dedicated acid-compliant key value store, or an in-memory solution.</source>
          <target state="translated">膨大な量のデータを保存することになると思うのであれば、ボリュームの話をしましょう:典型的な更新確認は1キロバイトの何分の1かです。HTTPでは現在、確実に応答するまでに1分か2分かかります。アクションを1週間だけ保存したとしても、クライアントが追いつくチャンスは十分にあります。非常に大きなボリュームがある場合は、専用の酸準拠のキーバリューストア、またはインメモリソリューションが必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5e3f77bd7d922a0787f75fec577234f6dce48c77" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;POST&lt;/strong&gt; method you can send body params in &lt;code&gt;form-data&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;メソッドでは、 &lt;code&gt;form-data&lt;/code&gt; パラメータで本文パラメータを送信できます</target>
        </trans-unit>
        <trans-unit id="ae084cc36a47a0ae5ba94fddaf0353c8961a476b" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PUT&lt;/strong&gt; method you have to send body params in &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;メソッドでは、本体パラメーターを &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; で送信する必要があります</target>
        </trans-unit>
        <trans-unit id="9431cceefc51a270cdbc8ad21cfd20758abb6247" translate="yes" xml:space="preserve">
          <source>In REST, there's no such thing as a resource containing &quot;content&quot;. I refer as &quot;content&quot; to data that the service uses to render representations consistently. It typically consists of some related rows in a database or a file (e.g. an image file). It's up to the service to convert the user's content into something the service can use, e.g. converting a JSON payload into SQL statements.</source>
          <target state="translated">RESTでは、「コンテンツ」を含むリソースというものは存在しません。私は、サービスが一貫して表現をレンダリングするために使用するデータを「コンテンツ」と呼んでいます。一般的には、データベースやファイル(画像ファイルなど)の中の関連する行から構成されます。ユーザーのコンテンツをサービスが使用できるものに変換するのはサービス次第で、例えばJSONペイロードをSQL文に変換するなどです。</target>
        </trans-unit>
        <trans-unit id="258ba4ae5c03cdfdac38fed39baa86957f31d85a" translate="yes" xml:space="preserve">
          <source>In a single line, use &lt;strong&gt;POST&lt;/strong&gt; to add &lt;strong&gt;a new entry&lt;/strong&gt; in the database and &lt;strong&gt;PUT&lt;/strong&gt; to &lt;strong&gt;update&lt;/strong&gt; something in the database.</source>
          <target state="translated">1行で、 &lt;strong&gt;POST&lt;/strong&gt;を使用してデータベースに&lt;strong&gt;新しいエントリ&lt;/strong&gt;を追加し&lt;strong&gt;、&lt;/strong&gt; &lt;strong&gt;PUT&lt;/strong&gt;を使用してデータベース内の何かを&lt;strong&gt;更新&lt;/strong&gt;します。</target>
        </trans-unit>
        <trans-unit id="935d9d64a7b6c614a61126ee51efa95f2a005750" translate="yes" xml:space="preserve">
          <source>In a very simple way I'm taking the example of the Facebook timeline.</source>
          <target state="translated">非常に簡単に言うと、私はFacebookのタイムラインを例にしています。</target>
        </trans-unit>
        <trans-unit id="5796889f185413ae8caeb602438951b389d9b045" translate="yes" xml:space="preserve">
          <source>In addition to differences suggested by others, I want to add one more.</source>
          <target state="translated">他の人が提案してくれた違いに加えて、もう一つ付け加えたいと思います。</target>
        </trans-unit>
        <trans-unit id="d0a40d3ab4c006f0fd0242d76461457c6d244bfe" translate="yes" xml:space="preserve">
          <source>In both cases, the request body contains the data for the resource to be created or updated. It should be obvious from the route names that POST is not idempotent (if you call it 3 times it will create 3 objects), but PUT is idempotent (if you call it 3 times the result is the same). PUT is often used for &quot;upsert&quot; operation (create or update), but you can always return a 404 error if you only want to use it to modify.</source>
          <target state="translated">どちらの場合も、リクエストボディには作成または更新されるリソースのデータが含まれています。ルート名から明らかなように、POSTはアイドエンプテントではない(3回呼べば3つのオブジェクトを作成する)が、PUTはアイドエンプテントである(3回呼べば結果は同じ)。PUTは &quot;upsert &quot;操作(作成や更新)によく使われますが、修正にしか使いたくない場合は必ず404エラーを返します。</target>
        </trans-unit>
        <trans-unit id="573cffeb2d758c1d002d1b38d8d410abd12cf26c" translate="yes" xml:space="preserve">
          <source>In both cases, these operations can be performed multiple times with the same results. That is the resource will not be changed by requesting the operation more than once. Hence, a true idempotent operation.
Use the HTTP POST method when:</source>
          <target state="translated">いずれの場合も、これらの操作は同じ結果で複数回実行することができます。つまり、操作を複数回要求してもリソースが変更されることはありません。したがって、真のアイドエンプテント操作となります。ときに HTTP POST メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="cbfc88d28449849d5a03796a1b27b42013a1a384" translate="yes" xml:space="preserve">
          <source>In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an &quot;INSERT&quot; query.</source>
          <target state="translated">POSTの場合、同じクエリが複数回実行されると、複数の学生レコードがデータベースに作成され、&quot;INSERT &quot;クエリの実行ごとにデータベースの状態が変化します。</target>
        </trans-unit>
        <trans-unit id="315a82166f32c0e6bdbe44329b3f92d7b32440b4" translate="yes" xml:space="preserve">
          <source>In fact, you might even be able to use AtomPub directly. While it came out of the blogging community, it is in no way restricted to blogging: it is a generic protocol for RESTfully interacting with arbitrary (nested) collections of arbitrary resources via HTTP. If you can represent your application as a nested collection of resources, then you can just use AtomPub and not worry about whether to use PUT or POST, what HTTP Status Codes to return and all those details.</source>
          <target state="translated">実際、AtomPubを直接使うこともできるかもしれません。これはブログコミュニティから生まれたものですが、決してブログに限定されたものではありません:HTTPを介して任意のリソースの任意の(入れ子になった)コレクションとRESTfullyに対話するための一般的なプロトコルです。もしあなたのアプリケーションをリソースの入れ子になったコレクションとして表現できれば、AtomPub を使うだけで、PUT を使うか POST を使うか、どの HTTP ステータスコードを返すかなどの詳細を気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="4b6a091fc94c88da148a77392e516193f6f66982" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;POST&lt;/code&gt; is used to &lt;strong&gt;create&lt;/strong&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;POST&lt;/code&gt; を使用してを&lt;strong&gt;作成&lt;/strong&gt;し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcfbe76fe288131ae25a4df6a695eb5ab43c9f7d" translate="yes" xml:space="preserve">
          <source>In practice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; that summarizes the best practices.</source>
          <target state="translated">実際には、POSTはリソースの作成に適しています。 新しく作成されたリソースのURLは、Location応答ヘッダーで返されます。 リソースを完全に更新するには、PUTを使用する必要があります。 これらはRESTful APIを設計する際のベストプラクティスであることを理解してください。 HTTP仕様自体は、リソースの作成/更新に関するいくつかの制限があるPUT / POSTの使用を制限しません。 ベストプラクティスをまとめた&lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">要するに</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="f8f5b658f1ff8b04b3e81cc7e7976e9561692c82" translate="yes" xml:space="preserve">
          <source>It is true that the R(etrieve) and D(elete) of the CRUD operations can be mapped directly to the HTTP methods GET and DELETE respectively. However, the confusion lies in the C(reate) and U(update) operations. In some cases, one can use the PUT for a create while in other cases a POST will be required. The ambiguity lies in the definition of an HTTP PUT method versus an HTTP POST method.</source>
          <target state="translated">確かに、CRUD操作のR(etrieve)とD(elete)は、それぞれHTTPメソッドGETとDELETEに直接マッピングすることができます。しかし、混乱を招くのは C(reate)と U(update)操作です。いくつかのケースでは、作成にPUTを使用することができますが、他のケースではPOSTが必要になります。この曖昧さは、HTTP PUTメソッドとHTTP POSTメソッドの定義にあります。</target>
        </trans-unit>
        <trans-unit id="a419fc1de6f5fcd3ae809038b7b9a687efa1b1dd" translate="yes" xml:space="preserve">
          <source>It now may be tempting to simply return a 303 in the event that a POST is repeated. However, the opposite is true. Returning a 303 would only make sense if multiple create requests (creating different resources) return the same content. An example would be a &quot;thank you for submitting your request message&quot; that the client need not re-download each time. RFC 7231 still maintains in section 4.2.2 that POST is not to be idempotent and continues to maintain that POST should be used for create.</source>
          <target state="translated">今では、POSTが繰り返された場合に単純に303を返すことが誘惑になっているかもしれません。しかし、その逆もあります。303 を返すのは、複数の create リクエスト (異なるリソースの作成)が同じ内容を返す場合にのみ意味があります。例としては、クライアントが毎回再ダウンロードする必要のない「リクエストメッセージを送信してくれてありがとう」があります。RFC 7231はセクション4.2.2で、POSTがidempotentであってはならないことを維持しており、 createにはPOSTを使用すべきであることを維持しています。</target>
        </trans-unit>
        <trans-unit id="82a86d7eed2a55a644d7944a1404883b9ed82ac6" translate="yes" xml:space="preserve">
          <source>Let me highlight some important parts of the spec:</source>
          <target state="translated">スペックの重要な部分を強調してみます。</target>
        </trans-unit>
        <trans-unit id="27175fcbf0cac61488369580d1a39f1dc721a45f" translate="yes" xml:space="preserve">
          <source>Let's be very clear and direct here. If you are a .NET developer working with Web API, the facts are (from the Microsoft API documentation),
&lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&lt;/a&gt;:</source>
          <target state="translated">ここで非常に明確かつ直接説明しましょう。 Web APIを使用する.NET開発者の場合、事実は（Microsoft APIのドキュメントから） &lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-webです。 -api-that-supports-crud-operations&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="857a3f4adc539ed4bbe21171ae40606e572a4ee6" translate="yes" xml:space="preserve">
          <source>Merge (Update if already existing, else insert)</source>
          <target state="translated">マージ (既に存在する場合は更新、そうでない場合は挿入)</target>
        </trans-unit>
        <trans-unit id="d6917a3435aea050d9a0d15a35f97af6e01858e4" translate="yes" xml:space="preserve">
          <source>Most of the time, you will use them like this:</source>
          <target state="translated">ほとんどの場合、このような使い方をすることになります。</target>
        </trans-unit>
        <trans-unit id="d61559b89b4cc3627f671076f6d46721d16134fc" translate="yes" xml:space="preserve">
          <source>Neither is quite right.</source>
          <target state="translated">どちらが正しいとは言えません。</target>
        </trans-unit>
        <trans-unit id="29c91aceaf4eab28f2f98e779bebb50691497adc" translate="yes" xml:space="preserve">
          <source>Note that POST &quot;creates&quot; a new element in the collection, and PUT &quot;replaces&quot; an element at a given URL, but it is a very common practice to use PUT for partial modifications, that is, use it only to update existing resources and only modify the included fields in the body (ignoring the other fields). This is technically incorrect, if you want to be REST-purist, PUT should replace the whole resource and you should use PATCH for the partial update. I personally don't care much as far as the behavior is clear and consistent across all your API endpoints.</source>
          <target state="translated">POSTはコレクション内の新しい要素を「作成」し、PUTは与えられたURLの要素を「置換」することに注意してください。しかし、部分的な変更にPUTを使うのは非常に一般的な慣習です。これは技術的に間違っています。REST-puristになりたいのであれば、PUTはリソース全体を置き換えるべきで、部分的な更新にはPATCHを使うべきです。個人的には、すべてのAPIエンドポイントで動作が明確で一貫性がある限り、あまり気にしていません。</target>
        </trans-unit>
        <trans-unit id="aed489a86f6999b5a22f73530a241b671e75935e" translate="yes" xml:space="preserve">
          <source>Note that in this case the resource
  name is not specified, the new objects
  URL path would be returned to you.</source>
          <target state="translated">この場合、リソース名が指定されていないと、新しいオブジェクトのURLパスが返されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0190e7f10880e789af039b6a119817ade48d5dc" translate="yes" xml:space="preserve">
          <source>Note that the following is an error:</source>
          <target state="translated">以下はエラーになるので注意してください。</target>
        </trans-unit>
        <trans-unit id="94ed497609bfa8317d3c8fed64915d395cd4506d" translate="yes" xml:space="preserve">
          <source>Note, however, that not all modern browsers support HTTP verbs other than GET or POST.</source>
          <target state="translated">しかし、すべての最新ブラウザが GET や POST 以外の HTTP 動詞をサポートしているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e324155fc5920c681ee3f3fe84a2ed08ebec851" translate="yes" xml:space="preserve">
          <source>Once you are using PUT you are refering to a &lt;strong&gt;resource&lt;/strong&gt; or single item, possibly inside a &lt;strong&gt;collection&lt;/strong&gt;. So when you say:</source>
          <target state="translated">PUTを使用すると、 &lt;strong&gt;コレクション&lt;/strong&gt;内の&lt;strong&gt;リソース&lt;/strong&gt;または単一のアイテムを参照することになり&lt;strong&gt;ます&lt;/strong&gt; 。 だからあなたが言うとき：</target>
        </trans-unit>
        <trans-unit id="c5516139d4acd3169adf148d2df83962379be2e8" translate="yes" xml:space="preserve">
          <source>Otherwise, use POST to initially create the object, and PUT to update the object:</source>
          <target state="translated">それ以外の場合は、最初にオブジェクトを作成するにはPOSTを使用し、オブジェクトを更新するにはPUTを使用します。</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="4413fe84411cbdf88cfc031d8a1393f608c4e15e" translate="yes" xml:space="preserve">
          <source>POST as send mail in &lt;strong&gt;post&lt;/strong&gt; office.</source>
          <target state="translated">&lt;strong&gt;郵便&lt;/strong&gt;局でメールを送信するPOST。</target>
        </trans-unit>
        <trans-unit id="1e2c64ac62aa82754ed88cbebd18c452a61f35fc" translate="yes" xml:space="preserve">
          <source>POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing -- if you think about it, creating a new member of a collection is actually a special case of this kind of update, from the collection's perspective)</source>
          <target state="translated">POSTは、既存のオブジェクトに対する非対称的な更新にも使えます(特に、全体を指定せずにオブジェクトの一部を変更するような場合です。)</target>
        </trans-unit>
        <trans-unit id="7199a1f38c458034e4e9122d80a96f6d399a16c7" translate="yes" xml:space="preserve">
          <source>POST can perform the other three functions, but then the semantics of the request will be lost on the intermediaries such as caches and proxies. This also applies to providing security on the resource, since a post's URI doesn't necessarily indicate the resource it is applying to (it can though).</source>
          <target state="translated">POSTは他の3つの機能を実行することができますが、キャッシュやプロキシのような仲介者にはリクエストのセマンティクスが失われてしまいます。これはリソースのセキュリティを提供する場合にも適用されます。</target>
        </trans-unit>
        <trans-unit id="a3841df602dc207eb894628e42ca39fa38600ef6" translate="yes" xml:space="preserve">
          <source>POST invalidates cached copies of the entire containing resource (better consistency)</source>
          <target state="translated">POST は、キャッシュされたリソース全体のコピーを無効にします。</target>
        </trans-unit>
        <trans-unit id="c22f736aab2b2863938a628162d88b4124790887" translate="yes" xml:space="preserve">
          <source>POST is basically a free form message, with its meaning being defined 'out of band'. If the message can be interpreted as adding a resource to a directory, that would be OK, but basically you need to understand the message you are sending (posting) to know what will happen with the resource.</source>
          <target state="translated">POSTは基本的には自由形式のメッセージであり、その意味は「バンドから外れた」と定義されています。メッセージがディレクトリにリソースを追加すると解釈できるのであれば問題ありませんが、基本的にはリソースがどうなるのかを知るためには、送信(投稿)するメッセージを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="50e5624274970285a79a86def7e5f8ea14309ec5" translate="yes" xml:space="preserve">
          <source>POST is good for creating new objects under a collection (and create does not need to be idempotent)</source>
          <target state="translated">POST はコレクションの下に新しいオブジェクトを作成するのに適しています (create は idempotent である必要はありません)。</target>
        </trans-unit>
        <trans-unit id="a4348a436cd7cc96fdb0094e0c165b3beab9d039" translate="yes" xml:space="preserve">
          <source>POST is like posting a letter to a mailbox or posting an email to an email queue.
PUT is like when you put an object in a cubby hole or a place on a shelf (it has a known address).</source>
          <target state="translated">POST は、メールボックスに手紙を投函したり、メールキューにメールを投函したりするようなものです。PUT は、物をキュービーホールや棚の上の場所に置くようなものです(住所がわかっている)。</target>
        </trans-unit>
        <trans-unit id="4db2a3f164214c5ab6b6162614daef8028ccda38" translate="yes" xml:space="preserve">
          <source>POST is not idempotent and the server &amp;hellip;</source>
          <target state="translated">POSTはべき等ではなく、サーバー&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="6bf075a0e5bf009d906f75d40d6c584b360d7cb7" translate="yes" xml:space="preserve">
          <source>POST is used to send data to server.</source>
          <target state="translated">POSTはサーバにデータを送信するために使用されます。</target>
        </trans-unit>
        <trans-unit id="f6c4170f0e615f9fa2848d48db2ab50f375369c3" translate="yes" xml:space="preserve">
          <source>POST:</source>
          <target state="translated">POST:</target>
        </trans-unit>
        <trans-unit id="d18f4e998d15f0ab1bd153b920ca0c74bdfeff78" translate="yes" xml:space="preserve">
          <source>POSTing twice with the same data means create two identical users with different ids. PUTing twice with the same data creates the user the first and updates him to the same state the second time (no changes). Since you end up with the same state after a &lt;code&gt;PUT&lt;/code&gt; no matter how many times you perform it, it is said to be &quot;equally potent&quot; every time - idempotent. This is useful for automatically retrying requests. No more 'are you sure you want to resend' when you push the back button on the browser.</source>
          <target state="translated">同じデータで2回POSTすると、IDが異なる2人の同一のユーザーが作成されます。 同じデータで2回PUTすると、最初にユーザーが作成され、2回目に同じ状態に更新されます（変更なし）。 &lt;code&gt;PUT&lt;/code&gt; 後は、何度実行しても同じ状態になるため、毎回「等効性」（べき等）であると言われています。 これはリクエストを自動的に再試行するのに役立ちます。 ブラウザの戻るボタンを押しても、「再送信してもよろしいですか？」</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="0774c3d8f11a1777d7cca86a15dfce5e923b8427" translate="yes" xml:space="preserve">
          <source>PUT can also be used for create if and only if you allow the client to name the resource. But since REST clients aren't supposed to make assumptions about URL structure, this is less in the intended spirit of things.</source>
          <target state="translated">クライアントがリソースに名前を付けることを許可している場合に限り、PUT は create にも使用できます。しかし、RESTクライアントはURLの構造を仮定することは想定していないので、これは物事の意図した精神に反するものです。</target>
        </trans-unit>
        <trans-unit id="53edc2f185fb0dcf741606243cd7f49687d0ba85" translate="yes" xml:space="preserve">
          <source>PUT i.e. take and &lt;strong&gt;put&lt;/strong&gt; where it was.</source>
          <target state="translated">PUT、つまり、それがあった場所に&lt;strong&gt;置き&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d17262b9924f1628e9bc6d1ceface83dc9e20080" translate="yes" xml:space="preserve">
          <source>PUT is good for updating existing objects (and update needs to be idempotent)</source>
          <target state="translated">PUT は既存のオブジェクトを更新するのに適しています (そして update は idempotent である必要があります)。</target>
        </trans-unit>
        <trans-unit id="2528780fd61687817cc4d77380ca20d9c55d5327" translate="yes" xml:space="preserve">
          <source>PUT is idempotent, so if you PUT an object twice, it has no effect.  This is a nice property, so I would use PUT when possible.</source>
          <target state="translated">PUTはidempotentなので、オブジェクトを2回PUTしても何の効果もありません。これは良いプロパティなので、可能であればPUTを使いたいところです。</target>
        </trans-unit>
        <trans-unit id="f54bdf6757feb089a4b6dd6043ed5a3812f4c969" translate="yes" xml:space="preserve">
          <source>PUT is idempotent. You can send the request 100 times and it will not matter. POST is not idempotent. If you send the request 100 times, you'll get 100 emails or 100 letters in your postal box.</source>
          <target state="translated">PUTは無意味です。リクエストを100回送っても問題ありません。POSTはidempotentではありません。リクエストを100回送れば、100通のメールや100通の手紙が郵便受けに入ってきます。</target>
        </trans-unit>
        <trans-unit id="7a94e837da966e20c0283efdebc7e6e8c4792dd1" translate="yes" xml:space="preserve">
          <source>PUT is less supported by e.g. Java ME, older browsers, firewalls</source>
          <target state="translated">PUT は、Java ME、古いブラウザ、ファイアウォールなどではあまりサポートされていません。</target>
        </trans-unit>
        <trans-unit id="beb21b8c66904ea993c9a6028ecf712630358d0d" translate="yes" xml:space="preserve">
          <source>PUT is merely a statement of what content the service should, from now on, use to render representations of the resource identified by the client; POST is a statement of what content the service should, from now on, contain (possibly duplicated) but it's up to the server how to identify that content.</source>
          <target state="translated">PUT は、クライアントによって識別されたリソースの表現をレンダリングするために、サービスが今後どのようなコンテンツを使用すべきかを記述したものに過ぎません。POST は、サービスが今後どのようなコンテンツを含むべきかを記述したものですが、そのコンテンツをどのように識別するかはサーバ次第です。</target>
        </trans-unit>
        <trans-unit id="481e4b9e200d5c2fea82c751622373a2b6a00819" translate="yes" xml:space="preserve">
          <source>PUT is used to transfer state to the server</source>
          <target state="translated">PUT は状態をサーバに転送するために使用されます。</target>
        </trans-unit>
        <trans-unit id="bad5201391f46977a9f8deb44fc372a5bc244a21" translate="yes" xml:space="preserve">
          <source>PUT refers to a resource, identified by the URI. In this case, you are updating it. It is the part of the three verbs referring to resources -- delete and get being the other two.</source>
          <target state="translated">PUTは、URIで識別されるリソースを指します。この場合は、それを更新していることになります。リソースを参照する3つの動詞のうち、deleteとgetが残りの2つである部分です。</target>
        </trans-unit>
        <trans-unit id="d444f457d29e103ad92323fcf2afb2424bd83004" translate="yes" xml:space="preserve">
          <source>PUT responses are not cacheable while POST ones are (Require Content-Location and expiration)</source>
          <target state="translated">PUT レスポンスはキャッシュ可能ですが、POST レスポンスはキャッシュできません(Require Content-Location と expiration)。</target>
        </trans-unit>
        <trans-unit id="15640c28b6c6596379e40a0e541c4b7183207d73" translate="yes" xml:space="preserve">
          <source>PUT vs. POST in REST</source>
          <target state="translated">RESTにおけるPUTとPOSTの比較</target>
        </trans-unit>
        <trans-unit id="ecd7c4f13506fe5521c5fe5e1b3db337ba4711ed" translate="yes" xml:space="preserve">
          <source>PUT:</source>
          <target state="translated">PUT:</target>
        </trans-unit>
        <trans-unit id="ecbeb70dff39883fdc79bab75f4eab0476369bf3" translate="yes" xml:space="preserve">
          <source>Performing a POST of data which has an ID which matches a resource already in the system is &amp;ldquo;a conflict with the current state of the resource.&amp;rdquo;</source>
          <target state="translated">すでにシステムにあるリソースと一致するIDを持つデータのPOSTを実行すると、「リソースの現在の状態との競合」になります。</target>
        </trans-unit>
        <trans-unit id="55c27430d43b1ad1ac779b51ba33aaaa16817d5a" translate="yes" xml:space="preserve">
          <source>Prior to PUT, clients couldn't directly know the URL that the server generated or if all it had generated any or whether the data to be sent to the server is already updated or not. PUT relieved the developer of all these headaches. PUT is idempotent, PUT handles race conditions, and PUT lets the client choose the URL.</source>
          <target state="translated">PUTの前は、クライアントはサーバが生成したURLを直接知ることができなかったし、サーバが生成したすべてのURLを知ることも、サーバに送信するデータがすでに更新されているかどうかを知ることもできませんでした。PUTは開発者のこれらの頭痛の種をすべて取り除きました。PUT はアイドエンプテントであり、PUT は競合条件を処理し、PUT はクライアントに URL を選択させることができます。</target>
        </trans-unit>
        <trans-unit id="500abc23a1f880a1d70f33cc1a5912ba903fcf59" translate="yes" xml:space="preserve">
          <source>REST is a &lt;em&gt;very&lt;/em&gt; high-level concept. In fact, it doesn't even mention HTTP at all!</source>
          <target state="translated">RESTは&lt;em&gt;非常に&lt;/em&gt;高度な概念です。 実際、HTTPについてはまったく触れられていません！</target>
        </trans-unit>
        <trans-unit id="f3f878fdda60ba178358813e7e7547df7ca8bed3" translate="yes" xml:space="preserve">
          <source>RFC 5789 says about PATCH (since 1995):</source>
          <target state="translated">RFC 5789はPATCHについて述べています(1995年以降)。</target>
        </trans-unit>
        <trans-unit id="2240960be744587b090255e994fafdd819cc51d2" translate="yes" xml:space="preserve">
          <source>Readers new to this topic will be struck by the endless discussion about what you &lt;em&gt;should&lt;/em&gt; do, and the relative absence of lessons from experience. The fact that REST is &quot;preferred&quot; over SOAP is, I suppose, a high-level learning from experience, but goodness we must have progressed from there? It's 2016. Roy's dissertation was in 2000. What have we developed? Was it fun? Was it easy to integrate with? To support? Will it handle the rise of smartphones and flaky mobile connections?</source>
          <target state="translated">このトピックを初めて読む読者は、あなた&lt;em&gt;が&lt;/em&gt;何を&lt;em&gt;すべき&lt;/em&gt;かについての無限の議論、そして経験からの教訓の相対的な欠如に衝撃を受けます。 SOAPよりもRESTが「推奨される」という事実は、経験からの高度な学習だと思いますが、そこから進歩したに違いないのでしょうか。 それは2016年です。ロイの論文は2000年でした。何を開発しましたか？ 楽しかったですか？ 統合は簡単でしたか？ サポートするには？ スマートフォンや不安定なモバイル接続の増加に対応しますか？</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="af48dc320f6330ed03797587a11eef43f0ec6f79" translate="yes" xml:space="preserve">
          <source>Remember, REST is a set of conventions and guidelines to keep your API simple. If you end up with a complicated work-around just to check the &quot;RESTfull&quot; box then you are defeating the purpose ;)</source>
          <target state="translated">RESTはAPIをシンプルに保つための規約とガイドラインのセットであることを覚えておいてください。もし、&quot;RESTfull &quot;ボックスをチェックするためだけに複雑な回避策を考えてしまうと、目的を達成できないことになってしまいます。)</target>
        </trans-unit>
        <trans-unit id="ee7cc50d6752f70e6ef133296cf031acbf88d94d" translate="yes" xml:space="preserve">
          <source>Ruby on Rails 4.0 will use the 'PATCH' method instead of PUT to do partial updates.</source>
          <target state="translated">Ruby on Rails 4.0では、部分的な更新を行うためにPUTではなく'PATCH'メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="e1a55a92c976da44c042e91aaa4d8b45fd7ebc14" translate="yes" xml:space="preserve">
          <source>Simple rule of thumb: Use POST to create, use PUT to update.</source>
          <target state="translated">経験則は簡単です。作成にはPOSTを使い、更新にはPUTを使う。</target>
        </trans-unit>
        <trans-unit id="563433492d9997914d4d5639b5bd77063df84eaa" translate="yes" xml:space="preserve">
          <source>Since the important part is for the client to understand the server has the resource and to take appropriate action. This is a &amp;ldquo;situation(s) where it is expected that the user might be able to resolve the conflict and resubmit the request.&amp;rdquo;</source>
          <target state="translated">重要な部分は、クライアントがサーバーにリソースがあることを理解し、適切なアクションをとることです。 これは「ユーザーが競合を解決してリクエストを再送信できることが期待される状況」です。</target>
        </trans-unit>
        <trans-unit id="214742f8ecec0788b74789ec5780c31fcabbb394" translate="yes" xml:space="preserve">
          <source>So you use POST and probably, but not necessary PUT for resource creation. You don't have to support both. For me POST is perfectly enough. So it is a design decision.</source>
          <target state="translated">つまり、リソースの作成にはPOSTとおそらく、必要ではないがPUTを使うわけですね。両方をサポートする必要はありません。私にとってはPOSTで十分です。なので、設計上の判断になります。</target>
        </trans-unit>
        <trans-unit id="312dad788b38db2f97ab20722cebe3f87855dfa4" translate="yes" xml:space="preserve">
          <source>So, which one should be used to create a resource? Or one needs to support both?</source>
          <target state="translated">では、リソースの作成にはどちらを使うべきなのでしょうか?それともどちらかが両方に対応する必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="af333de22f5db2954bfe57966628566c2cb3ee43" translate="yes" xml:space="preserve">
          <source>So: To save an existing user, or one where the client generates the id and it's been verified that the id is unique:</source>
          <target state="translated">ということです。既存のユーザを保存するため、またはクライアントがIDを生成し、そのIDが一意であることが確認されているユーザを保存するため。</target>
        </trans-unit>
        <trans-unit id="a8710dbdab40fac5c2f6093ab0a397321add575c" translate="yes" xml:space="preserve">
          <source>Social Media/Network Analogy:</source>
          <target state="translated">ソーシャルメディアネットワークアナロジー。</target>
        </trans-unit>
        <trans-unit id="aa6e7d148420cbd536359dd8922d3a773a333631" translate="yes" xml:space="preserve">
          <source>Some considerations:</source>
          <target state="translated">いくつかの考慮事項があります。</target>
        </trans-unit>
        <trans-unit id="f07350c10b92f7bbca1cebbb0c1aaadbf6301a75" translate="yes" xml:space="preserve">
          <source>Some other considerations:</source>
          <target state="translated">他にもいくつかの考慮事項があります。</target>
        </trans-unit>
        <trans-unit id="1392b1cbf3bb0fbae1580de51f28c0eb49cc1f97" translate="yes" xml:space="preserve">
          <source>Spec:</source>
          <target state="translated">Spec:</target>
        </trans-unit>
        <trans-unit id="9d63a661c96623ad056cc93701a94dbcd5290eef" translate="yes" xml:space="preserve">
          <source>Step 6 is where people commonly get confused about what to do. However, there is no reason to create a kludge to solve this issue. Instead, HTTP can be used as specified in &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616&lt;/a&gt; and the server replies:</source>
          <target state="translated">ステップ6では、一般的に何をすべきかについて混乱します。 ただし、この問題を解決するためにkludgeを作成する理由はありません。 代わりに、 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616で&lt;/a&gt;指定されているようにHTTPを使用でき、サーバーは次のように応答します。</target>
        </trans-unit>
        <trans-unit id="b49764080a9692f4a67935d54ce3bb45209b490c" translate="yes" xml:space="preserve">
          <source>Student Id is auto generated.</source>
          <target state="translated">学生IDは自動生成されます。</target>
        </trans-unit>
        <trans-unit id="aca4c099b5e77d0411d947634e38f0631bf9e86a" translate="yes" xml:space="preserve">
          <source>Successive delete requests can see and process the original confirmation, without hitting a 404 error. If things take longer than expected, we can respond provisionally, and we have a place where the client can check back for the definitive result. The nicest part of this pattern is its Kung-Fu (Panda) property. We take a weakness, the propensity for clients to repeat a request any time they don't understand the response, and turn it into &lt;em&gt;a strength&lt;/em&gt; :-)</source>
          <target state="translated">連続した削除リクエストは、404エラーに遭遇することなく、元の確認を表示および処理できます。 予想よりも時間がかかる場合は、暫定的に対応でき、クライアントが最終的な結果を確認できる場所があります。 このパターンの最も良い部分は、そのカンフー（パンダ）プロパティです。 私たちは弱点を取り、クライアントが応答を理解できないときはいつでも要求を繰り返し、それを&lt;em&gt;強みに&lt;/em&gt;変えます:-)</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="b9802a34f75ab08b9f79a147b7c88bf20e2dd462" translate="yes" xml:space="preserve">
          <source>Sure you &quot;can&quot; use &quot;POST&quot; to update, but just follow the conventions laid out for you with your given framework. In my case it is .NET / Web API, so &lt;strong&gt;PUT is for UPDATE&lt;/strong&gt; there is no debate.</source>
          <target state="translated">確かに「POST」を使用して更新できますが、指定されたフレームワークでレイアウトされた規則に従ってください。 私の場合は.NET / Web APIなので、 &lt;strong&gt;PUTはUPDATE用&lt;/strong&gt;であり、議論はありません。</target>
        </trans-unit>
        <trans-unit id="88f36ec6e839653d0f7569117f42e1085634abaa" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;PUT&lt;/code&gt; is used to &lt;strong&gt;create or update&lt;/strong&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;PUT&lt;/code&gt; はの&lt;strong&gt;作成または更新に&lt;/strong&gt;使用され&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6228527a9fe538603ee8860a20980509cae0390f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/strong&gt; method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the &lt;code&gt;Request-URI&lt;/code&gt; in the &lt;code&gt;Request-Line&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/strong&gt;メソッドを使用して、オリジンサーバーがリクエストに含まれるエンティティを、 &lt;code&gt;Request-Line&lt;/code&gt; の &lt;code&gt;Request-URI&lt;/code&gt; で識別されるリソースの新しい下位として受け入れることをリクエストします。</target>
        </trans-unit>
        <trans-unit id="fbf25e1a44ff44b0b030b51303b10b2f4e6c0844" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/strong&gt; method requests that the enclosed entity be stored under the supplied &lt;code&gt;Request-URI&lt;/code&gt;. If the &lt;code&gt;Request-URI&lt;/code&gt; refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the &lt;code&gt;Request-URI&lt;/code&gt; does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/strong&gt;メソッドは、囲まれたエンティティが指定された &lt;code&gt;Request-URI&lt;/code&gt; の下に格納されることを要求します。 &lt;code&gt;Request-URI&lt;/code&gt; が既存のリソースを参照している場合、囲まれたエンティティは、起点サーバーにあるエンティティの変更バージョンと見なされるべきです（SHOULD）。 &lt;code&gt;Request-URI&lt;/code&gt; が既存のリソースを指さず、そのURIが要求元のユーザーエージェントによって新しいリソースとして定義できる場合、オリジンサーバーはそのURIでリソースを作成できます。</target>
        </trans-unit>
        <trans-unit id="59c1ac24b7aebd8b407e3f0c9ff99488ea7968e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;POST&lt;/strong&gt; method is used to request that the origin server &lt;strong&gt;accept&lt;/strong&gt; the entity enclosed in the request as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; subordinate&lt;/strong&gt; of the resource identified by the Request-URI in the Request-Line</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt;メソッドを使用して、オリジンサーバーがリクエストに含まれるエンティティを、Request-LineのRequest-URIで識別されるリソースの&lt;strong&gt;&lt;em&gt;新しい&lt;/em&gt;下位&lt;/strong&gt;として&lt;strong&gt;受け入れる&lt;/strong&gt;ことをリクエストします。</target>
        </trans-unit>
        <trans-unit id="c563bf37c1b157d8576106b8f94786d60d4a88a8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;PUT&lt;/strong&gt; method requests that the enclosed entity be &lt;strong&gt;stored&lt;/strong&gt; under the supplied Request-URI. If the Request-URI refers to an &lt;strong&gt;already existing&lt;/strong&gt; resource, the enclosed entity SHOULD be considered as a &lt;strong&gt;modified version&lt;/strong&gt; of the one residing on the origin server. If the Request-URI does &lt;strong&gt;not point to an existing&lt;/strong&gt; resource, and that URI is &lt;strong&gt;capable&lt;/strong&gt; of being defined as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; resource&lt;/strong&gt; by the requesting user agent, the origin server can &lt;strong&gt;create&lt;/strong&gt; the resource with that URI.&quot;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt;メソッドは、囲まれたエンティティが指定&lt;strong&gt;さ&lt;/strong&gt;れたRequest-URIの下に&lt;strong&gt;格納さ&lt;/strong&gt;れることを要求します。 Request-URIが&lt;strong&gt;既存の&lt;/strong&gt;リソースを参照して&lt;strong&gt;いる&lt;/strong&gt;場合、囲まれたエンティティは、起点サーバーにあるエンティティの&lt;strong&gt;変更バージョン&lt;/strong&gt;と見なされるべきです（SHOULD）。 Request-URIが&lt;strong&gt;既存の&lt;/strong&gt;リソースを&lt;strong&gt;指さず&lt;/strong&gt; 、そのURIが要求元のユーザーエージェントによって&lt;strong&gt;&lt;em&gt;新しい&lt;/em&gt;リソース&lt;/strong&gt;として定義&lt;strong&gt;できる&lt;/strong&gt;場合、オリジンサーバーはそのURIでリソースを&lt;strong&gt;作成&lt;/strong&gt;でき&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="59fcd39418146017bc9d79b2463c3bd0da6fb592" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
    &lt;code&gt;created&lt;/code&gt; or &lt;code&gt;replaced&lt;/code&gt; with the state defined by the representation
    enclosed in the request message payload.</source>
          <target state="translated">PUTメソッドは、ターゲットリソースの状態を &lt;code&gt;created&lt;/code&gt; か、要求メッセージのペイロードで囲まれた表現で定義された状態に &lt;code&gt;replaced&lt;/code&gt; を要求します。</target>
        </trans-unit>
        <trans-unit id="e77dcb77c2b94fc15160e4b361047201bc47a791" translate="yes" xml:space="preserve">
          <source>The RFC reads like this:</source>
          <target state="translated">RFCは次のように読みます。</target>
        </trans-unit>
        <trans-unit id="2bf09923cd40e9a4020e710d08ab29ff70e0f921" translate="yes" xml:space="preserve">
          <source>The client POST a new resource to the server.</source>
          <target state="translated">クライアントはサーバーに新しいリソースをPOSTします。</target>
        </trans-unit>
        <trans-unit id="6d21b96b8e9dc8ceda9663e50081fd866f4a8784" translate="yes" xml:space="preserve">
          <source>The client does not have a URL for the resource (therefore PUT is not an option) and repeats the POST.</source>
          <target state="translated">クライアントはリソースのURLを持っておらず(したがってPUTはオプションではありません)、POSTを繰り返します。</target>
        </trans-unit>
        <trans-unit id="dab9c53b7a8f4efbb9c76b8f8b0c3647ff5ea29b" translate="yes" xml:space="preserve">
          <source>The client never receives the response.</source>
          <target state="translated">クライアントが応答を受け取ることはありません。</target>
        </trans-unit>
        <trans-unit id="7e77aa23ca0f2f2521e9d88d6afd4e68b94dfbe8" translate="yes" xml:space="preserve">
          <source>The content type &quot;application/x-www-form-urlencoded&quot; is inefficient
  for sending large quantities of binary data or text containing
  non-ASCII characters. The content type &quot;multipart/form-data&quot; should be
  used for submitting forms that contain files, non-ASCII data, and
  binary data.</source>
          <target state="translated">コンテンツタイプ「applicationx-www-form-urlencoded」は、大量のバイナリデータや非ASCII文字を含むテキストを送信する場合には効率が悪い。ファイル、非ASCIIデータ、バイナリデータを含むフォームの送信には、コンテンツタイプ &quot;multipartform-data &quot;を使用すべきである。</target>
        </trans-unit>
        <trans-unit id="c00e08de50ba7cbbdbcec8cf8cc194d4e2c70887" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</source>
          <target state="translated">POSTリクエストとPUTリクエストの根本的な違いは、Request-URIの意味の違いに反映されています。POSTリクエストのURIは、囲まれたエンティティを処理するリソースを識別します。そのリソースは、データを受け取るプロセス、他のプロトコルへのゲートウェイ、 またはアノテーションを受け取る別個のエンティティであるかもしれない。対照的に、PUTリクエストのURIはリクエストで囲まれたエンティティを 識別する。ユーザーエージェントはどのURIが意図されているかを知っており、サーバー はそのリクエストを他のリソースに適用しようとしてはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="531d093617728697be6cb081a0052d11e9261dcc" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,</source>
          <target state="translated">POSTリクエストとPUTリクエストの根本的な違いは、Request-URIの意味の違いに反映されています。POSTリクエストのURIは、囲まれたエンティティを処理するリソースを識別します。そのリソースは、データを受け取るプロセス、他のプロトコルへのゲートウェイ、 またはアノテーションを受け取る別個のエンティティであるかもしれない。対照的に、PUTリクエストのURIはリクエストで囲まれたエンティティを 識別する。ユーザーエージェントはどのURIが意図されているかを知っており、サーバー はそのリクエストを他のリソースに適用しようとしてはならない[MUST NOT]。サーバーがリクエストを別のURIに適用することを望む場合、サーバーはそのリク エストを他のリソースに適用しようとしてはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="9a92f77699786e960e9bee1d8eacf143a2e57922" translate="yes" xml:space="preserve">
          <source>The idea of a &lt;em&gt;RESTful-URL&lt;/em&gt; is actually a violation of REST as the server is in charge of the URL structure and should be free to decide how to use it to avoid coupling. If this confuses you read about the significance of self discovery on API design.</source>
          <target state="translated">&lt;em&gt;RESTful-URL&lt;/em&gt;の考え方は、サーバーがURL構造を担当しており、カップリングを回避するためにそれをどのように使用するかを自由に決定できるため、実際にはRESTの違反です。 これで混乱した場合は、API設計における自己発見の重要性について読んでください。</target>
        </trans-unit>
        <trans-unit id="08c88ada7f30da94a298cf8074dd8cb30fa5608e" translate="yes" xml:space="preserve">
          <source>The most important consideration is &lt;em&gt;reliability&lt;/em&gt;. If a POST message gets lost the state of the system is undefined. Automatic recovery is impossible. For PUT messages, the state is undefined only until the first successful retry.</source>
          <target state="translated">最も重要な考慮事項は&lt;em&gt;信頼性&lt;/em&gt;です。 POSTメッセージが失われた場合、システムの状態は未定義です。 自動回復は不可能です。 PUTメッセージの場合、最初の再試行が成功するまで、状態は未定義です。</target>
        </trans-unit>
        <trans-unit id="70a1801f56d9e3b89398dd57a765b43ab4ffd957" translate="yes" xml:space="preserve">
          <source>The relevant specification for PUT and POST is &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</source>
          <target state="translated">PUTおよびPOSTに関連する仕様は&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616&amp;sect;9.5ffです。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5212416a9c7e401d69b6999879d0f06d6e6c6b8f" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
  state of the resource. This code is only allowed in situations where
  it is expected that the user might be able to resolve the conflict and
  resubmit the request. The response body SHOULD include enough</source>
          <target state="translated">リソースの現在の状態との競合のためにリクエストを完了できませんでした。このコードは、ユーザーがコンフリクトを解決してリクエストを再送できるかもしれない と予想される状況でのみ許可される。応答ボディは十分な</target>
        </trans-unit>
        <trans-unit id="d5fcf6a88ce59329f97adb1fc601b9b08db15db3" translate="yes" xml:space="preserve">
          <source>The semantics are supposed be different, in that &quot;PUT&quot;, like &quot;GET&quot; is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.</source>
          <target state="translated">つまり、同じPUTリクエストを複数回実行しても、一度だけ実行したかのような結果になるということです。</target>
        </trans-unit>
        <trans-unit id="6497cf669dc224da5094578e5e54fa6ced3cdbc7" translate="yes" xml:space="preserve">
          <source>The server does the business, returns the response &lt;em&gt;and stores it against the agreed action URI&lt;/em&gt;. If anything goes wrong, the client repeats the request (natural behaviour!), and if the server has already seen it, it repeats the stored response &lt;em&gt;and does nothing else&lt;/em&gt;.</source>
          <target state="translated">サーバーはビジネスを行い、応答&lt;em&gt;を&lt;/em&gt;返し&lt;em&gt;、合意されたアクションURIに対して&lt;/em&gt;それ&lt;em&gt;を格納し&lt;/em&gt;ます。 何か問題が発生した場合、クライアントはリクエストを繰り返します（自然な動作です）。サーバーがすでにリクエストを確認している場合は、保存されているレスポンス&lt;em&gt;を&lt;/em&gt;繰り返し、 &lt;em&gt;それ以外は何もしません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5da1be1c708bb16e849af08a7fb0aa8d0d4c1309" translate="yes" xml:space="preserve">
          <source>The server is unaware the client has not received the response.</source>
          <target state="translated">サーバーは、クライアントが応答を受信していないことに気付いていません。</target>
        </trans-unit>
        <trans-unit id="62a97e57f72e643adc7cc713734b78e46c053ea2" translate="yes" xml:space="preserve">
          <source>The server processes the request and sends a response.</source>
          <target state="translated">サーバーはリクエストを処理し、レスポンスを送信します。</target>
        </trans-unit>
        <trans-unit id="ad17da286154778c13914cd41e9cf66091180592" translate="yes" xml:space="preserve">
          <source>There seems to always be some confusion as to when to use the HTTP POST versus the HTTP PUT method for REST services. Most developers will try to associate CRUD operations directly to HTTP methods. I will argue that this is not correct and one can not simply associate the CRUD concepts to the HTTP methods. That is:</source>
          <target state="translated">REST サービスで HTTP POST メソッドと HTTP PUT メソッドのどちらを使用するかについては、常にいくつかの混乱があるようです。ほとんどの開発者は CRUD 操作を HTTP メソッドに直接関連付けようとします。これは正しくなく、CRUD の概念を単純に HTTP メソッドに関連付けることはできません。つまり、CRUDの概念をHTTPメソッドに関連付けることはできません。</target>
        </trans-unit>
        <trans-unit id="7612d7c41fbfbe6d8a2310c67de97a21fbe00850" translate="yes" xml:space="preserve">
          <source>Therefore: &lt;strong&gt;PUT&lt;/strong&gt; is only a candidate for CREATE where the client already knows the url before the resource is created. Eg. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; as the title is used as the resource key</source>
          <target state="translated">したがって、 &lt;strong&gt;PUT&lt;/strong&gt;は、リソースが作成される前にクライアントがURLをすでに知っているCREATEの候補にすぎません。 例えば。 &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; (タイトルがリソースキーとして使用されるため）</target>
        </trans-unit>
        <trans-unit id="ea0f8ddfd30845a4b1c6a9e4d8ca5de38b2ab4ea" translate="yes" xml:space="preserve">
          <source>This forces the API to avoid state transition problems with multiple clients updating a single resource, and matches more nicely with event sourcing and CQRS. When the work is done asynchronously, POSTing the transformation and waiting for it to be applied seems appropriate.</source>
          <target state="translated">これは、複数のクライアントが単一のリソースを更新する際の状態遷移の問題を回避するためにAPIを強制的に使用し、イベントソーシングやCQRSとよりうまくマッチします。作業が非同期で行われる場合、変換をPOSTして適用されるのを待つのが適切だと思われます。</target>
        </trans-unit>
        <trans-unit id="0d513503c5d27d970dedbc3a017aa5dfc6730d1b" translate="yes" xml:space="preserve">
          <source>This is what AtomPub has to say about resource creation (section 9.2):</source>
          <target state="translated">これは、AtomPubがリソースの作成について言っていることです(9.2節)。</target>
        </trans-unit>
        <trans-unit id="db06c4e9bb7f4493ec87367452486878b32df472" translate="yes" xml:space="preserve">
          <source>This jibes with the other advice here, that PUT is best applied to resources that already have a name, and POST is good for creating a new object under an existing resource (and letting the server name it).</source>
          <target state="translated">これは、PUTはすでに名前があるリソースに適用するのが最適で、POSTは既存のリソースの下に新しいオブジェクトを作成するのに適しています(そしてサーバに名前を付けさせます)。</target>
        </trans-unit>
        <trans-unit id="329ccd5deda6ee5083da67216837de43b64d3560" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI of the Collection.</source>
          <target state="translated">コレクションにメンバーを追加するには、クライアントはコレクションの URI に POST リクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="8a44f83e9442ef60d290f2c8799f5cc060ff1e23" translate="yes" xml:space="preserve">
          <source>To overwrite an existing resource:</source>
          <target state="translated">既存のリソースを上書きします。</target>
        </trans-unit>
        <trans-unit id="300c31c8ca811ac31b1e4b0cbcc5df25674e9c0e" translate="yes" xml:space="preserve">
          <source>To understand it we need to question why PUT was required, what were the problems PUT was trying to solve that POST couldn't.</source>
          <target state="translated">それを理解するためには、なぜPUTが必要だったのか、POSTでは解決できなかった問題をPUTが解決しようとしていたのは何だったのか、という疑問を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="2b77e3950318466e7b1306d760c2096fcdcc38f3" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URI): Generic Syntax and Semantics</source>
          <target state="translated">統一的なリソース識別子 (URI)。一般的な構文と意味</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="e2fbf38e05ed6d395ec7f6efdfd2ea298e430b2a" translate="yes" xml:space="preserve">
          <source>Updates the resource with &lt;strong&gt;existingResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">/ resources URIまたは&lt;strong&gt;collection&lt;/strong&gt;で、 &lt;strong&gt;既存&lt;/strong&gt;のリソースIDを識別子として使用してリソースを更新します。</target>
        </trans-unit>
        <trans-unit id="f8079d8e5134eb77a5128a4f32d06200addab2ae" translate="yes" xml:space="preserve">
          <source>Use POST to create, and PUT to update. That's how Ruby on Rails is doing it, anyway.</source>
          <target state="translated">作成にはPOSTを使い、更新にはPUTを使う。とにかくRuby on Railsはそういうことをしています。</target>
        </trans-unit>
        <trans-unit id="7e3328f33c6c2ad3028951ba9c219f5262089b33" translate="yes" xml:space="preserve">
          <source>Used to create a resource, or
  overwrite it.  While you specify the
  resources new URL.</source>
          <target state="translated">リソースの作成や上書きに使用します。リソースの新しいURLを指定している間。</target>
        </trans-unit>
        <trans-unit id="caad456be6f2e43799931b874b916e57d669f040" translate="yes" xml:space="preserve">
          <source>Used to modify and update a resource</source>
          <target state="translated">リソースの変更と更新に使用します。</target>
        </trans-unit>
        <trans-unit id="534d6f360955fe24940d916537fd5f5d03013712" translate="yes" xml:space="preserve">
          <source>Useful when a resource's URL is known</source>
          <target state="translated">リソースのURLがわかっている場合に便利</target>
        </trans-unit>
        <trans-unit id="87dffc568fb442d1ab8b5daa3edd8813475735c7" translate="yes" xml:space="preserve">
          <source>Useful when the resource's URL is
unknown</source>
          <target state="translated">リソースのURLが不明な場合に便利</target>
        </trans-unit>
        <trans-unit id="d2f00b419fb58779569430425949be8c2946ab81" translate="yes" xml:space="preserve">
          <source>When dealing with REST and URI as general, you have &lt;strong&gt;generic&lt;/strong&gt; on the &lt;em&gt;left&lt;/em&gt; and &lt;strong&gt;specific&lt;/strong&gt; on the &lt;em&gt;right&lt;/em&gt;. The &lt;strong&gt;generics&lt;/strong&gt; are usually called &lt;strong&gt;collections&lt;/strong&gt; and the more &lt;strong&gt;specific&lt;/strong&gt; items can be called &lt;strong&gt;resource&lt;/strong&gt;. Note that a &lt;strong&gt;resource&lt;/strong&gt; can contain a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">RESTとURIを一般的に扱う場合、 &lt;em&gt;左側に&lt;/em&gt; &lt;strong&gt;ジェネリック&lt;/strong&gt; 、 &lt;em&gt;右側に&lt;/em&gt; &lt;strong&gt;特定のもの&lt;/strong&gt;を使用し&lt;em&gt;ます&lt;/em&gt; 。 &lt;strong&gt;ジェネリック&lt;/strong&gt;は通常&lt;strong&gt;コレクション&lt;/strong&gt;と呼ばれ、より&lt;strong&gt;具体的な&lt;/strong&gt;アイテムは&lt;strong&gt;リソース&lt;/strong&gt;と呼ばれます。 &lt;strong&gt;リソースに&lt;/strong&gt;は&lt;strong&gt;コレクション&lt;/strong&gt;を含めることができます。</target>
        </trans-unit>
        <trans-unit id="14ad7c96823b5a1d653bec9e758d08db87c5209c" translate="yes" xml:space="preserve">
          <source>When you POST to a resource at a particular URL, often you are posting a related piece of information to that URL. This implies that the resource at the URL already exists.</source>
          <target state="translated">特定のURLのリソースにPOSTするとき、多くの場合、そのURLに関連する情報を投稿しています。これは、そのURLのリソースが既に存在することを意味します。</target>
        </trans-unit>
        <trans-unit id="f6bf84ba90320cefe0d8fa5d18b1d11fe5272e46" translate="yes" xml:space="preserve">
          <source>When you PUT a resource at a particular URL what happens is that it should get saved at that URL, or something along those lines.</source>
          <target state="translated">特定のURLにリソースをPUTしたときに何が起こるかというと、そのURLに保存されているはずです。</target>
        </trans-unit>
        <trans-unit id="03669db6e556a71ab819d40f836e5bd27373b8b6" translate="yes" xml:space="preserve">
          <source>When you can't fully trust the client to do the right thing, it would be 
more appropriate to use &lt;strong&gt;POST&lt;/strong&gt; to create a new item and then send the URL back to the client in the response.</source>
          <target state="translated">クライアントが正しいことを実行することを完全に信頼できない場合は、 &lt;strong&gt;POST&lt;/strong&gt;を使用して新しいアイテムを作成し、応答でURLをクライアントに送信する方が適切です。</target>
        </trans-unit>
        <trans-unit id="22766c7cfca9b0f8a5c36dfb8f98f375b88a60a7" translate="yes" xml:space="preserve">
          <source>When you use POST you are &lt;strong&gt;always&lt;/strong&gt; refering to a &lt;strong&gt;collection&lt;/strong&gt;, so whenever you say:</source>
          <target state="translated">POSTを使用するときは&lt;strong&gt;常に&lt;/strong&gt; &lt;strong&gt;コレクション&lt;/strong&gt;を参照しているので、次のように言うときはいつでも：</target>
        </trans-unit>
        <trans-unit id="e380bb1d3e7c031588ca3a3c5bf3f6f0d241ddcf" translate="yes" xml:space="preserve">
          <source>Which is used is left up to you.  But just remember to use the right one depending on what object you are referencing in the request.</source>
          <target state="translated">どちらを使うかはあなた次第です。しかし、リクエストで参照しているオブジェクトに応じて正しいものを使うことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="ebbb5885abc4335ac57b9aa863e7c08abfc8ea5e" translate="yes" xml:space="preserve">
          <source>Which means if you have to submit</source>
          <target state="translated">ということは、もし</target>
        </trans-unit>
        <trans-unit id="1e394f3df68b2548c835945807e40cf42b367d8e" translate="yes" xml:space="preserve">
          <source>While there is probably an agnostic way to describe these, it does seem to be conflicting with various statements from answers to websites.</source>
          <target state="translated">これらを記述するには不可知論的な方法があるのでしょうが、ウェブサイトへの回答から様々な記述と矛盾しているように思えます。</target>
        </trans-unit>
        <trans-unit id="a5bc20d2d4325f529ff7555db67ccca89565a4cd" translate="yes" xml:space="preserve">
          <source>Wikipedia - REST</source>
          <target state="translated">ウィキペディア-REST</target>
        </trans-unit>
        <trans-unit id="386e23f3812d1bdded28437f31996a6a569b6fd3" translate="yes" xml:space="preserve">
          <source>With &amp;ldquo;REST without PUT&amp;rdquo; technique, the idea is that consumers are
  forced to post new 'nounified' request resources. As discussed
  earlier, changing a customer&amp;rsquo;s mailing address is a POST to a new
  &amp;ldquo;ChangeOfAddress&amp;rdquo; resource, not a PUT of a &amp;ldquo;Customer&amp;rdquo; resource with a
  different mailing address field value.</source>
          <target state="translated">「PUTなしのREST」手法を使用すると、消費者は新しい「統一された」要求リソースを投稿する必要があります。 前述のように、顧客の郵送先住所の変更は、新しい「ChangeOfAddress」リソースへのPOSTであり、異なる郵送先住所フィールド値を持つ「顧客」リソースのPUTではありません。</target>
        </trans-unit>
        <trans-unit id="53a0df456d0b82cfb20df7d1c7dcda70c26fd29c" translate="yes" xml:space="preserve">
          <source>With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.</source>
          <target state="translated">POSTでは、2つのリクエストが同時に来てURLを変更することができ、それらはオブジェクトの異なる部分を更新することができます。</target>
        </trans-unit>
        <trans-unit id="bcec0b85a95c09c1d9aa73bbac93122064920f3c" translate="yes" xml:space="preserve">
          <source>With POST, you're posting to the address of the QUEUE or COLLECTION. With PUT, you're putting to the address of the ITEM.</source>
          <target state="translated">POST では、QUEUE または COLLECTION のアドレスに投稿します。PUTでは、ITEMのアドレスに投稿します。</target>
        </trans-unit>
        <trans-unit id="e394766f3d8f38a5425a15f2e94e15f94cff2588" translate="yes" xml:space="preserve">
          <source>With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.</source>
          <target state="translated">PUTでは、同じクエリが複数回または1回実行された場合、STUDENTテーブルの状態は変わりません。</target>
        </trans-unit>
        <trans-unit id="9f13e4060016ff9f870bc818b8b5bcb9592a2292" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;POST&lt;/code&gt; to example.com/users since you don't know the &lt;code&gt;URL&lt;/code&gt; of the user yet, you want the server to create it.</source>
          <target state="translated">ユーザーの &lt;code&gt;URL&lt;/code&gt; がまだわからないので、example.com / usersに &lt;code&gt;POST&lt;/code&gt; します。サーバーで作成します。</target>
        </trans-unit>
        <trans-unit id="a3e29206f13fd7f313ac3a03984149fd94f809d9" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;PUT&lt;/code&gt; to example.com/users/id since you want to replace/create a &lt;em&gt;specific&lt;/em&gt; user.</source>
          <target state="translated">&lt;em&gt;特定の&lt;/em&gt;ユーザーを置換/作成したいので、example.com / users / &lt;code&gt;PUT&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="cd925494376cae5537a3d23703b024e74bd08383" translate="yes" xml:space="preserve">
          <source>You can find assertions on the web that say</source>
          <target state="translated">というアサーションをウェブ上で見つけることができます。</target>
        </trans-unit>
        <trans-unit id="deb01051624c8536f5e270d282325b0dbf3553ef" translate="yes" xml:space="preserve">
          <source>You can update or create a resource with PUT with the same object URL</source>
          <target state="translated">同じオブジェクトURLのPUTでリソースを更新または作成することができます。</target>
        </trans-unit>
        <trans-unit id="50c70a21ef7f357ae45ec172565f2b589fc30211" translate="yes" xml:space="preserve">
          <source>You could though do something like
  this to create a resources using POST:</source>
          <target state="translated">POSTを使ってリソースを作成するには、次のようなことをすることができます。</target>
        </trans-unit>
        <trans-unit id="8dddfd0893267c4dc2c1565595682d6ee7fe0449" translate="yes" xml:space="preserve">
          <source>You do not need to support both PUT and POST.</source>
          <target state="translated">PUTとPOSTの両方をサポートする必要はありません。</target>
        </trans-unit>
        <trans-unit id="1a70c96038989ab75bed3ead389a54345761a879" translate="yes" xml:space="preserve">
          <source>You have to ask &quot;what are you performing the action to?&quot; to distinguish what you should be using. Let's assume you're designing an API for asking questions.  If you want to use POST then you would do that to a list of questions. If you want to use PUT then you would do that to a particular question.</source>
          <target state="translated">何を使うべきかを区別するために、&quot;何のためにアクションを実行しているのか?&quot;と尋ねる必要があります。質問をするためのAPIを設計しているとしましょう。POSTを使用したい場合、質問のリストに対してこれを行います。もしPUTを使用したい場合は特定の質問に対して行います。</target>
        </trans-unit>
        <trans-unit id="aab05f743ff11af397a41e6a50b339a3a9b253b8" translate="yes" xml:space="preserve">
          <source>You will quickly spot the similarity with promises: we create and return the placeholder for the result before doing anything. Also like a promise, an action can succeed or fail one time, but its result can be fetched repeatedly.</source>
          <target state="translated">何かをする前に結果のプレースホルダを作成して返します。また、約束のように、アクションは一度だけ成功したり失敗したりしますが、その結果は繰り返し取得することができます。</target>
        </trans-unit>
        <trans-unit id="f363cc5672437cee525e493743ecf9b56f18170d" translate="yes" xml:space="preserve">
          <source>files, non-ASCII data, and binary data</source>
          <target state="translated">ファイル、非ASCIIデータ、バイナリデータ</target>
        </trans-unit>
        <trans-unit id="03d4991f0d2b56909a00a2c07cb0c98115001bed" translate="yes" xml:space="preserve">
          <source>information for the user to recognize the source of the conflict.
  Ideally, the response entity would include enough information for the
  user or user agent to fix the problem; however, that might not be
  possible and is not required.</source>
          <target state="translated">競合の発生源をユーザが認識するための情報を含む。理想的には、応答エンティティは、ユーザまたはユーザエージェントが問題を解決するのに十分な情報を含むことが望ましいが、それは不可能かもしれないし、必要ではない。</target>
        </trans-unit>
        <trans-unit id="a7cc393671d331a6f24f8870a93fd8292a27451f" translate="yes" xml:space="preserve">
          <source>it will work, but semantically you are saying that you want to add a resource to the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">それは機能しますが、意味的には、 &lt;em&gt;ユーザー&lt;/em&gt; &lt;strong&gt;コレクションの&lt;/strong&gt;下の&lt;em&gt;ジョン&lt;/em&gt; &lt;strong&gt;コレクションに&lt;/strong&gt;リソースを追加することを意味しています。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="d0b50e773f074b959f39222603c21bd08feff7c0" translate="yes" xml:space="preserve">
          <source>taken from &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Resource Modeling by Prakash Subramaniam of Thoughtworks&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST APIデザイン-ThoughtworksのPrakash Subramaniamによるリソースモデリングからの抜粋&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebe73780ee4475ed56cfa08985bac3ceeb53b38" translate="yes" xml:space="preserve">
          <source>the origin server can create the resource with that URI</source>
          <target state="translated">は、オリジンサーバーがそのURIでリソースを作成することができます。</target>
        </trans-unit>
        <trans-unit id="c4c609ca0b9379838bc225c20d08b72b88e05939" translate="yes" xml:space="preserve">
          <source>you are posting a new user to the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">新しいユーザーを&lt;em&gt;ユーザー&lt;/em&gt; &lt;strong&gt;コレクションに&lt;/strong&gt;投稿してい&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1f3bfcffc130ebfe19bd9ae363ee7834942fb61" translate="yes" xml:space="preserve">
          <source>you are telling to the server update, or create if it doesn't exist, the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;resource&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">サーバーの更新を指示するか、存在しない場合は、 &lt;em&gt;ユーザー&lt;/em&gt; &lt;strong&gt;コレクションの&lt;/strong&gt;下の&lt;em&gt;john&lt;/em&gt; &lt;strong&gt;リソース&lt;/strong&gt;を作成し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac747133049c7cac58b2f01633f4d4824881c480" translate="yes" xml:space="preserve">
          <source>you should use &lt;strong&gt;POST&lt;/strong&gt; method</source>
          <target state="translated">あなたは&lt;strong&gt;POST&lt;/strong&gt;メソッドを使うべきです</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
