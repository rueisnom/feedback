<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/630453">
    <body>
      <group id="630453">
        <trans-unit id="0c058b89b3c60a0ba555a3620d744eb93c511f1a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH is the new primary HTTP method for updates&lt;/a&gt;&quot; explains it.</source>
          <target state="translated">&amp;laquo; &lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH - это новый основной метод HTTP для обновлений&lt;/a&gt; &amp;raquo;, объясняет это.</target>
        </trans-unit>
        <trans-unit id="f74f51ed1b6ae265800adfcf8027c01c0018665f" translate="yes" xml:space="preserve">
          <source>10.4.10 409 Conflict</source>
          <target state="translated">10.4.10 409 Конфликт</target>
        </trans-unit>
        <trans-unit id="506fa830744fbb202514e4450da7b9fff37040d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; is designed to replace 2616 and in &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; describes the follow possible response for a POST</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; предназначен для замены 2616 и в &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;разделе 4.3.3&lt;/a&gt; описывается возможный ответ для POST.</target>
        </trans-unit>
        <trans-unit id="1a0c5e7063c7016b18d6c3928f19f62e9242e7e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;I wrote the following as part of another answer on SO regarding this&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;Я написал следующее как часть другого ответа на SO относительно этого&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="55aee01ee1d0f0416e9083e2d6f6557b9818cb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST /something&lt;/code&gt;: &quot;Take what I give you and put it anywhere you want under &lt;code&gt;/something&lt;/code&gt; as long as you give me its URL when you're done.&quot;</source>
          <target state="translated">&lt;code&gt;POST /something&lt;/code&gt; : &amp;laquo;Возьми то, что я тебе даю, и положи куда угодно, под &lt;code&gt;/something&lt;/code&gt; пока ты мне дашь его URL, когда закончишь&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="df611b43ba33bf88fde50464bfe23c704ed98e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST x&lt;/code&gt;: &quot;Store my content and give me an identifier that I can use to identify a resource (old or new) containing said content (possibly mixed with other content). Said resource should be identical or subordinate to that which &lt;code&gt;x&lt;/code&gt; identifies.&quot; &quot;&lt;em&gt;y&lt;/em&gt;'s resource is subordinate to &lt;em&gt;x&lt;/em&gt;'s resource&quot; is typically but not necessarily implemented by making &lt;em&gt;y&lt;/em&gt; a subpath of &lt;em&gt;x&lt;/em&gt; (e.g. &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; and &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt;) and modifying the representation(s) of &lt;em&gt;x&lt;/em&gt;'s resource to reflect the existence of a new resource, e.g. with a hyperlink to &lt;em&gt;y&lt;/em&gt;'s resource and some metadata. Only the latter is really essential to good design, as URLs are opaque in REST -- you're supposed to &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;use hypermedia&lt;/a&gt; instead of client-side URL construction to traverse the service anyways.</source>
          <target state="translated">&lt;code&gt;POST x&lt;/code&gt; : &amp;laquo;Храните мое содержимое и дайте мне идентификатор, который я могу использовать для идентификации ресурса (старого или нового), содержащего указанное содержимое (возможно, смешанного с другим содержимым). Указанный ресурс должен быть идентичным или подчиняться тому, который идентифицирует &lt;code&gt;x&lt;/code&gt; &amp;raquo;. &amp;laquo;Ресурс &lt;em&gt;y&lt;/em&gt; подчиняется ресурсу &lt;em&gt;x&lt;/em&gt; &amp;raquo;, как правило, но не обязательно реализуется путем превращения &lt;em&gt;y&lt;/em&gt; в подпуть &lt;em&gt;x&lt;/em&gt; (например, &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; и &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt; ) и изменения представления (й) &lt;em&gt;x&lt;/em&gt; ' s ресурс, чтобы отразить существование нового ресурса, например, с гиперссылкой на ресурс &lt;em&gt;y&lt;/em&gt; и некоторыми метаданными. Только последний действительно важен для хорошего дизайна, так как URL-адреса непрозрачны в REST - вы должны &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;использовать гипермедиа&lt;/a&gt; вместо создания URL-адреса на стороне клиента для обхода сервиса в любом случае.</target>
        </trans-unit>
        <trans-unit id="d458584efe00bde626b31645f1c9331669a393b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST&lt;/code&gt; means &quot;create new&quot; as in &quot;Here is the input for creating a user, create it for me&quot;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; означает &amp;laquo;создать новый&amp;raquo;, как в &amp;laquo;Вот вход для создания пользователя, создайте его для меня&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1a07f91414dd50cc7f1986ee5d6ee5a1fbee9ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; already exists): &quot;Take whatever you have at &lt;code&gt;/something&lt;/code&gt; and replace it with what I give you.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; (если &lt;code&gt;/something&lt;/code&gt; уже существует): &amp;laquo;Возьми то, что у тебя есть в &lt;code&gt;/something&lt;/code&gt; и замени это тем, что я тебе даю&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="46ab7ec42035f8ace3ccbdc9e29957431a709ad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; does not already exist): &quot;Take what I give you and put it at &lt;code&gt;/something&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; (если &lt;code&gt;/something&lt;/code&gt; еще не существует): &amp;laquo;Возьми то, что я тебе даю, и положи это в &lt;code&gt;/something&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8b19b9a7682dd06e6b9d4d9b60e4befaf7e822f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; does not identify a resource): &quot;Create a new resource containing my content and use &lt;code&gt;x&lt;/code&gt; to identify it.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; (если &lt;code&gt;x&lt;/code&gt; не идентифицирует ресурс): &amp;laquo;Создайте новый ресурс, содержащий мое содержимое, и используйте &lt;code&gt;x&lt;/code&gt; для его идентификации&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b7eeae57fac13ac526305058d9ec04d7f1c90069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; identifies a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;resource&lt;/a&gt;): &quot;Replace the content of the resource identified by &lt;code&gt;x&lt;/code&gt; with my content.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; (если &lt;code&gt;x&lt;/code&gt; идентифицирует &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;ресурс&lt;/a&gt; ): &amp;laquo;Заменить содержимое ресурса, обозначенного &lt;code&gt;x&lt;/code&gt; , моим контентом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="693d0f55f15f15a3670f566554ad630959a6464b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT&lt;/code&gt; means &quot;insert, replace if already exists&quot; as in &quot;Here is the data for user 5&quot;.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; означает &amp;laquo;вставить, заменить, если уже существует&amp;raquo;, как в &amp;laquo;Вот данные для пользователя 5&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ba9411546a0e55dde6f6b3b345e14406853999d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Некоторые могут придумать, что обновления могут выполняться с помощью POST.&lt;/em&gt; &lt;em&gt;Не существует жесткого правила, какое использовать для обновлений или какое использовать для создания.&lt;/em&gt; &lt;em&gt;Опять же, это условности, и я интуитивно склоняюсь к вышеупомянутым рассуждениям и следую им.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="494905e8546c28f7ca25ed531d6f9532f60855f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;-- generic -- specific --&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;- универсальный - специфичный -&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24bd66f9b0232fdec5910e08746f4135f3abc5f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3.4.  PUT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3.4.&lt;/strong&gt; &lt;strong&gt;ПОЛОЖИЛ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f00078b6cfd30a400e58409eebd42604b45de8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b79f8a35030639797e581e3751e158add431466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Great both can be used, so which one should I use in my RESTful design:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Можно использовать оба варианта, поэтому какой из них мне следует использовать в моем дизайне RESTful:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f204e179a99e4e4da9b046149c8fa27fab675704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Long Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Длинный ответ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ea66d061a28052dccef1603c0375aa549c7f0e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Longer Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Более длинный ответ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d19062995715b13929a5b7d5ad16cd259eea9489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ.&lt;/strong&gt; PUT требуется местоположение ресурса (уже ресурс), для которого должно происходить обновление, тогда как POST этого не требует. Поэтому интуитивно POST предназначен для создания нового ресурса, а PUT необходим для обновления уже существующего ресурса.</target>
        </trans-unit>
        <trans-unit id="973a94f5bc8d247be1da5613a2678e40ad80ce20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;New answer (now that I understand REST better):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Новый ответ (теперь, когда я лучше понимаю REST):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6eaec7db8eb07bc1a9853353813e5aacc4d8a7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; PUT has mostly been used to update resources (by replacing them in their entireties), but recently there is movement towards using PATCH for updating existing resources, as PUT specifies that it replaces the whole resource. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; PUT в основном использовался для обновления ресурсов (путем их полной замены), но в последнее время наблюдается движение к использованию PATCH для обновления существующих ресурсов, поскольку PUT указывает, что он заменяет весь ресурс. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f39f80f6a4493b75f71f2759494c67e2fe8499a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or you can do this&lt;/strong&gt;: consider your unsafe requests as ephemeral single-user resources (let's call them actions). Clients request a new &quot;action&quot; on a substantive resource with an empty POST to the resource. POST will be used only for this. Once safely in possession of the URI of the freshly minted action, the client PUTs the unsafe request to the action URI, &lt;em&gt;not the target resource&lt;/em&gt;. Resolving the action and updating the &quot;real&quot; resource is properly the job of your API, and is here decoupled from the unreliable network.</source>
          <target state="translated">&lt;strong&gt;Или вы можете сделать это&lt;/strong&gt; : рассматривайте ваши небезопасные запросы как эфемерные однопользовательские ресурсы (назовем их действиями). Клиенты запрашивают новое &amp;laquo;действие&amp;raquo; на основном ресурсе с пустым POST к ресурсу. POST будет использоваться только для этого. Как только надежно завладеет URI только что созданного действия, клиент помещает небезопасный запрос в URI действия, а &lt;em&gt;не в целевой ресурс&lt;/em&gt; . Разрешить действие и обновить &amp;laquo;реальный&amp;raquo; ресурс - это правильно работа вашего API, и здесь он отделен от ненадежной сети.</target>
        </trans-unit>
        <trans-unit id="83d03f71c82f9f3e365473c2e90a536428e4a72f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer (might be easier to read)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Оригинальный ответ (может быть легче читать)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fb16687bea1f8e2c7ffd77af09d8a11526e30bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overall:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overall:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fec18cd93d5bbce335b8a8b4685449de2c1a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PATCH&lt;/strong&gt; to a URL &lt;strong&gt;updates &lt;em&gt;part&lt;/em&gt; of the resource&lt;/strong&gt; at that client defined URL.</source>
          <target state="translated">&lt;strong&gt;PATCH&lt;/strong&gt; to URL &lt;strong&gt;обновляет &lt;em&gt;часть&lt;/em&gt; ресурса&lt;/strong&gt; по указанному клиенту URL.</target>
        </trans-unit>
        <trans-unit id="e900f8bab5ad45a82b31d5c9e77eb8b842fb8fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST creates a child resource&lt;/strong&gt;, so POST to &lt;code&gt;/items&lt;/code&gt; creates a resources that lives under the &lt;code&gt;/items&lt;/code&gt; resource. 
Eg. &lt;code&gt;/items/1&lt;/code&gt;. Sending the same post packet twice will create two resources.</source>
          <target state="translated">&lt;strong&gt;POST создает дочерний ресурс&lt;/strong&gt; , поэтому POST для &lt;code&gt;/items&lt;/code&gt; создает ресурсы, которые находятся под ресурсом &lt;code&gt;/items&lt;/code&gt; . Например. &lt;code&gt;/items/1&lt;/code&gt; . Отправка одного и того же почтового пакета дважды создаст два ресурса.</target>
        </trans-unit>
        <trans-unit id="84cd833b3d09b3772c7c9b69992c06365b49d808" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;POST:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51d739446154fe4129eacba513d3e7c1cbc82d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; /items</source>
          <target state="translated">&lt;strong&gt;ПОСТ&lt;/strong&gt; / предметы</target>
        </trans-unit>
        <trans-unit id="81f179204aeec70824672b29654dc73a5ef03745" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; You can think of something like &quot;INSERT INTO STUDENT(name, address) VALUES (&quot;abc&quot;, &quot;xyzzz&quot;);</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; Вы можете придумать что-то вроде &amp;laquo;ВСТАВИТЬ В СТУДЕНТА (имя, адрес) VALUES (&amp;laquo; abc &amp;raquo;,&amp;laquo; xyzzz &amp;raquo;);</target>
        </trans-unit>
        <trans-unit id="d84ba3155ffa58932b6b44f1f889c414429f25ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; a resource into a collection</source>
          <target state="translated">&lt;strong&gt;ПОСТ&lt;/strong&gt; ресурс в коллекцию</target>
        </trans-unit>
        <trans-unit id="c6057b584edf3b882a3192b1dc61a689a17f508b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; не идемпотентен, где состояние ресурса может стать другим, если операция выполняется несколько раз по сравнению с выполнением одного раза.</target>
        </trans-unit>
        <trans-unit id="fa11acc5dc60894a4a26cfcbe0027d32f1604de8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;PUT&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; должен использоваться, чтобы создать ресурс, и &lt;strong&gt;PUT&lt;/strong&gt; должен использоваться, чтобы изменить один</target>
        </trans-unit>
        <trans-unit id="83971fa0e325d0bc5650b7ff303b5ca7b5384576" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL &lt;strong&gt;creates a child resource&lt;/strong&gt; at a &lt;em&gt;server defined&lt;/em&gt; URL.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; для URL-адреса &lt;strong&gt;создает дочерний ресурс&lt;/strong&gt; на URL-адресе, &lt;em&gt;определенном сервером&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="39214825f7bf31755a7524b96e478ffac1270da2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL should be used to update or create a resource which is located at some other (&quot;subordinate&quot;) URL, or is not locatable via HTTP.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; to URL должен использоваться для обновления или создания ресурса, который расположен по какому-то другому (&amp;laquo;подчиненному&amp;raquo;) URL или не может быть обнаружен через HTTP.</target>
        </trans-unit>
        <trans-unit id="906a2e1913665dd7ea341fe6a356f1a5db4491c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; updates a resource, adds a subsidiary resource, or causes a change.  A POST is not idempotent, in the way that &lt;code&gt;x++&lt;/code&gt; is not idempotent.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; обновляет ресурс, добавляет вспомогательный ресурс или вызывает изменение. POST не идемпотентен, так как &lt;code&gt;x++&lt;/code&gt; не идемпотентен.</target>
        </trans-unit>
        <trans-unit id="1201fa44ed952a209bb94b60653ae5e6d12e8775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cb09efafb2a756a2c8c49fbf16fde25b499a6f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt;  /items/1234</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; / items / 1234</target>
        </trans-unit>
        <trans-unit id="04e6413418714eccb311ba8ccd68a6eb8397b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; You can think of similar to &quot;UPDATE STUDENT SET address = &quot;abc&quot; where id=&quot;123&quot;;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; Можно подумать, что-то похожее на &amp;laquo;ОБНОВЛЕНИЕ СТУДЕНТА SET address =&amp;laquo; abc &amp;raquo;, где id =&amp;laquo; 123 &amp;raquo;;</target>
        </trans-unit>
        <trans-unit id="bac831f172bbd16f060e11a1fcf6a1142deebaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; a resource identified by collection/:id</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; ресурс, идентифицируемый коллекцией /: id</target>
        </trans-unit>
        <trans-unit id="43e9659830aa7fe8a7b61df6c3d0f9fe51884752" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; implies putting a resource - completely replacing whatever is available at the given URL with a different thing.  By definition, a PUT is idempotent.  Do it as many times as you like, and the result is the same. &lt;code&gt;x=5&lt;/code&gt; is idempotent.  You can PUT a resource whether it previously exists, or not (eg, to Create, or to Update)!</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; подразумевает размещение ресурса - полная замена того, что доступно по данному URL, на другое. По определению, PUT является идемпотентом. Делайте это столько раз, сколько хотите, и результат тот же. &lt;code&gt;x=5&lt;/code&gt; идемпотент. Вы можете положить ресурс независимо от того, существует ли он ранее или нет (например, для создания или обновления)!</target>
        </trans-unit>
        <trans-unit id="11d47c3923ae9d2cba6624010bda74e130873ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is for creating or replacing a resource at a &lt;strong&gt;URL known by the client&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; предназначен для создания или замены ресурса по &lt;strong&gt;известному клиенту URL-адресу&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa7bf3d7c1668ea88085a1bf5c94b878a2e04e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; является идемпотентным, когда состояние ресурса будет одинаковым, если одна и та же операция выполняется один или несколько раз.</target>
        </trans-unit>
        <trans-unit id="ad48efa009a26f69b5139207c4818699892b929a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; replaces the resource at the known url if it already exists, so sending the same request twice has no effect. In other words, &lt;strong&gt;calls to PUT are idempotent&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; заменяет ресурс по известному URL, если он уже существует, поэтому отправка одного и того же запроса дважды не имеет никакого эффекта. Другими словами, &lt;strong&gt;вызовы PUT являются идемпотентными&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="47297bbd78d247783bb6a9b461b4320abab889a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;POST&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; следует использовать для создания ресурса, а &lt;strong&gt;POST&lt;/strong&gt; - для его изменения.</target>
        </trans-unit>
        <trans-unit id="2316d8434c10c4f7c6461cd73b5ad3a9c62ff074" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL &lt;strong&gt;creates/replaces the resource&lt;/strong&gt; in its entirety at the &lt;em&gt;client defined&lt;/em&gt; URL.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; to URL &lt;strong&gt;создает / заменяет ресурс&lt;/strong&gt; целиком по &lt;em&gt;заданному клиенту&lt;/em&gt; URL.</target>
        </trans-unit>
        <trans-unit id="9a47a55d20b6233f89d8f607db5f21886379877c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL should be used to update or create the resource that can be located at that URL.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; to URL должен использоваться для обновления или создания ресурса, который может быть расположен по этому URL.</target>
        </trans-unit>
        <trans-unit id="0eb5b9e913c2e4810b9d275d9137826d6361fccb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post&lt;/strong&gt; on social media: when we post message, it creates new post.</source>
          <target state="translated">&lt;strong&gt;Публикация&lt;/strong&gt; в социальных сетях: когда мы публикуем сообщение, создается новое сообщение.</target>
        </trans-unit>
        <trans-unit id="c379deb81ec8171aeba8c48b33c76a4077d81ae5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put&lt;/strong&gt;(i.e. edit) for the message we already Posted.</source>
          <target state="translated">&lt;strong&gt;Поставьте&lt;/strong&gt; (т.е. отредактируйте) сообщение, которое мы уже опубликовали.</target>
        </trans-unit>
        <trans-unit id="42f2ab7a6f0ba70ad4633ee1aeb9c5617f17e37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replying with a status code of 409 Conflict is the correct recourse because&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Ответ с кодом состояния 409 Конфликт является правильным решением, потому что&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="541c698af4296a2ac8f6dbcf007beace20e3289c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Короткий ответ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7dee22b45482414ebaedf9e5284e4fb4d8d9302d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The decision of whether to use PUT or POST to create a resource on a server with an HTTP + REST API is based on who owns the URL structure.&lt;/strong&gt; Having the client know, or participate in defining, the URL struct is an unnecessary coupling akin to the undesirable couplings that arose from SOA. Escaping types of couplings is the reason REST is so popular. Therefore, &lt;strong&gt;the proper method to use is POST.&lt;/strong&gt; There are exceptions to this rule and they occur when the client wishes to retain control over the location structure of the resources it deploys. This is rare and likely means something else is wrong.</source>
          <target state="translated">&lt;strong&gt;Решение о том, использовать ли PUT или POST для создания ресурса на сервере с HTTP + REST API, зависит от того, кому принадлежит структура URL.&lt;/strong&gt; Знание или участие клиента в определении структуры URL - это ненужная связь, сродни нежелательным связям, возникающим из SOA. Экранирование типов муфт является причиной популярности REST. Поэтому &lt;strong&gt;правильным методом для использования является POST.&lt;/strong&gt; Есть исключения из этого правила, и они возникают, когда клиент желает сохранить контроль над структурой расположения ресурсов, которые он развертывает. Это редко и, вероятно, означает, что что-то еще не так.</target>
        </trans-unit>
        <trans-unit id="52dde7c3fb20e3705b4cb8c6fdc0d421a3aa14d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018&lt;/strong&gt;: There is a case that can be made to avoid PUT. See &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;REST without PUT&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление 2018&lt;/strong&gt; : есть случай, который можно избежать, чтобы избежать PUT. Смотрите &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;ОТДЫХ без ПУТА&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ab5192fbe6cef7ceb3ab2181f51408e2e0392" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update based on release of RFC 7231 to Replace 2616&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление на основе выпуска RFC 7231 для замены 2616&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="823a6eb1d93ecc4c59ea5a879b8110b0723a4c56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using POST to create resources comes with a design consideration because POST is not idempotent.&lt;/strong&gt; This means that repeating a POST several times does not guarantee the same behavior each time. &lt;strong&gt;This scares people into using PUT to create resources when they should not.&lt;/strong&gt; They know it's wrong (POST is for CREATE) but they do it anyway because they don't know how to solve this problem.  This concern is demonstrated in the following situation:</source>
          <target state="translated">&lt;strong&gt;Использование POST для создания ресурсов требует разработки, поскольку POST не идемпотентен.&lt;/strong&gt; Это означает, что повторение POST несколько раз не гарантирует одно и то же поведение каждый раз. &lt;strong&gt;Это пугает людей использовать PUT для создания ресурсов, когда они не должны.&lt;/strong&gt; Они знают, что это неправильно (POST предназначен для CREATE), но они все равно делают это, потому что не знают, как решить эту проблему. Эта проблема проявляется в следующей ситуации:</target>
        </trans-unit>
        <trans-unit id="f8352b060f3bd6bf9405565ea670a52e1a19ac89" translate="yes" xml:space="preserve">
          <source>A PUT doesn't need to be a create; the service could error if the resource isn't already created, but otherwise update it. Or vice versa -- it may create the resource, but not allow updates. The only thing required about PUT is that it points to a specific resource, and its payload is the representation of that resource. A successful PUT means (barring interference) that a GET would retrieve the same resource.</source>
          <target state="translated">PUT не обязательно должен быть создан;сервис может ошибиться,если ресурс еще не создан,но в противном случае обновить его.Или наоборот-он может создать ресурс,но не разрешать обновления.Единственное,что требуется от PUT-это то,что он указывает на конкретный ресурс,и его полезная нагрузка-это представление этого ресурса.Успешный PUT означает (запрещающий вмешательство),что GET получит тот же самый ресурс.</target>
        </trans-unit>
        <trans-unit id="0e9a6a3224dfefa9263f801580fea79e1034124c" translate="yes" xml:space="preserve">
          <source>A REST API must not define fixed resource names or hierarchies (an
  obvious coupling of client and server). Servers must have the freedom
  to control their own namespace. Instead, allow servers to instruct
  clients on how to construct appropriate URIs, such as is done in HTML
  forms and URI templates, by defining those instructions within media
  types and link relations. [Failure here implies that clients are
  assuming a resource structure due to out-of band information, such as
  a domain-specific standard, which is the data-oriented equivalent to
  RPC's functional coupling].</source>
          <target state="translated">API REST не должно определять фиксированные имена ресурсов или иерархии (очевидная связь клиента и сервера).Серверы должны иметь свободу управления собственным пространством имён.Вместо этого,позвольте серверам инструктировать клиентов о том,как строить соответствующие URI,например,в HTML формах и шаблонах URI,определяя эти инструкции в рамках типов средств массовой информации и связей с ними.[Неудача здесь подразумевает,что клиенты предполагают структуру ресурсов из-за информации вне диапазона,такой как специфический для домена стандарт,который ориентирован на данные,эквивалентный функциональному взаимодействию RPC].</target>
        </trans-unit>
        <trans-unit id="4eebc73de916b615d31b4a9c02c76f42d153bef9" translate="yes" xml:space="preserve">
          <source>A general advice is to use &lt;code&gt;POST&lt;/code&gt; when you need the server to be in control of &lt;code&gt;URL&lt;/code&gt; generation of your resources. Use &lt;code&gt;PUT&lt;/code&gt; otherwise.  Prefer &lt;code&gt;PUT&lt;/code&gt;  over &lt;code&gt;POST&lt;/code&gt;.</source>
          <target state="translated">Общий совет - использовать &lt;code&gt;POST&lt;/code&gt; , когда вам нужно, чтобы сервер контролировал генерацию &lt;code&gt;URL&lt;/code&gt; ваших ресурсов. В противном случае используйте &lt;code&gt;PUT&lt;/code&gt; . Предпочитаю &lt;code&gt;PUT&lt;/code&gt; ,а не &lt;code&gt;POST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a46f192218c6e582580086317328dbf11d360983" translate="yes" xml:space="preserve">
          <source>A general rule: if you know the id or name of the item, use PUT. If you want the id or name of the item to be assigned by the receiving party, use POST.</source>
          <target state="translated">Общее правило:если вы знаете идентификатор или имя элемента,используйте PUT.Если вы хотите,чтобы идентификатор или имя элемента были назначены принимающей стороной,используйте POST.</target>
        </trans-unit>
        <trans-unit id="8d80afd687e25858c217eccf9caa91d0cf98797f" translate="yes" xml:space="preserve">
          <source>A new method is necessary to improve interoperability and prevent
     errors.  The PUT method is already defined to overwrite a resource
     with a complete new body, and cannot be reused to do partial changes.
     Otherwise, proxies and caches, and even clients and servers, may get
     confused as to the result of the operation.  POST is already used but
     without broad interoperability (for one, there is no standard way to
     discover patch format support).  PATCH was mentioned in earlier HTTP
     specifications, but not completely defined.</source>
          <target state="translated">Новый метод необходим для улучшения интероперабельности и предотвращения ошибок.Метод PUT уже определен для перезаписи ресурса с полным новым телом,и не может быть использован повторно для внесения частичных изменений.В противном случае прокси и кэши,и даже клиенты и серверы,могут запутаться в результате операции.POST уже используется,но без широкой интероперабельности (например,нет стандартного способа обнаружить поддержку формата патча).PATCH упоминался в более ранних спецификациях HTTP,но не был полностью определен.</target>
        </trans-unit>
        <trans-unit id="d7612bc02c9fa195c518a31c5e2d100c9f1167a8" translate="yes" xml:space="preserve">
          <source>A response which contains the URL of the resource with the conflicting ID and the appropriate preconditions for the resource would provide &amp;ldquo;enough information for the user or user agent to fix the problem&amp;rdquo; which is the ideal case per RFC 2616.</source>
          <target state="translated">Ответ, который содержит URL-адрес ресурса с конфликтующим идентификатором и соответствующие предварительные условия для ресурса, предоставит &amp;laquo;достаточную информацию для пользователя или пользовательского агента для решения проблемы&amp;raquo;, что является идеальным случаем согласно RFC 2616.</target>
        </trans-unit>
        <trans-unit id="0a5f004271832132b2407dff2153fd15001e9ee0" translate="yes" xml:space="preserve">
          <source>According to ME, real-life networks are unreliable. Requests timeout. Connections are reset. Networks go down for hours or days at a time. Trains go into tunnels with mobile users aboard. For any given request (as occasionally acknowledged in all this discussion) the request can fall in the water on its way, or the response can fall in the water on its way back. &lt;strong&gt;In these conditions, issuing PUT, POST and DELETE requests directly against substantive resources has always struck me as a little brutal and naive.&lt;/strong&gt;</source>
          <target state="translated">По словам ME, реальные сети ненадежны. Запрашивает тайм-аут. Соединения сбрасываются. Сети отключаются на часы или дни одновременно. Поезда идут в туннели с мобильными пользователями на борту. Для любого данного запроса (как иногда признается во всем этом обсуждении) запрос может упасть в воду на своем пути, или ответ может упасть в воде на обратном пути. &lt;strong&gt;В этих условиях выдача запросов PUT, POST и DELETE непосредственно на основные ресурсы всегда казалась мне немного жестокой и наивной.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44a64212bc466bad1c26da5cf30cd0ad13d5b0f6" translate="yes" xml:space="preserve">
          <source>According to the HTTP 1.1 specifications the GET, HEAD, DELETE, and PUT methods must be idempotent, and the POST method is not idempotent. That is to say that an operation is idempotent if it can be performed on a resource once or many times and always return the same state of that resource. Whereas a non idempotent operation can return a modified state of the resource from one request to another. Hence, in a non idempotent operation, there is no guarantee that one will receive the same state of a resource.</source>
          <target state="translated">Согласно спецификациям HTTP 1.1 методы GET,HEAD,DELETE и PUT должны быть идолопокрытыми,а метод POST не является идолопокрытым.То есть операция является idempotent,если ее можно выполнить на ресурсе один или несколько раз и всегда возвращать одно и то же состояние этого ресурса.В то время как операция,не являющаяся idempotent,может возвращать измененное состояние ресурса из одного запроса в другой.Следовательно,при выполнении непубличной операции нет никакой гарантии,что ресурс будет находиться в таком же состоянии.</target>
        </trans-unit>
        <trans-unit id="263017c41745f1b94fb06cd0b37045f3eec4ef1a" translate="yes" xml:space="preserve">
          <source>According to the HTTP/1.1 Spec:</source>
          <target state="translated">В соответствии со спецификацией HTTP1.1:</target>
        </trans-unit>
        <trans-unit id="99391b86ae4d4984d262f89901db8c15300e563f" translate="yes" xml:space="preserve">
          <source>According to this, you cannot send files or multipart data in the &lt;strong&gt;PUT&lt;/strong&gt; method</source>
          <target state="translated">В соответствии с этим вы не можете отправлять файлы или составные данные методом &lt;strong&gt;PUT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="400cd438f5e39bdc77550bfd923cf916451692bd" translate="yes" xml:space="preserve">
          <source>Additionally, and a bit more concisely, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 Section 4.3.4 PUT&lt;/a&gt; states (emphasis added),</source>
          <target state="translated">Кроме того, и более кратко, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231, раздел 4.3.4, PUT-&lt;/a&gt; состояния (выделение добавлено),</target>
        </trans-unit>
        <trans-unit id="18829b20b3b1624e09ed74c26fb7066a49e205d0" translate="yes" xml:space="preserve">
          <source>Analogy with database query</source>
          <target state="translated">Аналогия с запросом к базе данных</target>
        </trans-unit>
        <trans-unit id="1ecad98fe7923a037242a110b7abf85eb0ca5b54" translate="yes" xml:space="preserve">
          <source>Analogy:</source>
          <target state="translated">Analogy:</target>
        </trans-unit>
        <trans-unit id="cd8441cd54d554959dc0b978e4c1160125beaede" translate="yes" xml:space="preserve">
          <source>As for modifying the properties of the stream, you can do that with either PUT or POST. Basically, only use &quot;PUT&quot; when the operation is idempotent - otherwise use POST.</source>
          <target state="translated">Что касается изменения свойств потока,то это можно сделать как с помощью PUT,так и с помощью POST.В принципе,используйте &quot;PUT&quot; только тогда,когда операция является idempotent-в противном случае используйте POST.</target>
        </trans-unit>
        <trans-unit id="1505fe853a030352c8bbf3a78d4f0ba03add0832" translate="yes" xml:space="preserve">
          <source>As such, numerous thorny problems go away. Repeated insert requests won't create duplicates, and we don't create the real resource until we're in possession of the data. (database columns can stay not-nullable). Repeated update requests won't hit incompatible states and won't overwrite subsequent changes. Clients can (re)fetch and seamlessy process the original confirmation for whatever reason (client crashed, response went missing, etc.).</source>
          <target state="translated">Как таковые,многочисленные тернистые проблемы исчезают.Повторяющиеся запросы на вставку не создают дубликатов,и мы не создаем реального ресурса до тех пор,пока не получим во владение данные.(столбцы базы данных могут оставаться неуправляемыми).Повторяющиеся запросы на обновление не будут попадать в несовместимые состояния и не будут перезаписывать последующие изменения.Клиенты могут (пере)забрать и обработать оригинальное подтверждение по любой причине (клиент разбился,ответ пропал и т.д.).</target>
        </trans-unit>
        <trans-unit id="9269d826939b1ae8561cb8d676c6f19e2aeeeeb8" translate="yes" xml:space="preserve">
          <source>As your quote mentioned, you use PUT for creation of there is no resource assigned to an IRI, and you want to create a resource anyway. For example, &lt;code&gt;PUT /users/123/password&lt;/code&gt; usually replaces the old password with a new one, but you can use it to create a password if it does not exist already (for example, by freshly registered users or by restoring banned users).</source>
          <target state="translated">Как упоминалось в вашей цитате, вы используете PUT для создания, поскольку нет ресурса, назначенного IRI, и вы все равно хотите создать ресурс. Например, &lt;code&gt;PUT /users/123/password&lt;/code&gt; обычно заменяет старый пароль новым, но вы можете использовать его для создания пароля, если он еще не существует (например, недавно зарегистрированными пользователями или восстановлением заблокированных пользователей).</target>
        </trans-unit>
        <trans-unit id="678d1314d4c33bf4616bbffabc6f6412417d7408" translate="yes" xml:space="preserve">
          <source>At the risk of restating what has already been said, it seems important to remember that &lt;strong&gt;PUT&lt;/strong&gt; implies that the client controls what the &lt;em&gt;URL&lt;/em&gt; is going to end up being, when creating a resource. So part of the choice between &lt;strong&gt;PUT&lt;/strong&gt; and &lt;strong&gt;POST&lt;/strong&gt; is going to be about how much you can trust the client to provide correct, normalized &lt;em&gt;URL&lt;/em&gt; that are coherent with whatever your URL scheme is.</source>
          <target state="translated">Риск повторения того, что уже было сказано, кажется важным помнить, что &lt;strong&gt;PUT&lt;/strong&gt; подразумевает, что клиент контролирует, каким будет &lt;em&gt;URL-адрес&lt;/em&gt; , когда он будет создавать ресурс. Таким образом, часть выбора между &lt;strong&gt;PUT&lt;/strong&gt; и &lt;strong&gt;POST&lt;/strong&gt; будет зависеть от того, насколько вы можете доверять клиенту, предоставляя правильный, нормализованный &lt;em&gt;URL,&lt;/em&gt; который согласуется с вашей схемой URL.</target>
        </trans-unit>
        <trans-unit id="cd64c65270203c04e0ffe12619fc3c1cf5cb0838" translate="yes" xml:space="preserve">
          <source>At this point some people will argue that if &lt;em&gt;RESTful-URL's&lt;/em&gt; are used, the client does knows the URL of the resource and therefore a PUT is acceptable. After all, this is why canonical, normalized, Ruby on Rails, Django URLs are important, look at the Twitter API &amp;hellip; blah blah blah. Those people need to understand &lt;strong&gt;there is no such thing as a Restful-URL&lt;/strong&gt; and that &lt;strong&gt;Roy Fielding himself states that&lt;/strong&gt;:</source>
          <target state="translated">На этом этапе некоторые люди утверждают, что если используются &lt;em&gt;RESTful-URL&lt;/em&gt; , клиент знает URL-адрес ресурса, и поэтому PUT является приемлемым. В конце концов, именно поэтому важны канонические, нормализованные URL-адреса Ruby on Rails, Django, посмотрите на API Twitter&amp;hellip; бла-бла-бла. Эти люди должны понимать &lt;strong&gt;, что Restful-URL не существует,&lt;/strong&gt; и что &lt;strong&gt;сам Рой Филдинг утверждает, что&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="48ec0b3e3b0319156f9f91acfe20356337cec520" translate="yes" xml:space="preserve">
          <source>Based on the above idempotent definition, my take on using the HTTP PUT method versus using the HTTP POST method for REST services is:
Use the HTTP PUT method when:</source>
          <target state="translated">Основываясь на вышеприведенном определении idempotent,я считаю,что я использую метод HTTP PUT по сравнению с использованием метода HTTP POST для услуг REST:Использовать HTTP PUT метод когда:</target>
        </trans-unit>
        <trans-unit id="625c633dc893bb8acf9969ce26d2c745e6ed5c5d" translate="yes" xml:space="preserve">
          <source>Because PUT and GET and DELETE refer to a resource, they are also by definition idempotent.</source>
          <target state="translated">Поскольку PUT,GET и DELETE относятся к ресурсу,они также по определению являются идолопоклонниками.</target>
        </trans-unit>
        <trans-unit id="33d0f759f56954a746edd3401e6d1ad592971425" translate="yes" xml:space="preserve">
          <source>Before telling me this is not RESTful, please consider the numerous ways in which REST principles are respected. Clients don't construct URLs. The API stays discoverable, albeit with a little change in semantics. HTTP verbs are used appropriately. If you think this is a huge change to implement, I can tell you from experience that it's not.</source>
          <target state="translated">Прежде чем сказать мне,что это не является RESTful,пожалуйста,рассмотрите многочисленные способы,с помощью которых соблюдаются принципы REST.Клиенты не строят URL-адреса.API остается открытым,хотя и с небольшими изменениями в семантике.Глаголы HTTP используются соответствующим образом.Если вы считаете,что это огромное изменение в реализации,то по опыту могу сказать,что это не так.</target>
        </trans-unit>
        <trans-unit id="241aa52fb81745d04b1069f6da972cd395e23c48" translate="yes" xml:space="preserve">
          <source>Best of all, we give sending and receiving applications a chance to link the uniquely identified action to uniqueness in their respective environments. And we can start to demand, and enforce!, responsible behaviour from clients: repeat your requests as much as you like, but don't go generating a new action until you're in possession of a definitive result from the existing one.</source>
          <target state="translated">А лучше всего то,что мы даем возможность отправлять и получать заявки,связывая уникальное действие с уникальностью в соответствующей среде.И мы можем начать требовать и принуждать клиентов к ответственному поведению:повторяйте ваши запросы сколько угодно,но не генерируйте новое действие,пока не получите окончательный результат от существующего.</target>
        </trans-unit>
        <trans-unit id="b0bf6e9b80cf880bc4aee735753fe3f2ad23f833" translate="yes" xml:space="preserve">
          <source>Better is to choose between PUT and POST based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;idempotence&lt;/a&gt; of the action.</source>
          <target state="translated">Лучше выбирать между PUT и POST, основываясь на &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;идемпотентности&lt;/a&gt; действия.</target>
        </trans-unit>
        <trans-unit id="53c932206c69e73836ac721b4e0fe0b474be565c" translate="yes" xml:space="preserve">
          <source>Both PUT and POST can be used for creating.</source>
          <target state="translated">Для создания можно использовать как PUT,так и POST.</target>
        </trans-unit>
        <trans-unit id="2997f210a9beea7a9cbb23843149e3c1e35aa1ed" translate="yes" xml:space="preserve">
          <source>Both are used for data transmission between client to server, but there are subtle differences between them, which are:</source>
          <target state="translated">Оба используются для передачи данных между клиентом и сервером,но между ними есть тонкие различия:</target>
        </trans-unit>
        <trans-unit id="15b3b6388bc7e089c531c0bb3e2208420e07f69e" translate="yes" xml:space="preserve">
          <source>By this argument, PUT is for creating when you know the URL of the thing you will create. POST can be used to create when you know the URL of the &quot;factory&quot; or manager for the category of things you want to create.</source>
          <target state="translated">По этому аргументу,PUT предназначен для создания,когда вы знаете URL вещи,которую вы будете создавать.POST может быть использован для создания,когда вы знаете URL &quot;завода&quot; или менеджера для категории вещей,которые вы хотите создать.</target>
        </trans-unit>
        <trans-unit id="c7c8d0b3ba4ea21e1913266949e8103ea15c06b3" translate="yes" xml:space="preserve">
          <source>Can &lt;strong&gt;only&lt;/strong&gt; be performed with PUT in the following way:</source>
          <target state="translated">Может выполняться &lt;strong&gt;только&lt;/strong&gt; с помощью PUT следующим образом:</target>
        </trans-unit>
        <trans-unit id="29d666e583f03fcf75786741bc1b0cab3486e6df" translate="yes" xml:space="preserve">
          <source>Can be performed with both PUT or POST in the following way:</source>
          <target state="translated">Может выполняться как с PUT,так и с POST следующим образом:</target>
        </trans-unit>
        <trans-unit id="34e3815fe6dbc55d1a2ed6585c021c9fc37f549b" translate="yes" xml:space="preserve">
          <source>Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.</source>
          <target state="translated">Дело 1:Когда вы размещаете что-то на своей временной шкале,это новая запись.Поэтому в этом случае они используют метод POST,потому что метод POST не является бессильным.</target>
        </trans-unit>
        <trans-unit id="afe97da32ea658ba5cfa1f6a3af16660a6caad91" translate="yes" xml:space="preserve">
          <source>Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.</source>
          <target state="translated">Случай 2:Если ваш друг прокомментирует ваше сообщение в первый раз,это также создаст новую запись в базе данных,так что используется метод POST.</target>
        </trans-unit>
        <trans-unit id="51c87be0979efc83a96ee19ed6970b9953da779d" translate="yes" xml:space="preserve">
          <source>Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*</source>
          <target state="translated">Случай 3:Если ваш друг редактирует свой комментарий,то в этом случае у него есть идентификатор комментария,поэтому он будет обновлять существующий комментарий вместо того,чтобы создавать новую запись в базе данных.Поэтому для данного типа операций используйте метод PUT,поскольку он является idempotent.*.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="b0e2937475fc503e223c56343b52c44da7a6fa27" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a PUT request. For
  example, if versioning were being used and the entity being PUT
  included changes to a resource which conflict with those made by an
  earlier (third-party) request, the server might use the 409 response
  to indicate that it can&amp;rsquo;t complete the request. In this case, the
  response entity would likely contain a list of the differences between
  the two versions in a format defined by the response Content-Type.</source>
          <target state="translated">Конфликты чаще всего возникают в ответ на запрос PUT. Например, если использовалось управление версиями, а объект PUT включал изменения в ресурсе, которые конфликтуют с ресурсами, сделанными ранее (сторонним) запросом, сервер может использовать ответ 409, чтобы указать, что он не может выполнить запрос , В этом случае объект ответа, скорее всего, будет содержать список различий между двумя версиями в формате, определяемом типом содержимого ответа.</target>
        </trans-unit>
        <trans-unit id="93b186070c96257e81f5f76dda28fe4aaa692252" translate="yes" xml:space="preserve">
          <source>Create:</source>
          <target state="translated">Create:</target>
        </trans-unit>
        <trans-unit id="17b1e45ff463141be485d41572191a7ed7413417" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;A&lt;/strong&gt; new resource under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;. Usually the identifier is returned by the server.</source>
          <target state="translated">Создает новый ресурс в URI / resources или в &lt;strong&gt;коллекции&lt;/strong&gt; . Обычно идентификатор возвращается сервером.</target>
        </trans-unit>
        <trans-unit id="33e5496ae029f6fe64dd2213c64d6ba200b86f51" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;THE&lt;/strong&gt; new resource with &lt;strong&gt;newResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Создает новый ресурс с &lt;strong&gt;newResourceId&lt;/strong&gt; в качестве идентификатора под URI / resources или &lt;strong&gt;коллекцией&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="33ac997d5d937f49dfe9ade3e811b0f958a8e36d" translate="yes" xml:space="preserve">
          <source>Do not directly correlate and map CRUD operations to HTTP methods for REST services. The use of an HTTP PUT method versus an HTTP POST method should be based on the idempotent aspect of that operation. That is, if the operation is idempotent, then use the HTTP PUT method. If the operation is non idempotent, then use the HTTP POST method.</source>
          <target state="translated">Не соотносите напрямую и не сопоставляйте операции CRUD с HTTP-методами для REST-сервисов.Использование HTTP PUT-метода против HTTP POST-метода должно быть основано на идемпотентном аспекте этой операции.То есть,если операция является idempotent,то используйте метод HTTP PUT.Если же операция не является idempotent,то используйте метод HTTP POST.</target>
        </trans-unit>
        <trans-unit id="d370df4be6707296d029645b0b4712b06c53ef1c" translate="yes" xml:space="preserve">
          <source>Do you name your URL objects you create explicitly, or let the server decide? If you name them then use PUT.  If you let the server decide then use POST.</source>
          <target state="translated">Вы называете объекты URL-адреса,которые вы создаете в явном виде,или позволяете серверу принимать решения? Если вы дадите им имя,то используйте PUT.Если вы позволите серверу принять решение,то используйте POST.</target>
        </trans-unit>
        <trans-unit id="58945bef9cdd3ff1a80ba82c0e9d1f5a2d0ee11b" translate="yes" xml:space="preserve">
          <source>Edit: One more thing -- a PUT can create, but if it does then the ID has to be a natural ID -- AKA an email address. That way when you PUT twice, the second put is an update of the first. This makes it &lt;em&gt;idempotent&lt;/em&gt;.</source>
          <target state="translated">Изменить: еще одна вещь - PUT может создавать, но если это так, то идентификатор должен быть естественным ID - AKA адрес электронной почты. Таким образом, когда вы PUT дважды, второй будет обновлением первого. Это делает его &lt;em&gt;идемпотентным&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8ed4a1daabc4dbc57c02baa4ed3068d24acd58e8" translate="yes" xml:space="preserve">
          <source>For a new resource:</source>
          <target state="translated">Для нового ресурса:</target>
        </trans-unit>
        <trans-unit id="cff50999f4c249529ddc6e468c61561154669de5" translate="yes" xml:space="preserve">
          <source>For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.</source>
          <target state="translated">Например,когда вы хотите создать новый поток,вы можете PUT его на какой-нибудь URL.Но когда вы хотите POST сообщение к существующему потоку,вы POST к его URL.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="f547ae451be4b97139f6676d6b8b56908850c325" translate="yes" xml:space="preserve">
          <source>For instance, it may not be a good idea to create credit card transactions with POST.</source>
          <target state="translated">Например,может быть не очень хорошей идеей создавать операции по кредитным картам с POST.</target>
        </trans-unit>
        <trans-unit id="cc46f3f2f22617ca008bc0347b91c6bcc94f57de" translate="yes" xml:space="preserve">
          <source>For more information about this, read this &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;article&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации об этом, прочитайте эту &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;статью&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd29602a6814d7031623e943eb9ad9b03163c44" translate="yes" xml:space="preserve">
          <source>From a REST architecture's point of view there is none that matters. We could have lived without PUT as well. But from a client developer's point of view it made his/her life a lot simpler.</source>
          <target state="translated">С точки зрения архитектуры REST нет ничего,что имело бы значение.Мы могли бы жить и без PUT.Но с точки зрения заказчика-разработчика это сделало его жизнь намного проще.</target>
        </trans-unit>
        <trans-unit id="e554373d4e3272bcfc25cfb1cdb1bc748dad0740" translate="yes" xml:space="preserve">
          <source>HTTP does nothing to ensure reliable completion of the request-response, and that's just fine because this is properly the job of network-aware applications. Developing such an application, you can jump through hoops to use PUT instead of POST, then more hoops to give a certain kind of error on the server if you detect duplicate requests. Back at the client, you then have to jump through hoops to interpret these errors, refetch, revalidate and repost.</source>
          <target state="translated">HTTP не делает ничего,чтобы обеспечить надежное завершение запроса-ответа,и это просто прекрасно,потому что это нормальная работа сетевых приложений.Разрабатывая такое приложение,вы можете перескочить через обручи,чтобы использовать PUT вместо POST,а затем еще больше обручей,чтобы дать определенный вид ошибки на сервере,если вы обнаружите дублирующие запросы.Возвращаясь к клиенту,вы должны перепрыгнуть через обручи для интерпретации этих ошибок,рефетчеризации,повторной проверки и репостинга.</target>
        </trans-unit>
        <trans-unit id="b3fde5b13baf7e698d819867af72294baf96853b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Spec</source>
          <target state="translated">HTTP1.1 Спецификация</target>
        </trans-unit>
        <trans-unit id="5307592ab464b1dfe31ceb63373b1f53680a6aa6" translate="yes" xml:space="preserve">
          <source>Header &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">Заголовок &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a656b7b969733403da8fb5e2a09bcb24ed7b14b0" translate="yes" xml:space="preserve">
          <source>Hence, create or update based on existence of the &lt;strong&gt;resource&lt;/strong&gt;.</source>
          <target state="translated">Следовательно, создавать или обновлять в зависимости от наличия &lt;strong&gt;ресурса&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a09685c9924e957d538b394fd639ee93fed0a583" translate="yes" xml:space="preserve">
          <source>Hence, creates a new &lt;strong&gt;resource&lt;/strong&gt; on a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Следовательно, создает новый &lt;strong&gt;ресурс&lt;/strong&gt; в &lt;strong&gt;коллекции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaa5b7fc07bf5371832748f3289a7b2da4d980c" translate="yes" xml:space="preserve">
          <source>Here's a simple rule:</source>
          <target state="translated">Вот простое правило:</target>
        </trans-unit>
        <trans-unit id="8d27a8aff43735751da6f6d2d0ed6614a7eecf8a" translate="yes" xml:space="preserve">
          <source>I hope this helps any Microsoft developers that read all comments with Amazon and Sun/Java website links.</source>
          <target state="translated">Надеюсь,это поможет любому разработчику Microsoft,который прочитает все комментарии со ссылками на сайт Amazon и SunJava.</target>
        </trans-unit>
        <trans-unit id="5ca6bb95d20fb75f5f126fd38d614ae6b08d4b81" translate="yes" xml:space="preserve">
          <source>I interpret this, and the idempotency requirements on PUT, to mean that:</source>
          <target state="translated">Я интерпретирую это,и требования к идолопоклонству на PUT,как таковые:</target>
        </trans-unit>
        <trans-unit id="05235e2370ecb21ce9215b0f74750a3737456a63" translate="yes" xml:space="preserve">
          <source>I like this advice, from &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616's definition of PUT&lt;/a&gt;:</source>
          <target state="translated">Мне нравится этот совет из &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;определения PUT в RFC 2616&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="47aada42c69dd7c0210a4f1845e6ab606520fa95" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;PUT&lt;/code&gt; for Merge and update like operations and use &lt;code&gt;POST&lt;/code&gt; for Insertions.</source>
          <target state="translated">Я использую &lt;code&gt;PUT&lt;/code&gt; для слияния и обновления как операции и использую &lt;code&gt;POST&lt;/code&gt; для вставок.</target>
        </trans-unit>
        <trans-unit id="b527f56fb4de9ec139a67d896e81802d54cd82a0" translate="yes" xml:space="preserve">
          <source>I will describe the conventions which I think are most widely used and are most useful:</source>
          <target state="translated">Я опишу конвенции,которые,по моему мнению,наиболее широко используются и являются наиболее полезными:</target>
        </trans-unit>
        <trans-unit id="f9c0500253b27e41a2e9e90178c365ce2423d509" translate="yes" xml:space="preserve">
          <source>I'd like to add my &quot;pragmatic&quot; advice.  Use PUT when you know the &quot;id&quot; by which the object you are saving can be retrieved.  Using PUT won't work too well if you need, say, a database generated id to be returned for you to do future lookups or updates.</source>
          <target state="translated">Я хотел бы добавить свой &quot;прагматический&quot; совет.Используйте PUT,когда знаете &quot;id&quot;,с помощью которого можно получить сохраненный вами объект.Использование PUT не будет работать слишком хорошо,если вам,скажем,нужна база данных,сгенерированная id,которая будет возвращена,чтобы вы могли делать будущие поиски или обновления.</target>
        </trans-unit>
        <trans-unit id="66649e065e34c99642108c78cb23fe86c7332572" translate="yes" xml:space="preserve">
          <source>I'm going to land with the following:</source>
          <target state="translated">Я собираюсь приземлиться со следующим:</target>
        </trans-unit>
        <trans-unit id="dc85f0689c0d90da1345182eb8a915a8e4dd3c43" translate="yes" xml:space="preserve">
          <source>If the ID is generated (a new employee ID, for example), then the second PUT with the same URL would create a new record, which violates the idempotent rule. In this case the verb would be POST, and the message (not resource) would be to create a resource using the values defined in this message.</source>
          <target state="translated">Если ID генерируется (например,новый ID сотрудника),то второй PUT с тем же самым URL создаст новую запись,что нарушает правило idempotent.В этом случае глагол будет POST,а сообщение (не ресурс)будет создавать ресурс,используя значения,определенные в этом сообщении.</target>
        </trans-unit>
        <trans-unit id="e269e8bb2d1ae96b4945fea0fb22c28a23aa1d25" translate="yes" xml:space="preserve">
          <source>If the URL is not yet created, you
  should not be using POST to create it
  while specifying the name.  This should
  result in a 'resource not found' error
  because &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; does not exist
  yet.  You should PUT the &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt;
  resource on the server first.</source>
          <target state="translated">Если URL еще не создан, вам не следует использовать POST для его создания при указании имени. Это должно привести к ошибке &amp;laquo;ресурс не найден&amp;raquo;, поскольку &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; еще не существует. &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; вы должны поместить ресурс &amp;lt;new_question&amp;gt; на сервер.</target>
        </trans-unit>
        <trans-unit id="19c462827f591bd8bec6f3f537b7b39215387f40" translate="yes" xml:space="preserve">
          <source>If the result of processing a POST would be equivalent to a
  representation of an existing resource, an origin server MAY redirect
  the user agent to that resource by sending a 303 (See Other) response
  with the existing resource's identifier in the Location field.  This
  has the benefits of providing the user agent a resource identifier
  and transferring the representation via a method more amenable to
  shared caching, though at the cost of an extra request if the user
  agent does not already have the representation cached.</source>
          <target state="translated">Если результат обработки POST эквивалентен представлению существующего ресурса,то сервер происхождения MAY перенаправляет агента пользователя на этот ресурс,посылая ответ 303 (см.Другое)с идентификатором существующего ресурса в поле Location.Это имеет преимущества предоставления агенту пользователя идентификатора ресурса и передачи представления методом,более подверженным общему кэшированию,хотя и за счет дополнительного запроса,если агент пользователя еще не имеет представления в кэше.</target>
        </trans-unit>
        <trans-unit id="558a879fdfc95da4b234bea22b5e49ef57224b98" translate="yes" xml:space="preserve">
          <source>If you are familiar with database operations,
there are</source>
          <target state="translated">Если вы знакомы с операциями с базами данных,то есть</target>
        </trans-unit>
        <trans-unit id="1d065776051b8ea3a055903bde387f8a311a6be4" translate="yes" xml:space="preserve">
          <source>If you go on and try something like this:</source>
          <target state="translated">Если ты продолжишь и попробуешь что-нибудь подобное:</target>
        </trans-unit>
        <trans-unit id="0c6f7e90f3ea30966fd463c77a5a98203c024433" translate="yes" xml:space="preserve">
          <source>If you happen to have auto generated  URI's on your resource you can still use PUT by passing a generated URI (pointing to an empty resource) to the client.</source>
          <target state="translated">Если у вас случайно есть автоматически сгенерированные URI на вашем ресурсе,вы все еще можете использовать PUT,передавая сгенерированный URI (указывающий на пустой ресурс)клиенту.</target>
        </trans-unit>
        <trans-unit id="cd5ae750e099166d34c0aea0fb9b4fadd772975a" translate="yes" xml:space="preserve">
          <source>If you have any doubts about how to implement REST in HTTP, you can always take a look at the &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom Publication Protocol (AtomPub)&lt;/a&gt; specification. AtomPub is a standard for writing RESTful webservices with HTTP that was developed by many HTTP and REST luminaries, with some input from Roy Fielding, the inventor of REST and (co-)inventor of HTTP himself.</source>
          <target state="translated">Если у вас есть какие-либо сомнения относительно того, как реализовать REST в HTTP, вы всегда можете взглянуть на спецификацию &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;протокола публикации Atom (AtomPub)&lt;/a&gt; . AtomPub - это стандарт для написания веб-сервисов RESTful с HTTP, который был разработан многими светилами HTTP и REST при участии Роя Филдинга, изобретателя REST и (со) изобретателя самого HTTP.</target>
        </trans-unit>
        <trans-unit id="ec654f9d869b9d4e7e967af9a0e460df87b82e2e" translate="yes" xml:space="preserve">
          <source>If you think you'll have huge amounts of data to store, let's talk volumes: a typical update confirmation is a fraction of a kilobyte. HTTP currently gives you a minute or two to respond definitively. Even if you only store actions for a week, clients have ample chance to catch up. If you have very high volumes, you may want a dedicated acid-compliant key value store, or an in-memory solution.</source>
          <target state="translated">Если вы думаете,что у вас будут огромные объемы данных для хранения,давайте поговорим об объемах:типичное подтверждение обновления составляет долю килобайта.HTTP в настоящее время дает вам минуту или две,чтобы ответить окончательно.Даже если вы храните действия только в течение недели,у клиентов есть достаточно шансов наверстать упущенное.Если у вас очень большие объемы,вам может понадобиться специализированное хранилище значений ключей,соответствующих кислоте,или раствор в памяти.</target>
        </trans-unit>
        <trans-unit id="5e3f77bd7d922a0787f75fec577234f6dce48c77" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;POST&lt;/strong&gt; method you can send body params in &lt;code&gt;form-data&lt;/code&gt;</source>
          <target state="translated">В методе &lt;strong&gt;POST&lt;/strong&gt; вы можете отправлять параметры тела в &lt;code&gt;form-data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae084cc36a47a0ae5ba94fddaf0353c8961a476b" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PUT&lt;/strong&gt; method you have to send body params in &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">В методе &lt;strong&gt;PUT&lt;/strong&gt; вы должны отправлять параметры тела в &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9431cceefc51a270cdbc8ad21cfd20758abb6247" translate="yes" xml:space="preserve">
          <source>In REST, there's no such thing as a resource containing &quot;content&quot;. I refer as &quot;content&quot; to data that the service uses to render representations consistently. It typically consists of some related rows in a database or a file (e.g. an image file). It's up to the service to convert the user's content into something the service can use, e.g. converting a JSON payload into SQL statements.</source>
          <target state="translated">В REST нет ресурса,содержащего &quot;контент&quot;.Я называю &quot;контентом&quot; данные,которые сервис использует для последовательного представления.Обычно он состоит из некоторых связанных строк в базе данных или файле (например,файл изображения).Именно от службы зависит преобразование пользовательского контента в то,что может быть использовано службой,например,преобразование полезной нагрузки JSON в SQL-операторы.</target>
        </trans-unit>
        <trans-unit id="258ba4ae5c03cdfdac38fed39baa86957f31d85a" translate="yes" xml:space="preserve">
          <source>In a single line, use &lt;strong&gt;POST&lt;/strong&gt; to add &lt;strong&gt;a new entry&lt;/strong&gt; in the database and &lt;strong&gt;PUT&lt;/strong&gt; to &lt;strong&gt;update&lt;/strong&gt; something in the database.</source>
          <target state="translated">В одной строке используйте &lt;strong&gt;POST&lt;/strong&gt; для добавления &lt;strong&gt;новой записи&lt;/strong&gt; в базу данных и &lt;strong&gt;PUT&lt;/strong&gt; для &lt;strong&gt;обновления&lt;/strong&gt; чего-либо в базе данных.</target>
        </trans-unit>
        <trans-unit id="935d9d64a7b6c614a61126ee51efa95f2a005750" translate="yes" xml:space="preserve">
          <source>In a very simple way I'm taking the example of the Facebook timeline.</source>
          <target state="translated">В очень простом виде я беру пример с временной шкалой Facebook.</target>
        </trans-unit>
        <trans-unit id="5796889f185413ae8caeb602438951b389d9b045" translate="yes" xml:space="preserve">
          <source>In addition to differences suggested by others, I want to add one more.</source>
          <target state="translated">В дополнение к различиям,предложенным другими,я хочу добавить еще одно.</target>
        </trans-unit>
        <trans-unit id="d0a40d3ab4c006f0fd0242d76461457c6d244bfe" translate="yes" xml:space="preserve">
          <source>In both cases, the request body contains the data for the resource to be created or updated. It should be obvious from the route names that POST is not idempotent (if you call it 3 times it will create 3 objects), but PUT is idempotent (if you call it 3 times the result is the same). PUT is often used for &quot;upsert&quot; operation (create or update), but you can always return a 404 error if you only want to use it to modify.</source>
          <target state="translated">В обоих случаях орган заявки содержит данные для создаваемого или обновляемого ресурса.Из имен маршрутов должно быть очевидно,что POST не является idempotent (если вы назовёте его 3 раза,то он создаст 3 объекта),а PUT является idempotent (если вы назовёте его 3 раза,то результат будет тот же самый).PUT часто используется для операции &quot;upsert&quot; (создать или обновить),но вы всегда можете вернуть ошибку 404,если хотите использовать ее только для модификации.</target>
        </trans-unit>
        <trans-unit id="573cffeb2d758c1d002d1b38d8d410abd12cf26c" translate="yes" xml:space="preserve">
          <source>In both cases, these operations can be performed multiple times with the same results. That is the resource will not be changed by requesting the operation more than once. Hence, a true idempotent operation.
Use the HTTP POST method when:</source>
          <target state="translated">В обоих случаях эти операции могут быть выполнены несколько раз с одинаковыми результатами.То есть ресурс не будет меняться,запрашивая операцию более одного раза.Следовательно,это настоящая идолопоклонная операция.Используйте метод HTTP POST when:</target>
        </trans-unit>
        <trans-unit id="cbfc88d28449849d5a03796a1b27b42013a1a384" translate="yes" xml:space="preserve">
          <source>In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an &quot;INSERT&quot; query.</source>
          <target state="translated">В случае POST,если один и тот же запрос выполняется несколько раз,то в БД создается несколько студенческих записей и состояние БД меняется при каждом выполнении запроса &quot;INSERT&quot;.</target>
        </trans-unit>
        <trans-unit id="315a82166f32c0e6bdbe44329b3f92d7b32440b4" translate="yes" xml:space="preserve">
          <source>In fact, you might even be able to use AtomPub directly. While it came out of the blogging community, it is in no way restricted to blogging: it is a generic protocol for RESTfully interacting with arbitrary (nested) collections of arbitrary resources via HTTP. If you can represent your application as a nested collection of resources, then you can just use AtomPub and not worry about whether to use PUT or POST, what HTTP Status Codes to return and all those details.</source>
          <target state="translated">На самом деле,вы даже можете использовать AtomPub напрямую.Хотя он вышел из блог-сообщества,он ни в коем случае не ограничен блогами:это общий протокол для RESTfully взаимодействия с произвольными (вложенными)коллекциями произвольных ресурсов по HTTP.Если вы можете представить свое приложение в виде вложенной коллекции ресурсов,то вы можете просто использовать AtomPub и не беспокоиться о том,использовать ли PUT или POST,какие коды статусов HTTP возвращать и все эти детали.</target>
        </trans-unit>
        <trans-unit id="4b6a091fc94c88da148a77392e516193f6f66982" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;POST&lt;/code&gt; is used to &lt;strong&gt;create&lt;/strong&gt;.</source>
          <target state="translated">Другими словами, &lt;code&gt;POST&lt;/code&gt; используется для &lt;strong&gt;создания&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfbe76fe288131ae25a4df6a695eb5ab43c9f7d" translate="yes" xml:space="preserve">
          <source>In practice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; that summarizes the best practices.</source>
          <target state="translated">На практике POST хорошо работает для создания ресурсов. URL вновь созданного ресурса должен быть возвращен в заголовке ответа Location. PUT следует использовать для полного обновления ресурса. Пожалуйста, поймите, что это лучшие практики при разработке RESTful API. Спецификация HTTP как таковая не ограничивает использование PUT / POST с некоторыми ограничениями для создания / обновления ресурсов. Взгляните на &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; , где обобщены лучшие практики.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">Короче говоря:</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="f8f5b658f1ff8b04b3e81cc7e7976e9561692c82" translate="yes" xml:space="preserve">
          <source>It is true that the R(etrieve) and D(elete) of the CRUD operations can be mapped directly to the HTTP methods GET and DELETE respectively. However, the confusion lies in the C(reate) and U(update) operations. In some cases, one can use the PUT for a create while in other cases a POST will be required. The ambiguity lies in the definition of an HTTP PUT method versus an HTTP POST method.</source>
          <target state="translated">Верно,что R(etrieve)и D(elete)операций CRUD могут быть отображены непосредственно на HTTP методы GET и DELETE соответственно.Однако,путаница заключается в операциях C(reate)и U(update).В некоторых случаях можно использовать PUT для создания,в других случаях потребуется POST.Неопределенность заключается в определении метода HTTP PUT в сравнении с методом HTTP POST.</target>
        </trans-unit>
        <trans-unit id="a419fc1de6f5fcd3ae809038b7b9a687efa1b1dd" translate="yes" xml:space="preserve">
          <source>It now may be tempting to simply return a 303 in the event that a POST is repeated. However, the opposite is true. Returning a 303 would only make sense if multiple create requests (creating different resources) return the same content. An example would be a &quot;thank you for submitting your request message&quot; that the client need not re-download each time. RFC 7231 still maintains in section 4.2.2 that POST is not to be idempotent and continues to maintain that POST should be used for create.</source>
          <target state="translated">Теперь может возникнуть соблазн просто вернуть 303 в случае повторения ПОСТА.Однако верно и обратное.Возврат 303 будет иметь смысл только в том случае,если несколько запросов на создание (создание разных ресурсов)вернут одно и то же содержимое.В качестве примера можно привести &quot;спасибо за отправку сообщения с запросом&quot;,которое клиент не должен каждый раз перезагружать.RFC 7231 все еще утверждает в разделе 4.2.2,что POST не должен быть idempotent и продолжает утверждать,что POST должен использоваться для создания.</target>
        </trans-unit>
        <trans-unit id="82a86d7eed2a55a644d7944a1404883b9ed82ac6" translate="yes" xml:space="preserve">
          <source>Let me highlight some important parts of the spec:</source>
          <target state="translated">Позвольте мне выделить некоторые важные части спецификации:</target>
        </trans-unit>
        <trans-unit id="27175fcbf0cac61488369580d1a39f1dc721a45f" translate="yes" xml:space="preserve">
          <source>Let's be very clear and direct here. If you are a .NET developer working with Web API, the facts are (from the Microsoft API documentation),
&lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&lt;/a&gt;:</source>
          <target state="translated">Давайте будем очень ясными и прямыми. Если вы являетесь разработчиком .NET, работающим с Web API, факты (из документации Microsoft API), &lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web -api-that-поддерживает-crud-операции&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="857a3f4adc539ed4bbe21171ae40606e572a4ee6" translate="yes" xml:space="preserve">
          <source>Merge (Update if already existing, else insert)</source>
          <target state="translated">Слияние (Обновить,если уже есть,вставить)</target>
        </trans-unit>
        <trans-unit id="d6917a3435aea050d9a0d15a35f97af6e01858e4" translate="yes" xml:space="preserve">
          <source>Most of the time, you will use them like this:</source>
          <target state="translated">Большую часть времени вы будете использовать их вот так:</target>
        </trans-unit>
        <trans-unit id="d61559b89b4cc3627f671076f6d46721d16134fc" translate="yes" xml:space="preserve">
          <source>Neither is quite right.</source>
          <target state="translated">И это тоже не совсем верно.</target>
        </trans-unit>
        <trans-unit id="29c91aceaf4eab28f2f98e779bebb50691497adc" translate="yes" xml:space="preserve">
          <source>Note that POST &quot;creates&quot; a new element in the collection, and PUT &quot;replaces&quot; an element at a given URL, but it is a very common practice to use PUT for partial modifications, that is, use it only to update existing resources and only modify the included fields in the body (ignoring the other fields). This is technically incorrect, if you want to be REST-purist, PUT should replace the whole resource and you should use PATCH for the partial update. I personally don't care much as far as the behavior is clear and consistent across all your API endpoints.</source>
          <target state="translated">Обратите внимание,что POST &quot;создает&quot; новый элемент в коллекции,и PUT &quot;заменяет&quot; элемент на заданный URL,но это очень распространенная практика использования PUT для частичных изменений,то есть использовать его только для обновления существующих ресурсов и только изменять включенные поля в теле (игнорируя другие поля).Это технически неправильно,если вы хотите быть REST-пуристом,PUT должен заменить весь ресурс,и вы должны использовать PATCH для частичного обновления.Лично меня не сильно волнует,насколько четкое и последовательное поведение во всех ваших конечных точках API.</target>
        </trans-unit>
        <trans-unit id="aed489a86f6999b5a22f73530a241b671e75935e" translate="yes" xml:space="preserve">
          <source>Note that in this case the resource
  name is not specified, the new objects
  URL path would be returned to you.</source>
          <target state="translated">Обратите внимание,что в этом случае имя ресурса не указано,новый URL-адрес объекта будет возвращен вам.</target>
        </trans-unit>
        <trans-unit id="d0190e7f10880e789af039b6a119817ade48d5dc" translate="yes" xml:space="preserve">
          <source>Note that the following is an error:</source>
          <target state="translated">Обратите внимание,что следующее является ошибкой:</target>
        </trans-unit>
        <trans-unit id="94ed497609bfa8317d3c8fed64915d395cd4506d" translate="yes" xml:space="preserve">
          <source>Note, however, that not all modern browsers support HTTP verbs other than GET or POST.</source>
          <target state="translated">Обратите внимание,однако,что не все современные браузеры поддерживают HTTP глаголы,отличные от GET или POST.</target>
        </trans-unit>
        <trans-unit id="3e324155fc5920c681ee3f3fe84a2ed08ebec851" translate="yes" xml:space="preserve">
          <source>Once you are using PUT you are refering to a &lt;strong&gt;resource&lt;/strong&gt; or single item, possibly inside a &lt;strong&gt;collection&lt;/strong&gt;. So when you say:</source>
          <target state="translated">Как только вы используете PUT, вы ссылаетесь на &lt;strong&gt;ресурс&lt;/strong&gt; или отдельный элемент, возможно, внутри &lt;strong&gt;коллекции&lt;/strong&gt; . Поэтому, когда вы говорите:</target>
        </trans-unit>
        <trans-unit id="c5516139d4acd3169adf148d2df83962379be2e8" translate="yes" xml:space="preserve">
          <source>Otherwise, use POST to initially create the object, and PUT to update the object:</source>
          <target state="translated">В противном случае,используйте POST для первоначального создания объекта,а PUT для обновления объекта:</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="4413fe84411cbdf88cfc031d8a1393f608c4e15e" translate="yes" xml:space="preserve">
          <source>POST as send mail in &lt;strong&gt;post&lt;/strong&gt; office.</source>
          <target state="translated">POST как отправить почту в &lt;strong&gt;почтовом&lt;/strong&gt; отделении.</target>
        </trans-unit>
        <trans-unit id="1e2c64ac62aa82754ed88cbebd18c452a61f35fc" translate="yes" xml:space="preserve">
          <source>POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing -- if you think about it, creating a new member of a collection is actually a special case of this kind of update, from the collection's perspective)</source>
          <target state="translated">POST также может использоваться для неосвобожденных обновлений существующих объектов (в частности,изменение части объекта без указания всего объекта --если подумать,то создание нового члена коллекции на самом деле является особым случаем такого рода обновлений,с точки зрения коллекции)</target>
        </trans-unit>
        <trans-unit id="7199a1f38c458034e4e9122d80a96f6d399a16c7" translate="yes" xml:space="preserve">
          <source>POST can perform the other three functions, but then the semantics of the request will be lost on the intermediaries such as caches and proxies. This also applies to providing security on the resource, since a post's URI doesn't necessarily indicate the resource it is applying to (it can though).</source>
          <target state="translated">POST может выполнять три другие функции,но тогда семантика запроса будет потеряна на посредниках,таких как кэш и прокси.Это также относится к обеспечению безопасности на ресурсе,так как URI сообщения не обязательно указывает на ресурс,к которому оно применяется (хотя может).</target>
        </trans-unit>
        <trans-unit id="a3841df602dc207eb894628e42ca39fa38600ef6" translate="yes" xml:space="preserve">
          <source>POST invalidates cached copies of the entire containing resource (better consistency)</source>
          <target state="translated">POST делает недействительными кэшированные копии всего содержащего ресурса (лучшая согласованность)</target>
        </trans-unit>
        <trans-unit id="c22f736aab2b2863938a628162d88b4124790887" translate="yes" xml:space="preserve">
          <source>POST is basically a free form message, with its meaning being defined 'out of band'. If the message can be interpreted as adding a resource to a directory, that would be OK, but basically you need to understand the message you are sending (posting) to know what will happen with the resource.</source>
          <target state="translated">POST-это,по сути,сообщение в свободной форме,значение которого определяется как &quot;вне диапазона&quot;.Если сообщение может быть интерпретировано как добавление ресурса в каталог,это будет нормально,но в основном вам нужно понять сообщение,которое вы посылаете (отправляете),чтобы знать,что произойдёт с ресурсом.</target>
        </trans-unit>
        <trans-unit id="50e5624274970285a79a86def7e5f8ea14309ec5" translate="yes" xml:space="preserve">
          <source>POST is good for creating new objects under a collection (and create does not need to be idempotent)</source>
          <target state="translated">POST хорошо подходит для создания новых объектов под коллекцию (и создание не обязательно должно быть idempotent).</target>
        </trans-unit>
        <trans-unit id="a4348a436cd7cc96fdb0094e0c165b3beab9d039" translate="yes" xml:space="preserve">
          <source>POST is like posting a letter to a mailbox or posting an email to an email queue.
PUT is like when you put an object in a cubby hole or a place on a shelf (it has a known address).</source>
          <target state="translated">POST подобен отправке письма на почтовый ящик или отправке электронного письма в очередь.PUT-это то же самое,что когда вы помещаете объект в кубовое отверстие или место на полке (у него есть известный адрес).</target>
        </trans-unit>
        <trans-unit id="4db2a3f164214c5ab6b6162614daef8028ccda38" translate="yes" xml:space="preserve">
          <source>POST is not idempotent and the server &amp;hellip;</source>
          <target state="translated">ПОСТ не идемпотент, а сервер&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="6bf075a0e5bf009d906f75d40d6c584b360d7cb7" translate="yes" xml:space="preserve">
          <source>POST is used to send data to server.</source>
          <target state="translated">POST используется для отправки данных на сервер.</target>
        </trans-unit>
        <trans-unit id="f6c4170f0e615f9fa2848d48db2ab50f375369c3" translate="yes" xml:space="preserve">
          <source>POST:</source>
          <target state="translated">POST:</target>
        </trans-unit>
        <trans-unit id="d18f4e998d15f0ab1bd153b920ca0c74bdfeff78" translate="yes" xml:space="preserve">
          <source>POSTing twice with the same data means create two identical users with different ids. PUTing twice with the same data creates the user the first and updates him to the same state the second time (no changes). Since you end up with the same state after a &lt;code&gt;PUT&lt;/code&gt; no matter how many times you perform it, it is said to be &quot;equally potent&quot; every time - idempotent. This is useful for automatically retrying requests. No more 'are you sure you want to resend' when you push the back button on the browser.</source>
          <target state="translated">Двойная публикация с одинаковыми данными означает создание двух идентичных пользователей с разными идентификаторами. PUT дважды с одними и теми же данными создает пользователя первым и обновляет его до того же состояния во второй раз (без изменений). Поскольку после &lt;code&gt;PUT&lt;/code&gt; вы получаете одно и то же состояние, независимо от того, сколько раз вы его выполняете, оно называется &amp;laquo;одинаково мощным&amp;raquo; каждый раз - идемпотентным. Это полезно для автоматической повторной попытки запросов. Нет больше &amp;laquo;вы уверены, что хотите отправить&amp;raquo;, когда вы нажимаете кнопку &amp;laquo;Назад&amp;raquo; в браузере.</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="0774c3d8f11a1777d7cca86a15dfce5e923b8427" translate="yes" xml:space="preserve">
          <source>PUT can also be used for create if and only if you allow the client to name the resource. But since REST clients aren't supposed to make assumptions about URL structure, this is less in the intended spirit of things.</source>
          <target state="translated">PUT также может использоваться для создания,если и только если вы разрешаете клиенту давать имя ресурсу.Но поскольку клиенты REST не должны делать предположений о структуре URL,это в меньшей степени соответствует предполагаемому духу вещей.</target>
        </trans-unit>
        <trans-unit id="53edc2f185fb0dcf741606243cd7f49687d0ba85" translate="yes" xml:space="preserve">
          <source>PUT i.e. take and &lt;strong&gt;put&lt;/strong&gt; where it was.</source>
          <target state="translated">PUT т.е. возьми и &lt;strong&gt;положи,&lt;/strong&gt; где это было.</target>
        </trans-unit>
        <trans-unit id="d17262b9924f1628e9bc6d1ceface83dc9e20080" translate="yes" xml:space="preserve">
          <source>PUT is good for updating existing objects (and update needs to be idempotent)</source>
          <target state="translated">PUT хорош для обновления существующих объектов (и обновление должно быть idempotent).</target>
        </trans-unit>
        <trans-unit id="2528780fd61687817cc4d77380ca20d9c55d5327" translate="yes" xml:space="preserve">
          <source>PUT is idempotent, so if you PUT an object twice, it has no effect.  This is a nice property, so I would use PUT when possible.</source>
          <target state="translated">PUT является идимпотентом,поэтому,если вы нанесете объект дважды,это не будет иметь никакого эффекта.Это хорошее свойство,поэтому я бы использовал PUT,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="f54bdf6757feb089a4b6dd6043ed5a3812f4c969" translate="yes" xml:space="preserve">
          <source>PUT is idempotent. You can send the request 100 times and it will not matter. POST is not idempotent. If you send the request 100 times, you'll get 100 emails or 100 letters in your postal box.</source>
          <target state="translated">PUT-идиотка.Вы можете отправить запрос 100 раз и это не будет иметь значения.POST не идиотский.Если вы отправите запрос 100 раз,вы получите 100 писем или 100 писем в вашем почтовом ящике.</target>
        </trans-unit>
        <trans-unit id="7a94e837da966e20c0283efdebc7e6e8c4792dd1" translate="yes" xml:space="preserve">
          <source>PUT is less supported by e.g. Java ME, older browsers, firewalls</source>
          <target state="translated">PUT менее поддерживается,например,Java ME,старыми браузерами,брандмауэрами.</target>
        </trans-unit>
        <trans-unit id="beb21b8c66904ea993c9a6028ecf712630358d0d" translate="yes" xml:space="preserve">
          <source>PUT is merely a statement of what content the service should, from now on, use to render representations of the resource identified by the client; POST is a statement of what content the service should, from now on, contain (possibly duplicated) but it's up to the server how to identify that content.</source>
          <target state="translated">PUT-это просто указание на то,какое содержимое отныне должно использоваться сервисом для предоставления представлений ресурса,идентифицированного клиентом;POST-это указание на то,какое содержимое отныне должно содержаться сервисом (возможно,дублироваться),но только от сервера зависит,как идентифицировать это содержимое.</target>
        </trans-unit>
        <trans-unit id="481e4b9e200d5c2fea82c751622373a2b6a00819" translate="yes" xml:space="preserve">
          <source>PUT is used to transfer state to the server</source>
          <target state="translated">PUT используется для передачи состояния на сервер.</target>
        </trans-unit>
        <trans-unit id="bad5201391f46977a9f8deb44fc372a5bc244a21" translate="yes" xml:space="preserve">
          <source>PUT refers to a resource, identified by the URI. In this case, you are updating it. It is the part of the three verbs referring to resources -- delete and get being the other two.</source>
          <target state="translated">PUT относится к ресурсу,идентифицированному URI.В этом случае вы обновляете его.Это часть трех глаголов,относящихся к ресурсам-удалить и стать двумя другими.</target>
        </trans-unit>
        <trans-unit id="d444f457d29e103ad92323fcf2afb2424bd83004" translate="yes" xml:space="preserve">
          <source>PUT responses are not cacheable while POST ones are (Require Content-Location and expiration)</source>
          <target state="translated">PUT-ответы не кэшируются,а POST-ответы (Требовать Content-Location и истечения срока действия).</target>
        </trans-unit>
        <trans-unit id="15640c28b6c6596379e40a0e541c4b7183207d73" translate="yes" xml:space="preserve">
          <source>PUT vs. POST in REST</source>
          <target state="translated">PUT против POST в REST.</target>
        </trans-unit>
        <trans-unit id="ecd7c4f13506fe5521c5fe5e1b3db337ba4711ed" translate="yes" xml:space="preserve">
          <source>PUT:</source>
          <target state="translated">PUT:</target>
        </trans-unit>
        <trans-unit id="ecbeb70dff39883fdc79bab75f4eab0476369bf3" translate="yes" xml:space="preserve">
          <source>Performing a POST of data which has an ID which matches a resource already in the system is &amp;ldquo;a conflict with the current state of the resource.&amp;rdquo;</source>
          <target state="translated">Выполнение POST данных с идентификатором, который соответствует ресурсу, уже находящемуся в системе, является &amp;laquo;конфликтом с текущим состоянием ресурса&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="55c27430d43b1ad1ac779b51ba33aaaa16817d5a" translate="yes" xml:space="preserve">
          <source>Prior to PUT, clients couldn't directly know the URL that the server generated or if all it had generated any or whether the data to be sent to the server is already updated or not. PUT relieved the developer of all these headaches. PUT is idempotent, PUT handles race conditions, and PUT lets the client choose the URL.</source>
          <target state="translated">До PUT клиенты не могли напрямую узнать URL-адрес,который генерировал сервер,или все ли данные,которые он генерировал,или же данные,которые должны были быть отправлены на сервер,уже обновлены или нет.PUT избавлял разработчика от всех этих головных болей.PUT является idempotent,PUT обрабатывает условия гонки,и PUT позволяет клиенту выбрать URL.</target>
        </trans-unit>
        <trans-unit id="500abc23a1f880a1d70f33cc1a5912ba903fcf59" translate="yes" xml:space="preserve">
          <source>REST is a &lt;em&gt;very&lt;/em&gt; high-level concept. In fact, it doesn't even mention HTTP at all!</source>
          <target state="translated">REST - это концепция &lt;em&gt;очень&lt;/em&gt; высокого уровня. На самом деле, он даже не упоминает HTTP вообще!</target>
        </trans-unit>
        <trans-unit id="f3f878fdda60ba178358813e7e7547df7ca8bed3" translate="yes" xml:space="preserve">
          <source>RFC 5789 says about PATCH (since 1995):</source>
          <target state="translated">RFC 5789 говорит о PATCH (с 1995 года):</target>
        </trans-unit>
        <trans-unit id="2240960be744587b090255e994fafdd819cc51d2" translate="yes" xml:space="preserve">
          <source>Readers new to this topic will be struck by the endless discussion about what you &lt;em&gt;should&lt;/em&gt; do, and the relative absence of lessons from experience. The fact that REST is &quot;preferred&quot; over SOAP is, I suppose, a high-level learning from experience, but goodness we must have progressed from there? It's 2016. Roy's dissertation was in 2000. What have we developed? Was it fun? Was it easy to integrate with? To support? Will it handle the rise of smartphones and flaky mobile connections?</source>
          <target state="translated">Читатели, плохо знакомые с этой темой, будут поражены бесконечным обсуждением того, что вы &lt;em&gt;должны&lt;/em&gt; делать, и относительным отсутствием уроков из опыта. Тот факт, что REST является &amp;laquo;более предпочтительным&amp;raquo;, чем SOAP, является, я полагаю, высокоуровневым обучением на основе опыта, но разве мы добились прогресса оттуда? Это 2016 год. Диссертация Роя была в 2000 году. Что мы разработали? Это было весело? Было ли легко интегрироваться? Поддерживать? Будет ли он справляться с ростом смартфонов и нестабильной мобильной связи?</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="af48dc320f6330ed03797587a11eef43f0ec6f79" translate="yes" xml:space="preserve">
          <source>Remember, REST is a set of conventions and guidelines to keep your API simple. If you end up with a complicated work-around just to check the &quot;RESTfull&quot; box then you are defeating the purpose ;)</source>
          <target state="translated">Помните,что REST-это набор конвенций и рекомендаций для упрощения вашего API.Если вы закончите сложную обработку только для того,чтобы поставить галочку в поле &quot;RESTfull&quot;,то вы проигрываете цель;)</target>
        </trans-unit>
        <trans-unit id="ee7cc50d6752f70e6ef133296cf031acbf88d94d" translate="yes" xml:space="preserve">
          <source>Ruby on Rails 4.0 will use the 'PATCH' method instead of PUT to do partial updates.</source>
          <target state="translated">Ruby on Rails 4.0 будет использовать метод 'PATCH' вместо PUT для выполнения частичных обновлений.</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="e1a55a92c976da44c042e91aaa4d8b45fd7ebc14" translate="yes" xml:space="preserve">
          <source>Simple rule of thumb: Use POST to create, use PUT to update.</source>
          <target state="translated">Простое эмпирическое правило:Используйте POST для создания,PUT для обновления.</target>
        </trans-unit>
        <trans-unit id="563433492d9997914d4d5639b5bd77063df84eaa" translate="yes" xml:space="preserve">
          <source>Since the important part is for the client to understand the server has the resource and to take appropriate action. This is a &amp;ldquo;situation(s) where it is expected that the user might be able to resolve the conflict and resubmit the request.&amp;rdquo;</source>
          <target state="translated">Поскольку важная часть для клиента, чтобы понять, сервер имеет ресурс и принять соответствующие меры. Это &amp;laquo;ситуация (ситуации), когда ожидается, что пользователь сможет разрешить конфликт и повторно отправить запрос&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="214742f8ecec0788b74789ec5780c31fcabbb394" translate="yes" xml:space="preserve">
          <source>So you use POST and probably, but not necessary PUT for resource creation. You don't have to support both. For me POST is perfectly enough. So it is a design decision.</source>
          <target state="translated">То есть вы используете POST и,возможно,но не обязательно PUT для создания ресурса.Вам не нужно поддерживать и то,и другое.Для меня POST вполне достаточно.Так что это дизайнерское решение.</target>
        </trans-unit>
        <trans-unit id="312dad788b38db2f97ab20722cebe3f87855dfa4" translate="yes" xml:space="preserve">
          <source>So, which one should be used to create a resource? Or one needs to support both?</source>
          <target state="translated">Итак,какой из них следует использовать для создания ресурса? Или нужно поддерживать и то,и другое?</target>
        </trans-unit>
        <trans-unit id="af333de22f5db2954bfe57966628566c2cb3ee43" translate="yes" xml:space="preserve">
          <source>So: To save an existing user, or one where the client generates the id and it's been verified that the id is unique:</source>
          <target state="translated">Итак:Сохранить существующего пользователя,или пользователя,в котором клиент генерирует идентификатор,и было проверено,что идентификатор является уникальным:</target>
        </trans-unit>
        <trans-unit id="a8710dbdab40fac5c2f6093ab0a397321add575c" translate="yes" xml:space="preserve">
          <source>Social Media/Network Analogy:</source>
          <target state="translated">Аналогия Social MediaNetwork Analogy:</target>
        </trans-unit>
        <trans-unit id="aa6e7d148420cbd536359dd8922d3a773a333631" translate="yes" xml:space="preserve">
          <source>Some considerations:</source>
          <target state="translated">Некоторые соображения:</target>
        </trans-unit>
        <trans-unit id="f07350c10b92f7bbca1cebbb0c1aaadbf6301a75" translate="yes" xml:space="preserve">
          <source>Some other considerations:</source>
          <target state="translated">Некоторые другие соображения:</target>
        </trans-unit>
        <trans-unit id="1392b1cbf3bb0fbae1580de51f28c0eb49cc1f97" translate="yes" xml:space="preserve">
          <source>Spec:</source>
          <target state="translated">Spec:</target>
        </trans-unit>
        <trans-unit id="9d63a661c96623ad056cc93701a94dbcd5290eef" translate="yes" xml:space="preserve">
          <source>Step 6 is where people commonly get confused about what to do. However, there is no reason to create a kludge to solve this issue. Instead, HTTP can be used as specified in &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616&lt;/a&gt; and the server replies:</source>
          <target state="translated">На шестом этапе люди обычно не понимают, что делать. Тем не менее, нет причин для создания этой проблемы. Вместо этого можно использовать HTTP, как указано в &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616,&lt;/a&gt; и сервер отвечает:</target>
        </trans-unit>
        <trans-unit id="b49764080a9692f4a67935d54ce3bb45209b490c" translate="yes" xml:space="preserve">
          <source>Student Id is auto generated.</source>
          <target state="translated">Студенческий идентификатор автоматически генерируется.</target>
        </trans-unit>
        <trans-unit id="aca4c099b5e77d0411d947634e38f0631bf9e86a" translate="yes" xml:space="preserve">
          <source>Successive delete requests can see and process the original confirmation, without hitting a 404 error. If things take longer than expected, we can respond provisionally, and we have a place where the client can check back for the definitive result. The nicest part of this pattern is its Kung-Fu (Panda) property. We take a weakness, the propensity for clients to repeat a request any time they don't understand the response, and turn it into &lt;em&gt;a strength&lt;/em&gt; :-)</source>
          <target state="translated">Последовательные запросы на удаление могут просматривать и обрабатывать исходное подтверждение без ошибки 404. Если все займет больше времени, чем ожидалось, мы можем дать предварительный ответ, и у нас есть место, где клиент может проверить окончательный результат. Самая приятная часть этого шаблона - это его свойство кунг-фу (панда). Мы берем слабость, склонность клиентов повторять запрос каждый раз, когда они не понимают ответ, и превращаем его в &lt;em&gt;силу&lt;/em&gt; :-)</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="b9802a34f75ab08b9f79a147b7c88bf20e2dd462" translate="yes" xml:space="preserve">
          <source>Sure you &quot;can&quot; use &quot;POST&quot; to update, but just follow the conventions laid out for you with your given framework. In my case it is .NET / Web API, so &lt;strong&gt;PUT is for UPDATE&lt;/strong&gt; there is no debate.</source>
          <target state="translated">Конечно, вы &amp;laquo;можете&amp;raquo; использовать &amp;laquo;POST&amp;raquo; для обновления, но просто следуйте соглашениям, изложенным для вас с вашей данной платформой. В моем случае это .NET / Web API, поэтому &lt;strong&gt;PUT для ОБНОВЛЕНИЯ&lt;/strong&gt; не обсуждается.</target>
        </trans-unit>
        <trans-unit id="88f36ec6e839653d0f7569117f42e1085634abaa" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;PUT&lt;/code&gt; is used to &lt;strong&gt;create or update&lt;/strong&gt;.</source>
          <target state="translated">То есть &lt;code&gt;PUT&lt;/code&gt; используется для &lt;strong&gt;создания или обновления&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6228527a9fe538603ee8860a20980509cae0390f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/strong&gt; method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the &lt;code&gt;Request-URI&lt;/code&gt; in the &lt;code&gt;Request-Line&lt;/code&gt;</source>
          <target state="translated">Метод &lt;strong&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/strong&gt; используется для запроса, чтобы исходный сервер принял объект, включенный в запрос, в качестве нового подчиненного ресурса, идентифицируемого &lt;code&gt;Request-URI&lt;/code&gt; в &lt;code&gt;Request-Line&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf25e1a44ff44b0b030b51303b10b2f4e6c0844" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/strong&gt; method requests that the enclosed entity be stored under the supplied &lt;code&gt;Request-URI&lt;/code&gt;. If the &lt;code&gt;Request-URI&lt;/code&gt; refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the &lt;code&gt;Request-URI&lt;/code&gt; does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.&quot;</source>
          <target state="translated">Метод &lt;strong&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/strong&gt; запрашивает, чтобы вложенный объект был сохранен под предоставленным &lt;code&gt;Request-URI&lt;/code&gt; . Если &lt;code&gt;Request-URI&lt;/code&gt; ссылается на уже существующий ресурс, вложенный объект СЛЕДУЕТ рассматривать как модифицированную версию, находящуюся на исходном сервере. Если &lt;code&gt;Request-URI&lt;/code&gt; не указывает на существующий ресурс и этот URI может быть определен как новый ресурс запрашивающим пользовательским агентом, исходный сервер может создать ресурс с этим URI. &quot;</target>
        </trans-unit>
        <trans-unit id="59c1ac24b7aebd8b407e3f0c9ff99488ea7968e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;POST&lt;/strong&gt; method is used to request that the origin server &lt;strong&gt;accept&lt;/strong&gt; the entity enclosed in the request as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; subordinate&lt;/strong&gt; of the resource identified by the Request-URI in the Request-Line</source>
          <target state="translated">Метод &lt;strong&gt;POST&lt;/strong&gt; используется для запроса, чтобы исходный сервер &lt;strong&gt;принял&lt;/strong&gt; объект, включенный в запрос, в качестве &lt;strong&gt;&lt;em&gt;нового&lt;/em&gt; подчиненного&lt;/strong&gt; ресурса, идентифицируемого Request-URI в строке запроса</target>
        </trans-unit>
        <trans-unit id="c563bf37c1b157d8576106b8f94786d60d4a88a8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;PUT&lt;/strong&gt; method requests that the enclosed entity be &lt;strong&gt;stored&lt;/strong&gt; under the supplied Request-URI. If the Request-URI refers to an &lt;strong&gt;already existing&lt;/strong&gt; resource, the enclosed entity SHOULD be considered as a &lt;strong&gt;modified version&lt;/strong&gt; of the one residing on the origin server. If the Request-URI does &lt;strong&gt;not point to an existing&lt;/strong&gt; resource, and that URI is &lt;strong&gt;capable&lt;/strong&gt; of being defined as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; resource&lt;/strong&gt; by the requesting user agent, the origin server can &lt;strong&gt;create&lt;/strong&gt; the resource with that URI.&quot;</source>
          <target state="translated">Метод &lt;strong&gt;PUT&lt;/strong&gt; запрашивает, чтобы вложенный объект был &lt;strong&gt;сохранен&lt;/strong&gt; под предоставленным Request-URI. Если Request-URI ссылается на &lt;strong&gt;уже существующий&lt;/strong&gt; ресурс, вложенный объект СЛЕДУЕТ рассматривать как &lt;strong&gt;модифицированную версию,&lt;/strong&gt; находящуюся на исходном сервере. Если Request-URI &lt;strong&gt;не указывает на существующий&lt;/strong&gt; ресурс и этот URI &lt;strong&gt;может&lt;/strong&gt; быть определен как &lt;strong&gt;&lt;em&gt;новый&lt;/em&gt; ресурс&lt;/strong&gt; запрашивающим пользовательским агентом, исходный сервер может &lt;strong&gt;создать&lt;/strong&gt; ресурс с этим URI. &quot;</target>
        </trans-unit>
        <trans-unit id="59fcd39418146017bc9d79b2463c3bd0da6fb592" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
    &lt;code&gt;created&lt;/code&gt; or &lt;code&gt;replaced&lt;/code&gt; with the state defined by the representation
    enclosed in the request message payload.</source>
          <target state="translated">Метод PUT запрашивает, чтобы состояние целевого ресурса было &lt;code&gt;created&lt;/code&gt; или &lt;code&gt;replaced&lt;/code&gt; состоянием, определенным представлением, заключенным в полезную нагрузку сообщения запроса.</target>
        </trans-unit>
        <trans-unit id="e77dcb77c2b94fc15160e4b361047201bc47a791" translate="yes" xml:space="preserve">
          <source>The RFC reads like this:</source>
          <target state="translated">RFC читает вот так:</target>
        </trans-unit>
        <trans-unit id="2bf09923cd40e9a4020e710d08ab29ff70e0f921" translate="yes" xml:space="preserve">
          <source>The client POST a new resource to the server.</source>
          <target state="translated">Клиент POST нового ресурса на сервер.</target>
        </trans-unit>
        <trans-unit id="6d21b96b8e9dc8ceda9663e50081fd866f4a8784" translate="yes" xml:space="preserve">
          <source>The client does not have a URL for the resource (therefore PUT is not an option) and repeats the POST.</source>
          <target state="translated">Клиент не имеет URL для ресурса (поэтому PUT не является опцией)и повторяет POST.</target>
        </trans-unit>
        <trans-unit id="dab9c53b7a8f4efbb9c76b8f8b0c3647ff5ea29b" translate="yes" xml:space="preserve">
          <source>The client never receives the response.</source>
          <target state="translated">Клиент никогда не получает ответа.</target>
        </trans-unit>
        <trans-unit id="7e77aa23ca0f2f2521e9d88d6afd4e68b94dfbe8" translate="yes" xml:space="preserve">
          <source>The content type &quot;application/x-www-form-urlencoded&quot; is inefficient
  for sending large quantities of binary data or text containing
  non-ASCII characters. The content type &quot;multipart/form-data&quot; should be
  used for submitting forms that contain files, non-ASCII data, and
  binary data.</source>
          <target state="translated">Тип контента &quot;applicationx-www-form-urlencoded&quot; неэффективен для отправки больших объемов двоичных данных или текста,содержащего не-ASCII-символы.Тип содержимого &quot;многочастичные данные&quot; следует использовать для отправки форм,содержащих файлы,данные,не содержащие ASCII,и двоичные данные.</target>
        </trans-unit>
        <trans-unit id="c00e08de50ba7cbbdbcec8cf8cc194d4e2c70887" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</source>
          <target state="translated">Фундаментальное различие между ПОСТ и ПУТ-запросами отражено в различном значении Request-URI.URI в POST запросе идентифицирует ресурс,который будет обрабатывать вложенный объект.Этот ресурс может быть процессом,принимающим данные,шлюзом к какому-либо другому протоколу или отдельной сущностью,которая принимает аннотации.В отличие от этого,URI в PUT запросе идентифицирует сущность,заключенную в запрос-пользовательский агент знает,для чего предназначен URI,и сервер НЕ ДОЛЖЕН пытаться применить запрос к какому-либо другому ресурсу.</target>
        </trans-unit>
        <trans-unit id="531d093617728697be6cb081a0052d11e9261dcc" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,</source>
          <target state="translated">Фундаментальное различие между ПОСТ и ПУТ-запросами отражено в различном значении Request-URI.URI в POST запросе идентифицирует ресурс,который будет обрабатывать вложенный объект.Этот ресурс может быть процессом,принимающим данные,шлюзом к какому-либо другому протоколу или отдельной сущностью,которая принимает аннотации.В отличие от этого,URI в PUT запросе идентифицирует сущность,заключенную в запрос-пользовательский агент знает,для чего предназначен URI,и сервер НЕ ДОЛЖЕН пытаться применить запрос к какому-либо другому ресурсу.Если сервер хочет,чтобы запрос был применен к другому URI,</target>
        </trans-unit>
        <trans-unit id="9a92f77699786e960e9bee1d8eacf143a2e57922" translate="yes" xml:space="preserve">
          <source>The idea of a &lt;em&gt;RESTful-URL&lt;/em&gt; is actually a violation of REST as the server is in charge of the URL structure and should be free to decide how to use it to avoid coupling. If this confuses you read about the significance of self discovery on API design.</source>
          <target state="translated">Идея &lt;em&gt;RESTful-URL&lt;/em&gt; на самом деле является нарушением REST, так как сервер отвечает за структуру URL и должен иметь возможность самостоятельно решать, как его использовать, чтобы избежать связывания. Если это вас смущает, читайте о значении самопознания для разработки API.</target>
        </trans-unit>
        <trans-unit id="08c88ada7f30da94a298cf8074dd8cb30fa5608e" translate="yes" xml:space="preserve">
          <source>The most important consideration is &lt;em&gt;reliability&lt;/em&gt;. If a POST message gets lost the state of the system is undefined. Automatic recovery is impossible. For PUT messages, the state is undefined only until the first successful retry.</source>
          <target state="translated">Наиболее важным фактором является &lt;em&gt;надежность&lt;/em&gt; . Если сообщение POST теряется, состояние системы не определено. Автоматическое восстановление невозможно. Для сообщений PUT состояние не определено только до первой успешной попытки.</target>
        </trans-unit>
        <trans-unit id="70a1801f56d9e3b89398dd57a765b43ab4ffd957" translate="yes" xml:space="preserve">
          <source>The relevant specification for PUT and POST is &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</source>
          <target state="translated">Соответствующие спецификации для PUT и POST - &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5212416a9c7e401d69b6999879d0f06d6e6c6b8f" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
  state of the resource. This code is only allowed in situations where
  it is expected that the user might be able to resolve the conflict and
  resubmit the request. The response body SHOULD include enough</source>
          <target state="translated">Запрос не мог быть выполнен из-за конфликта с текущим состоянием ресурса.Данный код разрешен только в ситуациях,когда ожидается,что пользователь сможет разрешить конфликт и повторно отправить запрос.Тело ответа ДОЛЖНО включать достаточно</target>
        </trans-unit>
        <trans-unit id="d5fcf6a88ce59329f97adb1fc601b9b08db15db3" translate="yes" xml:space="preserve">
          <source>The semantics are supposed be different, in that &quot;PUT&quot;, like &quot;GET&quot; is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.</source>
          <target state="translated">Семантика должна быть иной,в том смысле,что &quot;PUT&quot;,как и &quot;GET&quot;,должен быть идимпотентным-это означает,что вы можете один и тот же точный запрос на PUT несколько раз,и результат будет таким же,как если бы вы выполнили его только один раз.</target>
        </trans-unit>
        <trans-unit id="6497cf669dc224da5094578e5e54fa6ced3cdbc7" translate="yes" xml:space="preserve">
          <source>The server does the business, returns the response &lt;em&gt;and stores it against the agreed action URI&lt;/em&gt;. If anything goes wrong, the client repeats the request (natural behaviour!), and if the server has already seen it, it repeats the stored response &lt;em&gt;and does nothing else&lt;/em&gt;.</source>
          <target state="translated">Сервер выполняет бизнес, возвращает ответ &lt;em&gt;и сохраняет его в соответствии с согласованным URI действия&lt;/em&gt; . Если что-то идет не так, клиент повторяет запрос (естественное поведение!), А если сервер его уже видел, он повторяет сохраненный ответ &lt;em&gt;и больше ничего не делает&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5da1be1c708bb16e849af08a7fb0aa8d0d4c1309" translate="yes" xml:space="preserve">
          <source>The server is unaware the client has not received the response.</source>
          <target state="translated">Сервер не знает,что клиент не получил ответа.</target>
        </trans-unit>
        <trans-unit id="62a97e57f72e643adc7cc713734b78e46c053ea2" translate="yes" xml:space="preserve">
          <source>The server processes the request and sends a response.</source>
          <target state="translated">Сервер обрабатывает запрос и посылает ответ.</target>
        </trans-unit>
        <trans-unit id="ad17da286154778c13914cd41e9cf66091180592" translate="yes" xml:space="preserve">
          <source>There seems to always be some confusion as to when to use the HTTP POST versus the HTTP PUT method for REST services. Most developers will try to associate CRUD operations directly to HTTP methods. I will argue that this is not correct and one can not simply associate the CRUD concepts to the HTTP methods. That is:</source>
          <target state="translated">Кажется,что всегда есть некоторая путаница в том,когда использовать HTTP POST против HTTP PUT метода для сервисов REST.Большинство разработчиков попытаются связать операции CRUD непосредственно с методами HTTP.Я буду утверждать,что это неправильно и нельзя просто ассоциировать концепции CRUD с методами HTTP.То есть:</target>
        </trans-unit>
        <trans-unit id="7612d7c41fbfbe6d8a2310c67de97a21fbe00850" translate="yes" xml:space="preserve">
          <source>Therefore: &lt;strong&gt;PUT&lt;/strong&gt; is only a candidate for CREATE where the client already knows the url before the resource is created. Eg. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; as the title is used as the resource key</source>
          <target state="translated">Следовательно: &lt;strong&gt;PUT&lt;/strong&gt; является только кандидатом на CREATE, где клиент уже знает URL-адрес до создания ресурса. Например. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; в качестве заголовка используется в качестве ключа ресурса</target>
        </trans-unit>
        <trans-unit id="ea0f8ddfd30845a4b1c6a9e4d8ca5de38b2ab4ea" translate="yes" xml:space="preserve">
          <source>This forces the API to avoid state transition problems with multiple clients updating a single resource, and matches more nicely with event sourcing and CQRS. When the work is done asynchronously, POSTing the transformation and waiting for it to be applied seems appropriate.</source>
          <target state="translated">Это заставляет API избегать проблем с переходом к другому состоянию при обновлении нескольких клиентов на одном ресурсе,и более хорошо сочетается с источниками событий и CQRS.Когда работа выполняется асинхронно,POSTing преобразование и ожидание его применения кажется уместным.</target>
        </trans-unit>
        <trans-unit id="0d513503c5d27d970dedbc3a017aa5dfc6730d1b" translate="yes" xml:space="preserve">
          <source>This is what AtomPub has to say about resource creation (section 9.2):</source>
          <target state="translated">Это то,что AtomPub должен сказать о создании ресурсов (раздел 9.2):</target>
        </trans-unit>
        <trans-unit id="db06c4e9bb7f4493ec87367452486878b32df472" translate="yes" xml:space="preserve">
          <source>This jibes with the other advice here, that PUT is best applied to resources that already have a name, and POST is good for creating a new object under an existing resource (and letting the server name it).</source>
          <target state="translated">Этот переход переход переходит на другой совет,что PUT лучше всего применять к ресурсам,у которых уже есть имя,а POST хорошо подходит для создания нового объекта под существующим ресурсом (и позволяет серверу дать ему имя).</target>
        </trans-unit>
        <trans-unit id="329ccd5deda6ee5083da67216837de43b64d3560" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI of the Collection.</source>
          <target state="translated">Чтобы добавить членов в Коллекцию,клиенты посылают POST-запросы в URI Коллекции.</target>
        </trans-unit>
        <trans-unit id="8a44f83e9442ef60d290f2c8799f5cc060ff1e23" translate="yes" xml:space="preserve">
          <source>To overwrite an existing resource:</source>
          <target state="translated">Чтобы перезаписать существующий ресурс:</target>
        </trans-unit>
        <trans-unit id="300c31c8ca811ac31b1e4b0cbcc5df25674e9c0e" translate="yes" xml:space="preserve">
          <source>To understand it we need to question why PUT was required, what were the problems PUT was trying to solve that POST couldn't.</source>
          <target state="translated">Чтобы понять это,нужно задать вопрос,зачем нужен PUT,какие проблемы PUT пытался решить,а POST не смог.</target>
        </trans-unit>
        <trans-unit id="2b77e3950318466e7b1306d760c2096fcdcc38f3" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URI): Generic Syntax and Semantics</source>
          <target state="translated">Унифицированные идентификаторы ресурсов (URI):Общий синтаксис и семантика</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="e2fbf38e05ed6d395ec7f6efdfd2ea298e430b2a" translate="yes" xml:space="preserve">
          <source>Updates the resource with &lt;strong&gt;existingResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Обновляет ресурс с &lt;strong&gt;существующим&lt;/strong&gt; ResourceId в качестве идентификатора в URI / resources или &lt;strong&gt;коллекции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f8079d8e5134eb77a5128a4f32d06200addab2ae" translate="yes" xml:space="preserve">
          <source>Use POST to create, and PUT to update. That's how Ruby on Rails is doing it, anyway.</source>
          <target state="translated">Используйте POST для создания,а PUT для обновления.Во всяком случае,так делает Ruby on Rails.</target>
        </trans-unit>
        <trans-unit id="7e3328f33c6c2ad3028951ba9c219f5262089b33" translate="yes" xml:space="preserve">
          <source>Used to create a resource, or
  overwrite it.  While you specify the
  resources new URL.</source>
          <target state="translated">Используется для создания ресурса или его перезаписи.Пока вы указываете новый URL ресурса.</target>
        </trans-unit>
        <trans-unit id="caad456be6f2e43799931b874b916e57d669f040" translate="yes" xml:space="preserve">
          <source>Used to modify and update a resource</source>
          <target state="translated">Используется для модификации и обновления ресурса</target>
        </trans-unit>
        <trans-unit id="534d6f360955fe24940d916537fd5f5d03013712" translate="yes" xml:space="preserve">
          <source>Useful when a resource's URL is known</source>
          <target state="translated">Полезно,когда URL ресурса известен.</target>
        </trans-unit>
        <trans-unit id="87dffc568fb442d1ab8b5daa3edd8813475735c7" translate="yes" xml:space="preserve">
          <source>Useful when the resource's URL is
unknown</source>
          <target state="translated">Полезно,когда URL ресурса неизвестен.</target>
        </trans-unit>
        <trans-unit id="d2f00b419fb58779569430425949be8c2946ab81" translate="yes" xml:space="preserve">
          <source>When dealing with REST and URI as general, you have &lt;strong&gt;generic&lt;/strong&gt; on the &lt;em&gt;left&lt;/em&gt; and &lt;strong&gt;specific&lt;/strong&gt; on the &lt;em&gt;right&lt;/em&gt;. The &lt;strong&gt;generics&lt;/strong&gt; are usually called &lt;strong&gt;collections&lt;/strong&gt; and the more &lt;strong&gt;specific&lt;/strong&gt; items can be called &lt;strong&gt;resource&lt;/strong&gt;. Note that a &lt;strong&gt;resource&lt;/strong&gt; can contain a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Когда вы имеете дело с REST и URI в целом, у вас есть &lt;strong&gt;общий&lt;/strong&gt; &lt;em&gt;слева&lt;/em&gt; и &lt;strong&gt;конкретный&lt;/strong&gt; &lt;em&gt;справа&lt;/em&gt; . &lt;strong&gt;Обобщения&lt;/strong&gt; обычно называются &lt;strong&gt;коллекциями,&lt;/strong&gt; а более &lt;strong&gt;конкретные&lt;/strong&gt; элементы могут называться &lt;strong&gt;ресурсами&lt;/strong&gt; . Обратите внимание, что &lt;strong&gt;ресурс&lt;/strong&gt; может содержать &lt;strong&gt;коллекцию&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="14ad7c96823b5a1d653bec9e758d08db87c5209c" translate="yes" xml:space="preserve">
          <source>When you POST to a resource at a particular URL, often you are posting a related piece of information to that URL. This implies that the resource at the URL already exists.</source>
          <target state="translated">Когда вы POST на ресурс по определённому URL,часто вы размещаете связанную с ним часть информации на этом URL.Это означает,что ресурс по этому URL уже существует.</target>
        </trans-unit>
        <trans-unit id="f6bf84ba90320cefe0d8fa5d18b1d11fe5272e46" translate="yes" xml:space="preserve">
          <source>When you PUT a resource at a particular URL what happens is that it should get saved at that URL, or something along those lines.</source>
          <target state="translated">Когда вы набираете ресурс по определенному URL,происходит то,что он должен быть сохранен по этому URL,или что-то в этом роде.</target>
        </trans-unit>
        <trans-unit id="03669db6e556a71ab819d40f836e5bd27373b8b6" translate="yes" xml:space="preserve">
          <source>When you can't fully trust the client to do the right thing, it would be 
more appropriate to use &lt;strong&gt;POST&lt;/strong&gt; to create a new item and then send the URL back to the client in the response.</source>
          <target state="translated">Если вы не можете полностью доверять клиенту, чтобы он поступал правильно, было бы более целесообразно использовать &lt;strong&gt;POST&lt;/strong&gt; для создания нового элемента, а затем отправлять URL-адрес клиенту в ответе.</target>
        </trans-unit>
        <trans-unit id="22766c7cfca9b0f8a5c36dfb8f98f375b88a60a7" translate="yes" xml:space="preserve">
          <source>When you use POST you are &lt;strong&gt;always&lt;/strong&gt; refering to a &lt;strong&gt;collection&lt;/strong&gt;, so whenever you say:</source>
          <target state="translated">Когда вы используете POST, вы &lt;strong&gt;всегда&lt;/strong&gt; ссылаетесь на &lt;strong&gt;коллекцию&lt;/strong&gt; , поэтому всякий раз, когда вы говорите:</target>
        </trans-unit>
        <trans-unit id="e380bb1d3e7c031588ca3a3c5bf3f6f0d241ddcf" translate="yes" xml:space="preserve">
          <source>Which is used is left up to you.  But just remember to use the right one depending on what object you are referencing in the request.</source>
          <target state="translated">Который используется,остается за тобой.Но не забудьте использовать правый в зависимости от того,на какой объект вы ссылаетесь в запросе.</target>
        </trans-unit>
        <trans-unit id="ebbb5885abc4335ac57b9aa863e7c08abfc8ea5e" translate="yes" xml:space="preserve">
          <source>Which means if you have to submit</source>
          <target state="translated">Что означает,что если вы должны представить</target>
        </trans-unit>
        <trans-unit id="1e394f3df68b2548c835945807e40cf42b367d8e" translate="yes" xml:space="preserve">
          <source>While there is probably an agnostic way to describe these, it does seem to be conflicting with various statements from answers to websites.</source>
          <target state="translated">Хотя,вероятно,существует агностический способ их описания,он,тем не менее,кажется противоречащим различным утверждениям из ответов на веб-сайты.</target>
        </trans-unit>
        <trans-unit id="a5bc20d2d4325f529ff7555db67ccca89565a4cd" translate="yes" xml:space="preserve">
          <source>Wikipedia - REST</source>
          <target state="translated">Википедия-REST</target>
        </trans-unit>
        <trans-unit id="386e23f3812d1bdded28437f31996a6a569b6fd3" translate="yes" xml:space="preserve">
          <source>With &amp;ldquo;REST without PUT&amp;rdquo; technique, the idea is that consumers are
  forced to post new 'nounified' request resources. As discussed
  earlier, changing a customer&amp;rsquo;s mailing address is a POST to a new
  &amp;ldquo;ChangeOfAddress&amp;rdquo; resource, not a PUT of a &amp;ldquo;Customer&amp;rdquo; resource with a
  different mailing address field value.</source>
          <target state="translated">С техникой &amp;laquo;REST без PUT&amp;raquo; идея заключается в том, что потребители вынуждены публиковать новые &amp;laquo;несущественные&amp;raquo; ресурсы запросов. Как обсуждалось ранее, изменение почтового адреса клиента - это POST на новый ресурс &amp;laquo;ChangeOfAddress&amp;raquo;, а не PUT ресурса &amp;laquo;Customer&amp;raquo; с другим значением поля почтового адреса.</target>
        </trans-unit>
        <trans-unit id="53a0df456d0b82cfb20df7d1c7dcda70c26fd29c" translate="yes" xml:space="preserve">
          <source>With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.</source>
          <target state="translated">С помощью POST вы можете иметь 2 запроса,которые приходят одновременно,внося изменения в URL,и они могут обновлять различные части объекта.</target>
        </trans-unit>
        <trans-unit id="bcec0b85a95c09c1d9aa73bbac93122064920f3c" translate="yes" xml:space="preserve">
          <source>With POST, you're posting to the address of the QUEUE or COLLECTION. With PUT, you're putting to the address of the ITEM.</source>
          <target state="translated">С помощью POST вы отправляете сообщение по адресу QUEUE или COLLECTION.С помощью PUT,вы размещаете по адресу ITEM.</target>
        </trans-unit>
        <trans-unit id="e394766f3d8f38a5425a15f2e94e15f94cff2588" translate="yes" xml:space="preserve">
          <source>With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.</source>
          <target state="translated">При использовании PUT,если один и тот же запрос выполняется несколько раз или один раз,состояние таблицы STUDENT остается неизменным.</target>
        </trans-unit>
        <trans-unit id="9f13e4060016ff9f870bc818b8b5bcb9592a2292" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;POST&lt;/code&gt; to example.com/users since you don't know the &lt;code&gt;URL&lt;/code&gt; of the user yet, you want the server to create it.</source>
          <target state="translated">Вы &lt;code&gt;POST&lt;/code&gt; на example.com/users, так как вы еще не знаете &lt;code&gt;URL&lt;/code&gt; пользователя, вы хотите, чтобы сервер его создал.</target>
        </trans-unit>
        <trans-unit id="a3e29206f13fd7f313ac3a03984149fd94f809d9" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;PUT&lt;/code&gt; to example.com/users/id since you want to replace/create a &lt;em&gt;specific&lt;/em&gt; user.</source>
          <target state="translated">Вы &lt;code&gt;PUT&lt;/code&gt; на example.com/users/id, поскольку хотите заменить / создать &lt;em&gt;конкретного&lt;/em&gt; пользователя.</target>
        </trans-unit>
        <trans-unit id="cd925494376cae5537a3d23703b024e74bd08383" translate="yes" xml:space="preserve">
          <source>You can find assertions on the web that say</source>
          <target state="translated">В сети можно найти утверждения,в которых говорится.</target>
        </trans-unit>
        <trans-unit id="deb01051624c8536f5e270d282325b0dbf3553ef" translate="yes" xml:space="preserve">
          <source>You can update or create a resource with PUT with the same object URL</source>
          <target state="translated">Вы можете обновить или создать ресурс с PUT с тем же URL объекта</target>
        </trans-unit>
        <trans-unit id="50c70a21ef7f357ae45ec172565f2b589fc30211" translate="yes" xml:space="preserve">
          <source>You could though do something like
  this to create a resources using POST:</source>
          <target state="translated">Хотя вы можете сделать что-то подобное,чтобы создать ресурсы,используя POST:</target>
        </trans-unit>
        <trans-unit id="8dddfd0893267c4dc2c1565595682d6ee7fe0449" translate="yes" xml:space="preserve">
          <source>You do not need to support both PUT and POST.</source>
          <target state="translated">Вам не нужно поддерживать как PUT,так и POST.</target>
        </trans-unit>
        <trans-unit id="1a70c96038989ab75bed3ead389a54345761a879" translate="yes" xml:space="preserve">
          <source>You have to ask &quot;what are you performing the action to?&quot; to distinguish what you should be using. Let's assume you're designing an API for asking questions.  If you want to use POST then you would do that to a list of questions. If you want to use PUT then you would do that to a particular question.</source>
          <target state="translated">Вы должны спросить &quot;что вы выполняете действия,чтобы?&quot;,чтобы отличить то,что вы должны использовать.Предположим,что вы разрабатываете API для задания вопросов.Если вы хотите использовать POST,то вы сделаете это со списком вопросов.Если вы хотите использовать PUT,то вы сделаете это с определенным вопросом.</target>
        </trans-unit>
        <trans-unit id="aab05f743ff11af397a41e6a50b339a3a9b253b8" translate="yes" xml:space="preserve">
          <source>You will quickly spot the similarity with promises: we create and return the placeholder for the result before doing anything. Also like a promise, an action can succeed or fail one time, but its result can be fetched repeatedly.</source>
          <target state="translated">Вы быстро заметите сходство с обещаниями:мы создаем и возвращаем плательщика за результат,прежде чем что-либо делать.Также,как и обещание,действие может однократно увенчаться успехом или неудачей,но результат может быть получен многократно.</target>
        </trans-unit>
        <trans-unit id="f363cc5672437cee525e493743ecf9b56f18170d" translate="yes" xml:space="preserve">
          <source>files, non-ASCII data, and binary data</source>
          <target state="translated">файлы,не-ASCII данные и двоичные данные.</target>
        </trans-unit>
        <trans-unit id="03d4991f0d2b56909a00a2c07cb0c98115001bed" translate="yes" xml:space="preserve">
          <source>information for the user to recognize the source of the conflict.
  Ideally, the response entity would include enough information for the
  user or user agent to fix the problem; however, that might not be
  possible and is not required.</source>
          <target state="translated">информацию,позволяющую пользователю распознать источник конфликта.В идеале,объект ответа должен включать достаточно информации для пользователя или агента пользователя,чтобы устранить проблему;однако это может оказаться невозможным и не требоваться.</target>
        </trans-unit>
        <trans-unit id="a7cc393671d331a6f24f8870a93fd8292a27451f" translate="yes" xml:space="preserve">
          <source>it will work, but semantically you are saying that you want to add a resource to the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">это будет работать, но семантически вы говорите, что хотите добавить ресурс в &lt;strong&gt;коллекцию&lt;/strong&gt; &lt;em&gt;john в&lt;/em&gt; &lt;strong&gt;коллекции&lt;/strong&gt; &lt;em&gt;users&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="d0b50e773f074b959f39222603c21bd08feff7c0" translate="yes" xml:space="preserve">
          <source>taken from &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Resource Modeling by Prakash Subramaniam of Thoughtworks&lt;/a&gt;</source>
          <target state="translated">взято из &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Моделирование ресурсов Пракашем Субраманиамом из Thoughtworks&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebe73780ee4475ed56cfa08985bac3ceeb53b38" translate="yes" xml:space="preserve">
          <source>the origin server can create the resource with that URI</source>
          <target state="translated">сервер происхождения может создать ресурс с этим URI.</target>
        </trans-unit>
        <trans-unit id="c4c609ca0b9379838bc225c20d08b72b88e05939" translate="yes" xml:space="preserve">
          <source>you are posting a new user to the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Вы публикуете нового пользователя в &lt;strong&gt;коллекции&lt;/strong&gt; &lt;em&gt;пользователей&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f3bfcffc130ebfe19bd9ae363ee7834942fb61" translate="yes" xml:space="preserve">
          <source>you are telling to the server update, or create if it doesn't exist, the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;resource&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Вы сообщаете серверу об обновлении или создаете, если он не существует, &lt;strong&gt;ресурс&lt;/strong&gt; &lt;em&gt;john&lt;/em&gt; в &lt;strong&gt;коллекции&lt;/strong&gt; &lt;em&gt;пользователей&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ac747133049c7cac58b2f01633f4d4824881c480" translate="yes" xml:space="preserve">
          <source>you should use &lt;strong&gt;POST&lt;/strong&gt; method</source>
          <target state="translated">Вы должны использовать метод &lt;strong&gt;POST&lt;/strong&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
