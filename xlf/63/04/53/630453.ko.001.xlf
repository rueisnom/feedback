<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/630453">
    <body>
      <group id="630453">
        <trans-unit id="0c058b89b3c60a0ba555a3620d744eb93c511f1a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH is the new primary HTTP method for updates&lt;/a&gt;&quot; explains it.</source>
          <target state="translated">&quot; &lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails : PATCH는 업데이트를위한 새로운 기본 HTTP 방법입니다&lt;/a&gt; &quot;라고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f74f51ed1b6ae265800adfcf8027c01c0018665f" translate="yes" xml:space="preserve">
          <source>10.4.10 409 Conflict</source>
          <target state="translated">10.4.10 409 충돌</target>
        </trans-unit>
        <trans-unit id="506fa830744fbb202514e4450da7b9fff37040d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; is designed to replace 2616 and in &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; describes the follow possible response for a POST</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; 은 2616을 대체하도록 설계되었으며 &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;4.3.3 절&lt;/a&gt; 에서 POST에 대한 다음 가능한 응답을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1a0c5e7063c7016b18d6c3928f19f62e9242e7e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;I wrote the following as part of another answer on SO regarding this&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;나는 이것에 관해 SO에 대한 또 다른 대답의 일부로 다음을 썼습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55aee01ee1d0f0416e9083e2d6f6557b9818cb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST /something&lt;/code&gt;: &quot;Take what I give you and put it anywhere you want under &lt;code&gt;/something&lt;/code&gt; as long as you give me its URL when you're done.&quot;</source>
          <target state="translated">&lt;code&gt;POST /something&lt;/code&gt; : &quot;내가 원하는 것을 가져 가서 URL을 알려주는 한 &lt;code&gt;/something&lt;/code&gt; 아래에 원하는 곳에 두십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="df611b43ba33bf88fde50464bfe23c704ed98e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST x&lt;/code&gt;: &quot;Store my content and give me an identifier that I can use to identify a resource (old or new) containing said content (possibly mixed with other content). Said resource should be identical or subordinate to that which &lt;code&gt;x&lt;/code&gt; identifies.&quot; &quot;&lt;em&gt;y&lt;/em&gt;'s resource is subordinate to &lt;em&gt;x&lt;/em&gt;'s resource&quot; is typically but not necessarily implemented by making &lt;em&gt;y&lt;/em&gt; a subpath of &lt;em&gt;x&lt;/em&gt; (e.g. &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; and &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt;) and modifying the representation(s) of &lt;em&gt;x&lt;/em&gt;'s resource to reflect the existence of a new resource, e.g. with a hyperlink to &lt;em&gt;y&lt;/em&gt;'s resource and some metadata. Only the latter is really essential to good design, as URLs are opaque in REST -- you're supposed to &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;use hypermedia&lt;/a&gt; instead of client-side URL construction to traverse the service anyways.</source>
          <target state="translated">&lt;code&gt;POST x&lt;/code&gt; : &quot;내 컨텐츠를 저장하고 해당 컨텐츠를 포함하는 자원 (이전 또는 신규)을 식별하는 데 사용할 수있는 식별자를 제공하십시오 (다른 컨텐츠와 혼합 될 수 있음). 해당 자원은 &lt;code&gt;x&lt;/code&gt; 가 식별하는 것과 동일하거나 종속적이어야합니다.&quot; &quot; &lt;em&gt;y&lt;/em&gt; 의 자원은 &lt;em&gt;x&lt;/em&gt; 의 자원에 종속적 &lt;em&gt;임&lt;/em&gt; &quot;은 일반적으로 &lt;em&gt;y&lt;/em&gt; 를 &lt;em&gt;x&lt;/em&gt; 의 하위 경로 (예 : &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; 및 &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt; )로 만들고 &lt;em&gt;x&lt;/em&gt; 의 표현을 수정하여 반드시 구현되는 것은 아닙니다. 새로운 자원의 존재를 반영하는 자원, 예를 들어 &lt;em&gt;y&lt;/em&gt; 의 자원에 대한 하이퍼 링크 및 일부 메타 데이터. REST에서는 URL이 불투명하기 때문에 후자 만이 디자인에 필수적입니다. 어쨌든 서비스를 통과하려면 클라이언트 측 URL 구성 대신 &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;하이퍼 미디어&lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d458584efe00bde626b31645f1c9331669a393b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST&lt;/code&gt; means &quot;create new&quot; as in &quot;Here is the input for creating a user, create it for me&quot;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 는 &quot;여기서 사용자를 작성하고 입력하십시오&quot;와 같이 &quot;새로 작성&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a07f91414dd50cc7f1986ee5d6ee5a1fbee9ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; already exists): &quot;Take whatever you have at &lt;code&gt;/something&lt;/code&gt; and replace it with what I give you.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; ( &lt;code&gt;/something&lt;/code&gt; 이 이미 존재하는 경우) : &quot; &lt;code&gt;/something&lt;/code&gt; 에있는 것을 가져 가서 내가 제공 한 것으로 바꾸십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="46ab7ec42035f8ace3ccbdc9e29957431a709ad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; does not already exist): &quot;Take what I give you and put it at &lt;code&gt;/something&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; ( &lt;code&gt;/something&lt;/code&gt; 이 존재하지 않는 경우) : &quot;내가주는 것을 가져 가서 &lt;code&gt;/something&lt;/code&gt; 에 두십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="8b19b9a7682dd06e6b9d4d9b60e4befaf7e822f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; does not identify a resource): &quot;Create a new resource containing my content and use &lt;code&gt;x&lt;/code&gt; to identify it.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; 가 자원을 식별하지 못하는 경우) : &quot;내 컨텐츠를 포함하는 새로운 자원을 작성하고 &lt;code&gt;x&lt;/code&gt; 를 사용하여 식별하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="b7eeae57fac13ac526305058d9ec04d7f1c90069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; identifies a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;resource&lt;/a&gt;): &quot;Replace the content of the resource identified by &lt;code&gt;x&lt;/code&gt; with my content.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; 가 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;자원을&lt;/a&gt; 식별하는 경우) : &quot; x로 식별 된 자원 의 컨텐츠를 내 컨텐츠로 바꾸십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="693d0f55f15f15a3670f566554ad630959a6464b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT&lt;/code&gt; means &quot;insert, replace if already exists&quot; as in &quot;Here is the data for user 5&quot;.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; 은 &quot;사용자 5의 데이터는 다음과 같습니다&quot;와 같이 &quot;이미 존재하는 경우 삽입, 교체&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ba9411546a0e55dde6f6b3b345e14406853999d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;일부는 POST로 업데이트를 수행 할 수 있습니다.&lt;/em&gt; &lt;em&gt;업데이트에 사용할 규칙이나 만들 때 사용할 규칙은 없습니다.&lt;/em&gt; &lt;em&gt;다시 말하지만 이것은 관습이며, 직관적으로 위에서 언급 한 추론에 관심이 있으며 따르십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="494905e8546c28f7ca25ed531d6f9532f60855f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;-- generic -- specific --&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;-일반-특정-&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24bd66f9b0232fdec5910e08746f4135f3abc5f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3.4.  PUT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3.4.&lt;/strong&gt; &lt;strong&gt;놓다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f00078b6cfd30a400e58409eebd42604b45de8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예를 들면 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b79f8a35030639797e581e3751e158add431466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Great both can be used, so which one should I use in my RESTful design:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;둘 다 사용할 수 있으므로 RESTful 디자인에서 어느 것을 사용해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f204e179a99e4e4da9b046149c8fa27fab675704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Long Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;긴 답변 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ea66d061a28052dccef1603c0375aa549c7f0e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Longer Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 긴 답변 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d19062995715b13929a5b7d5ad16cd259eea9489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; PUT에는 업데이트가 필요한 리소스 위치 (이미 리소스)가 필요하지만 POST에는 필요하지 않습니다. 따라서 직관적으로 POST는 새 리소스를 생성하기위한 것이며 PUT은 기존 리소스를 업데이트하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="973a94f5bc8d247be1da5613a2678e40ad80ce20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;New answer (now that I understand REST better):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;새로운 답변 (이제 REST를 더 잘 이해하고 있음) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6eaec7db8eb07bc1a9853353813e5aacc4d8a7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; PUT has mostly been used to update resources (by replacing them in their entireties), but recently there is movement towards using PATCH for updating existing resources, as PUT specifies that it replaces the whole resource. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; PUT은 주로 전체를 교체하여 리소스를 업데이트하는 데 사용되었지만 최근에는 PUT이 전체 리소스를 교체하도록 지정하므로 기존 리소스를 업데이트하기 위해 PATCH를 사용하는 방향으로 이동하고 있습니다. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f39f80f6a4493b75f71f2759494c67e2fe8499a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or you can do this&lt;/strong&gt;: consider your unsafe requests as ephemeral single-user resources (let's call them actions). Clients request a new &quot;action&quot; on a substantive resource with an empty POST to the resource. POST will be used only for this. Once safely in possession of the URI of the freshly minted action, the client PUTs the unsafe request to the action URI, &lt;em&gt;not the target resource&lt;/em&gt;. Resolving the action and updating the &quot;real&quot; resource is properly the job of your API, and is here decoupled from the unreliable network.</source>
          <target state="translated">&lt;strong&gt;또는 이렇게 할 수 있습니다&lt;/strong&gt; : 안전하지 않은 요청을 임시 단일 사용자 리소스로 간주하십시오 (작업이라고 함). 클라이언트는 자원에 빈 POST가있는 실질적인 자원에 대해 새로운 &quot;조치&quot;를 요청합니다. POST는이 용도로만 사용됩니다. 새로 작성된 작업의 URI를 안전하게 소유하면 클라이언트는 안전하지 않은 요청을 &lt;em&gt;대상 자원이 아닌&lt;/em&gt; 작업 URI에 PUT합니다. 조치를 해결하고 &quot;실제&quot;자원을 업데이트하는 것은 API의 역할이며, 신뢰할 수없는 네트워크와 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="83d03f71c82f9f3e365473c2e90a536428e4a72f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer (might be easier to read)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;원래 답변 (읽기 쉬울 수 있음)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fb16687bea1f8e2c7ffd77af09d8a11526e30bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overall:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overall:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fec18cd93d5bbce335b8a8b4685449de2c1a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PATCH&lt;/strong&gt; to a URL &lt;strong&gt;updates &lt;em&gt;part&lt;/em&gt; of the resource&lt;/strong&gt; at that client defined URL.</source>
          <target state="translated">URL로 &lt;strong&gt;PATCH&lt;/strong&gt; 는 해당 클라이언트 정의 URL에서 &lt;strong&gt;자원의 &lt;em&gt;일부&lt;/em&gt; 를 업데이트합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e900f8bab5ad45a82b31d5c9e77eb8b842fb8fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST creates a child resource&lt;/strong&gt;, so POST to &lt;code&gt;/items&lt;/code&gt; creates a resources that lives under the &lt;code&gt;/items&lt;/code&gt; resource. 
Eg. &lt;code&gt;/items/1&lt;/code&gt;. Sending the same post packet twice will create two resources.</source>
          <target state="translated">&lt;strong&gt;POST는 하위 자원을 작성&lt;/strong&gt; 하므로 POST to &lt;code&gt;/items&lt;/code&gt; 는 &lt;code&gt;/items&lt;/code&gt; 자원 아래에있는 자원을 작성합니다. 예 : &lt;code&gt;/items/1&lt;/code&gt; . 동일한 포스트 패킷을 두 번 보내면 두 개의 리소스가 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="84cd833b3d09b3772c7c9b69992c06365b49d808" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;POST:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51d739446154fe4129eacba513d3e7c1cbc82d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; /items</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; / 항목</target>
        </trans-unit>
        <trans-unit id="81f179204aeec70824672b29654dc73a5ef03745" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; You can think of something like &quot;INSERT INTO STUDENT(name, address) VALUES (&quot;abc&quot;, &quot;xyzzz&quot;);</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; &quot;INSERT INTO STUDENT (이름, 주소) 값 (&quot;abc &quot;,&quot;xyzzz &quot;);</target>
        </trans-unit>
        <trans-unit id="d84ba3155ffa58932b6b44f1f889c414429f25ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; a resource into a collection</source>
          <target state="translated">리소스를 컬렉션에 &lt;strong&gt;게시&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6057b584edf3b882a3192b1dc61a689a17f508b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; 는 비등 전성이므로 단일 시간 실행과 비교하여 작업이 여러 번 실행되는 경우 리소스 상태가 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa11acc5dc60894a4a26cfcbe0027d32f1604de8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;PUT&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; 는 리소스를 생성하는 데 사용되고 &lt;strong&gt;PUT&lt;/strong&gt; 은 리소스를 생성하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="83971fa0e325d0bc5650b7ff303b5ca7b5384576" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL &lt;strong&gt;creates a child resource&lt;/strong&gt; at a &lt;em&gt;server defined&lt;/em&gt; URL.</source>
          <target state="translated">URL로 &lt;strong&gt;POST&lt;/strong&gt; 는 &lt;em&gt;서버 정의&lt;/em&gt; URL에 &lt;strong&gt;하위 자원&lt;/strong&gt; 을 &lt;strong&gt;작성합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="39214825f7bf31755a7524b96e478ffac1270da2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL should be used to update or create a resource which is located at some other (&quot;subordinate&quot;) URL, or is not locatable via HTTP.</source>
          <target state="translated">URL에 대한 &lt;strong&gt;POST&lt;/strong&gt; 는 다른 ( &quot;하위&quot;) URL에 있거나 HTTP를 통해 찾을 수없는 자원을 업데이트하거나 작성하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="906a2e1913665dd7ea341fe6a356f1a5db4491c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; updates a resource, adds a subsidiary resource, or causes a change.  A POST is not idempotent, in the way that &lt;code&gt;x++&lt;/code&gt; is not idempotent.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; 는 리소스를 업데이트하거나 보조 리소스를 추가하거나 변경을 유발합니다. &lt;code&gt;x++&lt;/code&gt; 가 is 등원이 아닌 방식으로 POST는 dem 등성이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1201fa44ed952a209bb94b60653ae5e6d12e8775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cb09efafb2a756a2c8c49fbf16fde25b499a6f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt;  /items/1234</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; / items / 1234</target>
        </trans-unit>
        <trans-unit id="04e6413418714eccb311ba8ccd68a6eb8397b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; You can think of similar to &quot;UPDATE STUDENT SET address = &quot;abc&quot; where id=&quot;123&quot;;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; &quot;UPDATE STUDENT SET address =&quot;abc &quot;와 유사하게 생각할 수 있습니다. 여기서 id =&quot;123 &quot;;</target>
        </trans-unit>
        <trans-unit id="bac831f172bbd16f060e11a1fcf6a1142deebaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; a resource identified by collection/:id</source>
          <target state="translated">collection / : id로 식별 된 자원을 &lt;strong&gt;PUT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43e9659830aa7fe8a7b61df6c3d0f9fe51884752" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; implies putting a resource - completely replacing whatever is available at the given URL with a different thing.  By definition, a PUT is idempotent.  Do it as many times as you like, and the result is the same. &lt;code&gt;x=5&lt;/code&gt; is idempotent.  You can PUT a resource whether it previously exists, or not (eg, to Create, or to Update)!</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 은 자원을 넣는 것을 의미합니다. 주어진 URL에서 사용 가능한 모든 것을 다른 것으로 완전히 바꿉니다. 정의상 PUT은 dem 등원입니다. 원하는만큼 여러 번하면 결과는 같습니다. &lt;code&gt;x=5&lt;/code&gt; 는 dem 등원입니다. 리소스의 존재 여부에 관계없이 리소스를 PUT 할 수 있습니다 (예 : 만들기 또는 업데이트)!</target>
        </trans-unit>
        <trans-unit id="11d47c3923ae9d2cba6624010bda74e130873ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is for creating or replacing a resource at a &lt;strong&gt;URL known by the client&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 은 &lt;strong&gt;클라이언트가 알고&lt;/strong&gt; 있는 &lt;strong&gt;URL&lt;/strong&gt; 에서 자원을 작성하거나 대체하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3fa7bf3d7c1668ea88085a1bf5c94b878a2e04e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 은 dem 등원이며 동일한 작업이 한 번 또는 여러 번 실행될 경우 자원 상태가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ad48efa009a26f69b5139207c4818699892b929a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; replaces the resource at the known url if it already exists, so sending the same request twice has no effect. In other words, &lt;strong&gt;calls to PUT are idempotent&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 은 알려진 URL의 자원이 이미 존재하는 경우이를 대체하므로 동일한 요청을 두 번 보내는 것은 효과가 없습니다. 즉, &lt;strong&gt;PUT 호출은 dem 등원&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="47297bbd78d247783bb6a9b461b4320abab889a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;POST&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 을 사용하여 자원을 작성하고 &lt;strong&gt;POST&lt;/strong&gt; 를 사용하여 자원을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2316d8434c10c4f7c6461cd73b5ad3a9c62ff074" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL &lt;strong&gt;creates/replaces the resource&lt;/strong&gt; in its entirety at the &lt;em&gt;client defined&lt;/em&gt; URL.</source>
          <target state="translated">URL로 &lt;strong&gt;PUT&lt;/strong&gt; 은 &lt;em&gt;클라이언트가 정의한&lt;/em&gt; URL에서 전체적으로 &lt;strong&gt;리소스&lt;/strong&gt; 를 &lt;strong&gt;생성 / 대체합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9a47a55d20b6233f89d8f607db5f21886379877c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL should be used to update or create the resource that can be located at that URL.</source>
          <target state="translated">URL에 대한 &lt;strong&gt;PUT&lt;/strong&gt; 은 해당 URL에있는 자원을 업데이트하거나 작성하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0eb5b9e913c2e4810b9d275d9137826d6361fccb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post&lt;/strong&gt; on social media: when we post message, it creates new post.</source>
          <target state="translated">소셜 미디어에 게시 : 메시지를 게시하면 새 게시물이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c379deb81ec8171aeba8c48b33c76a4077d81ae5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put&lt;/strong&gt;(i.e. edit) for the message we already Posted.</source>
          <target state="translated">이미 게시 한 메시지를 &lt;strong&gt;넣습니다&lt;/strong&gt; (예 : 편집).</target>
        </trans-unit>
        <trans-unit id="42f2ab7a6f0ba70ad4633ee1aeb9c5617f17e37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replying with a status code of 409 Conflict is the correct recourse because&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;상태 코드 409 충돌로 응답하는 것은 다음과 같은 이유로 올바른 해결책입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="541c698af4296a2ac8f6dbcf007beace20e3289c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;짧은 답변:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7dee22b45482414ebaedf9e5284e4fb4d8d9302d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The decision of whether to use PUT or POST to create a resource on a server with an HTTP + REST API is based on who owns the URL structure.&lt;/strong&gt; Having the client know, or participate in defining, the URL struct is an unnecessary coupling akin to the undesirable couplings that arose from SOA. Escaping types of couplings is the reason REST is so popular. Therefore, &lt;strong&gt;the proper method to use is POST.&lt;/strong&gt; There are exceptions to this rule and they occur when the client wishes to retain control over the location structure of the resources it deploys. This is rare and likely means something else is wrong.</source>
          <target state="translated">&lt;strong&gt;PUT 또는 POST를 사용하여 HTTP + REST API가있는 서버에서 자원을 작성할지 여부는 URL 구조의 소유자를 기반으로 결정됩니다.&lt;/strong&gt; 클라이언트가 URL 구조를 알고 있거나 정의하는 데 참여하면 SOA에서 발생하는 바람직하지 않은 결합과 유사한 불필요한 결합이됩니다. 이스케이프 유형의 커플 링은 REST가 널리 사용되는 이유입니다. 따라서 &lt;strong&gt;올바른 사용 방법은 POST입니다.&lt;/strong&gt; 이 규칙에는 예외가 있으며 클라이언트가 배포 한 리소스의 위치 구조에 대한 제어 권한을 유지하려고 할 때 발생합니다. 이것은 드물고 다른 것이 잘못되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="52dde7c3fb20e3705b4cb8c6fdc0d421a3aa14d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018&lt;/strong&gt;: There is a case that can be made to avoid PUT. See &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;REST without PUT&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;2018 업데이트&lt;/strong&gt; : PUT을 피할 수있는 경우가 있습니다. &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;PUT없는 REST&quot;&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="018ab5192fbe6cef7ceb3ab2181f51408e2e0392" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update based on release of RFC 7231 to Replace 2616&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2616을 대체하기위한 RFC 7231 릴리스에 따른 업데이트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="823a6eb1d93ecc4c59ea5a879b8110b0723a4c56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using POST to create resources comes with a design consideration because POST is not idempotent.&lt;/strong&gt; This means that repeating a POST several times does not guarantee the same behavior each time. &lt;strong&gt;This scares people into using PUT to create resources when they should not.&lt;/strong&gt; They know it's wrong (POST is for CREATE) but they do it anyway because they don't know how to solve this problem.  This concern is demonstrated in the following situation:</source>
          <target state="translated">&lt;strong&gt;POST는 dem 등원이 아니기 때문에 POST를 사용하여 자원을 작성하는 것은 설계 고려 사항과 함께 제공됩니다.&lt;/strong&gt; 이것은 POST를 여러 번 반복한다고해서 매번 같은 동작을 보장하지는 않습니다. &lt;strong&gt;이로 인해 사람들은 PUT을 사용하여 리소스를 생성해서는 안됩니다.&lt;/strong&gt; 그들은 그것이 틀렸다는 것을 알고 있지만 (POST는 CREATE를위한 것입니다) 그들은이 문제를 해결하는 방법을 모르기 때문에 어쨌든 그렇게합니다. 이 문제는 다음 상황에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="f8352b060f3bd6bf9405565ea670a52e1a19ac89" translate="yes" xml:space="preserve">
          <source>A PUT doesn't need to be a create; the service could error if the resource isn't already created, but otherwise update it. Or vice versa -- it may create the resource, but not allow updates. The only thing required about PUT is that it points to a specific resource, and its payload is the representation of that resource. A successful PUT means (barring interference) that a GET would retrieve the same resource.</source>
          <target state="translated">PUT은 작성일 필요는 없습니다. 리소스가 아직 생성되지 않은 경우 서비스에서 오류가 발생할 수 있지만 그렇지 않으면 업데이트하십시오. 또는 그 반대의 경우도 리소스를 만들 수 있지만 업데이트는 허용하지 않습니다. PUT에 필요한 유일한 것은 특정 리소스를 가리키고 페이로드가 해당 리소스를 나타내는 것입니다. 성공적인 PUT은 GET이 동일한 자원을 검색한다는 것을 의미합니다 (방해 금지).</target>
        </trans-unit>
        <trans-unit id="0e9a6a3224dfefa9263f801580fea79e1034124c" translate="yes" xml:space="preserve">
          <source>A REST API must not define fixed resource names or hierarchies (an
  obvious coupling of client and server). Servers must have the freedom
  to control their own namespace. Instead, allow servers to instruct
  clients on how to construct appropriate URIs, such as is done in HTML
  forms and URI templates, by defining those instructions within media
  types and link relations. [Failure here implies that clients are
  assuming a resource structure due to out-of band information, such as
  a domain-specific standard, which is the data-oriented equivalent to
  RPC's functional coupling].</source>
          <target state="translated">REST API는 고정 자원 이름 또는 계층 (클라이언트와 서버의 명백한 결합)을 정의해서는 안됩니다. 서버는 자신의 네임 스페이스를 자유롭게 제어 할 수 있어야합니다. 대신, 서버가 클라이언트에게 HTML 형식 및 URI 템플릿에서 수행되는 것과 같은 적절한 URI를 구성하는 방법을 미디어 유형 및 링크 관계 내에서 해당 명령을 정의하여 지시 할 수 있습니다. [여기서 실패는 클라이언트가 RPC의 기능적 커플 링과 동등한 데이터 지향 인 도메인 별 표준과 같은 대역 외 정보로 인해 자원 구조를 가정하고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4eebc73de916b615d31b4a9c02c76f42d153bef9" translate="yes" xml:space="preserve">
          <source>A general advice is to use &lt;code&gt;POST&lt;/code&gt; when you need the server to be in control of &lt;code&gt;URL&lt;/code&gt; generation of your resources. Use &lt;code&gt;PUT&lt;/code&gt; otherwise.  Prefer &lt;code&gt;PUT&lt;/code&gt;  over &lt;code&gt;POST&lt;/code&gt;.</source>
          <target state="translated">일반적인 조언은 서버가 자원의 &lt;code&gt;URL&lt;/code&gt; 생성을 제어해야 할 때 &lt;code&gt;POST&lt;/code&gt; 를 사용하는 것입니다. 그렇지 않으면 &lt;code&gt;PUT&lt;/code&gt; 을 사용하십시오. &lt;code&gt;POST&lt;/code&gt; 보다 &lt;code&gt;PUT&lt;/code&gt; 을 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="a46f192218c6e582580086317328dbf11d360983" translate="yes" xml:space="preserve">
          <source>A general rule: if you know the id or name of the item, use PUT. If you want the id or name of the item to be assigned by the receiving party, use POST.</source>
          <target state="translated">일반적인 규칙 : 항목의 ID 또는 이름을 알고 있으면 PUT을 사용하십시오. 수신 측에서 품목의 ID 또는 이름을 지정하려면 POST를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d80afd687e25858c217eccf9caa91d0cf98797f" translate="yes" xml:space="preserve">
          <source>A new method is necessary to improve interoperability and prevent
     errors.  The PUT method is already defined to overwrite a resource
     with a complete new body, and cannot be reused to do partial changes.
     Otherwise, proxies and caches, and even clients and servers, may get
     confused as to the result of the operation.  POST is already used but
     without broad interoperability (for one, there is no standard way to
     discover patch format support).  PATCH was mentioned in earlier HTTP
     specifications, but not completely defined.</source>
          <target state="translated">상호 운용성을 개선하고 오류를 방지하려면 새로운 방법이 필요합니다. PUT 메소드는 이미 완전한 새 본문으로 자원을 겹쳐 쓰도록 정의되어 있으며 부분 변경을 위해 재사용 할 수 없습니다. 그렇지 않으면 프록시 및 캐시, 심지어 클라이언트 및 서버까지도 작업 결과가 혼란 스러울 수 있습니다. POST는 이미 사용되었지만 광범위한 상호 운용성이 없습니다 (하나의 경우 패치 형식 지원을 발견하는 표준 방법은 없습니다). PATCH는 이전 HTTP 사양에서 언급되었지만 완전히 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d7612bc02c9fa195c518a31c5e2d100c9f1167a8" translate="yes" xml:space="preserve">
          <source>A response which contains the URL of the resource with the conflicting ID and the appropriate preconditions for the resource would provide &amp;ldquo;enough information for the user or user agent to fix the problem&amp;rdquo; which is the ideal case per RFC 2616.</source>
          <target state="translated">충돌하는 ID를 가진 자원의 URL과 자원에 대한 적절한 사전 조건이 포함 된 응답은 RFC 2616에 이상적인 경우 인 &quot;사용자 또는 사용자 에이전트가 문제를 해결하기에 충분한 정보&quot;를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0a5f004271832132b2407dff2153fd15001e9ee0" translate="yes" xml:space="preserve">
          <source>According to ME, real-life networks are unreliable. Requests timeout. Connections are reset. Networks go down for hours or days at a time. Trains go into tunnels with mobile users aboard. For any given request (as occasionally acknowledged in all this discussion) the request can fall in the water on its way, or the response can fall in the water on its way back. &lt;strong&gt;In these conditions, issuing PUT, POST and DELETE requests directly against substantive resources has always struck me as a little brutal and naive.&lt;/strong&gt;</source>
          <target state="translated">ME에 따르면 실제 네트워크는 신뢰할 수 없다. 타임 아웃을 요청합니다. 연결이 재설정됩니다. 한 번에 몇 시간 또는 며칠 동안 네트워크가 다운됩니다. 기차는 모바일 사용자와 함께 터널로 들어갑니다. 주어진 모든 요청에 ​​대해 (이 토론에서 때때로 인정되는 바와 같이) 요청은 도중에 물에 빠지거나 응답이 다시 물에 빠질 수 있습니다. &lt;strong&gt;이러한 상황에서 실질적인 자원에 대해 직접 PUT, POST 및 DELETE 요청을 발행하는 것은 항상 조금 잔인하고 순진합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44a64212bc466bad1c26da5cf30cd0ad13d5b0f6" translate="yes" xml:space="preserve">
          <source>According to the HTTP 1.1 specifications the GET, HEAD, DELETE, and PUT methods must be idempotent, and the POST method is not idempotent. That is to say that an operation is idempotent if it can be performed on a resource once or many times and always return the same state of that resource. Whereas a non idempotent operation can return a modified state of the resource from one request to another. Hence, in a non idempotent operation, there is no guarantee that one will receive the same state of a resource.</source>
          <target state="translated">HTTP 1.1 스펙에 따르면 GET, HEAD, DELETE 및 PUT 메소드는 dem 등원이어야하며 POST 메소드는 dem 등원이 아닙니다. 즉, 작업이 한 번 또는 여러 번 리소스에서 수행 될 수 있고 항상 해당 리소스의 동일한 상태를 반환하는 경우에는 dem 등원입니다. i 등원이 아닌 작업은 한 요청에서 다른 요청으로 리소스의 수정 된 상태를 반환 할 수 있습니다. 따라서, i 등원이 아닌 작업에서는 동일한 상태의 리소스를받을 것이라는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="263017c41745f1b94fb06cd0b37045f3eec4ef1a" translate="yes" xml:space="preserve">
          <source>According to the HTTP/1.1 Spec:</source>
          <target state="translated">HTTP / 1.1 사양에 따르면 :</target>
        </trans-unit>
        <trans-unit id="99391b86ae4d4984d262f89901db8c15300e563f" translate="yes" xml:space="preserve">
          <source>According to this, you cannot send files or multipart data in the &lt;strong&gt;PUT&lt;/strong&gt; method</source>
          <target state="translated">이것에 따르면 &lt;strong&gt;PUT&lt;/strong&gt; 방법으로 파일이나 멀티 파트 데이터를 보낼 수 없습니다</target>
        </trans-unit>
        <trans-unit id="400cd438f5e39bdc77550bfd923cf916451692bd" translate="yes" xml:space="preserve">
          <source>Additionally, and a bit more concisely, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 Section 4.3.4 PUT&lt;/a&gt; states (emphasis added),</source>
          <target state="translated">또한 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 섹션 4.3.4 PUT&lt;/a&gt; 상태 (강조 추가)</target>
        </trans-unit>
        <trans-unit id="18829b20b3b1624e09ed74c26fb7066a49e205d0" translate="yes" xml:space="preserve">
          <source>Analogy with database query</source>
          <target state="translated">데이터베이스 쿼리와 유추</target>
        </trans-unit>
        <trans-unit id="1ecad98fe7923a037242a110b7abf85eb0ca5b54" translate="yes" xml:space="preserve">
          <source>Analogy:</source>
          <target state="translated">Analogy:</target>
        </trans-unit>
        <trans-unit id="cd8441cd54d554959dc0b978e4c1160125beaede" translate="yes" xml:space="preserve">
          <source>As for modifying the properties of the stream, you can do that with either PUT or POST. Basically, only use &quot;PUT&quot; when the operation is idempotent - otherwise use POST.</source>
          <target state="translated">스트림의 속성을 수정하는 경우 PUT 또는 POST로 수행 할 수 있습니다. 기본적으로, 조작이 dem 등원 일 경우에만 &quot;PUT&quot;을 사용하십시오. 그렇지 않으면 POST를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1505fe853a030352c8bbf3a78d4f0ba03add0832" translate="yes" xml:space="preserve">
          <source>As such, numerous thorny problems go away. Repeated insert requests won't create duplicates, and we don't create the real resource until we're in possession of the data. (database columns can stay not-nullable). Repeated update requests won't hit incompatible states and won't overwrite subsequent changes. Clients can (re)fetch and seamlessy process the original confirmation for whatever reason (client crashed, response went missing, etc.).</source>
          <target state="translated">따라서 수많은 가시적 인 문제가 사라집니다. 반복되는 삽입 요청은 중복을 생성하지 않으며 데이터를 소유 할 때까지 실제 리소스를 생성하지 않습니다. (데이터베이스 열은 널 입력 가능하지 않을 수 있습니다). 반복되는 업데이트 요청은 호환되지 않는 상태가되지 않으며 이후 변경 사항을 덮어 쓰지 않습니다. 고객은 어떤 이유로 든 (클라이언트 충돌, 응답 누락 등) 원래 확인을 (다시) 가져오고 완벽하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9269d826939b1ae8561cb8d676c6f19e2aeeeeb8" translate="yes" xml:space="preserve">
          <source>As your quote mentioned, you use PUT for creation of there is no resource assigned to an IRI, and you want to create a resource anyway. For example, &lt;code&gt;PUT /users/123/password&lt;/code&gt; usually replaces the old password with a new one, but you can use it to create a password if it does not exist already (for example, by freshly registered users or by restoring banned users).</source>
          <target state="translated">인용 한 바와 같이 IRI에 할당 된 리소스가없는 경우 PUT을 사용하고 어쨌든 리소스를 만들려고합니다. 예를 들어, &lt;code&gt;PUT /users/123/password&lt;/code&gt; 일반적으로 이전 비밀번호를 새 비밀번호로 바꾸지 만 비밀번호가없는 경우 (예 : 새로 등록한 사용자 또는 금지 된 사용자를 복원하여) 비밀번호를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="678d1314d4c33bf4616bbffabc6f6412417d7408" translate="yes" xml:space="preserve">
          <source>At the risk of restating what has already been said, it seems important to remember that &lt;strong&gt;PUT&lt;/strong&gt; implies that the client controls what the &lt;em&gt;URL&lt;/em&gt; is going to end up being, when creating a resource. So part of the choice between &lt;strong&gt;PUT&lt;/strong&gt; and &lt;strong&gt;POST&lt;/strong&gt; is going to be about how much you can trust the client to provide correct, normalized &lt;em&gt;URL&lt;/em&gt; that are coherent with whatever your URL scheme is.</source>
          <target state="translated">이미 말한 내용을 복구 할 위험이 있으므로 &lt;strong&gt;PUT&lt;/strong&gt; 은 리소스를 생성 할 때 클라이언트가 &lt;em&gt;URL&lt;/em&gt; 이 끝나는 대상을 제어한다는 것을 기억해야합니다. 따라서 &lt;strong&gt;PUT&lt;/strong&gt; 과 &lt;strong&gt;POST&lt;/strong&gt; 중 하나를 선택하는 것은 URL 스킴이 무엇이든간에 일관된 올바른 정규화 된 &lt;em&gt;URL&lt;/em&gt; 을 제공하도록 클라이언트를 얼마나 신뢰할 수 있는지에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd64c65270203c04e0ffe12619fc3c1cf5cb0838" translate="yes" xml:space="preserve">
          <source>At this point some people will argue that if &lt;em&gt;RESTful-URL's&lt;/em&gt; are used, the client does knows the URL of the resource and therefore a PUT is acceptable. After all, this is why canonical, normalized, Ruby on Rails, Django URLs are important, look at the Twitter API &amp;hellip; blah blah blah. Those people need to understand &lt;strong&gt;there is no such thing as a Restful-URL&lt;/strong&gt; and that &lt;strong&gt;Roy Fielding himself states that&lt;/strong&gt;:</source>
          <target state="translated">이 시점에서 일부 사람들은 &lt;em&gt;RESTful-URL&lt;/em&gt; 이 사용되면 클라이언트가 자원의 URL을 알고 있으므로 PUT이 허용된다고 주장합니다. 결국, 이것이 정식, 정규화 된 Ruby on Rails, Django URL이 중요한 이유입니다. Twitter API를 살펴보십시오 ... blah blah blah. 그 사람들 &lt;strong&gt;은 Restful-URL&lt;/strong&gt; 과 &lt;strong&gt;같은 것이 없으며&lt;/strong&gt; &lt;strong&gt;Roy Fielding 자신은 다음과 같이 말합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="48ec0b3e3b0319156f9f91acfe20356337cec520" translate="yes" xml:space="preserve">
          <source>Based on the above idempotent definition, my take on using the HTTP PUT method versus using the HTTP POST method for REST services is:
Use the HTTP PUT method when:</source>
          <target state="translated">위의 dem 등원 정의에 따라 REST 서비스에 HTTP POST 메소드를 사용하는 것과 HTTP PUT 메소드를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="625c633dc893bb8acf9969ce26d2c745e6ed5c5d" translate="yes" xml:space="preserve">
          <source>Because PUT and GET and DELETE refer to a resource, they are also by definition idempotent.</source>
          <target state="translated">PUT, GET 및 DELETE는 자원을 참조하므로 정의 상으로는 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="33d0f759f56954a746edd3401e6d1ad592971425" translate="yes" xml:space="preserve">
          <source>Before telling me this is not RESTful, please consider the numerous ways in which REST principles are respected. Clients don't construct URLs. The API stays discoverable, albeit with a little change in semantics. HTTP verbs are used appropriately. If you think this is a huge change to implement, I can tell you from experience that it's not.</source>
          <target state="translated">이것이 RESTful이 아니라고 말하기 전에 REST 원칙을 존중하는 다양한 방법을 고려하십시오. 클라이언트는 URL을 구성하지 않습니다. 의미에 약간의 변화가 있지만 API는 검색 가능한 상태로 유지됩니다. HTTP 동사가 적절하게 사용됩니다. 이것이 구현에 큰 변화라고 생각한다면 경험이 아니라고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="241aa52fb81745d04b1069f6da972cd395e23c48" translate="yes" xml:space="preserve">
          <source>Best of all, we give sending and receiving applications a chance to link the uniquely identified action to uniqueness in their respective environments. And we can start to demand, and enforce!, responsible behaviour from clients: repeat your requests as much as you like, but don't go generating a new action until you're in possession of a definitive result from the existing one.</source>
          <target state="translated">무엇보다도, 우리는 송수신 응용 프로그램에 고유하게 식별 된 작업을 해당 환경의 고유성과 연결할 수있는 기회를 제공합니다. 또한 고객의 책임있는 행동을 요구하고 시행 할 수 있습니다. 요청을 원하는만큼 반복하지만 기존 결과의 결정적인 결과를 얻을 때까지 새로운 조치를 취하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b0bf6e9b80cf880bc4aee735753fe3f2ad23f833" translate="yes" xml:space="preserve">
          <source>Better is to choose between PUT and POST based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;idempotence&lt;/a&gt; of the action.</source>
          <target state="translated">동작의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;dem 등성&lt;/a&gt; 에 따라 PUT과 POST 중에서 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="53c932206c69e73836ac721b4e0fe0b474be565c" translate="yes" xml:space="preserve">
          <source>Both PUT and POST can be used for creating.</source>
          <target state="translated">PUT과 POST는 모두 생성에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2997f210a9beea7a9cbb23843149e3c1e35aa1ed" translate="yes" xml:space="preserve">
          <source>Both are used for data transmission between client to server, but there are subtle differences between them, which are:</source>
          <target state="translated">둘 다 클라이언트에서 서버로의 데이터 전송에 사용되지만 이들 사이에는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b3b6388bc7e089c531c0bb3e2208420e07f69e" translate="yes" xml:space="preserve">
          <source>By this argument, PUT is for creating when you know the URL of the thing you will create. POST can be used to create when you know the URL of the &quot;factory&quot; or manager for the category of things you want to create.</source>
          <target state="translated">이 인수에 의해, PUT은 작성할 것의 URL을 알 때 작성하기위한 것입니다. POST를 사용하여 만들려는 항목의 범주에 대한 &quot;공장&quot;또는 관리자의 URL을 알고있을 때 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7c8d0b3ba4ea21e1913266949e8103ea15c06b3" translate="yes" xml:space="preserve">
          <source>Can &lt;strong&gt;only&lt;/strong&gt; be performed with PUT in the following way:</source>
          <target state="translated">다음과 같은 방식으로 PUT으로 &lt;strong&gt;만&lt;/strong&gt; 수행 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="29d666e583f03fcf75786741bc1b0cab3486e6df" translate="yes" xml:space="preserve">
          <source>Can be performed with both PUT or POST in the following way:</source>
          <target state="translated">다음과 같은 방식으로 PUT 또는 POST로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e3815fe6dbc55d1a2ed6585c021c9fc37f549b" translate="yes" xml:space="preserve">
          <source>Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.</source>
          <target state="translated">사례 1 : 타임 라인에 무언가를 게시하면 새로운 항목이됩니다. 따라서이 경우 POST 메소드는 비등 전성이므로 POST 메소드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="afe97da32ea658ba5cfa1f6a3af16660a6caad91" translate="yes" xml:space="preserve">
          <source>Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.</source>
          <target state="translated">사례 2 : 친구가 처음으로 게시물에 댓글을 달면 POST 메소드가 사용되도록 데이터베이스에 새 항목이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="51c87be0979efc83a96ee19ed6970b9953da779d" translate="yes" xml:space="preserve">
          <source>Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*</source>
          <target state="translated">사례 3 : 친구가 자신의 댓글을 편집하면이 경우 댓글 ID가 있으므로 데이터베이스에 새 항목을 만드는 대신 기존 댓글을 업데이트합니다. 따라서이 유형의 조작에는 PUT 메소드가 dem 등원이므로 사용하십시오. *</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="b0e2937475fc503e223c56343b52c44da7a6fa27" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a PUT request. For
  example, if versioning were being used and the entity being PUT
  included changes to a resource which conflict with those made by an
  earlier (third-party) request, the server might use the 409 response
  to indicate that it can&amp;rsquo;t complete the request. In this case, the
  response entity would likely contain a list of the differences between
  the two versions in a format defined by the response Content-Type.</source>
          <target state="translated">PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 높습니다. 예를 들어, 버전 관리를 사용 중이고 PUT중인 엔티티에 이전 (타사) 요청으로 작성된 자원과 충돌하는 자원에 대한 변경 사항이 포함 된 경우 서버는 409 응답을 사용하여 요청을 완료 할 수 없음을 표시 할 수 있습니다 . 이 경우 응답 엔티티는 응답 Content-Type에 의해 정의 된 형식으로 두 버전 사이의 차이점 목록을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b186070c96257e81f5f76dda28fe4aaa692252" translate="yes" xml:space="preserve">
          <source>Create:</source>
          <target state="translated">Create:</target>
        </trans-unit>
        <trans-unit id="17b1e45ff463141be485d41572191a7ed7413417" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;A&lt;/strong&gt; new resource under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;. Usually the identifier is returned by the server.</source>
          <target state="translated">/ resources URI 또는 &lt;strong&gt;collection&lt;/strong&gt; 아래에 새 자원을 작성합니다. 일반적으로 식별자는 서버에서 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33e5496ae029f6fe64dd2213c64d6ba200b86f51" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;THE&lt;/strong&gt; new resource with &lt;strong&gt;newResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">/ resources URI 또는 &lt;strong&gt;collection&lt;/strong&gt; 에서 &lt;strong&gt;newResourceId&lt;/strong&gt; 를 식별자로 사용하여 새 자원을 &lt;strong&gt;작성&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="33ac997d5d937f49dfe9ade3e811b0f958a8e36d" translate="yes" xml:space="preserve">
          <source>Do not directly correlate and map CRUD operations to HTTP methods for REST services. The use of an HTTP PUT method versus an HTTP POST method should be based on the idempotent aspect of that operation. That is, if the operation is idempotent, then use the HTTP PUT method. If the operation is non idempotent, then use the HTTP POST method.</source>
          <target state="translated">REST 서비스의 CRUD 조작을 HTTP 메소드에 직접 연관시키고 맵핑하지 마십시오. HTTP PUT 방법과 HTTP POST 방법의 사용은 해당 작업의 dem 등원 측면을 기반으로해야합니다. 즉, 조작이 dem 등원 인 경우 HTTP PUT 메소드를 사용하십시오. 조작이 dem 등원이 아닌 경우 HTTP POST 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d370df4be6707296d029645b0b4712b06c53ef1c" translate="yes" xml:space="preserve">
          <source>Do you name your URL objects you create explicitly, or let the server decide? If you name them then use PUT.  If you let the server decide then use POST.</source>
          <target state="translated">작성한 URL 오브젝트의 이름을 명시 적으로 지정합니까, 아니면 서버가 결정하도록 하시겠습니까? 이름을 지정하면 PUT을 사용하십시오. 서버가 결정하게하면 POST를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="58945bef9cdd3ff1a80ba82c0e9d1f5a2d0ee11b" translate="yes" xml:space="preserve">
          <source>Edit: One more thing -- a PUT can create, but if it does then the ID has to be a natural ID -- AKA an email address. That way when you PUT twice, the second put is an update of the first. This makes it &lt;em&gt;idempotent&lt;/em&gt;.</source>
          <target state="translated">편집 : PUT이 만들 수있는 또 하나의 것이지만, 그렇다면 ID는 자연스러운 ID이어야합니다. 이렇게하면 PUT을 두 번했을 때 두 번째 풋이 첫 번째 풋업입니다. 이것은 &lt;em&gt;dem 등원이된다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8ed4a1daabc4dbc57c02baa4ed3068d24acd58e8" translate="yes" xml:space="preserve">
          <source>For a new resource:</source>
          <target state="translated">새로운 자료 :</target>
        </trans-unit>
        <trans-unit id="cff50999f4c249529ddc6e468c61561154669de5" translate="yes" xml:space="preserve">
          <source>For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.</source>
          <target state="translated">예를 들어, 새 스트림을 만들려면 일부 URL에 넣을 수 있습니다. 그러나 기존 스트림에 메시지를 게시하려면 해당 URL에 POST하십시오.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f547ae451be4b97139f6676d6b8b56908850c325" translate="yes" xml:space="preserve">
          <source>For instance, it may not be a good idea to create credit card transactions with POST.</source>
          <target state="translated">예를 들어 POST로 신용 카드 거래를 생성하는 것은 좋지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc46f3f2f22617ca008bc0347b91c6bcc94f57de" translate="yes" xml:space="preserve">
          <source>For more information about this, read this &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;article&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은이 &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;기사를&lt;/a&gt; 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="6cd29602a6814d7031623e943eb9ad9b03163c44" translate="yes" xml:space="preserve">
          <source>From a REST architecture's point of view there is none that matters. We could have lived without PUT as well. But from a client developer's point of view it made his/her life a lot simpler.</source>
          <target state="translated">REST 아키텍처의 관점에서 중요한 것은 없습니다. 우리는 PUT 없이도 살 수있었습니다. 그러나 클라이언트 개발자의 관점에서 볼 때 그의 삶은 훨씬 단순 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="e554373d4e3272bcfc25cfb1cdb1bc748dad0740" translate="yes" xml:space="preserve">
          <source>HTTP does nothing to ensure reliable completion of the request-response, and that's just fine because this is properly the job of network-aware applications. Developing such an application, you can jump through hoops to use PUT instead of POST, then more hoops to give a certain kind of error on the server if you detect duplicate requests. Back at the client, you then have to jump through hoops to interpret these errors, refetch, revalidate and repost.</source>
          <target state="translated">HTTP는 요청-응답의 안정적인 완료를 보장하기 위해 아무 것도하지 않으며, 이는 네트워크 인식 응용 프로그램의 작업이기 때문에 괜찮습니다. 이러한 응용 프로그램을 개발하면 POST 대신 PUT을 사용하도록 후프를 건너 뛰고 중복 요청을 감지하면 서버에서 특정 종류의 오류를 발생시키는 후프를 더 많이 사용할 수 있습니다. 클라이언트로 돌아가서 이러한 오류를 해석하고 다시 가져오고, 다시 확인하고 다시 게시하려면 후프를 뛰어 넘어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3fde5b13baf7e698d819867af72294baf96853b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Spec</source>
          <target state="translated">HTTP / 1.1 사양</target>
        </trans-unit>
        <trans-unit id="5307592ab464b1dfe31ceb63373b1f53680a6aa6" translate="yes" xml:space="preserve">
          <source>Header &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a656b7b969733403da8fb5e2a09bcb24ed7b14b0" translate="yes" xml:space="preserve">
          <source>Hence, create or update based on existence of the &lt;strong&gt;resource&lt;/strong&gt;.</source>
          <target state="translated">따라서 &lt;strong&gt;자원의&lt;/strong&gt; 존재 여부에 따라 작성하거나 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="a09685c9924e957d538b394fd639ee93fed0a583" translate="yes" xml:space="preserve">
          <source>Hence, creates a new &lt;strong&gt;resource&lt;/strong&gt; on a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">따라서 &lt;strong&gt;컬렉션&lt;/strong&gt; 에 새 &lt;strong&gt;리소스&lt;/strong&gt; 를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ceaa5b7fc07bf5371832748f3289a7b2da4d980c" translate="yes" xml:space="preserve">
          <source>Here's a simple rule:</source>
          <target state="translated">간단한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d27a8aff43735751da6f6d2d0ed6614a7eecf8a" translate="yes" xml:space="preserve">
          <source>I hope this helps any Microsoft developers that read all comments with Amazon and Sun/Java website links.</source>
          <target state="translated">이것이 Amazon 및 Sun / Java 웹 사이트 링크로 모든 의견을 읽는 모든 Microsoft 개발자에게 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="5ca6bb95d20fb75f5f126fd38d614ae6b08d4b81" translate="yes" xml:space="preserve">
          <source>I interpret this, and the idempotency requirements on PUT, to mean that:</source>
          <target state="translated">나는 이것을 의미하며 PUT의 dem 등성 요구 사항을 다음과 같이 해석합니다.</target>
        </trans-unit>
        <trans-unit id="05235e2370ecb21ce9215b0f74750a3737456a63" translate="yes" xml:space="preserve">
          <source>I like this advice, from &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616's definition of PUT&lt;/a&gt;:</source>
          <target state="translated">나는 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616의 PUT 정의&lt;/a&gt; 에서이 조언을 좋아한다.</target>
        </trans-unit>
        <trans-unit id="47aada42c69dd7c0210a4f1845e6ab606520fa95" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;PUT&lt;/code&gt; for Merge and update like operations and use &lt;code&gt;POST&lt;/code&gt; for Insertions.</source>
          <target state="translated">병합에 &lt;code&gt;PUT&lt;/code&gt; 을 사용하고 유사한 작업을 업데이트하고 삽입에 &lt;code&gt;POST&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="b527f56fb4de9ec139a67d896e81802d54cd82a0" translate="yes" xml:space="preserve">
          <source>I will describe the conventions which I think are most widely used and are most useful:</source>
          <target state="translated">가장 널리 사용되고 가장 유용한 규칙을 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f9c0500253b27e41a2e9e90178c365ce2423d509" translate="yes" xml:space="preserve">
          <source>I'd like to add my &quot;pragmatic&quot; advice.  Use PUT when you know the &quot;id&quot; by which the object you are saving can be retrieved.  Using PUT won't work too well if you need, say, a database generated id to be returned for you to do future lookups or updates.</source>
          <target state="translated">&quot;실용적인&quot;조언을 추가하고 싶습니다. 저장하는 오브젝트를 검색 할 수있는 &quot;id&quot;를 알고있는 경우 PUT을 사용하십시오. 예를 들어 향후 조회 또는 업데이트를 위해 데이터베이스 생성 ID를 반환해야하는 경우 PUT을 사용하면 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66649e065e34c99642108c78cb23fe86c7332572" translate="yes" xml:space="preserve">
          <source>I'm going to land with the following:</source>
          <target state="translated">다음과 같이 착륙하겠습니다.</target>
        </trans-unit>
        <trans-unit id="dc85f0689c0d90da1345182eb8a915a8e4dd3c43" translate="yes" xml:space="preserve">
          <source>If the ID is generated (a new employee ID, for example), then the second PUT with the same URL would create a new record, which violates the idempotent rule. In this case the verb would be POST, and the message (not resource) would be to create a resource using the values defined in this message.</source>
          <target state="translated">ID가 생성되면 (예 : 새 직원 ID) 동일한 URL을 가진 두 번째 PUT은 새 레코드를 작성하여 dem 등원 규칙을 위반합니다. 이 경우 동사는 POST이고 메시지 (자원이 아님)는이 메시지에 정의 된 값을 사용하여 자원을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e269e8bb2d1ae96b4945fea0fb22c28a23aa1d25" translate="yes" xml:space="preserve">
          <source>If the URL is not yet created, you
  should not be using POST to create it
  while specifying the name.  This should
  result in a 'resource not found' error
  because &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; does not exist
  yet.  You should PUT the &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt;
  resource on the server first.</source>
          <target state="translated">URL이 아직 작성되지 않은 경우 이름을 지정하는 동안 POST를 사용하여 URL을 작성하지 않아야합니다. &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; 이 아직 없기 때문에 '리소스를 찾을 수 없음'오류가 발생합니다. 먼저 서버에서 &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; 리소스를 넣어야 합니다.</target>
        </trans-unit>
        <trans-unit id="19c462827f591bd8bec6f3f537b7b39215387f40" translate="yes" xml:space="preserve">
          <source>If the result of processing a POST would be equivalent to a
  representation of an existing resource, an origin server MAY redirect
  the user agent to that resource by sending a 303 (See Other) response
  with the existing resource's identifier in the Location field.  This
  has the benefits of providing the user agent a resource identifier
  and transferring the representation via a method more amenable to
  shared caching, though at the cost of an extra request if the user
  agent does not already have the representation cached.</source>
          <target state="translated">POST 처리 결과가 기존 자원의 표현과 동일한 경우, 원 서버는 Location 필드에 기존 자원의 식별자와 함께 303 (기타 참조) 응답을 전송하여 사용자 에이전트를 해당 자원으로 리디렉션 할 수 있습니다. 이는 사용자 에이전트가 이미 캐시 된 표현을 가지고 있지 않은 경우 추가 요청의 비용으로 사용자 에이전트에 자원 식별자를 제공하고 공유 캐싱에 더 적합한 방법을 통해 표현을 전송하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="558a879fdfc95da4b234bea22b5e49ef57224b98" translate="yes" xml:space="preserve">
          <source>If you are familiar with database operations,
there are</source>
          <target state="translated">데이터베이스 작업에 익숙하다면</target>
        </trans-unit>
        <trans-unit id="1d065776051b8ea3a055903bde387f8a311a6be4" translate="yes" xml:space="preserve">
          <source>If you go on and try something like this:</source>
          <target state="translated">계속해서 다음과 같이 해보십시오 :</target>
        </trans-unit>
        <trans-unit id="0c6f7e90f3ea30966fd463c77a5a98203c024433" translate="yes" xml:space="preserve">
          <source>If you happen to have auto generated  URI's on your resource you can still use PUT by passing a generated URI (pointing to an empty resource) to the client.</source>
          <target state="translated">자원에 자동 생성 된 URI가있는 경우 생성 된 URI (빈 자원을 가리키는)를 클라이언트에 전달하여 PUT을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5ae750e099166d34c0aea0fb9b4fadd772975a" translate="yes" xml:space="preserve">
          <source>If you have any doubts about how to implement REST in HTTP, you can always take a look at the &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom Publication Protocol (AtomPub)&lt;/a&gt; specification. AtomPub is a standard for writing RESTful webservices with HTTP that was developed by many HTTP and REST luminaries, with some input from Roy Fielding, the inventor of REST and (co-)inventor of HTTP himself.</source>
          <target state="translated">HTTP로 REST를 구현하는 방법에 대해 의문이있는 경우 언제든지 &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;AtomPub (Atom Publication Protocol)&lt;/a&gt; 사양을 살펴볼 수 있습니다. AtomPub는 많은 HTTP 및 REST 조명에 의해 개발 된 HTTP를 사용하여 RESTful 웹 서비스를 작성하기위한 표준이며, REST의 발명자이자 HTTP의 공동 발명자 인 Roy Fielding의 의견이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec654f9d869b9d4e7e967af9a0e460df87b82e2e" translate="yes" xml:space="preserve">
          <source>If you think you'll have huge amounts of data to store, let's talk volumes: a typical update confirmation is a fraction of a kilobyte. HTTP currently gives you a minute or two to respond definitively. Even if you only store actions for a week, clients have ample chance to catch up. If you have very high volumes, you may want a dedicated acid-compliant key value store, or an in-memory solution.</source>
          <target state="translated">저장할 대량의 데이터가 있다고 생각되면 볼륨을 말해 보겠습니다. 일반적인 업데이트 확인은 킬로바이트의 일부입니다. HTTP는 현재 결정적으로 응답하는 데 1-2 분을 제공합니다. 일주일 동안 만 작업을 저장하더라도 클라이언트는 따라 잡을 기회가 충분합니다. 볼륨이 매우 큰 경우 전용 산 호환 키 값 저장소 또는 인 메모리 솔루션이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3f77bd7d922a0787f75fec577234f6dce48c77" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;POST&lt;/strong&gt; method you can send body params in &lt;code&gt;form-data&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; 방법에서는 body &lt;code&gt;form-data&lt;/code&gt; params를 form-data로 보낼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ae084cc36a47a0ae5ba94fddaf0353c8961a476b" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PUT&lt;/strong&gt; method you have to send body params in &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 방법에서는 &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; 의 본문 매개 변수를 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="9431cceefc51a270cdbc8ad21cfd20758abb6247" translate="yes" xml:space="preserve">
          <source>In REST, there's no such thing as a resource containing &quot;content&quot;. I refer as &quot;content&quot; to data that the service uses to render representations consistently. It typically consists of some related rows in a database or a file (e.g. an image file). It's up to the service to convert the user's content into something the service can use, e.g. converting a JSON payload into SQL statements.</source>
          <target state="translated">REST에는 &quot;content&quot;를 포함하는 리소스와 같은 것은 없습니다. 서비스가 표현을 일관되게 표현하기 위해 사용하는 데이터를 &quot;콘텐츠&quot;라고합니다. 일반적으로 데이터베이스 또는 파일 (예 : 이미지 파일)의 일부 관련 행으로 구성됩니다. JSON 페이로드를 SQL 문으로 변환하는 것과 같이 사용자의 컨텐츠를 서비스가 사용할 수있는 것으로 변환하는 것은 서비스에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="258ba4ae5c03cdfdac38fed39baa86957f31d85a" translate="yes" xml:space="preserve">
          <source>In a single line, use &lt;strong&gt;POST&lt;/strong&gt; to add &lt;strong&gt;a new entry&lt;/strong&gt; in the database and &lt;strong&gt;PUT&lt;/strong&gt; to &lt;strong&gt;update&lt;/strong&gt; something in the database.</source>
          <target state="translated">한 줄로 &lt;strong&gt;POST&lt;/strong&gt; 를 사용하여 데이터베이스에 &lt;strong&gt;새 항목&lt;/strong&gt; 을 추가하고 &lt;strong&gt;PUT&lt;/strong&gt; 을 &lt;strong&gt;사용&lt;/strong&gt; 하여 데이터베이스에서 무언가를 &lt;strong&gt;업데이트&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="935d9d64a7b6c614a61126ee51efa95f2a005750" translate="yes" xml:space="preserve">
          <source>In a very simple way I'm taking the example of the Facebook timeline.</source>
          <target state="translated">아주 간단한 방법으로 Facebook 타임 라인을 예로 들겠습니다.</target>
        </trans-unit>
        <trans-unit id="5796889f185413ae8caeb602438951b389d9b045" translate="yes" xml:space="preserve">
          <source>In addition to differences suggested by others, I want to add one more.</source>
          <target state="translated">다른 사람들이 제안한 차이점 외에도 하나 더 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="d0a40d3ab4c006f0fd0242d76461457c6d244bfe" translate="yes" xml:space="preserve">
          <source>In both cases, the request body contains the data for the resource to be created or updated. It should be obvious from the route names that POST is not idempotent (if you call it 3 times it will create 3 objects), but PUT is idempotent (if you call it 3 times the result is the same). PUT is often used for &quot;upsert&quot; operation (create or update), but you can always return a 404 error if you only want to use it to modify.</source>
          <target state="translated">두 경우 모두 요청 본문에는 만들거나 업데이트 할 리소스에 대한 데이터가 포함됩니다. 경로 이름에서 POST는 idempotent가 아니며 (3 번 호출하면 3 개의 객체가 생성됨) PUT은 idempotent입니다 (3 번 호출하면 결과는 동일 함). PUT은 종종 &quot;upsert&quot;작업 (만들기 또는 업데이트)에 사용되지만 수정에만 사용하려는 경우 항상 404 오류를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="573cffeb2d758c1d002d1b38d8d410abd12cf26c" translate="yes" xml:space="preserve">
          <source>In both cases, these operations can be performed multiple times with the same results. That is the resource will not be changed by requesting the operation more than once. Hence, a true idempotent operation.
Use the HTTP POST method when:</source>
          <target state="translated">두 경우 모두 이러한 결과는 동일한 결과로 여러 번 수행 될 수 있습니다. 즉, 작업을 두 번 이상 요청해도 리소스가 변경되지 않습니다. 따라서 진정한 dem 등식 작업입니다. 다음과 같은 경우에 HTTP POST 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cbfc88d28449849d5a03796a1b27b42013a1a384" translate="yes" xml:space="preserve">
          <source>In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an &quot;INSERT&quot; query.</source>
          <target state="translated">POST의 경우, 동일한 쿼리가 여러 번 실행되면 데이터베이스에 여러 학생 레코드가 생성되고 &quot;INSERT&quot;쿼리가 실행될 때마다 데이터베이스 상태가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="315a82166f32c0e6bdbe44329b3f92d7b32440b4" translate="yes" xml:space="preserve">
          <source>In fact, you might even be able to use AtomPub directly. While it came out of the blogging community, it is in no way restricted to blogging: it is a generic protocol for RESTfully interacting with arbitrary (nested) collections of arbitrary resources via HTTP. If you can represent your application as a nested collection of resources, then you can just use AtomPub and not worry about whether to use PUT or POST, what HTTP Status Codes to return and all those details.</source>
          <target state="translated">실제로 AtomPub를 직접 사용할 수도 있습니다. 블로그 커뮤니티에서 나왔지만 블로그에는 제한이 없습니다. HTTP를 통해 임의의 (중첩 된) 임의의 리소스 모음과 RESTful하게 상호 작용하기위한 일반적인 프로토콜입니다. 응용 프로그램을 중첩 된 리소스 모음으로 나타낼 수 있다면 AtomPub을 사용하고 PUT 또는 POST 사용 여부, 반환 할 HTTP 상태 코드 및 모든 세부 정보에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b6a091fc94c88da148a77392e516193f6f66982" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;POST&lt;/code&gt; is used to &lt;strong&gt;create&lt;/strong&gt;.</source>
          <target state="translated">다시 말해 &lt;code&gt;POST&lt;/code&gt; 는을 &lt;strong&gt;만드는&lt;/strong&gt; 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fcfbe76fe288131ae25a4df6a695eb5ab43c9f7d" translate="yes" xml:space="preserve">
          <source>In practice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; that summarizes the best practices.</source>
          <target state="translated">실제로 POST는 리소스를 만드는 데 효과적입니다. 새로 작성된 자원의 URL은 위치 응답 헤더에 리턴되어야합니다. 리소스를 완전히 업데이트하려면 PUT을 사용해야합니다. RESTful API를 설계 할 때 모범 사례임을 이해하십시오. 이와 같이 HTTP 스펙은 자원 작성 / 업데이트에 대한 몇 가지 제한 사항으로 PUT / POST 사용을 제한하지 않습니다. 모범 사례를 요약 한 &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; 를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">한마디로 :</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="f8f5b658f1ff8b04b3e81cc7e7976e9561692c82" translate="yes" xml:space="preserve">
          <source>It is true that the R(etrieve) and D(elete) of the CRUD operations can be mapped directly to the HTTP methods GET and DELETE respectively. However, the confusion lies in the C(reate) and U(update) operations. In some cases, one can use the PUT for a create while in other cases a POST will be required. The ambiguity lies in the definition of an HTTP PUT method versus an HTTP POST method.</source>
          <target state="translated">CRUD 조작의 R (etrieve) 및 D (elete)는 각각 HTTP 메소드 GET 및 DELETE에 직접 맵핑 될 수 있습니다. 그러나 혼란은 C (reate) 및 U (update) 작업에 있습니다. 어떤 경우에는 작성에 PUT을 사용할 수 있지만 다른 경우에는 POST가 필요합니다. 모호성은 HTTP PUT 방법과 HTTP POST 방법의 정의에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a419fc1de6f5fcd3ae809038b7b9a687efa1b1dd" translate="yes" xml:space="preserve">
          <source>It now may be tempting to simply return a 303 in the event that a POST is repeated. However, the opposite is true. Returning a 303 would only make sense if multiple create requests (creating different resources) return the same content. An example would be a &quot;thank you for submitting your request message&quot; that the client need not re-download each time. RFC 7231 still maintains in section 4.2.2 that POST is not to be idempotent and continues to maintain that POST should be used for create.</source>
          <target state="translated">POST가 반복되는 경우 단순히 303을 반환하려는 유혹이있을 수 있습니다. 그러나 그 반대입니다. 303을 리턴하면 여러 작성 요청 (다른 자원 작성)이 동일한 컨텐츠를 리턴하는 경우에만 의미가 있습니다. 클라이언트가 매번 다시 다운로드 할 필요가없는 &quot;요청 메시지를 제출해 주셔서 감사합니다&quot;가 그 예입니다. RFC 7231은 여전히 ​​4.2.2 섹션에서 POST가 not 등원이 아니며 POST를 작성에 사용해야한다고 계속 유지합니다.</target>
        </trans-unit>
        <trans-unit id="82a86d7eed2a55a644d7944a1404883b9ed82ac6" translate="yes" xml:space="preserve">
          <source>Let me highlight some important parts of the spec:</source>
          <target state="translated">스펙의 중요한 부분을 강조하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="27175fcbf0cac61488369580d1a39f1dc721a45f" translate="yes" xml:space="preserve">
          <source>Let's be very clear and direct here. If you are a .NET developer working with Web API, the facts are (from the Microsoft API documentation),
&lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&lt;/a&gt;:</source>
          <target state="translated">매우 명확하고 직접합시다. Web API를 사용하는 .NET 개발자 인 경우 사실은 (Microsoft API 설명서에서) &lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web입니다. -api-that-crus-operations&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="857a3f4adc539ed4bbe21171ae40606e572a4ee6" translate="yes" xml:space="preserve">
          <source>Merge (Update if already existing, else insert)</source>
          <target state="translated">병합 (이미 존재하는 경우 업데이트, 그렇지 않으면 삽입)</target>
        </trans-unit>
        <trans-unit id="d6917a3435aea050d9a0d15a35f97af6e01858e4" translate="yes" xml:space="preserve">
          <source>Most of the time, you will use them like this:</source>
          <target state="translated">대부분의 경우 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d61559b89b4cc3627f671076f6d46721d16134fc" translate="yes" xml:space="preserve">
          <source>Neither is quite right.</source>
          <target state="translated">둘 다 옳지 않다.</target>
        </trans-unit>
        <trans-unit id="29c91aceaf4eab28f2f98e779bebb50691497adc" translate="yes" xml:space="preserve">
          <source>Note that POST &quot;creates&quot; a new element in the collection, and PUT &quot;replaces&quot; an element at a given URL, but it is a very common practice to use PUT for partial modifications, that is, use it only to update existing resources and only modify the included fields in the body (ignoring the other fields). This is technically incorrect, if you want to be REST-purist, PUT should replace the whole resource and you should use PATCH for the partial update. I personally don't care much as far as the behavior is clear and consistent across all your API endpoints.</source>
          <target state="translated">POST는 컬렉션에서 새 요소를 &quot;만들고&quot;PUT은 주어진 URL에서 요소를 &quot;바꾸기&quot;하지만 부분 수정을 위해 PUT을 사용하는 것이 매우 일반적입니다. 즉, 기존 리소스를 업데이트 할 때만 사용합니다. 본문에 포함 된 필드 만 수정하십시오 (다른 필드는 무시). REST-purist가 되려면 PUT이 전체 리소스를 대체해야하며 부분 업데이트에 PATCH를 사용해야합니다. 모든 API 엔드 포인트에서 동작이 명확하고 일관성이있는 한 개인적으로 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="aed489a86f6999b5a22f73530a241b671e75935e" translate="yes" xml:space="preserve">
          <source>Note that in this case the resource
  name is not specified, the new objects
  URL path would be returned to you.</source>
          <target state="translated">이 경우 리소스 이름을 지정하지 않으면 새 객체 URL 경로가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0190e7f10880e789af039b6a119817ade48d5dc" translate="yes" xml:space="preserve">
          <source>Note that the following is an error:</source>
          <target state="translated">다음은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="94ed497609bfa8317d3c8fed64915d395cd4506d" translate="yes" xml:space="preserve">
          <source>Note, however, that not all modern browsers support HTTP verbs other than GET or POST.</source>
          <target state="translated">그러나 모든 최신 브라우저가 GET 또는 POST 이외의 HTTP 동사를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e324155fc5920c681ee3f3fe84a2ed08ebec851" translate="yes" xml:space="preserve">
          <source>Once you are using PUT you are refering to a &lt;strong&gt;resource&lt;/strong&gt; or single item, possibly inside a &lt;strong&gt;collection&lt;/strong&gt;. So when you say:</source>
          <target state="translated">일단 PUT을 사용하고 있다면 &lt;strong&gt;콜렉션&lt;/strong&gt; 내부의 &lt;strong&gt;자원&lt;/strong&gt; 또는 단일 항목을 참조하는 것 &lt;strong&gt;입니다&lt;/strong&gt; . 그래서 당신이 말할 때 :</target>
        </trans-unit>
        <trans-unit id="c5516139d4acd3169adf148d2df83962379be2e8" translate="yes" xml:space="preserve">
          <source>Otherwise, use POST to initially create the object, and PUT to update the object:</source>
          <target state="translated">그렇지 않으면 POST를 사용하여 처음에 오브젝트를 작성하고 PUT을 사용하여 오브젝트를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="4413fe84411cbdf88cfc031d8a1393f608c4e15e" translate="yes" xml:space="preserve">
          <source>POST as send mail in &lt;strong&gt;post&lt;/strong&gt; office.</source>
          <target state="translated">&lt;strong&gt;우체국&lt;/strong&gt; 에서 메일 발송으로 POST.</target>
        </trans-unit>
        <trans-unit id="1e2c64ac62aa82754ed88cbebd18c452a61f35fc" translate="yes" xml:space="preserve">
          <source>POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing -- if you think about it, creating a new member of a collection is actually a special case of this kind of update, from the collection's perspective)</source>
          <target state="translated">POST는 또한 기존 객체에 대한 비등 전성 업데이트에도 사용될 수 있습니다 (특히 전체를 지정하지 않고 객체의 일부를 변경하는 경우-생각하면 컬렉션의 새 멤버를 만드는 것은 실제로 이런 종류의 특별한 경우입니다) 컬렉션의 관점에서 업데이트)</target>
        </trans-unit>
        <trans-unit id="7199a1f38c458034e4e9122d80a96f6d399a16c7" translate="yes" xml:space="preserve">
          <source>POST can perform the other three functions, but then the semantics of the request will be lost on the intermediaries such as caches and proxies. This also applies to providing security on the resource, since a post's URI doesn't necessarily indicate the resource it is applying to (it can though).</source>
          <target state="translated">POST는 다른 세 가지 기능을 수행 할 수 있지만 캐시 및 프록시와 같은 중개자에서 요청의 의미가 유실됩니다. 게시물의 URI가 적용되는 리소스를 반드시 나타내는 것은 아니기 때문에 리소스에 대한 보안 제공에도 적용됩니다 (그렇지만 가능).</target>
        </trans-unit>
        <trans-unit id="a3841df602dc207eb894628e42ca39fa38600ef6" translate="yes" xml:space="preserve">
          <source>POST invalidates cached copies of the entire containing resource (better consistency)</source>
          <target state="translated">POST는 전체 포함 리소스의 캐시 된 복사본을 무효화합니다 (일관성 향상)</target>
        </trans-unit>
        <trans-unit id="c22f736aab2b2863938a628162d88b4124790887" translate="yes" xml:space="preserve">
          <source>POST is basically a free form message, with its meaning being defined 'out of band'. If the message can be interpreted as adding a resource to a directory, that would be OK, but basically you need to understand the message you are sending (posting) to know what will happen with the resource.</source>
          <target state="translated">POST는 기본적으로 자유 형식 메시지이며 그 의미는 '대역 외'로 정의됩니다. 메시지가 디렉토리에 자원을 추가하는 것으로 해석 될 수 있으면 문제가 없지만 기본적으로 자원에 어떤 일이 발생하는지 알기 위해 송신 (게시)하는 메시지를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="50e5624274970285a79a86def7e5f8ea14309ec5" translate="yes" xml:space="preserve">
          <source>POST is good for creating new objects under a collection (and create does not need to be idempotent)</source>
          <target state="translated">POST는 컬렉션에서 새 객체를 만드는 데 유용합니다 (생성 할 필요가 없습니다).</target>
        </trans-unit>
        <trans-unit id="a4348a436cd7cc96fdb0094e0c165b3beab9d039" translate="yes" xml:space="preserve">
          <source>POST is like posting a letter to a mailbox or posting an email to an email queue.
PUT is like when you put an object in a cubby hole or a place on a shelf (it has a known address).</source>
          <target state="translated">POST는 편지함에 편지를 게시하거나 이메일을 이메일 대기열에 게시하는 것과 같습니다. PUT은 물체를 큐비 한 구멍이나 선반 위의 장소 (알려진 주소가 있음)에 넣을 때와 같습니다.</target>
        </trans-unit>
        <trans-unit id="4db2a3f164214c5ab6b6162614daef8028ccda38" translate="yes" xml:space="preserve">
          <source>POST is not idempotent and the server &amp;hellip;</source>
          <target state="translated">POST는 dem 등원이 아니며 서버는&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="6bf075a0e5bf009d906f75d40d6c584b360d7cb7" translate="yes" xml:space="preserve">
          <source>POST is used to send data to server.</source>
          <target state="translated">POST는 서버로 데이터를 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c4170f0e615f9fa2848d48db2ab50f375369c3" translate="yes" xml:space="preserve">
          <source>POST:</source>
          <target state="translated">POST:</target>
        </trans-unit>
        <trans-unit id="d18f4e998d15f0ab1bd153b920ca0c74bdfeff78" translate="yes" xml:space="preserve">
          <source>POSTing twice with the same data means create two identical users with different ids. PUTing twice with the same data creates the user the first and updates him to the same state the second time (no changes). Since you end up with the same state after a &lt;code&gt;PUT&lt;/code&gt; no matter how many times you perform it, it is said to be &quot;equally potent&quot; every time - idempotent. This is useful for automatically retrying requests. No more 'are you sure you want to resend' when you push the back button on the browser.</source>
          <target state="translated">동일한 데이터로 두 번 게시하면 ID가 다른 두 명의 동일한 사용자가 생성됩니다. 동일한 데이터로 두 번 PUT하면 첫 번째 사용자가 생성되고 두 번째로 동일한 상태로 업데이트됩니다 (변경 사항 없음). &lt;code&gt;PUT&lt;/code&gt; 을 수행 한 횟수에 관계없이 PUT 후에도 동일한 상태가되기 때문에 매번 &quot;동등한&quot;힘을 발휘합니다. 요청을 자동으로 재 시도하는 데 유용합니다. 브라우저에서 뒤로 버튼을 누를 때 더 이상 '재전송 하시겠습니까?'</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="0774c3d8f11a1777d7cca86a15dfce5e923b8427" translate="yes" xml:space="preserve">
          <source>PUT can also be used for create if and only if you allow the client to name the resource. But since REST clients aren't supposed to make assumptions about URL structure, this is less in the intended spirit of things.</source>
          <target state="translated">클라이언트가 자원의 이름을 지정할 수있는 경우에만 PUT을 작성에 사용할 수 있습니다. 그러나 REST 클라이언트는 URL 구조에 대해 가정하지 않아도되므로 의도 된 개념이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="53edc2f185fb0dcf741606243cd7f49687d0ba85" translate="yes" xml:space="preserve">
          <source>PUT i.e. take and &lt;strong&gt;put&lt;/strong&gt; where it was.</source>
          <target state="translated">PUT 즉, 원래 있던 곳에 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="d17262b9924f1628e9bc6d1ceface83dc9e20080" translate="yes" xml:space="preserve">
          <source>PUT is good for updating existing objects (and update needs to be idempotent)</source>
          <target state="translated">PUT은 기존 객체를 업데이트하는 데 좋습니다 (업데이트는 i 등원이어야 함)</target>
        </trans-unit>
        <trans-unit id="2528780fd61687817cc4d77380ca20d9c55d5327" translate="yes" xml:space="preserve">
          <source>PUT is idempotent, so if you PUT an object twice, it has no effect.  This is a nice property, so I would use PUT when possible.</source>
          <target state="translated">PUT은 dem 등원이므로 개체를 두 번 PUT하면 아무런 효과가 없습니다. 이것은 좋은 속성이므로 가능한 경우 PUT을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f54bdf6757feb089a4b6dd6043ed5a3812f4c969" translate="yes" xml:space="preserve">
          <source>PUT is idempotent. You can send the request 100 times and it will not matter. POST is not idempotent. If you send the request 100 times, you'll get 100 emails or 100 letters in your postal box.</source>
          <target state="translated">PUT은 dem 등원입니다. 요청을 100 번 보낼 수 있으며 중요하지 않습니다. POST는 dem 등성이 아닙니다. 요청을 100 번 보내면 우편함에 100 개의 이메일 또는 100 개의 편지가 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="7a94e837da966e20c0283efdebc7e6e8c4792dd1" translate="yes" xml:space="preserve">
          <source>PUT is less supported by e.g. Java ME, older browsers, firewalls</source>
          <target state="translated">PUT은 Java ME, 구형 브라우저, 방화벽 등에서 덜 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="beb21b8c66904ea993c9a6028ecf712630358d0d" translate="yes" xml:space="preserve">
          <source>PUT is merely a statement of what content the service should, from now on, use to render representations of the resource identified by the client; POST is a statement of what content the service should, from now on, contain (possibly duplicated) but it's up to the server how to identify that content.</source>
          <target state="translated">PUT은 이제 서비스가 클라이언트가 식별 한 자원의 표현을 렌더링하기 위해 사용해야하는 컨텐츠에 대한 설명 일뿐입니다. POST는 서비스가 어떤 내용을 포함해야하는지에 대한 진술입니다. (아마도 중복 될 수 있음) 해당 내용을 식별하는 방법은 서버에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="481e4b9e200d5c2fea82c751622373a2b6a00819" translate="yes" xml:space="preserve">
          <source>PUT is used to transfer state to the server</source>
          <target state="translated">PUT은 서버로 상태를 전송하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="bad5201391f46977a9f8deb44fc372a5bc244a21" translate="yes" xml:space="preserve">
          <source>PUT refers to a resource, identified by the URI. In this case, you are updating it. It is the part of the three verbs referring to resources -- delete and get being the other two.</source>
          <target state="translated">PUT은 URI로 식별되는 리소스를 나타냅니다. 이 경우 업데이트 중입니다. 리소스를 언급하는 세 동사의 일부입니다. 삭제하고 다른 두 개를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="d444f457d29e103ad92323fcf2afb2424bd83004" translate="yes" xml:space="preserve">
          <source>PUT responses are not cacheable while POST ones are (Require Content-Location and expiration)</source>
          <target state="translated">POST 응답이있는 동안 PUT 응답을 캐시 할 수 없습니다 (컨텐츠 위치 및 만료 필요)</target>
        </trans-unit>
        <trans-unit id="15640c28b6c6596379e40a0e541c4b7183207d73" translate="yes" xml:space="preserve">
          <source>PUT vs. POST in REST</source>
          <target state="translated">REST에서 PUT과 POST</target>
        </trans-unit>
        <trans-unit id="ecd7c4f13506fe5521c5fe5e1b3db337ba4711ed" translate="yes" xml:space="preserve">
          <source>PUT:</source>
          <target state="translated">PUT:</target>
        </trans-unit>
        <trans-unit id="ecbeb70dff39883fdc79bab75f4eab0476369bf3" translate="yes" xml:space="preserve">
          <source>Performing a POST of data which has an ID which matches a resource already in the system is &amp;ldquo;a conflict with the current state of the resource.&amp;rdquo;</source>
          <target state="translated">이미 시스템에있는 자원과 일치하는 ID를 가진 데이터의 POST를 수행하는 것은 &quot;자원의 현재 상태와 충돌합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="55c27430d43b1ad1ac779b51ba33aaaa16817d5a" translate="yes" xml:space="preserve">
          <source>Prior to PUT, clients couldn't directly know the URL that the server generated or if all it had generated any or whether the data to be sent to the server is already updated or not. PUT relieved the developer of all these headaches. PUT is idempotent, PUT handles race conditions, and PUT lets the client choose the URL.</source>
          <target state="translated">PUT 이전에는 클라이언트가 서버가 생성 한 URL이나 서버가 생성 한 모든 URL 또는 서버로 전송할 데이터가 이미 업데이트되었는지 여부를 직접 알 수 없었습니다. PUT은 이러한 모든 두통을 완화시켜줍니다. PUT은 dem 등원이며 PUT은 경쟁 조건을 처리하며 PUT은 클라이언트가 URL을 선택할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="500abc23a1f880a1d70f33cc1a5912ba903fcf59" translate="yes" xml:space="preserve">
          <source>REST is a &lt;em&gt;very&lt;/em&gt; high-level concept. In fact, it doesn't even mention HTTP at all!</source>
          <target state="translated">REST는 &lt;em&gt;매우&lt;/em&gt; 높은 수준의 개념입니다. 사실, 그것은 전혀 HTTP를 언급하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="f3f878fdda60ba178358813e7e7547df7ca8bed3" translate="yes" xml:space="preserve">
          <source>RFC 5789 says about PATCH (since 1995):</source>
          <target state="translated">RFC 5789는 PATCH에 대해 말합니다 (1995 년 이후).</target>
        </trans-unit>
        <trans-unit id="2240960be744587b090255e994fafdd819cc51d2" translate="yes" xml:space="preserve">
          <source>Readers new to this topic will be struck by the endless discussion about what you &lt;em&gt;should&lt;/em&gt; do, and the relative absence of lessons from experience. The fact that REST is &quot;preferred&quot; over SOAP is, I suppose, a high-level learning from experience, but goodness we must have progressed from there? It's 2016. Roy's dissertation was in 2000. What have we developed? Was it fun? Was it easy to integrate with? To support? Will it handle the rise of smartphones and flaky mobile connections?</source>
          <target state="translated">이 주제를 처음 접하는 독자 &lt;em&gt;는해야&lt;/em&gt; 할 일에 대한 끝없는 토론과 경험에서 얻은 교훈이없는 것에 대해 놀라게 될 것입니다. REST가 SOAP보다 &quot;선호&quot;된다는 사실은 경험을 통한 높은 수준의 학습이지만 우리가 거기서부터 발전해야한다고 생각합니까? 로이의 논문은 2000 년에있었습니다. 우리는 무엇을 개발 했습니까? 재밌었 어? 통합하기 쉬웠습니까? 지원하기 위해? 스마트 폰 및 비정상적인 모바일 연결의 증가를 처리 할 수 ​​있습니까?</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="af48dc320f6330ed03797587a11eef43f0ec6f79" translate="yes" xml:space="preserve">
          <source>Remember, REST is a set of conventions and guidelines to keep your API simple. If you end up with a complicated work-around just to check the &quot;RESTfull&quot; box then you are defeating the purpose ;)</source>
          <target state="translated">REST는 API를 단순하게 유지하기위한 일련의 규칙과 지침입니다. &quot;RESTfull&quot;상자를 체크하기 만하면 복잡한 해결 방법이 나오면 목적을 잃게됩니다.)</target>
        </trans-unit>
        <trans-unit id="ee7cc50d6752f70e6ef133296cf031acbf88d94d" translate="yes" xml:space="preserve">
          <source>Ruby on Rails 4.0 will use the 'PATCH' method instead of PUT to do partial updates.</source>
          <target state="translated">Ruby on Rails 4.0은 PUT 대신 'PATCH'방법을 사용하여 부분 업데이트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="e1a55a92c976da44c042e91aaa4d8b45fd7ebc14" translate="yes" xml:space="preserve">
          <source>Simple rule of thumb: Use POST to create, use PUT to update.</source>
          <target state="translated">간단한 경험 법칙 : POST를 사용하여 생성하고 PUT을 사용하여 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="563433492d9997914d4d5639b5bd77063df84eaa" translate="yes" xml:space="preserve">
          <source>Since the important part is for the client to understand the server has the resource and to take appropriate action. This is a &amp;ldquo;situation(s) where it is expected that the user might be able to resolve the conflict and resubmit the request.&amp;rdquo;</source>
          <target state="translated">중요한 부분은 클라이언트가 서버에 리소스가 있다는 것을 이해하고 적절한 조치를 취하는 것입니다. &quot;사용자가 충돌을 해결하고 요청을 다시 제출할 수있는 상황&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="214742f8ecec0788b74789ec5780c31fcabbb394" translate="yes" xml:space="preserve">
          <source>So you use POST and probably, but not necessary PUT for resource creation. You don't have to support both. For me POST is perfectly enough. So it is a design decision.</source>
          <target state="translated">따라서 POST를 사용하지만 리소스 생성에 필요하지는 않지만 PUT을 사용합니다. 둘 다 지원할 필요는 없습니다. 나를 위해 POST는 완벽하게 충분합니다. 따라서 디자인 결정입니다.</target>
        </trans-unit>
        <trans-unit id="312dad788b38db2f97ab20722cebe3f87855dfa4" translate="yes" xml:space="preserve">
          <source>So, which one should be used to create a resource? Or one needs to support both?</source>
          <target state="translated">리소스를 만드는 데 어떤 것을 사용해야합니까? 아니면 둘 다 지원해야합니까?</target>
        </trans-unit>
        <trans-unit id="af333de22f5db2954bfe57966628566c2cb3ee43" translate="yes" xml:space="preserve">
          <source>So: To save an existing user, or one where the client generates the id and it's been verified that the id is unique:</source>
          <target state="translated">따라서 : 기존 사용자 또는 클라이언트가 ID를 생성하고 ID가 고유하다는 것을 확인한 사용자를 저장하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a8710dbdab40fac5c2f6093ab0a397321add575c" translate="yes" xml:space="preserve">
          <source>Social Media/Network Analogy:</source>
          <target state="translated">소셜 미디어 / 네트워크 비유 :</target>
        </trans-unit>
        <trans-unit id="aa6e7d148420cbd536359dd8922d3a773a333631" translate="yes" xml:space="preserve">
          <source>Some considerations:</source>
          <target state="translated">몇 가지 고려 사항 :</target>
        </trans-unit>
        <trans-unit id="f07350c10b92f7bbca1cebbb0c1aaadbf6301a75" translate="yes" xml:space="preserve">
          <source>Some other considerations:</source>
          <target state="translated">다른 고려 사항 :</target>
        </trans-unit>
        <trans-unit id="1392b1cbf3bb0fbae1580de51f28c0eb49cc1f97" translate="yes" xml:space="preserve">
          <source>Spec:</source>
          <target state="translated">Spec:</target>
        </trans-unit>
        <trans-unit id="9d63a661c96623ad056cc93701a94dbcd5290eef" translate="yes" xml:space="preserve">
          <source>Step 6 is where people commonly get confused about what to do. However, there is no reason to create a kludge to solve this issue. Instead, HTTP can be used as specified in &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616&lt;/a&gt; and the server replies:</source>
          <target state="translated">6 단계는 사람들이 무엇을해야할지 혼란스러워하는 곳입니다. 그러나이 문제를 해결하기 위해 kludge를 만들 필요는 없습니다. 대신 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616에&lt;/a&gt; 지정된대로 HTTP를 사용할 수 있으며 서버는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="b49764080a9692f4a67935d54ce3bb45209b490c" translate="yes" xml:space="preserve">
          <source>Student Id is auto generated.</source>
          <target state="translated">학생 ID가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="aca4c099b5e77d0411d947634e38f0631bf9e86a" translate="yes" xml:space="preserve">
          <source>Successive delete requests can see and process the original confirmation, without hitting a 404 error. If things take longer than expected, we can respond provisionally, and we have a place where the client can check back for the definitive result. The nicest part of this pattern is its Kung-Fu (Panda) property. We take a weakness, the propensity for clients to repeat a request any time they don't understand the response, and turn it into &lt;em&gt;a strength&lt;/em&gt; :-)</source>
          <target state="translated">연속 삭제 요청은 404 오류를 발생시키지 않고 원래 확인을보고 처리 할 수 ​​있습니다. 예상보다 시간이 오래 걸리면 임시로 응답 할 수 있으며 고객이 최종 결과를 확인할 수있는 장소가 있습니다. 이 패턴의 가장 좋은 부분은 Kung-Fu (Panda) 속성입니다. 우리는 약점을 가지고 있으며, 고객이 응답을 이해하지 못할 때마다 요청을 반복 &lt;em&gt;하여 강점으로&lt;/em&gt; 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="b9802a34f75ab08b9f79a147b7c88bf20e2dd462" translate="yes" xml:space="preserve">
          <source>Sure you &quot;can&quot; use &quot;POST&quot; to update, but just follow the conventions laid out for you with your given framework. In my case it is .NET / Web API, so &lt;strong&gt;PUT is for UPDATE&lt;/strong&gt; there is no debate.</source>
          <target state="translated">물론 &quot;POST&quot;를 사용하여 업데이트 할 수는 있지만 주어진 프레임 워크에서 제시 한 규칙을 따르십시오. 필자의 경우 .NET / Web API이므로 &lt;strong&gt;PUT은 업데이트 용&lt;/strong&gt; 이므로 토론이 없습니다.</target>
        </trans-unit>
        <trans-unit id="88f36ec6e839653d0f7569117f42e1085634abaa" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;PUT&lt;/code&gt; is used to &lt;strong&gt;create or update&lt;/strong&gt;.</source>
          <target state="translated">즉, &lt;code&gt;PUT&lt;/code&gt; 은를 &lt;strong&gt;만들거나 업데이트&lt;/strong&gt; 하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6228527a9fe538603ee8860a20980509cae0390f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/strong&gt; method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the &lt;code&gt;Request-URI&lt;/code&gt; in the &lt;code&gt;Request-Line&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/strong&gt; 메소드는 오리진 서버가 요청에 포함 된 엔티티를 &lt;code&gt;Request-Line&lt;/code&gt; 의 &lt;code&gt;Request-URI&lt;/code&gt; 에 의해 식별 된 자원의 새로운 하위 항목으로 승인하도록 요청하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fbf25e1a44ff44b0b030b51303b10b2f4e6c0844" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/strong&gt; method requests that the enclosed entity be stored under the supplied &lt;code&gt;Request-URI&lt;/code&gt;. If the &lt;code&gt;Request-URI&lt;/code&gt; refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the &lt;code&gt;Request-URI&lt;/code&gt; does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/strong&gt; 메소드는 동봉 된 엔티티가 제공된 &lt;code&gt;Request-URI&lt;/code&gt; 아래에 저장되도록 요청합니다 . &lt;code&gt;Request-URI&lt;/code&gt; 가 이미 존재하는 자원을 참조하는 경우 동봉 된 엔티티는 원래 서버에있는 수정 된 버전으로 간주해야합니다. &lt;code&gt;Request-URI&lt;/code&gt; 가 기존 자원을 가리 키지 않고 요청 사용자 에이전트가 해당 URI를 새 자원으로 정의 할 수있는 경우, 원래 서버는 해당 URI로 자원을 작성할 수 있습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="59c1ac24b7aebd8b407e3f0c9ff99488ea7968e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;POST&lt;/strong&gt; method is used to request that the origin server &lt;strong&gt;accept&lt;/strong&gt; the entity enclosed in the request as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; subordinate&lt;/strong&gt; of the resource identified by the Request-URI in the Request-Line</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; 메소드는 오리진 서버가 요청에 포함 된 엔티티를 요청 라인의 Request-URI에 의해 식별 된 자원의 &lt;strong&gt;&lt;em&gt;새로운&lt;/em&gt; 하위&lt;/strong&gt; 항목으로 &lt;strong&gt;승인&lt;/strong&gt; 하도록 요청하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c563bf37c1b157d8576106b8f94786d60d4a88a8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;PUT&lt;/strong&gt; method requests that the enclosed entity be &lt;strong&gt;stored&lt;/strong&gt; under the supplied Request-URI. If the Request-URI refers to an &lt;strong&gt;already existing&lt;/strong&gt; resource, the enclosed entity SHOULD be considered as a &lt;strong&gt;modified version&lt;/strong&gt; of the one residing on the origin server. If the Request-URI does &lt;strong&gt;not point to an existing&lt;/strong&gt; resource, and that URI is &lt;strong&gt;capable&lt;/strong&gt; of being defined as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; resource&lt;/strong&gt; by the requesting user agent, the origin server can &lt;strong&gt;create&lt;/strong&gt; the resource with that URI.&quot;</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; 메소드는 동봉 된 엔티티가 제공된 Request-URI 아래에 &lt;strong&gt;저장&lt;/strong&gt; 되도록 요청합니다. Request-URI가 &lt;strong&gt;이미 존재하는&lt;/strong&gt; 자원을 참조하는 경우 동봉 된 엔티티는 원래 서버에있는 &lt;strong&gt;수정 된 버전&lt;/strong&gt; 으로 간주해야합니다. Request-URI가 &lt;strong&gt;기존&lt;/strong&gt; 자원을 &lt;strong&gt;가리 키지 않고&lt;/strong&gt; 요청 사용자 에이전트가 해당 URI를 &lt;strong&gt;&lt;em&gt;새&lt;/em&gt; 자원&lt;/strong&gt; 으로 정의 &lt;strong&gt;할 수있는&lt;/strong&gt; 경우, 원래 서버는 해당 URI로 자원을 &lt;strong&gt;작성할&lt;/strong&gt; 수 &lt;strong&gt;있습니다&lt;/strong&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="59fcd39418146017bc9d79b2463c3bd0da6fb592" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
    &lt;code&gt;created&lt;/code&gt; or &lt;code&gt;replaced&lt;/code&gt; with the state defined by the representation
    enclosed in the request message payload.</source>
          <target state="translated">PUT 메소드는 대상 자원의 상태를 &lt;code&gt;created&lt;/code&gt; 하거나 요청 메시지 페이로드에 포함 된 표현으로 정의 된 상태 &lt;code&gt;replaced&lt;/code&gt; 도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e77dcb77c2b94fc15160e4b361047201bc47a791" translate="yes" xml:space="preserve">
          <source>The RFC reads like this:</source>
          <target state="translated">RFC는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bf09923cd40e9a4020e710d08ab29ff70e0f921" translate="yes" xml:space="preserve">
          <source>The client POST a new resource to the server.</source>
          <target state="translated">클라이언트는 서버에 새 리소스를 POST합니다.</target>
        </trans-unit>
        <trans-unit id="6d21b96b8e9dc8ceda9663e50081fd866f4a8784" translate="yes" xml:space="preserve">
          <source>The client does not have a URL for the resource (therefore PUT is not an option) and repeats the POST.</source>
          <target state="translated">클라이언트에는 리소스에 대한 URL이 없으므로 (PUT은 옵션이 아님) POST를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="dab9c53b7a8f4efbb9c76b8f8b0c3647ff5ea29b" translate="yes" xml:space="preserve">
          <source>The client never receives the response.</source>
          <target state="translated">클라이언트는 응답을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e77aa23ca0f2f2521e9d88d6afd4e68b94dfbe8" translate="yes" xml:space="preserve">
          <source>The content type &quot;application/x-www-form-urlencoded&quot; is inefficient
  for sending large quantities of binary data or text containing
  non-ASCII characters. The content type &quot;multipart/form-data&quot; should be
  used for submitting forms that contain files, non-ASCII data, and
  binary data.</source>
          <target state="translated">&quot;application / x-www-form-urlencoded&quot;컨텐츠 유형은 많은 양의 이진 데이터 또는 ASCII가 아닌 문자를 포함하는 텍스트를 전송하는 데 비효율적입니다. 컨텐츠 유형 &quot;multipart / form-data&quot;는 파일, 비 ASCII 데이터 및 2 진 데이터를 포함하는 양식을 제출하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c00e08de50ba7cbbdbcec8cf8cc194d4e2c70887" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</source>
          <target state="translated">POST와 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영됩니다. POST 요청의 URI는 동봉 된 엔터티를 처리 할 리소스를 식별합니다. 해당 리소스는 데이터 수락 프로세스, 다른 프로토콜의 게이트웨이 또는 주석을 허용하는 별도의 엔터티 일 수 있습니다. 반대로 PUT 요청의 URI는 요청으로 묶인 엔티티를 식별합니다. 사용자 에이전트는 URI가 의도 된 것을 알고 서버는 다른 자원에 요청을 적용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="531d093617728697be6cb081a0052d11e9261dcc" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,</source>
          <target state="translated">POST와 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영됩니다. POST 요청의 URI는 동봉 된 엔터티를 처리 할 리소스를 식별합니다. 해당 리소스는 데이터 수락 프로세스, 다른 프로토콜의 게이트웨이 또는 주석을 허용하는 별도의 엔터티 일 수 있습니다. 반대로 PUT 요청의 URI는 요청으로 묶인 엔티티를 식별합니다. 사용자 에이전트는 URI가 의도 된 것을 알고 서버는 다른 자원에 요청을 적용해서는 안됩니다. 서버가 요청을 다른 URI에 적용하기를 원하는 경우,</target>
        </trans-unit>
        <trans-unit id="9a92f77699786e960e9bee1d8eacf143a2e57922" translate="yes" xml:space="preserve">
          <source>The idea of a &lt;em&gt;RESTful-URL&lt;/em&gt; is actually a violation of REST as the server is in charge of the URL structure and should be free to decide how to use it to avoid coupling. If this confuses you read about the significance of self discovery on API design.</source>
          <target state="translated">&lt;em&gt;RESTful-URL&lt;/em&gt; 의 아이디어는 서버가 URL 구조를 담당하므로 실제로 REST를 위반하는 것이므로 커플 링을 피하기 위해이를 사용하는 방법을 자유롭게 결정해야합니다. 이것이 혼란 스러우면 API 디자인에서 자체 발견의 중요성에 대해 읽습니다.</target>
        </trans-unit>
        <trans-unit id="08c88ada7f30da94a298cf8074dd8cb30fa5608e" translate="yes" xml:space="preserve">
          <source>The most important consideration is &lt;em&gt;reliability&lt;/em&gt;. If a POST message gets lost the state of the system is undefined. Automatic recovery is impossible. For PUT messages, the state is undefined only until the first successful retry.</source>
          <target state="translated">가장 중요한 고려 사항은 &lt;em&gt;신뢰성&lt;/em&gt; 입니다. POST 메시지가 유실되면 시스템 상태가 정의되지 않습니다. 자동 복구가 불가능합니다. PUT 메시지의 경우 첫 번째 재 시도까지만 상태가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70a1801f56d9e3b89398dd57a765b43ab4ffd957" translate="yes" xml:space="preserve">
          <source>The relevant specification for PUT and POST is &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</source>
          <target state="translated">PUT 및 POST에 대한 관련 사양은 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5212416a9c7e401d69b6999879d0f06d6e6c6b8f" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
  state of the resource. This code is only allowed in situations where
  it is expected that the user might be able to resolve the conflict and
  resubmit the request. The response body SHOULD include enough</source>
          <target state="translated">자원의 현재 상태와 충돌하여 요청을 완료 할 수 없습니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수있는 상황에서만 허용됩니다. 응답 본문에는 충분히 포함되어야합니다</target>
        </trans-unit>
        <trans-unit id="d5fcf6a88ce59329f97adb1fc601b9b08db15db3" translate="yes" xml:space="preserve">
          <source>The semantics are supposed be different, in that &quot;PUT&quot;, like &quot;GET&quot; is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.</source>
          <target state="translated">의미는 &quot;GET&quot;과 같은 &quot;PUT&quot;이 dem 등원이어야한다는 의미에서 달라야합니다. 즉, 동일한 정확한 PUT 요청을 여러 번 수행 할 수 있으며 결과는 한 번만 실행하는 것처럼됩니다.</target>
        </trans-unit>
        <trans-unit id="6497cf669dc224da5094578e5e54fa6ced3cdbc7" translate="yes" xml:space="preserve">
          <source>The server does the business, returns the response &lt;em&gt;and stores it against the agreed action URI&lt;/em&gt;. If anything goes wrong, the client repeats the request (natural behaviour!), and if the server has already seen it, it repeats the stored response &lt;em&gt;and does nothing else&lt;/em&gt;.</source>
          <target state="translated">서버는 비즈니스를 수행하고 응답을 리턴 &lt;em&gt;하며 동의 된 조치 URI에 대해&lt;/em&gt; 응답 &lt;em&gt;을 저장합니다&lt;/em&gt; . 문제가 발생하면 클라이언트는 요청을 반복하고 (자연스러운 행동!) 서버가 이미 요청을 본 경우 저장된 응답을 반복하고 &lt;em&gt;다른 작업은 수행하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5da1be1c708bb16e849af08a7fb0aa8d0d4c1309" translate="yes" xml:space="preserve">
          <source>The server is unaware the client has not received the response.</source>
          <target state="translated">서버가 클라이언트가 응답을받지 않았다는 것을 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="62a97e57f72e643adc7cc713734b78e46c053ea2" translate="yes" xml:space="preserve">
          <source>The server processes the request and sends a response.</source>
          <target state="translated">서버는 요청을 처리하고 응답을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ad17da286154778c13914cd41e9cf66091180592" translate="yes" xml:space="preserve">
          <source>There seems to always be some confusion as to when to use the HTTP POST versus the HTTP PUT method for REST services. Most developers will try to associate CRUD operations directly to HTTP methods. I will argue that this is not correct and one can not simply associate the CRUD concepts to the HTTP methods. That is:</source>
          <target state="translated">REST 서비스에 HTTP POST 대 HTTP PUT 메소드를 사용하는시기에 대해서는 항상 약간의 혼동이있는 것 같습니다. 대부분의 개발자는 CRUD 작업을 HTTP 메서드에 직접 연결하려고합니다. 나는 이것이 정확하지 않으며 CRUD 개념을 HTTP 메소드에 간단히 연관시킬 수는 없다고 주장 할 것이다. 그건:</target>
        </trans-unit>
        <trans-unit id="7612d7c41fbfbe6d8a2310c67de97a21fbe00850" translate="yes" xml:space="preserve">
          <source>Therefore: &lt;strong&gt;PUT&lt;/strong&gt; is only a candidate for CREATE where the client already knows the url before the resource is created. Eg. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; as the title is used as the resource key</source>
          <target state="translated">따라서 &lt;strong&gt;PUT&lt;/strong&gt; 은 리소스가 생성되기 전에 클라이언트가 이미 URL을 알고있는 CREATE의 후보 일뿐입니다. 예 : 제목으로 &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; 을 리소스 키로 사용</target>
        </trans-unit>
        <trans-unit id="ea0f8ddfd30845a4b1c6a9e4d8ca5de38b2ab4ea" translate="yes" xml:space="preserve">
          <source>This forces the API to avoid state transition problems with multiple clients updating a single resource, and matches more nicely with event sourcing and CQRS. When the work is done asynchronously, POSTing the transformation and waiting for it to be applied seems appropriate.</source>
          <target state="translated">이를 통해 API는 단일 클라이언트를 업데이트하는 여러 클라이언트의 상태 전이 문제를 피하고 이벤트 소싱 및 CQRS와 더 잘 일치합니다. 작업이 비동기 적으로 수행되면 변환을 POST하고 적용되기를 기다리는 것이 적절 해 보입니다.</target>
        </trans-unit>
        <trans-unit id="0d513503c5d27d970dedbc3a017aa5dfc6730d1b" translate="yes" xml:space="preserve">
          <source>This is what AtomPub has to say about resource creation (section 9.2):</source>
          <target state="translated">이것이 AtomPub가 리소스 생성 (섹션 9.2)에 대해 말한 내용입니다.</target>
        </trans-unit>
        <trans-unit id="db06c4e9bb7f4493ec87367452486878b32df472" translate="yes" xml:space="preserve">
          <source>This jibes with the other advice here, that PUT is best applied to resources that already have a name, and POST is good for creating a new object under an existing resource (and letting the server name it).</source>
          <target state="translated">이것은 다른 조언과 함께 PUT이 이미 이름을 가진 리소스에 가장 적합하고 POST는 기존 리소스 아래에 새 객체를 만들고 서버 이름을 지정하는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="329ccd5deda6ee5083da67216837de43b64d3560" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI of the Collection.</source>
          <target state="translated">컬렉션에 멤버를 추가하기 위해 클라이언트는 POST 요청을 컬렉션의 URI로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8a44f83e9442ef60d290f2c8799f5cc060ff1e23" translate="yes" xml:space="preserve">
          <source>To overwrite an existing resource:</source>
          <target state="translated">기존 리소스를 덮어 쓰려면</target>
        </trans-unit>
        <trans-unit id="300c31c8ca811ac31b1e4b0cbcc5df25674e9c0e" translate="yes" xml:space="preserve">
          <source>To understand it we need to question why PUT was required, what were the problems PUT was trying to solve that POST couldn't.</source>
          <target state="translated">이를 이해하기 위해 PUT이 필요한 이유, PUT이 POST로 해결할 수없는 문제는 무엇인지 질문해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b77e3950318466e7b1306d760c2096fcdcc38f3" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URI): Generic Syntax and Semantics</source>
          <target state="translated">URI (Uniform Resource Identifier) ​​: 일반 구문 및 의미</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="e2fbf38e05ed6d395ec7f6efdfd2ea298e430b2a" translate="yes" xml:space="preserve">
          <source>Updates the resource with &lt;strong&gt;existingResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">/ resources URI 또는 &lt;strong&gt;collection&lt;/strong&gt; 에서 식별자로 &lt;strong&gt;existingResourceId&lt;/strong&gt; 를 사용하여 자원을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="f8079d8e5134eb77a5128a4f32d06200addab2ae" translate="yes" xml:space="preserve">
          <source>Use POST to create, and PUT to update. That's how Ruby on Rails is doing it, anyway.</source>
          <target state="translated">POST를 사용하여 생성하고 PUT을 사용하여 업데이트하십시오. 어쨌든 Ruby on Rails는 그렇게하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3328f33c6c2ad3028951ba9c219f5262089b33" translate="yes" xml:space="preserve">
          <source>Used to create a resource, or
  overwrite it.  While you specify the
  resources new URL.</source>
          <target state="translated">리소스를 만들거나 덮어 쓰는 데 사용됩니다. 자원을 새 URL로 지정하는 동안.</target>
        </trans-unit>
        <trans-unit id="caad456be6f2e43799931b874b916e57d669f040" translate="yes" xml:space="preserve">
          <source>Used to modify and update a resource</source>
          <target state="translated">자원 수정 및 업데이트에 사용</target>
        </trans-unit>
        <trans-unit id="534d6f360955fe24940d916537fd5f5d03013712" translate="yes" xml:space="preserve">
          <source>Useful when a resource's URL is known</source>
          <target state="translated">자원의 URL을 알고있을 때 유용</target>
        </trans-unit>
        <trans-unit id="87dffc568fb442d1ab8b5daa3edd8813475735c7" translate="yes" xml:space="preserve">
          <source>Useful when the resource's URL is
unknown</source>
          <target state="translated">리소스의 URL을 알 수 없을 때 유용</target>
        </trans-unit>
        <trans-unit id="d2f00b419fb58779569430425949be8c2946ab81" translate="yes" xml:space="preserve">
          <source>When dealing with REST and URI as general, you have &lt;strong&gt;generic&lt;/strong&gt; on the &lt;em&gt;left&lt;/em&gt; and &lt;strong&gt;specific&lt;/strong&gt; on the &lt;em&gt;right&lt;/em&gt;. The &lt;strong&gt;generics&lt;/strong&gt; are usually called &lt;strong&gt;collections&lt;/strong&gt; and the more &lt;strong&gt;specific&lt;/strong&gt; items can be called &lt;strong&gt;resource&lt;/strong&gt;. Note that a &lt;strong&gt;resource&lt;/strong&gt; can contain a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">REST 및 URI를 일반적으로 처리 할 때 &lt;em&gt;왼쪽에&lt;/em&gt; &lt;strong&gt;일반&lt;/strong&gt; 이 있고 &lt;em&gt;오른쪽&lt;/em&gt; 에 &lt;strong&gt;특정&lt;/strong&gt; 이 &lt;em&gt;있습니다&lt;/em&gt; . &lt;strong&gt;제네릭&lt;/strong&gt; 은 일반적으로 &lt;strong&gt;컬렉션&lt;/strong&gt; 이라고하며보다 &lt;strong&gt;구체적인&lt;/strong&gt; 항목은 &lt;strong&gt;resource&lt;/strong&gt; 라고 할 수 있습니다. &lt;strong&gt;리소스&lt;/strong&gt; 는 &lt;strong&gt;컬렉션을&lt;/strong&gt; 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ad7c96823b5a1d653bec9e758d08db87c5209c" translate="yes" xml:space="preserve">
          <source>When you POST to a resource at a particular URL, often you are posting a related piece of information to that URL. This implies that the resource at the URL already exists.</source>
          <target state="translated">특정 URL의 리소스에 POST를 수행 할 때 관련 정보를 해당 URL에 게시하는 경우가 종종 있습니다. 이는 URL의 리소스가 이미 존재 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f6bf84ba90320cefe0d8fa5d18b1d11fe5272e46" translate="yes" xml:space="preserve">
          <source>When you PUT a resource at a particular URL what happens is that it should get saved at that URL, or something along those lines.</source>
          <target state="translated">특정 URL에 리소스를 넣으면 해당 URL 또는 해당 줄에 저장되어야합니다.</target>
        </trans-unit>
        <trans-unit id="03669db6e556a71ab819d40f836e5bd27373b8b6" translate="yes" xml:space="preserve">
          <source>When you can't fully trust the client to do the right thing, it would be 
more appropriate to use &lt;strong&gt;POST&lt;/strong&gt; to create a new item and then send the URL back to the client in the response.</source>
          <target state="translated">클라이언트가 올바른 작업을 수행 할 수 있다고 완전히 신뢰할 수없는 경우 &lt;strong&gt;POST&lt;/strong&gt; 를 사용하여 새 항목을 만든 다음 응답으로 클라이언트에 URL을 다시 보내는 것이 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="22766c7cfca9b0f8a5c36dfb8f98f375b88a60a7" translate="yes" xml:space="preserve">
          <source>When you use POST you are &lt;strong&gt;always&lt;/strong&gt; refering to a &lt;strong&gt;collection&lt;/strong&gt;, so whenever you say:</source>
          <target state="translated">POST를 사용할 때 &lt;strong&gt;항상&lt;/strong&gt; &lt;strong&gt;collection을&lt;/strong&gt; 참조하므로 다음과 같이 말할 때마다 :</target>
        </trans-unit>
        <trans-unit id="e380bb1d3e7c031588ca3a3c5bf3f6f0d241ddcf" translate="yes" xml:space="preserve">
          <source>Which is used is left up to you.  But just remember to use the right one depending on what object you are referencing in the request.</source>
          <target state="translated">사용되는 것은 당신에게 달려 있습니다. 그러나 요청에서 참조하는 객체에 따라 올바른 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebbb5885abc4335ac57b9aa863e7c08abfc8ea5e" translate="yes" xml:space="preserve">
          <source>Which means if you have to submit</source>
          <target state="translated">제출해야하는 경우</target>
        </trans-unit>
        <trans-unit id="1e394f3df68b2548c835945807e40cf42b367d8e" translate="yes" xml:space="preserve">
          <source>While there is probably an agnostic way to describe these, it does seem to be conflicting with various statements from answers to websites.</source>
          <target state="translated">이것들을 설명 할 수있는 불가지론적인 방법이있을 수 있지만, 웹 사이트에 대한 답변에서부터 다양한 진술과 충돌하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5bc20d2d4325f529ff7555db67ccca89565a4cd" translate="yes" xml:space="preserve">
          <source>Wikipedia - REST</source>
          <target state="translated">위키 백과-REST</target>
        </trans-unit>
        <trans-unit id="386e23f3812d1bdded28437f31996a6a569b6fd3" translate="yes" xml:space="preserve">
          <source>With &amp;ldquo;REST without PUT&amp;rdquo; technique, the idea is that consumers are
  forced to post new 'nounified' request resources. As discussed
  earlier, changing a customer&amp;rsquo;s mailing address is a POST to a new
  &amp;ldquo;ChangeOfAddress&amp;rdquo; resource, not a PUT of a &amp;ldquo;Customer&amp;rdquo; resource with a
  different mailing address field value.</source>
          <target state="translated">&quot;PUT없는 REST&quot;기술을 사용하면 소비자는 새로운 'ununified'요청 리소스를 게시해야합니다. 앞에서 설명한 것처럼 고객의 우편 주소 변경은 다른 우편 주소 필드 값을 가진 &quot;고객&quot;자원의 PUT이 아닌 새로운 &quot;ChangeOfAddress&quot;자원에 대한 POST입니다.</target>
        </trans-unit>
        <trans-unit id="53a0df456d0b82cfb20df7d1c7dcda70c26fd29c" translate="yes" xml:space="preserve">
          <source>With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.</source>
          <target state="translated">POST를 사용하면 URL을 수정하는 동시에 2 개의 요청을 수신 할 수 있으며 오브젝트의 다른 부분을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcec0b85a95c09c1d9aa73bbac93122064920f3c" translate="yes" xml:space="preserve">
          <source>With POST, you're posting to the address of the QUEUE or COLLECTION. With PUT, you're putting to the address of the ITEM.</source>
          <target state="translated">POST를 사용하면 QUEUE 또는 COLLECTION의 주소에 게시됩니다. PUT을 사용하면 ITEM의 주소를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e394766f3d8f38a5425a15f2e94e15f94cff2588" translate="yes" xml:space="preserve">
          <source>With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.</source>
          <target state="translated">PUT을 사용하면 동일한 쿼리가 여러 번 또는 한 번 실행되는 경우 STUDENT 테이블 상태는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9f13e4060016ff9f870bc818b8b5bcb9592a2292" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;POST&lt;/code&gt; to example.com/users since you don't know the &lt;code&gt;URL&lt;/code&gt; of the user yet, you want the server to create it.</source>
          <target state="translated">아직 사용자의 &lt;code&gt;URL&lt;/code&gt; 을 모르기 때문에 example.com/users에 &lt;code&gt;POST&lt;/code&gt; 를 수행하여 서버에서 URL 을 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a3e29206f13fd7f313ac3a03984149fd94f809d9" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;PUT&lt;/code&gt; to example.com/users/id since you want to replace/create a &lt;em&gt;specific&lt;/em&gt; user.</source>
          <target state="translated">&lt;em&gt;특정&lt;/em&gt; 사용자를 바꾸거나 만들려고하므로 example.com/users/id에 &lt;code&gt;PUT&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cd925494376cae5537a3d23703b024e74bd08383" translate="yes" xml:space="preserve">
          <source>You can find assertions on the web that say</source>
          <target state="translated">웹에서 다음과 같은 어설 션을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deb01051624c8536f5e270d282325b0dbf3553ef" translate="yes" xml:space="preserve">
          <source>You can update or create a resource with PUT with the same object URL</source>
          <target state="translated">동일한 객체 URL로 PUT을 사용하여 리소스를 업데이트하거나 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="50c70a21ef7f357ae45ec172565f2b589fc30211" translate="yes" xml:space="preserve">
          <source>You could though do something like
  this to create a resources using POST:</source>
          <target state="translated">POST를 사용하여 리소스를 만들기 위해 이와 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dddfd0893267c4dc2c1565595682d6ee7fe0449" translate="yes" xml:space="preserve">
          <source>You do not need to support both PUT and POST.</source>
          <target state="translated">PUT과 POST를 모두 지원할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a70c96038989ab75bed3ead389a54345761a879" translate="yes" xml:space="preserve">
          <source>You have to ask &quot;what are you performing the action to?&quot; to distinguish what you should be using. Let's assume you're designing an API for asking questions.  If you want to use POST then you would do that to a list of questions. If you want to use PUT then you would do that to a particular question.</source>
          <target state="translated">&quot;무슨 행동을하고 있습니까?&quot; 사용해야 할 것을 구별하기 위해. 질문을하기위한 API를 디자인한다고 가정 해 봅시다. POST를 사용하려면 질문 목록을 작성하십시오. PUT을 사용하려면 특정 질문에 대해 PUT을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aab05f743ff11af397a41e6a50b339a3a9b253b8" translate="yes" xml:space="preserve">
          <source>You will quickly spot the similarity with promises: we create and return the placeholder for the result before doing anything. Also like a promise, an action can succeed or fail one time, but its result can be fetched repeatedly.</source>
          <target state="translated">약속을 통해 유사점을 신속하게 파악할 수 있습니다. 어떤 작업을 수행하기 전에 결과에 대한 자리 표시자를 만들고 반환합니다. 또한 약속과 같이 동작은 한 번 성공하거나 실패 할 수 있지만 결과는 반복적으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f363cc5672437cee525e493743ecf9b56f18170d" translate="yes" xml:space="preserve">
          <source>files, non-ASCII data, and binary data</source>
          <target state="translated">파일, 비 ASCII 데이터 및 이진 데이터</target>
        </trans-unit>
        <trans-unit id="03d4991f0d2b56909a00a2c07cb0c98115001bed" translate="yes" xml:space="preserve">
          <source>information for the user to recognize the source of the conflict.
  Ideally, the response entity would include enough information for the
  user or user agent to fix the problem; however, that might not be
  possible and is not required.</source>
          <target state="translated">사용자가 충돌의 원인을 인식 할 수있는 정보. 이상적으로, 응답 엔티티는 사용자 또는 사용자 에이전트가 문제를 해결하기에 충분한 정보를 포함 할 것이다. 그러나 불가능할 수도 있고 필요하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7cc393671d331a6f24f8870a93fd8292a27451f" translate="yes" xml:space="preserve">
          <source>it will work, but semantically you are saying that you want to add a resource to the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">작동하지만 의미 상 &lt;em&gt;사용자&lt;/em&gt; &lt;strong&gt;콜렉션&lt;/strong&gt; 아래의 &lt;em&gt;john&lt;/em&gt; &lt;strong&gt;콜렉션&lt;/strong&gt; 에 자원을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="d0b50e773f074b959f39222603c21bd08feff7c0" translate="yes" xml:space="preserve">
          <source>taken from &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Resource Modeling by Prakash Subramaniam of Thoughtworks&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API 디자인-Prakash Subramaniam의 리소스 모델링에서 가져온 것&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebe73780ee4475ed56cfa08985bac3ceeb53b38" translate="yes" xml:space="preserve">
          <source>the origin server can create the resource with that URI</source>
          <target state="translated">오리진 서버는 해당 URI로 자원을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c609ca0b9379838bc225c20d08b72b88e05939" translate="yes" xml:space="preserve">
          <source>you are posting a new user to the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">새로운 사용자를 &lt;em&gt;users&lt;/em&gt; &lt;strong&gt;컬렉션에&lt;/strong&gt; 게시합니다.</target>
        </trans-unit>
        <trans-unit id="d1f3bfcffc130ebfe19bd9ae363ee7834942fb61" translate="yes" xml:space="preserve">
          <source>you are telling to the server update, or create if it doesn't exist, the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;resource&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">서버 업데이트를 알리거나 &lt;em&gt;users&lt;/em&gt; &lt;strong&gt;collection&lt;/strong&gt; 아래에 &lt;em&gt;john&lt;/em&gt; &lt;strong&gt;자원&lt;/strong&gt; 이 존재하지 않는 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ac747133049c7cac58b2f01633f4d4824881c480" translate="yes" xml:space="preserve">
          <source>you should use &lt;strong&gt;POST&lt;/strong&gt; method</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; 방법을 사용해야 &lt;strong&gt;합니다&lt;/strong&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
