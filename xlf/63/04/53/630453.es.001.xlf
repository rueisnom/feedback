<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/630453">
    <body>
      <group id="630453">
        <trans-unit id="0c058b89b3c60a0ba555a3620d744eb93c511f1a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH is the new primary HTTP method for updates&lt;/a&gt;&quot; explains it.</source>
          <target state="translated">&quot; &lt;a href=&quot;http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/&quot;&gt;Edge Rails: PATCH es el nuevo m&amp;eacute;todo HTTP primario para las actualizaciones&lt;/a&gt; &quot;, lo explica.</target>
        </trans-unit>
        <trans-unit id="f74f51ed1b6ae265800adfcf8027c01c0018665f" translate="yes" xml:space="preserve">
          <source>10.4.10 409 Conflict</source>
          <target state="translated">10.4.10 409 Conflicto</target>
        </trans-unit>
        <trans-unit id="506fa830744fbb202514e4450da7b9fff37040d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; is designed to replace 2616 and in &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; describes the follow possible response for a POST</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; est&amp;aacute; dise&amp;ntilde;ado para reemplazar 2616 y en la &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-4.3.3&quot;&gt;Secci&amp;oacute;n 4.3.3&lt;/a&gt; describe la siguiente respuesta posible para un POST</target>
        </trans-unit>
        <trans-unit id="1a0c5e7063c7016b18d6c3928f19f62e9242e7e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;I wrote the following as part of another answer on SO regarding this&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359&quot;&gt;Escrib&amp;iacute; lo siguiente como parte de otra respuesta en SO con respecto a esto&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="55aee01ee1d0f0416e9083e2d6f6557b9818cb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST /something&lt;/code&gt;: &quot;Take what I give you and put it anywhere you want under &lt;code&gt;/something&lt;/code&gt; as long as you give me its URL when you're done.&quot;</source>
          <target state="translated">&lt;code&gt;POST /something&lt;/code&gt; : &quot;Toma lo que te doy y ponlo donde quieras debajo de &lt;code&gt;/something&lt;/code&gt; siempre que me des su URL cuando hayas terminado&quot;.</target>
        </trans-unit>
        <trans-unit id="df611b43ba33bf88fde50464bfe23c704ed98e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST x&lt;/code&gt;: &quot;Store my content and give me an identifier that I can use to identify a resource (old or new) containing said content (possibly mixed with other content). Said resource should be identical or subordinate to that which &lt;code&gt;x&lt;/code&gt; identifies.&quot; &quot;&lt;em&gt;y&lt;/em&gt;'s resource is subordinate to &lt;em&gt;x&lt;/em&gt;'s resource&quot; is typically but not necessarily implemented by making &lt;em&gt;y&lt;/em&gt; a subpath of &lt;em&gt;x&lt;/em&gt; (e.g. &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; and &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt;) and modifying the representation(s) of &lt;em&gt;x&lt;/em&gt;'s resource to reflect the existence of a new resource, e.g. with a hyperlink to &lt;em&gt;y&lt;/em&gt;'s resource and some metadata. Only the latter is really essential to good design, as URLs are opaque in REST -- you're supposed to &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;use hypermedia&lt;/a&gt; instead of client-side URL construction to traverse the service anyways.</source>
          <target state="translated">&lt;code&gt;POST x&lt;/code&gt; : &quot;Almacenar mi contenido y darme un identificador que pueda usar para identificar un recurso (antiguo o nuevo) que contenga dicho contenido (posiblemente mezclado con otro contenido). Dicho recurso debe ser id&amp;eacute;ntico o subordinado a lo que &lt;code&gt;x&lt;/code&gt; identifica&quot;. &quot;El recurso de y est&amp;aacute; subordinado al recurso de &lt;em&gt;x&lt;/em&gt; &quot; se implementa t&amp;iacute;picamente, pero no necesariamente, haciendo &lt;em&gt;y&lt;/em&gt; un subpath de &lt;em&gt;x&lt;/em&gt; (por ejemplo, &lt;em&gt;x&lt;/em&gt; = &lt;code&gt;/foo&lt;/code&gt; e &lt;em&gt;y&lt;/em&gt; = &lt;code&gt;/foo/bar&lt;/code&gt; ) y modificando las representaciones de &lt;em&gt;x&lt;/em&gt; ' s recurso para reflejar la existencia de un nuevo recurso, por ejemplo, con un hiperv&amp;iacute;nculo al recurso y y algunos metadatos. Solo lo &amp;uacute;ltimo es realmente esencial para un buen dise&amp;ntilde;o, ya que las URL son opacas en REST: se supone que debe &lt;a href=&quot;https://stackoverflow.com/a/9194942/972499&quot;&gt;usar hipermedia en&lt;/a&gt; lugar de la construcci&amp;oacute;n de URL del lado del cliente para atravesar el servicio de todos modos.</target>
        </trans-unit>
        <trans-unit id="d458584efe00bde626b31645f1c9331669a393b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POST&lt;/code&gt; means &quot;create new&quot; as in &quot;Here is the input for creating a user, create it for me&quot;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; significa &quot;crear nuevo&quot; como en &quot;Aqu&amp;iacute; est&amp;aacute; la entrada para crear un usuario, cr&amp;eacute;elo por m&amp;iacute;&quot;.</target>
        </trans-unit>
        <trans-unit id="1a07f91414dd50cc7f1986ee5d6ee5a1fbee9ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; already exists): &quot;Take whatever you have at &lt;code&gt;/something&lt;/code&gt; and replace it with what I give you.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; (si &lt;code&gt;/something&lt;/code&gt; ya existe): &quot;Toma lo que tengas en &lt;code&gt;/something&lt;/code&gt; y reempl&amp;aacute;zalo con lo que te doy&quot;.</target>
        </trans-unit>
        <trans-unit id="46ab7ec42035f8ace3ccbdc9e29957431a709ad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; does not already exist): &quot;Take what I give you and put it at &lt;code&gt;/something&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;PUT /something&lt;/code&gt; (if &lt;code&gt;/something&lt;/code&gt; todav&amp;iacute;a no existe): &quot;Toma lo que te doy y ponlo en &lt;code&gt;/something&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="8b19b9a7682dd06e6b9d4d9b60e4befaf7e822f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; does not identify a resource): &quot;Create a new resource containing my content and use &lt;code&gt;x&lt;/code&gt; to identify it.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; (si &lt;code&gt;x&lt;/code&gt; no identifica un recurso): &quot;Crear un nuevo recurso que contenga mi contenido y use &lt;code&gt;x&lt;/code&gt; para identificarlo&quot;.</target>
        </trans-unit>
        <trans-unit id="b7eeae57fac13ac526305058d9ec04d7f1c90069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; identifies a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;resource&lt;/a&gt;): &quot;Replace the content of the resource identified by &lt;code&gt;x&lt;/code&gt; with my content.&quot;</source>
          <target state="translated">&lt;code&gt;PUT x&lt;/code&gt; (si &lt;code&gt;x&lt;/code&gt; identifica un &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1&quot;&gt;recurso&lt;/a&gt; ): &quot;Reemplace el contenido del recurso identificado por &lt;code&gt;x&lt;/code&gt; con mi contenido&quot;.</target>
        </trans-unit>
        <trans-unit id="693d0f55f15f15a3670f566554ad630959a6464b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PUT&lt;/code&gt; means &quot;insert, replace if already exists&quot; as in &quot;Here is the data for user 5&quot;.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; significa &quot;insertar, reemplazar si ya existe&quot; como en &quot;Aqu&amp;iacute; est&amp;aacute;n los datos para el usuario 5&quot;.</target>
        </trans-unit>
        <trans-unit id="ba9411546a0e55dde6f6b3b345e14406853999d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Algunos pueden pensar que las actualizaciones se pueden realizar con POST.&lt;/em&gt; &lt;em&gt;No hay una regla estricta sobre cu&amp;aacute;l usar para las actualizaciones o cu&amp;aacute;l usar para crear.&lt;/em&gt; &lt;em&gt;Nuevamente, estas son convenciones, e intuitivamente me inclino por el razonamiento mencionado anteriormente y lo sigo.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="494905e8546c28f7ca25ed531d6f9532f60855f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;-- generic -- specific --&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;- gen&amp;eacute;rico - espec&amp;iacute;fico -&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24bd66f9b0232fdec5910e08746f4135f3abc5f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.3.4.  PUT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.3.4&lt;/strong&gt; &lt;strong&gt;PONER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f00078b6cfd30a400e58409eebd42604b45de8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Un ejemplo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b79f8a35030639797e581e3751e158add431466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Great both can be used, so which one should I use in my RESTful design:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Se pueden usar dos excelentes, as&amp;iacute; que &amp;iquest;cu&amp;aacute;l debo usar en mi dise&amp;ntilde;o RESTful?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f204e179a99e4e4da9b046149c8fa27fab675704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Long Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Respuesta larga:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ea66d061a28052dccef1603c0375aa549c7f0e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Longer Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Respuesta larga:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d19062995715b13929a5b7d5ad16cd259eea9489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.</source>
          <target state="translated">&lt;strong&gt;NOTA:&lt;/strong&gt; PUT necesita una ubicaci&amp;oacute;n de recursos (ya-resource) en la que debe realizarse la actualizaci&amp;oacute;n, mientras que POST no lo requiere. Por lo tanto, intuitivamente POST est&amp;aacute; destinado a la creaci&amp;oacute;n de un nuevo recurso, mientras que PUT es necesario para actualizar el recurso ya existente.</target>
        </trans-unit>
        <trans-unit id="973a94f5bc8d247be1da5613a2678e40ad80ce20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;New answer (now that I understand REST better):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nueva respuesta (ahora que entiendo mejor REST):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6eaec7db8eb07bc1a9853353813e5aacc4d8a7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; PUT has mostly been used to update resources (by replacing them in their entireties), but recently there is movement towards using PATCH for updating existing resources, as PUT specifies that it replaces the whole resource. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; PUT se ha utilizado principalmente para actualizar recursos (al reemplazarlos en su totalidad), pero recientemente se ha avanzado hacia el uso de PATCH para actualizar los recursos existentes, ya que PUT especifica que reemplaza todo el recurso. &lt;a href=&quot;http://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f39f80f6a4493b75f71f2759494c67e2fe8499a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or you can do this&lt;/strong&gt;: consider your unsafe requests as ephemeral single-user resources (let's call them actions). Clients request a new &quot;action&quot; on a substantive resource with an empty POST to the resource. POST will be used only for this. Once safely in possession of the URI of the freshly minted action, the client PUTs the unsafe request to the action URI, &lt;em&gt;not the target resource&lt;/em&gt;. Resolving the action and updating the &quot;real&quot; resource is properly the job of your API, and is here decoupled from the unreliable network.</source>
          <target state="translated">&lt;strong&gt;O puede hacer esto&lt;/strong&gt; : considere sus solicitudes inseguras como recursos ef&amp;iacute;meros de un solo usuario (llam&amp;eacute;moslas acciones). Los clientes solicitan una nueva &quot;acci&amp;oacute;n&quot; en un recurso sustantivo con una POST vac&amp;iacute;a al recurso. POST se usar&amp;aacute; solo para esto. Una vez que posee de forma segura el URI de la acci&amp;oacute;n reci&amp;eacute;n emitida, el cliente PONE la solicitud insegura al URI de acci&amp;oacute;n, &lt;em&gt;no el recurso objetivo&lt;/em&gt; . Resolver la acci&amp;oacute;n y actualizar el recurso &quot;real&quot; es adecuadamente el trabajo de su API, y aqu&amp;iacute; se desacopla de la red poco confiable.</target>
        </trans-unit>
        <trans-unit id="83d03f71c82f9f3e365473c2e90a536428e4a72f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer (might be easier to read)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Respuesta original (puede ser m&amp;aacute;s f&amp;aacute;cil de leer)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fb16687bea1f8e2c7ffd77af09d8a11526e30bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overall:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overall:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fec18cd93d5bbce335b8a8b4685449de2c1a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PATCH&lt;/strong&gt; to a URL &lt;strong&gt;updates &lt;em&gt;part&lt;/em&gt; of the resource&lt;/strong&gt; at that client defined URL.</source>
          <target state="translated">&lt;strong&gt;PATCH&lt;/strong&gt; a una URL &lt;strong&gt;actualiza &lt;em&gt;parte&lt;/em&gt; del recurso&lt;/strong&gt; en esa URL definida por el cliente.</target>
        </trans-unit>
        <trans-unit id="e900f8bab5ad45a82b31d5c9e77eb8b842fb8fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST creates a child resource&lt;/strong&gt;, so POST to &lt;code&gt;/items&lt;/code&gt; creates a resources that lives under the &lt;code&gt;/items&lt;/code&gt; resource. 
Eg. &lt;code&gt;/items/1&lt;/code&gt;. Sending the same post packet twice will create two resources.</source>
          <target state="translated">&lt;strong&gt;POST crea un recurso hijo&lt;/strong&gt; , por lo que POST a &lt;code&gt;/items&lt;/code&gt; crea un recurso que vive debajo del recurso &lt;code&gt;/items&lt;/code&gt; . P.ej. &lt;code&gt;/items/1&lt;/code&gt; . Enviar el mismo paquete postal dos veces crear&amp;aacute; dos recursos.</target>
        </trans-unit>
        <trans-unit id="84cd833b3d09b3772c7c9b69992c06365b49d808" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;POST:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51d739446154fe4129eacba513d3e7c1cbc82d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; /items</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; / art&amp;iacute;culos</target>
        </trans-unit>
        <trans-unit id="81f179204aeec70824672b29654dc73a5ef03745" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; You can think of something like &quot;INSERT INTO STUDENT(name, address) VALUES (&quot;abc&quot;, &quot;xyzzz&quot;);</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; Puede pensar en algo como &quot;INSERTAR EN EL ESTUDIANTE (nombre, direcci&amp;oacute;n) VALORES (&quot; abc &quot;,&quot; xyzzz &quot;);</target>
        </trans-unit>
        <trans-unit id="d84ba3155ffa58932b6b44f1f889c414429f25ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; a resource into a collection</source>
          <target state="translated">&lt;strong&gt;PUBLICAR&lt;/strong&gt; un recurso en una colecci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="c6057b584edf3b882a3192b1dc61a689a17f508b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; no es idempotente, donde el estado del recurso puede ser diferente si la operaci&amp;oacute;n se ejecuta varias veces en comparaci&amp;oacute;n con la ejecuci&amp;oacute;n de una sola vez.</target>
        </trans-unit>
        <trans-unit id="fa11acc5dc60894a4a26cfcbe0027d32f1604de8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;PUT&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; debe usarse para crear un recurso, y &lt;strong&gt;PUT&lt;/strong&gt; debe usarse para modificar uno</target>
        </trans-unit>
        <trans-unit id="83971fa0e325d0bc5650b7ff303b5ca7b5384576" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL &lt;strong&gt;creates a child resource&lt;/strong&gt; at a &lt;em&gt;server defined&lt;/em&gt; URL.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; a una URL &lt;strong&gt;crea un recurso hijo&lt;/strong&gt; en una URL &lt;em&gt;definida por el servidor&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="39214825f7bf31755a7524b96e478ffac1270da2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; to a URL should be used to update or create a resource which is located at some other (&quot;subordinate&quot;) URL, or is not locatable via HTTP.</source>
          <target state="translated">&lt;strong&gt;La POST&lt;/strong&gt; a una URL debe usarse para actualizar o crear un recurso que se encuentra en otra URL (&quot;subordinada&quot;) o que no se puede localizar a trav&amp;eacute;s de HTTP.</target>
        </trans-unit>
        <trans-unit id="906a2e1913665dd7ea341fe6a356f1a5db4491c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;POST&lt;/strong&gt; updates a resource, adds a subsidiary resource, or causes a change.  A POST is not idempotent, in the way that &lt;code&gt;x++&lt;/code&gt; is not idempotent.</source>
          <target state="translated">&lt;strong&gt;POST&lt;/strong&gt; actualiza un recurso, agrega un recurso subsidiario o provoca un cambio. Un POST no es idempotente, en la forma en que &lt;code&gt;x++&lt;/code&gt; no es idempotente.</target>
        </trans-unit>
        <trans-unit id="1201fa44ed952a209bb94b60653ae5e6d12e8775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cb09efafb2a756a2c8c49fbf16fde25b499a6f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt;  /items/1234</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; / art&amp;iacute;culos / 1234</target>
        </trans-unit>
        <trans-unit id="04e6413418714eccb311ba8ccd68a6eb8397b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; You can think of similar to &quot;UPDATE STUDENT SET address = &quot;abc&quot; where id=&quot;123&quot;;</source>
          <target state="translated">&lt;strong&gt;PONER&lt;/strong&gt; Puede pensar en algo similar a &quot;ACTUALIZAR EL ESTUDIANTE SET address =&quot; abc &quot;donde id =&quot; 123 &quot;;</target>
        </trans-unit>
        <trans-unit id="bac831f172bbd16f060e11a1fcf6a1142deebaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; a resource identified by collection/:id</source>
          <target state="translated">&lt;strong&gt;PONER&lt;/strong&gt; un recurso identificado por colecci&amp;oacute;n /: id</target>
        </trans-unit>
        <trans-unit id="43e9659830aa7fe8a7b61df6c3d0f9fe51884752" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; implies putting a resource - completely replacing whatever is available at the given URL with a different thing.  By definition, a PUT is idempotent.  Do it as many times as you like, and the result is the same. &lt;code&gt;x=5&lt;/code&gt; is idempotent.  You can PUT a resource whether it previously exists, or not (eg, to Create, or to Update)!</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; implica poner un recurso, reemplazar completamente lo que est&amp;eacute; disponible en la URL dada por algo diferente. Por definici&amp;oacute;n, un PUT es idempotente. Hazlo tantas veces como quieras, y el resultado es el mismo. &lt;code&gt;x=5&lt;/code&gt; es idempotente. &amp;iexcl;Puede PONER un recurso si ya existe o no (por ejemplo, para Crear o para Actualizar)!</target>
        </trans-unit>
        <trans-unit id="11d47c3923ae9d2cba6624010bda74e130873ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is for creating or replacing a resource at a &lt;strong&gt;URL known by the client&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; es para crear o reemplazar un recurso en una &lt;strong&gt;URL conocida por el cliente&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa7bf3d7c1668ea88085a1bf5c94b878a2e04e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; es idempotente, donde el estado del recurso ser&amp;aacute; el mismo si la misma operaci&amp;oacute;n se ejecuta una o varias veces.</target>
        </trans-unit>
        <trans-unit id="ad48efa009a26f69b5139207c4818699892b929a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; replaces the resource at the known url if it already exists, so sending the same request twice has no effect. In other words, &lt;strong&gt;calls to PUT are idempotent&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; reemplaza el recurso en la URL conocida si ya existe, por lo que enviar la misma solicitud dos veces no tiene ning&amp;uacute;n efecto. En otras palabras, las &lt;strong&gt;llamadas a PUT son idempotentes&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="47297bbd78d247783bb6a9b461b4320abab889a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; should be used to create a resource, and &lt;strong&gt;POST&lt;/strong&gt; should be used to modify one</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; debe usarse para crear un recurso, y &lt;strong&gt;POST&lt;/strong&gt; debe usarse para modificar uno</target>
        </trans-unit>
        <trans-unit id="2316d8434c10c4f7c6461cd73b5ad3a9c62ff074" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL &lt;strong&gt;creates/replaces the resource&lt;/strong&gt; in its entirety at the &lt;em&gt;client defined&lt;/em&gt; URL.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; a una URL &lt;strong&gt;crea / reemplaza el recurso&lt;/strong&gt; en su totalidad en la URL &lt;em&gt;definida&lt;/em&gt; por el &lt;em&gt;cliente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9a47a55d20b6233f89d8f607db5f21886379877c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PUT&lt;/strong&gt; to a URL should be used to update or create the resource that can be located at that URL.</source>
          <target state="translated">&lt;strong&gt;PUT&lt;/strong&gt; a una URL debe usarse para actualizar o crear el recurso que se puede ubicar en esa URL.</target>
        </trans-unit>
        <trans-unit id="0eb5b9e913c2e4810b9d275d9137826d6361fccb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post&lt;/strong&gt; on social media: when we post message, it creates new post.</source>
          <target state="translated">&lt;strong&gt;Publicar&lt;/strong&gt; en las redes sociales: cuando publicamos un mensaje, crea una nueva publicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c379deb81ec8171aeba8c48b33c76a4077d81ae5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put&lt;/strong&gt;(i.e. edit) for the message we already Posted.</source>
          <target state="translated">&lt;strong&gt;Poner&lt;/strong&gt; (es decir, editar) para el mensaje que ya publicamos.</target>
        </trans-unit>
        <trans-unit id="42f2ab7a6f0ba70ad4633ee1aeb9c5617f17e37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replying with a status code of 409 Conflict is the correct recourse because&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Responder con un c&amp;oacute;digo de estado de 409 Conflict es el recurso correcto porque&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="541c698af4296a2ac8f6dbcf007beace20e3289c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Respuesta corta:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7dee22b45482414ebaedf9e5284e4fb4d8d9302d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The decision of whether to use PUT or POST to create a resource on a server with an HTTP + REST API is based on who owns the URL structure.&lt;/strong&gt; Having the client know, or participate in defining, the URL struct is an unnecessary coupling akin to the undesirable couplings that arose from SOA. Escaping types of couplings is the reason REST is so popular. Therefore, &lt;strong&gt;the proper method to use is POST.&lt;/strong&gt; There are exceptions to this rule and they occur when the client wishes to retain control over the location structure of the resources it deploys. This is rare and likely means something else is wrong.</source>
          <target state="translated">&lt;strong&gt;La decisi&amp;oacute;n de usar PUT o POST para crear un recurso en un servidor con una API HTTP + REST se basa en qui&amp;eacute;n posee la estructura de URL.&lt;/strong&gt; Hacer que el cliente sepa o participe en la definici&amp;oacute;n, la estructura de URL es un acoplamiento innecesario similar a los acoplamientos indeseables que surgieron de SOA. Escapar de los tipos de acoplamientos es la raz&amp;oacute;n por la cual REST es tan popular. Por lo tanto, &lt;strong&gt;el m&amp;eacute;todo apropiado para usar es POST.&lt;/strong&gt; Hay excepciones a esta regla y ocurren cuando el cliente desea retener el control sobre la estructura de ubicaci&amp;oacute;n de los recursos que implementa. Esto es raro y probablemente significa que algo m&amp;aacute;s est&amp;aacute; mal.</target>
        </trans-unit>
        <trans-unit id="52dde7c3fb20e3705b4cb8c6fdc0d421a3aa14d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018&lt;/strong&gt;: There is a case that can be made to avoid PUT. See &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;REST without PUT&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n 2018&lt;/strong&gt; : hay un caso que se puede hacer para evitar PUT. Ver &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/rest-without-put&quot;&gt;&quot;DESCANSO sin PUT&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ab5192fbe6cef7ceb3ab2181f51408e2e0392" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update based on release of RFC 7231 to Replace 2616&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n basada en el lanzamiento de RFC 7231 para reemplazar 2616&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="823a6eb1d93ecc4c59ea5a879b8110b0723a4c56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using POST to create resources comes with a design consideration because POST is not idempotent.&lt;/strong&gt; This means that repeating a POST several times does not guarantee the same behavior each time. &lt;strong&gt;This scares people into using PUT to create resources when they should not.&lt;/strong&gt; They know it's wrong (POST is for CREATE) but they do it anyway because they don't know how to solve this problem.  This concern is demonstrated in the following situation:</source>
          <target state="translated">&lt;strong&gt;El uso de POST para crear recursos viene con una consideraci&amp;oacute;n de dise&amp;ntilde;o porque POST no es idempotente.&lt;/strong&gt; Esto significa que repetir una POST varias veces no garantiza el mismo comportamiento cada vez. &lt;strong&gt;Esto asusta a las personas a usar PUT para crear recursos cuando no deber&amp;iacute;an.&lt;/strong&gt; Saben que est&amp;aacute; mal (POST es para CREATE) pero lo hacen de todos modos porque no saben c&amp;oacute;mo resolver este problema. Esta preocupaci&amp;oacute;n se demuestra en la siguiente situaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="f8352b060f3bd6bf9405565ea670a52e1a19ac89" translate="yes" xml:space="preserve">
          <source>A PUT doesn't need to be a create; the service could error if the resource isn't already created, but otherwise update it. Or vice versa -- it may create the resource, but not allow updates. The only thing required about PUT is that it points to a specific resource, and its payload is the representation of that resource. A successful PUT means (barring interference) that a GET would retrieve the same resource.</source>
          <target state="translated">Un PUT no tiene que ser un create;el servicio podría dar error si el recurso no está ya creado,pero de otra manera actualizarlo.O viceversa...puede crear el recurso,pero no permitir actualizaciones.Lo único que se requiere de PUT es que apunte a un recurso específico,y su carga útil es la representación de ese recurso.Un PUT exitoso significa (salvo interferencia)que un GET recuperaría el mismo recurso.</target>
        </trans-unit>
        <trans-unit id="0e9a6a3224dfefa9263f801580fea79e1034124c" translate="yes" xml:space="preserve">
          <source>A REST API must not define fixed resource names or hierarchies (an
  obvious coupling of client and server). Servers must have the freedom
  to control their own namespace. Instead, allow servers to instruct
  clients on how to construct appropriate URIs, such as is done in HTML
  forms and URI templates, by defining those instructions within media
  types and link relations. [Failure here implies that clients are
  assuming a resource structure due to out-of band information, such as
  a domain-specific standard, which is the data-oriented equivalent to
  RPC's functional coupling].</source>
          <target state="translated">Una API REST no debe definir nombres de recursos fijos o jerarquías (un acoplamiento obvio de cliente y servidor).Los servidores deben tener la libertad de controlar su propio espacio de nombres.En su lugar,permitir que los servidores instruyan a los clientes sobre cómo construir las URI adecuadas,como se hace en los formularios HTML y las plantillas de URI,definiendo esas instrucciones dentro de los tipos de medios y las relaciones de los enlaces.[El fallo aquí implica que los clientes están asumiendo una estructura de recursos debido a la información fuera de banda,como un estándar específico del dominio,que es el equivalente orientado a los datos del acoplamiento funcional de la RPC].</target>
        </trans-unit>
        <trans-unit id="4eebc73de916b615d31b4a9c02c76f42d153bef9" translate="yes" xml:space="preserve">
          <source>A general advice is to use &lt;code&gt;POST&lt;/code&gt; when you need the server to be in control of &lt;code&gt;URL&lt;/code&gt; generation of your resources. Use &lt;code&gt;PUT&lt;/code&gt; otherwise.  Prefer &lt;code&gt;PUT&lt;/code&gt;  over &lt;code&gt;POST&lt;/code&gt;.</source>
          <target state="translated">Un consejo general es utilizar &lt;code&gt;POST&lt;/code&gt; cuando necesite que el servidor controle la generaci&amp;oacute;n de &lt;code&gt;URL&lt;/code&gt; de sus recursos. Use &lt;code&gt;PUT&lt;/code&gt; de lo contrario. Prefiere &lt;code&gt;PUT&lt;/code&gt; sobre &lt;code&gt;POST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a46f192218c6e582580086317328dbf11d360983" translate="yes" xml:space="preserve">
          <source>A general rule: if you know the id or name of the item, use PUT. If you want the id or name of the item to be assigned by the receiving party, use POST.</source>
          <target state="translated">Una regla general:si sabes el ID o el nombre del artículo,usa PUT.Si quieres que el id o el nombre del artículo sea asignado por el receptor,usa POST.</target>
        </trans-unit>
        <trans-unit id="8d80afd687e25858c217eccf9caa91d0cf98797f" translate="yes" xml:space="preserve">
          <source>A new method is necessary to improve interoperability and prevent
     errors.  The PUT method is already defined to overwrite a resource
     with a complete new body, and cannot be reused to do partial changes.
     Otherwise, proxies and caches, and even clients and servers, may get
     confused as to the result of the operation.  POST is already used but
     without broad interoperability (for one, there is no standard way to
     discover patch format support).  PATCH was mentioned in earlier HTTP
     specifications, but not completely defined.</source>
          <target state="translated">Es necesario un nuevo método para mejorar la interoperabilidad y evitar errores.El método PUT ya está definido para sobrescribir un recurso con un nuevo cuerpo completo,y no puede ser reutilizado para hacer cambios parciales.De lo contrario,los proxies y cachés,e incluso los clientes y servidores,pueden confundirse en cuanto al resultado de la operación.El POST ya se utiliza pero sin una amplia interoperabilidad (por ejemplo,no hay una forma estándar de descubrir el soporte del formato de parches).PATCH se mencionó en especificaciones HTTP anteriores,pero no está completamente definido.</target>
        </trans-unit>
        <trans-unit id="d7612bc02c9fa195c518a31c5e2d100c9f1167a8" translate="yes" xml:space="preserve">
          <source>A response which contains the URL of the resource with the conflicting ID and the appropriate preconditions for the resource would provide &amp;ldquo;enough information for the user or user agent to fix the problem&amp;rdquo; which is the ideal case per RFC 2616.</source>
          <target state="translated">Una respuesta que contiene la URL del recurso con la ID en conflicto y las condiciones previas apropiadas para el recurso proporcionar&amp;iacute;a &quot;suficiente informaci&amp;oacute;n para el usuario o agente de usuario para solucionar el problema&quot;, que es el caso ideal seg&amp;uacute;n RFC 2616.</target>
        </trans-unit>
        <trans-unit id="0a5f004271832132b2407dff2153fd15001e9ee0" translate="yes" xml:space="preserve">
          <source>According to ME, real-life networks are unreliable. Requests timeout. Connections are reset. Networks go down for hours or days at a time. Trains go into tunnels with mobile users aboard. For any given request (as occasionally acknowledged in all this discussion) the request can fall in the water on its way, or the response can fall in the water on its way back. &lt;strong&gt;In these conditions, issuing PUT, POST and DELETE requests directly against substantive resources has always struck me as a little brutal and naive.&lt;/strong&gt;</source>
          <target state="translated">Seg&amp;uacute;n ME, las redes de la vida real no son confiables. Solicitudes de tiempo de espera. Se restablecen las conexiones. Las redes se caen durante horas o d&amp;iacute;as a la vez. Los trenes entran en t&amp;uacute;neles con usuarios m&amp;oacute;viles a bordo. Para cualquier solicitud dada (como se reconoce ocasionalmente en toda esta discusi&amp;oacute;n), la solicitud puede caer en el agua en su camino, o la respuesta puede caer en el agua en su camino de regreso. &lt;strong&gt;En estas condiciones, emitir solicitudes PUT, POST y DELETE directamente contra recursos sustantivos siempre me ha parecido un poco brutal e ingenuo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44a64212bc466bad1c26da5cf30cd0ad13d5b0f6" translate="yes" xml:space="preserve">
          <source>According to the HTTP 1.1 specifications the GET, HEAD, DELETE, and PUT methods must be idempotent, and the POST method is not idempotent. That is to say that an operation is idempotent if it can be performed on a resource once or many times and always return the same state of that resource. Whereas a non idempotent operation can return a modified state of the resource from one request to another. Hence, in a non idempotent operation, there is no guarantee that one will receive the same state of a resource.</source>
          <target state="translated">De acuerdo con las especificaciones de HTTP 1.1 los métodos GET,HEAD,DELETE y PUT deben ser idempotentes,y el método POST no es idempotente.Es decir,una operación es idempotente si puede ser realizada sobre un recurso una o varias veces y siempre devuelve el mismo estado de ese recurso.Mientras que una operación no idempotente puede devolver un estado modificado del recurso de una petición a otra.Por lo tanto,en una operación no idempotente,no hay garantía de que se reciba el mismo estado de un recurso.</target>
        </trans-unit>
        <trans-unit id="263017c41745f1b94fb06cd0b37045f3eec4ef1a" translate="yes" xml:space="preserve">
          <source>According to the HTTP/1.1 Spec:</source>
          <target state="translated">Según el HTTP1.1 Spec:</target>
        </trans-unit>
        <trans-unit id="99391b86ae4d4984d262f89901db8c15300e563f" translate="yes" xml:space="preserve">
          <source>According to this, you cannot send files or multipart data in the &lt;strong&gt;PUT&lt;/strong&gt; method</source>
          <target state="translated">De acuerdo con esto, no puede enviar archivos o datos de varias partes en el m&amp;eacute;todo &lt;strong&gt;PUT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="400cd438f5e39bdc77550bfd923cf916451692bd" translate="yes" xml:space="preserve">
          <source>Additionally, and a bit more concisely, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 Section 4.3.4 PUT&lt;/a&gt; states (emphasis added),</source>
          <target state="translated">Adem&amp;aacute;s, y de manera un poco m&amp;aacute;s concisa, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.4&quot;&gt;RFC 7231 Secci&amp;oacute;n 4.3.4&lt;/a&gt; Estados PUT (&amp;eacute;nfasis agregado),</target>
        </trans-unit>
        <trans-unit id="18829b20b3b1624e09ed74c26fb7066a49e205d0" translate="yes" xml:space="preserve">
          <source>Analogy with database query</source>
          <target state="translated">Analogía con la consulta de la base de datos</target>
        </trans-unit>
        <trans-unit id="1ecad98fe7923a037242a110b7abf85eb0ca5b54" translate="yes" xml:space="preserve">
          <source>Analogy:</source>
          <target state="translated">Analogy:</target>
        </trans-unit>
        <trans-unit id="cd8441cd54d554959dc0b978e4c1160125beaede" translate="yes" xml:space="preserve">
          <source>As for modifying the properties of the stream, you can do that with either PUT or POST. Basically, only use &quot;PUT&quot; when the operation is idempotent - otherwise use POST.</source>
          <target state="translated">En cuanto a la modificación de las propiedades de la corriente,puedes hacerlo con PUT o POST.Básicamente,sólo usa &quot;PUT&quot; cuando la operación es idempotente-de lo contrario usa POST.</target>
        </trans-unit>
        <trans-unit id="1505fe853a030352c8bbf3a78d4f0ba03add0832" translate="yes" xml:space="preserve">
          <source>As such, numerous thorny problems go away. Repeated insert requests won't create duplicates, and we don't create the real resource until we're in possession of the data. (database columns can stay not-nullable). Repeated update requests won't hit incompatible states and won't overwrite subsequent changes. Clients can (re)fetch and seamlessy process the original confirmation for whatever reason (client crashed, response went missing, etc.).</source>
          <target state="translated">Como tal,numerosos problemas espinosos desaparecen.Las solicitudes de inserción repetidas no crearán duplicados,y no creamos el recurso real hasta que estemos en posesión de los datos.(las columnas de la base de datos pueden permanecer no anulables).Las solicitudes de actualización repetidas no darán lugar a estados incompatibles y no sobrescribirán los cambios subsiguientes.Los clientes pueden (re)obtener y procesar sin problemas la confirmación original por cualquier razón (el cliente se estrelló,la respuesta se perdió,etc.).</target>
        </trans-unit>
        <trans-unit id="9269d826939b1ae8561cb8d676c6f19e2aeeeeb8" translate="yes" xml:space="preserve">
          <source>As your quote mentioned, you use PUT for creation of there is no resource assigned to an IRI, and you want to create a resource anyway. For example, &lt;code&gt;PUT /users/123/password&lt;/code&gt; usually replaces the old password with a new one, but you can use it to create a password if it does not exist already (for example, by freshly registered users or by restoring banned users).</source>
          <target state="translated">Como mencion&amp;oacute; en su presupuesto, usted usa PUT para crear un recurso no asignado a un IRI, y de todos modos desea crear un recurso. Por ejemplo, &lt;code&gt;PUT /users/123/password&lt;/code&gt; generalmente reemplaza la contrase&amp;ntilde;a anterior por una nueva, pero puede usarla para crear una contrase&amp;ntilde;a si a&amp;uacute;n no existe (por ejemplo, por usuarios reci&amp;eacute;n registrados o restaurando usuarios prohibidos).</target>
        </trans-unit>
        <trans-unit id="678d1314d4c33bf4616bbffabc6f6412417d7408" translate="yes" xml:space="preserve">
          <source>At the risk of restating what has already been said, it seems important to remember that &lt;strong&gt;PUT&lt;/strong&gt; implies that the client controls what the &lt;em&gt;URL&lt;/em&gt; is going to end up being, when creating a resource. So part of the choice between &lt;strong&gt;PUT&lt;/strong&gt; and &lt;strong&gt;POST&lt;/strong&gt; is going to be about how much you can trust the client to provide correct, normalized &lt;em&gt;URL&lt;/em&gt; that are coherent with whatever your URL scheme is.</source>
          <target state="translated">A riesgo de repetir lo que ya se ha dicho, parece importante recordar que &lt;strong&gt;PUT&lt;/strong&gt; implica que el cliente controla lo que la &lt;em&gt;URL&lt;/em&gt; terminar&amp;aacute; siendo, al crear un recurso. Por lo tanto, parte de la elecci&amp;oacute;n entre &lt;strong&gt;PUT&lt;/strong&gt; y &lt;strong&gt;POST&lt;/strong&gt; ser&amp;aacute; sobre cu&amp;aacute;nto puede confiar en el cliente para proporcionar una &lt;em&gt;URL&lt;/em&gt; correcta y normalizada que sea coherente con cualquier esquema de URL.</target>
        </trans-unit>
        <trans-unit id="cd64c65270203c04e0ffe12619fc3c1cf5cb0838" translate="yes" xml:space="preserve">
          <source>At this point some people will argue that if &lt;em&gt;RESTful-URL's&lt;/em&gt; are used, the client does knows the URL of the resource and therefore a PUT is acceptable. After all, this is why canonical, normalized, Ruby on Rails, Django URLs are important, look at the Twitter API &amp;hellip; blah blah blah. Those people need to understand &lt;strong&gt;there is no such thing as a Restful-URL&lt;/strong&gt; and that &lt;strong&gt;Roy Fielding himself states that&lt;/strong&gt;:</source>
          <target state="translated">En este punto, algunas personas argumentar&amp;aacute;n que si se usan &lt;em&gt;RESTful-URL&lt;/em&gt; , el cliente conoce la URL del recurso y, por lo tanto, un PUT es aceptable. Despu&amp;eacute;s de todo, es por eso que las URL can&amp;oacute;nicas, normalizadas, Ruby on Rails, Django son importantes, mira la API de Twitter ... bla, bla, bla. Esas personas deben comprender que &lt;strong&gt;no existe una URL de reposo&lt;/strong&gt; y que el &lt;strong&gt;propio Roy Fielding afirma que&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="48ec0b3e3b0319156f9f91acfe20356337cec520" translate="yes" xml:space="preserve">
          <source>Based on the above idempotent definition, my take on using the HTTP PUT method versus using the HTTP POST method for REST services is:
Use the HTTP PUT method when:</source>
          <target state="translated">Basado en la definición anterior,mi opinión sobre el uso del método HTTP PUT en comparación con el método HTTP POST para los servicios REST es:Usar el método HTTP PUT cuando:</target>
        </trans-unit>
        <trans-unit id="625c633dc893bb8acf9969ce26d2c745e6ed5c5d" translate="yes" xml:space="preserve">
          <source>Because PUT and GET and DELETE refer to a resource, they are also by definition idempotent.</source>
          <target state="translated">Debido a que PUT y GET y DELETE se refieren a un recurso,también son por definición idempotentes.</target>
        </trans-unit>
        <trans-unit id="33d0f759f56954a746edd3401e6d1ad592971425" translate="yes" xml:space="preserve">
          <source>Before telling me this is not RESTful, please consider the numerous ways in which REST principles are respected. Clients don't construct URLs. The API stays discoverable, albeit with a little change in semantics. HTTP verbs are used appropriately. If you think this is a huge change to implement, I can tell you from experience that it's not.</source>
          <target state="translated">Antes de decirme que esto no es REST,por favor considere las numerosas formas en que los principios de REST son respetados.Los clientes no construyen URLs.El API se mantiene descubrible,aunque con un pequeño cambio en la semántica.Los verbos HTTP se usan apropiadamente.Si crees que es un gran cambio para implementar,puedo decirte por experiencia que no lo es.</target>
        </trans-unit>
        <trans-unit id="241aa52fb81745d04b1069f6da972cd395e23c48" translate="yes" xml:space="preserve">
          <source>Best of all, we give sending and receiving applications a chance to link the uniquely identified action to uniqueness in their respective environments. And we can start to demand, and enforce!, responsible behaviour from clients: repeat your requests as much as you like, but don't go generating a new action until you're in possession of a definitive result from the existing one.</source>
          <target state="translated">Lo mejor de todo es que damos a las solicitudes de envío y recepción la oportunidad de vincular la acción identificada como única con la singularidad en sus respectivos entornos.Y podemos empezar a exigir,¡y hacer cumplir!,un comportamiento responsable de los clientes:repita sus solicitudes tanto como quiera,pero no vaya generando una nueva acción hasta que esté en posesión de un resultado definitivo de la existente.</target>
        </trans-unit>
        <trans-unit id="b0bf6e9b80cf880bc4aee735753fe3f2ad23f833" translate="yes" xml:space="preserve">
          <source>Better is to choose between PUT and POST based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;idempotence&lt;/a&gt; of the action.</source>
          <target state="translated">Mejor es elegir entre PUT y POST basado en la &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotent&quot;&gt;idempotencia&lt;/a&gt; de la acci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="53c932206c69e73836ac721b4e0fe0b474be565c" translate="yes" xml:space="preserve">
          <source>Both PUT and POST can be used for creating.</source>
          <target state="translated">Tanto el PUT como el POST pueden ser usados para crear.</target>
        </trans-unit>
        <trans-unit id="2997f210a9beea7a9cbb23843149e3c1e35aa1ed" translate="yes" xml:space="preserve">
          <source>Both are used for data transmission between client to server, but there are subtle differences between them, which are:</source>
          <target state="translated">Ambos se utilizan para la transmisión de datos entre el cliente y el servidor,pero hay sutiles diferencias entre ellos,que son:</target>
        </trans-unit>
        <trans-unit id="15b3b6388bc7e089c531c0bb3e2208420e07f69e" translate="yes" xml:space="preserve">
          <source>By this argument, PUT is for creating when you know the URL of the thing you will create. POST can be used to create when you know the URL of the &quot;factory&quot; or manager for the category of things you want to create.</source>
          <target state="translated">Con este argumento,PUT es para crear cuando conoces la URL de la cosa que vas a crear.POST es para crear cuando sabes la URL de la &quot;fábrica&quot; o del administrador de la categoría de cosas que quieres crear.</target>
        </trans-unit>
        <trans-unit id="c7c8d0b3ba4ea21e1913266949e8103ea15c06b3" translate="yes" xml:space="preserve">
          <source>Can &lt;strong&gt;only&lt;/strong&gt; be performed with PUT in the following way:</source>
          <target state="translated">&lt;strong&gt;Solo se&lt;/strong&gt; puede realizar con PUT de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="29d666e583f03fcf75786741bc1b0cab3486e6df" translate="yes" xml:space="preserve">
          <source>Can be performed with both PUT or POST in the following way:</source>
          <target state="translated">Se puede realizar tanto con PUT como con POST de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="34e3815fe6dbc55d1a2ed6585c021c9fc37f549b" translate="yes" xml:space="preserve">
          <source>Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.</source>
          <target state="translated">Caso 1:Cuando publicas algo en tu línea de tiempo,es una nueva entrada.Así que en este caso usan el método POST porque el método POST no es impotente.</target>
        </trans-unit>
        <trans-unit id="afe97da32ea658ba5cfa1f6a3af16660a6caad91" translate="yes" xml:space="preserve">
          <source>Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.</source>
          <target state="translated">Caso 2:Si tu amigo comenta tu post la primera vez,eso también creará una nueva entrada en la base de datos para que el método POST sea utilizado.</target>
        </trans-unit>
        <trans-unit id="51c87be0979efc83a96ee19ed6970b9953da779d" translate="yes" xml:space="preserve">
          <source>Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*</source>
          <target state="translated">Caso 3:Si tu amigo edita su comentario,en este caso,tenían un ID de comentario,por lo que actualizarán un comentario existente en lugar de crear una nueva entrada en la base de datos.Por lo tanto,para este tipo de operación utilice el método PUT porque es idempotente.*</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="b0e2937475fc503e223c56343b52c44da7a6fa27" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a PUT request. For
  example, if versioning were being used and the entity being PUT
  included changes to a resource which conflict with those made by an
  earlier (third-party) request, the server might use the 409 response
  to indicate that it can&amp;rsquo;t complete the request. In this case, the
  response entity would likely contain a list of the differences between
  the two versions in a format defined by the response Content-Type.</source>
          <target state="translated">Es m&amp;aacute;s probable que ocurran conflictos en respuesta a una solicitud PUT. Por ejemplo, si se usaban versiones y la entidad que se PUT inclu&amp;iacute;a cambios en un recurso que entran en conflicto con los realizados por una solicitud anterior (de terceros), el servidor podr&amp;iacute;a usar la respuesta 409 para indicar que no puede completar la solicitud . En este caso, la entidad de respuesta probablemente contendr&amp;iacute;a una lista de las diferencias entre las dos versiones en un formato definido por el Tipo de contenido de respuesta.</target>
        </trans-unit>
        <trans-unit id="93b186070c96257e81f5f76dda28fe4aaa692252" translate="yes" xml:space="preserve">
          <source>Create:</source>
          <target state="translated">Create:</target>
        </trans-unit>
        <trans-unit id="17b1e45ff463141be485d41572191a7ed7413417" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;A&lt;/strong&gt; new resource under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;. Usually the identifier is returned by the server.</source>
          <target state="translated">Crea &lt;strong&gt;un&lt;/strong&gt; nuevo recurso en el / resources URI, o &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; . Por lo general, el servidor devuelve el identificador.</target>
        </trans-unit>
        <trans-unit id="33e5496ae029f6fe64dd2213c64d6ba200b86f51" translate="yes" xml:space="preserve">
          <source>Creates &lt;strong&gt;THE&lt;/strong&gt; new resource with &lt;strong&gt;newResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Crea &lt;strong&gt;EL&lt;/strong&gt; nuevo recurso con &lt;strong&gt;newResourceId&lt;/strong&gt; como identificador, bajo el / URI de recursos, o &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="33ac997d5d937f49dfe9ade3e811b0f958a8e36d" translate="yes" xml:space="preserve">
          <source>Do not directly correlate and map CRUD operations to HTTP methods for REST services. The use of an HTTP PUT method versus an HTTP POST method should be based on the idempotent aspect of that operation. That is, if the operation is idempotent, then use the HTTP PUT method. If the operation is non idempotent, then use the HTTP POST method.</source>
          <target state="translated">No correlacione directamente y mapee las operaciones CRUD con los métodos HTTP para los servicios REST.El uso de un método HTTP PUT frente a un método HTTP POST debe basarse en el aspecto idempempotente de esa operación.Es decir,si la operación es idempotente,entonces usa el método HTTP PUT.Si la operación no es idempotente,entonces usa el método HTTP POST.</target>
        </trans-unit>
        <trans-unit id="d370df4be6707296d029645b0b4712b06c53ef1c" translate="yes" xml:space="preserve">
          <source>Do you name your URL objects you create explicitly, or let the server decide? If you name them then use PUT.  If you let the server decide then use POST.</source>
          <target state="translated">¿Nombra los objetos URL que crea explícitamente o deja que el servidor decida? Si los nombra,entonces use PUT.Si dejas que el servidor decida,entonces usa POST.</target>
        </trans-unit>
        <trans-unit id="58945bef9cdd3ff1a80ba82c0e9d1f5a2d0ee11b" translate="yes" xml:space="preserve">
          <source>Edit: One more thing -- a PUT can create, but if it does then the ID has to be a natural ID -- AKA an email address. That way when you PUT twice, the second put is an update of the first. This makes it &lt;em&gt;idempotent&lt;/em&gt;.</source>
          <target state="translated">Editar: Una cosa m&amp;aacute;s: un PUT puede crear, pero si lo hace, la ID debe ser una ID natural, tambi&amp;eacute;n conocida como una direcci&amp;oacute;n de correo electr&amp;oacute;nico. De esa manera, cuando PUT dos veces, el segundo puesto es una actualizaci&amp;oacute;n del primero. Esto lo hace &lt;em&gt;idempotente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8ed4a1daabc4dbc57c02baa4ed3068d24acd58e8" translate="yes" xml:space="preserve">
          <source>For a new resource:</source>
          <target state="translated">Para un nuevo recurso:</target>
        </trans-unit>
        <trans-unit id="cff50999f4c249529ddc6e468c61561154669de5" translate="yes" xml:space="preserve">
          <source>For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.</source>
          <target state="translated">Por ejemplo,cuando quieras crear un nuevo stream,puedes PUTARLO a alguna URL.Pero cuando quieres POSTAR un mensaje a un stream existente,lo POSTAS a su URL.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f547ae451be4b97139f6676d6b8b56908850c325" translate="yes" xml:space="preserve">
          <source>For instance, it may not be a good idea to create credit card transactions with POST.</source>
          <target state="translated">Por ejemplo,puede que no sea una buena idea crear transacciones de tarjetas de crédito con POST.</target>
        </trans-unit>
        <trans-unit id="cc46f3f2f22617ca008bc0347b91c6bcc94f57de" translate="yes" xml:space="preserve">
          <source>For more information about this, read this &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;article&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esto, lea este &lt;a href=&quot;http://articles.joshcodes.com/?p=5&quot;&gt;art&amp;iacute;culo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd29602a6814d7031623e943eb9ad9b03163c44" translate="yes" xml:space="preserve">
          <source>From a REST architecture's point of view there is none that matters. We could have lived without PUT as well. But from a client developer's point of view it made his/her life a lot simpler.</source>
          <target state="translated">Desde el punto de vista de la arquitectura REST no hay nada que importe.Podríamos haber vivido sin PUT también.Pero desde el punto de vista de un desarrollador cliente,hizo su vida mucho más simple.</target>
        </trans-unit>
        <trans-unit id="e554373d4e3272bcfc25cfb1cdb1bc748dad0740" translate="yes" xml:space="preserve">
          <source>HTTP does nothing to ensure reliable completion of the request-response, and that's just fine because this is properly the job of network-aware applications. Developing such an application, you can jump through hoops to use PUT instead of POST, then more hoops to give a certain kind of error on the server if you detect duplicate requests. Back at the client, you then have to jump through hoops to interpret these errors, refetch, revalidate and repost.</source>
          <target state="translated">El HTTP no hace nada para asegurar que se complete de forma fiable la solicitud-respuesta,y eso está muy bien porque es el trabajo adecuado de las aplicaciones de red.Desarrollando tal aplicación,puedes saltar a través de aros para usar PUT en lugar de POST,y luego más aros para dar un cierto tipo de error en el servidor si detectas solicitudes duplicadas.De vuelta al cliente,tienes que saltar a través de los aros para interpretar estos errores,volver a buscar,revalidar y reenviar.</target>
        </trans-unit>
        <trans-unit id="b3fde5b13baf7e698d819867af72294baf96853b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Spec</source>
          <target state="translated">HTTP1.1 Spec</target>
        </trans-unit>
        <trans-unit id="5307592ab464b1dfe31ceb63373b1f53680a6aa6" translate="yes" xml:space="preserve">
          <source>Header &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">Encabezado &lt;code&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a656b7b969733403da8fb5e2a09bcb24ed7b14b0" translate="yes" xml:space="preserve">
          <source>Hence, create or update based on existence of the &lt;strong&gt;resource&lt;/strong&gt;.</source>
          <target state="translated">Por lo tanto, cree o actualice seg&amp;uacute;n la existencia del &lt;strong&gt;recurso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a09685c9924e957d538b394fd639ee93fed0a583" translate="yes" xml:space="preserve">
          <source>Hence, creates a new &lt;strong&gt;resource&lt;/strong&gt; on a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Por lo tanto, crea un nuevo &lt;strong&gt;recurso&lt;/strong&gt; en una &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaa5b7fc07bf5371832748f3289a7b2da4d980c" translate="yes" xml:space="preserve">
          <source>Here's a simple rule:</source>
          <target state="translated">Aquí hay una regla simple:</target>
        </trans-unit>
        <trans-unit id="8d27a8aff43735751da6f6d2d0ed6614a7eecf8a" translate="yes" xml:space="preserve">
          <source>I hope this helps any Microsoft developers that read all comments with Amazon and Sun/Java website links.</source>
          <target state="translated">Espero que esto ayude a cualquier desarrollador de Microsoft que lea todos los comentarios con los enlaces de los sitios web de Amazon y SunJava.</target>
        </trans-unit>
        <trans-unit id="5ca6bb95d20fb75f5f126fd38d614ae6b08d4b81" translate="yes" xml:space="preserve">
          <source>I interpret this, and the idempotency requirements on PUT, to mean that:</source>
          <target state="translated">Interpreto esto,y los requisitos de idempotencia en PUT,en el sentido de que:</target>
        </trans-unit>
        <trans-unit id="05235e2370ecb21ce9215b0f74750a3737456a63" translate="yes" xml:space="preserve">
          <source>I like this advice, from &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;RFC 2616's definition of PUT&lt;/a&gt;:</source>
          <target state="translated">Me gusta este consejo, de &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;la definici&amp;oacute;n de PUT&lt;/a&gt; del RFC 2616 :</target>
        </trans-unit>
        <trans-unit id="47aada42c69dd7c0210a4f1845e6ab606520fa95" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;PUT&lt;/code&gt; for Merge and update like operations and use &lt;code&gt;POST&lt;/code&gt; for Insertions.</source>
          <target state="translated">Uso &lt;code&gt;PUT&lt;/code&gt; for Merge y actualizo operaciones similares y uso &lt;code&gt;POST&lt;/code&gt; para inserciones.</target>
        </trans-unit>
        <trans-unit id="b527f56fb4de9ec139a67d896e81802d54cd82a0" translate="yes" xml:space="preserve">
          <source>I will describe the conventions which I think are most widely used and are most useful:</source>
          <target state="translated">Describiré las convenciones que creo que se usan más ampliamente y que son más útiles:</target>
        </trans-unit>
        <trans-unit id="f9c0500253b27e41a2e9e90178c365ce2423d509" translate="yes" xml:space="preserve">
          <source>I'd like to add my &quot;pragmatic&quot; advice.  Use PUT when you know the &quot;id&quot; by which the object you are saving can be retrieved.  Using PUT won't work too well if you need, say, a database generated id to be returned for you to do future lookups or updates.</source>
          <target state="translated">Me gustaría añadir mi consejo &quot;pragmático&quot;.Usa PUT cuando sepas el &quot;id&quot; por el cual el objeto que estás guardando puede ser recuperado.Usar PUT no funcionará muy bien si necesitas,digamos,un id generado por la base de datos para ser devuelto para que hagas futuras búsquedas o actualizaciones.</target>
        </trans-unit>
        <trans-unit id="66649e065e34c99642108c78cb23fe86c7332572" translate="yes" xml:space="preserve">
          <source>I'm going to land with the following:</source>
          <target state="translated">Voy a aterrizar con lo siguiente:</target>
        </trans-unit>
        <trans-unit id="dc85f0689c0d90da1345182eb8a915a8e4dd3c43" translate="yes" xml:space="preserve">
          <source>If the ID is generated (a new employee ID, for example), then the second PUT with the same URL would create a new record, which violates the idempotent rule. In this case the verb would be POST, and the message (not resource) would be to create a resource using the values defined in this message.</source>
          <target state="translated">Si se genera el ID (un nuevo ID de empleado,por ejemplo),entonces el segundo PUT con la misma URL crearía un nuevo registro,lo que viola la regla de idempotencia.En este caso el verbo sería POST,y el mensaje (no recurso)sería crear un recurso usando los valores definidos en este mensaje.</target>
        </trans-unit>
        <trans-unit id="e269e8bb2d1ae96b4945fea0fb22c28a23aa1d25" translate="yes" xml:space="preserve">
          <source>If the URL is not yet created, you
  should not be using POST to create it
  while specifying the name.  This should
  result in a 'resource not found' error
  because &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; does not exist
  yet.  You should PUT the &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt;
  resource on the server first.</source>
          <target state="translated">Si la URL a&amp;uacute;n no se ha creado, no debe usar POST para crearla mientras especifica el nombre. Esto deber&amp;iacute;a dar como resultado un error de &quot;recurso no encontrado&quot; porque &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; a&amp;uacute;n no existe. &lt;code&gt;&amp;lt;new_question&amp;gt;&lt;/code&gt; debe PONER el recurso &amp;lt;new_question&amp;gt; en el servidor.</target>
        </trans-unit>
        <trans-unit id="19c462827f591bd8bec6f3f537b7b39215387f40" translate="yes" xml:space="preserve">
          <source>If the result of processing a POST would be equivalent to a
  representation of an existing resource, an origin server MAY redirect
  the user agent to that resource by sending a 303 (See Other) response
  with the existing resource's identifier in the Location field.  This
  has the benefits of providing the user agent a resource identifier
  and transferring the representation via a method more amenable to
  shared caching, though at the cost of an extra request if the user
  agent does not already have the representation cached.</source>
          <target state="translated">Si el resultado del procesamiento de un POST sería equivalente a una representación de un recurso existente,un servidor de origen PUEDE redirigir el agente de usuario a ese recurso enviando una respuesta 303 (Véase Otros)con el identificador del recurso existente en el campo Ubicación.Esto tiene la ventaja de proporcionar al agente de usuario un identificador de recurso y de transferir la representación mediante un método más propicio para el almacenamiento en caché compartido,aunque a costa de una solicitud adicional si el agente de usuario no tiene ya la representación en caché.</target>
        </trans-unit>
        <trans-unit id="558a879fdfc95da4b234bea22b5e49ef57224b98" translate="yes" xml:space="preserve">
          <source>If you are familiar with database operations,
there are</source>
          <target state="translated">Si está familiarizado con las operaciones de la base de datos,hay</target>
        </trans-unit>
        <trans-unit id="1d065776051b8ea3a055903bde387f8a311a6be4" translate="yes" xml:space="preserve">
          <source>If you go on and try something like this:</source>
          <target state="translated">Si sigues adelante e intentas algo como esto:</target>
        </trans-unit>
        <trans-unit id="0c6f7e90f3ea30966fd463c77a5a98203c024433" translate="yes" xml:space="preserve">
          <source>If you happen to have auto generated  URI's on your resource you can still use PUT by passing a generated URI (pointing to an empty resource) to the client.</source>
          <target state="translated">Si por casualidad tienes URI autogeneradas en tu recurso puedes seguir usando PUT pasando una URI generada (apuntando a un recurso vacío)al cliente.</target>
        </trans-unit>
        <trans-unit id="cd5ae750e099166d34c0aea0fb9b4fadd772975a" translate="yes" xml:space="preserve">
          <source>If you have any doubts about how to implement REST in HTTP, you can always take a look at the &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Atom Publication Protocol (AtomPub)&lt;/a&gt; specification. AtomPub is a standard for writing RESTful webservices with HTTP that was developed by many HTTP and REST luminaries, with some input from Roy Fielding, the inventor of REST and (co-)inventor of HTTP himself.</source>
          <target state="translated">Si tiene dudas sobre c&amp;oacute;mo implementar REST en HTTP, siempre puede consultar la especificaci&amp;oacute;n del &lt;a href=&quot;https://www.ietf.org/rfc/rfc5023.txt&quot;&gt;Protocolo de publicaci&amp;oacute;n Atom (AtomPub)&lt;/a&gt; . AtomPub es un est&amp;aacute;ndar para escribir servicios web RESTful con HTTP que fue desarrollado por muchas luminarias HTTP y REST, con algunos aportes de Roy Fielding, el inventor de REST y (co) inventor del propio HTTP.</target>
        </trans-unit>
        <trans-unit id="ec654f9d869b9d4e7e967af9a0e460df87b82e2e" translate="yes" xml:space="preserve">
          <source>If you think you'll have huge amounts of data to store, let's talk volumes: a typical update confirmation is a fraction of a kilobyte. HTTP currently gives you a minute or two to respond definitively. Even if you only store actions for a week, clients have ample chance to catch up. If you have very high volumes, you may want a dedicated acid-compliant key value store, or an in-memory solution.</source>
          <target state="translated">Si crees que tendrás grandes cantidades de datos que almacenar,hablemos de volúmenes:una confirmación de actualización típica es una fracción de un kilobyte.El HTTP actualmente te da uno o dos minutos para responder definitivamente.Incluso si sólo almacenas acciones durante una semana,los clientes tienen muchas posibilidades de ponerse al día.Si tienes volúmenes muy altos,puedes querer un almacén de valor clave dedicado a los ácidos,o una solución en memoria.</target>
        </trans-unit>
        <trans-unit id="5e3f77bd7d922a0787f75fec577234f6dce48c77" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;POST&lt;/strong&gt; method you can send body params in &lt;code&gt;form-data&lt;/code&gt;</source>
          <target state="translated">En el m&amp;eacute;todo &lt;strong&gt;POST&lt;/strong&gt; , puede enviar par&amp;aacute;metros del cuerpo en &lt;code&gt;form-data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae084cc36a47a0ae5ba94fddaf0353c8961a476b" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PUT&lt;/strong&gt; method you have to send body params in &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</source>
          <target state="translated">En el m&amp;eacute;todo &lt;strong&gt;PUT&lt;/strong&gt; , debe enviar los par&amp;aacute;metros del cuerpo en &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9431cceefc51a270cdbc8ad21cfd20758abb6247" translate="yes" xml:space="preserve">
          <source>In REST, there's no such thing as a resource containing &quot;content&quot;. I refer as &quot;content&quot; to data that the service uses to render representations consistently. It typically consists of some related rows in a database or a file (e.g. an image file). It's up to the service to convert the user's content into something the service can use, e.g. converting a JSON payload into SQL statements.</source>
          <target state="translated">En REST,no hay tal cosa como un recurso que contenga &quot;contenido&quot;.Me refiero como &quot;contenido&quot; a los datos que el servicio utiliza para hacer representaciones consistentes.Suele consistir en algunas filas relacionadas en una base de datos o un archivo (por ejemplo,un archivo de imagen).Depende del servicio convertir el contenido del usuario en algo que el servicio pueda utilizar,por ejemplo,convertir una carga útil JSON en sentencias SQL.</target>
        </trans-unit>
        <trans-unit id="258ba4ae5c03cdfdac38fed39baa86957f31d85a" translate="yes" xml:space="preserve">
          <source>In a single line, use &lt;strong&gt;POST&lt;/strong&gt; to add &lt;strong&gt;a new entry&lt;/strong&gt; in the database and &lt;strong&gt;PUT&lt;/strong&gt; to &lt;strong&gt;update&lt;/strong&gt; something in the database.</source>
          <target state="translated">En una sola l&amp;iacute;nea, use &lt;strong&gt;POST&lt;/strong&gt; para agregar &lt;strong&gt;una nueva entrada&lt;/strong&gt; en la base de datos y &lt;strong&gt;PUT&lt;/strong&gt; para &lt;strong&gt;actualizar&lt;/strong&gt; algo en la base de datos.</target>
        </trans-unit>
        <trans-unit id="935d9d64a7b6c614a61126ee51efa95f2a005750" translate="yes" xml:space="preserve">
          <source>In a very simple way I'm taking the example of the Facebook timeline.</source>
          <target state="translated">De una manera muy simple estoy tomando el ejemplo de la línea de tiempo de Facebook.</target>
        </trans-unit>
        <trans-unit id="5796889f185413ae8caeb602438951b389d9b045" translate="yes" xml:space="preserve">
          <source>In addition to differences suggested by others, I want to add one more.</source>
          <target state="translated">Además de las diferencias sugeridas por otros,quiero añadir una más.</target>
        </trans-unit>
        <trans-unit id="d0a40d3ab4c006f0fd0242d76461457c6d244bfe" translate="yes" xml:space="preserve">
          <source>In both cases, the request body contains the data for the resource to be created or updated. It should be obvious from the route names that POST is not idempotent (if you call it 3 times it will create 3 objects), but PUT is idempotent (if you call it 3 times the result is the same). PUT is often used for &quot;upsert&quot; operation (create or update), but you can always return a 404 error if you only want to use it to modify.</source>
          <target state="translated">En ambos casos,el órgano de solicitud contiene los datos del recurso que se va a crear o actualizar.Debería ser obvio por los nombres de las rutas que POST no es idempotente (si lo llamas 3 veces creará 3 objetos),pero PUT es idempotente (si lo llamas 3 veces el resultado es el mismo).PUT se usa a menudo para la operación &quot;upsert&quot; (crear o actualizar),pero siempre puedes devolver un error 404 si sólo quieres usarlo para modificar.</target>
        </trans-unit>
        <trans-unit id="573cffeb2d758c1d002d1b38d8d410abd12cf26c" translate="yes" xml:space="preserve">
          <source>In both cases, these operations can be performed multiple times with the same results. That is the resource will not be changed by requesting the operation more than once. Hence, a true idempotent operation.
Use the HTTP POST method when:</source>
          <target state="translated">En ambos casos,estas operaciones pueden realizarse varias veces con los mismos resultados.Es decir,el recurso no se modificará solicitando la operación más de una vez.Por lo tanto,una verdadera operación idempática.Utilice el método HTTP POST cuando:</target>
        </trans-unit>
        <trans-unit id="cbfc88d28449849d5a03796a1b27b42013a1a384" translate="yes" xml:space="preserve">
          <source>In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an &quot;INSERT&quot; query.</source>
          <target state="translated">En el caso del POST,si la misma consulta se ejecuta varias veces,se crean múltiples registros de Estudiante en la base de datos y el estado de la base de datos cambia en cada ejecución de una consulta &quot;INSERTAR&quot;.</target>
        </trans-unit>
        <trans-unit id="315a82166f32c0e6bdbe44329b3f92d7b32440b4" translate="yes" xml:space="preserve">
          <source>In fact, you might even be able to use AtomPub directly. While it came out of the blogging community, it is in no way restricted to blogging: it is a generic protocol for RESTfully interacting with arbitrary (nested) collections of arbitrary resources via HTTP. If you can represent your application as a nested collection of resources, then you can just use AtomPub and not worry about whether to use PUT or POST, what HTTP Status Codes to return and all those details.</source>
          <target state="translated">De hecho,incluso podrías usar el AtomPub directamente.Aunque surgió de la comunidad de bloggers,no se limita de ninguna manera a los blogs:es un protocolo genérico para interactuar con colecciones arbitrarias (anidadas)de recursos arbitrarios a través de HTTP.Si puedes representar tu aplicación como una colección anidada de recursos,entonces puedes usar AtomPub y no preocuparte de si usar PUT o POST,qué códigos de estado HTTP devolver y todos esos detalles.</target>
        </trans-unit>
        <trans-unit id="4b6a091fc94c88da148a77392e516193f6f66982" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;POST&lt;/code&gt; is used to &lt;strong&gt;create&lt;/strong&gt;.</source>
          <target state="translated">En otras palabras, &lt;code&gt;POST&lt;/code&gt; se usa para &lt;strong&gt;crear&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfbe76fe288131ae25a4df6a695eb5ab43c9f7d" translate="yes" xml:space="preserve">
          <source>In practice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; that summarizes the best practices.</source>
          <target state="translated">En la pr&amp;aacute;ctica, POST funciona bien para crear recursos. La URL del recurso reci&amp;eacute;n creado debe devolverse en el encabezado de respuesta de Ubicaci&amp;oacute;n. PUT debe usarse para actualizar un recurso por completo. Por favor, comprenda que estas son las mejores pr&amp;aacute;cticas al dise&amp;ntilde;ar una API RESTful. La especificaci&amp;oacute;n HTTP como tal no restringe el uso de PUT / POST con algunas restricciones para crear / actualizar recursos. Eche un vistazo a &lt;a href=&quot;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&quot;&gt;http://techoctave.com/c7/posts/71-twitter-rest-api-dissected&lt;/a&gt; que resume las mejores pr&amp;aacute;cticas.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">En resumen:</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="f8f5b658f1ff8b04b3e81cc7e7976e9561692c82" translate="yes" xml:space="preserve">
          <source>It is true that the R(etrieve) and D(elete) of the CRUD operations can be mapped directly to the HTTP methods GET and DELETE respectively. However, the confusion lies in the C(reate) and U(update) operations. In some cases, one can use the PUT for a create while in other cases a POST will be required. The ambiguity lies in the definition of an HTTP PUT method versus an HTTP POST method.</source>
          <target state="translated">Es cierto que el R(etrieve)y el D(elete)de las operaciones CRUD pueden ser mapeadas directamente a los métodos HTTP GET y DELETE respectivamente.Sin embargo,la confusión radica en las operaciones C(reate)y U(update).En algunos casos,se puede utilizar el PUT para una creación mientras que en otros casos se requerirá un POST.La ambigüedad radica en la definición de un método HTTP PUT frente a un método HTTP POST.</target>
        </trans-unit>
        <trans-unit id="a419fc1de6f5fcd3ae809038b7b9a687efa1b1dd" translate="yes" xml:space="preserve">
          <source>It now may be tempting to simply return a 303 in the event that a POST is repeated. However, the opposite is true. Returning a 303 would only make sense if multiple create requests (creating different resources) return the same content. An example would be a &quot;thank you for submitting your request message&quot; that the client need not re-download each time. RFC 7231 still maintains in section 4.2.2 that POST is not to be idempotent and continues to maintain that POST should be used for create.</source>
          <target state="translated">Ahora puede ser tentador simplemente devolver un 303 en caso de que se repita un POST.Sin embargo,lo contrario es cierto.Devolver un 303 sólo tendría sentido si varias solicitudes de creación (creando diferentes recursos)devuelven el mismo contenido.Un ejemplo sería un &quot;gracias por enviar su mensaje de solicitud&quot; que el cliente no tenga que volver a descargar cada vez.El RFC 7231 sigue manteniendo en la sección 4.2.2 que el POST no debe ser idempotente y sigue manteniendo que el POST debe ser usado para crear.</target>
        </trans-unit>
        <trans-unit id="82a86d7eed2a55a644d7944a1404883b9ed82ac6" translate="yes" xml:space="preserve">
          <source>Let me highlight some important parts of the spec:</source>
          <target state="translated">Permítanme destacar algunas partes importantes de la especificación:</target>
        </trans-unit>
        <trans-unit id="27175fcbf0cac61488369580d1a39f1dc721a45f" translate="yes" xml:space="preserve">
          <source>Let's be very clear and direct here. If you are a .NET developer working with Web API, the facts are (from the Microsoft API documentation),
&lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&lt;/a&gt;:</source>
          <target state="translated">Seamos muy claros y directos aqu&amp;iacute;. Si usted es un desarrollador de .NET que trabaja con API web, los hechos son (de la documentaci&amp;oacute;n de la API de Microsoft), &lt;a href=&quot;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations&quot;&gt;http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web -api-that-soporta-crud-operations&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="857a3f4adc539ed4bbe21171ae40606e572a4ee6" translate="yes" xml:space="preserve">
          <source>Merge (Update if already existing, else insert)</source>
          <target state="translated">Fusionar (Actualizar si ya existe,si no,insertar)</target>
        </trans-unit>
        <trans-unit id="d6917a3435aea050d9a0d15a35f97af6e01858e4" translate="yes" xml:space="preserve">
          <source>Most of the time, you will use them like this:</source>
          <target state="translated">La mayoría de las veces,los usarás así:</target>
        </trans-unit>
        <trans-unit id="d61559b89b4cc3627f671076f6d46721d16134fc" translate="yes" xml:space="preserve">
          <source>Neither is quite right.</source>
          <target state="translated">Ninguno de los dos está bien.</target>
        </trans-unit>
        <trans-unit id="29c91aceaf4eab28f2f98e779bebb50691497adc" translate="yes" xml:space="preserve">
          <source>Note that POST &quot;creates&quot; a new element in the collection, and PUT &quot;replaces&quot; an element at a given URL, but it is a very common practice to use PUT for partial modifications, that is, use it only to update existing resources and only modify the included fields in the body (ignoring the other fields). This is technically incorrect, if you want to be REST-purist, PUT should replace the whole resource and you should use PATCH for the partial update. I personally don't care much as far as the behavior is clear and consistent across all your API endpoints.</source>
          <target state="translated">Nótese que POST &quot;crea&quot; un nuevo elemento en la colección,y PUT &quot;reemplaza&quot; un elemento en una URL determinada,pero es una práctica muy común utilizar PUT para modificaciones parciales,es decir,utilizarlo sólo para actualizar los recursos existentes y sólo modificar los campos incluidos en el cuerpo (ignorando los otros campos).Esto es técnicamente incorrecto,si quieres ser REST-purista,PUT debería reemplazar todo el recurso y deberías usar PATCH para la actualización parcial.Personalmente no me importa mucho si el comportamiento es claro y consistente en todos tus puntos finales de la API.</target>
        </trans-unit>
        <trans-unit id="aed489a86f6999b5a22f73530a241b671e75935e" translate="yes" xml:space="preserve">
          <source>Note that in this case the resource
  name is not specified, the new objects
  URL path would be returned to you.</source>
          <target state="translated">Tenga en cuenta que en este caso no se especifica el nombre del recurso,la ruta URL de los nuevos objetos le será devuelta.</target>
        </trans-unit>
        <trans-unit id="d0190e7f10880e789af039b6a119817ade48d5dc" translate="yes" xml:space="preserve">
          <source>Note that the following is an error:</source>
          <target state="translated">Tenga en cuenta que lo siguiente es un error:</target>
        </trans-unit>
        <trans-unit id="94ed497609bfa8317d3c8fed64915d395cd4506d" translate="yes" xml:space="preserve">
          <source>Note, however, that not all modern browsers support HTTP verbs other than GET or POST.</source>
          <target state="translated">Tenga en cuenta,sin embargo,que no todos los navegadores modernos soportan verbos HTTP aparte de GET o POST.</target>
        </trans-unit>
        <trans-unit id="3e324155fc5920c681ee3f3fe84a2ed08ebec851" translate="yes" xml:space="preserve">
          <source>Once you are using PUT you are refering to a &lt;strong&gt;resource&lt;/strong&gt; or single item, possibly inside a &lt;strong&gt;collection&lt;/strong&gt;. So when you say:</source>
          <target state="translated">Una vez que est&amp;aacute; utilizando PUT, se est&amp;aacute; refiriendo a un &lt;strong&gt;recurso&lt;/strong&gt; o elemento individual, posiblemente dentro de una &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; . Entonces cuando dices:</target>
        </trans-unit>
        <trans-unit id="c5516139d4acd3169adf148d2df83962379be2e8" translate="yes" xml:space="preserve">
          <source>Otherwise, use POST to initially create the object, and PUT to update the object:</source>
          <target state="translated">De lo contrario,use POST para crear inicialmente el objeto,y PUT para actualizar el objeto:</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="4413fe84411cbdf88cfc031d8a1393f608c4e15e" translate="yes" xml:space="preserve">
          <source>POST as send mail in &lt;strong&gt;post&lt;/strong&gt; office.</source>
          <target state="translated">PUBLICAR como enviar correo en la &lt;strong&gt;oficina de&lt;/strong&gt; correos.</target>
        </trans-unit>
        <trans-unit id="1e2c64ac62aa82754ed88cbebd18c452a61f35fc" translate="yes" xml:space="preserve">
          <source>POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing -- if you think about it, creating a new member of a collection is actually a special case of this kind of update, from the collection's perspective)</source>
          <target state="translated">El POST también puede ser usado para actualizaciones no impertinentes de objetos existentes (especialmente,cambiar una parte de un objeto sin especificar el conjunto-si lo piensas,crear un nuevo miembro de una colección es en realidad un caso especial de este tipo de actualización,desde la perspectiva de la colección)</target>
        </trans-unit>
        <trans-unit id="7199a1f38c458034e4e9122d80a96f6d399a16c7" translate="yes" xml:space="preserve">
          <source>POST can perform the other three functions, but then the semantics of the request will be lost on the intermediaries such as caches and proxies. This also applies to providing security on the resource, since a post's URI doesn't necessarily indicate the resource it is applying to (it can though).</source>
          <target state="translated">El POST puede realizar las otras tres funciones,pero entonces la semántica de la solicitud se perderá en los intermediarios como los cachés y los proxies.Esto también se aplica a la seguridad del recurso,ya que la URI de un puesto no indica necesariamente el recurso al que se está aplicando (aunque puede).</target>
        </trans-unit>
        <trans-unit id="a3841df602dc207eb894628e42ca39fa38600ef6" translate="yes" xml:space="preserve">
          <source>POST invalidates cached copies of the entire containing resource (better consistency)</source>
          <target state="translated">El POST invalida las copias en caché de todo el recurso de contención (mayor consistencia)</target>
        </trans-unit>
        <trans-unit id="c22f736aab2b2863938a628162d88b4124790887" translate="yes" xml:space="preserve">
          <source>POST is basically a free form message, with its meaning being defined 'out of band'. If the message can be interpreted as adding a resource to a directory, that would be OK, but basically you need to understand the message you are sending (posting) to know what will happen with the resource.</source>
          <target state="translated">El POST es básicamente un mensaje de forma libre,cuyo significado se define como &quot;fuera de banda&quot;.Si el mensaje puede ser interpretado como la adición de un recurso a un directorio,eso estaría bien,pero básicamente necesitas entender el mensaje que estás enviando (posting)para saber qué pasará con el recurso.</target>
        </trans-unit>
        <trans-unit id="50e5624274970285a79a86def7e5f8ea14309ec5" translate="yes" xml:space="preserve">
          <source>POST is good for creating new objects under a collection (and create does not need to be idempotent)</source>
          <target state="translated">El POST es bueno para crear nuevos objetos bajo una colección (y no es necesario que la creación sea idempática)</target>
        </trans-unit>
        <trans-unit id="a4348a436cd7cc96fdb0094e0c165b3beab9d039" translate="yes" xml:space="preserve">
          <source>POST is like posting a letter to a mailbox or posting an email to an email queue.
PUT is like when you put an object in a cubby hole or a place on a shelf (it has a known address).</source>
          <target state="translated">POST es como enviar una carta a un buzón de correo o enviar un correo electrónico a una cola de correo electrónico.PUT es como cuando pones un objeto en un cubículo o en un lugar de un estante (tiene una dirección conocida).</target>
        </trans-unit>
        <trans-unit id="4db2a3f164214c5ab6b6162614daef8028ccda38" translate="yes" xml:space="preserve">
          <source>POST is not idempotent and the server &amp;hellip;</source>
          <target state="translated">POST no es idempotente y el servidor ...</target>
        </trans-unit>
        <trans-unit id="6bf075a0e5bf009d906f75d40d6c584b360d7cb7" translate="yes" xml:space="preserve">
          <source>POST is used to send data to server.</source>
          <target state="translated">El POST se utiliza para enviar datos al servidor.</target>
        </trans-unit>
        <trans-unit id="f6c4170f0e615f9fa2848d48db2ab50f375369c3" translate="yes" xml:space="preserve">
          <source>POST:</source>
          <target state="translated">POST:</target>
        </trans-unit>
        <trans-unit id="d18f4e998d15f0ab1bd153b920ca0c74bdfeff78" translate="yes" xml:space="preserve">
          <source>POSTing twice with the same data means create two identical users with different ids. PUTing twice with the same data creates the user the first and updates him to the same state the second time (no changes). Since you end up with the same state after a &lt;code&gt;PUT&lt;/code&gt; no matter how many times you perform it, it is said to be &quot;equally potent&quot; every time - idempotent. This is useful for automatically retrying requests. No more 'are you sure you want to resend' when you push the back button on the browser.</source>
          <target state="translated">PUBLICAR dos veces con los mismos datos significa crear dos usuarios id&amp;eacute;nticos con diferentes identificadores. PONER dos veces con los mismos datos crea al usuario el primero y lo actualiza al mismo estado la segunda vez (sin cambios). Como terminas con el mismo estado despu&amp;eacute;s de un &lt;code&gt;PUT&lt;/code&gt; , no importa cu&amp;aacute;ntas veces lo realices, se dice que es &quot;igualmente potente&quot; cada vez, idempotente. Esto es &amp;uacute;til para volver a intentar autom&amp;aacute;ticamente las solicitudes. No m&amp;aacute;s '&amp;iquest;est&amp;aacute;s seguro de que deseas reenviar' cuando presionas el bot&amp;oacute;n Atr&amp;aacute;s en el navegador?</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="0774c3d8f11a1777d7cca86a15dfce5e923b8427" translate="yes" xml:space="preserve">
          <source>PUT can also be used for create if and only if you allow the client to name the resource. But since REST clients aren't supposed to make assumptions about URL structure, this is less in the intended spirit of things.</source>
          <target state="translated">El PUT también puede ser usado para crear si y solo si permites al cliente nombrar el recurso.Pero como se supone que los clientes de REST no deben hacer suposiciones sobre la estructura de la URL,esto es menos en el espíritu de las cosas.</target>
        </trans-unit>
        <trans-unit id="53edc2f185fb0dcf741606243cd7f49687d0ba85" translate="yes" xml:space="preserve">
          <source>PUT i.e. take and &lt;strong&gt;put&lt;/strong&gt; where it was.</source>
          <target state="translated">PONER, es decir, tomar y &lt;strong&gt;poner&lt;/strong&gt; donde estaba.</target>
        </trans-unit>
        <trans-unit id="d17262b9924f1628e9bc6d1ceface83dc9e20080" translate="yes" xml:space="preserve">
          <source>PUT is good for updating existing objects (and update needs to be idempotent)</source>
          <target state="translated">PUT es bueno para actualizar los objetos existentes (y la actualización debe ser idempotente)</target>
        </trans-unit>
        <trans-unit id="2528780fd61687817cc4d77380ca20d9c55d5327" translate="yes" xml:space="preserve">
          <source>PUT is idempotent, so if you PUT an object twice, it has no effect.  This is a nice property, so I would use PUT when possible.</source>
          <target state="translated">PUT es idempotente,así que si PUT un objeto dos veces,no tiene ningún efecto.Esta es una buena propiedad,así que usaría PUT cuando fuera posible.</target>
        </trans-unit>
        <trans-unit id="f54bdf6757feb089a4b6dd6043ed5a3812f4c969" translate="yes" xml:space="preserve">
          <source>PUT is idempotent. You can send the request 100 times and it will not matter. POST is not idempotent. If you send the request 100 times, you'll get 100 emails or 100 letters in your postal box.</source>
          <target state="translated">PUT es idempotente.Puedes enviar la solicitud 100 veces y no importará.POST no es idempotente.Si envías la solicitud 100 veces,recibirás 100 correos electrónicos o 100 cartas en tu buzón.</target>
        </trans-unit>
        <trans-unit id="7a94e837da966e20c0283efdebc7e6e8c4792dd1" translate="yes" xml:space="preserve">
          <source>PUT is less supported by e.g. Java ME, older browsers, firewalls</source>
          <target state="translated">PUT está menos soportado por ej.Java ME,navegadores antiguos,cortafuegos</target>
        </trans-unit>
        <trans-unit id="beb21b8c66904ea993c9a6028ecf712630358d0d" translate="yes" xml:space="preserve">
          <source>PUT is merely a statement of what content the service should, from now on, use to render representations of the resource identified by the client; POST is a statement of what content the service should, from now on, contain (possibly duplicated) but it's up to the server how to identify that content.</source>
          <target state="translated">PUT es simplemente una declaración del contenido que el servicio debe,de ahora en adelante,utilizar para hacer representaciones del recurso identificado por el cliente;POST es una declaración del contenido que el servicio debe,de ahora en adelante,contener (posiblemente duplicado)pero depende del servidor cómo identificar ese contenido.</target>
        </trans-unit>
        <trans-unit id="481e4b9e200d5c2fea82c751622373a2b6a00819" translate="yes" xml:space="preserve">
          <source>PUT is used to transfer state to the server</source>
          <target state="translated">PUT se utiliza para transferir el estado al servidor</target>
        </trans-unit>
        <trans-unit id="bad5201391f46977a9f8deb44fc372a5bc244a21" translate="yes" xml:space="preserve">
          <source>PUT refers to a resource, identified by the URI. In this case, you are updating it. It is the part of the three verbs referring to resources -- delete and get being the other two.</source>
          <target state="translated">PUT se refiere a un recurso,identificado por el URI.En este caso,lo está actualizando.Es la parte de los tres verbos que se refieren a los recursos --borrar y obtener siendo los otros dos.</target>
        </trans-unit>
        <trans-unit id="d444f457d29e103ad92323fcf2afb2424bd83004" translate="yes" xml:space="preserve">
          <source>PUT responses are not cacheable while POST ones are (Require Content-Location and expiration)</source>
          <target state="translated">Las respuestas PUT no son almacenables en caché,mientras que las POST sí lo son (requieren localización y expiración del contenido)</target>
        </trans-unit>
        <trans-unit id="15640c28b6c6596379e40a0e541c4b7183207d73" translate="yes" xml:space="preserve">
          <source>PUT vs. POST in REST</source>
          <target state="translated">PUT vs.POST en REPOSO</target>
        </trans-unit>
        <trans-unit id="ecd7c4f13506fe5521c5fe5e1b3db337ba4711ed" translate="yes" xml:space="preserve">
          <source>PUT:</source>
          <target state="translated">PUT:</target>
        </trans-unit>
        <trans-unit id="ecbeb70dff39883fdc79bab75f4eab0476369bf3" translate="yes" xml:space="preserve">
          <source>Performing a POST of data which has an ID which matches a resource already in the system is &amp;ldquo;a conflict with the current state of the resource.&amp;rdquo;</source>
          <target state="translated">Realizar una POST de datos que tiene una ID que coincide con un recurso que ya est&amp;aacute; en el sistema es &quot;un conflicto con el estado actual del recurso&quot;.</target>
        </trans-unit>
        <trans-unit id="55c27430d43b1ad1ac779b51ba33aaaa16817d5a" translate="yes" xml:space="preserve">
          <source>Prior to PUT, clients couldn't directly know the URL that the server generated or if all it had generated any or whether the data to be sent to the server is already updated or not. PUT relieved the developer of all these headaches. PUT is idempotent, PUT handles race conditions, and PUT lets the client choose the URL.</source>
          <target state="translated">Antes del PUT,los clientes no podían saber directamente la URL que el servidor generaba o si todo lo que había generado ya estaba actualizado o no.PUT alivió al desarrollador de todos estos dolores de cabeza.PUT es idempotente,PUT maneja las condiciones de la carrera,y PUT permite al cliente elegir la URL.</target>
        </trans-unit>
        <trans-unit id="500abc23a1f880a1d70f33cc1a5912ba903fcf59" translate="yes" xml:space="preserve">
          <source>REST is a &lt;em&gt;very&lt;/em&gt; high-level concept. In fact, it doesn't even mention HTTP at all!</source>
          <target state="translated">REST es un concepto de &lt;em&gt;muy&lt;/em&gt; alto nivel. De hecho, &amp;iexcl;ni siquiera menciona HTTP en absoluto!</target>
        </trans-unit>
        <trans-unit id="f3f878fdda60ba178358813e7e7547df7ca8bed3" translate="yes" xml:space="preserve">
          <source>RFC 5789 says about PATCH (since 1995):</source>
          <target state="translated">RFC 5789 dice sobre PATCH (desde 1995):</target>
        </trans-unit>
        <trans-unit id="2240960be744587b090255e994fafdd819cc51d2" translate="yes" xml:space="preserve">
          <source>Readers new to this topic will be struck by the endless discussion about what you &lt;em&gt;should&lt;/em&gt; do, and the relative absence of lessons from experience. The fact that REST is &quot;preferred&quot; over SOAP is, I suppose, a high-level learning from experience, but goodness we must have progressed from there? It's 2016. Roy's dissertation was in 2000. What have we developed? Was it fun? Was it easy to integrate with? To support? Will it handle the rise of smartphones and flaky mobile connections?</source>
          <target state="translated">Los lectores nuevos en este tema se sorprender&amp;aacute;n con la discusi&amp;oacute;n interminable sobre lo que &lt;em&gt;debe&lt;/em&gt; hacer y la relativa ausencia de lecciones de la experiencia. El hecho de que REST sea &quot;preferido&quot; sobre SOAP es, supongo, un aprendizaje de alto nivel de la experiencia, pero &amp;iquest;Dios debe haber progresado desde all&amp;iacute;? Es 2016. La disertaci&amp;oacute;n de Roy fue en 2000. &amp;iquest;Qu&amp;eacute; hemos desarrollado? &amp;iquest;Fue divertido? &amp;iquest;Fue f&amp;aacute;cil integrarse? &amp;iquest;Apoyar? &amp;iquest;Manejar&amp;aacute; el auge de los tel&amp;eacute;fonos inteligentes y las conexiones m&amp;oacute;viles inestables?</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="af48dc320f6330ed03797587a11eef43f0ec6f79" translate="yes" xml:space="preserve">
          <source>Remember, REST is a set of conventions and guidelines to keep your API simple. If you end up with a complicated work-around just to check the &quot;RESTfull&quot; box then you are defeating the purpose ;)</source>
          <target state="translated">Recuerde,REST es un conjunto de convenciones y pautas para mantener su API simple.Si terminas con un trabajo complicado sólo por marcar la casilla &quot;RESTfull&quot; entonces estás derrotando el propósito ;)</target>
        </trans-unit>
        <trans-unit id="ee7cc50d6752f70e6ef133296cf031acbf88d94d" translate="yes" xml:space="preserve">
          <source>Ruby on Rails 4.0 will use the 'PATCH' method instead of PUT to do partial updates.</source>
          <target state="translated">Ruby on Rails 4.0 usará el método 'PATCH' en lugar de PUT para hacer actualizaciones parciales.</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="e1a55a92c976da44c042e91aaa4d8b45fd7ebc14" translate="yes" xml:space="preserve">
          <source>Simple rule of thumb: Use POST to create, use PUT to update.</source>
          <target state="translated">Una simple regla de oro:Usa POST para crear,usa PUT para actualizar.</target>
        </trans-unit>
        <trans-unit id="563433492d9997914d4d5639b5bd77063df84eaa" translate="yes" xml:space="preserve">
          <source>Since the important part is for the client to understand the server has the resource and to take appropriate action. This is a &amp;ldquo;situation(s) where it is expected that the user might be able to resolve the conflict and resubmit the request.&amp;rdquo;</source>
          <target state="translated">Dado que la parte importante es que el cliente comprenda que el servidor tiene el recurso y que tome las medidas adecuadas. Esta es una &quot;situaci&amp;oacute;n (es) donde se espera que el usuario pueda resolver el conflicto y volver a enviar la solicitud&quot;.</target>
        </trans-unit>
        <trans-unit id="214742f8ecec0788b74789ec5780c31fcabbb394" translate="yes" xml:space="preserve">
          <source>So you use POST and probably, but not necessary PUT for resource creation. You don't have to support both. For me POST is perfectly enough. So it is a design decision.</source>
          <target state="translated">Así que usas el POST y probablemente,pero no el PUT necesario para la creación de recursos.No tienes que apoyar ambas cosas.Para mí el POST es perfectamente suficiente.Así que es una decisión de diseño.</target>
        </trans-unit>
        <trans-unit id="312dad788b38db2f97ab20722cebe3f87855dfa4" translate="yes" xml:space="preserve">
          <source>So, which one should be used to create a resource? Or one needs to support both?</source>
          <target state="translated">Entonces,¿cuál debería usarse para crear un recurso? ¿O uno necesita apoyar a ambos?</target>
        </trans-unit>
        <trans-unit id="af333de22f5db2954bfe57966628566c2cb3ee43" translate="yes" xml:space="preserve">
          <source>So: To save an existing user, or one where the client generates the id and it's been verified that the id is unique:</source>
          <target state="translated">Así que..:Para salvar un usuario existente,o uno donde el cliente genera el id y se ha verificado que el id es único:</target>
        </trans-unit>
        <trans-unit id="a8710dbdab40fac5c2f6093ab0a397321add575c" translate="yes" xml:space="preserve">
          <source>Social Media/Network Analogy:</source>
          <target state="translated">Analogía de redes sociales:</target>
        </trans-unit>
        <trans-unit id="aa6e7d148420cbd536359dd8922d3a773a333631" translate="yes" xml:space="preserve">
          <source>Some considerations:</source>
          <target state="translated">Algunas consideraciones:</target>
        </trans-unit>
        <trans-unit id="f07350c10b92f7bbca1cebbb0c1aaadbf6301a75" translate="yes" xml:space="preserve">
          <source>Some other considerations:</source>
          <target state="translated">Algunas otras consideraciones:</target>
        </trans-unit>
        <trans-unit id="1392b1cbf3bb0fbae1580de51f28c0eb49cc1f97" translate="yes" xml:space="preserve">
          <source>Spec:</source>
          <target state="translated">Spec:</target>
        </trans-unit>
        <trans-unit id="9d63a661c96623ad056cc93701a94dbcd5290eef" translate="yes" xml:space="preserve">
          <source>Step 6 is where people commonly get confused about what to do. However, there is no reason to create a kludge to solve this issue. Instead, HTTP can be used as specified in &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616&lt;/a&gt; and the server replies:</source>
          <target state="translated">El paso 6 es donde las personas com&amp;uacute;nmente se confunden acerca de qu&amp;eacute; hacer. Sin embargo, no hay ninguna raz&amp;oacute;n para crear un error para resolver este problema. En cambio, HTTP se puede usar como se especifica en &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10&quot;&gt;RFC 2616&lt;/a&gt; y el servidor responde:</target>
        </trans-unit>
        <trans-unit id="b49764080a9692f4a67935d54ce3bb45209b490c" translate="yes" xml:space="preserve">
          <source>Student Id is auto generated.</source>
          <target state="translated">La identificación de estudiante se genera automáticamente.</target>
        </trans-unit>
        <trans-unit id="aca4c099b5e77d0411d947634e38f0631bf9e86a" translate="yes" xml:space="preserve">
          <source>Successive delete requests can see and process the original confirmation, without hitting a 404 error. If things take longer than expected, we can respond provisionally, and we have a place where the client can check back for the definitive result. The nicest part of this pattern is its Kung-Fu (Panda) property. We take a weakness, the propensity for clients to repeat a request any time they don't understand the response, and turn it into &lt;em&gt;a strength&lt;/em&gt; :-)</source>
          <target state="translated">Las solicitudes de eliminaci&amp;oacute;n sucesivas pueden ver y procesar la confirmaci&amp;oacute;n original, sin dar con un error 404. Si las cosas tardan m&amp;aacute;s de lo esperado, podemos responder provisionalmente, y tenemos un lugar donde el cliente puede verificar el resultado definitivo. La mejor parte de este patr&amp;oacute;n es su propiedad Kung-Fu (Panda). Tomamos una debilidad, la propensi&amp;oacute;n a que los clientes repitan una solicitud cada vez que no entienden la respuesta, y la convertimos en &lt;em&gt;una fortaleza&lt;/em&gt; :-)</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="b9802a34f75ab08b9f79a147b7c88bf20e2dd462" translate="yes" xml:space="preserve">
          <source>Sure you &quot;can&quot; use &quot;POST&quot; to update, but just follow the conventions laid out for you with your given framework. In my case it is .NET / Web API, so &lt;strong&gt;PUT is for UPDATE&lt;/strong&gt; there is no debate.</source>
          <target state="translated">Seguro que &quot;puede&quot; usar &quot;POST&quot; para actualizar, pero solo siga las convenciones establecidas para usted con su marco dado. En mi caso es .NET / Web API, por lo que &lt;strong&gt;PUT es para ACTUALIZAR&lt;/strong&gt; no hay debate.</target>
        </trans-unit>
        <trans-unit id="88f36ec6e839653d0f7569117f42e1085634abaa" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;PUT&lt;/code&gt; is used to &lt;strong&gt;create or update&lt;/strong&gt;.</source>
          <target state="translated">Es decir, &lt;code&gt;PUT&lt;/code&gt; se usa para &lt;strong&gt;crear o actualizar&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6228527a9fe538603ee8860a20980509cae0390f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/strong&gt; method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the &lt;code&gt;Request-URI&lt;/code&gt; in the &lt;code&gt;Request-Line&lt;/code&gt;</source>
          <target state="translated">El m&amp;eacute;todo &lt;strong&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/strong&gt; se utiliza para solicitar que el servidor de origen acepte la entidad incluida en la solicitud como un nuevo subordinado del recurso identificado por el &lt;code&gt;Request-URI&lt;/code&gt; de &lt;code&gt;Request-Line&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf25e1a44ff44b0b030b51303b10b2f4e6c0844" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/strong&gt; method requests that the enclosed entity be stored under the supplied &lt;code&gt;Request-URI&lt;/code&gt;. If the &lt;code&gt;Request-URI&lt;/code&gt; refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the &lt;code&gt;Request-URI&lt;/code&gt; does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.&quot;</source>
          <target state="translated">El m&amp;eacute;todo &lt;strong&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/strong&gt; solicita que la entidad incluida se almacene bajo el &lt;code&gt;Request-URI&lt;/code&gt; proporcionado. Si el &lt;code&gt;Request-URI&lt;/code&gt; refiere a un recurso ya existente, la entidad adjunta DEBE considerarse como una versi&amp;oacute;n modificada de la que reside en el servidor de origen. Si el &lt;code&gt;Request-URI&lt;/code&gt; no apunta a un recurso existente y el agente de usuario solicitante puede definir ese URI como un nuevo recurso, el servidor de origen puede crear el recurso con ese URI &quot;.</target>
        </trans-unit>
        <trans-unit id="59c1ac24b7aebd8b407e3f0c9ff99488ea7968e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;POST&lt;/strong&gt; method is used to request that the origin server &lt;strong&gt;accept&lt;/strong&gt; the entity enclosed in the request as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; subordinate&lt;/strong&gt; of the resource identified by the Request-URI in the Request-Line</source>
          <target state="translated">El m&amp;eacute;todo &lt;strong&gt;POST&lt;/strong&gt; se utiliza para solicitar que el servidor de origen &lt;strong&gt;acepte&lt;/strong&gt; la entidad incluida en la solicitud como un &lt;strong&gt;&lt;em&gt;nuevo&lt;/em&gt; subordinado&lt;/strong&gt; del recurso identificado por el URI de solicitud en la l&amp;iacute;nea de solicitud</target>
        </trans-unit>
        <trans-unit id="c563bf37c1b157d8576106b8f94786d60d4a88a8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;PUT&lt;/strong&gt; method requests that the enclosed entity be &lt;strong&gt;stored&lt;/strong&gt; under the supplied Request-URI. If the Request-URI refers to an &lt;strong&gt;already existing&lt;/strong&gt; resource, the enclosed entity SHOULD be considered as a &lt;strong&gt;modified version&lt;/strong&gt; of the one residing on the origin server. If the Request-URI does &lt;strong&gt;not point to an existing&lt;/strong&gt; resource, and that URI is &lt;strong&gt;capable&lt;/strong&gt; of being defined as a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt; resource&lt;/strong&gt; by the requesting user agent, the origin server can &lt;strong&gt;create&lt;/strong&gt; the resource with that URI.&quot;</source>
          <target state="translated">El m&amp;eacute;todo &lt;strong&gt;PUT&lt;/strong&gt; solicita que la entidad incluida se &lt;strong&gt;almacene&lt;/strong&gt; bajo el URI de solicitud proporcionado. Si el URI de solicitud se refiere a un recurso &lt;strong&gt;ya existente&lt;/strong&gt; , la entidad adjunta DEBE considerarse como una &lt;strong&gt;versi&amp;oacute;n modificada&lt;/strong&gt; de la que reside en el servidor de origen. Si el URI de solicitud &lt;strong&gt;no apunta a un&lt;/strong&gt; recurso &lt;strong&gt;existente&lt;/strong&gt; y el agente de usuario solicitante puede definir ese URI como un &lt;strong&gt;&lt;em&gt;nuevo&lt;/em&gt; recurso&lt;/strong&gt; , el servidor de origen puede &lt;strong&gt;crear&lt;/strong&gt; el recurso con ese URI &quot;.</target>
        </trans-unit>
        <trans-unit id="59fcd39418146017bc9d79b2463c3bd0da6fb592" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
    &lt;code&gt;created&lt;/code&gt; or &lt;code&gt;replaced&lt;/code&gt; with the state defined by the representation
    enclosed in the request message payload.</source>
          <target state="translated">El m&amp;eacute;todo PUT solicita que el estado del recurso de destino se &lt;code&gt;created&lt;/code&gt; o &lt;code&gt;replaced&lt;/code&gt; con el estado definido por la representaci&amp;oacute;n incluida en la carga &amp;uacute;til del mensaje de solicitud.</target>
        </trans-unit>
        <trans-unit id="e77dcb77c2b94fc15160e4b361047201bc47a791" translate="yes" xml:space="preserve">
          <source>The RFC reads like this:</source>
          <target state="translated">El RFC se lee así:</target>
        </trans-unit>
        <trans-unit id="2bf09923cd40e9a4020e710d08ab29ff70e0f921" translate="yes" xml:space="preserve">
          <source>The client POST a new resource to the server.</source>
          <target state="translated">El cliente envía un nuevo recurso al servidor.</target>
        </trans-unit>
        <trans-unit id="6d21b96b8e9dc8ceda9663e50081fd866f4a8784" translate="yes" xml:space="preserve">
          <source>The client does not have a URL for the resource (therefore PUT is not an option) and repeats the POST.</source>
          <target state="translated">El cliente no tiene una URL para el recurso (por lo tanto el PUT no es una opción)y repite el POST.</target>
        </trans-unit>
        <trans-unit id="dab9c53b7a8f4efbb9c76b8f8b0c3647ff5ea29b" translate="yes" xml:space="preserve">
          <source>The client never receives the response.</source>
          <target state="translated">El cliente nunca recibe la respuesta.</target>
        </trans-unit>
        <trans-unit id="7e77aa23ca0f2f2521e9d88d6afd4e68b94dfbe8" translate="yes" xml:space="preserve">
          <source>The content type &quot;application/x-www-form-urlencoded&quot; is inefficient
  for sending large quantities of binary data or text containing
  non-ASCII characters. The content type &quot;multipart/form-data&quot; should be
  used for submitting forms that contain files, non-ASCII data, and
  binary data.</source>
          <target state="translated">El tipo de contenido &quot;applicationx-www-form-urlencoded&quot; es ineficiente para enviar grandes cantidades de datos binarios o texto que contienen caracteres no ASCII.El tipo de contenido &quot;multipartform-data&quot; debe utilizarse para enviar formularios que contengan archivos,datos no ASCII y datos binarios.</target>
        </trans-unit>
        <trans-unit id="c00e08de50ba7cbbdbcec8cf8cc194d4e2c70887" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</source>
          <target state="translated">La diferencia fundamental entre las solicitudes POST y PUT se refleja en el diferente significado de la solicitud-URI.La URI en una solicitud POST identifica el recurso que se encargará de la entidad adjunta.Ese recurso puede ser un proceso de aceptación de datos,una puerta de entrada a algún otro protocolo o una entidad separada que acepta anotaciones.Por el contrario,la URI en una solicitud PUT identifica la entidad incluida en la solicitud --el agente de usuario sabe qué URI está destinada y el servidor NO DEBE intentar aplicar la solicitud a algún otro recurso.</target>
        </trans-unit>
        <trans-unit id="531d093617728697be6cb081a0052d11e9261dcc" translate="yes" xml:space="preserve">
          <source>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,</source>
          <target state="translated">La diferencia fundamental entre las solicitudes POST y PUT se refleja en el diferente significado de la solicitud-URI.La URI en una solicitud POST identifica el recurso que se encargará de la entidad adjunta.Ese recurso puede ser un proceso de aceptación de datos,una puerta de entrada a algún otro protocolo o una entidad separada que acepta anotaciones.Por el contrario,la URI en una solicitud PUT identifica la entidad incluida en la solicitud --el agente de usuario sabe qué URI está destinada y el servidor NO DEBE intentar aplicar la solicitud a algún otro recurso.Si el servidor desea que la solicitud se aplique a una URI diferente,</target>
        </trans-unit>
        <trans-unit id="9a92f77699786e960e9bee1d8eacf143a2e57922" translate="yes" xml:space="preserve">
          <source>The idea of a &lt;em&gt;RESTful-URL&lt;/em&gt; is actually a violation of REST as the server is in charge of the URL structure and should be free to decide how to use it to avoid coupling. If this confuses you read about the significance of self discovery on API design.</source>
          <target state="translated">La idea de una &lt;em&gt;URL RESTful&lt;/em&gt; es en realidad una violaci&amp;oacute;n de REST ya que el servidor est&amp;aacute; a cargo de la estructura de la URL y debe ser libre de decidir c&amp;oacute;mo usarla para evitar el acoplamiento. Si esto le confunde, lea acerca de la importancia del autodescubrimiento en el dise&amp;ntilde;o de API.</target>
        </trans-unit>
        <trans-unit id="08c88ada7f30da94a298cf8074dd8cb30fa5608e" translate="yes" xml:space="preserve">
          <source>The most important consideration is &lt;em&gt;reliability&lt;/em&gt;. If a POST message gets lost the state of the system is undefined. Automatic recovery is impossible. For PUT messages, the state is undefined only until the first successful retry.</source>
          <target state="translated">La consideraci&amp;oacute;n m&amp;aacute;s importante es la &lt;em&gt;fiabilidad&lt;/em&gt; . Si se pierde un mensaje POST, el estado del sistema no est&amp;aacute; definido. La recuperaci&amp;oacute;n autom&amp;aacute;tica es imposible. Para los mensajes PUT, el estado no est&amp;aacute; definido hasta el primer intento exitoso.</target>
        </trans-unit>
        <trans-unit id="70a1801f56d9e3b89398dd57a765b43ab4ffd957" translate="yes" xml:space="preserve">
          <source>The relevant specification for PUT and POST is &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</source>
          <target state="translated">La especificaci&amp;oacute;n relevante para PUT y POST es &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;RFC 2616 &amp;sect;9.5ff.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5212416a9c7e401d69b6999879d0f06d6e6c6b8f" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
  state of the resource. This code is only allowed in situations where
  it is expected that the user might be able to resolve the conflict and
  resubmit the request. The response body SHOULD include enough</source>
          <target state="translated">La solicitud no pudo completarse debido a un conflicto con el estado actual del recurso.Este código sólo se permite en situaciones en las que se espera que el usuario pueda resolver el conflicto y volver a presentar la solicitud.El cuerpo de respuesta DEBE incluir suficiente</target>
        </trans-unit>
        <trans-unit id="d5fcf6a88ce59329f97adb1fc601b9b08db15db3" translate="yes" xml:space="preserve">
          <source>The semantics are supposed be different, in that &quot;PUT&quot;, like &quot;GET&quot; is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.</source>
          <target state="translated">La semántica se supone que es diferente,en que &quot;PUT&quot;,al igual que &quot;GET&quot; se supone que es idempotente-es decir,puedes hacer la misma petición de PUT varias veces y el resultado será como si la ejecutaras una sola vez.</target>
        </trans-unit>
        <trans-unit id="6497cf669dc224da5094578e5e54fa6ced3cdbc7" translate="yes" xml:space="preserve">
          <source>The server does the business, returns the response &lt;em&gt;and stores it against the agreed action URI&lt;/em&gt;. If anything goes wrong, the client repeats the request (natural behaviour!), and if the server has already seen it, it repeats the stored response &lt;em&gt;and does nothing else&lt;/em&gt;.</source>
          <target state="translated">El servidor hace el negocio, devuelve la respuesta &lt;em&gt;y la almacena contra el URI de acci&amp;oacute;n acordado&lt;/em&gt; . Si algo sale mal, el cliente repite la solicitud (&amp;iexcl;comportamiento natural!), Y si el servidor ya lo ha visto, repite la respuesta almacenada &lt;em&gt;y no hace nada m&amp;aacute;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5da1be1c708bb16e849af08a7fb0aa8d0d4c1309" translate="yes" xml:space="preserve">
          <source>The server is unaware the client has not received the response.</source>
          <target state="translated">El servidor no sabe que el cliente no ha recibido la respuesta.</target>
        </trans-unit>
        <trans-unit id="62a97e57f72e643adc7cc713734b78e46c053ea2" translate="yes" xml:space="preserve">
          <source>The server processes the request and sends a response.</source>
          <target state="translated">El servidor procesa la solicitud y envía una respuesta.</target>
        </trans-unit>
        <trans-unit id="ad17da286154778c13914cd41e9cf66091180592" translate="yes" xml:space="preserve">
          <source>There seems to always be some confusion as to when to use the HTTP POST versus the HTTP PUT method for REST services. Most developers will try to associate CRUD operations directly to HTTP methods. I will argue that this is not correct and one can not simply associate the CRUD concepts to the HTTP methods. That is:</source>
          <target state="translated">Parece que siempre hay cierta confusión en cuanto a cuándo usar el método HTTP POST frente al HTTP PUT para los servicios REST.La mayoría de los desarrolladores tratarán de asociar las operaciones CRUD directamente a los métodos HTTP.Argumentaré que esto no es correcto y que no se puede simplemente asociar los conceptos CRUD a los métodos HTTP.Es decir:</target>
        </trans-unit>
        <trans-unit id="7612d7c41fbfbe6d8a2310c67de97a21fbe00850" translate="yes" xml:space="preserve">
          <source>Therefore: &lt;strong&gt;PUT&lt;/strong&gt; is only a candidate for CREATE where the client already knows the url before the resource is created. Eg. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; as the title is used as the resource key</source>
          <target state="translated">Por lo tanto: &lt;strong&gt;PUT&lt;/strong&gt; es solo un candidato para CREATE donde el cliente ya conoce la URL antes de que se cree el recurso. P.ej. &lt;code&gt;/blogs/nigel/entry/when_to_use_post_vs_put&lt;/code&gt; ya que el t&amp;iacute;tulo se usa como clave de recurso</target>
        </trans-unit>
        <trans-unit id="ea0f8ddfd30845a4b1c6a9e4d8ca5de38b2ab4ea" translate="yes" xml:space="preserve">
          <source>This forces the API to avoid state transition problems with multiple clients updating a single resource, and matches more nicely with event sourcing and CQRS. When the work is done asynchronously, POSTing the transformation and waiting for it to be applied seems appropriate.</source>
          <target state="translated">Esto obliga a la API a evitar problemas de transición de estado con múltiples clientes que actualizan un solo recurso,y se ajusta más bien a la fuente de eventos y al CQRS.Cuando el trabajo se hace de forma asíncrona,la publicación de la transformación y la espera de su aplicación parece apropiada.</target>
        </trans-unit>
        <trans-unit id="0d513503c5d27d970dedbc3a017aa5dfc6730d1b" translate="yes" xml:space="preserve">
          <source>This is what AtomPub has to say about resource creation (section 9.2):</source>
          <target state="translated">Esto es lo que AtomPub tiene que decir sobre la creación de recursos (sección 9.2):</target>
        </trans-unit>
        <trans-unit id="db06c4e9bb7f4493ec87367452486878b32df472" translate="yes" xml:space="preserve">
          <source>This jibes with the other advice here, that PUT is best applied to resources that already have a name, and POST is good for creating a new object under an existing resource (and letting the server name it).</source>
          <target state="translated">Esto se burla del otro consejo de aquí,que el PUT se aplica mejor a los recursos que ya tienen un nombre,y el POST es bueno para crear un nuevo objeto bajo un recurso existente (y dejar que el servidor le dé un nombre).</target>
        </trans-unit>
        <trans-unit id="329ccd5deda6ee5083da67216837de43b64d3560" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI of the Collection.</source>
          <target state="translated">Para añadir miembros a una Colección,los clientes envían solicitudes POST a la URI de la Colección.</target>
        </trans-unit>
        <trans-unit id="8a44f83e9442ef60d290f2c8799f5cc060ff1e23" translate="yes" xml:space="preserve">
          <source>To overwrite an existing resource:</source>
          <target state="translated">Para sobrescribir un recurso existente:</target>
        </trans-unit>
        <trans-unit id="300c31c8ca811ac31b1e4b0cbcc5df25674e9c0e" translate="yes" xml:space="preserve">
          <source>To understand it we need to question why PUT was required, what were the problems PUT was trying to solve that POST couldn't.</source>
          <target state="translated">Para entenderlo tenemos que preguntarnos por qué se requería el PUT,cuáles eran los problemas que el PUT intentaba resolver y que el POST no podía.</target>
        </trans-unit>
        <trans-unit id="2b77e3950318466e7b1306d760c2096fcdcc38f3" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URI): Generic Syntax and Semantics</source>
          <target state="translated">Identificadores Uniformes de Recursos (URI):Sintaxis y semántica genérica</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="e2fbf38e05ed6d395ec7f6efdfd2ea298e430b2a" translate="yes" xml:space="preserve">
          <source>Updates the resource with &lt;strong&gt;existingResourceId&lt;/strong&gt; as the identifier, under the /resources URI, or &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Actualiza el recurso con &lt;strong&gt;existenteResourceId&lt;/strong&gt; como el identificador, bajo el / URI de recursos, o &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f8079d8e5134eb77a5128a4f32d06200addab2ae" translate="yes" xml:space="preserve">
          <source>Use POST to create, and PUT to update. That's how Ruby on Rails is doing it, anyway.</source>
          <target state="translated">Usa POST para crear y PUT para actualizar.Así es como Ruby on Rails lo está haciendo,de todos modos.</target>
        </trans-unit>
        <trans-unit id="7e3328f33c6c2ad3028951ba9c219f5262089b33" translate="yes" xml:space="preserve">
          <source>Used to create a resource, or
  overwrite it.  While you specify the
  resources new URL.</source>
          <target state="translated">Se usa para crear un recurso,o para sobrescribirlo.Mientras especificas los recursos,la nueva URL.</target>
        </trans-unit>
        <trans-unit id="caad456be6f2e43799931b874b916e57d669f040" translate="yes" xml:space="preserve">
          <source>Used to modify and update a resource</source>
          <target state="translated">Se utiliza para modificar y actualizar un recurso</target>
        </trans-unit>
        <trans-unit id="534d6f360955fe24940d916537fd5f5d03013712" translate="yes" xml:space="preserve">
          <source>Useful when a resource's URL is known</source>
          <target state="translated">Útil cuando se conoce la URL de un recurso</target>
        </trans-unit>
        <trans-unit id="87dffc568fb442d1ab8b5daa3edd8813475735c7" translate="yes" xml:space="preserve">
          <source>Useful when the resource's URL is
unknown</source>
          <target state="translated">Útil cuando se desconoce la URL del recurso</target>
        </trans-unit>
        <trans-unit id="d2f00b419fb58779569430425949be8c2946ab81" translate="yes" xml:space="preserve">
          <source>When dealing with REST and URI as general, you have &lt;strong&gt;generic&lt;/strong&gt; on the &lt;em&gt;left&lt;/em&gt; and &lt;strong&gt;specific&lt;/strong&gt; on the &lt;em&gt;right&lt;/em&gt;. The &lt;strong&gt;generics&lt;/strong&gt; are usually called &lt;strong&gt;collections&lt;/strong&gt; and the more &lt;strong&gt;specific&lt;/strong&gt; items can be called &lt;strong&gt;resource&lt;/strong&gt;. Note that a &lt;strong&gt;resource&lt;/strong&gt; can contain a &lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Cuando se trata de REST y URI como general, tiene &lt;strong&gt;gen&amp;eacute;rico&lt;/strong&gt; a la &lt;em&gt;izquierda&lt;/em&gt; y &lt;strong&gt;espec&amp;iacute;fico&lt;/strong&gt; a la &lt;em&gt;derecha&lt;/em&gt; . Los &lt;strong&gt;gen&amp;eacute;ricos&lt;/strong&gt; generalmente se denominan &lt;strong&gt;colecciones&lt;/strong&gt; y los elementos m&amp;aacute;s &lt;strong&gt;espec&amp;iacute;ficos&lt;/strong&gt; se pueden llamar &lt;strong&gt;recurso&lt;/strong&gt; . Tenga en cuenta que un &lt;strong&gt;recurso&lt;/strong&gt; puede contener una &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="14ad7c96823b5a1d653bec9e758d08db87c5209c" translate="yes" xml:space="preserve">
          <source>When you POST to a resource at a particular URL, often you are posting a related piece of information to that URL. This implies that the resource at the URL already exists.</source>
          <target state="translated">Cuando usted PUBLICA a un recurso en un URL particular,a menudo está publicando una información relacionada con ese URL.Esto implica que el recurso en el URL ya existe.</target>
        </trans-unit>
        <trans-unit id="f6bf84ba90320cefe0d8fa5d18b1d11fe5272e46" translate="yes" xml:space="preserve">
          <source>When you PUT a resource at a particular URL what happens is that it should get saved at that URL, or something along those lines.</source>
          <target state="translated">Cuando PONES un recurso en un URL particular lo que sucede es que debe ser guardado en ese URL,o algo por el estilo.</target>
        </trans-unit>
        <trans-unit id="03669db6e556a71ab819d40f836e5bd27373b8b6" translate="yes" xml:space="preserve">
          <source>When you can't fully trust the client to do the right thing, it would be 
more appropriate to use &lt;strong&gt;POST&lt;/strong&gt; to create a new item and then send the URL back to the client in the response.</source>
          <target state="translated">Cuando no puede confiar plenamente en que el cliente haga lo correcto, ser&amp;iacute;a m&amp;aacute;s apropiado usar &lt;strong&gt;POST&lt;/strong&gt; para crear un nuevo elemento y luego enviar la URL de vuelta al cliente en la respuesta.</target>
        </trans-unit>
        <trans-unit id="22766c7cfca9b0f8a5c36dfb8f98f375b88a60a7" translate="yes" xml:space="preserve">
          <source>When you use POST you are &lt;strong&gt;always&lt;/strong&gt; refering to a &lt;strong&gt;collection&lt;/strong&gt;, so whenever you say:</source>
          <target state="translated">Cuando usa POST, &lt;strong&gt;siempre&lt;/strong&gt; se est&amp;aacute; refiriendo a una &lt;strong&gt;colecci&amp;oacute;n&lt;/strong&gt; , as&amp;iacute; que cada vez que dice:</target>
        </trans-unit>
        <trans-unit id="e380bb1d3e7c031588ca3a3c5bf3f6f0d241ddcf" translate="yes" xml:space="preserve">
          <source>Which is used is left up to you.  But just remember to use the right one depending on what object you are referencing in the request.</source>
          <target state="translated">Lo que se use queda a tu criterio.Pero recuerda usar el derecho dependiendo del objeto al que te refieras en la solicitud.</target>
        </trans-unit>
        <trans-unit id="ebbb5885abc4335ac57b9aa863e7c08abfc8ea5e" translate="yes" xml:space="preserve">
          <source>Which means if you have to submit</source>
          <target state="translated">Lo que significa que si tienes que presentar</target>
        </trans-unit>
        <trans-unit id="1e394f3df68b2548c835945807e40cf42b367d8e" translate="yes" xml:space="preserve">
          <source>While there is probably an agnostic way to describe these, it does seem to be conflicting with various statements from answers to websites.</source>
          <target state="translated">Aunque probablemente haya una forma agnóstica de describirlas,parece estar en conflicto con varias afirmaciones de las respuestas a los sitios web.</target>
        </trans-unit>
        <trans-unit id="a5bc20d2d4325f529ff7555db67ccca89565a4cd" translate="yes" xml:space="preserve">
          <source>Wikipedia - REST</source>
          <target state="translated">Wikipedia-DESCANSO</target>
        </trans-unit>
        <trans-unit id="386e23f3812d1bdded28437f31996a6a569b6fd3" translate="yes" xml:space="preserve">
          <source>With &amp;ldquo;REST without PUT&amp;rdquo; technique, the idea is that consumers are
  forced to post new 'nounified' request resources. As discussed
  earlier, changing a customer&amp;rsquo;s mailing address is a POST to a new
  &amp;ldquo;ChangeOfAddress&amp;rdquo; resource, not a PUT of a &amp;ldquo;Customer&amp;rdquo; resource with a
  different mailing address field value.</source>
          <target state="translated">Con la t&amp;eacute;cnica &quot;REST sin PUT&quot;, la idea es que los consumidores se vean obligados a publicar nuevos recursos de solicitud 'no anunciados'. Como se discuti&amp;oacute; anteriormente, cambiar la direcci&amp;oacute;n postal de un cliente es una POST a un nuevo recurso &quot;ChangeOfAddress&quot;, no un PUT de un recurso &quot;Cliente&quot; con un valor de campo de direcci&amp;oacute;n postal diferente.</target>
        </trans-unit>
        <trans-unit id="53a0df456d0b82cfb20df7d1c7dcda70c26fd29c" translate="yes" xml:space="preserve">
          <source>With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.</source>
          <target state="translated">Con el POST puedes tener 2 peticiones llegando al mismo tiempo haciendo modificaciones a una URL,y pueden actualizar diferentes partes del objeto.</target>
        </trans-unit>
        <trans-unit id="bcec0b85a95c09c1d9aa73bbac93122064920f3c" translate="yes" xml:space="preserve">
          <source>With POST, you're posting to the address of the QUEUE or COLLECTION. With PUT, you're putting to the address of the ITEM.</source>
          <target state="translated">Con el POST,se envía a la dirección de la COLA o COLECCIÓN.Con PUT,estás poniendo a la dirección del ARTÍCULO.</target>
        </trans-unit>
        <trans-unit id="e394766f3d8f38a5425a15f2e94e15f94cff2588" translate="yes" xml:space="preserve">
          <source>With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.</source>
          <target state="translated">Con PUT,si la misma consulta se ejecuta varias veces o una sola vez,el estado de la tabla STUDENT sigue siendo el mismo.</target>
        </trans-unit>
        <trans-unit id="9f13e4060016ff9f870bc818b8b5bcb9592a2292" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;POST&lt;/code&gt; to example.com/users since you don't know the &lt;code&gt;URL&lt;/code&gt; of the user yet, you want the server to create it.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; AS en example.com/users ya que a&amp;uacute;n no conoces la &lt;code&gt;URL&lt;/code&gt; del usuario, quieres que el servidor la cree.</target>
        </trans-unit>
        <trans-unit id="a3e29206f13fd7f313ac3a03984149fd94f809d9" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;PUT&lt;/code&gt; to example.com/users/id since you want to replace/create a &lt;em&gt;specific&lt;/em&gt; user.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; a example.com/users/id ya que desea reemplazar / crear un usuario &lt;em&gt;espec&amp;iacute;fico&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cd925494376cae5537a3d23703b024e74bd08383" translate="yes" xml:space="preserve">
          <source>You can find assertions on the web that say</source>
          <target state="translated">Puedes encontrar afirmaciones en la web que dicen</target>
        </trans-unit>
        <trans-unit id="deb01051624c8536f5e270d282325b0dbf3553ef" translate="yes" xml:space="preserve">
          <source>You can update or create a resource with PUT with the same object URL</source>
          <target state="translated">Puedes actualizar o crear un recurso con PUT con el mismo objeto URL</target>
        </trans-unit>
        <trans-unit id="50c70a21ef7f357ae45ec172565f2b589fc30211" translate="yes" xml:space="preserve">
          <source>You could though do something like
  this to create a resources using POST:</source>
          <target state="translated">Sin embargo,podrías hacer algo como esto para crear un recurso usando POST:</target>
        </trans-unit>
        <trans-unit id="8dddfd0893267c4dc2c1565595682d6ee7fe0449" translate="yes" xml:space="preserve">
          <source>You do not need to support both PUT and POST.</source>
          <target state="translated">No necesitas apoyar tanto el PUT como el POST.</target>
        </trans-unit>
        <trans-unit id="1a70c96038989ab75bed3ead389a54345761a879" translate="yes" xml:space="preserve">
          <source>You have to ask &quot;what are you performing the action to?&quot; to distinguish what you should be using. Let's assume you're designing an API for asking questions.  If you want to use POST then you would do that to a list of questions. If you want to use PUT then you would do that to a particular question.</source>
          <target state="translated">Tienes que preguntarte &quot;¿a qué estás realizando la acción?&quot; para distinguir lo que deberías usar.Asumamos que estás diseñando una API para hacer preguntas.Si quieres usar POST entonces lo harías con una lista de preguntas.Si quieres usar PUT entonces harías eso a una pregunta en particular.</target>
        </trans-unit>
        <trans-unit id="aab05f743ff11af397a41e6a50b339a3a9b253b8" translate="yes" xml:space="preserve">
          <source>You will quickly spot the similarity with promises: we create and return the placeholder for the result before doing anything. Also like a promise, an action can succeed or fail one time, but its result can be fetched repeatedly.</source>
          <target state="translated">Rápidamente descubrirá la similitud con las promesas:creamos y devolvemos el marcador de posición del resultado antes de hacer nada.También como una promesa,una acción puede tener éxito o fracasar una vez,pero su resultado puede ser obtenido repetidamente.</target>
        </trans-unit>
        <trans-unit id="f363cc5672437cee525e493743ecf9b56f18170d" translate="yes" xml:space="preserve">
          <source>files, non-ASCII data, and binary data</source>
          <target state="translated">archivos,datos no ASCII y datos binarios</target>
        </trans-unit>
        <trans-unit id="03d4991f0d2b56909a00a2c07cb0c98115001bed" translate="yes" xml:space="preserve">
          <source>information for the user to recognize the source of the conflict.
  Ideally, the response entity would include enough information for the
  user or user agent to fix the problem; however, that might not be
  possible and is not required.</source>
          <target state="translated">información para que el usuario reconozca la fuente del conflicto.Lo ideal sería que la entidad de respuesta incluyera suficiente información para que el usuario o el agente de usuario solucionara el problema;sin embargo,eso podría no ser posible y no es necesario.</target>
        </trans-unit>
        <trans-unit id="a7cc393671d331a6f24f8870a93fd8292a27451f" translate="yes" xml:space="preserve">
          <source>it will work, but semantically you are saying that you want to add a resource to the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">funcionar&amp;aacute;, pero sem&amp;aacute;nticamente est&amp;aacute; diciendo que desea agregar un recurso a la &lt;strong&gt;colecci&amp;oacute;n de&lt;/strong&gt; &lt;em&gt;John&lt;/em&gt; en la &lt;strong&gt;colecci&amp;oacute;n de&lt;/strong&gt; &lt;em&gt;usuarios&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="d0b50e773f074b959f39222603c21bd08feff7c0" translate="yes" xml:space="preserve">
          <source>taken from &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Resource Modeling by Prakash Subramaniam of Thoughtworks&lt;/a&gt;</source>
          <target state="translated">tomado de &lt;a href=&quot;https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling&quot;&gt;REST API Design - Modelado de recursos por Prakash Subramaniam de Thoughtworks&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebe73780ee4475ed56cfa08985bac3ceeb53b38" translate="yes" xml:space="preserve">
          <source>the origin server can create the resource with that URI</source>
          <target state="translated">el servidor de origen puede crear el recurso con esa URI</target>
        </trans-unit>
        <trans-unit id="c4c609ca0b9379838bc225c20d08b72b88e05939" translate="yes" xml:space="preserve">
          <source>you are posting a new user to the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">Est&amp;aacute; publicando un nuevo usuario en la &lt;strong&gt;colecci&amp;oacute;n de&lt;/strong&gt; &lt;em&gt;usuarios&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f3bfcffc130ebfe19bd9ae363ee7834942fb61" translate="yes" xml:space="preserve">
          <source>you are telling to the server update, or create if it doesn't exist, the &lt;em&gt;john&lt;/em&gt;&lt;strong&gt;resource&lt;/strong&gt; under the &lt;em&gt;users&lt;/em&gt;&lt;strong&gt;collection&lt;/strong&gt;.</source>
          <target state="translated">le est&amp;aacute; diciendo a la actualizaci&amp;oacute;n del servidor, o crea, si no existe, el &lt;strong&gt;recurso&lt;/strong&gt; &lt;em&gt;john&lt;/em&gt; en la &lt;strong&gt;colecci&amp;oacute;n de&lt;/strong&gt; &lt;em&gt;usuarios&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ac747133049c7cac58b2f01633f4d4824881c480" translate="yes" xml:space="preserve">
          <source>you should use &lt;strong&gt;POST&lt;/strong&gt; method</source>
          <target state="translated">deber&amp;iacute;as usar el m&amp;eacute;todo &lt;strong&gt;POST&lt;/strong&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
