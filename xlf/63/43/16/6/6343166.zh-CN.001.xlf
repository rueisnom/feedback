<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6343166">
    <body>
      <group id="6343166">
        <trans-unit id="e701d4f4ca8a7c0ce3eea20ba70d6bce670254b5" translate="yes" xml:space="preserve">
          <source>(From his example.)</source>
          <target state="translated">(引自他的例子)。</target>
        </trans-unit>
        <trans-unit id="caeb8c4daf10a7a29d60ebe7f726b5e6be1ea726" translate="yes" xml:space="preserve">
          <source>(I just had a long head-scratching moment trying to figure out why I was getting that error somewhere other than my main thread.  This was why; this thread helped; and hopefully this comment will help someone else.)</source>
          <target state="translated">(我只是想知道为什么我在我的主线程以外的地方出现了这个错误。这就是原因;这条线程帮助了我;希望这条评论能帮助到其他人)。)</target>
        </trans-unit>
        <trans-unit id="6a8088732944db5eec3c539530a0513e5fcc6250" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;Coroutines&lt;/a&gt; (Kotlin)</source>
          <target state="translated">&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;协程&lt;/a&gt; （ 科特琳 ）</target>
        </trans-unit>
        <trans-unit id="513a168553003f07d278a92713bcaebee5d17d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AsyncTask&lt;/code&gt; should ideally be used for short operations. Normal &lt;code&gt;Thread&lt;/code&gt; is not preferable for Android.</source>
          <target state="translated">理想情况下， &lt;code&gt;AsyncTask&lt;/code&gt; 应该用于简短操作。 对于Android而言，普通 &lt;code&gt;Thread&lt;/code&gt; 不是首选。</target>
        </trans-unit>
        <trans-unit id="f7974727712da83599bfb8e8c238a6155c2f8ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RxAndroid&lt;/code&gt; is another better alternative to this problem and it saves us from hassles of creating threads and then posting results on Android UI thread.
We just need to specify threads on which tasks need to be executed and everything is handled internally.</source>
          <target state="translated">&lt;code&gt;RxAndroid&lt;/code&gt; 是解决此问题的另一个更好的选择，它使我们免于创建线程然后将结果发布到Android UI线程上的麻烦。 我们只需要指定线程，就可以在这些线程上执行任务，并且所有事情都在内部进行处理。</target>
        </trans-unit>
        <trans-unit id="219b997bdcfa0046d264cf94a2386888ac6a5147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run()&lt;/code&gt; method of new thread</source>
          <target state="translated">新线程的 &lt;code&gt;run()&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="f5bbd6621b1e09056a5aa357275ada0230e4428b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;android.os.NetworkOnMainThreadException sending an email from Android&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;android.os.NetworkOnMainThreadException从Android发送电子邮件&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a25f771710bd8cde3227bd7972908fe47b297297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If your API requires an API Key or other header like a user token, etc. to be sent, Retrofit makes this easy (see this awesome answer for details: &lt;a href=&quot;https://stackoverflow.com/a/42899766/1024412&quot;&gt;https://stackoverflow.com/a/42899766/1024412&lt;/a&gt;).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果您的API要求发送API密钥或其他标头（例如用户令牌等），则Retrofit可以简化此操作（有关详细信息，请参见此真棒答案： &lt;a href=&quot;https://stackoverflow.com/a/42899766/1024412&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/42899766/1024412 ）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66961741ec9c0e83379baa24fc592717dcc9315e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation summary&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;实施摘要&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9c0c6f046f93218df6678063b471e792fb5e535" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IntentService approach&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IntentService方法&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2397d3757b8d169d35c47aa969de6541d61d5ec6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Typically Json, can be XML or something else&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;通常，Json可以是XML或其他名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dad356866e8f659fd325b891f3ebcdd63e20966" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Volley can also be used for ReST APIs, but due to the more complicated setup required I prefer to use Retrofit from Square as above (&lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Volley也可以用于ReST API，但是由于需要更复杂的设置，因此我更喜欢使用Square的Retrofit（如上所述）（ &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt; ）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="25e62674da40cc91ecdb9eecd1fc280c9eaea2b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AsyncTask&lt;/strong&gt; is designed to be a helper class around &lt;strong&gt;Thread&lt;/strong&gt; and &lt;strong&gt;Handler&lt;/strong&gt; and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as &lt;strong&gt;Executor&lt;/strong&gt;, &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt; and &lt;strong&gt;FutureTask&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;AsyncTask&lt;/strong&gt;被设计为围绕&lt;strong&gt;Thread&lt;/strong&gt;和&lt;strong&gt;Handler&lt;/strong&gt;的帮助器类，并且不构成通用的线程框架。 理想情况下，应将AsyncTasks用于较短的操作（最多几秒钟）。如果需要使线程长时间运行，则强烈建议您使用java.util.concurrent包提供的各种API，例如&lt;strong&gt;执行器&lt;/strong&gt; ， &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;和&lt;strong&gt;FutureTask&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6598d2b45c7dbf80276bd511c505bc2857a99510" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;But:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2133e68d566fe49c20988cfcce2bbb99801d6de7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DO NOT DO NETWORK WORK IN THE UI THREAD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不要在UI线程中进行网络工作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917cfe5738a6f66768d1da4e53af3171e558b3b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesApi.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesApi.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3021948f153e7007373ef5242b6d203511d5ce09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesApiBuilder&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesApiBuilder&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0ff55b5e14dbd360ec6c31743a34c3290cc49a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesFragment snippet&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;财务片段&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="567a81632d5511eb02ee4b8419137a833a82dc57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Handler:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Handler:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fff1888f36aaf72cc2080185fe1f5f2683cc4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HandlerThread&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HandlerThread&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="384422180405859aa2748fcda32661c85100c51d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c63a5cc621c4c365b35d0d44621b19b36fdf48e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ImageFetch.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ImageFetch.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a5ed542bf2a3a24445892b08dd385084f2f581b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt; call &lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt;&lt;code&gt;runOnUiThread()&lt;/code&gt;&lt;/a&gt; method and update view inside the &lt;code&gt;run()&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;或&lt;/strong&gt;调用&lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt; &lt;code&gt;runOnUiThread()&lt;/code&gt; &lt;/a&gt;方法并在 &lt;code&gt;run()&lt;/code&gt; 方法内更新视图。</target>
        </trans-unit>
        <trans-unit id="5eb9692511a9440615e36334fff23221552c6401" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt; use &lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot;&gt;AsyncTask class&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;或&lt;/strong&gt;使用&lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot;&gt;AsyncTask类&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2a7ef528060d56c8515b79d85a46d420cd9ce1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt;&lt;code&gt;doInBackground()&lt;/code&gt; method of AsyncTask class.</source>
          <target state="translated">&lt;strong&gt;或&lt;/strong&gt; AsyncTask类的 &lt;code&gt;doInBackground()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="49c900ba5a0475e269165d778322be2846b3c474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solution:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b38b4c4100e627a7e6c087c8e21cfdf4ed6d3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The accepted answer has some significant down-sides. It is not advisable to use AsyncTask for networking unless you &lt;em&gt;really&lt;/em&gt; know what you are doing. Some of the down-sides include:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;公认的答案有一些明显的缺点。&lt;/strong&gt; &lt;strong&gt;建议不要使用AsyncTask进行网络连接，除非您&lt;em&gt;真的&lt;/em&gt;知道自己在做什么。&lt;/strong&gt; &lt;strong&gt;缺点包括：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19b5e9d0ddf1bdb5d05bf7202e0f6fa71a0a776f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is not recommended&lt;/strong&gt;: use the &lt;code&gt;AsyncTask&lt;/code&gt; interface.</source>
          <target state="translated">&lt;strong&gt;不建议这样做&lt;/strong&gt; ：使用 &lt;code&gt;AsyncTask&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="e20c836962bfca05fb50974e95a20a24b1359cc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this in Your Activity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在您的活动中使用它&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7336c3aa8ca565418a4c68252e36d2812c114c54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UserViewDialog.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UserViewDialog.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8765d8046996c6e90e70fcf4c30238fcf731d749" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Way:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06e4b3f8e199aed94f3f2f897dfb806c1caa237a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You should almost always run network operations on a thread or as an asynchronous task.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您几乎应该始终在线程上或作为异步任务运行网络操作。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a36ba63f51ccfca556458e8a4cce314f801ac29c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;build.gradle&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;build.gradle&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2ec3ef457076fbfc6654a12bcb37263fdb07109" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;user_view_dialog.xml&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;user_view_dialog.xml&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87f2e56db8589458e7fa17b650e754fb55204d75" translate="yes" xml:space="preserve">
          <source>A Github project containing a complete working Android-Studio/Gradle project is available &lt;a href=&quot;https://github.com/steveliles/Android-Download-Service-Example&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">这里包含一个包含完整的Android-Studio / Gradle项目的Github项目。</target>
        </trans-unit>
        <trans-unit id="24f7c8831f32f043122b170cd7a35bd2b8eb3ad6" translate="yes" xml:space="preserve">
          <source>A Handler allows you to send and process Message and Runnable objects associated with a thread's MessageQueue. Each Handler instance is associated with a single thread and that thread's message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</source>
          <target state="translated">处理程序允许您发送和处理与线程的MessageQueueue相关联的Message和Runnable对象。每个处理程序实例都与单个线程和该线程的消息队列关联。当您创建一个新的处理程序时,它将被绑定到创建它的线程的线程消息队列中--从那一刻起,它将向该消息队列发送消息和可运行对象,并在消息队列中出现时执行它们。</target>
        </trans-unit>
        <trans-unit id="62525e1302249317dc097de933bbafd11fd21100" translate="yes" xml:space="preserve">
          <source>ADD this permission in android manifest.xml file: &amp;nbsp; &amp;nbsp;</source>
          <target state="translated">在android manifest.xml文件中添加此权限：</target>
        </trans-unit>
        <trans-unit id="ffae741742565dee96ff975c416b8d353112e510" translate="yes" xml:space="preserve">
          <source>Accessing network resources from the main (UI) thread cause this exception. Use a separate thread or AsyncTask for accessing a network resource to avoid this problem.</source>
          <target state="translated">从主线程(UI)访问网络资源会导致这个异常。使用单独的线程或AsyncTask来访问网络资源可以避免这个问题。</target>
        </trans-unit>
        <trans-unit id="0f0d0881b6e43f09d81175d22f7987bf0d1221b8" translate="yes" xml:space="preserve">
          <source>Add the following code to the onCreate method (Fragment, Activity) or the constructor (Dialog):</source>
          <target state="translated">在onCreate方法(Fragment,Activity)或构造函数(Dialog)中添加以下代码。</target>
        </trans-unit>
        <trans-unit id="9112f4dc99cf0253e3029c2c006685defa6b5de6" translate="yes" xml:space="preserve">
          <source>Add the following to your layout xml file to add an image:</source>
          <target state="translated">在你的布局xml文件中添加以下内容来添加图片。</target>
        </trans-unit>
        <trans-unit id="5742348ab2679838340e69e8e774beee58abe587" translate="yes" xml:space="preserve">
          <source>Add these lines to your Module level buid.gradle:</source>
          <target state="translated">在你的模块级别的buid.gradle中添加这几行。</target>
        </trans-unit>
        <trans-unit id="9d9bc4c443ca7664f0308a3d6d6f85d72ac6a70c" translate="yes" xml:space="preserve">
          <source>Add this line to your Module level buid.gradle:</source>
          <target state="translated">在你的模块级buid.gradle中添加这一行。</target>
        </trans-unit>
        <trans-unit id="c37195fe791a6d5ae7aa1680ddbf075189eb46ce" translate="yes" xml:space="preserve">
          <source>Add:</source>
          <target state="translated">Add:</target>
        </trans-unit>
        <trans-unit id="c9416697ac321c85343ea7b82034f38ccdbc1a49" translate="yes" xml:space="preserve">
          <source>Also, as others have mentioned, include the correct permissions to access the Internet:</source>
          <target state="translated">此外,正如其他人提到的,还包括正确的访问互联网的权限。</target>
        </trans-unit>
        <trans-unit id="85eb254309b9817b59cbdf1521ae57f2fd9bdd4a" translate="yes" xml:space="preserve">
          <source>Although above there is a huge solution pool, no one mentioned &lt;code&gt;com.koushikdutta.ion&lt;/code&gt;: &lt;a href=&quot;https://github.com/koush/ion&quot;&gt;https://github.com/koush/ion&lt;/a&gt;</source>
          <target state="translated">尽管上面有一个庞大的解决方案池，但没有人提到 &lt;code&gt;com.koushikdutta.ion&lt;/code&gt; ： &lt;a href=&quot;https://github.com/koush/ion&quot;&gt;https&lt;/a&gt; : //github.com/koush/ion</target>
        </trans-unit>
        <trans-unit id="865822065fcdc4d56fd5b2c5554b3da425ee6b15" translate="yes" xml:space="preserve">
          <source>And add this to AndroidManifest.xml</source>
          <target state="translated">并将其添加到AndroidManifest.xml中。</target>
        </trans-unit>
        <trans-unit id="d9e37bccfa0b1f88f4e499362fd7307daaa603e6" translate="yes" xml:space="preserve">
          <source>And it shows the below error:</source>
          <target state="translated">并显示以下错误。</target>
        </trans-unit>
        <trans-unit id="8fa6edcdeef0ba2e24b13161c844dedc283e5d95" translate="yes" xml:space="preserve">
          <source>Android has some good tips on good programming practices to design for responsiveness:
&lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&lt;/a&gt;</source>
          <target state="translated">Android提供了一些有关设计良好的编程实践以提高响应能力的好技巧： &lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;http&lt;/a&gt; : //developer.android.com/reference/android/os/NetworkOnMainThreadException.html</target>
        </trans-unit>
        <trans-unit id="69e8f859c636329f43322ad40ceb48e0db6287be" translate="yes" xml:space="preserve">
          <source>Another excellent library from Square. Please see the site for some great examples: &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;http://square.github.io/picasso/&lt;/a&gt;</source>
          <target state="translated">另一个来自Square的优秀图书馆。 请访问该站点以获取一些出色的示例： &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;http&lt;/a&gt; : //square.github.io/picasso/</target>
        </trans-unit>
        <trans-unit id="691706e7fa4ef71a62183103fde8d93a8e51cc9e" translate="yes" xml:space="preserve">
          <source>AsyncTask</source>
          <target state="translated">AsyncTask</target>
        </trans-unit>
        <trans-unit id="1e93f9e0b4644967ae582a89cc56cc92b5d29f7e" translate="yes" xml:space="preserve">
          <source>AsyncTask has different execution characteristics depending on the platform it executes on: prior to API level 4 AsyncTasks execute serially on a single background thread; from API level 4 through API level 10, AsyncTasks execute on a pool of up to 128 threads; from API level 11 onwards AsyncTask executes serially on a single background thread (unless you use the overloaded &lt;code&gt;executeOnExecutor&lt;/code&gt; method and supply an alternative executor). Code that works fine when running serially on ICS may break when executed concurrently on Gingerbread, say if you have inadvertent order-of-execution dependencies.</source>
          <target state="translated">AsyncTask根据执行平台的不同而具有不同的执行特征：在API级别4之前，AsyncTask在单个后台线程上串行执行； 从API级别4到API级别10，AsyncTasks在最多128个线程的池中执行； 从API级别11开始，AsyncTask在单个后台线程上串行执行（除非您使用重载的 &lt;code&gt;executeOnExecutor&lt;/code&gt; 方法并提供替代的执行程序）。 在ICS上串行运行时运行良好的代码在Gingerbread上同时执行时可能会中断，例如，如果您无意间执行了顺序。</target>
        </trans-unit>
        <trans-unit id="44013bbe71b1fbd1c9a2d927a1c92b80870d6c88" translate="yes" xml:space="preserve">
          <source>AsyncTask's created as non-static inner classes have an implicit reference to the enclosing Activity object, its context, and the entire View hierarchy created by that activity. This reference prevents the Activity from being garbage collected until the AsyncTask's background work completes. If the user's connection is slow, and/or the download is large, these short-term memory leaks can become a problem - for example, if the orientation changes several times (and you don't cancel the executing tasks), or the user navigates away from the Activity.</source>
          <target state="translated">AsyncTask作为非静态内部类创建的AsyncTask有一个隐含的引用,指向包围的Activity对象,它的上下文,以及由该活动创建的整个View层次结构。这个引用可以防止Activity在AsyncTask的后台工作完成之前被垃圾回收。如果用户的连接速度很慢,或者下载量很大,这些短期内存泄漏就会成为问题--例如,如果方向改变了几次(而你没有取消正在执行的任务),或者用户导航离开了Activity。</target>
        </trans-unit>
        <trans-unit id="4230b18c8bff24b31dcc1e2e960671cd033ff07c" translate="yes" xml:space="preserve">
          <source>AsyncTaskLoaders</source>
          <target state="translated">AsyncTaskLoaders</target>
        </trans-unit>
        <trans-unit id="cb8b3ce6e66e52a12f5f2c0ad7e5094bda40b6b3" translate="yes" xml:space="preserve">
          <source>AsyncTaskLoaders as they solve a lot of problems that are inherent to AsyncTask</source>
          <target state="translated">AsyncTaskLoaders,因为它们解决了很多AsyncTask固有的问题。</target>
        </trans-unit>
        <trans-unit id="275453a59ed88313d5d9db057a22bc44e738b318" translate="yes" xml:space="preserve">
          <source>Avoids the short-term memory leak problem</source>
          <target state="translated">避免了短期内存泄露问题</target>
        </trans-unit>
        <trans-unit id="318b3c70e158fa010b651f670e102419f34b2b6f" translate="yes" xml:space="preserve">
          <source>Better platform than AsyncTask to build and re-use robust networking code. Example: if you need to do an important upload, you could do it from &lt;code&gt;AsyncTask&lt;/code&gt; in an &lt;code&gt;Activity&lt;/code&gt;, but if the user context-switches out of the app to take a phone call, the system &lt;em&gt;may&lt;/em&gt; kill the app before the upload completes. It is &lt;em&gt;less likely&lt;/em&gt; to kill an application with an active &lt;code&gt;Service&lt;/code&gt;.</source>
          <target state="translated">比AsyncTask更好的平台可以构建和重用强大的网络代码。 示例：如果您需要进行重要的上传，则可以通过 &lt;code&gt;Activity&lt;/code&gt; 中的 &lt;code&gt;AsyncTask&lt;/code&gt; 进行，但是如果用户上下文切换出应用程序以拨打电话，则系统&lt;em&gt;可能会&lt;/em&gt;在上传完成之前终止该应用程序。 使用活动 &lt;code&gt;Service&lt;/code&gt; 杀死应用程序的&lt;em&gt;可能性较小&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5c54e0601a5de1de7c93e6b3cb6840ff964a55c" translate="yes" xml:space="preserve">
          <source>But it &lt;em&gt;is&lt;/em&gt; possible to remove this restriction and you override the default behavior, if you are willing to accept the consequences.</source>
          <target state="translated">但是，如果您愿意接受后果，可以删除此限制，并覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="e1ccca981ca2cf568f35c92e2a96024f1c0ae2f4" translate="yes" xml:space="preserve">
          <source>By specifiying &lt;code&gt;(Schedulers.io())&lt;/code&gt;,RxAndroid will run &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt;  on a different thread.</source>
          <target state="translated">通过指定 &lt;code&gt;(Schedulers.io())&lt;/code&gt; ，RxAndroid将在另一个线程上运行 &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a733d96f50669ee3a024320dba52c76ffd9916c0" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; we want to observe this Observable on the UI thread, i.e. we want our &lt;code&gt;onNext()&lt;/code&gt; callback to be called on the UI thread</source>
          <target state="translated">通过使用 &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; ,我们希望在UI线程上观察此Observable，即，我们希望在UI线程上调用 &lt;code&gt;onNext()&lt;/code&gt; 回调</target>
        </trans-unit>
        <trans-unit id="23e6e1c1aa426e5d7b44c38ea48e5aa37c66bf86" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start()&lt;/code&gt; on &lt;code&gt;HandlerThread&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;HandlerThread&lt;/code&gt; 上调用 &lt;code&gt;start()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="697e05789b1e07993024a18e40db15c1604fdedb" translate="yes" xml:space="preserve">
          <source>Compared to AsyncTask, this method allow to switch schedulers an arbitrary number of times (say, fetch data on one scheduler and process those data on another (say, Scheduler.computation()). You can also define you own schedulers.</source>
          <target state="translated">与AsyncTask相比,这种方法允许任意次数地切换调度器(例如,在一个调度器上获取数据,然后在另一个调度器上处理这些数据(例如,Scheduler.computation())。你也可以定义你自己的调度器。</target>
        </trans-unit>
        <trans-unit id="adf92671c951691565d7070c7723f7d16bbef6c3" translate="yes" xml:space="preserve">
          <source>Consequences:</source>
          <target state="translated">Consequences:</target>
        </trans-unit>
        <trans-unit id="cf1695909bd06b7d1535f7582f28ae658753161b" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;Handler&lt;/code&gt; by getting &lt;code&gt;Looper&lt;/code&gt; from &lt;code&gt;HanlerThread&lt;/code&gt;</source>
          <target state="translated">通过从 &lt;code&gt;HanlerThread&lt;/code&gt; 获取 &lt;code&gt;Looper&lt;/code&gt; 创建 &lt;code&gt;Handler&lt;/code&gt; 程序</target>
        </trans-unit>
        <trans-unit id="012ed6c6f98adc741cd31875bdd78e842bc6cd35" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;HandlerThread&lt;/code&gt;</source>
          <target state="translated">创建 &lt;code&gt;HandlerThread&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bd53b66ee3417ce806db059b05f3982150b67fa" translate="yes" xml:space="preserve">
          <source>Creating new &lt;code&gt;Thread/AsyncTask&lt;/code&gt; for each network operation is expensive. The &lt;code&gt;Thread/AsyncTask&lt;/code&gt; will be destroyed and re-created for next Network operations. But with &lt;code&gt;Handler&lt;/code&gt; and &lt;code&gt;HandlerThread&lt;/code&gt; approach, you can submit many network operations (as Runnable tasks) to single &lt;code&gt;HandlerThread&lt;/code&gt; by using &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">为每个网络操作创建新的 &lt;code&gt;Thread/AsyncTask&lt;/code&gt; 非常昂贵。 &lt;code&gt;Thread/AsyncTask&lt;/code&gt; 将被销毁，并为下一个网络操作重新创建。 但是，使用 &lt;code&gt;Handler&lt;/code&gt; 和 &lt;code&gt;HandlerThread&lt;/code&gt; 方法，您可以使用Handler将许多网络操作（作为Runnable任务）提交给单个 &lt;code&gt;HandlerThread&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a59664e1f5103a439fc80adc7a71c7e98484c6" translate="yes" xml:space="preserve">
          <source>Do not change SDK version</source>
          <target state="translated">请勿更改SDK版本</target>
        </trans-unit>
        <trans-unit id="e0837fad2f0ae614b0356de69abcb486a696a8f6" translate="yes" xml:space="preserve">
          <source>Do not use a separate thread</source>
          <target state="translated">请勿使用单独的线程</target>
        </trans-unit>
        <trans-unit id="53f06da8f50dcab7efb7d76184f7462ed8af7c53" translate="yes" xml:space="preserve">
          <source>Do not use strictMode (only in debug mode)</source>
          <target state="translated">不要使用 strictMode(仅在调试模式下)。</target>
        </trans-unit>
        <trans-unit id="502135fc6b53e36e0d9d4eaaa28073a23ea96be7" translate="yes" xml:space="preserve">
          <source>Do the network actions on another thread</source>
          <target state="translated">在另一个线程上做网络操作</target>
        </trans-unit>
        <trans-unit id="971a8305c868fd80d22f60a4d8d160cb7a991fbe" translate="yes" xml:space="preserve">
          <source>Don't forget to add this to &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file:</source>
          <target state="translated">不要忘记将其添加到 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="06499f8ccaa126b054fb3f7150ae1a0b210d99a2" translate="yes" xml:space="preserve">
          <source>Down-sides:</source>
          <target state="translated">Down-sides:</target>
        </trans-unit>
        <trans-unit id="f814e28ec49db65c50c06aafb3321ffb79ecc2e0" translate="yes" xml:space="preserve">
          <source>Effectively, you have to create a Service and create a job using JobInfo.Builder that specifies your criteria for when to run the service.</source>
          <target state="translated">实际上,您必须创建一个服务,并使用JobInfo.Builder创建一个作业,指定您何时运行服务的标准。</target>
        </trans-unit>
        <trans-unit id="5c7f380f95d204aac73f23f63c7393eb0543e674" translate="yes" xml:space="preserve">
          <source>Embed your Network operation related code in &lt;code&gt;Runnable&lt;/code&gt; object</source>
          <target state="translated">将与网络操作相关的代码嵌入到 &lt;code&gt;Runnable&lt;/code&gt; 对象中</target>
        </trans-unit>
        <trans-unit id="358d84aa8148063b462186c221ef88a0bda8ec99" translate="yes" xml:space="preserve">
          <source>For Example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="bc707941094afa664b5576ca9850ca3d09a0d12c" translate="yes" xml:space="preserve">
          <source>For example, if you do an HTTP request, that is a network action.</source>
          <target state="translated">例如,如果你做一个HTTP请求,那就是一个网络动作。</target>
        </trans-unit>
        <trans-unit id="d351df765f999c0ca38cc9e9af0d8a607d67bcad" translate="yes" xml:space="preserve">
          <source>For me it was this:</source>
          <target state="translated">对我来说是这样的。</target>
        </trans-unit>
        <trans-unit id="2cd0e7756ef740a068c38453f3d730fe52435f55" translate="yes" xml:space="preserve">
          <source>Full API Access</source>
          <target state="translated">完整的API访问</target>
        </trans-unit>
        <trans-unit id="9bbe5a52f1f6cb3223609414a521e4f44339c8c4" translate="yes" xml:space="preserve">
          <source>Full code for both the methods</source>
          <target state="translated">这两种方法的完整代码</target>
        </trans-unit>
        <trans-unit id="6255759d8a74c7639f11435cf3f2acc6ab79c1ff" translate="yes" xml:space="preserve">
          <source>FutureTask</source>
          <target state="translated">FutureTask</target>
        </trans-unit>
        <trans-unit id="4430ba17611ee081b2f448917a7bd652e7f7385e" translate="yes" xml:space="preserve">
          <source>FutureTask performs asynchronous processing, however, if the result is not ready yet or processing has not complete, calling get() will be block the thread</source>
          <target state="translated">FutureTask执行异步处理,但是,如果结果还没有准备好,或者处理还没有完成,调用get()将阻塞线程</target>
        </trans-unit>
        <trans-unit id="bc829e2ae2b954ef4ec64093c80f2450d463725b" translate="yes" xml:space="preserve">
          <source>HandlerThread is a handy class for starting a new thread that has a looper.</source>
          <target state="translated">HandlerThread是一个方便的类,用于启动一个新的线程,它有一个循环器。</target>
        </trans-unit>
        <trans-unit id="fd082ffa8fb62eaee846d2070533b8ec5d67f1bb" translate="yes" xml:space="preserve">
          <source>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that &lt;code&gt;start()&lt;/code&gt; must still be called.</source>
          <target state="translated">方便的类，用于启动具有循环程序的新线程。 然后可以使用循环程序创建处理程序类。 请注意，仍必须调用 &lt;code&gt;start()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cc52cc14e1a5685ba5239ee9b3b80609b99622a" translate="yes" xml:space="preserve">
          <source>Have a look at alternate solution using &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot;&gt;Handler&lt;/a&gt;</source>
          <target state="translated">看看使用&lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;和&lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot;&gt;Handler的&lt;/a&gt;替代解决方案</target>
        </trans-unit>
        <trans-unit id="f0b9177b74ca18e621454f7f7b449caea6bc5aec" translate="yes" xml:space="preserve">
          <source>How can I fix this issue?</source>
          <target state="translated">怎样才能解决这个问题?</target>
        </trans-unit>
        <trans-unit id="0eb57f52cb28af4167bee573fad580495f3b90c8" translate="yes" xml:space="preserve">
          <source>How do you use it with the finances API?</source>
          <target state="translated">如何用好财务API?</target>
        </trans-unit>
        <trans-unit id="d51be9b048201f57b8e7a5ae6ca09d7b8a7ab43d" translate="yes" xml:space="preserve">
          <source>How to execute the task:</source>
          <target state="translated">如何执行任务。</target>
        </trans-unit>
        <trans-unit id="ce9f9270f0617cd02fe9defe5c7c6e34bd0b7307" translate="yes" xml:space="preserve">
          <source>How to fix 'android.os.NetworkOnMainThreadException'</source>
          <target state="translated">如何修复 &quot;android.os.NetworkOnMainThreadException</target>
        </trans-unit>
        <trans-unit id="8de77b5f476ed26c770e194fb605b98e1a82d3a5" translate="yes" xml:space="preserve">
          <source>I got an error while running my Android project for RssReader.</source>
          <target state="translated">在运行RssReader的Android项目时,我得到一个错误。</target>
        </trans-unit>
        <trans-unit id="3b91fabc95887b693f4dfa70e1d6062162a86efd" translate="yes" xml:space="preserve">
          <source>I solved this problem using a new &lt;code&gt;Thread&lt;/code&gt;.</source>
          <target state="translated">我使用新的 &lt;code&gt;Thread&lt;/code&gt; 解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="142d2f28bc7d6579f3b39cccf765cfe64f6ac996" translate="yes" xml:space="preserve">
          <source>I will cover several use cases for performing network operations and &lt;em&gt;a&lt;/em&gt; solution or two for each.</source>
          <target state="translated">我将介绍几种用于执行网络操作的用例，以及&lt;em&gt;一个&lt;/em&gt;或两个&lt;em&gt;的&lt;/em&gt;解决方案。</target>
        </trans-unit>
        <trans-unit id="eb79dd216f0906b69283214a67e04b660a60e8de" translate="yes" xml:space="preserve">
          <source>If you are writing the &lt;code&gt;AsyncTask&lt;/code&gt; inline and not extending as a class, and on top of this, if there is a need to get a response out of the &lt;code&gt;AsyncTask&lt;/code&gt;, one can use the &lt;code&gt;get()&lt;/code&gt; method as below.</source>
          <target state="translated">如果您正在编写内联而不是作为类扩展的 &lt;code&gt;AsyncTask&lt;/code&gt; ，并且最重要的是，如果需要从 &lt;code&gt;AsyncTask&lt;/code&gt; 中获取响应，则可以使用如下的 &lt;code&gt;get()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="69281d3c4e6ef2c3c5df51b6142be7fb1c6cb75b" translate="yes" xml:space="preserve">
          <source>If you don't do it, you will get &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt;.</source>
          <target state="translated">如果不这样做，则将获得 &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="294d9347d892ee06f7aec9c2cbf325de863f5155" translate="yes" xml:space="preserve">
          <source>If you use your own concurrent version of &lt;code&gt;IntentService&lt;/code&gt; (like the one I linked above) you can control the level of concurrency via the &lt;code&gt;Executor&lt;/code&gt;.</source>
          <target state="translated">如果您使用自己的并发版本的 &lt;code&gt;IntentService&lt;/code&gt; （如我上面链接的版本），则可以通过 &lt;code&gt;Executor&lt;/code&gt; 控制并发级别。</target>
        </trans-unit>
        <trans-unit id="1bf6b5410ab9222ea1a93159816f0874947656d5" translate="yes" xml:space="preserve">
          <source>If you want to avoid short-term memory leaks, have well-defined execution characteristics across all platforms, and have a base to build really robust network handling, you might want to consider:</source>
          <target state="translated">如果你想避免短期内存泄露,在所有平台上有明确定义的执行特性,并且有基础构建真正的健壮的网络处理,你可能会考虑。</target>
        </trans-unit>
        <trans-unit id="2a046b5db560b388e6036ac3267aa757fb6a290b" translate="yes" xml:space="preserve">
          <source>If your activity restarts while network operations are in-flight it can still receive the result of the download via its &lt;code&gt;onActivityResult&lt;/code&gt; method</source>
          <target state="translated">如果在进行网络操作时重新启动活动，它仍然可以通过其 &lt;code&gt;onActivityResult&lt;/code&gt; 方法接收下载结果</target>
        </trans-unit>
        <trans-unit id="e15056d48dc96cceb3b8adfa0b6afa8a93761934" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MainActivity.java&lt;/code&gt; file you can add this line within your &lt;code&gt;oncreate()&lt;/code&gt; method</source>
          <target state="translated">在 &lt;code&gt;MainActivity.java&lt;/code&gt; 文件中，您可以在 &lt;code&gt;oncreate()&lt;/code&gt; 方法中添加此行</target>
        </trans-unit>
        <trans-unit id="71d43b7713c727b57fbe7094e690f36b2fc0e79b" translate="yes" xml:space="preserve">
          <source>In order to use this library, include following lines into you build.gradle file:</source>
          <target state="translated">为了使用这个库,请在你的build.gradle文件中加入以下几行。</target>
        </trans-unit>
        <trans-unit id="26ea76e4dc2c3947e33f8929d580b2b84da19fd0" translate="yes" xml:space="preserve">
          <source>In simple words,</source>
          <target state="translated">简单来说。</target>
        </trans-unit>
        <trans-unit id="c68fcc4a48da4d9bb066c962a07aa865a403043c" translate="yes" xml:space="preserve">
          <source>In your class,</source>
          <target state="translated">在你的班上。</target>
        </trans-unit>
        <trans-unit id="bc9986636734c9c68a3582400c0c1e70c9517bb6" translate="yes" xml:space="preserve">
          <source>IntentService</source>
          <target state="translated">IntentService</target>
        </trans-unit>
        <trans-unit id="39086a3738cdb1e675d91ffd6a18e45c3ddb56df" translate="yes" xml:space="preserve">
          <source>Ion</source>
          <target state="translated">Ion</target>
        </trans-unit>
        <trans-unit id="8fd729c3ffbfedde4e87f47362d289b5f636e6aa" translate="yes" xml:space="preserve">
          <source>It's also &lt;strong&gt;asynchronous&lt;/strong&gt; and &lt;strong&gt;very simple&lt;/strong&gt; to use:</source>
          <target state="translated">它也是&lt;strong&gt;异步的&lt;/strong&gt; ，使用起来&lt;strong&gt;非常简单&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="06099f2fec31249cb21eb4300d48c7abbd4ef703" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt; or Android &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;</source>
          <target state="translated">Java &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;线程&lt;/a&gt;或Android &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4660eb26c020ec9c3e4d425dc30493f95c84d638" translate="yes" xml:space="preserve">
          <source>Java threads are one-time use only and die after executing its run method.</source>
          <target state="translated">Java线程仅是一次性使用,在执行其运行方法后死亡。</target>
        </trans-unit>
        <trans-unit id="814c7b03e508f3e0a9648d132455b778495c5224" translate="yes" xml:space="preserve">
          <source>JobScheduler</source>
          <target state="translated">JobScheduler</target>
        </trans-unit>
        <trans-unit id="73be87f53b04ab1f8ea8b228cfcce5293a0d74f9" translate="yes" xml:space="preserve">
          <source>Just to spell out something explicitly:</source>
          <target state="translated">只不过是为了明确地拼出一些东西。</target>
        </trans-unit>
        <trans-unit id="6a4683ba8ae8772b9e78f73379f3085027b12b73" translate="yes" xml:space="preserve">
          <source>Let's say you are building a social networking app and want to load profile pictures of friends.</source>
          <target state="translated">假设你正在构建一个社交网络应用,想加载朋友的个人资料图片。</target>
        </trans-unit>
        <trans-unit id="dc50a9c8519026fc7d2a73b9efa6707fdeec656e" translate="yes" xml:space="preserve">
          <source>Let's say you are writing an app that lets users track stock prices, interest rates and currecy exchange rates. You find an Json API that looks something like this:</source>
          <target state="translated">假设你正在编写一个应用程序,让用户跟踪股票价格、利率和汇率。你找到了一个Json API,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c6253b343e333576f0af8c4ca137ac64ae2731c3" translate="yes" xml:space="preserve">
          <source>Let's say you're building a &quot;mood weather&quot; app that looks up the users GPS location and checks the current temperature in that area and tells them the mood. This type of app doesn't need to declare API endpoints; it just needs to be able to access one API endpoint.</source>
          <target state="translated">假设你正在构建一个 &quot;心情天气 &quot;APP,它可以查询用户的GPS位置,并检查该地区的当前温度,然后告诉他们心情。这种类型的APP不需要声明API端点,它只需要能够访问一个API端点即可。</target>
        </trans-unit>
        <trans-unit id="4883643a020f221ba2797172ae9b3c377b171dd8" translate="yes" xml:space="preserve">
          <source>Library for composing asynchronous and event-based programs by using observable sequences.</source>
          <target state="translated">通过使用可观察序列组成异步和基于事件的程序库。</target>
        </trans-unit>
        <trans-unit id="899ac73a6083f167ed75688c407fb070197364cb" translate="yes" xml:space="preserve">
          <source>Load images via HTTP</source>
          <target state="translated">通过HTTP加载图像</target>
        </trans-unit>
        <trans-unit id="c3b214c33683df211b549e5700b95cdd66d3b83d" translate="yes" xml:space="preserve">
          <source>Make the sure the target version is the same as your Android Target Library. If you are unsure what your target library is, right click your Project -&amp;gt; &lt;em&gt;Build Path&lt;/em&gt; -&amp;gt; &lt;em&gt;Android&lt;/em&gt;, and it should be the one that is ticked.</source>
          <target state="translated">确保目标版本与您的Android目标库相同。 如果不确定目标库是什么，请右键单击Project-&amp;gt; &lt;em&gt;Build Path-&lt;/em&gt; &amp;gt; &lt;em&gt;Android&lt;/em&gt; ，然后将其选中。</target>
        </trans-unit>
        <trans-unit id="89d9c1212bd26944e5bb0d6c8ce9c682166910f2" translate="yes" xml:space="preserve">
          <source>More code and complexity than &lt;code&gt;AsyncTask&lt;/code&gt;, though not as much as you might think</source>
          <target state="translated">比 &lt;code&gt;AsyncTask&lt;/code&gt; 更多的代码和复杂性，尽管没有您想象的那么多</target>
        </trans-unit>
        <trans-unit id="2f48fd059f6bc28467ddae795715a3fb536ea1c5" translate="yes" xml:space="preserve">
          <source>Network-based operations cannot be run on the main thread. You need to run all network-based tasks on a child thread or implement AsyncTask.</source>
          <target state="translated">基于网络的操作不能在主线程上运行。你需要在子线程上运行所有基于网络的任务,或者实现AsyncTask。</target>
        </trans-unit>
        <trans-unit id="7fb028cbee17d753e6d7524bdde797301d411f5b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;Thread&lt;/code&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; solutions have been explained already.</source>
          <target state="translated">已经解释了新的 &lt;code&gt;Thread&lt;/code&gt; 和&lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt;解决方案。</target>
        </trans-unit>
        <trans-unit id="4bab309558426d69bab2e28eb64e803e2f6a2131" translate="yes" xml:space="preserve">
          <source>Note, that although it provides benefits of simplicity and readability, it has its disadvantages.</source>
          <target state="translated">需要注意的是,虽然它有简单易读的好处,但也有它的缺点。</target>
        </trans-unit>
        <trans-unit id="7f88a97b0c34d5718ab601409fe417bd53cecf73" translate="yes" xml:space="preserve">
          <source>On Android, network operations cannot be run on the main thread. You can use Thread, AsyncTask (short-running tasks), Service (long-running tasks) to do network operations.</source>
          <target state="translated">在Android上,网络操作不能在主线程上运行。你可以使用Thread、AsyncTask(短运行任务)、Service(长运行任务)来进行网络操作。</target>
        </trans-unit>
        <trans-unit id="bdb733ed08744b922dea36539e95fd5cf074ea0e" translate="yes" xml:space="preserve">
          <source>One off ReST API access</source>
          <target state="translated">一次性的ReST API访问</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="192d153574aac488f39d715ee21fa8a4487cfccc" translate="yes" xml:space="preserve">
          <source>Picasso</source>
          <target state="translated">Picasso</target>
        </trans-unit>
        <trans-unit id="f9cca0fedd9d170b5badb24177eb529a48426caa" translate="yes" xml:space="preserve">
          <source>Please read msysmilu's great answer (&lt;a href=&quot;https://stackoverflow.com/a/28559884/1024412&quot;&gt;https://stackoverflow.com/a/28559884/1024412&lt;/a&gt;)</source>
          <target state="translated">请阅读msysmilu的出色答案（ &lt;a href=&quot;https://stackoverflow.com/a/28559884/1024412&quot;&gt;https://stackoverflow.com/a/28559884/1024412&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="ce2d60a5ff51ab439ffcc37e3f3bd66bf7d24053" translate="yes" xml:space="preserve">
          <source>Pros of using this approach:</source>
          <target state="translated">使用这种方法的优点。</target>
        </trans-unit>
        <trans-unit id="500ceb00c409658dec4ebbf84c1a351a817c1a07" translate="yes" xml:space="preserve">
          <source>Put all your works inside</source>
          <target state="translated">把你的作品都放在里面</target>
        </trans-unit>
        <trans-unit id="375a6316c9d1e17d7f86e8583f483fbbee79699c" translate="yes" xml:space="preserve">
          <source>Put your code inside:</source>
          <target state="translated">把你的代码放在里面。</target>
        </trans-unit>
        <trans-unit id="5c038e53bc60ed29fa76b4c0946713801ee5078f" translate="yes" xml:space="preserve">
          <source>ReST over HTTP</source>
          <target state="translated">通过HTTP的ReST</target>
        </trans-unit>
        <trans-unit id="efa1f242533e35071a673f3eff5f95cb5cfd9446" translate="yes" xml:space="preserve">
          <source>Read more &lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot;&gt;在这里&lt;/a&gt; ， &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot;&gt;这里&lt;/a&gt; ， &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot;&gt;这里&lt;/a&gt; ， &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot;&gt;这里&lt;/a&gt;阅读更多</target>
        </trans-unit>
        <trans-unit id="4cf159978b8c1183c57af358ef850a8c7dced6ea" translate="yes" xml:space="preserve">
          <source>Retrofit from Square</source>
          <target state="translated">方形改造</target>
        </trans-unit>
        <trans-unit id="9d8037932b313796752a5be70857679320624a53" translate="yes" xml:space="preserve">
          <source>RxJava</source>
          <target state="translated">RxJava</target>
        </trans-unit>
        <trans-unit id="96fc516616ad1f0b758e4f5f657fc4b2635e5d6b" translate="yes" xml:space="preserve">
          <source>Sample code snippet, which address  &lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;</source>
          <target state="translated">示例代码段，解决了 &lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c611e5488820a251dc87fc1b9af0a580d1f066f" translate="yes" xml:space="preserve">
          <source>ScheduledThreadPoolExecutor - a class that extends ThreadPoolExecutor. It can schedule tasks after a given delay or periodically.</source>
          <target state="translated">ScheduledThreadPoolExecutor-一个扩展了ThreadPoolExecutor的类。它可以在给定的延迟后或周期性地安排任务。</target>
        </trans-unit>
        <trans-unit id="3121c971f8834f01d89c2cd9215b7a6521e178e4" translate="yes" xml:space="preserve">
          <source>See also Stack&amp;nbsp;Overflow question:</source>
          <target state="translated">另请参阅堆栈溢出问题：</target>
        </trans-unit>
        <trans-unit id="ac616df27cceb4363e0d7c50f345bf7f2f4a6daa" translate="yes" xml:space="preserve">
          <source>So saying that you cannot do networking operations in the main thread means you cannot do networking operations in the UI thread, which means &lt;em&gt;you cannot do networking operations in a &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; block&lt;/em&gt; inside some other thread, either.</source>
          <target state="translated">因此，说您无法在主线程中执行联网操作意味着您无法在UI线程中进行联网操作，这意味着&lt;em&gt;您无法在&lt;/em&gt;其他线程内&lt;em&gt;的 &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; 块中进行联网操作。&lt;/em&gt; ，或者。</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="93dbabbf585e6feb938b7d234bde90abcdd14abd" translate="yes" xml:space="preserve">
          <source>Step 1: Create an &lt;code&gt;IntentService&lt;/code&gt; to perform the download. You can tell it what to download via &lt;code&gt;Intent&lt;/code&gt; extra's, and pass it a &lt;code&gt;PendingIntent&lt;/code&gt; to use to return the result to the &lt;code&gt;Activity&lt;/code&gt;:</source>
          <target state="translated">步骤1：创建一个 &lt;code&gt;IntentService&lt;/code&gt; 来执行下载。 您可以通过 &lt;code&gt;Intent&lt;/code&gt; extra告诉它要下载什么，然后将 &lt;code&gt;PendingIntent&lt;/code&gt; 传递给它，以将结果返回给 &lt;code&gt;Activity&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="abed1497c74da9e76fa8d5cd93a82cf3110827b2" translate="yes" xml:space="preserve">
          <source>Step 2: Register the service in the manifest:</source>
          <target state="translated">第二步:在清单中注册服务。</target>
        </trans-unit>
        <trans-unit id="3111778701990db5c06de60bfbae8d24129dd35c" translate="yes" xml:space="preserve">
          <source>Step 3: Invoke the service from the Activity, passing a PendingResult object which the Service will use to return the result:</source>
          <target state="translated">步骤3:从Activity中调用服务,传递一个PendingResult对象,服务将使用该对象来返回结果。</target>
        </trans-unit>
        <trans-unit id="a3fe7bf7055a9a8288d543d002bb366a3cde45be" translate="yes" xml:space="preserve">
          <source>Step 4: Handle the result in onActivityResult:</source>
          <target state="translated">步骤4:在onActivityResult中处理结果。</target>
        </trans-unit>
        <trans-unit id="6bd9a85779c516e4bf76fbd5dd97142c9014f878" translate="yes" xml:space="preserve">
          <source>Submit &lt;code&gt;Runnable&lt;/code&gt; task to &lt;code&gt;Handler&lt;/code&gt;</source>
          <target state="translated">将可运行任务提交给 &lt;code&gt;Handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e027307bc2282959e28b51f486a3dec4ceb9254" translate="yes" xml:space="preserve">
          <source>The code for asynchronous execution will look like:</source>
          <target state="translated">异步执行的代码会是这样的。</target>
        </trans-unit>
        <trans-unit id="eaa902ef2c37a71b3debc3a6c7dd98ec442b927b" translate="yes" xml:space="preserve">
          <source>The device I was testing my app on was 4.1.2 which is SDK Version 16!</source>
          <target state="translated">我测试我的应用的设备是4.1.2,也就是SDK版本16!我的设备是4.1.2。</target>
        </trans-unit>
        <trans-unit id="90c709da0828c17eb07bb6cbd11170be6b6c9dcf" translate="yes" xml:space="preserve">
          <source>The error is due to executing long running operations in main thread,You can easily rectify the problem by using &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsynTask&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt;. You can checkout this library &lt;a href=&quot;http://loopj.com/android-async-http/&quot;&gt;AsyncHTTPClient&lt;/a&gt; for better handling.</source>
          <target state="translated">该错误是由于在主线程中执行了长时间运行的操作引起的，您可以使用&lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsynTask&lt;/a&gt;或&lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt;轻松纠正此问题。 您可以检出此库&lt;a href=&quot;http://loopj.com/android-async-http/&quot;&gt;AsyncHTTPClient&lt;/a&gt;以获得更好的处理。</target>
        </trans-unit>
        <trans-unit id="509bd62b6859aefedb8a08790c39ea7d788bc07b" translate="yes" xml:space="preserve">
          <source>The error is the SDK warning!</source>
          <target state="translated">错误是SDK警告!</target>
        </trans-unit>
        <trans-unit id="bde255414b3db3a3975218011dee6d7415381afe" translate="yes" xml:space="preserve">
          <source>The first verified answer advice is to use AsynTask. Yes, this is a solution, but it is obsolete nowadays, because there are new tools around.</source>
          <target state="translated">第一个验证过的答案建议是使用AsynTask。是的,这是一个解决方案,但现在已经过时了,因为周围有新的工具。</target>
        </trans-unit>
        <trans-unit id="b879a9d186dc8ea701a01ff123a00f8e80bd037a" translate="yes" xml:space="preserve">
          <source>The getUrl method provides the URL address, and it will be executed on the main thread.</source>
          <target state="translated">getUrl方法提供了URL地址,它将在主线程中执行。</target>
        </trans-unit>
        <trans-unit id="7191dfaf1027a52bf52254687dd971bf7015fa36" translate="yes" xml:space="preserve">
          <source>The last dependency includes support for the .mainThread() scheduler.</source>
          <target state="translated">最后一个依赖关系包括对.mainThread()调度器的支持。</target>
        </trans-unit>
        <trans-unit id="56596bfcc3f43fe44a848397f10abae85f9d2066" translate="yes" xml:space="preserve">
          <source>The main gist of it is, it makes asynchronous code looks so much like synchronous</source>
          <target state="translated">它的主要内容是,它使异步代码看起来和同步的代码很像。</target>
        </trans-unit>
        <trans-unit id="e9c820beb5de62480e58a526f8b0a3743b104313" translate="yes" xml:space="preserve">
          <source>The main thread is basically the UI thread.</source>
          <target state="translated">主线程基本上就是UI线程。</target>
        </trans-unit>
        <trans-unit id="f1fcd0cab8c92c43bbe8eb5e1592c3328484c109" translate="yes" xml:space="preserve">
          <source>The top &lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;answer of spektom&lt;/a&gt; works perfect.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;spektom&lt;/a&gt;的最高答案很完美。</target>
        </trans-unit>
        <trans-unit id="f172bda9b652708d323386b639603b2f3c88bbf9" translate="yes" xml:space="preserve">
          <source>There are many great answers already on this question, but a lot of great libraries have come out since those answers were posted. This is intended as a kind of newbie-guide.</source>
          <target state="translated">关于这个问题,已经有很多很好的答案了,但是自从贴出这些答案之后,已经有很多很好的文库出来了。这篇文章的目的是作为一种新手指南。</target>
        </trans-unit>
        <trans-unit id="d110a87147ffbd490a008785b463c8534b5e591b" translate="yes" xml:space="preserve">
          <source>There are some approaches that you should choose depends on the situation</source>
          <target state="translated">有一些方法,你应该根据情况来选择</target>
        </trans-unit>
        <trans-unit id="b7e491e20bd62c867abc2057820c912ee74e10ac" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;https://github.com/Froussios/Intro-To-RxJava&quot;&gt;an excellent ebook for rx-java&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Froussios/Intro-To-RxJava&quot;&gt;rx-java&lt;/a&gt;是一本非常出色的电子书 。</target>
        </trans-unit>
        <trans-unit id="a039c317ef0ae701432a0a12db84e1a4ba1b0ba0" translate="yes" xml:space="preserve">
          <source>There is an article about &lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot;&gt;Painless Threading&lt;/a&gt; on the Android developer site which is a good introduction to this, and it will provide you with a much better depth of an answer than can be realistically provided here.</source>
          <target state="translated">Android开发人员网站上有一篇有关&lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot;&gt;无痛线程&lt;/a&gt;的文章，对此进行了很好的介绍，它将为您提供比此处实际提供的更好的答案深度。</target>
        </trans-unit>
        <trans-unit id="3fc611ee945fbb14411bd1defea7711cf15c34c1" translate="yes" xml:space="preserve">
          <source>There is another very convenient way for tackling this issue - use rxJava's concurrency capabilities. You can execute any task in background and post results to main thread in a very convenient way, so these results will be handed to processing chain.</source>
          <target state="translated">还有一个非常方便的方法来解决这个问题--使用rxJava的并发能力。你可以在后台执行任何任务,并将结果发布到主线程,非常方便,所以这些结果会被交给处理链。</target>
        </trans-unit>
        <trans-unit id="b9e790485979a363e42824420e80ddba2e4e7e0e" translate="yes" xml:space="preserve">
          <source>This exception is thrown when an application attempts to perform a networking operation on its main thread. Run your code in &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;&lt;code&gt;AsyncTask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当应用程序尝试在其主线程上执行联网操作时，将引发此异常。 在&lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt; &lt;code&gt;AsyncTask&lt;/code&gt; 中&lt;/a&gt;运行代码：</target>
        </trans-unit>
        <trans-unit id="7e61419ec095b3e0c8a04ce19bcc29e670641603" translate="yes" xml:space="preserve">
          <source>This exception occurs due to any heavy task performed on the main thread if that performing task takes &lt;em&gt;too much time&lt;/em&gt;.</source>
          <target state="translated">如果执行该主任务花费&lt;em&gt;太多时间，&lt;/em&gt;则由于在主线程上执行了繁重的任务而发生此异常。</target>
        </trans-unit>
        <trans-unit id="ae9bbc3e827bacbe8c9e65dacbdc9305a970f7cf" translate="yes" xml:space="preserve">
          <source>This happens in Android 3.0 and above. From Android 3.0 and above, they have restricted using network operations (functions that access the Internet) from running in the main thread/UI thread (what spawns from your on create and on resume methods in the activity).</source>
          <target state="translated">这种情况发生在Android 3.0及以上版本中。从安卓3.0及以上版本开始,他们限制了使用网络操作(访问互联网的函数)在主线程UI线程中运行(从活动中的on-create和on-resume方法中产生的东西)。</target>
        </trans-unit>
        <trans-unit id="b24a15ca4e1ad78f5f37336bab3ef204f811b2f6" translate="yes" xml:space="preserve">
          <source>This is a great library for this type of access.</source>
          <target state="translated">这是一个很好的图书馆,适合这种类型的访问方式。</target>
        </trans-unit>
        <trans-unit id="644e86cdfa96466092b0882052163a5bcb511ba6" translate="yes" xml:space="preserve">
          <source>This is an excellent choice for an API with multiple endpoints and allows you to declare the ReST endpoints instead of having to code them individually as with other libraries like ion or Volley. (website: &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;)</source>
          <target state="translated">对于具有多个端点的API，这是一个绝佳的选择，它使您可以声明ReST端点，而不必像其他离子库或Volley库那样单独编码它们。 （网站： &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http&lt;/a&gt; : //square.github.io/retrofit/ ）</target>
        </trans-unit>
        <trans-unit id="6bb9642b33c5f9d15af7b7b29997bb23f83dd632" translate="yes" xml:space="preserve">
          <source>This is how you run a task in a child thread:</source>
          <target state="translated">这就是你如何在子线程中运行一个任务。</target>
        </trans-unit>
        <trans-unit id="db8ec763b72c4b6f4ae9ec7979abcde7a79f5202" translate="yes" xml:space="preserve">
          <source>This is only thrown for applications targeting the &lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; SDK or higher. Applications targeting earlier SDK versions are allowed to do networking on their main event loop threads.</source>
          <target state="translated">仅针对面向&lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; SDK或更高版本的应用程序会抛出此错误。 面向早期SDK版本的应用程序可以在其主事件循环线程上进行联网。</target>
        </trans-unit>
        <trans-unit id="57a6ff90d4f7875dcc221cf52bf70e6e5a98e004" translate="yes" xml:space="preserve">
          <source>This is the defacto choice for long running processing on Android, a good example would be to upload or download large files. The upload and download may continue even if the user exits the app and you certainly do not want to block the user from being able to use the app while these tasks are going on.</source>
          <target state="translated">这是安卓系统中长期运行处理的必选,一个很好的例子就是上传或下载大文件。即使用户退出应用,上传和下载也可能会继续进行,你当然不希望在这些任务进行时阻止用户使用应用。</target>
        </trans-unit>
        <trans-unit id="ce6ed2e5a386ab2774d21d153fe76e28e13a8976" translate="yes" xml:space="preserve">
          <source>This is to encourage using separate threads for network operations. See &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; for more details on how to perform network activities the right way.</source>
          <target state="translated">这是为了鼓励使用单独的线程进行网络操作。 有关如何正确执行网络活动的更多详细信息，请参见&lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="50f279e5caf39dbfd8787ba3feb2f7e961537d9a" translate="yes" xml:space="preserve">
          <source>This works. Just made Dr.Luiji's answer a little simpler.</source>
          <target state="translated">这个可以用了。只是把吕二博士的回答简单化了一点。</target>
        </trans-unit>
        <trans-unit id="f4a2cb9c490779e4a09391cee0744b207dd645de" translate="yes" xml:space="preserve">
          <source>Thread pool implementation &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html&quot;&gt;ThreadPoolExecutor&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html&quot;&gt;ScheduledThreadPoolExecutor&lt;/a&gt;...</source>
          <target state="translated">线程池实现&lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html&quot;&gt;ThreadPoolExecutor&lt;/a&gt; ， &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html&quot;&gt;ScheduledThreadPoolExecutor&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="a397a8fa1a53e47a761c3cfea578780e310949bd" translate="yes" xml:space="preserve">
          <source>ThreadPoolExecutor class that implements ExecutorService which gives fine control on the thread pool (Eg, core pool size, max pool size, keep alive time, etc.)</source>
          <target state="translated">ThreadPoolExecutor类,它实现了ExecutorService,可以对线程池进行精细控制(例如,核心池大小、最大池子大小、最大池子大小、保持时间等)。</target>
        </trans-unit>
        <trans-unit id="b6e1f519155ac4c025ed7a8bf4289234f321123a" translate="yes" xml:space="preserve">
          <source>To avoid this, we can handle it using &lt;strong&gt;threads&lt;/strong&gt; or &lt;strong&gt;executers&lt;/strong&gt;</source>
          <target state="translated">为了避免这种情况，我们可以使用&lt;strong&gt;线程&lt;/strong&gt;或&lt;strong&gt;执行程序&lt;/strong&gt;来处理它</target>
        </trans-unit>
        <trans-unit id="60d22d61692e90485ac3d60c7cd80e4d5fcfbb7d" translate="yes" xml:space="preserve">
          <source>To simplify all these things, Android provides various ways, like &lt;code&gt;AsyncTask&lt;/code&gt;, &lt;code&gt;AsyncTaskLoader&lt;/code&gt;, &lt;code&gt;CursorLoader&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt;. So you can use any of these according to your requirements.</source>
          <target state="translated">为了简化所有这些操作，Android提供了多种方式，例如 &lt;code&gt;AsyncTask&lt;/code&gt; ， &lt;code&gt;AsyncTaskLoader&lt;/code&gt; ， &lt;code&gt;CursorLoader&lt;/code&gt; 或 &lt;code&gt;IntentService&lt;/code&gt; 。 因此，您可以根据自己的需求使用任何一种。</target>
        </trans-unit>
        <trans-unit id="1ea76dcbe8be19acd8a1982a087841a064cfcd3e" translate="yes" xml:space="preserve">
          <source>Um, I can't think of any others right now actually</source>
          <target state="translated">嗯,我现在想不出来其他的人了</target>
        </trans-unit>
        <trans-unit id="97e015cdd6a1113db3a98e8adc5b707a183e653c" translate="yes" xml:space="preserve">
          <source>Up-sides:</source>
          <target state="translated">Up-sides:</target>
        </trans-unit>
        <trans-unit id="7599502cfa428edf5e093d7e32d931a81ddfe99b" translate="yes" xml:space="preserve">
          <source>Use Service or AsyncTask</source>
          <target state="translated">使用服务或AsyncTask</target>
        </trans-unit>
        <trans-unit id="b2408a92a8a7e813ddc8d1699d4e3afbe1cbd674" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://androidannotations.org/&quot;&gt;Android Annotations&lt;/a&gt; is an option. It will allow you to simply run any method in a background thread:</source>
          <target state="translated">选择使用&lt;a href=&quot;http://androidannotations.org/&quot;&gt;Android注释&lt;/a&gt; 。 它将允许您在后台线程中简单地运行任何方法：</target>
        </trans-unit>
        <trans-unit id="f80468404a516fbf71c2d620082f9ad0dca15acf" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Service&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt; instead, perhaps with a &lt;code&gt;PendingIntent&lt;/code&gt; to return the result via the Activity's &lt;code&gt;onActivityResult&lt;/code&gt; method.</source>
          <target state="translated">而是使用 &lt;code&gt;Service&lt;/code&gt; 或 &lt;code&gt;IntentService&lt;/code&gt; ，或者使用 &lt;code&gt;PendingIntent&lt;/code&gt; 通过Activity的 &lt;code&gt;onActivityResult&lt;/code&gt; 方法返回结果。</target>
        </trans-unit>
        <trans-unit id="9f70e533db0150c260360b33e601c8514945d241" translate="yes" xml:space="preserve">
          <source>Using a library that does a nice job of this for you - there's a nice comparison of networking libs in &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;this question&lt;/a&gt;, or</source>
          <target state="translated">使用一个可以为您做得很好的库- &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;这个问题&lt;/a&gt;中网络库的比较不错，或者</target>
        </trans-unit>
        <trans-unit id="f095116f2fdd9535d80b88a6474753f6005d3446" translate="yes" xml:space="preserve">
          <source>Volley</source>
          <target state="translated">Volley</target>
        </trans-unit>
        <trans-unit id="1be565163d1d67c36d081e6e9ed9c89deb07ebcb" translate="yes" xml:space="preserve">
          <source>Volley requires more setup than Retrofit. You will need to create a class like this to setup a RequestQueue, an ImageLoader and an ImageCache, but it's not too bad:</source>
          <target state="translated">Volley比Retrofit需要更多的设置。你需要创建一个像这样的类来设置一个RequestQueueue,一个ImageLoader和ImageCache,但也不会太差。</target>
        </trans-unit>
        <trans-unit id="7c0d1456a9e7d9083aa28ea885a7246ebbbd8391" translate="yes" xml:space="preserve">
          <source>When you get something from Network response and want to show it on your view (like display response message in TextView), you need to &lt;strong&gt;return back to the UI&lt;/strong&gt; thread.</source>
          <target state="translated">当您从&amp;ldquo;网络&amp;rdquo;响应中获取某些内容并希望在视图中显示它时（例如TextView中的显示响应消息），您需要&lt;strong&gt;返回到UI&lt;/strong&gt;线程。</target>
        </trans-unit>
        <trans-unit id="9425da95831da82358ab97098eda19da644c187a" translate="yes" xml:space="preserve">
          <source>While using AsyncTask, update view from &lt;code&gt;onPostExecute()&lt;/code&gt; method</source>
          <target state="translated">使用AsyncTask时，通过 &lt;code&gt;onPostExecute()&lt;/code&gt; 方法更新视图</target>
        </trans-unit>
        <trans-unit id="3ced8911fbbe92b803208da3ca154b423d4a6c20" translate="yes" xml:space="preserve">
          <source>Will queue requests and run them on a &lt;em&gt;single&lt;/em&gt; background thread. You can easily control this by replacing &lt;code&gt;IntentService&lt;/code&gt; with an equivalent &lt;code&gt;Service&lt;/code&gt; implementation, perhaps like &lt;a href=&quot;https://github.com/steveliles/AsyncAndroid/blob/master/AsyncAndroid/src/main/java/com/packt/asyncandroid/chapter6/ConcurrentIntentService.java&quot;&gt;this one&lt;/a&gt;.</source>
          <target state="translated">将请求排队并在&lt;em&gt;单个&lt;/em&gt;后台线程上运行它们。 您可以通过用等效的 &lt;code&gt;Service&lt;/code&gt; 实现替换 &lt;code&gt;IntentService&lt;/code&gt; 来轻松地控制此操作，也许像&lt;a href=&quot;https://github.com/steveliles/AsyncAndroid/blob/master/AsyncAndroid/src/main/java/com/packt/asyncandroid/chapter6/ConcurrentIntentService.java&quot;&gt;这样&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5135659d0e8bd5f46b02613bfbcc4a0c825fd97d" translate="yes" xml:space="preserve">
          <source>You are able to move a part of your code into another thread to offload the &lt;code&gt;main thread&lt;/code&gt; and avoid getting &lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot;&gt;ANR&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;NetworkOnMainThreadException&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot;&gt;IllegalStateException&lt;/a&gt;(e.g. Cannot access database on the main thread since it may potentially lock the UI for a long period of time).</source>
          <target state="translated">您可以将代码的一部分移到另一个线程中以减轻 &lt;code&gt;main thread&lt;/code&gt; 负担，并避免获取&lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot;&gt;ANR&lt;/a&gt; ， &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;NetworkOnMainThreadException&lt;/a&gt; ， &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot;&gt;IllegalStateException&lt;/a&gt; （例如，无法访问主线程上的数据库，因为它可能长时间锁定UI）。</target>
        </trans-unit>
        <trans-unit id="1dcb961afecc7ed4f8ff92e83e462e2977fc4e8c" translate="yes" xml:space="preserve">
          <source>You can implement an &lt;code&gt;IntentService&lt;/code&gt; to perform downloads on a single background thread quite easily.</source>
          <target state="translated">您可以实现 &lt;code&gt;IntentService&lt;/code&gt; ,以非常容易地在单个后台线程上执行下载。</target>
        </trans-unit>
        <trans-unit id="1d25b678f66da4756ee3210eff3be9f55bc5d1b1" translate="yes" xml:space="preserve">
          <source>You cannot perform network &lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot;&gt;I/O&lt;/a&gt; on the UI thread on &lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt;. Technically, it &lt;em&gt;is&lt;/em&gt; possible on earlier versions of Android, but it is a really bad idea as it will cause your app to stop responding, and can result in the OS killing your app for being badly behaved. You'll need to run a background process or use AsyncTask to perform your network transaction on a background thread.</source>
          <target state="translated">您不能在&lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt;的UI线程上执行网络&lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot;&gt;I / O。&lt;/a&gt; 从技术上讲，可以在较早的Android版本上使用，但这是一个非常糟糕的主意，因为它将导致您的应用停止响应，并可能导致操作系统因行为不当而杀死您的应用。 您将需要运行后台进程或使用AsyncTask在后台线程上执行网络事务。</target>
        </trans-unit>
        <trans-unit id="423211d4e7a3631585c5340a517f60b555795410" translate="yes" xml:space="preserve">
          <source>You disable the strict mode using following code:</source>
          <target state="translated">你可以使用以下代码禁用严格模式。</target>
        </trans-unit>
        <trans-unit id="4085af883abb5e100e006893abefcf0b463ef524" translate="yes" xml:space="preserve">
          <source>You have to create a new Thread</source>
          <target state="translated">你必须创建一个新的线程</target>
        </trans-unit>
        <trans-unit id="d5a644a2460626c071917f71454f3652fc2ea29e" translate="yes" xml:space="preserve">
          <source>You should not do any time-consuming task on the main thread (UI thread), like any network operation, file I/O, or SQLite database operations. So for this kind of operation, you should create a worker thread, but the problem is that you can not directly perform any UI related operation from your worker thread. For that, you have to use &lt;code&gt;Handler&lt;/code&gt; and pass the &lt;code&gt;Message&lt;/code&gt;.</source>
          <target state="translated">您不应在主线程（UI线程）上执行任何耗时的任务，例如任何网络操作，文件I / O或SQLite数据库操作。 因此，对于这种操作，您应该创建一个工作线程，但是问题是您不能直接从工作线程执行任何与UI相关的操作。 为此，您必须使用 &lt;code&gt;Handler&lt;/code&gt; 并传递 &lt;code&gt;Message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="418695ed454c9db825cf329eb6f7fd3f653d0bb5" translate="yes" xml:space="preserve">
          <source>Your app will (in areas of spotty internet connection) become unresponsive and lock up, the user perceives slowness and has to do a force kill, and you risk the activity manager killing your app and telling the user that the app has stopped.</source>
          <target state="translated">你的APP会(在网络连接不畅的地区)变得没有反应并锁死,用户感知到速度慢,不得不进行强杀,而你就会冒着活动管理器杀死你的APP并告诉用户APP已经停止的风险。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="7f628363b72ea19e08f323f2bc74538e842171c1" translate="yes" xml:space="preserve">
          <source>makeCallParseResponse(..) - does actual work</source>
          <target state="translated">makeCallParseResponse(...)-做实际工作</target>
        </trans-unit>
        <trans-unit id="662231f30478ae40839ba8099ae853a863ad85ee" translate="yes" xml:space="preserve">
          <source>processResponse(..) - will handle result on main thread.</source>
          <target state="translated">processResponse(.)-将在主线程上处理结果。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
