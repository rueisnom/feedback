<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/6343166">
    <body>
      <group id="6343166">
        <trans-unit id="e701d4f4ca8a7c0ce3eea20ba70d6bce670254b5" translate="yes" xml:space="preserve">
          <source>(From his example.)</source>
          <target state="translated">(그의 예에서)</target>
        </trans-unit>
        <trans-unit id="caeb8c4daf10a7a29d60ebe7f726b5e6be1ea726" translate="yes" xml:space="preserve">
          <source>(I just had a long head-scratching moment trying to figure out why I was getting that error somewhere other than my main thread.  This was why; this thread helped; and hopefully this comment will help someone else.)</source>
          <target state="translated">(주요 스레드가 아닌 다른 곳에서 오류가 발생하는 이유를 알아 내려고하는 데 오랜 시간이 걸렸습니다.이 이유는이 스레드가 도움이 되었으며이 의견이 다른 사람에게 도움이되기를 바랍니다.)</target>
        </trans-unit>
        <trans-unit id="6a8088732944db5eec3c539530a0513e5fcc6250" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;Coroutines&lt;/a&gt; (Kotlin)</source>
          <target state="translated">코 &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;루틴&lt;/a&gt; (코 틀린)</target>
        </trans-unit>
        <trans-unit id="513a168553003f07d278a92713bcaebee5d17d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AsyncTask&lt;/code&gt; should ideally be used for short operations. Normal &lt;code&gt;Thread&lt;/code&gt; is not preferable for Android.</source>
          <target state="translated">짧은 작업에는 &lt;code&gt;AsyncTask&lt;/code&gt; 를 사용하는 것이 이상적입니다. 안드로이드에는 일반 &lt;code&gt;Thread&lt;/code&gt; 가 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7974727712da83599bfb8e8c238a6155c2f8ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RxAndroid&lt;/code&gt; is another better alternative to this problem and it saves us from hassles of creating threads and then posting results on Android UI thread.
We just need to specify threads on which tasks need to be executed and everything is handled internally.</source>
          <target state="translated">&lt;code&gt;RxAndroid&lt;/code&gt; 는이 문제에 대한 또 다른 좋은 대안이며 스레드를 생성 한 다음 Android UI 스레드에 결과를 게시하는 번거 로움을 덜어줍니다. 작업을 실행해야하는 스레드를 지정하면 모든 것이 내부적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="219b997bdcfa0046d264cf94a2386888ac6a5147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run()&lt;/code&gt; method of new thread</source>
          <target state="translated">새 스레드의 &lt;code&gt;run()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="f5bbd6621b1e09056a5aa357275ada0230e4428b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;android.os.NetworkOnMainThreadException sending an email from Android&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;android.os.NetworkOnMainThreadException 안드로이드에서 이메일을 보내는 중&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a25f771710bd8cde3227bd7972908fe47b297297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If your API requires an API Key or other header like a user token, etc. to be sent, Retrofit makes this easy (see this awesome answer for details: &lt;a href=&quot;https://stackoverflow.com/a/42899766/1024412&quot;&gt;https://stackoverflow.com/a/42899766/1024412&lt;/a&gt;).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;API에 API 키 또는 사용자 토큰 등의 다른 헤더를 보내야하는 경우 Retrofit을 사용하면이를 쉽게 수행 할 수 있습니다 (자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/a/42899766/1024412&quot;&gt;https://stackoverflow.com/a/42899766/1024412&lt;/a&gt; ).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66961741ec9c0e83379baa24fc592717dcc9315e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation summary&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;구현 요약&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9c0c6f046f93218df6678063b471e792fb5e535" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IntentService approach&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IntentService 접근&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2397d3757b8d169d35c47aa969de6541d61d5ec6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Typically Json, can be XML or something else&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;일반적으로 Json은 XML 또는 다른 것일 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dad356866e8f659fd325b891f3ebcdd63e20966" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Volley can also be used for ReST APIs, but due to the more complicated setup required I prefer to use Retrofit from Square as above (&lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;발리는 ReST API에도 사용할 수 있지만 더 복잡한 설정이 필요하기 때문에 위와 같이 Square에서 Retrofit을 사용하는 것을 선호합니다 ( &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="25e62674da40cc91ecdb9eecd1fc280c9eaea2b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AsyncTask&lt;/strong&gt; is designed to be a helper class around &lt;strong&gt;Thread&lt;/strong&gt; and &lt;strong&gt;Handler&lt;/strong&gt; and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as &lt;strong&gt;Executor&lt;/strong&gt;, &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt; and &lt;strong&gt;FutureTask&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;AsyncTask&lt;/strong&gt; 는 &lt;strong&gt;Thread&lt;/strong&gt; and &lt;strong&gt;Handler에&lt;/strong&gt; 대한 도우미 클래스로 설계되었으며 일반적인 스레딩 프레임 워크를 구성하지 않습니다. AsyncTasks는 짧은 작업 (최대 몇 초)에 이상적으로 사용되어야합니다. 스레드를 장기간 계속 실행해야하는 경우 java.util.concurrent 패키지에서 제공하는 다양한 API를 사용하는 것이 좋습니다. &lt;strong&gt;Executor&lt;/strong&gt; , &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt; 및 &lt;strong&gt;FutureTask&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6598d2b45c7dbf80276bd511c505bc2857a99510" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;But:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2133e68d566fe49c20988cfcce2bbb99801d6de7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DO NOT DO NETWORK WORK IN THE UI THREAD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UI 스레드에서 네트워크 작업을 수행하지 마십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917cfe5738a6f66768d1da4e53af3171e558b3b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesApi.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesApi.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3021948f153e7007373ef5242b6d203511d5ce09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesApiBuilder&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesApiBuilder&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0ff55b5e14dbd360ec6c31743a34c3290cc49a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesFragment snippet&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;재무 스 니펫&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="567a81632d5511eb02ee4b8419137a833a82dc57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Handler:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Handler:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fff1888f36aaf72cc2080185fe1f5f2683cc4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HandlerThread&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HandlerThread&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="384422180405859aa2748fcda32661c85100c51d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떻게?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c63a5cc621c4c365b35d0d44621b19b36fdf48e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ImageFetch.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ImageFetch.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a5ed542bf2a3a24445892b08dd385084f2f581b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt; call &lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt;&lt;code&gt;runOnUiThread()&lt;/code&gt;&lt;/a&gt; method and update view inside the &lt;code&gt;run()&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;또는&lt;/strong&gt; &lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt; &lt;code&gt;runOnUiThread()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하고 &lt;code&gt;run()&lt;/code&gt; 메소드 내에서 뷰를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="5eb9692511a9440615e36334fff23221552c6401" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt; use &lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot;&gt;AsyncTask class&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;또는&lt;/strong&gt; &lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot;&gt;AsyncTask 클래스를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a7ef528060d56c8515b79d85a46d420cd9ce1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt;&lt;code&gt;doInBackground()&lt;/code&gt; method of AsyncTask class.</source>
          <target state="translated">&lt;strong&gt;또는&lt;/strong&gt; AsyncTask 클래스의 &lt;code&gt;doInBackground()&lt;/code&gt; 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="49c900ba5a0475e269165d778322be2846b3c474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solution:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b38b4c4100e627a7e6c087c8e21cfdf4ed6d3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The accepted answer has some significant down-sides. It is not advisable to use AsyncTask for networking unless you &lt;em&gt;really&lt;/em&gt; know what you are doing. Some of the down-sides include:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;허용되는 답변에는 몇 가지 중요한 단점이 있습니다.&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;실제로&lt;/em&gt; 수행중인 작업을 모르는 경우 네트워킹에 AsyncTask를 사용하지 않는 것이 좋습니다.&lt;/strong&gt; &lt;strong&gt;단점 중 일부는 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19b5e9d0ddf1bdb5d05bf7202e0f6fa71a0a776f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is not recommended&lt;/strong&gt;: use the &lt;code&gt;AsyncTask&lt;/code&gt; interface.</source>
          <target state="translated">&lt;strong&gt;권장하지 않습니다&lt;/strong&gt; : &lt;code&gt;AsyncTask&lt;/code&gt; 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e20c836962bfca05fb50974e95a20a24b1359cc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this in Your Activity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;당신의 활동에 이것을 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7336c3aa8ca565418a4c68252e36d2812c114c54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UserViewDialog.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UserViewDialog.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8765d8046996c6e90e70fcf4c30238fcf731d749" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Way:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06e4b3f8e199aed94f3f2f897dfb806c1caa237a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You should almost always run network operations on a thread or as an asynchronous task.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;거의 항상 스레드에서 또는 비동기 작업으로 네트워크 작업을 실행해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a36ba63f51ccfca556458e8a4cce314f801ac29c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;build.gradle&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;build.gradle&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2ec3ef457076fbfc6654a12bcb37263fdb07109" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;user_view_dialog.xml&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;user_view_dialog.xml&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87f2e56db8589458e7fa17b650e754fb55204d75" translate="yes" xml:space="preserve">
          <source>A Github project containing a complete working Android-Studio/Gradle project is available &lt;a href=&quot;https://github.com/steveliles/Android-Download-Service-Example&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">완벽하게 작동하는 Android-Studio / Gradle 프로젝트가 포함 된 Github 프로젝트는 &lt;a href=&quot;https://github.com/steveliles/Android-Download-Service-Example&quot;&gt;여기에서&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24f7c8831f32f043122b170cd7a35bd2b8eb3ad6" translate="yes" xml:space="preserve">
          <source>A Handler allows you to send and process Message and Runnable objects associated with a thread's MessageQueue. Each Handler instance is associated with a single thread and that thread's message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</source>
          <target state="translated">핸들러를 사용하면 스레드의 MessageQueue와 관련된 Message 및 Runnable 객체를 보내고 처리 할 수 ​​있습니다. 각 핸들러 인스턴스는 단일 스레드 및 해당 스레드의 메시지 큐와 연관됩니다. 새 처리기를 만들면 처리기를 만드는 스레드의 스레드 / 메시지 큐에 바인딩됩니다. 이때부터 메시지와 실행 파일을 해당 메시지 큐로 전달하고 메시지에서 나올 때 실행합니다. 열.</target>
        </trans-unit>
        <trans-unit id="62525e1302249317dc097de933bbafd11fd21100" translate="yes" xml:space="preserve">
          <source>ADD this permission in android manifest.xml file: &amp;nbsp; &amp;nbsp;</source>
          <target state="translated">android manifest.xml 파일에서이 권한을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ffae741742565dee96ff975c416b8d353112e510" translate="yes" xml:space="preserve">
          <source>Accessing network resources from the main (UI) thread cause this exception. Use a separate thread or AsyncTask for accessing a network resource to avoid this problem.</source>
          <target state="translated">기본 (UI) 스레드에서 네트워크 리소스에 액세스하면이 예외가 발생합니다. 이 문제를 피하려면 네트워크 리소스에 액세스하기 위해 별도의 스레드 또는 AsyncTask를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f0d0881b6e43f09d81175d22f7987bf0d1221b8" translate="yes" xml:space="preserve">
          <source>Add the following code to the onCreate method (Fragment, Activity) or the constructor (Dialog):</source>
          <target state="translated">다음 코드를 onCreate 메소드 (Fragment, Activity) 또는 생성자 (Dialog)에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9112f4dc99cf0253e3029c2c006685defa6b5de6" translate="yes" xml:space="preserve">
          <source>Add the following to your layout xml file to add an image:</source>
          <target state="translated">이미지를 추가하려면 레이아웃 xml 파일에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5742348ab2679838340e69e8e774beee58abe587" translate="yes" xml:space="preserve">
          <source>Add these lines to your Module level buid.gradle:</source>
          <target state="translated">모듈 레벨 buid.gradle에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9d9bc4c443ca7664f0308a3d6d6f85d72ac6a70c" translate="yes" xml:space="preserve">
          <source>Add this line to your Module level buid.gradle:</source>
          <target state="translated">이 줄을 모듈 레벨 buid.gradle에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c37195fe791a6d5ae7aa1680ddbf075189eb46ce" translate="yes" xml:space="preserve">
          <source>Add:</source>
          <target state="translated">Add:</target>
        </trans-unit>
        <trans-unit id="c9416697ac321c85343ea7b82034f38ccdbc1a49" translate="yes" xml:space="preserve">
          <source>Also, as others have mentioned, include the correct permissions to access the Internet:</source>
          <target state="translated">또한 다른 사람들이 언급했듯이 인터넷에 액세스 할 수있는 올바른 권한을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="85eb254309b9817b59cbdf1521ae57f2fd9bdd4a" translate="yes" xml:space="preserve">
          <source>Although above there is a huge solution pool, no one mentioned &lt;code&gt;com.koushikdutta.ion&lt;/code&gt;: &lt;a href=&quot;https://github.com/koush/ion&quot;&gt;https://github.com/koush/ion&lt;/a&gt;</source>
          <target state="translated">위에 거대한 솔루션 풀이 있지만 아무도 &lt;code&gt;com.koushikdutta.ion&lt;/code&gt; 을 언급하지 않았습니다 : &lt;a href=&quot;https://github.com/koush/ion&quot;&gt;https://github.com/koush/ion&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="865822065fcdc4d56fd5b2c5554b3da425ee6b15" translate="yes" xml:space="preserve">
          <source>And add this to AndroidManifest.xml</source>
          <target state="translated">그리고 이것을 AndroidManifest.xml에 추가하십시오</target>
        </trans-unit>
        <trans-unit id="d9e37bccfa0b1f88f4e499362fd7307daaa603e6" translate="yes" xml:space="preserve">
          <source>And it shows the below error:</source>
          <target state="translated">그리고 아래 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa6edcdeef0ba2e24b13161c844dedc283e5d95" translate="yes" xml:space="preserve">
          <source>Android has some good tips on good programming practices to design for responsiveness:
&lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&lt;/a&gt;</source>
          <target state="translated">안드로이드는 반응 형 디자인을위한 훌륭한 프로그래밍 실습에 대한 유용한 팁을 제공합니다 : &lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69e8f859c636329f43322ad40ceb48e0db6287be" translate="yes" xml:space="preserve">
          <source>Another excellent library from Square. Please see the site for some great examples: &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;http://square.github.io/picasso/&lt;/a&gt;</source>
          <target state="translated">Square의 또 다른 훌륭한 도서관. 좋은 예를 보려면 사이트를 참조하십시오 : &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;http://square.github.io/picasso/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="691706e7fa4ef71a62183103fde8d93a8e51cc9e" translate="yes" xml:space="preserve">
          <source>AsyncTask</source>
          <target state="translated">AsyncTask</target>
        </trans-unit>
        <trans-unit id="1e93f9e0b4644967ae582a89cc56cc92b5d29f7e" translate="yes" xml:space="preserve">
          <source>AsyncTask has different execution characteristics depending on the platform it executes on: prior to API level 4 AsyncTasks execute serially on a single background thread; from API level 4 through API level 10, AsyncTasks execute on a pool of up to 128 threads; from API level 11 onwards AsyncTask executes serially on a single background thread (unless you use the overloaded &lt;code&gt;executeOnExecutor&lt;/code&gt; method and supply an alternative executor). Code that works fine when running serially on ICS may break when executed concurrently on Gingerbread, say if you have inadvertent order-of-execution dependencies.</source>
          <target state="translated">AsyncTask는 실행하는 플랫폼에 따라 다른 실행 특성을 갖습니다. API 레벨 4 이전의 AsyncTask는 단일 백그라운드 스레드에서 직렬로 실행됩니다. API 레벨 4에서 API 레벨 10까지 AsyncTasks는 최대 128 개의 스레드 풀에서 실행됩니다. API 레벨 11부터 AsyncTask는 단일 백그라운드 스레드에서 직렬로 실행됩니다 (오버로드 된 &lt;code&gt;executeOnExecutor&lt;/code&gt; 메소드를 사용하고 대체 실행 프로그램을 제공하지 않는 한). ICS에서 직렬로 실행할 때 정상적으로 작동하는 코드는 Gingerbread에서 동시에 실행될 때 작동하지 않을 수 있습니다 (예 : 부주의 한 실행 순서 종속성이있는 경우).</target>
        </trans-unit>
        <trans-unit id="44013bbe71b1fbd1c9a2d927a1c92b80870d6c88" translate="yes" xml:space="preserve">
          <source>AsyncTask's created as non-static inner classes have an implicit reference to the enclosing Activity object, its context, and the entire View hierarchy created by that activity. This reference prevents the Activity from being garbage collected until the AsyncTask's background work completes. If the user's connection is slow, and/or the download is large, these short-term memory leaks can become a problem - for example, if the orientation changes several times (and you don't cancel the executing tasks), or the user navigates away from the Activity.</source>
          <target state="translated">정적이 아닌 내부 클래스로 생성 된 AsyncTask는 둘러싸는 Activity 객체, 해당 컨텍스트 및 해당 활동에 의해 생성 된 전체 View 계층 구조에 대한 암시 적 참조를 갖습니다. 이 참조는 AsyncTask의 백그라운드 작업이 완료 될 때까지 Activity가 가비지 수집되지 않도록합니다. 사용자의 연결 속도가 느리거나 다운로드가 큰 경우 이러한 단기 메모리 누수는 문제가 될 수 있습니다. 예를 들어 방향이 여러 번 변경되거나 실행중인 작업을 취소하지 않은 경우 또는 사용자 활동에서 멀리 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4230b18c8bff24b31dcc1e2e960671cd033ff07c" translate="yes" xml:space="preserve">
          <source>AsyncTaskLoaders</source>
          <target state="translated">AsyncTaskLoaders</target>
        </trans-unit>
        <trans-unit id="cb8b3ce6e66e52a12f5f2c0ad7e5094bda40b6b3" translate="yes" xml:space="preserve">
          <source>AsyncTaskLoaders as they solve a lot of problems that are inherent to AsyncTask</source>
          <target state="translated">AsyncTaskLoader는 AsyncTask 고유의 많은 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="275453a59ed88313d5d9db057a22bc44e738b318" translate="yes" xml:space="preserve">
          <source>Avoids the short-term memory leak problem</source>
          <target state="translated">단기 메모리 누수 문제 방지</target>
        </trans-unit>
        <trans-unit id="318b3c70e158fa010b651f670e102419f34b2b6f" translate="yes" xml:space="preserve">
          <source>Better platform than AsyncTask to build and re-use robust networking code. Example: if you need to do an important upload, you could do it from &lt;code&gt;AsyncTask&lt;/code&gt; in an &lt;code&gt;Activity&lt;/code&gt;, but if the user context-switches out of the app to take a phone call, the system &lt;em&gt;may&lt;/em&gt; kill the app before the upload completes. It is &lt;em&gt;less likely&lt;/em&gt; to kill an application with an active &lt;code&gt;Service&lt;/code&gt;.</source>
          <target state="translated">강력한 네트워킹 코드를 빌드하고 재사용하기 위해 AsyncTask보다 나은 플랫폼. 예 : 중요한 업로드를 수행해야하는 경우 &lt;code&gt;Activity&lt;/code&gt; 의 &lt;code&gt;AsyncTask&lt;/code&gt; 에서 수행 할 수 있지만 사용자가 앱에서 컨텍스트를 전환하여 전화를 걸면 업로드가 완료되기 전에 시스템에서 앱이 종료 &lt;em&gt;될 수 있습니다&lt;/em&gt; . 활성 &lt;code&gt;Service&lt;/code&gt; 응용 프로그램을 종료 &lt;em&gt;할 가능성&lt;/em&gt; 은 &lt;em&gt;적습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b5c54e0601a5de1de7c93e6b3cb6840ff964a55c" translate="yes" xml:space="preserve">
          <source>But it &lt;em&gt;is&lt;/em&gt; possible to remove this restriction and you override the default behavior, if you are willing to accept the consequences.</source>
          <target state="translated">그러나이 제한을 제거 할 수 있으며 결과를 기꺼이 받아들이려는 경우 기본 동작을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e1ccca981ca2cf568f35c92e2a96024f1c0ae2f4" translate="yes" xml:space="preserve">
          <source>By specifiying &lt;code&gt;(Schedulers.io())&lt;/code&gt;,RxAndroid will run &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt;  on a different thread.</source>
          <target state="translated">&lt;code&gt;(Schedulers.io())&lt;/code&gt; 을 지정하면 RxAndroid는 다른 스레드에서 &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt; 를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a733d96f50669ee3a024320dba52c76ffd9916c0" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; we want to observe this Observable on the UI thread, i.e. we want our &lt;code&gt;onNext()&lt;/code&gt; callback to be called on the UI thread</source>
          <target state="translated">&lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; 를 사용하여 UI 스레드에서이 Observable을 관찰하려고합니다. 즉, UI 스레드에서 &lt;code&gt;onNext()&lt;/code&gt; 콜백을 호출하려고합니다.</target>
        </trans-unit>
        <trans-unit id="23e6e1c1aa426e5d7b44c38ea48e5aa37c66bf86" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start()&lt;/code&gt; on &lt;code&gt;HandlerThread&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HandlerThread&lt;/code&gt; 에서 &lt;code&gt;start()&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="697e05789b1e07993024a18e40db15c1604fdedb" translate="yes" xml:space="preserve">
          <source>Compared to AsyncTask, this method allow to switch schedulers an arbitrary number of times (say, fetch data on one scheduler and process those data on another (say, Scheduler.computation()). You can also define you own schedulers.</source>
          <target state="translated">AsyncTask와 비교하여이 메소드를 사용하면 스케줄러를 임의의 횟수로 전환 할 수 있습니다 (예 : 한 스케줄러에서 데이터를 페치하고 다른 스케줄러에서 해당 데이터를 처리합니다 (예 : Scheduler.computation ()). 또한 자신의 스케줄러를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf92671c951691565d7070c7723f7d16bbef6c3" translate="yes" xml:space="preserve">
          <source>Consequences:</source>
          <target state="translated">Consequences:</target>
        </trans-unit>
        <trans-unit id="cf1695909bd06b7d1535f7582f28ae658753161b" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;Handler&lt;/code&gt; by getting &lt;code&gt;Looper&lt;/code&gt; from &lt;code&gt;HanlerThread&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HanlerThread&lt;/code&gt; 에서 &lt;code&gt;Looper&lt;/code&gt; 를 가져 와서 &lt;code&gt;Handler&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="012ed6c6f98adc741cd31875bdd78e842bc6cd35" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;HandlerThread&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HandlerThread&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="9bd53b66ee3417ce806db059b05f3982150b67fa" translate="yes" xml:space="preserve">
          <source>Creating new &lt;code&gt;Thread/AsyncTask&lt;/code&gt; for each network operation is expensive. The &lt;code&gt;Thread/AsyncTask&lt;/code&gt; will be destroyed and re-created for next Network operations. But with &lt;code&gt;Handler&lt;/code&gt; and &lt;code&gt;HandlerThread&lt;/code&gt; approach, you can submit many network operations (as Runnable tasks) to single &lt;code&gt;HandlerThread&lt;/code&gt; by using &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">각 네트워크 작업에 대해 새 &lt;code&gt;Thread/AsyncTask&lt;/code&gt; 를 만드는 것은 비용이 많이 듭니다. 다음 네트워크 작업을 위해 &lt;code&gt;Thread/AsyncTask&lt;/code&gt; 가 삭제되고 다시 생성됩니다. 그러나 &lt;code&gt;Handler&lt;/code&gt; 및 &lt;code&gt;HandlerThread&lt;/code&gt; 접근 방식을 사용하면 &lt;code&gt;Handler&lt;/code&gt; 를 사용하여 많은 네트워크 작업 (실행 가능한 작업으로)을 단일 &lt;code&gt;HandlerThread&lt;/code&gt; 에 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a59664e1f5103a439fc80adc7a71c7e98484c6" translate="yes" xml:space="preserve">
          <source>Do not change SDK version</source>
          <target state="translated">SDK 버전을 변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e0837fad2f0ae614b0356de69abcb486a696a8f6" translate="yes" xml:space="preserve">
          <source>Do not use a separate thread</source>
          <target state="translated">별도의 스레드를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="53f06da8f50dcab7efb7d76184f7462ed8af7c53" translate="yes" xml:space="preserve">
          <source>Do not use strictMode (only in debug mode)</source>
          <target state="translated">strictMode를 사용하지 마십시오 (디버그 모드에서만)</target>
        </trans-unit>
        <trans-unit id="502135fc6b53e36e0d9d4eaaa28073a23ea96be7" translate="yes" xml:space="preserve">
          <source>Do the network actions on another thread</source>
          <target state="translated">다른 스레드에서 네트워크 작업 수행</target>
        </trans-unit>
        <trans-unit id="971a8305c868fd80d22f60a4d8d160cb7a991fbe" translate="yes" xml:space="preserve">
          <source>Don't forget to add this to &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file:</source>
          <target state="translated">이것을 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 파일에 추가하는 것을 잊지 마십시오 :</target>
        </trans-unit>
        <trans-unit id="06499f8ccaa126b054fb3f7150ae1a0b210d99a2" translate="yes" xml:space="preserve">
          <source>Down-sides:</source>
          <target state="translated">Down-sides:</target>
        </trans-unit>
        <trans-unit id="f814e28ec49db65c50c06aafb3321ffb79ecc2e0" translate="yes" xml:space="preserve">
          <source>Effectively, you have to create a Service and create a job using JobInfo.Builder that specifies your criteria for when to run the service.</source>
          <target state="translated">효과적으로 서비스를 작성하고 서비스 실행시기에 대한 기준을 지정하는 JobInfo.Builder를 사용하여 작업을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c7f380f95d204aac73f23f63c7393eb0543e674" translate="yes" xml:space="preserve">
          <source>Embed your Network operation related code in &lt;code&gt;Runnable&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;Runnable&lt;/code&gt; 객체에 네트워크 작업 관련 코드 포함</target>
        </trans-unit>
        <trans-unit id="358d84aa8148063b462186c221ef88a0bda8ec99" translate="yes" xml:space="preserve">
          <source>For Example:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="bc707941094afa664b5576ca9850ca3d09a0d12c" translate="yes" xml:space="preserve">
          <source>For example, if you do an HTTP request, that is a network action.</source>
          <target state="translated">예를 들어, HTTP 요청을하는 경우 이는 네트워크 작업입니다.</target>
        </trans-unit>
        <trans-unit id="d351df765f999c0ca38cc9e9af0d8a607d67bcad" translate="yes" xml:space="preserve">
          <source>For me it was this:</source>
          <target state="translated">나를 위해 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cd0e7756ef740a068c38453f3d730fe52435f55" translate="yes" xml:space="preserve">
          <source>Full API Access</source>
          <target state="translated">완전한 API 액세스</target>
        </trans-unit>
        <trans-unit id="9bbe5a52f1f6cb3223609414a521e4f44339c8c4" translate="yes" xml:space="preserve">
          <source>Full code for both the methods</source>
          <target state="translated">두 방법 모두에 대한 전체 코드</target>
        </trans-unit>
        <trans-unit id="6255759d8a74c7639f11435cf3f2acc6ab79c1ff" translate="yes" xml:space="preserve">
          <source>FutureTask</source>
          <target state="translated">FutureTask</target>
        </trans-unit>
        <trans-unit id="4430ba17611ee081b2f448917a7bd652e7f7385e" translate="yes" xml:space="preserve">
          <source>FutureTask performs asynchronous processing, however, if the result is not ready yet or processing has not complete, calling get() will be block the thread</source>
          <target state="translated">FutureTask는 비동기 처리를 수행하지만 결과가 아직 준비되지 않았거나 처리가 완료되지 않은 경우 get ()을 호출하면 스레드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="bc829e2ae2b954ef4ec64093c80f2450d463725b" translate="yes" xml:space="preserve">
          <source>HandlerThread is a handy class for starting a new thread that has a looper.</source>
          <target state="translated">HandlerThread는 루 퍼가있는 새 스레드를 시작하기위한 편리한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fd082ffa8fb62eaee846d2070533b8ec5d67f1bb" translate="yes" xml:space="preserve">
          <source>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that &lt;code&gt;start()&lt;/code&gt; must still be called.</source>
          <target state="translated">루 퍼가있는 새 스레드를 시작하기위한 편리한 클래스입니다. 그런 다음 루퍼를 사용하여 핸들러 클래스를 작성할 수 있습니다. &lt;code&gt;start()&lt;/code&gt; 는 여전히 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc52cc14e1a5685ba5239ee9b3b80609b99622a" translate="yes" xml:space="preserve">
          <source>Have a look at alternate solution using &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot;&gt;Handler&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt; 및 &lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot;&gt;Handler를&lt;/a&gt; 사용하는 대체 솔루션을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="f0b9177b74ca18e621454f7f7b449caea6bc5aec" translate="yes" xml:space="preserve">
          <source>How can I fix this issue?</source>
          <target state="translated">이 문제를 어떻게 해결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0eb57f52cb28af4167bee573fad580495f3b90c8" translate="yes" xml:space="preserve">
          <source>How do you use it with the finances API?</source>
          <target state="translated">Finances API와 함께 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="d51be9b048201f57b8e7a5ae6ca09d7b8a7ab43d" translate="yes" xml:space="preserve">
          <source>How to execute the task:</source>
          <target state="translated">작업을 수행하는 방법 :</target>
        </trans-unit>
        <trans-unit id="ce9f9270f0617cd02fe9defe5c7c6e34bd0b7307" translate="yes" xml:space="preserve">
          <source>How to fix 'android.os.NetworkOnMainThreadException'</source>
          <target state="translated">'android.os.NetworkOnMainThreadException'수정하는 방법</target>
        </trans-unit>
        <trans-unit id="8de77b5f476ed26c770e194fb605b98e1a82d3a5" translate="yes" xml:space="preserve">
          <source>I got an error while running my Android project for RssReader.</source>
          <target state="translated">RssReader 용 Android 프로젝트를 실행하는 동안 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="3b91fabc95887b693f4dfa70e1d6062162a86efd" translate="yes" xml:space="preserve">
          <source>I solved this problem using a new &lt;code&gt;Thread&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 를 사용 하여이 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="142d2f28bc7d6579f3b39cccf765cfe64f6ac996" translate="yes" xml:space="preserve">
          <source>I will cover several use cases for performing network operations and &lt;em&gt;a&lt;/em&gt; solution or two for each.</source>
          <target state="translated">네트워크 작업을 수행하기위한 몇 가지 사용 사례와 각 솔루션에 대해 한두 가지를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb79dd216f0906b69283214a67e04b660a60e8de" translate="yes" xml:space="preserve">
          <source>If you are writing the &lt;code&gt;AsyncTask&lt;/code&gt; inline and not extending as a class, and on top of this, if there is a need to get a response out of the &lt;code&gt;AsyncTask&lt;/code&gt;, one can use the &lt;code&gt;get()&lt;/code&gt; method as below.</source>
          <target state="translated">&lt;code&gt;AsyncTask&lt;/code&gt; 를 인라인으로 작성하고 클래스로 확장하지 않는 경우 &lt;code&gt;AsyncTask&lt;/code&gt; 에서 응답을 가져와야 할 경우 다음과 같이 &lt;code&gt;get()&lt;/code&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69281d3c4e6ef2c3c5df51b6142be7fb1c6cb75b" translate="yes" xml:space="preserve">
          <source>If you don't do it, you will get &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt;.</source>
          <target state="translated">그렇게하지 않으면 &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="294d9347d892ee06f7aec9c2cbf325de863f5155" translate="yes" xml:space="preserve">
          <source>If you use your own concurrent version of &lt;code&gt;IntentService&lt;/code&gt; (like the one I linked above) you can control the level of concurrency via the &lt;code&gt;Executor&lt;/code&gt;.</source>
          <target state="translated">자신의 동시 버전의 &lt;code&gt;IntentService&lt;/code&gt; (위에 링크 된 것과 같은)를 사용하는 경우 &lt;code&gt;Executor&lt;/code&gt; 를 통해 동시성 레벨을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf6b5410ab9222ea1a93159816f0874947656d5" translate="yes" xml:space="preserve">
          <source>If you want to avoid short-term memory leaks, have well-defined execution characteristics across all platforms, and have a base to build really robust network handling, you might want to consider:</source>
          <target state="translated">단기 메모리 누수를 피하고 모든 플랫폼에서 실행 특성을 명확하게 정의하고 실제로 강력한 네트워크 처리를 구축 할 수있는 기반이있는 경우 다음을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a046b5db560b388e6036ac3267aa757fb6a290b" translate="yes" xml:space="preserve">
          <source>If your activity restarts while network operations are in-flight it can still receive the result of the download via its &lt;code&gt;onActivityResult&lt;/code&gt; method</source>
          <target state="translated">네트워크 작업이 진행되는 동안 활동이 다시 시작되면 &lt;code&gt;onActivityResult&lt;/code&gt; 메소드를 통해 다운로드 결과를 계속받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e15056d48dc96cceb3b8adfa0b6afa8a93761934" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MainActivity.java&lt;/code&gt; file you can add this line within your &lt;code&gt;oncreate()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;MainActivity.java&lt;/code&gt; 파일에서 &lt;code&gt;oncreate()&lt;/code&gt; 메소드 내에이 행을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="71d43b7713c727b57fbe7094e690f36b2fc0e79b" translate="yes" xml:space="preserve">
          <source>In order to use this library, include following lines into you build.gradle file:</source>
          <target state="translated">이 라이브러리를 사용하려면 build.gradle 파일에 다음 행을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="26ea76e4dc2c3947e33f8929d580b2b84da19fd0" translate="yes" xml:space="preserve">
          <source>In simple words,</source>
          <target state="translated">간단히 말해서</target>
        </trans-unit>
        <trans-unit id="c68fcc4a48da4d9bb066c962a07aa865a403043c" translate="yes" xml:space="preserve">
          <source>In your class,</source>
          <target state="translated">수업 시간에</target>
        </trans-unit>
        <trans-unit id="bc9986636734c9c68a3582400c0c1e70c9517bb6" translate="yes" xml:space="preserve">
          <source>IntentService</source>
          <target state="translated">IntentService</target>
        </trans-unit>
        <trans-unit id="39086a3738cdb1e675d91ffd6a18e45c3ddb56df" translate="yes" xml:space="preserve">
          <source>Ion</source>
          <target state="translated">Ion</target>
        </trans-unit>
        <trans-unit id="8fd729c3ffbfedde4e87f47362d289b5f636e6aa" translate="yes" xml:space="preserve">
          <source>It's also &lt;strong&gt;asynchronous&lt;/strong&gt; and &lt;strong&gt;very simple&lt;/strong&gt; to use:</source>
          <target state="translated">또한 &lt;strong&gt;비동기식&lt;/strong&gt; 이며 사용하기가 &lt;strong&gt;매우 간단&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="06099f2fec31249cb21eb4300d48c7abbd4ef703" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt; or Android &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;</source>
          <target state="translated">자바 &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;스레드&lt;/a&gt; 또는 안드로이드 &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;핸들러&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4660eb26c020ec9c3e4d425dc30493f95c84d638" translate="yes" xml:space="preserve">
          <source>Java threads are one-time use only and die after executing its run method.</source>
          <target state="translated">Java 스레드는 한 번만 사용되며 run 메소드를 실행 한 후 죽습니다.</target>
        </trans-unit>
        <trans-unit id="814c7b03e508f3e0a9648d132455b778495c5224" translate="yes" xml:space="preserve">
          <source>JobScheduler</source>
          <target state="translated">JobScheduler</target>
        </trans-unit>
        <trans-unit id="73be87f53b04ab1f8ea8b228cfcce5293a0d74f9" translate="yes" xml:space="preserve">
          <source>Just to spell out something explicitly:</source>
          <target state="translated">명시 적으로 무언가를 철자하십시오.</target>
        </trans-unit>
        <trans-unit id="6a4683ba8ae8772b9e78f73379f3085027b12b73" translate="yes" xml:space="preserve">
          <source>Let's say you are building a social networking app and want to load profile pictures of friends.</source>
          <target state="translated">소셜 네트워킹 앱을 구축 중이며 친구의 프로필 사진을로드하려고한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="dc50a9c8519026fc7d2a73b9efa6707fdeec656e" translate="yes" xml:space="preserve">
          <source>Let's say you are writing an app that lets users track stock prices, interest rates and currecy exchange rates. You find an Json API that looks something like this:</source>
          <target state="translated">사용자가 주가, 금리 및 환율을 추적 할 수있는 앱을 작성한다고 가정 해 보겠습니다. 다음과 같은 Json API를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c6253b343e333576f0af8c4ca137ac64ae2731c3" translate="yes" xml:space="preserve">
          <source>Let's say you're building a &quot;mood weather&quot; app that looks up the users GPS location and checks the current temperature in that area and tells them the mood. This type of app doesn't need to declare API endpoints; it just needs to be able to access one API endpoint.</source>
          <target state="translated">사용자 GPS 위치를 조회하고 해당 지역의 현재 온도를 확인하여 분위기를 알려주는 &quot;기상 날씨&quot;앱을 구축한다고 가정 해 보겠습니다. 이 유형의 앱은 API 엔드 포인트를 선언 할 필요가 없습니다. 하나의 API 엔드 포인트에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4883643a020f221ba2797172ae9b3c377b171dd8" translate="yes" xml:space="preserve">
          <source>Library for composing asynchronous and event-based programs by using observable sequences.</source>
          <target state="translated">관찰 가능한 시퀀스를 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기위한 라이브러리.</target>
        </trans-unit>
        <trans-unit id="899ac73a6083f167ed75688c407fb070197364cb" translate="yes" xml:space="preserve">
          <source>Load images via HTTP</source>
          <target state="translated">HTTP를 통해 이미지로드</target>
        </trans-unit>
        <trans-unit id="c3b214c33683df211b549e5700b95cdd66d3b83d" translate="yes" xml:space="preserve">
          <source>Make the sure the target version is the same as your Android Target Library. If you are unsure what your target library is, right click your Project -&amp;gt; &lt;em&gt;Build Path&lt;/em&gt; -&amp;gt; &lt;em&gt;Android&lt;/em&gt;, and it should be the one that is ticked.</source>
          <target state="translated">대상 버전이 Android 대상 라이브러리와 동일한 지 확인하십시오. 대상 라이브러리가 무엇인지 확실하지 않은 경우 프로젝트-&amp;gt; &lt;em&gt;빌드 경로&lt;/em&gt; -&amp;gt; &lt;em&gt;Android를&lt;/em&gt; 마우스 오른쪽 단추로 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="89d9c1212bd26944e5bb0d6c8ce9c682166910f2" translate="yes" xml:space="preserve">
          <source>More code and complexity than &lt;code&gt;AsyncTask&lt;/code&gt;, though not as much as you might think</source>
          <target state="translated">생각보다 많지는 않지만 &lt;code&gt;AsyncTask&lt;/code&gt; 보다 많은 코드와 복잡성</target>
        </trans-unit>
        <trans-unit id="2f48fd059f6bc28467ddae795715a3fb536ea1c5" translate="yes" xml:space="preserve">
          <source>Network-based operations cannot be run on the main thread. You need to run all network-based tasks on a child thread or implement AsyncTask.</source>
          <target state="translated">메인 스레드에서 네트워크 기반 작업을 실행할 수 없습니다. 자식 스레드에서 모든 네트워크 기반 작업을 실행하거나 AsyncTask를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fb028cbee17d753e6d7524bdde797301d411f5b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;Thread&lt;/code&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; solutions have been explained already.</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 및 &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; 솔루션은 이미 설명되었습니다.</target>
        </trans-unit>
        <trans-unit id="4bab309558426d69bab2e28eb64e803e2f6a2131" translate="yes" xml:space="preserve">
          <source>Note, that although it provides benefits of simplicity and readability, it has its disadvantages.</source>
          <target state="translated">단순성과 가독성의 이점을 제공하지만 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f88a97b0c34d5718ab601409fe417bd53cecf73" translate="yes" xml:space="preserve">
          <source>On Android, network operations cannot be run on the main thread. You can use Thread, AsyncTask (short-running tasks), Service (long-running tasks) to do network operations.</source>
          <target state="translated">Android에서는 네트워크 작업을 기본 스레드에서 실행할 수 없습니다. 스레드, AsyncTask (단기 실행 작업), 서비스 (장기 실행 작업)를 사용하여 네트워크 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb733ed08744b922dea36539e95fd5cf074ea0e" translate="yes" xml:space="preserve">
          <source>One off ReST API access</source>
          <target state="translated">일회용 ReST API 액세스</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="192d153574aac488f39d715ee21fa8a4487cfccc" translate="yes" xml:space="preserve">
          <source>Picasso</source>
          <target state="translated">Picasso</target>
        </trans-unit>
        <trans-unit id="f9cca0fedd9d170b5badb24177eb529a48426caa" translate="yes" xml:space="preserve">
          <source>Please read msysmilu's great answer (&lt;a href=&quot;https://stackoverflow.com/a/28559884/1024412&quot;&gt;https://stackoverflow.com/a/28559884/1024412&lt;/a&gt;)</source>
          <target state="translated">msysmilu의 훌륭한 답변을 읽으십시오 ( &lt;a href=&quot;https://stackoverflow.com/a/28559884/1024412&quot;&gt;https://stackoverflow.com/a/28559884/1024412&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ce2d60a5ff51ab439ffcc37e3f3bd66bf7d24053" translate="yes" xml:space="preserve">
          <source>Pros of using this approach:</source>
          <target state="translated">이 방법을 사용하는 장점 :</target>
        </trans-unit>
        <trans-unit id="500ceb00c409658dec4ebbf84c1a351a817c1a07" translate="yes" xml:space="preserve">
          <source>Put all your works inside</source>
          <target state="translated">모든 작품을 안에 넣으십시오</target>
        </trans-unit>
        <trans-unit id="375a6316c9d1e17d7f86e8583f483fbbee79699c" translate="yes" xml:space="preserve">
          <source>Put your code inside:</source>
          <target state="translated">내부에 코드를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="5c038e53bc60ed29fa76b4c0946713801ee5078f" translate="yes" xml:space="preserve">
          <source>ReST over HTTP</source>
          <target state="translated">HTTP를 통한 ReST</target>
        </trans-unit>
        <trans-unit id="efa1f242533e35071a673f3eff5f95cb5cfd9446" translate="yes" xml:space="preserve">
          <source>Read more &lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot;&gt;은&lt;/a&gt; &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot;&gt;여기&lt;/a&gt; , &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot;&gt;여기&lt;/a&gt; , &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4cf159978b8c1183c57af358ef850a8c7dced6ea" translate="yes" xml:space="preserve">
          <source>Retrofit from Square</source>
          <target state="translated">광장에서 개조</target>
        </trans-unit>
        <trans-unit id="9d8037932b313796752a5be70857679320624a53" translate="yes" xml:space="preserve">
          <source>RxJava</source>
          <target state="translated">RxJava</target>
        </trans-unit>
        <trans-unit id="96fc516616ad1f0b758e4f5f657fc4b2635e5d6b" translate="yes" xml:space="preserve">
          <source>Sample code snippet, which address  &lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NetworkOnMainThreadException&lt;/code&gt; 을 해결하는 샘플 코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="4c611e5488820a251dc87fc1b9af0a580d1f066f" translate="yes" xml:space="preserve">
          <source>ScheduledThreadPoolExecutor - a class that extends ThreadPoolExecutor. It can schedule tasks after a given delay or periodically.</source>
          <target state="translated">ScheduledThreadPoolExecutor-ThreadPoolExecutor를 확장하는 클래스 지정된 지연 후 또는 주기적으로 작업을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3121c971f8834f01d89c2cd9215b7a6521e178e4" translate="yes" xml:space="preserve">
          <source>See also Stack&amp;nbsp;Overflow question:</source>
          <target state="translated">스택 오버플로 질문도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac616df27cceb4363e0d7c50f345bf7f2f4a6daa" translate="yes" xml:space="preserve">
          <source>So saying that you cannot do networking operations in the main thread means you cannot do networking operations in the UI thread, which means &lt;em&gt;you cannot do networking operations in a &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; block&lt;/em&gt; inside some other thread, either.</source>
          <target state="translated">따라서 메인 스레드에서 네트워킹 작업을 수행 할 수 없다는 것은 UI 스레드에서 &lt;em&gt;네트워킹 작업을 수행 할 수 없다는&lt;/em&gt; 것을 의미 &lt;em&gt;합니다.&lt;/em&gt; 이는 다른 스레드 내 &lt;em&gt;에서 &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; 블록에서 네트워킹 작업을 수행 할 수 없음&lt;/em&gt; 을 의미 &lt;em&gt;합니다.&lt;/em&gt; 어느 쪽이든.</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="93dbabbf585e6feb938b7d234bde90abcdd14abd" translate="yes" xml:space="preserve">
          <source>Step 1: Create an &lt;code&gt;IntentService&lt;/code&gt; to perform the download. You can tell it what to download via &lt;code&gt;Intent&lt;/code&gt; extra's, and pass it a &lt;code&gt;PendingIntent&lt;/code&gt; to use to return the result to the &lt;code&gt;Activity&lt;/code&gt;:</source>
          <target state="translated">1 단계 : 다운로드를 수행 할 &lt;code&gt;IntentService&lt;/code&gt; 를 작성하십시오. 인 &lt;code&gt;Intent&lt;/code&gt; 엑스트라를 통해 다운로드 할 내용을 알려주고 &lt;code&gt;PendingIntent&lt;/code&gt; 를 전달하여 결과를 &lt;code&gt;Activity&lt;/code&gt; 로 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abed1497c74da9e76fa8d5cd93a82cf3110827b2" translate="yes" xml:space="preserve">
          <source>Step 2: Register the service in the manifest:</source>
          <target state="translated">2 단계 : 매니페스트에 서비스를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="3111778701990db5c06de60bfbae8d24129dd35c" translate="yes" xml:space="preserve">
          <source>Step 3: Invoke the service from the Activity, passing a PendingResult object which the Service will use to return the result:</source>
          <target state="translated">3 단계 : 서비스가 결과를 리턴하는 데 사용할 PendingResult 오브젝트를 전달하여 활동에서 서비스를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a3fe7bf7055a9a8288d543d002bb366a3cde45be" translate="yes" xml:space="preserve">
          <source>Step 4: Handle the result in onActivityResult:</source>
          <target state="translated">4 단계 : onActivityResult에서 결과 처리 :</target>
        </trans-unit>
        <trans-unit id="6bd9a85779c516e4bf76fbd5dd97142c9014f878" translate="yes" xml:space="preserve">
          <source>Submit &lt;code&gt;Runnable&lt;/code&gt; task to &lt;code&gt;Handler&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Runnable&lt;/code&gt; 태스크를 &lt;code&gt;Handler&lt;/code&gt; 제출</target>
        </trans-unit>
        <trans-unit id="9e027307bc2282959e28b51f486a3dec4ceb9254" translate="yes" xml:space="preserve">
          <source>The code for asynchronous execution will look like:</source>
          <target state="translated">비동기 실행 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eaa902ef2c37a71b3debc3a6c7dd98ec442b927b" translate="yes" xml:space="preserve">
          <source>The device I was testing my app on was 4.1.2 which is SDK Version 16!</source>
          <target state="translated">내 앱을 테스트 한 장치는 SDK 버전 16 인 4.1.2였습니다!</target>
        </trans-unit>
        <trans-unit id="90c709da0828c17eb07bb6cbd11170be6b6c9dcf" translate="yes" xml:space="preserve">
          <source>The error is due to executing long running operations in main thread,You can easily rectify the problem by using &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsynTask&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt;. You can checkout this library &lt;a href=&quot;http://loopj.com/android-async-http/&quot;&gt;AsyncHTTPClient&lt;/a&gt; for better handling.</source>
          <target state="translated">오류는 메인 스레드에서 오래 실행되는 작업으로 인해 발생합니다 &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;.AsynTask&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt; 를 사용하여 쉽게 문제를 해결할 수 있습니다. 더 나은 처리를 위해이 라이브러리 &lt;a href=&quot;http://loopj.com/android-async-http/&quot;&gt;AsyncHTTPClient&lt;/a&gt; 를 체크 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509bd62b6859aefedb8a08790c39ea7d788bc07b" translate="yes" xml:space="preserve">
          <source>The error is the SDK warning!</source>
          <target state="translated">오류는 SDK 경고입니다!</target>
        </trans-unit>
        <trans-unit id="bde255414b3db3a3975218011dee6d7415381afe" translate="yes" xml:space="preserve">
          <source>The first verified answer advice is to use AsynTask. Yes, this is a solution, but it is obsolete nowadays, because there are new tools around.</source>
          <target state="translated">첫 번째로 확인 된 답변 조언은 AsynTask를 사용하는 것입니다. 예, 이것은 해결책이지만 새로운 도구가 있기 때문에 현재는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b879a9d186dc8ea701a01ff123a00f8e80bd037a" translate="yes" xml:space="preserve">
          <source>The getUrl method provides the URL address, and it will be executed on the main thread.</source>
          <target state="translated">getUrl 메소드는 URL 주소를 제공하며 기본 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7191dfaf1027a52bf52254687dd971bf7015fa36" translate="yes" xml:space="preserve">
          <source>The last dependency includes support for the .mainThread() scheduler.</source>
          <target state="translated">마지막 종속성에는 .mainThread () 스케줄러에 대한 지원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="56596bfcc3f43fe44a848397f10abae85f9d2066" translate="yes" xml:space="preserve">
          <source>The main gist of it is, it makes asynchronous code looks so much like synchronous</source>
          <target state="translated">그것의 주요 요점은 비동기 코드를 동기식으로 보이게합니다.</target>
        </trans-unit>
        <trans-unit id="e9c820beb5de62480e58a526f8b0a3743b104313" translate="yes" xml:space="preserve">
          <source>The main thread is basically the UI thread.</source>
          <target state="translated">기본 스레드는 기본적으로 UI 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="f1fcd0cab8c92c43bbe8eb5e1592c3328484c109" translate="yes" xml:space="preserve">
          <source>The top &lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;answer of spektom&lt;/a&gt; works perfect.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;spektom&lt;/a&gt; 의 최고 답변은 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f172bda9b652708d323386b639603b2f3c88bbf9" translate="yes" xml:space="preserve">
          <source>There are many great answers already on this question, but a lot of great libraries have come out since those answers were posted. This is intended as a kind of newbie-guide.</source>
          <target state="translated">이 질문에 이미 많은 훌륭한 답변이 있지만 그 답변이 게시 된 이후 많은 훌륭한 도서관이 나왔습니다. 이것은 일종의 초보자 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="d110a87147ffbd490a008785b463c8534b5e591b" translate="yes" xml:space="preserve">
          <source>There are some approaches that you should choose depends on the situation</source>
          <target state="translated">상황에 따라 선택해야 할 접근법이 있습니다</target>
        </trans-unit>
        <trans-unit id="b7e491e20bd62c867abc2057820c912ee74e10ac" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;https://github.com/Froussios/Intro-To-RxJava&quot;&gt;an excellent ebook for rx-java&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Froussios/Intro-To-RxJava&quot;&gt;rx-java를위한 훌륭한 전자 책&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a039c317ef0ae701432a0a12db84e1a4ba1b0ba0" translate="yes" xml:space="preserve">
          <source>There is an article about &lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot;&gt;Painless Threading&lt;/a&gt; on the Android developer site which is a good introduction to this, and it will provide you with a much better depth of an answer than can be realistically provided here.</source>
          <target state="translated">Android 개발자 사이트에 &lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot;&gt;Painless Threading&lt;/a&gt; 에 대한 기사가 있으며 여기에 대한 좋은 소개가 있으며 여기에 실제로 제공 할 수있는 것보다 훨씬 더 나은 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3fc611ee945fbb14411bd1defea7711cf15c34c1" translate="yes" xml:space="preserve">
          <source>There is another very convenient way for tackling this issue - use rxJava's concurrency capabilities. You can execute any task in background and post results to main thread in a very convenient way, so these results will be handed to processing chain.</source>
          <target state="translated">이 문제를 해결하는 또 다른 매우 편리한 방법이 있습니다. rxJava의 동시성 기능을 사용하십시오. 백그라운드에서 모든 작업을 실행하고 결과를 메인 스레드에 매우 편리한 방식으로 게시 할 수 있으므로 이러한 결과는 처리 체인으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e790485979a363e42824420e80ddba2e4e7e0e" translate="yes" xml:space="preserve">
          <source>This exception is thrown when an application attempts to perform a networking operation on its main thread. Run your code in &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;&lt;code&gt;AsyncTask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 예외는 응용 프로그램이 기본 스레드에서 네트워킹 작업을 수행하려고 할 때 발생합니다. &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt; &lt;code&gt;AsyncTask&lt;/code&gt; &lt;/a&gt; 에서 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7e61419ec095b3e0c8a04ce19bcc29e670641603" translate="yes" xml:space="preserve">
          <source>This exception occurs due to any heavy task performed on the main thread if that performing task takes &lt;em&gt;too much time&lt;/em&gt;.</source>
          <target state="translated">이 예외는 수행하는 작업이 &lt;em&gt;너무 많은 시간&lt;/em&gt; 이 걸리면 주 스레드에서 수행 된 많은 작업으로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ae9bbc3e827bacbe8c9e65dacbdc9305a970f7cf" translate="yes" xml:space="preserve">
          <source>This happens in Android 3.0 and above. From Android 3.0 and above, they have restricted using network operations (functions that access the Internet) from running in the main thread/UI thread (what spawns from your on create and on resume methods in the activity).</source>
          <target state="translated">이것은 Android 3.0 이상에서 발생합니다. Android 3.0 이상에서는 메인 스레드 / UI 스레드 (활동에서 생성 및 재개시 생성되는 메소드)에서 실행되는 네트워크 작업 (인터넷에 액세스하는 기능)을 사용하여 제한했습니다.</target>
        </trans-unit>
        <trans-unit id="b24a15ca4e1ad78f5f37336bab3ef204f811b2f6" translate="yes" xml:space="preserve">
          <source>This is a great library for this type of access.</source>
          <target state="translated">이 유형의 액세스를위한 훌륭한 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="644e86cdfa96466092b0882052163a5bcb511ba6" translate="yes" xml:space="preserve">
          <source>This is an excellent choice for an API with multiple endpoints and allows you to declare the ReST endpoints instead of having to code them individually as with other libraries like ion or Volley. (website: &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;)</source>
          <target state="translated">이는 엔드 포인트가 여러 개인 API에 탁월한 선택이며 이온 또는 발리와 같은 다른 라이브러리와 같이 개별적으로 코딩하지 않고 ReST 엔드 포인트를 선언 할 수 있습니다. (웹 사이트 : &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6bb9642b33c5f9d15af7b7b29997bb23f83dd632" translate="yes" xml:space="preserve">
          <source>This is how you run a task in a child thread:</source>
          <target state="translated">이것은 자식 스레드에서 작업을 실행하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="db8ec763b72c4b6f4ae9ec7979abcde7a79f5202" translate="yes" xml:space="preserve">
          <source>This is only thrown for applications targeting the &lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; SDK or higher. Applications targeting earlier SDK versions are allowed to do networking on their main event loop threads.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; SDK 이상을 대상으로하는 응용 프로그램에서만 발생합니다. 이전 SDK 버전을 대상으로하는 응용 프로그램은 기본 이벤트 루프 스레드에서 네트워킹을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a6ff90d4f7875dcc221cf52bf70e6e5a98e004" translate="yes" xml:space="preserve">
          <source>This is the defacto choice for long running processing on Android, a good example would be to upload or download large files. The upload and download may continue even if the user exits the app and you certainly do not want to block the user from being able to use the app while these tasks are going on.</source>
          <target state="translated">이것은 Android에서 장기 실행 처리를위한 사실상의 선택입니다. 좋은 예는 큰 파일을 업로드하거나 다운로드하는 것입니다. 사용자가 앱을 종료하더라도 이러한 작업이 진행되는 동안 사용자가 앱을 사용하지 못하도록 차단하고 싶지 않은 경우에도 업로드 및 다운로드가 계속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6ed2e5a386ab2774d21d153fe76e28e13a8976" translate="yes" xml:space="preserve">
          <source>This is to encourage using separate threads for network operations. See &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; for more details on how to perform network activities the right way.</source>
          <target state="translated">네트워크 작업에 별도의 스레드를 사용하도록 권장합니다. 올바른 방법으로 네트워크 활동을 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="50f279e5caf39dbfd8787ba3feb2f7e961537d9a" translate="yes" xml:space="preserve">
          <source>This works. Just made Dr.Luiji's answer a little simpler.</source>
          <target state="translated">작동합니다. Dr.Luiji의 대답을 좀 더 단순하게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="f4a2cb9c490779e4a09391cee0744b207dd645de" translate="yes" xml:space="preserve">
          <source>Thread pool implementation &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html&quot;&gt;ThreadPoolExecutor&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html&quot;&gt;ScheduledThreadPoolExecutor&lt;/a&gt;...</source>
          <target state="translated">스레드 풀 구현 &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html&quot;&gt;ThreadPoolExecutor&lt;/a&gt; , &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html&quot;&gt;ScheduledThreadPoolExecutor&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="a397a8fa1a53e47a761c3cfea578780e310949bd" translate="yes" xml:space="preserve">
          <source>ThreadPoolExecutor class that implements ExecutorService which gives fine control on the thread pool (Eg, core pool size, max pool size, keep alive time, etc.)</source>
          <target state="translated">스레드 풀 (예 : 코어 풀 크기, 최대 풀 크기, 활성 시간 유지 등)을 미세하게 제어하는 ​​ExecutorService를 구현하는 ThreadPoolExecutor 클래스</target>
        </trans-unit>
        <trans-unit id="b6e1f519155ac4c025ed7a8bf4289234f321123a" translate="yes" xml:space="preserve">
          <source>To avoid this, we can handle it using &lt;strong&gt;threads&lt;/strong&gt; or &lt;strong&gt;executers&lt;/strong&gt;</source>
          <target state="translated">이를 피하기 위해 &lt;strong&gt;스레드&lt;/strong&gt; 또는 &lt;strong&gt;실행기를&lt;/strong&gt; 사용하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="60d22d61692e90485ac3d60c7cd80e4d5fcfbb7d" translate="yes" xml:space="preserve">
          <source>To simplify all these things, Android provides various ways, like &lt;code&gt;AsyncTask&lt;/code&gt;, &lt;code&gt;AsyncTaskLoader&lt;/code&gt;, &lt;code&gt;CursorLoader&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt;. So you can use any of these according to your requirements.</source>
          <target state="translated">이러한 모든 것을 단순화하기 위해 Android는 &lt;code&gt;AsyncTask&lt;/code&gt; , &lt;code&gt;AsyncTaskLoader&lt;/code&gt; , &lt;code&gt;CursorLoader&lt;/code&gt; 또는 &lt;code&gt;IntentService&lt;/code&gt; 와 같은 다양한 방법을 제공합니다. 따라서 요구 사항에 따라 이들 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea76dcbe8be19acd8a1982a087841a064cfcd3e" translate="yes" xml:space="preserve">
          <source>Um, I can't think of any others right now actually</source>
          <target state="translated">음, 지금 다른 사람은 생각할 수 없어</target>
        </trans-unit>
        <trans-unit id="97e015cdd6a1113db3a98e8adc5b707a183e653c" translate="yes" xml:space="preserve">
          <source>Up-sides:</source>
          <target state="translated">Up-sides:</target>
        </trans-unit>
        <trans-unit id="7599502cfa428edf5e093d7e32d931a81ddfe99b" translate="yes" xml:space="preserve">
          <source>Use Service or AsyncTask</source>
          <target state="translated">서비스 또는 AsyncTask 사용</target>
        </trans-unit>
        <trans-unit id="b2408a92a8a7e813ddc8d1699d4e3afbe1cbd674" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://androidannotations.org/&quot;&gt;Android Annotations&lt;/a&gt; is an option. It will allow you to simply run any method in a background thread:</source>
          <target state="translated">&lt;a href=&quot;http://androidannotations.org/&quot;&gt;안드로이드 주석&lt;/a&gt; 사용은 옵션입니다. 백그라운드 스레드에서 모든 메소드를 간단하게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f80468404a516fbf71c2d620082f9ad0dca15acf" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Service&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt; instead, perhaps with a &lt;code&gt;PendingIntent&lt;/code&gt; to return the result via the Activity's &lt;code&gt;onActivityResult&lt;/code&gt; method.</source>
          <target state="translated">대신 &lt;code&gt;PendingIntent&lt;/code&gt; 와 함께 &lt;code&gt;Service&lt;/code&gt; 또는 &lt;code&gt;IntentService&lt;/code&gt; 를 사용하여 Activity의 &lt;code&gt;onActivityResult&lt;/code&gt; 메소드를 통해 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9f70e533db0150c260360b33e601c8514945d241" translate="yes" xml:space="preserve">
          <source>Using a library that does a nice job of this for you - there's a nice comparison of networking libs in &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;this question&lt;/a&gt;, or</source>
          <target state="translated">이 작업을 훌륭하게 수행하는 라이브러리를 사용하면 &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;이 질문&lt;/a&gt; 에 네트워킹 라이브러리를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f095116f2fdd9535d80b88a6474753f6005d3446" translate="yes" xml:space="preserve">
          <source>Volley</source>
          <target state="translated">Volley</target>
        </trans-unit>
        <trans-unit id="1be565163d1d67c36d081e6e9ed9c89deb07ebcb" translate="yes" xml:space="preserve">
          <source>Volley requires more setup than Retrofit. You will need to create a class like this to setup a RequestQueue, an ImageLoader and an ImageCache, but it's not too bad:</source>
          <target state="translated">발리는 개장보다 더 많은 설정이 필요합니다. RequestQueue, ImageLoader 및 ImageCache를 설정하려면 다음과 같은 클래스를 작성해야하지만 그렇게 나쁘지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c0d1456a9e7d9083aa28ea885a7246ebbbd8391" translate="yes" xml:space="preserve">
          <source>When you get something from Network response and want to show it on your view (like display response message in TextView), you need to &lt;strong&gt;return back to the UI&lt;/strong&gt; thread.</source>
          <target state="translated">네트워크 응답에서 무언가를 가져 와서 TextView의 디스플레이 응답 메시지와 같이보기에 표시 &lt;strong&gt;하려면 UI&lt;/strong&gt; 스레드 &lt;strong&gt;로 다시 돌아와야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9425da95831da82358ab97098eda19da644c187a" translate="yes" xml:space="preserve">
          <source>While using AsyncTask, update view from &lt;code&gt;onPostExecute()&lt;/code&gt; method</source>
          <target state="translated">AsyncTask를 사용하는 동안 &lt;code&gt;onPostExecute()&lt;/code&gt; 메소드에서보기를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="3ced8911fbbe92b803208da3ca154b423d4a6c20" translate="yes" xml:space="preserve">
          <source>Will queue requests and run them on a &lt;em&gt;single&lt;/em&gt; background thread. You can easily control this by replacing &lt;code&gt;IntentService&lt;/code&gt; with an equivalent &lt;code&gt;Service&lt;/code&gt; implementation, perhaps like &lt;a href=&quot;https://github.com/steveliles/AsyncAndroid/blob/master/AsyncAndroid/src/main/java/com/packt/asyncandroid/chapter6/ConcurrentIntentService.java&quot;&gt;this one&lt;/a&gt;.</source>
          <target state="translated">요청을 대기열에 넣고 &lt;em&gt;단일&lt;/em&gt; 백그라운드 스레드에서 실행합니다. &lt;code&gt;IntentService&lt;/code&gt; 를 이와 유사한 &lt;code&gt;Service&lt;/code&gt; 구현으로 바꾸면이를 쉽게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5135659d0e8bd5f46b02613bfbcc4a0c825fd97d" translate="yes" xml:space="preserve">
          <source>You are able to move a part of your code into another thread to offload the &lt;code&gt;main thread&lt;/code&gt; and avoid getting &lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot;&gt;ANR&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;NetworkOnMainThreadException&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot;&gt;IllegalStateException&lt;/a&gt;(e.g. Cannot access database on the main thread since it may potentially lock the UI for a long period of time).</source>
          <target state="translated">코드의 일부를 다른 스레드로 이동하여 &lt;code&gt;main thread&lt;/code&gt; 스레드를 오프로드하고 &lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot;&gt;ANR&lt;/a&gt; , &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;NetworkOnMainThreadException&lt;/a&gt; , &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot;&gt;IllegalStateException&lt;/a&gt; (예 : 메인 스레드의 데이터베이스에 액세스 할 수 없으므로 UI가 장기간 잠길 수 있으므로)을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dcb961afecc7ed4f8ff92e83e462e2977fc4e8c" translate="yes" xml:space="preserve">
          <source>You can implement an &lt;code&gt;IntentService&lt;/code&gt; to perform downloads on a single background thread quite easily.</source>
          <target state="translated">단일 백그라운드 스레드에서 다운로드를 매우 쉽게 수행하도록 &lt;code&gt;IntentService&lt;/code&gt; 를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d25b678f66da4756ee3210eff3be9f55bc5d1b1" translate="yes" xml:space="preserve">
          <source>You cannot perform network &lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot;&gt;I/O&lt;/a&gt; on the UI thread on &lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt;. Technically, it &lt;em&gt;is&lt;/em&gt; possible on earlier versions of Android, but it is a really bad idea as it will cause your app to stop responding, and can result in the OS killing your app for being badly behaved. You'll need to run a background process or use AsyncTask to perform your network transaction on a background thread.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; 의 UI 스레드에서 네트워크 &lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot;&gt;I / O&lt;/a&gt; 를 수행 할 수 없습니다. 기술적으로 &lt;em&gt;는&lt;/em&gt; 이전 버전의 Android에서 가능하지만 앱의 응답을 중지하고 OS가 앱을 종료시켜 앱이 제대로 작동하지 않을 수 있으므로 실제로 나쁜 생각입니다. 백그라운드 프로세스를 실행하거나 AsyncTask를 사용하여 백그라운드 스레드에서 네트워크 트랜잭션을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="423211d4e7a3631585c5340a517f60b555795410" translate="yes" xml:space="preserve">
          <source>You disable the strict mode using following code:</source>
          <target state="translated">다음 코드를 사용하여 엄격 모드를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4085af883abb5e100e006893abefcf0b463ef524" translate="yes" xml:space="preserve">
          <source>You have to create a new Thread</source>
          <target state="translated">새 스레드를 만들어야합니다</target>
        </trans-unit>
        <trans-unit id="d5a644a2460626c071917f71454f3652fc2ea29e" translate="yes" xml:space="preserve">
          <source>You should not do any time-consuming task on the main thread (UI thread), like any network operation, file I/O, or SQLite database operations. So for this kind of operation, you should create a worker thread, but the problem is that you can not directly perform any UI related operation from your worker thread. For that, you have to use &lt;code&gt;Handler&lt;/code&gt; and pass the &lt;code&gt;Message&lt;/code&gt;.</source>
          <target state="translated">네트워크 작업, 파일 I / O 또는 SQLite 데이터베이스 작업과 같이 메인 스레드 (UI 스레드)에서 시간 소모적 인 작업을 수행해서는 안됩니다. 따라서 이런 종류의 작업을 위해서는 작업자 스레드를 만들어야하지만 문제는 작업자 스레드에서 UI 관련 작업을 직접 수행 할 수 없다는 것입니다. 이를 위해서는 &lt;code&gt;Handler&lt;/code&gt; 를 사용하고 &lt;code&gt;Message&lt;/code&gt; 를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="418695ed454c9db825cf329eb6f7fd3f653d0bb5" translate="yes" xml:space="preserve">
          <source>Your app will (in areas of spotty internet connection) become unresponsive and lock up, the user perceives slowness and has to do a force kill, and you risk the activity manager killing your app and telling the user that the app has stopped.</source>
          <target state="translated">인터넷 연결이 빈약 한 영역에서 앱이 응답하지 않고 잠기고 사용자가 느리게 인식하고 강제 종료를 수행해야하며 활동 관리자가 앱을 종료하고 사용자에게 앱이 중지되었음을 알리는 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="7f628363b72ea19e08f323f2bc74538e842171c1" translate="yes" xml:space="preserve">
          <source>makeCallParseResponse(..) - does actual work</source>
          <target state="translated">makeCallParseResponse (..)-실제 작업 수행</target>
        </trans-unit>
        <trans-unit id="662231f30478ae40839ba8099ae853a863ad85ee" translate="yes" xml:space="preserve">
          <source>processResponse(..) - will handle result on main thread.</source>
          <target state="translated">processResponse (..)-메인 스레드의 결과를 처리합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
