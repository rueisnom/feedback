<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/6343166">
    <body>
      <group id="6343166">
        <trans-unit id="e701d4f4ca8a7c0ce3eea20ba70d6bce670254b5" translate="yes" xml:space="preserve">
          <source>(From his example.)</source>
          <target state="translated">(彼の例から)</target>
        </trans-unit>
        <trans-unit id="caeb8c4daf10a7a29d60ebe7f726b5e6be1ea726" translate="yes" xml:space="preserve">
          <source>(I just had a long head-scratching moment trying to figure out why I was getting that error somewhere other than my main thread.  This was why; this thread helped; and hopefully this comment will help someone else.)</source>
          <target state="translated">(メインスレッド以外のどこかでエラーが発生している理由を探ろうとして、長い間頭を悩ませていたところでした。このスレッドが助けになりました。)</target>
        </trans-unit>
        <trans-unit id="6a8088732944db5eec3c539530a0513e5fcc6250" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;Coroutines&lt;/a&gt; (Kotlin)</source>
          <target state="translated">&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;コルーチン&lt;/a&gt; （Kotlin）</target>
        </trans-unit>
        <trans-unit id="513a168553003f07d278a92713bcaebee5d17d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AsyncTask&lt;/code&gt; should ideally be used for short operations. Normal &lt;code&gt;Thread&lt;/code&gt; is not preferable for Android.</source>
          <target state="translated">&lt;code&gt;AsyncTask&lt;/code&gt; は、短時間の操作に理想的に使用する必要があります。 通常の &lt;code&gt;Thread&lt;/code&gt; は、Androidには適していません。</target>
        </trans-unit>
        <trans-unit id="f7974727712da83599bfb8e8c238a6155c2f8ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RxAndroid&lt;/code&gt; is another better alternative to this problem and it saves us from hassles of creating threads and then posting results on Android UI thread.
We just need to specify threads on which tasks need to be executed and everything is handled internally.</source>
          <target state="translated">&lt;code&gt;RxAndroid&lt;/code&gt; は、この問題のもう1つの優れた代替手段であり、スレッドを作成してからAndroid UIスレッドに結果を投稿するという煩わしさから解放されます。 タスクを実行する必要があるスレッドを指定するだけで、すべてが内部で処理されます。</target>
        </trans-unit>
        <trans-unit id="219b997bdcfa0046d264cf94a2386888ac6a5147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run()&lt;/code&gt; method of new thread</source>
          <target state="translated">新しいスレッドの &lt;code&gt;run()&lt;/code&gt; メソッド</target>
        </trans-unit>
        <trans-unit id="f5bbd6621b1e09056a5aa357275ada0230e4428b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;android.os.NetworkOnMainThreadException sending an email from Android&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;Androidからメールを送信するandroid.os.NetworkOnMainThreadException&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a25f771710bd8cde3227bd7972908fe47b297297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If your API requires an API Key or other header like a user token, etc. to be sent, Retrofit makes this easy (see this awesome answer for details: &lt;a href=&quot;https://stackoverflow.com/a/42899766/1024412&quot;&gt;https://stackoverflow.com/a/42899766/1024412&lt;/a&gt;).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;APIがAPIキーまたはユーザートークンなどの他のヘッダーの送信を必要とする場合、Retrofitはこれを簡単にします（詳細については、この素晴らしい回答を参照してください： &lt;a href=&quot;https://stackoverflow.com/a/42899766/1024412&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/42899766/1024412 ）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66961741ec9c0e83379baa24fc592717dcc9315e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation summary&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;実装の概要&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9c0c6f046f93218df6678063b471e792fb5e535" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IntentService approach&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IntentServiceアプローチ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2397d3757b8d169d35c47aa969de6541d61d5ec6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Typically Json, can be XML or something else&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;通常はJsonであり、XMLまたは他の何かにすることができます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dad356866e8f659fd325b891f3ebcdd63e20966" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Volley can also be used for ReST APIs, but due to the more complicated setup required I prefer to use Retrofit from Square as above (&lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VolleyはReST APIにも使用できますが、必要な設定がより複雑なため、上記のようにSquareからRetrofitを使用することを好みます（ &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt; ）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="25e62674da40cc91ecdb9eecd1fc280c9eaea2b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AsyncTask&lt;/strong&gt; is designed to be a helper class around &lt;strong&gt;Thread&lt;/strong&gt; and &lt;strong&gt;Handler&lt;/strong&gt; and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as &lt;strong&gt;Executor&lt;/strong&gt;, &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt; and &lt;strong&gt;FutureTask&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;AsyncTask&lt;/strong&gt;は、 &lt;strong&gt;スレッド&lt;/strong&gt;と&lt;strong&gt;ハンドラーの&lt;/strong&gt;ヘルパークラスになるように設計されており、汎用のスレッドフレームワークを構成しません。 AsyncTasksは、理想的には短い操作（最大で数秒）に使用する必要があります。スレッドを長期間実行し続ける必要がある場合は、java.util.concurrentパッケージによって提供されるさまざまなAPIを使用することを強くお勧めします。 &lt;strong&gt;エグゼキューター&lt;/strong&gt; 、 &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt; 、 &lt;strong&gt;FutureTask&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6598d2b45c7dbf80276bd511c505bc2857a99510" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;But:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2133e68d566fe49c20988cfcce2bbb99801d6de7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DO NOT DO NETWORK WORK IN THE UI THREAD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UIスレッドでネットワーク作業を行わないでください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917cfe5738a6f66768d1da4e53af3171e558b3b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesApi.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesApi.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3021948f153e7007373ef5242b6d203511d5ce09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesApiBuilder&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesApiBuilder&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0ff55b5e14dbd360ec6c31743a34c3290cc49a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FinancesFragment snippet&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FinancesFragmentスニペット&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="567a81632d5511eb02ee4b8419137a833a82dc57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Handler:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Handler:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fff1888f36aaf72cc2080185fe1f5f2683cc4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HandlerThread&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HandlerThread&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="384422180405859aa2748fcda32661c85100c51d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c63a5cc621c4c365b35d0d44621b19b36fdf48e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ImageFetch.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ImageFetch.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a5ed542bf2a3a24445892b08dd385084f2f581b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt; call &lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt;&lt;code&gt;runOnUiThread()&lt;/code&gt;&lt;/a&gt; method and update view inside the &lt;code&gt;run()&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;または&lt;/strong&gt; 、 &lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt; &lt;code&gt;runOnUiThread()&lt;/code&gt; &lt;/a&gt;メソッドを呼び出して、 &lt;code&gt;run()&lt;/code&gt; メソッド内のビューを更新します。</target>
        </trans-unit>
        <trans-unit id="5eb9692511a9440615e36334fff23221552c6401" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt; use &lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot;&gt;AsyncTask class&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;または&lt;/strong&gt; 、 &lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot;&gt;AsyncTaskクラスを&lt;/a&gt;使用します</target>
        </trans-unit>
        <trans-unit id="b2a7ef528060d56c8515b79d85a46d420cd9ce1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or&lt;/strong&gt;&lt;code&gt;doInBackground()&lt;/code&gt; method of AsyncTask class.</source>
          <target state="translated">&lt;strong&gt;または&lt;/strong&gt; 、AsyncTaskクラスの &lt;code&gt;doInBackground()&lt;/code&gt; メソッド。</target>
        </trans-unit>
        <trans-unit id="49c900ba5a0475e269165d778322be2846b3c474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solution:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b38b4c4100e627a7e6c087c8e21cfdf4ed6d3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The accepted answer has some significant down-sides. It is not advisable to use AsyncTask for networking unless you &lt;em&gt;really&lt;/em&gt; know what you are doing. Some of the down-sides include:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;受け入れられた回答には、いくつかの重大な欠点があります。&lt;/strong&gt; &lt;strong&gt;何をしているのか&lt;em&gt;本当に&lt;/em&gt;理解していない限り、ネットワークにAsyncTaskを使用することはお勧めできません。&lt;/strong&gt; &lt;strong&gt;いくつかの欠点は次のとおりです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19b5e9d0ddf1bdb5d05bf7202e0f6fa71a0a776f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is not recommended&lt;/strong&gt;: use the &lt;code&gt;AsyncTask&lt;/code&gt; interface.</source>
          <target state="translated">&lt;strong&gt;これは推奨されません&lt;/strong&gt; &lt;code&gt;AsyncTask&lt;/code&gt; インターフェースを使用してください 。</target>
        </trans-unit>
        <trans-unit id="e20c836962bfca05fb50974e95a20a24b1359cc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this in Your Activity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;あなたの活動でこれを使用してください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7336c3aa8ca565418a4c68252e36d2812c114c54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UserViewDialog.java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UserViewDialog.java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8765d8046996c6e90e70fcf4c30238fcf731d749" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Way:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06e4b3f8e199aed94f3f2f897dfb806c1caa237a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You should almost always run network operations on a thread or as an asynchronous task.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ほとんどの場合、ネットワーク操作はスレッド上で実行するか、非同期タスクとして実行する必要があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a36ba63f51ccfca556458e8a4cce314f801ac29c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;build.gradle&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;build.gradle&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2ec3ef457076fbfc6654a12bcb37263fdb07109" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;user_view_dialog.xml&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;user_view_dialog.xml&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87f2e56db8589458e7fa17b650e754fb55204d75" translate="yes" xml:space="preserve">
          <source>A Github project containing a complete working Android-Studio/Gradle project is available &lt;a href=&quot;https://github.com/steveliles/Android-Download-Service-Example&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">完全に機能するAndroid-Studio / Gradleプロジェクトを含むGithubプロジェクトは、 &lt;a href=&quot;https://github.com/steveliles/Android-Download-Service-Example&quot;&gt;こちらから&lt;/a&gt;入手できます 。</target>
        </trans-unit>
        <trans-unit id="24f7c8831f32f043122b170cd7a35bd2b8eb3ad6" translate="yes" xml:space="preserve">
          <source>A Handler allows you to send and process Message and Runnable objects associated with a thread's MessageQueue. Each Handler instance is associated with a single thread and that thread's message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</source>
          <target state="translated">ハンドラを使用すると、スレッドの MessageQueue に関連付けられた Message オブジェクトや Runnable オブジェクトを送信したり処理したりすることができます。各Handlerインスタンスは、1つのスレッドとそのスレッドのメッセージキューに関連付けられています。新しいハンドラを作成すると、そのハンドラは、それを作成したスレッドのメッセージキューにバインドされます --その時点から、そのメッセージキューにメッセージとランナブルを配信し、メッセージキューから出てきたものを実行します。</target>
        </trans-unit>
        <trans-unit id="62525e1302249317dc097de933bbafd11fd21100" translate="yes" xml:space="preserve">
          <source>ADD this permission in android manifest.xml file: &amp;nbsp; &amp;nbsp;</source>
          <target state="translated">この権限をandroid manifest.xmlファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="ffae741742565dee96ff975c416b8d353112e510" translate="yes" xml:space="preserve">
          <source>Accessing network resources from the main (UI) thread cause this exception. Use a separate thread or AsyncTask for accessing a network resource to avoid this problem.</source>
          <target state="translated">メイン(UI)スレッドからネットワークリソースにアクセスすると、この例外が発生します。この問題を回避するために、ネットワークリソースへのアクセスには別のスレッドまたは AsyncTask を使用してください。</target>
        </trans-unit>
        <trans-unit id="0f0d0881b6e43f09d81175d22f7987bf0d1221b8" translate="yes" xml:space="preserve">
          <source>Add the following code to the onCreate method (Fragment, Activity) or the constructor (Dialog):</source>
          <target state="translated">onCreateメソッド(Fragment,Activity)やコンストラクタ(Dialog)に以下のコードを追加します。</target>
        </trans-unit>
        <trans-unit id="9112f4dc99cf0253e3029c2c006685defa6b5de6" translate="yes" xml:space="preserve">
          <source>Add the following to your layout xml file to add an image:</source>
          <target state="translated">レイアウトxmlファイルに以下を追加して画像を追加します。</target>
        </trans-unit>
        <trans-unit id="5742348ab2679838340e69e8e774beee58abe587" translate="yes" xml:space="preserve">
          <source>Add these lines to your Module level buid.gradle:</source>
          <target state="translated">これらの行をモジュールレベルの buid.gradle に追加します。</target>
        </trans-unit>
        <trans-unit id="9d9bc4c443ca7664f0308a3d6d6f85d72ac6a70c" translate="yes" xml:space="preserve">
          <source>Add this line to your Module level buid.gradle:</source>
          <target state="translated">この行をモジュールレベルの buid.gradle に追加します。</target>
        </trans-unit>
        <trans-unit id="c37195fe791a6d5ae7aa1680ddbf075189eb46ce" translate="yes" xml:space="preserve">
          <source>Add:</source>
          <target state="translated">Add:</target>
        </trans-unit>
        <trans-unit id="c9416697ac321c85343ea7b82034f38ccdbc1a49" translate="yes" xml:space="preserve">
          <source>Also, as others have mentioned, include the correct permissions to access the Internet:</source>
          <target state="translated">また、他の人が言っていたように、インターネットにアクセスするための正しいパーミッションも含めて。</target>
        </trans-unit>
        <trans-unit id="85eb254309b9817b59cbdf1521ae57f2fd9bdd4a" translate="yes" xml:space="preserve">
          <source>Although above there is a huge solution pool, no one mentioned &lt;code&gt;com.koushikdutta.ion&lt;/code&gt;: &lt;a href=&quot;https://github.com/koush/ion&quot;&gt;https://github.com/koush/ion&lt;/a&gt;</source>
          <target state="translated">上記には巨大なソリューションプールがありますが、 &lt;code&gt;com.koushikdutta.ion&lt;/code&gt; については誰も言及していません ： &lt;a href=&quot;https://github.com/koush/ion&quot;&gt;https&lt;/a&gt; : //github.com/koush/ion</target>
        </trans-unit>
        <trans-unit id="865822065fcdc4d56fd5b2c5554b3da425ee6b15" translate="yes" xml:space="preserve">
          <source>And add this to AndroidManifest.xml</source>
          <target state="translated">そして、これをAndroidManifest.xmlに追加します。</target>
        </trans-unit>
        <trans-unit id="d9e37bccfa0b1f88f4e499362fd7307daaa603e6" translate="yes" xml:space="preserve">
          <source>And it shows the below error:</source>
          <target state="translated">そして、以下のようなエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="8fa6edcdeef0ba2e24b13161c844dedc283e5d95" translate="yes" xml:space="preserve">
          <source>Android has some good tips on good programming practices to design for responsiveness:
&lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&lt;/a&gt;</source>
          <target state="translated">Androidには、応答性を&lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;考慮&lt;/a&gt;して設計するための優れたプログラミング手法に関するヒントがいくつかあります。http ： //developer.android.com/reference/android/os/NetworkOnMainThreadException.html</target>
        </trans-unit>
        <trans-unit id="69e8f859c636329f43322ad40ceb48e0db6287be" translate="yes" xml:space="preserve">
          <source>Another excellent library from Square. Please see the site for some great examples: &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;http://square.github.io/picasso/&lt;/a&gt;</source>
          <target state="translated">Squareのもう1つの優れたライブラリ。 いくつかの優れた例については、サイトを参照してください： &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;http&lt;/a&gt; : //square.github.io/picasso/</target>
        </trans-unit>
        <trans-unit id="691706e7fa4ef71a62183103fde8d93a8e51cc9e" translate="yes" xml:space="preserve">
          <source>AsyncTask</source>
          <target state="translated">AsyncTask</target>
        </trans-unit>
        <trans-unit id="1e93f9e0b4644967ae582a89cc56cc92b5d29f7e" translate="yes" xml:space="preserve">
          <source>AsyncTask has different execution characteristics depending on the platform it executes on: prior to API level 4 AsyncTasks execute serially on a single background thread; from API level 4 through API level 10, AsyncTasks execute on a pool of up to 128 threads; from API level 11 onwards AsyncTask executes serially on a single background thread (unless you use the overloaded &lt;code&gt;executeOnExecutor&lt;/code&gt; method and supply an alternative executor). Code that works fine when running serially on ICS may break when executed concurrently on Gingerbread, say if you have inadvertent order-of-execution dependencies.</source>
          <target state="translated">AsyncTaskは、実行するプラットフォームに応じて実行特性が異なります。APIレベル4より前のAsyncTasksは、単一のバックグラウンドスレッドでシリアルに実行されます。 APIレベル4からAPIレベル10まで、AsyncTasksは最大128スレッドのプールで実行されます。 APIレベル11以降、AsyncTaskは単一のバックグラウンドスレッドで順次実行されます（オーバーロードされた &lt;code&gt;executeOnExecutor&lt;/code&gt; メソッドを使用して、代替のexecutorを提供する場合を除く）。 ICSでシリアルに実行すると正常に機能するコードは、Gingerbreadで同時に実行すると壊れる可能性があります（不注意による実行順序の依存関係がある場合など）。</target>
        </trans-unit>
        <trans-unit id="44013bbe71b1fbd1c9a2d927a1c92b80870d6c88" translate="yes" xml:space="preserve">
          <source>AsyncTask's created as non-static inner classes have an implicit reference to the enclosing Activity object, its context, and the entire View hierarchy created by that activity. This reference prevents the Activity from being garbage collected until the AsyncTask's background work completes. If the user's connection is slow, and/or the download is large, these short-term memory leaks can become a problem - for example, if the orientation changes several times (and you don't cancel the executing tasks), or the user navigates away from the Activity.</source>
          <target state="translated">非静的な内部クラスとして作成された AsyncTask は、そのアクティビティオブジェクトとそのコンテキスト、そしてそのアクティビティによって作成されたビュー階層全体への暗黙の参照を持っています。この参照により、AsyncTask のバックグラウンド作業が完了するまで Activity がガベージコレクションされるのを防ぎます。ユーザーの接続が遅い場合やダウンロード量が多い場合、これらの短期的なメモリリークが問題になることがあります。例えば、方向が何度か変更されたり(実行中のタスクをキャンセルしなかったり)、ユーザーがアクティビティから離れて移動したりした場合などです。</target>
        </trans-unit>
        <trans-unit id="4230b18c8bff24b31dcc1e2e960671cd033ff07c" translate="yes" xml:space="preserve">
          <source>AsyncTaskLoaders</source>
          <target state="translated">AsyncTaskLoaders</target>
        </trans-unit>
        <trans-unit id="cb8b3ce6e66e52a12f5f2c0ad7e5094bda40b6b3" translate="yes" xml:space="preserve">
          <source>AsyncTaskLoaders as they solve a lot of problems that are inherent to AsyncTask</source>
          <target state="translated">AsyncTaskLoaders は AsyncTask に内在する多くの問題を解決します。</target>
        </trans-unit>
        <trans-unit id="275453a59ed88313d5d9db057a22bc44e738b318" translate="yes" xml:space="preserve">
          <source>Avoids the short-term memory leak problem</source>
          <target state="translated">短期的なメモリリークの問題を回避</target>
        </trans-unit>
        <trans-unit id="318b3c70e158fa010b651f670e102419f34b2b6f" translate="yes" xml:space="preserve">
          <source>Better platform than AsyncTask to build and re-use robust networking code. Example: if you need to do an important upload, you could do it from &lt;code&gt;AsyncTask&lt;/code&gt; in an &lt;code&gt;Activity&lt;/code&gt;, but if the user context-switches out of the app to take a phone call, the system &lt;em&gt;may&lt;/em&gt; kill the app before the upload completes. It is &lt;em&gt;less likely&lt;/em&gt; to kill an application with an active &lt;code&gt;Service&lt;/code&gt;.</source>
          <target state="translated">堅牢なネットワークコードを構築して再利用するためのAsyncTaskよりも優れたプラットフォーム。 例：重要なアップロードを行う必要がある場合は、 &lt;code&gt;Activity&lt;/code&gt; の &lt;code&gt;AsyncTask&lt;/code&gt; から実行できますが、ユーザーがアプリからコンテキストを切り替えて電話を取ると、アップロードが完了する前にシステム&lt;em&gt;が&lt;/em&gt;アプリを強制終了する場合があります。 &lt;code&gt;Service&lt;/code&gt; アクティブなアプリケーションを強制終了する&lt;em&gt;可能性&lt;/em&gt;は&lt;em&gt;低くなり&lt;/em&gt; ます 。</target>
        </trans-unit>
        <trans-unit id="b5c54e0601a5de1de7c93e6b3cb6840ff964a55c" translate="yes" xml:space="preserve">
          <source>But it &lt;em&gt;is&lt;/em&gt; possible to remove this restriction and you override the default behavior, if you are willing to accept the consequences.</source>
          <target state="translated">ただし、結果を受け入れる場合は、この制限を削除してデフォルトの動作を上書きすること&lt;em&gt;が&lt;/em&gt;できます。</target>
        </trans-unit>
        <trans-unit id="e1ccca981ca2cf568f35c92e2a96024f1c0ae2f4" translate="yes" xml:space="preserve">
          <source>By specifiying &lt;code&gt;(Schedulers.io())&lt;/code&gt;,RxAndroid will run &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt;  on a different thread.</source>
          <target state="translated">&lt;code&gt;(Schedulers.io())&lt;/code&gt; を指定すると、RxAndroidは別のスレッドで &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="a733d96f50669ee3a024320dba52c76ffd9916c0" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; we want to observe this Observable on the UI thread, i.e. we want our &lt;code&gt;onNext()&lt;/code&gt; callback to be called on the UI thread</source>
          <target state="translated">&lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; を使用して、UIスレッドでこのObservableを監視したい、つまり、UIスレッドで &lt;code&gt;onNext()&lt;/code&gt; コールバックを呼び出したい</target>
        </trans-unit>
        <trans-unit id="23e6e1c1aa426e5d7b44c38ea48e5aa37c66bf86" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start()&lt;/code&gt; on &lt;code&gt;HandlerThread&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HandlerThread&lt;/code&gt; で &lt;code&gt;start()&lt;/code&gt; を呼び出す</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="697e05789b1e07993024a18e40db15c1604fdedb" translate="yes" xml:space="preserve">
          <source>Compared to AsyncTask, this method allow to switch schedulers an arbitrary number of times (say, fetch data on one scheduler and process those data on another (say, Scheduler.computation()). You can also define you own schedulers.</source>
          <target state="translated">AsyncTaskに比べて、任意の回数だけスケジューラを切り替えることができます(例えば、あるスケジューラでデータを取得し、別のスケジューラでデータを処理する(Scheduler.computation())。また、独自のスケジューラを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="adf92671c951691565d7070c7723f7d16bbef6c3" translate="yes" xml:space="preserve">
          <source>Consequences:</source>
          <target state="translated">Consequences:</target>
        </trans-unit>
        <trans-unit id="cf1695909bd06b7d1535f7582f28ae658753161b" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;Handler&lt;/code&gt; by getting &lt;code&gt;Looper&lt;/code&gt; from &lt;code&gt;HanlerThread&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HanlerThread&lt;/code&gt; から &lt;code&gt;Looper&lt;/code&gt; を取得して &lt;code&gt;Handler&lt;/code&gt; を作成する</target>
        </trans-unit>
        <trans-unit id="012ed6c6f98adc741cd31875bdd78e842bc6cd35" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;HandlerThread&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HandlerThread&lt;/code&gt; を作成する</target>
        </trans-unit>
        <trans-unit id="9bd53b66ee3417ce806db059b05f3982150b67fa" translate="yes" xml:space="preserve">
          <source>Creating new &lt;code&gt;Thread/AsyncTask&lt;/code&gt; for each network operation is expensive. The &lt;code&gt;Thread/AsyncTask&lt;/code&gt; will be destroyed and re-created for next Network operations. But with &lt;code&gt;Handler&lt;/code&gt; and &lt;code&gt;HandlerThread&lt;/code&gt; approach, you can submit many network operations (as Runnable tasks) to single &lt;code&gt;HandlerThread&lt;/code&gt; by using &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">ネットワーク操作ごとに新しい &lt;code&gt;Thread/AsyncTask&lt;/code&gt; を作成すると、コストがかかります。 &lt;code&gt;Thread/AsyncTask&lt;/code&gt; は破棄され、次のネットワーク操作のために再作成されます。 しかし、 &lt;code&gt;Handler&lt;/code&gt; と &lt;code&gt;HandlerThread&lt;/code&gt; アプローチでは、 Handlerを使用して、単一の &lt;code&gt;HandlerThread&lt;/code&gt; に （Runnableタスクとして）多くのネットワーク操作を送信できます。</target>
        </trans-unit>
        <trans-unit id="13a59664e1f5103a439fc80adc7a71c7e98484c6" translate="yes" xml:space="preserve">
          <source>Do not change SDK version</source>
          <target state="translated">SDK のバージョンを変更しないでください。</target>
        </trans-unit>
        <trans-unit id="e0837fad2f0ae614b0356de69abcb486a696a8f6" translate="yes" xml:space="preserve">
          <source>Do not use a separate thread</source>
          <target state="translated">別スレッドを使用しないでください</target>
        </trans-unit>
        <trans-unit id="53f06da8f50dcab7efb7d76184f7462ed8af7c53" translate="yes" xml:space="preserve">
          <source>Do not use strictMode (only in debug mode)</source>
          <target state="translated">strictMode を使用しない (デバッグモードでのみ)</target>
        </trans-unit>
        <trans-unit id="502135fc6b53e36e0d9d4eaaa28073a23ea96be7" translate="yes" xml:space="preserve">
          <source>Do the network actions on another thread</source>
          <target state="translated">別のスレッドでネットワークアクションを行う</target>
        </trans-unit>
        <trans-unit id="971a8305c868fd80d22f60a4d8d160cb7a991fbe" translate="yes" xml:space="preserve">
          <source>Don't forget to add this to &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file:</source>
          <target state="translated">これを &lt;code&gt;AndroidManifest.xml&lt;/code&gt; ファイルに追加することを忘れないでください：</target>
        </trans-unit>
        <trans-unit id="06499f8ccaa126b054fb3f7150ae1a0b210d99a2" translate="yes" xml:space="preserve">
          <source>Down-sides:</source>
          <target state="translated">Down-sides:</target>
        </trans-unit>
        <trans-unit id="f814e28ec49db65c50c06aafb3321ffb79ecc2e0" translate="yes" xml:space="preserve">
          <source>Effectively, you have to create a Service and create a job using JobInfo.Builder that specifies your criteria for when to run the service.</source>
          <target state="translated">効果的には、サービスを作成し、サービスを実行するタイミングの基準を指定したJobInfo.Builderを使ってジョブを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="5c7f380f95d204aac73f23f63c7393eb0543e674" translate="yes" xml:space="preserve">
          <source>Embed your Network operation related code in &lt;code&gt;Runnable&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;Runnable&lt;/code&gt; オブジェクトにネットワーク操作関連のコードを埋め込む</target>
        </trans-unit>
        <trans-unit id="358d84aa8148063b462186c221ef88a0bda8ec99" translate="yes" xml:space="preserve">
          <source>For Example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="bc707941094afa664b5576ca9850ca3d09a0d12c" translate="yes" xml:space="preserve">
          <source>For example, if you do an HTTP request, that is a network action.</source>
          <target state="translated">例えば、HTTPリクエストを行う場合、それはネットワークアクションです。</target>
        </trans-unit>
        <trans-unit id="d351df765f999c0ca38cc9e9af0d8a607d67bcad" translate="yes" xml:space="preserve">
          <source>For me it was this:</source>
          <target state="translated">私にとってはこれでした。</target>
        </trans-unit>
        <trans-unit id="2cd0e7756ef740a068c38453f3d730fe52435f55" translate="yes" xml:space="preserve">
          <source>Full API Access</source>
          <target state="translated">フルAPIアクセス</target>
        </trans-unit>
        <trans-unit id="9bbe5a52f1f6cb3223609414a521e4f44339c8c4" translate="yes" xml:space="preserve">
          <source>Full code for both the methods</source>
          <target state="translated">両方のメソッドのフルコード</target>
        </trans-unit>
        <trans-unit id="6255759d8a74c7639f11435cf3f2acc6ab79c1ff" translate="yes" xml:space="preserve">
          <source>FutureTask</source>
          <target state="translated">FutureTask</target>
        </trans-unit>
        <trans-unit id="4430ba17611ee081b2f448917a7bd652e7f7385e" translate="yes" xml:space="preserve">
          <source>FutureTask performs asynchronous processing, however, if the result is not ready yet or processing has not complete, calling get() will be block the thread</source>
          <target state="translated">FutureTask は非同期処理を行いますが、結果がまだ準備できていない場合や処理が完了していない場合は get()を呼び出すとスレッドがブロックされます。</target>
        </trans-unit>
        <trans-unit id="bc829e2ae2b954ef4ec64093c80f2450d463725b" translate="yes" xml:space="preserve">
          <source>HandlerThread is a handy class for starting a new thread that has a looper.</source>
          <target state="translated">HandlerThreadは、ルーパーを持つ新しいスレッドを開始するための便利なクラスです。</target>
        </trans-unit>
        <trans-unit id="fd082ffa8fb62eaee846d2070533b8ec5d67f1bb" translate="yes" xml:space="preserve">
          <source>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that &lt;code&gt;start()&lt;/code&gt; must still be called.</source>
          <target state="translated">ルーパーを持つ新しいスレッドを開始するための便利なクラス。 その後、ルーパーを使用してハンドラークラスを作成できます。 &lt;code&gt;start()&lt;/code&gt; を呼び出す必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0cc52cc14e1a5685ba5239ee9b3b80609b99622a" translate="yes" xml:space="preserve">
          <source>Have a look at alternate solution using &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot;&gt;Handler&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;と&lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot;&gt;Handler&lt;/a&gt;を使用した代替ソリューションをご覧ください</target>
        </trans-unit>
        <trans-unit id="f0b9177b74ca18e621454f7f7b449caea6bc5aec" translate="yes" xml:space="preserve">
          <source>How can I fix this issue?</source>
          <target state="translated">この問題を解決するにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="0eb57f52cb28af4167bee573fad580495f3b90c8" translate="yes" xml:space="preserve">
          <source>How do you use it with the finances API?</source>
          <target state="translated">財政APIとの使い分けは?</target>
        </trans-unit>
        <trans-unit id="d51be9b048201f57b8e7a5ae6ca09d7b8a7ab43d" translate="yes" xml:space="preserve">
          <source>How to execute the task:</source>
          <target state="translated">タスクの実行方法。</target>
        </trans-unit>
        <trans-unit id="ce9f9270f0617cd02fe9defe5c7c6e34bd0b7307" translate="yes" xml:space="preserve">
          <source>How to fix 'android.os.NetworkOnMainThreadException'</source>
          <target state="translated">'android.os.NetworkOnMainThreadException' の修正方法</target>
        </trans-unit>
        <trans-unit id="8de77b5f476ed26c770e194fb605b98e1a82d3a5" translate="yes" xml:space="preserve">
          <source>I got an error while running my Android project for RssReader.</source>
          <target state="translated">RssReaderのAndroidプロジェクトを実行中にエラーが出ました。</target>
        </trans-unit>
        <trans-unit id="3b91fabc95887b693f4dfa70e1d6062162a86efd" translate="yes" xml:space="preserve">
          <source>I solved this problem using a new &lt;code&gt;Thread&lt;/code&gt;.</source>
          <target state="translated">新しい &lt;code&gt;Thread&lt;/code&gt; を使用してこの問題を解決しました。</target>
        </trans-unit>
        <trans-unit id="142d2f28bc7d6579f3b39cccf765cfe64f6ac996" translate="yes" xml:space="preserve">
          <source>I will cover several use cases for performing network operations and &lt;em&gt;a&lt;/em&gt; solution or two for each.</source>
          <target state="translated">ネットワーク操作を実行するためのいくつかの使用例と&lt;em&gt;、&lt;/em&gt;それぞれに1つまたは2つのソリューションについて説明します。</target>
        </trans-unit>
        <trans-unit id="eb79dd216f0906b69283214a67e04b660a60e8de" translate="yes" xml:space="preserve">
          <source>If you are writing the &lt;code&gt;AsyncTask&lt;/code&gt; inline and not extending as a class, and on top of this, if there is a need to get a response out of the &lt;code&gt;AsyncTask&lt;/code&gt;, one can use the &lt;code&gt;get()&lt;/code&gt; method as below.</source>
          <target state="translated">&lt;code&gt;AsyncTask&lt;/code&gt; をインラインで記述し、クラスとして拡張しない場合、さらに &lt;code&gt;AsyncTask&lt;/code&gt; から応答を取得する必要がある場合は、以下のように &lt;code&gt;get()&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="69281d3c4e6ef2c3c5df51b6142be7fb1c6cb75b" translate="yes" xml:space="preserve">
          <source>If you don't do it, you will get &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt;.</source>
          <target state="translated">そうしないと、 &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="294d9347d892ee06f7aec9c2cbf325de863f5155" translate="yes" xml:space="preserve">
          <source>If you use your own concurrent version of &lt;code&gt;IntentService&lt;/code&gt; (like the one I linked above) you can control the level of concurrency via the &lt;code&gt;Executor&lt;/code&gt;.</source>
          <target state="translated">独自の並行バージョンの &lt;code&gt;IntentService&lt;/code&gt; （上記でリンクしたバージョンなど）を使用している場合は、 &lt;code&gt;Executor&lt;/code&gt; を使用して並行性のレベルを制御できます。</target>
        </trans-unit>
        <trans-unit id="1bf6b5410ab9222ea1a93159816f0874947656d5" translate="yes" xml:space="preserve">
          <source>If you want to avoid short-term memory leaks, have well-defined execution characteristics across all platforms, and have a base to build really robust network handling, you might want to consider:</source>
          <target state="translated">短期的なメモリリークを避けたい、すべてのプラットフォームで実行特性が明確に定義されている、本当に堅牢なネットワーク処理を構築するための基盤を持っている、という場合は、検討してみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="2a046b5db560b388e6036ac3267aa757fb6a290b" translate="yes" xml:space="preserve">
          <source>If your activity restarts while network operations are in-flight it can still receive the result of the download via its &lt;code&gt;onActivityResult&lt;/code&gt; method</source>
          <target state="translated">ネットワーク操作の実行中にアクティビティが再開した場合でも、 &lt;code&gt;onActivityResult&lt;/code&gt; メソッドを介してダウンロードの結果を受け取ることができます</target>
        </trans-unit>
        <trans-unit id="e15056d48dc96cceb3b8adfa0b6afa8a93761934" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MainActivity.java&lt;/code&gt; file you can add this line within your &lt;code&gt;oncreate()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;MainActivity.java&lt;/code&gt; ファイルで、この行を &lt;code&gt;oncreate()&lt;/code&gt; メソッド内に追加できます。</target>
        </trans-unit>
        <trans-unit id="71d43b7713c727b57fbe7094e690f36b2fc0e79b" translate="yes" xml:space="preserve">
          <source>In order to use this library, include following lines into you build.gradle file:</source>
          <target state="translated">このライブラリを使用するためには、以下の行を build.gradle ファイルにインクルードしてください。</target>
        </trans-unit>
        <trans-unit id="26ea76e4dc2c3947e33f8929d580b2b84da19fd0" translate="yes" xml:space="preserve">
          <source>In simple words,</source>
          <target state="translated">簡単に言うと</target>
        </trans-unit>
        <trans-unit id="c68fcc4a48da4d9bb066c962a07aa865a403043c" translate="yes" xml:space="preserve">
          <source>In your class,</source>
          <target state="translated">あなたのクラスで</target>
        </trans-unit>
        <trans-unit id="bc9986636734c9c68a3582400c0c1e70c9517bb6" translate="yes" xml:space="preserve">
          <source>IntentService</source>
          <target state="translated">IntentService</target>
        </trans-unit>
        <trans-unit id="39086a3738cdb1e675d91ffd6a18e45c3ddb56df" translate="yes" xml:space="preserve">
          <source>Ion</source>
          <target state="translated">Ion</target>
        </trans-unit>
        <trans-unit id="8fd729c3ffbfedde4e87f47362d289b5f636e6aa" translate="yes" xml:space="preserve">
          <source>It's also &lt;strong&gt;asynchronous&lt;/strong&gt; and &lt;strong&gt;very simple&lt;/strong&gt; to use:</source>
          <target state="translated">また、 &lt;strong&gt;非同期&lt;/strong&gt;で使用するのも&lt;strong&gt;非常に簡単&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="06099f2fec31249cb21eb4300d48c7abbd4ef703" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt; or Android &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;</source>
          <target state="translated">Java &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;スレッド&lt;/a&gt;またはAndroid &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot;&gt;HandlerThread&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4660eb26c020ec9c3e4d425dc30493f95c84d638" translate="yes" xml:space="preserve">
          <source>Java threads are one-time use only and die after executing its run method.</source>
          <target state="translated">Javaのスレッドは1回限りの使用であり、その実行メソッドを実行した後に死亡します。</target>
        </trans-unit>
        <trans-unit id="814c7b03e508f3e0a9648d132455b778495c5224" translate="yes" xml:space="preserve">
          <source>JobScheduler</source>
          <target state="translated">JobScheduler</target>
        </trans-unit>
        <trans-unit id="73be87f53b04ab1f8ea8b228cfcce5293a0d74f9" translate="yes" xml:space="preserve">
          <source>Just to spell out something explicitly:</source>
          <target state="translated">明示的に何かを綴るだけで</target>
        </trans-unit>
        <trans-unit id="6a4683ba8ae8772b9e78f73379f3085027b12b73" translate="yes" xml:space="preserve">
          <source>Let's say you are building a social networking app and want to load profile pictures of friends.</source>
          <target state="translated">SNSアプリを作っていて、友達のプロフィール写真を読み込みたいとしましょう。</target>
        </trans-unit>
        <trans-unit id="dc50a9c8519026fc7d2a73b9efa6707fdeec656e" translate="yes" xml:space="preserve">
          <source>Let's say you are writing an app that lets users track stock prices, interest rates and currecy exchange rates. You find an Json API that looks something like this:</source>
          <target state="translated">ユーザーが株価、金利、為替レートを追跡できるアプリを書いているとしましょう。このようなJson APIを見つけたとします。</target>
        </trans-unit>
        <trans-unit id="c6253b343e333576f0af8c4ca137ac64ae2731c3" translate="yes" xml:space="preserve">
          <source>Let's say you're building a &quot;mood weather&quot; app that looks up the users GPS location and checks the current temperature in that area and tells them the mood. This type of app doesn't need to declare API endpoints; it just needs to be able to access one API endpoint.</source>
          <target state="translated">例えば、ユーザーのGPS位置を調べ、その地域の現在の気温をチェックして気分を伝える「ムード天気」アプリを作っているとしましょう。このタイプのアプリはAPIエンドポイントを宣言する必要はありません。</target>
        </trans-unit>
        <trans-unit id="4883643a020f221ba2797172ae9b3c377b171dd8" translate="yes" xml:space="preserve">
          <source>Library for composing asynchronous and event-based programs by using observable sequences.</source>
          <target state="translated">観測可能なシーケンスを用いて非同期プログラムやイベントベースのプログラムを構成するためのライブラリです。</target>
        </trans-unit>
        <trans-unit id="899ac73a6083f167ed75688c407fb070197364cb" translate="yes" xml:space="preserve">
          <source>Load images via HTTP</source>
          <target state="translated">HTTP経由で画像を読み込む</target>
        </trans-unit>
        <trans-unit id="c3b214c33683df211b549e5700b95cdd66d3b83d" translate="yes" xml:space="preserve">
          <source>Make the sure the target version is the same as your Android Target Library. If you are unsure what your target library is, right click your Project -&amp;gt; &lt;em&gt;Build Path&lt;/em&gt; -&amp;gt; &lt;em&gt;Android&lt;/em&gt;, and it should be the one that is ticked.</source>
          <target state="translated">ターゲットバージョンがAndroidターゲットライブラリと同じであることを確認します。 ターゲットライブラリがわからない場合は、プロジェクト-&amp;gt; &lt;em&gt;ビルドパス&lt;/em&gt; -&amp;gt; &lt;em&gt;Androidを&lt;/em&gt;右クリックし、チェックマークが付いているはずです。</target>
        </trans-unit>
        <trans-unit id="89d9c1212bd26944e5bb0d6c8ce9c682166910f2" translate="yes" xml:space="preserve">
          <source>More code and complexity than &lt;code&gt;AsyncTask&lt;/code&gt;, though not as much as you might think</source>
          <target state="translated">&lt;code&gt;AsyncTask&lt;/code&gt; よりも多くのコードと複雑さ、ただしあなたが思うほどではない</target>
        </trans-unit>
        <trans-unit id="2f48fd059f6bc28467ddae795715a3fb536ea1c5" translate="yes" xml:space="preserve">
          <source>Network-based operations cannot be run on the main thread. You need to run all network-based tasks on a child thread or implement AsyncTask.</source>
          <target state="translated">ネットワークベースの操作をメインスレッドで実行することはできません。すべてのネットワークベースのタスクを子スレッドで実行するか、AsyncTaskを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="7fb028cbee17d753e6d7524bdde797301d411f5b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;Thread&lt;/code&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; solutions have been explained already.</source>
          <target state="translated">新しい &lt;code&gt;Thread&lt;/code&gt; と&lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt;ソリューションはすでに説明されています。</target>
        </trans-unit>
        <trans-unit id="4bab309558426d69bab2e28eb64e803e2f6a2131" translate="yes" xml:space="preserve">
          <source>Note, that although it provides benefits of simplicity and readability, it has its disadvantages.</source>
          <target state="translated">シンプルで読みやすいというメリットはあるものの、デメリットもあるので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="7f88a97b0c34d5718ab601409fe417bd53cecf73" translate="yes" xml:space="preserve">
          <source>On Android, network operations cannot be run on the main thread. You can use Thread, AsyncTask (short-running tasks), Service (long-running tasks) to do network operations.</source>
          <target state="translated">Androidでは、ネットワーク操作をメインスレッドで実行することはできません。Thread,AsyncTask(短期タスク)、Service(長期タスク)を使ってネットワーク操作を行うことができます。</target>
        </trans-unit>
        <trans-unit id="bdb733ed08744b922dea36539e95fd5cf074ea0e" translate="yes" xml:space="preserve">
          <source>One off ReST API access</source>
          <target state="translated">ワンオフReST APIアクセス</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="192d153574aac488f39d715ee21fa8a4487cfccc" translate="yes" xml:space="preserve">
          <source>Picasso</source>
          <target state="translated">Picasso</target>
        </trans-unit>
        <trans-unit id="f9cca0fedd9d170b5badb24177eb529a48426caa" translate="yes" xml:space="preserve">
          <source>Please read msysmilu's great answer (&lt;a href=&quot;https://stackoverflow.com/a/28559884/1024412&quot;&gt;https://stackoverflow.com/a/28559884/1024412&lt;/a&gt;)</source>
          <target state="translated">msysmiluの素晴らしい答えを読んでください（ &lt;a href=&quot;https://stackoverflow.com/a/28559884/1024412&quot;&gt;https://stackoverflow.com/a/28559884/1024412&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="ce2d60a5ff51ab439ffcc37e3f3bd66bf7d24053" translate="yes" xml:space="preserve">
          <source>Pros of using this approach:</source>
          <target state="translated">このアプローチを使うことの利点</target>
        </trans-unit>
        <trans-unit id="500ceb00c409658dec4ebbf84c1a351a817c1a07" translate="yes" xml:space="preserve">
          <source>Put all your works inside</source>
          <target state="translated">すべての作品を中に入れて</target>
        </trans-unit>
        <trans-unit id="375a6316c9d1e17d7f86e8583f483fbbee79699c" translate="yes" xml:space="preserve">
          <source>Put your code inside:</source>
          <target state="translated">コードを中に入れて</target>
        </trans-unit>
        <trans-unit id="5c038e53bc60ed29fa76b4c0946713801ee5078f" translate="yes" xml:space="preserve">
          <source>ReST over HTTP</source>
          <target state="translated">HTTP 上の ReST</target>
        </trans-unit>
        <trans-unit id="efa1f242533e35071a673f3eff5f95cb5cfd9446" translate="yes" xml:space="preserve">
          <source>Read more &lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">続きを読む&lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot;&gt;ここ&lt;/a&gt; 、 &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot;&gt;ここ&lt;/a&gt; 、 &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot;&gt;ここ&lt;/a&gt; 、 &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot;&gt;ここ&lt;/a&gt; 、 ここ</target>
        </trans-unit>
        <trans-unit id="4cf159978b8c1183c57af358ef850a8c7dced6ea" translate="yes" xml:space="preserve">
          <source>Retrofit from Square</source>
          <target state="translated">スクエアからのレトロフィット</target>
        </trans-unit>
        <trans-unit id="9d8037932b313796752a5be70857679320624a53" translate="yes" xml:space="preserve">
          <source>RxJava</source>
          <target state="translated">RxJava</target>
        </trans-unit>
        <trans-unit id="96fc516616ad1f0b758e4f5f657fc4b2635e5d6b" translate="yes" xml:space="preserve">
          <source>Sample code snippet, which address  &lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NetworkOnMainThreadException&lt;/code&gt; に対処するサンプルコードスニペット</target>
        </trans-unit>
        <trans-unit id="4c611e5488820a251dc87fc1b9af0a580d1f066f" translate="yes" xml:space="preserve">
          <source>ScheduledThreadPoolExecutor - a class that extends ThreadPoolExecutor. It can schedule tasks after a given delay or periodically.</source>
          <target state="translated">ScheduledThreadPoolExecutor-ThreadPoolExecutor を継承したクラスです。これは、与えられた遅延後や定期的にタスクをスケジュールすることができます。</target>
        </trans-unit>
        <trans-unit id="3121c971f8834f01d89c2cd9215b7a6521e178e4" translate="yes" xml:space="preserve">
          <source>See also Stack&amp;nbsp;Overflow question:</source>
          <target state="translated">Stack Overflowの質問も参照してください。</target>
        </trans-unit>
        <trans-unit id="ac616df27cceb4363e0d7c50f345bf7f2f4a6daa" translate="yes" xml:space="preserve">
          <source>So saying that you cannot do networking operations in the main thread means you cannot do networking operations in the UI thread, which means &lt;em&gt;you cannot do networking operations in a &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; block&lt;/em&gt; inside some other thread, either.</source>
          <target state="translated">つまり、メインスレッドでネットワーク操作を実行できないということは、UIスレッドで&lt;em&gt;ネットワーク操作を実行できないこと&lt;/em&gt;を意味し&lt;em&gt;ます&lt;/em&gt; 。つまり、他のスレッド内の&lt;em&gt; &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; ブロックでネットワーク操作を実行できません。&lt;/em&gt; 、どちらか。</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="93dbabbf585e6feb938b7d234bde90abcdd14abd" translate="yes" xml:space="preserve">
          <source>Step 1: Create an &lt;code&gt;IntentService&lt;/code&gt; to perform the download. You can tell it what to download via &lt;code&gt;Intent&lt;/code&gt; extra's, and pass it a &lt;code&gt;PendingIntent&lt;/code&gt; to use to return the result to the &lt;code&gt;Activity&lt;/code&gt;:</source>
          <target state="translated">ステップ1：ダウンロードを実行する &lt;code&gt;IntentService&lt;/code&gt; を作成します。 &lt;code&gt;Intent&lt;/code&gt; エキストラ経由で何をダウンロードするかを伝え、結果を &lt;code&gt;Activity&lt;/code&gt; に返すために使用する &lt;code&gt;PendingIntent&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="abed1497c74da9e76fa8d5cd93a82cf3110827b2" translate="yes" xml:space="preserve">
          <source>Step 2: Register the service in the manifest:</source>
          <target state="translated">ステップ2:マニフェストにサービスを登録します。</target>
        </trans-unit>
        <trans-unit id="3111778701990db5c06de60bfbae8d24129dd35c" translate="yes" xml:space="preserve">
          <source>Step 3: Invoke the service from the Activity, passing a PendingResult object which the Service will use to return the result:</source>
          <target state="translated">ステップ3:アクティビティからサービスを呼び出し、サービスが結果を返すために使用するPendingResultオブジェクトを渡します。</target>
        </trans-unit>
        <trans-unit id="a3fe7bf7055a9a8288d543d002bb366a3cde45be" translate="yes" xml:space="preserve">
          <source>Step 4: Handle the result in onActivityResult:</source>
          <target state="translated">ステップ4:onActivityResultで結果を処理します。</target>
        </trans-unit>
        <trans-unit id="6bd9a85779c516e4bf76fbd5dd97142c9014f878" translate="yes" xml:space="preserve">
          <source>Submit &lt;code&gt;Runnable&lt;/code&gt; task to &lt;code&gt;Handler&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Handler&lt;/code&gt; への実行可能なタスクの送信</target>
        </trans-unit>
        <trans-unit id="9e027307bc2282959e28b51f486a3dec4ceb9254" translate="yes" xml:space="preserve">
          <source>The code for asynchronous execution will look like:</source>
          <target state="translated">非同期実行のコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="eaa902ef2c37a71b3debc3a6c7dd98ec442b927b" translate="yes" xml:space="preserve">
          <source>The device I was testing my app on was 4.1.2 which is SDK Version 16!</source>
          <target state="translated">私がアプリをテストしていた端末は4.1.2で、SDKバージョンは16でした。</target>
        </trans-unit>
        <trans-unit id="90c709da0828c17eb07bb6cbd11170be6b6c9dcf" translate="yes" xml:space="preserve">
          <source>The error is due to executing long running operations in main thread,You can easily rectify the problem by using &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsynTask&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt;. You can checkout this library &lt;a href=&quot;http://loopj.com/android-async-http/&quot;&gt;AsyncHTTPClient&lt;/a&gt; for better handling.</source>
          <target state="translated">このエラーは、メインスレッドで実行時間の長い操作が原因です&lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;。AsynTask&lt;/a&gt;または&lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt;を使用すると、問題を簡単に修正できます。 このライブラリ&lt;a href=&quot;http://loopj.com/android-async-http/&quot;&gt;AsyncHTTPClient&lt;/a&gt;をチェックアウトして、処理を向上させることができます。</target>
        </trans-unit>
        <trans-unit id="509bd62b6859aefedb8a08790c39ea7d788bc07b" translate="yes" xml:space="preserve">
          <source>The error is the SDK warning!</source>
          <target state="translated">エラーはSDKの警告!</target>
        </trans-unit>
        <trans-unit id="bde255414b3db3a3975218011dee6d7415381afe" translate="yes" xml:space="preserve">
          <source>The first verified answer advice is to use AsynTask. Yes, this is a solution, but it is obsolete nowadays, because there are new tools around.</source>
          <target state="translated">最初に検証された答えのアドバイスは、AsynTaskを使用することです。はい、これは解決策ですが、周りには新しいツールがあるので、今では時代遅れです。</target>
        </trans-unit>
        <trans-unit id="b879a9d186dc8ea701a01ff123a00f8e80bd037a" translate="yes" xml:space="preserve">
          <source>The getUrl method provides the URL address, and it will be executed on the main thread.</source>
          <target state="translated">getUrlメソッドはURLアドレスを提供し、メインスレッド上で実行されます。</target>
        </trans-unit>
        <trans-unit id="7191dfaf1027a52bf52254687dd971bf7015fa36" translate="yes" xml:space="preserve">
          <source>The last dependency includes support for the .mainThread() scheduler.</source>
          <target state="translated">最後の依存関係には .mainThread()スケジューラのサポートが含まれています。</target>
        </trans-unit>
        <trans-unit id="56596bfcc3f43fe44a848397f10abae85f9d2066" translate="yes" xml:space="preserve">
          <source>The main gist of it is, it makes asynchronous code looks so much like synchronous</source>
          <target state="translated">主な要点は、非同期コードを同期コードのように見えるようにすることです。</target>
        </trans-unit>
        <trans-unit id="e9c820beb5de62480e58a526f8b0a3743b104313" translate="yes" xml:space="preserve">
          <source>The main thread is basically the UI thread.</source>
          <target state="translated">メインスレッドは基本的にUIスレッドです。</target>
        </trans-unit>
        <trans-unit id="f1fcd0cab8c92c43bbe8eb5e1592c3328484c109" translate="yes" xml:space="preserve">
          <source>The top &lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;answer of spektom&lt;/a&gt; works perfect.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;spektom&lt;/a&gt;のトップアンサーは完璧に機能します。</target>
        </trans-unit>
        <trans-unit id="f172bda9b652708d323386b639603b2f3c88bbf9" translate="yes" xml:space="preserve">
          <source>There are many great answers already on this question, but a lot of great libraries have come out since those answers were posted. This is intended as a kind of newbie-guide.</source>
          <target state="translated">この質問にはすでに多くの素晴らしい回答がありますが、それらの回答が投稿されて以来、多くの素晴らしいライブラリが出てきています。これは一種の初心者向けのガイドです。</target>
        </trans-unit>
        <trans-unit id="d110a87147ffbd490a008785b463c8534b5e591b" translate="yes" xml:space="preserve">
          <source>There are some approaches that you should choose depends on the situation</source>
          <target state="translated">状況によって選ぶべきアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="b7e491e20bd62c867abc2057820c912ee74e10ac" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;https://github.com/Froussios/Intro-To-RxJava&quot;&gt;an excellent ebook for rx-java&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Froussios/Intro-To-RxJava&quot;&gt;rx-javaの優れた電子ブック&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="a039c317ef0ae701432a0a12db84e1a4ba1b0ba0" translate="yes" xml:space="preserve">
          <source>There is an article about &lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot;&gt;Painless Threading&lt;/a&gt; on the Android developer site which is a good introduction to this, and it will provide you with a much better depth of an answer than can be realistically provided here.</source>
          <target state="translated">Android開発者向けサイトに、 &lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot;&gt;Painless Threading&lt;/a&gt;に関する記事があり、これを紹介するのに適しています。これにより、ここで現実的に提供できるよりもはるかに深い回答が得られます。</target>
        </trans-unit>
        <trans-unit id="3fc611ee945fbb14411bd1defea7711cf15c34c1" translate="yes" xml:space="preserve">
          <source>There is another very convenient way for tackling this issue - use rxJava's concurrency capabilities. You can execute any task in background and post results to main thread in a very convenient way, so these results will be handed to processing chain.</source>
          <target state="translated">この問題に取り組むためには、もう一つ便利な方法があります-rxJavaの同時実行機能を使ってください。バックグラウンドで任意のタスクを実行し、結果をメインスレッドに投稿することができます。</target>
        </trans-unit>
        <trans-unit id="b9e790485979a363e42824420e80ddba2e4e7e0e" translate="yes" xml:space="preserve">
          <source>This exception is thrown when an application attempts to perform a networking operation on its main thread. Run your code in &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;&lt;code&gt;AsyncTask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">この例外は、アプリケーションがメインスレッドでネットワーク操作を実行しようとしたときにスローされます。 &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt; &lt;code&gt;AsyncTask&lt;/code&gt; で&lt;/a&gt;コードを実行します。</target>
        </trans-unit>
        <trans-unit id="7e61419ec095b3e0c8a04ce19bcc29e670641603" translate="yes" xml:space="preserve">
          <source>This exception occurs due to any heavy task performed on the main thread if that performing task takes &lt;em&gt;too much time&lt;/em&gt;.</source>
          <target state="translated">この例外は、メインスレッドで実行される重いタスクが原因で、その実行タスクに時間がかかり&lt;em&gt;すぎる&lt;/em&gt;場合に発生します。</target>
        </trans-unit>
        <trans-unit id="ae9bbc3e827bacbe8c9e65dacbdc9305a970f7cf" translate="yes" xml:space="preserve">
          <source>This happens in Android 3.0 and above. From Android 3.0 and above, they have restricted using network operations (functions that access the Internet) from running in the main thread/UI thread (what spawns from your on create and on resume methods in the activity).</source>
          <target state="translated">これは、Android 3.0以上で発生します。Android 3.0以上では、ネットワーク操作(インターネットにアクセスする関数)を使用してメインスレッドUIスレッド(アクティビティ内のon createメソッドとon resumeメソッドからスポーンするもの)で実行することを制限しています。</target>
        </trans-unit>
        <trans-unit id="b24a15ca4e1ad78f5f37336bab3ef204f811b2f6" translate="yes" xml:space="preserve">
          <source>This is a great library for this type of access.</source>
          <target state="translated">この手のアクセスにはもってこいの図書館です。</target>
        </trans-unit>
        <trans-unit id="644e86cdfa96466092b0882052163a5bcb511ba6" translate="yes" xml:space="preserve">
          <source>This is an excellent choice for an API with multiple endpoints and allows you to declare the ReST endpoints instead of having to code them individually as with other libraries like ion or Volley. (website: &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;)</source>
          <target state="translated">これは、複数のエンドポイントを持つAPIの優れた選択肢であり、ReSTエンドポイントを、ionやVolleyなどの他のライブラリのように個別にコーディングする代わりに宣言することができます。 （ウェブサイト： &lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;http&lt;/a&gt; : //square.github.io/retrofit/ ）</target>
        </trans-unit>
        <trans-unit id="6bb9642b33c5f9d15af7b7b29997bb23f83dd632" translate="yes" xml:space="preserve">
          <source>This is how you run a task in a child thread:</source>
          <target state="translated">子スレッドでタスクを実行する方法です。</target>
        </trans-unit>
        <trans-unit id="db8ec763b72c4b6f4ae9ec7979abcde7a79f5202" translate="yes" xml:space="preserve">
          <source>This is only thrown for applications targeting the &lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; SDK or higher. Applications targeting earlier SDK versions are allowed to do networking on their main event loop threads.</source>
          <target state="translated">これは&lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt; SDK以降をターゲットとするアプリケーションでのみスローされます。 以前のSDKバージョンをターゲットとするアプリケーションは、メインイベントループスレッドでネットワーキングを実行できます。</target>
        </trans-unit>
        <trans-unit id="57a6ff90d4f7875dcc221cf52bf70e6e5a98e004" translate="yes" xml:space="preserve">
          <source>This is the defacto choice for long running processing on Android, a good example would be to upload or download large files. The upload and download may continue even if the user exits the app and you certainly do not want to block the user from being able to use the app while these tasks are going on.</source>
          <target state="translated">これは、Android上で長時間実行される処理のためのデファクトチョイスであり、良い例としては、大容量ファイルのアップロードやダウンロードが挙げられます。アップロードやダウンロードは、ユーザーがアプリを終了しても継続される可能性があり、これらのタスクが実行されている間、ユーザーがアプリを使用することができるようにブロックしたくないのは確かです。</target>
        </trans-unit>
        <trans-unit id="ce6ed2e5a386ab2774d21d153fe76e28e13a8976" translate="yes" xml:space="preserve">
          <source>This is to encourage using separate threads for network operations. See &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; for more details on how to perform network activities the right way.</source>
          <target state="translated">これは、ネットワーク操作に個別のスレッドを使用することを推奨するためです。 ネットワークアクティビティを正しい方法で実行する方法の詳細については、 &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="50f279e5caf39dbfd8787ba3feb2f7e961537d9a" translate="yes" xml:space="preserve">
          <source>This works. Just made Dr.Luiji's answer a little simpler.</source>
          <target state="translated">これでうまくいきました。ルイジ博士の答えをもう少し簡単にしただけです。</target>
        </trans-unit>
        <trans-unit id="f4a2cb9c490779e4a09391cee0744b207dd645de" translate="yes" xml:space="preserve">
          <source>Thread pool implementation &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html&quot;&gt;ThreadPoolExecutor&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html&quot;&gt;ScheduledThreadPoolExecutor&lt;/a&gt;...</source>
          <target state="translated">スレッドプールの実装&lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html&quot;&gt;ThreadPoolExecutor&lt;/a&gt; 、 &lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html&quot;&gt;ScheduledThreadPoolExecutor&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="a397a8fa1a53e47a761c3cfea578780e310949bd" translate="yes" xml:space="preserve">
          <source>ThreadPoolExecutor class that implements ExecutorService which gives fine control on the thread pool (Eg, core pool size, max pool size, keep alive time, etc.)</source>
          <target state="translated">スレッドプールを細かく制御する ExecutorService を実装した ThreadPoolExecutor クラス (コアプールサイズ、最大プールサイズ、キープアライブ時間など)</target>
        </trans-unit>
        <trans-unit id="b6e1f519155ac4c025ed7a8bf4289234f321123a" translate="yes" xml:space="preserve">
          <source>To avoid this, we can handle it using &lt;strong&gt;threads&lt;/strong&gt; or &lt;strong&gt;executers&lt;/strong&gt;</source>
          <target state="translated">これを回避するために、 &lt;strong&gt;スレッド&lt;/strong&gt;または&lt;strong&gt;実行プログラム&lt;/strong&gt;を使用して処理できます。</target>
        </trans-unit>
        <trans-unit id="60d22d61692e90485ac3d60c7cd80e4d5fcfbb7d" translate="yes" xml:space="preserve">
          <source>To simplify all these things, Android provides various ways, like &lt;code&gt;AsyncTask&lt;/code&gt;, &lt;code&gt;AsyncTaskLoader&lt;/code&gt;, &lt;code&gt;CursorLoader&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt;. So you can use any of these according to your requirements.</source>
          <target state="translated">これらすべてを簡素化するために、Androidには、 &lt;code&gt;AsyncTaskLoader&lt;/code&gt; 、 &lt;code&gt;CursorLoader&lt;/code&gt; 、 CursorLoader 、 IntentServiceなどのさまざまな方法が用意されています。 したがって、要件に応じてこれらのいずれかを使用できます。</target>
        </trans-unit>
        <trans-unit id="1ea76dcbe8be19acd8a1982a087841a064cfcd3e" translate="yes" xml:space="preserve">
          <source>Um, I can't think of any others right now actually</source>
          <target state="translated">今は他に思いつかないわ</target>
        </trans-unit>
        <trans-unit id="97e015cdd6a1113db3a98e8adc5b707a183e653c" translate="yes" xml:space="preserve">
          <source>Up-sides:</source>
          <target state="translated">Up-sides:</target>
        </trans-unit>
        <trans-unit id="7599502cfa428edf5e093d7e32d931a81ddfe99b" translate="yes" xml:space="preserve">
          <source>Use Service or AsyncTask</source>
          <target state="translated">サービスまたは AsyncTask を使用する</target>
        </trans-unit>
        <trans-unit id="b2408a92a8a7e813ddc8d1699d4e3afbe1cbd674" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://androidannotations.org/&quot;&gt;Android Annotations&lt;/a&gt; is an option. It will allow you to simply run any method in a background thread:</source>
          <target state="translated">&lt;a href=&quot;http://androidannotations.org/&quot;&gt;Androidアノテーションの&lt;/a&gt;使用はオプションです。 これにより、バックグラウンドスレッドで任意のメソッドを簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="f80468404a516fbf71c2d620082f9ad0dca15acf" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Service&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt; instead, perhaps with a &lt;code&gt;PendingIntent&lt;/code&gt; to return the result via the Activity's &lt;code&gt;onActivityResult&lt;/code&gt; method.</source>
          <target state="translated">代わりに &lt;code&gt;Service&lt;/code&gt; または &lt;code&gt;IntentService&lt;/code&gt; を使用し、おそらくPendingIntentを使用して、アクティビティの &lt;code&gt;onActivityResult&lt;/code&gt; メソッドを介して結果を返します。</target>
        </trans-unit>
        <trans-unit id="9f70e533db0150c260360b33e601c8514945d241" translate="yes" xml:space="preserve">
          <source>Using a library that does a nice job of this for you - there's a nice comparison of networking libs in &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;this question&lt;/a&gt;, or</source>
          <target state="translated">あなたのためにこれの素晴らしい仕事をするライブラリを使う- &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;この質問に&lt;/a&gt;はネットワークライブラリの素晴らしい比較があります、または</target>
        </trans-unit>
        <trans-unit id="f095116f2fdd9535d80b88a6474753f6005d3446" translate="yes" xml:space="preserve">
          <source>Volley</source>
          <target state="translated">Volley</target>
        </trans-unit>
        <trans-unit id="1be565163d1d67c36d081e6e9ed9c89deb07ebcb" translate="yes" xml:space="preserve">
          <source>Volley requires more setup than Retrofit. You will need to create a class like this to setup a RequestQueue, an ImageLoader and an ImageCache, but it's not too bad:</source>
          <target state="translated">VolleyはRetrofitよりもセットアップが必要です。RequestQueue、ImageLoader、ImageCacheをセットアップするには、このようなクラスを作る必要がありますが、悪くはありません。</target>
        </trans-unit>
        <trans-unit id="7c0d1456a9e7d9083aa28ea885a7246ebbbd8391" translate="yes" xml:space="preserve">
          <source>When you get something from Network response and want to show it on your view (like display response message in TextView), you need to &lt;strong&gt;return back to the UI&lt;/strong&gt; thread.</source>
          <target state="translated">ネットワーク応答から何かを取得し、それをビューに表示したい場合（TextViewの応答メッセージの表示など）、 &lt;strong&gt;UI&lt;/strong&gt;スレッドに&lt;strong&gt;戻る&lt;/strong&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="9425da95831da82358ab97098eda19da644c187a" translate="yes" xml:space="preserve">
          <source>While using AsyncTask, update view from &lt;code&gt;onPostExecute()&lt;/code&gt; method</source>
          <target state="translated">AsyncTaskの使用中に、 &lt;code&gt;onPostExecute()&lt;/code&gt; メソッドからビューを更新する</target>
        </trans-unit>
        <trans-unit id="3ced8911fbbe92b803208da3ca154b423d4a6c20" translate="yes" xml:space="preserve">
          <source>Will queue requests and run them on a &lt;em&gt;single&lt;/em&gt; background thread. You can easily control this by replacing &lt;code&gt;IntentService&lt;/code&gt; with an equivalent &lt;code&gt;Service&lt;/code&gt; implementation, perhaps like &lt;a href=&quot;https://github.com/steveliles/AsyncAndroid/blob/master/AsyncAndroid/src/main/java/com/packt/asyncandroid/chapter6/ConcurrentIntentService.java&quot;&gt;this one&lt;/a&gt;.</source>
          <target state="translated">リクエストをキューに入れ、 &lt;em&gt;単一の&lt;/em&gt;バックグラウンドスレッドで実行します。 &lt;code&gt;IntentService&lt;/code&gt; を同等の &lt;code&gt;Service&lt;/code&gt; 実装に置き換えることで、おそらく&lt;a href=&quot;https://github.com/steveliles/AsyncAndroid/blob/master/AsyncAndroid/src/main/java/com/packt/asyncandroid/chapter6/ConcurrentIntentService.java&quot;&gt;これの&lt;/a&gt;ように、これを簡単に制御できます。</target>
        </trans-unit>
        <trans-unit id="5135659d0e8bd5f46b02613bfbcc4a0c825fd97d" translate="yes" xml:space="preserve">
          <source>You are able to move a part of your code into another thread to offload the &lt;code&gt;main thread&lt;/code&gt; and avoid getting &lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot;&gt;ANR&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;NetworkOnMainThreadException&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot;&gt;IllegalStateException&lt;/a&gt;(e.g. Cannot access database on the main thread since it may potentially lock the UI for a long period of time).</source>
          <target state="translated">コードの一部を別のスレッドに移動して &lt;code&gt;main thread&lt;/code&gt; 負荷を軽減し、 &lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot;&gt;ANR&lt;/a&gt; 、 &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot;&gt;NetworkOnMainThreadException&lt;/a&gt; 、 &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot;&gt;IllegalStateException&lt;/a&gt;を回避できます（たとえば、UIが長期間ロックされる可能性があるため、メインスレッドのデータベースにアクセスできません）。</target>
        </trans-unit>
        <trans-unit id="1dcb961afecc7ed4f8ff92e83e462e2977fc4e8c" translate="yes" xml:space="preserve">
          <source>You can implement an &lt;code&gt;IntentService&lt;/code&gt; to perform downloads on a single background thread quite easily.</source>
          <target state="translated">&lt;code&gt;IntentService&lt;/code&gt; を実装すると、単一のバックグラウンドスレッドで非常に簡単にダウンロードを実行できます。</target>
        </trans-unit>
        <trans-unit id="1d25b678f66da4756ee3210eff3be9f55bc5d1b1" translate="yes" xml:space="preserve">
          <source>You cannot perform network &lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot;&gt;I/O&lt;/a&gt; on the UI thread on &lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycomb&lt;/a&gt;. Technically, it &lt;em&gt;is&lt;/em&gt; possible on earlier versions of Android, but it is a really bad idea as it will cause your app to stop responding, and can result in the OS killing your app for being badly behaved. You'll need to run a background process or use AsyncTask to perform your network transaction on a background thread.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot;&gt;Honeycombの&lt;/a&gt; UIスレッドでネットワーク&lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot;&gt;I / O&lt;/a&gt;を実行することはできません。 技術的に&lt;em&gt;は&lt;/em&gt; 、以前のバージョンのAndroidでも可能ですが、アプリが応答しなくなり、OSが不適切な動作をしてアプリを強制終了する可能性があるため、これは非常に悪い考えです。 バックグラウンドスレッドでネットワークトランザクションを実行するには、バックグラウンドプロセスを実行するか、AsyncTaskを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="423211d4e7a3631585c5340a517f60b555795410" translate="yes" xml:space="preserve">
          <source>You disable the strict mode using following code:</source>
          <target state="translated">以下のコードを使用して、ストリクトモードを無効にします。</target>
        </trans-unit>
        <trans-unit id="4085af883abb5e100e006893abefcf0b463ef524" translate="yes" xml:space="preserve">
          <source>You have to create a new Thread</source>
          <target state="translated">新しいスレッドを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="d5a644a2460626c071917f71454f3652fc2ea29e" translate="yes" xml:space="preserve">
          <source>You should not do any time-consuming task on the main thread (UI thread), like any network operation, file I/O, or SQLite database operations. So for this kind of operation, you should create a worker thread, but the problem is that you can not directly perform any UI related operation from your worker thread. For that, you have to use &lt;code&gt;Handler&lt;/code&gt; and pass the &lt;code&gt;Message&lt;/code&gt;.</source>
          <target state="translated">メインスレッド（UIスレッド）では、ネットワーク操作、ファイルI / O、SQLiteデータベース操作など、時間のかかるタスクを実行しないでください。 そのため、この種の操作ではワーカースレッドを作成する必要がありますが、問題は、ワーカースレッドからUI関連の操作を直接実行できないことです。 そのためには、 &lt;code&gt;Handler&lt;/code&gt; を使用して &lt;code&gt;Message&lt;/code&gt; を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="418695ed454c9db825cf329eb6f7fd3f653d0bb5" translate="yes" xml:space="preserve">
          <source>Your app will (in areas of spotty internet connection) become unresponsive and lock up, the user perceives slowness and has to do a force kill, and you risk the activity manager killing your app and telling the user that the app has stopped.</source>
          <target state="translated">あなたのアプリは(インターネット接続が不安定な地域では)無反応になり、ロックアップされ、ユーザーは遅さを認識し、強制終了を行う必要があります、あなたはアクティビティマネージャがあなたのアプリを殺し、アプリが停止したことをユーザーに伝える危険性があります。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="7f628363b72ea19e08f323f2bc74538e842171c1" translate="yes" xml:space="preserve">
          <source>makeCallParseResponse(..) - does actual work</source>
          <target state="translated">makeCallParseResponse(...)-実際の作業を行う</target>
        </trans-unit>
        <trans-unit id="662231f30478ae40839ba8099ae853a863ad85ee" translate="yes" xml:space="preserve">
          <source>processResponse(..) - will handle result on main thread.</source>
          <target state="translated">processResponse(...)-メインスレッドで結果を処理します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
