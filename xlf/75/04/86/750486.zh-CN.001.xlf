<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/750486">
    <body>
      <group id="750486">
        <trans-unit id="dc928c660df5af8037b30d806a3d5e2bf719a6ad" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or asynchronous code, e.g. using Promises:</source>
          <target state="translated">&amp;hellip;或异步代码，例如使用Promises：</target>
        </trans-unit>
        <trans-unit id="eb729be35a722439cea750b023efdfbd8a9fd5db" translate="yes" xml:space="preserve">
          <source>(*) I'm the author of query-js and therefor biased towards using it, so don't take my words as a recommendation for said library only for the declarative approach :)</source>
          <target state="translated">(*)我是query-js的作者,因此我对使用它有偏见,所以不要把我的话当做是对这个库的推荐,只是为了声明性的方法:)</target>
        </trans-unit>
        <trans-unit id="eddee0d119554968d570b6aaa4f40b56ba855167" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;let&lt;/code&gt; makes variables block scoped. Blocks are denoted by curly braces, but in the case of the for loop the initialization variable, &lt;code&gt;i&lt;/code&gt; in our case, is considered to be declared in the braces.)</source>
          <target state="translated">（ &lt;code&gt;let&lt;/code&gt; make变量成为块作用域。块用花括号表示，但是在for循环的情况下，初始化变量（在本例中为 &lt;code&gt;i&lt;/code&gt; )被视为在花括号中声明。）</target>
        </trans-unit>
        <trans-unit id="f507a9dd45beea522efee731e516a4bfacc41cde" translate="yes" xml:space="preserve">
          <source>// edited to use &lt;code&gt;forEach&lt;/code&gt; instead of map.</source>
          <target state="translated">//编辑为使用 &lt;code&gt;forEach&lt;/code&gt; 而不是map。</target>
        </trans-unit>
        <trans-unit id="17b3607fc13ef64118c5443ba1c9c1d143b46fdd" translate="yes" xml:space="preserve">
          <source>2015 Solution: forEach</source>
          <target state="translated">2015年解决方案:对于每一个</target>
        </trans-unit>
        <trans-unit id="d16a35fbcaef2b1dca935e1c55b24f332b1909de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is similar to &lt;code&gt;let&lt;/code&gt; with the additional restriction that the variable name can't be rebound to a new reference after initial assignment.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 与 &lt;code&gt;let&lt;/code&gt; 类似，但有一个额外的限制，即变量名称在初始赋值后不能反弹到新引用。</target>
        </trans-unit>
        <trans-unit id="fbbe8653d1dfb5593d280c0119120a5978f7f167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; will then point to an object that is specific to that particular turn of the loop, and will return the correct value without the additional closure notation.  This obviously significantly simplifies this problem.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 然后将指向特定于该循环特定循环的对象，并将返回正确的值，而无需附加的闭合符号。 这显然大大简化了这个问题。</target>
        </trans-unit>
        <trans-unit id="aa353dcd5215f0728af0723f85f0b49b2fd877da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cee360f8affd282a49319123ba4b739670977a33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;JavaScript Functions close over the scope they are declared in, and retain access to that scope even as variable values inside of that scope change.&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;ldquo; JavaScript函数在声明它们的范围内关闭，并且即使该范围内的变量值发生更改，也保留对该范围的访问。&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcd4a38dd9d5d22f20fd8d103d19cba48e2a08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE2 : using let&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;案例2：使用let&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2336bd1c125961b35dcc0669018238c6a1c450b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case1&lt;/strong&gt; : &lt;strong&gt;using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;案例1&lt;/strong&gt; ： &lt;strong&gt;使用 &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db76f0a25108e4cb963d0a08f23235f505a9cc91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="928e77cd42bada13b2e96f39a542c07f34441c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt; (2014):</source>
          <target state="translated">&lt;strong&gt;编辑&lt;/strong&gt; （2014年）：</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ee4929b02b00a95af685069745e1a9289475361" translate="yes" xml:space="preserve">
          <source>A function defines a new environment</source>
          <target state="translated">一个函数定义了一个新的环境</target>
        </trans-unit>
        <trans-unit id="e2c13ee3a978048a3137a1833fb1aa49fd75d41a" translate="yes" xml:space="preserve">
          <source>After reading through various solutions, I'd like to add that the reason those solutions work is to rely on the concept of &lt;strong&gt;scope chain&lt;/strong&gt;. It's the way JavaScript resolve a variable during execution.</source>
          <target state="translated">在阅读了各种解决方案之后，我想补充一点，那些解决方案起作用的原因是依赖于&lt;strong&gt;范围链&lt;/strong&gt;的概念。 这是JavaScript在执行期间解析变量的方式。</target>
        </trans-unit>
        <trans-unit id="59f1a06e96e0a1d91f4b2f10b668ef1eb36280e5" translate="yes" xml:space="preserve">
          <source>And yet another solution: instead of creating another loop, just bind the &lt;code&gt;this&lt;/code&gt; to the return function.</source>
          <target state="translated">还有另一种解决方案：无需创建另一个循环，只需将 &lt;code&gt;this&lt;/code&gt; 绑定到return函数。</target>
        </trans-unit>
        <trans-unit id="af8dd16cbb53de1fb9c996e760b11016a9adf276" translate="yes" xml:space="preserve">
          <source>Another option is to construct a function object which will be able to close over the variable. That can be accomplished thusly</source>
          <target state="translated">另一个选择是构造一个函数对象,它将能够在变量上方关闭。这可以这样来实现</target>
        </trans-unit>
        <trans-unit id="83f0151cc81dcad21b18870ef244c89ed233b178" translate="yes" xml:space="preserve">
          <source>Another way of saying it is that the &lt;code&gt;i&lt;/code&gt; in your function is bound at the time of executing the function, not the time of creating the function.</source>
          <target state="translated">换句话说，函数中的 &lt;code&gt;i&lt;/code&gt; 是在执行函数时绑定的，而不是在创建函数时绑定的。</target>
        </trans-unit>
        <trans-unit id="fe46ee279e1078d521ad24eab1803db3091cc1ba" translate="yes" xml:space="preserve">
          <source>Another way that hasn't been mentioned yet is the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">尚未提及的另一种方法是使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a3039f572fbd5faba88c0f53f09bab9d8efef2a" translate="yes" xml:space="preserve">
          <source>As pointed out by @squint and @mekdev, you get better performance by creating the function outside the loop first and then binding the results within the loop.</source>
          <target state="translated">正如@squint和@mekdev所指出的,你可以通过先在循环外创建函数,然后在循环内绑定结果来获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="42b2efc257450cf5c19a0de0f625821526dd089a" translate="yes" xml:space="preserve">
          <source>Beware, though, that IE9-IE11 and Edge prior to Edge 14 support &lt;code&gt;let&lt;/code&gt; but get the above wrong (they don't create a new &lt;code&gt;i&lt;/code&gt; each time, so all the functions above would log 3 like they would if we used &lt;code&gt;var&lt;/code&gt;). Edge 14 finally gets it right.</source>
          <target state="translated">不过请注意，IE9-IE11和Edge 14之前的Edge支持却导致了上述错误（它们不会每次都创建一个新的 &lt;code&gt;i&lt;/code&gt; ，因此上面的所有函数都将记录3，就像我们使用 &lt;code&gt;var&lt;/code&gt; 一样 ）。 Edge 14终于正确了。</target>
        </trans-unit>
        <trans-unit id="f85de91248746eb3a5e9b79c074698a4ae4c28de" translate="yes" xml:space="preserve">
          <source>Bit late to the party, but I was exploring this issue today and noticed that many of the answers don't completely address how Javascript treats scopes, which is essentially what this boils down to.</source>
          <target state="translated">有点晚了,但我今天在探索这个问题,注意到很多答案并没有完全解决Javascript如何处理作用域的问题,而这正是问题的本质所在。</target>
        </trans-unit>
        <trans-unit id="f6d18dcd8e75cb24ac1b57dbc9fcb10f393b34db" translate="yes" xml:space="preserve">
          <source>Browser support is now here for those targeting the latest versions of browsers. &lt;code&gt;const&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; are currently supported in the latest Firefox, Safari, Edge and Chrome. It also is supported in Node, and you can use it anywhere by taking advantage of build tools like Babel.  You can see a working example here: &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http://jsfiddle.net/ben336/rbU4t/2/&lt;/a&gt;</source>
          <target state="translated">现在，针对那些针对最新版本浏览器的浏览器提供了支持。 最新的Firefox，Safari，Edge和Chrome当前支持 &lt;code&gt;const&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; 。 它在Node中也受支持，您可以利用Babel等构建工具在任何地方使用它。 您可以在此处看到一个有效的示例： &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/ben336/rbU4t/2/</target>
        </trans-unit>
        <trans-unit id="92e8592d1f91df5a55a1cfdc2e8ad8109f4f444e" translate="yes" xml:space="preserve">
          <source>By binding &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt;, solves the problem as well.</source>
          <target state="translated">通过绑定&lt;strong&gt;&lt;em&gt;此&lt;/em&gt;&lt;/strong&gt; ，也解决了问题。</target>
        </trans-unit>
        <trans-unit id="e2c0b41bb4cd85c199d654ca3b1181205c008ac6" translate="yes" xml:space="preserve">
          <source>By wrapping it in an outer function either explicitly define a helper function like &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;harto&lt;/a&gt; did or use an anonymous function like &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjorn&lt;/a&gt; did:</source>
          <target state="translated">通过将其包装在外部函数中，或者像&lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;harto&lt;/a&gt;那样显式定义一个辅助函数，或者像&lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjorn&lt;/a&gt;那样使用匿名函数：</target>
        </trans-unit>
        <trans-unit id="b00f1c7b6969ce0e50f2b22fb797f9393fa48092" translate="yes" xml:space="preserve">
          <source>Classic solution: Closures</source>
          <target state="translated">经典的解决方案。封闭器</target>
        </trans-unit>
        <trans-unit id="598760db895cc7507725eda06e8c54cdcd677e9d" translate="yes" xml:space="preserve">
          <source>Closures in loops</source>
          <target state="translated">循环中的闭合</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="dbf8d82fe089a56de712565f9c4ada9757048bdf" translate="yes" xml:space="preserve">
          <source>Creating the inner function inside a wrapper function gives the inner function a private environment that only it can access, a &quot;closure&quot;. Thus, every time we call the wrapper function we create a new inner function with it's own separate environment, ensuring that the &lt;code&gt;ilocal&lt;/code&gt; variables don't collide and overwrite each other. A few minor optimizations gives the final answer that many other SO users gave:</source>
          <target state="translated">在包装函数内部创建内部函数会为内部函数提供一个只有其才能访问的私有环境，即&amp;ldquo;闭包&amp;rdquo;。 因此，每次调用包装函数时，我们都会使用其自己的独立环境创建一个新的内部函数，以确保 &lt;code&gt;ilocal&lt;/code&gt; 变量不会发生碰撞和彼此覆盖。 进行一些次要的优化可以得出许多其他SO用户给出的最终答案：</target>
        </trans-unit>
        <trans-unit id="0bf57ac890ee94c29cbca98cfd5e5a3399af610b" translate="yes" xml:space="preserve">
          <source>Do the same thing, Go to the scopes . Now you will see two objects &lt;code&gt;&quot;Block&quot;&lt;/code&gt; and &lt;code&gt;&quot;Global&quot;&lt;/code&gt;. Now expand &lt;code&gt;Block&lt;/code&gt; object , you 
will see 'i' is defined there , and the strange thing is that , for every functions , the value if &lt;code&gt;i&lt;/code&gt; is different (0 , 1, 2).</source>
          <target state="translated">做同样的事情，转到范围。 现在，您将看到两个对象 &lt;code&gt;&quot;Block&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Global&quot;&lt;/code&gt; 。 现在展开 &lt;code&gt;Block&lt;/code&gt; 对象，您将看到在那里定义了&amp;ldquo; i&amp;rdquo;，而奇怪的是，对于每个函数，如果 &lt;code&gt;i&lt;/code&gt; 不同（0、1、2），则该值为。</target>
        </trans-unit>
        <trans-unit id="dc17cd44f5151274b6472f08f4a5ba3902b3c50d" translate="yes" xml:space="preserve">
          <source>Docs here:</source>
          <target state="translated">文件在这里。</target>
        </trans-unit>
        <trans-unit id="5b6186c2bae4c5d9cff6452027174031b440b4fc" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 (ES6) introduces new &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords that are scoped differently than &lt;code&gt;var&lt;/code&gt;-based variables. For example, in a loop with a &lt;code&gt;let&lt;/code&gt;-based index, each iteration through the loop will have a new value of &lt;code&gt;i&lt;/code&gt; where each value is scoped inside the loop, so your code would work as you expect. There are many resources, but I'd recommend &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2ality's block-scoping post&lt;/a&gt; as a great source of information.</source>
          <target state="translated">ECMAScript 6（ES6）引入了新的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 关键字，它们的作用域与基于 &lt;code&gt;var&lt;/code&gt; 的变量不同。 例如，在具有基于 &lt;code&gt;let&lt;/code&gt; 的索引的循环中，循环中的每个迭代将具有新值 &lt;code&gt;i&lt;/code&gt; ，其中每个值的作用域都在循环内，因此您的代码将按预期工作。 有很多资源，但是我建议&lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2ality的块定义范围文章&lt;/a&gt;作为大量信息来源。</target>
        </trans-unit>
        <trans-unit id="5ed5a45b23d6515c9b67dd7392bcd46f8b115bb8" translate="yes" xml:space="preserve">
          <source>ES6 solution: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">ES6解决方案： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64bc654fab8e53127f8d388bf9e93a88ac2444b0" translate="yes" xml:space="preserve">
          <source>Each function definition forms a scope consisting of all the local 
variables declared by &lt;code&gt;var&lt;/code&gt; and its &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">每个函数定义形成一个范围，该范围由 &lt;code&gt;var&lt;/code&gt; 声明的所有局部变量及其 &lt;code&gt;arguments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6de361507511a955710bf041e4598d0a56a8dae7" translate="yes" xml:space="preserve">
          <source>Each function in the array above closes over the global scope (global, simply because that happens to be the scope they're declared in).</source>
          <target state="translated">上面数组中的每个函数都会在全局作用域上关闭(全局,只是因为那恰好是它们声明的作用域)。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="c98d55c06e5db0b478bd67b5f9f6e088981d4dbc" translate="yes" xml:space="preserve">
          <source>First of all, understand what's wrong with this code:</source>
          <target state="translated">首先,了解这个代码有什么问题。</target>
        </trans-unit>
        <trans-unit id="5590c5a73882c70beab8fa507ee23f99c76c54db" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, please see &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript closure pitfalls and usage&lt;/a&gt;</source>
          <target state="translated">有关详细讨论，请参见&lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript封闭陷阱和用法&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf49ae6852c624511c9b32a1af34f1d76ca92bea" translate="yes" xml:space="preserve">
          <source>For each time &lt;code&gt;makeCounter&lt;/code&gt; is invoked, &lt;code&gt;{counter: 0}&lt;/code&gt; results in a new object being created. Also, a new copy of &lt;code&gt;obj&lt;/code&gt; 
is created as well to reference the new object. Thus, &lt;code&gt;counter1&lt;/code&gt; and &lt;code&gt;counter2&lt;/code&gt; are independent of each other.</source>
          <target state="translated">每次调用 &lt;code&gt;makeCounter&lt;/code&gt; 时 ， &lt;code&gt;{counter: 0}&lt;/code&gt; 创建一个新对象。 另外， &lt;code&gt;obj&lt;/code&gt; 创建一个新的obj副本以引用该新对象。 因此， &lt;code&gt;counter1&lt;/code&gt; 和 &lt;code&gt;counter2&lt;/code&gt; 彼此独立。</target>
        </trans-unit>
        <trans-unit id="84dd8709188509b7ebfa0a06cdf3ca787373d95d" translate="yes" xml:space="preserve">
          <source>For more detail about how closer works , please go through the awesome video tutorial &lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0&lt;/a&gt;</source>
          <target state="translated">有关更近距离工作原理的更多详细信息，请浏览精彩的视频教程&lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73383c41720fe072e14e88088ed75954af130ef2" translate="yes" xml:space="preserve">
          <source>Here when the &lt;code&gt;funcs[]&lt;/code&gt; array is being initialized, &lt;code&gt;i&lt;/code&gt; is being incremented, the &lt;code&gt;funcs&lt;/code&gt; array is initialized and the size of &lt;code&gt;func&lt;/code&gt; array becomes 3,  so &lt;code&gt;i = 3,&lt;/code&gt;. 
Now when the &lt;code&gt;funcs[j]()&lt;/code&gt; is called, it is again using the variable &lt;code&gt;i&lt;/code&gt;, which has already been incremented to 3.</source>
          <target state="translated">在这里，当 &lt;code&gt;funcs[]&lt;/code&gt; 数组被初始化时， &lt;code&gt;i&lt;/code&gt; 被递增， &lt;code&gt;funcs&lt;/code&gt; 数组被初始化并且 &lt;code&gt;func&lt;/code&gt; 数组的大小变为3，所以 &lt;code&gt;i = 3,&lt;/code&gt; ，。 现在，当调用 &lt;code&gt;funcs[j]()&lt;/code&gt; ，它再次使用变量 &lt;code&gt;i&lt;/code&gt; ，该变量已经增加到3。</target>
        </trans-unit>
        <trans-unit id="8f35d22ff5ba383350d5598f465bc196cdf3ce7b" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses &lt;code&gt;forEach&lt;/code&gt; (works back to IE9):</source>
          <target state="translated">这是使用 &lt;code&gt;forEach&lt;/code&gt; 的简单解决方案（可回溯到IE9）：</target>
        </trans-unit>
        <trans-unit id="2642451687a6d07efdd6119990ff4d294e12e364" translate="yes" xml:space="preserve">
          <source>Here's another variation on the technique, similar to Bjorn's (apphacker), which lets you assign the variable value inside the function rather than passing it as a parameter, which might be clearer sometimes:</source>
          <target state="translated">这里有另一种变体技术,类似于Bjorn(apphacker),它可以让你在函数内部分配变量值,而不是将其作为参数传递,这样有时可能会更清楚。</target>
        </trans-unit>
        <trans-unit id="e202b66610d948919c3fdefd78e9484928e84630" translate="yes" xml:space="preserve">
          <source>I prefer to use &lt;code&gt;forEach&lt;/code&gt; function, which has its own closure with creating a pseudo range:</source>
          <target state="translated">我更喜欢使用 &lt;code&gt;forEach&lt;/code&gt; 函数，该函数在创建伪范围时有其自己的关闭方式：</target>
        </trans-unit>
        <trans-unit id="992673a4459fe4cf804cfb25b0564cfb73dcf973" translate="yes" xml:space="preserve">
          <source>I'm surprised no one yet has suggested using the &lt;code&gt;forEach&lt;/code&gt; function to better avoid (re)using local variables. In fact, I'm not using &lt;code&gt;for(var i ...)&lt;/code&gt; at all anymore for this reason.</source>
          <target state="translated">我很惊讶，没有人建议使用 &lt;code&gt;forEach&lt;/code&gt; 函数来更好地避免（重新）使用局部变量。 实际上，由于这个原因，我不再使用 &lt;code&gt;for(var i ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e040e009c09ed4ea050266166917340b79d5172" translate="yes" xml:space="preserve">
          <source>If we have inner function defined inside another (outer) function, this 
forms a chain, and will be used during execution</source>
          <target state="translated">如果我们在另一个(外部)函数中定义了内部函数,这将形成一个链,并在执行过程中使用</target>
        </trans-unit>
        <trans-unit id="48318c5a7aa0cc36320e6ea3e8a2f58e178c5e74" translate="yes" xml:space="preserve">
          <source>If you happen to be working in jQuery, the &lt;code&gt;$.each()&lt;/code&gt; function gives you a similar capability.</source>
          <target state="translated">如果您碰巧在jQuery中工作，则 &lt;code&gt;$.each()&lt;/code&gt; 函数可为您提供类似的功能。</target>
        </trans-unit>
        <trans-unit id="1b95e198fd7ba1aeb8dcff4ebe0215d817d76da2" translate="yes" xml:space="preserve">
          <source>Important: JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. In other words, block statements do not introduce a scope. Although &quot;standalone&quot; blocks are valid syntax, you do not want to use standalone blocks in JavaScript, because they don't do what you think they do, if you think they do anything like such blocks in C or Java.</source>
          <target state="translated">重要的是。JavaScript没有块的作用域。用块引入的变量是在包含函数或脚本中引入的范围,设置变量的效果会在块本身之外持续存在。换句话说,块语句不引入作用域。虽然 &quot;独立的 &quot;块是有效的语法,但你不希望在JavaScript中使用独立的块,因为它们并不像你认为的那样,如果你认为它们所做的事情和C语言或Java中的这样的块一样,那么它们所做的事情就不像你认为的那样。</target>
        </trans-unit>
        <trans-unit id="fc1c433ad90b0405b9ca2f387ce719f1317f024c" translate="yes" xml:space="preserve">
          <source>In the initial code:</source>
          <target state="translated">在最初的代码中。</target>
        </trans-unit>
        <trans-unit id="3309306702dd9476c24f82f81900b045baacba18" translate="yes" xml:space="preserve">
          <source>Instead of using:</source>
          <target state="translated">而不是使用。</target>
        </trans-unit>
        <trans-unit id="0e64d1c665d5704b6db4083a7e876035507656e4" translate="yes" xml:space="preserve">
          <source>It includes the common mistake in creating closure in the loop as what we have here, as well as why we need closure and the performance consideration.</source>
          <target state="translated">它包括了在循环中创建闭合的常见错误,就像我们这里所说的那样,以及我们为什么需要闭合和性能的考虑。</target>
        </trans-unit>
        <trans-unit id="c7a62a8bcb4b3f1a995d4c6ad5d2aed23bd392a4" translate="yes" xml:space="preserve">
          <source>It outputs this:</source>
          <target state="translated">它的输出是这样的。</target>
        </trans-unit>
        <trans-unit id="446ebfbbfc1222a93e3455219c2dab41a45fae1a" translate="yes" xml:space="preserve">
          <source>JavaScript closure inside loops – simple practical example</source>
          <target state="translated">循环中的JavaScript闭包----简单的实用例子</target>
        </trans-unit>
        <trans-unit id="b59b3a0eadd20a0309b2b53fc1fde821c0efabd9" translate="yes" xml:space="preserve">
          <source>JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script</source>
          <target state="translated">JavaScript没有块的作用域。用块引入的变量是在包含函数或脚本的范围内。</target>
        </trans-unit>
        <trans-unit id="7730326939f83587e92049d0141579e4c07112ed" translate="yes" xml:space="preserve">
          <source>JavaScript functions &quot;close over&quot; the scope they have access to upon declaration, and retain access to that scope even as variables in that scope change.</source>
          <target state="translated">JavaScript函数在声明时对它们所能访问的作用域进行 &quot;关闭&quot;,并保留对该作用域的访问,即使该作用域中的变量发生变化。</target>
        </trans-unit>
        <trans-unit id="238b22aa94cfcf877019c9fda879a8c85eccf5c8" translate="yes" xml:space="preserve">
          <source>Just like before, where each inner function outputted the last value assigned to &lt;code&gt;i&lt;/code&gt;, now each inner function just outputs the last value assigned to &lt;code&gt;ilocal&lt;/code&gt;. But shouldn't each iteration have it's own &lt;code&gt;ilocal&lt;/code&gt;?</source>
          <target state="translated">就像以前一样，每个内部函数输出分配给 &lt;code&gt;i&lt;/code&gt; 的最后一个值，现在每个内部函数仅输出分配给 &lt;code&gt;ilocal&lt;/code&gt; 的最后一个值。 但是，每次迭代是否都不应拥有自己的 &lt;code&gt;ilocal&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="60de88573410b40b98c0419ee80d503add1f0b84" translate="yes" xml:space="preserve">
          <source>Just thought I'd add an explanation for clarity. For a solution, personally, I'd go with Harto's since it is the most self-explanatory way of doing it from the answers here. Any of the code posted will work, but I'd opt for a closure factory over having to write a pile of comments to explain why I'm declaring a new variable(Freddy and 1800's) or have weird embedded closure syntax(apphacker).</source>
          <target state="translated">只是想补充一个解释,以示明确。对于解决方案,我个人认为,我会选择Harto的方法,因为从这里的答案来看,这是最能说明问题的方法。发布的任何代码都可以,但我选择了一个闭包工厂,而不是写一堆注释来解释我为什么要声明一个新的变量(Freddy和1800's),或者有奇怪的嵌入式闭包语法(apphacker)。</target>
        </trans-unit>
        <trans-unit id="a8606d4d4c57cf9245d54d71c6060344bd0018af" translate="yes" xml:space="preserve">
          <source>Later those functions are invoked logging the most current value of &lt;code&gt;i&lt;/code&gt; in the global scope. That's the magic, and frustration, of closure.</source>
          <target state="translated">稍后调用这些函数，记录全局范围内 &lt;code&gt;i&lt;/code&gt; 的最新值。 这就是关闭的魔力和挫败感。</target>
        </trans-unit>
        <trans-unit id="a4cbeead2a01a91773ed38966d1bd68a0cf65493" translate="yes" xml:space="preserve">
          <source>Look how easy it is now! For more information see &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;this answer&lt;/a&gt;, which my info is based off of.</source>
          <target state="translated">看看现在有多容易！ 有关更多信息，请参见此&lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;答案&lt;/a&gt; ，我的信息基于此答案 。</target>
        </trans-unit>
        <trans-unit id="b088112b87675051406803805f579695595f5b2d" translate="yes" xml:space="preserve">
          <source>Many solutions seem correct but they don't mention it's called &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt;&lt;code&gt;Currying&lt;/code&gt;&lt;/a&gt; which is a functional programming design pattern for situations like here. 3-10 times faster than bind depending on the browser.</source>
          <target state="translated">许多解决方案似乎都是正确的，但他们没有提及它称为&lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt; &lt;code&gt;Currying&lt;/code&gt; 的情况&lt;/a&gt; ，这是一种针对此类情况的功能编程设计模式。 比绑定速度快3到10倍，具体取决于浏览器。</target>
        </trans-unit>
        <trans-unit id="e962642d87dac6e6eaabd9cce80d6d6ef936efb9" translate="yes" xml:space="preserve">
          <source>More detail can be found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">更多细节可以在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;这里&lt;/a&gt;找到</target>
        </trans-unit>
        <trans-unit id="f044a862a3c54554110bd80647a24a8aec606c78" translate="yes" xml:space="preserve">
          <source>Most of the other answers provide ways to work around by creating another variable that won't change the value for you.</source>
          <target state="translated">大多数其他的答案都提供了通过创建另一个不会为你改变值的变量来解决的方法。</target>
        </trans-unit>
        <trans-unit id="f3db1d328e14ab1aba57088c58908a1f67ace0c3" translate="yes" xml:space="preserve">
          <source>My value: 0</source>
          <target state="translated">我的值:0</target>
        </trans-unit>
        <trans-unit id="2d55b4d0b763195615ef4724ce4993d677fbd4b0" translate="yes" xml:space="preserve">
          <source>My value: 1</source>
          <target state="translated">我的价值:1</target>
        </trans-unit>
        <trans-unit id="0331560236a0dceed2a2d2b9bf6bd0e3be783b79" translate="yes" xml:space="preserve">
          <source>My value: 2</source>
          <target state="translated">我的价值:2</target>
        </trans-unit>
        <trans-unit id="e8f2bf16e2d1a506e725cd7e4f26518d4243a2b8" translate="yes" xml:space="preserve">
          <source>My value: 3</source>
          <target state="translated">我的价值。3</target>
        </trans-unit>
        <trans-unit id="6d57ec64d31326c59930512d69d111aaca5158ea" translate="yes" xml:space="preserve">
          <source>Note that whatever technique you use, the &lt;code&gt;index&lt;/code&gt; variable becomes a sort of static variable, bound to the returned copy of the inner function. I.e., changes to its value are preserved between calls. It can be very handy.</source>
          <target state="translated">请注意，无论使用哪种技术， &lt;code&gt;index&lt;/code&gt; 变量都将成为一种静态变量，绑定到内部函数的返回副本上。 即，在两次调用之间保留对其值的更改。 可能非常方便。</target>
        </trans-unit>
        <trans-unit id="d115a789a23b856b557e0cada39a69b17b4eb6ab" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;counters[0]&lt;/code&gt; and &lt;code&gt;counters[1]&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; independent. In fact, they operate on the same &lt;code&gt;obj&lt;/code&gt;!</source>
          <target state="translated">注意， &lt;code&gt;counters[0]&lt;/code&gt; 和 &lt;code&gt;counters[1]&lt;/code&gt; &lt;em&gt;不是&lt;/em&gt;独立的。 实际上，它们在相同的 &lt;code&gt;obj&lt;/code&gt; 上操作 ！</target>
        </trans-unit>
        <trans-unit id="27739c2610dea465069c0941fc061abd280f2fe1" translate="yes" xml:space="preserve">
          <source>Now open your &lt;strong&gt;chrome console window&lt;/strong&gt; by pressing &lt;strong&gt;F12&lt;/strong&gt; and refresh the page.
Expend every 3 functions inside the array.You will see an property called &lt;code&gt;[[Scopes]]&lt;/code&gt;.Expand that one. You will see one 
array object called &lt;code&gt;&quot;Global&quot;&lt;/code&gt;,expand that one. You will find a property &lt;code&gt;'i'&lt;/code&gt; declared into the object which having value 3.</source>
          <target state="translated">现在，按&lt;strong&gt;F12键&lt;/strong&gt;打开&lt;strong&gt;chrome控制台窗口&lt;/strong&gt; ，然后刷新页面。 扩展数组中的每3个函数。您将看到一个名为 &lt;code&gt;[[Scopes]]&lt;/code&gt; 的属性。将其扩展。 您将看到一个名为 &lt;code&gt;&quot;Global&quot;&lt;/code&gt; 数组对象，将其展开。 您会发现在对象中声明的属性 &lt;code&gt;'i'&lt;/code&gt; 值为3。</target>
        </trans-unit>
        <trans-unit id="9d0128e42e75de0128629303ed3317596a65ec7c" translate="yes" xml:space="preserve">
          <source>Now replace the &lt;code&gt;'var'&lt;/code&gt; with &lt;code&gt;'let'&lt;/code&gt;</source>
          <target state="translated">现在将 &lt;code&gt;'var'&lt;/code&gt; 替换为 &lt;code&gt;'let'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7a5c903dc66b4202f3fb5824fd1acaebe39b5e3" translate="yes" xml:space="preserve">
          <source>Now the question is, what is the value of variable &lt;code&gt;i&lt;/code&gt; when the function is called? Because the first loop is created with the condition of &lt;code&gt;i &amp;lt; 3&lt;/code&gt;, it stops immediately when the condition is false, so it is &lt;code&gt;i = 3&lt;/code&gt;.</source>
          <target state="translated">现在的问题是，调用函数时变量 &lt;code&gt;i&lt;/code&gt; 的值是多少？ 因为第一个循环是在条件 &lt;code&gt;i &amp;lt; 3&lt;/code&gt; 的情况下创建的，所以当条件为false时，它将立即停止，因此它是 &lt;code&gt;i = 3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abede10eb5958e091577c93ed78b659c1fd6b8d7" translate="yes" xml:space="preserve">
          <source>Now to solve this, we have many options. Below are two of them:</source>
          <target state="translated">现在要解决这个问题,我们有很多选择。下面是其中的两个方案。</target>
        </trans-unit>
        <trans-unit id="cfc6640b07aafd6b4f2b2c454cc170531c28bdd0" translate="yes" xml:space="preserve">
          <source>Other Option can be to introduce a &lt;code&gt;tempFunc&lt;/code&gt; which returns the actual function:</source>
          <target state="translated">其他选项可以是引入 &lt;code&gt;tempFunc&lt;/code&gt; ，它返回实际函数：</target>
        </trans-unit>
        <trans-unit id="34f687cbb93dc0653344b56a9a0414f48bb65986" translate="yes" xml:space="preserve">
          <source>Personally I think @Aust's &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt;more recent answer about using &lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; is the best way to do this kind of thing now. There's also lo-dash/underscore's &lt;code&gt;_.partial&lt;/code&gt; when you don't need or want to mess with &lt;code&gt;bind&lt;/code&gt;'s &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">我个人认为@Aust &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt;关于使用 &lt;code&gt;.bind&lt;/code&gt; 的最新解答&lt;/a&gt;是现在执行此类操作的最佳方法。 当您不需要或不想与 &lt;code&gt;bind&lt;/code&gt; 的 &lt;code&gt;_.partial&lt;/code&gt; 时，还可以使用破折号/下划线的 &lt;code&gt;thisArg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="33ae767cca439e92c07c52820fbd5bfdc58bbc2a" translate="yes" xml:space="preserve">
          <source>Reiterated for emphasis:</source>
          <target state="translated">再次重申,以示强调。</target>
        </trans-unit>
        <trans-unit id="73347c41ddd8169b581b07c3a5f099ea95b7fcec" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;the performance gain in different browsers&lt;/a&gt;.</source>
          <target state="translated">查看&lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;不同浏览器中的性能提升&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f14d9d164a119f095479c9bdd9465790ed99d8a9" translate="yes" xml:space="preserve">
          <source>Since there is no block scope in JavaScript - only function scope - by wrapping the function creation in a new function, you ensure that the value of &quot;i&quot; remains as you intended.</source>
          <target state="translated">因为在JavaScript中没有块作用域----只有函数作用域----通过在一个新的函数中封装函数的创建,你可以确保 &quot;i &quot;的值保持原样。</target>
        </trans-unit>
        <trans-unit id="12ea089e3baa0954613acc9720385107e03757cc" translate="yes" xml:space="preserve">
          <source>So as many others mentioned, the problem is that the inner function is referencing the same &lt;code&gt;i&lt;/code&gt; variable. So why don't we just create a new local variable each iteration, and have the inner function reference that instead?</source>
          <target state="translated">因此，正如许多其他提到的那样，问题在于内部函数正在引用相同的 &lt;code&gt;i&lt;/code&gt; 变量。 那么，为什么不每次迭代都创建一个新的局部变量，而让内部函数引用呢？</target>
        </trans-unit>
        <trans-unit id="7d7773485c1261a529fe53aef20a83135c3f681e" translate="yes" xml:space="preserve">
          <source>So, your goal is to first save the value of &lt;code&gt;i&lt;/code&gt; to function and only after that save the function to &lt;code&gt;funcs&lt;/code&gt;. This could be done for example this way:</source>
          <target state="translated">因此，您的目标是首先将 &lt;code&gt;i&lt;/code&gt; 的值保存到函数，然后 &lt;code&gt;funcs&lt;/code&gt; 函数保存到funcs 。 例如，可以通过以下方式完成此操作：</target>
        </trans-unit>
        <trans-unit id="410e0c771b6ff78915e121b00114280170dd8b10" translate="yes" xml:space="preserve">
          <source>Solution is to use another helper function:</source>
          <target state="translated">解决办法是使用另一个助手功能。</target>
        </trans-unit>
        <trans-unit id="d016322d1f5eb6c4a54ca8c4ccd762b80be09d6c" translate="yes" xml:space="preserve">
          <source>That looks uglier than ranges in other languages, but IMHO less monstrous than other solutions.</source>
          <target state="translated">这看起来比其他语言中的范围更丑,但IMHO没有其他解决方案那么可怕。</target>
        </trans-unit>
        <trans-unit id="fbf90835c1301013d8226aab628759d12857a503" translate="yes" xml:space="preserve">
          <source>The annominous function you declared will not call and check the value inside the function unless you invoke the 
functions.</source>
          <target state="translated">你所声明的年表函数不会调用和检查函数内部的值,除非你调用函数。</target>
        </trans-unit>
        <trans-unit id="4ec86a7c0d2ecc1756f2033a01be68683a88896e" translate="yes" xml:space="preserve">
          <source>The code in OP's question is replaced with &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of &lt;strong&gt;&lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">OP问题中的代码被&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;代替了&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f008bbf9daade719e6087c2d074071c310e2e621" translate="yes" xml:space="preserve">
          <source>The error actually does not occur until &lt;code&gt;funcs[someIndex]&lt;/code&gt; is executed &lt;code&gt;()&lt;/code&gt;. Using this same logic, it should be apparent that the value of &lt;code&gt;i&lt;/code&gt; is also not collected until this point either. Once the original loop finishes, &lt;code&gt;i++&lt;/code&gt; brings &lt;code&gt;i&lt;/code&gt; to the value of &lt;code&gt;3&lt;/code&gt; which results in the condition &lt;code&gt;i &amp;lt; 3&lt;/code&gt; failing and the loop ending. At this point, &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and so when &lt;code&gt;funcs[someIndex]()&lt;/code&gt; is used, and &lt;code&gt;i&lt;/code&gt; is evaluated, it is 3 - every time.</source>
          <target state="translated">在执行 &lt;code&gt;funcs[someIndex]&lt;/code&gt; 之前，实际上不会发生该错误。 使用相同的逻辑，很明显，直到这一点， &lt;code&gt;i&lt;/code&gt; 的值也不会被收集。 原始循环完成后， &lt;code&gt;i++&lt;/code&gt; 将 &lt;code&gt;i&lt;/code&gt; 的值设为 &lt;code&gt;3&lt;/code&gt; ，这会导致条件 &lt;code&gt;i &amp;lt; 3&lt;/code&gt; 失败并结束循环。 此时， &lt;code&gt;i&lt;/code&gt; 为 &lt;code&gt;3&lt;/code&gt; ，因此当使用 &lt;code&gt;funcs[someIndex]()&lt;/code&gt; 并求值 &lt;code&gt;i&lt;/code&gt; 时 ，每次为3。</target>
        </trans-unit>
        <trans-unit id="856ee0f77cb901a2d5f4921b4e1b1fda12a1619c" translate="yes" xml:space="preserve">
          <source>The idea behind this is, encapsulating the entire body of the for loop with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; (Immediately-Invoked Function Expression) and passing &lt;code&gt;new_i&lt;/code&gt; as a parameter and capturing it as &lt;code&gt;i&lt;/code&gt;. Since the anonymous function is executed immediately, the &lt;code&gt;i&lt;/code&gt; value is different for each function defined inside the anonymous function.</source>
          <target state="translated">其背后的想法是，使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; （立即调用函数表达式）封装for循环的整个主体，并传递 &lt;code&gt;new_i&lt;/code&gt; 作为参数并将其捕获为 &lt;code&gt;i&lt;/code&gt; 。 由于匿名函数会立即执行，因此匿名函数内定义的每个函数的 &lt;code&gt;i&lt;/code&gt; 值都不同。</target>
        </trans-unit>
        <trans-unit id="f1be8f1dfe77f7136b4b98db5a0445bec48d7249" translate="yes" xml:space="preserve">
          <source>The idea is that each invocation of the callback function used with the &lt;code&gt;.forEach&lt;/code&gt; loop will be its own closure. The parameter passed in to that handler is the array element specific to that particular step of the iteration. If it's used in an asynchronous callback, it won't collide with any of the other callbacks established at other steps of the iteration.</source>
          <target state="translated">这个想法是，与 &lt;code&gt;.forEach&lt;/code&gt; 循环一起使用的回调函数的每次调用都将是其自己的关闭。 传递给该处理程序的参数是特定于迭代的特定步骤的数组元素。 如果在异步回调中使用它，它将不会与在迭代其他步骤中建立的任何其他回调发生冲突。</target>
        </trans-unit>
        <trans-unit id="554e7da9cb27d2c612a6625d286e83984129f98b" translate="yes" xml:space="preserve">
          <source>The main issue with the code shown by the OP is that &lt;code&gt;i&lt;/code&gt; is never read until the second loop. To demonstrate, imagine seeing an error inside of the code</source>
          <target state="translated">OP显示的代码的主要问题是，直到第二个循环 &lt;code&gt;i&lt;/code&gt; 才被读取。 为了演示，假设看到代码内部有错误</target>
        </trans-unit>
        <trans-unit id="ac7d64ba26be65a9bdda7a473360cd89e1a6bfca" translate="yes" xml:space="preserve">
          <source>The most simple solution would be,</source>
          <target state="translated">最简单的解决办法是:</target>
        </trans-unit>
        <trans-unit id="ad056b8ebf63fda047c5428d6a688ada28283e8b" translate="yes" xml:space="preserve">
          <source>The reason your original example did not work is that all the closures you created in the loop referenced the same frame. In effect, having 3 methods on one object with only a single &lt;code&gt;i&lt;/code&gt; variable. They all printed out the same value.</source>
          <target state="translated">您的原始示例无效的原因是，您在循环中创建的所有闭包都引用了同一框架。 实际上，在一个对象上只有3个方法只有一个 &lt;code&gt;i&lt;/code&gt; 变量。 它们都打印出相同的值。</target>
        </trans-unit>
        <trans-unit id="2ad989a69c7aecece4a1ee2beea421081fc0179e" translate="yes" xml:space="preserve">
          <source>The same problem occurs when the delay in running the function is caused by using event listeners:</source>
          <target state="translated">当使用事件监听器导致函数运行延迟时,也会出现同样的问题。</target>
        </trans-unit>
        <trans-unit id="060fca584006f839b664cab15c91a1e82cb22479" translate="yes" xml:space="preserve">
          <source>There is also a let keyword instead of var, that would allow using the block scope rule. In that case defining a variable inside the for would do the trick. That said, the let keyword isn't a practical solution because of compatibility.</source>
          <target state="translated">还有一个let关键字代替var,可以使用block scope规则。在这种情况下,在for中定义一个变量就能解决问题。尽管如此,由于兼容性问题,let关键字并不是一个实际的解决方案。</target>
        </trans-unit>
        <trans-unit id="448449d35ae4a06a2d9dfb987eef9bacd22eea0a" translate="yes" xml:space="preserve">
          <source>This also means that inner functions &quot;hold onto&quot; outer variables and keep them alive, even if the outer function returns. To utilize this, we create and call a wrapper function purely to make a new scope, declare &lt;code&gt;ilocal&lt;/code&gt; in the new scope, and return an inner function that uses &lt;code&gt;ilocal&lt;/code&gt; (more explanation below):</source>
          <target state="translated">这也意味着内部函数&amp;ldquo;保持&amp;rdquo;外部变量并使它们保持活动状态，即使外部函数返回也是如此。 为了利用这一点，我们纯粹创建并调用包装函数来创建一个新的作用域，在新的作用域中声明 &lt;code&gt;ilocal&lt;/code&gt; ，并返回一个使用 &lt;code&gt;ilocal&lt;/code&gt; 的内部函数（下面有更多解释）：</target>
        </trans-unit>
        <trans-unit id="12de75a0410bd48617dd0ea44ed803a6ca2adf1b" translate="yes" xml:space="preserve">
          <source>This describes the common mistake with using closures in JavaScript.</source>
          <target state="translated">这描述了在JavaScript中使用闭包的常见错误。</target>
        </trans-unit>
        <trans-unit id="ae8410f183f820b5d96d27651b33df1df916e1be" translate="yes" xml:space="preserve">
          <source>This is because there is only one copy of &lt;code&gt;obj&lt;/code&gt; shared across all iterations of the loop, perhaps for performance reasons.
Even though &lt;code&gt;{counter: 0}&lt;/code&gt; creates a new object in each iteration, the same copy of &lt;code&gt;obj&lt;/code&gt; will just get updated with a
reference to the newest object.</source>
          <target state="translated">这是因为可能出于性能原因，在循环的所有迭代中仅共享 &lt;code&gt;obj&lt;/code&gt; 的一个副本。 即使 &lt;code&gt;{counter: 0}&lt;/code&gt; 在每次迭代中创建一个新对象，同一 &lt;code&gt;obj&lt;/code&gt; 副本也将通过引用最新对象来更新。</target>
        </trans-unit>
        <trans-unit id="8a4540349f8251832e92d8707899d72ccee1d16c" translate="yes" xml:space="preserve">
          <source>This is exactly why this bug is so tricky. Even though you are redeclaring a variable, Javascript won't throw an error, and JSLint won't even throw a warning. This is also why the best way to solve this is to take advantage of closures, which is essentially the idea that in Javascript, inner functions have access to outer variables because inner scopes &quot;enclose&quot; outer scopes.</source>
          <target state="translated">这正是这个bug如此棘手的原因。即使你在重新声明一个变量,Javascript也不会抛出错误,JSLint甚至不会抛出警告。这也是为什么解决这个问题的最好方法是利用闭包,这本质上就是在Javascript中,内部函数可以访问外部变量,因为内部作用域 &quot;包围 &quot;了外部作用域。</target>
        </trans-unit>
        <trans-unit id="5b55d617be50854b7689496d73fe6a980d489ff4" translate="yes" xml:space="preserve">
          <source>This is only one of the multiple ways to solve this problem.</source>
          <target state="translated">这只是解决这个问题的多种方法之一。</target>
        </trans-unit>
        <trans-unit id="69dff230b8b191d491a2e7f9b2016da82afd61e2" translate="yes" xml:space="preserve">
          <source>This question really shows the history of JavaScript! Now we can avoid block scoping with arrow functions and handle loops directly from DOM nodes using Object methods.</source>
          <target state="translated">这个问题真的说明了JavaScript的发展史! 现在我们可以用箭头函数避免了块的缩放,直接用对象方法处理DOM节点的循环。</target>
        </trans-unit>
        <trans-unit id="d060596a3fb90d867391aebfaa4b523816d6f393" translate="yes" xml:space="preserve">
          <source>This sends the iterator &lt;code&gt;i&lt;/code&gt; into the anonymous function of which we define as &lt;code&gt;index&lt;/code&gt;.  This creates a closure, where the variable &lt;code&gt;i&lt;/code&gt; gets saved for later use in any asynchronous functionality within the IIFE.</source>
          <target state="translated">这会将迭代器 &lt;code&gt;i&lt;/code&gt; 发送到我们定义为 &lt;code&gt;index&lt;/code&gt; 的匿名函数中。 这将创建一个闭包，其中将保存变量 &lt;code&gt;i&lt;/code&gt; ，以供以后在IIFE中的任何异步功能中使用。</target>
        </trans-unit>
        <trans-unit id="568f52b727645cf73bf4a4ec5cc6047938d24a52" translate="yes" xml:space="preserve">
          <source>This solution seems to fit any such problem since it will require minimal changes to the original code suffering from this issue. In fact, this is by design, it should not be an issue at all!</source>
          <target state="translated">这个解决方案似乎适合任何这样的问题,因为它将需要对遭受这个问题的原始代码进行最小的修改。事实上,这是设计上的,这应该完全不是问题!</target>
        </trans-unit>
        <trans-unit id="63ead8ff0238da7dad275c58b2be0db34f001961" translate="yes" xml:space="preserve">
          <source>This way, each function will have it's own variable &lt;code&gt;x&lt;/code&gt; and we set this &lt;code&gt;x&lt;/code&gt; to the value of &lt;code&gt;i&lt;/code&gt; in each iteration.</source>
          <target state="translated">这样，每个函数将拥有自己的变量 &lt;code&gt;x&lt;/code&gt; ，我们在每次迭代中将此 &lt;code&gt;x&lt;/code&gt; 设置为 &lt;code&gt;i&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="ba14827e824873be8ebe61d778cfebbcb83cf379" translate="yes" xml:space="preserve">
          <source>This works because local variables in the function scope directly, as well as function argument variables, are allocated 
new copies upon entry.</source>
          <target state="translated">这是因为直接在函数作用域中的局部变量以及函数参数变量,在进入时都会分配新的副本。</target>
        </trans-unit>
        <trans-unit id="dc5df1b4ba78c7a8aba9d785a79d7a07889df926" translate="yes" xml:space="preserve">
          <source>To get past this, you must evaluate &lt;code&gt;i&lt;/code&gt; as it is encountered. Note that this has already happened in the form of &lt;code&gt;funcs[i]&lt;/code&gt; (where there are 3 unique indexes). There are several ways to capture this value. One is to pass it in as a parameter to a function which is shown in several ways already here.</source>
          <target state="translated">为了克服这个问题，您必须对遇到的 &lt;code&gt;i&lt;/code&gt; 进行评估。 请注意，这已经以 &lt;code&gt;funcs[i]&lt;/code&gt; 的形式发生（其中有3个唯一索引）。 有几种获取此值的方法。 一种是将其作为参数传递给函数，此处已经以几种方式显示了该函数。</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="9e545c304f2b2af0893d3299d7eeb524e05f8fa5" translate="yes" xml:space="preserve">
          <source>Turns out, that's the issue. Each iteration is sharing the same scope, so every iteration after the first is just overwriting &lt;code&gt;ilocal&lt;/code&gt;. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">原来，这就是问题所在。 每次迭代共享相同的作用域，因此，第一次迭代之后的每次迭代都将覆盖 &lt;code&gt;ilocal&lt;/code&gt; 。 从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="dde2205fa0c208c200d47ab8a2639e821de84aa8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;closure&lt;/a&gt; structure, this would reduce your extra for loop. You can do it in a single for loop:</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;闭包&lt;/a&gt;结构，这样可以减少多余的for循环。 您可以在单个for循环中执行此操作：</target>
        </trans-unit>
        <trans-unit id="1d0fb26471bd522c3a6eb4395151f9fa462bd3e4" translate="yes" xml:space="preserve">
          <source>Use let(blocked-scope) instead of var.</source>
          <target state="translated">用let(block-scope)代替var。</target>
        </trans-unit>
        <trans-unit id="02390d462bc4466f4b044a7431c4ace04d0fc8eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; solves this by creating a new scope each time the &lt;code&gt;for&lt;/code&gt; loop runs, creating a separated scope for each function to close over. Various other techniques do the same thing with extra functions.</source>
          <target state="translated">使用 &lt;code&gt;let&lt;/code&gt; 代替 &lt;code&gt;var&lt;/code&gt; 可解决此问题，方法是在每次 &lt;code&gt;for&lt;/code&gt; 循环运行时创建一个新范围，为每个要关闭的函数创建一个单独的范围。 其他各种技术也可以通过其他功能来完成相同的任务。</target>
        </trans-unit>
        <trans-unit id="2e638ddaa7a309550103b73c19dacbc50a4f95be" translate="yes" xml:space="preserve">
          <source>Using a closure in a loop is tricky.</source>
          <target state="translated">在一个循环中使用闭合是很棘手的。</target>
        </trans-unit>
        <trans-unit id="e58d2a9f67a5c27e888bf7a370ee438bb7cbfe85" translate="yes" xml:space="preserve">
          <source>Using an &lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, the simplest and most readable way to enclose an index variable:</source>
          <target state="translated">使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;立即调用函数表达式&lt;/a&gt; ，这是封装索引变量的最简单，最易读的方法：</target>
        </trans-unit>
        <trans-unit id="55f01718a62a1826d870465a04e10f4146d32e91" translate="yes" xml:space="preserve">
          <source>We can initialize &lt;code&gt;i&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; or initialize a new variable &lt;code&gt;index&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; and make it equal to &lt;code&gt;i&lt;/code&gt;. So when the call is being made, &lt;code&gt;index&lt;/code&gt; will be used and its scope will end after initialization. And for calling, &lt;code&gt;index&lt;/code&gt; will be initialized again:</source>
          <target state="translated">我们可以使用 &lt;code&gt;let&lt;/code&gt; 初始化 &lt;code&gt;i&lt;/code&gt; 或使用let初始化一个新的变量 &lt;code&gt;index&lt;/code&gt; 并使它等于 &lt;code&gt;i&lt;/code&gt; 。 因此，在进行调用时，将使用 &lt;code&gt;index&lt;/code&gt; 并且其范围将在初始化后结束。 对于调用， &lt;code&gt;index&lt;/code&gt; 将再次初始化：</target>
        </trans-unit>
        <trans-unit id="13061d26e5ff9f96a4c74bef2c43e6074905c506" translate="yes" xml:space="preserve">
          <source>We can see this by checking &lt;code&gt;ilocal&lt;/code&gt; before we declare it in each iteration:</source>
          <target state="translated">我们可以通过在每次迭代中声明 &lt;code&gt;ilocal&lt;/code&gt; 之前检查ilocal来看到它：</target>
        </trans-unit>
        <trans-unit id="ecacf20dbf2ba01fc16a5963696f4d9f3b309d3a" translate="yes" xml:space="preserve">
          <source>We will check , what actually happens when you declare &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;
  one by one.</source>
          <target state="translated">我们将检查，当您声明 &lt;code&gt;var&lt;/code&gt; 并 &lt;code&gt;let&lt;/code&gt; 一一声明时实际发生了什么。</target>
        </trans-unit>
        <trans-unit id="82eaf8efa37e385e9b7152f30bdaadc0bf9ed115" translate="yes" xml:space="preserve">
          <source>Well, the problem is that the variable &lt;code&gt;i&lt;/code&gt;, within each of your anonymous functions, is bound to the same variable outside of the function.</source>
          <target state="translated">好吧，问题在于每个匿名函数中的变量 &lt;code&gt;i&lt;/code&gt; 都绑定到函数外部的相同变量。</target>
        </trans-unit>
        <trans-unit id="41eb5e4bb9040aafd86158f33adfb76207526d4e" translate="yes" xml:space="preserve">
          <source>What you need to understand is the scope of the variables in javascript is based on the function. This is an important difference than say c# where you have block scope, and just copying the variable to one inside the for will work.</source>
          <target state="translated">你需要了解的是,javascript中的变量的作用域是基于函数。这与c#中的block scope不同,在c#中,你有block scope,只要把变量复制到for里面的变量就可以了。</target>
        </trans-unit>
        <trans-unit id="63c86ee44958806285b881b5c6d1c72978293ea3" translate="yes" xml:space="preserve">
          <source>What you want to do is bind the variable within each function to a separate, unchanging value outside of the function:</source>
          <target state="translated">你要做的是将每个函数内的变量绑定到函数外的一个独立的、不变的值。</target>
        </trans-unit>
        <trans-unit id="8eedced39e77d173c59310d3d7130994ae20c1ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the solution to this basic problem?</source>
          <target state="translated">这个基本问题有什么解决方案？</target>
        </trans-unit>
        <trans-unit id="6f1a7ec31d6598725ab3a3e62f3cd605ed9af980" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, now the scope chain will be &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt;. This time &lt;code&gt;i&lt;/code&gt; can be found in the outer function's scope which is executed 3 times in the for loop, each time has value &lt;code&gt;i&lt;/code&gt; bound correctly. It won't use the value of &lt;code&gt;window.i&lt;/code&gt; when inner executed.</source>
          <target state="translated">当 &lt;code&gt;funcs&lt;/code&gt; 被执行时，作用域链现在将是 &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt; 。 这次 &lt;code&gt;i&lt;/code&gt; 可以在外部函数的作用域中找到，该作用域在for循环中执行了3次，每次都有正确绑定的值 &lt;code&gt;i&lt;/code&gt; 。 内部执行时，它将不使用 &lt;code&gt;window.i&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="136bf4b99e71d62b188da8ea337423ca7b32ee1a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, the scope chain will be &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt;. Since the variable &lt;code&gt;i&lt;/code&gt; cannot be found in &lt;code&gt;function inner&lt;/code&gt; (neither declared using &lt;code&gt;var&lt;/code&gt; nor passed as arguments), it continues to search, until the value of &lt;code&gt;i&lt;/code&gt; is eventually found in the global scope which is &lt;code&gt;window.i&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;funcs&lt;/code&gt; 被执行时，作用域链将是 &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt; 。 由于无法在 &lt;code&gt;function inner&lt;/code&gt; 找到变量 &lt;code&gt;i&lt;/code&gt; （既不使用 &lt;code&gt;var&lt;/code&gt; 声明也不作为参数传递），因此它将继续搜索，直到最终在 &lt;code&gt;window.i&lt;/code&gt; 全局范围内找到 &lt;code&gt;i&lt;/code&gt; 的值为止。</target>
        </trans-unit>
        <trans-unit id="0b6868f0d3df7b445fd72bcfe0420c84dbdc0c32" translate="yes" xml:space="preserve">
          <source>When a function gets executed, the runtime evaluates variables by searching the &lt;strong&gt;scope chain&lt;/strong&gt;. If a variable can be found in a certain point of the chain it will stop searching and use it, otherwise it continues until the global scope reached which belongs to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">执行函数时，运行时将通过搜索&lt;strong&gt;作用域链来&lt;/strong&gt;评估变量。 如果在链的某个点可以找到一个变量，它将停止搜索并使用它，否则它将一直持续到达到属于 &lt;code&gt;window&lt;/code&gt; 的全局范围为止。</target>
        </trans-unit>
        <trans-unit id="fdddce5cff579a440ec0f06c1f3a7517de4c89ef" translate="yes" xml:space="preserve">
          <source>When you create the closure, &lt;code&gt;i&lt;/code&gt; is a reference to the variable defined in the outside scope, not a copy of it as it was when you created the closure. It will be evaluated at the time of execution.</source>
          <target state="translated">创建闭包时， &lt;code&gt;i&lt;/code&gt; 是对外部作用域中定义的变量的引用，而不是创建闭包时的副本。 执行时将对其进行评估。</target>
        </trans-unit>
        <trans-unit id="c32d98513496eff571f807348f60d6eb70fa8459" translate="yes" xml:space="preserve">
          <source>When you declare a variable using &lt;code&gt;'var'&lt;/code&gt; outside a function ,it becomes global variable(you can check by typing &lt;code&gt;i&lt;/code&gt; or 
&lt;code&gt;window.i&lt;/code&gt; in console window.It will return 3).</source>
          <target state="translated">当您在函数外使用 &lt;code&gt;'var'&lt;/code&gt; 声明变量时，它将成为全局变量（您可以通过在控制台 &lt;code&gt;window.i&lt;/code&gt; 中键入 &lt;code&gt;i&lt;/code&gt; 或window.i进行检查，它将返回3）。</target>
        </trans-unit>
        <trans-unit id="0700c840cf9074a17d6a57a019478e06397f4b95" translate="yes" xml:space="preserve">
          <source>When you declare variable using &lt;code&gt;'let'&lt;/code&gt; even outside the function but inside the loop , this variable will not be a Global 
variable , it will become a &lt;code&gt;Block&lt;/code&gt; level variable which is only available for the same function only.That is the reason , we 
are getting value of &lt;code&gt;i&lt;/code&gt; different for each function when we invoke the functions.</source>
          <target state="translated">当您甚至在函数外部但在循环内部使用 &lt;code&gt;'let'&lt;/code&gt; 声明变量时，此变量将不是全局变量，它将变为 &lt;code&gt;Block&lt;/code&gt; 级变量，仅适用于同一函数。这就是我们当我们调用函数时，每个函数的 &lt;code&gt;i&lt;/code&gt; 值都不同。</target>
        </trans-unit>
        <trans-unit id="9315dce1f25ea4c4ba2729e3d74db8c96a980595" translate="yes" xml:space="preserve">
          <source>When you invoke the function , &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; takes the value from its &lt;code&gt;Global&lt;/code&gt; object and display the 
result.</source>
          <target state="translated">调用该函数时， &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; 从其 &lt;code&gt;Global&lt;/code&gt; 对象获取值并显示结果。</target>
        </trans-unit>
        <trans-unit id="a04cb324afc79fff8ebd9cd463d1cacdf8ff5c49" translate="yes" xml:space="preserve">
          <source>Whereas I'd like it to output:</source>
          <target state="translated">而我想让它输出。</target>
        </trans-unit>
        <trans-unit id="c125d7c3843c2a8edd798658a1c8b7142f2e0175" translate="yes" xml:space="preserve">
          <source>With ES6 now mainstream, we can now use the new &lt;code&gt;let&lt;/code&gt; keyword to create block-scoped variables:</source>
          <target state="translated">随着ES6现在成为主流，我们现在可以使用新的 &lt;code&gt;let&lt;/code&gt; 关键字创建块范围的变量：</target>
        </trans-unit>
        <trans-unit id="06647b92e9f39b50b8b5c9c9165cbfd5329f2810" translate="yes" xml:space="preserve">
          <source>With ES6 now widely supported, the best answer to this question has changed.  ES6 provides the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords for this exact circumstance.  Instead of messing around with closures, we can just use &lt;code&gt;let&lt;/code&gt; to set a loop scope variable like this:</source>
          <target state="translated">如今，ES6得到了广泛支持，对此问题的最佳答案已经改变。 ES6为此情况提供了 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 关键字。 不用弄乱闭包，我们可以使用 &lt;code&gt;let&lt;/code&gt; 来设置这样的循环作用域变量：</target>
        </trans-unit>
        <trans-unit id="bccb870c0505ba1198c8bd20fb323ffcaa0eec55" translate="yes" xml:space="preserve">
          <source>With new features of ES6 block level scoping is managed:</source>
          <target state="translated">通过ES6的新功能,块级范围化管理。</target>
        </trans-unit>
        <trans-unit id="3f61a03573e1881b334382ba87fe17f8963f8f85" translate="yes" xml:space="preserve">
          <source>With the relatively widespread availability of the &lt;code&gt;Array.prototype.forEach&lt;/code&gt; function (in 2015), it's worth noting that in those situations involving iteration primarily over an array of values, &lt;code&gt;.forEach()&lt;/code&gt; provides a clean, natural way to get a distinct closure for every iteration. That is, assuming you've got some sort of array containing values (DOM references, objects, whatever), and the problem arises of setting up callbacks specific to each element, you can do this:</source>
          <target state="translated">随着 &lt;code&gt;Array.prototype.forEach&lt;/code&gt; 函数的普及（在2015年），值得注意的是，在那些主要涉及对值数组进行迭代的情况下， &lt;code&gt;.forEach()&lt;/code&gt; 提供了一种干净自然的方法来为每次迭代。 也就是说，假设您有某种包含值的数组（DOM引用，对象等），并且出现了针对每个元素设置回调的问题，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="afbb288fca9f8548f939b37452aa20bfc52aa22a" translate="yes" xml:space="preserve">
          <source>Wrapping it in a function that evaluates returning the function like apphacker's answer will do the trick, as the variable now has the function scope.</source>
          <target state="translated">把它封装在一个函数中,像apphacker的答案一样,用返回函数进行评价的函数就可以了,因为这个变量现在有了函数的作用域。</target>
        </trans-unit>
        <trans-unit id="5a12c8a80e49d75e10abdc201b4e47c6ffdad1fc" translate="yes" xml:space="preserve">
          <source>You could then use your second loop and get the expected result or you could do</source>
          <target state="translated">然后,你可以使用第二个循环,得到预期的结果,或者你可以使用</target>
        </trans-unit>
        <trans-unit id="f3b66d71de3296a4d256ccc09d82d040d2cdb4f8" translate="yes" xml:space="preserve">
          <source>You could use a declarative module for lists of data such as &lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt;(*). In these situations I personally find a declarative approach less surprising</source>
          <target state="translated">您可以对数据列表使用声明性模块，例如&lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt; （*）。 在这些情况下，我个人发现声明式方法不足为奇</target>
        </trans-unit>
        <trans-unit id="ae314c4eceee085891b4c457750851f14dd5d46f" translate="yes" xml:space="preserve">
          <source>You need to understand that, in time when your functions are created, none of their code is executed, it is only saved for later. And so when they are called later, the interpreter executes them and asks: &quot;What is the current value of &lt;code&gt;i&lt;/code&gt;?&quot;</source>
          <target state="translated">您需要了解，在创建函数时，不会执行任何代码，只会将其保存以供以后使用。 因此，当稍后调用它们时，解释器将执行它们并询问：&amp;ldquo; &lt;code&gt;i&lt;/code&gt; 的当前值是多少？&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="4002c68c62355c5ff649328699085ae7df82a379" translate="yes" xml:space="preserve">
          <source>Your code doesn't work, because what it does is:</source>
          <target state="translated">你的代码不行,因为它的作用是。</target>
        </trans-unit>
        <trans-unit id="b42f3f6f796fa3cfcb6b1b8d49c7bcccc3a7164c" translate="yes" xml:space="preserve">
          <source>const</source>
          <target state="translated">const</target>
        </trans-unit>
        <trans-unit id="0262f9bb6ecbef4efbae97193c08ec335698a205" translate="yes" xml:space="preserve">
          <source>let</source>
          <target state="translated">let</target>
        </trans-unit>
        <trans-unit id="047a45ccf14f791a4c2261e7921f98e1170c10cc" translate="yes" xml:space="preserve">
          <source>no array</source>
          <target state="translated">无阵列</target>
        </trans-unit>
        <trans-unit id="90aa229371a8bfd35bc600335c626fdfc9e82632" translate="yes" xml:space="preserve">
          <source>no extra for loop</source>
          <target state="translated">不计成本</target>
        </trans-unit>
        <trans-unit id="fd20c34806b69001e12b7c2055620cd556c5b03f" translate="yes" xml:space="preserve">
          <source>try this shorter one</source>
          <target state="translated">试试这个短一点的</target>
        </trans-unit>
        <trans-unit id="a0d8045ff0e1110c300c0605fa5a3d0a54a9a9dc" translate="yes" xml:space="preserve">
          <source>which alerts &quot;2&quot;, for 3 times. This is because anonymous functions created in for loop, shares same closure, and in that closure, the value of &lt;code&gt;i&lt;/code&gt; is the same. Use this to prevent shared closure:</source>
          <target state="translated">会发出&amp;ldquo; 2&amp;rdquo;警报3次。 这是因为在for循环中创建的匿名函数共享相同的闭包，并且在该闭包中， &lt;code&gt;i&lt;/code&gt; 的值相同。 使用这个来防止共享关闭：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
