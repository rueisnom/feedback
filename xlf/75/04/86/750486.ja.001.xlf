<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/750486">
    <body>
      <group id="750486">
        <trans-unit id="dc928c660df5af8037b30d806a3d5e2bf719a6ad" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or asynchronous code, e.g. using Promises:</source>
          <target state="translated">&amp;hellip;または非同期コード、例えばPromisesの使用：</target>
        </trans-unit>
        <trans-unit id="eb729be35a722439cea750b023efdfbd8a9fd5db" translate="yes" xml:space="preserve">
          <source>(*) I'm the author of query-js and therefor biased towards using it, so don't take my words as a recommendation for said library only for the declarative approach :)</source>
          <target state="translated">(*)私は query-js の作者であり、それを使うことに偏見を持っているので、私の言葉を宣言的なアプローチのためだけにライブラリを推奨していると思わないでください :)</target>
        </trans-unit>
        <trans-unit id="eddee0d119554968d570b6aaa4f40b56ba855167" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;let&lt;/code&gt; makes variables block scoped. Blocks are denoted by curly braces, but in the case of the for loop the initialization variable, &lt;code&gt;i&lt;/code&gt; in our case, is considered to be declared in the braces.)</source>
          <target state="translated">（ &lt;code&gt;let&lt;/code&gt; を使用すると、変数のブロックスコープが作成されます。ブロックは中括弧で示されますが、forループの場合、初期化変数（この場合は &lt;code&gt;i&lt;/code&gt; ）は中括弧で宣言されていると見なされます。）</target>
        </trans-unit>
        <trans-unit id="f507a9dd45beea522efee731e516a4bfacc41cde" translate="yes" xml:space="preserve">
          <source>// edited to use &lt;code&gt;forEach&lt;/code&gt; instead of map.</source>
          <target state="translated">//マップの代わりに &lt;code&gt;forEach&lt;/code&gt; を使用するように編集されました。</target>
        </trans-unit>
        <trans-unit id="17b3607fc13ef64118c5443ba1c9c1d143b46fdd" translate="yes" xml:space="preserve">
          <source>2015 Solution: forEach</source>
          <target state="translated">2015年ソリューション:forEach</target>
        </trans-unit>
        <trans-unit id="d16a35fbcaef2b1dca935e1c55b24f332b1909de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is similar to &lt;code&gt;let&lt;/code&gt; with the additional restriction that the variable name can't be rebound to a new reference after initial assignment.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; は &lt;code&gt;let&lt;/code&gt; に似ていますが、最初の割り当て後に変数名を新しい参照に再バインドできないという追加の制限があります。</target>
        </trans-unit>
        <trans-unit id="fbbe8653d1dfb5593d280c0119120a5978f7f167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; will then point to an object that is specific to that particular turn of the loop, and will return the correct value without the additional closure notation.  This obviously significantly simplifies this problem.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; は、ループの特定のターンに固有のオブジェクトを指し、追加のクロージャー表記なしで正しい値を返します。 これは明らかにこの問題を大幅に簡素化します。</target>
        </trans-unit>
        <trans-unit id="aa353dcd5215f0728af0723f85f0b49b2fd877da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cee360f8affd282a49319123ba4b739670977a33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;JavaScript Functions close over the scope they are declared in, and retain access to that scope even as variable values inside of that scope change.&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;「JavaScript関数は、宣言されているスコープを閉じ、スコープ内の変数値が変更されても、そのスコープへのアクセスを保持します。」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcd4a38dd9d5d22f20fd8d103d19cba48e2a08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE2 : using let&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CASE2：letを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2336bd1c125961b35dcc0669018238c6a1c450b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case1&lt;/strong&gt; : &lt;strong&gt;using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Case1&lt;/strong&gt; ： &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; を使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db76f0a25108e4cb963d0a08f23235f505a9cc91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="928e77cd42bada13b2e96f39a542c07f34441c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt; (2014):</source>
          <target state="translated">&lt;strong&gt;編集&lt;/strong&gt; （2014）：</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ee4929b02b00a95af685069745e1a9289475361" translate="yes" xml:space="preserve">
          <source>A function defines a new environment</source>
          <target state="translated">関数は新しい環境を定義します。</target>
        </trans-unit>
        <trans-unit id="e2c13ee3a978048a3137a1833fb1aa49fd75d41a" translate="yes" xml:space="preserve">
          <source>After reading through various solutions, I'd like to add that the reason those solutions work is to rely on the concept of &lt;strong&gt;scope chain&lt;/strong&gt;. It's the way JavaScript resolve a variable during execution.</source>
          <target state="translated">さまざまなソリューションを読んだ後、これらのソリューションが機能する理由は、 &lt;strong&gt;スコープチェーンの&lt;/strong&gt;概念に依存するためであることを付け加えておきます。 これは、JavaScriptが実行中に変数を解決する方法です。</target>
        </trans-unit>
        <trans-unit id="59f1a06e96e0a1d91f4b2f10b668ef1eb36280e5" translate="yes" xml:space="preserve">
          <source>And yet another solution: instead of creating another loop, just bind the &lt;code&gt;this&lt;/code&gt; to the return function.</source>
          <target state="translated">そしてさらに別の解決策：別のループを作成する代わりに、 &lt;code&gt;this&lt;/code&gt; をreturn関数にバインドするだけです。</target>
        </trans-unit>
        <trans-unit id="af8dd16cbb53de1fb9c996e760b11016a9adf276" translate="yes" xml:space="preserve">
          <source>Another option is to construct a function object which will be able to close over the variable. That can be accomplished thusly</source>
          <target state="translated">もう一つの選択肢は、変数の上で閉じることができる関数オブジェクトを構築することです。これは次のようにして実現できます。</target>
        </trans-unit>
        <trans-unit id="83f0151cc81dcad21b18870ef244c89ed233b178" translate="yes" xml:space="preserve">
          <source>Another way of saying it is that the &lt;code&gt;i&lt;/code&gt; in your function is bound at the time of executing the function, not the time of creating the function.</source>
          <target state="translated">別の言い方をすると、関数の &lt;code&gt;i&lt;/code&gt; は、関数の作成時ではなく、関数の実行時にバインドされるということです。</target>
        </trans-unit>
        <trans-unit id="fe46ee279e1078d521ad24eab1803db3091cc1ba" translate="yes" xml:space="preserve">
          <source>Another way that hasn't been mentioned yet is the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">まだ言及されていないもう1つの方法は、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; &lt;/a&gt;の使用です。</target>
        </trans-unit>
        <trans-unit id="0a3039f572fbd5faba88c0f53f09bab9d8efef2a" translate="yes" xml:space="preserve">
          <source>As pointed out by @squint and @mekdev, you get better performance by creating the function outside the loop first and then binding the results within the loop.</source>
          <target state="translated">squint さんや @mekdev さんが指摘しているように、最初にループの外側で関数を作成してから、ループ内で結果をバインドするとパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="42b2efc257450cf5c19a0de0f625821526dd089a" translate="yes" xml:space="preserve">
          <source>Beware, though, that IE9-IE11 and Edge prior to Edge 14 support &lt;code&gt;let&lt;/code&gt; but get the above wrong (they don't create a new &lt;code&gt;i&lt;/code&gt; each time, so all the functions above would log 3 like they would if we used &lt;code&gt;var&lt;/code&gt;). Edge 14 finally gets it right.</source>
          <target state="translated">ただし、IE 14の前のIE9〜IE11とEdgeは、上記の誤りを犯します（毎回新しい &lt;code&gt;i&lt;/code&gt; を作成しないため、上記のすべての関数は、 &lt;code&gt;var&lt;/code&gt; を使用した場合と同様に3を記録します）。 Edge 14はついにそれを正しくします。</target>
        </trans-unit>
        <trans-unit id="f85de91248746eb3a5e9b79c074698a4ae4c28de" translate="yes" xml:space="preserve">
          <source>Bit late to the party, but I was exploring this issue today and noticed that many of the answers don't completely address how Javascript treats scopes, which is essentially what this boils down to.</source>
          <target state="translated">少し遅れての参加ですが、今日この問題を調べていて、多くの回答が Javascript がスコープをどのように扱うかについて完全には触れていないことに気付きました。</target>
        </trans-unit>
        <trans-unit id="f6d18dcd8e75cb24ac1b57dbc9fcb10f393b34db" translate="yes" xml:space="preserve">
          <source>Browser support is now here for those targeting the latest versions of browsers. &lt;code&gt;const&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; are currently supported in the latest Firefox, Safari, Edge and Chrome. It also is supported in Node, and you can use it anywhere by taking advantage of build tools like Babel.  You can see a working example here: &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http://jsfiddle.net/ben336/rbU4t/2/&lt;/a&gt;</source>
          <target state="translated">最新バージョンのブラウザーを対象とするユーザー向けに、ブラウザーのサポートが提供されています。 &lt;code&gt;const&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; は現在、最新のFirefox、Safari、Edge、Chromeでサポートされています。 Nodeでもサポートされており、Babelのようなビルドツールを利用することで、どこでも使用できます。 ここで実際の例を見ることができます： &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/ben336/rbU4t/2/</target>
        </trans-unit>
        <trans-unit id="92e8592d1f91df5a55a1cfdc2e8ad8109f4f444e" translate="yes" xml:space="preserve">
          <source>By binding &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt;, solves the problem as well.</source>
          <target state="translated">これをバインドすることで、問題も解決します。</target>
        </trans-unit>
        <trans-unit id="e2c0b41bb4cd85c199d654ca3b1181205c008ac6" translate="yes" xml:space="preserve">
          <source>By wrapping it in an outer function either explicitly define a helper function like &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;harto&lt;/a&gt; did or use an anonymous function like &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjorn&lt;/a&gt; did:</source>
          <target state="translated">それを外部関数でラップすることにより、 &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;hartoの&lt;/a&gt;ようにヘルパー関数を明示的に定義するか、 &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjornの&lt;/a&gt;ように無名関数を使用します。</target>
        </trans-unit>
        <trans-unit id="b00f1c7b6969ce0e50f2b22fb797f9393fa48092" translate="yes" xml:space="preserve">
          <source>Classic solution: Closures</source>
          <target state="translated">古典的なソリューション。クロージャ</target>
        </trans-unit>
        <trans-unit id="598760db895cc7507725eda06e8c54cdcd677e9d" translate="yes" xml:space="preserve">
          <source>Closures in loops</source>
          <target state="translated">ループ内のクロージャー</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="dbf8d82fe089a56de712565f9c4ada9757048bdf" translate="yes" xml:space="preserve">
          <source>Creating the inner function inside a wrapper function gives the inner function a private environment that only it can access, a &quot;closure&quot;. Thus, every time we call the wrapper function we create a new inner function with it's own separate environment, ensuring that the &lt;code&gt;ilocal&lt;/code&gt; variables don't collide and overwrite each other. A few minor optimizations gives the final answer that many other SO users gave:</source>
          <target state="translated">ラッパー関数内に内部関数を作成すると、内部関数に、それだけがアクセスできるプライベート環境、つまり「クロージャー」が与えられます。 したがって、ラッパー関数を呼び出すたびに、独自の環境で新しい内部関数を作成し、 &lt;code&gt;ilocal&lt;/code&gt; 変数が互いに衝突したり上書きしたりしないようにします。 いくつかのマイナーな最適化は、他の多くのSOユーザーが与えた最終的な答えを与えます：</target>
        </trans-unit>
        <trans-unit id="0bf57ac890ee94c29cbca98cfd5e5a3399af610b" translate="yes" xml:space="preserve">
          <source>Do the same thing, Go to the scopes . Now you will see two objects &lt;code&gt;&quot;Block&quot;&lt;/code&gt; and &lt;code&gt;&quot;Global&quot;&lt;/code&gt;. Now expand &lt;code&gt;Block&lt;/code&gt; object , you 
will see 'i' is defined there , and the strange thing is that , for every functions , the value if &lt;code&gt;i&lt;/code&gt; is different (0 , 1, 2).</source>
          <target state="translated">同じことを行って、スコープに移動します。 これで、2つのオブジェクト &lt;code&gt;&quot;Block&quot;&lt;/code&gt; と &lt;code&gt;&quot;Global&quot;&lt;/code&gt; ます。 &lt;code&gt;Block&lt;/code&gt; オブジェクトを展開すると、「i」がそこで定義されていることがわかります。奇妙なのは、すべての関数について、 &lt;code&gt;i&lt;/code&gt; が異なる場合の値（0、1、2）です。</target>
        </trans-unit>
        <trans-unit id="dc17cd44f5151274b6472f08f4a5ba3902b3c50d" translate="yes" xml:space="preserve">
          <source>Docs here:</source>
          <target state="translated">ドクはこちら</target>
        </trans-unit>
        <trans-unit id="b9fe62386d70662f1db6b480e16730b97172e263" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 (ES6) introduces new &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords that are scoped differently than &lt;code&gt;var&lt;/code&gt;-based variables. For example, in a loop with a &lt;code&gt;let&lt;/code&gt;-based index, each iteration through the loop will have a new variable &lt;code&gt;i&lt;/code&gt; with loop scope, so your code would work as you expect. There are many resources, but I'd recommend &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2ality's block-scoping post&lt;/a&gt; as a great source of information.</source>
          <target state="translated">ECMAScript 6（ES6）では、 &lt;code&gt;var&lt;/code&gt; ベースの変数とはスコープが異なる新しい &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; キーワードが導入されています。 たとえば、 &lt;code&gt;let&lt;/code&gt; ベースのインデックスを持つループでは、ループの各反復にループスコープを持つ新しい変数 &lt;code&gt;i&lt;/code&gt; があるため、コードは期待どおりに機能します。 多くのリソースがありますが、 &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2alityのブロックスコーピングの投稿&lt;/a&gt;を優れた情報源としてお勧めします。</target>
        </trans-unit>
        <trans-unit id="5ed5a45b23d6515c9b67dd7392bcd46f8b115bb8" translate="yes" xml:space="preserve">
          <source>ES6 solution: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">ES6ソリューション： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64bc654fab8e53127f8d388bf9e93a88ac2444b0" translate="yes" xml:space="preserve">
          <source>Each function definition forms a scope consisting of all the local 
variables declared by &lt;code&gt;var&lt;/code&gt; and its &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">各関数定義は、 &lt;code&gt;var&lt;/code&gt; とその &lt;code&gt;arguments&lt;/code&gt; によって宣言されたすべてのローカル変数で構成されるスコープを形成します 。</target>
        </trans-unit>
        <trans-unit id="6de361507511a955710bf041e4598d0a56a8dae7" translate="yes" xml:space="preserve">
          <source>Each function in the array above closes over the global scope (global, simply because that happens to be the scope they're declared in).</source>
          <target state="translated">上の配列の各関数は、グローバルスコープ (グローバル、単に宣言されているスコープがたまたまそのスコープであるからです)で閉じます。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="c98d55c06e5db0b478bd67b5f9f6e088981d4dbc" translate="yes" xml:space="preserve">
          <source>First of all, understand what's wrong with this code:</source>
          <target state="translated">まず、このコードの何が悪いのかを理解しましょう。</target>
        </trans-unit>
        <trans-unit id="5590c5a73882c70beab8fa507ee23f99c76c54db" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, please see &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript closure pitfalls and usage&lt;/a&gt;</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScriptクロージャーの落とし穴と使用法&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="bf49ae6852c624511c9b32a1af34f1d76ca92bea" translate="yes" xml:space="preserve">
          <source>For each time &lt;code&gt;makeCounter&lt;/code&gt; is invoked, &lt;code&gt;{counter: 0}&lt;/code&gt; results in a new object being created. Also, a new copy of &lt;code&gt;obj&lt;/code&gt; 
is created as well to reference the new object. Thus, &lt;code&gt;counter1&lt;/code&gt; and &lt;code&gt;counter2&lt;/code&gt; are independent of each other.</source>
          <target state="translated">&lt;code&gt;makeCounter&lt;/code&gt; が呼び出されるたびに、 &lt;code&gt;{counter: 0}&lt;/code&gt; によって新しいオブジェクトが作成されます。 また、新しいオブジェクトを参照するために、 &lt;code&gt;obj&lt;/code&gt; の新しいコピーも作成されます。 したがって、 &lt;code&gt;counter1&lt;/code&gt; と &lt;code&gt;counter2&lt;/code&gt; は互いに独立しています。</target>
        </trans-unit>
        <trans-unit id="84dd8709188509b7ebfa0a06cdf3ca787373d95d" translate="yes" xml:space="preserve">
          <source>For more detail about how closer works , please go through the awesome video tutorial &lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0&lt;/a&gt;</source>
          <target state="translated">接近性の詳細については、素晴らしい動画チュートリアル&lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0をご覧ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73383c41720fe072e14e88088ed75954af130ef2" translate="yes" xml:space="preserve">
          <source>Here when the &lt;code&gt;funcs[]&lt;/code&gt; array is being initialized, &lt;code&gt;i&lt;/code&gt; is being incremented, the &lt;code&gt;funcs&lt;/code&gt; array is initialized and the size of &lt;code&gt;func&lt;/code&gt; array becomes 3,  so &lt;code&gt;i = 3,&lt;/code&gt;. 
Now when the &lt;code&gt;funcs[j]()&lt;/code&gt; is called, it is again using the variable &lt;code&gt;i&lt;/code&gt;, which has already been incremented to 3.</source>
          <target state="translated">ここで、 &lt;code&gt;funcs[]&lt;/code&gt; 配列が初期化され、 &lt;code&gt;i&lt;/code&gt; がインクリメントされ、 &lt;code&gt;funcs&lt;/code&gt; 配列が初期化され、 &lt;code&gt;func&lt;/code&gt; 配列のサイズが3になるため、 &lt;code&gt;i = 3,&lt;/code&gt; ます。 &lt;code&gt;funcs[j]()&lt;/code&gt; が呼び出されると、すでに3にインクリメントされた変数 &lt;code&gt;i&lt;/code&gt; が再び使用されています。</target>
        </trans-unit>
        <trans-unit id="8f35d22ff5ba383350d5598f465bc196cdf3ce7b" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses &lt;code&gt;forEach&lt;/code&gt; (works back to IE9):</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; を使用する簡単なソリューションを次に示します（IE9まで機能します）。</target>
        </trans-unit>
        <trans-unit id="2642451687a6d07efdd6119990ff4d294e12e364" translate="yes" xml:space="preserve">
          <source>Here's another variation on the technique, similar to Bjorn's (apphacker), which lets you assign the variable value inside the function rather than passing it as a parameter, which might be clearer sometimes:</source>
          <target state="translated">これは、パラメータとして渡すのではなく、関数内で変数の値を代入することができます。</target>
        </trans-unit>
        <trans-unit id="e202b66610d948919c3fdefd78e9484928e84630" translate="yes" xml:space="preserve">
          <source>I prefer to use &lt;code&gt;forEach&lt;/code&gt; function, which has its own closure with creating a pseudo range:</source>
          <target state="translated">私は、疑似範囲を作成する独自のクロージャーを持つ &lt;code&gt;forEach&lt;/code&gt; 関数を使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="992673a4459fe4cf804cfb25b0564cfb73dcf973" translate="yes" xml:space="preserve">
          <source>I'm surprised no one yet has suggested using the &lt;code&gt;forEach&lt;/code&gt; function to better avoid (re)using local variables. In fact, I'm not using &lt;code&gt;for(var i ...)&lt;/code&gt; at all anymore for this reason.</source>
          <target state="translated">ローカル変数の使用を（再）回避するために &lt;code&gt;forEach&lt;/code&gt; 関数を使用することをまだ誰も提案していないことに驚いています。 実際、私はこの理由で &lt;code&gt;for(var i ...)&lt;/code&gt; をまったく使用していません。</target>
        </trans-unit>
        <trans-unit id="2e040e009c09ed4ea050266166917340b79d5172" translate="yes" xml:space="preserve">
          <source>If we have inner function defined inside another (outer) function, this 
forms a chain, and will be used during execution</source>
          <target state="translated">内側の関数が別の (外側の)関数の中で定義されている場合、これはチェーンを形成し、実行時に使用されます。</target>
        </trans-unit>
        <trans-unit id="48318c5a7aa0cc36320e6ea3e8a2f58e178c5e74" translate="yes" xml:space="preserve">
          <source>If you happen to be working in jQuery, the &lt;code&gt;$.each()&lt;/code&gt; function gives you a similar capability.</source>
          <target state="translated">たまたまjQueryで作業している場合、 &lt;code&gt;$.each()&lt;/code&gt; 関数は同様の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="1b95e198fd7ba1aeb8dcff4ebe0215d817d76da2" translate="yes" xml:space="preserve">
          <source>Important: JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. In other words, block statements do not introduce a scope. Although &quot;standalone&quot; blocks are valid syntax, you do not want to use standalone blocks in JavaScript, because they don't do what you think they do, if you think they do anything like such blocks in C or Java.</source>
          <target state="translated">重要です。JavaScriptにはブロックスコープがありません。ブロックで導入された変数は、その中に含まれる関数やスクリプトにスコープが適用され、それらを設定した効果はブロック自体を超えて持続します。言い換えれば、ブロック文はスコープを導入しません。スタンドアロン」ブロックは有効な構文ですが、CやJavaでそのようなブロックのようなことをすると思っているのであれば、JavaScriptでスタンドアロンブロックを使うのは避けた方がいいでしょう。</target>
        </trans-unit>
        <trans-unit id="fc1c433ad90b0405b9ca2f387ce719f1317f024c" translate="yes" xml:space="preserve">
          <source>In the initial code:</source>
          <target state="translated">初期コードでは</target>
        </trans-unit>
        <trans-unit id="3309306702dd9476c24f82f81900b045baacba18" translate="yes" xml:space="preserve">
          <source>Instead of using:</source>
          <target state="translated">使う代わりに</target>
        </trans-unit>
        <trans-unit id="0e64d1c665d5704b6db4083a7e876035507656e4" translate="yes" xml:space="preserve">
          <source>It includes the common mistake in creating closure in the loop as what we have here, as well as why we need closure and the performance consideration.</source>
          <target state="translated">ここにあるものとして、ループの中にクロージャーを作る際によくある間違いや、なぜクロージャーが必要なのか、パフォーマンスへの配慮などが含まれています。</target>
        </trans-unit>
        <trans-unit id="c7a62a8bcb4b3f1a995d4c6ad5d2aed23bd392a4" translate="yes" xml:space="preserve">
          <source>It outputs this:</source>
          <target state="translated">これを出力します。</target>
        </trans-unit>
        <trans-unit id="446ebfbbfc1222a93e3455219c2dab41a45fae1a" translate="yes" xml:space="preserve">
          <source>JavaScript closure inside loops – simple practical example</source>
          <target state="translated">ループ内のJavaScriptクロージャ-簡単な実用例</target>
        </trans-unit>
        <trans-unit id="b59b3a0eadd20a0309b2b53fc1fde821c0efabd9" translate="yes" xml:space="preserve">
          <source>JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script</source>
          <target state="translated">JavaScriptにはブロックスコープがありません。ブロックで導入された変数は、その中に含まれる関数やスクリプトにスコープされます。</target>
        </trans-unit>
        <trans-unit id="7730326939f83587e92049d0141579e4c07112ed" translate="yes" xml:space="preserve">
          <source>JavaScript functions &quot;close over&quot; the scope they have access to upon declaration, and retain access to that scope even as variables in that scope change.</source>
          <target state="translated">JavaScript の関数は、宣言時にアクセスできるスコープを &quot;クローズオーバー&quot; し、そのスコープ内の変数が変更されてもそのスコープへのアクセスを保持します。</target>
        </trans-unit>
        <trans-unit id="238b22aa94cfcf877019c9fda879a8c85eccf5c8" translate="yes" xml:space="preserve">
          <source>Just like before, where each inner function outputted the last value assigned to &lt;code&gt;i&lt;/code&gt;, now each inner function just outputs the last value assigned to &lt;code&gt;ilocal&lt;/code&gt;. But shouldn't each iteration have it's own &lt;code&gt;ilocal&lt;/code&gt;?</source>
          <target state="translated">前と同じように、各内部関数は &lt;code&gt;i&lt;/code&gt; に割り当てられた最後の値を出力しましたが、ここで各内部関数は &lt;code&gt;ilocal&lt;/code&gt; に割り当てられた最後の値を出力します。 しかし、各反復に独自の &lt;code&gt;ilocal&lt;/code&gt; があるべきではありませんか？</target>
        </trans-unit>
        <trans-unit id="60de88573410b40b98c0419ee80d503add1f0b84" translate="yes" xml:space="preserve">
          <source>Just thought I'd add an explanation for clarity. For a solution, personally, I'd go with Harto's since it is the most self-explanatory way of doing it from the answers here. Any of the code posted will work, but I'd opt for a closure factory over having to write a pile of comments to explain why I'm declaring a new variable(Freddy and 1800's) or have weird embedded closure syntax(apphacker).</source>
          <target state="translated">分かりやすくするために説明を付け加えようと思っただけです。解決策としては、個人的には、ここでの回答の中で最もわかりやすい方法だと思うので、Hartoのものを選ぶと思います。投稿されたコードはどれでも動作しますが、なぜ新しい変数を宣言しているのかを説明するためにコメントの山を書かなければならなかったり(フレディと1800's)、奇妙なクロージャ構文が埋め込まれていたり(apphacker)するよりは、クロージャファクトリを選ぶと思います。</target>
        </trans-unit>
        <trans-unit id="a8606d4d4c57cf9245d54d71c6060344bd0018af" translate="yes" xml:space="preserve">
          <source>Later those functions are invoked logging the most current value of &lt;code&gt;i&lt;/code&gt; in the global scope. That's the magic, and frustration, of closure.</source>
          <target state="translated">後でこれらの関数が呼び出され、グローバルスコープで &lt;code&gt;i&lt;/code&gt; の最新の値がログに記録されます。 それが閉鎖の魔法であり、欲求不満です。</target>
        </trans-unit>
        <trans-unit id="a4cbeead2a01a91773ed38966d1bd68a0cf65493" translate="yes" xml:space="preserve">
          <source>Look how easy it is now! For more information see &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;this answer&lt;/a&gt;, which my info is based off of.</source>
          <target state="translated">とても簡単です。 詳細については、 &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;この&lt;/a&gt;情報を参照してください。私の情報はこの回答に基づいています。</target>
        </trans-unit>
        <trans-unit id="b088112b87675051406803805f579695595f5b2d" translate="yes" xml:space="preserve">
          <source>Many solutions seem correct but they don't mention it's called &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt;&lt;code&gt;Currying&lt;/code&gt;&lt;/a&gt; which is a functional programming design pattern for situations like here. 3-10 times faster than bind depending on the browser.</source>
          <target state="translated">多くの解決策は正しいように見えますが、 &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt; &lt;code&gt;Currying&lt;/code&gt; &lt;/a&gt;と呼ばれ、ここでのような状況のための関数型プログラミングの設計パターンであるとは述べていません。 ブラウザによっては、バインドより3〜10倍高速です。</target>
        </trans-unit>
        <trans-unit id="e962642d87dac6e6eaabd9cce80d6d6ef936efb9" translate="yes" xml:space="preserve">
          <source>More detail can be found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">詳細は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;こちら&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f044a862a3c54554110bd80647a24a8aec606c78" translate="yes" xml:space="preserve">
          <source>Most of the other answers provide ways to work around by creating another variable that won't change the value for you.</source>
          <target state="translated">他の回答のほとんどは、あなたのために値を変更しない別の変数を作成することによって回避する方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="f3db1d328e14ab1aba57088c58908a1f67ace0c3" translate="yes" xml:space="preserve">
          <source>My value: 0</source>
          <target state="translated">私の価値:0</target>
        </trans-unit>
        <trans-unit id="2d55b4d0b763195615ef4724ce4993d677fbd4b0" translate="yes" xml:space="preserve">
          <source>My value: 1</source>
          <target state="translated">私の価値:1</target>
        </trans-unit>
        <trans-unit id="0331560236a0dceed2a2d2b9bf6bd0e3be783b79" translate="yes" xml:space="preserve">
          <source>My value: 2</source>
          <target state="translated">私の価値:2</target>
        </trans-unit>
        <trans-unit id="e8f2bf16e2d1a506e725cd7e4f26518d4243a2b8" translate="yes" xml:space="preserve">
          <source>My value: 3</source>
          <target state="translated">私の価値 3</target>
        </trans-unit>
        <trans-unit id="6d57ec64d31326c59930512d69d111aaca5158ea" translate="yes" xml:space="preserve">
          <source>Note that whatever technique you use, the &lt;code&gt;index&lt;/code&gt; variable becomes a sort of static variable, bound to the returned copy of the inner function. I.e., changes to its value are preserved between calls. It can be very handy.</source>
          <target state="translated">どのような手法を使用しても、 &lt;code&gt;index&lt;/code&gt; 変数は一種の静的変数になり、返される内部関数のコピーにバインドされます。 つまり、その値の変更は呼び出し間で保持されます。 とても便利です。</target>
        </trans-unit>
        <trans-unit id="d115a789a23b856b557e0cada39a69b17b4eb6ab" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;counters[0]&lt;/code&gt; and &lt;code&gt;counters[1]&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; independent. In fact, they operate on the same &lt;code&gt;obj&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;counters[0]&lt;/code&gt; と &lt;code&gt;counters[1]&lt;/code&gt; は独立して&lt;em&gt;いない&lt;/em&gt;ことに注意してください。 実際、それらは同じ &lt;code&gt;obj&lt;/code&gt; 動作します！</target>
        </trans-unit>
        <trans-unit id="27739c2610dea465069c0941fc061abd280f2fe1" translate="yes" xml:space="preserve">
          <source>Now open your &lt;strong&gt;chrome console window&lt;/strong&gt; by pressing &lt;strong&gt;F12&lt;/strong&gt; and refresh the page.
Expend every 3 functions inside the array.You will see an property called &lt;code&gt;[[Scopes]]&lt;/code&gt;.Expand that one. You will see one 
array object called &lt;code&gt;&quot;Global&quot;&lt;/code&gt;,expand that one. You will find a property &lt;code&gt;'i'&lt;/code&gt; declared into the object which having value 3.</source>
          <target state="translated">次に、 &lt;strong&gt;F12キー&lt;/strong&gt;を押して&lt;strong&gt;Chrome&lt;/strong&gt; &lt;strong&gt;コンソールウィンドウを&lt;/strong&gt;開き、ページを更新します。 配列内の3つの関数をすべて展開します。 &lt;code&gt;[[Scopes]]&lt;/code&gt; というプロパティが表示されます。そのプロパティを展開します。 &lt;code&gt;&quot;Global&quot;&lt;/code&gt; という1つの配列オブジェクトが表示され、それを展開します。 値3を持つオブジェクトに宣言されたプロパティ &lt;code&gt;'i'&lt;/code&gt; が見つかります。</target>
        </trans-unit>
        <trans-unit id="9d0128e42e75de0128629303ed3317596a65ec7c" translate="yes" xml:space="preserve">
          <source>Now replace the &lt;code&gt;'var'&lt;/code&gt; with &lt;code&gt;'let'&lt;/code&gt;</source>
          <target state="translated">次に、 &lt;code&gt;'var'&lt;/code&gt; を &lt;code&gt;'let'&lt;/code&gt; 置き換えます</target>
        </trans-unit>
        <trans-unit id="e7a5c903dc66b4202f3fb5824fd1acaebe39b5e3" translate="yes" xml:space="preserve">
          <source>Now the question is, what is the value of variable &lt;code&gt;i&lt;/code&gt; when the function is called? Because the first loop is created with the condition of &lt;code&gt;i &amp;lt; 3&lt;/code&gt;, it stops immediately when the condition is false, so it is &lt;code&gt;i = 3&lt;/code&gt;.</source>
          <target state="translated">問題は、関数が呼び出されたときの変数 &lt;code&gt;i&lt;/code&gt; の値は何ですか？ 最初のループは &lt;code&gt;i &amp;lt; 3&lt;/code&gt; 条件で作成されるため、条件がfalseになるとすぐに停止するため、 &lt;code&gt;i = 3&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="abede10eb5958e091577c93ed78b659c1fd6b8d7" translate="yes" xml:space="preserve">
          <source>Now to solve this, we have many options. Below are two of them:</source>
          <target state="translated">さて、これを解決するには、多くの選択肢があります。以下にそのうちの2つを紹介します。</target>
        </trans-unit>
        <trans-unit id="cfc6640b07aafd6b4f2b2c454cc170531c28bdd0" translate="yes" xml:space="preserve">
          <source>Other Option can be to introduce a &lt;code&gt;tempFunc&lt;/code&gt; which returns the actual function:</source>
          <target state="translated">他のオプションは、実際の関数を返す &lt;code&gt;tempFunc&lt;/code&gt; を導入することです：</target>
        </trans-unit>
        <trans-unit id="34f687cbb93dc0653344b56a9a0414f48bb65986" translate="yes" xml:space="preserve">
          <source>Personally I think @Aust's &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt;more recent answer about using &lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; is the best way to do this kind of thing now. There's also lo-dash/underscore's &lt;code&gt;_.partial&lt;/code&gt; when you don't need or want to mess with &lt;code&gt;bind&lt;/code&gt;'s &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">個人的には、 &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; 使用に関する@Aust&lt;/a&gt;のより最近の回答が、この種のことを今や行う最良の方法だと思います。 &lt;code&gt;bind&lt;/code&gt; の &lt;code&gt;thisArg&lt;/code&gt; を使用する必要がない、または変更したくない場合は、lo-dash / underscoreの &lt;code&gt;_.partial&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="33ae767cca439e92c07c52820fbd5bfdc58bbc2a" translate="yes" xml:space="preserve">
          <source>Reiterated for emphasis:</source>
          <target state="translated">強調のために再掲。</target>
        </trans-unit>
        <trans-unit id="73347c41ddd8169b581b07c3a5f099ea95b7fcec" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;the performance gain in different browsers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;さまざまなブラウザでのパフォーマンスの向上を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="f14d9d164a119f095479c9bdd9465790ed99d8a9" translate="yes" xml:space="preserve">
          <source>Since there is no block scope in JavaScript - only function scope - by wrapping the function creation in a new function, you ensure that the value of &quot;i&quot; remains as you intended.</source>
          <target state="translated">JavaScriptにはブロックスコープは存在せず、関数スコープのみが存在するため、関数の作成を新しい関数でラップすることで、&quot;i &quot;の値が意図した通りに残ることを保証します。</target>
        </trans-unit>
        <trans-unit id="12ea089e3baa0954613acc9720385107e03757cc" translate="yes" xml:space="preserve">
          <source>So as many others mentioned, the problem is that the inner function is referencing the same &lt;code&gt;i&lt;/code&gt; variable. So why don't we just create a new local variable each iteration, and have the inner function reference that instead?</source>
          <target state="translated">他の多くの人が述べたように、問題は内部関数が同じ &lt;code&gt;i&lt;/code&gt; 変数を参照していることです。 では、反復ごとに新しいローカル変数を作成し、代わりにその内部関数参照を用意しないのはなぜでしょうか。</target>
        </trans-unit>
        <trans-unit id="7d7773485c1261a529fe53aef20a83135c3f681e" translate="yes" xml:space="preserve">
          <source>So, your goal is to first save the value of &lt;code&gt;i&lt;/code&gt; to function and only after that save the function to &lt;code&gt;funcs&lt;/code&gt;. This could be done for example this way:</source>
          <target state="translated">したがって、目標は最初に &lt;code&gt;i&lt;/code&gt; の値を関数に保存し、その後にのみ関数を &lt;code&gt;funcs&lt;/code&gt; に保存することです。 これは、たとえば次の方法で行うことができます。</target>
        </trans-unit>
        <trans-unit id="410e0c771b6ff78915e121b00114280170dd8b10" translate="yes" xml:space="preserve">
          <source>Solution is to use another helper function:</source>
          <target state="translated">解決策は、別のヘルパー関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="d016322d1f5eb6c4a54ca8c4ccd762b80be09d6c" translate="yes" xml:space="preserve">
          <source>That looks uglier than ranges in other languages, but IMHO less monstrous than other solutions.</source>
          <target state="translated">他の言語の範囲よりも醜く見えますが、IMHOでは他のソリューションよりも怪物的ではありません。</target>
        </trans-unit>
        <trans-unit id="fbf90835c1301013d8226aab628759d12857a503" translate="yes" xml:space="preserve">
          <source>The annominous function you declared will not call and check the value inside the function unless you invoke the 
functions.</source>
          <target state="translated">宣言したアノミネート関数は、関数を呼び出さない限り、関数内の値を呼び出してチェックすることはありません。</target>
        </trans-unit>
        <trans-unit id="4ec86a7c0d2ecc1756f2033a01be68683a88896e" translate="yes" xml:space="preserve">
          <source>The code in OP's question is replaced with &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of &lt;strong&gt;&lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">OPの質問のコードは、 &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;ではなく&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="f008bbf9daade719e6087c2d074071c310e2e621" translate="yes" xml:space="preserve">
          <source>The error actually does not occur until &lt;code&gt;funcs[someIndex]&lt;/code&gt; is executed &lt;code&gt;()&lt;/code&gt;. Using this same logic, it should be apparent that the value of &lt;code&gt;i&lt;/code&gt; is also not collected until this point either. Once the original loop finishes, &lt;code&gt;i++&lt;/code&gt; brings &lt;code&gt;i&lt;/code&gt; to the value of &lt;code&gt;3&lt;/code&gt; which results in the condition &lt;code&gt;i &amp;lt; 3&lt;/code&gt; failing and the loop ending. At this point, &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and so when &lt;code&gt;funcs[someIndex]()&lt;/code&gt; is used, and &lt;code&gt;i&lt;/code&gt; is evaluated, it is 3 - every time.</source>
          <target state="translated">エラーは、 &lt;code&gt;funcs[someIndex]&lt;/code&gt; が実行されるまで実際には発生しません &lt;code&gt;()&lt;/code&gt; 。 これと同じロジックを使用すると、 &lt;code&gt;i&lt;/code&gt; の値もこの時点まで収集されないことは明らかです。 元のループが終了すると、 &lt;code&gt;i++&lt;/code&gt; によってiの値が &lt;code&gt;3&lt;/code&gt; になり、 &lt;code&gt;i &amp;lt; 3&lt;/code&gt; の条件が失敗してループが終了します。 この時点では、 &lt;code&gt;i&lt;/code&gt; は &lt;code&gt;3&lt;/code&gt; なので、 &lt;code&gt;funcs[someIndex]()&lt;/code&gt; が使用され、 &lt;code&gt;i&lt;/code&gt; が評価されると、毎回3になります。</target>
        </trans-unit>
        <trans-unit id="856ee0f77cb901a2d5f4921b4e1b1fda12a1619c" translate="yes" xml:space="preserve">
          <source>The idea behind this is, encapsulating the entire body of the for loop with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; (Immediately-Invoked Function Expression) and passing &lt;code&gt;new_i&lt;/code&gt; as a parameter and capturing it as &lt;code&gt;i&lt;/code&gt;. Since the anonymous function is executed immediately, the &lt;code&gt;i&lt;/code&gt; value is different for each function defined inside the anonymous function.</source>
          <target state="translated">この背後にあるアイデアは、forループの本体全体を&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; （即時に呼び出される関数式）でカプセル化し、 new_iを &lt;code&gt;new_i&lt;/code&gt; として渡し、それを &lt;code&gt;i&lt;/code&gt; としてキャプチャーすることです。 無名関数はすぐに実行されるため、無名関数内で定義された関数ごとに &lt;code&gt;i&lt;/code&gt; 値は異なります。</target>
        </trans-unit>
        <trans-unit id="f1be8f1dfe77f7136b4b98db5a0445bec48d7249" translate="yes" xml:space="preserve">
          <source>The idea is that each invocation of the callback function used with the &lt;code&gt;.forEach&lt;/code&gt; loop will be its own closure. The parameter passed in to that handler is the array element specific to that particular step of the iteration. If it's used in an asynchronous callback, it won't collide with any of the other callbacks established at other steps of the iteration.</source>
          <target state="translated">アイデアは、 &lt;code&gt;.forEach&lt;/code&gt; ループで使用されるコールバック関数の呼び出しごとに独自のクロージャーになるというものです。 そのハンドラーに渡されるパラメーターは、反復の特定のステップに固有の配列要素です。 非同期コールバックで使用される場合、反復の他のステップで確立された他のコールバックと衝突しません。</target>
        </trans-unit>
        <trans-unit id="554e7da9cb27d2c612a6625d286e83984129f98b" translate="yes" xml:space="preserve">
          <source>The main issue with the code shown by the OP is that &lt;code&gt;i&lt;/code&gt; is never read until the second loop. To demonstrate, imagine seeing an error inside of the code</source>
          <target state="translated">OPによって示されるコードの主な問題は、2番目のループまで読み込まれないことです。 実例として、コード内でエラーが発生することを想像してください。</target>
        </trans-unit>
        <trans-unit id="ac7d64ba26be65a9bdda7a473360cd89e1a6bfca" translate="yes" xml:space="preserve">
          <source>The most simple solution would be,</source>
          <target state="translated">最もシンプルな解決策は</target>
        </trans-unit>
        <trans-unit id="ad056b8ebf63fda047c5428d6a688ada28283e8b" translate="yes" xml:space="preserve">
          <source>The reason your original example did not work is that all the closures you created in the loop referenced the same frame. In effect, having 3 methods on one object with only a single &lt;code&gt;i&lt;/code&gt; variable. They all printed out the same value.</source>
          <target state="translated">元の例が機能しなかった理由は、ループで作成したすべてのクロージャーが同じフレームを参照したためです。 実際には、1つのオブジェクトに3つのメソッドがあり、 &lt;code&gt;i&lt;/code&gt; 変数は1つだけです。 それらはすべて同じ値を出力しました。</target>
        </trans-unit>
        <trans-unit id="2ad989a69c7aecece4a1ee2beea421081fc0179e" translate="yes" xml:space="preserve">
          <source>The same problem occurs when the delay in running the function is caused by using event listeners:</source>
          <target state="translated">イベントリスナーを使用することで、関数の実行に遅延が発生する場合も同様の問題が発生します。</target>
        </trans-unit>
        <trans-unit id="060fca584006f839b664cab15c91a1e82cb22479" translate="yes" xml:space="preserve">
          <source>There is also a let keyword instead of var, that would allow using the block scope rule. In that case defining a variable inside the for would do the trick. That said, the let keyword isn't a practical solution because of compatibility.</source>
          <target state="translated">var の代わりに let キーワードがあり、ブロックスコープルールを使用することができます。この場合、for の中で変数を定義すればうまくいくでしょう。とはいえ、互換性の問題から let キーワードは実用的な解決策ではありません。</target>
        </trans-unit>
        <trans-unit id="448449d35ae4a06a2d9dfb987eef9bacd22eea0a" translate="yes" xml:space="preserve">
          <source>This also means that inner functions &quot;hold onto&quot; outer variables and keep them alive, even if the outer function returns. To utilize this, we create and call a wrapper function purely to make a new scope, declare &lt;code&gt;ilocal&lt;/code&gt; in the new scope, and return an inner function that uses &lt;code&gt;ilocal&lt;/code&gt; (more explanation below):</source>
          <target state="translated">これは、内部関数が外部変数を「保持」し、外部関数が戻った場合でもそれらを維持することも意味します。 これを利用するには、純粋にラッパー関数を作成して呼び出し、新しいスコープを作成し、新しいスコープで &lt;code&gt;ilocal&lt;/code&gt; を宣言し、 &lt;code&gt;ilocal&lt;/code&gt; を使用する内部関数を返します （以下の詳細説明）。</target>
        </trans-unit>
        <trans-unit id="12de75a0410bd48617dd0ea44ed803a6ca2adf1b" translate="yes" xml:space="preserve">
          <source>This describes the common mistake with using closures in JavaScript.</source>
          <target state="translated">JavaScriptでクロージャを使用する際によくある間違いについて解説します。</target>
        </trans-unit>
        <trans-unit id="ae8410f183f820b5d96d27651b33df1df916e1be" translate="yes" xml:space="preserve">
          <source>This is because there is only one copy of &lt;code&gt;obj&lt;/code&gt; shared across all iterations of the loop, perhaps for performance reasons.
Even though &lt;code&gt;{counter: 0}&lt;/code&gt; creates a new object in each iteration, the same copy of &lt;code&gt;obj&lt;/code&gt; will just get updated with a
reference to the newest object.</source>
          <target state="translated">これは、おそらくパフォーマンス上の理由により、ループのすべての反復で共有される &lt;code&gt;obj&lt;/code&gt; のコピーが1つしかないためです。 &lt;code&gt;{counter: 0}&lt;/code&gt; は各反復で新しいオブジェクトを作成しますが、 &lt;code&gt;obj&lt;/code&gt; の同じコピーは最新のオブジェクトへの参照で更新されるだけです。</target>
        </trans-unit>
        <trans-unit id="8a4540349f8251832e92d8707899d72ccee1d16c" translate="yes" xml:space="preserve">
          <source>This is exactly why this bug is so tricky. Even though you are redeclaring a variable, Javascript won't throw an error, and JSLint won't even throw a warning. This is also why the best way to solve this is to take advantage of closures, which is essentially the idea that in Javascript, inner functions have access to outer variables because inner scopes &quot;enclose&quot; outer scopes.</source>
          <target state="translated">これがまさにこのバグが厄介な理由です。変数を再宣言していても、Javascript はエラーを出さず、JSLint は警告すら出さないのです。これがまた、このバグを解決する最善の方法がクロージャを利用することである理由でもあります。これは、本質的には、Javascriptでは内側のスコープが外側のスコープを「囲む」ので、内側の関数は外側の変数にアクセスできるという考え方です。</target>
        </trans-unit>
        <trans-unit id="5b55d617be50854b7689496d73fe6a980d489ff4" translate="yes" xml:space="preserve">
          <source>This is only one of the multiple ways to solve this problem.</source>
          <target state="translated">これは、複数の方法のうちの一つに過ぎません。</target>
        </trans-unit>
        <trans-unit id="69dff230b8b191d491a2e7f9b2016da82afd61e2" translate="yes" xml:space="preserve">
          <source>This question really shows the history of JavaScript! Now we can avoid block scoping with arrow functions and handle loops directly from DOM nodes using Object methods.</source>
          <target state="translated">この質問は本当にJavaScriptの歴史を示しています これで、矢印関数でブロックスコープを回避し、オブジェクトメソッドを使ってDOMノードから直接ループを処理することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d060596a3fb90d867391aebfaa4b523816d6f393" translate="yes" xml:space="preserve">
          <source>This sends the iterator &lt;code&gt;i&lt;/code&gt; into the anonymous function of which we define as &lt;code&gt;index&lt;/code&gt;.  This creates a closure, where the variable &lt;code&gt;i&lt;/code&gt; gets saved for later use in any asynchronous functionality within the IIFE.</source>
          <target state="translated">これにより、イテレーター &lt;code&gt;i&lt;/code&gt; が無名関数に送信され、その無名関数が &lt;code&gt;index&lt;/code&gt; として定義されます 。 これによりクロージャーが作成され、変数 &lt;code&gt;i&lt;/code&gt; は、IIFE内の非同期機能で後で使用するために保存されます。</target>
        </trans-unit>
        <trans-unit id="568f52b727645cf73bf4a4ec5cc6047938d24a52" translate="yes" xml:space="preserve">
          <source>This solution seems to fit any such problem since it will require minimal changes to the original code suffering from this issue. In fact, this is by design, it should not be an issue at all!</source>
          <target state="translated">この解決策は、この問題に悩まされている元のコードに最小限の変更を必要とするので、このような問題にも適合するように思われます。実際、これは設計上の問題であり、全く問題にならないはずです。</target>
        </trans-unit>
        <trans-unit id="63ead8ff0238da7dad275c58b2be0db34f001961" translate="yes" xml:space="preserve">
          <source>This way, each function will have it's own variable &lt;code&gt;x&lt;/code&gt; and we set this &lt;code&gt;x&lt;/code&gt; to the value of &lt;code&gt;i&lt;/code&gt; in each iteration.</source>
          <target state="translated">このように、各関数は独自の変数 &lt;code&gt;x&lt;/code&gt; を持ち、この &lt;code&gt;x&lt;/code&gt; を各反復で &lt;code&gt;i&lt;/code&gt; の値に設定します。</target>
        </trans-unit>
        <trans-unit id="ba14827e824873be8ebe61d778cfebbcb83cf379" translate="yes" xml:space="preserve">
          <source>This works because local variables in the function scope directly, as well as function argument variables, are allocated 
new copies upon entry.</source>
          <target state="translated">これは、関数の引数変数と同様に、関数スコープ内のローカル変数が直接、エントリ時に新しいコピーが割り当てられるために動作します。</target>
        </trans-unit>
        <trans-unit id="dc5df1b4ba78c7a8aba9d785a79d7a07889df926" translate="yes" xml:space="preserve">
          <source>To get past this, you must evaluate &lt;code&gt;i&lt;/code&gt; as it is encountered. Note that this has already happened in the form of &lt;code&gt;funcs[i]&lt;/code&gt; (where there are 3 unique indexes). There are several ways to capture this value. One is to pass it in as a parameter to a function which is shown in several ways already here.</source>
          <target state="translated">これを乗り越えるには、 &lt;code&gt;i&lt;/code&gt; を検出する必要があります。 これは既に &lt;code&gt;funcs[i]&lt;/code&gt; 形式で行われていることに注意してください（3つの一意のインデックスがあります）。 この値を取得するにはいくつかの方法があります。 1つは、関数としてパラメーターとして渡すことです。これは、既にいくつかの方法で示されています。</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="9e545c304f2b2af0893d3299d7eeb524e05f8fa5" translate="yes" xml:space="preserve">
          <source>Turns out, that's the issue. Each iteration is sharing the same scope, so every iteration after the first is just overwriting &lt;code&gt;ilocal&lt;/code&gt;. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">結局のところ、それが問題です。 各反復は同じスコープを共有しているため、最初の反復後のすべての反復は、単に &lt;code&gt;ilocal&lt;/code&gt; を上書きしています。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="dde2205fa0c208c200d47ab8a2639e821de84aa8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;closure&lt;/a&gt; structure, this would reduce your extra for loop. You can do it in a single for loop:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;クロージャー&lt;/a&gt;構造を使用してください。これにより、ループの追加が削減されます。 あなたはそれを単一のforループで行うことができます：</target>
        </trans-unit>
        <trans-unit id="1d0fb26471bd522c3a6eb4395151f9fa462bd3e4" translate="yes" xml:space="preserve">
          <source>Use let(blocked-scope) instead of var.</source>
          <target state="translated">var の代わりに let(blocked-scope)を使用します。</target>
        </trans-unit>
        <trans-unit id="02390d462bc4466f4b044a7431c4ace04d0fc8eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; solves this by creating a new scope each time the &lt;code&gt;for&lt;/code&gt; loop runs, creating a separated scope for each function to close over. Various other techniques do the same thing with extra functions.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; の代わりに &lt;code&gt;let&lt;/code&gt; を使用すると、 &lt;code&gt;for&lt;/code&gt; ループが実行されるたびに新しいスコープが作成され、関数ごとに個別のスコープが作成されて終了します。 他のさまざまなテクニックは、追加の機能で同じことを行います。</target>
        </trans-unit>
        <trans-unit id="2e638ddaa7a309550103b73c19dacbc50a4f95be" translate="yes" xml:space="preserve">
          <source>Using a closure in a loop is tricky.</source>
          <target state="translated">ループの中でクロージャを使用することは厄介です。</target>
        </trans-unit>
        <trans-unit id="e58d2a9f67a5c27e888bf7a370ee438bb7cbfe85" translate="yes" xml:space="preserve">
          <source>Using an &lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, the simplest and most readable way to enclose an index variable:</source>
          <target state="translated">インデックス変数を囲む最も簡単で最も読みやすい方法である、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;即時に呼び出される関数式&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="55f01718a62a1826d870465a04e10f4146d32e91" translate="yes" xml:space="preserve">
          <source>We can initialize &lt;code&gt;i&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; or initialize a new variable &lt;code&gt;index&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; and make it equal to &lt;code&gt;i&lt;/code&gt;. So when the call is being made, &lt;code&gt;index&lt;/code&gt; will be used and its scope will end after initialization. And for calling, &lt;code&gt;index&lt;/code&gt; will be initialized again:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; で &lt;code&gt;i&lt;/code&gt; を初期化するか、 letで新しい変数 &lt;code&gt;index&lt;/code&gt; を初期化して、 &lt;code&gt;i&lt;/code&gt; に等しくすることができます。 したがって、呼び出しが行われると、 &lt;code&gt;index&lt;/code&gt; が使用され、そのスコープは初期化後に終了します。 そして呼び出しのために、 &lt;code&gt;index&lt;/code&gt; は再び初期化されます：</target>
        </trans-unit>
        <trans-unit id="13061d26e5ff9f96a4c74bef2c43e6074905c506" translate="yes" xml:space="preserve">
          <source>We can see this by checking &lt;code&gt;ilocal&lt;/code&gt; before we declare it in each iteration:</source>
          <target state="translated">これを確認するには、各反復で宣言する前に &lt;code&gt;ilocal&lt;/code&gt; をチェックします。</target>
        </trans-unit>
        <trans-unit id="ecacf20dbf2ba01fc16a5963696f4d9f3b309d3a" translate="yes" xml:space="preserve">
          <source>We will check , what actually happens when you declare &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;
  one by one.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; を宣言して1つずつ &lt;code&gt;let&lt;/code&gt; すると実際に何が起こるかを確認します。</target>
        </trans-unit>
        <trans-unit id="82eaf8efa37e385e9b7152f30bdaadc0bf9ed115" translate="yes" xml:space="preserve">
          <source>Well, the problem is that the variable &lt;code&gt;i&lt;/code&gt;, within each of your anonymous functions, is bound to the same variable outside of the function.</source>
          <target state="translated">問題は、各匿名関数内の変数 &lt;code&gt;i&lt;/code&gt; が、関数の外で同じ変数にバインドされていることです。</target>
        </trans-unit>
        <trans-unit id="41eb5e4bb9040aafd86158f33adfb76207526d4e" translate="yes" xml:space="preserve">
          <source>What you need to understand is the scope of the variables in javascript is based on the function. This is an important difference than say c# where you have block scope, and just copying the variable to one inside the for will work.</source>
          <target state="translated">理解する必要があるのは、javascriptの変数のスコープは関数に基づいているということです。これはブロックスコープがあるc#との重要な違いであり、変数をforの中の1つにコピーするだけで動作します。</target>
        </trans-unit>
        <trans-unit id="63c86ee44958806285b881b5c6d1c72978293ea3" translate="yes" xml:space="preserve">
          <source>What you want to do is bind the variable within each function to a separate, unchanging value outside of the function:</source>
          <target state="translated">あなたがしたいことは、各関数内の変数を、関数の外部にある別個の不変の値にバインドすることです。</target>
        </trans-unit>
        <trans-unit id="8eedced39e77d173c59310d3d7130994ae20c1ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the solution to this basic problem?</source>
          <target state="translated">この基本的な問題の解決策は何ですか？</target>
        </trans-unit>
        <trans-unit id="6f1a7ec31d6598725ab3a3e62f3cd605ed9af980" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, now the scope chain will be &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt;. This time &lt;code&gt;i&lt;/code&gt; can be found in the outer function's scope which is executed 3 times in the for loop, each time has value &lt;code&gt;i&lt;/code&gt; bound correctly. It won't use the value of &lt;code&gt;window.i&lt;/code&gt; when inner executed.</source>
          <target state="translated">&lt;code&gt;funcs&lt;/code&gt; が実行されると、スコープチェーンは &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt; inner- &amp;gt; function outerになります。 今回は、forループで3回実行される外部関数のスコープで &lt;code&gt;i&lt;/code&gt; を見つけることができます。毎回、値 &lt;code&gt;i&lt;/code&gt; は正しくバインドされています。 内部実行時に &lt;code&gt;window.i&lt;/code&gt; の値を使用しません。</target>
        </trans-unit>
        <trans-unit id="136bf4b99e71d62b188da8ea337423ca7b32ee1a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, the scope chain will be &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt;. Since the variable &lt;code&gt;i&lt;/code&gt; cannot be found in &lt;code&gt;function inner&lt;/code&gt; (neither declared using &lt;code&gt;var&lt;/code&gt; nor passed as arguments), it continues to search, until the value of &lt;code&gt;i&lt;/code&gt; is eventually found in the global scope which is &lt;code&gt;window.i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;funcs&lt;/code&gt; が実行されると、スコープチェーンは &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt; inner- &amp;gt; globalになります。 変数 &lt;code&gt;i&lt;/code&gt; は、 &lt;code&gt;function inner&lt;/code&gt; （ &lt;code&gt;var&lt;/code&gt; を使用して宣言されておらず、引数として渡されることもない）では見つからないため、最終的に &lt;code&gt;i&lt;/code&gt; の値がグローバルスコープである &lt;code&gt;window.i&lt;/code&gt; で見つかるまで、検索を続けます。</target>
        </trans-unit>
        <trans-unit id="0b6868f0d3df7b445fd72bcfe0420c84dbdc0c32" translate="yes" xml:space="preserve">
          <source>When a function gets executed, the runtime evaluates variables by searching the &lt;strong&gt;scope chain&lt;/strong&gt;. If a variable can be found in a certain point of the chain it will stop searching and use it, otherwise it continues until the global scope reached which belongs to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">関数が実行されると、ランタイムは&lt;strong&gt;スコープチェーンを&lt;/strong&gt;検索して変数を評価します。 チェーンの特定のポイントで変数が見つかると、検索を停止して使用し &lt;code&gt;window&lt;/code&gt; 。それ以外の場合は、 windowに属するグローバルスコープに到達するまで続行されます 。</target>
        </trans-unit>
        <trans-unit id="fdddce5cff579a440ec0f06c1f3a7517de4c89ef" translate="yes" xml:space="preserve">
          <source>When you create the closure, &lt;code&gt;i&lt;/code&gt; is a reference to the variable defined in the outside scope, not a copy of it as it was when you created the closure. It will be evaluated at the time of execution.</source>
          <target state="translated">クロージャーを作成するとき、 &lt;code&gt;i&lt;/code&gt; は外部スコープで定義された変数への参照であり、クロージャーを作成したときのコピーではありません。 実行時に評価されます。</target>
        </trans-unit>
        <trans-unit id="c32d98513496eff571f807348f60d6eb70fa8459" translate="yes" xml:space="preserve">
          <source>When you declare a variable using &lt;code&gt;'var'&lt;/code&gt; outside a function ,it becomes global variable(you can check by typing &lt;code&gt;i&lt;/code&gt; or 
&lt;code&gt;window.i&lt;/code&gt; in console window.It will return 3).</source>
          <target state="translated">関数 &lt;code&gt;'var'&lt;/code&gt; 外で'var'を使用して変数を宣言すると、グローバル変数になります（コンソールウィンドウで &lt;code&gt;i&lt;/code&gt; または &lt;code&gt;window.i&lt;/code&gt; と入力すると確認できます。3が返されます）。</target>
        </trans-unit>
        <trans-unit id="0700c840cf9074a17d6a57a019478e06397f4b95" translate="yes" xml:space="preserve">
          <source>When you declare variable using &lt;code&gt;'let'&lt;/code&gt; even outside the function but inside the loop , this variable will not be a Global 
variable , it will become a &lt;code&gt;Block&lt;/code&gt; level variable which is only available for the same function only.That is the reason , we 
are getting value of &lt;code&gt;i&lt;/code&gt; different for each function when we invoke the functions.</source>
          <target state="translated">関数の外側でもループの内側でも &lt;code&gt;'let'&lt;/code&gt; を使用して変数を宣言すると、この変数はグローバル変数ではなく、同じ関数でのみ使用できる &lt;code&gt;Block&lt;/code&gt; レベルの変数になります。そのため、関数を呼び出すときに、関数ごとに異なる &lt;code&gt;i&lt;/code&gt; の値を取得します。</target>
        </trans-unit>
        <trans-unit id="9315dce1f25ea4c4ba2729e3d74db8c96a980595" translate="yes" xml:space="preserve">
          <source>When you invoke the function , &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; takes the value from its &lt;code&gt;Global&lt;/code&gt; object and display the 
result.</source>
          <target state="translated">関数を呼び出すと、 &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; は &lt;code&gt;Global&lt;/code&gt; オブジェクトから値を取得し、結果を表示します。</target>
        </trans-unit>
        <trans-unit id="a04cb324afc79fff8ebd9cd463d1cacdf8ff5c49" translate="yes" xml:space="preserve">
          <source>Whereas I'd like it to output:</source>
          <target state="translated">出力してほしいのに対し</target>
        </trans-unit>
        <trans-unit id="c125d7c3843c2a8edd798658a1c8b7142f2e0175" translate="yes" xml:space="preserve">
          <source>With ES6 now mainstream, we can now use the new &lt;code&gt;let&lt;/code&gt; keyword to create block-scoped variables:</source>
          <target state="translated">ES6が主流になったので、新しい &lt;code&gt;let&lt;/code&gt; キーワードを使用して、ブロックスコープの変数を作成できます。</target>
        </trans-unit>
        <trans-unit id="06647b92e9f39b50b8b5c9c9165cbfd5329f2810" translate="yes" xml:space="preserve">
          <source>With ES6 now widely supported, the best answer to this question has changed.  ES6 provides the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords for this exact circumstance.  Instead of messing around with closures, we can just use &lt;code&gt;let&lt;/code&gt; to set a loop scope variable like this:</source>
          <target state="translated">ES6が広くサポートされるようになり、この質問に対する最良の答えが変わりました。 ES6には、この正確な状況のための &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; キーワードが用意されています。 クロージャーをいじるのではなく、次のように &lt;code&gt;let&lt;/code&gt; を使用してループスコープ変数を設定できます。</target>
        </trans-unit>
        <trans-unit id="bccb870c0505ba1198c8bd20fb323ffcaa0eec55" translate="yes" xml:space="preserve">
          <source>With new features of ES6 block level scoping is managed:</source>
          <target state="translated">ES6の新機能により、ブロックレベルのスコーピングが管理されます。</target>
        </trans-unit>
        <trans-unit id="3f61a03573e1881b334382ba87fe17f8963f8f85" translate="yes" xml:space="preserve">
          <source>With the relatively widespread availability of the &lt;code&gt;Array.prototype.forEach&lt;/code&gt; function (in 2015), it's worth noting that in those situations involving iteration primarily over an array of values, &lt;code&gt;.forEach()&lt;/code&gt; provides a clean, natural way to get a distinct closure for every iteration. That is, assuming you've got some sort of array containing values (DOM references, objects, whatever), and the problem arises of setting up callbacks specific to each element, you can do this:</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach&lt;/code&gt; 関数が比較的広く利用されているため（2015年）、主に値の配列に対する反復を伴う状況では、 &lt;code&gt;.forEach()&lt;/code&gt; が明確で自然な方法でクロージャーを取得できることに注目する価値がありますすべての反復。 つまり、値（DOM参照、オブジェクトなど）を含むある種の配列があり、各要素に固有のコールバックを設定するときに問題が発生すると想定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="afbb288fca9f8548f939b37452aa20bfc52aa22a" translate="yes" xml:space="preserve">
          <source>Wrapping it in a function that evaluates returning the function like apphacker's answer will do the trick, as the variable now has the function scope.</source>
          <target state="translated">apphackerの答えのような関数を返す評価関数でラップすることで、変数に関数スコープを持つようになり、トリックを行うことができます。</target>
        </trans-unit>
        <trans-unit id="5a12c8a80e49d75e10abdc201b4e47c6ffdad1fc" translate="yes" xml:space="preserve">
          <source>You could then use your second loop and get the expected result or you could do</source>
          <target state="translated">2 番目のループを使用して、期待される結果を得ることもできますし、次のようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="f3b66d71de3296a4d256ccc09d82d040d2cdb4f8" translate="yes" xml:space="preserve">
          <source>You could use a declarative module for lists of data such as &lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt;(*). In these situations I personally find a declarative approach less surprising</source>
          <target state="translated">&lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt; （*）などのデータのリストに宣言モジュールを使用できます。 これらの状況では、私は個人的に宣言的アプローチがそれほど驚くべきことではないと感じています</target>
        </trans-unit>
        <trans-unit id="ae314c4eceee085891b4c457750851f14dd5d46f" translate="yes" xml:space="preserve">
          <source>You need to understand that, in time when your functions are created, none of their code is executed, it is only saved for later. And so when they are called later, the interpreter executes them and asks: &quot;What is the current value of &lt;code&gt;i&lt;/code&gt;?&quot;</source>
          <target state="translated">関数が作成されると、コードは実行されず、後で使用するためにのみ保存されることを理解する必要があります。 そして、それらが後で呼び出されると、インタプリタはそれらを実行し、「 &lt;code&gt;i&lt;/code&gt; の現在の値は何ですか？」と尋ねます。</target>
        </trans-unit>
        <trans-unit id="4002c68c62355c5ff649328699085ae7df82a379" translate="yes" xml:space="preserve">
          <source>Your code doesn't work, because what it does is:</source>
          <target state="translated">あなたのコードは機能していません。</target>
        </trans-unit>
        <trans-unit id="b42f3f6f796fa3cfcb6b1b8d49c7bcccc3a7164c" translate="yes" xml:space="preserve">
          <source>const</source>
          <target state="translated">const</target>
        </trans-unit>
        <trans-unit id="0262f9bb6ecbef4efbae97193c08ec335698a205" translate="yes" xml:space="preserve">
          <source>let</source>
          <target state="translated">let</target>
        </trans-unit>
        <trans-unit id="047a45ccf14f791a4c2261e7921f98e1170c10cc" translate="yes" xml:space="preserve">
          <source>no array</source>
          <target state="translated">無配列</target>
        </trans-unit>
        <trans-unit id="90aa229371a8bfd35bc600335c626fdfc9e82632" translate="yes" xml:space="preserve">
          <source>no extra for loop</source>
          <target state="translated">ループのための余分なものはありません</target>
        </trans-unit>
        <trans-unit id="fd20c34806b69001e12b7c2055620cd556c5b03f" translate="yes" xml:space="preserve">
          <source>try this shorter one</source>
          <target state="translated">これより短いのを試してみる</target>
        </trans-unit>
        <trans-unit id="a0d8045ff0e1110c300c0605fa5a3d0a54a9a9dc" translate="yes" xml:space="preserve">
          <source>which alerts &quot;2&quot;, for 3 times. This is because anonymous functions created in for loop, shares same closure, and in that closure, the value of &lt;code&gt;i&lt;/code&gt; is the same. Use this to prevent shared closure:</source>
          <target state="translated">「2」を3回警告します。 これは、forループで作成された無名関数が同じクロージャーを共有し、そのクロージャーで &lt;code&gt;i&lt;/code&gt; の値が同じであるためです。 これを使用して共有閉鎖を防止します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
