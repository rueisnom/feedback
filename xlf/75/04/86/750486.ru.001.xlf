<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/750486">
    <body>
      <group id="750486">
        <trans-unit id="dc928c660df5af8037b30d806a3d5e2bf719a6ad" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or asynchronous code, e.g. using Promises:</source>
          <target state="translated">... или асинхронный код, например, используя Promises:</target>
        </trans-unit>
        <trans-unit id="eb729be35a722439cea750b023efdfbd8a9fd5db" translate="yes" xml:space="preserve">
          <source>(*) I'm the author of query-js and therefor biased towards using it, so don't take my words as a recommendation for said library only for the declarative approach :)</source>
          <target state="translated">(*)Я автор query-js и поэтому предвзято отношусь к его использованию,так что не воспринимайте мои слова как рекомендацию для упомянутой библиотеки только для декларативного подхода :)</target>
        </trans-unit>
        <trans-unit id="eddee0d119554968d570b6aaa4f40b56ba855167" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;let&lt;/code&gt; makes variables block scoped. Blocks are denoted by curly braces, but in the case of the for loop the initialization variable, &lt;code&gt;i&lt;/code&gt; in our case, is considered to be declared in the braces.)</source>
          <target state="translated">( &lt;code&gt;let&lt;/code&gt; сделать блок переменных областью видимости. Блоки обозначены фигурными скобками, но в случае цикла for переменная инициализации, в нашем случае &lt;code&gt;i&lt;/code&gt; , считается объявленной в фигурных скобках.)</target>
        </trans-unit>
        <trans-unit id="f507a9dd45beea522efee731e516a4bfacc41cde" translate="yes" xml:space="preserve">
          <source>// edited to use &lt;code&gt;forEach&lt;/code&gt; instead of map.</source>
          <target state="translated">// отредактировано для использования &lt;code&gt;forEach&lt;/code&gt; вместо map.</target>
        </trans-unit>
        <trans-unit id="17b3607fc13ef64118c5443ba1c9c1d143b46fdd" translate="yes" xml:space="preserve">
          <source>2015 Solution: forEach</source>
          <target state="translated">2015 Решение:forEach</target>
        </trans-unit>
        <trans-unit id="d16a35fbcaef2b1dca935e1c55b24f332b1909de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is similar to &lt;code&gt;let&lt;/code&gt; with the additional restriction that the variable name can't be rebound to a new reference after initial assignment.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; аналогично разрешению с дополнительным ограничением, что имя переменной не может быть привязано к новой ссылке после первоначального присваивания.</target>
        </trans-unit>
        <trans-unit id="fbbe8653d1dfb5593d280c0119120a5978f7f167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; will then point to an object that is specific to that particular turn of the loop, and will return the correct value without the additional closure notation.  This obviously significantly simplifies this problem.</source>
          <target state="translated">Затем &lt;code&gt;val&lt;/code&gt; будет указывать на объект, относящийся к конкретному повороту цикла, и вернет правильное значение без дополнительной записи замыкания. Это, очевидно, значительно упрощает эту проблему.</target>
        </trans-unit>
        <trans-unit id="aa353dcd5215f0728af0723f85f0b49b2fd877da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cee360f8affd282a49319123ba4b739670977a33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;JavaScript Functions close over the scope they are declared in, and retain access to that scope even as variable values inside of that scope change.&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;Функции JavaScript закрывают область, в которой они объявлены, и сохраняют доступ к этой области даже при изменении значений переменных внутри этой области&amp;raquo;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcd4a38dd9d5d22f20fd8d103d19cba48e2a08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE2 : using let&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CASE2: используя let&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2336bd1c125961b35dcc0669018238c6a1c450b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case1&lt;/strong&gt; : &lt;strong&gt;using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Case1&lt;/strong&gt; : &lt;strong&gt;использование &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db76f0a25108e4cb963d0a08f23235f505a9cc91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="928e77cd42bada13b2e96f39a542c07f34441c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt; (2014):</source>
          <target state="translated">&lt;strong&gt;Изменить&lt;/strong&gt; (2014):</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ee4929b02b00a95af685069745e1a9289475361" translate="yes" xml:space="preserve">
          <source>A function defines a new environment</source>
          <target state="translated">Функция определяет новую среду</target>
        </trans-unit>
        <trans-unit id="e2c13ee3a978048a3137a1833fb1aa49fd75d41a" translate="yes" xml:space="preserve">
          <source>After reading through various solutions, I'd like to add that the reason those solutions work is to rely on the concept of &lt;strong&gt;scope chain&lt;/strong&gt;. It's the way JavaScript resolve a variable during execution.</source>
          <target state="translated">Прочитав различные решения, я хотел бы добавить, что причина, по которой эти решения работают, заключается в том, чтобы опираться на концепцию &lt;strong&gt;цепочки областей действия&lt;/strong&gt; . Это способ, которым JavaScript разрешает переменную во время выполнения.</target>
        </trans-unit>
        <trans-unit id="59f1a06e96e0a1d91f4b2f10b668ef1eb36280e5" translate="yes" xml:space="preserve">
          <source>And yet another solution: instead of creating another loop, just bind the &lt;code&gt;this&lt;/code&gt; to the return function.</source>
          <target state="translated">И еще одно решение: вместо создания другого цикла просто свяжите &lt;code&gt;this&lt;/code&gt; с функцией return.</target>
        </trans-unit>
        <trans-unit id="af8dd16cbb53de1fb9c996e760b11016a9adf276" translate="yes" xml:space="preserve">
          <source>Another option is to construct a function object which will be able to close over the variable. That can be accomplished thusly</source>
          <target state="translated">Другой вариант-построить объект функции,который сможет закрываться поверх переменной.Это может быть сделано таким образом.</target>
        </trans-unit>
        <trans-unit id="83f0151cc81dcad21b18870ef244c89ed233b178" translate="yes" xml:space="preserve">
          <source>Another way of saying it is that the &lt;code&gt;i&lt;/code&gt; in your function is bound at the time of executing the function, not the time of creating the function.</source>
          <target state="translated">Еще один способ сказать, что &lt;code&gt;i&lt;/code&gt; в вашей функции связан во время выполнения функции, а не во время ее создания.</target>
        </trans-unit>
        <trans-unit id="fe46ee279e1078d521ad24eab1803db3091cc1ba" translate="yes" xml:space="preserve">
          <source>Another way that hasn't been mentioned yet is the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Еще один способ, который еще не был упомянут, это использование &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a3039f572fbd5faba88c0f53f09bab9d8efef2a" translate="yes" xml:space="preserve">
          <source>As pointed out by @squint and @mekdev, you get better performance by creating the function outside the loop first and then binding the results within the loop.</source>
          <target state="translated">Как было указано в @squint и @mekdev,сначала создается функция вне цикла,а затем выполняется привязка результатов внутри цикла.</target>
        </trans-unit>
        <trans-unit id="42b2efc257450cf5c19a0de0f625821526dd089a" translate="yes" xml:space="preserve">
          <source>Beware, though, that IE9-IE11 and Edge prior to Edge 14 support &lt;code&gt;let&lt;/code&gt; but get the above wrong (they don't create a new &lt;code&gt;i&lt;/code&gt; each time, so all the functions above would log 3 like they would if we used &lt;code&gt;var&lt;/code&gt;). Edge 14 finally gets it right.</source>
          <target state="translated">Остерегайтесь, однако, того, что IE9-IE11 и Edge до поддержки Edge 14 &lt;code&gt;let&lt;/code&gt; но ошиблись выше (они не создают новый &lt;code&gt;i&lt;/code&gt; каждый раз, поэтому все вышеперечисленные функции регистрировали бы 3, как если бы мы использовали &lt;code&gt;var&lt;/code&gt; ). Край 14, наконец, понимает это правильно.</target>
        </trans-unit>
        <trans-unit id="f85de91248746eb3a5e9b79c074698a4ae4c28de" translate="yes" xml:space="preserve">
          <source>Bit late to the party, but I was exploring this issue today and noticed that many of the answers don't completely address how Javascript treats scopes, which is essentially what this boils down to.</source>
          <target state="translated">Немного поздновато для вечеринки,но сегодня я изучал этот вопрос и заметил,что многие ответы не полностью посвящены тому,как Javascript обращается со сферами действия,что,по сути,и является тем,к чему это сводится.</target>
        </trans-unit>
        <trans-unit id="f6d18dcd8e75cb24ac1b57dbc9fcb10f393b34db" translate="yes" xml:space="preserve">
          <source>Browser support is now here for those targeting the latest versions of browsers. &lt;code&gt;const&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; are currently supported in the latest Firefox, Safari, Edge and Chrome. It also is supported in Node, and you can use it anywhere by taking advantage of build tools like Babel.  You can see a working example here: &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http://jsfiddle.net/ben336/rbU4t/2/&lt;/a&gt;</source>
          <target state="translated">Поддержка браузеров теперь доступна для тех, кто ориентирован на последние версии браузеров. &lt;code&gt;const&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; в настоящее время поддерживаются в последних версиях Firefox, Safari, Edge и Chrome. Он также поддерживается в Node, и вы можете использовать его где угодно, используя такие инструменты сборки, как Babel. Вы можете увидеть рабочий пример здесь: &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http://jsfiddle.net/ben336/rbU4t/2/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e8592d1f91df5a55a1cfdc2e8ad8109f4f444e" translate="yes" xml:space="preserve">
          <source>By binding &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt;, solves the problem as well.</source>
          <target state="translated">Связывая &lt;strong&gt;&lt;em&gt;это&lt;/em&gt;&lt;/strong&gt; , решает проблему также.</target>
        </trans-unit>
        <trans-unit id="e2c0b41bb4cd85c199d654ca3b1181205c008ac6" translate="yes" xml:space="preserve">
          <source>By wrapping it in an outer function either explicitly define a helper function like &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;harto&lt;/a&gt; did or use an anonymous function like &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjorn&lt;/a&gt; did:</source>
          <target state="translated">Обернув его во внешнюю функцию, либо явно определите вспомогательную функцию, как &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;это&lt;/a&gt; сделал harto , либо используйте анонимную функцию, как это сделал &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Бьорн&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b00f1c7b6969ce0e50f2b22fb797f9393fa48092" translate="yes" xml:space="preserve">
          <source>Classic solution: Closures</source>
          <target state="translated">Классическое решение:Закрытия</target>
        </trans-unit>
        <trans-unit id="598760db895cc7507725eda06e8c54cdcd677e9d" translate="yes" xml:space="preserve">
          <source>Closures in loops</source>
          <target state="translated">Закрытие в петлях</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="dbf8d82fe089a56de712565f9c4ada9757048bdf" translate="yes" xml:space="preserve">
          <source>Creating the inner function inside a wrapper function gives the inner function a private environment that only it can access, a &quot;closure&quot;. Thus, every time we call the wrapper function we create a new inner function with it's own separate environment, ensuring that the &lt;code&gt;ilocal&lt;/code&gt; variables don't collide and overwrite each other. A few minor optimizations gives the final answer that many other SO users gave:</source>
          <target state="translated">Создание внутренней функции внутри функции-оболочки дает внутренней функции частную среду, к которой только она может получить доступ, &amp;laquo;замыкание&amp;raquo;. Таким образом, каждый раз, когда мы вызываем функцию-обертку, мы создаем новую внутреннюю функцию со своей собственной отдельной средой, гарантируя, что &lt;code&gt;ilocal&lt;/code&gt; переменные не конфликтуют и не перезаписывают друг друга. Несколько небольших оптимизаций дают окончательный ответ, который дали многие другие пользователи SO:</target>
        </trans-unit>
        <trans-unit id="0bf57ac890ee94c29cbca98cfd5e5a3399af610b" translate="yes" xml:space="preserve">
          <source>Do the same thing, Go to the scopes . Now you will see two objects &lt;code&gt;&quot;Block&quot;&lt;/code&gt; and &lt;code&gt;&quot;Global&quot;&lt;/code&gt;. Now expand &lt;code&gt;Block&lt;/code&gt; object , you 
will see 'i' is defined there , and the strange thing is that , for every functions , the value if &lt;code&gt;i&lt;/code&gt; is different (0 , 1, 2).</source>
          <target state="translated">Сделай то же самое, иди в прицелы. Теперь вы увидите два объекта &lt;code&gt;&quot;Block&quot;&lt;/code&gt; и &lt;code&gt;&quot;Global&quot;&lt;/code&gt; . Теперь разверните объект &lt;code&gt;Block&lt;/code&gt; , вы увидите, что там определено &amp;laquo;i&amp;raquo;, и странно то, что для каждой функции значение &lt;code&gt;i&lt;/code&gt; отличается (0, 1, 2).</target>
        </trans-unit>
        <trans-unit id="dc17cd44f5151274b6472f08f4a5ba3902b3c50d" translate="yes" xml:space="preserve">
          <source>Docs here:</source>
          <target state="translated">Доктора слушают:</target>
        </trans-unit>
        <trans-unit id="5b6186c2bae4c5d9cff6452027174031b440b4fc" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 (ES6) introduces new &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords that are scoped differently than &lt;code&gt;var&lt;/code&gt;-based variables. For example, in a loop with a &lt;code&gt;let&lt;/code&gt;-based index, each iteration through the loop will have a new value of &lt;code&gt;i&lt;/code&gt; where each value is scoped inside the loop, so your code would work as you expect. There are many resources, but I'd recommend &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2ality's block-scoping post&lt;/a&gt; as a great source of information.</source>
          <target state="translated">ECMAScript 6 (ES6) представляет новые ключевые слова &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; , которые имеют область действия, отличную от переменных на основе &lt;code&gt;var&lt;/code&gt; . Например, в цикле с индексом на основе &lt;code&gt;let&lt;/code&gt; каждая итерация цикла будет иметь новое значение &lt;code&gt;i&lt;/code&gt; , где каждое значение находится в пределах цикла, поэтому ваш код будет работать так, как вы ожидаете. Есть много ресурсов, но я бы рекомендовал &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;блок-обзор 2ality&lt;/a&gt; в качестве отличного источника информации.</target>
        </trans-unit>
        <trans-unit id="5ed5a45b23d6515c9b67dd7392bcd46f8b115bb8" translate="yes" xml:space="preserve">
          <source>ES6 solution: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Решение ES6: &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64bc654fab8e53127f8d388bf9e93a88ac2444b0" translate="yes" xml:space="preserve">
          <source>Each function definition forms a scope consisting of all the local 
variables declared by &lt;code&gt;var&lt;/code&gt; and its &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">Каждое определение функции формирует область видимости, состоящую из всех локальных переменных, объявленных &lt;code&gt;var&lt;/code&gt; , и ее &lt;code&gt;arguments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6de361507511a955710bf041e4598d0a56a8dae7" translate="yes" xml:space="preserve">
          <source>Each function in the array above closes over the global scope (global, simply because that happens to be the scope they're declared in).</source>
          <target state="translated">Каждая функция в массиве выше закрывается над глобальной областью видимости (глобальной,просто потому что это та область видимости,в которой они объявлены).</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="c98d55c06e5db0b478bd67b5f9f6e088981d4dbc" translate="yes" xml:space="preserve">
          <source>First of all, understand what's wrong with this code:</source>
          <target state="translated">Прежде всего,пойми,что не так с этим кодом:</target>
        </trans-unit>
        <trans-unit id="5590c5a73882c70beab8fa507ee23f99c76c54db" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, please see &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript closure pitfalls and usage&lt;/a&gt;</source>
          <target state="translated">Для подробного обсуждения, пожалуйста, смотрите &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript закрытие ловушек и использование&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf49ae6852c624511c9b32a1af34f1d76ca92bea" translate="yes" xml:space="preserve">
          <source>For each time &lt;code&gt;makeCounter&lt;/code&gt; is invoked, &lt;code&gt;{counter: 0}&lt;/code&gt; results in a new object being created. Also, a new copy of &lt;code&gt;obj&lt;/code&gt; 
is created as well to reference the new object. Thus, &lt;code&gt;counter1&lt;/code&gt; and &lt;code&gt;counter2&lt;/code&gt; are independent of each other.</source>
          <target state="translated">Каждый раз, &lt;code&gt;makeCounter&lt;/code&gt; вызывается makeCounter , &lt;code&gt;{counter: 0}&lt;/code&gt; приводит к созданию нового объекта. Также создается новая копия объекта &lt;code&gt;obj&lt;/code&gt; для ссылки на новый объект. Таким образом, &lt;code&gt;counter1&lt;/code&gt; и counter2 не зависят друг от друга.</target>
        </trans-unit>
        <trans-unit id="84dd8709188509b7ebfa0a06cdf3ca787373d95d" translate="yes" xml:space="preserve">
          <source>For more detail about how closer works , please go through the awesome video tutorial &lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0&lt;/a&gt;</source>
          <target state="translated">Для получения более подробной информации о том, как ближе работает, пожалуйста, посмотрите удивительный видеоурок &lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73383c41720fe072e14e88088ed75954af130ef2" translate="yes" xml:space="preserve">
          <source>Here when the &lt;code&gt;funcs[]&lt;/code&gt; array is being initialized, &lt;code&gt;i&lt;/code&gt; is being incremented, the &lt;code&gt;funcs&lt;/code&gt; array is initialized and the size of &lt;code&gt;func&lt;/code&gt; array becomes 3,  so &lt;code&gt;i = 3,&lt;/code&gt;. 
Now when the &lt;code&gt;funcs[j]()&lt;/code&gt; is called, it is again using the variable &lt;code&gt;i&lt;/code&gt;, which has already been incremented to 3.</source>
          <target state="translated">Здесь, когда массив &lt;code&gt;funcs[]&lt;/code&gt; инициализируется, &lt;code&gt;i&lt;/code&gt; увеличивается, массив &lt;code&gt;funcs&lt;/code&gt; инициализируется и размер массива &lt;code&gt;func&lt;/code&gt; становится равным 3, поэтому &lt;code&gt;i = 3,&lt;/code&gt; ,. Теперь, когда &lt;code&gt;funcs[j]()&lt;/code&gt; , он снова использует переменную &lt;code&gt;i&lt;/code&gt; , которая уже была увеличена до 3.</target>
        </trans-unit>
        <trans-unit id="8f35d22ff5ba383350d5598f465bc196cdf3ce7b" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses &lt;code&gt;forEach&lt;/code&gt; (works back to IE9):</source>
          <target state="translated">Вот простое решение, которое использует &lt;code&gt;forEach&lt;/code&gt; (работает с IE9):</target>
        </trans-unit>
        <trans-unit id="2642451687a6d07efdd6119990ff4d294e12e364" translate="yes" xml:space="preserve">
          <source>Here's another variation on the technique, similar to Bjorn's (apphacker), which lets you assign the variable value inside the function rather than passing it as a parameter, which might be clearer sometimes:</source>
          <target state="translated">Вот еще один вариант техники,похожий на Bjorn (apphacker),который позволяет присваивать значение переменной внутри функции,а не передавать ее в качестве параметра,что иногда может быть более понятно:</target>
        </trans-unit>
        <trans-unit id="e202b66610d948919c3fdefd78e9484928e84630" translate="yes" xml:space="preserve">
          <source>I prefer to use &lt;code&gt;forEach&lt;/code&gt; function, which has its own closure with creating a pseudo range:</source>
          <target state="translated">Я предпочитаю использовать &lt;code&gt;forEach&lt;/code&gt; , которая имеет свое собственное закрытие с созданием псевдодальности:</target>
        </trans-unit>
        <trans-unit id="992673a4459fe4cf804cfb25b0564cfb73dcf973" translate="yes" xml:space="preserve">
          <source>I'm surprised no one yet has suggested using the &lt;code&gt;forEach&lt;/code&gt; function to better avoid (re)using local variables. In fact, I'm not using &lt;code&gt;for(var i ...)&lt;/code&gt; at all anymore for this reason.</source>
          <target state="translated">Я удивлен, что никто еще не предложил использовать &lt;code&gt;forEach&lt;/code&gt; чтобы лучше избегать (пере) использования локальных переменных. На самом деле, я больше не использую &lt;code&gt;for(var i ...)&lt;/code&gt; по этой причине.</target>
        </trans-unit>
        <trans-unit id="2e040e009c09ed4ea050266166917340b79d5172" translate="yes" xml:space="preserve">
          <source>If we have inner function defined inside another (outer) function, this 
forms a chain, and will be used during execution</source>
          <target state="translated">Если мы имеем внутреннюю функцию,определенную внутри другой (внешней)функции,то она образует цепочку,и будет использоваться во время выполнения</target>
        </trans-unit>
        <trans-unit id="48318c5a7aa0cc36320e6ea3e8a2f58e178c5e74" translate="yes" xml:space="preserve">
          <source>If you happen to be working in jQuery, the &lt;code&gt;$.each()&lt;/code&gt; function gives you a similar capability.</source>
          <target state="translated">Если вы работаете в jQuery, &lt;code&gt;$.each()&lt;/code&gt; дает вам аналогичную возможность.</target>
        </trans-unit>
        <trans-unit id="1b95e198fd7ba1aeb8dcff4ebe0215d817d76da2" translate="yes" xml:space="preserve">
          <source>Important: JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. In other words, block statements do not introduce a scope. Although &quot;standalone&quot; blocks are valid syntax, you do not want to use standalone blocks in JavaScript, because they don't do what you think they do, if you think they do anything like such blocks in C or Java.</source>
          <target state="translated">Важно:JavaScript не имеет блок-области.Переменные,вводимые с помощью блока,попадают в содержащую их функцию или скрипт,а эффект их установки сохраняется за пределами самого блока.Другими словами,блочные операторы не вводят область видимости.Хотя &quot;автономные&quot; блоки являются допустимым синтаксисом,вы не хотите использовать автономные блоки в JavaScript,потому что они не делают того,что вы думаете,что они делают,если вы думаете,что они делают что-то подобное таким блокам на C или Java.</target>
        </trans-unit>
        <trans-unit id="fc1c433ad90b0405b9ca2f387ce719f1317f024c" translate="yes" xml:space="preserve">
          <source>In the initial code:</source>
          <target state="translated">В исходном коде:</target>
        </trans-unit>
        <trans-unit id="3309306702dd9476c24f82f81900b045baacba18" translate="yes" xml:space="preserve">
          <source>Instead of using:</source>
          <target state="translated">Вместо того,чтобы использовать:</target>
        </trans-unit>
        <trans-unit id="0e64d1c665d5704b6db4083a7e876035507656e4" translate="yes" xml:space="preserve">
          <source>It includes the common mistake in creating closure in the loop as what we have here, as well as why we need closure and the performance consideration.</source>
          <target state="translated">Он включает в себя общую ошибку в создании закрытия в цикле,как то,что мы имеем здесь,а также,почему мы должны закрыть и производительности рассмотрения.</target>
        </trans-unit>
        <trans-unit id="c7a62a8bcb4b3f1a995d4c6ad5d2aed23bd392a4" translate="yes" xml:space="preserve">
          <source>It outputs this:</source>
          <target state="translated">Он выводит это:</target>
        </trans-unit>
        <trans-unit id="446ebfbbfc1222a93e3455219c2dab41a45fae1a" translate="yes" xml:space="preserve">
          <source>JavaScript closure inside loops – simple practical example</source>
          <target state="translated">Закрытие JavaScript внутри циклов-простой практический пример</target>
        </trans-unit>
        <trans-unit id="b59b3a0eadd20a0309b2b53fc1fde821c0efabd9" translate="yes" xml:space="preserve">
          <source>JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script</source>
          <target state="translated">JavaScript не имеет блок-области.Переменные,вводимые с блоком,относятся к содержащей функции или скрипту</target>
        </trans-unit>
        <trans-unit id="7730326939f83587e92049d0141579e4c07112ed" translate="yes" xml:space="preserve">
          <source>JavaScript functions &quot;close over&quot; the scope they have access to upon declaration, and retain access to that scope even as variables in that scope change.</source>
          <target state="translated">JavaScript функции &quot;закрывают&quot; область применения,к которой они имеют доступ после объявления,и сохраняют доступ к этой области применения даже при изменении переменных в этой области применения.</target>
        </trans-unit>
        <trans-unit id="238b22aa94cfcf877019c9fda879a8c85eccf5c8" translate="yes" xml:space="preserve">
          <source>Just like before, where each inner function outputted the last value assigned to &lt;code&gt;i&lt;/code&gt;, now each inner function just outputs the last value assigned to &lt;code&gt;ilocal&lt;/code&gt;. But shouldn't each iteration have it's own &lt;code&gt;ilocal&lt;/code&gt;?</source>
          <target state="translated">Как и раньше, когда каждая внутренняя функция выводила последнее значение, назначенное для &lt;code&gt;i&lt;/code&gt; , теперь каждая внутренняя функция просто выводит последнее значение, присвоенное &lt;code&gt;ilocal&lt;/code&gt; . Но не должна ли каждая итерация иметь свой собственный &lt;code&gt;ilocal&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="60de88573410b40b98c0419ee80d503add1f0b84" translate="yes" xml:space="preserve">
          <source>Just thought I'd add an explanation for clarity. For a solution, personally, I'd go with Harto's since it is the most self-explanatory way of doing it from the answers here. Any of the code posted will work, but I'd opt for a closure factory over having to write a pile of comments to explain why I'm declaring a new variable(Freddy and 1800's) or have weird embedded closure syntax(apphacker).</source>
          <target state="translated">Просто подумал,что добавлю объяснение для ясности.Для решения,лично я бы пошёл с Harto's,так как это самый понятный способ сделать это из ответов здесь.Любой размещенный код будет работать,но я бы выбрал фабрику по закрытию,вместо того,чтобы писать кучу комментариев,объясняющих,почему я объявляю новую переменную(Freddy и 1800's)или имею странный встроенный синтаксис закрытия(apphacker).</target>
        </trans-unit>
        <trans-unit id="a8606d4d4c57cf9245d54d71c6060344bd0018af" translate="yes" xml:space="preserve">
          <source>Later those functions are invoked logging the most current value of &lt;code&gt;i&lt;/code&gt; in the global scope. That's the magic, and frustration, of closure.</source>
          <target state="translated">Позже эти функции вызываются, регистрируя самое последнее значение &lt;code&gt;i&lt;/code&gt; в глобальной области видимости. Это магия и разочарование закрытия.</target>
        </trans-unit>
        <trans-unit id="a4cbeead2a01a91773ed38966d1bd68a0cf65493" translate="yes" xml:space="preserve">
          <source>Look how easy it is now! For more information see &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;this answer&lt;/a&gt;, which my info is based off of.</source>
          <target state="translated">Посмотрите, как это просто сейчас! Для получения дополнительной информации см. &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;Этот ответ&lt;/a&gt; , на котором основана моя информация.</target>
        </trans-unit>
        <trans-unit id="b088112b87675051406803805f579695595f5b2d" translate="yes" xml:space="preserve">
          <source>Many solutions seem correct but they don't mention it's called &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt;&lt;code&gt;Currying&lt;/code&gt;&lt;/a&gt; which is a functional programming design pattern for situations like here. 3-10 times faster than bind depending on the browser.</source>
          <target state="translated">Многие решения кажутся правильными, но они не упоминают, что это называется &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt; &lt;code&gt;Currying&lt;/code&gt; &lt;/a&gt; который является функциональным шаблоном проектирования программирования для подобных ситуаций. В 3-10 раз быстрее, чем привязка в зависимости от браузера.</target>
        </trans-unit>
        <trans-unit id="e962642d87dac6e6eaabd9cce80d6d6ef936efb9" translate="yes" xml:space="preserve">
          <source>More detail can be found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Более подробно можно найти &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f044a862a3c54554110bd80647a24a8aec606c78" translate="yes" xml:space="preserve">
          <source>Most of the other answers provide ways to work around by creating another variable that won't change the value for you.</source>
          <target state="translated">Большинство других ответов предоставляют возможность работать,создавая другую переменную,которая не будет изменять значение для вас.</target>
        </trans-unit>
        <trans-unit id="f3db1d328e14ab1aba57088c58908a1f67ace0c3" translate="yes" xml:space="preserve">
          <source>My value: 0</source>
          <target state="translated">Мое значение:0</target>
        </trans-unit>
        <trans-unit id="2d55b4d0b763195615ef4724ce4993d677fbd4b0" translate="yes" xml:space="preserve">
          <source>My value: 1</source>
          <target state="translated">Моя ценность:1</target>
        </trans-unit>
        <trans-unit id="0331560236a0dceed2a2d2b9bf6bd0e3be783b79" translate="yes" xml:space="preserve">
          <source>My value: 2</source>
          <target state="translated">Моя ценность:2</target>
        </trans-unit>
        <trans-unit id="e8f2bf16e2d1a506e725cd7e4f26518d4243a2b8" translate="yes" xml:space="preserve">
          <source>My value: 3</source>
          <target state="translated">Моя ценность:3</target>
        </trans-unit>
        <trans-unit id="6d57ec64d31326c59930512d69d111aaca5158ea" translate="yes" xml:space="preserve">
          <source>Note that whatever technique you use, the &lt;code&gt;index&lt;/code&gt; variable becomes a sort of static variable, bound to the returned copy of the inner function. I.e., changes to its value are preserved between calls. It can be very handy.</source>
          <target state="translated">Обратите внимание, что какой бы метод вы ни использовали, &lt;code&gt;index&lt;/code&gt; переменная становится своего рода статической переменной, связанной с возвращаемой копией внутренней функции. Т.е. изменения его значения сохраняются между вызовами. Это может быть очень удобно.</target>
        </trans-unit>
        <trans-unit id="d115a789a23b856b557e0cada39a69b17b4eb6ab" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;counters[0]&lt;/code&gt; and &lt;code&gt;counters[1]&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; independent. In fact, they operate on the same &lt;code&gt;obj&lt;/code&gt;!</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;counters[0]&lt;/code&gt; и &lt;code&gt;counters[1]&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; являются независимыми. На самом деле они работают на одном &lt;code&gt;obj&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="27739c2610dea465069c0941fc061abd280f2fe1" translate="yes" xml:space="preserve">
          <source>Now open your &lt;strong&gt;chrome console window&lt;/strong&gt; by pressing &lt;strong&gt;F12&lt;/strong&gt; and refresh the page.
Expend every 3 functions inside the array.You will see an property called &lt;code&gt;[[Scopes]]&lt;/code&gt;.Expand that one. You will see one 
array object called &lt;code&gt;&quot;Global&quot;&lt;/code&gt;,expand that one. You will find a property &lt;code&gt;'i'&lt;/code&gt; declared into the object which having value 3.</source>
          <target state="translated">Теперь откройте &lt;strong&gt;окно консоли Chrome&lt;/strong&gt; , нажав клавишу &lt;strong&gt;F12,&lt;/strong&gt; и обновите страницу. Расходуйте каждые 3 функции внутри массива. Вы увидите свойство &lt;code&gt;[[Scopes]]&lt;/code&gt; . Разверните это свойство. Вы увидите один объект массива с именем &lt;code&gt;&quot;Global&quot;&lt;/code&gt; , разверните его. Вы найдете свойство &lt;code&gt;'i'&lt;/code&gt; , объявленное в объекте со значением 3.</target>
        </trans-unit>
        <trans-unit id="9d0128e42e75de0128629303ed3317596a65ec7c" translate="yes" xml:space="preserve">
          <source>Now replace the &lt;code&gt;'var'&lt;/code&gt; with &lt;code&gt;'let'&lt;/code&gt;</source>
          <target state="translated">Теперь замените &lt;code&gt;'var'&lt;/code&gt; на &lt;code&gt;'let'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7a5c903dc66b4202f3fb5824fd1acaebe39b5e3" translate="yes" xml:space="preserve">
          <source>Now the question is, what is the value of variable &lt;code&gt;i&lt;/code&gt; when the function is called? Because the first loop is created with the condition of &lt;code&gt;i &amp;lt; 3&lt;/code&gt;, it stops immediately when the condition is false, so it is &lt;code&gt;i = 3&lt;/code&gt;.</source>
          <target state="translated">Теперь вопрос в том, каково значение переменной &lt;code&gt;i&lt;/code&gt; при вызове функции? Поскольку первый цикл создается с условием &lt;code&gt;i &amp;lt; 3&lt;/code&gt; , он немедленно останавливается, когда условие ложно, поэтому это &lt;code&gt;i = 3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abede10eb5958e091577c93ed78b659c1fd6b8d7" translate="yes" xml:space="preserve">
          <source>Now to solve this, we have many options. Below are two of them:</source>
          <target state="translated">Теперь,чтобы решить эту проблему,у нас есть много вариантов.Ниже их два:</target>
        </trans-unit>
        <trans-unit id="cfc6640b07aafd6b4f2b2c454cc170531c28bdd0" translate="yes" xml:space="preserve">
          <source>Other Option can be to introduce a &lt;code&gt;tempFunc&lt;/code&gt; which returns the actual function:</source>
          <target state="translated">Другим вариантом может быть введение &lt;code&gt;tempFunc&lt;/code&gt; , которая возвращает фактическую функцию:</target>
        </trans-unit>
        <trans-unit id="34f687cbb93dc0653344b56a9a0414f48bb65986" translate="yes" xml:space="preserve">
          <source>Personally I think @Aust's &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt;more recent answer about using &lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; is the best way to do this kind of thing now. There's also lo-dash/underscore's &lt;code&gt;_.partial&lt;/code&gt; when you don't need or want to mess with &lt;code&gt;bind&lt;/code&gt;'s &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">Лично я думаю, что &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt;более свежий ответ&lt;/a&gt; @ Aust об использовании &lt;code&gt;.bind&lt;/code&gt; - лучший способ сделать это сейчас. Также есть &lt;code&gt;_.partial&lt;/code&gt; в lo-dash / underscore, когда вам не нужно или хотите &lt;code&gt;bind&lt;/code&gt; с &lt;code&gt;thisArg&lt;/code&gt; от bind .</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="33ae767cca439e92c07c52820fbd5bfdc58bbc2a" translate="yes" xml:space="preserve">
          <source>Reiterated for emphasis:</source>
          <target state="translated">Повторяю за акцентом:</target>
        </trans-unit>
        <trans-unit id="73347c41ddd8169b581b07c3a5f099ea95b7fcec" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;the performance gain in different browsers&lt;/a&gt;.</source>
          <target state="translated">Смотрите &lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;прирост производительности в разных браузерах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f14d9d164a119f095479c9bdd9465790ed99d8a9" translate="yes" xml:space="preserve">
          <source>Since there is no block scope in JavaScript - only function scope - by wrapping the function creation in a new function, you ensure that the value of &quot;i&quot; remains as you intended.</source>
          <target state="translated">Так как в JavaScript нет области видимости блока-только область видимости функции-обернув создание функции в новую функцию,вы гарантируете,что значение &quot;i&quot; останется таким,каким вы задумывали.</target>
        </trans-unit>
        <trans-unit id="12ea089e3baa0954613acc9720385107e03757cc" translate="yes" xml:space="preserve">
          <source>So as many others mentioned, the problem is that the inner function is referencing the same &lt;code&gt;i&lt;/code&gt; variable. So why don't we just create a new local variable each iteration, and have the inner function reference that instead?</source>
          <target state="translated">Итак, как уже упоминалось, проблема в том, что внутренняя функция ссылается на ту же переменную &lt;code&gt;i&lt;/code&gt; . Так почему бы нам просто не создавать новую локальную переменную на каждой итерации и вместо этого ссылаться на внутреннюю функцию?</target>
        </trans-unit>
        <trans-unit id="7d7773485c1261a529fe53aef20a83135c3f681e" translate="yes" xml:space="preserve">
          <source>So, your goal is to first save the value of &lt;code&gt;i&lt;/code&gt; to function and only after that save the function to &lt;code&gt;funcs&lt;/code&gt;. This could be done for example this way:</source>
          <target state="translated">Итак, ваша цель - сначала сохранить значение &lt;code&gt;i&lt;/code&gt; для функции, и только после этого сохранить функцию в &lt;code&gt;funcs&lt;/code&gt; . Это можно сделать, например, так:</target>
        </trans-unit>
        <trans-unit id="410e0c771b6ff78915e121b00114280170dd8b10" translate="yes" xml:space="preserve">
          <source>Solution is to use another helper function:</source>
          <target state="translated">Решение заключается в использовании другой вспомогательной функции:</target>
        </trans-unit>
        <trans-unit id="d016322d1f5eb6c4a54ca8c4ccd762b80be09d6c" translate="yes" xml:space="preserve">
          <source>That looks uglier than ranges in other languages, but IMHO less monstrous than other solutions.</source>
          <target state="translated">Это выглядит уродливее,чем диапазоны в других языках,но IMHO менее чудовищно,чем другие решения.</target>
        </trans-unit>
        <trans-unit id="fbf90835c1301013d8226aab628759d12857a503" translate="yes" xml:space="preserve">
          <source>The annominous function you declared will not call and check the value inside the function unless you invoke the 
functions.</source>
          <target state="translated">Объявленная вами анноминальная функция не будет вызываться и проверять значение внутри функции,если только вы не вызвали эти функции.</target>
        </trans-unit>
        <trans-unit id="4ec86a7c0d2ecc1756f2033a01be68683a88896e" translate="yes" xml:space="preserve">
          <source>The code in OP's question is replaced with &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of &lt;strong&gt;&lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Код в вопросе OP заменен на &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; вместо &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f008bbf9daade719e6087c2d074071c310e2e621" translate="yes" xml:space="preserve">
          <source>The error actually does not occur until &lt;code&gt;funcs[someIndex]&lt;/code&gt; is executed &lt;code&gt;()&lt;/code&gt;. Using this same logic, it should be apparent that the value of &lt;code&gt;i&lt;/code&gt; is also not collected until this point either. Once the original loop finishes, &lt;code&gt;i++&lt;/code&gt; brings &lt;code&gt;i&lt;/code&gt; to the value of &lt;code&gt;3&lt;/code&gt; which results in the condition &lt;code&gt;i &amp;lt; 3&lt;/code&gt; failing and the loop ending. At this point, &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and so when &lt;code&gt;funcs[someIndex]()&lt;/code&gt; is used, and &lt;code&gt;i&lt;/code&gt; is evaluated, it is 3 - every time.</source>
          <target state="translated">Ошибка на самом деле не возникает, пока не будет выполнена &lt;code&gt;funcs[someIndex]&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; . Используя ту же логику, должно быть очевидно, что значение &lt;code&gt;i&lt;/code&gt; также не собирается до этой точки. По завершении исходного цикла &lt;code&gt;i++&lt;/code&gt; возвращает &lt;code&gt;i&lt;/code&gt; к значению &lt;code&gt;3&lt;/code&gt; , что приводит к сбою условия &lt;code&gt;i &amp;lt; 3&lt;/code&gt; и завершению цикла. На данный момент, &lt;code&gt;i&lt;/code&gt; равен &lt;code&gt;3&lt;/code&gt; , и поэтому, когда используется &lt;code&gt;funcs[someIndex]()&lt;/code&gt; , и &lt;code&gt;i&lt;/code&gt; оцениваю, это 3 - каждый раз.</target>
        </trans-unit>
        <trans-unit id="856ee0f77cb901a2d5f4921b4e1b1fda12a1619c" translate="yes" xml:space="preserve">
          <source>The idea behind this is, encapsulating the entire body of the for loop with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; (Immediately-Invoked Function Expression) and passing &lt;code&gt;new_i&lt;/code&gt; as a parameter and capturing it as &lt;code&gt;i&lt;/code&gt;. Since the anonymous function is executed immediately, the &lt;code&gt;i&lt;/code&gt; value is different for each function defined inside the anonymous function.</source>
          <target state="translated">Идея, лежащая в основе этого, заключается в том, чтобы инкапсулировать все тело цикла for с помощью &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; -выражения (немедленного вызова функции) и &lt;code&gt;new_i&lt;/code&gt; в качестве параметра new_i и записать его как &lt;code&gt;i&lt;/code&gt; . Поскольку анонимная функция выполняется немедленно, значение &lt;code&gt;i&lt;/code&gt; отличается для каждой функции, определенной внутри анонимной функции.</target>
        </trans-unit>
        <trans-unit id="f1be8f1dfe77f7136b4b98db5a0445bec48d7249" translate="yes" xml:space="preserve">
          <source>The idea is that each invocation of the callback function used with the &lt;code&gt;.forEach&lt;/code&gt; loop will be its own closure. The parameter passed in to that handler is the array element specific to that particular step of the iteration. If it's used in an asynchronous callback, it won't collide with any of the other callbacks established at other steps of the iteration.</source>
          <target state="translated">Идея состоит в том, что каждый вызов функции обратного вызова, используемой с циклом &lt;code&gt;.forEach&lt;/code&gt; , будет собственным закрытием. Параметр, передаваемый этому обработчику, является элементом массива, специфичным для данного конкретного шага итерации. Если он используется в асинхронном обратном вызове, он не будет конфликтовать ни с одним из других обратных вызовов, установленных на других этапах итерации.</target>
        </trans-unit>
        <trans-unit id="554e7da9cb27d2c612a6625d286e83984129f98b" translate="yes" xml:space="preserve">
          <source>The main issue with the code shown by the OP is that &lt;code&gt;i&lt;/code&gt; is never read until the second loop. To demonstrate, imagine seeing an error inside of the code</source>
          <target state="translated">Основная проблема с кодом, показанным OP, состоит в том, что &lt;code&gt;i&lt;/code&gt; никогда не читаю до второго цикла. Чтобы продемонстрировать, представьте, что видите ошибку внутри кода</target>
        </trans-unit>
        <trans-unit id="ac7d64ba26be65a9bdda7a473360cd89e1a6bfca" translate="yes" xml:space="preserve">
          <source>The most simple solution would be,</source>
          <target state="translated">Самым простым решением было бы,</target>
        </trans-unit>
        <trans-unit id="ad056b8ebf63fda047c5428d6a688ada28283e8b" translate="yes" xml:space="preserve">
          <source>The reason your original example did not work is that all the closures you created in the loop referenced the same frame. In effect, having 3 methods on one object with only a single &lt;code&gt;i&lt;/code&gt; variable. They all printed out the same value.</source>
          <target state="translated">Причина, по которой исходный пример не сработал, заключается в том, что все замыкания, созданные в цикле, ссылаются на один и тот же кадр. По сути, наличие 3 методов для одного объекта с единственной переменной &lt;code&gt;i&lt;/code&gt; . Все они распечатаны одинакового значения.</target>
        </trans-unit>
        <trans-unit id="2ad989a69c7aecece4a1ee2beea421081fc0179e" translate="yes" xml:space="preserve">
          <source>The same problem occurs when the delay in running the function is caused by using event listeners:</source>
          <target state="translated">Та же проблема возникает,когда задержка в работе функции вызвана использованием слушателей событий:</target>
        </trans-unit>
        <trans-unit id="060fca584006f839b664cab15c91a1e82cb22479" translate="yes" xml:space="preserve">
          <source>There is also a let keyword instead of var, that would allow using the block scope rule. In that case defining a variable inside the for would do the trick. That said, the let keyword isn't a practical solution because of compatibility.</source>
          <target state="translated">Также есть ключевое слово let вместо var,которое позволяет использовать правило блочной области видимости.В этом случае определение переменной внутри правила for выполнило бы свою задачу.Тем не менее,ключевое слово let не является практичным решением из-за совместимости.</target>
        </trans-unit>
        <trans-unit id="448449d35ae4a06a2d9dfb987eef9bacd22eea0a" translate="yes" xml:space="preserve">
          <source>This also means that inner functions &quot;hold onto&quot; outer variables and keep them alive, even if the outer function returns. To utilize this, we create and call a wrapper function purely to make a new scope, declare &lt;code&gt;ilocal&lt;/code&gt; in the new scope, and return an inner function that uses &lt;code&gt;ilocal&lt;/code&gt; (more explanation below):</source>
          <target state="translated">Это также означает, что внутренние функции &amp;laquo;держат&amp;raquo; внешние переменные и поддерживают их, даже если внешняя функция возвращается. Чтобы использовать это, мы создаем и вызываем функцию-обертку исключительно для создания новой области, объявляем &lt;code&gt;ilocal&lt;/code&gt; в новой области и возвращаем внутреннюю функцию, которая использует &lt;code&gt;ilocal&lt;/code&gt; (более подробное объяснение ниже):</target>
        </trans-unit>
        <trans-unit id="12de75a0410bd48617dd0ea44ed803a6ca2adf1b" translate="yes" xml:space="preserve">
          <source>This describes the common mistake with using closures in JavaScript.</source>
          <target state="translated">Это описывает распространенную ошибку с использованием замыканий в JavaScript.</target>
        </trans-unit>
        <trans-unit id="ae8410f183f820b5d96d27651b33df1df916e1be" translate="yes" xml:space="preserve">
          <source>This is because there is only one copy of &lt;code&gt;obj&lt;/code&gt; shared across all iterations of the loop, perhaps for performance reasons.
Even though &lt;code&gt;{counter: 0}&lt;/code&gt; creates a new object in each iteration, the same copy of &lt;code&gt;obj&lt;/code&gt; will just get updated with a
reference to the newest object.</source>
          <target state="translated">Это связано с тем, что для всех итераций цикла используется только одна копия &lt;code&gt;obj&lt;/code&gt; , возможно, из соображений производительности. Несмотря на то, что &lt;code&gt;{counter: 0}&lt;/code&gt; создает новый объект в каждой итерации, одна и та же копия &lt;code&gt;obj&lt;/code&gt; просто обновляется со ссылкой на самый новый объект.</target>
        </trans-unit>
        <trans-unit id="8a4540349f8251832e92d8707899d72ccee1d16c" translate="yes" xml:space="preserve">
          <source>This is exactly why this bug is so tricky. Even though you are redeclaring a variable, Javascript won't throw an error, and JSLint won't even throw a warning. This is also why the best way to solve this is to take advantage of closures, which is essentially the idea that in Javascript, inner functions have access to outer variables because inner scopes &quot;enclose&quot; outer scopes.</source>
          <target state="translated">Именно поэтому этот жучок такой хитрый.Несмотря на то,что вы переименовываете переменную,Javascript не будет бросать ошибку,а JSLint даже не будет бросать предупреждение.Вот почему лучший способ решить эту проблему-это воспользоваться замыканием,которое по сути является идеей,что в Javascript внутренние функции имеют доступ к внешним переменным,потому что внутренние области видимости &quot;замыкают&quot; внешние области видимости.</target>
        </trans-unit>
        <trans-unit id="5b55d617be50854b7689496d73fe6a980d489ff4" translate="yes" xml:space="preserve">
          <source>This is only one of the multiple ways to solve this problem.</source>
          <target state="translated">Это только один из множества способов решения данной проблемы.</target>
        </trans-unit>
        <trans-unit id="69dff230b8b191d491a2e7f9b2016da82afd61e2" translate="yes" xml:space="preserve">
          <source>This question really shows the history of JavaScript! Now we can avoid block scoping with arrow functions and handle loops directly from DOM nodes using Object methods.</source>
          <target state="translated">Этот вопрос действительно показывает историю JavaScript! Теперь мы можем избежать блочного просмотра с помощью функций стрелок и обрабатывать циклы непосредственно с DOM-узлов с помощью методов Object.</target>
        </trans-unit>
        <trans-unit id="d060596a3fb90d867391aebfaa4b523816d6f393" translate="yes" xml:space="preserve">
          <source>This sends the iterator &lt;code&gt;i&lt;/code&gt; into the anonymous function of which we define as &lt;code&gt;index&lt;/code&gt;.  This creates a closure, where the variable &lt;code&gt;i&lt;/code&gt; gets saved for later use in any asynchronous functionality within the IIFE.</source>
          <target state="translated">Это отправляет итератор &lt;code&gt;i&lt;/code&gt; в анонимную функцию, которую мы определяем как &lt;code&gt;index&lt;/code&gt; . Это создает замыкание, где переменная &lt;code&gt;i&lt;/code&gt; сохраняется для последующего использования в любой асинхронной функциональности в IIFE.</target>
        </trans-unit>
        <trans-unit id="568f52b727645cf73bf4a4ec5cc6047938d24a52" translate="yes" xml:space="preserve">
          <source>This solution seems to fit any such problem since it will require minimal changes to the original code suffering from this issue. In fact, this is by design, it should not be an issue at all!</source>
          <target state="translated">Такое решение,похоже,подходит для любой подобной проблемы,так как потребует минимальных изменений в исходном коде,страдающем от этой проблемы.На самом деле,это по замыслу,это вовсе не должно быть проблемой!</target>
        </trans-unit>
        <trans-unit id="63ead8ff0238da7dad275c58b2be0db34f001961" translate="yes" xml:space="preserve">
          <source>This way, each function will have it's own variable &lt;code&gt;x&lt;/code&gt; and we set this &lt;code&gt;x&lt;/code&gt; to the value of &lt;code&gt;i&lt;/code&gt; in each iteration.</source>
          <target state="translated">Таким образом, каждая функция будет иметь свою собственную переменную &lt;code&gt;x&lt;/code&gt; , и мы устанавливаем для этого значения &lt;code&gt;x&lt;/code&gt; значение &lt;code&gt;i&lt;/code&gt; в каждой итерации.</target>
        </trans-unit>
        <trans-unit id="ba14827e824873be8ebe61d778cfebbcb83cf379" translate="yes" xml:space="preserve">
          <source>This works because local variables in the function scope directly, as well as function argument variables, are allocated 
new copies upon entry.</source>
          <target state="translated">Это работает потому,что локальные переменные в области видимости функции напрямую,как и переменные аргумента функции,при входе присваивают новые копии.</target>
        </trans-unit>
        <trans-unit id="dc5df1b4ba78c7a8aba9d785a79d7a07889df926" translate="yes" xml:space="preserve">
          <source>To get past this, you must evaluate &lt;code&gt;i&lt;/code&gt; as it is encountered. Note that this has already happened in the form of &lt;code&gt;funcs[i]&lt;/code&gt; (where there are 3 unique indexes). There are several ways to capture this value. One is to pass it in as a parameter to a function which is shown in several ways already here.</source>
          <target state="translated">Чтобы обойти это, вы должны оценить, как он встречается. Обратите внимание, что это уже произошло в форме &lt;code&gt;funcs[i]&lt;/code&gt; (где есть 3 уникальных индекса). Есть несколько способов получить это значение. Одним из них является передача его в качестве параметра функции, которая показана здесь несколькими способами.</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="9e545c304f2b2af0893d3299d7eeb524e05f8fa5" translate="yes" xml:space="preserve">
          <source>Turns out, that's the issue. Each iteration is sharing the same scope, so every iteration after the first is just overwriting &lt;code&gt;ilocal&lt;/code&gt;. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">Оказывается, это проблема. Каждая итерация имеет одну и ту же область видимости, поэтому каждая итерация после первой просто перезаписывает &lt;code&gt;ilocal&lt;/code&gt; . От &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dde2205fa0c208c200d47ab8a2639e821de84aa8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;closure&lt;/a&gt; structure, this would reduce your extra for loop. You can do it in a single for loop:</source>
          <target state="translated">Используйте структуру &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;замыкания&lt;/a&gt; , это уменьшит ваш дополнительный цикл for. Вы можете сделать это в одном цикле for:</target>
        </trans-unit>
        <trans-unit id="1d0fb26471bd522c3a6eb4395151f9fa462bd3e4" translate="yes" xml:space="preserve">
          <source>Use let(blocked-scope) instead of var.</source>
          <target state="translated">Используйте let(block-scope)вместо var.</target>
        </trans-unit>
        <trans-unit id="02390d462bc4466f4b044a7431c4ace04d0fc8eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; solves this by creating a new scope each time the &lt;code&gt;for&lt;/code&gt; loop runs, creating a separated scope for each function to close over. Various other techniques do the same thing with extra functions.</source>
          <target state="translated">Использование &lt;code&gt;let&lt;/code&gt; вместо &lt;code&gt;var&lt;/code&gt; решает эту проблему, создавая новую область видимости при каждом запуске цикла &lt;code&gt;for&lt;/code&gt; , создавая отдельную область видимости для каждой закрываемой функции. Различные другие методы делают то же самое с дополнительными функциями.</target>
        </trans-unit>
        <trans-unit id="2e638ddaa7a309550103b73c19dacbc50a4f95be" translate="yes" xml:space="preserve">
          <source>Using a closure in a loop is tricky.</source>
          <target state="translated">Использовать замыкание в петле сложно.</target>
        </trans-unit>
        <trans-unit id="e58d2a9f67a5c27e888bf7a370ee438bb7cbfe85" translate="yes" xml:space="preserve">
          <source>Using an &lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, the simplest and most readable way to enclose an index variable:</source>
          <target state="translated">Использование выражения &amp;laquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;немедленно вызванная функция&amp;raquo;&lt;/a&gt; - самый простой и читаемый способ заключить индексную переменную:</target>
        </trans-unit>
        <trans-unit id="55f01718a62a1826d870465a04e10f4146d32e91" translate="yes" xml:space="preserve">
          <source>We can initialize &lt;code&gt;i&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; or initialize a new variable &lt;code&gt;index&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; and make it equal to &lt;code&gt;i&lt;/code&gt;. So when the call is being made, &lt;code&gt;index&lt;/code&gt; will be used and its scope will end after initialization. And for calling, &lt;code&gt;index&lt;/code&gt; will be initialized again:</source>
          <target state="translated">Мы можем инициализировать &lt;code&gt;i&lt;/code&gt; с помощью &lt;code&gt;let&lt;/code&gt; или инициализировать &lt;code&gt;index&lt;/code&gt; новой переменной с помощью &lt;code&gt;let&lt;/code&gt; и сделать его равным &lt;code&gt;i&lt;/code&gt; . Таким образом, при выполнении вызова будет использоваться &lt;code&gt;index&lt;/code&gt; , и его область действия будет завершена после инициализации. И для вызова &lt;code&gt;index&lt;/code&gt; будет снова инициализирован:</target>
        </trans-unit>
        <trans-unit id="13061d26e5ff9f96a4c74bef2c43e6074905c506" translate="yes" xml:space="preserve">
          <source>We can see this by checking &lt;code&gt;ilocal&lt;/code&gt; before we declare it in each iteration:</source>
          <target state="translated">Мы можем убедиться в этом, проверив &lt;code&gt;ilocal&lt;/code&gt; перед тем, как объявить это в каждой итерации:</target>
        </trans-unit>
        <trans-unit id="ecacf20dbf2ba01fc16a5963696f4d9f3b309d3a" translate="yes" xml:space="preserve">
          <source>We will check , what actually happens when you declare &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;
  one by one.</source>
          <target state="translated">Мы проверим, что на самом деле происходит, когда вы объявляете &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; один за другим.</target>
        </trans-unit>
        <trans-unit id="82eaf8efa37e385e9b7152f30bdaadc0bf9ed115" translate="yes" xml:space="preserve">
          <source>Well, the problem is that the variable &lt;code&gt;i&lt;/code&gt;, within each of your anonymous functions, is bound to the same variable outside of the function.</source>
          <target state="translated">Проблема в том, что переменная &lt;code&gt;i&lt;/code&gt; в каждой из ваших анонимных функций связана с одной и той же переменной вне функции.</target>
        </trans-unit>
        <trans-unit id="41eb5e4bb9040aafd86158f33adfb76207526d4e" translate="yes" xml:space="preserve">
          <source>What you need to understand is the scope of the variables in javascript is based on the function. This is an important difference than say c# where you have block scope, and just copying the variable to one inside the for will work.</source>
          <target state="translated">Что вам нужно понять,так это то,что область применения переменных в javascript основана на функции.Это важное различие,чем,скажем,c#,где у вас есть область видимости блока,и просто копирование переменной в одну внутри for будет работать.</target>
        </trans-unit>
        <trans-unit id="63c86ee44958806285b881b5c6d1c72978293ea3" translate="yes" xml:space="preserve">
          <source>What you want to do is bind the variable within each function to a separate, unchanging value outside of the function:</source>
          <target state="translated">Что вы хотите сделать,так это привязать переменную внутри каждой функции к отдельному неизменяемому значению вне функции:</target>
        </trans-unit>
        <trans-unit id="8eedced39e77d173c59310d3d7130994ae20c1ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the solution to this basic problem?</source>
          <target state="translated">Каково решение этой основной проблемы?</target>
        </trans-unit>
        <trans-unit id="6f1a7ec31d6598725ab3a3e62f3cd605ed9af980" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, now the scope chain will be &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt;. This time &lt;code&gt;i&lt;/code&gt; can be found in the outer function's scope which is executed 3 times in the for loop, each time has value &lt;code&gt;i&lt;/code&gt; bound correctly. It won't use the value of &lt;code&gt;window.i&lt;/code&gt; when inner executed.</source>
          <target state="translated">Когда выполняются функции, теперь цепочка областей действия будет &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt; . На этот раз &lt;code&gt;i&lt;/code&gt; можно найти в области видимости внешней функции, которая выполняется 3 раза в цикле for, каждый раз значение имеет правильную привязку. Он не будет использовать значение &lt;code&gt;window.i&lt;/code&gt; при внутреннем выполнении.</target>
        </trans-unit>
        <trans-unit id="136bf4b99e71d62b188da8ea337423ca7b32ee1a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, the scope chain will be &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt;. Since the variable &lt;code&gt;i&lt;/code&gt; cannot be found in &lt;code&gt;function inner&lt;/code&gt; (neither declared using &lt;code&gt;var&lt;/code&gt; nor passed as arguments), it continues to search, until the value of &lt;code&gt;i&lt;/code&gt; is eventually found in the global scope which is &lt;code&gt;window.i&lt;/code&gt;.</source>
          <target state="translated">Когда выполняются функции, цепочка областей действия будет &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt; . Поскольку переменная &lt;code&gt;i&lt;/code&gt; не может быть найдена во &lt;code&gt;function inner&lt;/code&gt; (ни объявленной с использованием &lt;code&gt;var&lt;/code&gt; , ни переданной в качестве аргументов), она продолжает поиск, пока значение &lt;code&gt;i&lt;/code&gt; не будет найдено в глобальной области видимости, которая является &lt;code&gt;window.i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b6868f0d3df7b445fd72bcfe0420c84dbdc0c32" translate="yes" xml:space="preserve">
          <source>When a function gets executed, the runtime evaluates variables by searching the &lt;strong&gt;scope chain&lt;/strong&gt;. If a variable can be found in a certain point of the chain it will stop searching and use it, otherwise it continues until the global scope reached which belongs to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">Когда функция выполняется, среда выполнения оценивает переменные путем поиска в &lt;strong&gt;цепочке областей действия&lt;/strong&gt; . Если переменная может быть найдена в определенной точке цепочки, она прекращает поиск и использует ее, в противном случае она продолжается до достижения глобальной области видимости, принадлежащей &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdddce5cff579a440ec0f06c1f3a7517de4c89ef" translate="yes" xml:space="preserve">
          <source>When you create the closure, &lt;code&gt;i&lt;/code&gt; is a reference to the variable defined in the outside scope, not a copy of it as it was when you created the closure. It will be evaluated at the time of execution.</source>
          <target state="translated">Когда вы создаете замыкание, &lt;code&gt;i&lt;/code&gt; являюсь ссылкой на переменную, определенную во внешней области видимости, а не его копией, как это было при создании замыкания. Он будет оценен во время исполнения.</target>
        </trans-unit>
        <trans-unit id="c32d98513496eff571f807348f60d6eb70fa8459" translate="yes" xml:space="preserve">
          <source>When you declare a variable using &lt;code&gt;'var'&lt;/code&gt; outside a function ,it becomes global variable(you can check by typing &lt;code&gt;i&lt;/code&gt; or 
&lt;code&gt;window.i&lt;/code&gt; in console window.It will return 3).</source>
          <target state="translated">Когда вы объявляете переменную, используя &lt;code&gt;'var'&lt;/code&gt; вне функции, она становится глобальной переменной (вы можете проверить, набрав &lt;code&gt;i&lt;/code&gt; или &lt;code&gt;window.i&lt;/code&gt; в окне консоли. Она вернет 3).</target>
        </trans-unit>
        <trans-unit id="0700c840cf9074a17d6a57a019478e06397f4b95" translate="yes" xml:space="preserve">
          <source>When you declare variable using &lt;code&gt;'let'&lt;/code&gt; even outside the function but inside the loop , this variable will not be a Global 
variable , it will become a &lt;code&gt;Block&lt;/code&gt; level variable which is only available for the same function only.That is the reason , we 
are getting value of &lt;code&gt;i&lt;/code&gt; different for each function when we invoke the functions.</source>
          <target state="translated">Когда вы объявляете переменную, используя &lt;code&gt;'let'&lt;/code&gt; даже вне функции, но внутри цикла, эта переменная не будет глобальной переменной, она станет переменной уровня &lt;code&gt;Block&lt;/code&gt; которая доступна только для той же функции. По этой причине мы Получение значения &lt;code&gt;i&lt;/code&gt; отличается для каждой функции, когда мы вызываем функции.</target>
        </trans-unit>
        <trans-unit id="9315dce1f25ea4c4ba2729e3d74db8c96a980595" translate="yes" xml:space="preserve">
          <source>When you invoke the function , &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; takes the value from its &lt;code&gt;Global&lt;/code&gt; object and display the 
result.</source>
          <target state="translated">Когда вы вызываете функцию, &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; берет значение из своего &lt;code&gt;Global&lt;/code&gt; объекта и отображает результат.</target>
        </trans-unit>
        <trans-unit id="a04cb324afc79fff8ebd9cd463d1cacdf8ff5c49" translate="yes" xml:space="preserve">
          <source>Whereas I'd like it to output:</source>
          <target state="translated">В то время как я хотел бы,чтобы это вышло:</target>
        </trans-unit>
        <trans-unit id="c125d7c3843c2a8edd798658a1c8b7142f2e0175" translate="yes" xml:space="preserve">
          <source>With ES6 now mainstream, we can now use the new &lt;code&gt;let&lt;/code&gt; keyword to create block-scoped variables:</source>
          <target state="translated">Теперь, когда ES6 стал массовым, теперь мы можем использовать новое ключевое слово &lt;code&gt;let&lt;/code&gt; для создания блочных переменных:</target>
        </trans-unit>
        <trans-unit id="06647b92e9f39b50b8b5c9c9165cbfd5329f2810" translate="yes" xml:space="preserve">
          <source>With ES6 now widely supported, the best answer to this question has changed.  ES6 provides the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords for this exact circumstance.  Instead of messing around with closures, we can just use &lt;code&gt;let&lt;/code&gt; to set a loop scope variable like this:</source>
          <target state="translated">С ES6, теперь широко поддерживаемой, лучший ответ на этот вопрос изменился. ES6 предоставляет ключевые слова &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; для этого точного обстоятельства. Вместо того, чтобы возиться с замыканиями, мы можем просто использовать &lt;code&gt;let&lt;/code&gt; , чтобы установить переменную области видимости цикла следующим образом:</target>
        </trans-unit>
        <trans-unit id="bccb870c0505ba1198c8bd20fb323ffcaa0eec55" translate="yes" xml:space="preserve">
          <source>With new features of ES6 block level scoping is managed:</source>
          <target state="translated">С новыми функциями ES6 осуществляется управление масштабированием на уровне блоков:</target>
        </trans-unit>
        <trans-unit id="3f61a03573e1881b334382ba87fe17f8963f8f85" translate="yes" xml:space="preserve">
          <source>With the relatively widespread availability of the &lt;code&gt;Array.prototype.forEach&lt;/code&gt; function (in 2015), it's worth noting that in those situations involving iteration primarily over an array of values, &lt;code&gt;.forEach()&lt;/code&gt; provides a clean, natural way to get a distinct closure for every iteration. That is, assuming you've got some sort of array containing values (DOM references, objects, whatever), and the problem arises of setting up callbacks specific to each element, you can do this:</source>
          <target state="translated">Учитывая относительно широкую доступность функции &lt;code&gt;Array.prototype.forEach&lt;/code&gt; (в 2015 году), стоит отметить, что в тех ситуациях, когда итерации &lt;code&gt;.forEach()&lt;/code&gt; основном по массиву значений, .forEach () предоставляет чистый, естественный способ получить отчетливое замыкание для каждая итерация. То есть, если у вас есть какой-то массив, содержащий значения (ссылки на DOM, объекты и т. Д.), И возникает проблема настройки обратных вызовов, специфичных для каждого элемента, вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="afbb288fca9f8548f939b37452aa20bfc52aa22a" translate="yes" xml:space="preserve">
          <source>Wrapping it in a function that evaluates returning the function like apphacker's answer will do the trick, as the variable now has the function scope.</source>
          <target state="translated">Обертывание его в функцию,которая оценивает возврат функции,как ответ аппакера,сделает трюк,так как переменная теперь имеет область видимости функции.</target>
        </trans-unit>
        <trans-unit id="5a12c8a80e49d75e10abdc201b4e47c6ffdad1fc" translate="yes" xml:space="preserve">
          <source>You could then use your second loop and get the expected result or you could do</source>
          <target state="translated">Затем вы можете использовать ваш второй цикл и получить ожидаемый результат или вы можете сделать</target>
        </trans-unit>
        <trans-unit id="f3b66d71de3296a4d256ccc09d82d040d2cdb4f8" translate="yes" xml:space="preserve">
          <source>You could use a declarative module for lists of data such as &lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt;(*). In these situations I personally find a declarative approach less surprising</source>
          <target state="translated">Вы можете использовать декларативный модуль для списков данных, таких как &lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt; (*). В этих ситуациях я лично считаю декларативный подход менее удивительным</target>
        </trans-unit>
        <trans-unit id="ae314c4eceee085891b4c457750851f14dd5d46f" translate="yes" xml:space="preserve">
          <source>You need to understand that, in time when your functions are created, none of their code is executed, it is only saved for later. And so when they are called later, the interpreter executes them and asks: &quot;What is the current value of &lt;code&gt;i&lt;/code&gt;?&quot;</source>
          <target state="translated">Вы должны понимать, что во время создания ваших функций ни один из их кодов не выполняется, он сохраняется только для последующего использования. И поэтому, когда они вызываются позже, интерпретатор выполняет их и спрашивает: &amp;laquo;Каково текущее значение &lt;code&gt;i&lt;/code&gt; ?&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="4002c68c62355c5ff649328699085ae7df82a379" translate="yes" xml:space="preserve">
          <source>Your code doesn't work, because what it does is:</source>
          <target state="translated">Твой код не работает,потому что он работает:</target>
        </trans-unit>
        <trans-unit id="b42f3f6f796fa3cfcb6b1b8d49c7bcccc3a7164c" translate="yes" xml:space="preserve">
          <source>const</source>
          <target state="translated">const</target>
        </trans-unit>
        <trans-unit id="0262f9bb6ecbef4efbae97193c08ec335698a205" translate="yes" xml:space="preserve">
          <source>let</source>
          <target state="translated">let</target>
        </trans-unit>
        <trans-unit id="047a45ccf14f791a4c2261e7921f98e1170c10cc" translate="yes" xml:space="preserve">
          <source>no array</source>
          <target state="translated">отсутствие массива</target>
        </trans-unit>
        <trans-unit id="90aa229371a8bfd35bc600335c626fdfc9e82632" translate="yes" xml:space="preserve">
          <source>no extra for loop</source>
          <target state="translated">без лишних деталей</target>
        </trans-unit>
        <trans-unit id="fd20c34806b69001e12b7c2055620cd556c5b03f" translate="yes" xml:space="preserve">
          <source>try this shorter one</source>
          <target state="translated">попробуйте этот короткий</target>
        </trans-unit>
        <trans-unit id="a0d8045ff0e1110c300c0605fa5a3d0a54a9a9dc" translate="yes" xml:space="preserve">
          <source>which alerts &quot;2&quot;, for 3 times. This is because anonymous functions created in for loop, shares same closure, and in that closure, the value of &lt;code&gt;i&lt;/code&gt; is the same. Use this to prevent shared closure:</source>
          <target state="translated">который предупреждает &quot;2&quot;, 3 раза. Это связано с тем, что анонимные функции, созданные в цикле for, имеют одно и то же замыкание, и в этом замыкании значение &lt;code&gt;i&lt;/code&gt; одинаково. Используйте это для предотвращения общего закрытия:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
