<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/750486">
    <body>
      <group id="750486">
        <trans-unit id="dc928c660df5af8037b30d806a3d5e2bf719a6ad" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or asynchronous code, e.g. using Promises:</source>
          <target state="translated">또는 비동기 코드 (예 : 약속 사용) :</target>
        </trans-unit>
        <trans-unit id="eb729be35a722439cea750b023efdfbd8a9fd5db" translate="yes" xml:space="preserve">
          <source>(*) I'm the author of query-js and therefor biased towards using it, so don't take my words as a recommendation for said library only for the declarative approach :)</source>
          <target state="translated">(*) 나는 query-js의 저자이며 그것을 사용하는 것에 편향되어 있으므로 선언적 접근 방식에 대해서만 상기 라이브러리에 대한 권장 사항으로 내 말을 받아들이지 마십시오. :)</target>
        </trans-unit>
        <trans-unit id="eddee0d119554968d570b6aaa4f40b56ba855167" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;let&lt;/code&gt; makes variables block scoped. Blocks are denoted by curly braces, but in the case of the for loop the initialization variable, &lt;code&gt;i&lt;/code&gt; in our case, is considered to be declared in the braces.)</source>
          <target state="translated">(변수 범위를 블록으로 지정합니다. 블록은 중괄호로 표시되지만 for 루프의 경우 초기화 변수 &lt;code&gt;i&lt;/code&gt; 는 중괄호로 선언 된 것으로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="f507a9dd45beea522efee731e516a4bfacc41cde" translate="yes" xml:space="preserve">
          <source>// edited to use &lt;code&gt;forEach&lt;/code&gt; instead of map.</source>
          <target state="translated">// map 대신 &lt;code&gt;forEach&lt;/code&gt; 를 사용하도록 편집했습니다.</target>
        </trans-unit>
        <trans-unit id="17b3607fc13ef64118c5443ba1c9c1d143b46fdd" translate="yes" xml:space="preserve">
          <source>2015 Solution: forEach</source>
          <target state="translated">2015 솔루션 : forEach</target>
        </trans-unit>
        <trans-unit id="d16a35fbcaef2b1dca935e1c55b24f332b1909de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is similar to &lt;code&gt;let&lt;/code&gt; with the additional restriction that the variable name can't be rebound to a new reference after initial assignment.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 초기 할당 후에 변수 이름을 새로운 참조로 리바운드 할 수 없다는 추가 제한을 &lt;code&gt;let&lt;/code&gt; 하는 것과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="fbbe8653d1dfb5593d280c0119120a5978f7f167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; will then point to an object that is specific to that particular turn of the loop, and will return the correct value without the additional closure notation.  This obviously significantly simplifies this problem.</source>
          <target state="translated">그런 다음 &lt;code&gt;val&lt;/code&gt; 은 루프의 특정 회전과 관련된 객체를 가리키고 추가 클로저 표기법없이 올바른 값을 반환합니다. 이것은 분명히이 문제를 단순화시킵니다.</target>
        </trans-unit>
        <trans-unit id="aa353dcd5215f0728af0723f85f0b49b2fd877da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/QcUjH/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cee360f8affd282a49319123ba4b739670977a33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;JavaScript Functions close over the scope they are declared in, and retain access to that scope even as variable values inside of that scope change.&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;JavaScript 함수는 선언 된 범위를 닫고 해당 범위 내의 변수 값이 변경 되더라도 해당 범위에 대한 액세스 권한을 유지합니다.&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcd4a38dd9d5d22f20fd8d103d19cba48e2a08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE2 : using let&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CASE2 : let 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2336bd1c125961b35dcc0669018238c6a1c450b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case1&lt;/strong&gt; : &lt;strong&gt;using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Case1&lt;/strong&gt; : &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db76f0a25108e4cb963d0a08f23235f505a9cc91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="928e77cd42bada13b2e96f39a542c07f34441c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt; (2014):</source>
          <target state="translated">&lt;strong&gt;편집&lt;/strong&gt; (2014) :</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ee4929b02b00a95af685069745e1a9289475361" translate="yes" xml:space="preserve">
          <source>A function defines a new environment</source>
          <target state="translated">새로운 환경을 정의하는 함수</target>
        </trans-unit>
        <trans-unit id="e2c13ee3a978048a3137a1833fb1aa49fd75d41a" translate="yes" xml:space="preserve">
          <source>After reading through various solutions, I'd like to add that the reason those solutions work is to rely on the concept of &lt;strong&gt;scope chain&lt;/strong&gt;. It's the way JavaScript resolve a variable during execution.</source>
          <target state="translated">다양한 솔루션을 읽은 후 해당 솔루션이 작동하는 이유는 &lt;strong&gt;스코프 체인&lt;/strong&gt; 개념에 의존하기 때문입니다. JavaScript가 실행 중에 변수를 해결하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="59f1a06e96e0a1d91f4b2f10b668ef1eb36280e5" translate="yes" xml:space="preserve">
          <source>And yet another solution: instead of creating another loop, just bind the &lt;code&gt;this&lt;/code&gt; to the return function.</source>
          <target state="translated">그리고 또 다른 해결책 : 다른 루프를 만드는 대신 &lt;code&gt;this&lt;/code&gt; 반환 함수에 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="af8dd16cbb53de1fb9c996e760b11016a9adf276" translate="yes" xml:space="preserve">
          <source>Another option is to construct a function object which will be able to close over the variable. That can be accomplished thusly</source>
          <target state="translated">또 다른 옵션은 변수를 닫을 수있는 함수 객체를 구성하는 것입니다. 그것은 그렇게 달성 될 수있다</target>
        </trans-unit>
        <trans-unit id="83f0151cc81dcad21b18870ef244c89ed233b178" translate="yes" xml:space="preserve">
          <source>Another way of saying it is that the &lt;code&gt;i&lt;/code&gt; in your function is bound at the time of executing the function, not the time of creating the function.</source>
          <target state="translated">그것을 말하는 또 다른 방법은 함수를 만들 때가 아니라 함수를 실행할 때 함수의 &lt;code&gt;i&lt;/code&gt; 가 바인딩된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe46ee279e1078d521ad24eab1803db3091cc1ba" translate="yes" xml:space="preserve">
          <source>Another way that hasn't been mentioned yet is the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">아직 언급되지 않은 또 다른 방법은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; 를&lt;/a&gt; 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a3039f572fbd5faba88c0f53f09bab9d8efef2a" translate="yes" xml:space="preserve">
          <source>As pointed out by @squint and @mekdev, you get better performance by creating the function outside the loop first and then binding the results within the loop.</source>
          <target state="translated">@squint와 @mekdev에서 지적했듯이 루프 외부에서 함수를 먼저 만든 다음 루프 내에서 결과를 바인딩하여 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="42b2efc257450cf5c19a0de0f625821526dd089a" translate="yes" xml:space="preserve">
          <source>Beware, though, that IE9-IE11 and Edge prior to Edge 14 support &lt;code&gt;let&lt;/code&gt; but get the above wrong (they don't create a new &lt;code&gt;i&lt;/code&gt; each time, so all the functions above would log 3 like they would if we used &lt;code&gt;var&lt;/code&gt;). Edge 14 finally gets it right.</source>
          <target state="translated">그러나 Edge 14 이전의 IE9-IE11 및 Edge는 위의 잘못을 &lt;code&gt;let&lt;/code&gt; 하지만 매번 새 &lt;code&gt;i&lt;/code&gt; 를 작성하지 않으므로 위의 모든 함수는 &lt;code&gt;var&lt;/code&gt; 를 사용하는 것처럼 3을 기록합니다. Edge 14가 마침내 그것을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="f85de91248746eb3a5e9b79c074698a4ae4c28de" translate="yes" xml:space="preserve">
          <source>Bit late to the party, but I was exploring this issue today and noticed that many of the answers don't completely address how Javascript treats scopes, which is essentially what this boils down to.</source>
          <target state="translated">파티에 늦었지만 오늘이 문제를 탐색하고 있었고 많은 답변이 Javascript가 범위를 처리하는 방법을 완전히 다루지 않았 음을 발견했습니다. 이것이 본질적으로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d18dcd8e75cb24ac1b57dbc9fcb10f393b34db" translate="yes" xml:space="preserve">
          <source>Browser support is now here for those targeting the latest versions of browsers. &lt;code&gt;const&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; are currently supported in the latest Firefox, Safari, Edge and Chrome. It also is supported in Node, and you can use it anywhere by taking advantage of build tools like Babel.  You can see a working example here: &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http://jsfiddle.net/ben336/rbU4t/2/&lt;/a&gt;</source>
          <target state="translated">최신 버전의 브라우저를 대상으로하는 사용자를위한 브라우저 지원이 제공됩니다. &lt;code&gt;const&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; 은 현재 최신 Firefox, Safari, Edge 및 Chrome에서 지원됩니다. 또한 Node에서도 지원되며 Babel과 같은 빌드 도구를 활용하여 어디서나 사용할 수 있습니다. 실제 예제를 볼 수 있습니다 : &lt;a href=&quot;http://jsfiddle.net/ben336/rbU4t/2/&quot;&gt;http://jsfiddle.net/ben336/rbU4t/2/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e8592d1f91df5a55a1cfdc2e8ad8109f4f444e" translate="yes" xml:space="preserve">
          <source>By binding &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt;, solves the problem as well.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;이것을&lt;/em&gt;&lt;/strong&gt; 바인딩하면 문제도 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="e2c0b41bb4cd85c199d654ca3b1181205c008ac6" translate="yes" xml:space="preserve">
          <source>By wrapping it in an outer function either explicitly define a helper function like &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;harto&lt;/a&gt; did or use an anonymous function like &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjorn&lt;/a&gt; did:</source>
          <target state="translated">외부 함수에 래핑하여 &lt;a href=&quot;https://stackoverflow.com/a/750506&quot;&gt;harto&lt;/a&gt; 처럼 도우미 함수를 명시 적으로 정의하거나 &lt;a href=&quot;https://stackoverflow.com/a/750495&quot;&gt;Bjorn&lt;/a&gt; 처럼 익명 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b00f1c7b6969ce0e50f2b22fb797f9393fa48092" translate="yes" xml:space="preserve">
          <source>Classic solution: Closures</source>
          <target state="translated">클래식 솔루션 : 마감</target>
        </trans-unit>
        <trans-unit id="598760db895cc7507725eda06e8c54cdcd677e9d" translate="yes" xml:space="preserve">
          <source>Closures in loops</source>
          <target state="translated">루프 폐쇄</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="dbf8d82fe089a56de712565f9c4ada9757048bdf" translate="yes" xml:space="preserve">
          <source>Creating the inner function inside a wrapper function gives the inner function a private environment that only it can access, a &quot;closure&quot;. Thus, every time we call the wrapper function we create a new inner function with it's own separate environment, ensuring that the &lt;code&gt;ilocal&lt;/code&gt; variables don't collide and overwrite each other. A few minor optimizations gives the final answer that many other SO users gave:</source>
          <target state="translated">랩퍼 함수 내에 내부 함수를 작성하면 내부 함수에만 액세스 할 수있는 &quot;클로저&quot;개인 환경이 제공됩니다. 따라서 랩퍼 함수를 ​​호출 할 때마다 자체 환경이있는 새로운 내부 함수를 작성하여 &lt;code&gt;ilocal&lt;/code&gt; 변수가 서로 충돌하고 겹쳐지지 않도록합니다. 몇 가지 사소한 최적화는 다른 많은 SO 사용자가 제공 한 최종 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0bf57ac890ee94c29cbca98cfd5e5a3399af610b" translate="yes" xml:space="preserve">
          <source>Do the same thing, Go to the scopes . Now you will see two objects &lt;code&gt;&quot;Block&quot;&lt;/code&gt; and &lt;code&gt;&quot;Global&quot;&lt;/code&gt;. Now expand &lt;code&gt;Block&lt;/code&gt; object , you 
will see 'i' is defined there , and the strange thing is that , for every functions , the value if &lt;code&gt;i&lt;/code&gt; is different (0 , 1, 2).</source>
          <target state="translated">동일한 작업을 수행하십시오. 범위로 이동하십시오. 이제 &lt;code&gt;&quot;Block&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;Global&quot;&lt;/code&gt; 두 객체가 보일 것입니다. 이제 &lt;code&gt;Block&lt;/code&gt; 객체를 확장하면 거기에 'i'가 정의되어 있으며 이상한 점은 모든 함수에 대해 &lt;code&gt;i&lt;/code&gt; 가 다른 경우 값 (0, 1, 2)이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc17cd44f5151274b6472f08f4a5ba3902b3c50d" translate="yes" xml:space="preserve">
          <source>Docs here:</source>
          <target state="translated">여기 문서 :</target>
        </trans-unit>
        <trans-unit id="5b6186c2bae4c5d9cff6452027174031b440b4fc" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 (ES6) introduces new &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords that are scoped differently than &lt;code&gt;var&lt;/code&gt;-based variables. For example, in a loop with a &lt;code&gt;let&lt;/code&gt;-based index, each iteration through the loop will have a new value of &lt;code&gt;i&lt;/code&gt; where each value is scoped inside the loop, so your code would work as you expect. There are many resources, but I'd recommend &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2ality's block-scoping post&lt;/a&gt; as a great source of information.</source>
          <target state="translated">ECMAScript 6 (ES6)에는 &lt;code&gt;var&lt;/code&gt; 기반 변수와 다른 범위의 새로운 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 키워드가 도입되었습니다. 예를 들어, &lt;code&gt;let&lt;/code&gt; 기반 색인이있는 루프에서 루프를 통한 각 반복에는 새 값 &lt;code&gt;i&lt;/code&gt; 가 있으며, 여기서 각 값은 루프 내에서 범위가 지정되므로 코드가 예상대로 작동합니다. 많은 자료가 있지만 &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;2ality의 블록 범위 게시물&lt;/a&gt; 을 훌륭한 정보 출처로 추천합니다.</target>
        </trans-unit>
        <trans-unit id="5ed5a45b23d6515c9b67dd7392bcd46f8b115bb8" translate="yes" xml:space="preserve">
          <source>ES6 solution: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">ES6 솔루션 : &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64bc654fab8e53127f8d388bf9e93a88ac2444b0" translate="yes" xml:space="preserve">
          <source>Each function definition forms a scope consisting of all the local 
variables declared by &lt;code&gt;var&lt;/code&gt; and its &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">각 함수 정의는 &lt;code&gt;var&lt;/code&gt; 및 해당 &lt;code&gt;arguments&lt;/code&gt; 선언 된 모든 로컬 변수로 구성된 범위를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="6de361507511a955710bf041e4598d0a56a8dae7" translate="yes" xml:space="preserve">
          <source>Each function in the array above closes over the global scope (global, simply because that happens to be the scope they're declared in).</source>
          <target state="translated">위의 배열에있는 각 함수는 전역 범위 (전역 적으로 선언 된 범위이기 때문에 전역)를 통해 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="c98d55c06e5db0b478bd67b5f9f6e088981d4dbc" translate="yes" xml:space="preserve">
          <source>First of all, understand what's wrong with this code:</source>
          <target state="translated">우선,이 코드의 문제점을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="5590c5a73882c70beab8fa507ee23f99c76c54db" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, please see &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript closure pitfalls and usage&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://gist.github.com/lucastan/5420969&quot;&gt;JavaScript 클로저 함정 및 사용법을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf49ae6852c624511c9b32a1af34f1d76ca92bea" translate="yes" xml:space="preserve">
          <source>For each time &lt;code&gt;makeCounter&lt;/code&gt; is invoked, &lt;code&gt;{counter: 0}&lt;/code&gt; results in a new object being created. Also, a new copy of &lt;code&gt;obj&lt;/code&gt; 
is created as well to reference the new object. Thus, &lt;code&gt;counter1&lt;/code&gt; and &lt;code&gt;counter2&lt;/code&gt; are independent of each other.</source>
          <target state="translated">&lt;code&gt;makeCounter&lt;/code&gt; 가 호출 될 때마다 &lt;code&gt;{counter: 0}&lt;/code&gt; 이 새 오브젝트를 작성합니다. 또한 새 객체를 참조 할뿐만 아니라 새로운 &lt;code&gt;obj&lt;/code&gt; 사본이 생성됩니다. 따라서 &lt;code&gt;counter1&lt;/code&gt; 과 &lt;code&gt;counter2&lt;/code&gt; 는 서로 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="84dd8709188509b7ebfa0a06cdf3ca787373d95d" translate="yes" xml:space="preserve">
          <source>For more detail about how closer works , please go through the awesome video tutorial &lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;https://youtu.be/71AtaJpJHw0&lt;/a&gt;</source>
          <target state="translated">더 가까이 작동하는 방법에 대한 자세한 내용은 멋진 비디오 자습서를 &lt;a href=&quot;https://youtu.be/71AtaJpJHw0&quot;&gt;참조하십시오 https://youtu.be/71AtaJpJHw0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73383c41720fe072e14e88088ed75954af130ef2" translate="yes" xml:space="preserve">
          <source>Here when the &lt;code&gt;funcs[]&lt;/code&gt; array is being initialized, &lt;code&gt;i&lt;/code&gt; is being incremented, the &lt;code&gt;funcs&lt;/code&gt; array is initialized and the size of &lt;code&gt;func&lt;/code&gt; array becomes 3,  so &lt;code&gt;i = 3,&lt;/code&gt;. 
Now when the &lt;code&gt;funcs[j]()&lt;/code&gt; is called, it is again using the variable &lt;code&gt;i&lt;/code&gt;, which has already been incremented to 3.</source>
          <target state="translated">여기서 &lt;code&gt;funcs[]&lt;/code&gt; 배열을 초기화 할 때 &lt;code&gt;i&lt;/code&gt; 가 증가하고, &lt;code&gt;funcs&lt;/code&gt; 배열이 초기화되고 &lt;code&gt;func&lt;/code&gt; 배열의 크기가 3이되어 &lt;code&gt;i = 3,&lt;/code&gt; 됩니다. 이제 &lt;code&gt;funcs[j]()&lt;/code&gt; 가 호출되면 이미 3으로 증가한 변수 &lt;code&gt;i&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8f35d22ff5ba383350d5598f465bc196cdf3ce7b" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses &lt;code&gt;forEach&lt;/code&gt; (works back to IE9):</source>
          <target state="translated">다음은 &lt;code&gt;forEach&lt;/code&gt; 를 사용하는 간단한 솔루션입니다 (IE9로 다시 작동).</target>
        </trans-unit>
        <trans-unit id="2642451687a6d07efdd6119990ff4d294e12e364" translate="yes" xml:space="preserve">
          <source>Here's another variation on the technique, similar to Bjorn's (apphacker), which lets you assign the variable value inside the function rather than passing it as a parameter, which might be clearer sometimes:</source>
          <target state="translated">Bjorn (apphacker)과 유사한이 기술에 대한 또 다른 변형은 다음과 같습니다.이 값을 사용하면 변수 값을 매개 변수로 전달하지 않고 함수 내부에 변수 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e202b66610d948919c3fdefd78e9484928e84630" translate="yes" xml:space="preserve">
          <source>I prefer to use &lt;code&gt;forEach&lt;/code&gt; function, which has its own closure with creating a pseudo range:</source>
          <target state="translated">의사 범위를 만드는 자체 폐쇄 기능이있는 &lt;code&gt;forEach&lt;/code&gt; 함수를 사용하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="992673a4459fe4cf804cfb25b0564cfb73dcf973" translate="yes" xml:space="preserve">
          <source>I'm surprised no one yet has suggested using the &lt;code&gt;forEach&lt;/code&gt; function to better avoid (re)using local variables. In fact, I'm not using &lt;code&gt;for(var i ...)&lt;/code&gt; at all anymore for this reason.</source>
          <target state="translated">아무도 아직 &lt;code&gt;forEach&lt;/code&gt; 함수를 사용하여 로컬 변수를 사용하지 않는 것이 좋습니다. 사실, 나는 더 이상 for &lt;code&gt;for(var i ...)&lt;/code&gt; 를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e040e009c09ed4ea050266166917340b79d5172" translate="yes" xml:space="preserve">
          <source>If we have inner function defined inside another (outer) function, this 
forms a chain, and will be used during execution</source>
          <target state="translated">내부 함수가 다른 (외부) 함수 안에 정의되어 있으면 체인을 형성하고 실행 중에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="48318c5a7aa0cc36320e6ea3e8a2f58e178c5e74" translate="yes" xml:space="preserve">
          <source>If you happen to be working in jQuery, the &lt;code&gt;$.each()&lt;/code&gt; function gives you a similar capability.</source>
          <target state="translated">jQuery에서 작업하는 경우 &lt;code&gt;$.each()&lt;/code&gt; 함수는 비슷한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1b95e198fd7ba1aeb8dcff4ebe0215d817d76da2" translate="yes" xml:space="preserve">
          <source>Important: JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. In other words, block statements do not introduce a scope. Although &quot;standalone&quot; blocks are valid syntax, you do not want to use standalone blocks in JavaScript, because they don't do what you think they do, if you think they do anything like such blocks in C or Java.</source>
          <target state="translated">중요 : JavaScript에는 블록 범위가 없습니다. 블록과 함께 도입 된 변수는 포함 함수 또는 스크립트로 범위가 지정되며 변수 설정의 효과는 블록 자체를 넘어서 유지됩니다. 다시 말해, 블록 명령문은 범위를 도입하지 않습니다. &quot;독립형&quot;블록은 유효한 구문이지만 C 또는 Java에서 이러한 블록과 같은 것으로 생각되면 자신이 생각하는대로하지 않기 때문에 JavaScript에서 독립형 블록을 사용하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc1c433ad90b0405b9ca2f387ce719f1317f024c" translate="yes" xml:space="preserve">
          <source>In the initial code:</source>
          <target state="translated">초기 코드에서 :</target>
        </trans-unit>
        <trans-unit id="3309306702dd9476c24f82f81900b045baacba18" translate="yes" xml:space="preserve">
          <source>Instead of using:</source>
          <target state="translated">사용하는 대신:</target>
        </trans-unit>
        <trans-unit id="0e64d1c665d5704b6db4083a7e876035507656e4" translate="yes" xml:space="preserve">
          <source>It includes the common mistake in creating closure in the loop as what we have here, as well as why we need closure and the performance consideration.</source>
          <target state="translated">여기에는 루프에서 클로저를 생성 할 때 발생하는 일반적인 실수와 클로저가 필요한 이유 및 성능 고려 사항이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c7a62a8bcb4b3f1a995d4c6ad5d2aed23bd392a4" translate="yes" xml:space="preserve">
          <source>It outputs this:</source>
          <target state="translated">이것을 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="446ebfbbfc1222a93e3455219c2dab41a45fae1a" translate="yes" xml:space="preserve">
          <source>JavaScript closure inside loops – simple practical example</source>
          <target state="translated">루프 내부의 JavaScript 클로저 &amp;ndash; 간단한 실제 예</target>
        </trans-unit>
        <trans-unit id="b59b3a0eadd20a0309b2b53fc1fde821c0efabd9" translate="yes" xml:space="preserve">
          <source>JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script</source>
          <target state="translated">JavaScript에는 블록 범위가 없습니다. 블록으로 도입 된 변수는 포함 함수 또는 스크립트 범위</target>
        </trans-unit>
        <trans-unit id="7730326939f83587e92049d0141579e4c07112ed" translate="yes" xml:space="preserve">
          <source>JavaScript functions &quot;close over&quot; the scope they have access to upon declaration, and retain access to that scope even as variables in that scope change.</source>
          <target state="translated">JavaScript 함수는 선언시 액세스 할 수있는 범위를 &quot;닫고&quot;해당 범위의 변수가 변경 되더라도 해당 범위에 대한 액세스 권한을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="238b22aa94cfcf877019c9fda879a8c85eccf5c8" translate="yes" xml:space="preserve">
          <source>Just like before, where each inner function outputted the last value assigned to &lt;code&gt;i&lt;/code&gt;, now each inner function just outputs the last value assigned to &lt;code&gt;ilocal&lt;/code&gt;. But shouldn't each iteration have it's own &lt;code&gt;ilocal&lt;/code&gt;?</source>
          <target state="translated">이전과 마찬가지로 각 내부 함수가 &lt;code&gt;i&lt;/code&gt; 에 할당 된 마지막 값을 출력 한 경우 각 내부 함수는 &lt;code&gt;ilocal&lt;/code&gt; 에 할당 된 마지막 값을 출력합니다. 그러나 각 반복에 고유 한 &lt;code&gt;ilocal&lt;/code&gt; 이 없어야 합니까?</target>
        </trans-unit>
        <trans-unit id="60de88573410b40b98c0419ee80d503add1f0b84" translate="yes" xml:space="preserve">
          <source>Just thought I'd add an explanation for clarity. For a solution, personally, I'd go with Harto's since it is the most self-explanatory way of doing it from the answers here. Any of the code posted will work, but I'd opt for a closure factory over having to write a pile of comments to explain why I'm declaring a new variable(Freddy and 1800's) or have weird embedded closure syntax(apphacker).</source>
          <target state="translated">명확성을 위해 설명을 추가한다고 생각했습니다. 해결책을 위해 개인적으로 Harto 's와 함께 갈 것입니다. 하 토스의 대답에서 가장 잘 설명 할 수있는 방법이기 때문입니다. 게시 된 코드는 모두 작동하지만 새 변수를 선언하는 이유 (Freddy 및 1800) 또는 이상한 내장 폐쇄 구문 (apphacker)이있는 이유를 설명하기 위해 주석 더미를 작성 해야하는 폐쇄 공장을 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="a8606d4d4c57cf9245d54d71c6060344bd0018af" translate="yes" xml:space="preserve">
          <source>Later those functions are invoked logging the most current value of &lt;code&gt;i&lt;/code&gt; in the global scope. That's the magic, and frustration, of closure.</source>
          <target state="translated">나중에 이러한 함수는 전역 범위에서 &lt;code&gt;i&lt;/code&gt; 의 최신 값을 기록하여 호출됩니다. 그것이 폐쇄의 마법과 좌절입니다.</target>
        </trans-unit>
        <trans-unit id="a4cbeead2a01a91773ed38966d1bd68a0cf65493" translate="yes" xml:space="preserve">
          <source>Look how easy it is now! For more information see &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;this answer&lt;/a&gt;, which my info is based off of.</source>
          <target state="translated">지금 얼마나 쉬운 지보세요! 자세한 내용은 내 &lt;a href=&quot;https://stackoverflow.com/a/16661498/1852456&quot;&gt;답변을&lt;/a&gt; 기반으로하는 이 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b088112b87675051406803805f579695595f5b2d" translate="yes" xml:space="preserve">
          <source>Many solutions seem correct but they don't mention it's called &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt;&lt;code&gt;Currying&lt;/code&gt;&lt;/a&gt; which is a functional programming design pattern for situations like here. 3-10 times faster than bind depending on the browser.</source>
          <target state="translated">많은 솔루션이 올바른 것처럼 보이지만 여기와 같은 상황에 대한 기능적 프로그래밍 디자인 패턴 인 &lt;a href=&quot;https://www.sitepoint.com/currying-in-functional-javascript/&quot;&gt; &lt;code&gt;Currying&lt;/code&gt; &lt;/a&gt; 은 언급하지 않았습니다. 브라우저에 따라 바인딩보다 3-10 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e962642d87dac6e6eaabd9cce80d6d6ef936efb9" translate="yes" xml:space="preserve">
          <source>More detail can be found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;여기를 참조하십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f044a862a3c54554110bd80647a24a8aec606c78" translate="yes" xml:space="preserve">
          <source>Most of the other answers provide ways to work around by creating another variable that won't change the value for you.</source>
          <target state="translated">다른 답변의 대부분은 값을 변경하지 않는 다른 변수를 만들어서 해결하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f3db1d328e14ab1aba57088c58908a1f67ace0c3" translate="yes" xml:space="preserve">
          <source>My value: 0</source>
          <target state="translated">내 가치 : 0</target>
        </trans-unit>
        <trans-unit id="2d55b4d0b763195615ef4724ce4993d677fbd4b0" translate="yes" xml:space="preserve">
          <source>My value: 1</source>
          <target state="translated">내 가치 : 1</target>
        </trans-unit>
        <trans-unit id="0331560236a0dceed2a2d2b9bf6bd0e3be783b79" translate="yes" xml:space="preserve">
          <source>My value: 2</source>
          <target state="translated">내 가치 : 2</target>
        </trans-unit>
        <trans-unit id="e8f2bf16e2d1a506e725cd7e4f26518d4243a2b8" translate="yes" xml:space="preserve">
          <source>My value: 3</source>
          <target state="translated">내 가치 : 3</target>
        </trans-unit>
        <trans-unit id="6d57ec64d31326c59930512d69d111aaca5158ea" translate="yes" xml:space="preserve">
          <source>Note that whatever technique you use, the &lt;code&gt;index&lt;/code&gt; variable becomes a sort of static variable, bound to the returned copy of the inner function. I.e., changes to its value are preserved between calls. It can be very handy.</source>
          <target state="translated">어떤 기술을 사용하든 &lt;code&gt;index&lt;/code&gt; 변수는 내부 함수의 반환 된 복사본에 바인딩 된 일종의 정적 변수가됩니다. 즉, 값을 변경해도 통화간에 유지됩니다. 매우 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d115a789a23b856b557e0cada39a69b17b4eb6ab" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;counters[0]&lt;/code&gt; and &lt;code&gt;counters[1]&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; independent. In fact, they operate on the same &lt;code&gt;obj&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;counters[0]&lt;/code&gt; 와 &lt;code&gt;counters[1]&lt;/code&gt; 은 독립적 &lt;em&gt;이지 않습니다&lt;/em&gt; . 실제로, 그들은 동일한 &lt;code&gt;obj&lt;/code&gt; 에서 작동합니다!</target>
        </trans-unit>
        <trans-unit id="27739c2610dea465069c0941fc061abd280f2fe1" translate="yes" xml:space="preserve">
          <source>Now open your &lt;strong&gt;chrome console window&lt;/strong&gt; by pressing &lt;strong&gt;F12&lt;/strong&gt; and refresh the page.
Expend every 3 functions inside the array.You will see an property called &lt;code&gt;[[Scopes]]&lt;/code&gt;.Expand that one. You will see one 
array object called &lt;code&gt;&quot;Global&quot;&lt;/code&gt;,expand that one. You will find a property &lt;code&gt;'i'&lt;/code&gt; declared into the object which having value 3.</source>
          <target state="translated">이제 &lt;strong&gt;F12&lt;/strong&gt; 를 눌러 &lt;strong&gt;크롬 콘솔 창&lt;/strong&gt; 을 열고 페이지를 새로 고 &lt;strong&gt;칩니다&lt;/strong&gt; . 배열 내에서 3 개의 함수마다 소비합니다. &lt;code&gt;[[Scopes]]&lt;/code&gt; 라는 속성이 표시됩니다. &lt;code&gt;&quot;Global&quot;&lt;/code&gt; 이라는 배열 객체가 하나 표시됩니다. 값이 3 인 객체에 &lt;code&gt;'i'&lt;/code&gt; 속성이 선언되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d0128e42e75de0128629303ed3317596a65ec7c" translate="yes" xml:space="preserve">
          <source>Now replace the &lt;code&gt;'var'&lt;/code&gt; with &lt;code&gt;'let'&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;'var'&lt;/code&gt; 을 &lt;code&gt;'let'&lt;/code&gt; 으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e7a5c903dc66b4202f3fb5824fd1acaebe39b5e3" translate="yes" xml:space="preserve">
          <source>Now the question is, what is the value of variable &lt;code&gt;i&lt;/code&gt; when the function is called? Because the first loop is created with the condition of &lt;code&gt;i &amp;lt; 3&lt;/code&gt;, it stops immediately when the condition is false, so it is &lt;code&gt;i = 3&lt;/code&gt;.</source>
          <target state="translated">이제 문제는 함수가 호출 될 때 변수 &lt;code&gt;i&lt;/code&gt; 의 값은 무엇입니까? 첫 번째 루프는 &lt;code&gt;i &amp;lt; 3&lt;/code&gt; 조건으로 작성되므로 조건이 false 일 때 즉시 중지되므로 &lt;code&gt;i = 3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="abede10eb5958e091577c93ed78b659c1fd6b8d7" translate="yes" xml:space="preserve">
          <source>Now to solve this, we have many options. Below are two of them:</source>
          <target state="translated">이제이 문제를 해결하기 위해 많은 옵션이 있습니다. 아래는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="cfc6640b07aafd6b4f2b2c454cc170531c28bdd0" translate="yes" xml:space="preserve">
          <source>Other Option can be to introduce a &lt;code&gt;tempFunc&lt;/code&gt; which returns the actual function:</source>
          <target state="translated">다른 옵션은 실제 함수를 반환하는 &lt;code&gt;tempFunc&lt;/code&gt; 를 도입하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="34f687cbb93dc0653344b56a9a0414f48bb65986" translate="yes" xml:space="preserve">
          <source>Personally I think @Aust's &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt;more recent answer about using &lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; is the best way to do this kind of thing now. There's also lo-dash/underscore's &lt;code&gt;_.partial&lt;/code&gt; when you don't need or want to mess with &lt;code&gt;bind&lt;/code&gt;'s &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">개인적으로 나는 &lt;a href=&quot;https://stackoverflow.com/a/19323214/918959&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; 사용에 대한 @Aust의 최근 답변&lt;/a&gt; 이 지금 이런 종류의 일을하는 가장 좋은 방법이라고 생각합니다. &lt;code&gt;bind&lt;/code&gt; 의 &lt;code&gt;thisArg&lt;/code&gt; 를 필요로하거나 엉망으로 만들지 않을 때 lo-dash / underscore의 &lt;code&gt;_.partial&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="33ae767cca439e92c07c52820fbd5bfdc58bbc2a" translate="yes" xml:space="preserve">
          <source>Reiterated for emphasis:</source>
          <target state="translated">강조를 위해 반복했다 :</target>
        </trans-unit>
        <trans-unit id="73347c41ddd8169b581b07c3a5f099ea95b7fcec" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;the performance gain in different browsers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsperf.com/bind-vs-curry&quot;&gt;다른 브라우저에서 성능 향상을&lt;/a&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f14d9d164a119f095479c9bdd9465790ed99d8a9" translate="yes" xml:space="preserve">
          <source>Since there is no block scope in JavaScript - only function scope - by wrapping the function creation in a new function, you ensure that the value of &quot;i&quot; remains as you intended.</source>
          <target state="translated">함수 작성을 새 함수로 랩핑하여 JavaScript에는 함수 범위 만있는 블록 범위가 없으므로 &quot;i&quot;값이 의도 한대로 유지되도록합니다.</target>
        </trans-unit>
        <trans-unit id="12ea089e3baa0954613acc9720385107e03757cc" translate="yes" xml:space="preserve">
          <source>So as many others mentioned, the problem is that the inner function is referencing the same &lt;code&gt;i&lt;/code&gt; variable. So why don't we just create a new local variable each iteration, and have the inner function reference that instead?</source>
          <target state="translated">많은 다른 사람들이 언급했듯이 문제는 내부 함수가 동일한 &lt;code&gt;i&lt;/code&gt; 변수를 참조한다는 것입니다. 그렇다면 매번 반복 할 때마다 새로운 지역 변수를 만들고 내부 함수 참조를 대신 사용하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7d7773485c1261a529fe53aef20a83135c3f681e" translate="yes" xml:space="preserve">
          <source>So, your goal is to first save the value of &lt;code&gt;i&lt;/code&gt; to function and only after that save the function to &lt;code&gt;funcs&lt;/code&gt;. This could be done for example this way:</source>
          <target state="translated">따라서 목표는 먼저 &lt;code&gt;i&lt;/code&gt; 값을 함수에 저장 한 후에 만 ​​함수를 &lt;code&gt;funcs&lt;/code&gt; 에 저장하는 것입니다. 예를 들어 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410e0c771b6ff78915e121b00114280170dd8b10" translate="yes" xml:space="preserve">
          <source>Solution is to use another helper function:</source>
          <target state="translated">해결책은 다른 도우미 기능을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d016322d1f5eb6c4a54ca8c4ccd762b80be09d6c" translate="yes" xml:space="preserve">
          <source>That looks uglier than ranges in other languages, but IMHO less monstrous than other solutions.</source>
          <target state="translated">그것은 다른 언어의 범위보다 더 추해 보이지만 IMHO는 다른 솔루션보다 괴물이 적습니다.</target>
        </trans-unit>
        <trans-unit id="fbf90835c1301013d8226aab628759d12857a503" translate="yes" xml:space="preserve">
          <source>The annominous function you declared will not call and check the value inside the function unless you invoke the 
functions.</source>
          <target state="translated">선언 한 익명 함수는 함수를 호출하지 않으면 함수 내부의 값을 호출하고 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ec86a7c0d2ecc1756f2033a01be68683a88896e" translate="yes" xml:space="preserve">
          <source>The code in OP's question is replaced with &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of &lt;strong&gt;&lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">OP 질문의 코드는 &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt; 대신 &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; 으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f008bbf9daade719e6087c2d074071c310e2e621" translate="yes" xml:space="preserve">
          <source>The error actually does not occur until &lt;code&gt;funcs[someIndex]&lt;/code&gt; is executed &lt;code&gt;()&lt;/code&gt;. Using this same logic, it should be apparent that the value of &lt;code&gt;i&lt;/code&gt; is also not collected until this point either. Once the original loop finishes, &lt;code&gt;i++&lt;/code&gt; brings &lt;code&gt;i&lt;/code&gt; to the value of &lt;code&gt;3&lt;/code&gt; which results in the condition &lt;code&gt;i &amp;lt; 3&lt;/code&gt; failing and the loop ending. At this point, &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and so when &lt;code&gt;funcs[someIndex]()&lt;/code&gt; is used, and &lt;code&gt;i&lt;/code&gt; is evaluated, it is 3 - every time.</source>
          <target state="translated">&lt;code&gt;funcs[someIndex]&lt;/code&gt; 가 실행될 때까지 실제로 오류가 발생하지 않습니다 &lt;code&gt;()&lt;/code&gt; . 이 같은 논리를 사용하면이 시점까지 &lt;code&gt;i&lt;/code&gt; 의 값도 수집되지 않습니다. 원래 루프가 완료되면 &lt;code&gt;i++&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 를 &lt;code&gt;3&lt;/code&gt; 의 값으로 가져 오며 &lt;code&gt;i &amp;lt; 3&lt;/code&gt; 실패하고 루프가 종료됩니다. 이 시점에서 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;3&lt;/code&gt; 이므로 &lt;code&gt;funcs[someIndex]()&lt;/code&gt; 를 사용하고 &lt;code&gt;i&lt;/code&gt; 를 평가할 때마다 3입니다.</target>
        </trans-unit>
        <trans-unit id="856ee0f77cb901a2d5f4921b4e1b1fda12a1619c" translate="yes" xml:space="preserve">
          <source>The idea behind this is, encapsulating the entire body of the for loop with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; (Immediately-Invoked Function Expression) and passing &lt;code&gt;new_i&lt;/code&gt; as a parameter and capturing it as &lt;code&gt;i&lt;/code&gt;. Since the anonymous function is executed immediately, the &lt;code&gt;i&lt;/code&gt; value is different for each function defined inside the anonymous function.</source>
          <target state="translated">이에 대한 아이디어는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;IIFE&lt;/a&gt; (즉시 호출 함수 표현식)로 for 루프의 전체 본문을 캡슐화하고 &lt;code&gt;new_i&lt;/code&gt; 를 매개 변수로 전달하고 &lt;code&gt;i&lt;/code&gt; 로 캡처하는 것입니다. 익명 함수는 즉시 실행되므로 익명 함수 내에 정의 된 각 함수마다 &lt;code&gt;i&lt;/code&gt; 값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f1be8f1dfe77f7136b4b98db5a0445bec48d7249" translate="yes" xml:space="preserve">
          <source>The idea is that each invocation of the callback function used with the &lt;code&gt;.forEach&lt;/code&gt; loop will be its own closure. The parameter passed in to that handler is the array element specific to that particular step of the iteration. If it's used in an asynchronous callback, it won't collide with any of the other callbacks established at other steps of the iteration.</source>
          <target state="translated">&lt;code&gt;.forEach&lt;/code&gt; 루프와 함께 사용되는 콜백 함수를 호출 할 때마다 고유 한 클로저가됩니다. 해당 핸들러에 전달 된 매개 변수는 반복의 특정 단계에 고유 한 배열 요소입니다. 비동기 콜백에서 사용되는 경우 반복의 다른 단계에서 설정된 다른 콜백과 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="554e7da9cb27d2c612a6625d286e83984129f98b" translate="yes" xml:space="preserve">
          <source>The main issue with the code shown by the OP is that &lt;code&gt;i&lt;/code&gt; is never read until the second loop. To demonstrate, imagine seeing an error inside of the code</source>
          <target state="translated">OP에 의해 표시된 코드의 주요 문제는 두 번째 루프까지 &lt;code&gt;i&lt;/code&gt; 를 읽지 않는다는 것입니다. 시연하기 위해 코드 내부에 오류가 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="ac7d64ba26be65a9bdda7a473360cd89e1a6bfca" translate="yes" xml:space="preserve">
          <source>The most simple solution would be,</source>
          <target state="translated">가장 간단한 해결책은</target>
        </trans-unit>
        <trans-unit id="ad056b8ebf63fda047c5428d6a688ada28283e8b" translate="yes" xml:space="preserve">
          <source>The reason your original example did not work is that all the closures you created in the loop referenced the same frame. In effect, having 3 methods on one object with only a single &lt;code&gt;i&lt;/code&gt; variable. They all printed out the same value.</source>
          <target state="translated">원래 예제가 작동하지 않은 이유는 루프에서 작성한 모든 클로저가 동일한 프레임을 참조했기 때문입니다. 실제로 하나의 &lt;code&gt;i&lt;/code&gt; 변수 만있는 하나의 객체에 3 개의 메소드가 있습니다. 그들은 모두 같은 값을 인쇄했습니다.</target>
        </trans-unit>
        <trans-unit id="2ad989a69c7aecece4a1ee2beea421081fc0179e" translate="yes" xml:space="preserve">
          <source>The same problem occurs when the delay in running the function is caused by using event listeners:</source>
          <target state="translated">이벤트 리스너를 사용하여 함수 실행 지연이 발생하는 경우에도 동일한 문제점이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="060fca584006f839b664cab15c91a1e82cb22479" translate="yes" xml:space="preserve">
          <source>There is also a let keyword instead of var, that would allow using the block scope rule. In that case defining a variable inside the for would do the trick. That said, the let keyword isn't a practical solution because of compatibility.</source>
          <target state="translated">var 대신 let 키워드가있어 블록 범위 규칙을 사용할 수 있습니다. 이 경우 for 내부에 변수를 정의하면 트릭을 수행합니다. 즉, let 키워드는 호환성 때문에 실용적인 솔루션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="448449d35ae4a06a2d9dfb987eef9bacd22eea0a" translate="yes" xml:space="preserve">
          <source>This also means that inner functions &quot;hold onto&quot; outer variables and keep them alive, even if the outer function returns. To utilize this, we create and call a wrapper function purely to make a new scope, declare &lt;code&gt;ilocal&lt;/code&gt; in the new scope, and return an inner function that uses &lt;code&gt;ilocal&lt;/code&gt; (more explanation below):</source>
          <target state="translated">이는 내부 함수가 외부 변수를 &quot;유지&quot;하여 외부 함수가 리턴 되더라도 계속 유지함을 의미합니다. 이를 활용하기 위해 순전히 래퍼 함수를 ​​만들어 호출하여 새 범위를 만들고 새 범위에서 &lt;code&gt;ilocal&lt;/code&gt; 을 선언 한 다음 ilocal 을 사용하는 내부 함수를 반환합니다 (자세한 내용은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="12de75a0410bd48617dd0ea44ed803a6ca2adf1b" translate="yes" xml:space="preserve">
          <source>This describes the common mistake with using closures in JavaScript.</source>
          <target state="translated">이것은 JavaScript에서 클로저를 사용하는 일반적인 실수를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ae8410f183f820b5d96d27651b33df1df916e1be" translate="yes" xml:space="preserve">
          <source>This is because there is only one copy of &lt;code&gt;obj&lt;/code&gt; shared across all iterations of the loop, perhaps for performance reasons.
Even though &lt;code&gt;{counter: 0}&lt;/code&gt; creates a new object in each iteration, the same copy of &lt;code&gt;obj&lt;/code&gt; will just get updated with a
reference to the newest object.</source>
          <target state="translated">아마도 성능상의 이유로 루프의 모든 반복에서 공유되는 &lt;code&gt;obj&lt;/code&gt; 사본이 하나만 있기 때문입니다. &lt;code&gt;{counter: 0}&lt;/code&gt; 이 각 반복에서 새 객체를 생성하더라도 동일한 &lt;code&gt;obj&lt;/code&gt; 사본이 최신 객체에 대한 참조로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8a4540349f8251832e92d8707899d72ccee1d16c" translate="yes" xml:space="preserve">
          <source>This is exactly why this bug is so tricky. Even though you are redeclaring a variable, Javascript won't throw an error, and JSLint won't even throw a warning. This is also why the best way to solve this is to take advantage of closures, which is essentially the idea that in Javascript, inner functions have access to outer variables because inner scopes &quot;enclose&quot; outer scopes.</source>
          <target state="translated">이것이 바로이 버그가 너무 까다로운 이유입니다. 변수를 다시 선언하더라도 Javascript는 오류를 발생시키지 않으며 JSLint는 경고를 발생시키지 않습니다. 또한이를 해결하는 가장 좋은 방법은 클로저를 활용하는 것입니다. 이는 본질적으로 자바 스크립트에서 내부 범위가 외부 범위를 &quot;포함&quot;하기 때문에 내부 함수가 외부 변수에 액세스 할 수 있다는 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="5b55d617be50854b7689496d73fe6a980d489ff4" translate="yes" xml:space="preserve">
          <source>This is only one of the multiple ways to solve this problem.</source>
          <target state="translated">이것은이 문제를 해결하는 여러 방법 중 하나 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="69dff230b8b191d491a2e7f9b2016da82afd61e2" translate="yes" xml:space="preserve">
          <source>This question really shows the history of JavaScript! Now we can avoid block scoping with arrow functions and handle loops directly from DOM nodes using Object methods.</source>
          <target state="translated">이 질문은 실제로 JavaScript의 역사를 보여줍니다! 이제 화살표 함수로 블록 범위를 피하고 Object 메소드를 사용하여 DOM 노드에서 직접 루프를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d060596a3fb90d867391aebfaa4b523816d6f393" translate="yes" xml:space="preserve">
          <source>This sends the iterator &lt;code&gt;i&lt;/code&gt; into the anonymous function of which we define as &lt;code&gt;index&lt;/code&gt;.  This creates a closure, where the variable &lt;code&gt;i&lt;/code&gt; gets saved for later use in any asynchronous functionality within the IIFE.</source>
          <target state="translated">이것은 iterator &lt;code&gt;i&lt;/code&gt; 를 우리가 &lt;code&gt;index&lt;/code&gt; 로 정의하는 익명 함수로 보냅니다. 이렇게하면 IIFE 내의 비동기 기능에서 나중에 사용하기 위해 변수 &lt;code&gt;i&lt;/code&gt; 가 저장되는 클로저가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="568f52b727645cf73bf4a4ec5cc6047938d24a52" translate="yes" xml:space="preserve">
          <source>This solution seems to fit any such problem since it will require minimal changes to the original code suffering from this issue. In fact, this is by design, it should not be an issue at all!</source>
          <target state="translated">이 솔루션은이 문제로 고통받는 원래 코드를 최소한으로 변경해야하기 때문에 이러한 문제에 적합합니다. 실제로 이것은 의도적으로 설계된 것이므로 전혀 문제가되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="63ead8ff0238da7dad275c58b2be0db34f001961" translate="yes" xml:space="preserve">
          <source>This way, each function will have it's own variable &lt;code&gt;x&lt;/code&gt; and we set this &lt;code&gt;x&lt;/code&gt; to the value of &lt;code&gt;i&lt;/code&gt; in each iteration.</source>
          <target state="translated">이런 식으로, 각 함수는 자신의 변수 &lt;code&gt;x&lt;/code&gt; 를 가질 것이고 우리는이 반복에서 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;i&lt;/code&gt; 의 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ba14827e824873be8ebe61d778cfebbcb83cf379" translate="yes" xml:space="preserve">
          <source>This works because local variables in the function scope directly, as well as function argument variables, are allocated 
new copies upon entry.</source>
          <target state="translated">이는 함수 인수 변수뿐만 아니라 함수 범위의 로컬 변수에도 입력시 새 사본이 할당되기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dc5df1b4ba78c7a8aba9d785a79d7a07889df926" translate="yes" xml:space="preserve">
          <source>To get past this, you must evaluate &lt;code&gt;i&lt;/code&gt; as it is encountered. Note that this has already happened in the form of &lt;code&gt;funcs[i]&lt;/code&gt; (where there are 3 unique indexes). There are several ways to capture this value. One is to pass it in as a parameter to a function which is shown in several ways already here.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;i&lt;/code&gt; 가 발생할 때 i 를 평가해야합니다. 이것은 이미 &lt;code&gt;funcs[i]&lt;/code&gt; (3 개의 고유 인덱스가있는) 형식으로 발생했습니다. 이 값을 캡처하는 방법에는 여러 가지가 있습니다. 하나는 이미 여러 방법으로 표시되는 함수에 매개 변수로 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="9e545c304f2b2af0893d3299d7eeb524e05f8fa5" translate="yes" xml:space="preserve">
          <source>Turns out, that's the issue. Each iteration is sharing the same scope, so every iteration after the first is just overwriting &lt;code&gt;ilocal&lt;/code&gt;. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">그게 문제입니다. 각 반복은 동일한 범위를 공유하므로 첫 번째 이후의 모든 반복은 &lt;code&gt;ilocal&lt;/code&gt; 을 덮어 쓰는 것 입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope&quot;&gt;MDN에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dde2205fa0c208c200d47ab8a2639e821de84aa8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;closure&lt;/a&gt; structure, this would reduce your extra for loop. You can do it in a single for loop:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;클로저&lt;/a&gt; 구조를 사용하면 여분의 for 루프가 줄어 듭니다. 단일 for 루프에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0fb26471bd522c3a6eb4395151f9fa462bd3e4" translate="yes" xml:space="preserve">
          <source>Use let(blocked-scope) instead of var.</source>
          <target state="translated">var 대신 let (blocked-scope)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="02390d462bc4466f4b044a7431c4ace04d0fc8eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; solves this by creating a new scope each time the &lt;code&gt;for&lt;/code&gt; loop runs, creating a separated scope for each function to close over. Various other techniques do the same thing with extra functions.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 대신 &lt;code&gt;let&lt;/code&gt; 을 사용하면 &lt;code&gt;for&lt;/code&gt; 루프가 실행될 때마다 새 범위를 만들고 각 함수에 대해 별도의 범위를 만들어서이 문제를 해결합니다. 다른 여러 가지 기술은 추가 기능을 사용하여 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2e638ddaa7a309550103b73c19dacbc50a4f95be" translate="yes" xml:space="preserve">
          <source>Using a closure in a loop is tricky.</source>
          <target state="translated">루프에서 클로저를 사용하는 것은 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="e58d2a9f67a5c27e888bf7a370ee438bb7cbfe85" translate="yes" xml:space="preserve">
          <source>Using an &lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, the simplest and most readable way to enclose an index variable:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;즉시 호출되는 함수 표현식을&lt;/a&gt; 사용하면 인덱스 변수를 묶는 가장 간단하고 읽기 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="55f01718a62a1826d870465a04e10f4146d32e91" translate="yes" xml:space="preserve">
          <source>We can initialize &lt;code&gt;i&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; or initialize a new variable &lt;code&gt;index&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt; and make it equal to &lt;code&gt;i&lt;/code&gt;. So when the call is being made, &lt;code&gt;index&lt;/code&gt; will be used and its scope will end after initialization. And for calling, &lt;code&gt;index&lt;/code&gt; will be initialized again:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 으로 &lt;code&gt;i&lt;/code&gt; 를 초기화하거나 let 으로 새로운 변수 &lt;code&gt;index&lt;/code&gt; 를 초기화하고 i 와 동일하게 만들 수 있습니다. 따라서 호출이 이루어지면 &lt;code&gt;index&lt;/code&gt; 가 사용되며 초기화 후에 범위가 종료됩니다. 그리고 호출을 위해 &lt;code&gt;index&lt;/code&gt; 가 다시 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="13061d26e5ff9f96a4c74bef2c43e6074905c506" translate="yes" xml:space="preserve">
          <source>We can see this by checking &lt;code&gt;ilocal&lt;/code&gt; before we declare it in each iteration:</source>
          <target state="translated">각 반복에서 선언하기 전에 &lt;code&gt;ilocal&lt;/code&gt; 을 확인하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecacf20dbf2ba01fc16a5963696f4d9f3b309d3a" translate="yes" xml:space="preserve">
          <source>We will check , what actually happens when you declare &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;
  one by one.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 를 선언 &lt;code&gt;let&lt;/code&gt; 하나씩 할 때 실제로 어떤 일이 발생하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="82eaf8efa37e385e9b7152f30bdaadc0bf9ed115" translate="yes" xml:space="preserve">
          <source>Well, the problem is that the variable &lt;code&gt;i&lt;/code&gt;, within each of your anonymous functions, is bound to the same variable outside of the function.</source>
          <target state="translated">문제는 각 익명 함수 내의 변수 &lt;code&gt;i&lt;/code&gt; 가 함수 외부의 동일한 변수에 바인딩되어 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="41eb5e4bb9040aafd86158f33adfb76207526d4e" translate="yes" xml:space="preserve">
          <source>What you need to understand is the scope of the variables in javascript is based on the function. This is an important difference than say c# where you have block scope, and just copying the variable to one inside the for will work.</source>
          <target state="translated">이해해야 할 것은 자바 스크립트의 변수 범위는 함수를 기반으로한다는 것입니다. 이것은 블록 범위가있는 c #보다 중요한 차이점이며 변수를 for 내부에 복사하면 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c86ee44958806285b881b5c6d1c72978293ea3" translate="yes" xml:space="preserve">
          <source>What you want to do is bind the variable within each function to a separate, unchanging value outside of the function:</source>
          <target state="translated">당신이하고 싶은 것은 각 함수 내의 변수를 함수 외부의 변하지 않는 별도의 값에 바인딩하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8eedced39e77d173c59310d3d7130994ae20c1ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the solution to this basic problem?</source>
          <target state="translated">이 기본 문제에 대한 해결책은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6f1a7ec31d6598725ab3a3e62f3cd605ed9af980" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, now the scope chain will be &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt;. This time &lt;code&gt;i&lt;/code&gt; can be found in the outer function's scope which is executed 3 times in the for loop, each time has value &lt;code&gt;i&lt;/code&gt; bound correctly. It won't use the value of &lt;code&gt;window.i&lt;/code&gt; when inner executed.</source>
          <target state="translated">&lt;code&gt;funcs&lt;/code&gt; 가 실행되면 스코프 체인은 inner- &lt;code&gt;function inner -&amp;gt; function outer&lt;/code&gt; 됩니다. 이번에는 for 루프에서 3 번 실행되는 외부 함수 범위에서 찾을 수 있으며 매번 값 &lt;code&gt;i&lt;/code&gt; 가 올바르게 바인딩됩니다. inner가 실행될 때 &lt;code&gt;window.i&lt;/code&gt; 의 값을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="136bf4b99e71d62b188da8ea337423ca7b32ee1a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;funcs&lt;/code&gt; gets executed, the scope chain will be &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt;. Since the variable &lt;code&gt;i&lt;/code&gt; cannot be found in &lt;code&gt;function inner&lt;/code&gt; (neither declared using &lt;code&gt;var&lt;/code&gt; nor passed as arguments), it continues to search, until the value of &lt;code&gt;i&lt;/code&gt; is eventually found in the global scope which is &lt;code&gt;window.i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;funcs&lt;/code&gt; 가 실행되면 범위 체인은 inner- &lt;code&gt;function inner -&amp;gt; global&lt;/code&gt; 입니다. 변수 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;var&lt;/code&gt; &lt;code&gt;function inner&lt;/code&gt; 선언되거나 인수로 전달되지 않은 inner 함수 에서 찾을 수 없으므로 i 의 값이 결국 &lt;code&gt;window.i&lt;/code&gt; 전역 범위에서 발견 될 때까지 계속 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0b6868f0d3df7b445fd72bcfe0420c84dbdc0c32" translate="yes" xml:space="preserve">
          <source>When a function gets executed, the runtime evaluates variables by searching the &lt;strong&gt;scope chain&lt;/strong&gt;. If a variable can be found in a certain point of the chain it will stop searching and use it, otherwise it continues until the global scope reached which belongs to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">함수가 실행될 때 런타임은 &lt;strong&gt;범위 체인&lt;/strong&gt; 을 검색하여 변수를 평가합니다. 체인의 특정 지점에서 변수를 찾을 수 있으면 검색을 중지하고 사용합니다. 그렇지 않으면 전역 범위에 도달 할 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="fdddce5cff579a440ec0f06c1f3a7517de4c89ef" translate="yes" xml:space="preserve">
          <source>When you create the closure, &lt;code&gt;i&lt;/code&gt; is a reference to the variable defined in the outside scope, not a copy of it as it was when you created the closure. It will be evaluated at the time of execution.</source>
          <target state="translated">클로저를 생성 할 때, &lt;code&gt;i&lt;/code&gt; 는 클로저를 생성 할 때와 같이 복사본이 아닌 외부 범위에 정의 된 변수에 대한 참조입니다. 실행 시점에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c32d98513496eff571f807348f60d6eb70fa8459" translate="yes" xml:space="preserve">
          <source>When you declare a variable using &lt;code&gt;'var'&lt;/code&gt; outside a function ,it becomes global variable(you can check by typing &lt;code&gt;i&lt;/code&gt; or 
&lt;code&gt;window.i&lt;/code&gt; in console window.It will return 3).</source>
          <target state="translated">함수 외부에서 &lt;code&gt;'var'&lt;/code&gt; 을 사용하여 변수를 선언하면 전역 변수가됩니다 (콘솔 &lt;code&gt;window.i&lt;/code&gt; 에서 &lt;code&gt;i&lt;/code&gt; 또는 window.i 를 입력하여 확인할 수 있습니다. 3을 반환합니다).</target>
        </trans-unit>
        <trans-unit id="0700c840cf9074a17d6a57a019478e06397f4b95" translate="yes" xml:space="preserve">
          <source>When you declare variable using &lt;code&gt;'let'&lt;/code&gt; even outside the function but inside the loop , this variable will not be a Global 
variable , it will become a &lt;code&gt;Block&lt;/code&gt; level variable which is only available for the same function only.That is the reason , we 
are getting value of &lt;code&gt;i&lt;/code&gt; different for each function when we invoke the functions.</source>
          <target state="translated">함수 외부에서도 루프 내부에서 &lt;code&gt;'let'&lt;/code&gt; 을 사용하여 변수를 선언하면이 변수는 전역 변수가 아니며 동일한 함수에서만 사용할 수있는 &lt;code&gt;Block&lt;/code&gt; 수준 변수가됩니다. 그 이유는 다음과 같습니다. 함수를 호출 할 때 각 함수마다 다른 &lt;code&gt;i&lt;/code&gt; 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9315dce1f25ea4c4ba2729e3d74db8c96a980595" translate="yes" xml:space="preserve">
          <source>When you invoke the function , &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; takes the value from its &lt;code&gt;Global&lt;/code&gt; object and display the 
result.</source>
          <target state="translated">함수를 호출하면 &lt;code&gt;console.log(&quot;My value: &quot; + i)&lt;/code&gt; 는 &lt;code&gt;Global&lt;/code&gt; 객체에서 값을 가져와 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a04cb324afc79fff8ebd9cd463d1cacdf8ff5c49" translate="yes" xml:space="preserve">
          <source>Whereas I'd like it to output:</source>
          <target state="translated">반면 출력을 원합니다.</target>
        </trans-unit>
        <trans-unit id="c125d7c3843c2a8edd798658a1c8b7142f2e0175" translate="yes" xml:space="preserve">
          <source>With ES6 now mainstream, we can now use the new &lt;code&gt;let&lt;/code&gt; keyword to create block-scoped variables:</source>
          <target state="translated">ES6이 이제 주류가되었으므로 새로운 &lt;code&gt;let&lt;/code&gt; 키워드를 사용하여 블록 범위 변수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06647b92e9f39b50b8b5c9c9165cbfd5329f2810" translate="yes" xml:space="preserve">
          <source>With ES6 now widely supported, the best answer to this question has changed.  ES6 provides the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords for this exact circumstance.  Instead of messing around with closures, we can just use &lt;code&gt;let&lt;/code&gt; to set a loop scope variable like this:</source>
          <target state="translated">ES6가 널리 지원되면서이 질문에 대한 최상의 답변이 변경되었습니다. ES6는이 정확한 상황에 대한 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 키워드를 제공합니다. 클로저를 어지럽히 지 &lt;code&gt;let&lt;/code&gt; 을 사용하여 다음과 같이 루프 범위 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bccb870c0505ba1198c8bd20fb323ffcaa0eec55" translate="yes" xml:space="preserve">
          <source>With new features of ES6 block level scoping is managed:</source>
          <target state="translated">ES6의 새로운 기능으로 블록 레벨 범위가 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="3f61a03573e1881b334382ba87fe17f8963f8f85" translate="yes" xml:space="preserve">
          <source>With the relatively widespread availability of the &lt;code&gt;Array.prototype.forEach&lt;/code&gt; function (in 2015), it's worth noting that in those situations involving iteration primarily over an array of values, &lt;code&gt;.forEach()&lt;/code&gt; provides a clean, natural way to get a distinct closure for every iteration. That is, assuming you've got some sort of array containing values (DOM references, objects, whatever), and the problem arises of setting up callbacks specific to each element, you can do this:</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach&lt;/code&gt; 함수 (2015 년)의 상대적으로 널리 사용되는 경우, &lt;code&gt;.forEach()&lt;/code&gt; 는 주로 값 배열에 대한 반복이 관련된 상황에서 .forEach () 가 명확하고 자연스러운 방법을 제공합니다. 모든 반복. 즉, 값 (DOM 참조, 객체 등)을 포함하는 일종의 배열이 있고 각 요소에 특정한 콜백을 설정하는 데 문제가 있다고 가정하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbb288fca9f8548f939b37452aa20bfc52aa22a" translate="yes" xml:space="preserve">
          <source>Wrapping it in a function that evaluates returning the function like apphacker's answer will do the trick, as the variable now has the function scope.</source>
          <target state="translated">변수에 함수 범위가 있으므로 apphacker의 답변과 같은 함수 반환을 평가하는 함수로 그것을 감싸는 것은 트릭을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5a12c8a80e49d75e10abdc201b4e47c6ffdad1fc" translate="yes" xml:space="preserve">
          <source>You could then use your second loop and get the expected result or you could do</source>
          <target state="translated">그런 다음 두 번째 루프를 사용하여 예상 결과를 얻거나 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3b66d71de3296a4d256ccc09d82d040d2cdb4f8" translate="yes" xml:space="preserve">
          <source>You could use a declarative module for lists of data such as &lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt;(*). In these situations I personally find a declarative approach less surprising</source>
          <target state="translated">&lt;a href=&quot;https://github.com/runefs/query-js&quot;&gt;query-js&lt;/a&gt; (*)와 같은 데이터 목록에 선언적 모듈을 사용할 수 있습니다. 이러한 상황에서 나는 개인적으로 선언적 접근 방식이 덜 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="ae314c4eceee085891b4c457750851f14dd5d46f" translate="yes" xml:space="preserve">
          <source>You need to understand that, in time when your functions are created, none of their code is executed, it is only saved for later. And so when they are called later, the interpreter executes them and asks: &quot;What is the current value of &lt;code&gt;i&lt;/code&gt;?&quot;</source>
          <target state="translated">함수가 생성 될 때 코드가 실행되지 않으면 나중에 저장하기 만한다는 것을 이해해야합니다. 그리고 나중에 호출 될 때 인터프리터는이를 실행하고 &quot; &lt;code&gt;i&lt;/code&gt; 의 현재 값은 무엇입니까?&quot;라고 묻습니다.</target>
        </trans-unit>
        <trans-unit id="4002c68c62355c5ff649328699085ae7df82a379" translate="yes" xml:space="preserve">
          <source>Your code doesn't work, because what it does is:</source>
          <target state="translated">코드가 작동하지 않는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b42f3f6f796fa3cfcb6b1b8d49c7bcccc3a7164c" translate="yes" xml:space="preserve">
          <source>const</source>
          <target state="translated">const</target>
        </trans-unit>
        <trans-unit id="0262f9bb6ecbef4efbae97193c08ec335698a205" translate="yes" xml:space="preserve">
          <source>let</source>
          <target state="translated">let</target>
        </trans-unit>
        <trans-unit id="047a45ccf14f791a4c2261e7921f98e1170c10cc" translate="yes" xml:space="preserve">
          <source>no array</source>
          <target state="translated">배열 없음</target>
        </trans-unit>
        <trans-unit id="90aa229371a8bfd35bc600335c626fdfc9e82632" translate="yes" xml:space="preserve">
          <source>no extra for loop</source>
          <target state="translated">추가 for 루프 없음</target>
        </trans-unit>
        <trans-unit id="fd20c34806b69001e12b7c2055620cd556c5b03f" translate="yes" xml:space="preserve">
          <source>try this shorter one</source>
          <target state="translated">이 짧은 시도</target>
        </trans-unit>
        <trans-unit id="a0d8045ff0e1110c300c0605fa5a3d0a54a9a9dc" translate="yes" xml:space="preserve">
          <source>which alerts &quot;2&quot;, for 3 times. This is because anonymous functions created in for loop, shares same closure, and in that closure, the value of &lt;code&gt;i&lt;/code&gt; is the same. Use this to prevent shared closure:</source>
          <target state="translated">&quot;2&quot;를 3 번 ​​경고합니다. 이는 for 루프에서 생성 된 익명 함수가 동일한 클로저를 공유하며 해당 클로저에서 &lt;code&gt;i&lt;/code&gt; 의 값이 동일하기 때문입니다. 공유 폐쇄를 방지하려면 다음을 사용하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
