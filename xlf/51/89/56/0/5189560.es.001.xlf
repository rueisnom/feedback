<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/5189560">
    <body>
      <group id="5189560">
        <trans-unit id="0f6e71b1a03ea4118f8aca590d18524c56b24e91" translate="yes" xml:space="preserve">
          <source>(in this case, squash the two last commits)</source>
          <target state="translated">(en este caso,aplastar los dos últimos compromisos)</target>
        </trans-unit>
        <trans-unit id="00a75dfc6a363821c165dda8663912f8b12308bb" translate="yes" xml:space="preserve">
          <source>... Which automatically squashes together the last &lt;code&gt;N&lt;/code&gt; commits, inclusive.</source>
          <target state="translated">... Que aplasta autom&amp;aacute;ticamente las &amp;uacute;ltimas &lt;code&gt;N&lt;/code&gt; confirmaciones, inclusive.</target>
        </trans-unit>
        <trans-unit id="e912fb518c6c899659dd36fc58ca72800c398da1" translate="yes" xml:space="preserve">
          <source>... or using Windows' Command Prompt:</source>
          <target state="translated">...o usando el símbolo de comando de Windows:</target>
        </trans-unit>
        <trans-unit id="f9868bd7af9ea1a05d5a2cc3db7e9e630cb95cb1" translate="yes" xml:space="preserve">
          <source>1) Identify the commit short hash</source>
          <target state="translated">1)Identificar el hachís corto de la comisión</target>
        </trans-unit>
        <trans-unit id="a266d1bf09d724f5e01d17ae11e07a3b904343ee" translate="yes" xml:space="preserve">
          <source>1) git reset --soft HEAD~2 &amp;amp;&amp;amp; git commit -m&quot;&lt;strong&gt;message&lt;/strong&gt;&quot;</source>
          <target state="translated">1) git reset --soft HEAD ~ 2 &amp;amp;&amp;amp; git commit -m &quot; &lt;strong&gt;mensaje&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="31bac7a25e633d602c5f07d013cf5bad6b5c8e6d" translate="yes" xml:space="preserve">
          <source>2) If you want to squash (merge) last two commit</source>
          <target state="translated">2)Si quieres aplastar (fusionar)los dos últimos,hazlo.</target>
        </trans-unit>
        <trans-unit id="cbd711953c1351ee6a5326f8709d2fa00a65e56d" translate="yes" xml:space="preserve">
          <source>2) git push</source>
          <target state="translated">2)empujar el git</target>
        </trans-unit>
        <trans-unit id="ea65c50e6ab609f46f3b9dff142c828dcb7a2b4c" translate="yes" xml:space="preserve">
          <source>3) This opens up a &lt;code&gt;nano&lt;/code&gt; editor for merging. And it looks like below</source>
          <target state="translated">3) Esto abre un editor &lt;code&gt;nano&lt;/code&gt; para fusionar. Y se ve a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="78b84c9eba8b454d71ff15e78d7b205c76275eca" translate="yes" xml:space="preserve">
          <source>4) Rename the word &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; which is present before &lt;code&gt;abcd1234&lt;/code&gt;. After rename it should be like below.</source>
          <target state="translated">4) Cambie el nombre de la palabra &lt;code&gt;pick&lt;/code&gt; a &lt;code&gt;squash&lt;/code&gt; que est&amp;aacute; presente antes de &lt;code&gt;abcd1234&lt;/code&gt; . Despu&amp;eacute;s de cambiar el nombre, deber&amp;iacute;a ser como a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="71b14741158ee8ef04c0060e1f8a21f8fb3b1e25" translate="yes" xml:space="preserve">
          <source>5) Now save and close the &lt;code&gt;nano&lt;/code&gt; editor. Press &lt;code&gt;ctrl + o&lt;/code&gt; and press &lt;code&gt;Enter&lt;/code&gt; to save. And then press &lt;code&gt;ctrl + x&lt;/code&gt; to exit the editor.</source>
          <target state="translated">5) Ahora guarde y cierre el &lt;code&gt;nano&lt;/code&gt; editor. Presione &lt;code&gt;ctrl + o&lt;/code&gt; y presione &lt;code&gt;Enter&lt;/code&gt; para guardar. Y luego presione &lt;code&gt;ctrl + x&lt;/code&gt; para salir del editor.</target>
        </trans-unit>
        <trans-unit id="85cf74b710242b910482c040916448edae877361" translate="yes" xml:space="preserve">
          <source>6) Then &lt;code&gt;nano&lt;/code&gt; editor again opens for updating comments, if necessary update it.</source>
          <target state="translated">6) Luego, &lt;code&gt;nano&lt;/code&gt; editor se abre nuevamente para actualizar los comentarios, si es necesario, actual&amp;iacute;celo.</target>
        </trans-unit>
        <trans-unit id="dfc29b1eb351d0fcd6446b260cefa0750b92fd58" translate="yes" xml:space="preserve">
          <source>7) Now its squashed successfully, you can verify it by checking logs.</source>
          <target state="translated">7)Ahora que ha sido aplastado con éxito,puedes verificarlo comprobando los registros.</target>
        </trans-unit>
        <trans-unit id="0534fb54df6a2793525c086550d32e11a5d6cdf6" translate="yes" xml:space="preserve">
          <source>8) Now push to repo. Note to add &lt;code&gt;+&lt;/code&gt; sign before the branch name. This means forced push.</source>
          <target state="translated">8) Ahora presiona para repo. Nota para agregar &lt;code&gt;+&lt;/code&gt; signo antes del nombre de la sucursal. Esto significa empuje forzado.</target>
        </trans-unit>
        <trans-unit id="060566f0626a9c056933505d6f6cf04d52e947e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;Anomies answer&lt;/a&gt; is good, but I felt insecure about this so I decided to add a couple of screenshots.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;La respuesta de Anomies&lt;/a&gt; es buena, pero me sent&amp;iacute; insegura al respecto, as&amp;iacute; que decid&amp;iacute; agregar un par de capturas de pantalla.</target>
        </trans-unit>
        <trans-unit id="0aa246496b4e1fd607eb4727df2b1c6b2fd5d5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt;  // puts all changes in stage</source>
          <target state="translated">&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt; // pone todos los cambios en el escenario</target>
        </trans-unit>
        <trans-unit id="7055a5977843ebb56fc6cf1a7433d6529c41d611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; , where N is the number of commits I want to join, &lt;em&gt;starting from the most recent one&lt;/em&gt;. So &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; would mean &quot;squash the last 5 commits into a new one&quot;;</source>
          <target state="translated">&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; , donde N es el n&amp;uacute;mero de confirmaciones que quiero unir, &lt;em&gt;comenzando por la m&amp;aacute;s reciente&lt;/em&gt; . Entonces &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; significar&amp;iacute;a &quot;aplastar los &amp;uacute;ltimos 5 commits en uno nuevo&quot;;</target>
        </trans-unit>
        <trans-unit id="4f4ea95712f9097dba8f82df029c2063fe45d6db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; the only real advantage of this method over the simpler &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; suggested by Chris Johnsen in &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;his answer&lt;/a&gt; is that you get the commit message prepopulated with every commit message that you're squashing.</source>
          <target state="translated">&lt;em&gt;Actualizaci&amp;oacute;n:&lt;/em&gt; la &amp;uacute;nica ventaja real de este m&amp;eacute;todo sobre el simple &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; sugerido por Chris Johnsen en &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;su respuesta&lt;/a&gt; es que obtiene el mensaje de confirmaci&amp;oacute;n rellenado previamente con cada mensaje de confirmaci&amp;oacute;n que est&amp;aacute; aplastando.</target>
        </trans-unit>
        <trans-unit id="7bc1abce6232c8b6c9b96cbc89e3473e9d63b768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A practical everyday example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Un pr&amp;aacute;ctico ejemplo cotidiano.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68214ab4e4aca49ed9688ab7ba5060c6d11a94f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the interactive rebase editor:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usando el editor de rebase interactivo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab98be530e6bee8cd013851490d34d6048cd6904" translate="yes" xml:space="preserve">
          <source>Add Christine Perfect</source>
          <target state="translated">Añade a Christine Perfect</target>
        </trans-unit>
        <trans-unit id="bfb4f0dc3070ad453043d38a7fd9f425d739332c" translate="yes" xml:space="preserve">
          <source>Add Danny Kirwan</source>
          <target state="translated">Añade a Danny Kirwan</target>
        </trans-unit>
        <trans-unit id="7aa7c343556333bbf1afb97214bb9452da86a2bf" translate="yes" xml:space="preserve">
          <source>Add a global &quot;squash&quot; alias from bash: (or Git Bash on Windows)</source>
          <target state="translated">Añade un alias global de &quot;squash&quot; de Bash:(o Git Bash en Windows)</target>
        </trans-unit>
        <trans-unit id="b1b79d483720ae24eec3e5adbd6ca57ec881cd82" translate="yes" xml:space="preserve">
          <source>Advantage of 1st procedure is to squash multiple commits and to reorder. But this procedure will be difficult if we need to merge a fix to very old commit.</source>
          <target state="translated">La ventaja del primer procedimiento es aplastar múltiples compromisos y reordenar.Pero este procedimiento será difícil si necesitamos fusionar un arreglo de un compromiso muy antiguo.</target>
        </trans-unit>
        <trans-unit id="7868a386b46b1e0c5a783fd920cb3a86a91ca21b" translate="yes" xml:space="preserve">
          <source>After rebase will finish you can choose message for squashed H0 and B0:</source>
          <target state="translated">Después de que la base termine,puedes elegir el mensaje para H0 y B0 aplastados:</target>
        </trans-unit>
        <trans-unit id="48786ade9458227291ecdfcbc328a0b9a48bba9c" translate="yes" xml:space="preserve">
          <source>After save and exit rebase will apply commits in turn after H1. That means that it will ask you to resolve conflicts again (where HEAD will be H1 at first and then accumulating commits as they are applied).</source>
          <target state="translated">Después de guardar y salir de la base se aplicarán las confirmaciones por turnos después de la H1.Eso significa que te pedirá que resuelvas los conflictos de nuevo (donde HEAD será H1 al principio y luego acumulará las confirmaciones a medida que se apliquen).</target>
        </trans-unit>
        <trans-unit id="b90a4b8a8c8bb781c2de8719251307f780e35ad0" translate="yes" xml:space="preserve">
          <source>And what happens? You just made single commit that get from Fritz to Bill Clinton. Because you forgot that yesterday you were working on the Buckingham Nicks version of this project. And &lt;code&gt;git log&lt;/code&gt; doesn't match what you see on GitHub.</source>
          <target state="translated">&amp;iquest;Y que pasa? Acabas de hacer un solo compromiso que pasa de Fritz a Bill Clinton. Porque olvidaste que ayer estabas trabajando en la versi&amp;oacute;n de Buckingham Nicks de este proyecto. Y &lt;code&gt;git log&lt;/code&gt; no coincide con lo que ves en GitHub.</target>
        </trans-unit>
        <trans-unit id="093e99d3dbc1e1d8c95fe7ba70003dcb67751c12" translate="yes" xml:space="preserve">
          <source>As the commit on line 1 is &lt;code&gt;HEAD&lt;/code&gt;, in most cases you would leave this as &lt;code&gt;pick&lt;/code&gt;. 
 You cannot use &lt;code&gt;squash&lt;/code&gt; or &lt;code&gt;fixup&lt;/code&gt; as there is no other commit to squash the commit into.</source>
          <target state="translated">Como el commit en la l&amp;iacute;nea 1 es &lt;code&gt;HEAD&lt;/code&gt; , en la mayor&amp;iacute;a de los casos lo dejar&amp;iacute;a como &lt;code&gt;pick&lt;/code&gt; . No puede usar &lt;code&gt;squash&lt;/code&gt; o &lt;code&gt;fixup&lt;/code&gt; ya que no hay otro commit para aplastar el commit.</target>
        </trans-unit>
        <trans-unit id="3b41b6bdffa611514466e9905a87e0b849f5fdea" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;this article&lt;/a&gt; I found this method easier for my usecase.</source>
          <target state="translated">Basado en &lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;este art&amp;iacute;culo&lt;/a&gt; , encontr&amp;eacute; este m&amp;eacute;todo m&amp;aacute;s f&amp;aacute;cil para mi caso de uso.</target>
        </trans-unit>
        <trans-unit id="e29ab6f60ee8c7e67c1f6b510f26b71c099d14d4" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;Chris Johnsen's answer&lt;/a&gt;,</source>
          <target state="translated">Seg&amp;uacute;n &lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;la respuesta de Chris Johnsen&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a1a2639cbe33c22eb5dbb88182e215a85ff59b4" translate="yes" xml:space="preserve">
          <source>Bill Clinton</source>
          <target state="translated">Bill Clinton</target>
        </trans-unit>
        <trans-unit id="e91185e515d9c1ad67ebd9560c54d10d75f7605a" translate="yes" xml:space="preserve">
          <source>Both of those methods squash the last three commits into a single new commit in the same way. The soft reset just re-points HEAD to the last commit that you do not want to squash. Neither the index nor the working tree are touched by the soft reset, leaving the index in the desired state for your new commit (i.e. it already has all the changes from the commits that you are about to &amp;ldquo;throw away&amp;rdquo;).</source>
          <target state="translated">Ambos m&amp;eacute;todos aplastan los &amp;uacute;ltimos tres commits en un solo nuevo commit de la misma manera. El restablecimiento parcial solo vuelve a apuntar HEAD a la &amp;uacute;ltima confirmaci&amp;oacute;n que no desea aplastar. Ni el &amp;iacute;ndice ni el &amp;aacute;rbol de trabajo son tocados por el reinicio suave, dejando el &amp;iacute;ndice en el estado deseado para su nueva confirmaci&amp;oacute;n (es decir, ya tiene todos los cambios de las confirmaciones que est&amp;aacute; a punto de &quot;desechar&quot;).</target>
        </trans-unit>
        <trans-unit id="11d466714aac7655883761ed97c5295c4bfdafbb" translate="yes" xml:space="preserve">
          <source>Check out the target branch (e.g. 'master')</source>
          <target state="translated">Revisa la rama del objetivo (por ejemplo,&quot;maestro&quot;)</target>
        </trans-unit>
        <trans-unit id="4fc0c1dfdb777b642cb8be476d33324610a18450" translate="yes" xml:space="preserve">
          <source>Checkout the golden repo</source>
          <target state="translated">Revisa el repo dorado</target>
        </trans-unit>
        <trans-unit id="828d4675ea69be7bbbd51d39ea75d7e2c353989c" translate="yes" xml:space="preserve">
          <source>Commit your changes (this will be the only commit that goes in dev-branch)</source>
          <target state="translated">Comprometer sus cambios (este será el único compromiso que va en dev-branch)</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="8affcece617012629577cf8bfabbbc0cbdccf5e6" translate="yes" xml:space="preserve">
          <source>Create a new branch from it(golden repo) as follows</source>
          <target state="translated">Crear una nueva rama a partir de ella (repo de oro)de la siguiente manera</target>
        </trans-unit>
        <trans-unit id="51a53ea31f4f996d5387d6d4244348d9a9522bfe" translate="yes" xml:space="preserve">
          <source>Execute &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;&lt;code&gt;git rebase -i [your hash]&lt;/code&gt;&lt;/a&gt;, in my case:</source>
          <target state="translated">Ejecute &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt; &lt;code&gt;git rebase -i [your hash]&lt;/code&gt; &lt;/a&gt; , en mi caso:</target>
        </trans-unit>
        <trans-unit id="ac8b133f58886974b11bc6af37c28baf4d4c4593" translate="yes" xml:space="preserve">
          <source>Find the commit hash you want to squash on top of, say &lt;code&gt;d43e15&lt;/code&gt;.</source>
          <target state="translated">Encuentre el hash de confirmaci&amp;oacute;n que desea aplastar, por ejemplo &lt;code&gt;d43e15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fe861b00c32729b8570a41dd960986992c8977" translate="yes" xml:space="preserve">
          <source>Find the exact files you want to get &lt;em&gt;to&lt;/em&gt;, and &lt;code&gt;git checkout&lt;/code&gt; them</source>
          <target state="translated">Encuentra los archivos exactos a los que deseas acceder y &lt;code&gt;git checkout&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="513ddb206d72ddd403d65e37a963ba3c61af9ca1" translate="yes" xml:space="preserve">
          <source>Find the exact prior commit you want to keep in history, and &lt;code&gt;git reset --soft&lt;/code&gt; that</source>
          <target state="translated">Encuentre el compromiso previo exacto que desea mantener en el historial y &lt;code&gt;git reset --soft&lt;/code&gt; que</target>
        </trans-unit>
        <trans-unit id="cbff6a6b4ceaa070a2583eb67ba786884ec2dce3" translate="yes" xml:space="preserve">
          <source>First I find out the number of commits between my feature branch and current master branch by</source>
          <target state="translated">Primero averiguo el número de confirmaciones entre mi rama principal y la rama principal actual por</target>
        </trans-unit>
        <trans-unit id="b17781596baa10e42e5d27e04c27b98e980cac0e" translate="yes" xml:space="preserve">
          <source>First add the required files for commit</source>
          <target state="translated">Primero agregue los archivos necesarios para la confirmación</target>
        </trans-unit>
        <trans-unit id="e3a67cef2cd706c75ce38bcabf3f0ff9e944ae90" translate="yes" xml:space="preserve">
          <source>For details click on the &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;Link&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">Para m&amp;aacute;s detalles, haga clic en el &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;enlace&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af1603c24d4db6e43caf6f4bf93db855e59a5472" translate="yes" xml:space="preserve">
          <source>For example, if you are looking to merge all the commits into one, the 'pick' is the first commit you made and all future ones (placed below the first) should be set to 'squash'. If using vim, use &lt;strong&gt;:x&lt;/strong&gt; in insert mode to save and exit the editor.</source>
          <target state="translated">Por ejemplo, si est&amp;aacute; buscando fusionar todos los commits en uno, el 'pick' es el primer commit que realiz&amp;oacute; y todos los futuros (colocados debajo del primero) deben establecerse en 'squash'. Si usa vim, use &lt;strong&gt;: x&lt;/strong&gt; en modo de inserci&amp;oacute;n para guardar y salir del editor.</target>
        </trans-unit>
        <trans-unit id="e5634b5e021244ee271ad922152ae052ceecc536" translate="yes" xml:space="preserve">
          <source>For more on this and other ways to rewrite your commit history see &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;this helpful post&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta y otras formas de reescribir su historial de confirmaci&amp;oacute;n, consulte &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;esta publicaci&amp;oacute;n &amp;uacute;til&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc8b719f20cf72ebfb1459a1756eda92bcc9e219" translate="yes" xml:space="preserve">
          <source>Four commits:</source>
          <target state="translated">Cuatro compromisos:</target>
        </trans-unit>
        <trans-unit id="0ff5edf7ba7c13b10c729d9325013204a570385b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;^&lt;/code&gt; means the previous commit to &lt;code&gt;OLDCOMMIT&lt;/code&gt;. This &lt;code&gt;rebase&lt;/code&gt; command opens interactive window on a editor (vim or nano) on that
we no need to do anything just save and exiting is sufficient. Because the option passed to this will automatically move the latest
commit to next to old commit and change the operation to &lt;code&gt;fixup&lt;/code&gt; (equivalent to squash). Then rebase continues and finishes.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;^&lt;/code&gt; significa el commit anterior a &lt;code&gt;OLDCOMMIT&lt;/code&gt; . Este comando &lt;code&gt;rebase&lt;/code&gt; abre una ventana interactiva en un editor (vim o nano) en el que no necesitamos hacer nada, solo guardar y salir es suficiente. Debido a que la opci&amp;oacute;n pasada a esto mover&amp;aacute; autom&amp;aacute;ticamente la &amp;uacute;ltima confirmaci&amp;oacute;n al lado de la confirmaci&amp;oacute;n anterior y cambiar&amp;aacute; la operaci&amp;oacute;n a &lt;code&gt;fixup&lt;/code&gt; (equivalente a squash). Entonces rebase contin&amp;uacute;a y termina.</target>
        </trans-unit>
        <trans-unit id="1ab294f6db6b416c34905212bef55947aeddd00a" translate="yes" xml:space="preserve">
          <source>Here even &lt;code&gt;git log --oneline&lt;/code&gt; also can be used to get short hash.</source>
          <target state="translated">Aqu&amp;iacute; incluso &lt;code&gt;git log --oneline&lt;/code&gt; tambi&amp;eacute;n se puede usar para obtener hash corto.</target>
        </trans-unit>
        <trans-unit id="abfc9c95a5a36468169f0e59eed3b53351764f57" translate="yes" xml:space="preserve">
          <source>Hope it helps, thanks.</source>
          <target state="translated">Espero que ayude,gracias.</target>
        </trans-unit>
        <trans-unit id="e9acce96a379cc84dadce50a2a0d0c8a84bd8163" translate="yes" xml:space="preserve">
          <source>How can I squash my last X commits together into one commit using Git?</source>
          <target state="translated">¿Cómo puedo aplastar mis últimos X compromisos en un solo compromiso usando Git?</target>
        </trans-unit>
        <trans-unit id="b3aa1fa40cb10cce596ab2f6735206a7a54e21a1" translate="yes" xml:space="preserve">
          <source>How many commits u need to merge, u need to give next that HEAD(like this HEAD~2)</source>
          <target state="translated">¿Cuántos compromisos necesitas para fusionarte,necesitas dar a continuación esa CABEZA (como esta CABEZA~2)</target>
        </trans-unit>
        <trans-unit id="01e83eedbee0bac8113da661371c9e862faa5901" translate="yes" xml:space="preserve">
          <source>I find a more generic solution is not to specify 'N' commits, but rather the branch/commit-id you want to squash on top of.  This is less error-prone than counting the commits up to a specific commit&amp;mdash;just specify the tag directly, or if you really want to count you can specify HEAD~N.</source>
          <target state="translated">Creo que una soluci&amp;oacute;n m&amp;aacute;s gen&amp;eacute;rica no es especificar confirmaciones 'N', sino m&amp;aacute;s bien la rama / commit-id que desea aplastar. Esto es menos propenso a errores que contar las confirmaciones hasta una confirmaci&amp;oacute;n espec&amp;iacute;fica: solo especifique la etiqueta directamente, o si realmente desea contar puede especificar HEAD ~ N.</target>
        </trans-unit>
        <trans-unit id="15f7cd9bd7d23b350c09940eb410992e9fe3d486" translate="yes" xml:space="preserve">
          <source>I haven't seen a workflow like that on this page. (That may be my eyes.) If I understand &lt;code&gt;rebase&lt;/code&gt; correctly, multiple merges would require &lt;strong&gt;multiple conflict resolutions&lt;/strong&gt;. I do NOT want even to think about that!</source>
          <target state="translated">No he visto un flujo de trabajo como ese en esta p&amp;aacute;gina. (Esos pueden ser mis ojos). Si entiendo correctamente el &lt;code&gt;rebase&lt;/code&gt; , m&amp;uacute;ltiples fusiones requerir&amp;iacute;an &lt;strong&gt;m&amp;uacute;ltiples resoluciones de conflictos&lt;/strong&gt; . &amp;iexcl;NO quiero ni siquiera pensar en eso!</target>
        </trans-unit>
        <trans-unit id="b87f73f2e8db36e6d71fb06157044e936572698f" translate="yes" xml:space="preserve">
          <source>I prefer to use the command &lt;code&gt;fixup&lt;/code&gt; as this &quot;squashes&quot; the commit's changes into the commit on the line above and discards the commit's message.</source>
          <target state="translated">Prefiero usar la &lt;code&gt;fixup&lt;/code&gt; del comando ya que esto &quot;aplasta&quot; los cambios del commit en el commit en la l&amp;iacute;nea de arriba y descarta el mensaje del commit.</target>
        </trans-unit>
        <trans-unit id="11f555b9e44717e3b66217f13f903c4371b5dda4" translate="yes" xml:space="preserve">
          <source>I recommend avoiding &lt;code&gt;git reset&lt;/code&gt; when possible -- especially for Git-novices.  Unless you really need to automate a process based on a &lt;em&gt;number&lt;/em&gt; of commits, there is a less exotic way...</source>
          <target state="translated">Recomiendo evitar &lt;code&gt;git reset&lt;/code&gt; cuando sea posible, especialmente para los principiantes de Git. A menos que realmente necesite automatizar un proceso basado en una &lt;em&gt;serie&lt;/em&gt; de confirmaciones, hay una forma menos ex&amp;oacute;tica ...</target>
        </trans-unit>
        <trans-unit id="3dca227ddd161112834d5cf5d8d8bf15553d4ddf" translate="yes" xml:space="preserve">
          <source>I then run &lt;code&gt;git log&lt;/code&gt; or &lt;code&gt;gitk&lt;/code&gt; and get the commit SHA of the new feature (in this case &lt;code&gt;1ff9460&lt;/code&gt;).</source>
          <target state="translated">Luego ejecuto &lt;code&gt;git log&lt;/code&gt; o &lt;code&gt;gitk&lt;/code&gt; y obtengo el SHA de confirmaci&amp;oacute;n de la nueva caracter&amp;iacute;stica (en este caso &lt;code&gt;1ff9460&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9bc0e663b42f4c03fed1ae440e72de7476b8085f" translate="yes" xml:space="preserve">
          <source>I think the easiest way to do this is by making a new branch off of master and doing a merge --squash of the feature branch.</source>
          <target state="translated">Creo que la forma más fácil de hacerlo es haciendo una nueva rama del maestro y haciendo una fusión...</target>
        </trans-unit>
        <trans-unit id="c58228448370201426a2ca0267ec9560383413e8" translate="yes" xml:space="preserve">
          <source>I use the alias:</source>
          <target state="translated">Uso el alias:</target>
        </trans-unit>
        <trans-unit id="86001cc8c4eed6dfdd49e895d88ca2295d3b8afd" translate="yes" xml:space="preserve">
          <source>I wanted to squash these commits into one before pushing the change. I prefere to reset the branch to the state of 'origin/dev' (this will leave all changes from the 96 commits unstaged) and then commit the changes at once:</source>
          <target state="translated">Quería aplastar estos compromisos en uno antes de empujar el cambio.Prefiero reajustar la rama al estado &quot;origindev&quot; (esto dejará todos los cambios de las 96 confirmaciones sin preparar)y luego confirmar los cambios de una vez:</target>
        </trans-unit>
        <trans-unit id="3ef5f47215cc877254b4c604b64a56fd37c0c5dd" translate="yes" xml:space="preserve">
          <source>I'd probably do what &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair suggested&lt;/a&gt;, though.</source>
          <target state="translated">Sin embargo, probablemente har&amp;iacute;a lo que &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair me sugiri&amp;oacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1dbb1610551849ad4b8eb20bae4c982b7e33d6" translate="yes" xml:space="preserve">
          <source>I've recently committed a new feature.  Since then, I have committed two bug fixes.  But now I have discovered a bug (or maybe just a spelling error) in the new feature I committed.  How annoying!  I don't want a new commit polluting my commit history!</source>
          <target state="translated">Recientemente he comprometido una nueva característica.Desde entonces,he cometido dos correcciones de errores.Pero ahora he descubierto un error (o tal vez sólo un error ortográfico)en la nueva característica que he cometido.Qué fastidio! No quiero que una nueva confirmación contamine mi historial de confirmaciones!</target>
        </trans-unit>
        <trans-unit id="600ba8b07c35f3aa98f10bd9215d0c431e3ac6f8" translate="yes" xml:space="preserve">
          <source>If you also want to update the remote branch with the squashed commit:</source>
          <target state="translated">Si también quieres actualizar la rama remota con el commit aplastado:</target>
        </trans-unit>
        <trans-unit id="c8107381ad7a4e9bfcfe1e4bfd58c9168ef6516d" translate="yes" xml:space="preserve">
          <source>If you are on a remote branch(called &lt;code&gt;feature-branch&lt;/code&gt;) cloned from a Golden Repository(&lt;code&gt;golden_repo_name&lt;/code&gt;), then here's the technique to squash your commits into one:</source>
          <target state="translated">Si est&amp;aacute; en una rama remota (llamada &lt;code&gt;feature-branch&lt;/code&gt; ) clonada de un Golden Repository ( &lt;code&gt;golden_repo_name&lt;/code&gt; ), entonces esta es la t&amp;eacute;cnica para aplastar sus confirmaciones en una:</target>
        </trans-unit>
        <trans-unit id="32f47536faa9331321aee23cdac3148266be1e42" translate="yes" xml:space="preserve">
          <source>If you don't care about the commit messages of the in-between commits, you can use</source>
          <target state="translated">Si no te importan los mensajes de confirmación de las confirmaciones intermedias,puedes usar</target>
        </trans-unit>
        <trans-unit id="787518d9bc259dac56a32f39ea1e2a792a17531f" translate="yes" xml:space="preserve">
          <source>If you have picked only one commit and squashed the rest, you can adjust one commit message:</source>
          <target state="translated">Si has elegido sólo una confirmación y has aplastado el resto,puedes ajustar un mensaje de confirmación:</target>
        </trans-unit>
        <trans-unit id="2b626aec01c288f93e9d5a110eb02bd59f405ad8" translate="yes" xml:space="preserve">
          <source>If you use TortoiseGit, you can the function &lt;code&gt;Combine to one commit&lt;/code&gt;:</source>
          <target state="translated">Si usa TortoiseGit, puede usar la funci&amp;oacute;n &lt;code&gt;Combine to one commit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="52aefe4131cf6e22141e6a89050a2d36c82447da" translate="yes" xml:space="preserve">
          <source>If you want to squish &lt;em&gt;every&lt;/em&gt; commit into a single commit (e.g. when releasing a project publicly for the first time), try:</source>
          <target state="translated">Si desea dividir &lt;em&gt;cada&lt;/em&gt; commit en un solo commit (por ejemplo, al lanzar un proyecto p&amp;uacute;blicamente por primera vez), intente:</target>
        </trans-unit>
        <trans-unit id="f827f77438492c15d0d2aa806bcc35f58430f25e" translate="yes" xml:space="preserve">
          <source>If you want to start editing the new commit message with a concatenation of the existing commit messages (i.e. similar to what a pick/squash/squash/&amp;hellip;/squash &lt;code&gt;git rebase -i&lt;/code&gt; instruction list would start you with), then you need to extract those messages and pass them to &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">Si desea comenzar a editar el nuevo mensaje de confirmaci&amp;oacute;n con una concatenaci&amp;oacute;n de los mensajes de confirmaci&amp;oacute;n existentes (es decir, similar a lo que comenzar&amp;iacute;a con una lista de instrucciones pick / squash / squash / ... / squash &lt;code&gt;git rebase -i&lt;/code&gt; ), entonces debe extraer esos mensajes y pasarlos a &lt;code&gt;git commit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="088b19cf941b3ff8da3b7eb151f8d881f3db1fff" translate="yes" xml:space="preserve">
          <source>If you want to write the new commit message from scratch, this suffices:</source>
          <target state="translated">Si quieres escribir el nuevo mensaje de confirmación desde cero,esto es suficiente:</target>
        </trans-unit>
        <trans-unit id="79f1ff9673cb765c19eb55c4d649e27cf47e1e06" translate="yes" xml:space="preserve">
          <source>If you're working with GitLab, you can just click the Squash option in the Merge Request as shown below. The commit message will be the title of the Merge Request.</source>
          <target state="translated">Si trabajas con GitLab,puedes hacer clic en la opción Squash en la solicitud de fusión como se muestra a continuación.El mensaje de confirmación será el título de la solicitud de fusión.</target>
        </trans-unit>
        <trans-unit id="a017ecd71bf7f57fd4ca564c4f4814ffbbbd55eb" translate="yes" xml:space="preserve">
          <source>In addition to other excellent answers, I'd like to add how &lt;code&gt;git rebase -i&lt;/code&gt; always confuses me with the commit order - older to newer one or vice versa? So this is my workflow:</source>
          <target state="translated">Adem&amp;aacute;s de otras excelentes respuestas, me gustar&amp;iacute;a agregar c&amp;oacute;mo &lt;code&gt;git rebase -i&lt;/code&gt; siempre me confunde con el orden de confirmaci&amp;oacute;n: &amp;iquest;m&amp;aacute;s antiguo a m&amp;aacute;s nuevo o viceversa? Entonces este es mi flujo de trabajo:</target>
        </trans-unit>
        <trans-unit id="e0c5c08fbe43f01fe7feb65bad1556407d8bf81f" translate="yes" xml:space="preserve">
          <source>In my case, I want to squash everything on the commit that was first in time. The ordering is from first to last, so exactly the other way as in &lt;code&gt;git log&lt;/code&gt;. In my case, I want:</source>
          <target state="translated">En mi caso, quiero aplastar todo en el commit que fue primero en el tiempo. El orden es del primero al &amp;uacute;ltimo, as&amp;iacute; que exactamente al rev&amp;eacute;s que en &lt;code&gt;git log&lt;/code&gt; . En mi caso, quiero:</target>
        </trans-unit>
        <trans-unit id="812b8ce0a931bda8d43ab639459be7c06897670f" translate="yes" xml:space="preserve">
          <source>In my workflow, I start a branch, and my first commit on that branch summarizes the goal (i.e. it's usually what I will push as the 'final' message for the feature to the public repository.)  So when I'm done, all I want to do is &lt;code&gt;git squash master&lt;/code&gt; back to the first message and then I'm ready to push.</source>
          <target state="translated">En mi flujo de trabajo, comienzo una rama, y ​​mi primer compromiso en esa rama resume el objetivo (es decir, generalmente es lo que presionar&amp;eacute; como el mensaje 'final' para la funci&amp;oacute;n al repositorio p&amp;uacute;blico). Entonces, cuando haya terminado, todo Lo que quiero hacer es volver al primer mensaje de &lt;code&gt;git squash master&lt;/code&gt; y luego estoy listo para presionar.</target>
        </trans-unit>
        <trans-unit id="cfebaa62652e8409b9f3689f76707285002e6e2c" translate="yes" xml:space="preserve">
          <source>In question it could be ambiguous what is meant by &quot;last&quot;.</source>
          <target state="translated">En cuestión podría ser ambiguo lo que se entiende por &quot;último&quot;.</target>
        </trans-unit>
        <trans-unit id="9306409d13d02f1d92a630f721830c055b515fbf" translate="yes" xml:space="preserve">
          <source>In the branch you would like to combine the commits on, run:</source>
          <target state="translated">En la rama en la que te gustaría combinar los compromisos,corre:</target>
        </trans-unit>
        <trans-unit id="88c73138cde2bf54e60255d9bd740e5e58d9f261" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past the command is &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; es el hash SHA1 o la ubicaci&amp;oacute;n relativa del HEAD de la rama actual desde la que se analizan los commits para el comando rebase. Por ejemplo, si el usuario desea ver 5 confirmaciones del HEAD actual en el pasado, el comando es &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0babcfbdf70396a1070d18ba28e5456936528f" translate="yes" xml:space="preserve">
          <source>In this very abbreviated history of the &lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt; repository you have opened a pull request to merge in the the Bill Clinton commit into the original (&lt;code&gt;MASTER&lt;/code&gt;) Fleetwood Mac commit.</source>
          <target state="translated">En esta historia muy abreviada del repositorio &lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt; , ha abierto una solicitud de extracci&amp;oacute;n para fusionarse en el compromiso de Bill Clinton en el compromiso original ( &lt;code&gt;MASTER&lt;/code&gt; ) Fleetwood Mac.</target>
        </trans-unit>
        <trans-unit id="bf126b3fade88997f0548ade26b8b5c4bfea4c6b" translate="yes" xml:space="preserve">
          <source>It's possible to use rebase but in different manner then in others mentioned answers:</source>
          <target state="translated">Es posible usar la rebase,pero de manera diferente a las otras respuestas mencionadas:</target>
        </trans-unit>
        <trans-unit id="028bc2366d79ea4ef91789bfa66ae316236a417d" translate="yes" xml:space="preserve">
          <source>LA1974</source>
          <target state="translated">LA1974</target>
        </trans-unit>
        <trans-unit id="fb2a8991936042159a3bb1d749bea91292a31069" translate="yes" xml:space="preserve">
          <source>Lastly, I run</source>
          <target state="translated">Por último,corro</target>
        </trans-unit>
        <trans-unit id="57fe6ea67ceef51616f8ae62d6f8e1cb4229da2f" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;git commit&lt;/code&gt; that warps directly from the &lt;em&gt;from&lt;/em&gt; to the &lt;em&gt;to&lt;/em&gt;</source>
          <target state="translated">Realice un &lt;code&gt;git commit&lt;/code&gt; que se deforme directamente de &lt;em&gt;from&lt;/em&gt; a the &lt;em&gt;to&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49e92ccd1adc445eb977e8a994e8fd9adc2bc217" translate="yes" xml:space="preserve">
          <source>Mark the relevant commits in the log view</source>
          <target state="translated">Marque las confirmaciones pertinentes en la vista de registro</target>
        </trans-unit>
        <trans-unit id="0fc0ad9a332750ab53c934b71eb3800bf3e4909a" translate="yes" xml:space="preserve">
          <source>My 'dev' branch was ahead of 'origin/dev' by 96 commits (so these commits were not pushed to the remote yet).</source>
          <target state="translated">Mi rama 'dev' se adelantó a 'origindev' por 96 compromisos (por lo que estos compromisos no fueron empujados al remoto todavía).</target>
        </trans-unit>
        <trans-unit id="8293f55e479d0410deb525c2426e813f0803e546" translate="yes" xml:space="preserve">
          <source>Next, I bring up the interactive rebase editor with &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt;.  The &lt;code&gt;~&lt;/code&gt; after the commit SHA tells the editor to include that commit in the editor.</source>
          <target state="translated">A continuaci&amp;oacute;n, presento el editor de rebase interactivo con &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt; . El &lt;code&gt;~&lt;/code&gt; despu&amp;eacute;s del commit SHA le dice al editor que incluya ese commit en el editor.</target>
        </trans-unit>
        <trans-unit id="a6117317363c016a257f2208f2a02cd8432aaabc" translate="yes" xml:space="preserve">
          <source>Next, I move the commit containing the fix (&lt;code&gt;fe7f1e0&lt;/code&gt;) to underneath the feature commit, and change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;fixup&lt;/code&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, muevo el commit que contiene el arreglo ( &lt;code&gt;fe7f1e0&lt;/code&gt; ) debajo del commit de caracter&amp;iacute;sticas, y cambio la &lt;code&gt;pick&lt;/code&gt; a la &lt;code&gt;fixup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8423bc929eacf6c5159737bd94c0cbd3c5778996" translate="yes" xml:space="preserve">
          <source>Note : This is based on using git on &lt;code&gt;ubuntu&lt;/code&gt; shell. If you are using different os (&lt;code&gt;Windows&lt;/code&gt; or &lt;code&gt;Mac&lt;/code&gt;) then above commands are same except editor. You might get different editor.</source>
          <target state="translated">Nota: Esto se basa en usar git en &lt;code&gt;ubuntu&lt;/code&gt; shell. Si est&amp;aacute; utilizando diferentes &lt;code&gt;Windows&lt;/code&gt; ( Windows o &lt;code&gt;Mac&lt;/code&gt; ), los comandos anteriores son los mismos, excepto el editor. Puede obtener un editor diferente.</target>
        </trans-unit>
        <trans-unit id="20b053a3e9165bb14f6a88287ca972e8a2dce8ee" translate="yes" xml:space="preserve">
          <source>Note: The resultant commit message is a combination of all the squashed commits, in order. If you are unhappy with that, you can always &lt;code&gt;git commit --amend&lt;/code&gt; to modify it manually. (Or, edit the alias to match your tastes.)</source>
          <target state="translated">Nota: El mensaje de confirmaci&amp;oacute;n resultante es una combinaci&amp;oacute;n de todas las confirmaciones aplastadas, en orden. Si no est&amp;aacute; satisfecho con eso, siempre puede hacer &lt;code&gt;git commit --amend&lt;/code&gt; y modificarlo manualmente. (O edite el alias para que coincida con sus gustos).</target>
        </trans-unit>
        <trans-unit id="d6377f9be4e13e6d8f9e38c5003db9b8ab9af614" translate="yes" xml:space="preserve">
          <source>Now this creates a new commit on top of HEAD with &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Ahora esto crea una nueva confirmaci&amp;oacute;n sobre HEAD con la &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48a3a5484c6d47719f56ef39bf6dd2a38a49336a" translate="yes" xml:space="preserve">
          <source>Now use</source>
          <target state="translated">Ahora usa</target>
        </trans-unit>
        <trans-unit id="3b3a3e1be78f40ef46e629b130884d7de89ba488" translate="yes" xml:space="preserve">
          <source>Open TortoiseGit context menu</source>
          <target state="translated">Abrir el menú contextual de TortoiseGit</target>
        </trans-unit>
        <trans-unit id="a5015e7e2cecbb5b2a96a0da08d780166899f93a" translate="yes" xml:space="preserve">
          <source>P.S. If you just do some reset to BO: 
(for example, using &lt;code&gt;reset --mixed&lt;/code&gt; that is explained in more detail here &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https://stackoverflow.com/a/18690845/2405850&lt;/a&gt;):</source>
          <target state="translated">PD Si solo hace un reinicio a BO: (por ejemplo, usando &lt;code&gt;reset --mixed&lt;/code&gt; que se explica con m&amp;aacute;s detalle aqu&amp;iacute; &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https://stackoverflow.com/a/18690845/2405850&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="e8df79c1f7f324f7ea12be589f8d4145c0fff656" translate="yes" xml:space="preserve">
          <source>PR and merge TO master &lt;em&gt;by reviewer&lt;/em&gt;.
(Yes, it would be easier for the developer to &lt;code&gt;merge --squash&lt;/code&gt; after the PR, but the team thought that would slow down the process.)</source>
          <target state="translated">PR y fusionar TO master &lt;em&gt;por revisor&lt;/em&gt; . (S&amp;iacute;, ser&amp;iacute;a m&amp;aacute;s f&amp;aacute;cil para el desarrollador &lt;code&gt;merge --squash&lt;/code&gt; despu&amp;eacute;s del RP, pero el equipo pens&amp;oacute; que eso retrasar&amp;iacute;a el proceso).</target>
        </trans-unit>
        <trans-unit id="7e84941f3d4a75c0dc177c26e3d8294131e792e3" translate="yes" xml:space="preserve">
          <source>Procedure 1</source>
          <target state="translated">Procedimiento 1</target>
        </trans-unit>
        <trans-unit id="9d3b7680f495af80fe40294525dfe378fc4a6043" translate="yes" xml:space="preserve">
          <source>Procedure 2</source>
          <target state="translated">Procedimiento 2</target>
        </trans-unit>
        <trans-unit id="2c937bebe0ed8ae169f2202e531a6094c90fee0c" translate="yes" xml:space="preserve">
          <source>Push the branch to your local repository</source>
          <target state="translated">Empuje la rama a su depósito local</target>
        </trans-unit>
        <trans-unit id="a73eccc33144570add3bc96c79ccd1f27423bf72" translate="yes" xml:space="preserve">
          <source>Push the change to a particular branch</source>
          <target state="translated">Empujar el cambio a una rama particular</target>
        </trans-unit>
        <trans-unit id="ca87402c617e64e22c3d7193a1f96b2b02c17659" translate="yes" xml:space="preserve">
          <source>Put squash instead of pick to H0:</source>
          <target state="translated">Poner calabaza en lugar de escoger a H0:</target>
        </trans-unit>
        <trans-unit id="260756bf22f9f993d1bc033875848a9357f0d969" translate="yes" xml:space="preserve">
          <source>Put the to-be-squashed commits on a working branch (if they aren't already) -- use gitk for this</source>
          <target state="translated">Poner los compromisos a ser aplastados en una rama de trabajo (si es que no lo están ya)...usa a Gitk para esto.</target>
        </trans-unit>
        <trans-unit id="9e66b40d5e26b8f80f7e041f81061eb7ad61a1b5" translate="yes" xml:space="preserve">
          <source>Reviewer does PR and merges to master.</source>
          <target state="translated">El revisor hace las relaciones públicas y se fusiona con el maestro.</target>
        </trans-unit>
        <trans-unit id="8c3a77045a4803d7837f166a12ee9caf303269a1" translate="yes" xml:space="preserve">
          <source>See where you are with &lt;code&gt;git log&lt;/code&gt;. Most important, find the commit hash of the first commit you &lt;em&gt;don't&lt;/em&gt; want to squash. So only the :</source>
          <target state="translated">Vea d&amp;oacute;nde est&amp;aacute; con &lt;code&gt;git log&lt;/code&gt; . Lo m&amp;aacute;s importante es encontrar el hash de confirmaci&amp;oacute;n de la primera confirmaci&amp;oacute;n que &lt;em&gt;no&lt;/em&gt; desea aplastar. Entonces solo el:</target>
        </trans-unit>
        <trans-unit id="a2da3b6230bae4fd68ed9664dced96244baa2508" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Combine to one commit&lt;/code&gt; from the context menu</source>
          <target state="translated">Seleccione &lt;code&gt;Combine to one commit&lt;/code&gt; en el men&amp;uacute; contextual.</target>
        </trans-unit>
        <trans-unit id="eab195238ec47a36730ecb88741d15affc592ef0" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Show Log&lt;/code&gt;</source>
          <target state="translated">Seleccione &lt;code&gt;Show Log&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef5af955bf451fa0bf9ce8667bb1749136652a01" translate="yes" xml:space="preserve">
          <source>Simple one-liner that always works, given that you are currently on the branch you want to squash, master is the branch it originated from, and the latest commit contains the commit message and author you wish to use:</source>
          <target state="translated">Una simple línea que siempre funciona,dado que actualmente estás en la rama que quieres aplastar,el maestro es la rama de la que se originó,y la última confirmación contiene el mensaje de confirmación y el autor que deseas usar:</target>
        </trans-unit>
        <trans-unit id="48e87018ba090a96eb3b4261c69ab3bc1688ba76" translate="yes" xml:space="preserve">
          <source>So the 2nd procedure helps to merge the commit to very old commit easily.</source>
          <target state="translated">Así que el 2º procedimiento ayuda a fusionar el compromiso con un compromiso muy antiguo fácilmente.</target>
        </trans-unit>
        <trans-unit id="1606820c64383f2678929b220f43c62392e4802a" translate="yes" xml:space="preserve">
          <source>So, this seems to work for us.</source>
          <target state="translated">Así que,esto parece funcionar para nosotros.</target>
        </trans-unit>
        <trans-unit id="c65f5cec26fdf510a411914b43897da6b752dc54" translate="yes" xml:space="preserve">
          <source>Sources &amp;amp; additional reads: &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;#1&lt;/a&gt;, &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;#2&lt;/a&gt;.</source>
          <target state="translated">Fuentes y lecturas adicionales: &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;# 1&lt;/a&gt; , &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;# 2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fe78756ce38b0a0104a04e440f7455dc5041f0" translate="yes" xml:space="preserve">
          <source>Squash merge with your local branch that you have already</source>
          <target state="translated">La calabaza se fusiona con su sucursal local que ya tiene</target>
        </trans-unit>
        <trans-unit id="f250854c3f99d28c958f70dce4dd6eb4cb062123" translate="yes" xml:space="preserve">
          <source>Squash my last X commits together using Git</source>
          <target state="translated">Aplastar mis últimos compromisos X juntos usando Git</target>
        </trans-unit>
        <trans-unit id="fa32bacb7f009d82ac949dca9b0e80d1d0dbd93c" translate="yes" xml:space="preserve">
          <source>Step 0: git log</source>
          <target state="translated">Paso 0:registro de git</target>
        </trans-unit>
        <trans-unit id="8e0ca5bd90136b4a7b027927451c19e1f346a18b" translate="yes" xml:space="preserve">
          <source>Step 1: git rebase</source>
          <target state="translated">Paso 1:la base de git</target>
        </trans-unit>
        <trans-unit id="d7eb36401823c9a736a592ee2155703f797e50da" translate="yes" xml:space="preserve">
          <source>Step 2: pick / squash what you want</source>
          <target state="translated">Paso 2:elige la calabaza que quieras</target>
        </trans-unit>
        <trans-unit id="a5e2c10a701fc35282279ec7765f80119e96ce60" translate="yes" xml:space="preserve">
          <source>Step 3: Adjust message(s)</source>
          <target state="translated">Paso 3:Ajustar los mensajes</target>
        </trans-unit>
        <trans-unit id="7692952e23e9867e52383f181dfe0cb65c218f1d" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;this handy blog post&lt;/a&gt; I found that you can use this command to squash the last 3 commits:</source>
          <target state="translated">Gracias a &lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;esta &amp;uacute;til publicaci&amp;oacute;n de blog&lt;/a&gt; , descubr&amp;iacute; que puedes usar este comando para aplastar las &amp;uacute;ltimas 3 confirmaciones:</target>
        </trans-unit>
        <trans-unit id="06fa56961a9b1119f58d05a3eea1f250493fd074" translate="yes" xml:space="preserve">
          <source>That's it. Once you save this (&lt;code&gt;:wq&lt;/code&gt;), you're done. Have a look at it with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">Eso es. Una vez que guarde esto ( &lt;code&gt;:wq&lt;/code&gt; ), ya est&amp;aacute;. Echa un vistazo con &lt;code&gt;git log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad8a077aa099078c8cbac44ec84ae98b2cd4e20e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;documentation for &lt;code&gt;git merge&lt;/code&gt;&lt;/a&gt; describes the &lt;code&gt;--squash&lt;/code&gt; option in more detail.</source>
          <target state="translated">La &lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;documentaci&amp;oacute;n para &lt;code&gt;git merge&lt;/code&gt; &lt;/a&gt; describe la opci&amp;oacute;n &lt;code&gt;--squash&lt;/code&gt; con m&amp;aacute;s detalle.</target>
        </trans-unit>
        <trans-unit id="0e607204ccc0308b417695ca633595dcad436b1d" translate="yes" xml:space="preserve">
          <source>The command will open the interactive rebase editor which then allows you to reorder, squash, reword, etc as per normal.</source>
          <target state="translated">El comando abrirá el editor interactivo de la base que le permitirá reordenar,aplastar,reescribir,etc.como de costumbre.</target>
        </trans-unit>
        <trans-unit id="925d19add6cc8a59abd536b73f79b247585837ee" translate="yes" xml:space="preserve">
          <source>The commit message will be prepopulated based on the squash.</source>
          <target state="translated">El mensaje de confirmación será prepoblado en base a la calabaza.</target>
        </trans-unit>
        <trans-unit id="8a6719516ac538e9ed622d11335500e260fc9964" translate="yes" xml:space="preserve">
          <source>The documentation displayed is pretty clear.  On any given line you can change the command from &lt;code&gt;pick&lt;/code&gt; to a command of your choice.</source>
          <target state="translated">La documentaci&amp;oacute;n que se muestra es bastante clara. En cualquier l&amp;iacute;nea dada, puede cambiar el comando de &lt;code&gt;pick&lt;/code&gt; a un comando de su elecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6c4ad30909bb83a10ddf48ebb81e1d7adda4edf0" translate="yes" xml:space="preserve">
          <source>The first thing I do is fix the mistake and make a new commit with the comment &lt;code&gt;squash this into my new feature!&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;Lo primero que hago es corregir el error y hacer una nueva confirmaci&amp;oacute;n con el comentario, &lt;code&gt;squash this into my new feature!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a54a921df7a18b8fa7bcbb17b04135a3f9ca0a4" translate="yes" xml:space="preserve">
          <source>The interactive rebase editor shows the last three commits.  This constraint was determined by &lt;code&gt;HEAD~3&lt;/code&gt; when running the command &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt;.</source>
          <target state="translated">El editor de rebase interactivo muestra los &amp;uacute;ltimos tres commits. &lt;code&gt;HEAD~3&lt;/code&gt; determin&amp;oacute; esta restricci&amp;oacute;n al ejecutar el comando &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40de1d7485f29f3c3927203644f6993e9c59eb2c" translate="yes" xml:space="preserve">
          <source>The most recent commit, &lt;code&gt;HEAD&lt;/code&gt;, is displayed first on line 1.  The lines starting with a &lt;code&gt;#&lt;/code&gt; are comments/documentation.</source>
          <target state="translated">El commit m&amp;aacute;s reciente, &lt;code&gt;HEAD&lt;/code&gt; , se muestra primero en la l&amp;iacute;nea 1. Las l&amp;iacute;neas que comienzan con un &lt;code&gt;#&lt;/code&gt; son comentarios / documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="15bd41701489226c2dce4509a6fee4be4aa552ba" translate="yes" xml:space="preserve">
          <source>The problem is that H0 contains H1 and H2 (and generally more commits before merge and after branching) while B0 don't. So you have to manage changes from H0, merge, H1, H2, B0 at least.</source>
          <target state="translated">El problema es que H0 contiene H1 y H2 (y generalmente más compromisos antes de la fusión y después de la ramificación)mientras que B0 no.Así que tienes que manejar los cambios de H0,fusionar,H1,H2,B0 por lo menos.</target>
        </trans-unit>
        <trans-unit id="6331cadceddf56d7aa2077447230eea2f9a842c7" translate="yes" xml:space="preserve">
          <source>Then commit using &lt;code&gt;--fixup&lt;/code&gt; option and the &lt;code&gt;OLDCOMMIT&lt;/code&gt; should be on which we need to merge(squash) this commit.</source>
          <target state="translated">Luego &lt;code&gt;--fixup&lt;/code&gt; usando la opci&amp;oacute;n --fixup y &lt;code&gt;OLDCOMMIT&lt;/code&gt; deber&amp;iacute;a estar en el que necesitamos fusionar (aplastar) este commit.</target>
        </trans-unit>
        <trans-unit id="625c194045dd72da9dae9e8a5696dc4cd84a15ed" translate="yes" xml:space="preserve">
          <source>Then execute below command to merge(squash) the new commit to the &lt;code&gt;OLDCOMMIT&lt;/code&gt;.</source>
          <target state="translated">Luego ejecute el siguiente comando para fusionar (aplastar) el nuevo commit a &lt;code&gt;OLDCOMMIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a925126395e6b2ebaae2cf1711a295f24f5b5f" translate="yes" xml:space="preserve">
          <source>Then last commits by time are H0, merge, B0. To squash them you will have to rebase your merged branch on commit H1.</source>
          <target state="translated">Entonces los últimos compromisos por tiempo son H0,fusión,B0.Para aplastarlas tendrás que volver a basar tu rama fusionada en la comisión H1.</target>
        </trans-unit>
        <trans-unit id="4b5c4a5092abbae0b51b1df123053bf15993a9f0" translate="yes" xml:space="preserve">
          <source>Then to continue the rebase:</source>
          <target state="translated">Luego para continuar con el rebase:</target>
        </trans-unit>
        <trans-unit id="cec55a62a50d094219c9ed6c3d7233b58b9df6cd" translate="yes" xml:space="preserve">
          <source>Then you have all of the changes ready to commit.</source>
          <target state="translated">Entonces tienes todos los cambios listos para comprometerte.</target>
        </trans-unit>
        <trans-unit id="546b13232526f68926882878963e76932c04582d" translate="yes" xml:space="preserve">
          <source>Then, I create another branch based out my-feature branch, keep &lt;code&gt;my-feature&lt;/code&gt; branch untouched.</source>
          <target state="translated">Luego, creo otra rama basada en mi rama de caracter&amp;iacute;sticas, mantengo intacta &lt;code&gt;my-feature&lt;/code&gt; rama de caracter&amp;iacute;sticas .</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="a14755fe0a2432949166566a2c3b293cbb3334a8" translate="yes" xml:space="preserve">
          <source>Thinking that nobody would ever care to read the full repository history. (There actually is a repository, click the link above!) You decide to squash these commits. So you go and run &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt;. Then you &lt;code&gt;git push --force&lt;/code&gt; it onto GitHub to clean up your PR.</source>
          <target state="translated">Pensando que a nadie le importar&amp;iacute;a leer el historial completo del repositorio. (En realidad hay un repositorio, &amp;iexcl;haga clic en el enlace de arriba!) Decide aplastar estas confirmaciones. Entonces, vaya y ejecute &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt; . Luego, &lt;code&gt;git push --force&lt;/code&gt; sobre GitHub para limpiar tu PR.</target>
        </trans-unit>
        <trans-unit id="e8779d0790a0a6c1a85e49564ee8661d2563c832" translate="yes" xml:space="preserve">
          <source>This function automatically executes all necessary single git steps.
Unfortunatly only available for Windows.</source>
          <target state="translated">Esta función ejecuta automáticamente todos los pasos necesarios de un solo git.Desafortunadamente sólo está disponible para Windows.</target>
        </trans-unit>
        <trans-unit id="4fad2e44fdb033a06b3f6360d78eb01c683e6c42" translate="yes" xml:space="preserve">
          <source>This is handy as it works even when you are on a local branch with no tracking information/remote repo.</source>
          <target state="translated">Esto es útil ya que funciona incluso cuando estás en una sucursal local sin información de rastreo.</target>
        </trans-unit>
        <trans-unit id="084858599aa0e25ed248f7286a555ac974946b7c" translate="yes" xml:space="preserve">
          <source>This is super-duper kludgy, but in a kind of cool way, so I'll just toss it into the ring:</source>
          <target state="translated">Esto es super-duper kludgy,pero de una forma genial,así que lo lanzaré al ring:</target>
        </trans-unit>
        <trans-unit id="bfd5d4a30f5a6bd68aea5b76c13d7f98cd5ab3ed" translate="yes" xml:space="preserve">
          <source>This will dump the history being squashed before it does so&amp;mdash;this gives you a chance to recover by grabbing an old commit ID off the console if you want to revert.  (Solaris users note it uses the GNU sed &lt;code&gt;-i&lt;/code&gt; option, Mac and Linux users should be fine with this.)</source>
          <target state="translated">Esto volcar&amp;aacute; el historial que se est&amp;aacute; aplastando antes de que lo haga; esto le brinda la oportunidad de recuperarse al obtener una ID de confirmaci&amp;oacute;n anterior de la consola si desea revertir. (Los usuarios de Solaris notan que usa la opci&amp;oacute;n GNU sed &lt;code&gt;-i&lt;/code&gt; , los usuarios de Mac y Linux deber&amp;iacute;an estar de acuerdo con esto).</target>
        </trans-unit>
        <trans-unit id="dc92e0bbd27c7f53e720875e6878c42bc7b99b1c" translate="yes" xml:space="preserve">
          <source>This will open the text editor and you must switch the 'pick' in front of each commit with 'squash' if you would like these commits to be merged together. From documentation:</source>
          <target state="translated">Esto abrirá el editor de texto y deberás cambiar el &quot;pick&quot; delante de cada confirmación con &quot;squash&quot; si quieres que estas confirmaciones se fusionen.De la documentación:</target>
        </trans-unit>
        <trans-unit id="876cf8ee642d0b29004c0d70c60d3ce90f399a68" translate="yes" xml:space="preserve">
          <source>This will show you choice options (as mentioned in other answers):</source>
          <target state="translated">Esto le mostrará las opciones de elección (como se menciona en otras respuestas):</target>
        </trans-unit>
        <trans-unit id="d2bce6c83325757e7a54433a83c6e7084810007e" translate="yes" xml:space="preserve">
          <source>This works well when all the commits are local, but if you try to change any commits already pushed to the remote you can really cause problems for other devs that have checked out the same branch!</source>
          <target state="translated">Esto funciona bien cuando todas las confirmaciones son locales,pero si intentas cambiar las confirmaciones ya enviadas al remoto puedes causar problemas a otros desarrolladores que hayan revisado la misma rama.</target>
        </trans-unit>
        <trans-unit id="1dbe8ac5ab79108392c62a34cf9417a1ac8ae9c7" translate="yes" xml:space="preserve">
          <source>To do this you can use following git command.</source>
          <target state="translated">Para ello puedes usar el siguiente comando git.</target>
        </trans-unit>
        <trans-unit id="603b6f4899ba5a0c325455ae848805098f30ac76" translate="yes" xml:space="preserve">
          <source>To squash the last 10 commits into 1 single commit:</source>
          <target state="translated">Para aplastar los últimos 10 compromisos en un solo compromiso:</target>
        </trans-unit>
        <trans-unit id="d453af1b2806f0771f8120f5f48b125b16f17109" translate="yes" xml:space="preserve">
          <source>Translation: provide a new &quot;editor&quot; for git which, if the filename to be edited is &lt;code&gt;git-rebase-todo&lt;/code&gt; (the interactive rebase prompt) changes all but the first &quot;pick&quot; to &quot;squash&quot;, and otherwise spawns vim - so that when you're prompted to edit the squashed commit message, you get vim. (And obviously I was squashing the last five commits on branch foo, but you could change that however you like.)</source>
          <target state="translated">Traducci&amp;oacute;n: proporcione un nuevo &quot;editor&quot; para git que, si el nombre de archivo que se va a editar es &lt;code&gt;git-rebase-todo&lt;/code&gt; (la solicitud interactiva de rebase) cambia todo excepto la primera &quot;selecci&amp;oacute;n&quot; a &quot;squash&quot;, y de lo contrario genera vim, de modo que cuando se le pide que edite el mensaje de confirmaci&amp;oacute;n aplastado, obtiene vim. (Y, obviamente, estaba aplastando los &amp;uacute;ltimos cinco commits en branch foo, pero puedes cambiar eso como quieras).</target>
        </trans-unit>
        <trans-unit id="2e04cd50a2d8a6e325a64a9e9d1e89bf9850e0a7" translate="yes" xml:space="preserve">
          <source>Update like below &lt;code&gt;pick&lt;/code&gt; one commit and &lt;code&gt;squash&lt;/code&gt; the others into the most recent,</source>
          <target state="translated">Actualice como se muestra a continuaci&amp;oacute;n, &lt;code&gt;pick&lt;/code&gt; un commit y &lt;code&gt;squash&lt;/code&gt; los otros en el m&amp;aacute;s reciente,</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="10c4aabc7d6d07adf02cb1c2e40e88d5732500a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; and replace &quot;pick&quot; on the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;, as described in &lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;the manual&lt;/a&gt;.</source>
          <target state="translated">Use &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; y reemplace &quot;pick&quot; en el segundo y posteriores commits con &quot;squash&quot; o &quot;fixup&quot;, como se describe en &lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;el manual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1b9ab9a0e0959c8d60301c1dd590795036c32e" translate="yes" xml:space="preserve">
          <source>WARNING: First make sure you commit your work&amp;mdash;check that &lt;code&gt;git status&lt;/code&gt; is clean (since &lt;code&gt;git reset --hard&lt;/code&gt; will throw away staged and unstaged changes)</source>
          <target state="translated">ADVERTENCIA: Primero aseg&amp;uacute;rese de comprometer su trabajo: verifique que el &lt;code&gt;git status&lt;/code&gt; est&amp;eacute; limpio (ya que &lt;code&gt;git reset --hard&lt;/code&gt; eliminar&amp;aacute; los cambios por etapas y por etapas)</target>
        </trans-unit>
        <trans-unit id="52065276a52b15005dd5aee61d9b2417c0b2ced8" translate="yes" xml:space="preserve">
          <source>What about an answer for the question related to a workflow like this?</source>
          <target state="translated">¿Qué tal una respuesta a la pregunta relacionada con un flujo de trabajo como este?</target>
        </trans-unit>
        <trans-unit id="387737056476baadea4c3b6310eccb9d5e50141c" translate="yes" xml:space="preserve">
          <source>What can be really convenient:</source>
          <target state="translated">Lo que puede ser realmente conveniente:</target>
        </trans-unit>
        <trans-unit id="765789c174c2479941c09177922e1d21cc6827fc" translate="yes" xml:space="preserve">
          <source>What i did is</source>
          <target state="translated">Lo que hice es</target>
        </trans-unit>
        <trans-unit id="d21b0bcb168b83ca89e96c0b658ad9d3fc1df640" translate="yes" xml:space="preserve">
          <source>When closing the editor, the fix will get squashed into the feature commit and my commit history will look nice and clean!</source>
          <target state="translated">Al cerrar el editor,el arreglo se aplastará en la confirmación de la función y mi historial de confirmaciones se verá bien y limpio!</target>
        </trans-unit>
        <trans-unit id="d4ceba0e28653571c383b8285d758678e129e217" translate="yes" xml:space="preserve">
          <source>You can do this fairly easily without &lt;code&gt;git rebase&lt;/code&gt; or &lt;code&gt;git merge --squash&lt;/code&gt;. In this example, we'll squash the last 3 commits.</source>
          <target state="translated">Puede hacerlo con bastante facilidad sin &lt;code&gt;git rebase&lt;/code&gt; o &lt;code&gt;git merge --squash&lt;/code&gt; . En este ejemplo, aplastaremos los &amp;uacute;ltimos 3 commits.</target>
        </trans-unit>
        <trans-unit id="757adf068d4225d6c149a530d9e62dc3a26e1485" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git merge --squash&lt;/code&gt; for this, which is slightly more elegant than &lt;code&gt;git rebase -i&lt;/code&gt;.  Suppose you're on master and you want to squash the last 12 commits into one.</source>
          <target state="translated">Puede usar &lt;code&gt;git merge --squash&lt;/code&gt; para esto, que es un poco m&amp;aacute;s elegante que &lt;code&gt;git rebase -i&lt;/code&gt; . Supongamos que est&amp;aacute;s en master y quieres aplastar los &amp;uacute;ltimos 12 commits en uno.</target>
        </trans-unit>
        <trans-unit id="71fb008e5d4b8f4decb5fc1d8418a270127e8380" translate="yes" xml:space="preserve">
          <source>You may also change the order of the commits. This allows you to squash or fixup commits that are not adjacent chronologically.</source>
          <target state="translated">También puede cambiar el orden de los compromisos.Esto te permite aplastar o arreglar las confirmaciones que no son adyacentes cronológicamente.</target>
        </trans-unit>
        <trans-unit id="f67e78ddf7e52bc3a80985eea97c30cace0d72aa" translate="yes" xml:space="preserve">
          <source>You opened a pull request and on GitHub you see this:</source>
          <target state="translated">Abriste una solicitud de extracción y en GitHub ves esto:</target>
        </trans-unit>
        <trans-unit id="6f42ea37efb2330eb9f8ae87f778d2109ad00e3b" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;~/.gitconfig&lt;/code&gt; should now contain this alias:</source>
          <target state="translated">Su &lt;code&gt;~/.gitconfig&lt;/code&gt; ahora debe contener este alias:</target>
        </trans-unit>
        <trans-unit id="758b9ac3be25f469194a9e3fd22799cf55e4cc10" translate="yes" xml:space="preserve">
          <source>edit and commit a lot locally, merge master regularly</source>
          <target state="translated">editar y comprometerse mucho localmente,fusionar el maestro regularmente</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="e0d33137a7b35fa4c2c656343c06f10e9f77b403" translate="yes" xml:space="preserve">
          <source>finally a push to remote,</source>
          <target state="translated">finalmente un empujón al control remoto,</target>
        </trans-unit>
        <trans-unit id="4b04d2a98dc3f0fd0b938cafe5761aa32fafe654" translate="yes" xml:space="preserve">
          <source>for example &lt;code&gt;git log --graph&lt;/code&gt; outputs the following (simplified):</source>
          <target state="translated">por ejemplo, &lt;code&gt;git log --graph&lt;/code&gt; genera lo siguiente (simplificado):</target>
        </trans-unit>
        <trans-unit id="d76620ae96c7ca431e1db5376c1cfcf85d087916" translate="yes" xml:space="preserve">
          <source>git commit</source>
          <target state="translated">git commit</target>
        </trans-unit>
        <trans-unit id="371e49a0b18c50d82d292aef71ea992421ef9133" translate="yes" xml:space="preserve">
          <source>git push origin (branch_name) --force</source>
          <target state="translated">git push origin (branch_name)--force</target>
        </trans-unit>
        <trans-unit id="56322e172fdd72aded4057a4a7b371ca73775805" translate="yes" xml:space="preserve">
          <source>git reset --soft Head~3 &amp;amp;&amp;amp;</source>
          <target state="translated">git reset --Soft Head ~ 3 &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="946fc396fd4b258f758878e94fa72b2ed7382c42" translate="yes" xml:space="preserve">
          <source>if for example you want to squash the last 3 commits to a single commit in a branch(remote repository) in for example: &lt;a href=&quot;https://bitbucket.org&quot;&gt;https://bitbucket.org&lt;/a&gt;</source>
          <target state="translated">si, por ejemplo, desea aplastar las &amp;uacute;ltimas 3 confirmaciones a una &amp;uacute;nica confirmaci&amp;oacute;n en una rama (repositorio remoto) en, por ejemplo: &lt;a href=&quot;https://bitbucket.org&quot;&gt;https://bitbucket.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="611d5f9682115beec752b912992f91f4d6631a4e" translate="yes" xml:space="preserve">
          <source>many local commits, &lt;em&gt;mixed with multiple merges FROM master&lt;/em&gt;,</source>
          <target state="translated">muchos commits locales, &lt;em&gt;mezclados con m&amp;uacute;ltiples fusiones de master&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="f1d1f78c97a0cfa141dba4aa92f53b7119108001" translate="yes" xml:space="preserve">
          <source>n(=4 here) is the number of last commit. Then you got following options,</source>
          <target state="translated">n(=4 aquí)es el número de la última entrega.Entonces tienes las siguientes opciones,</target>
        </trans-unit>
        <trans-unit id="a06e25653856f59ec61310038b0e76e461953e35" translate="yes" xml:space="preserve">
          <source>p, pick  = use commit</source>
          <target state="translated">p,pick=use commit</target>
        </trans-unit>
        <trans-unit id="e4ae77df54121cf3234bc6148af99f1b9c9169e9" translate="yes" xml:space="preserve">
          <source>s, squash  = use commit, but meld into previous commit</source>
          <target state="translated">s,squash=usa commit,pero se fusiona con el commit anterior</target>
        </trans-unit>
        <trans-unit id="f60c1a720971c0a3baf938460a4d4f212174afca" translate="yes" xml:space="preserve">
          <source>the editor pops up again with a default message for the new commit: change it to your needs, save and close. Squash completed!</source>
          <target state="translated">el editor aparece de nuevo con un mensaje predeterminado para la nueva confirmación:cámbialo a tus necesidades,guarda y cierra.¡Calabaza completada!</target>
        </trans-unit>
        <trans-unit id="14373bc7f8d111bad35942b43a801f430a7d6401" translate="yes" xml:space="preserve">
          <source>the editor pops up, showing the list of commits I want to merge. Now they are displayed in &lt;em&gt;reverse order&lt;/em&gt;: the older commit is on top. Mark as &quot;squash&quot; or &quot;s&quot; all the commits in there &lt;em&gt;except the first/older one&lt;/em&gt;: it will be used as a starting point. Save and close the editor;</source>
          <target state="translated">aparece el editor, mostrando la lista de confirmaciones que quiero fusionar. Ahora se muestran en &lt;em&gt;orden inverso&lt;/em&gt; : la confirmaci&amp;oacute;n anterior est&amp;aacute; en la parte superior. Marque como &quot;squash&quot; o &quot;s&quot; todas las confirmaciones all&amp;iacute;, &lt;em&gt;excepto la primera / anterior&lt;/em&gt; : se utilizar&amp;aacute; como punto de partida. Guarda y cierra el editor;</target>
        </trans-unit>
        <trans-unit id="fdadc9f4e4d7f36a7d4ff5b5e8ef900c37504ed9" translate="yes" xml:space="preserve">
          <source>then you squash into B0 changes of H0, H1, H2 (losing completely commits for changes after branching and before merge.</source>
          <target state="translated">entonces se aplasta en B0 los cambios de H0,H1,H2 (perdiendo completamente los compromisos para los cambios después de la ramificación y antes de la fusión.</target>
        </trans-unit>
        <trans-unit id="857ce54ac9c9e1932a376ea4c0ed0fa4f8b713ad" translate="yes" xml:space="preserve">
          <source>where the number of ^'s is X</source>
          <target state="translated">donde el número de ^ es X</target>
        </trans-unit>
        <trans-unit id="9cd599249730cbcaaa3eaaca4c150509b03fe784" translate="yes" xml:space="preserve">
          <source>⚠️ WARNING: &quot;My last X commits&quot; might be ambiguous.</source>
          <target state="translated">⚠️ ADVERTENCIA:&quot;Mi última X se compromete&quot; podría ser ambiguo.</target>
        </trans-unit>
        <trans-unit id="257eca43111b6053a03fada07551d11187f131cc" translate="yes" xml:space="preserve">
          <source>🐻 MORAL OF THE STORY</source>
          <target state="translated">🐻 MORALEJA DE LA HISTORIA</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
