<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/5189560">
    <body>
      <group id="5189560">
        <trans-unit id="0f6e71b1a03ea4118f8aca590d18524c56b24e91" translate="yes" xml:space="preserve">
          <source>(in this case, squash the two last commits)</source>
          <target state="translated">(在这种情况下,碾压最后的两个承诺)</target>
        </trans-unit>
        <trans-unit id="00a75dfc6a363821c165dda8663912f8b12308bb" translate="yes" xml:space="preserve">
          <source>... Which automatically squashes together the last &lt;code&gt;N&lt;/code&gt; commits, inclusive.</source>
          <target state="translated">...会自动将最后 &lt;code&gt;N&lt;/code&gt; 次提交（包括首尾）压缩在一起。</target>
        </trans-unit>
        <trans-unit id="e912fb518c6c899659dd36fc58ca72800c398da1" translate="yes" xml:space="preserve">
          <source>... or using Windows' Command Prompt:</source>
          <target state="translated">...或使用Windows的命令提示符。</target>
        </trans-unit>
        <trans-unit id="f9868bd7af9ea1a05d5a2cc3db7e9e630cb95cb1" translate="yes" xml:space="preserve">
          <source>1) Identify the commit short hash</source>
          <target state="translated">1)识别提交的短散列</target>
        </trans-unit>
        <trans-unit id="a266d1bf09d724f5e01d17ae11e07a3b904343ee" translate="yes" xml:space="preserve">
          <source>1) git reset --soft HEAD~2 &amp;amp;&amp;amp; git commit -m&quot;&lt;strong&gt;message&lt;/strong&gt;&quot;</source>
          <target state="translated">1）git reset --soft HEAD〜2 &amp;amp;&amp;amp; git commit -m&amp;ldquo; &lt;strong&gt;消息&lt;/strong&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="31bac7a25e633d602c5f07d013cf5bad6b5c8e6d" translate="yes" xml:space="preserve">
          <source>2) If you want to squash (merge) last two commit</source>
          <target state="translated">2)如果你想把最后两个提交的内容粉碎(合并),那么你就可以把最后的两个提交</target>
        </trans-unit>
        <trans-unit id="cbd711953c1351ee6a5326f8709d2fa00a65e56d" translate="yes" xml:space="preserve">
          <source>2) git push</source>
          <target state="translated">2)git推送</target>
        </trans-unit>
        <trans-unit id="ea65c50e6ab609f46f3b9dff142c828dcb7a2b4c" translate="yes" xml:space="preserve">
          <source>3) This opens up a &lt;code&gt;nano&lt;/code&gt; editor for merging. And it looks like below</source>
          <target state="translated">3）这将打开一个用于合并的 &lt;code&gt;nano&lt;/code&gt; 编辑器。 它看起来像下面</target>
        </trans-unit>
        <trans-unit id="78b84c9eba8b454d71ff15e78d7b205c76275eca" translate="yes" xml:space="preserve">
          <source>4) Rename the word &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; which is present before &lt;code&gt;abcd1234&lt;/code&gt;. After rename it should be like below.</source>
          <target state="translated">4）重命名 &lt;code&gt;squash&lt;/code&gt; 到 &lt;code&gt;abcd1234&lt;/code&gt; 之前。 重命名后，应如下所示。</target>
        </trans-unit>
        <trans-unit id="71b14741158ee8ef04c0060e1f8a21f8fb3b1e25" translate="yes" xml:space="preserve">
          <source>5) Now save and close the &lt;code&gt;nano&lt;/code&gt; editor. Press &lt;code&gt;ctrl + o&lt;/code&gt; and press &lt;code&gt;Enter&lt;/code&gt; to save. And then press &lt;code&gt;ctrl + x&lt;/code&gt; to exit the editor.</source>
          <target state="translated">5）现在保存并关闭 &lt;code&gt;nano&lt;/code&gt; 编辑器。 按 &lt;code&gt;ctrl + o&lt;/code&gt; ，然后按 &lt;code&gt;Enter&lt;/code&gt; 键保存。 然后按 &lt;code&gt;ctrl + x&lt;/code&gt; 退出编辑器。</target>
        </trans-unit>
        <trans-unit id="85cf74b710242b910482c040916448edae877361" translate="yes" xml:space="preserve">
          <source>6) Then &lt;code&gt;nano&lt;/code&gt; editor again opens for updating comments, if necessary update it.</source>
          <target state="translated">6）然后再次打开 &lt;code&gt;nano&lt;/code&gt; 编辑器以更新注释，必要时对其进行更新。</target>
        </trans-unit>
        <trans-unit id="dfc29b1eb351d0fcd6446b260cefa0750b92fd58" translate="yes" xml:space="preserve">
          <source>7) Now its squashed successfully, you can verify it by checking logs.</source>
          <target state="translated">7)现在它被压制成功了,你可以通过查看日志来验证。</target>
        </trans-unit>
        <trans-unit id="0534fb54df6a2793525c086550d32e11a5d6cdf6" translate="yes" xml:space="preserve">
          <source>8) Now push to repo. Note to add &lt;code&gt;+&lt;/code&gt; sign before the branch name. This means forced push.</source>
          <target state="translated">8）现在按回购。 注意在分支名称前添加 &lt;code&gt;+&lt;/code&gt; 号。 这意味着强制推动。</target>
        </trans-unit>
        <trans-unit id="060566f0626a9c056933505d6f6cf04d52e947e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;Anomies answer&lt;/a&gt; is good, but I felt insecure about this so I decided to add a couple of screenshots.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;异常答案&lt;/a&gt;是好的，但是我对此感到不安全，因此我决定添加一些屏幕截图。</target>
        </trans-unit>
        <trans-unit id="0aa246496b4e1fd607eb4727df2b1c6b2fd5d5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt;  // puts all changes in stage</source>
          <target state="translated">&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt; //将所有更改置于阶段</target>
        </trans-unit>
        <trans-unit id="7055a5977843ebb56fc6cf1a7433d6529c41d611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; , where N is the number of commits I want to join, &lt;em&gt;starting from the most recent one&lt;/em&gt;. So &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; would mean &quot;squash the last 5 commits into a new one&quot;;</source>
          <target state="translated">&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; ，其中N是我要加入的提交数， &lt;em&gt;从最近一次开始&lt;/em&gt; 。 因此 &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; 意味着&amp;ldquo;将最后5次提交压缩为一个新提交&amp;rdquo;；</target>
        </trans-unit>
        <trans-unit id="4f4ea95712f9097dba8f82df029c2063fe45d6db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; the only real advantage of this method over the simpler &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; suggested by Chris Johnsen in &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;his answer&lt;/a&gt; is that you get the commit message prepopulated with every commit message that you're squashing.</source>
          <target state="translated">&lt;em&gt;更新：&lt;/em&gt;此方法相对于Chris Johnsen在&lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;他的答案中&lt;/a&gt;建议的更简单的 &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; 的唯一真正优势是，您得到的提交消息中都包含您要压缩的每个提交消息。</target>
        </trans-unit>
        <trans-unit id="7bc1abce6232c8b6c9b96cbc89e3473e9d63b768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A practical everyday example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一个实际的日常例子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68214ab4e4aca49ed9688ab7ba5060c6d11a94f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the interactive rebase editor:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用交互式基础编辑器：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab98be530e6bee8cd013851490d34d6048cd6904" translate="yes" xml:space="preserve">
          <source>Add Christine Perfect</source>
          <target state="translated">添加Christine Perfect</target>
        </trans-unit>
        <trans-unit id="bfb4f0dc3070ad453043d38a7fd9f425d739332c" translate="yes" xml:space="preserve">
          <source>Add Danny Kirwan</source>
          <target state="translated">添加Danny Kirwan</target>
        </trans-unit>
        <trans-unit id="7aa7c343556333bbf1afb97214bb9452da86a2bf" translate="yes" xml:space="preserve">
          <source>Add a global &quot;squash&quot; alias from bash: (or Git Bash on Windows)</source>
          <target state="translated">在bash中添加一个全局的 &quot;squash &quot;别名。(或Windows上的Git Bash)</target>
        </trans-unit>
        <trans-unit id="b1b79d483720ae24eec3e5adbd6ca57ec881cd82" translate="yes" xml:space="preserve">
          <source>Advantage of 1st procedure is to squash multiple commits and to reorder. But this procedure will be difficult if we need to merge a fix to very old commit.</source>
          <target state="translated">第1个过程的优点是可以压制多个提交,并重新排序。但是如果我们需要合并一个修复到非常老的提交,这个过程会很困难。</target>
        </trans-unit>
        <trans-unit id="7868a386b46b1e0c5a783fd920cb3a86a91ca21b" translate="yes" xml:space="preserve">
          <source>After rebase will finish you can choose message for squashed H0 and B0:</source>
          <target state="translated">重装完成后,你可以选择H0和B0被压扁的消息。</target>
        </trans-unit>
        <trans-unit id="48786ade9458227291ecdfcbc328a0b9a48bba9c" translate="yes" xml:space="preserve">
          <source>After save and exit rebase will apply commits in turn after H1. That means that it will ask you to resolve conflicts again (where HEAD will be H1 at first and then accumulating commits as they are applied).</source>
          <target state="translated">保存和退出后,rebase会在H1之后依次应用提交。这意味着它将要求你再次解决冲突(这里的HEAD将是H1开始,然后在应用时累积提交)。</target>
        </trans-unit>
        <trans-unit id="b90a4b8a8c8bb781c2de8719251307f780e35ad0" translate="yes" xml:space="preserve">
          <source>And what happens? You just made single commit that get from Fritz to Bill Clinton. Because you forgot that yesterday you were working on the Buckingham Nicks version of this project. And &lt;code&gt;git log&lt;/code&gt; doesn't match what you see on GitHub.</source>
          <target state="translated">那会发生什么呢？ 您刚刚做出了一次从Fritz到Bill Clinton的提交。 因为您忘记了昨天您正在从事该项目的白金汉尼克斯版本。 &lt;code&gt;git log&lt;/code&gt; 与您在GitHub上看到的不匹配。</target>
        </trans-unit>
        <trans-unit id="093e99d3dbc1e1d8c95fe7ba70003dcb67751c12" translate="yes" xml:space="preserve">
          <source>As the commit on line 1 is &lt;code&gt;HEAD&lt;/code&gt;, in most cases you would leave this as &lt;code&gt;pick&lt;/code&gt;. 
 You cannot use &lt;code&gt;squash&lt;/code&gt; or &lt;code&gt;fixup&lt;/code&gt; as there is no other commit to squash the commit into.</source>
          <target state="translated">由于第1行的提交为 &lt;code&gt;HEAD&lt;/code&gt; ，在大多数情况下，您将其保留为 &lt;code&gt;pick&lt;/code&gt; 。 您不能使用 &lt;code&gt;squash&lt;/code&gt; 或 &lt;code&gt;fixup&lt;/code&gt; ,因为没有其他提交可以将提交压缩到其中。</target>
        </trans-unit>
        <trans-unit id="3b41b6bdffa611514466e9905a87e0b849f5fdea" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;this article&lt;/a&gt; I found this method easier for my usecase.</source>
          <target state="translated">根据&lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;本文，&lt;/a&gt;我发现此方法更适合我的用例。</target>
        </trans-unit>
        <trans-unit id="e29ab6f60ee8c7e67c1f6b510f26b71c099d14d4" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;Chris Johnsen's answer&lt;/a&gt;,</source>
          <target state="translated">根据&lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;克里斯&amp;middot;约翰森的回答&lt;/a&gt; ，</target>
        </trans-unit>
        <trans-unit id="9a1a2639cbe33c22eb5dbb88182e215a85ff59b4" translate="yes" xml:space="preserve">
          <source>Bill Clinton</source>
          <target state="translated">比尔-克林顿</target>
        </trans-unit>
        <trans-unit id="e91185e515d9c1ad67ebd9560c54d10d75f7605a" translate="yes" xml:space="preserve">
          <source>Both of those methods squash the last three commits into a single new commit in the same way. The soft reset just re-points HEAD to the last commit that you do not want to squash. Neither the index nor the working tree are touched by the soft reset, leaving the index in the desired state for your new commit (i.e. it already has all the changes from the commits that you are about to &amp;ldquo;throw away&amp;rdquo;).</source>
          <target state="translated">这两种方法都以相同的方式将最后三个提交压缩为单个新提交。 软重置只是将HEAD重新指向您不想挤压的最后一次提交。 软复位既不会触及索引也不会影响工作树，从而使索引处于新提交的所需状态（即，它已经具有您要&amp;ldquo;丢弃&amp;rdquo;的提交的所有更改）。</target>
        </trans-unit>
        <trans-unit id="11d466714aac7655883761ed97c5295c4bfdafbb" translate="yes" xml:space="preserve">
          <source>Check out the target branch (e.g. 'master')</source>
          <target state="translated">检查出目标分支(如'master')。</target>
        </trans-unit>
        <trans-unit id="4fc0c1dfdb777b642cb8be476d33324610a18450" translate="yes" xml:space="preserve">
          <source>Checkout the golden repo</source>
          <target state="translated">查看黄金回购</target>
        </trans-unit>
        <trans-unit id="828d4675ea69be7bbbd51d39ea75d7e2c353989c" translate="yes" xml:space="preserve">
          <source>Commit your changes (this will be the only commit that goes in dev-branch)</source>
          <target state="translated">提交你的修改(这将是唯一一个在dev-branch中提交的提交)。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="8affcece617012629577cf8bfabbbc0cbdccf5e6" translate="yes" xml:space="preserve">
          <source>Create a new branch from it(golden repo) as follows</source>
          <target state="translated">从它中创建一个新的分支(Golden repo),如下所示</target>
        </trans-unit>
        <trans-unit id="51a53ea31f4f996d5387d6d4244348d9a9522bfe" translate="yes" xml:space="preserve">
          <source>Execute &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;&lt;code&gt;git rebase -i [your hash]&lt;/code&gt;&lt;/a&gt;, in my case:</source>
          <target state="translated">在我的情况下，执行&lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt; &lt;code&gt;git rebase -i [your hash]&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac8b133f58886974b11bc6af37c28baf4d4c4593" translate="yes" xml:space="preserve">
          <source>Find the commit hash you want to squash on top of, say &lt;code&gt;d43e15&lt;/code&gt;.</source>
          <target state="translated">找到要 &lt;code&gt;d43e15&lt;/code&gt; 的提交哈希，例如d43e15 。</target>
        </trans-unit>
        <trans-unit id="16fe861b00c32729b8570a41dd960986992c8977" translate="yes" xml:space="preserve">
          <source>Find the exact files you want to get &lt;em&gt;to&lt;/em&gt;, and &lt;code&gt;git checkout&lt;/code&gt; them</source>
          <target state="translated">找到您要获取的确切文件，然后 &lt;code&gt;git checkout&lt;/code&gt; 它们</target>
        </trans-unit>
        <trans-unit id="513ddb206d72ddd403d65e37a963ba3c61af9ca1" translate="yes" xml:space="preserve">
          <source>Find the exact prior commit you want to keep in history, and &lt;code&gt;git reset --soft&lt;/code&gt; that</source>
          <target state="translated">找到您想要保留在历史记录中的确切先前提交，然后 &lt;code&gt;git reset --soft&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbff6a6b4ceaa070a2583eb67ba786884ec2dce3" translate="yes" xml:space="preserve">
          <source>First I find out the number of commits between my feature branch and current master branch by</source>
          <target state="translated">首先,我找出我的特征分支和当前主分支之间的提交数,方法是</target>
        </trans-unit>
        <trans-unit id="b17781596baa10e42e5d27e04c27b98e980cac0e" translate="yes" xml:space="preserve">
          <source>First add the required files for commit</source>
          <target state="translated">首先添加需要提交的文件</target>
        </trans-unit>
        <trans-unit id="e3a67cef2cd706c75ce38bcabf3f0ff9e944ae90" translate="yes" xml:space="preserve">
          <source>For details click on the &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;Link&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">有关详细信息，请单击&lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af1603c24d4db6e43caf6f4bf93db855e59a5472" translate="yes" xml:space="preserve">
          <source>For example, if you are looking to merge all the commits into one, the 'pick' is the first commit you made and all future ones (placed below the first) should be set to 'squash'. If using vim, use &lt;strong&gt;:x&lt;/strong&gt; in insert mode to save and exit the editor.</source>
          <target state="translated">例如，如果您希望将所有提交合并为一个，则&amp;ldquo; pick&amp;rdquo;是您进行的第一个提交，所有将来的提交（置于第一个之后）应设置为&amp;ldquo; squash&amp;rdquo;。 如果使用vim，请在插入模式下使用&lt;strong&gt;：x&lt;/strong&gt;保存并退出编辑器。</target>
        </trans-unit>
        <trans-unit id="e5634b5e021244ee271ad922152ae052ceecc536" translate="yes" xml:space="preserve">
          <source>For more on this and other ways to rewrite your commit history see &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;this helpful post&lt;/a&gt;</source>
          <target state="translated">有关此方法以及重写提交历史记录的其他方法的更多信息，请参见此&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;有用的帖子&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc8b719f20cf72ebfb1459a1756eda92bcc9e219" translate="yes" xml:space="preserve">
          <source>Four commits:</source>
          <target state="translated">四个承诺。</target>
        </trans-unit>
        <trans-unit id="0ff5edf7ba7c13b10c729d9325013204a570385b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;^&lt;/code&gt; means the previous commit to &lt;code&gt;OLDCOMMIT&lt;/code&gt;. This &lt;code&gt;rebase&lt;/code&gt; command opens interactive window on a editor (vim or nano) on that
we no need to do anything just save and exiting is sufficient. Because the option passed to this will automatically move the latest
commit to next to old commit and change the operation to &lt;code&gt;fixup&lt;/code&gt; (equivalent to squash). Then rebase continues and finishes.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 表示对 &lt;code&gt;OLDCOMMIT&lt;/code&gt; 的先前提交。 这个 &lt;code&gt;rebase&lt;/code&gt; 命令在编辑器（vim或nano）上打开交互式窗口，在该窗口上我们不需要做任何事情，只需保存并退出即可。 因为传递给此选项的选项将自动将最新提交移至旧提交旁边，并将操作更改为 &lt;code&gt;fixup&lt;/code&gt; （等效于squash）。 然后变基继续并完成。</target>
        </trans-unit>
        <trans-unit id="1ab294f6db6b416c34905212bef55947aeddd00a" translate="yes" xml:space="preserve">
          <source>Here even &lt;code&gt;git log --oneline&lt;/code&gt; also can be used to get short hash.</source>
          <target state="translated">这里甚至 &lt;code&gt;git log --oneline&lt;/code&gt; 也可以用来获取短哈希。</target>
        </trans-unit>
        <trans-unit id="abfc9c95a5a36468169f0e59eed3b53351764f57" translate="yes" xml:space="preserve">
          <source>Hope it helps, thanks.</source>
          <target state="translated">希望对你有帮助,谢谢。</target>
        </trans-unit>
        <trans-unit id="e9acce96a379cc84dadce50a2a0d0c8a84bd8163" translate="yes" xml:space="preserve">
          <source>How can I squash my last X commits together into one commit using Git?</source>
          <target state="translated">如何使用Git将我最后的X个提交压缩成一个提交?</target>
        </trans-unit>
        <trans-unit id="b3aa1fa40cb10cce596ab2f6735206a7a54e21a1" translate="yes" xml:space="preserve">
          <source>How many commits u need to merge, u need to give next that HEAD(like this HEAD~2)</source>
          <target state="translated">你需要合并多少个提交,你需要给下一个HEAD(比如这个HEAD~2)</target>
        </trans-unit>
        <trans-unit id="01e83eedbee0bac8113da661371c9e862faa5901" translate="yes" xml:space="preserve">
          <source>I find a more generic solution is not to specify 'N' commits, but rather the branch/commit-id you want to squash on top of.  This is less error-prone than counting the commits up to a specific commit&amp;mdash;just specify the tag directly, or if you really want to count you can specify HEAD~N.</source>
          <target state="translated">我发现一个更通用的解决方案不是指定&amp;ldquo; N&amp;rdquo;个提交，而是要在其上方压入的branch / commit-id。 与将提交计数到特定提交相比，这种方法更不容易出错-只需直接指定标签，或者如果您真的想计数，则可以指定HEAD〜N。</target>
        </trans-unit>
        <trans-unit id="15f7cd9bd7d23b350c09940eb410992e9fe3d486" translate="yes" xml:space="preserve">
          <source>I haven't seen a workflow like that on this page. (That may be my eyes.) If I understand &lt;code&gt;rebase&lt;/code&gt; correctly, multiple merges would require &lt;strong&gt;multiple conflict resolutions&lt;/strong&gt;. I do NOT want even to think about that!</source>
          <target state="translated">我在此页面上没有看到这样的工作流程。 （这可能是我的眼睛。）如果我正确理解了 &lt;code&gt;rebase&lt;/code&gt; ，则多次合并将需要&lt;strong&gt;多个冲突解决方案&lt;/strong&gt; 。 我什至不想考虑！</target>
        </trans-unit>
        <trans-unit id="b87f73f2e8db36e6d71fb06157044e936572698f" translate="yes" xml:space="preserve">
          <source>I prefer to use the command &lt;code&gt;fixup&lt;/code&gt; as this &quot;squashes&quot; the commit's changes into the commit on the line above and discards the commit's message.</source>
          <target state="translated">我更喜欢使用命令 &lt;code&gt;fixup&lt;/code&gt; ,因为这可以将提交的更改&amp;ldquo;压榨&amp;rdquo;到上一行的提交中，并丢弃提交的消息。</target>
        </trans-unit>
        <trans-unit id="11f555b9e44717e3b66217f13f903c4371b5dda4" translate="yes" xml:space="preserve">
          <source>I recommend avoiding &lt;code&gt;git reset&lt;/code&gt; when possible -- especially for Git-novices.  Unless you really need to automate a process based on a &lt;em&gt;number&lt;/em&gt; of commits, there is a less exotic way...</source>
          <target state="translated">我建议尽可能避免 &lt;code&gt;git reset&lt;/code&gt; -特别是对于Git-novices。 除非您真的需要基于&lt;em&gt;多个&lt;/em&gt;提交使流程自动化，否则会有一种不太常见的方式...</target>
        </trans-unit>
        <trans-unit id="3dca227ddd161112834d5cf5d8d8bf15553d4ddf" translate="yes" xml:space="preserve">
          <source>I then run &lt;code&gt;git log&lt;/code&gt; or &lt;code&gt;gitk&lt;/code&gt; and get the commit SHA of the new feature (in this case &lt;code&gt;1ff9460&lt;/code&gt;).</source>
          <target state="translated">然后，我运行 &lt;code&gt;git log&lt;/code&gt; 或 &lt;code&gt;gitk&lt;/code&gt; 并获取新功能的提交SHA（在本例中为 &lt;code&gt;1ff9460&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9bc0e663b42f4c03fed1ae440e72de7476b8085f" translate="yes" xml:space="preserve">
          <source>I think the easiest way to do this is by making a new branch off of master and doing a merge --squash of the feature branch.</source>
          <target state="translated">我认为最简单的方法是在master上建立一个新的分支,然后对特征分支进行合并--squash。</target>
        </trans-unit>
        <trans-unit id="c58228448370201426a2ca0267ec9560383413e8" translate="yes" xml:space="preserve">
          <source>I use the alias:</source>
          <target state="translated">我用的是化名。</target>
        </trans-unit>
        <trans-unit id="86001cc8c4eed6dfdd49e895d88ca2295d3b8afd" translate="yes" xml:space="preserve">
          <source>I wanted to squash these commits into one before pushing the change. I prefere to reset the branch to the state of 'origin/dev' (this will leave all changes from the 96 commits unstaged) and then commit the changes at once:</source>
          <target state="translated">我想在推送更改之前将这些提交压缩成一个。我倾向于将分支重设为'origindev'状态 (这将使96个提交中的所有更改都不被缓存),然后一次性提交这些更改。</target>
        </trans-unit>
        <trans-unit id="3ef5f47215cc877254b4c604b64a56fd37c0c5dd" translate="yes" xml:space="preserve">
          <source>I'd probably do what &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair suggested&lt;/a&gt;, though.</source>
          <target state="translated">我可能会做&lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair的建议&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d1dbb1610551849ad4b8eb20bae4c982b7e33d6" translate="yes" xml:space="preserve">
          <source>I've recently committed a new feature.  Since then, I have committed two bug fixes.  But now I have discovered a bug (or maybe just a spelling error) in the new feature I committed.  How annoying!  I don't want a new commit polluting my commit history!</source>
          <target state="translated">我最近提交了一个新功能。从那时起,我已经提交了两个bug修复。但现在我发现我提交的新功能中出现了一个bug(或许只是拼写错误)。多么烦人啊!我不希望再提交一个新的提交。我不想让一个新的提交污染我的提交历史记录!</target>
        </trans-unit>
        <trans-unit id="600ba8b07c35f3aa98f10bd9215d0c431e3ac6f8" translate="yes" xml:space="preserve">
          <source>If you also want to update the remote branch with the squashed commit:</source>
          <target state="translated">如果你也想用被压扁的提交更新远程分支。</target>
        </trans-unit>
        <trans-unit id="c8107381ad7a4e9bfcfe1e4bfd58c9168ef6516d" translate="yes" xml:space="preserve">
          <source>If you are on a remote branch(called &lt;code&gt;feature-branch&lt;/code&gt;) cloned from a Golden Repository(&lt;code&gt;golden_repo_name&lt;/code&gt;), then here's the technique to squash your commits into one:</source>
          <target state="translated">如果您位于从Golden Repository（ &lt;code&gt;golden_repo_name&lt;/code&gt; ）克隆的远程分支（称为 &lt;code&gt;feature-branch&lt;/code&gt; ）上，则可以使用以下技术将提交压缩为一个：</target>
        </trans-unit>
        <trans-unit id="32f47536faa9331321aee23cdac3148266be1e42" translate="yes" xml:space="preserve">
          <source>If you don't care about the commit messages of the in-between commits, you can use</source>
          <target state="translated">如果你不关心提交之间的提交信息,你可以使用</target>
        </trans-unit>
        <trans-unit id="787518d9bc259dac56a32f39ea1e2a792a17531f" translate="yes" xml:space="preserve">
          <source>If you have picked only one commit and squashed the rest, you can adjust one commit message:</source>
          <target state="translated">如果你只选了一个提交,把其他的都压扁了,你可以调整一个提交信息。</target>
        </trans-unit>
        <trans-unit id="2b626aec01c288f93e9d5a110eb02bd59f405ad8" translate="yes" xml:space="preserve">
          <source>If you use TortoiseGit, you can the function &lt;code&gt;Combine to one commit&lt;/code&gt;:</source>
          <target state="translated">如果使用TortoiseGit，则可以将功能 &lt;code&gt;Combine to one commit&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="52aefe4131cf6e22141e6a89050a2d36c82447da" translate="yes" xml:space="preserve">
          <source>If you want to squish &lt;em&gt;every&lt;/em&gt; commit into a single commit (e.g. when releasing a project publicly for the first time), try:</source>
          <target state="translated">如果要将&lt;em&gt;每个&lt;/em&gt;提交压缩为单个提交（例如，首次公开发布项目时），请尝试：</target>
        </trans-unit>
        <trans-unit id="f827f77438492c15d0d2aa806bcc35f58430f25e" translate="yes" xml:space="preserve">
          <source>If you want to start editing the new commit message with a concatenation of the existing commit messages (i.e. similar to what a pick/squash/squash/&amp;hellip;/squash &lt;code&gt;git rebase -i&lt;/code&gt; instruction list would start you with), then you need to extract those messages and pass them to &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">如果要开始使用现有提交消息的串联来编辑新的提交消息（即类似于pick / squash / squash /&amp;hellip;/ squash &lt;code&gt;git rebase -i&lt;/code&gt; 指令列表的开头），则需要提取这些消息并将它们传递给 &lt;code&gt;git commit&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="088b19cf941b3ff8da3b7eb151f8d881f3db1fff" translate="yes" xml:space="preserve">
          <source>If you want to write the new commit message from scratch, this suffices:</source>
          <target state="translated">如果你想从头开始写新的提交信息,这个就足够了。</target>
        </trans-unit>
        <trans-unit id="79f1ff9673cb765c19eb55c4d649e27cf47e1e06" translate="yes" xml:space="preserve">
          <source>If you're working with GitLab, you can just click the Squash option in the Merge Request as shown below. The commit message will be the title of the Merge Request.</source>
          <target state="translated">如果你使用GitLab,你可以直接点击合并请求中的Squash选项,如下图所示。提交消息将是合并请求的标题。</target>
        </trans-unit>
        <trans-unit id="a017ecd71bf7f57fd4ca564c4f4814ffbbbd55eb" translate="yes" xml:space="preserve">
          <source>In addition to other excellent answers, I'd like to add how &lt;code&gt;git rebase -i&lt;/code&gt; always confuses me with the commit order - older to newer one or vice versa? So this is my workflow:</source>
          <target state="translated">除了其他出色的答案，我想补充一下 &lt;code&gt;git rebase -i&lt;/code&gt; 总是使我对提交顺序感到困惑-从旧到新，反之亦然？ 这是我的工作流程：</target>
        </trans-unit>
        <trans-unit id="e0c5c08fbe43f01fe7feb65bad1556407d8bf81f" translate="yes" xml:space="preserve">
          <source>In my case, I want to squash everything on the commit that was first in time. The ordering is from first to last, so exactly the other way as in &lt;code&gt;git log&lt;/code&gt;. In my case, I want:</source>
          <target state="translated">就我而言，我想压缩第一次提交中的所有内容。 顺序是 &lt;code&gt;git log&lt;/code&gt; ，与git log中的顺序完全相反。 就我而言，我想要：</target>
        </trans-unit>
        <trans-unit id="812b8ce0a931bda8d43ab639459be7c06897670f" translate="yes" xml:space="preserve">
          <source>In my workflow, I start a branch, and my first commit on that branch summarizes the goal (i.e. it's usually what I will push as the 'final' message for the feature to the public repository.)  So when I'm done, all I want to do is &lt;code&gt;git squash master&lt;/code&gt; back to the first message and then I'm ready to push.</source>
          <target state="translated">在我的工作流程中，我启动了一个分支，并且对该分支的第一次提交总结了目标（即通常是我将其作为功能的&amp;ldquo;最终&amp;rdquo;消息推送到公共存储库的内容。）我想做的是将 &lt;code&gt;git squash master&lt;/code&gt; 回到第一条消息，然后我准备推送。</target>
        </trans-unit>
        <trans-unit id="cfebaa62652e8409b9f3689f76707285002e6e2c" translate="yes" xml:space="preserve">
          <source>In question it could be ambiguous what is meant by &quot;last&quot;.</source>
          <target state="translated">问题是,&quot;最后 &quot;的意思可能是含糊不清。</target>
        </trans-unit>
        <trans-unit id="9306409d13d02f1d92a630f721830c055b515fbf" translate="yes" xml:space="preserve">
          <source>In the branch you would like to combine the commits on, run:</source>
          <target state="translated">在你想结合提交的分支中,运行。</target>
        </trans-unit>
        <trans-unit id="88c73138cde2bf54e60255d9bd740e5e58d9f261" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past the command is &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; 是SHA1哈希或当前分支的HEAD的相对位置，从该分支分析提交的rebase命令。 例如，如果用户过去希望查看当前HEAD的5个提交，则命令为 &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b0babcfbdf70396a1070d18ba28e5456936528f" translate="yes" xml:space="preserve">
          <source>In this very abbreviated history of the &lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt; repository you have opened a pull request to merge in the the Bill Clinton commit into the original (&lt;code&gt;MASTER&lt;/code&gt;) Fleetwood Mac commit.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt;存储库的这段非常简短的历史记录中，您已经打开了pull请求，以将Bill Clinton提交合并到原始的Fleetwood Mac提交中。</target>
        </trans-unit>
        <trans-unit id="bf126b3fade88997f0548ade26b8b5c4bfea4c6b" translate="yes" xml:space="preserve">
          <source>It's possible to use rebase but in different manner then in others mentioned answers:</source>
          <target state="translated">它可以使用rebase,但方式不同,然后在其他人提到的答案。</target>
        </trans-unit>
        <trans-unit id="028bc2366d79ea4ef91789bfa66ae316236a417d" translate="yes" xml:space="preserve">
          <source>LA1974</source>
          <target state="translated">LA1974</target>
        </trans-unit>
        <trans-unit id="fb2a8991936042159a3bb1d749bea91292a31069" translate="yes" xml:space="preserve">
          <source>Lastly, I run</source>
          <target state="translated">最后,我跑</target>
        </trans-unit>
        <trans-unit id="57fe6ea67ceef51616f8ae62d6f8e1cb4229da2f" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;git commit&lt;/code&gt; that warps directly from the &lt;em&gt;from&lt;/em&gt; to the &lt;em&gt;to&lt;/em&gt;</source>
          <target state="translated">进行 &lt;code&gt;git commit&lt;/code&gt; ，直接从&lt;em&gt;from&lt;/em&gt;变形到&lt;em&gt;to&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49e92ccd1adc445eb977e8a994e8fd9adc2bc217" translate="yes" xml:space="preserve">
          <source>Mark the relevant commits in the log view</source>
          <target state="translated">在日志视图中标记相关的提交</target>
        </trans-unit>
        <trans-unit id="0fc0ad9a332750ab53c934b71eb3800bf3e4909a" translate="yes" xml:space="preserve">
          <source>My 'dev' branch was ahead of 'origin/dev' by 96 commits (so these commits were not pushed to the remote yet).</source>
          <target state="translated">我的'dev'分支比'origindev'提前了96个提交(所以这些提交还没有推送到远程)。</target>
        </trans-unit>
        <trans-unit id="8293f55e479d0410deb525c2426e813f0803e546" translate="yes" xml:space="preserve">
          <source>Next, I bring up the interactive rebase editor with &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt;.  The &lt;code&gt;~&lt;/code&gt; after the commit SHA tells the editor to include that commit in the editor.</source>
          <target state="translated">接下来，我使用 &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt; 出交互式rebase编辑器。 提交后的〜SHA告诉编辑器将该提交包含在编辑器中。</target>
        </trans-unit>
        <trans-unit id="a6117317363c016a257f2208f2a02cd8432aaabc" translate="yes" xml:space="preserve">
          <source>Next, I move the commit containing the fix (&lt;code&gt;fe7f1e0&lt;/code&gt;) to underneath the feature commit, and change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;fixup&lt;/code&gt;.</source>
          <target state="translated">接下来，我将包含修订的提交（ &lt;code&gt;fe7f1e0&lt;/code&gt; ）移动到功能提交的下方，并将 &lt;code&gt;pick&lt;/code&gt; 更改为 &lt;code&gt;fixup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8423bc929eacf6c5159737bd94c0cbd3c5778996" translate="yes" xml:space="preserve">
          <source>Note : This is based on using git on &lt;code&gt;ubuntu&lt;/code&gt; shell. If you are using different os (&lt;code&gt;Windows&lt;/code&gt; or &lt;code&gt;Mac&lt;/code&gt;) then above commands are same except editor. You might get different editor.</source>
          <target state="translated">注意：这是基于在 &lt;code&gt;ubuntu&lt;/code&gt; shell上使用git的基础。 如果您使用不同的操作系统（ &lt;code&gt;Windows&lt;/code&gt; 或 &lt;code&gt;Mac&lt;/code&gt; ），则除了编辑器外，上述命令相同。 您可能会获得不同的编辑器。</target>
        </trans-unit>
        <trans-unit id="20b053a3e9165bb14f6a88287ca972e8a2dce8ee" translate="yes" xml:space="preserve">
          <source>Note: The resultant commit message is a combination of all the squashed commits, in order. If you are unhappy with that, you can always &lt;code&gt;git commit --amend&lt;/code&gt; to modify it manually. (Or, edit the alias to match your tastes.)</source>
          <target state="translated">注意：结果提交消息按顺序是所有压缩的提交的组合。 如果您对此不满意，可以随时使用 &lt;code&gt;git commit --amend&lt;/code&gt; 手动修改它。 （或者，编辑别名以符合您的口味。）</target>
        </trans-unit>
        <trans-unit id="d6377f9be4e13e6d8f9e38c5003db9b8ab9af614" translate="yes" xml:space="preserve">
          <source>Now this creates a new commit on top of HEAD with &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，这会使用 &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt; 在HEAD上创建一个新提交。</target>
        </trans-unit>
        <trans-unit id="48a3a5484c6d47719f56ef39bf6dd2a38a49336a" translate="yes" xml:space="preserve">
          <source>Now use</source>
          <target state="translated">现在用</target>
        </trans-unit>
        <trans-unit id="3b3a3e1be78f40ef46e629b130884d7de89ba488" translate="yes" xml:space="preserve">
          <source>Open TortoiseGit context menu</source>
          <target state="translated">打开TortoiseGit上下文菜单</target>
        </trans-unit>
        <trans-unit id="a5015e7e2cecbb5b2a96a0da08d780166899f93a" translate="yes" xml:space="preserve">
          <source>P.S. If you just do some reset to BO: 
(for example, using &lt;code&gt;reset --mixed&lt;/code&gt; that is explained in more detail here &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https://stackoverflow.com/a/18690845/2405850&lt;/a&gt;):</source>
          <target state="translated">PS：如果您只是对BO进行了一些重置：（例如，使用 &lt;code&gt;reset --mixed&lt;/code&gt; ，请在这里&lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https://stackoverflow.com/a/18690845/2405850&lt;/a&gt;进行详细说明）：</target>
        </trans-unit>
        <trans-unit id="e8df79c1f7f324f7ea12be589f8d4145c0fff656" translate="yes" xml:space="preserve">
          <source>PR and merge TO master &lt;em&gt;by reviewer&lt;/em&gt;.
(Yes, it would be easier for the developer to &lt;code&gt;merge --squash&lt;/code&gt; after the PR, but the team thought that would slow down the process.)</source>
          <target state="translated">公关&lt;em&gt;并由审稿人&lt;/em&gt;合并为硕士。 （是的，在PR之后，开发人员 &lt;code&gt;merge --squash&lt;/code&gt; 会更容易，但是团队认为这样做会减慢该过程。）</target>
        </trans-unit>
        <trans-unit id="7e84941f3d4a75c0dc177c26e3d8294131e792e3" translate="yes" xml:space="preserve">
          <source>Procedure 1</source>
          <target state="translated">程序一</target>
        </trans-unit>
        <trans-unit id="9d3b7680f495af80fe40294525dfe378fc4a6043" translate="yes" xml:space="preserve">
          <source>Procedure 2</source>
          <target state="translated">程序2</target>
        </trans-unit>
        <trans-unit id="2c937bebe0ed8ae169f2202e531a6094c90fee0c" translate="yes" xml:space="preserve">
          <source>Push the branch to your local repository</source>
          <target state="translated">将分支推送到你的本地版本库</target>
        </trans-unit>
        <trans-unit id="a73eccc33144570add3bc96c79ccd1f27423bf72" translate="yes" xml:space="preserve">
          <source>Push the change to a particular branch</source>
          <target state="translated">将更改推送到特定的分支</target>
        </trans-unit>
        <trans-unit id="ca87402c617e64e22c3d7193a1f96b2b02c17659" translate="yes" xml:space="preserve">
          <source>Put squash instead of pick to H0:</source>
          <target state="translated">把壁球而不是挑到H0。</target>
        </trans-unit>
        <trans-unit id="260756bf22f9f993d1bc033875848a9357f0d969" translate="yes" xml:space="preserve">
          <source>Put the to-be-squashed commits on a working branch (if they aren't already) -- use gitk for this</source>
          <target state="translated">把即将被取消的提交放在一个工作分支上(如果还没有的话)----用gitk来做这个。</target>
        </trans-unit>
        <trans-unit id="9e66b40d5e26b8f80f7e041f81061eb7ad61a1b5" translate="yes" xml:space="preserve">
          <source>Reviewer does PR and merges to master.</source>
          <target state="translated">审稿人做PR,并合并到主人。</target>
        </trans-unit>
        <trans-unit id="8c3a77045a4803d7837f166a12ee9caf303269a1" translate="yes" xml:space="preserve">
          <source>See where you are with &lt;code&gt;git log&lt;/code&gt;. Most important, find the commit hash of the first commit you &lt;em&gt;don't&lt;/em&gt; want to squash. So only the :</source>
          <target state="translated">使用 &lt;code&gt;git log&lt;/code&gt; 查看您的位置。 最重要的是，找到您&lt;em&gt;不想&lt;/em&gt;压榨的第一个提交的提交哈希。 所以只有：</target>
        </trans-unit>
        <trans-unit id="a2da3b6230bae4fd68ed9664dced96244baa2508" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Combine to one commit&lt;/code&gt; from the context menu</source>
          <target state="translated">从上下文菜单中选择&amp;ldquo; &lt;code&gt;Combine to one commit&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="eab195238ec47a36730ecb88741d15affc592ef0" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Show Log&lt;/code&gt;</source>
          <target state="translated">选择 &lt;code&gt;Show Log&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef5af955bf451fa0bf9ce8667bb1749136652a01" translate="yes" xml:space="preserve">
          <source>Simple one-liner that always works, given that you are currently on the branch you want to squash, master is the branch it originated from, and the latest commit contains the commit message and author you wish to use:</source>
          <target state="translated">简单的单行本,考虑到你当前正在你想要压榨的分支上,master是它的分支,而最新的提交包含了你希望使用的提交信息和作者。</target>
        </trans-unit>
        <trans-unit id="48e87018ba090a96eb3b4261c69ab3bc1688ba76" translate="yes" xml:space="preserve">
          <source>So the 2nd procedure helps to merge the commit to very old commit easily.</source>
          <target state="translated">所以第2个过程有助于将提交合并到非常老的提交中。</target>
        </trans-unit>
        <trans-unit id="1606820c64383f2678929b220f43c62392e4802a" translate="yes" xml:space="preserve">
          <source>So, this seems to work for us.</source>
          <target state="translated">所以,这似乎对我们来说是可行的。</target>
        </trans-unit>
        <trans-unit id="c65f5cec26fdf510a411914b43897da6b752dc54" translate="yes" xml:space="preserve">
          <source>Sources &amp;amp; additional reads: &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;#1&lt;/a&gt;, &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;#2&lt;/a&gt;.</source>
          <target state="translated">来源和其他读物： &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;＃1&lt;/a&gt; ， &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;＃2&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7fe78756ce38b0a0104a04e440f7455dc5041f0" translate="yes" xml:space="preserve">
          <source>Squash merge with your local branch that you have already</source>
          <target state="translated">壁球与您已经在当地的分支机构合并</target>
        </trans-unit>
        <trans-unit id="f250854c3f99d28c958f70dce4dd6eb4cb062123" translate="yes" xml:space="preserve">
          <source>Squash my last X commits together using Git</source>
          <target state="translated">用Git把我最后一次提交的X提交挤在一起了。</target>
        </trans-unit>
        <trans-unit id="fa32bacb7f009d82ac949dca9b0e80d1d0dbd93c" translate="yes" xml:space="preserve">
          <source>Step 0: git log</source>
          <target state="translated">第0步:git日志</target>
        </trans-unit>
        <trans-unit id="8e0ca5bd90136b4a7b027927451c19e1f346a18b" translate="yes" xml:space="preserve">
          <source>Step 1: git rebase</source>
          <target state="translated">步骤1:git rebase</target>
        </trans-unit>
        <trans-unit id="d7eb36401823c9a736a592ee2155703f797e50da" translate="yes" xml:space="preserve">
          <source>Step 2: pick / squash what you want</source>
          <target state="translated">第二步:挑选你想要的南瓜</target>
        </trans-unit>
        <trans-unit id="a5e2c10a701fc35282279ec7765f80119e96ce60" translate="yes" xml:space="preserve">
          <source>Step 3: Adjust message(s)</source>
          <target state="translated">第三步:调整信息</target>
        </trans-unit>
        <trans-unit id="7692952e23e9867e52383f181dfe0cb65c218f1d" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;this handy blog post&lt;/a&gt; I found that you can use this command to squash the last 3 commits:</source>
          <target state="translated">感谢&lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;这篇方便的博客文章，&lt;/a&gt;我发现您可以使用此命令来压缩最近的3次提交：</target>
        </trans-unit>
        <trans-unit id="06fa56961a9b1119f58d05a3eea1f250493fd074" translate="yes" xml:space="preserve">
          <source>That's it. Once you save this (&lt;code&gt;:wq&lt;/code&gt;), you're done. Have a look at it with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">而已。 保存此（ &lt;code&gt;:wq&lt;/code&gt; ）后，就完成了。 用 &lt;code&gt;git log&lt;/code&gt; 看一下。</target>
        </trans-unit>
        <trans-unit id="ad8a077aa099078c8cbac44ec84ae98b2cd4e20e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;documentation for &lt;code&gt;git merge&lt;/code&gt;&lt;/a&gt; describes the &lt;code&gt;--squash&lt;/code&gt; option in more detail.</source>
          <target state="translated">&lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt; &lt;code&gt;git merge&lt;/code&gt; &lt;/a&gt;的文档更详细地介绍了 &lt;code&gt;--squash&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="0e607204ccc0308b417695ca633595dcad436b1d" translate="yes" xml:space="preserve">
          <source>The command will open the interactive rebase editor which then allows you to reorder, squash, reword, etc as per normal.</source>
          <target state="translated">该命令将打开交互式的rebase编辑器,然后你可以按照正常的方式重新排序、压扁、重写等。</target>
        </trans-unit>
        <trans-unit id="925d19add6cc8a59abd536b73f79b247585837ee" translate="yes" xml:space="preserve">
          <source>The commit message will be prepopulated based on the squash.</source>
          <target state="translated">提交的消息将根据压箱底预填充。</target>
        </trans-unit>
        <trans-unit id="8a6719516ac538e9ed622d11335500e260fc9964" translate="yes" xml:space="preserve">
          <source>The documentation displayed is pretty clear.  On any given line you can change the command from &lt;code&gt;pick&lt;/code&gt; to a command of your choice.</source>
          <target state="translated">显示的文档非常清晰。 在任何给定的行上，您都可以将命令从 &lt;code&gt;pick&lt;/code&gt; 更改为您选择的命令。</target>
        </trans-unit>
        <trans-unit id="6c4ad30909bb83a10ddf48ebb81e1d7adda4edf0" translate="yes" xml:space="preserve">
          <source>The first thing I do is fix the mistake and make a new commit with the comment &lt;code&gt;squash this into my new feature!&lt;/code&gt;.</source>
          <target state="translated">我要做的第一件事是修复错误，并使用注释将其提交 &lt;code&gt;squash this into my new feature!&lt;/code&gt; 进行新的提交！ 。</target>
        </trans-unit>
        <trans-unit id="5a54a921df7a18b8fa7bcbb17b04135a3f9ca0a4" translate="yes" xml:space="preserve">
          <source>The interactive rebase editor shows the last three commits.  This constraint was determined by &lt;code&gt;HEAD~3&lt;/code&gt; when running the command &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt;.</source>
          <target state="translated">交互式基础编辑器显示最后三个提交。 当运行命令 &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt; 时，此约束由 &lt;code&gt;HEAD~3&lt;/code&gt; 确定。</target>
        </trans-unit>
        <trans-unit id="40de1d7485f29f3c3927203644f6993e9c59eb2c" translate="yes" xml:space="preserve">
          <source>The most recent commit, &lt;code&gt;HEAD&lt;/code&gt;, is displayed first on line 1.  The lines starting with a &lt;code&gt;#&lt;/code&gt; are comments/documentation.</source>
          <target state="translated">最新提交 &lt;code&gt;HEAD&lt;/code&gt; 最初显示在第1行。以 &lt;code&gt;#&lt;/code&gt; 开头的行是注释/文档。</target>
        </trans-unit>
        <trans-unit id="15bd41701489226c2dce4509a6fee4be4aa552ba" translate="yes" xml:space="preserve">
          <source>The problem is that H0 contains H1 and H2 (and generally more commits before merge and after branching) while B0 don't. So you have to manage changes from H0, merge, H1, H2, B0 at least.</source>
          <target state="translated">问题是,H0包含H1和H2(一般来说合并前和分支后的提交比较多),而B0没有。所以你至少要管理好H0、合并、H1、H2、B0的变更。</target>
        </trans-unit>
        <trans-unit id="6331cadceddf56d7aa2077447230eea2f9a842c7" translate="yes" xml:space="preserve">
          <source>Then commit using &lt;code&gt;--fixup&lt;/code&gt; option and the &lt;code&gt;OLDCOMMIT&lt;/code&gt; should be on which we need to merge(squash) this commit.</source>
          <target state="translated">然后使用 &lt;code&gt;--fixup&lt;/code&gt; 选项提交， &lt;code&gt;OLDCOMMIT&lt;/code&gt; 应该在OLDCOMMIT上合并（挤压）此提交。</target>
        </trans-unit>
        <trans-unit id="625c194045dd72da9dae9e8a5696dc4cd84a15ed" translate="yes" xml:space="preserve">
          <source>Then execute below command to merge(squash) the new commit to the &lt;code&gt;OLDCOMMIT&lt;/code&gt;.</source>
          <target state="translated">然后执行以下命令以合并（ &lt;code&gt;OLDCOMMIT&lt;/code&gt; ）对OLDCOMMIT的新提交。</target>
        </trans-unit>
        <trans-unit id="63a925126395e6b2ebaae2cf1711a295f24f5b5f" translate="yes" xml:space="preserve">
          <source>Then last commits by time are H0, merge, B0. To squash them you will have to rebase your merged branch on commit H1.</source>
          <target state="translated">那么最后的提交按时间划分为H0、merge、B0。要把它们压制掉,你必须把合并后的分支重新建立在提交H1上。</target>
        </trans-unit>
        <trans-unit id="4b5c4a5092abbae0b51b1df123053bf15993a9f0" translate="yes" xml:space="preserve">
          <source>Then to continue the rebase:</source>
          <target state="translated">然后再继续重做基础。</target>
        </trans-unit>
        <trans-unit id="cec55a62a50d094219c9ed6c3d7233b58b9df6cd" translate="yes" xml:space="preserve">
          <source>Then you have all of the changes ready to commit.</source>
          <target state="translated">然后,你已经准备好了所有的修改,可以提交了。</target>
        </trans-unit>
        <trans-unit id="546b13232526f68926882878963e76932c04582d" translate="yes" xml:space="preserve">
          <source>Then, I create another branch based out my-feature branch, keep &lt;code&gt;my-feature&lt;/code&gt; branch untouched.</source>
          <target state="translated">然后，我基于我的功能分支创建另一个分支，保持 &lt;code&gt;my-feature&lt;/code&gt; 分支不变。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="a14755fe0a2432949166566a2c3b293cbb3334a8" translate="yes" xml:space="preserve">
          <source>Thinking that nobody would ever care to read the full repository history. (There actually is a repository, click the link above!) You decide to squash these commits. So you go and run &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt;. Then you &lt;code&gt;git push --force&lt;/code&gt; it onto GitHub to clean up your PR.</source>
          <target state="translated">认为没有人会愿意阅读完整的存储库历史记录。 （实际上有一个存储库，请单击上面的链接！）您决定压缩这些提交。 所以你去运行 &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt; 。 然后您 &lt;code&gt;git push --force&lt;/code&gt; 将其强制到GitHub上以清理您的PR。</target>
        </trans-unit>
        <trans-unit id="e8779d0790a0a6c1a85e49564ee8661d2563c832" translate="yes" xml:space="preserve">
          <source>This function automatically executes all necessary single git steps.
Unfortunatly only available for Windows.</source>
          <target state="translated">这个功能可以自动执行所有必要的单次git步骤。不幸的是,该功能只适用于Windows系统。</target>
        </trans-unit>
        <trans-unit id="4fad2e44fdb033a06b3f6360d78eb01c683e6c42" translate="yes" xml:space="preserve">
          <source>This is handy as it works even when you are on a local branch with no tracking information/remote repo.</source>
          <target state="translated">这很方便,因为即使你在没有跟踪信息remote repo的本地分支上也能正常工作。</target>
        </trans-unit>
        <trans-unit id="084858599aa0e25ed248f7286a555ac974946b7c" translate="yes" xml:space="preserve">
          <source>This is super-duper kludgy, but in a kind of cool way, so I'll just toss it into the ring:</source>
          <target state="translated">这是超级笨手笨脚的,但有种酷炫的感觉,所以我就把它扔进戒指里吧。</target>
        </trans-unit>
        <trans-unit id="bfd5d4a30f5a6bd68aea5b76c13d7f98cd5ab3ed" translate="yes" xml:space="preserve">
          <source>This will dump the history being squashed before it does so&amp;mdash;this gives you a chance to recover by grabbing an old commit ID off the console if you want to revert.  (Solaris users note it uses the GNU sed &lt;code&gt;-i&lt;/code&gt; option, Mac and Linux users should be fine with this.)</source>
          <target state="translated">这将在此之前转储被压缩的历史记录，这使您有机会通过还原控制台中的旧提交ID来进行恢复。 （Solaris用户注意到它使用了GNU sed &lt;code&gt;-i&lt;/code&gt; 选项，Mac和Linux用户应该可以使用此选项。）</target>
        </trans-unit>
        <trans-unit id="dc92e0bbd27c7f53e720875e6878c42bc7b99b1c" translate="yes" xml:space="preserve">
          <source>This will open the text editor and you must switch the 'pick' in front of each commit with 'squash' if you would like these commits to be merged together. From documentation:</source>
          <target state="translated">这将打开文本编辑器,如果你想让这些提交合并在一起,你必须把每个提交前面的 &quot;pick &quot;换成 &quot;squash&quot;。来自于文档。</target>
        </trans-unit>
        <trans-unit id="876cf8ee642d0b29004c0d70c60d3ce90f399a68" translate="yes" xml:space="preserve">
          <source>This will show you choice options (as mentioned in other answers):</source>
          <target state="translated">这样就可以看到选择题的选项(如其他答案中提到的)。</target>
        </trans-unit>
        <trans-unit id="d2bce6c83325757e7a54433a83c6e7084810007e" translate="yes" xml:space="preserve">
          <source>This works well when all the commits are local, but if you try to change any commits already pushed to the remote you can really cause problems for other devs that have checked out the same branch!</source>
          <target state="translated">当所有的提交都是本地提交时,这个方法很好用,但如果你试图修改任何已经推送到远程的提交,就会给其他已经检查出同一分支的开发者带来麻烦!如果你的提交都是本地提交,那么你就会发现你的提交会有问题。</target>
        </trans-unit>
        <trans-unit id="1dbe8ac5ab79108392c62a34cf9417a1ac8ae9c7" translate="yes" xml:space="preserve">
          <source>To do this you can use following git command.</source>
          <target state="translated">要做到这一点,你可以使用以下git命令。</target>
        </trans-unit>
        <trans-unit id="603b6f4899ba5a0c325455ae848805098f30ac76" translate="yes" xml:space="preserve">
          <source>To squash the last 10 commits into 1 single commit:</source>
          <target state="translated">要把最后10个承诺压成1个单一承诺。</target>
        </trans-unit>
        <trans-unit id="d453af1b2806f0771f8120f5f48b125b16f17109" translate="yes" xml:space="preserve">
          <source>Translation: provide a new &quot;editor&quot; for git which, if the filename to be edited is &lt;code&gt;git-rebase-todo&lt;/code&gt; (the interactive rebase prompt) changes all but the first &quot;pick&quot; to &quot;squash&quot;, and otherwise spawns vim - so that when you're prompted to edit the squashed commit message, you get vim. (And obviously I was squashing the last five commits on branch foo, but you could change that however you like.)</source>
          <target state="translated">翻译：为git提供一个新的&amp;ldquo;编辑器&amp;rdquo;，如果要编辑的文件名是 &lt;code&gt;git-rebase-todo&lt;/code&gt; （交互式变基提示），则将除了第一个&amp;ldquo; pick&amp;rdquo;之外的所有内容都更改为&amp;ldquo; squash&amp;rdquo;，否则生成vim-这样当系统提示您编辑压缩的提交消息时，您将获得vim。 （很明显，我在foo分支上压缩了最后五个commit，但是您可以根据需要更改它。）</target>
        </trans-unit>
        <trans-unit id="2e04cd50a2d8a6e325a64a9e9d1e89bf9850e0a7" translate="yes" xml:space="preserve">
          <source>Update like below &lt;code&gt;pick&lt;/code&gt; one commit and &lt;code&gt;squash&lt;/code&gt; the others into the most recent,</source>
          <target state="translated">像下面这样更新， &lt;code&gt;pick&lt;/code&gt; 一个提交并将其他提交 &lt;code&gt;squash&lt;/code&gt; 到最近一次，</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="10c4aabc7d6d07adf02cb1c2e40e88d5732500a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; and replace &quot;pick&quot; on the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;, as described in &lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;the manual&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; ,并在第二次及以后的提交中将&amp;ldquo; pick&amp;rdquo;替换为&amp;ldquo; squash&amp;rdquo;或&amp;ldquo; fixup&amp;rdquo;，如&lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;手册&lt;/a&gt;中所述 。</target>
        </trans-unit>
        <trans-unit id="1f1b9ab9a0e0959c8d60301c1dd590795036c32e" translate="yes" xml:space="preserve">
          <source>WARNING: First make sure you commit your work&amp;mdash;check that &lt;code&gt;git status&lt;/code&gt; is clean (since &lt;code&gt;git reset --hard&lt;/code&gt; will throw away staged and unstaged changes)</source>
          <target state="translated">警告：首先请确保您已完成工作-检查 &lt;code&gt;git status&lt;/code&gt; 是否干净（由于 &lt;code&gt;git reset --hard&lt;/code&gt; 将丢弃暂存和未暂存的更改）</target>
        </trans-unit>
        <trans-unit id="52065276a52b15005dd5aee61d9b2417c0b2ced8" translate="yes" xml:space="preserve">
          <source>What about an answer for the question related to a workflow like this?</source>
          <target state="translated">这样的工作流程相关问题的答案呢?</target>
        </trans-unit>
        <trans-unit id="387737056476baadea4c3b6310eccb9d5e50141c" translate="yes" xml:space="preserve">
          <source>What can be really convenient:</source>
          <target state="translated">能真正方便的是。</target>
        </trans-unit>
        <trans-unit id="765789c174c2479941c09177922e1d21cc6827fc" translate="yes" xml:space="preserve">
          <source>What i did is</source>
          <target state="translated">我所做的是</target>
        </trans-unit>
        <trans-unit id="d21b0bcb168b83ca89e96c0b658ad9d3fc1df640" translate="yes" xml:space="preserve">
          <source>When closing the editor, the fix will get squashed into the feature commit and my commit history will look nice and clean!</source>
          <target state="translated">当关闭编辑器时,这个修复会被挤到功能提交中,我的提交历史记录看起来会很干净漂亮!</target>
        </trans-unit>
        <trans-unit id="d4ceba0e28653571c383b8285d758678e129e217" translate="yes" xml:space="preserve">
          <source>You can do this fairly easily without &lt;code&gt;git rebase&lt;/code&gt; or &lt;code&gt;git merge --squash&lt;/code&gt;. In this example, we'll squash the last 3 commits.</source>
          <target state="translated">您可以很容易地做到这一点，而无需 &lt;code&gt;git rebase&lt;/code&gt; 或 &lt;code&gt;git merge --squash&lt;/code&gt; 。 在此示例中，我们将压缩最后3次提交。</target>
        </trans-unit>
        <trans-unit id="757adf068d4225d6c149a530d9e62dc3a26e1485" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git merge --squash&lt;/code&gt; for this, which is slightly more elegant than &lt;code&gt;git rebase -i&lt;/code&gt;.  Suppose you're on master and you want to squash the last 12 commits into one.</source>
          <target state="translated">您可以为此使用 &lt;code&gt;git merge --squash&lt;/code&gt; ，这比 &lt;code&gt;git rebase -i&lt;/code&gt; 稍微好一点。 假设您在master上，并且想要将最后12次提交压缩为1次。</target>
        </trans-unit>
        <trans-unit id="71fb008e5d4b8f4decb5fc1d8418a270127e8380" translate="yes" xml:space="preserve">
          <source>You may also change the order of the commits. This allows you to squash or fixup commits that are not adjacent chronologically.</source>
          <target state="translated">你也可以改变提交的顺序。这可以让您将不相邻的提交按时间顺序进行挤压或修复。</target>
        </trans-unit>
        <trans-unit id="f67e78ddf7e52bc3a80985eea97c30cace0d72aa" translate="yes" xml:space="preserve">
          <source>You opened a pull request and on GitHub you see this:</source>
          <target state="translated">你打开了一个pull请求,在GitHub上看到这样的内容。</target>
        </trans-unit>
        <trans-unit id="6f42ea37efb2330eb9f8ae87f778d2109ad00e3b" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;~/.gitconfig&lt;/code&gt; should now contain this alias:</source>
          <target state="translated">您的 &lt;code&gt;~/.gitconfig&lt;/code&gt; 现在应包含以下别名：</target>
        </trans-unit>
        <trans-unit id="758b9ac3be25f469194a9e3fd22799cf55e4cc10" translate="yes" xml:space="preserve">
          <source>edit and commit a lot locally, merge master regularly</source>
          <target state="translated">多编辑、多提交,定期合并主站</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="e0d33137a7b35fa4c2c656343c06f10e9f77b403" translate="yes" xml:space="preserve">
          <source>finally a push to remote,</source>
          <target state="translated">终于推到了远程。</target>
        </trans-unit>
        <trans-unit id="4b04d2a98dc3f0fd0b938cafe5761aa32fafe654" translate="yes" xml:space="preserve">
          <source>for example &lt;code&gt;git log --graph&lt;/code&gt; outputs the following (simplified):</source>
          <target state="translated">例如 &lt;code&gt;git log --graph&lt;/code&gt; 输出以下内容（简化）：</target>
        </trans-unit>
        <trans-unit id="d76620ae96c7ca431e1db5376c1cfcf85d087916" translate="yes" xml:space="preserve">
          <source>git commit</source>
          <target state="translated">吉特提交</target>
        </trans-unit>
        <trans-unit id="371e49a0b18c50d82d292aef71ea992421ef9133" translate="yes" xml:space="preserve">
          <source>git push origin (branch_name) --force</source>
          <target state="translated">git push origin (branch_name)--force</target>
        </trans-unit>
        <trans-unit id="56322e172fdd72aded4057a4a7b371ca73775805" translate="yes" xml:space="preserve">
          <source>git reset --soft Head~3 &amp;amp;&amp;amp;</source>
          <target state="translated">git reset --soft Head〜3 &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="946fc396fd4b258f758878e94fa72b2ed7382c42" translate="yes" xml:space="preserve">
          <source>if for example you want to squash the last 3 commits to a single commit in a branch(remote repository) in for example: &lt;a href=&quot;https://bitbucket.org&quot;&gt;https://bitbucket.org&lt;/a&gt;</source>
          <target state="translated">例如，如果您想将最后3次提交压缩为分支机构（远程存储库）中的单个提交，例如： &lt;a href=&quot;https://bitbucket.org&quot;&gt;https&lt;/a&gt; : //bitbucket.org</target>
        </trans-unit>
        <trans-unit id="611d5f9682115beec752b912992f91f4d6631a4e" translate="yes" xml:space="preserve">
          <source>many local commits, &lt;em&gt;mixed with multiple merges FROM master&lt;/em&gt;,</source>
          <target state="translated">许多本地提交， &lt;em&gt;混合有来自master的多个合并&lt;/em&gt; ，</target>
        </trans-unit>
        <trans-unit id="f1d1f78c97a0cfa141dba4aa92f53b7119108001" translate="yes" xml:space="preserve">
          <source>n(=4 here) is the number of last commit. Then you got following options,</source>
          <target state="translated">n(=4)是上次提交的次数。那么你有以下选项。</target>
        </trans-unit>
        <trans-unit id="a06e25653856f59ec61310038b0e76e461953e35" translate="yes" xml:space="preserve">
          <source>p, pick  = use commit</source>
          <target state="translated">p,pick=使用提交</target>
        </trans-unit>
        <trans-unit id="e4ae77df54121cf3234bc6148af99f1b9c9169e9" translate="yes" xml:space="preserve">
          <source>s, squash  = use commit, but meld into previous commit</source>
          <target state="translated">s,squash=使用提交,但合并到之前的提交中。</target>
        </trans-unit>
        <trans-unit id="f60c1a720971c0a3baf938460a4d4f212174afca" translate="yes" xml:space="preserve">
          <source>the editor pops up again with a default message for the new commit: change it to your needs, save and close. Squash completed!</source>
          <target state="translated">编辑器会再次弹出新提交的默认信息:根据自己的需要修改,保存并关闭。Squash完成!</target>
        </trans-unit>
        <trans-unit id="14373bc7f8d111bad35942b43a801f430a7d6401" translate="yes" xml:space="preserve">
          <source>the editor pops up, showing the list of commits I want to merge. Now they are displayed in &lt;em&gt;reverse order&lt;/em&gt;: the older commit is on top. Mark as &quot;squash&quot; or &quot;s&quot; all the commits in there &lt;em&gt;except the first/older one&lt;/em&gt;: it will be used as a starting point. Save and close the editor;</source>
          <target state="translated">编辑器弹出，显示我要合并的提交列表。 现在，它们以&lt;em&gt;相反的顺序&lt;/em&gt;显示：较早的提交位于顶部。 将其中的所有提交标记为&amp;ldquo; squash&amp;rdquo;或&amp;ldquo; s&amp;rdquo;， &lt;em&gt;除了第一个/较旧&lt;/em&gt;的提交&lt;em&gt;之外&lt;/em&gt; ：它将用作起点。 保存并关闭编辑器；</target>
        </trans-unit>
        <trans-unit id="fdadc9f4e4d7f36a7d4ff5b5e8ef900c37504ed9" translate="yes" xml:space="preserve">
          <source>then you squash into B0 changes of H0, H1, H2 (losing completely commits for changes after branching and before merge.</source>
          <target state="translated">然后你把H0、H1、H2的变化压成B0(分支后和合并前的变化完全失去提交)。</target>
        </trans-unit>
        <trans-unit id="857ce54ac9c9e1932a376ea4c0ed0fa4f8b713ad" translate="yes" xml:space="preserve">
          <source>where the number of ^'s is X</source>
          <target state="translated">其中^'s的数量为X</target>
        </trans-unit>
        <trans-unit id="9cd599249730cbcaaa3eaaca4c150509b03fe784" translate="yes" xml:space="preserve">
          <source>⚠️ WARNING: &quot;My last X commits&quot; might be ambiguous.</source>
          <target state="translated">⚠️ 警告:&quot;我最后的X次提交 &quot;可能会有歧义。</target>
        </trans-unit>
        <trans-unit id="257eca43111b6053a03fada07551d11187f131cc" translate="yes" xml:space="preserve">
          <source>🐻 MORAL OF THE STORY</source>
          <target state="translated">🐻故事的寓意</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
