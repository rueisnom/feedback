<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/5189560">
    <body>
      <group id="5189560">
        <trans-unit id="0f6e71b1a03ea4118f8aca590d18524c56b24e91" translate="yes" xml:space="preserve">
          <source>(in this case, squash the two last commits)</source>
          <target state="translated">(この場合は最後の2つのコミットをつぶす)</target>
        </trans-unit>
        <trans-unit id="00a75dfc6a363821c165dda8663912f8b12308bb" translate="yes" xml:space="preserve">
          <source>... Which automatically squashes together the last &lt;code&gt;N&lt;/code&gt; commits, inclusive.</source>
          <target state="translated">...最後の &lt;code&gt;N&lt;/code&gt; 個のコミットを含めて、自動的につぶします。</target>
        </trans-unit>
        <trans-unit id="e912fb518c6c899659dd36fc58ca72800c398da1" translate="yes" xml:space="preserve">
          <source>... or using Windows' Command Prompt:</source>
          <target state="translated">...または Windows のコマンドプロンプトを使用します。</target>
        </trans-unit>
        <trans-unit id="f9868bd7af9ea1a05d5a2cc3db7e9e630cb95cb1" translate="yes" xml:space="preserve">
          <source>1) Identify the commit short hash</source>
          <target state="translated">1)コミットショートハッシュを識別する</target>
        </trans-unit>
        <trans-unit id="a266d1bf09d724f5e01d17ae11e07a3b904343ee" translate="yes" xml:space="preserve">
          <source>1) git reset --soft HEAD~2 &amp;amp;&amp;amp; git commit -m&quot;&lt;strong&gt;message&lt;/strong&gt;&quot;</source>
          <target state="translated">1）git reset --soft HEAD〜2 &amp;amp;&amp;amp; git commit -m &quot; &lt;strong&gt;メッセージ&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="31bac7a25e633d602c5f07d013cf5bad6b5c8e6d" translate="yes" xml:space="preserve">
          <source>2) If you want to squash (merge) last two commit</source>
          <target state="translated">2)最後の2つのコミットを(マージして)潰したい場合</target>
        </trans-unit>
        <trans-unit id="cbd711953c1351ee6a5326f8709d2fa00a65e56d" translate="yes" xml:space="preserve">
          <source>2) git push</source>
          <target state="translated">2)git push</target>
        </trans-unit>
        <trans-unit id="ea65c50e6ab609f46f3b9dff142c828dcb7a2b4c" translate="yes" xml:space="preserve">
          <source>3) This opens up a &lt;code&gt;nano&lt;/code&gt; editor for merging. And it looks like below</source>
          <target state="translated">3）これにより、マージ用の &lt;code&gt;nano&lt;/code&gt; エディターが開きます。 そして、それは以下のように見えます</target>
        </trans-unit>
        <trans-unit id="78b84c9eba8b454d71ff15e78d7b205c76275eca" translate="yes" xml:space="preserve">
          <source>4) Rename the word &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; which is present before &lt;code&gt;abcd1234&lt;/code&gt;. After rename it should be like below.</source>
          <target state="translated">4）単語 &lt;code&gt;pick&lt;/code&gt; の名前を &lt;code&gt;abcd1234&lt;/code&gt; の前にある &lt;code&gt;squash&lt;/code&gt; に変更します 。 名前を変更すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="71b14741158ee8ef04c0060e1f8a21f8fb3b1e25" translate="yes" xml:space="preserve">
          <source>5) Now save and close the &lt;code&gt;nano&lt;/code&gt; editor. Press &lt;code&gt;ctrl + o&lt;/code&gt; and press &lt;code&gt;Enter&lt;/code&gt; to save. And then press &lt;code&gt;ctrl + x&lt;/code&gt; to exit the editor.</source>
          <target state="translated">5） &lt;code&gt;nano&lt;/code&gt; エディターを保存して閉じます。 保存するには、 &lt;code&gt;ctrl + o&lt;/code&gt; &lt;code&gt;Enter&lt;/code&gt; を押してからEnterキーを押します。 そして、 &lt;code&gt;ctrl + x&lt;/code&gt; を押してエディターを終了します。</target>
        </trans-unit>
        <trans-unit id="85cf74b710242b910482c040916448edae877361" translate="yes" xml:space="preserve">
          <source>6) Then &lt;code&gt;nano&lt;/code&gt; editor again opens for updating comments, if necessary update it.</source>
          <target state="translated">6）次に、必要に応じてコメントを更新するために、コメントを更新するために &lt;code&gt;nano&lt;/code&gt; エディターが再び開きます。</target>
        </trans-unit>
        <trans-unit id="dfc29b1eb351d0fcd6446b260cefa0750b92fd58" translate="yes" xml:space="preserve">
          <source>7) Now its squashed successfully, you can verify it by checking logs.</source>
          <target state="translated">7)Now its squashed successfully,you can verify it by checking logs.</target>
        </trans-unit>
        <trans-unit id="0534fb54df6a2793525c086550d32e11a5d6cdf6" translate="yes" xml:space="preserve">
          <source>8) Now push to repo. Note to add &lt;code&gt;+&lt;/code&gt; sign before the branch name. This means forced push.</source>
          <target state="translated">8）リポジトリにプッシュします。 ブランチ名の前に &lt;code&gt;+&lt;/code&gt; 記号を追加することに注意してください。 これは強制プッシュを意味します。</target>
        </trans-unit>
        <trans-unit id="060566f0626a9c056933505d6f6cf04d52e947e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;Anomies answer&lt;/a&gt; is good, but I felt insecure about this so I decided to add a couple of screenshots.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;Anomiesの回答&lt;/a&gt;は良いですが、私はこれについて不安を感じたので、スクリーンショットをいくつか追加することにしました。</target>
        </trans-unit>
        <trans-unit id="0aa246496b4e1fd607eb4727df2b1c6b2fd5d5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt;  // puts all changes in stage</source>
          <target state="translated">&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt; //すべての変更をステージに入れます</target>
        </trans-unit>
        <trans-unit id="7055a5977843ebb56fc6cf1a7433d6529c41d611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; , where N is the number of commits I want to join, &lt;em&gt;starting from the most recent one&lt;/em&gt;. So &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; would mean &quot;squash the last 5 commits into a new one&quot;;</source>
          <target state="translated">&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; 。ここで、Nは、 &lt;em&gt;最新&lt;/em&gt;のコミット&lt;em&gt;から始めて、&lt;/em&gt;参加したいコミットの数です。 したがって、 &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; は、「最後の5つのコミットを新しいものにつぶす」ことを意味します。</target>
        </trans-unit>
        <trans-unit id="4f4ea95712f9097dba8f82df029c2063fe45d6db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; the only real advantage of this method over the simpler &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; suggested by Chris Johnsen in &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;his answer&lt;/a&gt; is that you get the commit message prepopulated with every commit message that you're squashing.</source>
          <target state="translated">&lt;em&gt;更新：&lt;/em&gt;単純な &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; に対するこのメソッドの唯一の本当の利点は、Chris Johnsenが&lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;彼の回答&lt;/a&gt;で提案したもので、 つぶしているすべてのコミットメッセージでコミットメッセージが事前入力されていることです。</target>
        </trans-unit>
        <trans-unit id="7bc1abce6232c8b6c9b96cbc89e3473e9d63b768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A practical everyday example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実用的な日常の例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68214ab4e4aca49ed9688ab7ba5060c6d11a94f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the interactive rebase editor:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;インタラクティブなリベースエディターの使用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab98be530e6bee8cd013851490d34d6048cd6904" translate="yes" xml:space="preserve">
          <source>Add Christine Perfect</source>
          <target state="translated">クリスティン パーフェクトを追加</target>
        </trans-unit>
        <trans-unit id="bfb4f0dc3070ad453043d38a7fd9f425d739332c" translate="yes" xml:space="preserve">
          <source>Add Danny Kirwan</source>
          <target state="translated">Danny Kirwan を追加</target>
        </trans-unit>
        <trans-unit id="7aa7c343556333bbf1afb97214bb9452da86a2bf" translate="yes" xml:space="preserve">
          <source>Add a global &quot;squash&quot; alias from bash: (or Git Bash on Windows)</source>
          <target state="translated">bashからグローバルな &quot;squash &quot;エイリアスを追加します。(Windows では Git バッシュ)</target>
        </trans-unit>
        <trans-unit id="b1b79d483720ae24eec3e5adbd6ca57ec881cd82" translate="yes" xml:space="preserve">
          <source>Advantage of 1st procedure is to squash multiple commits and to reorder. But this procedure will be difficult if we need to merge a fix to very old commit.</source>
          <target state="translated">1つ目の方法の利点は、複数のコミットをつぶすことができることと、順番を入れ替えることができることです。しかし、非常に古いコミットの修正をマージする必要がある場合には、この方法は難しいでしょう。</target>
        </trans-unit>
        <trans-unit id="7868a386b46b1e0c5a783fd920cb3a86a91ca21b" translate="yes" xml:space="preserve">
          <source>After rebase will finish you can choose message for squashed H0 and B0:</source>
          <target state="translated">リベースが終了したら、H0とB0を潰したときのメッセージを選択します。</target>
        </trans-unit>
        <trans-unit id="48786ade9458227291ecdfcbc328a0b9a48bba9c" translate="yes" xml:space="preserve">
          <source>After save and exit rebase will apply commits in turn after H1. That means that it will ask you to resolve conflicts again (where HEAD will be H1 at first and then accumulating commits as they are applied).</source>
          <target state="translated">保存して終了した後、rebaseはH1の後に順番にコミットを適用していきます。つまり、コンフリクトを再度解決するように要求してくるということです (最初は HEAD が H1 で、それが適用されるとコミットが蓄積されていきます)。</target>
        </trans-unit>
        <trans-unit id="b90a4b8a8c8bb781c2de8719251307f780e35ad0" translate="yes" xml:space="preserve">
          <source>And what happens? You just made single commit that get from Fritz to Bill Clinton. Because you forgot that yesterday you were working on the Buckingham Nicks version of this project. And &lt;code&gt;git log&lt;/code&gt; doesn't match what you see on GitHub.</source>
          <target state="translated">そして、何が起こりますか？ FritzからBill Clintonに到達する単一のコミットを作成しました。 昨日、このプロジェクトのバッキンガムニックスバージョンで作業していたことを忘れたためです。 そして、 &lt;code&gt;git log&lt;/code&gt; はGitHubに表示されるものと一致しません。</target>
        </trans-unit>
        <trans-unit id="093e99d3dbc1e1d8c95fe7ba70003dcb67751c12" translate="yes" xml:space="preserve">
          <source>As the commit on line 1 is &lt;code&gt;HEAD&lt;/code&gt;, in most cases you would leave this as &lt;code&gt;pick&lt;/code&gt;. 
 You cannot use &lt;code&gt;squash&lt;/code&gt; or &lt;code&gt;fixup&lt;/code&gt; as there is no other commit to squash the commit into.</source>
          <target state="translated">1行目のコミットは &lt;code&gt;HEAD&lt;/code&gt; であるため、ほとんどの場合、これは &lt;code&gt;pick&lt;/code&gt; ままにします。 コミットをスカッシュする他のコミットがないため、 &lt;code&gt;squash&lt;/code&gt; または &lt;code&gt;fixup&lt;/code&gt; を使用できません。</target>
        </trans-unit>
        <trans-unit id="3b41b6bdffa611514466e9905a87e0b849f5fdea" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;this article&lt;/a&gt; I found this method easier for my usecase.</source>
          <target state="translated">&lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;この記事&lt;/a&gt;に基づいて、私はこの方法が私のユースケースにとってより簡単であることを発見しました。</target>
        </trans-unit>
        <trans-unit id="e29ab6f60ee8c7e67c1f6b510f26b71c099d14d4" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;Chris Johnsen's answer&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;クリスジョンセンの答えに&lt;/a&gt;基づいて、</target>
        </trans-unit>
        <trans-unit id="9a1a2639cbe33c22eb5dbb88182e215a85ff59b4" translate="yes" xml:space="preserve">
          <source>Bill Clinton</source>
          <target state="translated">ビル・クリントン</target>
        </trans-unit>
        <trans-unit id="e91185e515d9c1ad67ebd9560c54d10d75f7605a" translate="yes" xml:space="preserve">
          <source>Both of those methods squash the last three commits into a single new commit in the same way. The soft reset just re-points HEAD to the last commit that you do not want to squash. Neither the index nor the working tree are touched by the soft reset, leaving the index in the desired state for your new commit (i.e. it already has all the changes from the commits that you are about to &amp;ldquo;throw away&amp;rdquo;).</source>
          <target state="translated">これらの方法はどちらも、最後の3つのコミットを同じ方法で1つの新しいコミットに押しつぶします。 ソフトリセットは、スカッシュしたくない最後のコミットにHEADを再ポイントするだけです。 インデックスも作業ツリーもソフトリセットの影響を受けず、インデックスは新しいコミットの望ましい状態のままになります（つまり、「破棄」しようとしているコミットからのすべての変更がすでにあります）。</target>
        </trans-unit>
        <trans-unit id="11d466714aac7655883761ed97c5295c4bfdafbb" translate="yes" xml:space="preserve">
          <source>Check out the target branch (e.g. 'master')</source>
          <target state="translated">対象となるブランチを確認する (例:'master')</target>
        </trans-unit>
        <trans-unit id="4fc0c1dfdb777b642cb8be476d33324610a18450" translate="yes" xml:space="preserve">
          <source>Checkout the golden repo</source>
          <target state="translated">黄金レポをチェック</target>
        </trans-unit>
        <trans-unit id="828d4675ea69be7bbbd51d39ea75d7e2c353989c" translate="yes" xml:space="preserve">
          <source>Commit your changes (this will be the only commit that goes in dev-branch)</source>
          <target state="translated">変更をコミットします (これは dev-branch に入る唯一のコミットになります)</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="8affcece617012629577cf8bfabbbc0cbdccf5e6" translate="yes" xml:space="preserve">
          <source>Create a new branch from it(golden repo) as follows</source>
          <target state="translated">それ(golden repo)から以下のように新しいブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="51a53ea31f4f996d5387d6d4244348d9a9522bfe" translate="yes" xml:space="preserve">
          <source>Execute &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;&lt;code&gt;git rebase -i [your hash]&lt;/code&gt;&lt;/a&gt;, in my case:</source>
          <target state="translated">私の場合、 &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt; &lt;code&gt;git rebase -i [your hash]&lt;/code&gt; を&lt;/a&gt;実行します 。</target>
        </trans-unit>
        <trans-unit id="ac8b133f58886974b11bc6af37c28baf4d4c4593" translate="yes" xml:space="preserve">
          <source>Find the commit hash you want to squash on top of, say &lt;code&gt;d43e15&lt;/code&gt;.</source>
          <target state="translated">スカッシュしたいコミットハッシュを見つけます、例えば &lt;code&gt;d43e15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16fe861b00c32729b8570a41dd960986992c8977" translate="yes" xml:space="preserve">
          <source>Find the exact files you want to get &lt;em&gt;to&lt;/em&gt;, and &lt;code&gt;git checkout&lt;/code&gt; them</source>
          <target state="translated">取得&lt;em&gt;し&lt;/em&gt;たい正確なファイルを見つけ、それらを &lt;code&gt;git checkout&lt;/code&gt; します</target>
        </trans-unit>
        <trans-unit id="513ddb206d72ddd403d65e37a963ba3c61af9ca1" translate="yes" xml:space="preserve">
          <source>Find the exact prior commit you want to keep in history, and &lt;code&gt;git reset --soft&lt;/code&gt; that</source>
          <target state="translated">履歴に残したい正確な以前のコミットを見つけ、 &lt;code&gt;git reset --soft&lt;/code&gt; that</target>
        </trans-unit>
        <trans-unit id="cbff6a6b4ceaa070a2583eb67ba786884ec2dce3" translate="yes" xml:space="preserve">
          <source>First I find out the number of commits between my feature branch and current master branch by</source>
          <target state="translated">最初に、自分の機能ブランチと現在の master ブランチ間のコミット数を調べるには</target>
        </trans-unit>
        <trans-unit id="b17781596baa10e42e5d27e04c27b98e980cac0e" translate="yes" xml:space="preserve">
          <source>First add the required files for commit</source>
          <target state="translated">最初にコミットに必要なファイルを追加します。</target>
        </trans-unit>
        <trans-unit id="e3a67cef2cd706c75ce38bcabf3f0ff9e944ae90" translate="yes" xml:space="preserve">
          <source>For details click on the &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;Link&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;リンクを&lt;/strong&gt;&lt;/a&gt;クリックしてください</target>
        </trans-unit>
        <trans-unit id="af1603c24d4db6e43caf6f4bf93db855e59a5472" translate="yes" xml:space="preserve">
          <source>For example, if you are looking to merge all the commits into one, the 'pick' is the first commit you made and all future ones (placed below the first) should be set to 'squash'. If using vim, use &lt;strong&gt;:x&lt;/strong&gt; in insert mode to save and exit the editor.</source>
          <target state="translated">たとえば、すべてのコミットを1つにマージする場合、「ピック」は最初に行ったコミットであり、将来のすべてのコミット（最初の下に配置）は「スカッシュ」に設定する必要があります。 vimを使用している場合は、挿入モードで&lt;strong&gt;：x&lt;/strong&gt;を使用して、エディターを保存して終了します。</target>
        </trans-unit>
        <trans-unit id="e5634b5e021244ee271ad922152ae052ceecc536" translate="yes" xml:space="preserve">
          <source>For more on this and other ways to rewrite your commit history see &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;this helpful post&lt;/a&gt;</source>
          <target state="translated">これとコミット履歴を書き換える他の方法の詳細については、 &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;この役立つ投稿を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="fc8b719f20cf72ebfb1459a1756eda92bcc9e219" translate="yes" xml:space="preserve">
          <source>Four commits:</source>
          <target state="translated">4人のコミット。</target>
        </trans-unit>
        <trans-unit id="0ff5edf7ba7c13b10c729d9325013204a570385b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;^&lt;/code&gt; means the previous commit to &lt;code&gt;OLDCOMMIT&lt;/code&gt;. This &lt;code&gt;rebase&lt;/code&gt; command opens interactive window on a editor (vim or nano) on that
we no need to do anything just save and exiting is sufficient. Because the option passed to this will automatically move the latest
commit to next to old commit and change the operation to &lt;code&gt;fixup&lt;/code&gt; (equivalent to squash). Then rebase continues and finishes.</source>
          <target state="translated">ここで &lt;code&gt;^&lt;/code&gt; は、 &lt;code&gt;OLDCOMMIT&lt;/code&gt; への前回のコミットを意味します。 この &lt;code&gt;rebase&lt;/code&gt; コマンドは、エディター（vimまたはnano）でインタラクティブウィンドウを開きます。保存するだけで終了するだけで十分です。 これに渡されたオプションは、最新のコミットを古いコミットの隣に自動的に移動し、操作を &lt;code&gt;fixup&lt;/code&gt; （スカッシュに相当）に変更するためです。 その後、リベースが続行して終了します。</target>
        </trans-unit>
        <trans-unit id="1ab294f6db6b416c34905212bef55947aeddd00a" translate="yes" xml:space="preserve">
          <source>Here even &lt;code&gt;git log --oneline&lt;/code&gt; also can be used to get short hash.</source>
          <target state="translated">ここでも &lt;code&gt;git log --oneline&lt;/code&gt; を使用して短いハッシュを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="abfc9c95a5a36468169f0e59eed3b53351764f57" translate="yes" xml:space="preserve">
          <source>Hope it helps, thanks.</source>
          <target state="translated">役に立つといいけど、ありがとう。</target>
        </trans-unit>
        <trans-unit id="e9acce96a379cc84dadce50a2a0d0c8a84bd8163" translate="yes" xml:space="preserve">
          <source>How can I squash my last X commits together into one commit using Git?</source>
          <target state="translated">Git を使って、最後の X コミットをひとつのコミットにまとめるにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="b3aa1fa40cb10cce596ab2f6735206a7a54e21a1" translate="yes" xml:space="preserve">
          <source>How many commits u need to merge, u need to give next that HEAD(like this HEAD~2)</source>
          <target state="translated">マージするコミットの数は、次の HEAD(この HEAD~2 のように)を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="01e83eedbee0bac8113da661371c9e862faa5901" translate="yes" xml:space="preserve">
          <source>I find a more generic solution is not to specify 'N' commits, but rather the branch/commit-id you want to squash on top of.  This is less error-prone than counting the commits up to a specific commit&amp;mdash;just specify the tag directly, or if you really want to count you can specify HEAD~N.</source>
          <target state="translated">より一般的な解決策は、「N」コミットを指定するのではなく、スカッシュしたいブランチ/コミットIDを指定することです。 これは、特定のコミットまでのコミットをカウントするよりもエラーが発生しにくくなります。タグを直接指定するか、本当にカウントしたい場合はHEAD〜Nを指定できます。</target>
        </trans-unit>
        <trans-unit id="15f7cd9bd7d23b350c09940eb410992e9fe3d486" translate="yes" xml:space="preserve">
          <source>I haven't seen a workflow like that on this page. (That may be my eyes.) If I understand &lt;code&gt;rebase&lt;/code&gt; correctly, multiple merges would require &lt;strong&gt;multiple conflict resolutions&lt;/strong&gt;. I do NOT want even to think about that!</source>
          <target state="translated">このページでは、そのようなワークフローを見たことがありません。 （それが私の目かもしれません。） &lt;code&gt;rebase&lt;/code&gt; 正しく理解している場合、複数のマージには&lt;strong&gt;複数の競合解決&lt;/strong&gt;が必要になります。 そんなこと考えたくない！</target>
        </trans-unit>
        <trans-unit id="b87f73f2e8db36e6d71fb06157044e936572698f" translate="yes" xml:space="preserve">
          <source>I prefer to use the command &lt;code&gt;fixup&lt;/code&gt; as this &quot;squashes&quot; the commit's changes into the commit on the line above and discards the commit's message.</source>
          <target state="translated">私はコマンド &lt;code&gt;fixup&lt;/code&gt; を使用することを好みます。これは、コミットの変更を上の行のコミットに「押しつぶし」、コミットのメッセージを破棄するためです。</target>
        </trans-unit>
        <trans-unit id="11f555b9e44717e3b66217f13f903c4371b5dda4" translate="yes" xml:space="preserve">
          <source>I recommend avoiding &lt;code&gt;git reset&lt;/code&gt; when possible -- especially for Git-novices.  Unless you really need to automate a process based on a &lt;em&gt;number&lt;/em&gt; of commits, there is a less exotic way...</source>
          <target state="translated">特にGit初心者の場合は、可能な限り &lt;code&gt;git reset&lt;/code&gt; を使用しないことをお勧めします。 本当に&lt;em&gt;多く&lt;/em&gt;のコミットに基づいてプロセスを自動化する必要がない限り、それほど珍しい方法はありません...</target>
        </trans-unit>
        <trans-unit id="3dca227ddd161112834d5cf5d8d8bf15553d4ddf" translate="yes" xml:space="preserve">
          <source>I then run &lt;code&gt;git log&lt;/code&gt; or &lt;code&gt;gitk&lt;/code&gt; and get the commit SHA of the new feature (in this case &lt;code&gt;1ff9460&lt;/code&gt;).</source>
          <target state="translated">次に &lt;code&gt;git log&lt;/code&gt; または &lt;code&gt;gitk&lt;/code&gt; を実行して、新機能のコミットSHA（この場合は &lt;code&gt;1ff9460&lt;/code&gt; ）を取得します。</target>
        </trans-unit>
        <trans-unit id="9bc0e663b42f4c03fed1ae440e72de7476b8085f" translate="yes" xml:space="preserve">
          <source>I think the easiest way to do this is by making a new branch off of master and doing a merge --squash of the feature branch.</source>
          <target state="translated">これを行う最も簡単な方法は、master から新しいブランチを作って、 feature ブランチを merge -squash することだと思います。</target>
        </trans-unit>
        <trans-unit id="c58228448370201426a2ca0267ec9560383413e8" translate="yes" xml:space="preserve">
          <source>I use the alias:</source>
          <target state="translated">私は別名を使っています。</target>
        </trans-unit>
        <trans-unit id="86001cc8c4eed6dfdd49e895d88ca2295d3b8afd" translate="yes" xml:space="preserve">
          <source>I wanted to squash these commits into one before pushing the change. I prefere to reset the branch to the state of 'origin/dev' (this will leave all changes from the 96 commits unstaged) and then commit the changes at once:</source>
          <target state="translated">変更をプッシュする前に、これらのコミットを一つにまとめたいと思いました。ブランチを 'origindev' の状態にリセットして (これにより 96 回のコミットからのすべての変更がステージされずに残ります)、変更を一度にコミットすることを好みます。</target>
        </trans-unit>
        <trans-unit id="3ef5f47215cc877254b4c604b64a56fd37c0c5dd" translate="yes" xml:space="preserve">
          <source>I'd probably do what &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair suggested&lt;/a&gt;, though.</source>
          <target state="translated">でも、おそらく私は&lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longairが提案&lt;/a&gt;したことをするでしょう。</target>
        </trans-unit>
        <trans-unit id="8d1dbb1610551849ad4b8eb20bae4c982b7e33d6" translate="yes" xml:space="preserve">
          <source>I've recently committed a new feature.  Since then, I have committed two bug fixes.  But now I have discovered a bug (or maybe just a spelling error) in the new feature I committed.  How annoying!  I don't want a new commit polluting my commit history!</source>
          <target state="translated">最近、新機能をコミットしました。それ以来、私は二つのバグフィックスをコミットしました。しかし今、私はコミットした新機能の中にバグを発見しました(あるいは単にスペルミスかもしれません)。なんて迷惑なんでしょう! 新しいコミットでコミット履歴を汚したくありません!</target>
        </trans-unit>
        <trans-unit id="600ba8b07c35f3aa98f10bd9215d0c431e3ac6f8" translate="yes" xml:space="preserve">
          <source>If you also want to update the remote branch with the squashed commit:</source>
          <target state="translated">また、リモートブランチをsquashedしたコミットで更新したい場合。</target>
        </trans-unit>
        <trans-unit id="c8107381ad7a4e9bfcfe1e4bfd58c9168ef6516d" translate="yes" xml:space="preserve">
          <source>If you are on a remote branch(called &lt;code&gt;feature-branch&lt;/code&gt;) cloned from a Golden Repository(&lt;code&gt;golden_repo_name&lt;/code&gt;), then here's the technique to squash your commits into one:</source>
          <target state="translated">ゴールデンリポジトリ（ &lt;code&gt;golden_repo_name&lt;/code&gt; ）から複製されたリモートブランチ（ &lt;code&gt;feature-branch&lt;/code&gt; と呼ばれます）を使用している場合、コミットを1つにまとめる方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="32f47536faa9331321aee23cdac3148266be1e42" translate="yes" xml:space="preserve">
          <source>If you don't care about the commit messages of the in-between commits, you can use</source>
          <target state="translated">中間コミットのコミットメッセージを気にしない場合は</target>
        </trans-unit>
        <trans-unit id="787518d9bc259dac56a32f39ea1e2a792a17531f" translate="yes" xml:space="preserve">
          <source>If you have picked only one commit and squashed the rest, you can adjust one commit message:</source>
          <target state="translated">コミットを1つだけ選んで残りを潰した場合は、1つのコミットメッセージを調整することができます。</target>
        </trans-unit>
        <trans-unit id="2b626aec01c288f93e9d5a110eb02bd59f405ad8" translate="yes" xml:space="preserve">
          <source>If you use TortoiseGit, you can the function &lt;code&gt;Combine to one commit&lt;/code&gt;:</source>
          <target state="translated">TortoiseGitを使用する場合 &lt;code&gt;Combine to one commit&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="52aefe4131cf6e22141e6a89050a2d36c82447da" translate="yes" xml:space="preserve">
          <source>If you want to squish &lt;em&gt;every&lt;/em&gt; commit into a single commit (e.g. when releasing a project publicly for the first time), try:</source>
          <target state="translated">&lt;em&gt;すべての&lt;/em&gt;コミットを1つのコミットに圧縮する場合（たとえば、プロジェクトを初めて一般公開する場合）、次のことを試してください。</target>
        </trans-unit>
        <trans-unit id="f827f77438492c15d0d2aa806bcc35f58430f25e" translate="yes" xml:space="preserve">
          <source>If you want to start editing the new commit message with a concatenation of the existing commit messages (i.e. similar to what a pick/squash/squash/&amp;hellip;/squash &lt;code&gt;git rebase -i&lt;/code&gt; instruction list would start you with), then you need to extract those messages and pass them to &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">既存のコミットメッセージを連結して新しいコミットメッセージの編集を開始したい場合（つまり、pick / squash / squash /&amp;hellip;/ squash &lt;code&gt;git rebase -i&lt;/code&gt; 命令リストから開始するものと同様）、抽出する必要があります。それらのメッセージを &lt;code&gt;git commit&lt;/code&gt; に渡します：</target>
        </trans-unit>
        <trans-unit id="088b19cf941b3ff8da3b7eb151f8d881f3db1fff" translate="yes" xml:space="preserve">
          <source>If you want to write the new commit message from scratch, this suffices:</source>
          <target state="translated">新しいコミットメッセージを一から書きたい場合は、これで十分です。</target>
        </trans-unit>
        <trans-unit id="79f1ff9673cb765c19eb55c4d649e27cf47e1e06" translate="yes" xml:space="preserve">
          <source>If you're working with GitLab, you can just click the Squash option in the Merge Request as shown below. The commit message will be the title of the Merge Request.</source>
          <target state="translated">GitLab で作業している場合は、以下のようにマージリクエストの Squash オプションをクリックするだけです。コミットメッセージはマージリクエストのタイトルになります。</target>
        </trans-unit>
        <trans-unit id="a017ecd71bf7f57fd4ca564c4f4814ffbbbd55eb" translate="yes" xml:space="preserve">
          <source>In addition to other excellent answers, I'd like to add how &lt;code&gt;git rebase -i&lt;/code&gt; always confuses me with the commit order - older to newer one or vice versa? So this is my workflow:</source>
          <target state="translated">他の優れた答えに加えて、 &lt;code&gt;git rebase -i&lt;/code&gt; が常にコミット順序と混同する方法を追加したいと思います-古いものから新しいものへ、またはその逆ですか？ これが私のワークフローです：</target>
        </trans-unit>
        <trans-unit id="e0c5c08fbe43f01fe7feb65bad1556407d8bf81f" translate="yes" xml:space="preserve">
          <source>In my case, I want to squash everything on the commit that was first in time. The ordering is from first to last, so exactly the other way as in &lt;code&gt;git log&lt;/code&gt;. In my case, I want:</source>
          <target state="translated">私の場合、最初にコミットしたすべてのものを押しつぶしたいと思います。 順序は最初から最後までなので、 &lt;code&gt;git log&lt;/code&gt; とまったく同じです。 私の場合、私は欲しい：</target>
        </trans-unit>
        <trans-unit id="812b8ce0a931bda8d43ab639459be7c06897670f" translate="yes" xml:space="preserve">
          <source>In my workflow, I start a branch, and my first commit on that branch summarizes the goal (i.e. it's usually what I will push as the 'final' message for the feature to the public repository.)  So when I'm done, all I want to do is &lt;code&gt;git squash master&lt;/code&gt; back to the first message and then I'm ready to push.</source>
          <target state="translated">私のワークフローでは、ブランチを開始し、そのブランチでの最初のコミットで目標を要約します（つまり、これは通常、機能の「最終」メッセージとしてパブリックリポジトリにプッシュするものです）。私がやりたいのは &lt;code&gt;git squash master&lt;/code&gt; を最初のメッセージに戻し、プッシュする準備ができていることです。</target>
        </trans-unit>
        <trans-unit id="cfebaa62652e8409b9f3689f76707285002e6e2c" translate="yes" xml:space="preserve">
          <source>In question it could be ambiguous what is meant by &quot;last&quot;.</source>
          <target state="translated">問題は、「最後」が何を意味しているのかが曖昧になっている可能性があります。</target>
        </trans-unit>
        <trans-unit id="9306409d13d02f1d92a630f721830c055b515fbf" translate="yes" xml:space="preserve">
          <source>In the branch you would like to combine the commits on, run:</source>
          <target state="translated">コミットを結合したいブランチで実行してください。</target>
        </trans-unit>
        <trans-unit id="88c73138cde2bf54e60255d9bd740e5e58d9f261" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past the command is &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; は、SHA1ハッシュ、またはrebaseコマンドのコミットが分析される現在のブランチのHEADからの相対位置です。 たとえば、ユーザーが過去の現在のHEADから5つのコミットを表示したい場合、コマンドは &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7b0babcfbdf70396a1070d18ba28e5456936528f" translate="yes" xml:space="preserve">
          <source>In this very abbreviated history of the &lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt; repository you have opened a pull request to merge in the the Bill Clinton commit into the original (&lt;code&gt;MASTER&lt;/code&gt;) Fleetwood Mac commit.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt;リポジトリのこの非常に簡略化された履歴で、Bill Clintonコミットを元の（ &lt;code&gt;MASTER&lt;/code&gt; ）Fleetwood Macコミットにマージするプルリクエストを開きました。</target>
        </trans-unit>
        <trans-unit id="bf126b3fade88997f0548ade26b8b5c4bfea4c6b" translate="yes" xml:space="preserve">
          <source>It's possible to use rebase but in different manner then in others mentioned answers:</source>
          <target state="translated">リベースを使用することは可能ですが、他の回答とは異なる方法で使用することができます。</target>
        </trans-unit>
        <trans-unit id="028bc2366d79ea4ef91789bfa66ae316236a417d" translate="yes" xml:space="preserve">
          <source>LA1974</source>
          <target state="translated">LA1974</target>
        </trans-unit>
        <trans-unit id="fb2a8991936042159a3bb1d749bea91292a31069" translate="yes" xml:space="preserve">
          <source>Lastly, I run</source>
          <target state="translated">最後に、私は走ります。</target>
        </trans-unit>
        <trans-unit id="57fe6ea67ceef51616f8ae62d6f8e1cb4229da2f" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;git commit&lt;/code&gt; that warps directly from the &lt;em&gt;from&lt;/em&gt; to the &lt;em&gt;to&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fromから&lt;/em&gt; toに直接ワープする &lt;code&gt;git commit&lt;/code&gt; を作成&lt;em&gt;する&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49e92ccd1adc445eb977e8a994e8fd9adc2bc217" translate="yes" xml:space="preserve">
          <source>Mark the relevant commits in the log view</source>
          <target state="translated">ログビューで関連するコミットをマークする</target>
        </trans-unit>
        <trans-unit id="0fc0ad9a332750ab53c934b71eb3800bf3e4909a" translate="yes" xml:space="preserve">
          <source>My 'dev' branch was ahead of 'origin/dev' by 96 commits (so these commits were not pushed to the remote yet).</source>
          <target state="translated">私の 'dev' ブランチは 'origindev' よりも 96 コミット分進んでいました (このため、これらのコミットはまだリモートにはプッシュされていません)。</target>
        </trans-unit>
        <trans-unit id="8293f55e479d0410deb525c2426e813f0803e546" translate="yes" xml:space="preserve">
          <source>Next, I bring up the interactive rebase editor with &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt;.  The &lt;code&gt;~&lt;/code&gt; after the commit SHA tells the editor to include that commit in the editor.</source>
          <target state="translated">次に、 &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt; を使用してインタラクティブなリベースエディターを起動します。 コミット後のSHAは、そのコミットをエディターに含めるようにエディターに指示します。</target>
        </trans-unit>
        <trans-unit id="a6117317363c016a257f2208f2a02cd8432aaabc" translate="yes" xml:space="preserve">
          <source>Next, I move the commit containing the fix (&lt;code&gt;fe7f1e0&lt;/code&gt;) to underneath the feature commit, and change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;fixup&lt;/code&gt;.</source>
          <target state="translated">次に、修正（ &lt;code&gt;fe7f1e0&lt;/code&gt; ）を含むコミットを機能コミットの下に移動し、 &lt;code&gt;pick&lt;/code&gt; を &lt;code&gt;fixup&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="8423bc929eacf6c5159737bd94c0cbd3c5778996" translate="yes" xml:space="preserve">
          <source>Note : This is based on using git on &lt;code&gt;ubuntu&lt;/code&gt; shell. If you are using different os (&lt;code&gt;Windows&lt;/code&gt; or &lt;code&gt;Mac&lt;/code&gt;) then above commands are same except editor. You might get different editor.</source>
          <target state="translated">注：これは、 &lt;code&gt;ubuntu&lt;/code&gt; シェルでのgitの使用に基づいています。 別のOS（ &lt;code&gt;Windows&lt;/code&gt; または &lt;code&gt;Mac&lt;/code&gt; ）を使用している場合、上記のコマンドはエディターを除いて同じです。 別のエディターが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="20b053a3e9165bb14f6a88287ca972e8a2dce8ee" translate="yes" xml:space="preserve">
          <source>Note: The resultant commit message is a combination of all the squashed commits, in order. If you are unhappy with that, you can always &lt;code&gt;git commit --amend&lt;/code&gt; to modify it manually. (Or, edit the alias to match your tastes.)</source>
          <target state="translated">注：結果のコミットメッセージは、すべての押しつぶされたコミットを順番に組み合わせたものです。 これに不満がある場合は、いつでも &lt;code&gt;git commit --amend&lt;/code&gt; を実行して手動で変更できます。 （または、好みに合わせてエイリアスを編集します。）</target>
        </trans-unit>
        <trans-unit id="d6377f9be4e13e6d8f9e38c5003db9b8ab9af614" translate="yes" xml:space="preserve">
          <source>Now this creates a new commit on top of HEAD with &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt; を使用して HEADの上に新しいコミットが作成されます。</target>
        </trans-unit>
        <trans-unit id="48a3a5484c6d47719f56ef39bf6dd2a38a49336a" translate="yes" xml:space="preserve">
          <source>Now use</source>
          <target state="translated">今すぐ使用してください。</target>
        </trans-unit>
        <trans-unit id="3b3a3e1be78f40ef46e629b130884d7de89ba488" translate="yes" xml:space="preserve">
          <source>Open TortoiseGit context menu</source>
          <target state="translated">TortoiseGitのコンテキストメニューを開く</target>
        </trans-unit>
        <trans-unit id="a5015e7e2cecbb5b2a96a0da08d780166899f93a" translate="yes" xml:space="preserve">
          <source>P.S. If you just do some reset to BO: 
(for example, using &lt;code&gt;reset --mixed&lt;/code&gt; that is explained in more detail here &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https://stackoverflow.com/a/18690845/2405850&lt;/a&gt;):</source>
          <target state="translated">PS BOをリセットするだけの場合（たとえば、 &lt;code&gt;reset --mixed&lt;/code&gt; を使用すると、 &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https&lt;/a&gt; ： //stackoverflow.com/a/18690845/2405850で詳しく説明されます ）：</target>
        </trans-unit>
        <trans-unit id="e8df79c1f7f324f7ea12be589f8d4145c0fff656" translate="yes" xml:space="preserve">
          <source>PR and merge TO master &lt;em&gt;by reviewer&lt;/em&gt;.
(Yes, it would be easier for the developer to &lt;code&gt;merge --squash&lt;/code&gt; after the PR, but the team thought that would slow down the process.)</source>
          <target state="translated">PRと&lt;em&gt;レビュー担当者による&lt;/em&gt;マスターへのマージ。 （はい、開発者にとっては、PR後に &lt;code&gt;merge --squash&lt;/code&gt; をマージする方が簡単ですが、チームはプロセスを遅くすると考えていました。）</target>
        </trans-unit>
        <trans-unit id="7e84941f3d4a75c0dc177c26e3d8294131e792e3" translate="yes" xml:space="preserve">
          <source>Procedure 1</source>
          <target state="translated">手順1</target>
        </trans-unit>
        <trans-unit id="9d3b7680f495af80fe40294525dfe378fc4a6043" translate="yes" xml:space="preserve">
          <source>Procedure 2</source>
          <target state="translated">手順2</target>
        </trans-unit>
        <trans-unit id="2c937bebe0ed8ae169f2202e531a6094c90fee0c" translate="yes" xml:space="preserve">
          <source>Push the branch to your local repository</source>
          <target state="translated">ブランチをローカルリポジトリにプッシュ</target>
        </trans-unit>
        <trans-unit id="a73eccc33144570add3bc96c79ccd1f27423bf72" translate="yes" xml:space="preserve">
          <source>Push the change to a particular branch</source>
          <target state="translated">特定のブランチに変更をプッシュ</target>
        </trans-unit>
        <trans-unit id="ca87402c617e64e22c3d7193a1f96b2b02c17659" translate="yes" xml:space="preserve">
          <source>Put squash instead of pick to H0:</source>
          <target state="translated">H0にピックの代わりにスカッシュを入れます。</target>
        </trans-unit>
        <trans-unit id="260756bf22f9f993d1bc033875848a9357f0d969" translate="yes" xml:space="preserve">
          <source>Put the to-be-squashed commits on a working branch (if they aren't already) -- use gitk for this</source>
          <target state="translated">潰すべきコミットを作業用ブランチに置いて (もしそうでなければ)--gitk を使います。</target>
        </trans-unit>
        <trans-unit id="9e66b40d5e26b8f80f7e041f81061eb7ad61a1b5" translate="yes" xml:space="preserve">
          <source>Reviewer does PR and merges to master.</source>
          <target state="translated">レビュアーはPRをして、マスターにマージします。</target>
        </trans-unit>
        <trans-unit id="8c3a77045a4803d7837f166a12ee9caf303269a1" translate="yes" xml:space="preserve">
          <source>See where you are with &lt;code&gt;git log&lt;/code&gt;. Most important, find the commit hash of the first commit you &lt;em&gt;don't&lt;/em&gt; want to squash. So only the :</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; で現在の場所を確認してください。 最も重要なのは、スカッシュしたく&lt;em&gt;ない&lt;/em&gt;最初のコミットのコミットハッシュを見つけることです。 だから：</target>
        </trans-unit>
        <trans-unit id="a2da3b6230bae4fd68ed9664dced96244baa2508" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Combine to one commit&lt;/code&gt; from the context menu</source>
          <target state="translated">コンテキストメニューから &lt;code&gt;Combine to one commit&lt;/code&gt; を選択します</target>
        </trans-unit>
        <trans-unit id="eab195238ec47a36730ecb88741d15affc592ef0" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Show Log&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Show Log&lt;/code&gt; 選択します</target>
        </trans-unit>
        <trans-unit id="ef5af955bf451fa0bf9ce8667bb1749136652a01" translate="yes" xml:space="preserve">
          <source>Simple one-liner that always works, given that you are currently on the branch you want to squash, master is the branch it originated from, and the latest commit contains the commit message and author you wish to use:</source>
          <target state="translated">シンプルなワンライナーで、あなたが現在スクショしたいブランチにいて、master はそのブランチの元になったブランチで、最新のコミットには使用したいコミットメッセージと作者が含まれていることを考えると、常に機能します。</target>
        </trans-unit>
        <trans-unit id="48e87018ba090a96eb3b4261c69ab3bc1688ba76" translate="yes" xml:space="preserve">
          <source>So the 2nd procedure helps to merge the commit to very old commit easily.</source>
          <target state="translated">そのため、2つ目の手順では、非常に古いコミットを簡単にマージすることができます。</target>
        </trans-unit>
        <trans-unit id="1606820c64383f2678929b220f43c62392e4802a" translate="yes" xml:space="preserve">
          <source>So, this seems to work for us.</source>
          <target state="translated">ということで、これは私たちには効果があるようです。</target>
        </trans-unit>
        <trans-unit id="c65f5cec26fdf510a411914b43897da6b752dc54" translate="yes" xml:space="preserve">
          <source>Sources &amp;amp; additional reads: &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;#1&lt;/a&gt;, &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;#2&lt;/a&gt;.</source>
          <target state="translated">ソースと追加の読み取り： &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;＃1&lt;/a&gt; 、 &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;＃2&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7fe78756ce38b0a0104a04e440f7455dc5041f0" translate="yes" xml:space="preserve">
          <source>Squash merge with your local branch that you have already</source>
          <target state="translated">スカッシュは、すでにお持ちのローカルブランチと合併します。</target>
        </trans-unit>
        <trans-unit id="f250854c3f99d28c958f70dce4dd6eb4cb062123" translate="yes" xml:space="preserve">
          <source>Squash my last X commits together using Git</source>
          <target state="translated">Git を使って最後の X コミットをまとめてつぶす</target>
        </trans-unit>
        <trans-unit id="fa32bacb7f009d82ac949dca9b0e80d1d0dbd93c" translate="yes" xml:space="preserve">
          <source>Step 0: git log</source>
          <target state="translated">ステップ 0:git log</target>
        </trans-unit>
        <trans-unit id="8e0ca5bd90136b4a7b027927451c19e1f346a18b" translate="yes" xml:space="preserve">
          <source>Step 1: git rebase</source>
          <target state="translated">ステップ 1:git rebase</target>
        </trans-unit>
        <trans-unit id="d7eb36401823c9a736a592ee2155703f797e50da" translate="yes" xml:space="preserve">
          <source>Step 2: pick / squash what you want</source>
          <target state="translated">ステップ2:あなたが欲しいものをスカッシュを選ぶ</target>
        </trans-unit>
        <trans-unit id="a5e2c10a701fc35282279ec7765f80119e96ce60" translate="yes" xml:space="preserve">
          <source>Step 3: Adjust message(s)</source>
          <target state="translated">ステップ3:メッセージを調整する</target>
        </trans-unit>
        <trans-unit id="7692952e23e9867e52383f181dfe0cb65c218f1d" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;this handy blog post&lt;/a&gt; I found that you can use this command to squash the last 3 commits:</source>
          <target state="translated">&lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;この便利なブログ投稿の&lt;/a&gt;おかげで、 このコマンドを使用して最後の3つのコミットを押しつぶすことができることがわかりました。</target>
        </trans-unit>
        <trans-unit id="06fa56961a9b1119f58d05a3eea1f250493fd074" translate="yes" xml:space="preserve">
          <source>That's it. Once you save this (&lt;code&gt;:wq&lt;/code&gt;), you're done. Have a look at it with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">それでおしまい。 これを保存したら（ &lt;code&gt;:wq&lt;/code&gt; ）、これで完了です。 &lt;code&gt;git log&lt;/code&gt; で確認してください。</target>
        </trans-unit>
        <trans-unit id="ad8a077aa099078c8cbac44ec84ae98b2cd4e20e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;documentation for &lt;code&gt;git merge&lt;/code&gt;&lt;/a&gt; describes the &lt;code&gt;--squash&lt;/code&gt; option in more detail.</source>
          <target state="translated">&lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt; &lt;code&gt;git merge&lt;/code&gt; &lt;/a&gt;のドキュメントでは、 &lt;code&gt;--squash&lt;/code&gt; オプションについて詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="0e607204ccc0308b417695ca633595dcad436b1d" translate="yes" xml:space="preserve">
          <source>The command will open the interactive rebase editor which then allows you to reorder, squash, reword, etc as per normal.</source>
          <target state="translated">このコマンドはインタラクティブなリベースエディタを開き、通常のように並べ替え、潰し、書き換えなどを行うことができます。</target>
        </trans-unit>
        <trans-unit id="925d19add6cc8a59abd536b73f79b247585837ee" translate="yes" xml:space="preserve">
          <source>The commit message will be prepopulated based on the squash.</source>
          <target state="translated">コミットメッセージはsquashに基づいてプリポップされます。</target>
        </trans-unit>
        <trans-unit id="8a6719516ac538e9ed622d11335500e260fc9964" translate="yes" xml:space="preserve">
          <source>The documentation displayed is pretty clear.  On any given line you can change the command from &lt;code&gt;pick&lt;/code&gt; to a command of your choice.</source>
          <target state="translated">表示されるドキュメントはかなり明確です。 任意の行で、コマンドを &lt;code&gt;pick&lt;/code&gt; から選択したコマンドに変更できます。</target>
        </trans-unit>
        <trans-unit id="6c4ad30909bb83a10ddf48ebb81e1d7adda4edf0" translate="yes" xml:space="preserve">
          <source>The first thing I do is fix the mistake and make a new commit with the comment &lt;code&gt;squash this into my new feature!&lt;/code&gt;.</source>
          <target state="translated">私が最初に行うことは、間違いを修正し、コメントで新しいコミットを作成して、 &lt;code&gt;squash this into my new feature!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a54a921df7a18b8fa7bcbb17b04135a3f9ca0a4" translate="yes" xml:space="preserve">
          <source>The interactive rebase editor shows the last three commits.  This constraint was determined by &lt;code&gt;HEAD~3&lt;/code&gt; when running the command &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt;.</source>
          <target state="translated">インタラクティブなリベースエディタには、最後の3つのコミットが表示されます。 この制約は、コマンド &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt; 実行したときに &lt;code&gt;HEAD~3&lt;/code&gt; によって決定されました。</target>
        </trans-unit>
        <trans-unit id="40de1d7485f29f3c3927203644f6993e9c59eb2c" translate="yes" xml:space="preserve">
          <source>The most recent commit, &lt;code&gt;HEAD&lt;/code&gt;, is displayed first on line 1.  The lines starting with a &lt;code&gt;#&lt;/code&gt; are comments/documentation.</source>
          <target state="translated">最新のコミットである &lt;code&gt;HEAD&lt;/code&gt; が1行目に最初に表示されます。 &lt;code&gt;#&lt;/code&gt; で始まる行はコメント/ドキュメントです。</target>
        </trans-unit>
        <trans-unit id="15bd41701489226c2dce4509a6fee4be4aa552ba" translate="yes" xml:space="preserve">
          <source>The problem is that H0 contains H1 and H2 (and generally more commits before merge and after branching) while B0 don't. So you have to manage changes from H0, merge, H1, H2, B0 at least.</source>
          <target state="translated">問題は、H0にはH1とH2が含まれているのに対し、B0には含まれていないのに対し、H0にはH1とH2が含まれている(そして一般的にはマージ前とブランチ後のコミットが多い)ということです。なので、少なくともH0、マージ、H1、H2、B0からの変更を管理しなければなりません。</target>
        </trans-unit>
        <trans-unit id="6331cadceddf56d7aa2077447230eea2f9a842c7" translate="yes" xml:space="preserve">
          <source>Then commit using &lt;code&gt;--fixup&lt;/code&gt; option and the &lt;code&gt;OLDCOMMIT&lt;/code&gt; should be on which we need to merge(squash) this commit.</source>
          <target state="translated">次に &lt;code&gt;--fixup&lt;/code&gt; オプションを使用してコミットします。このコミットをマージ（スカッシュ）する必要があるのは &lt;code&gt;OLDCOMMIT&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="625c194045dd72da9dae9e8a5696dc4cd84a15ed" translate="yes" xml:space="preserve">
          <source>Then execute below command to merge(squash) the new commit to the &lt;code&gt;OLDCOMMIT&lt;/code&gt;.</source>
          <target state="translated">次に、以下のコマンドを実行して、新しいコミットを &lt;code&gt;OLDCOMMIT&lt;/code&gt; にマージ（スカッシュ）します。</target>
        </trans-unit>
        <trans-unit id="63a925126395e6b2ebaae2cf1711a295f24f5b5f" translate="yes" xml:space="preserve">
          <source>Then last commits by time are H0, merge, B0. To squash them you will have to rebase your merged branch on commit H1.</source>
          <target state="translated">最後のコミットは H0,merge,B0 です。これらを潰すには、マージしたブランチをコミット H1 にリベースする必要があります。</target>
        </trans-unit>
        <trans-unit id="4b5c4a5092abbae0b51b1df123053bf15993a9f0" translate="yes" xml:space="preserve">
          <source>Then to continue the rebase:</source>
          <target state="translated">そして、リベースを続けるために</target>
        </trans-unit>
        <trans-unit id="cec55a62a50d094219c9ed6c3d7233b58b9df6cd" translate="yes" xml:space="preserve">
          <source>Then you have all of the changes ready to commit.</source>
          <target state="translated">これで、すべての変更をコミットする準備が整いました。</target>
        </trans-unit>
        <trans-unit id="546b13232526f68926882878963e76932c04582d" translate="yes" xml:space="preserve">
          <source>Then, I create another branch based out my-feature branch, keep &lt;code&gt;my-feature&lt;/code&gt; branch untouched.</source>
          <target state="translated">次に、featureブランチに基づいて別のブランチを作成し、featureブランチはそのままにし &lt;code&gt;my-feature&lt;/code&gt; おきます。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="a14755fe0a2432949166566a2c3b293cbb3334a8" translate="yes" xml:space="preserve">
          <source>Thinking that nobody would ever care to read the full repository history. (There actually is a repository, click the link above!) You decide to squash these commits. So you go and run &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt;. Then you &lt;code&gt;git push --force&lt;/code&gt; it onto GitHub to clean up your PR.</source>
          <target state="translated">誰もリポジトリの完全な履歴を読みたくないと思っている。 （実際にはリポジトリがあります。上のリンクをクリックしてください！）これらのコミットを破棄することにしました。 それで、あなたは &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt; ます。 次に、 &lt;code&gt;git push --force&lt;/code&gt; をGitHubに強制して、PRをクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="e8779d0790a0a6c1a85e49564ee8661d2563c832" translate="yes" xml:space="preserve">
          <source>This function automatically executes all necessary single git steps.
Unfortunatly only available for Windows.</source>
          <target state="translated">この機能は、必要なシングルgitのステップを自動的に実行してくれます。残念ながらWindowsでしか利用できません。</target>
        </trans-unit>
        <trans-unit id="4fad2e44fdb033a06b3f6360d78eb01c683e6c42" translate="yes" xml:space="preserve">
          <source>This is handy as it works even when you are on a local branch with no tracking information/remote repo.</source>
          <target state="translated">追跡情報のないローカル支店でも動作するので重宝しています。</target>
        </trans-unit>
        <trans-unit id="084858599aa0e25ed248f7286a555ac974946b7c" translate="yes" xml:space="preserve">
          <source>This is super-duper kludgy, but in a kind of cool way, so I'll just toss it into the ring:</source>
          <target state="translated">これは超ド級なんですが、ある意味カッコいいので、リングに放り込んでおきます。</target>
        </trans-unit>
        <trans-unit id="bfd5d4a30f5a6bd68aea5b76c13d7f98cd5ab3ed" translate="yes" xml:space="preserve">
          <source>This will dump the history being squashed before it does so&amp;mdash;this gives you a chance to recover by grabbing an old commit ID off the console if you want to revert.  (Solaris users note it uses the GNU sed &lt;code&gt;-i&lt;/code&gt; option, Mac and Linux users should be fine with this.)</source>
          <target state="translated">これにより、破棄される前に履歴が破棄されます。元に戻す場合は、古いコミットIDをコンソールから取得することで、復元する機会があります。 （Solarisユーザーは、GNU sed &lt;code&gt;-i&lt;/code&gt; オプションを使用していることに注意してください。MacおよびLinuxユーザーは、これで問題ありません。）</target>
        </trans-unit>
        <trans-unit id="dc92e0bbd27c7f53e720875e6878c42bc7b99b1c" translate="yes" xml:space="preserve">
          <source>This will open the text editor and you must switch the 'pick' in front of each commit with 'squash' if you would like these commits to be merged together. From documentation:</source>
          <target state="translated">これはテキストエディタを開きます。これらのコミットをまとめてマージしたい場合は、各コミットの前にある 'pick' を 'squash' に切り替えなければなりません。ドキュメントより。</target>
        </trans-unit>
        <trans-unit id="876cf8ee642d0b29004c0d70c60d3ce90f399a68" translate="yes" xml:space="preserve">
          <source>This will show you choice options (as mentioned in other answers):</source>
          <target state="translated">これで選択肢が表示されます(他の回答にも記載されています)。</target>
        </trans-unit>
        <trans-unit id="d2bce6c83325757e7a54433a83c6e7084810007e" translate="yes" xml:space="preserve">
          <source>This works well when all the commits are local, but if you try to change any commits already pushed to the remote you can really cause problems for other devs that have checked out the same branch!</source>
          <target state="translated">これはすべてのコミットがローカルにある場合にはうまくいきますが、すでにリモートにプッシュされているコミットを変更しようとすると、同じブランチをチェックアウトした他の開発者に問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1dbe8ac5ab79108392c62a34cf9417a1ac8ae9c7" translate="yes" xml:space="preserve">
          <source>To do this you can use following git command.</source>
          <target state="translated">これを行うには、以下のgitコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="603b6f4899ba5a0c325455ae848805098f30ac76" translate="yes" xml:space="preserve">
          <source>To squash the last 10 commits into 1 single commit:</source>
          <target state="translated">最後の10回のコミットを1つのコミットにつぶす。</target>
        </trans-unit>
        <trans-unit id="d453af1b2806f0771f8120f5f48b125b16f17109" translate="yes" xml:space="preserve">
          <source>Translation: provide a new &quot;editor&quot; for git which, if the filename to be edited is &lt;code&gt;git-rebase-todo&lt;/code&gt; (the interactive rebase prompt) changes all but the first &quot;pick&quot; to &quot;squash&quot;, and otherwise spawns vim - so that when you're prompted to edit the squashed commit message, you get vim. (And obviously I was squashing the last five commits on branch foo, but you could change that however you like.)</source>
          <target state="translated">翻訳：gitに新しい「エディター」を提供します。編集するファイル名が &lt;code&gt;git-rebase-todo&lt;/code&gt; （インタラクティブなリベースプロンプト）の場合、最初の「pick」以外のすべてを「squash」に変更し、それ以外の場合はvimを生成します。押しつぶされたコミットメッセージを編集するように求められたら、vimが表示されます。 （そして明らかに私はブランチfooの最後の5つのコミットを押しつぶしていましたが、好きなように変更することができます。）</target>
        </trans-unit>
        <trans-unit id="2e04cd50a2d8a6e325a64a9e9d1e89bf9850e0a7" translate="yes" xml:space="preserve">
          <source>Update like below &lt;code&gt;pick&lt;/code&gt; one commit and &lt;code&gt;squash&lt;/code&gt; the others into the most recent,</source>
          <target state="translated">以下のように更新して、1つのコミットを &lt;code&gt;pick&lt;/code&gt; 、他のコミットを最新のものに &lt;code&gt;squash&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="10c4aabc7d6d07adf02cb1c2e40e88d5732500a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; and replace &quot;pick&quot; on the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;, as described in &lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;the manual&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;マニュアルに&lt;/a&gt;記載されているように、 &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; を使用し、2回目以降のコミットの「pick」を「squash」または「fixup」に置き換えます 。</target>
        </trans-unit>
        <trans-unit id="1f1b9ab9a0e0959c8d60301c1dd590795036c32e" translate="yes" xml:space="preserve">
          <source>WARNING: First make sure you commit your work&amp;mdash;check that &lt;code&gt;git status&lt;/code&gt; is clean (since &lt;code&gt;git reset --hard&lt;/code&gt; will throw away staged and unstaged changes)</source>
          <target state="translated">警告：最初に作業をコミットしてください &lt;code&gt;git reset --hard&lt;/code&gt; &lt;code&gt;git status&lt;/code&gt; がクリーンであることを確認してください（ git reset --hardはステージングされた変更とステージングされていない変更を破棄するため）</target>
        </trans-unit>
        <trans-unit id="52065276a52b15005dd5aee61d9b2417c0b2ced8" translate="yes" xml:space="preserve">
          <source>What about an answer for the question related to a workflow like this?</source>
          <target state="translated">このようなワークフローに関連した質問の回答はどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="387737056476baadea4c3b6310eccb9d5e50141c" translate="yes" xml:space="preserve">
          <source>What can be really convenient:</source>
          <target state="translated">本当に便利になるもの。</target>
        </trans-unit>
        <trans-unit id="765789c174c2479941c09177922e1d21cc6827fc" translate="yes" xml:space="preserve">
          <source>What i did is</source>
          <target state="translated">私がしたことは</target>
        </trans-unit>
        <trans-unit id="d21b0bcb168b83ca89e96c0b658ad9d3fc1df640" translate="yes" xml:space="preserve">
          <source>When closing the editor, the fix will get squashed into the feature commit and my commit history will look nice and clean!</source>
          <target state="translated">エディタを閉じると、修正はフィーチャーコミットにつぶされ、私のコミット履歴はきれいに見えるようになります。</target>
        </trans-unit>
        <trans-unit id="d4ceba0e28653571c383b8285d758678e129e217" translate="yes" xml:space="preserve">
          <source>You can do this fairly easily without &lt;code&gt;git rebase&lt;/code&gt; or &lt;code&gt;git merge --squash&lt;/code&gt;. In this example, we'll squash the last 3 commits.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; や &lt;code&gt;git merge --squash&lt;/code&gt; を使わなくても、これはかなり簡単に行えます。 この例では、最後の3つのコミットを押しつぶします。</target>
        </trans-unit>
        <trans-unit id="757adf068d4225d6c149a530d9e62dc3a26e1485" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git merge --squash&lt;/code&gt; for this, which is slightly more elegant than &lt;code&gt;git rebase -i&lt;/code&gt;.  Suppose you're on master and you want to squash the last 12 commits into one.</source>
          <target state="translated">これには &lt;code&gt;git merge --squash&lt;/code&gt; を使用できます。これは &lt;code&gt;git rebase -i&lt;/code&gt; よりも少しエレガントです。 あなたがマスターであり、最後の12のコミットを1つにつぶしたいとします。</target>
        </trans-unit>
        <trans-unit id="71fb008e5d4b8f4decb5fc1d8418a270127e8380" translate="yes" xml:space="preserve">
          <source>You may also change the order of the commits. This allows you to squash or fixup commits that are not adjacent chronologically.</source>
          <target state="translated">コミットの順番を変更することもできます。これにより、時系列的に隣接していないコミットを潰したり、修正したりすることができます。</target>
        </trans-unit>
        <trans-unit id="f67e78ddf7e52bc3a80985eea97c30cace0d72aa" translate="yes" xml:space="preserve">
          <source>You opened a pull request and on GitHub you see this:</source>
          <target state="translated">プルリクエストを開いて、GitHub上ではこのように表示されています。</target>
        </trans-unit>
        <trans-unit id="6f42ea37efb2330eb9f8ae87f778d2109ad00e3b" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;~/.gitconfig&lt;/code&gt; should now contain this alias:</source>
          <target state="translated">&lt;code&gt;~/.gitconfig&lt;/code&gt; 次のエイリアスが含まれているはずです：</target>
        </trans-unit>
        <trans-unit id="758b9ac3be25f469194a9e3fd22799cf55e4cc10" translate="yes" xml:space="preserve">
          <source>edit and commit a lot locally, merge master regularly</source>
          <target state="translated">ローカルで多くの編集とコミットを行い、定期的にマスターをマージする</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="e0d33137a7b35fa4c2c656343c06f10e9f77b403" translate="yes" xml:space="preserve">
          <source>finally a push to remote,</source>
          <target state="translated">最後にリモートへの一押し。</target>
        </trans-unit>
        <trans-unit id="4b04d2a98dc3f0fd0b938cafe5761aa32fafe654" translate="yes" xml:space="preserve">
          <source>for example &lt;code&gt;git log --graph&lt;/code&gt; outputs the following (simplified):</source>
          <target state="translated">たとえば &lt;code&gt;git log --graph&lt;/code&gt; は以下を出力します（簡略化）：</target>
        </trans-unit>
        <trans-unit id="d76620ae96c7ca431e1db5376c1cfcf85d087916" translate="yes" xml:space="preserve">
          <source>git commit</source>
          <target state="translated">git commit</target>
        </trans-unit>
        <trans-unit id="371e49a0b18c50d82d292aef71ea992421ef9133" translate="yes" xml:space="preserve">
          <source>git push origin (branch_name) --force</source>
          <target state="translated">git push origin (branch_name)--force</target>
        </trans-unit>
        <trans-unit id="56322e172fdd72aded4057a4a7b371ca73775805" translate="yes" xml:space="preserve">
          <source>git reset --soft Head~3 &amp;amp;&amp;amp;</source>
          <target state="translated">git reset --soft Head〜3 &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="946fc396fd4b258f758878e94fa72b2ed7382c42" translate="yes" xml:space="preserve">
          <source>if for example you want to squash the last 3 commits to a single commit in a branch(remote repository) in for example: &lt;a href=&quot;https://bitbucket.org&quot;&gt;https://bitbucket.org&lt;/a&gt;</source>
          <target state="translated">たとえば、最後の3つのコミットをブランチ（リモートリポジトリ）の単一のコミットに押しつぶしたい場合は、たとえば、 &lt;a href=&quot;https://bitbucket.org&quot;&gt;https&lt;/a&gt; ： //bitbucket.org</target>
        </trans-unit>
        <trans-unit id="611d5f9682115beec752b912992f91f4d6631a4e" translate="yes" xml:space="preserve">
          <source>many local commits, &lt;em&gt;mixed with multiple merges FROM master&lt;/em&gt;,</source>
          <target state="translated">多くのローカルコミット、 &lt;em&gt;複数のマージFROMマスターが混在&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1d1f78c97a0cfa141dba4aa92f53b7119108001" translate="yes" xml:space="preserve">
          <source>n(=4 here) is the number of last commit. Then you got following options,</source>
          <target state="translated">n(ここでは4)は最後にコミットした回数です。そうすると、以下のようなオプションがあります。</target>
        </trans-unit>
        <trans-unit id="a06e25653856f59ec61310038b0e76e461953e35" translate="yes" xml:space="preserve">
          <source>p, pick  = use commit</source>
          <target state="translated">p,pick=use commit</target>
        </trans-unit>
        <trans-unit id="e4ae77df54121cf3234bc6148af99f1b9c9169e9" translate="yes" xml:space="preserve">
          <source>s, squash  = use commit, but meld into previous commit</source>
          <target state="translated">s,squash=コミットを使用するが、前のコミットに合わせる</target>
        </trans-unit>
        <trans-unit id="f60c1a720971c0a3baf938460a4d4f212174afca" translate="yes" xml:space="preserve">
          <source>the editor pops up again with a default message for the new commit: change it to your needs, save and close. Squash completed!</source>
          <target state="translated">をクリックすると、新しいコミットのためのデフォルトのメッセージが再びポップアップ表示されます。Squash が完成しました。</target>
        </trans-unit>
        <trans-unit id="14373bc7f8d111bad35942b43a801f430a7d6401" translate="yes" xml:space="preserve">
          <source>the editor pops up, showing the list of commits I want to merge. Now they are displayed in &lt;em&gt;reverse order&lt;/em&gt;: the older commit is on top. Mark as &quot;squash&quot; or &quot;s&quot; all the commits in there &lt;em&gt;except the first/older one&lt;/em&gt;: it will be used as a starting point. Save and close the editor;</source>
          <target state="translated">エディターがポップアップし、マージしたいコミットのリストが表示されます。 現在、それらは&lt;em&gt;逆の順序で&lt;/em&gt;表示されています。古いコミットが一番上にあります。 &lt;em&gt;最初の/古いものを除いて&lt;/em&gt; 、そこにあるすべてのコミットを「スカッシュ」または「s」としてマークします。これは開始点として使用されます。 エディターを保存して閉じます。</target>
        </trans-unit>
        <trans-unit id="fdadc9f4e4d7f36a7d4ff5b5e8ef900c37504ed9" translate="yes" xml:space="preserve">
          <source>then you squash into B0 changes of H0, H1, H2 (losing completely commits for changes after branching and before merge.</source>
          <target state="translated">そして、H0,H1,H2 の変更を B0 に押し込んでしまいます (ブランチ後とマージ前の変更のコミットを完全に失うことになります)。</target>
        </trans-unit>
        <trans-unit id="857ce54ac9c9e1932a376ea4c0ed0fa4f8b713ad" translate="yes" xml:space="preserve">
          <source>where the number of ^'s is X</source>
          <target state="translated">ここで、^の数はX</target>
        </trans-unit>
        <trans-unit id="9cd599249730cbcaaa3eaaca4c150509b03fe784" translate="yes" xml:space="preserve">
          <source>⚠️ WARNING: &quot;My last X commits&quot; might be ambiguous.</source>
          <target state="translated">⚠️ 警告:「私の最後のXコミット」は曖昧な場合があります。</target>
        </trans-unit>
        <trans-unit id="257eca43111b6053a03fada07551d11187f131cc" translate="yes" xml:space="preserve">
          <source>🐻 MORAL OF THE STORY</source>
          <target state="translated">🐻 この話の教訓</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
