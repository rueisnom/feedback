<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5189560">
    <body>
      <group id="5189560">
        <trans-unit id="0f6e71b1a03ea4118f8aca590d18524c56b24e91" translate="yes" xml:space="preserve">
          <source>(in this case, squash the two last commits)</source>
          <target state="translated">(이 경우 마지막 커밋 두 개를 스쿼시하십시오)</target>
        </trans-unit>
        <trans-unit id="00a75dfc6a363821c165dda8663912f8b12308bb" translate="yes" xml:space="preserve">
          <source>... Which automatically squashes together the last &lt;code&gt;N&lt;/code&gt; commits, inclusive.</source>
          <target state="translated">... 마지막 &lt;code&gt;N&lt;/code&gt; 커밋을 자동으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="e912fb518c6c899659dd36fc58ca72800c398da1" translate="yes" xml:space="preserve">
          <source>... or using Windows' Command Prompt:</source>
          <target state="translated">... 또는 Windows 명령 프롬프트 사용 :</target>
        </trans-unit>
        <trans-unit id="f9868bd7af9ea1a05d5a2cc3db7e9e630cb95cb1" translate="yes" xml:space="preserve">
          <source>1) Identify the commit short hash</source>
          <target state="translated">1) 커밋 쇼트 해시 식별</target>
        </trans-unit>
        <trans-unit id="a266d1bf09d724f5e01d17ae11e07a3b904343ee" translate="yes" xml:space="preserve">
          <source>1) git reset --soft HEAD~2 &amp;amp;&amp;amp; git commit -m&quot;&lt;strong&gt;message&lt;/strong&gt;&quot;</source>
          <target state="translated">1) git reset --soft HEAD ~ 2 &amp;amp;&amp;amp; git commit -m &quot; &lt;strong&gt;메시지&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="31bac7a25e633d602c5f07d013cf5bad6b5c8e6d" translate="yes" xml:space="preserve">
          <source>2) If you want to squash (merge) last two commit</source>
          <target state="translated">2) 마지막 두 커밋을 스쿼시 (병합)하려는 경우</target>
        </trans-unit>
        <trans-unit id="cbd711953c1351ee6a5326f8709d2fa00a65e56d" translate="yes" xml:space="preserve">
          <source>2) git push</source>
          <target state="translated">2) 자식 푸시</target>
        </trans-unit>
        <trans-unit id="ea65c50e6ab609f46f3b9dff142c828dcb7a2b4c" translate="yes" xml:space="preserve">
          <source>3) This opens up a &lt;code&gt;nano&lt;/code&gt; editor for merging. And it looks like below</source>
          <target state="translated">3) 병합을위한 &lt;code&gt;nano&lt;/code&gt; 편집기가 열립니다. 그리고 그것은 아래와 같습니다</target>
        </trans-unit>
        <trans-unit id="78b84c9eba8b454d71ff15e78d7b205c76275eca" translate="yes" xml:space="preserve">
          <source>4) Rename the word &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; which is present before &lt;code&gt;abcd1234&lt;/code&gt;. After rename it should be like below.</source>
          <target state="translated">4) &lt;code&gt;pick&lt;/code&gt; 이라는 단어를 &lt;code&gt;abcd1234&lt;/code&gt; 이전에 존재하는 &lt;code&gt;squash&lt;/code&gt; 로 이름을 바꿉니다. 이름을 바꾼 후에는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="71b14741158ee8ef04c0060e1f8a21f8fb3b1e25" translate="yes" xml:space="preserve">
          <source>5) Now save and close the &lt;code&gt;nano&lt;/code&gt; editor. Press &lt;code&gt;ctrl + o&lt;/code&gt; and press &lt;code&gt;Enter&lt;/code&gt; to save. And then press &lt;code&gt;ctrl + x&lt;/code&gt; to exit the editor.</source>
          <target state="translated">5) 이제 &lt;code&gt;nano&lt;/code&gt; 편집기를 저장하고 닫습니다. &lt;code&gt;ctrl + o&lt;/code&gt; 를 누르고 &lt;code&gt;Enter&lt;/code&gt; 를 눌러 저장하십시오. 그런 다음 &lt;code&gt;ctrl + x&lt;/code&gt; 를 눌러 편집기를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="85cf74b710242b910482c040916448edae877361" translate="yes" xml:space="preserve">
          <source>6) Then &lt;code&gt;nano&lt;/code&gt; editor again opens for updating comments, if necessary update it.</source>
          <target state="translated">6) 그런 다음 필요에 따라 주석을 업데이트하기 위해 &lt;code&gt;nano&lt;/code&gt; 편집기가 다시 열립니다.</target>
        </trans-unit>
        <trans-unit id="dfc29b1eb351d0fcd6446b260cefa0750b92fd58" translate="yes" xml:space="preserve">
          <source>7) Now its squashed successfully, you can verify it by checking logs.</source>
          <target state="translated">7) 이제 성공적으로 뭉개졌습니다. 로그를 확인하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0534fb54df6a2793525c086550d32e11a5d6cdf6" translate="yes" xml:space="preserve">
          <source>8) Now push to repo. Note to add &lt;code&gt;+&lt;/code&gt; sign before the branch name. This means forced push.</source>
          <target state="translated">8) 이제 repo로 밉니다. 지점 이름 앞에 &lt;code&gt;+&lt;/code&gt; 부호를 추가하십시오. 이것은 강제 푸시를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="060566f0626a9c056933505d6f6cf04d52e947e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;Anomies answer&lt;/a&gt; is good, but I felt insecure about this so I decided to add a couple of screenshots.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5189600/562769&quot;&gt;Anomies의 대답&lt;/a&gt; 은 좋지만, 이것에 대해 불안감을 느꼈기 때문에 몇 개의 스크린 샷을 추가하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="0aa246496b4e1fd607eb4727df2b1c6b2fd5d5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt;  // puts all changes in stage</source>
          <target state="translated">&lt;code&gt;git merge --squash new-branch-temp&lt;/code&gt; // 모든 변경 사항을 스테이지에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7055a5977843ebb56fc6cf1a7433d6529c41d611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; , where N is the number of commits I want to join, &lt;em&gt;starting from the most recent one&lt;/em&gt;. So &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; would mean &quot;squash the last 5 commits into a new one&quot;;</source>
          <target state="translated">&lt;code&gt;git rebase -i HEAD~[N]&lt;/code&gt; 여기서 N은 &lt;em&gt;가장 최근에 시작한&lt;/em&gt; 커밋 수입니다. &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; 는 &quot;마지막 5 개의 커밋을 새로운 것으로 스쿼시&quot;하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4f4ea95712f9097dba8f82df029c2063fe45d6db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; the only real advantage of this method over the simpler &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; suggested by Chris Johnsen in &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5201642#5201642&quot;&gt;his answer&lt;/a&gt; is that you get the commit message prepopulated with every commit message that you're squashing.</source>
          <target state="translated">&lt;em&gt;업데이트 :&lt;/em&gt; Chris Johnsen이 제안한 간단한 &lt;code&gt;git reset --soft HEAD~12 &amp;amp;&amp;amp; git commit&lt;/code&gt; 방법의 유일한 장점은 스쿼시하는 모든 커밋 메시지로 커밋 메시지가 미리 채워져 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7bc1abce6232c8b6c9b96cbc89e3473e9d63b768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A practical everyday example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실용적인 일상 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68214ab4e4aca49ed9688ab7ba5060c6d11a94f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the interactive rebase editor:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;대화식 rebase 편집기 사용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab98be530e6bee8cd013851490d34d6048cd6904" translate="yes" xml:space="preserve">
          <source>Add Christine Perfect</source>
          <target state="translated">Christine Perfect 추가</target>
        </trans-unit>
        <trans-unit id="bfb4f0dc3070ad453043d38a7fd9f425d739332c" translate="yes" xml:space="preserve">
          <source>Add Danny Kirwan</source>
          <target state="translated">대니 커완 추가</target>
        </trans-unit>
        <trans-unit id="7aa7c343556333bbf1afb97214bb9452da86a2bf" translate="yes" xml:space="preserve">
          <source>Add a global &quot;squash&quot; alias from bash: (or Git Bash on Windows)</source>
          <target state="translated">bash에서 전역 &quot;스쿼시&quot;별칭 추가 : (또는 Windows의 Git Bash)</target>
        </trans-unit>
        <trans-unit id="b1b79d483720ae24eec3e5adbd6ca57ec881cd82" translate="yes" xml:space="preserve">
          <source>Advantage of 1st procedure is to squash multiple commits and to reorder. But this procedure will be difficult if we need to merge a fix to very old commit.</source>
          <target state="translated">첫 번째 절차의 장점은 여러 커밋을 스쿼시하고 재정렬하는 것입니다. 그러나 수정 사항을 아주 오래된 커밋에 병합해야하는 경우이 절차는 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="7868a386b46b1e0c5a783fd920cb3a86a91ca21b" translate="yes" xml:space="preserve">
          <source>After rebase will finish you can choose message for squashed H0 and B0:</source>
          <target state="translated">리베이스가 완료되면 찌그러진 H0 및 B0에 대한 메시지를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48786ade9458227291ecdfcbc328a0b9a48bba9c" translate="yes" xml:space="preserve">
          <source>After save and exit rebase will apply commits in turn after H1. That means that it will ask you to resolve conflicts again (where HEAD will be H1 at first and then accumulating commits as they are applied).</source>
          <target state="translated">저장 후 종료 후 rebase는 H1 이후에 커밋을 차례로 적용합니다. 즉, 충돌을 다시 해결하도록 요청합니다 (처음에는 HEAD가 H1이되고 적용되는 커밋이 누적 됨).</target>
        </trans-unit>
        <trans-unit id="b90a4b8a8c8bb781c2de8719251307f780e35ad0" translate="yes" xml:space="preserve">
          <source>And what happens? You just made single commit that get from Fritz to Bill Clinton. Because you forgot that yesterday you were working on the Buckingham Nicks version of this project. And &lt;code&gt;git log&lt;/code&gt; doesn't match what you see on GitHub.</source>
          <target state="translated">그리고 어떻게됩니까? 프리츠에서 빌 클린턴까지 한 번 커밋했습니다. 어제 잊어 버렸기 때문에이 프로젝트의 Buckingham Nicks 버전을 작업하고있었습니다. 그리고 &lt;code&gt;git log&lt;/code&gt; 는 GitHub에서 보이는 것과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="093e99d3dbc1e1d8c95fe7ba70003dcb67751c12" translate="yes" xml:space="preserve">
          <source>As the commit on line 1 is &lt;code&gt;HEAD&lt;/code&gt;, in most cases you would leave this as &lt;code&gt;pick&lt;/code&gt;. 
 You cannot use &lt;code&gt;squash&lt;/code&gt; or &lt;code&gt;fixup&lt;/code&gt; as there is no other commit to squash the commit into.</source>
          <target state="translated">라인 1의 커밋이 &lt;code&gt;HEAD&lt;/code&gt; 이므로 대부분의 경우 이것을 &lt;code&gt;pick&lt;/code&gt; 으로 남겨 두어야합니다. 커밋을 스쿼시하려는 다른 커밋이 없으므로 &lt;code&gt;squash&lt;/code&gt; 또는 &lt;code&gt;fixup&lt;/code&gt; 을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b41b6bdffa611514466e9905a87e0b849f5fdea" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;this article&lt;/a&gt; I found this method easier for my usecase.</source>
          <target state="translated">&lt;a href=&quot;http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&quot;&gt;이 기사를&lt;/a&gt; 바탕으로이 방법이 유스 케이스에 더 쉽다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="e29ab6f60ee8c7e67c1f6b510f26b71c099d14d4" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;Chris Johnsen's answer&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5201642/1580288&quot;&gt;Chris Johnsen의 답변을&lt;/a&gt; 바탕으로</target>
        </trans-unit>
        <trans-unit id="9a1a2639cbe33c22eb5dbb88182e215a85ff59b4" translate="yes" xml:space="preserve">
          <source>Bill Clinton</source>
          <target state="translated">빌 클린턴</target>
        </trans-unit>
        <trans-unit id="e91185e515d9c1ad67ebd9560c54d10d75f7605a" translate="yes" xml:space="preserve">
          <source>Both of those methods squash the last three commits into a single new commit in the same way. The soft reset just re-points HEAD to the last commit that you do not want to squash. Neither the index nor the working tree are touched by the soft reset, leaving the index in the desired state for your new commit (i.e. it already has all the changes from the commits that you are about to &amp;ldquo;throw away&amp;rdquo;).</source>
          <target state="translated">이 두 가지 방법 모두 마지막 세 개의 커밋을 같은 방식으로 하나의 새로운 커밋으로 스쿼시합니다. 소프트 리셋은 스쿼시하지 않으려는 마지막 커밋으로 HEAD를 다시 가리 킵니다. 소프트 재설정으로 인덱스와 작업 트리를 건드리지 않고 새 커밋에 대해 원하는 상태로 인덱스를 유지합니다 (즉, 이미 &quot;버려두려고하는 커밋의 모든 변경 사항이 이미 있습니다&quot;).</target>
        </trans-unit>
        <trans-unit id="11d466714aac7655883761ed97c5295c4bfdafbb" translate="yes" xml:space="preserve">
          <source>Check out the target branch (e.g. 'master')</source>
          <target state="translated">대상 지점을 확인하십시오 (예 : '마스터')</target>
        </trans-unit>
        <trans-unit id="4fc0c1dfdb777b642cb8be476d33324610a18450" translate="yes" xml:space="preserve">
          <source>Checkout the golden repo</source>
          <target state="translated">골든 레포 확인</target>
        </trans-unit>
        <trans-unit id="828d4675ea69be7bbbd51d39ea75d7e2c353989c" translate="yes" xml:space="preserve">
          <source>Commit your changes (this will be the only commit that goes in dev-branch)</source>
          <target state="translated">변경 사항을 커밋하십시오 (dev-branch로 진행되는 유일한 커밋입니다)</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="8affcece617012629577cf8bfabbbc0cbdccf5e6" translate="yes" xml:space="preserve">
          <source>Create a new branch from it(golden repo) as follows</source>
          <target state="translated">다음과 같이 새 지점 (골든 리포지토리)을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="51a53ea31f4f996d5387d6d4244348d9a9522bfe" translate="yes" xml:space="preserve">
          <source>Execute &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;&lt;code&gt;git rebase -i [your hash]&lt;/code&gt;&lt;/a&gt;, in my case:</source>
          <target state="translated">내 경우에는 &lt;a href=&quot;https://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt; &lt;code&gt;git rebase -i [your hash]&lt;/code&gt; 를&lt;/a&gt; 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac8b133f58886974b11bc6af37c28baf4d4c4593" translate="yes" xml:space="preserve">
          <source>Find the commit hash you want to squash on top of, say &lt;code&gt;d43e15&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d43e15&lt;/code&gt; 와 같이 스쿼시하려는 커밋 해시를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="16fe861b00c32729b8570a41dd960986992c8977" translate="yes" xml:space="preserve">
          <source>Find the exact files you want to get &lt;em&gt;to&lt;/em&gt;, and &lt;code&gt;git checkout&lt;/code&gt; them</source>
          <target state="translated">원하는 정확한 파일을 찾고 &lt;code&gt;git checkout&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="513ddb206d72ddd403d65e37a963ba3c61af9ca1" translate="yes" xml:space="preserve">
          <source>Find the exact prior commit you want to keep in history, and &lt;code&gt;git reset --soft&lt;/code&gt; that</source>
          <target state="translated">기록에 유지하려는 정확한 이전 커밋을 찾고 &lt;code&gt;git reset --soft&lt;/code&gt; that</target>
        </trans-unit>
        <trans-unit id="cbff6a6b4ceaa070a2583eb67ba786884ec2dce3" translate="yes" xml:space="preserve">
          <source>First I find out the number of commits between my feature branch and current master branch by</source>
          <target state="translated">먼저 기능 지점과 현재 마스터 지점 사이의 커밋 수를</target>
        </trans-unit>
        <trans-unit id="b17781596baa10e42e5d27e04c27b98e980cac0e" translate="yes" xml:space="preserve">
          <source>First add the required files for commit</source>
          <target state="translated">먼저 커밋에 필요한 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e3a67cef2cd706c75ce38bcabf3f0ff9e944ae90" translate="yes" xml:space="preserve">
          <source>For details click on the &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;Link&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&quot;&gt;&lt;strong&gt;링크를&lt;/strong&gt;&lt;/a&gt; 클릭하십시오</target>
        </trans-unit>
        <trans-unit id="af1603c24d4db6e43caf6f4bf93db855e59a5472" translate="yes" xml:space="preserve">
          <source>For example, if you are looking to merge all the commits into one, the 'pick' is the first commit you made and all future ones (placed below the first) should be set to 'squash'. If using vim, use &lt;strong&gt;:x&lt;/strong&gt; in insert mode to save and exit the editor.</source>
          <target state="translated">예를 들어, 모든 커밋을 하나로 병합하려는 경우 'pick'은 첫 번째 커밋이며 이후의 모든 커밋 (첫 번째 아래에 배치)은 'squash'로 설정해야합니다. vim을 사용하는 경우 삽입 모드에서 &lt;strong&gt;: x&lt;/strong&gt; 를 사용하여 편집기를 저장하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e5634b5e021244ee271ad922152ae052ceecc536" translate="yes" xml:space="preserve">
          <source>For more on this and other ways to rewrite your commit history see &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;this helpful post&lt;/a&gt;</source>
          <target state="translated">커밋 기록을 다시 작성하는 방법과 다른 방법에 대한 자세한 내용은 &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&quot;&gt;이 유용한 게시물을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc8b719f20cf72ebfb1459a1756eda92bcc9e219" translate="yes" xml:space="preserve">
          <source>Four commits:</source>
          <target state="translated">네 가지 커밋 :</target>
        </trans-unit>
        <trans-unit id="0ff5edf7ba7c13b10c729d9325013204a570385b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;^&lt;/code&gt; means the previous commit to &lt;code&gt;OLDCOMMIT&lt;/code&gt;. This &lt;code&gt;rebase&lt;/code&gt; command opens interactive window on a editor (vim or nano) on that
we no need to do anything just save and exiting is sufficient. Because the option passed to this will automatically move the latest
commit to next to old commit and change the operation to &lt;code&gt;fixup&lt;/code&gt; (equivalent to squash). Then rebase continues and finishes.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 는 &lt;code&gt;OLDCOMMIT&lt;/code&gt; 에 대한 이전 커밋을 의미합니다. 이 &lt;code&gt;rebase&lt;/code&gt; 명령은 편집기 (vim 또는 nano)에서 대화식 창을 열어 저장하고 종료하기 만하면됩니다. 이 옵션이 전달되면 최신 커밋이 이전 커밋 옆으로 자동 이동되고 작업을 &lt;code&gt;fixup&lt;/code&gt; (스쿼시와 동일)으로 변경합니다. 그런 다음 리베이스가 계속되고 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="1ab294f6db6b416c34905212bef55947aeddd00a" translate="yes" xml:space="preserve">
          <source>Here even &lt;code&gt;git log --oneline&lt;/code&gt; also can be used to get short hash.</source>
          <target state="translated">여기에서도 &lt;code&gt;git log --oneline&lt;/code&gt; 조차도 짧은 해시를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abfc9c95a5a36468169f0e59eed3b53351764f57" translate="yes" xml:space="preserve">
          <source>Hope it helps, thanks.</source>
          <target state="translated">도움이 되길 바랍니다. 감사합니다.</target>
        </trans-unit>
        <trans-unit id="e9acce96a379cc84dadce50a2a0d0c8a84bd8163" translate="yes" xml:space="preserve">
          <source>How can I squash my last X commits together into one commit using Git?</source>
          <target state="translated">마지막 X 커밋을 Git을 사용하여 하나의 커밋으로 어떻게 스쿼시 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b3aa1fa40cb10cce596ab2f6735206a7a54e21a1" translate="yes" xml:space="preserve">
          <source>How many commits u need to merge, u need to give next that HEAD(like this HEAD~2)</source>
          <target state="translated">병합해야 할 커밋 수, 다음 HEAD를 제공해야합니다 (이 HEAD ~ 2)</target>
        </trans-unit>
        <trans-unit id="01e83eedbee0bac8113da661371c9e862faa5901" translate="yes" xml:space="preserve">
          <source>I find a more generic solution is not to specify 'N' commits, but rather the branch/commit-id you want to squash on top of.  This is less error-prone than counting the commits up to a specific commit&amp;mdash;just specify the tag directly, or if you really want to count you can specify HEAD~N.</source>
          <target state="translated">더 일반적인 해결책은 'N'커밋을 지정하는 것이 아니라 스쿼시하려는 분기 / 커밋 ID를 찾는 것입니다. 이는 특정 커밋까지 커밋을 계산하는 것보다 오류가 덜 발생합니다. 태그를 직접 지정하거나 실제로 계산하려면 HEAD ~ N을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f7cd9bd7d23b350c09940eb410992e9fe3d486" translate="yes" xml:space="preserve">
          <source>I haven't seen a workflow like that on this page. (That may be my eyes.) If I understand &lt;code&gt;rebase&lt;/code&gt; correctly, multiple merges would require &lt;strong&gt;multiple conflict resolutions&lt;/strong&gt;. I do NOT want even to think about that!</source>
          <target state="translated">이 페이지에서 이와 같은 워크 플로를 보지 못했습니다. (그것이 내 눈일지도 모른다.) 내가 &lt;code&gt;rebase&lt;/code&gt; 올바르게 이해한다면, 여러 번의 병합은 &lt;strong&gt;여러 개의 충돌 해결을&lt;/strong&gt; 요구할 것이다. 나는 그것에 대해 생각조차하고 싶지 않습니다!</target>
        </trans-unit>
        <trans-unit id="b87f73f2e8db36e6d71fb06157044e936572698f" translate="yes" xml:space="preserve">
          <source>I prefer to use the command &lt;code&gt;fixup&lt;/code&gt; as this &quot;squashes&quot; the commit's changes into the commit on the line above and discards the commit's message.</source>
          <target state="translated">위의 줄에서 커밋 변경 사항을 &quot;스쿼시&quot;하고 커밋 메시지를 삭제하므로 명령 &lt;code&gt;fixup&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11f555b9e44717e3b66217f13f903c4371b5dda4" translate="yes" xml:space="preserve">
          <source>I recommend avoiding &lt;code&gt;git reset&lt;/code&gt; when possible -- especially for Git-novices.  Unless you really need to automate a process based on a &lt;em&gt;number&lt;/em&gt; of commits, there is a less exotic way...</source>
          <target state="translated">가능하면 &lt;code&gt;git reset&lt;/code&gt; 을 피하는 것이 좋습니다-특히 Git-novices의 경우. &lt;em&gt;많은&lt;/em&gt; 커밋을 기반으로 프로세스를 자동화 해야하는 경우가 아니라면 덜 이국적인 방법이 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="3dca227ddd161112834d5cf5d8d8bf15553d4ddf" translate="yes" xml:space="preserve">
          <source>I then run &lt;code&gt;git log&lt;/code&gt; or &lt;code&gt;gitk&lt;/code&gt; and get the commit SHA of the new feature (in this case &lt;code&gt;1ff9460&lt;/code&gt;).</source>
          <target state="translated">그런 다음 &lt;code&gt;git log&lt;/code&gt; 또는 &lt;code&gt;gitk&lt;/code&gt; 를 실행하고 새로운 기능 (이 경우 &lt;code&gt;1ff9460&lt;/code&gt; )의 커밋 SHA를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9bc0e663b42f4c03fed1ae440e72de7476b8085f" translate="yes" xml:space="preserve">
          <source>I think the easiest way to do this is by making a new branch off of master and doing a merge --squash of the feature branch.</source>
          <target state="translated">가장 쉬운 방법은 마스터에서 새 브랜치를 만들고 기능 브랜치를 병합하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c58228448370201426a2ca0267ec9560383413e8" translate="yes" xml:space="preserve">
          <source>I use the alias:</source>
          <target state="translated">별명을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="86001cc8c4eed6dfdd49e895d88ca2295d3b8afd" translate="yes" xml:space="preserve">
          <source>I wanted to squash these commits into one before pushing the change. I prefere to reset the branch to the state of 'origin/dev' (this will leave all changes from the 96 commits unstaged) and then commit the changes at once:</source>
          <target state="translated">변경 사항을 추진하기 전에 이러한 커밋을 하나로 스쿼시하고 싶었습니다. 분기를 'origin / dev'상태로 재설정하고 (96 커밋의 모든 변경 사항을 스테이지되지 않은 상태로 유지) 변경 사항을 한 번에 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="3ef5f47215cc877254b4c604b64a56fd37c0c5dd" translate="yes" xml:space="preserve">
          <source>I'd probably do what &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair suggested&lt;/a&gt;, though.</source>
          <target state="translated">그래도 &lt;a href=&quot;https://stackoverflow.com/questions/5189560/how-can-i-squash-my-last-x-commits-together-using-git/5190323#5190323&quot;&gt;Mark Longair가 제안한 것을&lt;/a&gt; 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d1dbb1610551849ad4b8eb20bae4c982b7e33d6" translate="yes" xml:space="preserve">
          <source>I've recently committed a new feature.  Since then, I have committed two bug fixes.  But now I have discovered a bug (or maybe just a spelling error) in the new feature I committed.  How annoying!  I don't want a new commit polluting my commit history!</source>
          <target state="translated">최근에 새로운 기능을 커밋했습니다. 그 이후로 두 가지 버그 수정을했습니다. 그러나 이제는 내가 저지른 새로운 기능에서 버그 (또는 철자 오류)를 발견했습니다. 짜증나! 커밋 기록을 오염시키는 새로운 커밋을 원하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="600ba8b07c35f3aa98f10bd9215d0c431e3ac6f8" translate="yes" xml:space="preserve">
          <source>If you also want to update the remote branch with the squashed commit:</source>
          <target state="translated">또한 중단 된 커밋으로 원격 지점을 업데이트하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="c8107381ad7a4e9bfcfe1e4bfd58c9168ef6516d" translate="yes" xml:space="preserve">
          <source>If you are on a remote branch(called &lt;code&gt;feature-branch&lt;/code&gt;) cloned from a Golden Repository(&lt;code&gt;golden_repo_name&lt;/code&gt;), then here's the technique to squash your commits into one:</source>
          <target state="translated">골든 리포지토리 ( &lt;code&gt;golden_repo_name&lt;/code&gt; )에서 복제 된 원격 브랜치 ( &lt;code&gt;feature-branch&lt;/code&gt; )에 있다면 커밋을 하나로 묶는 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f47536faa9331321aee23cdac3148266be1e42" translate="yes" xml:space="preserve">
          <source>If you don't care about the commit messages of the in-between commits, you can use</source>
          <target state="translated">중간 커밋의 커밋 메시지에 신경 쓰지 않으면 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="787518d9bc259dac56a32f39ea1e2a792a17531f" translate="yes" xml:space="preserve">
          <source>If you have picked only one commit and squashed the rest, you can adjust one commit message:</source>
          <target state="translated">커밋을 하나만 선택하고 나머지는 스쿼시 한 ​​경우 하나의 커밋 메시지를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b626aec01c288f93e9d5a110eb02bd59f405ad8" translate="yes" xml:space="preserve">
          <source>If you use TortoiseGit, you can the function &lt;code&gt;Combine to one commit&lt;/code&gt;:</source>
          <target state="translated">TortoiseGit을 사용하면 &lt;code&gt;Combine to one commit&lt;/code&gt; 함수 를 하나의 커밋에 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52aefe4131cf6e22141e6a89050a2d36c82447da" translate="yes" xml:space="preserve">
          <source>If you want to squish &lt;em&gt;every&lt;/em&gt; commit into a single commit (e.g. when releasing a project publicly for the first time), try:</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 커밋을 단일 커밋으로 뭉개 버리려면 (예 : 프로젝트를 처음 공개 할 때) 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="f827f77438492c15d0d2aa806bcc35f58430f25e" translate="yes" xml:space="preserve">
          <source>If you want to start editing the new commit message with a concatenation of the existing commit messages (i.e. similar to what a pick/squash/squash/&amp;hellip;/squash &lt;code&gt;git rebase -i&lt;/code&gt; instruction list would start you with), then you need to extract those messages and pass them to &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">기존 커밋 메시지를 연결하여 새 커밋 메시지를 편집하려면 (예 : pick / squash / squash /&amp;hellip; / squash &lt;code&gt;git rebase -i&lt;/code&gt; 명령 목록과 유사) 추출해야합니다. 해당 메시지를 &lt;code&gt;git commit&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="088b19cf941b3ff8da3b7eb151f8d881f3db1fff" translate="yes" xml:space="preserve">
          <source>If you want to write the new commit message from scratch, this suffices:</source>
          <target state="translated">새로운 커밋 메시지를 처음부터 작성하려면 다음과 같이 충분합니다.</target>
        </trans-unit>
        <trans-unit id="79f1ff9673cb765c19eb55c4d649e27cf47e1e06" translate="yes" xml:space="preserve">
          <source>If you're working with GitLab, you can just click the Squash option in the Merge Request as shown below. The commit message will be the title of the Merge Request.</source>
          <target state="translated">GitLab을 사용하는 경우 아래 그림과 같이 병합 요청에서 스쿼시 옵션을 클릭하면됩니다. 커밋 메시지는 병합 요청의 제목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a017ecd71bf7f57fd4ca564c4f4814ffbbbd55eb" translate="yes" xml:space="preserve">
          <source>In addition to other excellent answers, I'd like to add how &lt;code&gt;git rebase -i&lt;/code&gt; always confuses me with the commit order - older to newer one or vice versa? So this is my workflow:</source>
          <target state="translated">다른 훌륭한 답변 외에도 &lt;code&gt;git rebase -i&lt;/code&gt; 가 커밋 순서와 항상 혼동되는 방법을 추가하고 싶습니다. 이것이 내 워크 플로입니다.</target>
        </trans-unit>
        <trans-unit id="e0c5c08fbe43f01fe7feb65bad1556407d8bf81f" translate="yes" xml:space="preserve">
          <source>In my case, I want to squash everything on the commit that was first in time. The ordering is from first to last, so exactly the other way as in &lt;code&gt;git log&lt;/code&gt;. In my case, I want:</source>
          <target state="translated">제 경우에는 처음 커밋에 대한 모든 것을 스쿼시하고 싶습니다. 순서는 처음부터 끝이므로 &lt;code&gt;git log&lt;/code&gt; 와 같은 다른 방법입니다. 제 경우에는 다음을 원합니다.</target>
        </trans-unit>
        <trans-unit id="812b8ce0a931bda8d43ab639459be7c06897670f" translate="yes" xml:space="preserve">
          <source>In my workflow, I start a branch, and my first commit on that branch summarizes the goal (i.e. it's usually what I will push as the 'final' message for the feature to the public repository.)  So when I'm done, all I want to do is &lt;code&gt;git squash master&lt;/code&gt; back to the first message and then I'm ready to push.</source>
          <target state="translated">워크 플로에서 지점을 시작하면 해당 지점에 대한 첫 번째 커밋이 목표를 요약합니다 (즉, 일반적으로 해당 기능에 대한 '최종'메시지로 공용 리포지토리에 푸시하는 것입니다). 나는 &lt;code&gt;git squash master&lt;/code&gt; 를 첫 번째 메시지로 되돌리고 나서 푸시 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="cfebaa62652e8409b9f3689f76707285002e6e2c" translate="yes" xml:space="preserve">
          <source>In question it could be ambiguous what is meant by &quot;last&quot;.</source>
          <target state="translated">문제는 &quot;마지막&quot;의 의미가 모호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9306409d13d02f1d92a630f721830c055b515fbf" translate="yes" xml:space="preserve">
          <source>In the branch you would like to combine the commits on, run:</source>
          <target state="translated">지점에서 커밋을 결합하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="88c73138cde2bf54e60255d9bd740e5e58d9f261" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past the command is &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;&amp;lt;after-this-commit&amp;gt;&lt;/code&gt; 은 SHA1 해시이거나 rebase 명령에 대한 커밋이 분석되는 현재 분기의 HEAD로부터의 상대 위치입니다. 예를 들어, 사용자가 과거에 현재 HEAD에서 5 개의 커밋을 보려면 명령은 &lt;code&gt;git rebase -i HEAD~5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b0babcfbdf70396a1070d18ba28e5456936528f" translate="yes" xml:space="preserve">
          <source>In this very abbreviated history of the &lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt; repository you have opened a pull request to merge in the the Bill Clinton commit into the original (&lt;code&gt;MASTER&lt;/code&gt;) Fleetwood Mac commit.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/fleetwood-mac/band-history/about-our-band-starting-1967.md#i-cant-believe-you-actually-clicked-this&quot;&gt;https://github.com/fleetwood-mac/band-history&lt;/a&gt; 리포지토리의 매우 약식 기록에서 Bill Clinton 커밋을 원래 ( &lt;code&gt;MASTER&lt;/code&gt; ) Fleetwood Mac 커밋으로 병합하기위한 풀 요청을 열었습니다.</target>
        </trans-unit>
        <trans-unit id="bf126b3fade88997f0548ade26b8b5c4bfea4c6b" translate="yes" xml:space="preserve">
          <source>It's possible to use rebase but in different manner then in others mentioned answers:</source>
          <target state="translated">rebase를 사용할 수는 있지만 다른 방법으로 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="028bc2366d79ea4ef91789bfa66ae316236a417d" translate="yes" xml:space="preserve">
          <source>LA1974</source>
          <target state="translated">LA1974</target>
        </trans-unit>
        <trans-unit id="fb2a8991936042159a3bb1d749bea91292a31069" translate="yes" xml:space="preserve">
          <source>Lastly, I run</source>
          <target state="translated">마지막으로</target>
        </trans-unit>
        <trans-unit id="57fe6ea67ceef51616f8ae62d6f8e1cb4229da2f" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;git commit&lt;/code&gt; that warps directly from the &lt;em&gt;from&lt;/em&gt; to the &lt;em&gt;to&lt;/em&gt;</source>
          <target state="translated">시작부터 끝까지 직행하는 &lt;code&gt;git commit&lt;/code&gt; 만들기</target>
        </trans-unit>
        <trans-unit id="49e92ccd1adc445eb977e8a994e8fd9adc2bc217" translate="yes" xml:space="preserve">
          <source>Mark the relevant commits in the log view</source>
          <target state="translated">로그보기에서 관련 커밋을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="0fc0ad9a332750ab53c934b71eb3800bf3e4909a" translate="yes" xml:space="preserve">
          <source>My 'dev' branch was ahead of 'origin/dev' by 96 commits (so these commits were not pushed to the remote yet).</source>
          <target state="translated">내 'dev'브랜치는 96 커밋으로 'origin / dev'보다 앞서있었습니다 (따라서 커밋은 아직 원격으로 푸시되지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="8293f55e479d0410deb525c2426e813f0803e546" translate="yes" xml:space="preserve">
          <source>Next, I bring up the interactive rebase editor with &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt;.  The &lt;code&gt;~&lt;/code&gt; after the commit SHA tells the editor to include that commit in the editor.</source>
          <target state="translated">다음으로, &lt;code&gt;git rebase -i 1ff9460~&lt;/code&gt; 과 함께 대화 형 rebase 편집기를 불러옵니다. 커밋 SHA 이후의 &lt;code&gt;~&lt;/code&gt; 는 편집기에 해당 커밋을 포함하도록 편집기에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="a6117317363c016a257f2208f2a02cd8432aaabc" translate="yes" xml:space="preserve">
          <source>Next, I move the commit containing the fix (&lt;code&gt;fe7f1e0&lt;/code&gt;) to underneath the feature commit, and change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;fixup&lt;/code&gt;.</source>
          <target state="translated">다음으로 수정 사항 ( &lt;code&gt;fe7f1e0&lt;/code&gt; )이 포함 된 커밋을 기능 커밋 아래로 이동하고 &lt;code&gt;pick&lt;/code&gt; 을 &lt;code&gt;fixup&lt;/code&gt; 으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8423bc929eacf6c5159737bd94c0cbd3c5778996" translate="yes" xml:space="preserve">
          <source>Note : This is based on using git on &lt;code&gt;ubuntu&lt;/code&gt; shell. If you are using different os (&lt;code&gt;Windows&lt;/code&gt; or &lt;code&gt;Mac&lt;/code&gt;) then above commands are same except editor. You might get different editor.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;ubuntu&lt;/code&gt; 쉘에서 git 사용을 기반으로합니다. 다른 os ( &lt;code&gt;Windows&lt;/code&gt; 또는 &lt;code&gt;Mac&lt;/code&gt; )를 사용하는 경우 위의 명령은 편집기를 제외하고 동일합니다. 다른 편집기를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b053a3e9165bb14f6a88287ca972e8a2dce8ee" translate="yes" xml:space="preserve">
          <source>Note: The resultant commit message is a combination of all the squashed commits, in order. If you are unhappy with that, you can always &lt;code&gt;git commit --amend&lt;/code&gt; to modify it manually. (Or, edit the alias to match your tastes.)</source>
          <target state="translated">참고 : 결과 커밋 메시지는 모든 스와치 된 커밋을 순서대로 조합 한 것입니다. 당신이 그것에 만족하지 않으면, 당신은 항상 수동으로 수정하기 위해 &lt;code&gt;git commit --amend&lt;/code&gt; 할 수 있습니다. 또는 취향에 맞게 별칭을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="d6377f9be4e13e6d8f9e38c5003db9b8ab9af614" translate="yes" xml:space="preserve">
          <source>Now this creates a new commit on top of HEAD with &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;fixup1 &amp;lt;OLDCOMMIT_MSG&amp;gt;&lt;/code&gt; 를 사용 하여 HEAD 위에 새 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48a3a5484c6d47719f56ef39bf6dd2a38a49336a" translate="yes" xml:space="preserve">
          <source>Now use</source>
          <target state="translated">이제 사용</target>
        </trans-unit>
        <trans-unit id="3b3a3e1be78f40ef46e629b130884d7de89ba488" translate="yes" xml:space="preserve">
          <source>Open TortoiseGit context menu</source>
          <target state="translated">TortoiseGit 컨텍스트 메뉴 열기</target>
        </trans-unit>
        <trans-unit id="a5015e7e2cecbb5b2a96a0da08d780166899f93a" translate="yes" xml:space="preserve">
          <source>P.S. If you just do some reset to BO: 
(for example, using &lt;code&gt;reset --mixed&lt;/code&gt; that is explained in more detail here &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https://stackoverflow.com/a/18690845/2405850&lt;/a&gt;):</source>
          <target state="translated">추신 : BO로 재설정하는 경우 (예 : &lt;a href=&quot;https://stackoverflow.com/a/18690845/2405850&quot;&gt;https&lt;/a&gt; : &lt;code&gt;reset --mixed&lt;/code&gt; 에서 자세히 설명하는 reset --mixed 사용) :</target>
        </trans-unit>
        <trans-unit id="e8df79c1f7f324f7ea12be589f8d4145c0fff656" translate="yes" xml:space="preserve">
          <source>PR and merge TO master &lt;em&gt;by reviewer&lt;/em&gt;.
(Yes, it would be easier for the developer to &lt;code&gt;merge --squash&lt;/code&gt; after the PR, but the team thought that would slow down the process.)</source>
          <target state="translated">&lt;em&gt;검토 자에 의해&lt;/em&gt; PR 및 마스터 &lt;em&gt;로&lt;/em&gt; 병합. (예, 개발자는 PR 이후 &lt;code&gt;merge --squash&lt;/code&gt; 를 병합 하는 것이 더 쉬울 것이지만 팀은 프로세스 속도가 느려질 것이라고 생각했습니다.)</target>
        </trans-unit>
        <trans-unit id="7e84941f3d4a75c0dc177c26e3d8294131e792e3" translate="yes" xml:space="preserve">
          <source>Procedure 1</source>
          <target state="translated">절차 1</target>
        </trans-unit>
        <trans-unit id="9d3b7680f495af80fe40294525dfe378fc4a6043" translate="yes" xml:space="preserve">
          <source>Procedure 2</source>
          <target state="translated">절차 2</target>
        </trans-unit>
        <trans-unit id="2c937bebe0ed8ae169f2202e531a6094c90fee0c" translate="yes" xml:space="preserve">
          <source>Push the branch to your local repository</source>
          <target state="translated">지점을 로컬 리포지토리로 푸시</target>
        </trans-unit>
        <trans-unit id="a73eccc33144570add3bc96c79ccd1f27423bf72" translate="yes" xml:space="preserve">
          <source>Push the change to a particular branch</source>
          <target state="translated">변경 사항을 특정 지점으로 푸시</target>
        </trans-unit>
        <trans-unit id="ca87402c617e64e22c3d7193a1f96b2b02c17659" translate="yes" xml:space="preserve">
          <source>Put squash instead of pick to H0:</source>
          <target state="translated">H0 대신 pick 대신 squash를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="260756bf22f9f993d1bc033875848a9357f0d969" translate="yes" xml:space="preserve">
          <source>Put the to-be-squashed commits on a working branch (if they aren't already) -- use gitk for this</source>
          <target state="translated">작업중인 분기에 스쿼시 된 커밋을 넣습니다 (아직없는 경우)-gitk를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e66b40d5e26b8f80f7e041f81061eb7ad61a1b5" translate="yes" xml:space="preserve">
          <source>Reviewer does PR and merges to master.</source>
          <target state="translated">검토자가 PR을 수행하고 마스터에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="8c3a77045a4803d7837f166a12ee9caf303269a1" translate="yes" xml:space="preserve">
          <source>See where you are with &lt;code&gt;git log&lt;/code&gt;. Most important, find the commit hash of the first commit you &lt;em&gt;don't&lt;/em&gt; want to squash. So only the :</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 가있는 곳을보십시오. 가장 중요한 것은 스쿼시 &lt;em&gt;하지&lt;/em&gt; 않으려는 첫 번째 커밋의 커밋 해시를 찾으십시오. 따라서 :</target>
        </trans-unit>
        <trans-unit id="a2da3b6230bae4fd68ed9664dced96244baa2508" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Combine to one commit&lt;/code&gt; from the context menu</source>
          <target state="translated">컨텍스트 메뉴에서 &lt;code&gt;Combine to one commit&lt;/code&gt; 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="eab195238ec47a36730ecb88741d15affc592ef0" translate="yes" xml:space="preserve">
          <source>Select &lt;code&gt;Show Log&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Show Log&lt;/code&gt; 선택 하십시오.</target>
        </trans-unit>
        <trans-unit id="ef5af955bf451fa0bf9ce8667bb1749136652a01" translate="yes" xml:space="preserve">
          <source>Simple one-liner that always works, given that you are currently on the branch you want to squash, master is the branch it originated from, and the latest commit contains the commit message and author you wish to use:</source>
          <target state="translated">현재 스쿼시하려는 브랜치에 있고 마스터는 브랜치이며 브랜치에는 최신 커밋 메시지와 작성자가 포함되어 있으므로 항상 작동하는 간단한 단일 라이너.</target>
        </trans-unit>
        <trans-unit id="48e87018ba090a96eb3b4261c69ab3bc1688ba76" translate="yes" xml:space="preserve">
          <source>So the 2nd procedure helps to merge the commit to very old commit easily.</source>
          <target state="translated">따라서 두 번째 절차는 커밋을 아주 오래된 커밋에 쉽게 병합하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="1606820c64383f2678929b220f43c62392e4802a" translate="yes" xml:space="preserve">
          <source>So, this seems to work for us.</source>
          <target state="translated">그래서 이것은 우리에게 효과가있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="c65f5cec26fdf510a411914b43897da6b752dc54" translate="yes" xml:space="preserve">
          <source>Sources &amp;amp; additional reads: &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;#1&lt;/a&gt;, &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;#2&lt;/a&gt;.</source>
          <target state="translated">소스 및 추가 읽기 : &lt;a href=&quot;https://www.devroom.io/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;# 1&lt;/a&gt; , &lt;a href=&quot;https://www.internalpointers.com/post/squash-commits-into-one-git&quot;&gt;# 2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fe78756ce38b0a0104a04e440f7455dc5041f0" translate="yes" xml:space="preserve">
          <source>Squash merge with your local branch that you have already</source>
          <target state="translated">스쿼시는 이미 가지고있는 지역 지점과 합병</target>
        </trans-unit>
        <trans-unit id="f250854c3f99d28c958f70dce4dd6eb4cb062123" translate="yes" xml:space="preserve">
          <source>Squash my last X commits together using Git</source>
          <target state="translated">Git을 사용하여 마지막 X 커밋을 스쿼시하십시오.</target>
        </trans-unit>
        <trans-unit id="fa32bacb7f009d82ac949dca9b0e80d1d0dbd93c" translate="yes" xml:space="preserve">
          <source>Step 0: git log</source>
          <target state="translated">0 단계 : 자식 로그</target>
        </trans-unit>
        <trans-unit id="8e0ca5bd90136b4a7b027927451c19e1f346a18b" translate="yes" xml:space="preserve">
          <source>Step 1: git rebase</source>
          <target state="translated">1 단계 : 자식 리베이스</target>
        </trans-unit>
        <trans-unit id="d7eb36401823c9a736a592ee2155703f797e50da" translate="yes" xml:space="preserve">
          <source>Step 2: pick / squash what you want</source>
          <target state="translated">2 단계 : 원하는 것을 골라 / 스쿼시</target>
        </trans-unit>
        <trans-unit id="a5e2c10a701fc35282279ec7765f80119e96ce60" translate="yes" xml:space="preserve">
          <source>Step 3: Adjust message(s)</source>
          <target state="translated">3 단계 : 메시지 조정</target>
        </trans-unit>
        <trans-unit id="7692952e23e9867e52383f181dfe0cb65c218f1d" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;this handy blog post&lt;/a&gt; I found that you can use this command to squash the last 3 commits:</source>
          <target state="translated">&lt;a href=&quot;https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/&quot;&gt;이 편리한 블로그 게시물&lt;/a&gt; 덕분 에이 명령을 사용하여 마지막 3 개의 커밋을 스쿼시 할 수 있음을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="06fa56961a9b1119f58d05a3eea1f250493fd074" translate="yes" xml:space="preserve">
          <source>That's it. Once you save this (&lt;code&gt;:wq&lt;/code&gt;), you're done. Have a look at it with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">그게 다야. 이것을 저장하면 ( &lt;code&gt;:wq&lt;/code&gt; ) 완료된 것입니다. &lt;code&gt;git log&lt;/code&gt; 로 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="ad8a077aa099078c8cbac44ec84ae98b2cd4e20e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;documentation for &lt;code&gt;git merge&lt;/code&gt;&lt;/a&gt; describes the &lt;code&gt;--squash&lt;/code&gt; option in more detail.</source>
          <target state="translated">&lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt; &lt;code&gt;git merge&lt;/code&gt; 에 대한 문서&lt;/a&gt; 는 &lt;code&gt;--squash&lt;/code&gt; 옵션에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0e607204ccc0308b417695ca633595dcad436b1d" translate="yes" xml:space="preserve">
          <source>The command will open the interactive rebase editor which then allows you to reorder, squash, reword, etc as per normal.</source>
          <target state="translated">이 명령은 대화식 rebase 편집기를 열고 평소대로 재정렬, 스쿼시, 리워드 등을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925d19add6cc8a59abd536b73f79b247585837ee" translate="yes" xml:space="preserve">
          <source>The commit message will be prepopulated based on the squash.</source>
          <target state="translated">커밋 메시지는 스쿼시를 기반으로 미리 채워집니다.</target>
        </trans-unit>
        <trans-unit id="8a6719516ac538e9ed622d11335500e260fc9964" translate="yes" xml:space="preserve">
          <source>The documentation displayed is pretty clear.  On any given line you can change the command from &lt;code&gt;pick&lt;/code&gt; to a command of your choice.</source>
          <target state="translated">표시되는 문서는 매우 명확합니다. 주어진 행에서 명령을 &lt;code&gt;pick&lt;/code&gt; 에서 선택한 명령으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4ad30909bb83a10ddf48ebb81e1d7adda4edf0" translate="yes" xml:space="preserve">
          <source>The first thing I do is fix the mistake and make a new commit with the comment &lt;code&gt;squash this into my new feature!&lt;/code&gt;.</source>
          <target state="translated">내가해야 할 첫 번째 일은 실수를 수정하고 주석으로 &lt;code&gt;squash this into my new feature!&lt;/code&gt; 새로운 커밋 으로 내 새로운 기능으로 만드는 것입니다! .</target>
        </trans-unit>
        <trans-unit id="5a54a921df7a18b8fa7bcbb17b04135a3f9ca0a4" translate="yes" xml:space="preserve">
          <source>The interactive rebase editor shows the last three commits.  This constraint was determined by &lt;code&gt;HEAD~3&lt;/code&gt; when running the command &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt;.</source>
          <target state="translated">대화식 rebase 편집기는 마지막 3 개의 커밋을 보여줍니다. 이 제한 조건은 &lt;code&gt;git rebase -i HEAD~3&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;HEAD~3&lt;/code&gt; 의해 결정되었습니다.</target>
        </trans-unit>
        <trans-unit id="40de1d7485f29f3c3927203644f6993e9c59eb2c" translate="yes" xml:space="preserve">
          <source>The most recent commit, &lt;code&gt;HEAD&lt;/code&gt;, is displayed first on line 1.  The lines starting with a &lt;code&gt;#&lt;/code&gt; are comments/documentation.</source>
          <target state="translated">가장 최근의 커밋 인 &lt;code&gt;HEAD&lt;/code&gt; 가 첫 번째 줄에 첫 번째로 표시됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄은 주석 / 문서입니다.</target>
        </trans-unit>
        <trans-unit id="15bd41701489226c2dce4509a6fee4be4aa552ba" translate="yes" xml:space="preserve">
          <source>The problem is that H0 contains H1 and H2 (and generally more commits before merge and after branching) while B0 don't. So you have to manage changes from H0, merge, H1, H2, B0 at least.</source>
          <target state="translated">문제는 H0에 H1과 H2가 포함되어 있으며 (B는 병합하지 않고 분기 후 더 많은 커밋) B0은 포함하지 않는다는 것입니다. 따라서 최소한 H0, merge, H1, H2, B0의 변경 사항을 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="6331cadceddf56d7aa2077447230eea2f9a842c7" translate="yes" xml:space="preserve">
          <source>Then commit using &lt;code&gt;--fixup&lt;/code&gt; option and the &lt;code&gt;OLDCOMMIT&lt;/code&gt; should be on which we need to merge(squash) this commit.</source>
          <target state="translated">그런 다음 &lt;code&gt;--fixup&lt;/code&gt; 옵션을 사용하여 커밋하면 OLDCOMMIT 가이 커밋을 병합 (스쿼시)해야합니다.</target>
        </trans-unit>
        <trans-unit id="625c194045dd72da9dae9e8a5696dc4cd84a15ed" translate="yes" xml:space="preserve">
          <source>Then execute below command to merge(squash) the new commit to the &lt;code&gt;OLDCOMMIT&lt;/code&gt;.</source>
          <target state="translated">그런 다음 아래 명령을 실행하여 새 커밋을 &lt;code&gt;OLDCOMMIT&lt;/code&gt; 에 병합하십시오 (스쿼시).</target>
        </trans-unit>
        <trans-unit id="63a925126395e6b2ebaae2cf1711a295f24f5b5f" translate="yes" xml:space="preserve">
          <source>Then last commits by time are H0, merge, B0. To squash them you will have to rebase your merged branch on commit H1.</source>
          <target state="translated">그런 다음 시간별 마지막 커밋은 H0, merge, B0입니다. 스쿼시하려면 커밋 H1에 병합 된 브랜치를 리베이스해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b5c4a5092abbae0b51b1df123053bf15993a9f0" translate="yes" xml:space="preserve">
          <source>Then to continue the rebase:</source>
          <target state="translated">그런 다음 리베이스를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="cec55a62a50d094219c9ed6c3d7233b58b9df6cd" translate="yes" xml:space="preserve">
          <source>Then you have all of the changes ready to commit.</source>
          <target state="translated">그런 다음 모든 변경 사항을 커밋 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="546b13232526f68926882878963e76932c04582d" translate="yes" xml:space="preserve">
          <source>Then, I create another branch based out my-feature branch, keep &lt;code&gt;my-feature&lt;/code&gt; branch untouched.</source>
          <target state="translated">그런 다음 기능 지점을 기반으로 다른 지점을 만들고 &lt;code&gt;my-feature&lt;/code&gt; 지점을 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="a14755fe0a2432949166566a2c3b293cbb3334a8" translate="yes" xml:space="preserve">
          <source>Thinking that nobody would ever care to read the full repository history. (There actually is a repository, click the link above!) You decide to squash these commits. So you go and run &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt;. Then you &lt;code&gt;git push --force&lt;/code&gt; it onto GitHub to clean up your PR.</source>
          <target state="translated">아무도 전체 저장소 기록을 읽을 필요가 없다고 생각합니다. (실제로 저장소가 있으므로 위의 링크를 클릭하십시오!) 이러한 커밋을 스쿼시하기로 결정했습니다. 그래서 &lt;code&gt;git reset --soft HEAD~4 &amp;amp;&amp;amp; git commit&lt;/code&gt; . 그런 다음 &lt;code&gt;git push --force&lt;/code&gt; GitHub에 강제로 넣어 PR을 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="e8779d0790a0a6c1a85e49564ee8661d2563c832" translate="yes" xml:space="preserve">
          <source>This function automatically executes all necessary single git steps.
Unfortunatly only available for Windows.</source>
          <target state="translated">이 기능은 필요한 모든 단일 git 단계를 자동으로 실행합니다. 불행히도 Windows에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fad2e44fdb033a06b3f6360d78eb01c683e6c42" translate="yes" xml:space="preserve">
          <source>This is handy as it works even when you are on a local branch with no tracking information/remote repo.</source>
          <target state="translated">추적 정보 / 원격 리포지토리가없는 로컬 지점에 있어도 편리합니다.</target>
        </trans-unit>
        <trans-unit id="084858599aa0e25ed248f7286a555ac974946b7c" translate="yes" xml:space="preserve">
          <source>This is super-duper kludgy, but in a kind of cool way, so I'll just toss it into the ring:</source>
          <target state="translated">이것은 슈퍼 듀퍼 클루 지이지만 멋진 방법으로 링에 던져 넣을 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfd5d4a30f5a6bd68aea5b76c13d7f98cd5ab3ed" translate="yes" xml:space="preserve">
          <source>This will dump the history being squashed before it does so&amp;mdash;this gives you a chance to recover by grabbing an old commit ID off the console if you want to revert.  (Solaris users note it uses the GNU sed &lt;code&gt;-i&lt;/code&gt; option, Mac and Linux users should be fine with this.)</source>
          <target state="translated">이렇게하면 이전에 찌그러진 기록이 덤프됩니다. 되돌릴 경우 콘솔에서 오래된 커밋 ID를 가져와 복구 할 수 있습니다. (Solaris 사용자는 GNU sed &lt;code&gt;-i&lt;/code&gt; 옵션을 사용하므로 Mac 및 Linux 사용자는 이에 적합해야합니다.)</target>
        </trans-unit>
        <trans-unit id="dc92e0bbd27c7f53e720875e6878c42bc7b99b1c" translate="yes" xml:space="preserve">
          <source>This will open the text editor and you must switch the 'pick' in front of each commit with 'squash' if you would like these commits to be merged together. From documentation:</source>
          <target state="translated">텍스트 편집기가 열리고 커밋을 병합하려면 각 커밋 앞에서 'pick'을 'squash'로 전환해야합니다. 설명서에서 :</target>
        </trans-unit>
        <trans-unit id="876cf8ee642d0b29004c0d70c60d3ce90f399a68" translate="yes" xml:space="preserve">
          <source>This will show you choice options (as mentioned in other answers):</source>
          <target state="translated">그러면 다른 답변에서 언급 한대로 선택 옵션이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bce6c83325757e7a54433a83c6e7084810007e" translate="yes" xml:space="preserve">
          <source>This works well when all the commits are local, but if you try to change any commits already pushed to the remote you can really cause problems for other devs that have checked out the same branch!</source>
          <target state="translated">이것은 모든 커밋이 로컬 인 경우 잘 작동하지만 이미 원격으로 푸시 된 커밋을 변경하려고하면 동일한 분기를 체크 아웃 한 다른 개발자에게 실제로 문제가 발생할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="1dbe8ac5ab79108392c62a34cf9417a1ac8ae9c7" translate="yes" xml:space="preserve">
          <source>To do this you can use following git command.</source>
          <target state="translated">이를 위해 다음 git 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="603b6f4899ba5a0c325455ae848805098f30ac76" translate="yes" xml:space="preserve">
          <source>To squash the last 10 commits into 1 single commit:</source>
          <target state="translated">마지막 10 개의 커밋을 하나의 단일 커밋으로 스쿼시하려면 :</target>
        </trans-unit>
        <trans-unit id="d453af1b2806f0771f8120f5f48b125b16f17109" translate="yes" xml:space="preserve">
          <source>Translation: provide a new &quot;editor&quot; for git which, if the filename to be edited is &lt;code&gt;git-rebase-todo&lt;/code&gt; (the interactive rebase prompt) changes all but the first &quot;pick&quot; to &quot;squash&quot;, and otherwise spawns vim - so that when you're prompted to edit the squashed commit message, you get vim. (And obviously I was squashing the last five commits on branch foo, but you could change that however you like.)</source>
          <target state="translated">번역 : 편집 할 파일 이름이 &lt;code&gt;git-rebase-todo&lt;/code&gt; (대화식 rebase 프롬프트) 인 경우 첫 번째 &quot;pick&quot;을 제외한 모든 것을 &quot;squash&quot;로 변경하고 그렇지 않으면 vim을 스폰하는 git 용 새 &quot;편집기&quot;를 제공합니다. 취소 된 커밋 메시지를 편집하라는 메시지가 표시되면 vim이 표시됩니다. (그리고 분명히 나는 ​​foo 브랜치에서 마지막 5 개의 커밋을 스쿼시하고 있었지만 원하는대로 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2e04cd50a2d8a6e325a64a9e9d1e89bf9850e0a7" translate="yes" xml:space="preserve">
          <source>Update like below &lt;code&gt;pick&lt;/code&gt; one commit and &lt;code&gt;squash&lt;/code&gt; the others into the most recent,</source>
          <target state="translated">다음과 같이 업데이트하면 하나의 커밋을 &lt;code&gt;pick&lt;/code&gt; 하고 다른 하나는 최신 커밋으로 &lt;code&gt;squash&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="10c4aabc7d6d07adf02cb1c2e40e88d5732500a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; and replace &quot;pick&quot; on the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;, as described in &lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;the manual&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git rebase -i &amp;lt;after-this-commit&amp;gt;&lt;/code&gt; 을 &lt;a href=&quot;http://git-scm.com/docs/git-rebase#_interactive_mode&quot;&gt;사용하고 매뉴얼에&lt;/a&gt; 설명 된대로 두 번째 및 후속 커밋에서 &quot;pick&quot;을 &quot;squash&quot;또는 &quot;fixup&quot;으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="1f1b9ab9a0e0959c8d60301c1dd590795036c32e" translate="yes" xml:space="preserve">
          <source>WARNING: First make sure you commit your work&amp;mdash;check that &lt;code&gt;git status&lt;/code&gt; is clean (since &lt;code&gt;git reset --hard&lt;/code&gt; will throw away staged and unstaged changes)</source>
          <target state="translated">경고 : 먼저 작업을 커밋해야합니다. &lt;code&gt;git status&lt;/code&gt; 가 깨끗한 지 확인하십시오 ( &lt;code&gt;git reset --hard&lt;/code&gt; 가 단계적 및 비 단계적 변경을 버린 이후)</target>
        </trans-unit>
        <trans-unit id="52065276a52b15005dd5aee61d9b2417c0b2ced8" translate="yes" xml:space="preserve">
          <source>What about an answer for the question related to a workflow like this?</source>
          <target state="translated">이와 같은 워크 플로와 관련된 질문에 대한 답변은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="387737056476baadea4c3b6310eccb9d5e50141c" translate="yes" xml:space="preserve">
          <source>What can be really convenient:</source>
          <target state="translated">정말 편리 할 수있는 것 :</target>
        </trans-unit>
        <trans-unit id="765789c174c2479941c09177922e1d21cc6827fc" translate="yes" xml:space="preserve">
          <source>What i did is</source>
          <target state="translated">내가 한 일은</target>
        </trans-unit>
        <trans-unit id="d21b0bcb168b83ca89e96c0b658ad9d3fc1df640" translate="yes" xml:space="preserve">
          <source>When closing the editor, the fix will get squashed into the feature commit and my commit history will look nice and clean!</source>
          <target state="translated">편집기를 닫으면 수정 사항이 기능 커밋으로 찌그러지고 커밋 기록이 멋지게 보입니다.</target>
        </trans-unit>
        <trans-unit id="d4ceba0e28653571c383b8285d758678e129e217" translate="yes" xml:space="preserve">
          <source>You can do this fairly easily without &lt;code&gt;git rebase&lt;/code&gt; or &lt;code&gt;git merge --squash&lt;/code&gt;. In this example, we'll squash the last 3 commits.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 또는 &lt;code&gt;git merge --squash&lt;/code&gt; 없이 상당히 쉽게 할 수 있습니다. 이 예에서는 마지막 3 개의 커밋을 스쿼시합니다.</target>
        </trans-unit>
        <trans-unit id="757adf068d4225d6c149a530d9e62dc3a26e1485" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git merge --squash&lt;/code&gt; for this, which is slightly more elegant than &lt;code&gt;git rebase -i&lt;/code&gt;.  Suppose you're on master and you want to squash the last 12 commits into one.</source>
          <target state="translated">이를 위해 &lt;code&gt;git merge --squash&lt;/code&gt; 를 사용할 수 있습니다. 이것은 &lt;code&gt;git rebase -i&lt;/code&gt; 보다 약간 더 우아합니다. 당신이 마스터에 있고 마지막 12 개의 커밋을 하나로 만들고 싶다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="71fb008e5d4b8f4decb5fc1d8418a270127e8380" translate="yes" xml:space="preserve">
          <source>You may also change the order of the commits. This allows you to squash or fixup commits that are not adjacent chronologically.</source>
          <target state="translated">커밋 순서를 변경할 수도 있습니다. 이를 통해 연대순으로 인접하지 않은 커밋을 스쿼시하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f67e78ddf7e52bc3a80985eea97c30cace0d72aa" translate="yes" xml:space="preserve">
          <source>You opened a pull request and on GitHub you see this:</source>
          <target state="translated">풀 요청을 열었고 GitHub에서 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f42ea37efb2330eb9f8ae87f778d2109ad00e3b" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;~/.gitconfig&lt;/code&gt; should now contain this alias:</source>
          <target state="translated">&lt;code&gt;~/.gitconfig&lt;/code&gt; 에 다음 별칭이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="758b9ac3be25f469194a9e3fd22799cf55e4cc10" translate="yes" xml:space="preserve">
          <source>edit and commit a lot locally, merge master regularly</source>
          <target state="translated">로컬에서 많은 편집 및 커밋, 정기적으로 마스터 병합</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="e0d33137a7b35fa4c2c656343c06f10e9f77b403" translate="yes" xml:space="preserve">
          <source>finally a push to remote,</source>
          <target state="translated">마침내 리모컨으로의 밀기</target>
        </trans-unit>
        <trans-unit id="4b04d2a98dc3f0fd0b938cafe5761aa32fafe654" translate="yes" xml:space="preserve">
          <source>for example &lt;code&gt;git log --graph&lt;/code&gt; outputs the following (simplified):</source>
          <target state="translated">예를 들어 &lt;code&gt;git log --graph&lt;/code&gt; 는 다음과 같이 출력됩니다 (간체).</target>
        </trans-unit>
        <trans-unit id="d76620ae96c7ca431e1db5376c1cfcf85d087916" translate="yes" xml:space="preserve">
          <source>git commit</source>
          <target state="translated">자식 커밋</target>
        </trans-unit>
        <trans-unit id="371e49a0b18c50d82d292aef71ea992421ef9133" translate="yes" xml:space="preserve">
          <source>git push origin (branch_name) --force</source>
          <target state="translated">자식 푸시 원점 (branch_name) --force</target>
        </trans-unit>
        <trans-unit id="56322e172fdd72aded4057a4a7b371ca73775805" translate="yes" xml:space="preserve">
          <source>git reset --soft Head~3 &amp;amp;&amp;amp;</source>
          <target state="translated">git reset-소프트 헤드 ~ 3 &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="946fc396fd4b258f758878e94fa72b2ed7382c42" translate="yes" xml:space="preserve">
          <source>if for example you want to squash the last 3 commits to a single commit in a branch(remote repository) in for example: &lt;a href=&quot;https://bitbucket.org&quot;&gt;https://bitbucket.org&lt;/a&gt;</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://bitbucket.org&quot;&gt;https://bitbucket.org&lt;/a&gt; 와 같이 지점 (원격 저장소)의 단일 커밋에 대한 마지막 3 개의 커밋을 스쿼시하려는 경우</target>
        </trans-unit>
        <trans-unit id="611d5f9682115beec752b912992f91f4d6631a4e" translate="yes" xml:space="preserve">
          <source>many local commits, &lt;em&gt;mixed with multiple merges FROM master&lt;/em&gt;,</source>
          <target state="translated">여러 로컬 커밋, &lt;em&gt;여러 병합 FROM master와 혼합&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="f1d1f78c97a0cfa141dba4aa92f53b7119108001" translate="yes" xml:space="preserve">
          <source>n(=4 here) is the number of last commit. Then you got following options,</source>
          <target state="translated">n (= 4 here)은 마지막 커밋 수입니다. 그런 다음 다음 옵션을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a06e25653856f59ec61310038b0e76e461953e35" translate="yes" xml:space="preserve">
          <source>p, pick  = use commit</source>
          <target state="translated">p, pick = 커밋 사용</target>
        </trans-unit>
        <trans-unit id="e4ae77df54121cf3234bc6148af99f1b9c9169e9" translate="yes" xml:space="preserve">
          <source>s, squash  = use commit, but meld into previous commit</source>
          <target state="translated">s, squash = 커밋을 사용하지만 이전 커밋에 통합</target>
        </trans-unit>
        <trans-unit id="f60c1a720971c0a3baf938460a4d4f212174afca" translate="yes" xml:space="preserve">
          <source>the editor pops up again with a default message for the new commit: change it to your needs, save and close. Squash completed!</source>
          <target state="translated">새로운 커밋에 대한 기본 메시지와 함께 편집기가 다시 나타납니다. 필요에 따라 변경하고 저장 한 후 닫으십시오. 스쿼시 완성!</target>
        </trans-unit>
        <trans-unit id="14373bc7f8d111bad35942b43a801f430a7d6401" translate="yes" xml:space="preserve">
          <source>the editor pops up, showing the list of commits I want to merge. Now they are displayed in &lt;em&gt;reverse order&lt;/em&gt;: the older commit is on top. Mark as &quot;squash&quot; or &quot;s&quot; all the commits in there &lt;em&gt;except the first/older one&lt;/em&gt;: it will be used as a starting point. Save and close the editor;</source>
          <target state="translated">편집기가 팝업되어 병합하려는 커밋 목록을 보여줍니다. 이제 그것들은 &lt;em&gt;역순&lt;/em&gt; 으로 표시됩니다 : 이전 커밋이 맨 위에 있습니다. &lt;em&gt;첫 번째 / 이전&lt;/em&gt; 커밋을 &lt;em&gt;제외한&lt;/em&gt; 모든 커밋을 &quot;스쿼시&quot;또는 &quot;s&quot;로 표시합니다. 시작점으로 사용됩니다. 편집기를 저장하고 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="fdadc9f4e4d7f36a7d4ff5b5e8ef900c37504ed9" translate="yes" xml:space="preserve">
          <source>then you squash into B0 changes of H0, H1, H2 (losing completely commits for changes after branching and before merge.</source>
          <target state="translated">그런 다음 H0, H1, H2의 B0 변경으로 스쿼시합니다. 분기 후 및 병합 전에 변경 사항을 완전히 커밋하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="857ce54ac9c9e1932a376ea4c0ed0fa4f8b713ad" translate="yes" xml:space="preserve">
          <source>where the number of ^'s is X</source>
          <target state="translated">^의 개수는 X입니다.</target>
        </trans-unit>
        <trans-unit id="9cd599249730cbcaaa3eaaca4c150509b03fe784" translate="yes" xml:space="preserve">
          <source>⚠️ WARNING: &quot;My last X commits&quot; might be ambiguous.</source>
          <target state="translated">⚠️ 경고 : &quot;마지막 X 커밋&quot;이 모호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257eca43111b6053a03fada07551d11187f131cc" translate="yes" xml:space="preserve">
          <source>🐻 MORAL OF THE STORY</source>
          <target state="translated">🐻 이야기의 교훈</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
