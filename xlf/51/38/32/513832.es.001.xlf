<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/513832">
    <body>
      <group id="513832">
        <trans-unit id="534e6e35df4d7a293d4fb797e174a5f76b1e1e74" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)&quot;&gt;Objects.equals()&lt;/a&gt; checks for &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;.equals()&lt;/code&gt; so you don't have to (available as of JDK7, also available in &lt;a href=&quot;https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#equals&quot;&gt;Guava&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)&quot;&gt;Objects.equals ()&lt;/a&gt; busca &lt;code&gt;null&lt;/code&gt; antes de llamar a &lt;code&gt;.equals()&lt;/code&gt; para que no tenga que hacerlo (disponible a partir de JDK7, tambi&amp;eacute;n disponible en &lt;a href=&quot;https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#equals&quot;&gt;Guava&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="50d43f0916ad54e9845c2ad2b4e494d7973e3311" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contentEquals-java.lang.CharSequence-&quot;&gt;String.contentEquals()&lt;/a&gt; compares the content of the &lt;code&gt;String&lt;/code&gt; with the content of any &lt;code&gt;CharSequence&lt;/code&gt; (available since Java 1.5).</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contentEquals-java.lang.CharSequence-&quot;&gt;String.contentEquals ()&lt;/a&gt; compara el contenido de &lt;code&gt;String&lt;/code&gt; con el contenido de cualquier &lt;code&gt;CharSequence&lt;/code&gt; (disponible desde Java 1.5).</target>
        </trans-unit>
        <trans-unit id="e192e0e817715cc164367bdc6257808206f7aef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; compares String values.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; compara los valores de cadena.</target>
        </trans-unit>
        <trans-unit id="88f052486d7c3398f63c986b644896db673de477" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; compares the data in a class (assuming the function is implemented).
&lt;code&gt;==&lt;/code&gt; compares pointer locations (location of the object in memory).</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; compara los datos en una clase (suponiendo que la funci&amp;oacute;n est&amp;eacute; implementada). &lt;code&gt;==&lt;/code&gt; compara las ubicaciones del puntero (ubicaci&amp;oacute;n del objeto en la memoria).</target>
        </trans-unit>
        <trans-unit id="97f06596c10185b66f044c98db5fa447f42cbbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; tests for value equality (whether they are logically &quot;equal&quot;).</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; prueba la igualdad de valores (si son l&amp;oacute;gicamente &quot;iguales&quot;).</target>
        </trans-unit>
        <trans-unit id="2d0683433eb16443cb6ac4e5d95688372936574c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; compares Object references.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; compara referencias de objetos.</target>
        </trans-unit>
        <trans-unit id="d99d8255c217ecd40d6e336608014d1c046139ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; compares the reference value of objects whereas the &lt;code&gt;equals()&lt;/code&gt; method present in the &lt;code&gt;java.lang.String&lt;/code&gt; class compares the contents of the &lt;code&gt;String&lt;/code&gt; object (to another object).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; compara el valor de referencia de los objetos, mientras que el m&amp;eacute;todo &lt;code&gt;equals()&lt;/code&gt; presente en la clase &lt;code&gt;java.lang.String&lt;/code&gt; compara el contenido del objeto &lt;code&gt;String&lt;/code&gt; (con otro objeto).</target>
        </trans-unit>
        <trans-unit id="a7845d5fc79d961485ccf489239e9b8562c7adcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; handles &lt;code&gt;null&lt;/code&gt; strings fine, but calling &lt;code&gt;.equals()&lt;/code&gt; from a null string will cause an exception:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; maneja cadenas &lt;code&gt;null&lt;/code&gt; bien, pero llamar a &lt;code&gt;.equals()&lt;/code&gt; desde una cadena nula causar&amp;aacute; una excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="127a53ded3ac4bf04076d5f594c50d3375520fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means that your two string references are exactly the same object. You may have heard that this is the case because Java keeps sort of a literal table (which it does), but that is not always the case. Some strings are loaded in different ways, constructed from other strings, etc., so you must never assume that two identical strings are stored in the same location.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; significa que sus dos referencias de cadena son exactamente el mismo objeto. Es posible que haya escuchado que este es el caso porque Java mantiene una especie de tabla literal (lo que hace), pero ese no es siempre el caso. Algunas cadenas se cargan de diferentes maneras, construidas a partir de otras cadenas, etc., por lo que nunca debe suponer que dos cadenas id&amp;eacute;nticas se almacenan en la misma ubicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="972cd1c4c26a9b3d5a65d2854333166a32a64472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; performs a &lt;strong&gt;reference&lt;/strong&gt; equality check, whether the 2 objects (strings in this case) refer to the same object in the memory.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; realiza una comprobaci&amp;oacute;n de igualdad de &lt;strong&gt;referencia&lt;/strong&gt; , si los 2 objetos (cadenas en este caso) se refieren al mismo objeto en la memoria.</target>
        </trans-unit>
        <trans-unit id="3e8ab4bbb062dbd444c07ca3191ce5b49b24c15e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; returns true if both objects (NOT TALKING ABOUT PRIMITIVES) point to the SAME object instance.
&lt;code&gt;.equals()&lt;/code&gt; returns true if the two objects contain the same data &lt;a href=&quot;http://www.java-samples.com/showtutorial.php?tutorialid=221&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; Versus &lt;code&gt;==&lt;/code&gt; in Java&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; devuelve verdadero si ambos objetos (NO HABLAN SOBRE PRIMITIVOS) apuntan a la MISMA instancia de objeto. &lt;code&gt;.equals()&lt;/code&gt; devuelve verdadero si los dos objetos contienen los mismos datos &lt;a href=&quot;http://www.java-samples.com/showtutorial.php?tutorialid=221&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; Versus &lt;code&gt;==&lt;/code&gt; en Java&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65bb9efb919c1b1b9f8f00a8ab69486e0c1f6fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; tests for reference equality (whether they are the same object).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; prueba la igualdad de referencia (si son el mismo objeto).</target>
        </trans-unit>
        <trans-unit id="a40f8dacba2a1950f6ea624f0d2317bcc2a772dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; tests object references, &lt;code&gt;.equals()&lt;/code&gt; tests the string values.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; prueba referencias de objeto, &lt;code&gt;.equals()&lt;/code&gt; prueba los valores de cadena.</target>
        </trans-unit>
        <trans-unit id="a6e3babe176e5f525115bc259e2f5e512d8d9667" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals&lt;/code&gt; is actually the method of the Object class, but it is Overridden into the String class and a new definition is given which compares the contents of object.</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; es en realidad el m&amp;eacute;todo de la clase Object, pero se reemplaza en la clase String y se proporciona una nueva definici&amp;oacute;n que compara el contenido del objeto.</target>
        </trans-unit>
        <trans-unit id="ce16c9cf4f660e1842cc8af2704dd6ef8946c75c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Example&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8218a9a9840123be7b37c5258175c475d6d3d5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(a==b) ===&amp;gt; true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;(a == b) ===&amp;gt; verdadero&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de97c48c26c2975344975ab7fd565ec5f47f43e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;==&lt;/code&gt; compares object references in Java&lt;/strong&gt;, and that is no exception for &lt;code&gt;String&lt;/code&gt; objects.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;==&lt;/code&gt; compara referencias de objetos en Java&lt;/strong&gt; , y eso no es una excepci&amp;oacute;n para los objetos &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9b336e70ecf3d8434ca63a79793c6e9a5a5306" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But beware of nulls!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Pero cuidado con los nulos!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83aa0f60e0ba5d1766913ffd675fc9f79c342e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf6e653fe9d46dc5857806ccff042fa746c23fc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c83e5f944d3f32a33f78893b1ae58827ce8aa54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For comparing the actual contents of objects (including &lt;code&gt;String&lt;/code&gt;), one must use the &lt;code&gt;equals&lt;/code&gt; method&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Para comparar el contenido real de los objetos (incluida la &lt;code&gt;String&lt;/code&gt; ), se debe utilizar el m&amp;eacute;todo &lt;code&gt;equals&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="380badf346b49077ad347f903d9e64bdfc6c0961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 1: Java String comparison with the equals method&lt;/strong&gt;
Most of the time (maybe 95% of the time) I compare strings with the equals method of the Java String class, like this:</source>
          <target state="translated">&lt;strong&gt;Opci&amp;oacute;n 1: comparaci&amp;oacute;n de cadenas de Java con el m&amp;eacute;todo de igualdad&lt;/strong&gt; La mayor&amp;iacute;a de las veces (tal vez el 95% del tiempo) comparo cadenas con el m&amp;eacute;todo de igualdad de la clase de cadena de Java, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="eb85d4a727a36caf962b7bac941d7c46f894a6a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 2: String comparison with the equalsIgnoreCase method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Opci&amp;oacute;n 2: comparaci&amp;oacute;n de cadenas con el m&amp;eacute;todo equalsIgnoreCase&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d42bd1a8a45eb4097779363d21181e70e60ef953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 3: Java String comparison with the compareTo method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Opci&amp;oacute;n 3: comparaci&amp;oacute;n de cadenas Java con el m&amp;eacute;todo compareTo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae8b1214c75a26ad44633cb7ce38b5eea68d2fd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;if(a==b) ===&amp;gt; false.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;if (a == b) ===&amp;gt; falso.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ebc8538d9ce17c45cfa160ccf33b7ac0efa63fee" translate="yes" xml:space="preserve">
          <source>A key note is that strings are stored in one lump pool so once a string is created it is forever stored in a program at the same address. Strings do not change, they are immutable. This is why it is a bad idea to use regular string concatenation if you have a serious of amount of string processing to do. Instead you would use the &lt;code&gt;StringBuilder&lt;/code&gt; classes provided. Remember the pointers to this string can change and if you were interested to see if two pointers were the same &lt;code&gt;==&lt;/code&gt; would be a fine way to go. Strings themselves do not.</source>
          <target state="translated">Una nota clave es que las cadenas se almacenan en un conjunto de bloques, por lo que una vez que se crea una cadena, se almacena para siempre en un programa en la misma direcci&amp;oacute;n. Las cadenas no cambian, son inmutables. Es por eso que es una mala idea usar la concatenaci&amp;oacute;n de cadenas regular si tiene una gran cantidad de procesamiento de cadenas que hacer. En su lugar, usar&amp;iacute;a las clases &lt;code&gt;StringBuilder&lt;/code&gt; proporcionadas. Recuerde que los punteros a esta cadena pueden cambiar y si estuviera interesado en ver si dos punteros eran iguales &lt;code&gt;==&lt;/code&gt; ser&amp;iacute;a un buen camino a seguir. Las cuerdas no lo hacen.</target>
        </trans-unit>
        <trans-unit id="2e32a37850b13cf98c87aa3bc11f6bbc550512a2" translate="yes" xml:space="preserve">
          <source>All objects are guaranteed to have a &lt;code&gt;.equals()&lt;/code&gt; method since Object contains a method, &lt;code&gt;.equals()&lt;/code&gt;, that returns a boolean. It is the subclass' job to override this method if a further defining definition is required. Without it (i.e. using &lt;code&gt;==&lt;/code&gt;) only memory addresses are checked between two objects for equality. String overrides this &lt;code&gt;.equals()&lt;/code&gt; method and instead of using the memory address it returns the comparison of strings at the character level for equality.</source>
          <target state="translated">Se garantiza que todos los objetos tienen un m&amp;eacute;todo &lt;code&gt;.equals()&lt;/code&gt; ya que Object contiene un m&amp;eacute;todo, &lt;code&gt;.equals()&lt;/code&gt; , que devuelve un valor booleano. Es el trabajo de la subclase anular este m&amp;eacute;todo si se requiere una definici&amp;oacute;n adicional. Sin &amp;eacute;l (es decir, usando &lt;code&gt;==&lt;/code&gt; ) solo se verifican las direcciones de memoria entre dos objetos para la igualdad. La cadena anula este m&amp;eacute;todo &lt;code&gt;.equals()&lt;/code&gt; y, en lugar de utilizar la direcci&amp;oacute;n de memoria, devuelve la comparaci&amp;oacute;n de cadenas en el nivel de caracteres para la igualdad.</target>
        </trans-unit>
        <trans-unit id="2e7d953f9e0db5183f7079c0553cc235460d97be" translate="yes" xml:space="preserve">
          <source>But mind it respects the case of String. If you want case insensitive compare then you must go for the equalsIgnoreCase method of the String class.</source>
          <target state="translated">Pero ten en cuenta que respeta el caso de String.Si quieres comparar sin distinguir entre mayúsculas y minúsculas,entonces debes usar el método igual a IgnorarCasos de la clase String.</target>
        </trans-unit>
        <trans-unit id="08393c6c77f96e040c5d84e5121ed2a44b0608d1" translate="yes" xml:space="preserve">
          <source>But what you can do is to call &lt;code&gt;intern()&lt;/code&gt; on your non-literal strings.</source>
          <target state="translated">Pero lo que puede hacer es llamar a &lt;code&gt;intern()&lt;/code&gt; en sus cadenas no literales.</target>
        </trans-unit>
        <trans-unit id="15a3cf51d08c5a4791935fe82b44b7c4f15102fb" translate="yes" xml:space="preserve">
          <source>But, when the two strings contain the exact same string of characters, the equals method will return true, as in this example:</source>
          <target state="translated">Pero,cuando las dos cadenas contienen exactamente la misma cadena de caracteres,el método de los iguales volverá verdadero,como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="af38a399948a04b463b546d4f948912c00118098" translate="yes" xml:space="preserve">
          <source>Consequently, if you want to test whether two strings have the same value you will probably want to use &lt;code&gt;Objects.equals()&lt;/code&gt;.</source>
          <target state="translated">En consecuencia, si desea probar si dos cadenas tienen el mismo valor, probablemente querr&amp;aacute; usar &lt;code&gt;Objects.equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6aafac2f992d36c8bca828739a7404532d20a8a6" translate="yes" xml:space="preserve">
          <source>Consider two different reference variables, &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt;:</source>
          <target state="translated">Considere dos variables de referencia diferentes, &lt;code&gt;str1&lt;/code&gt; y &lt;code&gt;str2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9847ecced7aa002791c61138db5356d024636623" translate="yes" xml:space="preserve">
          <source>Definitely the use of &lt;code&gt;equals()&lt;/code&gt; method is recommended.</source>
          <target state="translated">Definitivamente se recomienda el uso del m&amp;eacute;todo &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf3bcba66a1552787dd686311371f4c3aa8ed466" translate="yes" xml:space="preserve">
          <source>Don't worry about the performance. Some things to encourage using &lt;code&gt;String.equals()&lt;/code&gt;:</source>
          <target state="translated">No te preocupes por el rendimiento. Algunas cosas para fomentar el uso de &lt;code&gt;String.equals()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b06f25fbeed92476c87e1968ec046f4936266cc1" translate="yes" xml:space="preserve">
          <source>Equals does the real comparison for you.</source>
          <target state="translated">Equals hace la comparación real para ti.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f4fca6333e5c683fdaa7713181bcfbd25b1d2643" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot;&gt;JLS 3.10.5. &lt;em&gt;String Literals&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">De &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot;&gt;JLS 3.10.5.&lt;/a&gt; &lt;em&gt;Literales de cuerda&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="003e5d38b8c1eac244f02ac363a47c0bbaf9273c" translate="yes" xml:space="preserve">
          <source>From zacherates example:</source>
          <target state="translated">Del ejemplo de Zacherates:</target>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="14fb73b968e1433308008402842a19df1bd245b3" translate="yes" xml:space="preserve">
          <source>How do I compare strings in Java</source>
          <target state="translated">¿Cómo comparo las cadenas en Java</target>
        </trans-unit>
        <trans-unit id="e90775e8efad74a01524c188edc8b6dc2072c2b5" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;==&lt;/code&gt; fails in the following case:</source>
          <target state="translated">Sin embargo, &lt;code&gt;==&lt;/code&gt; falla en el siguiente caso:</target>
        </trans-unit>
        <trans-unit id="ad8fc1b7115a0a617bf3361c92f8d88d012c6205" translate="yes" xml:space="preserve">
          <source>I agree with the answer from zacherates.</source>
          <target state="translated">Estoy de acuerdo con la respuesta de los zacherates.</target>
        </trans-unit>
        <trans-unit id="209b45599a8f24c29dacb03bdf122cc9869d6a84" translate="yes" xml:space="preserve">
          <source>I think that when you define a &lt;code&gt;String&lt;/code&gt; you define an object. So you need to use &lt;code&gt;.equals()&lt;/code&gt;. When you use primitive data types you use &lt;code&gt;==&lt;/code&gt; but with &lt;code&gt;String&lt;/code&gt; (and any object) you must use &lt;code&gt;.equals()&lt;/code&gt;.</source>
          <target state="translated">Creo que cuando define una &lt;code&gt;String&lt;/code&gt; , define un objeto. Entonces necesitas usar &lt;code&gt;.equals()&lt;/code&gt; . Cuando usa tipos de datos primitivos, usa &lt;code&gt;==&lt;/code&gt; pero con &lt;code&gt;String&lt;/code&gt; (y cualquier objeto) debe usar &lt;code&gt;.equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6deec886dc61621c93ed9d7b5c29032c707f83c" translate="yes" xml:space="preserve">
          <source>I've been using the &lt;code&gt;==&lt;/code&gt; operator in my program to compare all my strings so far.
However, I ran into a bug, changed one of them into &lt;code&gt;.equals()&lt;/code&gt; instead, and it fixed the bug.</source>
          <target state="translated">He estado usando el operador &lt;code&gt;==&lt;/code&gt; en mi programa para comparar todas mis cadenas hasta ahora. Sin embargo, me encontr&amp;eacute; con un error, cambi&amp;eacute; uno de ellos a &lt;code&gt;.equals()&lt;/code&gt; y solucion&amp;oacute; el error.</target>
        </trans-unit>
        <trans-unit id="ee1db44f97923a97f6aa14945a8e524aef45e729" translate="yes" xml:space="preserve">
          <source>If a comparison of two &lt;code&gt;String&lt;/code&gt; objects using &lt;code&gt;==&lt;/code&gt; turns out to be &lt;code&gt;true&lt;/code&gt;, that is because the &lt;code&gt;String&lt;/code&gt; objects were interned, and the Java Virtual Machine is having multiple references point to the same instance of &lt;code&gt;String&lt;/code&gt;. One should not expect that comparing one &lt;code&gt;String&lt;/code&gt; object containing the same contents as another &lt;code&gt;String&lt;/code&gt; object using &lt;code&gt;==&lt;/code&gt; to evaluate as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si una comparaci&amp;oacute;n de dos objetos &lt;code&gt;String&lt;/code&gt; con &lt;code&gt;==&lt;/code&gt; resulta ser &lt;code&gt;true&lt;/code&gt; , es porque los objetos &lt;code&gt;String&lt;/code&gt; fueron internados y la M&amp;aacute;quina virtual Java tiene m&amp;uacute;ltiples referencias que apuntan a la misma instancia de &lt;code&gt;String&lt;/code&gt; . No se debe esperar que al comparar un objeto &lt;code&gt;String&lt;/code&gt; que contiene el mismo contenido que otro objeto &lt;code&gt;String&lt;/code&gt; use &lt;code&gt;==&lt;/code&gt; para evaluar como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0975ad48f5593aec2b3883279cad972877d542d2" translate="yes" xml:space="preserve">
          <source>If the 2 string references are not the same, &lt;code&gt;String.equals()&lt;/code&gt; will next check the lengths of the strings. This is also a fast operation because the &lt;code&gt;String&lt;/code&gt; class stores the length of the string, no need to count the characters or code points. If the lengths differ, no further check is performed, we know they cannot be equal.</source>
          <target state="translated">Si las 2 referencias de cadena no son iguales, &lt;code&gt;String.equals()&lt;/code&gt; luego verificar&amp;aacute; las longitudes de las cadenas. Esta tambi&amp;eacute;n es una operaci&amp;oacute;n r&amp;aacute;pida porque la clase &lt;code&gt;String&lt;/code&gt; almacena la longitud de la cadena, no es necesario contar los caracteres o puntos de c&amp;oacute;digo. Si las longitudes difieren, no se realiza ninguna otra verificaci&amp;oacute;n, sabemos que no pueden ser iguales.</target>
        </trans-unit>
        <trans-unit id="622b2c72cef877135d3204c3e9e609ea0df5f20c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;equals()&lt;/code&gt; method is present in the &lt;code&gt;java.lang.Object&lt;/code&gt; class, and it is expected to check for the equivalence of the state of objects! That means, the contents of the objects. Whereas the &lt;code&gt;==&lt;/code&gt; operator is expected to check the actual object instances are same or not.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;code&gt;equals()&lt;/code&gt; est&amp;aacute; presente en la clase &lt;code&gt;java.lang.Object&lt;/code&gt; , &amp;iexcl;y se espera que verifique la equivalencia del estado de los objetos! Eso significa, el contenido de los objetos. Mientras que se espera que el operador &lt;code&gt;==&lt;/code&gt; verifique que las instancias de objeto reales sean iguales o no.</target>
        </trans-unit>
        <trans-unit id="d701e5196e6f58abe2f4c8d3e765a337b6d5958c" translate="yes" xml:space="preserve">
          <source>If you intern the non-literal String equality is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Si internas, la igualdad de cadena no literal es &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a18409dd8aad86765bdf0eb5ade6c3e9c27a06b1" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;equals()&lt;/code&gt;</source>
          <target state="translated">Si usa los &lt;code&gt;equals()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a606952753cf3dc70cfcd11f34796ac37f150100" translate="yes" xml:space="preserve">
          <source>If you're like me, when I first started using Java, I wanted to use the &quot;==&quot; operator to test whether two String instances were equal, but for better or worse, that's not the correct way to do it in Java.</source>
          <target state="translated">Si eres como yo,cuando empecé a usar Java,quería usar el operador &quot;==&quot; para probar si dos instancias de String eran iguales,pero para bien o para mal,esa no es la forma correcta de hacerlo en Java.</target>
        </trans-unit>
        <trans-unit id="19563d43dbd1fb12946c8b55472adc3ce8a4a839" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;String.equals()&lt;/code&gt; first checks for reference equality (using &lt;code&gt;==&lt;/code&gt;), and if the 2 strings are the same by reference, no further calculation is performed!</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;String.equals()&lt;/code&gt; primero verifica la igualdad de referencia (usando &lt;code&gt;==&lt;/code&gt; ), y si las 2 cadenas son iguales por referencia, &amp;iexcl;no se realiza ning&amp;uacute;n c&amp;aacute;lculo adicional!</target>
        </trans-unit>
        <trans-unit id="df7f3b75bfe7cc351d7943de807b0754f7e73609" translate="yes" xml:space="preserve">
          <source>In Java, when the &lt;strong&gt;&amp;ldquo;==&amp;rdquo;&lt;/strong&gt; operator is used to compare 2 objects, it checks to see if the objects refer to the same place in memory. In other words, it checks to see if the 2 object names are basically references to the same memory location.</source>
          <target state="translated">En Java, cuando el operador &lt;strong&gt;&quot;==&quot;&lt;/strong&gt; se usa para comparar 2 objetos, verifica si los objetos se refieren al mismo lugar en la memoria. En otras palabras, verifica si los 2 nombres de objeto son b&amp;aacute;sicamente referencias a la misma ubicaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="f9de1f4d7b9c7548a170b2aee63ef265f6232437" translate="yes" xml:space="preserve">
          <source>In some string comparison tests you'll want to ignore whether the strings are uppercase or lowercase. When you want to test your strings for equality in this case-insensitive manner, use the equalsIgnoreCase method of the String class, like this:</source>
          <target state="translated">En algunas pruebas de comparación de cuerdas querrás ignorar si las cuerdas son mayúsculas o minúsculas.Cuando quieras probar la igualdad de tus cuerdas de esta manera insensible a las mayúsculas y minúsculas,usa el método equalsIgnoreCase de la clase String,así:</target>
        </trans-unit>
        <trans-unit id="5096e9095a26aead7dd77a00dd73649fb297b01c" translate="yes" xml:space="preserve">
          <source>In this case for &lt;code&gt;new String(&quot;test&quot;)&lt;/code&gt; the statement new String will be created on the heap, and that reference will be given to &lt;code&gt;b&lt;/code&gt;, so &lt;code&gt;b&lt;/code&gt; will be given a reference on the heap, not in String pool.</source>
          <target state="translated">En este caso para una &lt;code&gt;new String(&quot;test&quot;)&lt;/code&gt; la declaraci&amp;oacute;n nueva Cadena se crear&amp;aacute; en el mont&amp;oacute;n, y esa referencia se dar&amp;aacute; a &lt;code&gt;b&lt;/code&gt; , por lo que &lt;code&gt;b&lt;/code&gt; se dar&amp;aacute; una referencia en el mont&amp;oacute;n, no en el conjunto de Cadena.</target>
        </trans-unit>
        <trans-unit id="ca3a426a66508840a27f96c237b38e05c70f30b4" translate="yes" xml:space="preserve">
          <source>In this tutorial I'll demonstrate several different ways to correctly compare Java strings, starting with the approach I use most of the time. At the end of this Java String comparison tutorial I'll also discuss why the &quot;==&quot; operator doesn't work when comparing Java strings.</source>
          <target state="translated">En este tutorial demostraré varias formas diferentes de comparar correctamente las cadenas de Java,empezando por el enfoque que utilizo la mayoría de las veces.Al final de este tutorial de comparación de cadenas de Java también discutiré por qué el operador &quot;==&quot; no funciona cuando se comparan cadenas de Java.</target>
        </trans-unit>
        <trans-unit id="66c5627d8cfe42bc4a6e93001ed6714eba02b7c5" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;==&lt;/code&gt; bad? When should it and should it not be used? What's the difference?</source>
          <target state="translated">&amp;iquest;Es &lt;code&gt;==&lt;/code&gt; malo? &amp;iquest;Cu&amp;aacute;ndo deber&amp;iacute;a y no deber&amp;iacute;a usarse? &amp;iquest;Cual es la diferencia?</target>
        </trans-unit>
        <trans-unit id="44ed4293c7fc2288444421274472d44a6e861151" translate="yes" xml:space="preserve">
          <source>Java also talks about the function intern() that can be used on a string to make it part of the cache so &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;).intern()&lt;/code&gt; will return true.</source>
          <target state="translated">Java tambi&amp;eacute;n habla de la funci&amp;oacute;n intern () que se puede usar en una cadena para que forme parte de la memoria cach&amp;eacute;, por lo que &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;).intern()&lt;/code&gt; devolver&amp;aacute; true.</target>
        </trans-unit>
        <trans-unit id="bbcdbf601957f23cebef96d44f7ff1ddf50b5aff" translate="yes" xml:space="preserve">
          <source>Java have a String pool under which Java manages the memory allocation for the String objects. See &lt;a href=&quot;https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java&quot;&gt;&lt;strong&gt;String Pools in Java&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">Java tiene un conjunto de cadenas bajo el cual Java gestiona la asignaci&amp;oacute;n de memoria para los objetos de cadena. Ver &lt;a href=&quot;https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java&quot;&gt;&lt;strong&gt;grupos de cadenas en Java&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8dd2b96dbe38262e709c95739664151e953eb1" translate="yes" xml:space="preserve">
          <source>Let's See:</source>
          <target state="translated">Veamos:</target>
        </trans-unit>
        <trans-unit id="a73fa850bcd40c5192a74b3a633598a1eeddab8d" translate="yes" xml:space="preserve">
          <source>Make sure you understand why.  It's because the &lt;code&gt;==&lt;/code&gt; comparison only compares references; the &lt;code&gt;equals()&lt;/code&gt; method does a character-by-character comparison of the contents.</source>
          <target state="translated">Aseg&amp;uacute;rate de entender por qu&amp;eacute;. Es porque la comparaci&amp;oacute;n &lt;code&gt;==&lt;/code&gt; solo compara referencias; El m&amp;eacute;todo &lt;code&gt;equals()&lt;/code&gt; realiza una comparaci&amp;oacute;n car&amp;aacute;cter por car&amp;aacute;cter de los contenidos.</target>
        </trans-unit>
        <trans-unit id="91794435135957626e3496e47088bf3118716d4a" translate="yes" xml:space="preserve">
          <source>Moreover, a string literal always refers to the &lt;em&gt;same&lt;/em&gt; instance of class &lt;code&gt;String&lt;/code&gt;. This is because string literals - or, more generally, strings that are the values of constant expressions (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28&quot;&gt;&amp;sect;15.28&lt;/a&gt;) - are &quot;interned&quot; so as to share unique instances, using the method &lt;code&gt;String.intern&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, un literal de cadena siempre se refiere a la &lt;em&gt;misma&lt;/em&gt; instancia de la clase &lt;code&gt;String&lt;/code&gt; . Esto se debe a que los literales de cadena, o, m&amp;aacute;s generalmente, las cadenas que son valores de expresiones constantes ( &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28&quot;&gt;&amp;sect;15.28&lt;/a&gt; ), est&amp;aacute;n &quot;internados&quot; para compartir instancias &amp;uacute;nicas, utilizando el m&amp;eacute;todo &lt;code&gt;String.intern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c374a8d811dc06c407f72b0c1bd01c73410b563a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;.equals()&lt;/code&gt; method belongs to class &lt;code&gt;Object&lt;/code&gt; (super class of all classes). You need to override it as per you class requirement, but for String it is already implemented, and it checks whether two strings have the same value or not.</source>
          <target state="translated">Tenga en cuenta que el m&amp;eacute;todo &lt;code&gt;.equals()&lt;/code&gt; pertenece a la clase &lt;code&gt;Object&lt;/code&gt; ( superclase de todas las clases). Debe anularlo seg&amp;uacute;n los requisitos de su clase, pero para String ya est&amp;aacute; implementado y verifica si dos cadenas tienen el mismo valor o no.</target>
        </trans-unit>
        <trans-unit id="ef7869c142e8b9c650d51fd7d526dffaf522ae76" translate="yes" xml:space="preserve">
          <source>Note: == operator is much faster than equals just because you are comparing two memory addresses, but you need to be sure that the code isn't creating new String instances in the code. Otherwise you will encounter bugs.</source>
          <target state="translated">Nota:==el operador es mucho más rápido que los iguales sólo porque estás comparando dos direcciones de memoria,pero tienes que estar seguro de que el código no está creando nuevas instancias de String en el código.De lo contrario,te encontrarás con errores.</target>
        </trans-unit>
        <trans-unit id="05f4a05acd2ff60019ca1cc57a02118ad5e2b4c8" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;a&lt;/code&gt; is pointing to a String in the String pool while &lt;code&gt;b&lt;/code&gt; is pointing to a String on the heap. Because of that we get:</source>
          <target state="translated">Ahora &lt;code&gt;a&lt;/code&gt; apunta a una Cadena en el conjunto de Cadenas, mientras que &lt;code&gt;b&lt;/code&gt; apunta a una Cadena en el mont&amp;oacute;n. Por eso obtenemos:</target>
        </trans-unit>
        <trans-unit id="3ae4c4c99288daf3be8f6b076a1e030bc8f2a226" translate="yes" xml:space="preserve">
          <source>Now you will get the &lt;code&gt;FALSE&lt;/code&gt; as output, because both &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt; are pointing to two different objects even though both of them share the same string content. It is because of &lt;code&gt;new String()&lt;/code&gt; a new object is created every time.</source>
          <target state="translated">Ahora obtendr&amp;aacute; el &lt;code&gt;FALSE&lt;/code&gt; como salida, porque tanto &lt;code&gt;str1&lt;/code&gt; como &lt;code&gt;str2&lt;/code&gt; apuntan a dos objetos diferentes a pesar de que ambos comparten el mismo contenido de cadena. Debido a la &lt;code&gt;new String()&lt;/code&gt; se crea un nuevo objeto cada vez.</target>
        </trans-unit>
        <trans-unit id="77c5595bc439eb350a3083fde96d4b94b19d4d24" translate="yes" xml:space="preserve">
          <source>Obviously &lt;code&gt;==&lt;/code&gt; is faster, but will (might) give false results in many cases if you just want to tell if 2 &lt;code&gt;String&lt;/code&gt;s hold the same text.</source>
          <target state="translated">Obviamente &lt;code&gt;==&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pido, pero (podr&amp;iacute;a) dar resultados falsos en muchos casos si solo quiere saber si 2 &lt;code&gt;String&lt;/code&gt; contienen el mismo texto.</target>
        </trans-unit>
        <trans-unit id="3f5984755ab3c60967abd3d47569bff195c24d31" translate="yes" xml:space="preserve">
          <source>Only if we got this far will the contents of the 2 strings be actually compared, and this will be a short-hand comparison: not all the characters will be compared, if we find a mismatching character (at the same position in the 2 strings), no further characters will be checked.</source>
          <target state="translated">Sólo si llegamos hasta aquí se comparará realmente el contenido de las 2 cuerdas,y ésta será una comparación a corto plazo:no se compararán todos los caracteres,si encontramos un carácter que no coincide (en la misma posición en las 2 cuerdas),no se comprobará ningún otro carácter.</target>
        </trans-unit>
        <trans-unit id="4931a37091118ff489ec2354e6f1916dc8e35e55" translate="yes" xml:space="preserve">
          <source>Operator &lt;em&gt;==&lt;/em&gt; is always meant for &lt;strong&gt;object reference comparison&lt;/strong&gt;, whereas the String class &lt;em&gt;.equals()&lt;/em&gt; method is overridden for &lt;strong&gt;content comparison&lt;/strong&gt;:</source>
          <target state="translated">Operador &lt;em&gt;==&lt;/em&gt; siempre est&amp;aacute; destinado a la &lt;strong&gt;comparaci&amp;oacute;n de referencias de objetos&lt;/strong&gt; , mientras que el m&amp;eacute;todo de clase de cadena &lt;em&gt;.equals ()&lt;/em&gt; se anula para la &lt;strong&gt;comparaci&amp;oacute;n de contenido&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="62d3323f1a4b43a5308396720b3529bdc784b601" translate="yes" xml:space="preserve">
          <source>Reason: If you create a String object using the &lt;code&gt;new&lt;/code&gt; keyword a separate space is allocated to it on the heap.</source>
          <target state="translated">Motivo: si crea un objeto String con la &lt;code&gt;new&lt;/code&gt; palabra clave, se le asignar&amp;aacute; un espacio separado en el mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e004e448e24213231c66b0837a3d3ab87e6c6817" translate="yes" xml:space="preserve">
          <source>Reason: String literals created without null are stored in the String pool in the permgen area of heap. So both s1 and s2 point to same object in the pool.</source>
          <target state="translated">Razón:Los literales de las cuerdas creados sin nulos se almacenan en la piscina de cuerdas en el área permanente del montón.Así que tanto s1 como s2 apuntan al mismo objeto en la piscina.</target>
        </trans-unit>
        <trans-unit id="e9694929438ff9ef921133d3e537bf55f70f6175" translate="yes" xml:space="preserve">
          <source>Similar examples can also be found in &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#d5e1634&quot;&gt;JLS 3.10.5-1&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n se pueden encontrar ejemplos similares en &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#d5e1634&quot;&gt;JLS 3.10.5-1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7678ffc7a34ab9b5bce1ba690a307007c3bc4cb7" translate="yes" xml:space="preserve">
          <source>So if you know that &lt;code&gt;fooString1&lt;/code&gt; may be null, tell the reader that by writing</source>
          <target state="translated">Entonces, si sabe que &lt;code&gt;fooString1&lt;/code&gt; puede ser nulo, d&amp;iacute;gale al lector que escribiendo</target>
        </trans-unit>
        <trans-unit id="6364ba01158454f664dad6de332f337ba05f8043" translate="yes" xml:space="preserve">
          <source>So the question is if all the strings are cached in the system, how come &lt;code&gt;==&lt;/code&gt; returns false whereas equals return true? Well, this is possible. If you make a new string like &lt;code&gt;String str = new String(&quot;Testing&quot;)&lt;/code&gt; you end up creating a new string in the cache even if the cache already contains a string having the same content. In short &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;)&lt;/code&gt; will always return false.</source>
          <target state="translated">Entonces, la pregunta es si todas las cadenas est&amp;aacute;n almacenadas en cach&amp;eacute; en el sistema, &amp;iquest;c&amp;oacute;mo es que &lt;code&gt;==&lt;/code&gt; devuelve falso mientras que igual devuelve verdadero? Bueno, esto es posible. Si crea una nueva cadena como &lt;code&gt;String str = new String(&quot;Testing&quot;)&lt;/code&gt; , termina creando una nueva cadena en el cach&amp;eacute;, incluso si el cach&amp;eacute; ya contiene una cadena con el mismo contenido. En resumen &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;)&lt;/code&gt; siempre devolver&amp;aacute; false.</target>
        </trans-unit>
        <trans-unit id="925bf81cb272f91e408e2585dfe66406073ec384" translate="yes" xml:space="preserve">
          <source>So using &lt;code&gt;.equals()&lt;/code&gt; is always better.</source>
          <target state="translated">Entonces, usar &lt;code&gt;.equals()&lt;/code&gt; siempre es mejor.</target>
        </trans-unit>
        <trans-unit id="64e94d29a587c1b43ed1ff2b1f5eea22f76e7e69" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;==&lt;/code&gt; gives illusions of comparing String values, as in following cases:</source>
          <target state="translated">A veces &lt;code&gt;==&lt;/code&gt; da ilusiones de comparar valores de cadena, como en los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="ef7777dabf10c38fea3b84a7896afa72857e8048" translate="yes" xml:space="preserve">
          <source>Sometimes it looks as if &lt;code&gt;==&lt;/code&gt; compares values, because Java does some behind-the-scenes stuff to make sure identical in-line strings are actually the same object.</source>
          <target state="translated">A veces parece que &lt;code&gt;==&lt;/code&gt; compara valores, porque Java hace algunas cosas detr&amp;aacute;s de escena para asegurarse de que cadenas id&amp;eacute;nticas en l&amp;iacute;nea sean realmente el mismo objeto.</target>
        </trans-unit>
        <trans-unit id="dc72f9ad1e0fe392b547dcb502b649489b4e684e" translate="yes" xml:space="preserve">
          <source>Strings in Java are immutable. That means whenever you try to change/modify the string you get a new instance. You cannot change the original string. This has been done so that these string instances can be cached. A typical program contains a lot of string references and caching these instances can decrease the memory footprint and increase the performance of the program.</source>
          <target state="translated">Las cuerdas en Java son inmutables.Eso significa que cada vez que intentas cambiar o modificar una cadena,obtienes una nueva instancia.No puedes cambiar la cadena original.Esto se ha hecho para que estas instancias de cadenas puedan ser almacenadas en caché.Un programa típico contiene muchas referencias de cadenas y el cacheo de estas instancias puede disminuir la huella de la memoria y aumentar el rendimiento del programa.</target>
        </trans-unit>
        <trans-unit id="1a5b82a90623ced9b5ebfc731549926d882846eb" translate="yes" xml:space="preserve">
          <source>Taking a look at a quick String comparison example with the equals method, if the following test were run, the two strings would not be considered equal because the characters are not the exactly the same (the case of the characters is different):</source>
          <target state="translated">Si se observa un ejemplo de comparación rápida de cadenas con el método de los iguales,si se realizara la siguiente prueba,las dos cadenas no se considerarían iguales porque los caracteres no son exactamente los mismos (el caso de los caracteres es diferente):</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="b0163278938a7a8c6bd706310467bbb52b4e5811" translate="yes" xml:space="preserve">
          <source>That may help you.</source>
          <target state="translated">Eso puede ayudarte.</target>
        </trans-unit>
        <trans-unit id="956e0cfc5f2a662f8be4c8e1953a725f10223a4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.equals()&lt;/code&gt; method  check if the two strings have the same value.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;.equals()&lt;/code&gt; verifica si las dos cadenas tienen el mismo valor.</target>
        </trans-unit>
        <trans-unit id="3e72766ae6883a1ca99b3e34b1d125ce6dbd4582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.equals()&lt;/code&gt; method will check if the two strings have the same value.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;.equals()&lt;/code&gt; verificar&amp;aacute; si las dos cadenas tienen el mismo valor.</target>
        </trans-unit>
        <trans-unit id="3978d062c149bf7accbca4cf5ab4522220f8fe12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; compares the references and does not compare the actual strings. If you did create every string using &lt;code&gt;new String(somestring).intern()&lt;/code&gt; then you can use the &lt;code&gt;==&lt;/code&gt; operator to compare two strings, otherwise equals() or compareTo methods can only be used.</source>
          <target state="translated">El &lt;code&gt;==&lt;/code&gt; compara las referencias y no compara las cadenas reales. Si cre&amp;oacute; cada cadena usando la &lt;code&gt;new String(somestring).intern()&lt;/code&gt; entonces puede usar el operador &lt;code&gt;==&lt;/code&gt; para comparar dos cadenas, de lo contrario solo se pueden usar los m&amp;eacute;todos equals () o compareTo.</target>
        </trans-unit>
        <trans-unit id="5512073b994a06023b1cc12815e391ae76326db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator check if the two references point to the same object or not. &lt;code&gt;.equals()&lt;/code&gt; check for the actual string content (value).</source>
          <target state="translated">El operador &lt;code&gt;==&lt;/code&gt; verifica si las dos referencias apuntan al mismo objeto o no. &lt;code&gt;.equals()&lt;/code&gt; verifica el contenido real de la cadena (valor).</target>
        </trans-unit>
        <trans-unit id="38eb3a4f9caacaa06f820fa599872a9b24a84e2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator checks if the two strings are exactly the same object.</source>
          <target state="translated">El operador &lt;code&gt;==&lt;/code&gt; verifica si las dos cadenas son exactamente el mismo objeto.</target>
        </trans-unit>
        <trans-unit id="a9a0606a28ccdd73d47713f4b0a9ffe7105e4faa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator checks to see if the two strings are exactly the same object.</source>
          <target state="translated">El operador &lt;code&gt;==&lt;/code&gt; verifica si las dos cadenas son exactamente el mismo objeto.</target>
        </trans-unit>
        <trans-unit id="d48da5a819a7433506b69dd9c4156df1be51f528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method will check whether the &lt;strong&gt;contents&lt;/strong&gt; or the &lt;strong&gt;states&lt;/strong&gt; of 2 objects are the same.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;equals()&lt;/code&gt; verificar&amp;aacute; si el &lt;strong&gt;contenido&lt;/strong&gt; o los &lt;strong&gt;estados&lt;/strong&gt; de 2 objetos son iguales.</target>
        </trans-unit>
        <trans-unit id="4c712b2bf82e618b0042ca50c72334d695ff56a7" translate="yes" xml:space="preserve">
          <source>The Java String class actually overrides the default equals() implementation in the Object class &amp;ndash; and it overrides the method so that it checks only the values of the strings, not their locations in memory.
 This means that if you call the equals() method to compare 2 String objects, then as long as the actual sequence of characters is equal, both objects are considered equal.</source>
          <target state="translated">La clase Java String en realidad anula la implementaci&amp;oacute;n equals () predeterminada en la clase Object, y anula el m&amp;eacute;todo para que verifique solo los valores de las cadenas, no sus ubicaciones en la memoria. Esto significa que si llama al m&amp;eacute;todo equals () para comparar 2 objetos String, siempre que la secuencia real de caracteres sea igual, ambos objetos se considerar&amp;aacute;n iguales.</target>
        </trans-unit>
        <trans-unit id="b255548604584b6fe35e432b209faddbe10a7980" translate="yes" xml:space="preserve">
          <source>The following is shorter, but it&amp;rsquo;s less obvious that it checks for null (from Java 7):</source>
          <target state="translated">Lo siguiente es m&amp;aacute;s corto, pero es menos obvio que verifica nulo (de Java 7):</target>
        </trans-unit>
        <trans-unit id="3caa790aba81043457285ebcb715deab21762bd6" translate="yes" xml:space="preserve">
          <source>There is also a third, less common way to compare Java strings, and that's with the String class compareTo method. If the two strings are exactly the same, the compareTo method will return a value of 0 (zero). Here's a quick example of what this String comparison approach looks like:</source>
          <target state="translated">También hay una tercera forma,menos común,de comparar cadenas de Java,y es con el método de la clase String compareTo.Si las dos cadenas son exactamente iguales,el método compareTo devolverá un valor de 0 (cero).Aquí hay un ejemplo rápido de cómo es este enfoque de comparación de cadenas:</target>
        </trans-unit>
        <trans-unit id="bd99e0fef1de55924764a54805cc9bf8add6c76c" translate="yes" xml:space="preserve">
          <source>This String equals method looks at the two Java strings, and if they contain the exact same string of characters, they are considered equal.</source>
          <target state="translated">Este método String equals mira las dos cadenas de Java,y si contienen exactamente la misma cadena de caracteres,se consideran iguales.</target>
        </trans-unit>
        <trans-unit id="e9a6798a3b8ca94cbcd2c60ca2d18c6ff69b9779" translate="yes" xml:space="preserve">
          <source>This is because when you create any String literal, the JVM first searches for that literal in the String pool, and if it finds a match, that same reference will be given to the new String. Because of this, we get:</source>
          <target state="translated">Esto se debe a que cuando se crea cualquier literal de un String,la JVM primero busca ese literal en el pool de String,y si encuentra una coincidencia,esa misma referencia se dará al nuevo String.Debido a esto,obtenemos:</target>
        </trans-unit>
        <trans-unit id="9123a723dd721a4c3eb2ba822a7a05286c4f3051" translate="yes" xml:space="preserve">
          <source>When all is said and done, even if we have guarantee that the strings are interns, using the &lt;code&gt;equals()&lt;/code&gt; method is still not that overhead that one might think, definitely the recommended way. If you want efficient reference check, then use enums where it is guaranteed by the language specification and implementation that the same enum value will be the same object (by reference).</source>
          <target state="translated">Cuando todo est&amp;aacute; dicho y hecho, incluso si tenemos la garant&amp;iacute;a de que las cadenas son pasantes, usar el m&amp;eacute;todo &lt;code&gt;equals()&lt;/code&gt; todav&amp;iacute;a no es una sobrecarga que uno podr&amp;iacute;a pensar, definitivamente la forma recomendada. Si desea una verificaci&amp;oacute;n de referencia eficiente, utilice enumeraciones donde la especificaci&amp;oacute;n y la implementaci&amp;oacute;n del lenguaje garanticen que el mismo valor de enumeraci&amp;oacute;n ser&amp;aacute; el mismo objeto (por referencia).</target>
        </trans-unit>
        <trans-unit id="c6dbba253687916f57aa803f9e2177e9867ca001" translate="yes" xml:space="preserve">
          <source>When using == operator for string comparison you are not comparing the contents of the string, but are actually comparing the memory address. If they are both equal it will return true and false otherwise. Whereas equals in string compares the string contents.</source>
          <target state="translated">Cuando se utiliza el operador ==para la comparación de cadenas no se está comparando el contenido de la cadena,sino que se está comparando la dirección de la memoria.Si ambos son iguales,se devolverá verdadero y falso de otra manera.Mientras que el operador igual en cadena compara el contenido de la cadena.</target>
        </trans-unit>
        <trans-unit id="8d70775b46e120808e9850984c65117158958e7d" translate="yes" xml:space="preserve">
          <source>When you call new for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, each one gets a new reference that points to the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; in the string table.  The references are different, but the content is the same.</source>
          <target state="translated">Cuando llama a new para &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; , cada uno obtiene una nueva referencia que apunta al &lt;code&gt;&quot;foo&quot;&lt;/code&gt; en la tabla de cadenas. Las referencias son diferentes, pero el contenido es el mismo.</target>
        </trans-unit>
        <trans-unit id="4d0a9e43f42077a13b12f40c79f0b6c8bc2da63a" translate="yes" xml:space="preserve">
          <source>When you check (compare) two objects using the &lt;code&gt;==&lt;/code&gt; operator it compares the address equality into the string-pool. If the two String objects have the same address references then it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. But if you want to compare the contents of two String objects then you must override the &lt;code&gt;equals&lt;/code&gt; method.</source>
          <target state="translated">Cuando marca (compara) dos objetos con el operador &lt;code&gt;==&lt;/code&gt; , compara la igualdad de direcciones en el conjunto de cadenas. Si los dos objetos String tienen las mismas referencias de direcci&amp;oacute;n, devuelve &lt;code&gt;true&lt;/code&gt; , de lo contrario &lt;code&gt;false&lt;/code&gt; . Pero si desea comparar el contenido de dos objetos String, debe anular el m&amp;eacute;todo &lt;code&gt;equals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="586e208e279cd35f608e8fe3160362705865c64d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;.equals()&lt;/code&gt; always compares a value of String so it gives true in both cases:</source>
          <target state="translated">Mientras que &lt;code&gt;.equals()&lt;/code&gt; siempre compara un valor de String, por lo que da verdadero en ambos casos:</target>
        </trans-unit>
        <trans-unit id="41629ab5d619a837a7d228c06888aa2337ba8eac" translate="yes" xml:space="preserve">
          <source>While I'm writing about this concept of equality in Java, it's important to note that the Java language includes an equals method in the base Java Object class. Whenever you're creating your own objects and you want to provide a means to see if two instances of your object are &quot;equal&quot;, you should override (and implement) this equals method in your class (in the same way the Java language provides this equality/comparison behavior in the String equals method).</source>
          <target state="translated">Mientras escribo sobre este concepto de igualdad en Java,es importante notar que el lenguaje Java incluye un método de igualdad en la clase de objetos Java básicos.Siempre que estés creando tus propios objetos y quieras proporcionar un medio para ver si dos instancias de tu objeto son &quot;iguales&quot;,deberías anular (e implementar)este método de igualdad en tu clase (de la misma manera que el lenguaje Java proporciona este comportamiento de comparación de igualdad en el método de igualdad String).</target>
        </trans-unit>
        <trans-unit id="dce24af4033f2e3a02feb720dd5df0c2bafd0e35" translate="yes" xml:space="preserve">
          <source>Yea, it's bad...</source>
          <target state="translated">Sí,es malo...</target>
        </trans-unit>
        <trans-unit id="d6e11d8f251b17000089bf6e46de65e7004dda75" translate="yes" xml:space="preserve">
          <source>Yes, &lt;code&gt;==&lt;/code&gt; is bad for comparing Strings (any objects really, unless you know they're canonical).  &lt;code&gt;==&lt;/code&gt; just compares object references.  &lt;code&gt;.equals()&lt;/code&gt; tests for equality. For Strings, often they'll be the same but as you've discovered, that's not guaranteed always.</source>
          <target state="translated">S&amp;iacute;, &lt;code&gt;==&lt;/code&gt; es malo para comparar cadenas (cualquier objeto realmente, a menos que sepa que son can&amp;oacute;nicos). &lt;code&gt;==&lt;/code&gt; solo compara referencias de objetos. &lt;code&gt;.equals()&lt;/code&gt; prueba de igualdad. Para las cadenas, a menudo ser&amp;aacute;n las mismas, pero como has descubierto, eso no siempre est&amp;aacute; garantizado.</target>
        </trans-unit>
        <trans-unit id="f8e7716ea4c3e20c7bdf723f23756bb919d9eaad" translate="yes" xml:space="preserve">
          <source>You almost &lt;strong&gt;always&lt;/strong&gt; want to use &lt;code&gt;Objects.equals()&lt;/code&gt;. In the &lt;strong&gt;rare&lt;/strong&gt; situation where you &lt;strong&gt;know&lt;/strong&gt; you're dealing with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--&quot;&gt;interned&lt;/a&gt; strings, you &lt;em&gt;can&lt;/em&gt; use &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Casi &lt;strong&gt;siempre&lt;/strong&gt; quieres usar &lt;code&gt;Objects.equals()&lt;/code&gt; . En la &lt;strong&gt;rara&lt;/strong&gt; situaci&amp;oacute;n en la que &lt;strong&gt;sabe&lt;/strong&gt; que est&amp;aacute; tratando con cadenas &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--&quot;&gt;internados&lt;/a&gt; , &lt;em&gt;puede&lt;/em&gt; usar &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5161c797f0345d83c726119d178d75aa5610fb2c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;compareTo()&lt;/code&gt; method to compare two Strings. If the compareTo result is 0, then the two strings are equal, otherwise the strings being compared are not equal.</source>
          <target state="translated">Tambi&amp;eacute;n puede usar el &lt;code&gt;compareTo()&lt;/code&gt; para comparar dos cadenas. Si el resultado compareTo es 0, entonces las dos cadenas son iguales, de lo contrario las cadenas que se comparan no son iguales.</target>
        </trans-unit>
        <trans-unit id="0afb8ff09e0f16ede865ab95dfcdc15300c82b5a" translate="yes" xml:space="preserve">
          <source>You may want to have a look at this &lt;a href=&quot;http://www.ensta-paristech.fr/~diam/java/online/notes-java/data/expressions/22compareobjects.html&quot;&gt;==, .equals(), compareTo(), and compare()&lt;/a&gt;</source>
          <target state="translated">Es posible que desee echar un vistazo a this &lt;a href=&quot;http://www.ensta-paristech.fr/~diam/java/online/notes-java/data/expressions/22compareobjects.html&quot;&gt;==, .equals (), compareTo () y compare ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ea16d98d575b2b8348dcba9edc206a8a0907873" translate="yes" xml:space="preserve">
          <source>You will get the output as &lt;code&gt;TRUE&lt;/code&gt; if you use &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Obtendr&amp;aacute; el resultado como &lt;code&gt;TRUE&lt;/code&gt; si usa &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
