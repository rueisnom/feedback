<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/513832">
    <body>
      <group id="513832">
        <trans-unit id="534e6e35df4d7a293d4fb797e174a5f76b1e1e74" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)&quot;&gt;Objects.equals()&lt;/a&gt; checks for &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;.equals()&lt;/code&gt; so you don't have to (available as of JDK7, also available in &lt;a href=&quot;https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#equals&quot;&gt;Guava&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)&quot;&gt;Objects.equals（）&lt;/a&gt;在调用 &lt;code&gt;.equals()&lt;/code&gt; 之前检查是否为 &lt;code&gt;null&lt;/code&gt; ，因此您不必这样做（从JDK7开始可用，在&lt;a href=&quot;https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#equals&quot;&gt;Guava中&lt;/a&gt;也可用）。</target>
        </trans-unit>
        <trans-unit id="50d43f0916ad54e9845c2ad2b4e494d7973e3311" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contentEquals-java.lang.CharSequence-&quot;&gt;String.contentEquals()&lt;/a&gt; compares the content of the &lt;code&gt;String&lt;/code&gt; with the content of any &lt;code&gt;CharSequence&lt;/code&gt; (available since Java 1.5).</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contentEquals-java.lang.CharSequence-&quot;&gt;String.contentEquals（）&lt;/a&gt;将 &lt;code&gt;String&lt;/code&gt; 的内容与任何 &lt;code&gt;CharSequence&lt;/code&gt; 的内容进行比较（从Java 1.5开始可用）。</target>
        </trans-unit>
        <trans-unit id="e192e0e817715cc164367bdc6257808206f7aef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; compares String values.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; 比较字符串值。</target>
        </trans-unit>
        <trans-unit id="88f052486d7c3398f63c986b644896db673de477" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; compares the data in a class (assuming the function is implemented).
&lt;code&gt;==&lt;/code&gt; compares pointer locations (location of the object in memory).</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; 比较类中的数据（假设函数已实现）。 &lt;code&gt;==&lt;/code&gt; 比较指针位置（对象在内存中的位置）。</target>
        </trans-unit>
        <trans-unit id="97f06596c10185b66f044c98db5fa447f42cbbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; tests for value equality (whether they are logically &quot;equal&quot;).</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; 测试值是否相等（在逻辑上是否相等）。</target>
        </trans-unit>
        <trans-unit id="2d0683433eb16443cb6ac4e5d95688372936574c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; compares Object references.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 比较对象引用。</target>
        </trans-unit>
        <trans-unit id="d99d8255c217ecd40d6e336608014d1c046139ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; compares the reference value of objects whereas the &lt;code&gt;equals()&lt;/code&gt; method present in the &lt;code&gt;java.lang.String&lt;/code&gt; class compares the contents of the &lt;code&gt;String&lt;/code&gt; object (to another object).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 比较对象的参考值，而 &lt;code&gt;java.lang.String&lt;/code&gt; 类中存在的 &lt;code&gt;equals()&lt;/code&gt; 方法将 &lt;code&gt;String&lt;/code&gt; 对象的内容（与另一个对象）进行比较。</target>
        </trans-unit>
        <trans-unit id="a7845d5fc79d961485ccf489239e9b8562c7adcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; handles &lt;code&gt;null&lt;/code&gt; strings fine, but calling &lt;code&gt;.equals()&lt;/code&gt; from a null string will cause an exception:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 可以很好地处理 &lt;code&gt;null&lt;/code&gt; 字符串，但是从null字符串调用 &lt;code&gt;.equals()&lt;/code&gt; 会导致异常：</target>
        </trans-unit>
        <trans-unit id="127a53ded3ac4bf04076d5f594c50d3375520fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means that your two string references are exactly the same object. You may have heard that this is the case because Java keeps sort of a literal table (which it does), but that is not always the case. Some strings are loaded in different ways, constructed from other strings, etc., so you must never assume that two identical strings are stored in the same location.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 表示您的两个字符串引用是完全相同的对象。 您可能已经听说过这种情况，因为Java保留了某种文字表（它确实这样做了），但并非总是如此。 某些字符串以不同的方式加载，是由其他字符串等构成的，因此，您绝不能假定两个相同的字符串存储在同一位置。</target>
        </trans-unit>
        <trans-unit id="972cd1c4c26a9b3d5a65d2854333166a32a64472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; performs a &lt;strong&gt;reference&lt;/strong&gt; equality check, whether the 2 objects (strings in this case) refer to the same object in the memory.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 执行&lt;strong&gt;引用&lt;/strong&gt;相等性检查，以检查2个对象（在这种情况下为字符串）是否引用内存中的同一对象。</target>
        </trans-unit>
        <trans-unit id="3e8ab4bbb062dbd444c07ca3191ce5b49b24c15e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; returns true if both objects (NOT TALKING ABOUT PRIMITIVES) point to the SAME object instance.
&lt;code&gt;.equals()&lt;/code&gt; returns true if the two objects contain the same data &lt;a href=&quot;http://www.java-samples.com/showtutorial.php?tutorialid=221&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; Versus &lt;code&gt;==&lt;/code&gt; in Java&lt;/a&gt;</source>
          <target state="translated">如果两个对象（不谈论原语）都指向SAME对象实例，则 &lt;code&gt;==&lt;/code&gt; 返回true。 如果两个对象包含相同的数据&lt;a href=&quot;http://www.java-samples.com/showtutorial.php?tutorialid=221&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; 与Java中的 &lt;code&gt;==&lt;/code&gt; ，&lt;/a&gt;则 &lt;code&gt;.equals()&lt;/code&gt; 返回true</target>
        </trans-unit>
        <trans-unit id="65bb9efb919c1b1b9f8f00a8ab69486e0c1f6fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; tests for reference equality (whether they are the same object).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 测试引用是否相等（它们是否是同一对象）。</target>
        </trans-unit>
        <trans-unit id="a40f8dacba2a1950f6ea624f0d2317bcc2a772dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; tests object references, &lt;code&gt;.equals()&lt;/code&gt; tests the string values.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 测试对象引用， &lt;code&gt;.equals()&lt;/code&gt; 测试字符串值。</target>
        </trans-unit>
        <trans-unit id="a6e3babe176e5f525115bc259e2f5e512d8d9667" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals&lt;/code&gt; is actually the method of the Object class, but it is Overridden into the String class and a new definition is given which compares the contents of object.</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; 实际上是Object类的方法，但是它被重写为String类，并给出了一个新的定义来比较对象的内容。</target>
        </trans-unit>
        <trans-unit id="ce16c9cf4f660e1842cc8af2704dd6ef8946c75c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Example&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8218a9a9840123be7b37c5258175c475d6d3d5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(a==b) ===&amp;gt; true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;（a == b）===&amp;gt;是&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de97c48c26c2975344975ab7fd565ec5f47f43e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;==&lt;/code&gt; compares object references in Java&lt;/strong&gt;, and that is no exception for &lt;code&gt;String&lt;/code&gt; objects.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;==&lt;/code&gt; 比较Java中的对象引用&lt;/strong&gt; ，并且 &lt;code&gt;String&lt;/code&gt; 对象也不例外。</target>
        </trans-unit>
        <trans-unit id="4f9b336e70ecf3d8434ca63a79793c6e9a5a5306" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But beware of nulls!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但要注意空值！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83aa0f60e0ba5d1766913ffd675fc9f79c342e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;情况1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf6e653fe9d46dc5857806ccff042fa746c23fc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;情况二&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c83e5f944d3f32a33f78893b1ae58827ce8aa54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For comparing the actual contents of objects (including &lt;code&gt;String&lt;/code&gt;), one must use the &lt;code&gt;equals&lt;/code&gt; method&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;为了比较对象（包括 &lt;code&gt;String&lt;/code&gt; ）的实际内容，必须使用 &lt;code&gt;equals&lt;/code&gt; 方法&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="380badf346b49077ad347f903d9e64bdfc6c0961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 1: Java String comparison with the equals method&lt;/strong&gt;
Most of the time (maybe 95% of the time) I compare strings with the equals method of the Java String class, like this:</source>
          <target state="translated">&lt;strong&gt;选项1：使用equals方法&lt;/strong&gt;对&lt;strong&gt;Java字符串进行比较&lt;/strong&gt;大多数时候（可能是95％的时间），我将字符串与Java String类的equals方法进行比较，如下所示：</target>
        </trans-unit>
        <trans-unit id="eb85d4a727a36caf962b7bac941d7c46f894a6a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 2: String comparison with the equalsIgnoreCase method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;选项2：使用equalsIgnoreCase方法进行字符串比较&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d42bd1a8a45eb4097779363d21181e70e60ef953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 3: Java String comparison with the compareTo method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;选项3：使用compareTo方法比较Java字符串&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae8b1214c75a26ad44633cb7ce38b5eea68d2fd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;if(a==b) ===&amp;gt; false.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;if（a == b）===&amp;gt;否。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ebc8538d9ce17c45cfa160ccf33b7ac0efa63fee" translate="yes" xml:space="preserve">
          <source>A key note is that strings are stored in one lump pool so once a string is created it is forever stored in a program at the same address. Strings do not change, they are immutable. This is why it is a bad idea to use regular string concatenation if you have a serious of amount of string processing to do. Instead you would use the &lt;code&gt;StringBuilder&lt;/code&gt; classes provided. Remember the pointers to this string can change and if you were interested to see if two pointers were the same &lt;code&gt;==&lt;/code&gt; would be a fine way to go. Strings themselves do not.</source>
          <target state="translated">一个重要的注意事项是，字符串存储在一个总池中，因此一旦创建了字符串，它将永远存储在同一地址的程序中。 字符串不变，它们是不可变的。 这就是为什么如果您有大量的字符串处理需要使用常规的字符串连接是一个不好的主意的原因。 相反，您将使用提供的 &lt;code&gt;StringBuilder&lt;/code&gt; 类。 请记住，指向此字符串的指针可以更改，如果您有兴趣查看两个指针是否相同，则 &lt;code&gt;==&lt;/code&gt; 将是一个不错的选择。 字符串本身没有。</target>
        </trans-unit>
        <trans-unit id="2e32a37850b13cf98c87aa3bc11f6bbc550512a2" translate="yes" xml:space="preserve">
          <source>All objects are guaranteed to have a &lt;code&gt;.equals()&lt;/code&gt; method since Object contains a method, &lt;code&gt;.equals()&lt;/code&gt;, that returns a boolean. It is the subclass' job to override this method if a further defining definition is required. Without it (i.e. using &lt;code&gt;==&lt;/code&gt;) only memory addresses are checked between two objects for equality. String overrides this &lt;code&gt;.equals()&lt;/code&gt; method and instead of using the memory address it returns the comparison of strings at the character level for equality.</source>
          <target state="translated">保证所有对象都有 &lt;code&gt;.equals()&lt;/code&gt; 方法，因为Object包含一个返回布尔值的方法 &lt;code&gt;.equals()&lt;/code&gt; 。 如果需要进一步的定义定义，则重写此方法是子类的工作。 没有它（即使用 &lt;code&gt;==&lt;/code&gt; ），仅检查两个对象之间的内存地址是否相等。 字符串重写此 &lt;code&gt;.equals()&lt;/code&gt; 方法，而不是使用内存地址，而是返回字符级别的字符串比较以确保相等。</target>
        </trans-unit>
        <trans-unit id="2e7d953f9e0db5183f7079c0553cc235460d97be" translate="yes" xml:space="preserve">
          <source>But mind it respects the case of String. If you want case insensitive compare then you must go for the equalsIgnoreCase method of the String class.</source>
          <target state="translated">但是要注意它尊重String类的大小写。如果你想要不区分大小写的比较,那么你必须使用String类的equalsIgnoreCase方法。</target>
        </trans-unit>
        <trans-unit id="08393c6c77f96e040c5d84e5121ed2a44b0608d1" translate="yes" xml:space="preserve">
          <source>But what you can do is to call &lt;code&gt;intern()&lt;/code&gt; on your non-literal strings.</source>
          <target state="translated">但是您可以做的是在非文字字符串上调用 &lt;code&gt;intern()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15a3cf51d08c5a4791935fe82b44b7c4f15102fb" translate="yes" xml:space="preserve">
          <source>But, when the two strings contain the exact same string of characters, the equals method will return true, as in this example:</source>
          <target state="translated">但是,当两个字符串中包含完全相同的字符串时,等号方法将返回true,就像这个例子中的例子一样。</target>
        </trans-unit>
        <trans-unit id="af38a399948a04b463b546d4f948912c00118098" translate="yes" xml:space="preserve">
          <source>Consequently, if you want to test whether two strings have the same value you will probably want to use &lt;code&gt;Objects.equals()&lt;/code&gt;.</source>
          <target state="translated">因此，如果要测试两个字符串是否具有相同的值，则可能要使用 &lt;code&gt;Objects.equals()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aafac2f992d36c8bca828739a7404532d20a8a6" translate="yes" xml:space="preserve">
          <source>Consider two different reference variables, &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt;:</source>
          <target state="translated">考虑两个不同的参考变量 &lt;code&gt;str1&lt;/code&gt; 和 &lt;code&gt;str2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9847ecced7aa002791c61138db5356d024636623" translate="yes" xml:space="preserve">
          <source>Definitely the use of &lt;code&gt;equals()&lt;/code&gt; method is recommended.</source>
          <target state="translated">绝对建议使用 &lt;code&gt;equals()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="bf3bcba66a1552787dd686311371f4c3aa8ed466" translate="yes" xml:space="preserve">
          <source>Don't worry about the performance. Some things to encourage using &lt;code&gt;String.equals()&lt;/code&gt;:</source>
          <target state="translated">不用担心性能。 鼓励使用 &lt;code&gt;String.equals()&lt;/code&gt; 的一些事情：</target>
        </trans-unit>
        <trans-unit id="b06f25fbeed92476c87e1968ec046f4936266cc1" translate="yes" xml:space="preserve">
          <source>Equals does the real comparison for you.</source>
          <target state="translated">Equals为你做了真正的比较。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f4fca6333e5c683fdaa7713181bcfbd25b1d2643" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot;&gt;JLS 3.10.5. &lt;em&gt;String Literals&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot;&gt;JLS 3.10.5起。&lt;/a&gt; &lt;em&gt;字符串文字&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="003e5d38b8c1eac244f02ac363a47c0bbaf9273c" translate="yes" xml:space="preserve">
          <source>From zacherates example:</source>
          <target state="translated">从撒切尔茨的例子来看。</target>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="14fb73b968e1433308008402842a19df1bd245b3" translate="yes" xml:space="preserve">
          <source>How do I compare strings in Java</source>
          <target state="translated">如何在Java中比较字符串</target>
        </trans-unit>
        <trans-unit id="e90775e8efad74a01524c188edc8b6dc2072c2b5" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;==&lt;/code&gt; fails in the following case:</source>
          <target state="translated">但是，在以下情况下 &lt;code&gt;==&lt;/code&gt; 失败：</target>
        </trans-unit>
        <trans-unit id="ad8fc1b7115a0a617bf3361c92f8d88d012c6205" translate="yes" xml:space="preserve">
          <source>I agree with the answer from zacherates.</source>
          <target state="translated">我同意Zacherates的回答。</target>
        </trans-unit>
        <trans-unit id="209b45599a8f24c29dacb03bdf122cc9869d6a84" translate="yes" xml:space="preserve">
          <source>I think that when you define a &lt;code&gt;String&lt;/code&gt; you define an object. So you need to use &lt;code&gt;.equals()&lt;/code&gt;. When you use primitive data types you use &lt;code&gt;==&lt;/code&gt; but with &lt;code&gt;String&lt;/code&gt; (and any object) you must use &lt;code&gt;.equals()&lt;/code&gt;.</source>
          <target state="translated">我认为，当您定义 &lt;code&gt;String&lt;/code&gt; 时，您将定义一个对象。 因此，您需要使用 &lt;code&gt;.equals()&lt;/code&gt; 。 使用原始数据类型时，请使用 &lt;code&gt;==&lt;/code&gt; ,但对于 &lt;code&gt;String&lt;/code&gt; （和任何对象），必须使用 &lt;code&gt;.equals()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6deec886dc61621c93ed9d7b5c29032c707f83c" translate="yes" xml:space="preserve">
          <source>I've been using the &lt;code&gt;==&lt;/code&gt; operator in my program to compare all my strings so far.
However, I ran into a bug, changed one of them into &lt;code&gt;.equals()&lt;/code&gt; instead, and it fixed the bug.</source>
          <target state="translated">到目前为止，我一直在程序中使用 &lt;code&gt;==&lt;/code&gt; 运算符比较所有字符串。 但是，我遇到了一个错误，将其中一个更改为 &lt;code&gt;.equals()&lt;/code&gt; ，并修复了该错误。</target>
        </trans-unit>
        <trans-unit id="ee1db44f97923a97f6aa14945a8e524aef45e729" translate="yes" xml:space="preserve">
          <source>If a comparison of two &lt;code&gt;String&lt;/code&gt; objects using &lt;code&gt;==&lt;/code&gt; turns out to be &lt;code&gt;true&lt;/code&gt;, that is because the &lt;code&gt;String&lt;/code&gt; objects were interned, and the Java Virtual Machine is having multiple references point to the same instance of &lt;code&gt;String&lt;/code&gt;. One should not expect that comparing one &lt;code&gt;String&lt;/code&gt; object containing the same contents as another &lt;code&gt;String&lt;/code&gt; object using &lt;code&gt;==&lt;/code&gt; to evaluate as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;==&lt;/code&gt; 对两个 &lt;code&gt;String&lt;/code&gt; 对象进行比较的结果为 &lt;code&gt;true&lt;/code&gt; ，那是因为 &lt;code&gt;String&lt;/code&gt; 对象已被嵌入，并且Java虚拟机具有多个引用指向 &lt;code&gt;String&lt;/code&gt; 的同一实例。 不应期望使用 &lt;code&gt;==&lt;/code&gt; 将包含相同内容的另一个 &lt;code&gt;String&lt;/code&gt; 对象与另一个String对象进行比较以得出 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0975ad48f5593aec2b3883279cad972877d542d2" translate="yes" xml:space="preserve">
          <source>If the 2 string references are not the same, &lt;code&gt;String.equals()&lt;/code&gt; will next check the lengths of the strings. This is also a fast operation because the &lt;code&gt;String&lt;/code&gt; class stores the length of the string, no need to count the characters or code points. If the lengths differ, no further check is performed, we know they cannot be equal.</source>
          <target state="translated">如果两个字符串引用不同，则 &lt;code&gt;String.equals()&lt;/code&gt; 接下来将检查字符串的长度。 这也是一种快速的操作，因为 &lt;code&gt;String&lt;/code&gt; 类存储了字符串的长度，无需计算字符或代码点。 如果长度不同，则不会进一步检查，我们知道它们不能相等。</target>
        </trans-unit>
        <trans-unit id="622b2c72cef877135d3204c3e9e609ea0df5f20c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;equals()&lt;/code&gt; method is present in the &lt;code&gt;java.lang.Object&lt;/code&gt; class, and it is expected to check for the equivalence of the state of objects! That means, the contents of the objects. Whereas the &lt;code&gt;==&lt;/code&gt; operator is expected to check the actual object instances are same or not.</source>
          <target state="translated">如果 &lt;code&gt;java.lang.Object&lt;/code&gt; 类中存在 &lt;code&gt;equals()&lt;/code&gt; 方法， 则应检查对象状态是否相等！ 也就是说，对象的内容。 而 &lt;code&gt;==&lt;/code&gt; 运算符应检查实际对象实例是否相同。</target>
        </trans-unit>
        <trans-unit id="d701e5196e6f58abe2f4c8d3e765a337b6d5958c" translate="yes" xml:space="preserve">
          <source>If you intern the non-literal String equality is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">如果您实习非字面性的String相等为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a18409dd8aad86765bdf0eb5ade6c3e9c27a06b1" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;equals()&lt;/code&gt;</source>
          <target state="translated">如果您使用 &lt;code&gt;equals()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a606952753cf3dc70cfcd11f34796ac37f150100" translate="yes" xml:space="preserve">
          <source>If you're like me, when I first started using Java, I wanted to use the &quot;==&quot; operator to test whether two String instances were equal, but for better or worse, that's not the correct way to do it in Java.</source>
          <target state="translated">如果你和我一样,当我刚开始使用Java时,我想用&quot;===&quot;操作符来测试两个String实例是否相等,但无论好坏,这在Java中都不是正确的方法。</target>
        </trans-unit>
        <trans-unit id="19563d43dbd1fb12946c8b55472adc3ce8a4a839" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;String.equals()&lt;/code&gt; first checks for reference equality (using &lt;code&gt;==&lt;/code&gt;), and if the 2 strings are the same by reference, no further calculation is performed!</source>
          <target state="translated">&lt;code&gt;String.equals()&lt;/code&gt; 的实现首先检查引用是否相等（使用 &lt;code&gt;==&lt;/code&gt; ），如果两个字符串的引用相同，则不执行进一步的计算！</target>
        </trans-unit>
        <trans-unit id="df7f3b75bfe7cc351d7943de807b0754f7e73609" translate="yes" xml:space="preserve">
          <source>In Java, when the &lt;strong&gt;&amp;ldquo;==&amp;rdquo;&lt;/strong&gt; operator is used to compare 2 objects, it checks to see if the objects refer to the same place in memory. In other words, it checks to see if the 2 object names are basically references to the same memory location.</source>
          <target state="translated">在Java中，当使用&lt;strong&gt;&amp;ldquo; ==&amp;rdquo;&lt;/strong&gt;运算符比较两个对象时，它将检查对象是否指向内存中的同一位置。 换句话说，它检查两个对象名称是否基本上是对相同内存位置的引用。</target>
        </trans-unit>
        <trans-unit id="f9de1f4d7b9c7548a170b2aee63ef265f6232437" translate="yes" xml:space="preserve">
          <source>In some string comparison tests you'll want to ignore whether the strings are uppercase or lowercase. When you want to test your strings for equality in this case-insensitive manner, use the equalsIgnoreCase method of the String class, like this:</source>
          <target state="translated">在一些字符串比较测试中,你会希望忽略字符串是大写还是小写。当你想以这种不区分大小写的方式测试字符串是否平等时,可以使用String类的equalsIgnoreCase方法,就像这样。</target>
        </trans-unit>
        <trans-unit id="5096e9095a26aead7dd77a00dd73649fb297b01c" translate="yes" xml:space="preserve">
          <source>In this case for &lt;code&gt;new String(&quot;test&quot;)&lt;/code&gt; the statement new String will be created on the heap, and that reference will be given to &lt;code&gt;b&lt;/code&gt;, so &lt;code&gt;b&lt;/code&gt; will be given a reference on the heap, not in String pool.</source>
          <target state="translated">在这种情况下，对于 &lt;code&gt;new String(&quot;test&quot;)&lt;/code&gt; ，将在堆上创建new String语句，并且该引用将被赋予 &lt;code&gt;b&lt;/code&gt; ，因此 &lt;code&gt;b&lt;/code&gt; 将在堆上（而不是在字符串池中）被赋予引用。</target>
        </trans-unit>
        <trans-unit id="ca3a426a66508840a27f96c237b38e05c70f30b4" translate="yes" xml:space="preserve">
          <source>In this tutorial I'll demonstrate several different ways to correctly compare Java strings, starting with the approach I use most of the time. At the end of this Java String comparison tutorial I'll also discuss why the &quot;==&quot; operator doesn't work when comparing Java strings.</source>
          <target state="translated">在本教程中,我将演示几种不同的方法来正确比较Java字符串,先从我最常用的方法开始。在这个Java字符串比较教程的最后,我还将讨论为什么在比较Java字符串时,&quot;===&quot;操作符不起作用。</target>
        </trans-unit>
        <trans-unit id="66c5627d8cfe42bc4a6e93001ed6714eba02b7c5" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;==&lt;/code&gt; bad? When should it and should it not be used? What's the difference?</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 不好吗？ 什么时候应该使用它，不应该使用它？ 有什么不同？</target>
        </trans-unit>
        <trans-unit id="44ed4293c7fc2288444421274472d44a6e861151" translate="yes" xml:space="preserve">
          <source>Java also talks about the function intern() that can be used on a string to make it part of the cache so &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;).intern()&lt;/code&gt; will return true.</source>
          <target state="translated">Java还讨论了可以在字符串上使用的intern（）函数，使其成为缓存的一部分，因此 &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;).intern()&lt;/code&gt; 将返回true。</target>
        </trans-unit>
        <trans-unit id="bbcdbf601957f23cebef96d44f7ff1ddf50b5aff" translate="yes" xml:space="preserve">
          <source>Java have a String pool under which Java manages the memory allocation for the String objects. See &lt;a href=&quot;https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java&quot;&gt;&lt;strong&gt;String Pools in Java&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">Java有一个String池，Java在该池下管理String对象的内存分配。 请参见&lt;a href=&quot;https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java&quot;&gt;&lt;strong&gt;Java中的字符串池&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8dd2b96dbe38262e709c95739664151e953eb1" translate="yes" xml:space="preserve">
          <source>Let's See:</source>
          <target state="translated">让我们来看看。</target>
        </trans-unit>
        <trans-unit id="a73fa850bcd40c5192a74b3a633598a1eeddab8d" translate="yes" xml:space="preserve">
          <source>Make sure you understand why.  It's because the &lt;code&gt;==&lt;/code&gt; comparison only compares references; the &lt;code&gt;equals()&lt;/code&gt; method does a character-by-character comparison of the contents.</source>
          <target state="translated">确保您了解原因。 这是因为 &lt;code&gt;==&lt;/code&gt; 比较仅比较引用； &lt;code&gt;equals()&lt;/code&gt; 方法对内容进行逐字符比较。</target>
        </trans-unit>
        <trans-unit id="91794435135957626e3496e47088bf3118716d4a" translate="yes" xml:space="preserve">
          <source>Moreover, a string literal always refers to the &lt;em&gt;same&lt;/em&gt; instance of class &lt;code&gt;String&lt;/code&gt;. This is because string literals - or, more generally, strings that are the values of constant expressions (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28&quot;&gt;&amp;sect;15.28&lt;/a&gt;) - are &quot;interned&quot; so as to share unique instances, using the method &lt;code&gt;String.intern&lt;/code&gt;.</source>
          <target state="translated">此外，字符串文字总是引用类 &lt;code&gt;String&lt;/code&gt; 的&lt;em&gt;相同&lt;/em&gt;实例。 这是因为使用方法 &lt;code&gt;String.intern&lt;/code&gt; 对字符串文字（或更&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28&quot;&gt;常见的&lt;/a&gt;是常量表达式的值（第15.28节 ）的字符串 ）进行&amp;ldquo;内联&amp;rdquo;，以便共享唯一的实例。</target>
        </trans-unit>
        <trans-unit id="c374a8d811dc06c407f72b0c1bd01c73410b563a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;.equals()&lt;/code&gt; method belongs to class &lt;code&gt;Object&lt;/code&gt; (super class of all classes). You need to override it as per you class requirement, but for String it is already implemented, and it checks whether two strings have the same value or not.</source>
          <target state="translated">请注意， &lt;code&gt;.equals()&lt;/code&gt; 方法属于 &lt;code&gt;Object&lt;/code&gt; 类（所有类的超类）。 您需要根据您的类要求重写它，但是对于String而言，它已经实现，并且它检查两个字符串是否具有相同的值。</target>
        </trans-unit>
        <trans-unit id="ef7869c142e8b9c650d51fd7d526dffaf522ae76" translate="yes" xml:space="preserve">
          <source>Note: == operator is much faster than equals just because you are comparing two memory addresses, but you need to be sure that the code isn't creating new String instances in the code. Otherwise you will encounter bugs.</source>
          <target state="translated">注意:==操作符比equals快得多,只是因为你是在比较两个内存地址,但你需要确保代码中没有创建新的String实例。否则你会遇到bug。</target>
        </trans-unit>
        <trans-unit id="05f4a05acd2ff60019ca1cc57a02118ad5e2b4c8" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;a&lt;/code&gt; is pointing to a String in the String pool while &lt;code&gt;b&lt;/code&gt; is pointing to a String on the heap. Because of that we get:</source>
          <target state="translated">现在， &lt;code&gt;a&lt;/code&gt; 指向字符串池中的字符串，而 &lt;code&gt;b&lt;/code&gt; 指向堆上的字符串。 因此，我们得到：</target>
        </trans-unit>
        <trans-unit id="3ae4c4c99288daf3be8f6b076a1e030bc8f2a226" translate="yes" xml:space="preserve">
          <source>Now you will get the &lt;code&gt;FALSE&lt;/code&gt; as output, because both &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt; are pointing to two different objects even though both of them share the same string content. It is because of &lt;code&gt;new String()&lt;/code&gt; a new object is created every time.</source>
          <target state="translated">现在，您将获得 &lt;code&gt;FALSE&lt;/code&gt; 作为输出，因为 &lt;code&gt;str1&lt;/code&gt; 和 &lt;code&gt;str2&lt;/code&gt; 都指向两个不同的对象，即使它们都共享相同的字符串内容。 因为有了 &lt;code&gt;new String()&lt;/code&gt; ,每次都会创建一个新对象。</target>
        </trans-unit>
        <trans-unit id="77c5595bc439eb350a3083fde96d4b94b19d4d24" translate="yes" xml:space="preserve">
          <source>Obviously &lt;code&gt;==&lt;/code&gt; is faster, but will (might) give false results in many cases if you just want to tell if 2 &lt;code&gt;String&lt;/code&gt;s hold the same text.</source>
          <target state="translated">显然， &lt;code&gt;==&lt;/code&gt; 更快，但是如果您只想知道2个 &lt;code&gt;String&lt;/code&gt; 是否包含相同文本，则（可能）在许多情况下会给出错误结果。</target>
        </trans-unit>
        <trans-unit id="3f5984755ab3c60967abd3d47569bff195c24d31" translate="yes" xml:space="preserve">
          <source>Only if we got this far will the contents of the 2 strings be actually compared, and this will be a short-hand comparison: not all the characters will be compared, if we find a mismatching character (at the same position in the 2 strings), no further characters will be checked.</source>
          <target state="translated">只有走到这一步,才会真正地比较2个字符串的内容,这将是一个短手比较:并不是所有的字符都会被比较,如果发现不匹配的字符(在2个字符串中的相同位置),就不会再检查其他字符。</target>
        </trans-unit>
        <trans-unit id="4931a37091118ff489ec2354e6f1916dc8e35e55" translate="yes" xml:space="preserve">
          <source>Operator &lt;em&gt;==&lt;/em&gt; is always meant for &lt;strong&gt;object reference comparison&lt;/strong&gt;, whereas the String class &lt;em&gt;.equals()&lt;/em&gt; method is overridden for &lt;strong&gt;content comparison&lt;/strong&gt;:</source>
          <target state="translated">运算符&lt;em&gt;==&lt;/em&gt;始终用于&lt;strong&gt;对象引用比较&lt;/strong&gt; ，而String类&lt;em&gt;.equals（）&lt;/em&gt;方法被覆盖以进行&lt;strong&gt;内容比较&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="62d3323f1a4b43a5308396720b3529bdc784b601" translate="yes" xml:space="preserve">
          <source>Reason: If you create a String object using the &lt;code&gt;new&lt;/code&gt; keyword a separate space is allocated to it on the heap.</source>
          <target state="translated">原因：如果使用 &lt;code&gt;new&lt;/code&gt; 关键字创建String对象，则会在堆上为其分配单独的空间。</target>
        </trans-unit>
        <trans-unit id="e004e448e24213231c66b0837a3d3ab87e6c6817" translate="yes" xml:space="preserve">
          <source>Reason: String literals created without null are stored in the String pool in the permgen area of heap. So both s1 and s2 point to same object in the pool.</source>
          <target state="translated">原因是:创建的没有null的字符串字元被存储在堆的permgen区域的String池中。所以s1和s2都指向池中的同一个对象。</target>
        </trans-unit>
        <trans-unit id="e9694929438ff9ef921133d3e537bf55f70f6175" translate="yes" xml:space="preserve">
          <source>Similar examples can also be found in &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#d5e1634&quot;&gt;JLS 3.10.5-1&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#d5e1634&quot;&gt;JLS 3.10.5-1中&lt;/a&gt;也可以找到类似的示例。</target>
        </trans-unit>
        <trans-unit id="7678ffc7a34ab9b5bce1ba690a307007c3bc4cb7" translate="yes" xml:space="preserve">
          <source>So if you know that &lt;code&gt;fooString1&lt;/code&gt; may be null, tell the reader that by writing</source>
          <target state="translated">因此，如果您知道 &lt;code&gt;fooString1&lt;/code&gt; 可能为null，请告诉读者</target>
        </trans-unit>
        <trans-unit id="6364ba01158454f664dad6de332f337ba05f8043" translate="yes" xml:space="preserve">
          <source>So the question is if all the strings are cached in the system, how come &lt;code&gt;==&lt;/code&gt; returns false whereas equals return true? Well, this is possible. If you make a new string like &lt;code&gt;String str = new String(&quot;Testing&quot;)&lt;/code&gt; you end up creating a new string in the cache even if the cache already contains a string having the same content. In short &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;)&lt;/code&gt; will always return false.</source>
          <target state="translated">所以问题是，如果所有字符串都缓存在系统中， &lt;code&gt;==&lt;/code&gt; 如何返回false，而equals返回true？ 好吧，这是可能的。 如果您创建一个新字符串，例如 &lt;code&gt;String str = new String(&quot;Testing&quot;)&lt;/code&gt; 那么即使该缓存中已经包含具有相同内容的字符串，最终也会在缓存中创建一个新字符串。 简而言之， &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;)&lt;/code&gt; 将始终返回false。</target>
        </trans-unit>
        <trans-unit id="925bf81cb272f91e408e2585dfe66406073ec384" translate="yes" xml:space="preserve">
          <source>So using &lt;code&gt;.equals()&lt;/code&gt; is always better.</source>
          <target state="translated">因此，使用 &lt;code&gt;.equals()&lt;/code&gt; 总是更好。</target>
        </trans-unit>
        <trans-unit id="64e94d29a587c1b43ed1ff2b1f5eea22f76e7e69" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;==&lt;/code&gt; gives illusions of comparing String values, as in following cases:</source>
          <target state="translated">有时 &lt;code&gt;==&lt;/code&gt; 会产生比较String值的错觉，例如以下情况：</target>
        </trans-unit>
        <trans-unit id="ef7777dabf10c38fea3b84a7896afa72857e8048" translate="yes" xml:space="preserve">
          <source>Sometimes it looks as if &lt;code&gt;==&lt;/code&gt; compares values, because Java does some behind-the-scenes stuff to make sure identical in-line strings are actually the same object.</source>
          <target state="translated">有时看起来 &lt;code&gt;==&lt;/code&gt; 比较值，因为Java做了一些幕后操作，以确保相同的内联字符串实际上是同一对象。</target>
        </trans-unit>
        <trans-unit id="dc72f9ad1e0fe392b547dcb502b649489b4e684e" translate="yes" xml:space="preserve">
          <source>Strings in Java are immutable. That means whenever you try to change/modify the string you get a new instance. You cannot change the original string. This has been done so that these string instances can be cached. A typical program contains a lot of string references and caching these instances can decrease the memory footprint and increase the performance of the program.</source>
          <target state="translated">Java中的字符串是不可更改的。这意味着每当你试图改变修改字符串时,你就会得到一个新的实例。你不能改变原来的字符串。这样做是为了让这些字符串实例可以被缓存。一个典型的程序包含大量的字符串引用,缓存这些实例可以减少内存占用,提高程序的性能。</target>
        </trans-unit>
        <trans-unit id="1a5b82a90623ced9b5ebfc731549926d882846eb" translate="yes" xml:space="preserve">
          <source>Taking a look at a quick String comparison example with the equals method, if the following test were run, the two strings would not be considered equal because the characters are not the exactly the same (the case of the characters is different):</source>
          <target state="translated">看一下用equals方法的快速字符串比较的例子,如果运行下面的测试,两个字符串不会被认为是相等的,因为字符不完全相同(字符的情况不同)。</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="b0163278938a7a8c6bd706310467bbb52b4e5811" translate="yes" xml:space="preserve">
          <source>That may help you.</source>
          <target state="translated">这也许对你有帮助。</target>
        </trans-unit>
        <trans-unit id="956e0cfc5f2a662f8be4c8e1953a725f10223a4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.equals()&lt;/code&gt; method  check if the two strings have the same value.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; 方法检查两个字符串是否具有相同的值。</target>
        </trans-unit>
        <trans-unit id="3e72766ae6883a1ca99b3e34b1d125ce6dbd4582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.equals()&lt;/code&gt; method will check if the two strings have the same value.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; 方法将检查两个字符串是否具有相同的值。</target>
        </trans-unit>
        <trans-unit id="3978d062c149bf7accbca4cf5ab4522220f8fe12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; compares the references and does not compare the actual strings. If you did create every string using &lt;code&gt;new String(somestring).intern()&lt;/code&gt; then you can use the &lt;code&gt;==&lt;/code&gt; operator to compare two strings, otherwise equals() or compareTo methods can only be used.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 比较引用，不比较实际字符串。 如果确实使用 &lt;code&gt;new String(somestring).intern()&lt;/code&gt; 创建了每个字符串，则可以使用 &lt;code&gt;==&lt;/code&gt; 运算符比较两个字符串，否则只能使用equals（）或compareTo方法。</target>
        </trans-unit>
        <trans-unit id="5512073b994a06023b1cc12815e391ae76326db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator check if the two references point to the same object or not. &lt;code&gt;.equals()&lt;/code&gt; check for the actual string content (value).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 运算符检查两个引用是否指向同一对象。 &lt;code&gt;.equals()&lt;/code&gt; 检查实际的字符串内容（值）。</target>
        </trans-unit>
        <trans-unit id="38eb3a4f9caacaa06f820fa599872a9b24a84e2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator checks if the two strings are exactly the same object.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 运算符检查两个字符串是否完全相同。</target>
        </trans-unit>
        <trans-unit id="a9a0606a28ccdd73d47713f4b0a9ffe7105e4faa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator checks to see if the two strings are exactly the same object.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 运算符检查两个字符串是否完全相同。</target>
        </trans-unit>
        <trans-unit id="d48da5a819a7433506b69dd9c4156df1be51f528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method will check whether the &lt;strong&gt;contents&lt;/strong&gt; or the &lt;strong&gt;states&lt;/strong&gt; of 2 objects are the same.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; 方法将检查2个对象的&lt;strong&gt;内容&lt;/strong&gt;或&lt;strong&gt;状态&lt;/strong&gt;是否相同。</target>
        </trans-unit>
        <trans-unit id="4c712b2bf82e618b0042ca50c72334d695ff56a7" translate="yes" xml:space="preserve">
          <source>The Java String class actually overrides the default equals() implementation in the Object class &amp;ndash; and it overrides the method so that it checks only the values of the strings, not their locations in memory.
 This means that if you call the equals() method to compare 2 String objects, then as long as the actual sequence of characters is equal, both objects are considered equal.</source>
          <target state="translated">Java String类实际上覆盖了Object类中默认的equals（）实现，并且覆盖了该方法，因此它仅检查字符串的值，而不检查它们在内存中的位置。 这意味着，如果调用equals（）方法比较2个String对象，则只要实际字符序列相等，两个对象就被视为相等。</target>
        </trans-unit>
        <trans-unit id="b255548604584b6fe35e432b209faddbe10a7980" translate="yes" xml:space="preserve">
          <source>The following is shorter, but it&amp;rsquo;s less obvious that it checks for null (from Java 7):</source>
          <target state="translated">以下内容更简短，但是它不检查空值（从Java 7开始）不太明显：</target>
        </trans-unit>
        <trans-unit id="3caa790aba81043457285ebcb715deab21762bd6" translate="yes" xml:space="preserve">
          <source>There is also a third, less common way to compare Java strings, and that's with the String class compareTo method. If the two strings are exactly the same, the compareTo method will return a value of 0 (zero). Here's a quick example of what this String comparison approach looks like:</source>
          <target state="translated">还有第三种比较Java字符串的方法,也就是String类的compareTo方法。如果两个字符串完全相同,compareTo方法将返回一个值为0(0)的值。下面是这个String比较方法的简单例子。</target>
        </trans-unit>
        <trans-unit id="bd99e0fef1de55924764a54805cc9bf8add6c76c" translate="yes" xml:space="preserve">
          <source>This String equals method looks at the two Java strings, and if they contain the exact same string of characters, they are considered equal.</source>
          <target state="translated">这个String equals方法查看两个Java字符串,如果它们包含完全相同的字符串,则认为它们是相等的。</target>
        </trans-unit>
        <trans-unit id="e9a6798a3b8ca94cbcd2c60ca2d18c6ff69b9779" translate="yes" xml:space="preserve">
          <source>This is because when you create any String literal, the JVM first searches for that literal in the String pool, and if it finds a match, that same reference will be given to the new String. Because of this, we get:</source>
          <target state="translated">这是因为当你创建任何String字段时,JVM首先会在String池中搜索该字段,如果找到匹配的字段,那么同样的引用会被赋予新的String。因为这样,我们得到的是</target>
        </trans-unit>
        <trans-unit id="9123a723dd721a4c3eb2ba822a7a05286c4f3051" translate="yes" xml:space="preserve">
          <source>When all is said and done, even if we have guarantee that the strings are interns, using the &lt;code&gt;equals()&lt;/code&gt; method is still not that overhead that one might think, definitely the recommended way. If you want efficient reference check, then use enums where it is guaranteed by the language specification and implementation that the same enum value will be the same object (by reference).</source>
          <target state="translated">总而言之，即使我们保证字符串是实习生，使用 &lt;code&gt;equals()&lt;/code&gt; 方法仍然不是人们可能会想到的开销，绝对是推荐的方法。 如果要进行有效的引用检查，请在语言规范和实现保证相同的枚举值是相同对象（通过引用）的情况下使用枚举。</target>
        </trans-unit>
        <trans-unit id="c6dbba253687916f57aa803f9e2177e9867ca001" translate="yes" xml:space="preserve">
          <source>When using == operator for string comparison you are not comparing the contents of the string, but are actually comparing the memory address. If they are both equal it will return true and false otherwise. Whereas equals in string compares the string contents.</source>
          <target state="translated">当使用==操作符进行字符串比较时,你不是在比较字符串的内容,而是在比较内存地址。如果它们都相等,则返回true,否则返回false。而字符串中的equals则是比较字符串的内容。</target>
        </trans-unit>
        <trans-unit id="8d70775b46e120808e9850984c65117158958e7d" translate="yes" xml:space="preserve">
          <source>When you call new for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, each one gets a new reference that points to the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; in the string table.  The references are different, but the content is the same.</source>
          <target state="translated">当您为 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 调用new时，每个引用都会获得一个新引用，该引用指向字符串表中的 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 。 引用不同，但是内容相同。</target>
        </trans-unit>
        <trans-unit id="4d0a9e43f42077a13b12f40c79f0b6c8bc2da63a" translate="yes" xml:space="preserve">
          <source>When you check (compare) two objects using the &lt;code&gt;==&lt;/code&gt; operator it compares the address equality into the string-pool. If the two String objects have the same address references then it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. But if you want to compare the contents of two String objects then you must override the &lt;code&gt;equals&lt;/code&gt; method.</source>
          <target state="translated">当您使用 &lt;code&gt;==&lt;/code&gt; 运算符检查（比较）两个对象时，它将地址相等性比较到字符串池中。 如果两个String对象具有相同的地址引用，则它返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。 但是，如果要比较两个String对象的内容，则必须重写 &lt;code&gt;equals&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="586e208e279cd35f608e8fe3160362705865c64d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;.equals()&lt;/code&gt; always compares a value of String so it gives true in both cases:</source>
          <target state="translated">虽然 &lt;code&gt;.equals()&lt;/code&gt; 总是比较String的值，所以在两种情况下它都为true：</target>
        </trans-unit>
        <trans-unit id="41629ab5d619a837a7d228c06888aa2337ba8eac" translate="yes" xml:space="preserve">
          <source>While I'm writing about this concept of equality in Java, it's important to note that the Java language includes an equals method in the base Java Object class. Whenever you're creating your own objects and you want to provide a means to see if two instances of your object are &quot;equal&quot;, you should override (and implement) this equals method in your class (in the same way the Java language provides this equality/comparison behavior in the String equals method).</source>
          <target state="translated">当我在Java中写这个平等的概念时,需要注意的是,Java语言在基础Java对象类中包含了一个equals方法。每当你在创建自己的对象时,如果你想提供一种方法来查看对象的两个实例是否 &quot;相等&quot;,你应该在你的类中覆盖(并实现)这个equals方法(就像Java语言在String equals方法中提供这种平等比较行为一样)。</target>
        </trans-unit>
        <trans-unit id="dce24af4033f2e3a02feb720dd5df0c2bafd0e35" translate="yes" xml:space="preserve">
          <source>Yea, it's bad...</source>
          <target state="translated">是的,这很糟糕.....</target>
        </trans-unit>
        <trans-unit id="d6e11d8f251b17000089bf6e46de65e7004dda75" translate="yes" xml:space="preserve">
          <source>Yes, &lt;code&gt;==&lt;/code&gt; is bad for comparing Strings (any objects really, unless you know they're canonical).  &lt;code&gt;==&lt;/code&gt; just compares object references.  &lt;code&gt;.equals()&lt;/code&gt; tests for equality. For Strings, often they'll be the same but as you've discovered, that's not guaranteed always.</source>
          <target state="translated">是的， &lt;code&gt;==&lt;/code&gt; 对比较字符串（任何对象，除非您知道它们是规范的）都是不利的。 &lt;code&gt;==&lt;/code&gt; 只是比较对象引用。 &lt;code&gt;.equals()&lt;/code&gt; 测试是否相等。 对于字符串，通常它们是相同的，但是正如您所发现的，并不能保证总是如此。</target>
        </trans-unit>
        <trans-unit id="f8e7716ea4c3e20c7bdf723f23756bb919d9eaad" translate="yes" xml:space="preserve">
          <source>You almost &lt;strong&gt;always&lt;/strong&gt; want to use &lt;code&gt;Objects.equals()&lt;/code&gt;. In the &lt;strong&gt;rare&lt;/strong&gt; situation where you &lt;strong&gt;know&lt;/strong&gt; you're dealing with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--&quot;&gt;interned&lt;/a&gt; strings, you &lt;em&gt;can&lt;/em&gt; use &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">您几乎&lt;strong&gt;总是&lt;/strong&gt;想使用 &lt;code&gt;Objects.equals()&lt;/code&gt; 。 在&lt;strong&gt;极少数&lt;/strong&gt;情况下，您&lt;strong&gt;知道&lt;/strong&gt;要处理&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--&quot;&gt;内部&lt;/a&gt;字符串， &lt;em&gt;可以&lt;/em&gt;使用 &lt;code&gt;==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5161c797f0345d83c726119d178d75aa5610fb2c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;compareTo()&lt;/code&gt; method to compare two Strings. If the compareTo result is 0, then the two strings are equal, otherwise the strings being compared are not equal.</source>
          <target state="translated">您也可以使用 &lt;code&gt;compareTo()&lt;/code&gt; 方法比较两个字符串。 如果compareTo结果为0，则两个字符串相等，否则比较的字符串不相等。</target>
        </trans-unit>
        <trans-unit id="0afb8ff09e0f16ede865ab95dfcdc15300c82b5a" translate="yes" xml:space="preserve">
          <source>You may want to have a look at this &lt;a href=&quot;http://www.ensta-paristech.fr/~diam/java/online/notes-java/data/expressions/22compareobjects.html&quot;&gt;==, .equals(), compareTo(), and compare()&lt;/a&gt;</source>
          <target state="translated">您可能需要看一下&lt;a href=&quot;http://www.ensta-paristech.fr/~diam/java/online/notes-java/data/expressions/22compareobjects.html&quot;&gt;== 、. equals（），compareTo（）和compare（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ea16d98d575b2b8348dcba9edc206a8a0907873" translate="yes" xml:space="preserve">
          <source>You will get the output as &lt;code&gt;TRUE&lt;/code&gt; if you use &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;==&lt;/code&gt; ,则输出将为 &lt;code&gt;TRUE&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
