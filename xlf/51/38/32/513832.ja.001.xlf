<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/513832">
    <body>
      <group id="513832">
        <trans-unit id="534e6e35df4d7a293d4fb797e174a5f76b1e1e74" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)&quot;&gt;Objects.equals()&lt;/a&gt; checks for &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;.equals()&lt;/code&gt; so you don't have to (available as of JDK7, also available in &lt;a href=&quot;https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#equals&quot;&gt;Guava&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)&quot;&gt;Objects.equals（）&lt;/a&gt;は、 &lt;code&gt;.equals()&lt;/code&gt; を呼び出す前に &lt;code&gt;null&lt;/code&gt; をチェックするので、その必要はありません（JDK7以降で利用可能、 &lt;a href=&quot;https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#equals&quot;&gt;Guava&lt;/a&gt;でも利用可能）。</target>
        </trans-unit>
        <trans-unit id="50d43f0916ad54e9845c2ad2b4e494d7973e3311" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contentEquals-java.lang.CharSequence-&quot;&gt;String.contentEquals()&lt;/a&gt; compares the content of the &lt;code&gt;String&lt;/code&gt; with the content of any &lt;code&gt;CharSequence&lt;/code&gt; (available since Java 1.5).</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contentEquals-java.lang.CharSequence-&quot;&gt;String.contentEquals（）&lt;/a&gt;は、 &lt;code&gt;String&lt;/code&gt; のコンテンツを任意の &lt;code&gt;CharSequence&lt;/code&gt; （Java 1.5以降で使用可能）のコンテンツと比較します。</target>
        </trans-unit>
        <trans-unit id="e192e0e817715cc164367bdc6257808206f7aef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; compares String values.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; は文字列値を比較します。</target>
        </trans-unit>
        <trans-unit id="88f052486d7c3398f63c986b644896db673de477" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; compares the data in a class (assuming the function is implemented).
&lt;code&gt;==&lt;/code&gt; compares pointer locations (location of the object in memory).</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; は、クラス内のデータを比較します（関数が実装されている場合）。 &lt;code&gt;==&lt;/code&gt; ポインタの場所（メモリ内のオブジェクトの場所）を比較します。</target>
        </trans-unit>
        <trans-unit id="97f06596c10185b66f044c98db5fa447f42cbbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.equals()&lt;/code&gt; tests for value equality (whether they are logically &quot;equal&quot;).</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; は 、値が等しいかどうかをテストします（論理的に「等しい」かどうか）。</target>
        </trans-unit>
        <trans-unit id="2d0683433eb16443cb6ac4e5d95688372936574c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; compares Object references.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; オブジェクト参照を比較します。</target>
        </trans-unit>
        <trans-unit id="d99d8255c217ecd40d6e336608014d1c046139ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; compares the reference value of objects whereas the &lt;code&gt;equals()&lt;/code&gt; method present in the &lt;code&gt;java.lang.String&lt;/code&gt; class compares the contents of the &lt;code&gt;String&lt;/code&gt; object (to another object).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; はオブジェクトの参照値を比較しますが、 &lt;code&gt;java.lang.String&lt;/code&gt; クラスにある &lt;code&gt;equals()&lt;/code&gt; メソッドは、 &lt;code&gt;String&lt;/code&gt; オブジェクトの内容を（別のオブジェクトと）比較します。</target>
        </trans-unit>
        <trans-unit id="a7845d5fc79d961485ccf489239e9b8562c7adcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; handles &lt;code&gt;null&lt;/code&gt; strings fine, but calling &lt;code&gt;.equals()&lt;/code&gt; from a null string will cause an exception:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 文字列を &lt;code&gt;.equals()&lt;/code&gt; 処理しますが、null文字列から.equals（）を呼び出すと例外が発生します。</target>
        </trans-unit>
        <trans-unit id="127a53ded3ac4bf04076d5f594c50d3375520fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means that your two string references are exactly the same object. You may have heard that this is the case because Java keeps sort of a literal table (which it does), but that is not always the case. Some strings are loaded in different ways, constructed from other strings, etc., so you must never assume that two identical strings are stored in the same location.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; は、2つの文字列参照がまったく同じオブジェクトであることを意味します。 これは、Javaがリテラルテーブル（そうする）を保持しているためだと聞いたことがあるかもしれませんが、常にそうであるとは限りません。 一部の文字列は異なる方法でロードされ、他の文字列などから構築されるため、2つの同一の文字列が同じ場所に格納されていると決して想定してはなりません。</target>
        </trans-unit>
        <trans-unit id="972cd1c4c26a9b3d5a65d2854333166a32a64472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; performs a &lt;strong&gt;reference&lt;/strong&gt; equality check, whether the 2 objects (strings in this case) refer to the same object in the memory.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; は、2つのオブジェクト（この場合は文字列）がメモリ内の同じオブジェクトを参照しているかどうかの&lt;strong&gt;参照&lt;/strong&gt;等価チェックを実行します。</target>
        </trans-unit>
        <trans-unit id="3e8ab4bbb062dbd444c07ca3191ce5b49b24c15e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; returns true if both objects (NOT TALKING ABOUT PRIMITIVES) point to the SAME object instance.
&lt;code&gt;.equals()&lt;/code&gt; returns true if the two objects contain the same data &lt;a href=&quot;http://www.java-samples.com/showtutorial.php?tutorialid=221&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; Versus &lt;code&gt;==&lt;/code&gt; in Java&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 両方のオブジェクト（PRIMITIVEについて話さない）が同じオブジェクトインスタンスを指している場合、trueを返します。 &lt;code&gt;.equals()&lt;/code&gt; は、2つのオブジェクトに同じデータ&lt;a href=&quot;http://www.java-samples.com/showtutorial.php?tutorialid=221&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; &lt;/a&gt;含まれる場合にtrueを返します。equals（） とJavaでは &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65bb9efb919c1b1b9f8f00a8ab69486e0c1f6fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; tests for reference equality (whether they are the same object).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 参照が等しいかどうかをテストします（同じオブジェクトかどうか）。</target>
        </trans-unit>
        <trans-unit id="a40f8dacba2a1950f6ea624f0d2317bcc2a772dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; tests object references, &lt;code&gt;.equals()&lt;/code&gt; tests the string values.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; オブジェクト参照をテストし、 &lt;code&gt;.equals()&lt;/code&gt; は文字列値をテストします。</target>
        </trans-unit>
        <trans-unit id="a6e3babe176e5f525115bc259e2f5e512d8d9667" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals&lt;/code&gt; is actually the method of the Object class, but it is Overridden into the String class and a new definition is given which compares the contents of object.</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; は実際にはObjectクラスのメソッドですが、Stringクラスにオーバーライドされ、オブジェクトの内容を比較する新しい定義が与えられます。</target>
        </trans-unit>
        <trans-unit id="ce16c9cf4f660e1842cc8af2704dd6ef8946c75c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Example&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8218a9a9840123be7b37c5258175c475d6d3d5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(a==b) ===&amp;gt; true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;（a == b）===&amp;gt; true&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de97c48c26c2975344975ab7fd565ec5f47f43e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;==&lt;/code&gt; compares object references in Java&lt;/strong&gt;, and that is no exception for &lt;code&gt;String&lt;/code&gt; objects.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;==&lt;/code&gt; Javaのオブジェクト参照を比較します&lt;/strong&gt; 。これは、 &lt;code&gt;String&lt;/code&gt; オブジェクトの場合も例外ではありません。</target>
        </trans-unit>
        <trans-unit id="4f9b336e70ecf3d8434ca63a79793c6e9a5a5306" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But beware of nulls!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ただし、ヌルには注意してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83aa0f60e0ba5d1766913ffd675fc9f79c342e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;事例1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf6e653fe9d46dc5857806ccff042fa746c23fc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;事例2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c83e5f944d3f32a33f78893b1ae58827ce8aa54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For comparing the actual contents of objects (including &lt;code&gt;String&lt;/code&gt;), one must use the &lt;code&gt;equals&lt;/code&gt; method&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;オブジェクト（ &lt;code&gt;String&lt;/code&gt; を含む）の実際の内容を比較するには、 &lt;code&gt;equals&lt;/code&gt; メソッドを使用する必要があります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="380badf346b49077ad347f903d9e64bdfc6c0961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 1: Java String comparison with the equals method&lt;/strong&gt;
Most of the time (maybe 95% of the time) I compare strings with the equals method of the Java String class, like this:</source>
          <target state="translated">&lt;strong&gt;オプション1：equalsメソッドを使用したJava文字列の比較&lt;/strong&gt;ほとんどの&lt;strong&gt;場合&lt;/strong&gt; （おそらく95％の場合）、次のように文字列をJava Stringクラスのequalsメソッドと比較します。</target>
        </trans-unit>
        <trans-unit id="eb85d4a727a36caf962b7bac941d7c46f894a6a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 2: String comparison with the equalsIgnoreCase method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オプション2：equalsIgnoreCaseメソッドを使用した文字列比較&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d42bd1a8a45eb4097779363d21181e70e60ef953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 3: Java String comparison with the compareTo method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オプション3：compareToメソッドを使用したJava文字列の比較&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae8b1214c75a26ad44633cb7ce38b5eea68d2fd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;if(a==b) ===&amp;gt; false.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;if（a == b）===&amp;gt; false。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ebc8538d9ce17c45cfa160ccf33b7ac0efa63fee" translate="yes" xml:space="preserve">
          <source>A key note is that strings are stored in one lump pool so once a string is created it is forever stored in a program at the same address. Strings do not change, they are immutable. This is why it is a bad idea to use regular string concatenation if you have a serious of amount of string processing to do. Instead you would use the &lt;code&gt;StringBuilder&lt;/code&gt; classes provided. Remember the pointers to this string can change and if you were interested to see if two pointers were the same &lt;code&gt;==&lt;/code&gt; would be a fine way to go. Strings themselves do not.</source>
          <target state="translated">重要な点は、文字列は1つの一括プールに格納されるため、文字列が作成されると、プログラム内の同じアドレスに永久に格納されるということです。 文字列は変更されず、不変です。 これが、深刻な文字列処理を行う必要がある場合に、通常の文字列連結を使用することが悪い考えである理由です。 代わりに、提供されている &lt;code&gt;StringBuilder&lt;/code&gt; クラスを使用します。 この文字列へのポインタは変更される可能性があり、2つのポインタが同じであるかどうかを確認したい場合は、 &lt;code&gt;==&lt;/code&gt; を使用することをお勧めします。 文字列自体にはありません。</target>
        </trans-unit>
        <trans-unit id="2e32a37850b13cf98c87aa3bc11f6bbc550512a2" translate="yes" xml:space="preserve">
          <source>All objects are guaranteed to have a &lt;code&gt;.equals()&lt;/code&gt; method since Object contains a method, &lt;code&gt;.equals()&lt;/code&gt;, that returns a boolean. It is the subclass' job to override this method if a further defining definition is required. Without it (i.e. using &lt;code&gt;==&lt;/code&gt;) only memory addresses are checked between two objects for equality. String overrides this &lt;code&gt;.equals()&lt;/code&gt; method and instead of using the memory address it returns the comparison of strings at the character level for equality.</source>
          <target state="translated">Objectにはブール値を返す &lt;code&gt;.equals()&lt;/code&gt; が含まれているため、すべてのオブジェクトは &lt;code&gt;.equals()&lt;/code&gt; メソッドを持つことが保証されています。 さらに定義が必要な場合、このメソッドをオーバーライドするのはサブクラスの仕事です。 それがなければ（ &lt;code&gt;==&lt;/code&gt; を使用して）、2つのオブジェクト間でメモリアドレスのみが等しいかどうかがチェックされます。 文字列はこの &lt;code&gt;.equals()&lt;/code&gt; メソッドをオーバーライドし、メモリアドレスを使用する代わりに、文字レベルで文字列を比較して等しいかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="2e7d953f9e0db5183f7079c0553cc235460d97be" translate="yes" xml:space="preserve">
          <source>But mind it respects the case of String. If you want case insensitive compare then you must go for the equalsIgnoreCase method of the String class.</source>
          <target state="translated">しかし、これは String の大文字と小文字を区別します。大文字小文字を区別せずに比較したい場合は、String クラスの equalsIgnoreCase メソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="08393c6c77f96e040c5d84e5121ed2a44b0608d1" translate="yes" xml:space="preserve">
          <source>But what you can do is to call &lt;code&gt;intern()&lt;/code&gt; on your non-literal strings.</source>
          <target state="translated">しかし、あなたができることは、非リテラル文字列で &lt;code&gt;intern()&lt;/code&gt; を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="15a3cf51d08c5a4791935fe82b44b7c4f15102fb" translate="yes" xml:space="preserve">
          <source>But, when the two strings contain the exact same string of characters, the equals method will return true, as in this example:</source>
          <target state="translated">しかし、2つの文字列に全く同じ文字列が含まれている場合は、この例のようにequalsメソッドはtrueを返します。</target>
        </trans-unit>
        <trans-unit id="af38a399948a04b463b546d4f948912c00118098" translate="yes" xml:space="preserve">
          <source>Consequently, if you want to test whether two strings have the same value you will probably want to use &lt;code&gt;Objects.equals()&lt;/code&gt;.</source>
          <target state="translated">したがって、2つの文字列が同じ値であるかどうかをテストする場合は、おそらく &lt;code&gt;Objects.equals()&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6aafac2f992d36c8bca828739a7404532d20a8a6" translate="yes" xml:space="preserve">
          <source>Consider two different reference variables, &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt;:</source>
          <target state="translated">2つの異なる参照変数 &lt;code&gt;str1&lt;/code&gt; と &lt;code&gt;str2&lt;/code&gt; を考えます。</target>
        </trans-unit>
        <trans-unit id="9847ecced7aa002791c61138db5356d024636623" translate="yes" xml:space="preserve">
          <source>Definitely the use of &lt;code&gt;equals()&lt;/code&gt; method is recommended.</source>
          <target state="translated">間違いなく、 &lt;code&gt;equals()&lt;/code&gt; メソッドの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="bf3bcba66a1552787dd686311371f4c3aa8ed466" translate="yes" xml:space="preserve">
          <source>Don't worry about the performance. Some things to encourage using &lt;code&gt;String.equals()&lt;/code&gt;:</source>
          <target state="translated">パフォーマンスについて心配する必要はありません。 &lt;code&gt;String.equals()&lt;/code&gt; の使用を奨励するいくつかのこと：</target>
        </trans-unit>
        <trans-unit id="b06f25fbeed92476c87e1968ec046f4936266cc1" translate="yes" xml:space="preserve">
          <source>Equals does the real comparison for you.</source>
          <target state="translated">イコールはあなたのために本当の比較をしてくれます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="f4fca6333e5c683fdaa7713181bcfbd25b1d2643" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot;&gt;JLS 3.10.5. &lt;em&gt;String Literals&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot;&gt;JLS 3.10.5以降。&lt;/a&gt; &lt;em&gt;文字列リテラル&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="003e5d38b8c1eac244f02ac363a47c0bbaf9273c" translate="yes" xml:space="preserve">
          <source>From zacherates example:</source>
          <target state="translated">ザハーテスの例から。</target>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="14fb73b968e1433308008402842a19df1bd245b3" translate="yes" xml:space="preserve">
          <source>How do I compare strings in Java</source>
          <target state="translated">Javaで文字列を比較するには</target>
        </trans-unit>
        <trans-unit id="e90775e8efad74a01524c188edc8b6dc2072c2b5" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;==&lt;/code&gt; fails in the following case:</source>
          <target state="translated">ただし、 &lt;code&gt;==&lt;/code&gt; は次の場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="ad8fc1b7115a0a617bf3361c92f8d88d012c6205" translate="yes" xml:space="preserve">
          <source>I agree with the answer from zacherates.</source>
          <target state="translated">zacheratesさんの回答に同意します。</target>
        </trans-unit>
        <trans-unit id="209b45599a8f24c29dacb03bdf122cc9869d6a84" translate="yes" xml:space="preserve">
          <source>I think that when you define a &lt;code&gt;String&lt;/code&gt; you define an object. So you need to use &lt;code&gt;.equals()&lt;/code&gt;. When you use primitive data types you use &lt;code&gt;==&lt;/code&gt; but with &lt;code&gt;String&lt;/code&gt; (and any object) you must use &lt;code&gt;.equals()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; を定義するとき、オブジェクトを定義すると思います。 したがって、 &lt;code&gt;.equals()&lt;/code&gt; を使用する必要があります。 プリミティブデータ型を使用する場合は &lt;code&gt;==&lt;/code&gt; を使用しますが、 &lt;code&gt;String&lt;/code&gt; （および任意のオブジェクト）では &lt;code&gt;.equals()&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c6deec886dc61621c93ed9d7b5c29032c707f83c" translate="yes" xml:space="preserve">
          <source>I've been using the &lt;code&gt;==&lt;/code&gt; operator in my program to compare all my strings so far.
However, I ran into a bug, changed one of them into &lt;code&gt;.equals()&lt;/code&gt; instead, and it fixed the bug.</source>
          <target state="translated">これまで、プログラムで &lt;code&gt;==&lt;/code&gt; 演算子を使用してすべての文字列を比較してきました。 しかし、私はバグに遭遇し、そのうちの1つを代わりに &lt;code&gt;.equals()&lt;/code&gt; に変更し、それによってバグが修正されました。</target>
        </trans-unit>
        <trans-unit id="ee1db44f97923a97f6aa14945a8e524aef45e729" translate="yes" xml:space="preserve">
          <source>If a comparison of two &lt;code&gt;String&lt;/code&gt; objects using &lt;code&gt;==&lt;/code&gt; turns out to be &lt;code&gt;true&lt;/code&gt;, that is because the &lt;code&gt;String&lt;/code&gt; objects were interned, and the Java Virtual Machine is having multiple references point to the same instance of &lt;code&gt;String&lt;/code&gt;. One should not expect that comparing one &lt;code&gt;String&lt;/code&gt; object containing the same contents as another &lt;code&gt;String&lt;/code&gt; object using &lt;code&gt;==&lt;/code&gt; to evaluate as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; を使用した2つの &lt;code&gt;String&lt;/code&gt; オブジェクトの比較が &lt;code&gt;true&lt;/code&gt; であることが判明した場合 、それは &lt;code&gt;String&lt;/code&gt; オブジェクトがインターンされ、Java仮想マシンが &lt;code&gt;String&lt;/code&gt; の同じインスタンスを指す複数の参照を持っているためです。 &lt;code&gt;==&lt;/code&gt; を使用して同じ内容を含む1つの &lt;code&gt;String&lt;/code&gt; オブジェクトを別の &lt;code&gt;String&lt;/code&gt; オブジェクトと比較して &lt;code&gt;true&lt;/code&gt; と評価することを期待するべきではありません。</target>
        </trans-unit>
        <trans-unit id="0975ad48f5593aec2b3883279cad972877d542d2" translate="yes" xml:space="preserve">
          <source>If the 2 string references are not the same, &lt;code&gt;String.equals()&lt;/code&gt; will next check the lengths of the strings. This is also a fast operation because the &lt;code&gt;String&lt;/code&gt; class stores the length of the string, no need to count the characters or code points. If the lengths differ, no further check is performed, we know they cannot be equal.</source>
          <target state="translated">2つの文字列参照が同じでない場合、 &lt;code&gt;String.equals()&lt;/code&gt; は次に文字列の長さをチェックします。 &lt;code&gt;String&lt;/code&gt; クラスは文字列の長さを格納するため、これも高速な操作です。文字やコードポイントを数える必要はありません。 長さが異なる場合、それ以上のチェックは行われません。これらを等しくすることはできません。</target>
        </trans-unit>
        <trans-unit id="622b2c72cef877135d3204c3e9e609ea0df5f20c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;equals()&lt;/code&gt; method is present in the &lt;code&gt;java.lang.Object&lt;/code&gt; class, and it is expected to check for the equivalence of the state of objects! That means, the contents of the objects. Whereas the &lt;code&gt;==&lt;/code&gt; operator is expected to check the actual object instances are same or not.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; メソッドが &lt;code&gt;java.lang.Object&lt;/code&gt; クラスに存在し、オブジェクトの状態の等価性をチェックすることが期待されている場合！ つまり、オブジェクトの内容です。 一方、 &lt;code&gt;==&lt;/code&gt; 演算子は、実際のオブジェクトインスタンスが同じかどうかをチェックすることが期待されています。</target>
        </trans-unit>
        <trans-unit id="d701e5196e6f58abe2f4c8d3e765a337b6d5958c" translate="yes" xml:space="preserve">
          <source>If you intern the non-literal String equality is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">あなたがインターンする場合、非リテラル文字列の等価性は &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a18409dd8aad86765bdf0eb5ade6c3e9c27a06b1" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;equals()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; を使用する場合</target>
        </trans-unit>
        <trans-unit id="a606952753cf3dc70cfcd11f34796ac37f150100" translate="yes" xml:space="preserve">
          <source>If you're like me, when I first started using Java, I wanted to use the &quot;==&quot; operator to test whether two String instances were equal, but for better or worse, that's not the correct way to do it in Java.</source>
          <target state="translated">もしあなたが私のように、Javaを使い始めた頃は、2つのStringインスタンスが等しいかどうかをテストするために&quot;==&quot;演算子を使いたかったのですが、良くも悪くも、それはJavaでは正しい方法ではありません。</target>
        </trans-unit>
        <trans-unit id="19563d43dbd1fb12946c8b55472adc3ce8a4a839" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;String.equals()&lt;/code&gt; first checks for reference equality (using &lt;code&gt;==&lt;/code&gt;), and if the 2 strings are the same by reference, no further calculation is performed!</source>
          <target state="translated">&lt;code&gt;String.equals()&lt;/code&gt; の実装は、最初に参照の等価性をチェックし（ &lt;code&gt;==&lt;/code&gt; を使用）、2つの文字列が参照によって同じである場合、それ以上の計算は実行されません。</target>
        </trans-unit>
        <trans-unit id="df7f3b75bfe7cc351d7943de807b0754f7e73609" translate="yes" xml:space="preserve">
          <source>In Java, when the &lt;strong&gt;&amp;ldquo;==&amp;rdquo;&lt;/strong&gt; operator is used to compare 2 objects, it checks to see if the objects refer to the same place in memory. In other words, it checks to see if the 2 object names are basically references to the same memory location.</source>
          <target state="translated">Javaでは、 &lt;strong&gt;「==」&lt;/strong&gt;演算子を使用して2つのオブジェクトを比較すると、オブジェクトがメモリ内の同じ場所を参照しているかどうかが確認されます。 つまり、2つのオブジェクト名が基本的に同じメモリロケーションへの参照であるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="f9de1f4d7b9c7548a170b2aee63ef265f6232437" translate="yes" xml:space="preserve">
          <source>In some string comparison tests you'll want to ignore whether the strings are uppercase or lowercase. When you want to test your strings for equality in this case-insensitive manner, use the equalsIgnoreCase method of the String class, like this:</source>
          <target state="translated">いくつかの文字列比較テストでは、文字列が大文字か小文字かを無視したい場合があるでしょう。このように大文字小文字を区別しない方法で文字列をテストしたい場合は、String クラスの equalsIgnoreCase メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="5096e9095a26aead7dd77a00dd73649fb297b01c" translate="yes" xml:space="preserve">
          <source>In this case for &lt;code&gt;new String(&quot;test&quot;)&lt;/code&gt; the statement new String will be created on the heap, and that reference will be given to &lt;code&gt;b&lt;/code&gt;, so &lt;code&gt;b&lt;/code&gt; will be given a reference on the heap, not in String pool.</source>
          <target state="translated">この場合、 &lt;code&gt;new String(&quot;test&quot;)&lt;/code&gt; の場合 、ステートメントnew Stringがヒープ上に作成され、その参照が &lt;code&gt;b&lt;/code&gt; に渡されるため、 &lt;code&gt;b&lt;/code&gt; には文字列プールではなく、ヒープ上の参照が付与されます。</target>
        </trans-unit>
        <trans-unit id="ca3a426a66508840a27f96c237b38e05c70f30b4" translate="yes" xml:space="preserve">
          <source>In this tutorial I'll demonstrate several different ways to correctly compare Java strings, starting with the approach I use most of the time. At the end of this Java String comparison tutorial I'll also discuss why the &quot;==&quot; operator doesn't work when comparing Java strings.</source>
          <target state="translated">このチュートリアルでは、私がよく使うアプローチから始めて、Java文字列を正しく比較するためのいくつかの異なる方法を実演します。このJava文字列比較チュートリアルの最後には、Java文字列を比較するときに&quot;==&quot;演算子が機能しない理由についても説明します。</target>
        </trans-unit>
        <trans-unit id="66c5627d8cfe42bc4a6e93001ed6714eba02b7c5" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;==&lt;/code&gt; bad? When should it and should it not be used? What's the difference?</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 悪いですか？ いつ使用すべきか、使用すべきでないか？ 違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="44ed4293c7fc2288444421274472d44a6e861151" translate="yes" xml:space="preserve">
          <source>Java also talks about the function intern() that can be used on a string to make it part of the cache so &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;).intern()&lt;/code&gt; will return true.</source>
          <target state="translated">Javaはまた、 &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;).intern()&lt;/code&gt; がtrueを返すように、文字列をキャッシュの一部にするために使用できる関数intern（）についても話します。</target>
        </trans-unit>
        <trans-unit id="bbcdbf601957f23cebef96d44f7ff1ddf50b5aff" translate="yes" xml:space="preserve">
          <source>Java have a String pool under which Java manages the memory allocation for the String objects. See &lt;a href=&quot;https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java&quot;&gt;&lt;strong&gt;String Pools in Java&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">JavaにはStringプールがあり、その下でJavaがStringオブジェクトのメモリ割り当てを管理します。 &lt;a href=&quot;https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java&quot;&gt;&lt;strong&gt;Javaの文字列プールを&lt;/strong&gt;&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="ed8dd2b96dbe38262e709c95739664151e953eb1" translate="yes" xml:space="preserve">
          <source>Let's See:</source>
          <target state="translated">見てみよう</target>
        </trans-unit>
        <trans-unit id="a73fa850bcd40c5192a74b3a633598a1eeddab8d" translate="yes" xml:space="preserve">
          <source>Make sure you understand why.  It's because the &lt;code&gt;==&lt;/code&gt; comparison only compares references; the &lt;code&gt;equals()&lt;/code&gt; method does a character-by-character comparison of the contents.</source>
          <target state="translated">理由を理解してください。 &lt;code&gt;==&lt;/code&gt; 比較は参照のみを比較するためです。 &lt;code&gt;equals()&lt;/code&gt; メソッドは、内容を文字ごとに比較します。</target>
        </trans-unit>
        <trans-unit id="91794435135957626e3496e47088bf3118716d4a" translate="yes" xml:space="preserve">
          <source>Moreover, a string literal always refers to the &lt;em&gt;same&lt;/em&gt; instance of class &lt;code&gt;String&lt;/code&gt;. This is because string literals - or, more generally, strings that are the values of constant expressions (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28&quot;&gt;&amp;sect;15.28&lt;/a&gt;) - are &quot;interned&quot; so as to share unique instances, using the method &lt;code&gt;String.intern&lt;/code&gt;.</source>
          <target state="translated">さらに、文字列リテラルは常に &lt;code&gt;String&lt;/code&gt; クラスの&lt;em&gt;同じ&lt;/em&gt;インスタンスを参照します。 これは、文字列リテラル、またはより一般的には定数式の値である文字列（ &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28&quot;&gt;&amp;sect;15.28&lt;/a&gt; ）が、メソッド &lt;code&gt;String.intern&lt;/code&gt; を使用して一意のインスタンスを共有するように「インターン」されるためです 。</target>
        </trans-unit>
        <trans-unit id="c374a8d811dc06c407f72b0c1bd01c73410b563a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;.equals()&lt;/code&gt; method belongs to class &lt;code&gt;Object&lt;/code&gt; (super class of all classes). You need to override it as per you class requirement, but for String it is already implemented, and it checks whether two strings have the same value or not.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; メソッドは &lt;code&gt;Object&lt;/code&gt; クラス（すべてのクラスのスーパークラス）に属していることに注意してください。 クラスの要件に従ってオーバーライドする必要がありますが、Stringの場合はすでに実装されており、2つのストリングの値が同じかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="ef7869c142e8b9c650d51fd7d526dffaf522ae76" translate="yes" xml:space="preserve">
          <source>Note: == operator is much faster than equals just because you are comparing two memory addresses, but you need to be sure that the code isn't creating new String instances in the code. Otherwise you will encounter bugs.</source>
          <target state="translated">注意:==演算子は、2つのメモリアドレスを比較しているという理由だけで、イコールよりもはるかに高速ですが、コード中に新しいStringインスタンスが生成されていないことを確認する必要があります。そうしないとバグが発生します。</target>
        </trans-unit>
        <trans-unit id="05f4a05acd2ff60019ca1cc57a02118ad5e2b4c8" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;a&lt;/code&gt; is pointing to a String in the String pool while &lt;code&gt;b&lt;/code&gt; is pointing to a String on the heap. Because of that we get:</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; は文字列プール内の文字列を指し、 bはヒープ上の文字列を指します。 そのため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3ae4c4c99288daf3be8f6b076a1e030bc8f2a226" translate="yes" xml:space="preserve">
          <source>Now you will get the &lt;code&gt;FALSE&lt;/code&gt; as output, because both &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt; are pointing to two different objects even though both of them share the same string content. It is because of &lt;code&gt;new String()&lt;/code&gt; a new object is created every time.</source>
          <target state="translated">&lt;code&gt;str1&lt;/code&gt; と &lt;code&gt;str2&lt;/code&gt; の両方が同じ文字列コンテンツを共有していても、 str1とstr2の両方が2つの異なるオブジェクトを指しているため、出力として &lt;code&gt;FALSE&lt;/code&gt; が返されます。 これは &lt;code&gt;new String()&lt;/code&gt; が原因で、毎回新しいオブジェクトが作成されます。</target>
        </trans-unit>
        <trans-unit id="77c5595bc439eb350a3083fde96d4b94b19d4d24" translate="yes" xml:space="preserve">
          <source>Obviously &lt;code&gt;==&lt;/code&gt; is faster, but will (might) give false results in many cases if you just want to tell if 2 &lt;code&gt;String&lt;/code&gt;s hold the same text.</source>
          <target state="translated">明らかに &lt;code&gt;==&lt;/code&gt; の方が高速ですが、2つの &lt;code&gt;String&lt;/code&gt; が同じテキストを保持しているかどうかを確認したいだけの場合、多くの場合、誤った結果をもたらす可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f5984755ab3c60967abd3d47569bff195c24d31" translate="yes" xml:space="preserve">
          <source>Only if we got this far will the contents of the 2 strings be actually compared, and this will be a short-hand comparison: not all the characters will be compared, if we find a mismatching character (at the same position in the 2 strings), no further characters will be checked.</source>
          <target state="translated">ここまで来た場合のみ、2つの文字列の内容が実際に比較され、これは短手比較となります。</target>
        </trans-unit>
        <trans-unit id="4931a37091118ff489ec2354e6f1916dc8e35e55" translate="yes" xml:space="preserve">
          <source>Operator &lt;em&gt;==&lt;/em&gt; is always meant for &lt;strong&gt;object reference comparison&lt;/strong&gt;, whereas the String class &lt;em&gt;.equals()&lt;/em&gt; method is overridden for &lt;strong&gt;content comparison&lt;/strong&gt;:</source>
          <target state="translated">演算子&lt;em&gt;==&lt;/em&gt;は常に&lt;strong&gt;オブジェクト参照の比較を&lt;/strong&gt;意味し&lt;strong&gt;ます&lt;/strong&gt;が、 &lt;strong&gt;コンテンツ比較で&lt;/strong&gt;はStringクラスの&lt;em&gt;.equals（）&lt;/em&gt;メソッドがオーバーライドされ&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="62d3323f1a4b43a5308396720b3529bdc784b601" translate="yes" xml:space="preserve">
          <source>Reason: If you create a String object using the &lt;code&gt;new&lt;/code&gt; keyword a separate space is allocated to it on the heap.</source>
          <target state="translated">理由： &lt;code&gt;new&lt;/code&gt; キーワードを使用してStringオブジェクトを作成すると、ヒープ上に個別のスペースが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="e004e448e24213231c66b0837a3d3ab87e6c6817" translate="yes" xml:space="preserve">
          <source>Reason: String literals created without null are stored in the String pool in the permgen area of heap. So both s1 and s2 point to same object in the pool.</source>
          <target state="translated">理由。nullを含まずに作成された文字列リテラルは、ヒープのpermgen領域の文字列プールに格納されているため、s1もs2もプール内の同じオブジェクトを指している。つまり、s1もs2もプール内の同じオブジェクトを指していることになります。</target>
        </trans-unit>
        <trans-unit id="e9694929438ff9ef921133d3e537bf55f70f6175" translate="yes" xml:space="preserve">
          <source>Similar examples can also be found in &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#d5e1634&quot;&gt;JLS 3.10.5-1&lt;/a&gt;.</source>
          <target state="translated">同様の例は、 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#d5e1634&quot;&gt;JLS 3.10.5-1に&lt;/a&gt;もあります。</target>
        </trans-unit>
        <trans-unit id="7678ffc7a34ab9b5bce1ba690a307007c3bc4cb7" translate="yes" xml:space="preserve">
          <source>So if you know that &lt;code&gt;fooString1&lt;/code&gt; may be null, tell the reader that by writing</source>
          <target state="translated">したがって、 &lt;code&gt;fooString1&lt;/code&gt; がnullである可能性があることがわかっている場合は、次のように記述して、</target>
        </trans-unit>
        <trans-unit id="6364ba01158454f664dad6de332f337ba05f8043" translate="yes" xml:space="preserve">
          <source>So the question is if all the strings are cached in the system, how come &lt;code&gt;==&lt;/code&gt; returns false whereas equals return true? Well, this is possible. If you make a new string like &lt;code&gt;String str = new String(&quot;Testing&quot;)&lt;/code&gt; you end up creating a new string in the cache even if the cache already contains a string having the same content. In short &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;)&lt;/code&gt; will always return false.</source>
          <target state="translated">したがって、問題は、すべての文字列がシステムにキャッシュされる場合、 &lt;code&gt;==&lt;/code&gt; はfalseを返し、equalsはtrueを返すのはなぜですか？ まあ、これは可能です。 &lt;code&gt;String str = new String(&quot;Testing&quot;)&lt;/code&gt; ような新しい文字列を作成すると、キャッシュに同じ内容の文字列がすでに含まれている場合でも、キャッシュに新しい文字列が作成されます。 つまり、 &lt;code&gt;&quot;MyString&quot; == new String(&quot;MyString&quot;)&lt;/code&gt; は常にfalseを返します。</target>
        </trans-unit>
        <trans-unit id="925bf81cb272f91e408e2585dfe66406073ec384" translate="yes" xml:space="preserve">
          <source>So using &lt;code&gt;.equals()&lt;/code&gt; is always better.</source>
          <target state="translated">したがって、 &lt;code&gt;.equals()&lt;/code&gt; を使用する方が常に優れています。</target>
        </trans-unit>
        <trans-unit id="64e94d29a587c1b43ed1ff2b1f5eea22f76e7e69" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;==&lt;/code&gt; gives illusions of comparing String values, as in following cases:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; は、以下の場合のように、文字列値を比較する錯覚を与えることがあります。</target>
        </trans-unit>
        <trans-unit id="ef7777dabf10c38fea3b84a7896afa72857e8048" translate="yes" xml:space="preserve">
          <source>Sometimes it looks as if &lt;code&gt;==&lt;/code&gt; compares values, because Java does some behind-the-scenes stuff to make sure identical in-line strings are actually the same object.</source>
          <target state="translated">場合によっては、 &lt;code&gt;==&lt;/code&gt; が値を比較するように見えることがあります。これは、Javaが舞台裏で何かを行い、同一のインライン文字列が実際に同じオブジェクトであることを確認するためです。</target>
        </trans-unit>
        <trans-unit id="dc72f9ad1e0fe392b547dcb502b649489b4e684e" translate="yes" xml:space="preserve">
          <source>Strings in Java are immutable. That means whenever you try to change/modify the string you get a new instance. You cannot change the original string. This has been done so that these string instances can be cached. A typical program contains a lot of string references and caching these instances can decrease the memory footprint and increase the performance of the program.</source>
          <target state="translated">Javaの文字列は不変です。つまり、文字列を変更しようとすると、いつでも新しいインスタンスが得られます。元の文字列を変更することはできません。これは、これらの文字列インスタンスをキャッシュするために行われています。典型的なプログラムには多くの文字列参照が含まれており、これらのインスタンスをキャッシュすることでメモリフットプリントを減らし、プログラムのパフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="1a5b82a90623ced9b5ebfc731549926d882846eb" translate="yes" xml:space="preserve">
          <source>Taking a look at a quick String comparison example with the equals method, if the following test were run, the two strings would not be considered equal because the characters are not the exactly the same (the case of the characters is different):</source>
          <target state="translated">equalsメソッドを使った簡単な文字列比較の例を見てみると、以下のテストを実行した場合、2つの文字列は、文字が全く同じではない(文字のケースが異なる)ため、等しいとはみなされません。</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="b0163278938a7a8c6bd706310467bbb52b4e5811" translate="yes" xml:space="preserve">
          <source>That may help you.</source>
          <target state="translated">それはあなたの助けになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="956e0cfc5f2a662f8be4c8e1953a725f10223a4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.equals()&lt;/code&gt; method  check if the two strings have the same value.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; メソッドは、2つの文字列が同じ値であるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="3e72766ae6883a1ca99b3e34b1d125ce6dbd4582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.equals()&lt;/code&gt; method will check if the two strings have the same value.</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; メソッドは、2つの文字列が同じ値であるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="3978d062c149bf7accbca4cf5ab4522220f8fe12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; compares the references and does not compare the actual strings. If you did create every string using &lt;code&gt;new String(somestring).intern()&lt;/code&gt; then you can use the &lt;code&gt;==&lt;/code&gt; operator to compare two strings, otherwise equals() or compareTo methods can only be used.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; は参照を比較し、実際の文字列は比較しません。 &lt;code&gt;new String(somestring).intern()&lt;/code&gt; を使用してすべての文字列を作成した場合、 &lt;code&gt;==&lt;/code&gt; 演算子を使用して2つの文字列を比較できます。それ以外の場合は、equals（）またはcompareToメソッドのみを使用できます。</target>
        </trans-unit>
        <trans-unit id="5512073b994a06023b1cc12815e391ae76326db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator check if the two references point to the same object or not. &lt;code&gt;.equals()&lt;/code&gt; check for the actual string content (value).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子は、2つの参照が同じオブジェクトを指しているかどうかを確認します。 &lt;code&gt;.equals()&lt;/code&gt; は、実際の文字列の内容（値）を確認します。</target>
        </trans-unit>
        <trans-unit id="38eb3a4f9caacaa06f820fa599872a9b24a84e2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator checks if the two strings are exactly the same object.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子は、2つの文字列がまったく同じオブジェクトかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="a9a0606a28ccdd73d47713f4b0a9ffe7105e4faa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator checks to see if the two strings are exactly the same object.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子は、2つの文字列がまったく同じオブジェクトかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="d48da5a819a7433506b69dd9c4156df1be51f528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method will check whether the &lt;strong&gt;contents&lt;/strong&gt; or the &lt;strong&gt;states&lt;/strong&gt; of 2 objects are the same.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; メソッドは、2つのオブジェクトの&lt;strong&gt;内容&lt;/strong&gt;または&lt;strong&gt;状態&lt;/strong&gt;が同じかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="4c712b2bf82e618b0042ca50c72334d695ff56a7" translate="yes" xml:space="preserve">
          <source>The Java String class actually overrides the default equals() implementation in the Object class &amp;ndash; and it overrides the method so that it checks only the values of the strings, not their locations in memory.
 This means that if you call the equals() method to compare 2 String objects, then as long as the actual sequence of characters is equal, both objects are considered equal.</source>
          <target state="translated">Java Stringクラスは、実際にはObjectクラスのデフォルトのequals（）実装をオーバーライドします。また、メソッドをオーバーライドして、メモリ内の場所ではなく、文字列の値のみをチェックします。 つまり、equals（）メソッドを呼び出して2つのStringオブジェクトを比較する場合、実際の文字シーケンスが等しい限り、両方のオブジェクトは等しいと見なされます。</target>
        </trans-unit>
        <trans-unit id="b255548604584b6fe35e432b209faddbe10a7980" translate="yes" xml:space="preserve">
          <source>The following is shorter, but it&amp;rsquo;s less obvious that it checks for null (from Java 7):</source>
          <target state="translated">以下は短いですが、（Java 7から）nullをチェックすることはそれほど明白ではありません。</target>
        </trans-unit>
        <trans-unit id="3caa790aba81043457285ebcb715deab21762bd6" translate="yes" xml:space="preserve">
          <source>There is also a third, less common way to compare Java strings, and that's with the String class compareTo method. If the two strings are exactly the same, the compareTo method will return a value of 0 (zero). Here's a quick example of what this String comparison approach looks like:</source>
          <target state="translated">Java の文字列を比較するための 3 番目の、あまり一般的ではない方法もありますが、それは String クラスの compareTo メソッドです。2 つの文字列が全く同じ場合、compareTo メソッドは 0 (ゼロ)の値を返します。この文字列比較アプローチがどのように見えるか、簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="bd99e0fef1de55924764a54805cc9bf8add6c76c" translate="yes" xml:space="preserve">
          <source>This String equals method looks at the two Java strings, and if they contain the exact same string of characters, they are considered equal.</source>
          <target state="translated">このString equalsメソッドは、2つのJava文字列を見て、全く同じ文字列が含まれていれば、それらは等しいとみなされます。</target>
        </trans-unit>
        <trans-unit id="e9a6798a3b8ca94cbcd2c60ca2d18c6ff69b9779" translate="yes" xml:space="preserve">
          <source>This is because when you create any String literal, the JVM first searches for that literal in the String pool, and if it finds a match, that same reference will be given to the new String. Because of this, we get:</source>
          <target state="translated">これは、任意のStringリテラルを作成すると、JVMは最初にStringプール内のそのリテラルを検索し、一致するものが見つかった場合、その同じ参照が新しいStringに与えられるからです。このため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="9123a723dd721a4c3eb2ba822a7a05286c4f3051" translate="yes" xml:space="preserve">
          <source>When all is said and done, even if we have guarantee that the strings are interns, using the &lt;code&gt;equals()&lt;/code&gt; method is still not that overhead that one might think, definitely the recommended way. If you want efficient reference check, then use enums where it is guaranteed by the language specification and implementation that the same enum value will be the same object (by reference).</source>
          <target state="translated">文字列がインターンであることが保証されていても、 &lt;code&gt;equals()&lt;/code&gt; メソッドを使用してもオーバーヘッドとは考えられないため、推奨される方法です。 効率的な参照チェックが必要な場合は、言語仕様と実装によって同じ列挙値が同じオブジェクト（参照）になることが保証されている列挙型を使用してください。</target>
        </trans-unit>
        <trans-unit id="c6dbba253687916f57aa803f9e2177e9867ca001" translate="yes" xml:space="preserve">
          <source>When using == operator for string comparison you are not comparing the contents of the string, but are actually comparing the memory address. If they are both equal it will return true and false otherwise. Whereas equals in string compares the string contents.</source>
          <target state="translated">文字列比較に ==演算子を使用する場合、文字列の内容を比較するのではなく、実際にメモリアドレスを比較します。両方が等しい場合はtrueを返し、そうでない場合はfalseを返します。一方、文字列内の equas は文字列の内容を比較します。</target>
        </trans-unit>
        <trans-unit id="8d70775b46e120808e9850984c65117158958e7d" translate="yes" xml:space="preserve">
          <source>When you call new for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, each one gets a new reference that points to the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; in the string table.  The references are different, but the content is the same.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; に対してnewを呼び出すと、それぞれが文字列テーブルの &lt;code&gt;&quot;foo&quot;&lt;/code&gt; を指す新しい参照を取得します。 参照は異なりますが、内容は同じです。</target>
        </trans-unit>
        <trans-unit id="4d0a9e43f42077a13b12f40c79f0b6c8bc2da63a" translate="yes" xml:space="preserve">
          <source>When you check (compare) two objects using the &lt;code&gt;==&lt;/code&gt; operator it compares the address equality into the string-pool. If the two String objects have the same address references then it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. But if you want to compare the contents of two String objects then you must override the &lt;code&gt;equals&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子を使用して2つのオブジェクトをチェック（比較）すると、アドレスの等価性が文字列プールと比較されます。 2つのStringオブジェクトが同じアドレス参照を持っている場合は &lt;code&gt;true&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;false&lt;/code&gt; を返します 。 ただし、2つのStringオブジェクトの内容を比較する場合は、 &lt;code&gt;equals&lt;/code&gt; メソッドをオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="586e208e279cd35f608e8fe3160362705865c64d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;.equals()&lt;/code&gt; always compares a value of String so it gives true in both cases:</source>
          <target state="translated">&lt;code&gt;.equals()&lt;/code&gt; は常にStringの値を比較するため、どちらの場合もtrueになります。</target>
        </trans-unit>
        <trans-unit id="41629ab5d619a837a7d228c06888aa2337ba8eac" translate="yes" xml:space="preserve">
          <source>While I'm writing about this concept of equality in Java, it's important to note that the Java language includes an equals method in the base Java Object class. Whenever you're creating your own objects and you want to provide a means to see if two instances of your object are &quot;equal&quot;, you should override (and implement) this equals method in your class (in the same way the Java language provides this equality/comparison behavior in the String equals method).</source>
          <target state="translated">Javaにおけるこの平等の概念について書いていますが、Java言語では、ベースとなるJavaオブジェクト・クラスに平等メソッドが含まれていることに注意することが重要です。独自のオブジェクトを作成していて、オブジェクトの2つのインスタンスが「等しい」かどうかを確認する手段を提供したい場合はいつでも、クラス内でこのequalsメソッドをオーバーライド(実装)する必要があります(Java言語がString equalsメソッドでこの等値比較の動作を提供するのと同じ方法で)。</target>
        </trans-unit>
        <trans-unit id="dce24af4033f2e3a02feb720dd5df0c2bafd0e35" translate="yes" xml:space="preserve">
          <source>Yea, it's bad...</source>
          <target state="translated">ああ、それは悪いことだ...</target>
        </trans-unit>
        <trans-unit id="d6e11d8f251b17000089bf6e46de65e7004dda75" translate="yes" xml:space="preserve">
          <source>Yes, &lt;code&gt;==&lt;/code&gt; is bad for comparing Strings (any objects really, unless you know they're canonical).  &lt;code&gt;==&lt;/code&gt; just compares object references.  &lt;code&gt;.equals()&lt;/code&gt; tests for equality. For Strings, often they'll be the same but as you've discovered, that's not guaranteed always.</source>
          <target state="translated">はい、 &lt;code&gt;==&lt;/code&gt; は文字列の比較には適していません（正規のオブジェクトであることがわかっている場合を除いて、実際にはすべてのオブジェクト）。 &lt;code&gt;==&lt;/code&gt; 単にオブジェクト参照を比較します。 &lt;code&gt;.equals()&lt;/code&gt; は 、等しいかどうかをテストします。 文字列の場合、それらはしばしば同じですが、あなたが発見したように、それは常に保証されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="f8e7716ea4c3e20c7bdf723f23756bb919d9eaad" translate="yes" xml:space="preserve">
          <source>You almost &lt;strong&gt;always&lt;/strong&gt; want to use &lt;code&gt;Objects.equals()&lt;/code&gt;. In the &lt;strong&gt;rare&lt;/strong&gt; situation where you &lt;strong&gt;know&lt;/strong&gt; you're dealing with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--&quot;&gt;interned&lt;/a&gt; strings, you &lt;em&gt;can&lt;/em&gt; use &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;Objects.equals()&lt;/code&gt; を使用します。 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--&quot;&gt;インターンされた&lt;/a&gt;文字列を処理して&lt;strong&gt;いる&lt;/strong&gt;ことが&lt;strong&gt;わかっ&lt;/strong&gt;ている&lt;strong&gt;まれな&lt;/strong&gt;状況では、 &lt;code&gt;==&lt;/code&gt; &lt;em&gt;を&lt;/em&gt;使用&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5161c797f0345d83c726119d178d75aa5610fb2c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;compareTo()&lt;/code&gt; method to compare two Strings. If the compareTo result is 0, then the two strings are equal, otherwise the strings being compared are not equal.</source>
          <target state="translated">また、 &lt;code&gt;compareTo()&lt;/code&gt; メソッドを使用して、2つの文字列を比較することもできます。 compareToの結果が0の場合、2つの文字列は等しいです。それ以外の場合、比較される文字列は等しくありません。</target>
        </trans-unit>
        <trans-unit id="0afb8ff09e0f16ede865ab95dfcdc15300c82b5a" translate="yes" xml:space="preserve">
          <source>You may want to have a look at this &lt;a href=&quot;http://www.ensta-paristech.fr/~diam/java/online/notes-java/data/expressions/22compareobjects.html&quot;&gt;==, .equals(), compareTo(), and compare()&lt;/a&gt;</source>
          <target state="translated">この&lt;a href=&quot;http://www.ensta-paristech.fr/~diam/java/online/notes-java/data/expressions/22compareobjects.html&quot;&gt;== 、. equals（）、compareTo（）、compare（）を確認してください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ea16d98d575b2b8348dcba9edc206a8a0907873" translate="yes" xml:space="preserve">
          <source>You will get the output as &lt;code&gt;TRUE&lt;/code&gt; if you use &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; を使用すると、出力が &lt;code&gt;TRUE&lt;/code&gt; になります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
