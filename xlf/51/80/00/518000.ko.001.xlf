<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/518000">
    <body>
      <group id="518000">
        <trans-unit id="1dee29437206aa2b90705d515faaafcb0add50ca" translate="yes" xml:space="preserve">
          <source>&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;Which programming languages are pass by reference?&lt;/a&gt;</source>
          <target state="translated">&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi-&lt;/a&gt; &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;어떤 프로그래밍 언어가 참조로 전달됩니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07698e10df4dd98b0bf399ab50011ce57e452623" translate="yes" xml:space="preserve">
          <source>(From the article mentioned above.)</source>
          <target state="translated">(위의 기사에서)</target>
        </trans-unit>
        <trans-unit id="edeb4423fd301ceb5f86fc44d38b40f3c9ba6fa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Return a value of type Reference&lt;/b&gt; whose base value is baseValue and whose referenced name is
  propertyNameString, and whose strict mode flag is strict.</source>
          <target state="translated">기본 값이 baseValue이고 참조 이름이 propertyNameString이고 엄격 모드 플래그가 엄격한 &lt;b&gt;Reference 유형의 값을 리턴합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d0d476f54a71b8ac89e5d06ddffbeccc263797e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TL;DR&lt;/b&gt;: Everythings're passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.</source>
          <target state="translated">&lt;b&gt;TL; DR&lt;/b&gt; : 모든 것은 가치에 의해 전달되지만 Objects의 속성은 참조이며 Object의 정의는 표준에서 오싹합니다.</target>
        </trans-unit>
        <trans-unit id="5cc31de26a91a7607db07fbc10e5bdca64ddd6b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compound values are always assigned/passed by reference-copy&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;복합 값은 항상 참조 복사에 의해 할당 / 전달됩니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b825d8d1882d46055d101f87ec20d9423ddb0d0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function arguments and parameters are not the same thing.  Also, a variable's value is not the variable's object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;함수 인수와 매개 변수는 동일하지 않습니다.&lt;/em&gt; &lt;em&gt;또한 변수의 값은 변수의 객체가 아닙니다 (다양한 사람들이 이미 지적했지만 분명히 무시합니다).&lt;/em&gt; &lt;em&gt;이러한 차이점은 올바른 이해에 중요합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dec8a494f102cfe95fa805f288c3d04ee0a6b711" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Primitive values are always assigned/passed by value-copy&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;기본 값은 항상 value-copy에 의해 지정 / 전달됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="207d1e3b4f674510d97d07b156c4c5ee3a4de294" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because in JavaScript, it doesn't matter whether it's passed by value or by reference or whatever.
What matters is mutation vs assignment of the parameters passed into a function.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript에서는 값으로 전달되는지 또는 참조로 전달되는지 여부는 중요하지 않습니다.&lt;/strong&gt; &lt;strong&gt;중요한 것은 함수에 전달 된 매개 변수의 돌연변이 대 돌연변이입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a42287a91a97e2c4e1094a867ae8805599745087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt;:  The function argument's value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object's data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.</source>
          <target state="translated">&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt; : 함수 인자의 값은 해당 함수 파라미터에 의해 직접 업데이트 될 수 있습니다. 도움이되는 경우 함수 매개 변수는 인수에 대한 효과적인 &quot;별칭&quot;이됩니다. 동일한 메모리 위치에서 동일한 값을 효과적으로 참조합니다. 함수 인수가 객체 변수 인 경우, 함수 매개 변수는 여전히 인수와 동일한 객체를 가리 키기 때문에 객체의 데이터를 변경하는 기능은 값별 대소 문자와 다르지 않습니다. 그러나 객체 변수의 경우 함수 매개 변수가 완전히 다른 객체로 설정되면 인수도 다른 객체를 가리 킵니다. 값에 의한 경우에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c12cc2e2533791936e57d4b9415ab42ea32e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex&lt;/strong&gt;: When you access a complex type you work on a reference to its value</source>
          <target state="translated">&lt;strong&gt;Complex&lt;/strong&gt; : 복합 유형에 액세스하면 해당 값에 대한 참조 작업</target>
        </trans-unit>
        <trans-unit id="1301250d5301f648cf05701bd59197e854b822ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;: Variable outside the function which is passed to the function by the caller.</source>
          <target state="translated">&lt;strong&gt;함수 인수&lt;/strong&gt; : 호출자가 함수에 전달하는 함수 외부의 변수입니다.</target>
        </trans-unit>
        <trans-unit id="65492a390eb86ea3356e64d01cfaa27d6c3fab3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function parameter&lt;/strong&gt;:  Variable declared in a function definition, used for referencing variables passed to the function.</source>
          <target state="translated">&lt;strong&gt;함수 매개 변수&lt;/strong&gt; : 함수 정의에 선언 된 변수로, 함수에 전달 된 변수를 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65a6814d6b676f546b18918b30e471d0b5236d77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Memory location&lt;/strong&gt;:  Where a variable's value is stored.  (The location itself is represented by a number separate from the value stored at the location.)</source>
          <target state="translated">&lt;strong&gt;메모리 위치&lt;/strong&gt; : 변수 값이 저장되는 위치. 위치 자체는 위치에 저장된 값과 다른 숫자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5996d89441c8d0e61fe5412acbb5b6378fb43e74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object clone/copy&lt;/strong&gt;: A new object is created and the original object's data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.</source>
          <target state="translated">&lt;strong&gt;객체 복제 / 복사&lt;/strong&gt; : 새로운 객체가 생성되고 원본 객체의 데이터가 복사됩니다. 이것은 깊은 사본 또는 얕은 사본 일 수 있지만 요점은 새 객체가 생성된다는 것입니다. 개체의 복사본을 만드는 것은 값으로 전달하는 것과 별개의 개념입니다. 일부 언어는 클래스 객체와 구조체 등을 구별하며 다른 유형의 변수를 전달하는 데 다른 동작을 가질 수 있습니다. 그러나 JavaScript는 객체 변수를 전달할 때 이와 같은 작업을 자동으로 수행하지 않습니다. 그러나 자동 객체 복제가 없다고해서 참조 별 통과로 변환되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fa53139221548e1fd770ad7abe04c1dc6d698150" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object variable&lt;/strong&gt;:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object's actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.</source>
          <target state="translated">&lt;strong&gt;Object variable&lt;/strong&gt; : 기본 기본 값이 &quot;object&quot;자체가 아닌 변수이며, 값은 오브젝트의 실제 데이터가 저장되는 메모리의 다른 위치에 대한 포인터 (메모리 위치 값)입니다. 대부분의 고급 언어에서 &quot;포인터&quot;측면은 다양한 상황에서 자동 역 참조를 통해 효과적으로 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="d880bbb046dd0fb8ed275862bb6d9eb727b33d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참조로 전달 (객체)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab95d2eb7f10fa0819e1bef83f4bd83e6ae79ba7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value (primitive type)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;값으로 전달 (기본 유형)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d87f3236c9b7ff2b627b66d6a54c489872ad459f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass-by-value or Call-by-sharing (for objects)&lt;/strong&gt;:  The function argument's value is COPIED to another memory location which is referenced by the function's parameter symbol (regardless of whether it's on the stack or heap).  In other words, the function parameter received a copy of the passed argument's value... AND (critical) the argument's value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable's value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter's value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument's value IS NEVER UPDATED, so it will continue to point to the &lt;em&gt;same&lt;/em&gt; object throughout and even after the function call (even if its object's data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.</source>
          <target state="translated">&lt;strong&gt;값별 전달 또는 공유 별 호출 (객체의 경우)&lt;/strong&gt; : 함수 인수의 값은 스택 또는 힙에 있는지 여부에 관계없이 함수의 매개 변수 기호로 참조되는 다른 메모리 위치에 복사됩니다. 즉, 함수 매개 변수가 전달 된 인수 값의 사본을 수신했습니다. AND (필수) 인수 값이 호출 함수에 의해 업데이트 / 변경 / 변경되지 않았습니다. 객체 변수의 값은 객체 자체가 아니라 객체에 대한 포인터이므로 객체 변수를 값으로 전달하면 포인터가 함수 매개 변수 변수에 복사됩니다. 함수 매개 변수의 값은 메모리에서 정확히 동일한 객체를 가리 킵니다. 객체 데이터 자체는 함수 매개 변수를 통해 직접 변경할 수 있지만 함수 인수의 값은 절대로 업데이트되지 않으므로 함수 호출 전체 및 이후에도 (객체의 데이터가 변경되었거나 함수 매개 변수에는 모두 다른 객체가 할당됩니다). 참조 된 객체가 함수 매개 변수 변수를 통해 업데이트 가능하기 때문에 함수 인수가 참조로 전달되었다고 결론을 내릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3daa908ef93ef3beddf5ee815280e35804b2ab50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitive variable&lt;/strong&gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable's value IS the actual value represented by the variable's symbol rather than a pointer to another memory location.</source>
          <target state="translated">&lt;strong&gt;원시 변수&lt;/strong&gt; : 값이 실제 값인 변수. 이 개념조차도 다양한 언어의 자동 복싱 및 객체와 유사한 컨텍스트로 인해 복잡 할 수 있지만 일반적인 아이디어는 변수의 값이 다른 메모리 위치에 대한 포인터가 아니라 변수의 기호로 표시되는 실제 값이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="738f561981f804bed95647891f285ca2a07e0ffc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitives&lt;/strong&gt;: When you access a primitive type you work directly on its
value</source>
          <target state="translated">&lt;strong&gt;프리미티브&lt;/strong&gt; : 프리미티브 유형에 액세스하면 해당 값을 직접 작업합니다.</target>
        </trans-unit>
        <trans-unit id="f1d08a4ffaed6d05dab4d5131e21bf7f0ad7cc25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special case, pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;특수 사례, 참조로 전달 (객체)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d30d6d093711f7dc4bbd3b5d3e73777eb88a76b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symbol&lt;/strong&gt;:  Text string used to refer to variable (i.e. variable's name).</source>
          <target state="translated">&lt;strong&gt;Symbol&lt;/strong&gt; : 변수 (예 : 변수 이름)를 나타내는 데 사용되는 텍스트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="dbb628f544b2f5b04bb5df870aacd2b707683b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;:  Particular bits stored in memory and referenced using variable's symbol.</source>
          <target state="translated">&lt;strong&gt;Value&lt;/strong&gt; : 메모리에 저장되고 변수의 심볼을 사용하여 참조되는 특정 비트.</target>
        </trans-unit>
        <trans-unit id="4a4a44d5c5dbc605d366445b9f5e39a3dbd71772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variable&lt;/strong&gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.</source>
          <target state="translated">&lt;strong&gt;변수&lt;/strong&gt; : 메모리의 특정 위치에서 값을 참조하는 기호의 결합 된 개념. 이 용어는 일반적으로 세부 사항을 논의 할 때 단독으로 사용하기에는 너무로드됩니다.</target>
        </trans-unit>
        <trans-unit id="5a8e1fdd316d10b0c0cd59d94a6940772041c1cd" translate="yes" xml:space="preserve">
          <source>A object is automatically passed by reference, without the need to specifically state it</source>
          <target state="translated">명시 적으로 언급 할 필요없이 참조에 의해 객체가 자동으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b440a38266bd3bd8023694ca76f1853cb56c68f1" translate="yes" xml:space="preserve">
          <source>A primitive value passed to a function cannot be modified by the function. A copy is made.</source>
          <target state="translated">함수에 전달 된 기본 값은 함수로 수정할 수 없습니다. 사본이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="79ce62763f1e30b37f20149148f8548734cf61b5" translate="yes" xml:space="preserve">
          <source>A very detailed explanation about copying, passing and comparing by value and by reference is in &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;this chapter&lt;/a&gt; of the &lt;em&gt;&quot;JavaScript: The Definitive Guide&quot;&lt;/em&gt; book.</source>
          <target state="translated">값과 참조에 의한 복사, 전달 및 비교에 대한 자세한 설명은 &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;이&lt;/a&gt; &lt;em&gt;&quot;JavaScript : Definitive Guide&quot;&lt;/em&gt; 책의 장에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d35a2aa876badcd3c415f65100051e77924dd6" translate="yes" xml:space="preserve">
          <source>Access of Object Properties</source>
          <target state="translated">객체 속성 액세스</target>
        </trans-unit>
        <trans-unit id="3e9807bf09a22721f2ffa94b835d05c65938f14a" translate="yes" xml:space="preserve">
          <source>Again, we pick a favorite.</source>
          <target state="translated">다시, 우리는 마음에 드는 것을 골라냅니다.</target>
        </trans-unit>
        <trans-unit id="988045fdd90b44521a9b2b9c55dfe875b6ad44e6" translate="yes" xml:space="preserve">
          <source>Although it doesn't really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?</source>
          <target state="translated">마지막에는 중요하지 않지만, 규칙을 통과하는 논쟁을 제시하는 올바른 방법이 무엇인지 알고 싶습니다. JavaScript 사양에 대한 발췌가 있습니까? 이것에 대한 의미론을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="96ef530acd2543eafd4ab0cb7e97e8162bcf66fb" translate="yes" xml:space="preserve">
          <source>Always remember that the equals sign (=) means assignment.
Always remember that passing a parameter to a function &lt;em&gt;in JavaScript&lt;/em&gt; also means assignment.
They are the same and the 2 variables are connected in exactly the same way (which is to say they aren't, unless you count that they are assigned to the same object).</source>
          <target state="translated">항상 등호 (=)는 할당을 의미합니다. &lt;em&gt;JavaScript&lt;/em&gt; 에서 함수 &lt;em&gt;에&lt;/em&gt; 매개 변수를 전달하는 것도 할당을 의미한다는 것을 항상 기억하십시오. 그것들은 동일하고 2 개의 변수는 정확히 같은 방식으로 연결됩니다 (즉, 동일한 객체에 할당되었다고 계산하지 않는 한 그렇지 않습니다).</target>
        </trans-unit>
        <trans-unit id="bfdc1eb7888008268dcd1f229efc00ed9fe4071e" translate="yes" xml:space="preserve">
          <source>An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:</source>
          <target state="translated">무언가가 &quot;통과 기준&quot;인지 판단하는 쉬운 방법은 &quot;스왑&quot;기능을 작성할 수 있는지 여부입니다. 예를 들어 C에서는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3055a2e0457cb299ca6d433ebcc210c7bab9799e" translate="yes" xml:space="preserve">
          <source>An object outside a function is passed into a function by giving a reference to the outside object.</source>
          <target state="translated">함수 외부의 객체는 외부 객체에 대한 참조를 제공하여 함수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b05bb9226e6abe9287bbf028bf6e5a6bed6624b9" translate="yes" xml:space="preserve">
          <source>An object passed to a function can have its members modified by the function.</source>
          <target state="translated">함수에 전달 된 객체는 함수로 멤버를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e123b648bf0a31ec900d67e265e2a81d689d3d" translate="yes" xml:space="preserve">
          <source>Array and Object is passed as  pass by reference or  pass by value based on these two condition.</source>
          <target state="translated">이 두 가지 조건에 따라 배열과 객체는 참조로 전달되거나 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7628591e37cbe88cf6fb309ba297bb58229eacac" translate="yes" xml:space="preserve">
          <source>As a final example, consider why a common attempt to clear an array doesn't work as expected.</source>
          <target state="translated">마지막 예로 배열을 지우는 일반적인 시도가 예상대로 작동하지 않는 이유를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="178ee3db1a483706ed36d79f599e1a13d33df86f" translate="yes" xml:space="preserve">
          <source>Before we leave the topic of
  manipulating objects and arrays by
  reference, we need to clear up a point
  of nomenclature.</source>
          <target state="translated">객체와 배열 조작이라는 주제를 참조로 떠나기 전에 명명법을 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8884a4d2e00d4a1e326a98a062754846001f9b2" translate="yes" xml:space="preserve">
          <source>Both our favoriteString and string1 variables are assigned to 'Hello world'. Now, what if we want to change our favoriteString??? What will happen???</source>
          <target state="translated">우리의 favoriteString과 string1 변수는 모두 'Hello world'에 할당됩니다. 이제 favoriteString을 변경하려면 어떻게해야합니까 ??? 무슨 일이 일어날 것???</target>
        </trans-unit>
        <trans-unit id="aa133f04e687ffaadb65bfc4786e9aafccdad56e" translate="yes" xml:space="preserve">
          <source>But both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are separate references to the same shared value &lt;code&gt;[1,2,3]&lt;/code&gt;, which is a compound value. It's important to note that neither &lt;code&gt;c&lt;/code&gt; nor &lt;code&gt;d&lt;/code&gt; more &quot;owns&quot; the &lt;code&gt;[1,2,3]&lt;/code&gt; value -- both are just equal peer references to the value. So, when using either reference to modify (&lt;code&gt;.push(4)&lt;/code&gt;) the actual shared &lt;code&gt;array&lt;/code&gt; value itself, it's affecting just the one shared value, and both references will reference the newly modified value &lt;code&gt;[1,2,3,4]&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;d&lt;/code&gt; 는 모두 동일한 공유 값 &lt;code&gt;[1,2,3]&lt;/code&gt; 에 대한 별도의 참조이며, 이는 복합 값입니다. &lt;code&gt;c&lt;/code&gt; 나 &lt;code&gt;d&lt;/code&gt; 는 더 이상 &lt;code&gt;[1,2,3]&lt;/code&gt; 값을 &quot;소유&quot;하지 않으며 둘 다 그 값에 대한 동일한 피어 참조 일뿐입니다. 따라서 실제 공유 &lt;code&gt;array&lt;/code&gt; 값 자체를 수정하기 위해 참조 ( &lt;code&gt;.push(4)&lt;/code&gt; )를 사용할 때 하나의 공유 값에만 영향을 미치며 두 참조는 새로 수정 된 값 &lt;code&gt;[1,2,3,4]&lt;/code&gt; 를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="296985a800b1e8c9380cebd23dfbc86e71426942" translate="yes" xml:space="preserve">
          <source>Call CheckObjectCoercible(baseValue).</source>
          <target state="translated">CheckObjectCoercible (baseValue)을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="393aa90af622b95d2fecad8fb5a88f507b3e5d67" translate="yes" xml:space="preserve">
          <source>Changing the value of any changes value for both the variable.</source>
          <target state="translated">변수의 값을 변경하면 변수에 대한 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e68569b88f0d63d426d55a5ad6eb50201341e31f" translate="yes" xml:space="preserve">
          <source>Compound value (object, array, etc) that can be passed by reference-copy</source>
          <target state="translated">참조 복사로 전달할 수있는 복합 값 (객체, 배열 등)</target>
        </trans-unit>
        <trans-unit id="26b600a5d56d8944d8651beec06ae0642c20e289" translate="yes" xml:space="preserve">
          <source>Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.</source>
          <target state="translated">인수와 변수 객체는 함수 호출의 시작 부분에서 생성 된 실행 컨텍스트 동안 생성 된 객체입니다. 함수에 전달 된 실제 값 / 참조는이 인수 + 변수 객체에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="5cecf4a03ec84caeeda78029a5bd713522ec8fe8" translate="yes" xml:space="preserve">
          <source>Construction of Argument Lists</source>
          <target state="translated">인수리스트의 구성</target>
        </trans-unit>
        <trans-unit id="635aa588bea9df239881e622d2cd3adbad8bf3c9" translate="yes" xml:space="preserve">
          <source>Definition of &quot;Object&quot;</source>
          <target state="translated">&quot;객체&quot;의 정의</target>
        </trans-unit>
        <trans-unit id="e9656fda095be85a55c47e88f0f2142837377331" translate="yes" xml:space="preserve">
          <source>E.g.:</source>
          <target state="translated">E.g.:</target>
        </trans-unit>
        <trans-unit id="e8a531332b5e0c2dac36ce0017c63f03c75815b9" translate="yes" xml:space="preserve">
          <source>Every time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.</source>
          <target state="translated">변수를 함수에 전달할 때마다 등호 (=) 부호를 사용하는 것처럼 매개 변수 변수의 이름이 무엇이든 &quot;할당&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="83b1fe6393f9ea04f7c6ef0ebceb29757afe9a44" translate="yes" xml:space="preserve">
          <source>First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.</source>
          <target state="translated">우선, 모든 사람이 파악하지 못하는 추상화 수준은 여러 가지입니다. 4 세대 또는 5 세대 언어를 배운 신입 프로그래머는 포인터에 대한 포인터로 단계적으로 표시되지 않은 어셈블리 또는 C 프로그래머에게 익숙한 개념을 염두에 두지 못할 수 있습니다. 참조 별 통과는 단순히 함수 매개 변수를 사용하여 참조 된 객체를 변경하는 기능을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="01bf4a9057daf1172b230a29ebe7eb0911eb8d6d" translate="yes" xml:space="preserve">
          <source>For programming language lawyers, I've went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;asking&lt;/a&gt; it on the ECMAScript mailing list.</source>
          <target state="translated">프로그래밍 언어 변호사를 위해 ECMAScript 5.1 (최신판보다 읽기 쉬운)의 다음 섹션을 살펴 보았으며 ECMAScript 메일 링리스트에서 &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;질문&lt;/a&gt; 했습니다.</target>
        </trans-unit>
        <trans-unit id="bd46cdb9b904080183e993ad3943a7303f85bd9f" translate="yes" xml:space="preserve">
          <source>Functions are objects</source>
          <target state="translated">함수는 객체입니다</target>
        </trans-unit>
        <trans-unit id="2fb8e5522eb18d1143e0bd9cb31d216fa77b5c59" translate="yes" xml:space="preserve">
          <source>Here is a rebuttal to this:</source>
          <target state="translated">이에 대한 반박은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47be461e851afeca8344b89d76c09b76e3e854ed" translate="yes" xml:space="preserve">
          <source>Here is an example, passing a number (a primitive type)</source>
          <target state="translated">다음은 숫자 (원시 유형)를 전달하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="6d1956753d691a97c45c137388c4df02dd75b9c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;obj&lt;/code&gt; acts as a wrapper for the scalar primitive property &lt;code&gt;a&lt;/code&gt;. When passed to &lt;code&gt;foo(..)&lt;/code&gt;, a copy of the &lt;code&gt;obj&lt;/code&gt; reference is passed in and set to the &lt;code&gt;wrapper&lt;/code&gt;parameter. We now can use the &lt;code&gt;wrapper&lt;/code&gt; reference to access the shared object, and update its property. After the function finishes, &lt;code&gt;obj.a&lt;/code&gt; will see the updated value &lt;code&gt;42&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;obj&lt;/code&gt; 는 스칼라 프리미티브 속성 &lt;code&gt;a&lt;/code&gt; 의 래퍼 역할을 합니다 . &lt;code&gt;foo(..)&lt;/code&gt; 로 전달되면 &lt;code&gt;obj&lt;/code&gt; 참조의 사본이 전달되어 &lt;code&gt;wrapper&lt;/code&gt; 매개 변수로 설정됩니다. 이제 &lt;code&gt;wrapper&lt;/code&gt; 참조를 사용하여 공유 객체에 액세스하고 속성을 업데이트 할 수 있습니다. 함수가 완료되면 &lt;code&gt;obj.a&lt;/code&gt; 는 업데이트 된 값 &lt;code&gt;42&lt;/code&gt; 를 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="05dc205598b6fae1df14251d0f1b665f0352c482" translate="yes" xml:space="preserve">
          <source>Here, we mean
  simply that a reference to an object
  or array -- not the object itself --
  is passed to a function. A function
  can use the reference to modify
  properties of the object or elements
  of the array. But if the function
  overwrites the reference with a
  reference to a new object or array,
  that modification is not visible
  outside of the function.</source>
          <target state="translated">여기서 우리는 단순히 객체 자체가 아닌 객체 또는 배열에 대한 참조가 함수에 전달된다는 것을 의미합니다. 함수는 참조를 사용하여 배열의 객체 또는 요소의 속성을 수정할 수 있습니다. 그러나 함수가 참조를 새 객체 또는 배열에 대한 참조로 덮어 쓰면 해당 수정은 함수 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec613745ca6fb8018d61844fbac16fd497f35e96" translate="yes" xml:space="preserve">
          <source>I have found the &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend method&lt;/a&gt; of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js library&lt;/a&gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.</source>
          <target state="translated">&lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js 라이브러리&lt;/a&gt; 의 &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend 메소드&lt;/a&gt; 는 객체를 매개 변수로 전달하거나 수정하거나 완전히 대체 할 때 매우 유용하다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="da00583f56bed3adae6b3854cb9669d9ef039b2e" translate="yes" xml:space="preserve">
          <source>I would say it is pass-by-copy -</source>
          <target state="translated">나는 그것이 패스 바이 패스라고 말할 것입니다-</target>
        </trans-unit>
        <trans-unit id="99152f78f2285e9f5178a28c6ae891d22918905b" translate="yes" xml:space="preserve">
          <source>I've read through these answers multiple times, but didn't REALLY get it until I learned about the technical definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;Call by sharing&quot;&lt;/a&gt; as termed by Barbara Liskov</source>
          <target state="translated">이 답변을 여러 번 읽었지만 Barbara Liskov가 말하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;공유하여 전화&quot;&lt;/a&gt; 의 기술적 정의에 대해 배울 때까지는 실제로 그것을 얻지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="668d70912c4017d9abe459009e674ca09138a746" translate="yes" xml:space="preserve">
          <source>I.e. effectively primitive types are passed by value, and complex types are passed by reference.</source>
          <target state="translated">즉, 효과적으로 기본 유형은 값으로 전달되고 복합 유형은 참조로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0ec6ec8507ceaa91f883d8986d51cbca5f8b1a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj1&lt;/code&gt; was not a reference at all, then changing &lt;code&gt;obj1.item&lt;/code&gt; would have no effect on the &lt;code&gt;obj1&lt;/code&gt; outside of the function.</source>
          <target state="translated">&lt;code&gt;obj1&lt;/code&gt; 이 전혀 참조가 아닌 경우 &lt;code&gt;obj1.item&lt;/code&gt; 을 변경해도 함수 외부의 &lt;code&gt;obj1&lt;/code&gt; 에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59dbe46a8ab60f48cf2577d1714a38c220edd92d" translate="yes" xml:space="preserve">
          <source>If the argument was a proper reference, then everything would have changed. &lt;code&gt;num&lt;/code&gt; would be &lt;code&gt;100&lt;/code&gt;, and &lt;code&gt;obj2.item&lt;/code&gt; would read &lt;code&gt;&quot;changed&quot;&lt;/code&gt;.</source>
          <target state="translated">인수가 적절한 참조라면 모든 것이 변경되었을 것입니다. &lt;code&gt;num&lt;/code&gt; 은 &lt;code&gt;100&lt;/code&gt; 이고 &lt;code&gt;obj2.item&lt;/code&gt; 은 &lt;code&gt;&quot;changed&quot;&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="8184ee6c0e0f41f78f07ffde38ac0df94ff1ef63" translate="yes" xml:space="preserve">
          <source>If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let
  strict be false.</source>
          <target state="translated">평가중인 구문 작성이 엄격 모드 코드에 포함되어 있으면 엄격을 true로 설정하고 그렇지 않으면 엄격을 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0514b00b4153ffccc1fdf8db144a3bb4f96beb69" translate="yes" xml:space="preserve">
          <source>If you can't do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.</source>
          <target state="translated">JavaScript에서 이와 동등한 기능을 수행 할 수없는 경우 &quot;pass by reference&quot;가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ed437ed8c9b163811c8c45a0df65ee0cfa2b2119" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;strong&gt;objects&lt;/strong&gt; are stored as references:</source>
          <target state="translated">JavaScript에서 &lt;strong&gt;객체&lt;/strong&gt; 는 참조로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4a244292f7a66631a95bd0016a42e5a3d8a6fdee" translate="yes" xml:space="preserve">
          <source>In JavaScript, the type of the value &lt;em&gt;solely&lt;/em&gt; controls whether that value will be assigned by &lt;strong&gt;value-copy&lt;/strong&gt; or by &lt;strong&gt;reference-copy&lt;/strong&gt;.</source>
          <target state="translated">JavaScript에서 값의 유형은 해당 값을 &lt;strong&gt;value-copy&lt;/strong&gt; 또는 &lt;strong&gt;reference-copy&lt;/strong&gt; 로 지정할지 여부 &lt;em&gt;만&lt;/em&gt; 제어합니다.</target>
        </trans-unit>
        <trans-unit id="bf140191af1dcec987a4dde5edb6fb8a16e09a25" translate="yes" xml:space="preserve">
          <source>In a low level language, if you want to pass a variable by reference you have to use a specific syntax in the creation of the function:</source>
          <target state="translated">저수준 언어에서 참조로 변수를 전달하려면 함수 작성시 특정 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="81c7785c18e39819bdc6bf53496b0a9a6239d0fc" translate="yes" xml:space="preserve">
          <source>In both alerts you will find the value to be undefined.</source>
          <target state="translated">두 경고 모두 값이 정의되지 않은 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35606096aee27d974b3090d3e8e5ae1f3bda2fd4" translate="yes" xml:space="preserve">
          <source>In my book that's called passing by reference.</source>
          <target state="translated">내 책에서는 참조로 전달이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3f390d1963a58a5cc587e0e6330cf78dff59fc86" translate="yes" xml:space="preserve">
          <source>In practical terms, this means that if you change the parameter itself (as with &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt;), that won't affect the item that was fed into the parameter. But if you change the &lt;strong&gt;INTERNALS&lt;/strong&gt; of the parameter, that will propagate back up (as with &lt;code&gt;obj1&lt;/code&gt;).</source>
          <target state="translated">실제로는 매개 변수 자체를 변경하면 ( &lt;code&gt;num&lt;/code&gt; 및 &lt;code&gt;obj2&lt;/code&gt; 와 마찬가지로) 매개 변수에 공급 된 항목에 영향을 미치지 않습니다. 그러나 매개 변수의 &lt;strong&gt;내부&lt;/strong&gt; 를 변경하면 &lt;code&gt;obj1&lt;/code&gt; 과 같이 다시 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="b57ba2b5cb9f82c19123db765fac17e24d1951eb" translate="yes" xml:space="preserve">
          <source>In the above snippet, because &lt;code&gt;2&lt;/code&gt; is a scalar primitive, &lt;code&gt;a&lt;/code&gt; holds one initial copy of that value, and &lt;code&gt;b&lt;/code&gt; is assigned another copy of the value. When changing &lt;code&gt;b&lt;/code&gt;, you are in no way changing the value in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">위의 스 니펫에서 &lt;code&gt;2&lt;/code&gt; 는 스칼라 프리미티브이므로 &lt;code&gt;a&lt;/code&gt; 는 해당 값의 초기 사본 하나를 보유하고 &lt;code&gt;b&lt;/code&gt; 에는 다른 값 사본이 할당됩니다. &lt;code&gt;b&lt;/code&gt; 를 변경할 때 a 의 값을 변경하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9be98568917515ecc47f6e69cddc320618b40a6f" translate="yes" xml:space="preserve">
          <source>Inside the function, parameter variables, &lt;code&gt;inVar1&lt;/code&gt; and &lt;code&gt;inVar2&lt;/code&gt;, receive the contents being passed.</source>
          <target state="translated">함수 내에서 매개 변수 변수 &lt;code&gt;inVar1&lt;/code&gt; 및 &lt;code&gt;inVar2&lt;/code&gt; 는 전달되는 컨텐츠를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="eb0aded998f21b511a6bf2ba99f8f35d22c1fb84" translate="yes" xml:space="preserve">
          <source>Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is &lt;em&gt;itself&lt;/em&gt; a reference.
Technically, this is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;call-by-sharing&lt;/a&gt;.</source>
          <target state="translated">대신, 전달 된 품목이 값으로 전달되는 상황입니다. 그러나 가치에 의해 전달되는 항목 &lt;em&gt;자체&lt;/em&gt; 는 참조입니다. 기술적으로이를 &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;공유 호출&lt;/a&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d302320d7430fecc028a90dc07690d841f6022" translate="yes" xml:space="preserve">
          <source>Is JavaScript a pass-by-reference or pass-by-value language</source>
          <target state="translated">JavaScript는 참조 기준 또는 값 기준 언어입니까?</target>
        </trans-unit>
        <trans-unit id="762dca873ea18a90a6df0ccb480c5023409ab8ee" translate="yes" xml:space="preserve">
          <source>It is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;effort&lt;/a&gt; to understand.</source>
          <target state="translated">&quot;개체는 속성의 모음&quot;이라고 5.1 판에 정의되어 있습니다. 그러므로 우리는 객체의 값이 콜렉션이라고 추론 할 수 있지만, 콜렉션의 값이 무엇인지에 대해서는 사양에서 잘 정의되어 있지 않으며 이해 &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;하기&lt;/a&gt; 위해 약간의 노력 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="986429e47688846136b52b4cd304e16867c4438c" translate="yes" xml:space="preserve">
          <source>It is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they're only used to describe the behavior of the delete, the typeof, and the assignment operators.</source>
          <target state="translated">8.7 &quot;참조 사양 유형&quot;섹션에 설명되어 있으며, 참조는 언어의 실제 유형이 아니며 삭제, typeof 및 대입 연산자의 동작을 설명하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc2fc8bac54ed799049c59646ec8689ad7f219e2" translate="yes" xml:space="preserve">
          <source>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its &lt;em&gt;members&lt;/em&gt;, those changes persist outside of the function.  This makes it &lt;em&gt;look&lt;/em&gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.</source>
          <target state="translated">항상 값으로 전달되지만 객체의 경우 변수 값이 참조입니다. 이로 인해 객체를 전달하고 &lt;em&gt;멤버&lt;/em&gt; 를 변경하면 해당 변경 사항이 함수 외부에 유지됩니다. 이것은 참조로 전달하는 것처럼 &lt;em&gt;보입니다&lt;/em&gt; . 그러나 실제로 객체 변수의 값을 변경하면 변경 사항이 지속되지 않고 실제로 값을 전달한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a28927b7d2922705fe9300b7e6edf22dfdb59e" translate="yes" xml:space="preserve">
          <source>It's interesting in JavaScript. Consider this example:</source>
          <target state="translated">JavaScript에서 흥미 롭습니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a58c0376442784131cce6ed16ca6889fa180a199" translate="yes" xml:space="preserve">
          <source>It's tempting to think that &lt;em&gt;primitives&lt;/em&gt; are enforced by special rules while &lt;em&gt;objects&lt;/em&gt; are not, but primitives are simply the end of the pointer chain.</source>
          <target state="translated">&lt;em&gt;프리미티브&lt;/em&gt; 는 특별한 규칙에 의해 시행되는 반면 &lt;em&gt;객체&lt;/em&gt; 는 그렇지 않지만 프리미티브는 단순히 포인터 체인의 끝이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0f6e466f49c26929af238bc6449efa0b8dbf2534" translate="yes" xml:space="preserve">
          <source>It's time to throw out everything you know about pass by value / reference.</source>
          <target state="translated">이제 당신이 아는 모든 것을 가치 / 기준으로 전달할 때입니다.</target>
        </trans-unit>
        <trans-unit id="c1ad2e0efeecec9224ee8d6ce3fbe2b458a354fc" translate="yes" xml:space="preserve">
          <source>JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object's data via the function parameter is synonymous to &quot;pass-by-value&quot;.</source>
          <target state="translated">JavaScript는 참조로 전달되지 않습니다. 자세히 읽으면, 모든 반대 의견이 가치에 의한 의미를 이해하지 못하고 함수 매개 변수를 통해 객체의 데이터를 업데이트 할 수있는 능력이 &quot;가치에 따른 가치&quot;와 동일하다는 잘못된 결론을 내릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2d80fc6a6ff698bf0fd9cfa17926536bf0021d5" translate="yes" xml:space="preserve">
          <source>JavaScript is always &lt;em&gt;pass-by-value&lt;/em&gt;; everything is of value type.</source>
          <target state="translated">JavaScript는 항상 &lt;em&gt;가치를 전달합니다&lt;/em&gt; . 모든 것이 가치 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d61aca1d96d43376df88c4a107691b9524026ab9" translate="yes" xml:space="preserve">
          <source>JavaScript passes primitive types by value and object types by reference</source>
          <target state="translated">JavaScript는 기본 유형을 값으로 전달하고 객체 유형을 참조로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="821543b87e4b4527bdc1a22fea2a59bd6cf89783" translate="yes" xml:space="preserve">
          <source>Javascript is a high level language that does this conversion for you. 
So, although objects are passed by reference, the language converts the reference parameter to the value. You don't need to use &lt;code&gt;&amp;amp;&lt;/code&gt;, on the function definition, to pass it by reference, neither &lt;code&gt;*&lt;/code&gt;, on the function body, to convert the reference to the value, JS does it for you.</source>
          <target state="translated">Javascript는 이러한 변환을 수행하는 고급 언어입니다. 따라서 객체는 참조로 전달되지만 언어는 참조 매개 변수를 값으로 변환합니다. 함수 정의에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하여 참조로 전달할 필요는 없으며 함수 본문에서 &lt;code&gt;*&lt;/code&gt; 를 참조로 전달하여 참조를 값으로 변환하면 JS가 대신합니다.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="e2890eaeaae54ae8213119b094d6eac3b0d0f34d" translate="yes" xml:space="preserve">
          <source>Let arg be GetValue(ref).</source>
          <target state="translated">arg를 GetValue (ref)로 둡니다.</target>
        </trans-unit>
        <trans-unit id="d5b52edd936f17bee3970c4c4428d8bdb2114974" translate="yes" xml:space="preserve">
          <source>Let baseReference be the result of evaluating MemberExpression.</source>
          <target state="translated">baseReference를 MemberExpression을 평가 한 결과로 둡니다.</target>
        </trans-unit>
        <trans-unit id="5793a1bc1d3ece9a28dfc1f7df2511a7f09c3cea" translate="yes" xml:space="preserve">
          <source>Let baseValue be GetValue(baseReference).</source>
          <target state="translated">baseValue를 GetValue (baseReference)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0fbb0a339d88c497bca6b7e0e0802f2e1a9e810f" translate="yes" xml:space="preserve">
          <source>Let propertyNameReference be the result of evaluating Expression.</source>
          <target state="translated">propertyNameReference를 Expression을 평가 한 결과로 둡니다.</target>
        </trans-unit>
        <trans-unit id="e26b41e64cfc85d8131bd89ab1968cf9b539bc12" translate="yes" xml:space="preserve">
          <source>Let propertyNameString be ToString(propertyNameValue).</source>
          <target state="translated">propertyNameString을 ToString (propertyNameValue)으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d27739e60a7d1d0ee771b1f518f987ee71282c40" translate="yes" xml:space="preserve">
          <source>Let propertyNameValue be GetValue(propertyNameReference).</source>
          <target state="translated">propertyNameValue를 GetValue (propertyNameReference)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="765c825fb8ce47d020ac3dcc136c15f73cbaa9d1" translate="yes" xml:space="preserve">
          <source>Let ref be the result of evaluating AssignmentExpression.</source>
          <target state="translated">AssignmentExpression을 평가 한 결과로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="ba443140669d7febc24e1df988b59f67bf1999bc" translate="yes" xml:space="preserve">
          <source>My simple way to understand this...</source>
          <target state="translated">이것을 이해하는 간단한 방법은 ...</target>
        </trans-unit>
        <trans-unit id="41e399d344b8bb63a9437372496bb38b9ea65720" translate="yes" xml:space="preserve">
          <source>My two cents... This is the way I understand it. (Feel free to correct me if I'm wrong)</source>
          <target state="translated">내 두 센트 ... 이것이 내가 이해하는 방식입니다. (내가 틀렸다면 자유롭게 고쳐주십시오)</target>
        </trans-unit>
        <trans-unit id="cc50c81892c92e84bb1ae3f1a86483bee39914a6" translate="yes" xml:space="preserve">
          <source>Next, for whatever reason, we decide that we like object 2 better. So, we simply do a little re-assignment.</source>
          <target state="translated">다음으로, 어떤 이유로 든 객체 2를 더 좋아하기로 결정합니다. 그래서 우리는 단순히 약간의 재 할당을합니다.</target>
        </trans-unit>
        <trans-unit id="5983d2311d0216c94667916653cda7009208c7ff" translate="yes" xml:space="preserve">
          <source>Nothing happened to object1 or to object2. We haven't changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.</source>
          <target state="translated">object1 또는 object2에 아무런 변화가 없습니다. 우리는 데이터를 전혀 변경하지 않았습니다. 우리가 한 일은 우리가 가장 좋아하는 물건을 다시 할당하는 것이 었습니다. object2와 favoriteObject가 모두 동일한 오브젝트에 지정되어 있음을 알아야합니다. 변수 중 하나를 통해 해당 개체를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ed35c065098b7007966c00ae087554253b51c5" translate="yes" xml:space="preserve">
          <source>Now, let's say that we like object1 better... So, we &quot;assign&quot; a new variable.</source>
          <target state="translated">이제 object1을 더 좋아한다고 가정 해 봅시다. 그래서 새로운 변수를 &quot;할당&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="fefaeda9e706a96b72c3a91f6d46d3d47c7c5900" translate="yes" xml:space="preserve">
          <source>Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you simply assigned using the equal (=) sign.</source>
          <target state="translated">이제 함수와 매개 변수 전달에 대해 ... 함수를 호출하고 매개 변수를 전달할 때 기본적으로 수행하는 작업은 새 변수에 대한 &quot;할당&quot;이며 단순히 다음을 사용하여 할당 한 것과 동일하게 작동합니다. 등호 (=) 부호</target>
        </trans-unit>
        <trans-unit id="b357112211b094b3237788d525b078423b089167" translate="yes" xml:space="preserve">
          <source>Now, people like to bicker endlessly about whether &quot;pass by reference&quot;
  is the correct way to describe what Java et al. actually do. The point
  is this:</source>
          <target state="translated">이제 사람들은 &quot;참조로 전달&quot;이 Java 등을 설명하는 올바른 방법인지에 대해 끝없이 울부 짖는 것을 좋아합니다. 실제로 그렇습니다. 요점은 이것입니다 :</target>
        </trans-unit>
        <trans-unit id="a7538e8091867206be4163070d38a8f2f6e2fc36" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function</source>
          <target state="translated">자, 똑같은 기능이지만</target>
        </trans-unit>
        <trans-unit id="54f947ec6644ed78ef13a3901e8e53b29b1eae30" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function call</source>
          <target state="translated">자, 똑같은 것이지만 함수 호출</target>
        </trans-unit>
        <trans-unit id="85abe287e946ffe23eec095f98389cf0bb761865" translate="yes" xml:space="preserve">
          <source>OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn't matter whether something is passed by reference or by value... What matters is assignment vs mutation.</source>
          <target state="translated">이 글 전체를 읽어 보면 JavaScript에서 함수 호출이 어떻게 작동하는지 더 잘 이해할 수있을 것입니다. 무언가가 참조로 전달되는지 또는 가치로 전달되는지는 중요하지 않습니다 ... 중요한 것은 할당 대 돌연변이입니다.</target>
        </trans-unit>
        <trans-unit id="49aff953ef64c0bfd256e94df786773f165a1a31" translate="yes" xml:space="preserve">
          <source>OK, let me do my best to explain what I mean. Let's say you have a few objects.</source>
          <target state="translated">자, 제가 의미하는 바를 설명하기 위해 최선을 다하겠습니다. 몇 가지 물건이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="d3ac732c421aaa382ba2a7df3b9370ee3d46965c" translate="yes" xml:space="preserve">
          <source>OK, now let&amp;rsquo;s give a few examples using objects instead... first, without the function.</source>
          <target state="translated">자, 이제 함수없이 먼저 객체를 사용하는 몇 가지 예를 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="55f468caaf302476af028732ffb89566f3834bf7" translate="yes" xml:space="preserve">
          <source>OK, now let's look at primitives like strings for example</source>
          <target state="translated">자, 예를 들어 문자열과 같은 프리미티브를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ed4f6a94ec208043cd9b8120122b92570d99ac3f" translate="yes" xml:space="preserve">
          <source>Objects are passed by reference (the reference is passed by value).</source>
          <target state="translated">객체는 참조로 전달됩니다 (참조는 값으로 전달).</target>
        </trans-unit>
        <trans-unit id="a0023dbe18ebfeae7656c8332857dde47f6a7acc" translate="yes" xml:space="preserve">
          <source>Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an &lt;em&gt;object&lt;/em&gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are &lt;em&gt;primitives&lt;/em&gt;.</source>
          <target state="translated">객체는 값이고 객체의 멤버 함수는 값 자체입니다 (함수는 JavaScript에서 일류 객체임을 기억하십시오). 또한 JavaScript의 모든 것이 &lt;em&gt;객체&lt;/em&gt; 라는 개념과 관련하여; 이것은 잘못이다. 문자열, 기호, 숫자, 부울, 널 및 정의되지 않은 것은 &lt;em&gt;기본 요소&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c473076e20653740c581b65a9c148582980e1f2" translate="yes" xml:space="preserve">
          <source>On Reference</source>
          <target state="translated">참조</target>
        </trans-unit>
        <trans-unit id="24023d41b24981459776a8deb45dffaf544e073a" translate="yes" xml:space="preserve">
          <source>On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:</source>
          <target state="translated">경우에 따라 기본 프로토 타입에서 상속 된 일부 멤버 함수 및 속성을 활용할 수 있지만 이는 단지 편의를위한 것입니다. 그것들이 객체 자체라는 것을 의미하지는 않습니다. 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d12f26544314335beb7af690a37352634d31faf" translate="yes" xml:space="preserve">
          <source>One more example:</source>
          <target state="translated">하나 더 예 :</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="61d70ce6c0868b0a4084920bfa36265cd2924428" translate="yes" xml:space="preserve">
          <source>PHP does something similar since version 5: all objects are passed by reference, but all primitives &lt;em&gt;may&lt;/em&gt; be passed by reference, if preceded by an ampersand (&amp;amp;). Otherwise primitives are passed by value.</source>
          <target state="translated">PHP는 버전 5 이후로 비슷한 기능을 수행합니다. 모든 객체는 참조로 전달되지만 모든 프리미티브 &lt;em&gt;는&lt;/em&gt; 앰퍼샌드 (&amp;amp;)가 앞에 오는 경우 참조로 전달 &lt;em&gt;될 수&lt;/em&gt; 있습니다. 그렇지 않으면 프리미티브가 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa6714b9431fbeb4050db107726bf42359cbd64" translate="yes" xml:space="preserve">
          <source>Passing an object does not copy the object.</source>
          <target state="translated">객체를 전달해도 객체는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="177116d45ea2e23710bb7ea3a718654efa24f9bc" translate="yes" xml:space="preserve">
          <source>Passing arguments to a function in JavaScript is analogous to passing
parameters by pointer value in C:</source>
          <target state="translated">JavaScript에서 함수에 인수를 전달하는 것은 C에서 포인터 값으로 매개 변수를 전달하는 것과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="01f2294132d2e2f2b4566ede86b13262366d51fb" translate="yes" xml:space="preserve">
          <source>Primitives (number, Boolean, etc.) are passed by value.</source>
          <target state="translated">프리미티브 (숫자, 부울 등)는 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1fbe034f18e45d911f35c38befd6ffef1237ff9d" translate="yes" xml:space="preserve">
          <source>Primitives are passed by value and objects are passed by reference. This is quite different from other languages like C, Visual Basic, or Delphi. I can't say how they handle objects and primitives exactly, but I know of Visual Basic and Delphi that it can (and should) be specified.</source>
          <target state="translated">프리미티브는 값으로 전달되고 객체는 참조로 전달됩니다. 이것은 C, Visual Basic 또는 Delphi와 같은 다른 언어와는 상당히 다릅니다. 객체와 프리미티브를 정확히 처리하는 방법을 말할 수는 없지만 Visual Basic과 Delphi는 지정할 수 있고 알고 있어야한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a5e4b79e22cee55b6065ffe3f652237cc7594a" translate="yes" xml:space="preserve">
          <source>Readers
  familiar with the other meaning of
  this term may prefer to say that
  objects and arrays are passed by
  value, but the value that is passed is
  actually a reference rather than the
  object itself.</source>
          <target state="translated">이 용어의 다른 의미에 익숙한 독자는 객체와 배열이 값으로 전달된다고 말하는 것을 선호하지만 전달되는 값은 실제로는 객체 자체가 아니라 참조입니다.</target>
        </trans-unit>
        <trans-unit id="13206fd4fe5b59fc41e3d5a63a6488e8b552facb" translate="yes" xml:space="preserve">
          <source>Reassigning a variable merely points that pointer at a new value.</source>
          <target state="translated">변수를 다시 할당하면 해당 포인터가 새 값을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="3207f76b42378372483b9234b1caf6f7a147a617" translate="yes" xml:space="preserve">
          <source>Reassigning a variable will never affect other variables that were pointing at that same object</source>
          <target state="translated">변수를 다시 할당해도 동일한 객체를 가리키는 다른 변수에는 영향을 미치지 않습니다</target>
        </trans-unit>
        <trans-unit id="d310f078235065dddc3b458e5e588f59ca402bb8" translate="yes" xml:space="preserve">
          <source>Repeating this with an object yields different results:</source>
          <target state="translated">이것을 객체와 함께 반복하면 다른 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="203297a3389833da40302baa74058f84dfb4172b" translate="yes" xml:space="preserve">
          <source>Return a List whose sole item is arg.</source>
          <target state="translated">유일한 항목이 arg 인 List를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fea577a31c06a6a5a9a25864cabd1f7cd04ffc69" translate="yes" xml:space="preserve">
          <source>Section 11.2.1 &quot;Property Accessors&quot;</source>
          <target state="translated">섹션 11.2.1 &quot;속성 접근 자&quot;</target>
        </trans-unit>
        <trans-unit id="e3cdf6da05c63ab4f98f08c709113dc947f4641b" translate="yes" xml:space="preserve">
          <source>Section 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:</source>
          <target state="translated">11.2.4 절 &quot;인수 목록&quot;에서는 단 하나의 인수로 구성된 인수 목록을 생성 할 때 다음을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3dffa3d82c957452592ddbe22ee7b9fbabbad396" translate="yes" xml:space="preserve">
          <source>Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).</source>
          <target state="translated">의미론!! 구체적인 정의를 설정하면 동일한 단어와 구문을 사용할 때도 동일한 내용을 설명하지 않기 때문에 일부 답변과 의견이 호환되지 않을 수 있지만 혼동을 피하는 것이 중요합니다 (특히 새로운 프로그래머의 경우).</target>
        </trans-unit>
        <trans-unit id="9042860968c9655fa63ade5546c81f532a616526" translate="yes" xml:space="preserve">
          <source>Simple values inside functions will not change those values outside of the function (they are passed by value), whereas complex ones will (they are passed by reference).</source>
          <target state="translated">함수 내부의 간단한 값은 함수 외부에서 해당 값을 변경하지 않지만 (값으로 전달됨) 복잡한 값은 참조로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="af00e0ad8adf530d42297d91d90e47a9e641005b" translate="yes" xml:space="preserve">
          <source>Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.</source>
          <target state="translated">간단히 말해, 기본 유형의 경우 함수 호출의 시작 부분에서 값이 복사되고 객체 유형의 경우 참조가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="14e546fc199d754d3c9fb63d6f7e0dc0eda5708f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;inVar2&lt;/code&gt; received the reference of &lt;code&gt;{ prop: 2 }&lt;/code&gt;, you can change the value of the object's property.</source>
          <target state="translated">&lt;code&gt;inVar2&lt;/code&gt; 가 &lt;code&gt;{ prop: 2 }&lt;/code&gt; 의 참조를 수신 했으므로 객체의 속성 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b26d53b2a6c26d221c34b2ced9596e48f74edf5" translate="yes" xml:space="preserve">
          <source>So changing the value of a variable doesn't affect the other, as they both reside in two different locations.</source>
          <target state="translated">따라서 변수의 값을 변경해도 다른 두 위치에 상주하므로 다른 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f443d83baee5de8b57871adc873303085a0467cd" translate="yes" xml:space="preserve">
          <source>So in JavaScript, if I pass an object X into a function via a parameter, it will still be X. If you are changing data &lt;em&gt;inside&lt;/em&gt; the function (or any other object, but that's not important) that new value is also available outside the function.</source>
          <target state="translated">따라서 JavaScript에서 객체 X를 매개 변수를 통해 함수에 전달하면 여전히 X가 &lt;em&gt;됩니다&lt;/em&gt; . 함수 (또는 다른 객체, 그러나 중요하지는 않습니다) &lt;em&gt;내부&lt;/em&gt; 의 데이터를 변경하는 경우 새 값도 외부에서 사용할 수 있습니다 함수.</target>
        </trans-unit>
        <trans-unit id="8f7623c6dec052db957de7605896e4a2a3e6b647" translate="yes" xml:space="preserve">
          <source>So, &lt;strike&gt;forget about &lt;em&gt;&quot;pass by reference/value&quot;&lt;/em&gt;&lt;/strike&gt; don't get hung up on &quot;pass by reference/value&quot; because:</source>
          <target state="translated">따라서 &lt;strike&gt;&lt;em&gt;&quot;참조 / 값으로&lt;/em&gt;&lt;/strike&gt; 전달&quot;은 다음과 같은 이유로 &quot;참조 / 값으로 전달&quot;에 매달리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="68d38550c4da9fcceac584158479a156958fb538" translate="yes" xml:space="preserve">
          <source>Some final comments:</source>
          <target state="translated">마지막 의견 :</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="26220bb61f95026a6699bda5f772ab5f459fb7d2" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00317f5e100f735c8f89f41e078aacbee58460d5" translate="yes" xml:space="preserve">
          <source>Strings are immutable, so it doesn't really matter for them.</source>
          <target state="translated">문자열은 변경할 수 없으므로 실제로 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0020398180c05f3b9f05227c429a1215e0aae80" translate="yes" xml:space="preserve">
          <source>Take these examples.</source>
          <target state="translated">이 예제들을 보자.</target>
        </trans-unit>
        <trans-unit id="96016a84f6ccaa21c0ff5eb49c88180b5839dbb7" translate="yes" xml:space="preserve">
          <source>That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.</source>
          <target state="translated">즉, 매개 변수 값 자체에 액세스하면 매개 변수 참조를 변경할 수 있습니다. 반면, 평가 후 매개 변수에 대한 지정은 사라지고 함수 호출자는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e9b208745c0adc4ae130578652525c2f81da6a0" translate="yes" xml:space="preserve">
          <source>That's why when you try to change an object inside a function, by replacing it's value (i.e. &lt;code&gt;age = {value:5}&lt;/code&gt;), the change doesn't persist, but if you change it's properties (i.e. &lt;code&gt;age.value = 5&lt;/code&gt;), it does.</source>
          <target state="translated">그렇기 때문에 함수 내에서 객체 값을 바꾸려고 할 때 (예 : &lt;code&gt;age = {value:5}&lt;/code&gt; ) 변경 사항이 유지되지 않지만 속성을 변경하면 (예 : &lt;code&gt;age.value = 5&lt;/code&gt; ), 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="ff449e061e42e079c42808abf8dc5c78475c9c12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;age&lt;/code&gt; is a reference to &lt;code&gt;myAge&lt;/code&gt;, but if you want the value you have to convert the reference, using &lt;code&gt;*age&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;age&lt;/code&gt; 는 &lt;code&gt;myAge&lt;/code&gt; 에 대한 참조이지만 값을 원하면 &lt;code&gt;*age&lt;/code&gt; 를 사용하여 참조를 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cfb912d780ddf9573a7ca91bac5773da514df0e" translate="yes" xml:space="preserve">
          <source>The JavaScript engine assigns the object to the variable &lt;code&gt;c&lt;/code&gt;, and it points to some memory, say (0x012).</source>
          <target state="translated">JavaScript 엔진은 객체를 변수 &lt;code&gt;c&lt;/code&gt; 에 할당하고 (0x012)와 같은 일부 메모리를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="54327c1b59eda63c1878391f14ad9c7f807364da" translate="yes" xml:space="preserve">
          <source>The MDN docs explain it clearly, without being too verbose:</source>
          <target state="translated">MDN 문서는 너무 자세하지 않고 명확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="131abb827464b85b18ae518074aac50427c4fc92" translate="yes" xml:space="preserve">
          <source>The equal(=) operator sets up new memory space or address</source>
          <target state="translated">equal (=) 연산자는 새로운 메모리 공간 또는 주소를 설정합니다</target>
        </trans-unit>
        <trans-unit id="ebfa1ea7372d6f23abc337f70c4f4df97d8a30cd" translate="yes" xml:space="preserve">
          <source>The most succinct explanation I found was in the &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB style guide&lt;/a&gt;:</source>
          <target state="translated">내가 찾은 가장 간결한 설명은 &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB 스타일 가이드에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3d021afb081241b899877ae82ca0e06ab382f15" translate="yes" xml:space="preserve">
          <source>The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)</source>
          <target state="translated">함수에 전달하는 변수의 이름이 함수 매개 변수의 이름과 같은 경우가 유일한 문제입니다. 이 경우 함수 내부의 매개 변수를 함수 전용의 완전히 새로운 변수 인 것처럼 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e351bcd6c54bf11efb568e95ee714a771482cbd" translate="yes" xml:space="preserve">
          <source>The only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven't modified the variable, but the object itself.</source>
          <target state="translated">&quot;변수 수정&quot;이 다른 변수에 영향을 미치는 유일한 시간은 기본 개체가 변경되는 경우입니다 (이 경우 변수를 수정하지 않고 개체 자체).</target>
        </trans-unit>
        <trans-unit id="e117feea80f4052240b302d90852bffb9002a69f" translate="yes" xml:space="preserve">
          <source>The parameters of a function call are the function's &lt;em&gt;arguments&lt;/em&gt;.
  Arguments are passed to functions &lt;em&gt;by value&lt;/em&gt;. If the function changes
  the value of an argument, this change is not reflected globally or in
  the calling function. However, object references are values, too, and
  they are special: if the function changes the referred object's
  properties, that change is visible outside the function, (...)</source>
          <target state="translated">함수 호출의 매개 변수는 함수의 &lt;em&gt;인수&lt;/em&gt; 입니다. 인수는 &lt;em&gt;value별로&lt;/em&gt; 함수 &lt;em&gt;에&lt;/em&gt; 전달됩니다. 함수가 인수의 값을 변경하면이 변경 사항이 전체적으로 또는 호출 함수에 반영되지 않습니다. 그러나 객체 참조도 값이며 특수합니다. 함수가 참조 된 객체의 속성을 변경하면 해당 변경 내용은 함수 외부에서 볼 수 있습니다 (...)</target>
        </trans-unit>
        <trans-unit id="df2fd245eb7826b794aeb3d9f1b7a4aa9ba6448f" translate="yes" xml:space="preserve">
          <source>The phrase &quot;pass by
  reference&quot; can have several meanings.
  To some readers, the phrase refers to
  a function invocation technique that
  allows a function to assign new values
  to its arguments and to have those
  modified values visible outside the
  function. This is not the way the term
  is used in this book.</source>
          <target state="translated">문구 &quot;통과 기준&quot;은 여러 가지 의미를 가질 수 있습니다. 일부 독자에게이 문구는 함수가 새로운 값을 인수에 할당하고 수정 된 값을 함수 외부에서 볼 수 있도록하는 함수 호출 기술을 말합니다. 이것은이 책에서 용어가 사용되는 방식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="40424125880f7bec8d7f9e5602a94c76e97cd1cc" translate="yes" xml:space="preserve">
          <source>The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).</source>
          <target state="translated">기본 유형 (숫자, 문자열 등)은 값으로 전달되지만 값을 통해 전달 될 수 있기 때문에 객체를 알 수 없습니다 (객체를 보유한 변수가 실제로 객체를 참조하는 것으로 간주하는 경우) ) 및 참조로 전달 (객체에 대한 변수가 객체 자체를 보유하고 있다고 생각할 때).</target>
        </trans-unit>
        <trans-unit id="8fbaf791a543ee22f0fd296541edf5a1bfa479b1" translate="yes" xml:space="preserve">
          <source>The production ArgumentList : AssignmentExpression is evaluated as follows:</source>
          <target state="translated">프로덕션 ArgumentList : AssignmentExpression은 다음과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ecee46c34e5a0a1af1170066ea3f9a92c40b9de1" translate="yes" xml:space="preserve">
          <source>The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</source>
          <target state="translated">프로덕션 MemberExpression : MemberExpression [Expression]은 다음과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="e64cfc5706b868b32b799d93138e5cd834b8bce0" translate="yes" xml:space="preserve">
          <source>The section also enumerate cases where argument list has 0 or &amp;gt;1 arguments.</source>
          <target state="translated">이 섹션은 인수 목록에 0 또는&amp;gt; 1 개의 인수가있는 경우도 열거합니다.</target>
        </trans-unit>
        <trans-unit id="dbf3ebd42f5ddf6e8a07546545a97d0d73e8f740" translate="yes" xml:space="preserve">
          <source>The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren't visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller's scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned &amp;mdash; it is shared.</source>
          <target state="translated">공유에 의한 호출의 의미는 함수 내의 함수 인수에 대한 할당이 (참조 의미론과 달리) 호출자에게 표시되지 않는다는 점에서 참조에 의한 호출과 다릅니다. 예를 들어 변수가 전달되면 불가능합니다. 호출자의 범위에서 해당 변수에 대한 할당을 시뮬레이션합니다. 그러나 함수가 호출자와 동일한 오브젝트에 액세스 할 수 있으므로 (복사되지 않음), 오브젝트가 변경 가능한 경우 함수 내에서 호출자가 볼 수 있으며, 이는 값에 의한 호출과 다를 수 있습니다. 의미론. 함수 내에서 변경 가능한 객체의 돌연변이는 객체가 복사 또는 복제되지 않기 때문에 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4316acc1d74e70023ca752c79e9fc23bbbea3d" translate="yes" xml:space="preserve">
          <source>The terms are only used to describe the &lt;em&gt;behavior&lt;/em&gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn't adequately describe the actual behavior and supplementary info has to be provided</source>
          <target state="translated">이 용어는 언어의 &lt;em&gt;동작&lt;/em&gt; 을 설명하는 데만 사용되며 실제 실제 구현은 아닙니다. 이러한 추상화의 결과로, 적절한 설명에 필수적인 중요한 세부 사항이 손실되며, 이는 단일 용어가 실제 행동을 적절하게 설명하지 못하고 추가 정보를 제공해야하는 현재 상황으로 이어질 수밖에 없습니다</target>
        </trans-unit>
        <trans-unit id="626d24ad73a240837e037855870f41fe70cd5f31" translate="yes" xml:space="preserve">
          <source>The variable doesn't &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It's always pass by value (even when that value is a reference...).</source>
          <target state="translated">변수는 객체를 &quot;보유&quot;하지 않습니다. 참조를 보유합니다. 해당 참조를 다른 변수에 할당 할 수 있으며 이제 둘 다 동일한 객체를 참조합니다. 항상 값으로 전달됩니다 (값이 참조 일 때도).</target>
        </trans-unit>
        <trans-unit id="dca56569992ce2b50c87910c0d7c7c9858ba2c6f" translate="yes" xml:space="preserve">
          <source>There is no &quot;pass by reference&quot; available in JavaScript.</source>
          <target state="translated">JavaScript에는 &quot;참조로 전달&quot;이 없습니다.</target>
        </trans-unit>
        <trans-unit id="361031a3f3abf898ac288ca94af4b04c26e7d902" translate="yes" xml:space="preserve">
          <source>There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn't have a function and just used the equal sign to assign to a new variable.</source>
          <target state="translated">객체와 프리미티브를 구별 할 필요는 없습니다. 왜냐하면 함수가없는 것과 같은 방식으로 작동하고 등호를 사용하여 새 변수에 할당했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1aa166014dcdcbcff2f5f9b82565c5b3c2e956bf" translate="yes" xml:space="preserve">
          <source>There's no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.</source>
          <target state="translated">매개 변수로 전달 된 변수가 보유한 값을 변경할 방법이 없습니다. JavaScript가 참조로 전달을 지원하는 경우 가능합니다.</target>
        </trans-unit>
        <trans-unit id="010934035b63fc110de9e084961250609ba49e08" translate="yes" xml:space="preserve">
          <source>There's some discussion about the use of the term &quot;pass by reference&quot; in JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;here&lt;/a&gt;, but to answer your question:</source>
          <target state="translated">JavaScript에서 &quot;pass by reference&quot;라는 용어를 사용하는 방법에 대한 토론이 있지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;여기&lt;/a&gt; 에 귀하의 질문에 대한 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3971268996a99a5df86f39832ec5539e7dd9d70" translate="yes" xml:space="preserve">
          <source>These concepts were not originally defined with the intent of describing javascript in particular and so I don't feel compelled to use them when they only add to the confusion.</source>
          <target state="translated">이 개념은 원래 자바 스크립트를 설명하려는 의도로 정의되지 않았으므로 혼란에 빠질 때 사용하도록 강요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e16663c0ae48f1219b8db33d73a88db1512811fc" translate="yes" xml:space="preserve">
          <source>Think of it like this: It's always pass by value. However, the value of an object is not the object itself, but a reference to that object.</source>
          <target state="translated">이것을 다음과 같이 생각하십시오 : 그것은 항상 가치를 지니고 있습니다. 그러나 객체의 값은 객체 자체가 아니라 해당 객체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="705df426723dfd9a58e61806d528e760b06fe084" translate="yes" xml:space="preserve">
          <source>This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.</source>
          <target state="translated">값으로 전달 및 참조로 전달 (JavaScript)에 대한 자세한 설명입니다. 이 개념에서는 변수를 참조로 전달하고 변수를 참조로 전달하는 것에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="3f9efc65382f339c71ef4d14543d364c027db24a" translate="yes" xml:space="preserve">
          <source>This produces the output:</source>
          <target state="translated">출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a1116d28bfe37e6545e3ebc5bd2c217059edabe0" translate="yes" xml:space="preserve">
          <source>Thus, everything's are passed by reference.</source>
          <target state="translated">따라서 모든 것이 참조로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3678321f62ae967b6f938900843022091b6a3c1b" translate="yes" xml:space="preserve">
          <source>Thus, properties of Objects are always available as reference.</source>
          <target state="translated">따라서 객체의 속성은 항상 참조로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0821fb327f2753fc69a24f9f6c10a0a8791e18c7" translate="yes" xml:space="preserve">
          <source>To answer your question: pointers are passed.</source>
          <target state="translated">귀하의 질문에 대답하기 위해 : 포인터가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7bbe358444a139cd8eb2208023bd472900f08800" translate="yes" xml:space="preserve">
          <source>To effectively pass a compound value (like an &lt;code&gt;array&lt;/code&gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</source>
          <target state="translated">값 복사로 복합 값 (예 : &lt;code&gt;array&lt;/code&gt; )을 효과적으로 전달하려면 전달 된 참조가 여전히 원본을 가리 키지 않도록 수동으로 사본을 작성해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1abf81928ceac0fa096e0f4f2795b3ee7f8da32" translate="yes" xml:space="preserve">
          <source>Uh oh.... What has happened. We couldn't change string1 by changing favoriteString... Why?? Because we didn't &lt;em&gt;change&lt;/em&gt; our string &lt;em&gt;object&lt;/em&gt;. All we did was &quot;RE ASSIGN&quot; the favoriteString &lt;em&gt;variable&lt;/em&gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn't assign anything. (Well, not to the &lt;em&gt;variable itself&lt;/em&gt;, ... we did, however, assign the name property to a new string.) Instead, we simply mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or &lt;em&gt;mutate&lt;/em&gt; the string object &lt;em&gt;itself&lt;/em&gt;, we couldn't have, because strings are actually immutable in JavaScript.)</source>
          <target state="translated">어 .. 무슨 일이야. favoriteString을 변경하여 string1을 변경할 수 없습니다 ... 왜 ?? 문자열 &lt;em&gt;객체를&lt;/em&gt; &lt;em&gt;변경&lt;/em&gt; 하지 않았기 때문입니다. 우리가 한 것은 favoriteString &lt;em&gt;변수&lt;/em&gt; 를 새 문자열에 &quot;RE ASSIGN&quot;하는 것뿐입니다. 이것은 본질적으로 string1에서 연결을 끊었습니다. 이전 예제에서 객체의 이름을 바꿀 때 아무 것도 할당하지 않았습니다. ( &lt;em&gt;변수 자체가 아니라&lt;/em&gt; , name 속성을 새 문자열에 할당했습니다.) 대신, 단순히 2 개의 변수와 기본 개체 사이의 연결을 유지하는 개체를 변경했습니다. (문자열 객체 &lt;em&gt;자체&lt;/em&gt; 를 수정하거나 &lt;em&gt;변경&lt;/em&gt; 하고 싶더라도 문자열은 실제로 JavaScript에서 변경할 수 없기 때문에 가질 수 없었습니다.)</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="ad44083b5ca9c555d81d716126062a61d9fc5f75" translate="yes" xml:space="preserve">
          <source>Variables are &lt;em&gt;pointers&lt;/em&gt; to values in memory.</source>
          <target state="translated">변수는 메모리의 값을 &lt;em&gt;가리키는 포인터&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="678a462c2bd82f3f082479b480f76e063a36fb4b" translate="yes" xml:space="preserve">
          <source>What we have done is &quot;assignment&quot;... We've assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.</source>
          <target state="translated">우리가 한 것은 &quot;할당&quot;입니다. 우리는 변수 &quot;object1&quot;과 &quot;object2&quot;에 2 개의 별개의 빈 객체를 할당했습니다.</target>
        </trans-unit>
        <trans-unit id="84d66e6463f366bb3793d71142052ebf0b3271b4" translate="yes" xml:space="preserve">
          <source>When calling a function, you are passing the content (reference or
value) of the argument variables, not the the variables themselves.</source>
          <target state="translated">함수를 호출 할 때 변수 자체가 아닌 인수 변수의 내용 (참조 또는 값)을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b675d8ab55a62fa7342693de178ca61efdefdab7" translate="yes" xml:space="preserve">
          <source>When d=c, in this step &lt;code&gt;d&lt;/code&gt; points to the same location (0x012).</source>
          <target state="translated">d = c 인 경우,이 단계에서 &lt;code&gt;d&lt;/code&gt; 는 동일한 위치 (0x012)를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="6603f9e15352ae782eb9dbf4dc53a8cacea1f46d" translate="yes" xml:space="preserve">
          <source>When we make the assignment &lt;code&gt;b = [4,5,6]&lt;/code&gt;, we are doing absolutely nothing to affect where &lt;code&gt;a&lt;/code&gt; is still referencing (&lt;code&gt;[1,2,3]&lt;/code&gt;). To do that, &lt;code&gt;b&lt;/code&gt; would have to be a pointer to &lt;code&gt;a&lt;/code&gt; rather than a reference to the &lt;code&gt;array&lt;/code&gt; -- but no such capability exists in JS!</source>
          <target state="translated">&lt;code&gt;b = [4,5,6]&lt;/code&gt; 대입하면 &lt;code&gt;a&lt;/code&gt; 가 여전히 참조하는 위치 ( &lt;code&gt;[1,2,3]&lt;/code&gt; )에 영향을 미치지 않습니다. 그렇게하려면 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;array&lt;/code&gt; 대한 참조가 아니라 a에 대한 포인터 여야하지만 JS에는 그러한 기능이 없습니다!</target>
        </trans-unit>
        <trans-unit id="13f9dc2555da1b44daf4195c85cac47042d3a3a1" translate="yes" xml:space="preserve">
          <source>When we pass in the argument &lt;code&gt;a&lt;/code&gt;, it assigns a copy of the &lt;code&gt;a&lt;/code&gt; reference to &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are separate references pointing at the same &lt;code&gt;[1,2,3]&lt;/code&gt; value. Now, inside the function, we can use that reference to mutate the value itself (&lt;code&gt;push(4)&lt;/code&gt;). But when we make the assignment &lt;code&gt;x = [4,5,6]&lt;/code&gt;, this is in no way affecting where the initial reference &lt;code&gt;a&lt;/code&gt; is pointing -- still points at the (now modified) &lt;code&gt;[1,2,3,4]&lt;/code&gt; value.</source>
          <target state="translated">인수 &lt;code&gt;a&lt;/code&gt; 를 전달 &lt;code&gt;a&lt;/code&gt; 참조 사본을 &lt;code&gt;x&lt;/code&gt; 에 할당합니다. &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 는 동일한 &lt;code&gt;[1,2,3]&lt;/code&gt; 값을 가리키는 별도의 참조입니다. 이제 함수 내에서 해당 참조를 사용하여 값 자체를 변경할 수 있습니다 ( &lt;code&gt;push(4)&lt;/code&gt; ). 그러나 우리가 &lt;code&gt;x = [4,5,6]&lt;/code&gt; 할당 할 때 이것은 초기 참조 &lt;code&gt;a&lt;/code&gt; 가 가리키는 위치에 영향을 미치지 않으며 여전히 (현재 수정 된) &lt;code&gt;[1,2,3,4]&lt;/code&gt; 값을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="dc1b4ec703eec5dfe10344c61e1e765e58682a65" translate="yes" xml:space="preserve">
          <source>When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else.</source>
          <target state="translated">해당 참조를 사용하여 객체를 조작하면 외부 객체가 영향을받습니다. 그러나 함수 내부에서 다른 것에 대한 참조를 가리 키기로 결정한 경우에는 외부에있는 객체에 전혀 영향을 미치지 않았습니다. 왜냐하면 다른 모든 것에 대한 참조를 리디렉션하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a5f72cf83865e4414b2e92fe68d2f91039221270" translate="yes" xml:space="preserve">
          <source>a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).</source>
          <target state="translated">a는 메모리 (0x001)에 할당되고 b는 메모리 (0x002)에 값의 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ba35e803347ae1a6fbb922bb822df3c9557c5075" translate="yes" xml:space="preserve">
          <source>a very confusing situation is where you can't realize how your referenced variable changes, let's take a look at a very good example:</source>
          <target state="translated">매우 혼란스러운 상황은 참조 된 변수가 어떻게 변경되는지 알 수없는 곳입니다. 아주 좋은 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1a91322ba3053b9c0d30aeec04a7ec7d757a54ad" translate="yes" xml:space="preserve">
          <source>and in a more complicated story:</source>
          <target state="translated">더 복잡한 이야기에서 :</target>
        </trans-unit>
        <trans-unit id="dbe8beff245d88e0093cd5bdb6c0a20809a330d5" translate="yes" xml:space="preserve">
          <source>applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).</source>
          <target state="translated">JavaScript의 모든 기본 유형 (문자열, 숫자, 부울, 정의되지 않은 및 널)에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4e4aeb4d95583c62381700ab3cfbd849ddf35b64" translate="yes" xml:space="preserve">
          <source>but we cant do the same thing with the purple arrow, we may want to move 'john' cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...</source>
          <target state="translated">그러나 우리는 자주색 화살표로 같은 일을 할 수 없습니다. 우리는 'john'셀을 여기 또는 다른 많은 것들로 옮기고 싶을 수도 있습니다. ...</target>
        </trans-unit>
        <trans-unit id="e4cf40496f043253f0d64368904b930d9b69c16d" translate="yes" xml:space="preserve">
          <source>every type2-value (green) is a &lt;strong&gt;single square&lt;/strong&gt; while a type1-value (blue) is a &lt;strong&gt;group of them&lt;/strong&gt;:</source>
          <target state="translated">모든 type2 값 (녹색)은 &lt;strong&gt;단일 사각형이고&lt;/strong&gt; type1 값 (파란색)은 그 &lt;strong&gt;그룹입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="dd74f54fdfe237acc828874dddffdcfc48e8abc5" translate="yes" xml:space="preserve">
          <source>here you are assigning new object or array to old one.you are not changing the value of property 
of old object.so it is pass by value.</source>
          <target state="translated">여기에서 새 객체 또는 배열을 이전 객체에 할당합니다. 오래된 객체의 속성 값을 변경하지 않으므로 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a20f2e836503b1a3b14f37b2c5bd01437f59d8f4" translate="yes" xml:space="preserve">
          <source>here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.</source>
          <target state="translated">여기서는 오래된 객체의 속성 값을 변경합니다. 이전 객체에 새 객체 또는 배열을 할당하지 않으므로 참조로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="53ff18bfd84d263fea5d0d0003eebc0c7a27a864" translate="yes" xml:space="preserve">
          <source>if you are changing a property value of an object or array then it is pass by Reference.</source>
          <target state="translated">객체 또는 배열의 속성 값을 변경하는 경우 참조를 통해 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3e6856e162be438b0b1b28e9475c58786691c0c2" translate="yes" xml:space="preserve">
          <source>if you are changing value of that Object or array with new Object or Array then it is pass by Value.</source>
          <target state="translated">새로운 Object 또는 Array를 사용하여 해당 Object 또는 Array의 값을 변경하면 Value를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="37fb1667392900bb5ef5037dd0e0b507e63dc8dd" translate="yes" xml:space="preserve">
          <source>if you imagine memory as below squares which in every one of them just one type2-value can be saved:</source>
          <target state="translated">메모리를 아래 사각형으로 생각하면 각각 하나의 type2 값만 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ec615b08c0e036b2bca13e54163fa4149fab8d" translate="yes" xml:space="preserve">
          <source>in javascript we can put values in two layer: &lt;strong&gt;type1&lt;/strong&gt;-&lt;code&gt;objects&lt;/code&gt; and &lt;strong&gt;type2&lt;/strong&gt;-all other types of value such as &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</source>
          <target state="translated">자바 스크립트에서 우리는 &lt;strong&gt;type1&lt;/strong&gt; - &lt;code&gt;objects&lt;/code&gt; 와 &lt;strong&gt;type2&lt;/strong&gt; - &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc와 같은 다른 모든 유형의 값을 두 계층에 넣을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="53b0a1b2fadf4e040cdc2155a7340de24aca93cb" translate="yes" xml:space="preserve">
          <source>number</source>
          <target state="translated">number</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="f0f7f39ec7e62249ee81dac2c3f1b3586a4fd52e" translate="yes" xml:space="preserve">
          <source>objects</source>
          <target state="translated">objects</target>
        </trans-unit>
        <trans-unit id="43c608c48ee77ebcf1192df657480116bb88d93b" translate="yes" xml:space="preserve">
          <source>primitive type variable like string,number are always pass as  pass
by value.</source>
          <target state="translated">문자열, 숫자와 같은 기본 유형 변수는 항상 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0366c73137f63703a81f4390aa8afe89322b7310" translate="yes" xml:space="preserve">
          <source>sharing what I know of references in JavaScript</source>
          <target state="translated">JavaScript에서 내가 알고있는 것을 공유</target>
        </trans-unit>
        <trans-unit id="340b6603b7ec42319770e6733e4f6bacbc9b29bb" translate="yes" xml:space="preserve">
          <source>so here &lt;strong&gt;references&lt;/strong&gt; can rescue us:</source>
          <target state="translated">그래서 여기 &lt;strong&gt;참조&lt;/strong&gt; 는 우리를 구출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="bffc56aa90003a62e1312aa3131fb673e4b8fa39" translate="yes" xml:space="preserve">
          <source>symbol in &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; 의 기호</target>
        </trans-unit>
        <trans-unit id="1a6bbba542e8dfa1abb5d45893298c0eb2f0d406" translate="yes" xml:space="preserve">
          <source>the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that's not easy at all! :</source>
          <target state="translated">요점은 type2 값을 나타내려면 주소가 명확하지만 type1 값에 대해 동일한 작업을 수행하려는 경우 전혀 쉽지 않다는 것입니다. :</target>
        </trans-unit>
        <trans-unit id="d5d4cd07616a542891b7ec2d0257b3a24b69856e" translate="yes" xml:space="preserve">
          <source>undefined</source>
          <target state="translated">undefined</target>
        </trans-unit>
        <trans-unit id="c097133877b58bb1a18daa1d045149700ebbbf11" translate="yes" xml:space="preserve">
          <source>well, it's about 'performance' and 'speed' and in the simple word 'memory management' in a programming language.</source>
          <target state="translated">글쎄, 그것은 '성능'과 '속도'에 관한 것이고 프로그래밍 언어에서 간단한 단어 '메모리 관리'에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ba026f489ec792196a7e8a5a6ac751fc3641db1" translate="yes" xml:space="preserve">
          <source>while the green arrow here is a typical variable, the purple one is an object variable, so &lt;strong&gt;because the green arrow(typical variable) has just one task&lt;/strong&gt; (and that is indicating a typical value) we don't need to separate it's value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...</source>
          <target state="translated">여기서 녹색 화살표는 일반적인 변수이지만 자주색 변수는 객체 변수이므로 &lt;strong&gt;녹색 화살표 (일반 변수)에는 작업이 하나뿐&lt;/strong&gt; 이므로 (일반적인 값을 나타냄) 값을 구분할 필요가 없습니다. 그것은 우리가가는 곳마다 그리고 모든 할당, 기능 등에서 녹색 화살표를 그 값으로 움직입니다 ...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
