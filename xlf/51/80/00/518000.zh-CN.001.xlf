<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/518000">
    <body>
      <group id="518000">
        <trans-unit id="1dee29437206aa2b90705d515faaafcb0add50ca" translate="yes" xml:space="preserve">
          <source>&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;Which programming languages are pass by reference?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;-Brian Bi-&lt;/a&gt; &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;哪些编程语言通过引用传递？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07698e10df4dd98b0bf399ab50011ce57e452623" translate="yes" xml:space="preserve">
          <source>(From the article mentioned above.)</source>
          <target state="translated">(摘自上述文章)。</target>
        </trans-unit>
        <trans-unit id="edeb4423fd301ceb5f86fc44d38b40f3c9ba6fa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Return a value of type Reference&lt;/b&gt; whose base value is baseValue and whose referenced name is
  propertyNameString, and whose strict mode flag is strict.</source>
          <target state="translated">&lt;b&gt;返回类型为Reference&lt;/b&gt;的&lt;b&gt;值，&lt;/b&gt;其基值为baseValue，其引用名称为propertyNameString，其strict模式标志为strict。</target>
        </trans-unit>
        <trans-unit id="d0d476f54a71b8ac89e5d06ddffbeccc263797e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TL;DR&lt;/b&gt;: Everythings're passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.</source>
          <target state="translated">&lt;b&gt;TL; DR&lt;/b&gt; ：一切都是通过值传递的，但是Objects的属性是引用，并且标准中非常缺少Object的定义。</target>
        </trans-unit>
        <trans-unit id="5cc31de26a91a7607db07fbc10e5bdca64ddd6b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compound values are always assigned/passed by reference-copy&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;复合值始终由参考副本分配/传递&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b825d8d1882d46055d101f87ec20d9423ddb0d0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function arguments and parameters are not the same thing.  Also, a variable's value is not the variable's object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;函数参数和参数不是一回事。&lt;/em&gt; &lt;em&gt;同样，变量的值也不是变量的对象（正如各种人已经指出的那样，但是显然被忽略了）。&lt;/em&gt; &lt;em&gt;这些区别对于正确理解至关重要。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dec8a494f102cfe95fa805f288c3d04ee0a6b711" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Primitive values are always assigned/passed by value-copy&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;原始值始终由value-copy分配/传递&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="207d1e3b4f674510d97d07b156c4c5ee3a4de294" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because in JavaScript, it doesn't matter whether it's passed by value or by reference or whatever.
What matters is mutation vs assignment of the parameters passed into a function.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;因为在JavaScript中，按值，按引用或其他方式传递都无关紧要。&lt;/strong&gt; &lt;strong&gt;重要的是传递给函数的参数的变异与赋值。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a42287a91a97e2c4e1094a867ae8805599745087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt;:  The function argument's value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object's data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.</source>
          <target state="translated">&lt;strong&gt;调用/传递引用&lt;/strong&gt; ：可以/将通过相应的函数参数直接更新函数参数的值。 如果有帮助，函数参数将成为该参数的有效&amp;ldquo;别名&amp;rdquo;-它们有效地引用了相同内存位置处的相同值。 如果函数参数是对象变量，则更改对象数据的能力与传递值的情况没有区别，因为函数参数仍将指向与参数相同的对象。 但是在对象变量的情况下，如果将功能参数设置为完全不同的对象，则参数同样会指向不同的对象，这在传递值的情况下不会发生。</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c12cc2e2533791936e57d4b9415ab42ea32e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex&lt;/strong&gt;: When you access a complex type you work on a reference to its value</source>
          <target state="translated">&lt;strong&gt;复杂&lt;/strong&gt; ：访问复杂类型时，需要引用其值</target>
        </trans-unit>
        <trans-unit id="1301250d5301f648cf05701bd59197e854b822ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;: Variable outside the function which is passed to the function by the caller.</source>
          <target state="translated">&lt;strong&gt;函数参数&lt;/strong&gt; ：函数外部的变量，由调用者传递给函数。</target>
        </trans-unit>
        <trans-unit id="65492a390eb86ea3356e64d01cfaa27d6c3fab3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function parameter&lt;/strong&gt;:  Variable declared in a function definition, used for referencing variables passed to the function.</source>
          <target state="translated">&lt;strong&gt;函数参数&lt;/strong&gt; ：在函数定义中声明的变量，用于引用传递给函数的变量。</target>
        </trans-unit>
        <trans-unit id="65a6814d6b676f546b18918b30e471d0b5236d77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Memory location&lt;/strong&gt;:  Where a variable's value is stored.  (The location itself is represented by a number separate from the value stored at the location.)</source>
          <target state="translated">&lt;strong&gt;内存位置&lt;/strong&gt; ：存储变量值的位置。 （位置本身由与该位置存储的值分开的数字表示。）</target>
        </trans-unit>
        <trans-unit id="5996d89441c8d0e61fe5412acbb5b6378fb43e74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object clone/copy&lt;/strong&gt;: A new object is created and the original object's data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.</source>
          <target state="translated">&lt;strong&gt;对象克隆/复制&lt;/strong&gt; ：创建一个新对象，并复制原始对象的数据。 这可以是深层副本，也可以是浅层副本，但要点是要创建一个新对象。 创建对象的副本是与值传递不同的概念。 一些语言区分类对象和结构（或类似结构），并且对于传递不同类型的变量可能具有不同的行为。 但是，在传递对象变量时，JavaScript不会自动执行此类操作。 但是缺少自动对象克隆功能并不能转换为按引用传递。</target>
        </trans-unit>
        <trans-unit id="fa53139221548e1fd770ad7abe04c1dc6d698150" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object variable&lt;/strong&gt;:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object's actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.</source>
          <target state="translated">&lt;strong&gt;对象变量&lt;/strong&gt; ：其基本基础值不是&amp;ldquo;对象&amp;rdquo;本身的变量，而是其值是指向内存中存储对象实际数据的另一个位置的指针（内存位置值）。 在大多数高级语言中，&amp;ldquo;指针&amp;rdquo;方面通过在各种情况下自动取消引用而有效地隐藏了。</target>
        </trans-unit>
        <trans-unit id="d880bbb046dd0fb8ed275862bb6d9eb727b33d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通过引用传递（对象）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab95d2eb7f10fa0819e1bef83f4bd83e6ae79ba7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value (primitive type)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;按值传递（原始类型）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d87f3236c9b7ff2b627b66d6a54c489872ad459f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass-by-value or Call-by-sharing (for objects)&lt;/strong&gt;:  The function argument's value is COPIED to another memory location which is referenced by the function's parameter symbol (regardless of whether it's on the stack or heap).  In other words, the function parameter received a copy of the passed argument's value... AND (critical) the argument's value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable's value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter's value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument's value IS NEVER UPDATED, so it will continue to point to the &lt;em&gt;same&lt;/em&gt; object throughout and even after the function call (even if its object's data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.</source>
          <target state="translated">&lt;strong&gt;传递值或共享调用（对于对象）&lt;/strong&gt; ：函数参数的值被复制到另一个存储位置，该位置由函数的参数符号引用（无论它在堆栈还是堆上）。 换句话说，函数参数接收到传递的参数值的副本...并且（关键）参数的值不会被调用函数更新/更改/更改。 请记住，对象变量的值不是对象本身，而是对象的指针，因此按值传递对象变量会将指针复制到函数参数变量。 函数参数的值指向内存中完全相同的对象。 对象数据本身可以通过function参数直接更改，但是function参数的值是NEVER UPDATED，因此即使在函数调用之后，即使在对象调用后，它也将继续指向&lt;em&gt;同一&lt;/em&gt;对象（即使对象的数据已更改或功能参数一共分配了一个不同的对象）。 仅仅因为所引用的对象可通过功能参数变量进行更新而得出结论，认为函数参数是通过引用传递的，这是不正确的。</target>
        </trans-unit>
        <trans-unit id="3daa908ef93ef3beddf5ee815280e35804b2ab50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitive variable&lt;/strong&gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable's value IS the actual value represented by the variable's symbol rather than a pointer to another memory location.</source>
          <target state="translated">&lt;strong&gt;原始变量&lt;/strong&gt; ：其值为实际值的变量。 即使自动装箱和各种语言的类对象上下文也可能使此概念变得复杂，但是总体思路是，变量的值是由变量的符号表示的实际值，而不是指向另一个内存位置的指针。</target>
        </trans-unit>
        <trans-unit id="738f561981f804bed95647891f285ca2a07e0ffc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitives&lt;/strong&gt;: When you access a primitive type you work directly on its
value</source>
          <target state="translated">&lt;strong&gt;基元&lt;/strong&gt; ：访问基元类型时，可以直接使用其值</target>
        </trans-unit>
        <trans-unit id="f1d08a4ffaed6d05dab4d5131e21bf7f0ad7cc25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special case, pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;特殊情况，通过引用传递（对象）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d30d6d093711f7dc4bbd3b5d3e73777eb88a76b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symbol&lt;/strong&gt;:  Text string used to refer to variable (i.e. variable's name).</source>
          <target state="translated">&lt;strong&gt;符号&lt;/strong&gt; ：用于引用变量的文本字符串（即变量的名称）。</target>
        </trans-unit>
        <trans-unit id="dbb628f544b2f5b04bb5df870aacd2b707683b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;:  Particular bits stored in memory and referenced using variable's symbol.</source>
          <target state="translated">&lt;strong&gt;值&lt;/strong&gt; ：存储在存储器中的特定位，并使用变量的符号进行引用。</target>
        </trans-unit>
        <trans-unit id="4a4a44d5c5dbc605d366445b9f5e39a3dbd71772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variable&lt;/strong&gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.</source>
          <target state="translated">&lt;strong&gt;变量&lt;/strong&gt; ：符号的组合概念，它引用内存中特定位置的值。 这个术语通常过于繁琐，无法在讨论细节时单独使用。</target>
        </trans-unit>
        <trans-unit id="5a8e1fdd316d10b0c0cd59d94a6940772041c1cd" translate="yes" xml:space="preserve">
          <source>A object is automatically passed by reference, without the need to specifically state it</source>
          <target state="translated">对象是通过引用自动传递的,不需要特别声明它</target>
        </trans-unit>
        <trans-unit id="b440a38266bd3bd8023694ca76f1853cb56c68f1" translate="yes" xml:space="preserve">
          <source>A primitive value passed to a function cannot be modified by the function. A copy is made.</source>
          <target state="translated">传给函数的基元值不能被函数修改。会被复制。</target>
        </trans-unit>
        <trans-unit id="79ce62763f1e30b37f20149148f8548734cf61b5" translate="yes" xml:space="preserve">
          <source>A very detailed explanation about copying, passing and comparing by value and by reference is in &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;this chapter&lt;/a&gt; of the &lt;em&gt;&quot;JavaScript: The Definitive Guide&quot;&lt;/em&gt; book.</source>
          <target state="translated">在&lt;em&gt;&amp;ldquo; JavaScript：权威指南&amp;rdquo;&lt;/em&gt;一书的&lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;这一章中&lt;/a&gt; ，有关于按值复制和传递以及比较的非常详细的解释。</target>
        </trans-unit>
        <trans-unit id="f9d35a2aa876badcd3c415f65100051e77924dd6" translate="yes" xml:space="preserve">
          <source>Access of Object Properties</source>
          <target state="translated">对象属性的访问</target>
        </trans-unit>
        <trans-unit id="3e9807bf09a22721f2ffa94b835d05c65938f14a" translate="yes" xml:space="preserve">
          <source>Again, we pick a favorite.</source>
          <target state="translated">还是那句话,我们选一个最喜欢的。</target>
        </trans-unit>
        <trans-unit id="988045fdd90b44521a9b2b9c55dfe875b6ad44e6" translate="yes" xml:space="preserve">
          <source>Although it doesn't really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?</source>
          <target state="translated">虽然最后并不重要,但我想知道正确的方法是什么?是否有JavaScript规范中的摘录,定义了相关的语义?</target>
        </trans-unit>
        <trans-unit id="96ef530acd2543eafd4ab0cb7e97e8162bcf66fb" translate="yes" xml:space="preserve">
          <source>Always remember that the equals sign (=) means assignment.
Always remember that passing a parameter to a function &lt;em&gt;in JavaScript&lt;/em&gt; also means assignment.
They are the same and the 2 variables are connected in exactly the same way (which is to say they aren't, unless you count that they are assigned to the same object).</source>
          <target state="translated">始终记住，等号（=）表示赋值。 永远记住，将参数传递给&lt;em&gt;JavaScript中&lt;/em&gt;的函数也意味着赋值。 它们是相同的，并且2个变量以完全相同的方式连接（也就是说，它们不是一样的，除非您将它们分配给同一对象）。</target>
        </trans-unit>
        <trans-unit id="bfdc1eb7888008268dcd1f229efc00ed9fe4071e" translate="yes" xml:space="preserve">
          <source>An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:</source>
          <target state="translated">判断某事是否 &quot;通过引用 &quot;的一个简单方法就是你是否可以写一个 &quot;交换 &quot;函数。例如,在C语言中,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="3055a2e0457cb299ca6d433ebcc210c7bab9799e" translate="yes" xml:space="preserve">
          <source>An object outside a function is passed into a function by giving a reference to the outside object.</source>
          <target state="translated">通过给外部对象一个引用,将函数外的对象传入函数。</target>
        </trans-unit>
        <trans-unit id="b05bb9226e6abe9287bbf028bf6e5a6bed6624b9" translate="yes" xml:space="preserve">
          <source>An object passed to a function can have its members modified by the function.</source>
          <target state="translated">传给函数的对象可以被函数修改其成员。</target>
        </trans-unit>
        <trans-unit id="29e123b648bf0a31ec900d67e265e2a81d689d3d" translate="yes" xml:space="preserve">
          <source>Array and Object is passed as  pass by reference or  pass by value based on these two condition.</source>
          <target state="translated">数组和对象的传递方式为通过引用传递或通过值传递,基于这两个条件。</target>
        </trans-unit>
        <trans-unit id="7628591e37cbe88cf6fb309ba297bb58229eacac" translate="yes" xml:space="preserve">
          <source>As a final example, consider why a common attempt to clear an array doesn't work as expected.</source>
          <target state="translated">作为最后一个例子,考虑一下为什么常见的清除数组的尝试没有达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="178ee3db1a483706ed36d79f599e1a13d33df86f" translate="yes" xml:space="preserve">
          <source>Before we leave the topic of
  manipulating objects and arrays by
  reference, we need to clear up a point
  of nomenclature.</source>
          <target state="translated">在我们离开通过引用来操作对象和数组这个话题之前,我们需要先弄清楚一点命名法。</target>
        </trans-unit>
        <trans-unit id="f8884a4d2e00d4a1e326a98a062754846001f9b2" translate="yes" xml:space="preserve">
          <source>Both our favoriteString and string1 variables are assigned to 'Hello world'. Now, what if we want to change our favoriteString??? What will happen???</source>
          <target state="translated">我们的favoriteString和string1变量都分配给了 &quot;Hello world&quot;。现在,如果我们想改变我们的最爱String? 会发生什么呢?</target>
        </trans-unit>
        <trans-unit id="aa133f04e687ffaadb65bfc4786e9aafccdad56e" translate="yes" xml:space="preserve">
          <source>But both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are separate references to the same shared value &lt;code&gt;[1,2,3]&lt;/code&gt;, which is a compound value. It's important to note that neither &lt;code&gt;c&lt;/code&gt; nor &lt;code&gt;d&lt;/code&gt; more &quot;owns&quot; the &lt;code&gt;[1,2,3]&lt;/code&gt; value -- both are just equal peer references to the value. So, when using either reference to modify (&lt;code&gt;.push(4)&lt;/code&gt;) the actual shared &lt;code&gt;array&lt;/code&gt; value itself, it's affecting just the one shared value, and both references will reference the newly modified value &lt;code&gt;[1,2,3,4]&lt;/code&gt;.</source>
          <target state="translated">但是 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 都是对相同共享值 &lt;code&gt;[1,2,3]&lt;/code&gt; 的单独引用，共享值是一个复合值。 重要的是要注意， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 都不会&amp;ldquo;拥有&amp;rdquo; &lt;code&gt;[1,2,3]&lt;/code&gt; 值-两者都是对该值的同等引用。 因此，当使用其中一个引用修改（ &lt;code&gt;.push(4)&lt;/code&gt; ）实际共享 &lt;code&gt;array&lt;/code&gt; 本身时，它仅影响一个共享值，并且两个引用都将引用新修改的值 &lt;code&gt;[1,2,3,4]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="296985a800b1e8c9380cebd23dfbc86e71426942" translate="yes" xml:space="preserve">
          <source>Call CheckObjectCoercible(baseValue).</source>
          <target state="translated">调用CheckObjectCoercible(baseValue)。</target>
        </trans-unit>
        <trans-unit id="393aa90af622b95d2fecad8fb5a88f507b3e5d67" translate="yes" xml:space="preserve">
          <source>Changing the value of any changes value for both the variable.</source>
          <target state="translated">改变任何一个变量的值,对于这两个变量的值都会发生改变。</target>
        </trans-unit>
        <trans-unit id="e68569b88f0d63d426d55a5ad6eb50201341e31f" translate="yes" xml:space="preserve">
          <source>Compound value (object, array, etc) that can be passed by reference-copy</source>
          <target state="translated">可以通过引用复制传递的复合值(对象、数组等)。</target>
        </trans-unit>
        <trans-unit id="26b600a5d56d8944d8651beec06ae0642c20e289" translate="yes" xml:space="preserve">
          <source>Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.</source>
          <target state="translated">考虑到参数和变量对象是在函数调用开始时创建的执行上下文中创建的对象--而你实际传递到函数中的valuereference恰好存储在这个参数+变量对象中。</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">考虑到以下几点:</target>
        </trans-unit>
        <trans-unit id="5cecf4a03ec84caeeda78029a5bd713522ec8fe8" translate="yes" xml:space="preserve">
          <source>Construction of Argument Lists</source>
          <target state="translated">论据清单的构建</target>
        </trans-unit>
        <trans-unit id="635aa588bea9df239881e622d2cd3adbad8bf3c9" translate="yes" xml:space="preserve">
          <source>Definition of &quot;Object&quot;</source>
          <target state="translated">&quot;物体 &quot;的定义</target>
        </trans-unit>
        <trans-unit id="e9656fda095be85a55c47e88f0f2142837377331" translate="yes" xml:space="preserve">
          <source>E.g.:</source>
          <target state="translated">E.g.:</target>
        </trans-unit>
        <trans-unit id="e8a531332b5e0c2dac36ce0017c63f03c75815b9" translate="yes" xml:space="preserve">
          <source>Every time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.</source>
          <target state="translated">每当你向一个函数传递一个变量时,你就像使用等号(=)符号一样,将变量 &quot;分配 &quot;给任何参数变量的名称。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="83b1fe6393f9ea04f7c6ef0ebceb29757afe9a44" translate="yes" xml:space="preserve">
          <source>First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.</source>
          <target state="translated">首先,有多层次的抽象,似乎不是每个人都能掌握。较新的程序员在第4代或第5代语言上学习过的程序员,可能很难将汇编或C语言程序员所熟悉的概念包裹在脑海中,不会被指针到指针的指针所迷惑。通过引用并不是简单地指使用函数参数变量改变引用对象的能力。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="01bf4a9057daf1172b230a29ebe7eb0911eb8d6d" translate="yes" xml:space="preserve">
          <source>For programming language lawyers, I've went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;asking&lt;/a&gt; it on the ECMAScript mailing list.</source>
          <target state="translated">对于编程语言律师，我阅读了ECMAScript 5.1的以下部分（比最新版本更易于阅读），并在ECMAScript邮件列表中进行了&lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;询问&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd46cdb9b904080183e993ad3943a7303f85bd9f" translate="yes" xml:space="preserve">
          <source>Functions are objects</source>
          <target state="translated">函数是对象</target>
        </trans-unit>
        <trans-unit id="2fb8e5522eb18d1143e0bd9cb31d216fa77b5c59" translate="yes" xml:space="preserve">
          <source>Here is a rebuttal to this:</source>
          <target state="translated">以下是对这一点的反驳。</target>
        </trans-unit>
        <trans-unit id="47be461e851afeca8344b89d76c09b76e3e854ed" translate="yes" xml:space="preserve">
          <source>Here is an example, passing a number (a primitive type)</source>
          <target state="translated">下面是一个例子,传递一个数字(一种基元类型</target>
        </trans-unit>
        <trans-unit id="6d1956753d691a97c45c137388c4df02dd75b9c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;obj&lt;/code&gt; acts as a wrapper for the scalar primitive property &lt;code&gt;a&lt;/code&gt;. When passed to &lt;code&gt;foo(..)&lt;/code&gt;, a copy of the &lt;code&gt;obj&lt;/code&gt; reference is passed in and set to the &lt;code&gt;wrapper&lt;/code&gt;parameter. We now can use the &lt;code&gt;wrapper&lt;/code&gt; reference to access the shared object, and update its property. After the function finishes, &lt;code&gt;obj.a&lt;/code&gt; will see the updated value &lt;code&gt;42&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;obj&lt;/code&gt; 充当标量基本属性 &lt;code&gt;a&lt;/code&gt; 的包装。 当传递给 &lt;code&gt;foo(..)&lt;/code&gt; 时 ，将传递 &lt;code&gt;obj&lt;/code&gt; 参考的副本并将其设置为 &lt;code&gt;wrapper&lt;/code&gt; 参数。 现在，我们可以使用 &lt;code&gt;wrapper&lt;/code&gt; 引用访问共享库，并更新其属性。 函数完成后， &lt;code&gt;obj.a&lt;/code&gt; 将看到更新后的值 &lt;code&gt;42&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05dc205598b6fae1df14251d0f1b665f0352c482" translate="yes" xml:space="preserve">
          <source>Here, we mean
  simply that a reference to an object
  or array -- not the object itself --
  is passed to a function. A function
  can use the reference to modify
  properties of the object or elements
  of the array. But if the function
  overwrites the reference with a
  reference to a new object or array,
  that modification is not visible
  outside of the function.</source>
          <target state="translated">在这里,我们的意思是,简单地说,就是把一个对象或数组的引用 ----而不是对象本身 ----传给一个函数。一个函数可以使用这个引用来修改对象或数组元素的属性。但是如果函数用一个新的对象或数组的引用覆盖了这个引用,那么这个修改在函数之外是不可见的。</target>
        </trans-unit>
        <trans-unit id="ec613745ca6fb8018d61844fbac16fd497f35e96" translate="yes" xml:space="preserve">
          <source>I have found the &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend method&lt;/a&gt; of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js library&lt;/a&gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.</source>
          <target state="translated">当我想将一个对象作为可以被修改或完全替换的参数传递给我时，我发现&lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js库&lt;/a&gt;的&lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend方法&lt;/a&gt;非常有用。</target>
        </trans-unit>
        <trans-unit id="da00583f56bed3adae6b3854cb9669d9ef039b2e" translate="yes" xml:space="preserve">
          <source>I would say it is pass-by-copy -</source>
          <target state="translated">我想说,它是通过复印件----。</target>
        </trans-unit>
        <trans-unit id="99152f78f2285e9f5178a28c6ae891d22918905b" translate="yes" xml:space="preserve">
          <source>I've read through these answers multiple times, but didn't REALLY get it until I learned about the technical definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;Call by sharing&quot;&lt;/a&gt; as termed by Barbara Liskov</source>
          <target state="translated">我已经多次阅读了这些答案，但是直到我了解Barbara Liskov所说的&lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&amp;ldquo;共享通话&amp;rdquo;&lt;/a&gt;的技术定义后，我才真正理解它。</target>
        </trans-unit>
        <trans-unit id="668d70912c4017d9abe459009e674ca09138a746" translate="yes" xml:space="preserve">
          <source>I.e. effectively primitive types are passed by value, and complex types are passed by reference.</source>
          <target state="translated">即有效的原始类型是通过值传递,复杂类型是通过引用传递。</target>
        </trans-unit>
        <trans-unit id="0ec6ec8507ceaa91f883d8986d51cbca5f8b1a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj1&lt;/code&gt; was not a reference at all, then changing &lt;code&gt;obj1.item&lt;/code&gt; would have no effect on the &lt;code&gt;obj1&lt;/code&gt; outside of the function.</source>
          <target state="translated">如果 &lt;code&gt;obj1&lt;/code&gt; 根本不是引用，则更改 &lt;code&gt;obj1.item&lt;/code&gt; 对该函数外部的 &lt;code&gt;obj1&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="59dbe46a8ab60f48cf2577d1714a38c220edd92d" translate="yes" xml:space="preserve">
          <source>If the argument was a proper reference, then everything would have changed. &lt;code&gt;num&lt;/code&gt; would be &lt;code&gt;100&lt;/code&gt;, and &lt;code&gt;obj2.item&lt;/code&gt; would read &lt;code&gt;&quot;changed&quot;&lt;/code&gt;.</source>
          <target state="translated">如果论点是一个适当的参考，那么一切都会改变。 &lt;code&gt;num&lt;/code&gt; 为 &lt;code&gt;100&lt;/code&gt; ，而 &lt;code&gt;obj2.item&lt;/code&gt; 读为 &lt;code&gt;&quot;changed&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8184ee6c0e0f41f78f07ffde38ac0df94ff1ef63" translate="yes" xml:space="preserve">
          <source>If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let
  strict be false.</source>
          <target state="translated">如果被评价的语法生产包含在严格模式代码中,则让严格为真,否则让严格为假。</target>
        </trans-unit>
        <trans-unit id="0514b00b4153ffccc1fdf8db144a3bb4f96beb69" translate="yes" xml:space="preserve">
          <source>If you can't do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.</source>
          <target state="translated">如果你不能在JavaScript中做到这一点,那就不是 &quot;通过引用传递&quot;。</target>
        </trans-unit>
        <trans-unit id="ed437ed8c9b163811c8c45a0df65ee0cfa2b2119" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;strong&gt;objects&lt;/strong&gt; are stored as references:</source>
          <target state="translated">在JavaScript中， &lt;strong&gt;对象&lt;/strong&gt;存储为引用：</target>
        </trans-unit>
        <trans-unit id="4a244292f7a66631a95bd0016a42e5a3d8a6fdee" translate="yes" xml:space="preserve">
          <source>In JavaScript, the type of the value &lt;em&gt;solely&lt;/em&gt; controls whether that value will be assigned by &lt;strong&gt;value-copy&lt;/strong&gt; or by &lt;strong&gt;reference-copy&lt;/strong&gt;.</source>
          <target state="translated">在JavaScript中，值的类型&lt;em&gt;仅&lt;/em&gt;控制该值是由&lt;strong&gt;value-copy&lt;/strong&gt;还是由&lt;strong&gt;reference-copy&lt;/strong&gt;分配。</target>
        </trans-unit>
        <trans-unit id="bf140191af1dcec987a4dde5edb6fb8a16e09a25" translate="yes" xml:space="preserve">
          <source>In a low level language, if you want to pass a variable by reference you have to use a specific syntax in the creation of the function:</source>
          <target state="translated">在低级语言中,如果你想通过引用传递一个变量,你必须在创建函数时使用特定的语法。</target>
        </trans-unit>
        <trans-unit id="81c7785c18e39819bdc6bf53496b0a9a6239d0fc" translate="yes" xml:space="preserve">
          <source>In both alerts you will find the value to be undefined.</source>
          <target state="translated">在这两个警报中,你会发现这个值是未定义的。</target>
        </trans-unit>
        <trans-unit id="35606096aee27d974b3090d3e8e5ae1f3bda2fd4" translate="yes" xml:space="preserve">
          <source>In my book that's called passing by reference.</source>
          <target state="translated">在我的书里,这叫 &quot;参照物&quot;。</target>
        </trans-unit>
        <trans-unit id="3f390d1963a58a5cc587e0e6330cf78dff59fc86" translate="yes" xml:space="preserve">
          <source>In practical terms, this means that if you change the parameter itself (as with &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt;), that won't affect the item that was fed into the parameter. But if you change the &lt;strong&gt;INTERNALS&lt;/strong&gt; of the parameter, that will propagate back up (as with &lt;code&gt;obj1&lt;/code&gt;).</source>
          <target state="translated">实际上，这意味着如果您更改参数本身（如 &lt;code&gt;num&lt;/code&gt; 和 &lt;code&gt;obj2&lt;/code&gt; ），则不会影响输入该参数的项目。 但是，如果您更改参数的&lt;strong&gt;INTERNALS&lt;/strong&gt; ，则它将传播回去（与 &lt;code&gt;obj1&lt;/code&gt; 一样 ）。</target>
        </trans-unit>
        <trans-unit id="b57ba2b5cb9f82c19123db765fac17e24d1951eb" translate="yes" xml:space="preserve">
          <source>In the above snippet, because &lt;code&gt;2&lt;/code&gt; is a scalar primitive, &lt;code&gt;a&lt;/code&gt; holds one initial copy of that value, and &lt;code&gt;b&lt;/code&gt; is assigned another copy of the value. When changing &lt;code&gt;b&lt;/code&gt;, you are in no way changing the value in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在上面的代码段中，由于 &lt;code&gt;2&lt;/code&gt; 是标量原语，所以 &lt;code&gt;a&lt;/code&gt; 持有该值的一个初始副本，而 &lt;code&gt;b&lt;/code&gt; 则分配了该值的另一​​个副本。 更改 &lt;code&gt;b&lt;/code&gt; 时 ，绝不会更改a中的值。</target>
        </trans-unit>
        <trans-unit id="9be98568917515ecc47f6e69cddc320618b40a6f" translate="yes" xml:space="preserve">
          <source>Inside the function, parameter variables, &lt;code&gt;inVar1&lt;/code&gt; and &lt;code&gt;inVar2&lt;/code&gt;, receive the contents being passed.</source>
          <target state="translated">在函数内部，参数变量 &lt;code&gt;inVar1&lt;/code&gt; 和 &lt;code&gt;inVar2&lt;/code&gt; 接收传递的内容。</target>
        </trans-unit>
        <trans-unit id="eb0aded998f21b511a6bf2ba99f8f35d22c1fb84" translate="yes" xml:space="preserve">
          <source>Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is &lt;em&gt;itself&lt;/em&gt; a reference.
Technically, this is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;call-by-sharing&lt;/a&gt;.</source>
          <target state="translated">相反，情况是传入的项目是按值传递的。 但是，按值传递的项目&lt;em&gt;本身&lt;/em&gt;就是参考。 从技术上讲，这称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;共享呼叫&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7d302320d7430fecc028a90dc07690d841f6022" translate="yes" xml:space="preserve">
          <source>Is JavaScript a pass-by-reference or pass-by-value language</source>
          <target state="translated">JavaScript是通过引用传递还是通过值传递的语言?</target>
        </trans-unit>
        <trans-unit id="762dca873ea18a90a6df0ccb480c5023409ab8ee" translate="yes" xml:space="preserve">
          <source>It is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;effort&lt;/a&gt; to understand.</source>
          <target state="translated">在5.1版中定义&amp;ldquo;对象是属性的集合&amp;rdquo;。 因此，我们可以推断出，对象的值就是集合，但是关于什么是集合的值在规范中定义得很差，需要一些&lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;努力&lt;/a&gt;才能理解。</target>
        </trans-unit>
        <trans-unit id="986429e47688846136b52b4cd304e16867c4438c" translate="yes" xml:space="preserve">
          <source>It is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they're only used to describe the behavior of the delete, the typeof, and the assignment operators.</source>
          <target state="translated">在第8.7节 &quot;引用规范类型 &quot;中描述过,引用在语言中并不是真正的类型--它们只是用来描述删除、typeof和赋值操作符的行为。</target>
        </trans-unit>
        <trans-unit id="fc2fc8bac54ed799049c59646ec8689ad7f219e2" translate="yes" xml:space="preserve">
          <source>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its &lt;em&gt;members&lt;/em&gt;, those changes persist outside of the function.  This makes it &lt;em&gt;look&lt;/em&gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.</source>
          <target state="translated">它总是按值传递，但是对于对象，变量的值是一个引用。 因此，当您传递对象并更改其&lt;em&gt;成员时&lt;/em&gt; ，这些更改会在函数外部持久存在。 这使其&lt;em&gt;看起来&lt;/em&gt;像通过引用传递。 但是，如果您实际上更改了对象变量的值，则会看到该更改不会持续存在，证明它确实是按值传递的。</target>
        </trans-unit>
        <trans-unit id="89a28927b7d2922705fe9300b7e6edf22dfdb59e" translate="yes" xml:space="preserve">
          <source>It's interesting in JavaScript. Consider this example:</source>
          <target state="translated">这在JavaScript中很有意思。考虑一下这个例子。</target>
        </trans-unit>
        <trans-unit id="a58c0376442784131cce6ed16ca6889fa180a199" translate="yes" xml:space="preserve">
          <source>It's tempting to think that &lt;em&gt;primitives&lt;/em&gt; are enforced by special rules while &lt;em&gt;objects&lt;/em&gt; are not, but primitives are simply the end of the pointer chain.</source>
          <target state="translated">容易想到&lt;em&gt;原语&lt;/em&gt;是由特殊规则强制执行的，而&lt;em&gt;对象&lt;/em&gt;不是，而原语只是指针链的末尾。</target>
        </trans-unit>
        <trans-unit id="0f6e466f49c26929af238bc6449efa0b8dbf2534" translate="yes" xml:space="preserve">
          <source>It's time to throw out everything you know about pass by value / reference.</source>
          <target state="translated">是时候抛出你所知道的一切通过价值参考的通行证了。</target>
        </trans-unit>
        <trans-unit id="c1ad2e0efeecec9224ee8d6ce3fbe2b458a354fc" translate="yes" xml:space="preserve">
          <source>JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object's data via the function parameter is synonymous to &quot;pass-by-value&quot;.</source>
          <target state="translated">JavaScript并不通过引用传递数据。如果你仔细阅读,你会发现,所有相反的观点都误解了什么是 &quot;逐值传递&quot;,他们错误地认为,通过函数参数更新对象的数据能力就是 &quot;逐值传递 &quot;的同义词。</target>
        </trans-unit>
        <trans-unit id="d2d80fc6a6ff698bf0fd9cfa17926536bf0021d5" translate="yes" xml:space="preserve">
          <source>JavaScript is always &lt;em&gt;pass-by-value&lt;/em&gt;; everything is of value type.</source>
          <target state="translated">JavaScript总是&lt;em&gt;按值传递&lt;/em&gt; ； 一切都是价值类型。</target>
        </trans-unit>
        <trans-unit id="d61aca1d96d43376df88c4a107691b9524026ab9" translate="yes" xml:space="preserve">
          <source>JavaScript passes primitive types by value and object types by reference</source>
          <target state="translated">JavaScript通过值传递基元类型,通过引用传递对象类型。</target>
        </trans-unit>
        <trans-unit id="821543b87e4b4527bdc1a22fea2a59bd6cf89783" translate="yes" xml:space="preserve">
          <source>Javascript is a high level language that does this conversion for you. 
So, although objects are passed by reference, the language converts the reference parameter to the value. You don't need to use &lt;code&gt;&amp;amp;&lt;/code&gt;, on the function definition, to pass it by reference, neither &lt;code&gt;*&lt;/code&gt;, on the function body, to convert the reference to the value, JS does it for you.</source>
          <target state="translated">Javascript是为您执行此转换的高级语言。 因此，尽管对象是通过引用传递的，但语言会将引用参数转换为值。 您不需要在函数定义上使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 来通过引用传递它，在函数体上也不需要 &lt;code&gt;*&lt;/code&gt; 来将引用转换为值，JS会为您完成。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">了解更多</target>
        </trans-unit>
        <trans-unit id="e2890eaeaae54ae8213119b094d6eac3b0d0f34d" translate="yes" xml:space="preserve">
          <source>Let arg be GetValue(ref).</source>
          <target state="translated">让arg为GetValue(ref)。</target>
        </trans-unit>
        <trans-unit id="d5b52edd936f17bee3970c4c4428d8bdb2114974" translate="yes" xml:space="preserve">
          <source>Let baseReference be the result of evaluating MemberExpression.</source>
          <target state="translated">让baseReference是评价MemberExpression的结果。</target>
        </trans-unit>
        <trans-unit id="5793a1bc1d3ece9a28dfc1f7df2511a7f09c3cea" translate="yes" xml:space="preserve">
          <source>Let baseValue be GetValue(baseReference).</source>
          <target state="translated">让baseValue为GetValue(baseReference)。</target>
        </trans-unit>
        <trans-unit id="0fbb0a339d88c497bca6b7e0e0802f2e1a9e810f" translate="yes" xml:space="preserve">
          <source>Let propertyNameReference be the result of evaluating Expression.</source>
          <target state="translated">让propertyNameReference是评价Expression的结果。</target>
        </trans-unit>
        <trans-unit id="e26b41e64cfc85d8131bd89ab1968cf9b539bc12" translate="yes" xml:space="preserve">
          <source>Let propertyNameString be ToString(propertyNameValue).</source>
          <target state="translated">让propertyNameString成为ToString(propertyNameValue)。</target>
        </trans-unit>
        <trans-unit id="d27739e60a7d1d0ee771b1f518f987ee71282c40" translate="yes" xml:space="preserve">
          <source>Let propertyNameValue be GetValue(propertyNameReference).</source>
          <target state="translated">Let propertyNameValue be GetValue(propertyNameReference)。</target>
        </trans-unit>
        <trans-unit id="765c825fb8ce47d020ac3dcc136c15f73cbaa9d1" translate="yes" xml:space="preserve">
          <source>Let ref be the result of evaluating AssignmentExpression.</source>
          <target state="translated">让ref是评价AssignmentExpression的结果。</target>
        </trans-unit>
        <trans-unit id="ba443140669d7febc24e1df988b59f67bf1999bc" translate="yes" xml:space="preserve">
          <source>My simple way to understand this...</source>
          <target state="translated">我简单的理解就是.....</target>
        </trans-unit>
        <trans-unit id="41e399d344b8bb63a9437372496bb38b9ea65720" translate="yes" xml:space="preserve">
          <source>My two cents... This is the way I understand it. (Feel free to correct me if I'm wrong)</source>
          <target state="translated">我的两分钱.....这是我的理解。(如果我说错了,请随时纠正我)</target>
        </trans-unit>
        <trans-unit id="cc50c81892c92e84bb1ae3f1a86483bee39914a6" translate="yes" xml:space="preserve">
          <source>Next, for whatever reason, we decide that we like object 2 better. So, we simply do a little re-assignment.</source>
          <target state="translated">接下来,不管出于什么原因,我们决定我们更喜欢对象2。所以,我们简单地做了一下重新分配。</target>
        </trans-unit>
        <trans-unit id="5983d2311d0216c94667916653cda7009208c7ff" translate="yes" xml:space="preserve">
          <source>Nothing happened to object1 or to object2. We haven't changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.</source>
          <target state="translated">对象1和对象2都没有发生任何变化。我们根本没有改变任何数据。我们所做的只是重新分配了我们最喜欢的对象是什么。要知道object2和favoriteObject都分配给同一个对象,这一点很重要。我们可以通过这些变量中的任何一个来改变那个对象。</target>
        </trans-unit>
        <trans-unit id="b0ed35c065098b7007966c00ae087554253b51c5" translate="yes" xml:space="preserve">
          <source>Now, let's say that we like object1 better... So, we &quot;assign&quot; a new variable.</source>
          <target state="translated">现在,让我们假设我们更喜欢对象1.....。所以,我们 &quot;分配 &quot;一个新的变量。</target>
        </trans-unit>
        <trans-unit id="fefaeda9e706a96b72c3a91f6d46d3d47c7c5900" translate="yes" xml:space="preserve">
          <source>Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you simply assigned using the equal (=) sign.</source>
          <target state="translated">现在,说到函数和传递参数......。当你调用一个函数,并传递一个参数时,你所做的本质上是对一个新变量的 &quot;赋值&quot;,它的工作原理和使用等号(=)符号赋值完全一样。</target>
        </trans-unit>
        <trans-unit id="b357112211b094b3237788d525b078423b089167" translate="yes" xml:space="preserve">
          <source>Now, people like to bicker endlessly about whether &quot;pass by reference&quot;
  is the correct way to describe what Java et al. actually do. The point
  is this:</source>
          <target state="translated">现在,人们喜欢无休止地争论 &quot;通过引用传递 &quot;是否是描述Java等实际工作的正确方式。问题的关键是这样的。</target>
        </trans-unit>
        <trans-unit id="a7538e8091867206be4163070d38a8f2f6e2fc36" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function</source>
          <target state="translated">现在,同样的事情,但有了一个功能</target>
        </trans-unit>
        <trans-unit id="54f947ec6644ed78ef13a3901e8e53b29b1eae30" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function call</source>
          <target state="translated">现在,同样的事情,但有一个函数调用</target>
        </trans-unit>
        <trans-unit id="85abe287e946ffe23eec095f98389cf0bb761865" translate="yes" xml:space="preserve">
          <source>OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn't matter whether something is passed by reference or by value... What matters is assignment vs mutation.</source>
          <target state="translated">好了,如果你读完这篇帖子,也许你现在对函数调用在JavaScript中的工作原理有了更深的理解。通过引用或值传递东西并不重要,重要的是赋值和突变。重要的是赋值与变异。</target>
        </trans-unit>
        <trans-unit id="49aff953ef64c0bfd256e94df786773f165a1a31" translate="yes" xml:space="preserve">
          <source>OK, let me do my best to explain what I mean. Let's say you have a few objects.</source>
          <target state="translated">好吧,让我尽力解释一下我的意思。就说你有几个对象吧。</target>
        </trans-unit>
        <trans-unit id="d3ac732c421aaa382ba2a7df3b9370ee3d46965c" translate="yes" xml:space="preserve">
          <source>OK, now let&amp;rsquo;s give a few examples using objects instead... first, without the function.</source>
          <target state="translated">好的，现在让我们举一些使用对象代替的示例...首先，不使用函数。</target>
        </trans-unit>
        <trans-unit id="55f468caaf302476af028732ffb89566f3834bf7" translate="yes" xml:space="preserve">
          <source>OK, now let's look at primitives like strings for example</source>
          <target state="translated">好了,现在我们来看看像字符串这样的基元,比如说</target>
        </trans-unit>
        <trans-unit id="ed4f6a94ec208043cd9b8120122b92570d99ac3f" translate="yes" xml:space="preserve">
          <source>Objects are passed by reference (the reference is passed by value).</source>
          <target state="translated">对象是通过引用传递的(引用是通过值传递的)。</target>
        </trans-unit>
        <trans-unit id="a0023dbe18ebfeae7656c8332857dde47f6a7acc" translate="yes" xml:space="preserve">
          <source>Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an &lt;em&gt;object&lt;/em&gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are &lt;em&gt;primitives&lt;/em&gt;.</source>
          <target state="translated">对象是值，对象的成员函数本身就是值（请记住，函数是JavaScript中的一流对象）。 另外，关于JavaScript中的所有内容都是&lt;em&gt;对象&lt;/em&gt;的概念； 这是错误的。 字符串，符号，数字，布尔值，null和undefineds是&lt;em&gt;基元&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c473076e20653740c581b65a9c148582980e1f2" translate="yes" xml:space="preserve">
          <source>On Reference</source>
          <target state="translated">关于参考资料</target>
        </trans-unit>
        <trans-unit id="24023d41b24981459776a8deb45dffaf544e073a" translate="yes" xml:space="preserve">
          <source>On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:</source>
          <target state="translated">有时,它们可以利用一些成员函数和属性继承自它们的基础原型,但这只是为了方便。但这并不意味着它们本身就是对象。试试下面的例子作为参考。</target>
        </trans-unit>
        <trans-unit id="4d12f26544314335beb7af690a37352634d31faf" translate="yes" xml:space="preserve">
          <source>One more example:</source>
          <target state="translated">再举一个例子。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="61d70ce6c0868b0a4084920bfa36265cd2924428" translate="yes" xml:space="preserve">
          <source>PHP does something similar since version 5: all objects are passed by reference, but all primitives &lt;em&gt;may&lt;/em&gt; be passed by reference, if preceded by an ampersand (&amp;amp;). Otherwise primitives are passed by value.</source>
          <target state="translated">从版本5开始，PHP进行了类似的操作：所有对象都通过引用传递，但是所有原语&lt;em&gt;都&lt;/em&gt;可以通过引用传递（如果前面带有＆符号，则可以通过引用传递）。 否则，基元将按值传递。</target>
        </trans-unit>
        <trans-unit id="4aa6714b9431fbeb4050db107726bf42359cbd64" translate="yes" xml:space="preserve">
          <source>Passing an object does not copy the object.</source>
          <target state="translated">传递一个对象不会复制对象。</target>
        </trans-unit>
        <trans-unit id="177116d45ea2e23710bb7ea3a718654efa24f9bc" translate="yes" xml:space="preserve">
          <source>Passing arguments to a function in JavaScript is analogous to passing
parameters by pointer value in C:</source>
          <target state="translated">在JavaScript中向一个函数传递参数,类似于C语言中通过指针值传递参数。</target>
        </trans-unit>
        <trans-unit id="01f2294132d2e2f2b4566ede86b13262366d51fb" translate="yes" xml:space="preserve">
          <source>Primitives (number, Boolean, etc.) are passed by value.</source>
          <target state="translated">元素(数字、布尔等)按值传递。</target>
        </trans-unit>
        <trans-unit id="1fbe034f18e45d911f35c38befd6ffef1237ff9d" translate="yes" xml:space="preserve">
          <source>Primitives are passed by value and objects are passed by reference. This is quite different from other languages like C, Visual Basic, or Delphi. I can't say how they handle objects and primitives exactly, but I know of Visual Basic and Delphi that it can (and should) be specified.</source>
          <target state="translated">基元是通过值传递,对象是通过引用传递。这与其他语言如C、Visual Basic或Delphi有很大的区别。我不能说它们到底是如何处理对象和基元的,但我知道Visual Basic和Delphi可以(而且应该)指定。</target>
        </trans-unit>
        <trans-unit id="b3a5e4b79e22cee55b6065ffe3f652237cc7594a" translate="yes" xml:space="preserve">
          <source>Readers
  familiar with the other meaning of
  this term may prefer to say that
  objects and arrays are passed by
  value, but the value that is passed is
  actually a reference rather than the
  object itself.</source>
          <target state="translated">熟悉这个词的另一种含义的读者可能更愿意说,对象和数组是通过值来传递的,但传递的值实际上是引用而不是对象本身。</target>
        </trans-unit>
        <trans-unit id="13206fd4fe5b59fc41e3d5a63a6488e8b552facb" translate="yes" xml:space="preserve">
          <source>Reassigning a variable merely points that pointer at a new value.</source>
          <target state="translated">重新分配一个变量只是将指针指向一个新的值。</target>
        </trans-unit>
        <trans-unit id="3207f76b42378372483b9234b1caf6f7a147a617" translate="yes" xml:space="preserve">
          <source>Reassigning a variable will never affect other variables that were pointing at that same object</source>
          <target state="translated">重新分配一个变量永远不会影响其他指向同一对象的变量。</target>
        </trans-unit>
        <trans-unit id="d310f078235065dddc3b458e5e588f59ca402bb8" translate="yes" xml:space="preserve">
          <source>Repeating this with an object yields different results:</source>
          <target state="translated">用一个物体重复这样做会产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="203297a3389833da40302baa74058f84dfb4172b" translate="yes" xml:space="preserve">
          <source>Return a List whose sole item is arg.</source>
          <target state="translated">返回一个List,其唯一的项目是arg。</target>
        </trans-unit>
        <trans-unit id="fea577a31c06a6a5a9a25864cabd1f7cd04ffc69" translate="yes" xml:space="preserve">
          <source>Section 11.2.1 &quot;Property Accessors&quot;</source>
          <target state="translated">第11.2.1节:&quot;财产访问器&quot;</target>
        </trans-unit>
        <trans-unit id="e3cdf6da05c63ab4f98f08c709113dc947f4641b" translate="yes" xml:space="preserve">
          <source>Section 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:</source>
          <target state="translated">第11.2.4节 &quot;论点列表 &quot;中,关于只由1个论点组成的论点列表,有如下规定:</target>
        </trans-unit>
        <trans-unit id="3dffa3d82c957452592ddbe22ee7b9fbabbad396" translate="yes" xml:space="preserve">
          <source>Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).</source>
          <target state="translated">语义学! 设置具体的定义,必然会使一些答案和注释不兼容,因为即使使用相同的词和短语,也不是在描述同一件事,但关键是要走出困惑(特别是对新程序员来说)。</target>
        </trans-unit>
        <trans-unit id="9042860968c9655fa63ade5546c81f532a616526" translate="yes" xml:space="preserve">
          <source>Simple values inside functions will not change those values outside of the function (they are passed by value), whereas complex ones will (they are passed by reference).</source>
          <target state="translated">函数内的简单值不会改变函数外的那些值(它们是通过值传递的),而复杂值会改变(它们是通过引用传递的)。</target>
        </trans-unit>
        <trans-unit id="af00e0ad8adf530d42297d91d90e47a9e641005b" translate="yes" xml:space="preserve">
          <source>Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.</source>
          <target state="translated">简单来说,对于基元类型,值在函数调用开始时被复制,对于对象类型,引用被复制。</target>
        </trans-unit>
        <trans-unit id="14e546fc199d754d3c9fb63d6f7e0dc0eda5708f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;inVar2&lt;/code&gt; received the reference of &lt;code&gt;{ prop: 2 }&lt;/code&gt;, you can change the value of the object's property.</source>
          <target state="translated">由于 &lt;code&gt;inVar2&lt;/code&gt; 收到了 &lt;code&gt;{ prop: 2 }&lt;/code&gt; 的引用，因此您可以更改对象属性的值。</target>
        </trans-unit>
        <trans-unit id="6b26d53b2a6c26d221c34b2ced9596e48f74edf5" translate="yes" xml:space="preserve">
          <source>So changing the value of a variable doesn't affect the other, as they both reside in two different locations.</source>
          <target state="translated">所以改变一个变量的值并不影响另一个变量,因为它们都存在于两个不同的位置。</target>
        </trans-unit>
        <trans-unit id="f443d83baee5de8b57871adc873303085a0467cd" translate="yes" xml:space="preserve">
          <source>So in JavaScript, if I pass an object X into a function via a parameter, it will still be X. If you are changing data &lt;em&gt;inside&lt;/em&gt; the function (or any other object, but that's not important) that new value is also available outside the function.</source>
          <target state="translated">因此，在JavaScript中，如果我通过参数将对象X传递给函数，则它仍然是X。如果要更改函数&lt;em&gt;内部&lt;/em&gt;的数据（或其他任何对象，但这并不重要），则在功能。</target>
        </trans-unit>
        <trans-unit id="8f7623c6dec052db957de7605896e4a2a3e6b647" translate="yes" xml:space="preserve">
          <source>So, &lt;strike&gt;forget about &lt;em&gt;&quot;pass by reference/value&quot;&lt;/em&gt;&lt;/strike&gt; don't get hung up on &quot;pass by reference/value&quot; because:</source>
          <target state="translated">因此，不用&lt;strike&gt;担心&lt;em&gt;&amp;ldquo;按引用/值传递&amp;rdquo;，&lt;/em&gt;&lt;/strike&gt;不要因为&amp;ldquo;按引用/值传递&lt;strike&gt;&lt;em&gt;&amp;rdquo;&lt;/em&gt;&lt;/strike&gt;而挂断电话，因为：</target>
        </trans-unit>
        <trans-unit id="68d38550c4da9fcceac584158479a156958fb538" translate="yes" xml:space="preserve">
          <source>Some final comments:</source>
          <target state="translated">最后的一些意见:</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="26220bb61f95026a6699bda5f772ab5f459fb7d2" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description</target>
        </trans-unit>
        <trans-unit id="00317f5e100f735c8f89f41e078aacbee58460d5" translate="yes" xml:space="preserve">
          <source>Strings are immutable, so it doesn't really matter for them.</source>
          <target state="translated">琴弦是一成不变的,所以对他们来说并不重要。</target>
        </trans-unit>
        <trans-unit id="d0020398180c05f3b9f05227c429a1215e0aae80" translate="yes" xml:space="preserve">
          <source>Take these examples.</source>
          <target state="translated">就拿这些例子来说吧。</target>
        </trans-unit>
        <trans-unit id="96016a84f6ccaa21c0ff5eb49c88180b5839dbb7" translate="yes" xml:space="preserve">
          <source>That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.</source>
          <target state="translated">也就是说,如果你去访问参数值本身,参数引用是可以改变的。另一方面,对参数的赋值在评估后会消失,函数调用者无法访问。</target>
        </trans-unit>
        <trans-unit id="1e9b208745c0adc4ae130578652525c2f81da6a0" translate="yes" xml:space="preserve">
          <source>That's why when you try to change an object inside a function, by replacing it's value (i.e. &lt;code&gt;age = {value:5}&lt;/code&gt;), the change doesn't persist, but if you change it's properties (i.e. &lt;code&gt;age.value = 5&lt;/code&gt;), it does.</source>
          <target state="translated">这就是为什么当您尝试通过替换函数的值（即 &lt;code&gt;age = {value:5}&lt;/code&gt; ）来更改函数中的对象时，更改不会持续存在，但是如果您更改其属性（即 &lt;code&gt;age.value = 5&lt;/code&gt; ），是的。</target>
        </trans-unit>
        <trans-unit id="ff449e061e42e079c42808abf8dc5c78475c9c12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;age&lt;/code&gt; is a reference to &lt;code&gt;myAge&lt;/code&gt;, but if you want the value you have to convert the reference, using &lt;code&gt;*age&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;age&lt;/code&gt; 是对 &lt;code&gt;myAge&lt;/code&gt; 的引用，但是如果您想要该值，则必须使用 &lt;code&gt;*age&lt;/code&gt; 转换引用。</target>
        </trans-unit>
        <trans-unit id="3cfb912d780ddf9573a7ca91bac5773da514df0e" translate="yes" xml:space="preserve">
          <source>The JavaScript engine assigns the object to the variable &lt;code&gt;c&lt;/code&gt;, and it points to some memory, say (0x012).</source>
          <target state="translated">JavaScript引擎将对象分配给变量 &lt;code&gt;c&lt;/code&gt; ，它指向一些内存，例如（0x012）。</target>
        </trans-unit>
        <trans-unit id="54327c1b59eda63c1878391f14ad9c7f807364da" translate="yes" xml:space="preserve">
          <source>The MDN docs explain it clearly, without being too verbose:</source>
          <target state="translated">MDN的医生解释的很清楚,不至于说的太啰嗦。</target>
        </trans-unit>
        <trans-unit id="131abb827464b85b18ae518074aac50427c4fc92" translate="yes" xml:space="preserve">
          <source>The equal(=) operator sets up new memory space or address</source>
          <target state="translated">equal(=)运算符设置了新的内存空间或地址。</target>
        </trans-unit>
        <trans-unit id="ebfa1ea7372d6f23abc337f70c4f4df97d8a30cd" translate="yes" xml:space="preserve">
          <source>The most succinct explanation I found was in the &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB style guide&lt;/a&gt;:</source>
          <target state="translated">我发现的最简洁的解释是在&lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB样式指南中&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3d021afb081241b899877ae82ca0e06ab382f15" translate="yes" xml:space="preserve">
          <source>The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)</source>
          <target state="translated">唯一的问题是,当你传递到函数中的变量名称与函数参数的名称相同时,就会出现问题。当这种情况发生的时候,你必须把函数中的参数当作是一个新的变量来处理(因为它确实是私有的</target>
        </trans-unit>
        <trans-unit id="2e351bcd6c54bf11efb568e95ee714a771482cbd" translate="yes" xml:space="preserve">
          <source>The only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven't modified the variable, but the object itself.</source>
          <target state="translated">只有当底层对象被突变时,&quot;修改变量 &quot;才会影响到不同的变量(在这种情况下,你没有修改变量,而是修改了对象本身。</target>
        </trans-unit>
        <trans-unit id="e117feea80f4052240b302d90852bffb9002a69f" translate="yes" xml:space="preserve">
          <source>The parameters of a function call are the function's &lt;em&gt;arguments&lt;/em&gt;.
  Arguments are passed to functions &lt;em&gt;by value&lt;/em&gt;. If the function changes
  the value of an argument, this change is not reflected globally or in
  the calling function. However, object references are values, too, and
  they are special: if the function changes the referred object's
  properties, that change is visible outside the function, (...)</source>
          <target state="translated">函数调用的&lt;em&gt;参数&lt;/em&gt;是函数的&lt;em&gt;参数&lt;/em&gt; 。 参数&lt;em&gt;通过值&lt;/em&gt;传递给函数。 如果函数更改了参数的值，则此更改不会在全局或调用函数中反映出来。 但是，对象引用也是值，并且它们很特殊：如果函数更改了所引用对象的属性，则该更改在函数外部是可见的（...）</target>
        </trans-unit>
        <trans-unit id="df2fd245eb7826b794aeb3d9f1b7a4aa9ba6448f" translate="yes" xml:space="preserve">
          <source>The phrase &quot;pass by
  reference&quot; can have several meanings.
  To some readers, the phrase refers to
  a function invocation technique that
  allows a function to assign new values
  to its arguments and to have those
  modified values visible outside the
  function. This is not the way the term
  is used in this book.</source>
          <target state="translated">&quot;通过引用传递 &quot;这个短语可以有多种含义。对一些读者来说,这个短语指的是一种函数调用技术,它允许一个函数给它的参数赋新值,并使这些修改后的值在函数之外可见。这不是本书中使用这个词的方式。</target>
        </trans-unit>
        <trans-unit id="40424125880f7bec8d7f9e5602a94c76e97cd1cc" translate="yes" xml:space="preserve">
          <source>The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).</source>
          <target state="translated">原始类型(数、字符串等)是通过值传递的,但对象是未知的,因为它们既可以通过值传递(在我们认为持有对象的变量实际上是对对象的引用的情况下),也可以通过引用传递(当我们认为对对象的变量持有对象本身时)。</target>
        </trans-unit>
        <trans-unit id="8fbaf791a543ee22f0fd296541edf5a1bfa479b1" translate="yes" xml:space="preserve">
          <source>The production ArgumentList : AssignmentExpression is evaluated as follows:</source>
          <target state="translated">生产的ArgumentList .AssignmentExpression AssignmentExpression的评价方式如下。</target>
        </trans-unit>
        <trans-unit id="ecee46c34e5a0a1af1170066ea3f9a92c40b9de1" translate="yes" xml:space="preserve">
          <source>The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</source>
          <target state="translated">生成的MemberExpression:MemberExpression[表达式 ]的评价方式如下。</target>
        </trans-unit>
        <trans-unit id="e64cfc5706b868b32b799d93138e5cd834b8bce0" translate="yes" xml:space="preserve">
          <source>The section also enumerate cases where argument list has 0 or &amp;gt;1 arguments.</source>
          <target state="translated">本节还列举了参数列表包含0或&amp;gt; 1个参数的情况。</target>
        </trans-unit>
        <trans-unit id="dbf3ebd42f5ddf6e8a07546545a97d0d73e8f740" translate="yes" xml:space="preserve">
          <source>The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren't visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller's scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned &amp;mdash; it is shared.</source>
          <target state="translated">通过共享进行调用的语义与通过引用进行调用的不同之处在于，调用者看不到对函数内函数参数的分配（与通过引用语义不同）[需要引用]，因此例如，如果传递了变量，则不可能在调用者范围内模拟对该变量的分配。 但是，由于函数可以访问与调用方相同的对象（不进行复制），因此，如果对象可变，则调用方可以看到函数中对象的突变（如果对象可变），这似乎与按值调用有所不同语义。 调用者可以看到函数中可变对象的突变，因为该对象没有被复制或克隆，而是共享的。</target>
        </trans-unit>
        <trans-unit id="8c4316acc1d74e70023ca752c79e9fc23bbbea3d" translate="yes" xml:space="preserve">
          <source>The terms are only used to describe the &lt;em&gt;behavior&lt;/em&gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn't adequately describe the actual behavior and supplementary info has to be provided</source>
          <target state="translated">这些术语仅用于描述语言的&lt;em&gt;行为&lt;/em&gt; ，而不一定是实际的基础实现。 由于这种抽象，丢失了对体面的解释必不可少的关键细节，这不可避免地导致当前情况，即单个术语不能充分描述实际行为，必须提供补充信息。</target>
        </trans-unit>
        <trans-unit id="626d24ad73a240837e037855870f41fe70cd5f31" translate="yes" xml:space="preserve">
          <source>The variable doesn't &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It's always pass by value (even when that value is a reference...).</source>
          <target state="translated">这个变量并不 &quot;持有 &quot;对象,它持有一个引用。你可以把这个引用分配给另一个变量,现在两者都引用了同一个对象。它总是通过值来传递(即使这个值是一个引用...........)。</target>
        </trans-unit>
        <trans-unit id="dca56569992ce2b50c87910c0d7c7c9858ba2c6f" translate="yes" xml:space="preserve">
          <source>There is no &quot;pass by reference&quot; available in JavaScript.</source>
          <target state="translated">JavaScript中没有 &quot;通过引用&quot;。</target>
        </trans-unit>
        <trans-unit id="361031a3f3abf898ac288ca94af4b04c26e7d902" translate="yes" xml:space="preserve">
          <source>There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn't have a function and just used the equal sign to assign to a new variable.</source>
          <target state="translated">区分对象和基元是没有任何意义的,因为它的工作原理和你没有函数,只是用等号赋值给一个新的变量一样,都是一样的。</target>
        </trans-unit>
        <trans-unit id="1aa166014dcdcbcff2f5f9b82565c5b3c2e956bf" translate="yes" xml:space="preserve">
          <source>There's no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.</source>
          <target state="translated">没有办法改变作为参数传递的变量所持有的值,如果JavaScript支持通过引用传递的话,这也是可以的。</target>
        </trans-unit>
        <trans-unit id="010934035b63fc110de9e084961250609ba49e08" translate="yes" xml:space="preserve">
          <source>There's some discussion about the use of the term &quot;pass by reference&quot; in JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;here&lt;/a&gt;, but to answer your question:</source>
          <target state="translated">这里有一些关于在JavaScript中使用&amp;ldquo;通过引用传递&amp;rdquo;一词的讨论，但可以回答您的问题：</target>
        </trans-unit>
        <trans-unit id="b3971268996a99a5df86f39832ec5539e7dd9d70" translate="yes" xml:space="preserve">
          <source>These concepts were not originally defined with the intent of describing javascript in particular and so I don't feel compelled to use them when they only add to the confusion.</source>
          <target state="translated">这些概念最初的定义并不是为了特别描述javascript,所以当它们只会增加混乱的时候,我并不觉得有必要使用它们。</target>
        </trans-unit>
        <trans-unit id="e16663c0ae48f1219b8db33d73a88db1512811fc" translate="yes" xml:space="preserve">
          <source>Think of it like this: It's always pass by value. However, the value of an object is not the object itself, but a reference to that object.</source>
          <target state="translated">这样想一想。它总是通过值来传递。然而,对象的值不是对象本身,而是对该对象的引用。</target>
        </trans-unit>
        <trans-unit id="705df426723dfd9a58e61806d528e760b06fe084" translate="yes" xml:space="preserve">
          <source>This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.</source>
          <target state="translated">这是对通过值传递和通过引用传递(JavaScript)的小编的解释。在这个概念中,他们说的是通过引用传递变量,通过引用传递变量。</target>
        </trans-unit>
        <trans-unit id="3f9efc65382f339c71ef4d14543d364c027db24a" translate="yes" xml:space="preserve">
          <source>This produces the output:</source>
          <target state="translated">这就产生了输出。</target>
        </trans-unit>
        <trans-unit id="a1116d28bfe37e6545e3ebc5bd2c217059edabe0" translate="yes" xml:space="preserve">
          <source>Thus, everything's are passed by reference.</source>
          <target state="translated">因此,一切的都是通过引用来传递。</target>
        </trans-unit>
        <trans-unit id="3678321f62ae967b6f938900843022091b6a3c1b" translate="yes" xml:space="preserve">
          <source>Thus, properties of Objects are always available as reference.</source>
          <target state="translated">因此,Objects的属性总是可以作为参考。</target>
        </trans-unit>
        <trans-unit id="0821fb327f2753fc69a24f9f6c10a0a8791e18c7" translate="yes" xml:space="preserve">
          <source>To answer your question: pointers are passed.</source>
          <target state="translated">回答你的问题:指点者通过。</target>
        </trans-unit>
        <trans-unit id="7bbe358444a139cd8eb2208023bd472900f08800" translate="yes" xml:space="preserve">
          <source>To effectively pass a compound value (like an &lt;code&gt;array&lt;/code&gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</source>
          <target state="translated">为了通过value-copy有效地传递复合值（如 &lt;code&gt;array&lt;/code&gt; ），您需要手动制作它的副本，以使传递的引用仍然指向原始值。 例如：</target>
        </trans-unit>
        <trans-unit id="e1abf81928ceac0fa096e0f4f2795b3ee7f8da32" translate="yes" xml:space="preserve">
          <source>Uh oh.... What has happened. We couldn't change string1 by changing favoriteString... Why?? Because we didn't &lt;em&gt;change&lt;/em&gt; our string &lt;em&gt;object&lt;/em&gt;. All we did was &quot;RE ASSIGN&quot; the favoriteString &lt;em&gt;variable&lt;/em&gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn't assign anything. (Well, not to the &lt;em&gt;variable itself&lt;/em&gt;, ... we did, however, assign the name property to a new string.) Instead, we simply mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or &lt;em&gt;mutate&lt;/em&gt; the string object &lt;em&gt;itself&lt;/em&gt;, we couldn't have, because strings are actually immutable in JavaScript.)</source>
          <target state="translated">呃哦...发生了什么事。 我们无法通过更改favoriteString来更改string1 ...为什么？ 因为我们没有&lt;em&gt;更改&lt;/em&gt;字符串&lt;em&gt;对象&lt;/em&gt; 。 我们所做的只是将&amp;ldquo; favoriteString&amp;rdquo; &lt;em&gt;变量&lt;/em&gt; &amp;ldquo;重新分配&amp;rdquo;为新字符串。 这实际上将其与string1断开了连接。 在上一个示例中，当我们重命名对象时，我们没有分配任何东西。 （但是，不是将&lt;em&gt;变量本身&lt;/em&gt;分配给...，但是，我们确实将name属性分配给了新的字符串。）相反，我们仅对对象进行了突变，以保持2个变量与基础对象之间的连接。 （即使我们想修改或更改字符串对象&lt;em&gt;本身&lt;/em&gt; ，也不能这样做，因为字符串实际上在JavaScript中是不可变的。）</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="ad44083b5ca9c555d81d716126062a61d9fc5f75" translate="yes" xml:space="preserve">
          <source>Variables are &lt;em&gt;pointers&lt;/em&gt; to values in memory.</source>
          <target state="translated">变量是&lt;em&gt;指向&lt;/em&gt;内存中值的&lt;em&gt;指针&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="678a462c2bd82f3f082479b480f76e063a36fb4b" translate="yes" xml:space="preserve">
          <source>What we have done is &quot;assignment&quot;... We've assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.</source>
          <target state="translated">我们所做的是 &quot;赋值&quot;.....。我们将2个独立的空对象分配给变量 &quot;object1 &quot;和 &quot;object2&quot;。</target>
        </trans-unit>
        <trans-unit id="84d66e6463f366bb3793d71142052ebf0b3271b4" translate="yes" xml:space="preserve">
          <source>When calling a function, you are passing the content (reference or
value) of the argument variables, not the the variables themselves.</source>
          <target state="translated">当调用一个函数时,你传递的是参数变量的内容(引用或值),而不是变量本身。</target>
        </trans-unit>
        <trans-unit id="b675d8ab55a62fa7342693de178ca61efdefdab7" translate="yes" xml:space="preserve">
          <source>When d=c, in this step &lt;code&gt;d&lt;/code&gt; points to the same location (0x012).</source>
          <target state="translated">当d = c时，在此步骤中 &lt;code&gt;d&lt;/code&gt; 指向相同的位置（0x012）。</target>
        </trans-unit>
        <trans-unit id="6603f9e15352ae782eb9dbf4dc53a8cacea1f46d" translate="yes" xml:space="preserve">
          <source>When we make the assignment &lt;code&gt;b = [4,5,6]&lt;/code&gt;, we are doing absolutely nothing to affect where &lt;code&gt;a&lt;/code&gt; is still referencing (&lt;code&gt;[1,2,3]&lt;/code&gt;). To do that, &lt;code&gt;b&lt;/code&gt; would have to be a pointer to &lt;code&gt;a&lt;/code&gt; rather than a reference to the &lt;code&gt;array&lt;/code&gt; -- but no such capability exists in JS!</source>
          <target state="translated">当我们使赋值 &lt;code&gt;b = [4,5,6]&lt;/code&gt; ，我们完全没有做任何事情来影响 &lt;code&gt;a&lt;/code&gt; 仍在引用的位置（ &lt;code&gt;[1,2,3]&lt;/code&gt; ）。 为此， &lt;code&gt;b&lt;/code&gt; 必须是指向a的指针，而不是对 &lt;code&gt;array&lt;/code&gt; 的引用-但是JS中不存在这种功能！</target>
        </trans-unit>
        <trans-unit id="13f9dc2555da1b44daf4195c85cac47042d3a3a1" translate="yes" xml:space="preserve">
          <source>When we pass in the argument &lt;code&gt;a&lt;/code&gt;, it assigns a copy of the &lt;code&gt;a&lt;/code&gt; reference to &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are separate references pointing at the same &lt;code&gt;[1,2,3]&lt;/code&gt; value. Now, inside the function, we can use that reference to mutate the value itself (&lt;code&gt;push(4)&lt;/code&gt;). But when we make the assignment &lt;code&gt;x = [4,5,6]&lt;/code&gt;, this is in no way affecting where the initial reference &lt;code&gt;a&lt;/code&gt; is pointing -- still points at the (now modified) &lt;code&gt;[1,2,3,4]&lt;/code&gt; value.</source>
          <target state="translated">当我们传入参数 &lt;code&gt;a&lt;/code&gt; 时 ，它将a的副本分配给 &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 是指向相同 &lt;code&gt;[1,2,3]&lt;/code&gt; 值的单独引用。 现在，在函数内部，我们可以使用该引用来改变值本身（ &lt;code&gt;push(4)&lt;/code&gt; ）。 但是，当我们使赋值 &lt;code&gt;x = [4,5,6]&lt;/code&gt; ，这绝不会影响初始参考 &lt;code&gt;a&lt;/code&gt; 指向的位置-仍然指向 &lt;code&gt;[1,2,3,4]&lt;/code&gt; 值（现在已修改）。</target>
        </trans-unit>
        <trans-unit id="dc1b4ec703eec5dfe10344c61e1e765e58682a65" translate="yes" xml:space="preserve">
          <source>When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else.</source>
          <target state="translated">当你用这个引用来操作它的对象时,外面的对象就会因此受到影响。但是,如果在函数内部,你决定将引用指向其他的东西,你根本没有影响到外面的对象,因为你所做的只是将引用重定向到其他的东西。</target>
        </trans-unit>
        <trans-unit id="a5f72cf83865e4414b2e92fe68d2f91039221270" translate="yes" xml:space="preserve">
          <source>a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).</source>
          <target state="translated">a被分配了一个内存(例如0x001),b在内存中创建一个值的副本(例如0x002)。</target>
        </trans-unit>
        <trans-unit id="ba35e803347ae1a6fbb922bb822df3c9557c5075" translate="yes" xml:space="preserve">
          <source>a very confusing situation is where you can't realize how your referenced variable changes, let's take a look at a very good example:</source>
          <target state="translated">一个非常混乱的情况是,你无法意识到你的引用变量是如何变化的,让我们来看一个非常好的例子。</target>
        </trans-unit>
        <trans-unit id="1a91322ba3053b9c0d30aeec04a7ec7d757a54ad" translate="yes" xml:space="preserve">
          <source>and in a more complicated story:</source>
          <target state="translated">而在一个更复杂的故事中。</target>
        </trans-unit>
        <trans-unit id="dbe8beff245d88e0093cd5bdb6c0a20809a330d5" translate="yes" xml:space="preserve">
          <source>applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).</source>
          <target state="translated">适用于JavaScript中的所有基元类型(string、number、Boolean、undefined和null)。</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4e4aeb4d95583c62381700ab3cfbd849ddf35b64" translate="yes" xml:space="preserve">
          <source>but we cant do the same thing with the purple arrow, we may want to move 'john' cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...</source>
          <target state="translated">但我们不能做同样的事情与紫色的箭头,我们可能要移动 &quot;约翰 &quot;单元格在这里或许多其他事情.........,所以紫色的箭头将坚持到它的地方,只是典型的箭头,被分配给它将移动....</target>
        </trans-unit>
        <trans-unit id="e4cf40496f043253f0d64368904b930d9b69c16d" translate="yes" xml:space="preserve">
          <source>every type2-value (green) is a &lt;strong&gt;single square&lt;/strong&gt; while a type1-value (blue) is a &lt;strong&gt;group of them&lt;/strong&gt;:</source>
          <target state="translated">每个type2值（绿色）是一个&lt;strong&gt;正方形，&lt;/strong&gt;而type1值（蓝色）是其中的一&lt;strong&gt;组&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="dd74f54fdfe237acc828874dddffdcfc48e8abc5" translate="yes" xml:space="preserve">
          <source>here you are assigning new object or array to old one.you are not changing the value of property 
of old object.so it is pass by value.</source>
          <target state="translated">这里你是在给旧对象分配新对象或数组,你并没有改变旧对象的属性值,所以它是通过值传递的。</target>
        </trans-unit>
        <trans-unit id="a20f2e836503b1a3b14f37b2c5bd01437f59d8f4" translate="yes" xml:space="preserve">
          <source>here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.</source>
          <target state="translated">这里你是在改变一个旧对象的属性值,你并没有将新对象或数组分配给旧对象,所以它是通过引用传递。</target>
        </trans-unit>
        <trans-unit id="53ff18bfd84d263fea5d0d0003eebc0c7a27a864" translate="yes" xml:space="preserve">
          <source>if you are changing a property value of an object or array then it is pass by Reference.</source>
          <target state="translated">如果你要改变一个对象或数组的属性值,那么它是通过引用来传递的。</target>
        </trans-unit>
        <trans-unit id="3e6856e162be438b0b1b28e9475c58786691c0c2" translate="yes" xml:space="preserve">
          <source>if you are changing value of that Object or array with new Object or Array then it is pass by Value.</source>
          <target state="translated">如果你用新的对象或数组改变该对象或数组的值,那么它将被Value传递。</target>
        </trans-unit>
        <trans-unit id="37fb1667392900bb5ef5037dd0e0b507e63dc8dd" translate="yes" xml:space="preserve">
          <source>if you imagine memory as below squares which in every one of them just one type2-value can be saved:</source>
          <target state="translated">如果你把内存想象成下面的方块,每一个方块中只有一个type2-值可以保存。</target>
        </trans-unit>
        <trans-unit id="d4ec615b08c0e036b2bca13e54163fa4149fab8d" translate="yes" xml:space="preserve">
          <source>in javascript we can put values in two layer: &lt;strong&gt;type1&lt;/strong&gt;-&lt;code&gt;objects&lt;/code&gt; and &lt;strong&gt;type2&lt;/strong&gt;-all other types of value such as &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</source>
          <target state="translated">在javascript中，我们可以将值分为两层： &lt;strong&gt;type1-&lt;/strong&gt; &lt;code&gt;objects&lt;/code&gt; 和&lt;strong&gt;type2-&lt;/strong&gt;所有其他类型的值，例如 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;boolean&lt;/code&gt; 等</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="53b0a1b2fadf4e040cdc2155a7340de24aca93cb" translate="yes" xml:space="preserve">
          <source>number</source>
          <target state="translated">number</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="f0f7f39ec7e62249ee81dac2c3f1b3586a4fd52e" translate="yes" xml:space="preserve">
          <source>objects</source>
          <target state="translated">objects</target>
        </trans-unit>
        <trans-unit id="43c608c48ee77ebcf1192df657480116bb88d93b" translate="yes" xml:space="preserve">
          <source>primitive type variable like string,number are always pass as  pass
by value.</source>
          <target state="translated">原始类型变量如string、number等总是作为传递值传递。</target>
        </trans-unit>
        <trans-unit id="0366c73137f63703a81f4390aa8afe89322b7310" translate="yes" xml:space="preserve">
          <source>sharing what I know of references in JavaScript</source>
          <target state="translated">分享我所知道的JavaScript中的引用</target>
        </trans-unit>
        <trans-unit id="340b6603b7ec42319770e6733e4f6bacbc9b29bb" translate="yes" xml:space="preserve">
          <source>so here &lt;strong&gt;references&lt;/strong&gt; can rescue us:</source>
          <target state="translated">因此，这里的&lt;strong&gt;引用&lt;/strong&gt;可以挽救我们：</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="bffc56aa90003a62e1312aa3131fb673e4b8fa39" translate="yes" xml:space="preserve">
          <source>symbol in &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; 中的符号</target>
        </trans-unit>
        <trans-unit id="1a6bbba542e8dfa1abb5d45893298c0eb2f0d406" translate="yes" xml:space="preserve">
          <source>the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that's not easy at all! :</source>
          <target state="translated">关键是,如果你想表示type2-value,地址是普通的,但如果你想对type1-value做同样的事情,那就不容易了! :</target>
        </trans-unit>
        <trans-unit id="d5d4cd07616a542891b7ec2d0257b3a24b69856e" translate="yes" xml:space="preserve">
          <source>undefined</source>
          <target state="translated">undefined</target>
        </trans-unit>
        <trans-unit id="c097133877b58bb1a18daa1d045149700ebbbf11" translate="yes" xml:space="preserve">
          <source>well, it's about 'performance' and 'speed' and in the simple word 'memory management' in a programming language.</source>
          <target state="translated">好吧,这是关于 &quot;性能 &quot;和 &quot;速度 &quot;的问题,用编程语言中的 &quot;内存管理 &quot;这个简单的词来形容。</target>
        </trans-unit>
        <trans-unit id="5ba026f489ec792196a7e8a5a6ac751fc3641db1" translate="yes" xml:space="preserve">
          <source>while the green arrow here is a typical variable, the purple one is an object variable, so &lt;strong&gt;because the green arrow(typical variable) has just one task&lt;/strong&gt; (and that is indicating a typical value) we don't need to separate it's value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...</source>
          <target state="translated">尽管此处的绿色箭头是一个典型变量，而紫色箭头是一个对象变量，所以&lt;strong&gt;由于绿色箭头（典型变量）只有一项任务&lt;/strong&gt; （即表示一个典型值），因此我们无需将其值与因此我们将绿色箭头及其值移动到所有位置，所有分配，函数等中&amp;hellip;&amp;hellip;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
