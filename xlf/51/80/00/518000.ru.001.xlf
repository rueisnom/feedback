<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/518000">
    <body>
      <group id="518000">
        <trans-unit id="1dee29437206aa2b90705d515faaafcb0add50ca" translate="yes" xml:space="preserve">
          <source>&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;Which programming languages are pass by reference?&lt;/a&gt;</source>
          <target state="translated">- &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Брайан Би&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;Какие языки программирования передаются по ссылке?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07698e10df4dd98b0bf399ab50011ce57e452623" translate="yes" xml:space="preserve">
          <source>(From the article mentioned above.)</source>
          <target state="translated">(Из статьи,упомянутой выше)</target>
        </trans-unit>
        <trans-unit id="edeb4423fd301ceb5f86fc44d38b40f3c9ba6fa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Return a value of type Reference&lt;/b&gt; whose base value is baseValue and whose referenced name is
  propertyNameString, and whose strict mode flag is strict.</source>
          <target state="translated">&lt;b&gt;Вернуть значение типа Reference&lt;/b&gt; , базовое значение которого равно baseValue, а ссылочное имя - propertyNameString, а флаг строгого режима - строгий.</target>
        </trans-unit>
        <trans-unit id="d0d476f54a71b8ac89e5d06ddffbeccc263797e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TL;DR&lt;/b&gt;: Everythings're passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.</source>
          <target state="translated">&lt;b&gt;TL; DR&lt;/b&gt; : все передается по значению, но свойства объектов являются ссылками, и определение объекта жутко не хватает в стандарте.</target>
        </trans-unit>
        <trans-unit id="5cc31de26a91a7607db07fbc10e5bdca64ddd6b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compound values are always assigned/passed by reference-copy&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Составные значения всегда присваиваются / передаются по ссылке-копии&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b825d8d1882d46055d101f87ec20d9423ddb0d0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function arguments and parameters are not the same thing.  Also, a variable's value is not the variable's object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Аргументы и параметры функций - это не одно и то же.&lt;/em&gt; &lt;em&gt;Кроме того, значение переменной не является объектом переменной (как уже указывалось различными людьми, но, очевидно, игнорируется).&lt;/em&gt; &lt;em&gt;Эти различия имеют решающее значение для правильного понимания.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dec8a494f102cfe95fa805f288c3d04ee0a6b711" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Primitive values are always assigned/passed by value-copy&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Примитивные значения всегда присваиваются / передаются значением-копией&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="207d1e3b4f674510d97d07b156c4c5ee3a4de294" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because in JavaScript, it doesn't matter whether it's passed by value or by reference or whatever.
What matters is mutation vs assignment of the parameters passed into a function.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Потому что в JavaScript не имеет значения, передается ли он по значению, по ссылке или как угодно.&lt;/strong&gt; &lt;strong&gt;Важна мутация против присвоения параметров, переданных в функцию.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a42287a91a97e2c4e1094a867ae8805599745087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt;:  The function argument's value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object's data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.</source>
          <target state="translated">&lt;strong&gt;Вызов / передача по ссылке&lt;/strong&gt; : значение аргумента функции может / будет обновляться напрямую с помощью соответствующего параметра функции. Если это помогает, параметр функции становится эффективным &amp;laquo;псевдонимом&amp;raquo; для аргумента - они фактически ссылаются на одно и то же значение в одной и той же ячейке памяти. Если аргумент функции является переменной объекта, возможность изменять данные объекта ничем не отличается от случая передачи по значению, поскольку параметр функции будет по-прежнему указывать на тот же объект, что и аргумент. Но в случае переменной объекта, если для параметра функции задан совершенно другой объект, то аргумент также будет указывать на другой объект - этого не происходит в случае передачи по значению.</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c12cc2e2533791936e57d4b9415ab42ea32e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex&lt;/strong&gt;: When you access a complex type you work on a reference to its value</source>
          <target state="translated">&lt;strong&gt;Сложный&lt;/strong&gt; : при доступе к сложному типу вы работаете со ссылкой на его значение</target>
        </trans-unit>
        <trans-unit id="1301250d5301f648cf05701bd59197e854b822ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;: Variable outside the function which is passed to the function by the caller.</source>
          <target state="translated">&lt;strong&gt;Аргумент функции&lt;/strong&gt; : переменная вне функции, которая передается функции вызывающей стороной.</target>
        </trans-unit>
        <trans-unit id="65492a390eb86ea3356e64d01cfaa27d6c3fab3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function parameter&lt;/strong&gt;:  Variable declared in a function definition, used for referencing variables passed to the function.</source>
          <target state="translated">&lt;strong&gt;Параметр функции&lt;/strong&gt; : Переменная, объявленная в определении функции, используется для ссылки на переменные, передаваемые в функцию.</target>
        </trans-unit>
        <trans-unit id="65a6814d6b676f546b18918b30e471d0b5236d77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Memory location&lt;/strong&gt;:  Where a variable's value is stored.  (The location itself is represented by a number separate from the value stored at the location.)</source>
          <target state="translated">&lt;strong&gt;Память&lt;/strong&gt; : где хранится значение переменной. (Само местоположение представлено числом, отдельным от значения, хранящегося в этом месте.)</target>
        </trans-unit>
        <trans-unit id="5996d89441c8d0e61fe5412acbb5b6378fb43e74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object clone/copy&lt;/strong&gt;: A new object is created and the original object's data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.</source>
          <target state="translated">&lt;strong&gt;Клонирование / копирование&lt;/strong&gt; объекта. Создается новый объект и копируются данные исходного объекта. Это может быть глубокая или мелкая копия, но дело в том, что создается новый объект. Создание копии объекта является отдельным понятием от передачи по значению. Некоторые языки различают объект класса и структуры (или тому подобное) и могут иметь разное поведение для передачи переменных разных типов. Но JavaScript не делает ничего подобного автоматически при передаче объектных переменных. Но отсутствие автоматического клонирования объектов не означает переход по ссылке.</target>
        </trans-unit>
        <trans-unit id="fa53139221548e1fd770ad7abe04c1dc6d698150" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object variable&lt;/strong&gt;:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object's actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.</source>
          <target state="translated">&lt;strong&gt;Переменная объекта&lt;/strong&gt; : переменная, базовое значение которой не является самим &amp;laquo;объектом&amp;raquo;, скорее ее значение является указателем (значением ячейки памяти) на другое место в памяти, где хранятся фактические данные объекта. В большинстве языков более высокого поколения аспект &amp;laquo;указатель&amp;raquo; эффективно скрывается за счет автоматической разыменования в различных контекстах.</target>
        </trans-unit>
        <trans-unit id="d880bbb046dd0fb8ed275862bb6d9eb727b33d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача по ссылке (объекты)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab95d2eb7f10fa0819e1bef83f4bd83e6ae79ba7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value (primitive type)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача по значению (примитивный тип)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d87f3236c9b7ff2b627b66d6a54c489872ad459f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass-by-value or Call-by-sharing (for objects)&lt;/strong&gt;:  The function argument's value is COPIED to another memory location which is referenced by the function's parameter symbol (regardless of whether it's on the stack or heap).  In other words, the function parameter received a copy of the passed argument's value... AND (critical) the argument's value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable's value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter's value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument's value IS NEVER UPDATED, so it will continue to point to the &lt;em&gt;same&lt;/em&gt; object throughout and even after the function call (even if its object's data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.</source>
          <target state="translated">&lt;strong&gt;Передача по значению или Call-by-share (для объектов)&lt;/strong&gt; : значение аргумента функции копируется в другое место в памяти, на которое ссылается символ параметра функции (независимо от того, находится он в стеке или в куче). Другими словами, параметр функции получил копию значения переданного аргумента ... И (критический) значение аргумента НИКОГДА НЕ ОБНОВЛЯЕТСЯ / ИЗМЕНЕНО / ИЗМЕНЕНО вызывающей функцией. Помните, что значение переменной объекта НЕ является самим объектом, скорее это указатель на объект, поэтому передача переменной объекта по значению копирует указатель на переменную параметра функции. Значение параметра функции указывает на точно такой же объект в памяти. Сами данные объекта могут быть изменены непосредственно через параметр функции, НО значение аргумента функции НИКОГДА НЕ ОБНОВЛЯЕТСЯ, поэтому оно будет продолжать указывать на один и тот &lt;em&gt;же&lt;/em&gt; объект во время и даже после вызова функции (даже если данные его объекта были изменены или если параметру функции назначается совсем другой объект). Неверно утверждать, что аргумент функции был передан по ссылке только потому, что указанный объект является обновляемым через переменную параметра функции.</target>
        </trans-unit>
        <trans-unit id="3daa908ef93ef3beddf5ee815280e35804b2ab50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitive variable&lt;/strong&gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable's value IS the actual value represented by the variable's symbol rather than a pointer to another memory location.</source>
          <target state="translated">&lt;strong&gt;Примитивная переменная&lt;/strong&gt; : переменная, значение которой является фактическим значением. Даже эта концепция может быть усложнена автобоксом и подобными объектам контекстами различных языков, но общие идеи состоят в том, что значение переменной является фактическим значением, представленным символом переменной, а не указателем на другое место в памяти.</target>
        </trans-unit>
        <trans-unit id="738f561981f804bed95647891f285ca2a07e0ffc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitives&lt;/strong&gt;: When you access a primitive type you work directly on its
value</source>
          <target state="translated">&lt;strong&gt;Примитивы&lt;/strong&gt; : когда вы обращаетесь к примитивному типу, вы работаете непосредственно с его значением</target>
        </trans-unit>
        <trans-unit id="f1d08a4ffaed6d05dab4d5131e21bf7f0ad7cc25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special case, pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Особый случай, передача по ссылке (объекты)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d30d6d093711f7dc4bbd3b5d3e73777eb88a76b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symbol&lt;/strong&gt;:  Text string used to refer to variable (i.e. variable's name).</source>
          <target state="translated">&lt;strong&gt;Символ&lt;/strong&gt; : текстовая строка, используемая для ссылки на переменную (т.е. имя переменной).</target>
        </trans-unit>
        <trans-unit id="dbb628f544b2f5b04bb5df870aacd2b707683b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;:  Particular bits stored in memory and referenced using variable's symbol.</source>
          <target state="translated">&lt;strong&gt;Значение&lt;/strong&gt; : конкретные биты, хранящиеся в памяти и на которые ссылается символ переменной.</target>
        </trans-unit>
        <trans-unit id="4a4a44d5c5dbc605d366445b9f5e39a3dbd71772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variable&lt;/strong&gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.</source>
          <target state="translated">&lt;strong&gt;Переменная&lt;/strong&gt; : объединенная концепция символа, который ссылается на значение в определенном месте в памяти. Этот термин обычно слишком загружен, чтобы использовать его отдельно при обсуждении деталей.</target>
        </trans-unit>
        <trans-unit id="5a8e1fdd316d10b0c0cd59d94a6940772041c1cd" translate="yes" xml:space="preserve">
          <source>A object is automatically passed by reference, without the need to specifically state it</source>
          <target state="translated">Объект автоматически передается по ссылке,без необходимости конкретно указывать его состояние.</target>
        </trans-unit>
        <trans-unit id="b440a38266bd3bd8023694ca76f1853cb56c68f1" translate="yes" xml:space="preserve">
          <source>A primitive value passed to a function cannot be modified by the function. A copy is made.</source>
          <target state="translated">Примитивное значение,переданное функции,не может быть изменено функцией.Копия делается.</target>
        </trans-unit>
        <trans-unit id="79ce62763f1e30b37f20149148f8548734cf61b5" translate="yes" xml:space="preserve">
          <source>A very detailed explanation about copying, passing and comparing by value and by reference is in &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;this chapter&lt;/a&gt; of the &lt;em&gt;&quot;JavaScript: The Definitive Guide&quot;&lt;/em&gt; book.</source>
          <target state="translated">Очень подробное объяснение о копировании, передаче и сравнении по значению и по ссылке содержится в &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;этой главе&lt;/a&gt; книги &lt;em&gt;&amp;laquo;JavaScript: Полное руководство&amp;raquo;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f9d35a2aa876badcd3c415f65100051e77924dd6" translate="yes" xml:space="preserve">
          <source>Access of Object Properties</source>
          <target state="translated">Доступ к свойствам объекта</target>
        </trans-unit>
        <trans-unit id="3e9807bf09a22721f2ffa94b835d05c65938f14a" translate="yes" xml:space="preserve">
          <source>Again, we pick a favorite.</source>
          <target state="translated">Опять же,мы выбираем фаворита.</target>
        </trans-unit>
        <trans-unit id="988045fdd90b44521a9b2b9c55dfe875b6ad44e6" translate="yes" xml:space="preserve">
          <source>Although it doesn't really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?</source>
          <target state="translated">Хотя в конце концов это не имеет значения,я хочу знать,что является правильным способом представления аргументов,проходящих через конвенции.Есть ли выдержка из спецификации JavaScript,которая определяет,что должно быть семантикой по этому поводу?</target>
        </trans-unit>
        <trans-unit id="96ef530acd2543eafd4ab0cb7e97e8162bcf66fb" translate="yes" xml:space="preserve">
          <source>Always remember that the equals sign (=) means assignment.
Always remember that passing a parameter to a function &lt;em&gt;in JavaScript&lt;/em&gt; also means assignment.
They are the same and the 2 variables are connected in exactly the same way (which is to say they aren't, unless you count that they are assigned to the same object).</source>
          <target state="translated">Всегда помните, что знак равенства (=) означает присваивание. Всегда помните, что передача параметра в функцию &lt;em&gt;в JavaScript&lt;/em&gt; также означает присваивание. Они одинаковы, и эти 2 переменные связаны одинаково (то есть они не связаны, если не считать, что они назначены одному и тому же объекту).</target>
        </trans-unit>
        <trans-unit id="bfdc1eb7888008268dcd1f229efc00ed9fe4071e" translate="yes" xml:space="preserve">
          <source>An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:</source>
          <target state="translated">Легкий способ определить,является ли что-то &quot;передачей по ссылке&quot;,-это записать функцию &quot;подкачки&quot;.Например,в C можно сделать:</target>
        </trans-unit>
        <trans-unit id="3055a2e0457cb299ca6d433ebcc210c7bab9799e" translate="yes" xml:space="preserve">
          <source>An object outside a function is passed into a function by giving a reference to the outside object.</source>
          <target state="translated">Объект вне функции передается в функцию,давая ссылку на внешний объект.</target>
        </trans-unit>
        <trans-unit id="b05bb9226e6abe9287bbf028bf6e5a6bed6624b9" translate="yes" xml:space="preserve">
          <source>An object passed to a function can have its members modified by the function.</source>
          <target state="translated">Объект,переданный функции,может иметь свои члены,измененные функцией.</target>
        </trans-unit>
        <trans-unit id="29e123b648bf0a31ec900d67e265e2a81d689d3d" translate="yes" xml:space="preserve">
          <source>Array and Object is passed as  pass by reference or  pass by value based on these two condition.</source>
          <target state="translated">Массив и Объект передаются по ссылке или по значению,основанному на этих двух условиях.</target>
        </trans-unit>
        <trans-unit id="7628591e37cbe88cf6fb309ba297bb58229eacac" translate="yes" xml:space="preserve">
          <source>As a final example, consider why a common attempt to clear an array doesn't work as expected.</source>
          <target state="translated">В качестве последнего примера рассмотрим,почему обычная попытка очистить массив работает не так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="178ee3db1a483706ed36d79f599e1a13d33df86f" translate="yes" xml:space="preserve">
          <source>Before we leave the topic of
  manipulating objects and arrays by
  reference, we need to clear up a point
  of nomenclature.</source>
          <target state="translated">Прежде чем оставить тему манипулирования объектами и массивами по ссылке,необходимо прояснить точку номенклатуры.</target>
        </trans-unit>
        <trans-unit id="f8884a4d2e00d4a1e326a98a062754846001f9b2" translate="yes" xml:space="preserve">
          <source>Both our favoriteString and string1 variables are assigned to 'Hello world'. Now, what if we want to change our favoriteString??? What will happen???</source>
          <target state="translated">И наши любимыеString и string1 переменные присвоены 'Hello world'.Что,если мы захотим изменить наш любимыйString? Что случится?</target>
        </trans-unit>
        <trans-unit id="aa133f04e687ffaadb65bfc4786e9aafccdad56e" translate="yes" xml:space="preserve">
          <source>But both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are separate references to the same shared value &lt;code&gt;[1,2,3]&lt;/code&gt;, which is a compound value. It's important to note that neither &lt;code&gt;c&lt;/code&gt; nor &lt;code&gt;d&lt;/code&gt; more &quot;owns&quot; the &lt;code&gt;[1,2,3]&lt;/code&gt; value -- both are just equal peer references to the value. So, when using either reference to modify (&lt;code&gt;.push(4)&lt;/code&gt;) the actual shared &lt;code&gt;array&lt;/code&gt; value itself, it's affecting just the one shared value, and both references will reference the newly modified value &lt;code&gt;[1,2,3,4]&lt;/code&gt;.</source>
          <target state="translated">Но и &lt;code&gt;c&lt;/code&gt; , и &lt;code&gt;d&lt;/code&gt; - это отдельные ссылки на одно и то же общее значение &lt;code&gt;[1,2,3]&lt;/code&gt; , которое является составным значением. Важно отметить, что ни &lt;code&gt;c&lt;/code&gt; , ни &lt;code&gt;d&lt;/code&gt; more не &amp;laquo;владеют&amp;raquo; значением &lt;code&gt;[1,2,3]&lt;/code&gt; - оба являются равными равноправными ссылками на значение. Таким образом, при использовании любой ссылки для изменения ( &lt;code&gt;.push(4)&lt;/code&gt; ) самого фактического значения общего &lt;code&gt;array&lt;/code&gt; это влияет только на одно общее значение, и обе ссылки будут ссылаться на вновь измененное значение &lt;code&gt;[1,2,3,4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="296985a800b1e8c9380cebd23dfbc86e71426942" translate="yes" xml:space="preserve">
          <source>Call CheckObjectCoercible(baseValue).</source>
          <target state="translated">Вызов CheckObjectCoercible(baseValue).</target>
        </trans-unit>
        <trans-unit id="393aa90af622b95d2fecad8fb5a88f507b3e5d67" translate="yes" xml:space="preserve">
          <source>Changing the value of any changes value for both the variable.</source>
          <target state="translated">Изменение значения любого изменения для обеих переменных.</target>
        </trans-unit>
        <trans-unit id="e68569b88f0d63d426d55a5ad6eb50201341e31f" translate="yes" xml:space="preserve">
          <source>Compound value (object, array, etc) that can be passed by reference-copy</source>
          <target state="translated">Сложное значение (объект,массив и т.д.),которое может быть передано по ссылке-копии</target>
        </trans-unit>
        <trans-unit id="26b600a5d56d8944d8651beec06ae0642c20e289" translate="yes" xml:space="preserve">
          <source>Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.</source>
          <target state="translated">Рассмотрим аргументы и объекты-переменные-это объекты,созданные в процессе выполнения контекста,созданного в начале вызова функции-и ваша фактическая ссылка на значение,переданное в функцию,просто сохраняется в этих аргументах+объекты-переменные.</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">Рассмотрим следующее:</target>
        </trans-unit>
        <trans-unit id="5cecf4a03ec84caeeda78029a5bd713522ec8fe8" translate="yes" xml:space="preserve">
          <source>Construction of Argument Lists</source>
          <target state="translated">Строительство списков аргументов</target>
        </trans-unit>
        <trans-unit id="635aa588bea9df239881e622d2cd3adbad8bf3c9" translate="yes" xml:space="preserve">
          <source>Definition of &quot;Object&quot;</source>
          <target state="translated">Определение &quot;Объекта&quot;</target>
        </trans-unit>
        <trans-unit id="e9656fda095be85a55c47e88f0f2142837377331" translate="yes" xml:space="preserve">
          <source>E.g.:</source>
          <target state="translated">E.g.:</target>
        </trans-unit>
        <trans-unit id="e8a531332b5e0c2dac36ce0017c63f03c75815b9" translate="yes" xml:space="preserve">
          <source>Every time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.</source>
          <target state="translated">Каждый раз,когда вы передаете переменную в функцию,вы &quot;присваиваете&quot; любое имя переменной параметра,как если бы вы использовали знак равенства (=).</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="83b1fe6393f9ea04f7c6ef0ebceb29757afe9a44" translate="yes" xml:space="preserve">
          <source>First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.</source>
          <target state="translated">Прежде всего,существует множество уровней абстракции,которые,кажется,не все понимают.Начинающим программистам,выучившим язык 4-го или 5-го поколения,может быть трудно зацикливаться на понятиях,знакомых ассемблерам или программистам на языке Си,не фазовый,с помощью указок на указки.Pass-by-reference не просто означает возможность изменить объект,на который ссылаются,используя переменную параметра функции.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">Например</target>
        </trans-unit>
        <trans-unit id="01bf4a9057daf1172b230a29ebe7eb0911eb8d6d" translate="yes" xml:space="preserve">
          <source>For programming language lawyers, I've went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;asking&lt;/a&gt; it on the ECMAScript mailing list.</source>
          <target state="translated">Для юристов, изучающих язык программирования, я прошел следующие разделы ECMAScript 5.1 (который легче читать, чем последнее издание) и дошел до того, что &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;спросил&lt;/a&gt; об этом в списке рассылки ECMAScript.</target>
        </trans-unit>
        <trans-unit id="bd46cdb9b904080183e993ad3943a7303f85bd9f" translate="yes" xml:space="preserve">
          <source>Functions are objects</source>
          <target state="translated">Функции являются объектами</target>
        </trans-unit>
        <trans-unit id="2fb8e5522eb18d1143e0bd9cb31d216fa77b5c59" translate="yes" xml:space="preserve">
          <source>Here is a rebuttal to this:</source>
          <target state="translated">Вот вам опровержение:</target>
        </trans-unit>
        <trans-unit id="47be461e851afeca8344b89d76c09b76e3e854ed" translate="yes" xml:space="preserve">
          <source>Here is an example, passing a number (a primitive type)</source>
          <target state="translated">Вот пример,передача числа (примитивный тип)</target>
        </trans-unit>
        <trans-unit id="6d1956753d691a97c45c137388c4df02dd75b9c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;obj&lt;/code&gt; acts as a wrapper for the scalar primitive property &lt;code&gt;a&lt;/code&gt;. When passed to &lt;code&gt;foo(..)&lt;/code&gt;, a copy of the &lt;code&gt;obj&lt;/code&gt; reference is passed in and set to the &lt;code&gt;wrapper&lt;/code&gt;parameter. We now can use the &lt;code&gt;wrapper&lt;/code&gt; reference to access the shared object, and update its property. After the function finishes, &lt;code&gt;obj.a&lt;/code&gt; will see the updated value &lt;code&gt;42&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;obj&lt;/code&gt; действует как обёртка для скалярного примитивного свойства &lt;code&gt;a&lt;/code&gt; . Когда передается в &lt;code&gt;foo(..)&lt;/code&gt; , копия ссылки на &lt;code&gt;obj&lt;/code&gt; передается и устанавливается в параметр &lt;code&gt;wrapper&lt;/code&gt; . Теперь мы можем использовать ссылку на &lt;code&gt;wrapper&lt;/code&gt; для доступа к общему объекту и обновления его свойства. После завершения функции &lt;code&gt;obj.a&lt;/code&gt; увидит обновленное значение &lt;code&gt;42&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05dc205598b6fae1df14251d0f1b665f0352c482" translate="yes" xml:space="preserve">
          <source>Here, we mean
  simply that a reference to an object
  or array -- not the object itself --
  is passed to a function. A function
  can use the reference to modify
  properties of the object or elements
  of the array. But if the function
  overwrites the reference with a
  reference to a new object or array,
  that modification is not visible
  outside of the function.</source>
          <target state="translated">Здесь мы имеем в виду,что в функцию передается просто ссылка на объект или массив,а не на сам объект.Функция может использовать ссылку для изменения свойств объекта или элементов массива.Но если функция перезаписывает ссылку со ссылкой на новый объект или массив,то это изменение не видно вне функции.</target>
        </trans-unit>
        <trans-unit id="ec613745ca6fb8018d61844fbac16fd497f35e96" translate="yes" xml:space="preserve">
          <source>I have found the &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend method&lt;/a&gt; of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js library&lt;/a&gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.</source>
          <target state="translated">Я считаю, что &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;метод extend&lt;/a&gt; &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;библиотеки Underscore.js&lt;/a&gt; очень полезен, когда я хочу передать объект в качестве параметра, который можно либо изменить, либо заменить целиком.</target>
        </trans-unit>
        <trans-unit id="da00583f56bed3adae6b3854cb9669d9ef039b2e" translate="yes" xml:space="preserve">
          <source>I would say it is pass-by-copy -</source>
          <target state="translated">Я бы сказал,что это проезжая копия -</target>
        </trans-unit>
        <trans-unit id="99152f78f2285e9f5178a28c6ae891d22918905b" translate="yes" xml:space="preserve">
          <source>I've read through these answers multiple times, but didn't REALLY get it until I learned about the technical definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;Call by sharing&quot;&lt;/a&gt; as termed by Barbara Liskov</source>
          <target state="translated">Я прочитал эти ответы несколько раз, но ДЕЙСТВИТЕЛЬНО не получил его, пока не узнал о техническом определении &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&amp;laquo;Позвонить, поделившись&amp;raquo;,&lt;/a&gt; как его назвала Барбара Лисков.</target>
        </trans-unit>
        <trans-unit id="668d70912c4017d9abe459009e674ca09138a746" translate="yes" xml:space="preserve">
          <source>I.e. effectively primitive types are passed by value, and complex types are passed by reference.</source>
          <target state="translated">Т.е.фактически примитивные типы передаются по значению,а сложные-по ссылке.</target>
        </trans-unit>
        <trans-unit id="0ec6ec8507ceaa91f883d8986d51cbca5f8b1a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj1&lt;/code&gt; was not a reference at all, then changing &lt;code&gt;obj1.item&lt;/code&gt; would have no effect on the &lt;code&gt;obj1&lt;/code&gt; outside of the function.</source>
          <target state="translated">Если &lt;code&gt;obj1&lt;/code&gt; вообще не является ссылкой, то изменение &lt;code&gt;obj1.item&lt;/code&gt; не будет влиять на &lt;code&gt;obj1&lt;/code&gt; вне функции.</target>
        </trans-unit>
        <trans-unit id="59dbe46a8ab60f48cf2577d1714a38c220edd92d" translate="yes" xml:space="preserve">
          <source>If the argument was a proper reference, then everything would have changed. &lt;code&gt;num&lt;/code&gt; would be &lt;code&gt;100&lt;/code&gt;, and &lt;code&gt;obj2.item&lt;/code&gt; would read &lt;code&gt;&quot;changed&quot;&lt;/code&gt;.</source>
          <target state="translated">Если бы аргумент был правильной ссылкой, то все бы изменилось. &lt;code&gt;num&lt;/code&gt; будет &lt;code&gt;100&lt;/code&gt; , а &lt;code&gt;obj2.item&lt;/code&gt; будет читать &lt;code&gt;&quot;changed&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8184ee6c0e0f41f78f07ffde38ac0df94ff1ef63" translate="yes" xml:space="preserve">
          <source>If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let
  strict be false.</source>
          <target state="translated">Если оцениваемая синтаксическая продукция содержится в строгом коде режима,пусть строгая правда,а строгая ложь.</target>
        </trans-unit>
        <trans-unit id="0514b00b4153ffccc1fdf8db144a3bb4f96beb69" translate="yes" xml:space="preserve">
          <source>If you can't do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.</source>
          <target state="translated">Если вы не можете сделать эквивалент в JavaScript,то это не &quot;передача по ссылке&quot;.</target>
        </trans-unit>
        <trans-unit id="ed437ed8c9b163811c8c45a0df65ee0cfa2b2119" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;strong&gt;objects&lt;/strong&gt; are stored as references:</source>
          <target state="translated">В JavaScript &lt;strong&gt;объекты&lt;/strong&gt; хранятся в виде ссылок:</target>
        </trans-unit>
        <trans-unit id="4a244292f7a66631a95bd0016a42e5a3d8a6fdee" translate="yes" xml:space="preserve">
          <source>In JavaScript, the type of the value &lt;em&gt;solely&lt;/em&gt; controls whether that value will be assigned by &lt;strong&gt;value-copy&lt;/strong&gt; or by &lt;strong&gt;reference-copy&lt;/strong&gt;.</source>
          <target state="translated">В JavaScript тип значения определяет &lt;em&gt;только&lt;/em&gt; то, будет ли это значение присваиваться &lt;strong&gt;значением-копией&lt;/strong&gt; или &lt;strong&gt;ссылкой-копией&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf140191af1dcec987a4dde5edb6fb8a16e09a25" translate="yes" xml:space="preserve">
          <source>In a low level language, if you want to pass a variable by reference you have to use a specific syntax in the creation of the function:</source>
          <target state="translated">На языке низкого уровня,если вы хотите передать переменную по ссылке,то при создании функции необходимо использовать определенный синтаксис:</target>
        </trans-unit>
        <trans-unit id="81c7785c18e39819bdc6bf53496b0a9a6239d0fc" translate="yes" xml:space="preserve">
          <source>In both alerts you will find the value to be undefined.</source>
          <target state="translated">В обоих предупреждениях вы найдете значение,которое не определено.</target>
        </trans-unit>
        <trans-unit id="35606096aee27d974b3090d3e8e5ae1f3bda2fd4" translate="yes" xml:space="preserve">
          <source>In my book that's called passing by reference.</source>
          <target state="translated">В моей книге,которая называется &quot;мимоходом по ссылке&quot;.</target>
        </trans-unit>
        <trans-unit id="3f390d1963a58a5cc587e0e6330cf78dff59fc86" translate="yes" xml:space="preserve">
          <source>In practical terms, this means that if you change the parameter itself (as with &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt;), that won't affect the item that was fed into the parameter. But if you change the &lt;strong&gt;INTERNALS&lt;/strong&gt; of the parameter, that will propagate back up (as with &lt;code&gt;obj1&lt;/code&gt;).</source>
          <target state="translated">На практике это означает, что если вы измените сам параметр (как в случае с &lt;code&gt;num&lt;/code&gt; и &lt;code&gt;obj2&lt;/code&gt; ), это не повлияет на элемент, который был передан в параметр. Но если вы измените &lt;strong&gt;ВНУТРЕННИЕ&lt;/strong&gt; значения параметра, он будет распространяться обратно (как в случае с &lt;code&gt;obj1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b57ba2b5cb9f82c19123db765fac17e24d1951eb" translate="yes" xml:space="preserve">
          <source>In the above snippet, because &lt;code&gt;2&lt;/code&gt; is a scalar primitive, &lt;code&gt;a&lt;/code&gt; holds one initial copy of that value, and &lt;code&gt;b&lt;/code&gt; is assigned another copy of the value. When changing &lt;code&gt;b&lt;/code&gt;, you are in no way changing the value in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше фрагменте, поскольку &lt;code&gt;2&lt;/code&gt; является скалярным примитивом, &lt;code&gt;a&lt;/code&gt; содержит одну начальную копию этого значения, а &lt;code&gt;b&lt;/code&gt; назначается другая копия значения. При изменении &lt;code&gt;b&lt;/code&gt; вы никоим образом не изменяете значение в &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be98568917515ecc47f6e69cddc320618b40a6f" translate="yes" xml:space="preserve">
          <source>Inside the function, parameter variables, &lt;code&gt;inVar1&lt;/code&gt; and &lt;code&gt;inVar2&lt;/code&gt;, receive the contents being passed.</source>
          <target state="translated">Внутри функции переменные параметров &lt;code&gt;inVar1&lt;/code&gt; и &lt;code&gt;inVar2&lt;/code&gt; получают передаваемое содержимое.</target>
        </trans-unit>
        <trans-unit id="eb0aded998f21b511a6bf2ba99f8f35d22c1fb84" translate="yes" xml:space="preserve">
          <source>Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is &lt;em&gt;itself&lt;/em&gt; a reference.
Technically, this is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;call-by-sharing&lt;/a&gt;.</source>
          <target state="translated">Вместо этого, ситуация такова, что переданный элемент передается по значению. Но элемент, который передается по значению, &lt;em&gt;сам&lt;/em&gt; по &lt;em&gt;себе&lt;/em&gt; является ссылкой. Технически это называется совместным использованием &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;вызовов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d302320d7430fecc028a90dc07690d841f6022" translate="yes" xml:space="preserve">
          <source>Is JavaScript a pass-by-reference or pass-by-value language</source>
          <target state="translated">Является ли JavaScript языком,проходящим по ссылке или по значению.</target>
        </trans-unit>
        <trans-unit id="762dca873ea18a90a6df0ccb480c5023409ab8ee" translate="yes" xml:space="preserve">
          <source>It is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;effort&lt;/a&gt; to understand.</source>
          <target state="translated">В редакции 5.1 определено, что &amp;laquo;Объект - это набор свойств&amp;raquo;. Следовательно, мы можем сделать вывод, что значением объекта является коллекция, но что касается значения коллекции, оно плохо определено в спецификации и требует немного &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;усилий&lt;/a&gt; для понимания.</target>
        </trans-unit>
        <trans-unit id="986429e47688846136b52b4cd304e16867c4438c" translate="yes" xml:space="preserve">
          <source>It is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they're only used to describe the behavior of the delete, the typeof, and the assignment operators.</source>
          <target state="translated">В разделе 8.7 &quot;Тип спецификации ссылки&quot; описано,что ссылки в языке не являются реальными типами-они используются только для описания поведения операторов удаления,типа и присваивания.</target>
        </trans-unit>
        <trans-unit id="fc2fc8bac54ed799049c59646ec8689ad7f219e2" translate="yes" xml:space="preserve">
          <source>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its &lt;em&gt;members&lt;/em&gt;, those changes persist outside of the function.  This makes it &lt;em&gt;look&lt;/em&gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.</source>
          <target state="translated">Он всегда передается по значению, но для объектов значение переменной является ссылкой. Из-за этого, когда вы передаете объект и изменяете его &lt;em&gt;члены&lt;/em&gt; , эти изменения сохраняются вне функции. Это &lt;em&gt;выглядит&lt;/em&gt; как передача по ссылке. Но если вы на самом деле измените значение переменной объекта, вы увидите, что это изменение не сохраняется, доказывая, что оно действительно передается по значению.</target>
        </trans-unit>
        <trans-unit id="89a28927b7d2922705fe9300b7e6edf22dfdb59e" translate="yes" xml:space="preserve">
          <source>It's interesting in JavaScript. Consider this example:</source>
          <target state="translated">Интересно на JavaScript.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="a58c0376442784131cce6ed16ca6889fa180a199" translate="yes" xml:space="preserve">
          <source>It's tempting to think that &lt;em&gt;primitives&lt;/em&gt; are enforced by special rules while &lt;em&gt;objects&lt;/em&gt; are not, but primitives are simply the end of the pointer chain.</source>
          <target state="translated">Заманчиво думать, что &lt;em&gt;примитивы&lt;/em&gt; применяются специальными правилами, а &lt;em&gt;объекты&lt;/em&gt; - нет, но примитивы - это просто конец цепочки указателей.</target>
        </trans-unit>
        <trans-unit id="0f6e466f49c26929af238bc6449efa0b8dbf2534" translate="yes" xml:space="preserve">
          <source>It's time to throw out everything you know about pass by value / reference.</source>
          <target state="translated">Пришло время выбросить все,что ты знаешь о том,как пройти по ссылке на значение.</target>
        </trans-unit>
        <trans-unit id="c1ad2e0efeecec9224ee8d6ce3fbe2b458a354fc" translate="yes" xml:space="preserve">
          <source>JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object's data via the function parameter is synonymous to &quot;pass-by-value&quot;.</source>
          <target state="translated">JavaScript не проходит по ссылке.Если вы внимательно прочитаете,то поймете,что все противоположные мнения неправильно понимают,что подразумевается под &quot;pass-by-value&quot;,и они ложно приходят к выводу,что возможность обновления данных объекта через параметр функции является синонимом &quot;pass-by-value&quot;.</target>
        </trans-unit>
        <trans-unit id="d2d80fc6a6ff698bf0fd9cfa17926536bf0021d5" translate="yes" xml:space="preserve">
          <source>JavaScript is always &lt;em&gt;pass-by-value&lt;/em&gt;; everything is of value type.</source>
          <target state="translated">JavaScript всегда &lt;em&gt;передается по значению&lt;/em&gt; ; все имеет значение типа.</target>
        </trans-unit>
        <trans-unit id="d61aca1d96d43376df88c4a107691b9524026ab9" translate="yes" xml:space="preserve">
          <source>JavaScript passes primitive types by value and object types by reference</source>
          <target state="translated">JavaScript передает примитивные типы по значению и типы объектов по ссылке</target>
        </trans-unit>
        <trans-unit id="821543b87e4b4527bdc1a22fea2a59bd6cf89783" translate="yes" xml:space="preserve">
          <source>Javascript is a high level language that does this conversion for you. 
So, although objects are passed by reference, the language converts the reference parameter to the value. You don't need to use &lt;code&gt;&amp;amp;&lt;/code&gt;, on the function definition, to pass it by reference, neither &lt;code&gt;*&lt;/code&gt;, on the function body, to convert the reference to the value, JS does it for you.</source>
          <target state="translated">Javascript - это язык высокого уровня, который делает это преобразование для вас. Таким образом, хотя объекты передаются по ссылке, язык преобразует параметр ссылки в значение. Вам не нужно использовать &lt;code&gt;&amp;amp;&lt;/code&gt; , для определения функции, чтобы передать ее по ссылке, а также &lt;code&gt;*&lt;/code&gt; , в теле функции, чтобы преобразовать ссылку в значение, JS сделает это за вас.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">Узнать больше</target>
        </trans-unit>
        <trans-unit id="e2890eaeaae54ae8213119b094d6eac3b0d0f34d" translate="yes" xml:space="preserve">
          <source>Let arg be GetValue(ref).</source>
          <target state="translated">Давайте поспорим о GetValue(ref).</target>
        </trans-unit>
        <trans-unit id="d5b52edd936f17bee3970c4c4428d8bdb2114974" translate="yes" xml:space="preserve">
          <source>Let baseReference be the result of evaluating MemberExpression.</source>
          <target state="translated">Пусть baseReference будет результатом оценки MemberExpression.</target>
        </trans-unit>
        <trans-unit id="5793a1bc1d3ece9a28dfc1f7df2511a7f09c3cea" translate="yes" xml:space="preserve">
          <source>Let baseValue be GetValue(baseReference).</source>
          <target state="translated">Пусть baseValue будет GetValue(baseReference).</target>
        </trans-unit>
        <trans-unit id="0fbb0a339d88c497bca6b7e0e0802f2e1a9e810f" translate="yes" xml:space="preserve">
          <source>Let propertyNameReference be the result of evaluating Expression.</source>
          <target state="translated">Пусть результатом оценки Expression будет свойствоNameReference.</target>
        </trans-unit>
        <trans-unit id="e26b41e64cfc85d8131bd89ab1968cf9b539bc12" translate="yes" xml:space="preserve">
          <source>Let propertyNameString be ToString(propertyNameValue).</source>
          <target state="translated">Пусть propertyNameString будет ToString(propertyNameValue).</target>
        </trans-unit>
        <trans-unit id="d27739e60a7d1d0ee771b1f518f987ee71282c40" translate="yes" xml:space="preserve">
          <source>Let propertyNameValue be GetValue(propertyNameReference).</source>
          <target state="translated">Пусть свойствоNameValue будет GetValue(propertyNameReference).</target>
        </trans-unit>
        <trans-unit id="765c825fb8ce47d020ac3dcc136c15f73cbaa9d1" translate="yes" xml:space="preserve">
          <source>Let ref be the result of evaluating AssignmentExpression.</source>
          <target state="translated">Пусть ref будет результатом оценки AssignmentExpression.</target>
        </trans-unit>
        <trans-unit id="ba443140669d7febc24e1df988b59f67bf1999bc" translate="yes" xml:space="preserve">
          <source>My simple way to understand this...</source>
          <target state="translated">Мой простой способ понять это...</target>
        </trans-unit>
        <trans-unit id="41e399d344b8bb63a9437372496bb38b9ea65720" translate="yes" xml:space="preserve">
          <source>My two cents... This is the way I understand it. (Feel free to correct me if I'm wrong)</source>
          <target state="translated">Мои два цента...Вот как я это понимаю.(Не стесняйся поправить меня,если я ошибаюсь)</target>
        </trans-unit>
        <trans-unit id="cc50c81892c92e84bb1ae3f1a86483bee39914a6" translate="yes" xml:space="preserve">
          <source>Next, for whatever reason, we decide that we like object 2 better. So, we simply do a little re-assignment.</source>
          <target state="translated">Далее,по какой-то причине,мы решаем,что нам больше нравится объект 2.Итак,мы просто делаем небольшое переназначение.</target>
        </trans-unit>
        <trans-unit id="5983d2311d0216c94667916653cda7009208c7ff" translate="yes" xml:space="preserve">
          <source>Nothing happened to object1 or to object2. We haven't changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.</source>
          <target state="translated">Ничего не случилось с объектом1 или с объектом2.Мы вообще не изменили никаких данных.Все,что мы сделали,это переназначили наш любимый объект.Важно знать,что объекту2 и любимомуОбъекту присваивается один и тот же объект.Мы можем изменить этот объект через любую из этих переменных.</target>
        </trans-unit>
        <trans-unit id="b0ed35c065098b7007966c00ae087554253b51c5" translate="yes" xml:space="preserve">
          <source>Now, let's say that we like object1 better... So, we &quot;assign&quot; a new variable.</source>
          <target state="translated">Скажем так,нам больше нравится объект1...Итак,мы &quot;присваиваем&quot; новую переменную.</target>
        </trans-unit>
        <trans-unit id="fefaeda9e706a96b72c3a91f6d46d3d47c7c5900" translate="yes" xml:space="preserve">
          <source>Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you simply assigned using the equal (=) sign.</source>
          <target state="translated">Теперь о функциях и передаче параметров.....Когда вы вызываете функцию и передаете параметр,то,по сути,вы делаете &quot;присваивание&quot; новой переменной,и это работает точно так же,как если бы вы просто присваивали,используя знак равенства (=).</target>
        </trans-unit>
        <trans-unit id="b357112211b094b3237788d525b078423b089167" translate="yes" xml:space="preserve">
          <source>Now, people like to bicker endlessly about whether &quot;pass by reference&quot;
  is the correct way to describe what Java et al. actually do. The point
  is this:</source>
          <target state="translated">Теперь люди любят бесконечно спорить о том,является ли &quot;передача по ссылке&quot; правильным способом описания того,что Java и др.на самом деле делают.Дело в этом:</target>
        </trans-unit>
        <trans-unit id="a7538e8091867206be4163070d38a8f2f6e2fc36" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function</source>
          <target state="translated">То же самое,но с функцией.</target>
        </trans-unit>
        <trans-unit id="54f947ec6644ed78ef13a3901e8e53b29b1eae30" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function call</source>
          <target state="translated">То же самое,но с вызовом функции...</target>
        </trans-unit>
        <trans-unit id="85abe287e946ffe23eec095f98389cf0bb761865" translate="yes" xml:space="preserve">
          <source>OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn't matter whether something is passed by reference or by value... What matters is assignment vs mutation.</source>
          <target state="translated">Хорошо,если вы прочитаете всю эту заметку,возможно,вы теперь лучше понимаете,как работают вызовы функций в JavaScript.Не имеет значения,передается ли что-то по ссылке или по значению...Важно то,что присваивание против мутации.</target>
        </trans-unit>
        <trans-unit id="49aff953ef64c0bfd256e94df786773f165a1a31" translate="yes" xml:space="preserve">
          <source>OK, let me do my best to explain what I mean. Let's say you have a few objects.</source>
          <target state="translated">Хорошо,позвольте мне сделать все,что в моих силах,чтобы объяснить,о чем я.Допустим,у тебя есть несколько объектов.</target>
        </trans-unit>
        <trans-unit id="d3ac732c421aaa382ba2a7df3b9370ee3d46965c" translate="yes" xml:space="preserve">
          <source>OK, now let&amp;rsquo;s give a few examples using objects instead... first, without the function.</source>
          <target state="translated">Хорошо, теперь давайте приведем несколько примеров использования объектов вместо ... во-первых, без функции.</target>
        </trans-unit>
        <trans-unit id="55f468caaf302476af028732ffb89566f3834bf7" translate="yes" xml:space="preserve">
          <source>OK, now let's look at primitives like strings for example</source>
          <target state="translated">Хорошо,теперь давайте посмотрим на примитивы вроде строк,например.</target>
        </trans-unit>
        <trans-unit id="ed4f6a94ec208043cd9b8120122b92570d99ac3f" translate="yes" xml:space="preserve">
          <source>Objects are passed by reference (the reference is passed by value).</source>
          <target state="translated">Объекты передаются по ссылке (ссылка передается по значению).</target>
        </trans-unit>
        <trans-unit id="a0023dbe18ebfeae7656c8332857dde47f6a7acc" translate="yes" xml:space="preserve">
          <source>Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an &lt;em&gt;object&lt;/em&gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are &lt;em&gt;primitives&lt;/em&gt;.</source>
          <target state="translated">Объекты являются значениями, а функции-члены объектов сами являются значениями (помните, что функции являются первоклассными объектами в JavaScript). Кроме того, относительно концепции, что все в JavaScript является &lt;em&gt;объектом&lt;/em&gt; ; это не правильно. Строки, символы, числа, логические значения, значения NULL и неопределенные значения являются &lt;em&gt;примитивами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7c473076e20653740c581b65a9c148582980e1f2" translate="yes" xml:space="preserve">
          <source>On Reference</source>
          <target state="translated">Для справки</target>
        </trans-unit>
        <trans-unit id="24023d41b24981459776a8deb45dffaf544e073a" translate="yes" xml:space="preserve">
          <source>On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:</source>
          <target state="translated">Иногда они могут использовать некоторые функции членов и свойства,унаследованные от их базовых прототипов,но это только для удобства.Это не означает,что они сами являются объектами.Для справки попробуйте следующее:</target>
        </trans-unit>
        <trans-unit id="4d12f26544314335beb7af690a37352634d31faf" translate="yes" xml:space="preserve">
          <source>One more example:</source>
          <target state="translated">Еще один пример:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="61d70ce6c0868b0a4084920bfa36265cd2924428" translate="yes" xml:space="preserve">
          <source>PHP does something similar since version 5: all objects are passed by reference, but all primitives &lt;em&gt;may&lt;/em&gt; be passed by reference, if preceded by an ampersand (&amp;amp;). Otherwise primitives are passed by value.</source>
          <target state="translated">PHP делает то же самое, начиная с версии 5: все объекты передаются по ссылке, но все примитивы &lt;em&gt;могут&lt;/em&gt; передаваться по ссылке, если перед ними стоит амперсанд (&amp;amp;). В противном случае примитивы передаются по значению.</target>
        </trans-unit>
        <trans-unit id="4aa6714b9431fbeb4050db107726bf42359cbd64" translate="yes" xml:space="preserve">
          <source>Passing an object does not copy the object.</source>
          <target state="translated">Передача объекта не копирует объект.</target>
        </trans-unit>
        <trans-unit id="177116d45ea2e23710bb7ea3a718654efa24f9bc" translate="yes" xml:space="preserve">
          <source>Passing arguments to a function in JavaScript is analogous to passing
parameters by pointer value in C:</source>
          <target state="translated">Передача аргументов в функцию в JavaScript аналогична передаче параметров по значению указателя в C:</target>
        </trans-unit>
        <trans-unit id="01f2294132d2e2f2b4566ede86b13262366d51fb" translate="yes" xml:space="preserve">
          <source>Primitives (number, Boolean, etc.) are passed by value.</source>
          <target state="translated">Примитивы (число,булев и т.д.)передаются по значению.</target>
        </trans-unit>
        <trans-unit id="1fbe034f18e45d911f35c38befd6ffef1237ff9d" translate="yes" xml:space="preserve">
          <source>Primitives are passed by value and objects are passed by reference. This is quite different from other languages like C, Visual Basic, or Delphi. I can't say how they handle objects and primitives exactly, but I know of Visual Basic and Delphi that it can (and should) be specified.</source>
          <target state="translated">Примитивы передаются по значению,а объекты-по ссылке.Это сильно отличается от других языков,таких как C,Visual Basic или Delphi.Не могу сказать,как именно они работают с объектами и примитивами,но я знаю о Visual Basic и Delphi,что он может (и должен)быть указан.</target>
        </trans-unit>
        <trans-unit id="b3a5e4b79e22cee55b6065ffe3f652237cc7594a" translate="yes" xml:space="preserve">
          <source>Readers
  familiar with the other meaning of
  this term may prefer to say that
  objects and arrays are passed by
  value, but the value that is passed is
  actually a reference rather than the
  object itself.</source>
          <target state="translated">Читатели,знакомые с другим значением этого термина,могут предпочесть сказать,что объекты и массивы передаются по значению,но передаваемое значение на самом деле является ссылкой,а не самим объектом.</target>
        </trans-unit>
        <trans-unit id="13206fd4fe5b59fc41e3d5a63a6488e8b552facb" translate="yes" xml:space="preserve">
          <source>Reassigning a variable merely points that pointer at a new value.</source>
          <target state="translated">Перераспределение переменной просто указывает на то,что указатель на новое значение.</target>
        </trans-unit>
        <trans-unit id="3207f76b42378372483b9234b1caf6f7a147a617" translate="yes" xml:space="preserve">
          <source>Reassigning a variable will never affect other variables that were pointing at that same object</source>
          <target state="translated">Перераспределение переменной никогда не повлияет на другие переменные,которые указывали на тот же самый объект</target>
        </trans-unit>
        <trans-unit id="d310f078235065dddc3b458e5e588f59ca402bb8" translate="yes" xml:space="preserve">
          <source>Repeating this with an object yields different results:</source>
          <target state="translated">Повторение этого с объектом дает разные результаты:</target>
        </trans-unit>
        <trans-unit id="203297a3389833da40302baa74058f84dfb4172b" translate="yes" xml:space="preserve">
          <source>Return a List whose sole item is arg.</source>
          <target state="translated">Возвратить список,единственным пунктом которого является спор.</target>
        </trans-unit>
        <trans-unit id="fea577a31c06a6a5a9a25864cabd1f7cd04ffc69" translate="yes" xml:space="preserve">
          <source>Section 11.2.1 &quot;Property Accessors&quot;</source>
          <target state="translated">Раздел 11.2.1 &quot;Имущественные аксессуары&quot;.</target>
        </trans-unit>
        <trans-unit id="e3cdf6da05c63ab4f98f08c709113dc947f4641b" translate="yes" xml:space="preserve">
          <source>Section 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:</source>
          <target state="translated">В разделе 11.2.4 &quot;Списки аргументов&quot; говорится следующее о составлении списка аргументов,состоящего только из одного аргумента:</target>
        </trans-unit>
        <trans-unit id="3dffa3d82c957452592ddbe22ee7b9fbabbad396" translate="yes" xml:space="preserve">
          <source>Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).</source>
          <target state="translated">Семантика!!! Установка конкретных определений обязательно сделает некоторые ответы и комментарии несовместимыми,так как они не описывают одно и то же даже при использовании одних и тех же слов и фраз,но очень важно забыть о путанице (особенно для новых программистов).</target>
        </trans-unit>
        <trans-unit id="9042860968c9655fa63ade5546c81f532a616526" translate="yes" xml:space="preserve">
          <source>Simple values inside functions will not change those values outside of the function (they are passed by value), whereas complex ones will (they are passed by reference).</source>
          <target state="translated">Простые значения внутри функций не будут изменять эти значения вне функции (они передаются по значению),тогда как сложные-будут (они передаются по ссылке).</target>
        </trans-unit>
        <trans-unit id="af00e0ad8adf530d42297d91d90e47a9e641005b" translate="yes" xml:space="preserve">
          <source>Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.</source>
          <target state="translated">Проще говоря,для примитивных типов значения копируются в начале вызова функции,для типа объекта-ссылка.</target>
        </trans-unit>
        <trans-unit id="14e546fc199d754d3c9fb63d6f7e0dc0eda5708f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;inVar2&lt;/code&gt; received the reference of &lt;code&gt;{ prop: 2 }&lt;/code&gt;, you can change the value of the object's property.</source>
          <target state="translated">Поскольку &lt;code&gt;inVar2&lt;/code&gt; получил ссылку &lt;code&gt;{ prop: 2 }&lt;/code&gt; , вы можете изменить значение свойства объекта.</target>
        </trans-unit>
        <trans-unit id="6b26d53b2a6c26d221c34b2ced9596e48f74edf5" translate="yes" xml:space="preserve">
          <source>So changing the value of a variable doesn't affect the other, as they both reside in two different locations.</source>
          <target state="translated">Таким образом,изменение значения переменной не влияет на другое,так как они оба находятся в двух разных местах.</target>
        </trans-unit>
        <trans-unit id="f443d83baee5de8b57871adc873303085a0467cd" translate="yes" xml:space="preserve">
          <source>So in JavaScript, if I pass an object X into a function via a parameter, it will still be X. If you are changing data &lt;em&gt;inside&lt;/em&gt; the function (or any other object, but that's not important) that new value is also available outside the function.</source>
          <target state="translated">Поэтому в JavaScript, если я передам объект X в функцию через параметр, он все равно будет X. Если вы изменяете данные &lt;em&gt;внутри&lt;/em&gt; функции (или любой другой объект, но это не важно), это новое значение также доступно за пределами функция.</target>
        </trans-unit>
        <trans-unit id="8f7623c6dec052db957de7605896e4a2a3e6b647" translate="yes" xml:space="preserve">
          <source>So, &lt;strike&gt;forget about &lt;em&gt;&quot;pass by reference/value&quot;&lt;/em&gt;&lt;/strike&gt; don't get hung up on &quot;pass by reference/value&quot; because:</source>
          <target state="translated">Итак, &lt;strike&gt;забудьте о &lt;em&gt;&amp;laquo;передаче по ссылке / значению&amp;raquo;&lt;/em&gt;&lt;/strike&gt; , не зацикливайтесь на &amp;laquo;передаче по ссылке / значению&amp;raquo;, потому что:</target>
        </trans-unit>
        <trans-unit id="68d38550c4da9fcceac584158479a156958fb538" translate="yes" xml:space="preserve">
          <source>Some final comments:</source>
          <target state="translated">Некоторые заключительные комментарии:</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="26220bb61f95026a6699bda5f772ab5f459fb7d2" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</source>
          <target state="translated">Источник: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00317f5e100f735c8f89f41e078aacbee58460d5" translate="yes" xml:space="preserve">
          <source>Strings are immutable, so it doesn't really matter for them.</source>
          <target state="translated">Струны непреложны,так что для них это не имеет значения.</target>
        </trans-unit>
        <trans-unit id="d0020398180c05f3b9f05227c429a1215e0aae80" translate="yes" xml:space="preserve">
          <source>Take these examples.</source>
          <target state="translated">Возьмите эти примеры.</target>
        </trans-unit>
        <trans-unit id="96016a84f6ccaa21c0ff5eb49c88180b5839dbb7" translate="yes" xml:space="preserve">
          <source>That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.</source>
          <target state="translated">То есть,ссылки на параметры могут быть изменены,если вы заходите и получаете доступ к самому значению параметра.С другой стороны,привязка к параметру исчезнет после обработки и будет недоступна вызывающему абоненту функции.</target>
        </trans-unit>
        <trans-unit id="1e9b208745c0adc4ae130578652525c2f81da6a0" translate="yes" xml:space="preserve">
          <source>That's why when you try to change an object inside a function, by replacing it's value (i.e. &lt;code&gt;age = {value:5}&lt;/code&gt;), the change doesn't persist, but if you change it's properties (i.e. &lt;code&gt;age.value = 5&lt;/code&gt;), it does.</source>
          <target state="translated">Вот почему, когда вы пытаетесь изменить объект внутри функции, заменяя его значение (то есть &lt;code&gt;age = {value:5}&lt;/code&gt; ), изменение не сохраняется, но если вы измените его свойства (то есть &lt;code&gt;age.value = 5&lt;/code&gt; ), оно делает.</target>
        </trans-unit>
        <trans-unit id="ff449e061e42e079c42808abf8dc5c78475c9c12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;age&lt;/code&gt; is a reference to &lt;code&gt;myAge&lt;/code&gt;, but if you want the value you have to convert the reference, using &lt;code&gt;*age&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;age&lt;/code&gt; &lt;code&gt;myAge&lt;/code&gt; является ссылкой на myAge , но если вы хотите получить значение, вы должны преобразовать ссылку, используя &lt;code&gt;*age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfb912d780ddf9573a7ca91bac5773da514df0e" translate="yes" xml:space="preserve">
          <source>The JavaScript engine assigns the object to the variable &lt;code&gt;c&lt;/code&gt;, and it points to some memory, say (0x012).</source>
          <target state="translated">Механизм JavaScript назначает объект переменной &lt;code&gt;c&lt;/code&gt; , и он указывает на некоторую память, скажем, (0x012).</target>
        </trans-unit>
        <trans-unit id="54327c1b59eda63c1878391f14ad9c7f807364da" translate="yes" xml:space="preserve">
          <source>The MDN docs explain it clearly, without being too verbose:</source>
          <target state="translated">MDN документы объясняют это ясно,не будучи слишком многословными:</target>
        </trans-unit>
        <trans-unit id="131abb827464b85b18ae518074aac50427c4fc92" translate="yes" xml:space="preserve">
          <source>The equal(=) operator sets up new memory space or address</source>
          <target state="translated">Оператор equal(=)устанавливает новое место в памяти или адрес</target>
        </trans-unit>
        <trans-unit id="ebfa1ea7372d6f23abc337f70c4f4df97d8a30cd" translate="yes" xml:space="preserve">
          <source>The most succinct explanation I found was in the &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB style guide&lt;/a&gt;:</source>
          <target state="translated">Самое краткое объяснение, которое я нашел, было в &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;руководстве по стилю AirBNB&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c3d021afb081241b899877ae82ca0e06ab382f15" translate="yes" xml:space="preserve">
          <source>The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)</source>
          <target state="translated">Единственное,что получается,это когда имя переменной,которую вы передаете в функцию,совпадает с именем параметра функции.Когда это происходит,нужно обращаться с параметром внутри функции так,как если бы это была совершенно новая переменная,приватная для функции (потому что это так).</target>
        </trans-unit>
        <trans-unit id="2e351bcd6c54bf11efb568e95ee714a771482cbd" translate="yes" xml:space="preserve">
          <source>The only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven't modified the variable, but the object itself.</source>
          <target state="translated">Единственный раз,когда &quot;модификация переменной&quot; влияет на другую переменную,это когда мутируется базовый объект (в этом случае вы модифицировали не переменную,а сам объект.</target>
        </trans-unit>
        <trans-unit id="e117feea80f4052240b302d90852bffb9002a69f" translate="yes" xml:space="preserve">
          <source>The parameters of a function call are the function's &lt;em&gt;arguments&lt;/em&gt;.
  Arguments are passed to functions &lt;em&gt;by value&lt;/em&gt;. If the function changes
  the value of an argument, this change is not reflected globally or in
  the calling function. However, object references are values, too, and
  they are special: if the function changes the referred object's
  properties, that change is visible outside the function, (...)</source>
          <target state="translated">Параметры вызова функции являются &lt;em&gt;аргументами&lt;/em&gt; функции. Аргументы передаются в функции &lt;em&gt;по значению&lt;/em&gt; . Если функция изменяет значение аргумента, это изменение не отражается глобально или в вызывающей функции. Однако ссылки на объекты также являются значениями, и они являются особыми: если функция изменяет свойства упомянутого объекта, это изменение видно за пределами функции, (...)</target>
        </trans-unit>
        <trans-unit id="df2fd245eb7826b794aeb3d9f1b7a4aa9ba6448f" translate="yes" xml:space="preserve">
          <source>The phrase &quot;pass by
  reference&quot; can have several meanings.
  To some readers, the phrase refers to
  a function invocation technique that
  allows a function to assign new values
  to its arguments and to have those
  modified values visible outside the
  function. This is not the way the term
  is used in this book.</source>
          <target state="translated">Фраза &quot;пройти по ссылке&quot; может иметь несколько значений.Для некоторых читателей эта фраза относится к технике вызова функции,которая позволяет функции присваивать своим аргументам новые значения и видеть эти измененные значения вне функции.В данной книге этот термин используется не так.</target>
        </trans-unit>
        <trans-unit id="40424125880f7bec8d7f9e5602a94c76e97cd1cc" translate="yes" xml:space="preserve">
          <source>The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).</source>
          <target state="translated">Примитивные типы (число,строка и т.д.)передаются по значению,но объекты неизвестны,так как могут быть как переданными по значению (в случае,если мы считаем,что переменная,содержащая объект,на самом деле является ссылкой на объект),так и переданными по ссылке (если мы считаем,что переменная к объекту содержит сам объект).</target>
        </trans-unit>
        <trans-unit id="8fbaf791a543ee22f0fd296541edf5a1bfa479b1" translate="yes" xml:space="preserve">
          <source>The production ArgumentList : AssignmentExpression is evaluated as follows:</source>
          <target state="translated">Производство ArgumentList:ПрисвоениеЭкспрессия оценивается следующим образом:</target>
        </trans-unit>
        <trans-unit id="ecee46c34e5a0a1af1170066ea3f9a92c40b9de1" translate="yes" xml:space="preserve">
          <source>The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</source>
          <target state="translated">Членство в производстве:Членство в производстве:Членство в производстве:Выражение[Выражение]оценивается следующим образом:</target>
        </trans-unit>
        <trans-unit id="e64cfc5706b868b32b799d93138e5cd834b8bce0" translate="yes" xml:space="preserve">
          <source>The section also enumerate cases where argument list has 0 or &amp;gt;1 arguments.</source>
          <target state="translated">В этом разделе также перечислены случаи, когда список аргументов имеет 0 или&amp;gt; 1 аргументов.</target>
        </trans-unit>
        <trans-unit id="dbf3ebd42f5ddf6e8a07546545a97d0d73e8f740" translate="yes" xml:space="preserve">
          <source>The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren't visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller's scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned &amp;mdash; it is shared.</source>
          <target state="translated">Семантика вызова путем совместного использования отличается от вызова путем ссылки тем, что присваивания аргументам функции внутри функции не видны вызывающей стороне (в отличие от ссылочной семантики) [необходима цитата], поэтому, например, если переменная была передана, это невозможно смоделировать присваивание этой переменной в области действия вызывающего. Однако, поскольку функция имеет доступ к тому же объекту, что и вызывающий объект (копия не создается), мутации этих объектов, если объекты изменчивы, внутри функции видны вызывающей стороне, что может отличаться от вызова по значению. семантика. Мутации изменяемого объекта в функции видны вызывающей стороне, потому что объект не копируется и не клонируется - он используется совместно.</target>
        </trans-unit>
        <trans-unit id="8c4316acc1d74e70023ca752c79e9fc23bbbea3d" translate="yes" xml:space="preserve">
          <source>The terms are only used to describe the &lt;em&gt;behavior&lt;/em&gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn't adequately describe the actual behavior and supplementary info has to be provided</source>
          <target state="translated">Термины используются только для описания &lt;em&gt;поведения&lt;/em&gt; языка, а не обязательно фактической базовой реализации. В результате этой абстракции критические детали, которые важны для достойного объяснения, теряются, что неизбежно приводит к текущей ситуации, когда один термин не адекватно описывает реальное поведение, и необходимо предоставить дополнительную информацию</target>
        </trans-unit>
        <trans-unit id="626d24ad73a240837e037855870f41fe70cd5f31" translate="yes" xml:space="preserve">
          <source>The variable doesn't &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It's always pass by value (even when that value is a reference...).</source>
          <target state="translated">Переменная не &quot;держит&quot; объект,а содержит ссылку.Вы можете присвоить эту ссылку другой переменной,и теперь оба ссылаются на один и тот же объект.Она всегда передается по значению (даже если это значение является ссылкой...).</target>
        </trans-unit>
        <trans-unit id="dca56569992ce2b50c87910c0d7c7c9858ba2c6f" translate="yes" xml:space="preserve">
          <source>There is no &quot;pass by reference&quot; available in JavaScript.</source>
          <target state="translated">В JavaScript нет &quot;pass by reference&quot;.</target>
        </trans-unit>
        <trans-unit id="361031a3f3abf898ac288ca94af4b04c26e7d902" translate="yes" xml:space="preserve">
          <source>There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn't have a function and just used the equal sign to assign to a new variable.</source>
          <target state="translated">Нет смысла различать объекты и примитивы,потому что он работает точно так же,как если бы у вас не было функции и вы просто использовали знак равенства для присвоения новой переменной.</target>
        </trans-unit>
        <trans-unit id="1aa166014dcdcbcff2f5f9b82565c5b3c2e956bf" translate="yes" xml:space="preserve">
          <source>There's no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.</source>
          <target state="translated">Нет способа изменить значение переменной,передаваемой в качестве параметра,что было бы возможно,если бы JavaScript поддерживал передачу по ссылке.</target>
        </trans-unit>
        <trans-unit id="010934035b63fc110de9e084961250609ba49e08" translate="yes" xml:space="preserve">
          <source>There's some discussion about the use of the term &quot;pass by reference&quot; in JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;here&lt;/a&gt;, but to answer your question:</source>
          <target state="translated">Здесь обсуждается использование термина &amp;laquo;передача по ссылке&amp;raquo; в JavaScript, но для ответа на ваш вопрос:</target>
        </trans-unit>
        <trans-unit id="b3971268996a99a5df86f39832ec5539e7dd9d70" translate="yes" xml:space="preserve">
          <source>These concepts were not originally defined with the intent of describing javascript in particular and so I don't feel compelled to use them when they only add to the confusion.</source>
          <target state="translated">Эти понятия изначально не были определены с целью описания яваскрипта в частности,и поэтому я не чувствую себя вынужденным использовать их,когда они только усугубляют путаницу.</target>
        </trans-unit>
        <trans-unit id="e16663c0ae48f1219b8db33d73a88db1512811fc" translate="yes" xml:space="preserve">
          <source>Think of it like this: It's always pass by value. However, the value of an object is not the object itself, but a reference to that object.</source>
          <target state="translated">Подумай об этом вот так:Это всегда проходит мимо стоимости.Однако,значение объекта-это не сам объект,а ссылка на этот объект.</target>
        </trans-unit>
        <trans-unit id="705df426723dfd9a58e61806d528e760b06fe084" translate="yes" xml:space="preserve">
          <source>This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.</source>
          <target state="translated">Это немного больше объясняет передачу по значению и передачу по ссылке (JavaScript).В этом понятии речь идет о передаче переменной по ссылке и передаче переменной по ссылке.</target>
        </trans-unit>
        <trans-unit id="3f9efc65382f339c71ef4d14543d364c027db24a" translate="yes" xml:space="preserve">
          <source>This produces the output:</source>
          <target state="translated">Это производит выход:</target>
        </trans-unit>
        <trans-unit id="a1116d28bfe37e6545e3ebc5bd2c217059edabe0" translate="yes" xml:space="preserve">
          <source>Thus, everything's are passed by reference.</source>
          <target state="translated">Таким образом,все передается по ссылке.</target>
        </trans-unit>
        <trans-unit id="3678321f62ae967b6f938900843022091b6a3c1b" translate="yes" xml:space="preserve">
          <source>Thus, properties of Objects are always available as reference.</source>
          <target state="translated">Таким образом,свойства Объектов всегда доступны в качестве справочной информации.</target>
        </trans-unit>
        <trans-unit id="0821fb327f2753fc69a24f9f6c10a0a8791e18c7" translate="yes" xml:space="preserve">
          <source>To answer your question: pointers are passed.</source>
          <target state="translated">Чтобы ответить на ваш вопрос:указатели пройдены.</target>
        </trans-unit>
        <trans-unit id="7bbe358444a139cd8eb2208023bd472900f08800" translate="yes" xml:space="preserve">
          <source>To effectively pass a compound value (like an &lt;code&gt;array&lt;/code&gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</source>
          <target state="translated">Чтобы эффективно передать составное значение (например, &lt;code&gt;array&lt;/code&gt; ) по значению-копированию, вам необходимо вручную сделать его копию, чтобы переданная ссылка не указывала на оригинал. Например:</target>
        </trans-unit>
        <trans-unit id="e1abf81928ceac0fa096e0f4f2795b3ee7f8da32" translate="yes" xml:space="preserve">
          <source>Uh oh.... What has happened. We couldn't change string1 by changing favoriteString... Why?? Because we didn't &lt;em&gt;change&lt;/em&gt; our string &lt;em&gt;object&lt;/em&gt;. All we did was &quot;RE ASSIGN&quot; the favoriteString &lt;em&gt;variable&lt;/em&gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn't assign anything. (Well, not to the &lt;em&gt;variable itself&lt;/em&gt;, ... we did, however, assign the name property to a new string.) Instead, we simply mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or &lt;em&gt;mutate&lt;/em&gt; the string object &lt;em&gt;itself&lt;/em&gt;, we couldn't have, because strings are actually immutable in JavaScript.)</source>
          <target state="translated">Э-э-э ... Что случилось? Мы не могли изменить string1, изменив favourString ... Почему ?? Потому что мы не &lt;em&gt;изменили&lt;/em&gt; наш строковый &lt;em&gt;объект&lt;/em&gt; . Все, что мы сделали, это &amp;laquo;RE ASSIGN&amp;raquo; &lt;em&gt;переменную favourString&lt;/em&gt; для новой строки. Это по существу отключило его от string1. В предыдущем примере, когда мы переименовали наш объект, мы ничего не назначали. (Ну, не для самой &lt;em&gt;переменной&lt;/em&gt; ... мы, однако, присвоили свойство name новой строке.) Вместо этого мы просто мутировали объект, который сохраняет связи между двумя переменными и базовыми объектами. (Даже если бы мы хотели изменить или изменить сам строковый объект, мы не смогли бы этого сделать, потому что строки на самом деле неизменны в JavaScript.)</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="ad44083b5ca9c555d81d716126062a61d9fc5f75" translate="yes" xml:space="preserve">
          <source>Variables are &lt;em&gt;pointers&lt;/em&gt; to values in memory.</source>
          <target state="translated">Переменные являются &lt;em&gt;указателями&lt;/em&gt; на значения в памяти.</target>
        </trans-unit>
        <trans-unit id="678a462c2bd82f3f082479b480f76e063a36fb4b" translate="yes" xml:space="preserve">
          <source>What we have done is &quot;assignment&quot;... We've assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.</source>
          <target state="translated">То,что мы сделали,это &quot;задание&quot;...Мы присвоили переменным &quot;object1&quot; и &quot;object2&quot; 2 отдельных пустых объекта.</target>
        </trans-unit>
        <trans-unit id="84d66e6463f366bb3793d71142052ebf0b3271b4" translate="yes" xml:space="preserve">
          <source>When calling a function, you are passing the content (reference or
value) of the argument variables, not the the variables themselves.</source>
          <target state="translated">При вызове функции передается содержимое (ссылка или значение)переменных аргумента,а не самих переменных.</target>
        </trans-unit>
        <trans-unit id="b675d8ab55a62fa7342693de178ca61efdefdab7" translate="yes" xml:space="preserve">
          <source>When d=c, in this step &lt;code&gt;d&lt;/code&gt; points to the same location (0x012).</source>
          <target state="translated">Когда d = c, на этом шаге &lt;code&gt;d&lt;/code&gt; указывает на то же местоположение (0x012).</target>
        </trans-unit>
        <trans-unit id="6603f9e15352ae782eb9dbf4dc53a8cacea1f46d" translate="yes" xml:space="preserve">
          <source>When we make the assignment &lt;code&gt;b = [4,5,6]&lt;/code&gt;, we are doing absolutely nothing to affect where &lt;code&gt;a&lt;/code&gt; is still referencing (&lt;code&gt;[1,2,3]&lt;/code&gt;). To do that, &lt;code&gt;b&lt;/code&gt; would have to be a pointer to &lt;code&gt;a&lt;/code&gt; rather than a reference to the &lt;code&gt;array&lt;/code&gt; -- but no such capability exists in JS!</source>
          <target state="translated">Когда мы делаем присваивание &lt;code&gt;b = [4,5,6]&lt;/code&gt; , мы абсолютно ничего не делаем, чтобы повлиять на то, где ссылка все еще ссылается ( &lt;code&gt;[1,2,3]&lt;/code&gt; ). Для этого &lt;code&gt;b&lt;/code&gt; должен быть указателем на &lt;code&gt;array&lt;/code&gt; а не ссылкой на него, но в JS такой возможности не существует!</target>
        </trans-unit>
        <trans-unit id="13f9dc2555da1b44daf4195c85cac47042d3a3a1" translate="yes" xml:space="preserve">
          <source>When we pass in the argument &lt;code&gt;a&lt;/code&gt;, it assigns a copy of the &lt;code&gt;a&lt;/code&gt; reference to &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are separate references pointing at the same &lt;code&gt;[1,2,3]&lt;/code&gt; value. Now, inside the function, we can use that reference to mutate the value itself (&lt;code&gt;push(4)&lt;/code&gt;). But when we make the assignment &lt;code&gt;x = [4,5,6]&lt;/code&gt;, this is in no way affecting where the initial reference &lt;code&gt;a&lt;/code&gt; is pointing -- still points at the (now modified) &lt;code&gt;[1,2,3,4]&lt;/code&gt; value.</source>
          <target state="translated">Когда мы передаем аргумент &lt;code&gt;a&lt;/code&gt; , он присваивает копию ссылки на &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; - это отдельные ссылки, указывающие на одно и то же значение &lt;code&gt;[1,2,3]&lt;/code&gt; . Теперь внутри функции мы можем использовать эту ссылку для изменения самого значения ( &lt;code&gt;push(4)&lt;/code&gt; ). Но когда мы делаем присваивание &lt;code&gt;x = [4,5,6]&lt;/code&gt; , это никоим образом не влияет на то, куда указывает исходная ссылка &lt;code&gt;a&lt;/code&gt; - все еще указывает на (теперь измененное) значение &lt;code&gt;[1,2,3,4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc1b4ec703eec5dfe10344c61e1e765e58682a65" translate="yes" xml:space="preserve">
          <source>When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else.</source>
          <target state="translated">Когда вы используете эту ссылку для манипулирования своим объектом,это влияет на объект снаружи.Однако,если внутри функции вы решили направить ссылку на что-то другое,то вы вовсе не повлияли на объект снаружи,потому что все,что вы сделали-это перенаправили ссылку на что-то другое.</target>
        </trans-unit>
        <trans-unit id="a5f72cf83865e4414b2e92fe68d2f91039221270" translate="yes" xml:space="preserve">
          <source>a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).</source>
          <target state="translated">a выделяет память (скажем,0x001)и b создает копию значения в памяти (скажем,0x002).</target>
        </trans-unit>
        <trans-unit id="ba35e803347ae1a6fbb922bb822df3c9557c5075" translate="yes" xml:space="preserve">
          <source>a very confusing situation is where you can't realize how your referenced variable changes, let's take a look at a very good example:</source>
          <target state="translated">очень запутанная ситуация,когда вы не можете понять,как изменяется ваша переменная,на которую вы ссылаетесь,давайте рассмотрим очень хороший пример:</target>
        </trans-unit>
        <trans-unit id="1a91322ba3053b9c0d30aeec04a7ec7d757a54ad" translate="yes" xml:space="preserve">
          <source>and in a more complicated story:</source>
          <target state="translated">и в более сложной истории:</target>
        </trans-unit>
        <trans-unit id="dbe8beff245d88e0093cd5bdb6c0a20809a330d5" translate="yes" xml:space="preserve">
          <source>applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).</source>
          <target state="translated">применяется ко всем типам примитивов в JavaScript (строка,число,булевский,неопределенный и нулевой).</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4e4aeb4d95583c62381700ab3cfbd849ddf35b64" translate="yes" xml:space="preserve">
          <source>but we cant do the same thing with the purple arrow, we may want to move 'john' cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...</source>
          <target state="translated">но мы не можем сделать то же самое с фиолетовой стрелкой,мы можем захотеть переместить сюда клетку &quot;Джона&quot; или многое другое...,поэтому фиолетовая стрелка будет прилипать к своему месту,и только типичные стрелки,которые были ей приписаны,будут двигаться...</target>
        </trans-unit>
        <trans-unit id="e4cf40496f043253f0d64368904b930d9b69c16d" translate="yes" xml:space="preserve">
          <source>every type2-value (green) is a &lt;strong&gt;single square&lt;/strong&gt; while a type1-value (blue) is a &lt;strong&gt;group of them&lt;/strong&gt;:</source>
          <target state="translated">каждое значение type2 (зеленый) - это &lt;strong&gt;один квадрат,&lt;/strong&gt; а значение type1 (синий) - их &lt;strong&gt;группа&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="dd74f54fdfe237acc828874dddffdcfc48e8abc5" translate="yes" xml:space="preserve">
          <source>here you are assigning new object or array to old one.you are not changing the value of property 
of old object.so it is pass by value.</source>
          <target state="translated">Присваивая новый объект или массив старому,вы не изменяете значение свойства старого объекта,поэтому оно передается по значению.</target>
        </trans-unit>
        <trans-unit id="a20f2e836503b1a3b14f37b2c5bd01437f59d8f4" translate="yes" xml:space="preserve">
          <source>here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.</source>
          <target state="translated">Здесь вы изменяете значение свойства старого объекта,а не присваиваете новый объект или массив старому,поэтому он передается по ссылке.</target>
        </trans-unit>
        <trans-unit id="53ff18bfd84d263fea5d0d0003eebc0c7a27a864" translate="yes" xml:space="preserve">
          <source>if you are changing a property value of an object or array then it is pass by Reference.</source>
          <target state="translated">если вы изменяете значение свойства объекта или массива,то оно передается по ссылке.</target>
        </trans-unit>
        <trans-unit id="3e6856e162be438b0b1b28e9475c58786691c0c2" translate="yes" xml:space="preserve">
          <source>if you are changing value of that Object or array with new Object or Array then it is pass by Value.</source>
          <target state="translated">если вы изменяете значение этого Объекта или массива с помощью нового Объекта или Массива,то оно передается по значению.</target>
        </trans-unit>
        <trans-unit id="37fb1667392900bb5ef5037dd0e0b507e63dc8dd" translate="yes" xml:space="preserve">
          <source>if you imagine memory as below squares which in every one of them just one type2-value can be saved:</source>
          <target state="translated">если представить себе память в виде квадратов ниже,в каждом из которых можно сохранить только одно значение type2:</target>
        </trans-unit>
        <trans-unit id="d4ec615b08c0e036b2bca13e54163fa4149fab8d" translate="yes" xml:space="preserve">
          <source>in javascript we can put values in two layer: &lt;strong&gt;type1&lt;/strong&gt;-&lt;code&gt;objects&lt;/code&gt; and &lt;strong&gt;type2&lt;/strong&gt;-all other types of value such as &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</source>
          <target state="translated">в javascript мы можем поместить значения в два слоя: &lt;strong&gt;type1&lt;/strong&gt; - &lt;code&gt;objects&lt;/code&gt; и &lt;strong&gt;type2&lt;/strong&gt; - все другие типы значений, такие как &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="53b0a1b2fadf4e040cdc2155a7340de24aca93cb" translate="yes" xml:space="preserve">
          <source>number</source>
          <target state="translated">number</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="f0f7f39ec7e62249ee81dac2c3f1b3586a4fd52e" translate="yes" xml:space="preserve">
          <source>objects</source>
          <target state="translated">objects</target>
        </trans-unit>
        <trans-unit id="43c608c48ee77ebcf1192df657480116bb88d93b" translate="yes" xml:space="preserve">
          <source>primitive type variable like string,number are always pass as  pass
by value.</source>
          <target state="translated">Примитивная переменная типа string,number всегда передается как pass by value.</target>
        </trans-unit>
        <trans-unit id="0366c73137f63703a81f4390aa8afe89322b7310" translate="yes" xml:space="preserve">
          <source>sharing what I know of references in JavaScript</source>
          <target state="translated">делиться тем,что я знаю о ссылках на JavaScript.</target>
        </trans-unit>
        <trans-unit id="340b6603b7ec42319770e6733e4f6bacbc9b29bb" translate="yes" xml:space="preserve">
          <source>so here &lt;strong&gt;references&lt;/strong&gt; can rescue us:</source>
          <target state="translated">так вот &lt;strong&gt;ссылки&lt;/strong&gt; могут спасти нас:</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="bffc56aa90003a62e1312aa3131fb673e4b8fa39" translate="yes" xml:space="preserve">
          <source>symbol in &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">символ в &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a6bbba542e8dfa1abb5d45893298c0eb2f0d406" translate="yes" xml:space="preserve">
          <source>the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that's not easy at all! :</source>
          <target state="translated">Дело в том,что если вы хотите указать значение type2-value,то адрес будет простым,но если вы хотите сделать то же самое для значения type1-value,то это совсем не просто! :</target>
        </trans-unit>
        <trans-unit id="d5d4cd07616a542891b7ec2d0257b3a24b69856e" translate="yes" xml:space="preserve">
          <source>undefined</source>
          <target state="translated">undefined</target>
        </trans-unit>
        <trans-unit id="c097133877b58bb1a18daa1d045149700ebbbf11" translate="yes" xml:space="preserve">
          <source>well, it's about 'performance' and 'speed' and in the simple word 'memory management' in a programming language.</source>
          <target state="translated">Ну,речь идет о &quot;производительности&quot; и &quot;скорости&quot;,а в простом слове &quot;управление памятью&quot; в языке программирования.</target>
        </trans-unit>
        <trans-unit id="5ba026f489ec792196a7e8a5a6ac751fc3641db1" translate="yes" xml:space="preserve">
          <source>while the green arrow here is a typical variable, the purple one is an object variable, so &lt;strong&gt;because the green arrow(typical variable) has just one task&lt;/strong&gt; (and that is indicating a typical value) we don't need to separate it's value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...</source>
          <target state="translated">в то время как зеленая стрелка здесь является типичной переменной, фиолетовая - объектной переменной, поэтому, &lt;strong&gt;поскольку зеленая стрелка (типичная переменная) имеет только одну задачу&lt;/strong&gt; (и это указывает на типичное значение), нам не нужно отделять ее значение от это так, мы перемещаем зеленую стрелку со значением того, куда он идет и во всех назначениях, функциях и так далее ...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
