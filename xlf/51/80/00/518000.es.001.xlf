<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/518000">
    <body>
      <group id="518000">
        <trans-unit id="1dee29437206aa2b90705d515faaafcb0add50ca" translate="yes" xml:space="preserve">
          <source>&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;Which programming languages are pass by reference?&lt;/a&gt;</source>
          <target state="translated">- &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;&amp;iquest;Qu&amp;eacute; lenguajes de programaci&amp;oacute;n se pasan por referencia?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07698e10df4dd98b0bf399ab50011ce57e452623" translate="yes" xml:space="preserve">
          <source>(From the article mentioned above.)</source>
          <target state="translated">(Del artículo mencionado anteriormente.)</target>
        </trans-unit>
        <trans-unit id="edeb4423fd301ceb5f86fc44d38b40f3c9ba6fa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Return a value of type Reference&lt;/b&gt; whose base value is baseValue and whose referenced name is
  propertyNameString, and whose strict mode flag is strict.</source>
          <target state="translated">&lt;b&gt;Devuelve un valor de tipo Referencia&lt;/b&gt; cuyo valor base es baseValue y cuyo nombre referenciado es propertyNameString, y cuyo indicador de modo estricto es estricto.</target>
        </trans-unit>
        <trans-unit id="d0d476f54a71b8ac89e5d06ddffbeccc263797e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TL;DR&lt;/b&gt;: Everythings're passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.</source>
          <target state="translated">&lt;b&gt;TL; DR&lt;/b&gt; : todo se pasa por valor, pero las propiedades de los objetos son referencias, y la definici&amp;oacute;n de objeto carece de forma espeluznante en el est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="5cc31de26a91a7607db07fbc10e5bdca64ddd6b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compound values are always assigned/passed by reference-copy&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Los valores compuestos siempre se asignan / pasan por copia de referencia&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b825d8d1882d46055d101f87ec20d9423ddb0d0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function arguments and parameters are not the same thing.  Also, a variable's value is not the variable's object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Los argumentos y par&amp;aacute;metros de la funci&amp;oacute;n no son lo mismo.&lt;/em&gt; &lt;em&gt;Adem&amp;aacute;s, el valor de una variable no es el objeto de la variable (como ya han se&amp;ntilde;alado varias personas, pero aparentemente ignorado).&lt;/em&gt; &lt;em&gt;Estas distinciones son cr&amp;iacute;ticas para la comprensi&amp;oacute;n adecuada.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dec8a494f102cfe95fa805f288c3d04ee0a6b711" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Primitive values are always assigned/passed by value-copy&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Los valores primitivos siempre se asignan / pasan por value-copy&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="207d1e3b4f674510d97d07b156c4c5ee3a4de294" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because in JavaScript, it doesn't matter whether it's passed by value or by reference or whatever.
What matters is mutation vs assignment of the parameters passed into a function.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Porque en JavaScript, no importa si se pasa por valor o por referencia o lo que sea.&lt;/strong&gt; &lt;strong&gt;Lo que importa es la mutaci&amp;oacute;n frente a la asignaci&amp;oacute;n de los par&amp;aacute;metros pasados ​​a una funci&amp;oacute;n.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a42287a91a97e2c4e1094a867ae8805599745087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt;:  The function argument's value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object's data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.</source>
          <target state="translated">&lt;strong&gt;Llamada / Pase por referencia&lt;/strong&gt; : el valor del argumento de la funci&amp;oacute;n puede / ser&amp;aacute; actualizado directamente por el par&amp;aacute;metro de funci&amp;oacute;n correspondiente. Si ayuda, el par&amp;aacute;metro de funci&amp;oacute;n se convierte en un &quot;alias&quot; efectivo para el argumento: se refieren efectivamente al mismo valor en la misma ubicaci&amp;oacute;n de memoria. Si un argumento de funci&amp;oacute;n es una variable de objeto, la capacidad de cambiar los datos del objeto no es diferente al caso de paso por valor ya que el par&amp;aacute;metro de funci&amp;oacute;n todav&amp;iacute;a apuntar&amp;aacute; al mismo objeto que el argumento. Pero en el caso de la variable de objeto, si el par&amp;aacute;metro de funci&amp;oacute;n se establece en un objeto completamente diferente, entonces el argumento tambi&amp;eacute;n apuntar&amp;aacute; al objeto diferente; esto no sucede en el caso de pasar por valor.</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c12cc2e2533791936e57d4b9415ab42ea32e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex&lt;/strong&gt;: When you access a complex type you work on a reference to its value</source>
          <target state="translated">&lt;strong&gt;Complejo&lt;/strong&gt; : cuando accede a un tipo complejo, trabaja en una referencia a su valor</target>
        </trans-unit>
        <trans-unit id="1301250d5301f648cf05701bd59197e854b822ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;: Variable outside the function which is passed to the function by the caller.</source>
          <target state="translated">&lt;strong&gt;Argumento de la funci&amp;oacute;n&lt;/strong&gt; : Variable fuera de la funci&amp;oacute;n que el llamante pasa a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="65492a390eb86ea3356e64d01cfaa27d6c3fab3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function parameter&lt;/strong&gt;:  Variable declared in a function definition, used for referencing variables passed to the function.</source>
          <target state="translated">&lt;strong&gt;Par&amp;aacute;metro de funci&amp;oacute;n&lt;/strong&gt; : Variable declarada en una definici&amp;oacute;n de funci&amp;oacute;n, utilizada para hacer referencia a variables pasadas a la funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="65a6814d6b676f546b18918b30e471d0b5236d77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Memory location&lt;/strong&gt;:  Where a variable's value is stored.  (The location itself is represented by a number separate from the value stored at the location.)</source>
          <target state="translated">&lt;strong&gt;Ubicaci&amp;oacute;n de la memoria&lt;/strong&gt; : donde se almacena el valor de una variable. (La ubicaci&amp;oacute;n en s&amp;iacute; est&amp;aacute; representada por un n&amp;uacute;mero separado del valor almacenado en la ubicaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="5996d89441c8d0e61fe5412acbb5b6378fb43e74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object clone/copy&lt;/strong&gt;: A new object is created and the original object's data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.</source>
          <target state="translated">&lt;strong&gt;Clonar / copiar&lt;/strong&gt; objeto: se crea un nuevo objeto y se copian los datos del objeto original. Esto puede ser una copia profunda o una copia superficial, pero el punto es que se crea un nuevo objeto. Crear una copia de un objeto es un concepto separado del paso por valor. Algunos lenguajes distinguen entre objetos de clase y estructuras (o similares), y pueden tener un comportamiento diferente para pasar variables de los diferentes tipos. Pero JavaScript no hace nada como esto autom&amp;aacute;ticamente al pasar variables de objeto. Pero la ausencia de clonaci&amp;oacute;n autom&amp;aacute;tica de objetos no se traduce en paso por referencia.</target>
        </trans-unit>
        <trans-unit id="fa53139221548e1fd770ad7abe04c1dc6d698150" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object variable&lt;/strong&gt;:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object's actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.</source>
          <target state="translated">&lt;strong&gt;Variable de objeto&lt;/strong&gt; : Variable cuyo valor subyacente b&amp;aacute;sico no es el &quot;objeto&quot; en s&amp;iacute;, sino que su valor es un puntero (valor de ubicaci&amp;oacute;n de memoria) a otra ubicaci&amp;oacute;n en la memoria donde se almacenan los datos reales del objeto. En la mayor&amp;iacute;a de los lenguajes de generaci&amp;oacute;n superior, el aspecto &quot;puntero&quot; se oculta efectivamente mediante la referencia autom&amp;aacute;tica en varios contextos.</target>
        </trans-unit>
        <trans-unit id="d880bbb046dd0fb8ed275862bb6d9eb727b33d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pase por referencia (objetos)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab95d2eb7f10fa0819e1bef83f4bd83e6ae79ba7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value (primitive type)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pasar por valor (tipo primitivo)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d87f3236c9b7ff2b627b66d6a54c489872ad459f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass-by-value or Call-by-sharing (for objects)&lt;/strong&gt;:  The function argument's value is COPIED to another memory location which is referenced by the function's parameter symbol (regardless of whether it's on the stack or heap).  In other words, the function parameter received a copy of the passed argument's value... AND (critical) the argument's value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable's value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter's value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument's value IS NEVER UPDATED, so it will continue to point to the &lt;em&gt;same&lt;/em&gt; object throughout and even after the function call (even if its object's data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.</source>
          <target state="translated">&lt;strong&gt;Pass-by-value o Call-by-sharing (para objetos)&lt;/strong&gt; : el valor del argumento de la funci&amp;oacute;n es COPIADO a otra ubicaci&amp;oacute;n de memoria a la que hace referencia el s&amp;iacute;mbolo del par&amp;aacute;metro de la funci&amp;oacute;n (independientemente de si est&amp;aacute; en la pila o en el mont&amp;oacute;n). En otras palabras, el par&amp;aacute;metro de funci&amp;oacute;n recibi&amp;oacute; una copia del valor del argumento pasado ... Y (cr&amp;iacute;tico) el valor del argumento NUNCA SE ACTUALIZA / ALTERA / CAMBIA por la funci&amp;oacute;n de llamada. Recuerde, el valor de una variable de objeto NO es el objeto en s&amp;iacute; mismo, sino que es el puntero al objeto, por lo que pasar una variable de objeto por valor copia el puntero a la variable del par&amp;aacute;metro de funci&amp;oacute;n. El valor del par&amp;aacute;metro de funci&amp;oacute;n apunta exactamente al mismo objeto en la memoria. Los datos del objeto en s&amp;iacute; pueden modificarse directamente a trav&amp;eacute;s del par&amp;aacute;metro de funci&amp;oacute;n, PERO el valor del argumento de la funci&amp;oacute;n NUNCA SE ACTUALIZA, por lo que continuar&amp;aacute; apuntando al &lt;em&gt;mismo&lt;/em&gt; objeto durante e incluso despu&amp;eacute;s de la llamada a la funci&amp;oacute;n (incluso si los datos de su objeto fueron alterados o si el par&amp;aacute;metro de funci&amp;oacute;n se le asigna un objeto completamente diferente). Es incorrecto concluir que el argumento de la funci&amp;oacute;n se pas&amp;oacute; por referencia solo porque el objeto referenciado es actualizable a trav&amp;eacute;s de la variable del par&amp;aacute;metro de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3daa908ef93ef3beddf5ee815280e35804b2ab50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitive variable&lt;/strong&gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable's value IS the actual value represented by the variable's symbol rather than a pointer to another memory location.</source>
          <target state="translated">&lt;strong&gt;Variable primitiva&lt;/strong&gt; : Variable cuyo valor ES el valor real. Incluso este concepto puede ser complicado por el auto-boxeo y los contextos similares a objetos de varios lenguajes, pero la idea general es que el valor de la variable ES el valor real representado por el s&amp;iacute;mbolo de la variable en lugar de un puntero a otra ubicaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="738f561981f804bed95647891f285ca2a07e0ffc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitives&lt;/strong&gt;: When you access a primitive type you work directly on its
value</source>
          <target state="translated">&lt;strong&gt;Primitivas&lt;/strong&gt; : cuando accede a un tipo primitivo, trabaja directamente en su valor</target>
        </trans-unit>
        <trans-unit id="f1d08a4ffaed6d05dab4d5131e21bf7f0ad7cc25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special case, pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso especial, pase por referencia (objetos)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d30d6d093711f7dc4bbd3b5d3e73777eb88a76b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symbol&lt;/strong&gt;:  Text string used to refer to variable (i.e. variable's name).</source>
          <target state="translated">&lt;strong&gt;S&amp;iacute;mbolo&lt;/strong&gt; : cadena de texto utilizada para referirse a la variable (es decir, el nombre de la variable).</target>
        </trans-unit>
        <trans-unit id="dbb628f544b2f5b04bb5df870aacd2b707683b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;:  Particular bits stored in memory and referenced using variable's symbol.</source>
          <target state="translated">&lt;strong&gt;Valor&lt;/strong&gt; : bits particulares almacenados en la memoria y referenciados mediante el s&amp;iacute;mbolo de la variable.</target>
        </trans-unit>
        <trans-unit id="4a4a44d5c5dbc605d366445b9f5e39a3dbd71772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variable&lt;/strong&gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.</source>
          <target state="translated">&lt;strong&gt;Variable&lt;/strong&gt; : concepto combinado de un s&amp;iacute;mbolo que hace referencia a un valor en una ubicaci&amp;oacute;n particular de la memoria. Este t&amp;eacute;rmino generalmente est&amp;aacute; demasiado cargado para ser usado solo en la discusi&amp;oacute;n de detalles.</target>
        </trans-unit>
        <trans-unit id="5a8e1fdd316d10b0c0cd59d94a6940772041c1cd" translate="yes" xml:space="preserve">
          <source>A object is automatically passed by reference, without the need to specifically state it</source>
          <target state="translated">Un objeto se pasa automáticamente por referencia,sin necesidad de declararlo específicamente</target>
        </trans-unit>
        <trans-unit id="b440a38266bd3bd8023694ca76f1853cb56c68f1" translate="yes" xml:space="preserve">
          <source>A primitive value passed to a function cannot be modified by the function. A copy is made.</source>
          <target state="translated">Un valor primitivo pasado a una función no puede ser modificado por la función.Se hace una copia.</target>
        </trans-unit>
        <trans-unit id="79ce62763f1e30b37f20149148f8548734cf61b5" translate="yes" xml:space="preserve">
          <source>A very detailed explanation about copying, passing and comparing by value and by reference is in &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;this chapter&lt;/a&gt; of the &lt;em&gt;&quot;JavaScript: The Definitive Guide&quot;&lt;/em&gt; book.</source>
          <target state="translated">En &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;este cap&amp;iacute;tulo&lt;/a&gt; del libro &lt;em&gt;&quot;JavaScript: la gu&amp;iacute;a definitiva&quot; encontrar&amp;aacute;&lt;/em&gt; una explicaci&amp;oacute;n muy detallada sobre c&amp;oacute;mo copiar, pasar y comparar por valor y por referencia.</target>
        </trans-unit>
        <trans-unit id="f9d35a2aa876badcd3c415f65100051e77924dd6" translate="yes" xml:space="preserve">
          <source>Access of Object Properties</source>
          <target state="translated">Acceso a las propiedades de los objetos</target>
        </trans-unit>
        <trans-unit id="3e9807bf09a22721f2ffa94b835d05c65938f14a" translate="yes" xml:space="preserve">
          <source>Again, we pick a favorite.</source>
          <target state="translated">De nuevo,elegimos un favorito.</target>
        </trans-unit>
        <trans-unit id="988045fdd90b44521a9b2b9c55dfe875b6ad44e6" translate="yes" xml:space="preserve">
          <source>Although it doesn't really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?</source>
          <target state="translated">Aunque al final no importa,quiero saber cuál es la forma correcta de presentar los argumentos que pasan las convenciones.¿Hay un extracto de la especificación de JavaScript,que define lo que debe ser la semántica en relación con esto?</target>
        </trans-unit>
        <trans-unit id="96ef530acd2543eafd4ab0cb7e97e8162bcf66fb" translate="yes" xml:space="preserve">
          <source>Always remember that the equals sign (=) means assignment.
Always remember that passing a parameter to a function &lt;em&gt;in JavaScript&lt;/em&gt; also means assignment.
They are the same and the 2 variables are connected in exactly the same way (which is to say they aren't, unless you count that they are assigned to the same object).</source>
          <target state="translated">Recuerde siempre que el signo igual (=) significa asignaci&amp;oacute;n. Recuerde siempre que pasar un par&amp;aacute;metro a una funci&amp;oacute;n &lt;em&gt;en JavaScript&lt;/em&gt; tambi&amp;eacute;n significa asignaci&amp;oacute;n. Son iguales y las 2 variables est&amp;aacute;n conectadas exactamente de la misma manera (es decir, no lo son, a menos que cuente que est&amp;aacute;n asignadas al mismo objeto).</target>
        </trans-unit>
        <trans-unit id="bfdc1eb7888008268dcd1f229efc00ed9fe4071e" translate="yes" xml:space="preserve">
          <source>An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:</source>
          <target state="translated">Una forma fácil de determinar si algo es &quot;pasar por referencia&quot; es si se puede escribir una función de &quot;intercambio&quot;.Por ejemplo,en C,puedes hacer:</target>
        </trans-unit>
        <trans-unit id="3055a2e0457cb299ca6d433ebcc210c7bab9799e" translate="yes" xml:space="preserve">
          <source>An object outside a function is passed into a function by giving a reference to the outside object.</source>
          <target state="translated">Un objeto fuera de una función se pasa a una función dando una referencia al objeto exterior.</target>
        </trans-unit>
        <trans-unit id="b05bb9226e6abe9287bbf028bf6e5a6bed6624b9" translate="yes" xml:space="preserve">
          <source>An object passed to a function can have its members modified by the function.</source>
          <target state="translated">Un objeto pasado a una función puede tener sus miembros modificados por la función.</target>
        </trans-unit>
        <trans-unit id="29e123b648bf0a31ec900d67e265e2a81d689d3d" translate="yes" xml:space="preserve">
          <source>Array and Object is passed as  pass by reference or  pass by value based on these two condition.</source>
          <target state="translated">La matriz y el objeto se pasan como referencia o valor de paso en base a estas dos condiciones.</target>
        </trans-unit>
        <trans-unit id="7628591e37cbe88cf6fb309ba297bb58229eacac" translate="yes" xml:space="preserve">
          <source>As a final example, consider why a common attempt to clear an array doesn't work as expected.</source>
          <target state="translated">Como un ejemplo final,considere por qué un intento común de despejar una matriz no funciona como se esperaba.</target>
        </trans-unit>
        <trans-unit id="178ee3db1a483706ed36d79f599e1a13d33df86f" translate="yes" xml:space="preserve">
          <source>Before we leave the topic of
  manipulating objects and arrays by
  reference, we need to clear up a point
  of nomenclature.</source>
          <target state="translated">Antes de dejar el tema de la manipulación de objetos y matrices por referencia,necesitamos aclarar un punto de nomenclatura.</target>
        </trans-unit>
        <trans-unit id="f8884a4d2e00d4a1e326a98a062754846001f9b2" translate="yes" xml:space="preserve">
          <source>Both our favoriteString and string1 variables are assigned to 'Hello world'. Now, what if we want to change our favoriteString??? What will happen???</source>
          <target state="translated">Nuestras variables favoritas,String y string1,están asignadas a 'Hello world'.Ahora,¿qué pasa si queremos cambiar nuestra Cadena favorita? ¿Qué pasará?</target>
        </trans-unit>
        <trans-unit id="aa133f04e687ffaadb65bfc4786e9aafccdad56e" translate="yes" xml:space="preserve">
          <source>But both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are separate references to the same shared value &lt;code&gt;[1,2,3]&lt;/code&gt;, which is a compound value. It's important to note that neither &lt;code&gt;c&lt;/code&gt; nor &lt;code&gt;d&lt;/code&gt; more &quot;owns&quot; the &lt;code&gt;[1,2,3]&lt;/code&gt; value -- both are just equal peer references to the value. So, when using either reference to modify (&lt;code&gt;.push(4)&lt;/code&gt;) the actual shared &lt;code&gt;array&lt;/code&gt; value itself, it's affecting just the one shared value, and both references will reference the newly modified value &lt;code&gt;[1,2,3,4]&lt;/code&gt;.</source>
          <target state="translated">Pero tanto &lt;code&gt;d&lt;/code&gt; son referencias separadas al mismo valor compartido &lt;code&gt;[1,2,3]&lt;/code&gt; , que es un valor compuesto. Es importante tener en cuenta que ni &lt;code&gt;c&lt;/code&gt; ni &lt;code&gt;d&lt;/code&gt; m&amp;aacute;s &quot;poseen&quot; el valor &lt;code&gt;[1,2,3]&lt;/code&gt; ; ambos son referencias iguales iguales al valor. Por lo tanto, cuando se utiliza cualquiera de las referencias para modificar ( &lt;code&gt;.push(4)&lt;/code&gt; ) el valor real de la &lt;code&gt;array&lt;/code&gt; compartida en s&amp;iacute;, solo afecta al valor compartido, y ambas referencias har&amp;aacute;n referencia al valor reci&amp;eacute;n modificado &lt;code&gt;[1,2,3,4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="296985a800b1e8c9380cebd23dfbc86e71426942" translate="yes" xml:space="preserve">
          <source>Call CheckObjectCoercible(baseValue).</source>
          <target state="translated">Llama a CheckObjectCoercible(ValorBase).</target>
        </trans-unit>
        <trans-unit id="393aa90af622b95d2fecad8fb5a88f507b3e5d67" translate="yes" xml:space="preserve">
          <source>Changing the value of any changes value for both the variable.</source>
          <target state="translated">Cambiando el valor de cualquier valor de cambio para ambas variables.</target>
        </trans-unit>
        <trans-unit id="e68569b88f0d63d426d55a5ad6eb50201341e31f" translate="yes" xml:space="preserve">
          <source>Compound value (object, array, etc) that can be passed by reference-copy</source>
          <target state="translated">Valor compuesto (objeto,matriz,etc.)que puede ser pasado por una copia de referencia.</target>
        </trans-unit>
        <trans-unit id="26b600a5d56d8944d8651beec06ae0642c20e289" translate="yes" xml:space="preserve">
          <source>Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.</source>
          <target state="translated">Considere que los argumentos y los objetos variables son objetos creados durante el contexto de ejecución creado al principio de la invocación de la función-y su valuación real pasada a la función sólo se almacena en estos argumentos+objetos variables.</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">Considere lo siguiente:</target>
        </trans-unit>
        <trans-unit id="5cecf4a03ec84caeeda78029a5bd713522ec8fe8" translate="yes" xml:space="preserve">
          <source>Construction of Argument Lists</source>
          <target state="translated">Construcción de listas de argumentos</target>
        </trans-unit>
        <trans-unit id="635aa588bea9df239881e622d2cd3adbad8bf3c9" translate="yes" xml:space="preserve">
          <source>Definition of &quot;Object&quot;</source>
          <target state="translated">Definición de &quot;Objeto&quot;</target>
        </trans-unit>
        <trans-unit id="e9656fda095be85a55c47e88f0f2142837377331" translate="yes" xml:space="preserve">
          <source>E.g.:</source>
          <target state="translated">E.g.:</target>
        </trans-unit>
        <trans-unit id="e8a531332b5e0c2dac36ce0017c63f03c75815b9" translate="yes" xml:space="preserve">
          <source>Every time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.</source>
          <target state="translated">Cada vez que pasas una variable a una función,estás &quot;Asignando&quot; a lo que sea el nombre de la variable del parámetro,como si usaras el signo igual (=).</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="83b1fe6393f9ea04f7c6ef0ebceb29757afe9a44" translate="yes" xml:space="preserve">
          <source>First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.</source>
          <target state="translated">En primer lugar,hay múltiples niveles de abstracción que no todos parecen comprender.Los programadores más recientes que han aprendido en los lenguajes de 4ª o 5ª generación pueden tener dificultades para envolver su mente en torno a conceptos familiares para los programadores de ensamblador o de C que no están en fase de puntero a puntero.Pasar por referencia no significa simplemente la capacidad de cambiar un objeto referenciado usando una variable de parámetro de función.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">Por ejemplo</target>
        </trans-unit>
        <trans-unit id="01bf4a9057daf1172b230a29ebe7eb0911eb8d6d" translate="yes" xml:space="preserve">
          <source>For programming language lawyers, I've went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;asking&lt;/a&gt; it on the ECMAScript mailing list.</source>
          <target state="translated">Para los abogados de lenguaje de programaci&amp;oacute;n, revis&amp;eacute; las siguientes secciones de ECMAScript 5.1 (que es m&amp;aacute;s f&amp;aacute;cil de leer que la &amp;uacute;ltima edici&amp;oacute;n) y llegu&amp;eacute; a &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;preguntar&lt;/a&gt; en la lista de correo de ECMAScript.</target>
        </trans-unit>
        <trans-unit id="bd46cdb9b904080183e993ad3943a7303f85bd9f" translate="yes" xml:space="preserve">
          <source>Functions are objects</source>
          <target state="translated">Las funciones son objetos</target>
        </trans-unit>
        <trans-unit id="2fb8e5522eb18d1143e0bd9cb31d216fa77b5c59" translate="yes" xml:space="preserve">
          <source>Here is a rebuttal to this:</source>
          <target state="translated">Aquí hay una refutación a esto:</target>
        </trans-unit>
        <trans-unit id="47be461e851afeca8344b89d76c09b76e3e854ed" translate="yes" xml:space="preserve">
          <source>Here is an example, passing a number (a primitive type)</source>
          <target state="translated">He aquí un ejemplo,pasando un número (un tipo primitivo)</target>
        </trans-unit>
        <trans-unit id="6d1956753d691a97c45c137388c4df02dd75b9c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;obj&lt;/code&gt; acts as a wrapper for the scalar primitive property &lt;code&gt;a&lt;/code&gt;. When passed to &lt;code&gt;foo(..)&lt;/code&gt;, a copy of the &lt;code&gt;obj&lt;/code&gt; reference is passed in and set to the &lt;code&gt;wrapper&lt;/code&gt;parameter. We now can use the &lt;code&gt;wrapper&lt;/code&gt; reference to access the shared object, and update its property. After the function finishes, &lt;code&gt;obj.a&lt;/code&gt; will see the updated value &lt;code&gt;42&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;obj&lt;/code&gt; act&amp;uacute;a como un contenedor para la propiedad primitiva escalar &lt;code&gt;a&lt;/code&gt; . Cuando se pasa a &lt;code&gt;foo(..)&lt;/code&gt; , se pasa una copia de la referencia &lt;code&gt;obj&lt;/code&gt; y se establece en el par&amp;aacute;metro &lt;code&gt;wrapper&lt;/code&gt; . Ahora podemos usar la referencia del &lt;code&gt;wrapper&lt;/code&gt; para acceder al objeto compartido y actualizar su propiedad. Una vez que finaliza la funci&amp;oacute;n, &lt;code&gt;obj.a&lt;/code&gt; ver&amp;aacute; el valor actualizado &lt;code&gt;42&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05dc205598b6fae1df14251d0f1b665f0352c482" translate="yes" xml:space="preserve">
          <source>Here, we mean
  simply that a reference to an object
  or array -- not the object itself --
  is passed to a function. A function
  can use the reference to modify
  properties of the object or elements
  of the array. But if the function
  overwrites the reference with a
  reference to a new object or array,
  that modification is not visible
  outside of the function.</source>
          <target state="translated">Aquí,nos referimos simplemente a que una referencia a un objeto o conjunto-no al objeto mismo-se pasa a una función.Una función puede utilizar la referencia para modificar las propiedades del objeto o los elementos de la matriz.Pero si la función sobrescribe la referencia con una referencia a un nuevo objeto o conjunto,esa modificación no es visible fuera de la función.</target>
        </trans-unit>
        <trans-unit id="ec613745ca6fb8018d61844fbac16fd497f35e96" translate="yes" xml:space="preserve">
          <source>I have found the &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend method&lt;/a&gt; of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js library&lt;/a&gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.</source>
          <target state="translated">He encontrado que el &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;m&amp;eacute;todo extendido&lt;/a&gt; de la &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;biblioteca Underscore.js es&lt;/a&gt; muy &amp;uacute;til cuando quiero pasar un objeto como un par&amp;aacute;metro que puede modificarse o reemplazarse por completo.</target>
        </trans-unit>
        <trans-unit id="da00583f56bed3adae6b3854cb9669d9ef039b2e" translate="yes" xml:space="preserve">
          <source>I would say it is pass-by-copy -</source>
          <target state="translated">Diría que es una copia de paso...</target>
        </trans-unit>
        <trans-unit id="99152f78f2285e9f5178a28c6ae891d22918905b" translate="yes" xml:space="preserve">
          <source>I've read through these answers multiple times, but didn't REALLY get it until I learned about the technical definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;Call by sharing&quot;&lt;/a&gt; as termed by Barbara Liskov</source>
          <target state="translated">He le&amp;iacute;do estas respuestas varias veces, pero REALMENTE no lo entend&amp;iacute; hasta que aprend&amp;iacute; acerca de la definici&amp;oacute;n t&amp;eacute;cnica de &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;Llamar al compartir&quot;,&lt;/a&gt; como lo llama Barbara Liskov</target>
        </trans-unit>
        <trans-unit id="668d70912c4017d9abe459009e674ca09138a746" translate="yes" xml:space="preserve">
          <source>I.e. effectively primitive types are passed by value, and complex types are passed by reference.</source>
          <target state="translated">Es decir,los tipos efectivamente primitivos se pasan por valor,y los tipos complejos se pasan por referencia.</target>
        </trans-unit>
        <trans-unit id="0ec6ec8507ceaa91f883d8986d51cbca5f8b1a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj1&lt;/code&gt; was not a reference at all, then changing &lt;code&gt;obj1.item&lt;/code&gt; would have no effect on the &lt;code&gt;obj1&lt;/code&gt; outside of the function.</source>
          <target state="translated">Si &lt;code&gt;obj1&lt;/code&gt; no fuera una referencia, cambiar &lt;code&gt;obj1.item&lt;/code&gt; no tendr&amp;iacute;a ning&amp;uacute;n efecto en &lt;code&gt;obj1&lt;/code&gt; fuera de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="59dbe46a8ab60f48cf2577d1714a38c220edd92d" translate="yes" xml:space="preserve">
          <source>If the argument was a proper reference, then everything would have changed. &lt;code&gt;num&lt;/code&gt; would be &lt;code&gt;100&lt;/code&gt;, and &lt;code&gt;obj2.item&lt;/code&gt; would read &lt;code&gt;&quot;changed&quot;&lt;/code&gt;.</source>
          <target state="translated">Si el argumento fuera una referencia adecuada, entonces todo habr&amp;iacute;a cambiado. &lt;code&gt;num&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;100&lt;/code&gt; y &lt;code&gt;obj2.item&lt;/code&gt; leer&amp;iacute;a &lt;code&gt;&quot;changed&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8184ee6c0e0f41f78f07ffde38ac0df94ff1ef63" translate="yes" xml:space="preserve">
          <source>If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let
  strict be false.</source>
          <target state="translated">Si la producción sintáctica que está siendo evaluada está contenida en un código de modo estricto,dejemos que lo estricto sea verdadero,si no,dejemos que lo estricto sea falso.</target>
        </trans-unit>
        <trans-unit id="0514b00b4153ffccc1fdf8db144a3bb4f96beb69" translate="yes" xml:space="preserve">
          <source>If you can't do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.</source>
          <target state="translated">Si no puedes hacer el equivalente de eso en JavaScript,no es &quot;pasar por referencia&quot;.</target>
        </trans-unit>
        <trans-unit id="ed437ed8c9b163811c8c45a0df65ee0cfa2b2119" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;strong&gt;objects&lt;/strong&gt; are stored as references:</source>
          <target state="translated">En JavaScript, los &lt;strong&gt;objetos&lt;/strong&gt; se almacenan como referencias:</target>
        </trans-unit>
        <trans-unit id="4a244292f7a66631a95bd0016a42e5a3d8a6fdee" translate="yes" xml:space="preserve">
          <source>In JavaScript, the type of the value &lt;em&gt;solely&lt;/em&gt; controls whether that value will be assigned by &lt;strong&gt;value-copy&lt;/strong&gt; or by &lt;strong&gt;reference-copy&lt;/strong&gt;.</source>
          <target state="translated">En JavaScript, el tipo de valor &lt;em&gt;solo&lt;/em&gt; controla si ese valor se asignar&amp;aacute; por &lt;strong&gt;copia de valor&lt;/strong&gt; o por &lt;strong&gt;copia&lt;/strong&gt; de &lt;strong&gt;referencia&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf140191af1dcec987a4dde5edb6fb8a16e09a25" translate="yes" xml:space="preserve">
          <source>In a low level language, if you want to pass a variable by reference you have to use a specific syntax in the creation of the function:</source>
          <target state="translated">En un lenguaje de bajo nivel,si se quiere pasar una variable por referencia hay que utilizar una sintaxis específica en la creación de la función:</target>
        </trans-unit>
        <trans-unit id="81c7785c18e39819bdc6bf53496b0a9a6239d0fc" translate="yes" xml:space="preserve">
          <source>In both alerts you will find the value to be undefined.</source>
          <target state="translated">En ambas alertas encontrará que el valor no está definido.</target>
        </trans-unit>
        <trans-unit id="35606096aee27d974b3090d3e8e5ae1f3bda2fd4" translate="yes" xml:space="preserve">
          <source>In my book that's called passing by reference.</source>
          <target state="translated">En mi libro eso se llama pasar por referencia.</target>
        </trans-unit>
        <trans-unit id="3f390d1963a58a5cc587e0e6330cf78dff59fc86" translate="yes" xml:space="preserve">
          <source>In practical terms, this means that if you change the parameter itself (as with &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt;), that won't affect the item that was fed into the parameter. But if you change the &lt;strong&gt;INTERNALS&lt;/strong&gt; of the parameter, that will propagate back up (as with &lt;code&gt;obj1&lt;/code&gt;).</source>
          <target state="translated">En t&amp;eacute;rminos pr&amp;aacute;cticos, esto significa que si cambia el par&amp;aacute;metro en s&amp;iacute; (como con &lt;code&gt;num&lt;/code&gt; y &lt;code&gt;obj2&lt;/code&gt; ), eso no afectar&amp;aacute; el elemento que se introdujo en el par&amp;aacute;metro. Pero si cambia los &lt;strong&gt;INTERNOS&lt;/strong&gt; del par&amp;aacute;metro, se propagar&amp;aacute; una copia de seguridad (como con &lt;code&gt;obj1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b57ba2b5cb9f82c19123db765fac17e24d1951eb" translate="yes" xml:space="preserve">
          <source>In the above snippet, because &lt;code&gt;2&lt;/code&gt; is a scalar primitive, &lt;code&gt;a&lt;/code&gt; holds one initial copy of that value, and &lt;code&gt;b&lt;/code&gt; is assigned another copy of the value. When changing &lt;code&gt;b&lt;/code&gt;, you are in no way changing the value in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">En el fragmento anterior, debido a que &lt;code&gt;2&lt;/code&gt; es una primitiva escalar, &lt;code&gt;a&lt;/code&gt; tiene una copia inicial de ese valor, y a &lt;code&gt;b&lt;/code&gt; se le asigna otra copia del valor. Al cambiar &lt;code&gt;b&lt;/code&gt; , de ninguna manera est&amp;aacute; cambiando el valor en &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be98568917515ecc47f6e69cddc320618b40a6f" translate="yes" xml:space="preserve">
          <source>Inside the function, parameter variables, &lt;code&gt;inVar1&lt;/code&gt; and &lt;code&gt;inVar2&lt;/code&gt;, receive the contents being passed.</source>
          <target state="translated">Dentro de la funci&amp;oacute;n, las variables de par&amp;aacute;metro, &lt;code&gt;inVar1&lt;/code&gt; e &lt;code&gt;inVar2&lt;/code&gt; , reciben los contenidos que se pasan.</target>
        </trans-unit>
        <trans-unit id="eb0aded998f21b511a6bf2ba99f8f35d22c1fb84" translate="yes" xml:space="preserve">
          <source>Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is &lt;em&gt;itself&lt;/em&gt; a reference.
Technically, this is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;call-by-sharing&lt;/a&gt;.</source>
          <target state="translated">En cambio, la situaci&amp;oacute;n es que el elemento pasado se pasa por valor. Pero el elemento que se pasa por valor es en &lt;em&gt;s&amp;iacute; mismo&lt;/em&gt; una referencia. T&amp;eacute;cnicamente, esto se llama &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;llamada por compartir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d302320d7430fecc028a90dc07690d841f6022" translate="yes" xml:space="preserve">
          <source>Is JavaScript a pass-by-reference or pass-by-value language</source>
          <target state="translated">¿Es el Javascript un lenguaje de referencia o de valores</target>
        </trans-unit>
        <trans-unit id="762dca873ea18a90a6df0ccb480c5023409ab8ee" translate="yes" xml:space="preserve">
          <source>It is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;effort&lt;/a&gt; to understand.</source>
          <target state="translated">Se define en la edici&amp;oacute;n 5.1 que &quot;Un objeto es una colecci&amp;oacute;n de propiedades&quot;. Por lo tanto, podemos inferir que el valor del objeto es la colecci&amp;oacute;n, pero en cuanto a cu&amp;aacute;l es el valor de la colecci&amp;oacute;n est&amp;aacute; mal definido en la especificaci&amp;oacute;n y requiere un poco de &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;esfuerzo&lt;/a&gt; para comprenderlo.</target>
        </trans-unit>
        <trans-unit id="986429e47688846136b52b4cd304e16867c4438c" translate="yes" xml:space="preserve">
          <source>It is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they're only used to describe the behavior of the delete, the typeof, and the assignment operators.</source>
          <target state="translated">En la sección 8.7 &quot;El tipo de especificación de referencia&quot; se describe que las referencias no son tipos reales en el idioma,sino que sólo se utilizan para describir el comportamiento de los operadores de borrado,el tipof y la asignación.</target>
        </trans-unit>
        <trans-unit id="fc2fc8bac54ed799049c59646ec8689ad7f219e2" translate="yes" xml:space="preserve">
          <source>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its &lt;em&gt;members&lt;/em&gt;, those changes persist outside of the function.  This makes it &lt;em&gt;look&lt;/em&gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.</source>
          <target state="translated">Siempre pasa por valor, pero para los objetos el valor de la variable es una referencia. Debido a esto, cuando pasa un objeto y cambia sus &lt;em&gt;miembros&lt;/em&gt; , esos cambios persisten fuera de la funci&amp;oacute;n. Esto hace que &lt;em&gt;parezca&lt;/em&gt; pasar por referencia. Pero si realmente cambia el valor de la variable de objeto, ver&amp;aacute; que el cambio no persiste, lo que demuestra que realmente pasa por valor.</target>
        </trans-unit>
        <trans-unit id="89a28927b7d2922705fe9300b7e6edf22dfdb59e" translate="yes" xml:space="preserve">
          <source>It's interesting in JavaScript. Consider this example:</source>
          <target state="translated">Es interesante en JavaScript.Considere este ejemplo:</target>
        </trans-unit>
        <trans-unit id="a58c0376442784131cce6ed16ca6889fa180a199" translate="yes" xml:space="preserve">
          <source>It's tempting to think that &lt;em&gt;primitives&lt;/em&gt; are enforced by special rules while &lt;em&gt;objects&lt;/em&gt; are not, but primitives are simply the end of the pointer chain.</source>
          <target state="translated">Es tentador pensar que &lt;em&gt;las&lt;/em&gt; reglas especiales imponen &lt;em&gt;primitivas&lt;/em&gt; mientras que los &lt;em&gt;objetos&lt;/em&gt; no, pero las primitivas son simplemente el final de la cadena de punteros.</target>
        </trans-unit>
        <trans-unit id="0f6e466f49c26929af238bc6449efa0b8dbf2534" translate="yes" xml:space="preserve">
          <source>It's time to throw out everything you know about pass by value / reference.</source>
          <target state="translated">Es hora de tirar todo lo que sabes sobre la referencia de los valores de paso.</target>
        </trans-unit>
        <trans-unit id="c1ad2e0efeecec9224ee8d6ce3fbe2b458a354fc" translate="yes" xml:space="preserve">
          <source>JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object's data via the function parameter is synonymous to &quot;pass-by-value&quot;.</source>
          <target state="translated">El JavaScript no pasa por referencia.Si lee con atención,se dará cuenta de que todas las opiniones contrarias malinterpretan lo que se entiende por &quot;pass-by-value&quot; y concluyen falsamente que la capacidad de actualizar los datos de un objeto a través del parámetro de la función es sinónimo de &quot;pass-by-value&quot;.</target>
        </trans-unit>
        <trans-unit id="d2d80fc6a6ff698bf0fd9cfa17926536bf0021d5" translate="yes" xml:space="preserve">
          <source>JavaScript is always &lt;em&gt;pass-by-value&lt;/em&gt;; everything is of value type.</source>
          <target state="translated">JavaScript siempre es &lt;em&gt;paso por valor&lt;/em&gt; ; todo es de tipo de valor.</target>
        </trans-unit>
        <trans-unit id="d61aca1d96d43376df88c4a107691b9524026ab9" translate="yes" xml:space="preserve">
          <source>JavaScript passes primitive types by value and object types by reference</source>
          <target state="translated">JavaScript pasa los tipos primitivos por valor y los tipos de objetos por referencia</target>
        </trans-unit>
        <trans-unit id="821543b87e4b4527bdc1a22fea2a59bd6cf89783" translate="yes" xml:space="preserve">
          <source>Javascript is a high level language that does this conversion for you. 
So, although objects are passed by reference, the language converts the reference parameter to the value. You don't need to use &lt;code&gt;&amp;amp;&lt;/code&gt;, on the function definition, to pass it by reference, neither &lt;code&gt;*&lt;/code&gt;, on the function body, to convert the reference to the value, JS does it for you.</source>
          <target state="translated">Javascript es un lenguaje de alto nivel que realiza esta conversi&amp;oacute;n por usted. Entonces, aunque los objetos se pasan por referencia, el lenguaje convierte el par&amp;aacute;metro de referencia al valor. No necesita usar &lt;code&gt;&amp;amp;&lt;/code&gt; , en la definici&amp;oacute;n de la funci&amp;oacute;n, para pasarlo por referencia, ni &lt;code&gt;*&lt;/code&gt; , en el cuerpo de la funci&amp;oacute;n, para convertir la referencia al valor, JS lo hace por usted.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">Aprende más.</target>
        </trans-unit>
        <trans-unit id="e2890eaeaae54ae8213119b094d6eac3b0d0f34d" translate="yes" xml:space="preserve">
          <source>Let arg be GetValue(ref).</source>
          <target state="translated">Let arg be GetValue(ref).</target>
        </trans-unit>
        <trans-unit id="d5b52edd936f17bee3970c4c4428d8bdb2114974" translate="yes" xml:space="preserve">
          <source>Let baseReference be the result of evaluating MemberExpression.</source>
          <target state="translated">Dejemos que baseReference sea el resultado de la evaluación de MemberExpression.</target>
        </trans-unit>
        <trans-unit id="5793a1bc1d3ece9a28dfc1f7df2511a7f09c3cea" translate="yes" xml:space="preserve">
          <source>Let baseValue be GetValue(baseReference).</source>
          <target state="translated">Que el valor base sea GetValue (referencia base).</target>
        </trans-unit>
        <trans-unit id="0fbb0a339d88c497bca6b7e0e0802f2e1a9e810f" translate="yes" xml:space="preserve">
          <source>Let propertyNameReference be the result of evaluating Expression.</source>
          <target state="translated">Dejemos que la propiedadNombreReferencia sea el resultado de la evaluación de Expresión.</target>
        </trans-unit>
        <trans-unit id="e26b41e64cfc85d8131bd89ab1968cf9b539bc12" translate="yes" xml:space="preserve">
          <source>Let propertyNameString be ToString(propertyNameValue).</source>
          <target state="translated">Deja que la propiedadNameString sea ToString(propiedadNameValue).</target>
        </trans-unit>
        <trans-unit id="d27739e60a7d1d0ee771b1f518f987ee71282c40" translate="yes" xml:space="preserve">
          <source>Let propertyNameValue be GetValue(propertyNameReference).</source>
          <target state="translated">Dejar que la propiedadNombreValor sea GetValue(propiedadNombreReferencia).</target>
        </trans-unit>
        <trans-unit id="765c825fb8ce47d020ac3dcc136c15f73cbaa9d1" translate="yes" xml:space="preserve">
          <source>Let ref be the result of evaluating AssignmentExpression.</source>
          <target state="translated">Que sea el resultado de la evaluación de AssignmentExpression.</target>
        </trans-unit>
        <trans-unit id="ba443140669d7febc24e1df988b59f67bf1999bc" translate="yes" xml:space="preserve">
          <source>My simple way to understand this...</source>
          <target state="translated">Mi simple manera de entender esto...</target>
        </trans-unit>
        <trans-unit id="41e399d344b8bb63a9437372496bb38b9ea65720" translate="yes" xml:space="preserve">
          <source>My two cents... This is the way I understand it. (Feel free to correct me if I'm wrong)</source>
          <target state="translated">Mis dos centavos...Así es como lo entiendo.(Siéntete libre de corregirme si me equivoco)</target>
        </trans-unit>
        <trans-unit id="cc50c81892c92e84bb1ae3f1a86483bee39914a6" translate="yes" xml:space="preserve">
          <source>Next, for whatever reason, we decide that we like object 2 better. So, we simply do a little re-assignment.</source>
          <target state="translated">Luego,por cualquier razón,decidimos que nos gusta más el objeto 2.Así que,simplemente hacemos una pequeña reasignación.</target>
        </trans-unit>
        <trans-unit id="5983d2311d0216c94667916653cda7009208c7ff" translate="yes" xml:space="preserve">
          <source>Nothing happened to object1 or to object2. We haven't changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.</source>
          <target state="translated">No le pasó nada al objeto 1 o al objeto 2.No hemos cambiado ningún dato en absoluto.Todo lo que hicimos fue reasignar cuál es nuestro objeto favorito.Es importante saber que el objeto2 y el objeto favorito están ambos asignados al mismo objeto.Podemos cambiar ese objeto a través de cualquiera de esas variables.</target>
        </trans-unit>
        <trans-unit id="b0ed35c065098b7007966c00ae087554253b51c5" translate="yes" xml:space="preserve">
          <source>Now, let's say that we like object1 better... So, we &quot;assign&quot; a new variable.</source>
          <target state="translated">Ahora,digamos que nos gusta más el objeto 1...Entonces,&quot;asignamos&quot; una nueva variable.</target>
        </trans-unit>
        <trans-unit id="fefaeda9e706a96b72c3a91f6d46d3d47c7c5900" translate="yes" xml:space="preserve">
          <source>Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you simply assigned using the equal (=) sign.</source>
          <target state="translated">Ahora,sobre las funciones y los parámetros de paso...Cuando llamas a una función y le pasas un parámetro,lo que estás haciendo esencialmente es una &quot;asignación&quot; a una nueva variable,y funciona exactamente igual que si simplemente la asignaras usando el signo igual (=).</target>
        </trans-unit>
        <trans-unit id="b357112211b094b3237788d525b078423b089167" translate="yes" xml:space="preserve">
          <source>Now, people like to bicker endlessly about whether &quot;pass by reference&quot;
  is the correct way to describe what Java et al. actually do. The point
  is this:</source>
          <target state="translated">Ahora,a la gente le gusta discutir sin parar sobre si &quot;pasar por referencia&quot; es la forma correcta de describir lo que Java et al.realmente hacen.El punto es este:</target>
        </trans-unit>
        <trans-unit id="a7538e8091867206be4163070d38a8f2f6e2fc36" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function</source>
          <target state="translated">Ahora,lo mismo,pero con una función</target>
        </trans-unit>
        <trans-unit id="54f947ec6644ed78ef13a3901e8e53b29b1eae30" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function call</source>
          <target state="translated">Ahora,lo mismo,pero con una llamada de función</target>
        </trans-unit>
        <trans-unit id="85abe287e946ffe23eec095f98389cf0bb761865" translate="yes" xml:space="preserve">
          <source>OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn't matter whether something is passed by reference or by value... What matters is assignment vs mutation.</source>
          <target state="translated">Bien,si lees todo este post,quizás ahora entiendas mejor cómo funcionan las llamadas a funciones en JavaScript.No importa si algo se pasa por referencia o por valor...Lo que importa es la asignación vs.la mutación.</target>
        </trans-unit>
        <trans-unit id="49aff953ef64c0bfd256e94df786773f165a1a31" translate="yes" xml:space="preserve">
          <source>OK, let me do my best to explain what I mean. Let's say you have a few objects.</source>
          <target state="translated">Bien,déjame hacer lo mejor para explicarte lo que quiero decir.Digamos que tienes unos cuantos objetos.</target>
        </trans-unit>
        <trans-unit id="d3ac732c421aaa382ba2a7df3b9370ee3d46965c" translate="yes" xml:space="preserve">
          <source>OK, now let&amp;rsquo;s give a few examples using objects instead... first, without the function.</source>
          <target state="translated">Bien, ahora demos algunos ejemplos usando objetos en su lugar ... primero, sin la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="55f468caaf302476af028732ffb89566f3834bf7" translate="yes" xml:space="preserve">
          <source>OK, now let's look at primitives like strings for example</source>
          <target state="translated">Bien,ahora veamos a los primitivos como las cuerdas por ejemplo</target>
        </trans-unit>
        <trans-unit id="ed4f6a94ec208043cd9b8120122b92570d99ac3f" translate="yes" xml:space="preserve">
          <source>Objects are passed by reference (the reference is passed by value).</source>
          <target state="translated">Los objetos se pasan por referencia (la referencia se pasa por valor).</target>
        </trans-unit>
        <trans-unit id="a0023dbe18ebfeae7656c8332857dde47f6a7acc" translate="yes" xml:space="preserve">
          <source>Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an &lt;em&gt;object&lt;/em&gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are &lt;em&gt;primitives&lt;/em&gt;.</source>
          <target state="translated">Los objetos son valores, y las funciones miembro de los objetos son valores en s&amp;iacute; mismos (recuerde que las funciones son objetos de primera clase en JavaScript). Adem&amp;aacute;s, con respecto al concepto de que todo en JavaScript es un &lt;em&gt;objeto&lt;/em&gt; ; esto est&amp;aacute; mal. Las cadenas, s&amp;iacute;mbolos, n&amp;uacute;meros, booleanos, nulos e indefinidos son &lt;em&gt;primitivos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7c473076e20653740c581b65a9c148582980e1f2" translate="yes" xml:space="preserve">
          <source>On Reference</source>
          <target state="translated">En referencia</target>
        </trans-unit>
        <trans-unit id="24023d41b24981459776a8deb45dffaf544e073a" translate="yes" xml:space="preserve">
          <source>On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:</source>
          <target state="translated">En ocasiones pueden aprovechar algunas funciones y propiedades de los miembros heredadas de sus prototipos base,pero esto es sólo por conveniencia.No significa que sean objetos en sí mismos.Pruebe lo siguiente como referencia:</target>
        </trans-unit>
        <trans-unit id="4d12f26544314335beb7af690a37352634d31faf" translate="yes" xml:space="preserve">
          <source>One more example:</source>
          <target state="translated">Un ejemplo más:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="61d70ce6c0868b0a4084920bfa36265cd2924428" translate="yes" xml:space="preserve">
          <source>PHP does something similar since version 5: all objects are passed by reference, but all primitives &lt;em&gt;may&lt;/em&gt; be passed by reference, if preceded by an ampersand (&amp;amp;). Otherwise primitives are passed by value.</source>
          <target state="translated">PHP hace algo similar desde la versi&amp;oacute;n 5: todos los objetos se pasan por referencia, pero todas las primitivas &lt;em&gt;se&lt;/em&gt; pueden pasar por referencia, si est&amp;aacute;n precedidas por un signo (&amp;amp;). De lo contrario, las primitivas se pasan por valor.</target>
        </trans-unit>
        <trans-unit id="4aa6714b9431fbeb4050db107726bf42359cbd64" translate="yes" xml:space="preserve">
          <source>Passing an object does not copy the object.</source>
          <target state="translated">Pasar un objeto no copia el objeto.</target>
        </trans-unit>
        <trans-unit id="177116d45ea2e23710bb7ea3a718654efa24f9bc" translate="yes" xml:space="preserve">
          <source>Passing arguments to a function in JavaScript is analogous to passing
parameters by pointer value in C:</source>
          <target state="translated">Pasar argumentos a una función en JavaScript es análogo a pasar parámetros por el valor del puntero en C:</target>
        </trans-unit>
        <trans-unit id="01f2294132d2e2f2b4566ede86b13262366d51fb" translate="yes" xml:space="preserve">
          <source>Primitives (number, Boolean, etc.) are passed by value.</source>
          <target state="translated">Los primitivos (número,booleano,etc.)se pasan por valor.</target>
        </trans-unit>
        <trans-unit id="1fbe034f18e45d911f35c38befd6ffef1237ff9d" translate="yes" xml:space="preserve">
          <source>Primitives are passed by value and objects are passed by reference. This is quite different from other languages like C, Visual Basic, or Delphi. I can't say how they handle objects and primitives exactly, but I know of Visual Basic and Delphi that it can (and should) be specified.</source>
          <target state="translated">Los primitivos se pasan por valor y los objetos se pasan por referencia.Esto es muy diferente de otros lenguajes como C,Visual Basic o Delphi.No puedo decir cómo manejan los objetos y los primitivos exactamente,pero sé de Visual Basic y Delphi que puede (y debe)ser especificado.</target>
        </trans-unit>
        <trans-unit id="b3a5e4b79e22cee55b6065ffe3f652237cc7594a" translate="yes" xml:space="preserve">
          <source>Readers
  familiar with the other meaning of
  this term may prefer to say that
  objects and arrays are passed by
  value, but the value that is passed is
  actually a reference rather than the
  object itself.</source>
          <target state="translated">Los lectores familiarizados con el otro significado de este término pueden preferir decir que los objetos y las matrices se pasan por valor,pero el valor que se pasa es en realidad una referencia más que el objeto en sí.</target>
        </trans-unit>
        <trans-unit id="13206fd4fe5b59fc41e3d5a63a6488e8b552facb" translate="yes" xml:space="preserve">
          <source>Reassigning a variable merely points that pointer at a new value.</source>
          <target state="translated">Reasignar una variable simplemente apunta ese puntero a un nuevo valor.</target>
        </trans-unit>
        <trans-unit id="3207f76b42378372483b9234b1caf6f7a147a617" translate="yes" xml:space="preserve">
          <source>Reassigning a variable will never affect other variables that were pointing at that same object</source>
          <target state="translated">Reasignar una variable nunca afectará a otras variables que apunten a ese mismo objeto</target>
        </trans-unit>
        <trans-unit id="d310f078235065dddc3b458e5e588f59ca402bb8" translate="yes" xml:space="preserve">
          <source>Repeating this with an object yields different results:</source>
          <target state="translated">Repetir esto con un objeto da resultados diferentes:</target>
        </trans-unit>
        <trans-unit id="203297a3389833da40302baa74058f84dfb4172b" translate="yes" xml:space="preserve">
          <source>Return a List whose sole item is arg.</source>
          <target state="translated">Devuelve una lista cuyo único artículo es arg.</target>
        </trans-unit>
        <trans-unit id="fea577a31c06a6a5a9a25864cabd1f7cd04ffc69" translate="yes" xml:space="preserve">
          <source>Section 11.2.1 &quot;Property Accessors&quot;</source>
          <target state="translated">Sección 11.2.1 &quot;Accesores de la propiedad&quot;</target>
        </trans-unit>
        <trans-unit id="e3cdf6da05c63ab4f98f08c709113dc947f4641b" translate="yes" xml:space="preserve">
          <source>Section 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:</source>
          <target state="translated">La sección 11.2.4 &quot;Listas de argumentos&quot; dice lo siguiente sobre la elaboración de una lista de argumentos que consiste en un solo argumento:</target>
        </trans-unit>
        <trans-unit id="3dffa3d82c957452592ddbe22ee7b9fbabbad396" translate="yes" xml:space="preserve">
          <source>Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).</source>
          <target state="translated">¡Semántica! Establecer definiciones concretas hará necesariamente que algunas respuestas y comentarios sean incompatibles,ya que no describen lo mismo aunque se utilicen las mismas palabras y frases,pero es fundamental superar la confusión (especialmente para los nuevos programadores).</target>
        </trans-unit>
        <trans-unit id="9042860968c9655fa63ade5546c81f532a616526" translate="yes" xml:space="preserve">
          <source>Simple values inside functions will not change those values outside of the function (they are passed by value), whereas complex ones will (they are passed by reference).</source>
          <target state="translated">Los valores simples dentro de las funciones no cambiarán esos valores fuera de la función (se pasan por valor),mientras que los complejos sí lo harán (se pasan por referencia).</target>
        </trans-unit>
        <trans-unit id="af00e0ad8adf530d42297d91d90e47a9e641005b" translate="yes" xml:space="preserve">
          <source>Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.</source>
          <target state="translated">Sencillamente,para los tipos primitivos,los valores se copian al principio de la llamada de función,para el tipo de objeto,la referencia se copia.</target>
        </trans-unit>
        <trans-unit id="14e546fc199d754d3c9fb63d6f7e0dc0eda5708f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;inVar2&lt;/code&gt; received the reference of &lt;code&gt;{ prop: 2 }&lt;/code&gt;, you can change the value of the object's property.</source>
          <target state="translated">Como &lt;code&gt;inVar2&lt;/code&gt; recibi&amp;oacute; la referencia de &lt;code&gt;{ prop: 2 }&lt;/code&gt; , puede cambiar el valor de la propiedad del objeto.</target>
        </trans-unit>
        <trans-unit id="6b26d53b2a6c26d221c34b2ced9596e48f74edf5" translate="yes" xml:space="preserve">
          <source>So changing the value of a variable doesn't affect the other, as they both reside in two different locations.</source>
          <target state="translated">Así que cambiar el valor de una variable no afecta a la otra,ya que ambas residen en dos lugares diferentes.</target>
        </trans-unit>
        <trans-unit id="f443d83baee5de8b57871adc873303085a0467cd" translate="yes" xml:space="preserve">
          <source>So in JavaScript, if I pass an object X into a function via a parameter, it will still be X. If you are changing data &lt;em&gt;inside&lt;/em&gt; the function (or any other object, but that's not important) that new value is also available outside the function.</source>
          <target state="translated">Entonces, en JavaScript, si paso un objeto X a una funci&amp;oacute;n a trav&amp;eacute;s de un par&amp;aacute;metro, seguir&amp;aacute; siendo X. Si est&amp;aacute; cambiando datos &lt;em&gt;dentro de&lt;/em&gt; la funci&amp;oacute;n (o cualquier otro objeto, pero eso no es importante), ese nuevo valor tambi&amp;eacute;n est&amp;aacute; disponible fuera del funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8f7623c6dec052db957de7605896e4a2a3e6b647" translate="yes" xml:space="preserve">
          <source>So, &lt;strike&gt;forget about &lt;em&gt;&quot;pass by reference/value&quot;&lt;/em&gt;&lt;/strike&gt; don't get hung up on &quot;pass by reference/value&quot; because:</source>
          <target state="translated">Entonces, &lt;strike&gt;olv&amp;iacute;date de &lt;em&gt;&quot;pasar por referencia / valor&quot;&lt;/em&gt;&lt;/strike&gt; , no te obsesiones con &quot;pasar por referencia / valor&quot; porque:</target>
        </trans-unit>
        <trans-unit id="68d38550c4da9fcceac584158479a156958fb538" translate="yes" xml:space="preserve">
          <source>Some final comments:</source>
          <target state="translated">Algunos comentarios finales:</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="26220bb61f95026a6699bda5f772ab5f459fb7d2" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</source>
          <target state="translated">Fuente: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00317f5e100f735c8f89f41e078aacbee58460d5" translate="yes" xml:space="preserve">
          <source>Strings are immutable, so it doesn't really matter for them.</source>
          <target state="translated">Las cuerdas son inmutables,así que realmente no les importa.</target>
        </trans-unit>
        <trans-unit id="d0020398180c05f3b9f05227c429a1215e0aae80" translate="yes" xml:space="preserve">
          <source>Take these examples.</source>
          <target state="translated">Toma estos ejemplos.</target>
        </trans-unit>
        <trans-unit id="96016a84f6ccaa21c0ff5eb49c88180b5839dbb7" translate="yes" xml:space="preserve">
          <source>That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.</source>
          <target state="translated">Es decir,las referencias de los parámetros son alterables si vas y accedes al valor del parámetro mismo.Por otro lado,la asignación a un parámetro desaparecerá después de la evaluación,y no es accesible para el llamador de la función.</target>
        </trans-unit>
        <trans-unit id="1e9b208745c0adc4ae130578652525c2f81da6a0" translate="yes" xml:space="preserve">
          <source>That's why when you try to change an object inside a function, by replacing it's value (i.e. &lt;code&gt;age = {value:5}&lt;/code&gt;), the change doesn't persist, but if you change it's properties (i.e. &lt;code&gt;age.value = 5&lt;/code&gt;), it does.</source>
          <target state="translated">Es por eso que cuando intenta cambiar un objeto dentro de una funci&amp;oacute;n, al reemplazar su valor (es decir, &lt;code&gt;age = {value:5}&lt;/code&gt; ), el cambio no persiste, pero si cambia sus propiedades (es decir, &lt;code&gt;age.value = 5&lt;/code&gt; ), lo hace.</target>
        </trans-unit>
        <trans-unit id="ff449e061e42e079c42808abf8dc5c78475c9c12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;age&lt;/code&gt; is a reference to &lt;code&gt;myAge&lt;/code&gt;, but if you want the value you have to convert the reference, using &lt;code&gt;*age&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;age&lt;/code&gt; &lt;code&gt;myAge&lt;/code&gt; es una referencia a myAge , pero si desea el valor, debe convertir la referencia, usando &lt;code&gt;*age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfb912d780ddf9573a7ca91bac5773da514df0e" translate="yes" xml:space="preserve">
          <source>The JavaScript engine assigns the object to the variable &lt;code&gt;c&lt;/code&gt;, and it points to some memory, say (0x012).</source>
          <target state="translated">El motor de JavaScript asigna el objeto a la variable &lt;code&gt;c&lt;/code&gt; , y apunta a un poco de memoria, digamos (0x012).</target>
        </trans-unit>
        <trans-unit id="54327c1b59eda63c1878391f14ad9c7f807364da" translate="yes" xml:space="preserve">
          <source>The MDN docs explain it clearly, without being too verbose:</source>
          <target state="translated">Los médicos del MDN lo explican claramente,sin ser demasiado verbosos:</target>
        </trans-unit>
        <trans-unit id="131abb827464b85b18ae518074aac50427c4fc92" translate="yes" xml:space="preserve">
          <source>The equal(=) operator sets up new memory space or address</source>
          <target state="translated">El operador igual(=)establece un nuevo espacio de memoria o dirección</target>
        </trans-unit>
        <trans-unit id="ebfa1ea7372d6f23abc337f70c4f4df97d8a30cd" translate="yes" xml:space="preserve">
          <source>The most succinct explanation I found was in the &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB style guide&lt;/a&gt;:</source>
          <target state="translated">La explicaci&amp;oacute;n m&amp;aacute;s sucinta que encontr&amp;eacute; fue en la &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;gu&amp;iacute;a de estilo de AirBNB&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c3d021afb081241b899877ae82ca0e06ab382f15" translate="yes" xml:space="preserve">
          <source>The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)</source>
          <target state="translated">El único &quot;gotcha&quot; es cuando el nombre de la variable que se pasa a la función es el mismo que el nombre del parámetro de la función.Cuando esto sucede,tienes que tratar el parámetro dentro de la función como si fuera una nueva variable privada de la función (porque lo es)</target>
        </trans-unit>
        <trans-unit id="2e351bcd6c54bf11efb568e95ee714a771482cbd" translate="yes" xml:space="preserve">
          <source>The only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven't modified the variable, but the object itself.</source>
          <target state="translated">La única vez que &quot;modificar una variable&quot; afecta a una variable diferente es cuando el objeto subyacente está mutado (en cuyo caso no se ha modificado la variable,sino el objeto mismo).</target>
        </trans-unit>
        <trans-unit id="e117feea80f4052240b302d90852bffb9002a69f" translate="yes" xml:space="preserve">
          <source>The parameters of a function call are the function's &lt;em&gt;arguments&lt;/em&gt;.
  Arguments are passed to functions &lt;em&gt;by value&lt;/em&gt;. If the function changes
  the value of an argument, this change is not reflected globally or in
  the calling function. However, object references are values, too, and
  they are special: if the function changes the referred object's
  properties, that change is visible outside the function, (...)</source>
          <target state="translated">Los par&amp;aacute;metros de una llamada a funci&amp;oacute;n son los &lt;em&gt;argumentos de&lt;/em&gt; la funci&amp;oacute;n. Los argumentos se pasan a las funciones &lt;em&gt;por valor&lt;/em&gt; . Si la funci&amp;oacute;n cambia el valor de un argumento, este cambio no se refleja globalmente o en la funci&amp;oacute;n de llamada. Sin embargo, las referencias a objetos tambi&amp;eacute;n son valores, y son especiales: si la funci&amp;oacute;n cambia las propiedades del objeto referido, ese cambio es visible fuera de la funci&amp;oacute;n, (...)</target>
        </trans-unit>
        <trans-unit id="df2fd245eb7826b794aeb3d9f1b7a4aa9ba6448f" translate="yes" xml:space="preserve">
          <source>The phrase &quot;pass by
  reference&quot; can have several meanings.
  To some readers, the phrase refers to
  a function invocation technique that
  allows a function to assign new values
  to its arguments and to have those
  modified values visible outside the
  function. This is not the way the term
  is used in this book.</source>
          <target state="translated">La frase &quot;pasar por referencia&quot; puede tener varios significados.Para algunos lectores,la frase se refiere a una técnica de invocación de funciones que permite que una función asigne nuevos valores a sus argumentos y que esos valores modificados sean visibles fuera de la función.Esta no es la forma en que se usa el término en este libro.</target>
        </trans-unit>
        <trans-unit id="40424125880f7bec8d7f9e5602a94c76e97cd1cc" translate="yes" xml:space="preserve">
          <source>The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).</source>
          <target state="translated">Los tipos primitivos (número,cadena,etc.)se pasan por valor,pero los objetos son desconocidos,porque pueden ser tanto pasados por valor (en caso de que consideremos que una variable que sostiene un objeto es de hecho una referencia al objeto)como pasados por referencia (cuando consideramos que la variable al objeto sostiene al objeto mismo).</target>
        </trans-unit>
        <trans-unit id="8fbaf791a543ee22f0fd296541edf5a1bfa479b1" translate="yes" xml:space="preserve">
          <source>The production ArgumentList : AssignmentExpression is evaluated as follows:</source>
          <target state="translated">La producción ArgumentList:AssignmentExpression se evalúa de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ecee46c34e5a0a1af1170066ea3f9a92c40b9de1" translate="yes" xml:space="preserve">
          <source>The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</source>
          <target state="translated">La producción de MemberExpression:MemberExpression [Expresión]se evalúa de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="e64cfc5706b868b32b799d93138e5cd834b8bce0" translate="yes" xml:space="preserve">
          <source>The section also enumerate cases where argument list has 0 or &amp;gt;1 arguments.</source>
          <target state="translated">La secci&amp;oacute;n tambi&amp;eacute;n enumera casos en los que la lista de argumentos tiene 0 o&amp;gt; 1 argumentos.</target>
        </trans-unit>
        <trans-unit id="dbf3ebd42f5ddf6e8a07546545a97d0d73e8f740" translate="yes" xml:space="preserve">
          <source>The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren't visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller's scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned &amp;mdash; it is shared.</source>
          <target state="translated">La sem&amp;aacute;ntica de la llamada al compartir difiere de la llamada por referencia en que las asignaciones a los argumentos de la funci&amp;oacute;n dentro de la funci&amp;oacute;n no son visibles para la persona que llama (a diferencia de la sem&amp;aacute;ntica de referencia) [cita requerida], por lo que, por ejemplo, si se pas&amp;oacute; una variable, no es posible para simular una asignaci&amp;oacute;n en esa variable en el alcance de la persona que llama. Sin embargo, dado que la funci&amp;oacute;n tiene acceso al mismo objeto que la persona que llama (no se realiza ninguna copia), las mutaciones en esos objetos, si los objetos son mutables, dentro de la funci&amp;oacute;n son visibles para la persona que llama, que puede parecer diferente de la llamada por valor sem&amp;aacute;ntica. Las mutaciones de un objeto mutable dentro de la funci&amp;oacute;n son visibles para la persona que llama porque el objeto no se copia ni se clona, ​​se comparte.</target>
        </trans-unit>
        <trans-unit id="8c4316acc1d74e70023ca752c79e9fc23bbbea3d" translate="yes" xml:space="preserve">
          <source>The terms are only used to describe the &lt;em&gt;behavior&lt;/em&gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn't adequately describe the actual behavior and supplementary info has to be provided</source>
          <target state="translated">Los t&amp;eacute;rminos solo se usan para describir el &lt;em&gt;comportamiento&lt;/em&gt; de un lenguaje, no necesariamente la implementaci&amp;oacute;n subyacente real. Como resultado de esta abstracci&amp;oacute;n, se pierden detalles cr&amp;iacute;ticos que son esenciales para una explicaci&amp;oacute;n decente, lo que inevitablemente conduce a la situaci&amp;oacute;n actual en la que un solo t&amp;eacute;rmino no describe adecuadamente el comportamiento real y se debe proporcionar informaci&amp;oacute;n complementaria</target>
        </trans-unit>
        <trans-unit id="626d24ad73a240837e037855870f41fe70cd5f31" translate="yes" xml:space="preserve">
          <source>The variable doesn't &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It's always pass by value (even when that value is a reference...).</source>
          <target state="translated">La variable no &quot;sostiene&quot; el objeto;sostiene una referencia.Puedes asignar esa referencia a otra variable,y ahora ambas hacen referencia al mismo objeto.Siempre pasa por un valor (incluso cuando ese valor es una referencia...).</target>
        </trans-unit>
        <trans-unit id="dca56569992ce2b50c87910c0d7c7c9858ba2c6f" translate="yes" xml:space="preserve">
          <source>There is no &quot;pass by reference&quot; available in JavaScript.</source>
          <target state="translated">No hay &quot;pasar por referencia&quot; disponible en JavaScript.</target>
        </trans-unit>
        <trans-unit id="361031a3f3abf898ac288ca94af4b04c26e7d902" translate="yes" xml:space="preserve">
          <source>There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn't have a function and just used the equal sign to assign to a new variable.</source>
          <target state="translated">No tiene sentido hacer una distinción entre objetos y primitivos,porque funciona exactamente de la misma manera que si no tuvieras una función y sólo usaras el signo igual para asignarla a una nueva variable.</target>
        </trans-unit>
        <trans-unit id="1aa166014dcdcbcff2f5f9b82565c5b3c2e956bf" translate="yes" xml:space="preserve">
          <source>There's no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.</source>
          <target state="translated">No hay forma de alterar el valor que tiene una variable pasada como parámetro,lo que sería posible si JavaScript soportara pasar por referencia.</target>
        </trans-unit>
        <trans-unit id="010934035b63fc110de9e084961250609ba49e08" translate="yes" xml:space="preserve">
          <source>There's some discussion about the use of the term &quot;pass by reference&quot; in JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;here&lt;/a&gt;, but to answer your question:</source>
          <target state="translated">Aqu&amp;iacute; hay una discusi&amp;oacute;n sobre el uso del t&amp;eacute;rmino &quot;pasar por referencia&quot; en JavaScript, pero para responder a su pregunta:</target>
        </trans-unit>
        <trans-unit id="b3971268996a99a5df86f39832ec5539e7dd9d70" translate="yes" xml:space="preserve">
          <source>These concepts were not originally defined with the intent of describing javascript in particular and so I don't feel compelled to use them when they only add to the confusion.</source>
          <target state="translated">Estos conceptos no se definieron originalmente con la intención de describir a Javascript en particular y por lo tanto no me siento obligado a usarlos cuando sólo contribuyen a la confusión.</target>
        </trans-unit>
        <trans-unit id="e16663c0ae48f1219b8db33d73a88db1512811fc" translate="yes" xml:space="preserve">
          <source>Think of it like this: It's always pass by value. However, the value of an object is not the object itself, but a reference to that object.</source>
          <target state="translated">Piénsalo así:Siempre pasa por el valor.Sin embargo,el valor de un objeto no es el objeto en sí mismo,sino una referencia a ese objeto.</target>
        </trans-unit>
        <trans-unit id="705df426723dfd9a58e61806d528e760b06fe084" translate="yes" xml:space="preserve">
          <source>This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.</source>
          <target state="translated">Esta es una pequeña explicación para pasar por valor y pasar por referencia (JavaScript).En este concepto se habla de pasar la variable por referencia y pasar la variable por referencia.</target>
        </trans-unit>
        <trans-unit id="3f9efc65382f339c71ef4d14543d364c027db24a" translate="yes" xml:space="preserve">
          <source>This produces the output:</source>
          <target state="translated">Esto produce la salida:</target>
        </trans-unit>
        <trans-unit id="a1116d28bfe37e6545e3ebc5bd2c217059edabe0" translate="yes" xml:space="preserve">
          <source>Thus, everything's are passed by reference.</source>
          <target state="translated">Así,todo se pasa por referencia.</target>
        </trans-unit>
        <trans-unit id="3678321f62ae967b6f938900843022091b6a3c1b" translate="yes" xml:space="preserve">
          <source>Thus, properties of Objects are always available as reference.</source>
          <target state="translated">Así,las propiedades de los objetos están siempre disponibles como referencia.</target>
        </trans-unit>
        <trans-unit id="0821fb327f2753fc69a24f9f6c10a0a8791e18c7" translate="yes" xml:space="preserve">
          <source>To answer your question: pointers are passed.</source>
          <target state="translated">Para responder a su pregunta:se aprueban los indicadores.</target>
        </trans-unit>
        <trans-unit id="7bbe358444a139cd8eb2208023bd472900f08800" translate="yes" xml:space="preserve">
          <source>To effectively pass a compound value (like an &lt;code&gt;array&lt;/code&gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</source>
          <target state="translated">Para pasar de manera efectiva un valor compuesto (como una &lt;code&gt;array&lt;/code&gt; ) por value-copy, debe hacer una copia manualmente de &amp;eacute;l, de modo que la referencia pasada no apunte al original. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e1abf81928ceac0fa096e0f4f2795b3ee7f8da32" translate="yes" xml:space="preserve">
          <source>Uh oh.... What has happened. We couldn't change string1 by changing favoriteString... Why?? Because we didn't &lt;em&gt;change&lt;/em&gt; our string &lt;em&gt;object&lt;/em&gt;. All we did was &quot;RE ASSIGN&quot; the favoriteString &lt;em&gt;variable&lt;/em&gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn't assign anything. (Well, not to the &lt;em&gt;variable itself&lt;/em&gt;, ... we did, however, assign the name property to a new string.) Instead, we simply mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or &lt;em&gt;mutate&lt;/em&gt; the string object &lt;em&gt;itself&lt;/em&gt;, we couldn't have, because strings are actually immutable in JavaScript.)</source>
          <target state="translated">Uh oh ... lo que ha pasado. No pudimos cambiar string1 cambiando a favoriteString ... &amp;iquest;Por qu&amp;eacute;? Porque no &lt;em&gt;cambiamos&lt;/em&gt; nuestro &lt;em&gt;objeto de&lt;/em&gt; cadena. Todo lo que hicimos fue &quot;RE ASIGNAR&quot; la &lt;em&gt;variable&lt;/em&gt; favoriteString a una nueva cadena. Esto esencialmente lo desconect&amp;oacute; de la cadena1. En el ejemplo anterior, cuando cambiamos el nombre de nuestro objeto, no asignamos nada. (Bueno, no a la &lt;em&gt;variable en s&amp;iacute;&lt;/em&gt; , ... sin embargo, asignamos la propiedad de nombre a una nueva cadena.) En cambio, simplemente mutamos el objeto que mantiene las conexiones entre las 2 variables y los objetos subyacentes. (Incluso si hubi&amp;eacute;ramos querido modificar o &lt;em&gt;mutar&lt;/em&gt; el objeto de cadena en &lt;em&gt;s&amp;iacute;&lt;/em&gt; , no podr&amp;iacute;amos haberlo hecho, porque las cadenas son realmente inmutables en JavaScript).</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="ad44083b5ca9c555d81d716126062a61d9fc5f75" translate="yes" xml:space="preserve">
          <source>Variables are &lt;em&gt;pointers&lt;/em&gt; to values in memory.</source>
          <target state="translated">Las variables son &lt;em&gt;punteros&lt;/em&gt; a valores en la memoria.</target>
        </trans-unit>
        <trans-unit id="678a462c2bd82f3f082479b480f76e063a36fb4b" translate="yes" xml:space="preserve">
          <source>What we have done is &quot;assignment&quot;... We've assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.</source>
          <target state="translated">Lo que hemos hecho es &quot;asignación&quot;...Hemos asignado 2 objetos vacíos separados a las variables &quot;object1&quot; y &quot;object2&quot;.</target>
        </trans-unit>
        <trans-unit id="84d66e6463f366bb3793d71142052ebf0b3271b4" translate="yes" xml:space="preserve">
          <source>When calling a function, you are passing the content (reference or
value) of the argument variables, not the the variables themselves.</source>
          <target state="translated">Cuando se llama una función,se pasa el contenido (referencia o valor)de las variables de argumento,no las variables propiamente dichas.</target>
        </trans-unit>
        <trans-unit id="b675d8ab55a62fa7342693de178ca61efdefdab7" translate="yes" xml:space="preserve">
          <source>When d=c, in this step &lt;code&gt;d&lt;/code&gt; points to the same location (0x012).</source>
          <target state="translated">Cuando d = c, en este paso, &lt;code&gt;d&lt;/code&gt; apunta a la misma ubicaci&amp;oacute;n (0x012).</target>
        </trans-unit>
        <trans-unit id="6603f9e15352ae782eb9dbf4dc53a8cacea1f46d" translate="yes" xml:space="preserve">
          <source>When we make the assignment &lt;code&gt;b = [4,5,6]&lt;/code&gt;, we are doing absolutely nothing to affect where &lt;code&gt;a&lt;/code&gt; is still referencing (&lt;code&gt;[1,2,3]&lt;/code&gt;). To do that, &lt;code&gt;b&lt;/code&gt; would have to be a pointer to &lt;code&gt;a&lt;/code&gt; rather than a reference to the &lt;code&gt;array&lt;/code&gt; -- but no such capability exists in JS!</source>
          <target state="translated">Cuando hacemos la asignaci&amp;oacute;n &lt;code&gt;b = [4,5,6]&lt;/code&gt; , no estamos haciendo absolutamente nada para afectar a donde &lt;code&gt;a&lt;/code&gt; todav&amp;iacute;a se hace referencia ( &lt;code&gt;[1,2,3]&lt;/code&gt; ). Para hacer eso, &lt;code&gt;b&lt;/code&gt; tendr&amp;iacute;a que ser un puntero a &lt;code&gt;a&lt;/code&gt; &lt;code&gt;array&lt;/code&gt; lugar de una referencia a ella, &amp;iexcl;pero tal capacidad no existe en JS!</target>
        </trans-unit>
        <trans-unit id="13f9dc2555da1b44daf4195c85cac47042d3a3a1" translate="yes" xml:space="preserve">
          <source>When we pass in the argument &lt;code&gt;a&lt;/code&gt;, it assigns a copy of the &lt;code&gt;a&lt;/code&gt; reference to &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are separate references pointing at the same &lt;code&gt;[1,2,3]&lt;/code&gt; value. Now, inside the function, we can use that reference to mutate the value itself (&lt;code&gt;push(4)&lt;/code&gt;). But when we make the assignment &lt;code&gt;x = [4,5,6]&lt;/code&gt;, this is in no way affecting where the initial reference &lt;code&gt;a&lt;/code&gt; is pointing -- still points at the (now modified) &lt;code&gt;[1,2,3,4]&lt;/code&gt; value.</source>
          <target state="translated">Cuando pasamos el argumento &lt;code&gt;a&lt;/code&gt; , asigna una copia de la referencia a a &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; son referencias separadas que apuntan al mismo valor &lt;code&gt;[1,2,3]&lt;/code&gt; . Ahora, dentro de la funci&amp;oacute;n, podemos usar esa referencia para mutar el valor mismo ( &lt;code&gt;push(4)&lt;/code&gt; ). Pero cuando hacemos la asignaci&amp;oacute;n &lt;code&gt;x = [4,5,6]&lt;/code&gt; , esto no afecta de ninguna manera a d&amp;oacute;nde apunta la referencia inicial &lt;code&gt;a&lt;/code&gt; - todav&amp;iacute;a apunta al valor (ahora modificado) &lt;code&gt;[1,2,3,4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc1b4ec703eec5dfe10344c61e1e765e58682a65" translate="yes" xml:space="preserve">
          <source>When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else.</source>
          <target state="translated">Cuando se utiliza esa referencia para manipular su objeto,el objeto exterior se ve así afectado.Sin embargo,si dentro de la función se decide apuntar la referencia a otra cosa,no se afecta el objeto exterior en absoluto,porque todo lo que se hace es redirigir la referencia a otra cosa.</target>
        </trans-unit>
        <trans-unit id="a5f72cf83865e4414b2e92fe68d2f91039221270" translate="yes" xml:space="preserve">
          <source>a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).</source>
          <target state="translated">a se le asigna una memoria (digamos 0x001)y b crea una copia del valor en la memoria (digamos 0x002).</target>
        </trans-unit>
        <trans-unit id="ba35e803347ae1a6fbb922bb822df3c9557c5075" translate="yes" xml:space="preserve">
          <source>a very confusing situation is where you can't realize how your referenced variable changes, let's take a look at a very good example:</source>
          <target state="translated">una situación muy confusa es cuando no puedes darte cuenta de cómo cambia tu variable de referencia,veamos un muy buen ejemplo:</target>
        </trans-unit>
        <trans-unit id="1a91322ba3053b9c0d30aeec04a7ec7d757a54ad" translate="yes" xml:space="preserve">
          <source>and in a more complicated story:</source>
          <target state="translated">y en una historia más complicada:</target>
        </trans-unit>
        <trans-unit id="dbe8beff245d88e0093cd5bdb6c0a20809a330d5" translate="yes" xml:space="preserve">
          <source>applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).</source>
          <target state="translated">se aplica a todos los tipos primitivos de JavaScript (cadena,número,booleano,indefinido y nulo).</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4e4aeb4d95583c62381700ab3cfbd849ddf35b64" translate="yes" xml:space="preserve">
          <source>but we cant do the same thing with the purple arrow, we may want to move 'john' cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...</source>
          <target state="translated">pero no podemos hacer lo mismo con la flecha púrpura,podemos querer mover la celda de 'John' aquí o muchas otras cosas...,así que la flecha púrpura se pegará a su lugar y sólo las flechas típicas que le fueron asignadas se moverán...</target>
        </trans-unit>
        <trans-unit id="e4cf40496f043253f0d64368904b930d9b69c16d" translate="yes" xml:space="preserve">
          <source>every type2-value (green) is a &lt;strong&gt;single square&lt;/strong&gt; while a type1-value (blue) is a &lt;strong&gt;group of them&lt;/strong&gt;:</source>
          <target state="translated">cada tipo2 (verde) es un &lt;strong&gt;solo cuadrado,&lt;/strong&gt; mientras que un tipo1 (azul) es un &lt;strong&gt;grupo de ellos&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="dd74f54fdfe237acc828874dddffdcfc48e8abc5" translate="yes" xml:space="preserve">
          <source>here you are assigning new object or array to old one.you are not changing the value of property 
of old object.so it is pass by value.</source>
          <target state="translated">Aquí se asigna un nuevo objeto o matriz al antiguo.No se cambia el valor de la propiedad del antiguo objeto.</target>
        </trans-unit>
        <trans-unit id="a20f2e836503b1a3b14f37b2c5bd01437f59d8f4" translate="yes" xml:space="preserve">
          <source>here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.</source>
          <target state="translated">Aquí se cambia el valor de una propiedad de un objeto antiguo.No se asigna un nuevo objeto o matriz a uno antiguo.</target>
        </trans-unit>
        <trans-unit id="53ff18bfd84d263fea5d0d0003eebc0c7a27a864" translate="yes" xml:space="preserve">
          <source>if you are changing a property value of an object or array then it is pass by Reference.</source>
          <target state="translated">si se cambia el valor de una propiedad de un objeto o de una matriz,entonces se pasa por Referencia.</target>
        </trans-unit>
        <trans-unit id="3e6856e162be438b0b1b28e9475c58786691c0c2" translate="yes" xml:space="preserve">
          <source>if you are changing value of that Object or array with new Object or Array then it is pass by Value.</source>
          <target state="translated">si estás cambiando el valor de ese objeto o matriz con un nuevo objeto o matriz,entonces se pasa por valor.</target>
        </trans-unit>
        <trans-unit id="37fb1667392900bb5ef5037dd0e0b507e63dc8dd" translate="yes" xml:space="preserve">
          <source>if you imagine memory as below squares which in every one of them just one type2-value can be saved:</source>
          <target state="translated">si te imaginas la memoria como debajo de los cuadrados que en cada uno de ellos sólo se puede guardar un valor de tipo 2:</target>
        </trans-unit>
        <trans-unit id="d4ec615b08c0e036b2bca13e54163fa4149fab8d" translate="yes" xml:space="preserve">
          <source>in javascript we can put values in two layer: &lt;strong&gt;type1&lt;/strong&gt;-&lt;code&gt;objects&lt;/code&gt; and &lt;strong&gt;type2&lt;/strong&gt;-all other types of value such as &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</source>
          <target state="translated">en javascript podemos poner valores en dos capas: &lt;strong&gt;type1&lt;/strong&gt; - &lt;code&gt;objects&lt;/code&gt; y &lt;strong&gt;type2&lt;/strong&gt; -todos los dem&amp;aacute;s tipos de valor como &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="53b0a1b2fadf4e040cdc2155a7340de24aca93cb" translate="yes" xml:space="preserve">
          <source>number</source>
          <target state="translated">number</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="f0f7f39ec7e62249ee81dac2c3f1b3586a4fd52e" translate="yes" xml:space="preserve">
          <source>objects</source>
          <target state="translated">objects</target>
        </trans-unit>
        <trans-unit id="43c608c48ee77ebcf1192df657480116bb88d93b" translate="yes" xml:space="preserve">
          <source>primitive type variable like string,number are always pass as  pass
by value.</source>
          <target state="translated">variables de tipo primitivo como la cadena,los números siempre pasan como valor de paso.</target>
        </trans-unit>
        <trans-unit id="0366c73137f63703a81f4390aa8afe89322b7310" translate="yes" xml:space="preserve">
          <source>sharing what I know of references in JavaScript</source>
          <target state="translated">compartiendo lo que sé de las referencias en JavaScript</target>
        </trans-unit>
        <trans-unit id="340b6603b7ec42319770e6733e4f6bacbc9b29bb" translate="yes" xml:space="preserve">
          <source>so here &lt;strong&gt;references&lt;/strong&gt; can rescue us:</source>
          <target state="translated">as&amp;iacute; que aqu&amp;iacute; las &lt;strong&gt;referencias&lt;/strong&gt; pueden rescatarnos:</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="bffc56aa90003a62e1312aa3131fb673e4b8fa39" translate="yes" xml:space="preserve">
          <source>symbol in &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">s&amp;iacute;mbolo en &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a6bbba542e8dfa1abb5d45893298c0eb2f0d406" translate="yes" xml:space="preserve">
          <source>the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that's not easy at all! :</source>
          <target state="translated">el punto es que si quieres indicar un valor de tipo 2,la dirección es simple pero si quieres hacer lo mismo para el valor de tipo 1 no es nada fácil! :</target>
        </trans-unit>
        <trans-unit id="d5d4cd07616a542891b7ec2d0257b3a24b69856e" translate="yes" xml:space="preserve">
          <source>undefined</source>
          <target state="translated">undefined</target>
        </trans-unit>
        <trans-unit id="c097133877b58bb1a18daa1d045149700ebbbf11" translate="yes" xml:space="preserve">
          <source>well, it's about 'performance' and 'speed' and in the simple word 'memory management' in a programming language.</source>
          <target state="translated">bueno,se trata de &quot;rendimiento&quot; y &quot;velocidad&quot; y en la simple palabra &quot;gestión de la memoria&quot; en un lenguaje de programación.</target>
        </trans-unit>
        <trans-unit id="5ba026f489ec792196a7e8a5a6ac751fc3641db1" translate="yes" xml:space="preserve">
          <source>while the green arrow here is a typical variable, the purple one is an object variable, so &lt;strong&gt;because the green arrow(typical variable) has just one task&lt;/strong&gt; (and that is indicating a typical value) we don't need to separate it's value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...</source>
          <target state="translated">mientras que la flecha verde aqu&amp;iacute; es una variable t&amp;iacute;pica, la p&amp;uacute;rpura es una variable de objeto, por lo que &lt;strong&gt;debido a que la flecha verde (variable t&amp;iacute;pica) tiene solo una tarea&lt;/strong&gt; (y eso indica un valor t&amp;iacute;pico) no necesitamos separar su valor de as&amp;iacute; que movemos la flecha verde con el valor de eso donde quiera que vaya y en todas las tareas, funciones, etc.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
