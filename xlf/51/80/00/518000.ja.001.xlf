<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/518000">
    <body>
      <group id="518000">
        <trans-unit id="1dee29437206aa2b90705d515faaafcb0add50ca" translate="yes" xml:space="preserve">
          <source>&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;Which programming languages are pass by reference?&lt;/a&gt;</source>
          <target state="translated">&amp;mdash; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot;&gt;Brian Bi-&lt;/a&gt; &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot;&gt;参照渡しされるプログラミング言語はどれですか。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07698e10df4dd98b0bf399ab50011ce57e452623" translate="yes" xml:space="preserve">
          <source>(From the article mentioned above.)</source>
          <target state="translated">(上記記事より)</target>
        </trans-unit>
        <trans-unit id="edeb4423fd301ceb5f86fc44d38b40f3c9ba6fa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Return a value of type Reference&lt;/b&gt; whose base value is baseValue and whose referenced name is
  propertyNameString, and whose strict mode flag is strict.</source>
          <target state="translated">基本値がbaseValueであり、参照名がpropertyNameStringであり、strictモードフラグがstrictである&lt;b&gt;Referenceタイプの値を返し&lt;/b&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d0d476f54a71b8ac89e5d06ddffbeccc263797e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TL;DR&lt;/b&gt;: Everythings're passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.</source>
          <target state="translated">&lt;b&gt;TL; DR&lt;/b&gt; ：すべては値で渡されますが、オブジェクトのプロパティは参照であり、オブジェクトの定義は標準で気味悪く欠けています。</target>
        </trans-unit>
        <trans-unit id="5cc31de26a91a7607db07fbc10e5bdca64ddd6b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compound values are always assigned/passed by reference-copy&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;複合値は常に参照コピーによって割り当て/渡されます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b825d8d1882d46055d101f87ec20d9423ddb0d0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function arguments and parameters are not the same thing.  Also, a variable's value is not the variable's object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;関数の引数とパラメーターは同じものではありません。&lt;/em&gt; &lt;em&gt;また、変数の値は変数のオブジェクトではありません（すでにさまざまな人々によって指摘されていますが、明らかに無視されています）。&lt;/em&gt; &lt;em&gt;これらの違いは、適切に理解するために重要です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dec8a494f102cfe95fa805f288c3d04ee0a6b711" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Primitive values are always assigned/passed by value-copy&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;プリミティブ値は常にvalue-copyによって割り当て/渡されます&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="207d1e3b4f674510d97d07b156c4c5ee3a4de294" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because in JavaScript, it doesn't matter whether it's passed by value or by reference or whatever.
What matters is mutation vs assignment of the parameters passed into a function.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScriptでは、値によって渡されるのか、参照によって渡されるのかは関係ありません。&lt;/strong&gt; &lt;strong&gt;重要なのは、関数に渡されるパラメーターの変異と割り当てです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a42287a91a97e2c4e1094a867ae8805599745087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt;:  The function argument's value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object's data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.</source>
          <target state="translated">&lt;strong&gt;呼び出し/参照渡し&lt;/strong&gt; ：関数の引数の値は、対応する関数パラメーターによって直接更新できます。 それが役立つ場合、関数パラメータは引数の有効な「エイリアス」になります。それらは、同じメモリ位置の同じ値を効果的に参照します。 関数の引数がオブジェクト変数の場合、関数のパラメーターは引き続き引数と同じオブジェクトを指すため、オブジェクトのデータを変更する機能は、値渡しの場合と同じです。 ただし、オブジェクト変数の場合、関数パラメーターが完全に異なるオブジェクトに設定されていると、引数も同様に別のオブジェクトを指します。これは、値渡しの場合には発生しません。</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c12cc2e2533791936e57d4b9415ab42ea32e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex&lt;/strong&gt;: When you access a complex type you work on a reference to its value</source>
          <target state="translated">&lt;strong&gt;Complex&lt;/strong&gt; ：複雑な型にアクセスすると、その値への参照で作業します</target>
        </trans-unit>
        <trans-unit id="1301250d5301f648cf05701bd59197e854b822ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;: Variable outside the function which is passed to the function by the caller.</source>
          <target state="translated">&lt;strong&gt;関数の引数&lt;/strong&gt; ：呼び出し元によって関数に渡される関数外の変数。</target>
        </trans-unit>
        <trans-unit id="65492a390eb86ea3356e64d01cfaa27d6c3fab3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function parameter&lt;/strong&gt;:  Variable declared in a function definition, used for referencing variables passed to the function.</source>
          <target state="translated">&lt;strong&gt;関数パラメーター&lt;/strong&gt; ：関数定義で宣言された変数。関数に渡される変数を参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="65a6814d6b676f546b18918b30e471d0b5236d77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Memory location&lt;/strong&gt;:  Where a variable's value is stored.  (The location itself is represented by a number separate from the value stored at the location.)</source>
          <target state="translated">&lt;strong&gt;メモリの場所&lt;/strong&gt; ：変数の値が格納される場所。 （場所自体は、その場所に格納されている値とは別の数値で表されます。）</target>
        </trans-unit>
        <trans-unit id="5996d89441c8d0e61fe5412acbb5b6378fb43e74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object clone/copy&lt;/strong&gt;: A new object is created and the original object's data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.</source>
          <target state="translated">&lt;strong&gt;オブジェクトの複製/コピー&lt;/strong&gt; ：新しいオブジェクトが作成され、元のオブジェクトのデータがコピーされます。 これはディープコピーまたはシャローコピーのどちらでもかまいませんが、ポイントは新しいオブジェクトが作成されることです。 オブジェクトのコピーの作成は、値渡しとは別の概念です。 一部の言語では、クラスオブジェクトと構造体（または同等のもの）を区別し、異なる型の変数を渡すための動作が異なる場合があります。 ただし、JavaScriptは、オブジェクト変数を渡すときに、このようなことを自動的には行いません。 ただし、自動オブジェクトクローンが存在しないことは、参照渡しに変換されません。</target>
        </trans-unit>
        <trans-unit id="fa53139221548e1fd770ad7abe04c1dc6d698150" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object variable&lt;/strong&gt;:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object's actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.</source>
          <target state="translated">&lt;strong&gt;オブジェクト変数&lt;/strong&gt; ：基本的な値が「オブジェクト」自体ではなく、その値がオブジェクトの実際のデータが格納されているメモリ内の別の場所へのポインタ（メモリロケーション値）である変数。 ほとんどの上位世代の言語では、「ポインター」の側面は、さまざまなコンテキストでの自動逆参照によって効果的に隠されます。</target>
        </trans-unit>
        <trans-unit id="d880bbb046dd0fb8ed275862bb6d9eb727b33d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;参照渡し（オブジェクト）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab95d2eb7f10fa0819e1bef83f4bd83e6ae79ba7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value (primitive type)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;値渡し（プリミティブ型）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d87f3236c9b7ff2b627b66d6a54c489872ad459f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass-by-value or Call-by-sharing (for objects)&lt;/strong&gt;:  The function argument's value is COPIED to another memory location which is referenced by the function's parameter symbol (regardless of whether it's on the stack or heap).  In other words, the function parameter received a copy of the passed argument's value... AND (critical) the argument's value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable's value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter's value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument's value IS NEVER UPDATED, so it will continue to point to the &lt;em&gt;same&lt;/em&gt; object throughout and even after the function call (even if its object's data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.</source>
          <target state="translated">&lt;strong&gt;値による受け渡しまたは共有による呼び出し（オブジェクトの場合）&lt;/strong&gt; ：関数の引数の値は、関数のパラメーターシンボルによって参照される別のメモリの場所にコピーされます（スタックにあるかヒープにあるかに関係なく）。 言い換えると、関数パラメーターは渡された引数の値のコピーを受け取りました... AND（クリティカル）引数の値は呼び出し側の関数によって決して更新/変更/変更されていません。 オブジェクト変数の値はオブジェクト自体ではなく、オブジェクトへのポインターであることを覚えておいてください。したがって、オブジェクト変数を値で渡すと、ポインターが関数パラメーター変数にコピーされます。 関数パラメーターの値は、メモリ内のまったく同じオブジェクトを指します。 オブジェクトデータ自体は関数パラメーターを介して直接変更できますが、関数の引数の値は更新されないため、関数の呼び出し中も、関数の呼び出し後も、 &lt;em&gt;同じ&lt;/em&gt;オブジェクトを指し続けます（オブジェクトのデータが変更された場合や、関数パラメーターには、まったく別のオブジェクトが割り当てられます）。 参照されたオブジェクトが関数パラメーター変数を介して更新可能であるという理由だけで、関数引数が参照によって渡されたと結論付けるのは誤りです。</target>
        </trans-unit>
        <trans-unit id="3daa908ef93ef3beddf5ee815280e35804b2ab50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitive variable&lt;/strong&gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable's value IS the actual value represented by the variable's symbol rather than a pointer to another memory location.</source>
          <target state="translated">&lt;strong&gt;プリミティブ変数&lt;/strong&gt; ：その値が実際の値である変数。 この概念でさえ、自動ボクシングとさまざまな言語のオブジェクトのようなコンテキストによって複雑になる可能性がありますが、一般的な考え方は、変数の値は、別のメモリ位置へのポインタではなく、変数のシンボルによって表される実際の値であるということです。</target>
        </trans-unit>
        <trans-unit id="738f561981f804bed95647891f285ca2a07e0ffc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Primitives&lt;/strong&gt;: When you access a primitive type you work directly on its
value</source>
          <target state="translated">&lt;strong&gt;プリミティブ&lt;/strong&gt; ：プリミティブ型にアクセスすると、その値を直接処理します</target>
        </trans-unit>
        <trans-unit id="f1d08a4ffaed6d05dab4d5131e21bf7f0ad7cc25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special case, pass by reference (objects)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;特殊なケース、参照渡し（オブジェクト）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d30d6d093711f7dc4bbd3b5d3e73777eb88a76b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symbol&lt;/strong&gt;:  Text string used to refer to variable (i.e. variable's name).</source>
          <target state="translated">&lt;strong&gt;シンボル&lt;/strong&gt; ：変数（変数名など）を参照するために使用されるテキスト文字列。</target>
        </trans-unit>
        <trans-unit id="dbb628f544b2f5b04bb5df870aacd2b707683b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;:  Particular bits stored in memory and referenced using variable's symbol.</source>
          <target state="translated">&lt;strong&gt;値&lt;/strong&gt; ：特定のビットがメモリに格納され、変数のシンボルを使用して参照されます。</target>
        </trans-unit>
        <trans-unit id="4a4a44d5c5dbc605d366445b9f5e39a3dbd71772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variable&lt;/strong&gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.</source>
          <target state="translated">&lt;strong&gt;変数&lt;/strong&gt; ：メモリ内の特定の場所にある値を参照するシンボルの組み合わせ概念。 この用語は通常、負荷が高すぎるため、詳細を説明するために単独で使用することはできません。</target>
        </trans-unit>
        <trans-unit id="5a8e1fdd316d10b0c0cd59d94a6940772041c1cd" translate="yes" xml:space="preserve">
          <source>A object is automatically passed by reference, without the need to specifically state it</source>
          <target state="translated">オブジェクトは参照によって自動的に渡され、特に指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b440a38266bd3bd8023694ca76f1853cb56c68f1" translate="yes" xml:space="preserve">
          <source>A primitive value passed to a function cannot be modified by the function. A copy is made.</source>
          <target state="translated">関数に渡されたプリミティブ値は、関数によって変更できない。コピーが行われます。</target>
        </trans-unit>
        <trans-unit id="79ce62763f1e30b37f20149148f8548734cf61b5" translate="yes" xml:space="preserve">
          <source>A very detailed explanation about copying, passing and comparing by value and by reference is in &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;this chapter&lt;/a&gt; of the &lt;em&gt;&quot;JavaScript: The Definitive Guide&quot;&lt;/em&gt; book.</source>
          <target state="translated">値と参照によるコピー、受け渡し、比較に関する非常に詳細な説明は、 &lt;em&gt;「JavaScript：The Definitive Guide」の&lt;/em&gt; &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot;&gt;この章&lt;/a&gt;にあり&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9d35a2aa876badcd3c415f65100051e77924dd6" translate="yes" xml:space="preserve">
          <source>Access of Object Properties</source>
          <target state="translated">オブジェクトプロパティのアクセス</target>
        </trans-unit>
        <trans-unit id="3e9807bf09a22721f2ffa94b835d05c65938f14a" translate="yes" xml:space="preserve">
          <source>Again, we pick a favorite.</source>
          <target state="translated">繰り返しになりますが、好きなものを選びます。</target>
        </trans-unit>
        <trans-unit id="988045fdd90b44521a9b2b9c55dfe875b6ad44e6" translate="yes" xml:space="preserve">
          <source>Although it doesn't really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?</source>
          <target state="translated">最後にはどうでもいいことなのですが、引数の受け渡しの規約の正しい表現方法を知りたいです。これに関するセマンティクスはどうあるべきかを定義したJavaScriptの仕様書からの抜粋はありませんか?</target>
        </trans-unit>
        <trans-unit id="96ef530acd2543eafd4ab0cb7e97e8162bcf66fb" translate="yes" xml:space="preserve">
          <source>Always remember that the equals sign (=) means assignment.
Always remember that passing a parameter to a function &lt;em&gt;in JavaScript&lt;/em&gt; also means assignment.
They are the same and the 2 variables are connected in exactly the same way (which is to say they aren't, unless you count that they are assigned to the same object).</source>
          <target state="translated">等号（=）は代入を意味することに注意してください。 &lt;em&gt;JavaScriptで&lt;/em&gt;関数&lt;em&gt;に&lt;/em&gt;パラメーターを渡すことも割り当てを意味することを常に覚えておいてください。 それらは同じであり、2つの変数はまったく同じ方法で接続されています（つまり、同じオブジェクトに割り当てられているとみなさない限り、接続されていません）。</target>
        </trans-unit>
        <trans-unit id="bfdc1eb7888008268dcd1f229efc00ed9fe4071e" translate="yes" xml:space="preserve">
          <source>An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:</source>
          <target state="translated">何かが「参照渡し」であるかどうかを判断する簡単な方法は、「スワップ」関数を書くことができるかどうかです。例えば、C言語では以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="3055a2e0457cb299ca6d433ebcc210c7bab9799e" translate="yes" xml:space="preserve">
          <source>An object outside a function is passed into a function by giving a reference to the outside object.</source>
          <target state="translated">関数の外部にあるオブジェクトは、外部オブジェクトへの参照を与えることで関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="b05bb9226e6abe9287bbf028bf6e5a6bed6624b9" translate="yes" xml:space="preserve">
          <source>An object passed to a function can have its members modified by the function.</source>
          <target state="translated">関数に渡されたオブジェクトは、その関数によってメンバが変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="29e123b648bf0a31ec900d67e265e2a81d689d3d" translate="yes" xml:space="preserve">
          <source>Array and Object is passed as  pass by reference or  pass by value based on these two condition.</source>
          <target state="translated">ArrayとObjectは、この2つの条件に基づいて参照渡しか値渡しかで渡されます。</target>
        </trans-unit>
        <trans-unit id="7628591e37cbe88cf6fb309ba297bb58229eacac" translate="yes" xml:space="preserve">
          <source>As a final example, consider why a common attempt to clear an array doesn't work as expected.</source>
          <target state="translated">最後の例として、一般的な配列をクリアしようとしても、なぜ期待したように動作しないのかを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="178ee3db1a483706ed36d79f599e1a13d33df86f" translate="yes" xml:space="preserve">
          <source>Before we leave the topic of
  manipulating objects and arrays by
  reference, we need to clear up a point
  of nomenclature.</source>
          <target state="translated">参照によるオブジェクトや配列の操作の話題から離れる前に、命名法のポイントをクリアしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="f8884a4d2e00d4a1e326a98a062754846001f9b2" translate="yes" xml:space="preserve">
          <source>Both our favoriteString and string1 variables are assigned to 'Hello world'. Now, what if we want to change our favoriteString??? What will happen???</source>
          <target state="translated">favoriteStringもstring1も「Hello world」に代入されています。では、favoriteStringを変更するとどうなるでしょうか?どうなるでしょうか?</target>
        </trans-unit>
        <trans-unit id="aa133f04e687ffaadb65bfc4786e9aafccdad56e" translate="yes" xml:space="preserve">
          <source>But both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are separate references to the same shared value &lt;code&gt;[1,2,3]&lt;/code&gt;, which is a compound value. It's important to note that neither &lt;code&gt;c&lt;/code&gt; nor &lt;code&gt;d&lt;/code&gt; more &quot;owns&quot; the &lt;code&gt;[1,2,3]&lt;/code&gt; value -- both are just equal peer references to the value. So, when using either reference to modify (&lt;code&gt;.push(4)&lt;/code&gt;) the actual shared &lt;code&gt;array&lt;/code&gt; value itself, it's affecting just the one shared value, and both references will reference the newly modified value &lt;code&gt;[1,2,3,4]&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;d&lt;/code&gt; はどちらも、複合値である同じ共有値 &lt;code&gt;[1,2,3]&lt;/code&gt; への個別の参照です。 &lt;code&gt;c&lt;/code&gt; も &lt;code&gt;d&lt;/code&gt; も &lt;code&gt;[1,2,3]&lt;/code&gt; の値を「所有」していないことに注意することが重要です。どちらも値への同等のピア参照にすぎません。 したがって、いずれかの参照を使用して実際の共有 &lt;code&gt;array&lt;/code&gt; 値自体を変更（ &lt;code&gt;.push(4)&lt;/code&gt; ） すると 、1つの共有値のみに影響し、両方の参照は新しく変更された値 &lt;code&gt;[1,2,3,4]&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="296985a800b1e8c9380cebd23dfbc86e71426942" translate="yes" xml:space="preserve">
          <source>Call CheckObjectCoercible(baseValue).</source>
          <target state="translated">CheckObjectCoercible(baseValue)を呼び出します。</target>
        </trans-unit>
        <trans-unit id="393aa90af622b95d2fecad8fb5a88f507b3e5d67" translate="yes" xml:space="preserve">
          <source>Changing the value of any changes value for both the variable.</source>
          <target state="translated">任意の値を変更すると、両方の変数の値が変更されます。</target>
        </trans-unit>
        <trans-unit id="e68569b88f0d63d426d55a5ad6eb50201341e31f" translate="yes" xml:space="preserve">
          <source>Compound value (object, array, etc) that can be passed by reference-copy</source>
          <target state="translated">参照コピーで渡せる複合値(オブジェクト、配列など)</target>
        </trans-unit>
        <trans-unit id="26b600a5d56d8944d8651beec06ae0642c20e289" translate="yes" xml:space="preserve">
          <source>Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.</source>
          <target state="translated">引数と変数オブジェクトは、関数呼び出しの最初に作成された実行コンテキストの間に作成されたオブジェクトであると考えてください-そして、関数に渡された実際の valuereference は、この引数+変数オブジェクトに格納されるだけです。</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="5cecf4a03ec84caeeda78029a5bd713522ec8fe8" translate="yes" xml:space="preserve">
          <source>Construction of Argument Lists</source>
          <target state="translated">引数リストの構築</target>
        </trans-unit>
        <trans-unit id="635aa588bea9df239881e622d2cd3adbad8bf3c9" translate="yes" xml:space="preserve">
          <source>Definition of &quot;Object&quot;</source>
          <target state="translated">&quot;オブジェクト &quot;の定義</target>
        </trans-unit>
        <trans-unit id="e9656fda095be85a55c47e88f0f2142837377331" translate="yes" xml:space="preserve">
          <source>E.g.:</source>
          <target state="translated">E.g.:</target>
        </trans-unit>
        <trans-unit id="e8a531332b5e0c2dac36ce0017c63f03c75815b9" translate="yes" xml:space="preserve">
          <source>Every time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.</source>
          <target state="translated">関数に変数を渡すたびに、イコール(=)記号を使った場合と同じように、パラメータ変数の名前に「代入」していることになります。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="83b1fe6393f9ea04f7c6ef0ebceb29757afe9a44" translate="yes" xml:space="preserve">
          <source>First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.</source>
          <target state="translated">まず第一に、抽象度のレベルが複数あり、誰もが把握しているわけではないようです。第4世代や第5世代の言語で学んできた新しいプログラマーは、アセンブリやC言語のプログラマーに馴染みのある概念を、ポインターからポインターへのポインターからポインターへのポインターに惑わされずに理解するのが難しいかもしれません。参照渡しとは、単に関数のパラメータ変数を使って参照されたオブジェクトを変更できることを意味するのではありません。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="01bf4a9057daf1172b230a29ebe7eb0911eb8d6d" translate="yes" xml:space="preserve">
          <source>For programming language lawyers, I've went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;asking&lt;/a&gt; it on the ECMAScript mailing list.</source>
          <target state="translated">プログラミング言語の弁護士のために、私はECMAScript 5.1の以下のセクション（最新版より読みやすい）を読み、ECMAScriptメーリングリストで&lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot;&gt;質問を&lt;/a&gt;しました。</target>
        </trans-unit>
        <trans-unit id="bd46cdb9b904080183e993ad3943a7303f85bd9f" translate="yes" xml:space="preserve">
          <source>Functions are objects</source>
          <target state="translated">関数はオブジェクト</target>
        </trans-unit>
        <trans-unit id="2fb8e5522eb18d1143e0bd9cb31d216fa77b5c59" translate="yes" xml:space="preserve">
          <source>Here is a rebuttal to this:</source>
          <target state="translated">これに対する反論です。</target>
        </trans-unit>
        <trans-unit id="47be461e851afeca8344b89d76c09b76e3e854ed" translate="yes" xml:space="preserve">
          <source>Here is an example, passing a number (a primitive type)</source>
          <target state="translated">ここでは、数値(プリミティブ型)を渡す例を示します。</target>
        </trans-unit>
        <trans-unit id="6d1956753d691a97c45c137388c4df02dd75b9c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;obj&lt;/code&gt; acts as a wrapper for the scalar primitive property &lt;code&gt;a&lt;/code&gt;. When passed to &lt;code&gt;foo(..)&lt;/code&gt;, a copy of the &lt;code&gt;obj&lt;/code&gt; reference is passed in and set to the &lt;code&gt;wrapper&lt;/code&gt;parameter. We now can use the &lt;code&gt;wrapper&lt;/code&gt; reference to access the shared object, and update its property. After the function finishes, &lt;code&gt;obj.a&lt;/code&gt; will see the updated value &lt;code&gt;42&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;obj&lt;/code&gt; はスカラープリミティブプロパティ &lt;code&gt;a&lt;/code&gt; のラッパーとして機能します。 &lt;code&gt;foo(..)&lt;/code&gt; に渡されると、 &lt;code&gt;obj&lt;/code&gt; 参照のコピーが渡され、 &lt;code&gt;wrapper&lt;/code&gt; パラメーターに設定されます。 これで、 &lt;code&gt;wrapper&lt;/code&gt; 参照を使用して共有オブジェクトにアクセスし、そのプロパティを更新できます。 関数が終了すると、 &lt;code&gt;obj.a&lt;/code&gt; には更新された値 &lt;code&gt;42&lt;/code&gt; が表示されます。</target>
        </trans-unit>
        <trans-unit id="05dc205598b6fae1df14251d0f1b665f0352c482" translate="yes" xml:space="preserve">
          <source>Here, we mean
  simply that a reference to an object
  or array -- not the object itself --
  is passed to a function. A function
  can use the reference to modify
  properties of the object or elements
  of the array. But if the function
  overwrites the reference with a
  reference to a new object or array,
  that modification is not visible
  outside of the function.</source>
          <target state="translated">ここでは,単にオブジェクトや配列への参照(オブジェクト自体ではなく)が関数に渡されることを意味しています.関数は、オブジェクトや配列の要素のプロパティを変更するために参照を使用することができます。しかし、関数が参照を新しいオブジェクトや配列への参照で上書きした場合、その変更は関数の外では見えません。</target>
        </trans-unit>
        <trans-unit id="ec613745ca6fb8018d61844fbac16fd497f35e96" translate="yes" xml:space="preserve">
          <source>I have found the &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;extend method&lt;/a&gt; of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.js library&lt;/a&gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.</source>
          <target state="translated">&lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;Underscore.jsライブラリーの&lt;/a&gt; &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot;&gt;拡張メソッド&lt;/a&gt;は、オブジェクトを変更または完全に置き換えることができるパラメーターとして渡す場合に非常に便利です。</target>
        </trans-unit>
        <trans-unit id="da00583f56bed3adae6b3854cb9669d9ef039b2e" translate="yes" xml:space="preserve">
          <source>I would say it is pass-by-copy -</source>
          <target state="translated">私はそれがパスバイコピーであると言うだろう-。</target>
        </trans-unit>
        <trans-unit id="99152f78f2285e9f5178a28c6ae891d22918905b" translate="yes" xml:space="preserve">
          <source>I've read through these answers multiple times, but didn't REALLY get it until I learned about the technical definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;&quot;Call by sharing&quot;&lt;/a&gt; as termed by Barbara Liskov</source>
          <target state="translated">私はこれらの回答を何度も読みましたが、Barbara Liskovによって呼ばれた&lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;「共有して呼び出す」&lt;/a&gt;の技術的な定義について学ぶまで、実際には理解しませんでした</target>
        </trans-unit>
        <trans-unit id="668d70912c4017d9abe459009e674ca09138a746" translate="yes" xml:space="preserve">
          <source>I.e. effectively primitive types are passed by value, and complex types are passed by reference.</source>
          <target state="translated">つまり、事実上のプリミティブ型は値で渡され、複雑な型は参照で渡されます。</target>
        </trans-unit>
        <trans-unit id="0ec6ec8507ceaa91f883d8986d51cbca5f8b1a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj1&lt;/code&gt; was not a reference at all, then changing &lt;code&gt;obj1.item&lt;/code&gt; would have no effect on the &lt;code&gt;obj1&lt;/code&gt; outside of the function.</source>
          <target state="translated">&lt;code&gt;obj1&lt;/code&gt; がまったく参照でなかった場合、 &lt;code&gt;obj1.item&lt;/code&gt; を変更しても、関数外の &lt;code&gt;obj1&lt;/code&gt; には影響がありません。</target>
        </trans-unit>
        <trans-unit id="59dbe46a8ab60f48cf2577d1714a38c220edd92d" translate="yes" xml:space="preserve">
          <source>If the argument was a proper reference, then everything would have changed. &lt;code&gt;num&lt;/code&gt; would be &lt;code&gt;100&lt;/code&gt;, and &lt;code&gt;obj2.item&lt;/code&gt; would read &lt;code&gt;&quot;changed&quot;&lt;/code&gt;.</source>
          <target state="translated">引数が適切な参照であった場合、すべてが変更されたはずです。 &lt;code&gt;num&lt;/code&gt; は &lt;code&gt;100&lt;/code&gt; になり、 &lt;code&gt;obj2.item&lt;/code&gt; は &lt;code&gt;&quot;changed&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="8184ee6c0e0f41f78f07ffde38ac0df94ff1ef63" translate="yes" xml:space="preserve">
          <source>If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let
  strict be false.</source>
          <target state="translated">評価される構文生産が strict モードのコードに含まれている場合、strict を true にし、そうでない場合は strict を false にする。</target>
        </trans-unit>
        <trans-unit id="0514b00b4153ffccc1fdf8db144a3bb4f96beb69" translate="yes" xml:space="preserve">
          <source>If you can't do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.</source>
          <target state="translated">JavaScriptでそれに相当することができないのであれば、「参照によるパス」ではありません。</target>
        </trans-unit>
        <trans-unit id="ed437ed8c9b163811c8c45a0df65ee0cfa2b2119" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;strong&gt;objects&lt;/strong&gt; are stored as references:</source>
          <target state="translated">JavaScriptでは、 &lt;strong&gt;オブジェクト&lt;/strong&gt;は参照として保存されます。</target>
        </trans-unit>
        <trans-unit id="4a244292f7a66631a95bd0016a42e5a3d8a6fdee" translate="yes" xml:space="preserve">
          <source>In JavaScript, the type of the value &lt;em&gt;solely&lt;/em&gt; controls whether that value will be assigned by &lt;strong&gt;value-copy&lt;/strong&gt; or by &lt;strong&gt;reference-copy&lt;/strong&gt;.</source>
          <target state="translated">JavaScriptでは、値のタイプは、その値が&lt;strong&gt;value-copy&lt;/strong&gt;によって割り当てられるか&lt;strong&gt;reference-copy&lt;/strong&gt;によって割り当てられるかを&lt;em&gt;単独で&lt;/em&gt;制御し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf140191af1dcec987a4dde5edb6fb8a16e09a25" translate="yes" xml:space="preserve">
          <source>In a low level language, if you want to pass a variable by reference you have to use a specific syntax in the creation of the function:</source>
          <target state="translated">低レベルの言語では、変数を参照で渡したい場合は、関数の作成時に特定の構文を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="81c7785c18e39819bdc6bf53496b0a9a6239d0fc" translate="yes" xml:space="preserve">
          <source>In both alerts you will find the value to be undefined.</source>
          <target state="translated">どちらのアラートでも、値が未定義であることがわかります。</target>
        </trans-unit>
        <trans-unit id="35606096aee27d974b3090d3e8e5ae1f3bda2fd4" translate="yes" xml:space="preserve">
          <source>In my book that's called passing by reference.</source>
          <target state="translated">私の本の中では「参考文献通過」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="3f390d1963a58a5cc587e0e6330cf78dff59fc86" translate="yes" xml:space="preserve">
          <source>In practical terms, this means that if you change the parameter itself (as with &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt;), that won't affect the item that was fed into the parameter. But if you change the &lt;strong&gt;INTERNALS&lt;/strong&gt; of the parameter, that will propagate back up (as with &lt;code&gt;obj1&lt;/code&gt;).</source>
          <target state="translated">実際には、これは、パラメーター自体を変更した場合（ &lt;code&gt;num&lt;/code&gt; および &lt;code&gt;obj2&lt;/code&gt; のように ）、パラメーターに供給されたアイテムには影響しないことを意味します。 ただし、パラメーターの&lt;strong&gt;INTERNALS&lt;/strong&gt;を変更すると、それは（ &lt;code&gt;obj1&lt;/code&gt; の場合と同様に）元に戻ります。</target>
        </trans-unit>
        <trans-unit id="b57ba2b5cb9f82c19123db765fac17e24d1951eb" translate="yes" xml:space="preserve">
          <source>In the above snippet, because &lt;code&gt;2&lt;/code&gt; is a scalar primitive, &lt;code&gt;a&lt;/code&gt; holds one initial copy of that value, and &lt;code&gt;b&lt;/code&gt; is assigned another copy of the value. When changing &lt;code&gt;b&lt;/code&gt;, you are in no way changing the value in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">上記のスニペットでは、 &lt;code&gt;2&lt;/code&gt; はスカラープリミティブで &lt;code&gt;a&lt;/code&gt; ため、 &lt;code&gt;b&lt;/code&gt; はその値の1つの初期コピーを保持し、 bは値の別のコピーを割り当てられます。 &lt;code&gt;b&lt;/code&gt; を変更する場合、 &lt;code&gt;a&lt;/code&gt; の値を変更することは決してありません。</target>
        </trans-unit>
        <trans-unit id="9be98568917515ecc47f6e69cddc320618b40a6f" translate="yes" xml:space="preserve">
          <source>Inside the function, parameter variables, &lt;code&gt;inVar1&lt;/code&gt; and &lt;code&gt;inVar2&lt;/code&gt;, receive the contents being passed.</source>
          <target state="translated">関数内では、パラメーター変数 &lt;code&gt;inVar1&lt;/code&gt; および &lt;code&gt;inVar2&lt;/code&gt; が 、渡されるコンテンツを受け取ります。</target>
        </trans-unit>
        <trans-unit id="eb0aded998f21b511a6bf2ba99f8f35d22c1fb84" translate="yes" xml:space="preserve">
          <source>Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is &lt;em&gt;itself&lt;/em&gt; a reference.
Technically, this is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;call-by-sharing&lt;/a&gt;.</source>
          <target state="translated">代わりに、渡されたアイテムが値によって渡される状況です。 ただし、値で渡されるアイテム&lt;em&gt;自体&lt;/em&gt;は参照です。 技術的には、これは&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;共有呼び出し&lt;/a&gt;と呼ばれます 。</target>
        </trans-unit>
        <trans-unit id="f7d302320d7430fecc028a90dc07690d841f6022" translate="yes" xml:space="preserve">
          <source>Is JavaScript a pass-by-reference or pass-by-value language</source>
          <target state="translated">JavaScript は参照渡し型、あるいは値渡し型の言語です。</target>
        </trans-unit>
        <trans-unit id="762dca873ea18a90a6df0ccb480c5023409ab8ee" translate="yes" xml:space="preserve">
          <source>It is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;effort&lt;/a&gt; to understand.</source>
          <target state="translated">5.1版では、「オブジェクトはプロパティのコレクション」と定義されています。 したがって、オブジェクトの値はコレクションであると推測できますが、コレクションの値は仕様で十分に定義されておらず、理解するには少し&lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;労力&lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="986429e47688846136b52b4cd304e16867c4438c" translate="yes" xml:space="preserve">
          <source>It is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they're only used to describe the behavior of the delete, the typeof, and the assignment operators.</source>
          <target state="translated">8.7項「参照指定型」で説明されていますが、参照はこの言語では実在の型ではなく、delete、typeof、代入演算子の動作を記述するためにのみ使用されています。</target>
        </trans-unit>
        <trans-unit id="fc2fc8bac54ed799049c59646ec8689ad7f219e2" translate="yes" xml:space="preserve">
          <source>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its &lt;em&gt;members&lt;/em&gt;, those changes persist outside of the function.  This makes it &lt;em&gt;look&lt;/em&gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.</source>
          <target state="translated">これは常に値渡しですが、オブジェクトの場合、変数の値は参照です。 このため、オブジェクトを渡してその&lt;em&gt;メンバー&lt;/em&gt;を変更すると、それらの変更は関数の外部で保持されます。 これにより、参照渡しのようになり&lt;em&gt;ます&lt;/em&gt; 。 しかし、実際にオブジェクト変数の値を変更すると、変更が持続しないことがわかり、値によって実際に渡されることが証明されます。</target>
        </trans-unit>
        <trans-unit id="89a28927b7d2922705fe9300b7e6edf22dfdb59e" translate="yes" xml:space="preserve">
          <source>It's interesting in JavaScript. Consider this example:</source>
          <target state="translated">JavaScriptでは面白いですね。この例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a58c0376442784131cce6ed16ca6889fa180a199" translate="yes" xml:space="preserve">
          <source>It's tempting to think that &lt;em&gt;primitives&lt;/em&gt; are enforced by special rules while &lt;em&gt;objects&lt;/em&gt; are not, but primitives are simply the end of the pointer chain.</source>
          <target state="translated">&lt;em&gt;オブジェクト&lt;/em&gt;がそうでない間、プリミティブは特別なルールによって強制されると考えるのは魅力的&lt;em&gt;です&lt;/em&gt;が、プリミティブは単にポインタチェーンの終わりです。</target>
        </trans-unit>
        <trans-unit id="0f6e466f49c26929af238bc6449efa0b8dbf2534" translate="yes" xml:space="preserve">
          <source>It's time to throw out everything you know about pass by value / reference.</source>
          <target state="translated">値の参照によるパスについて知っていることをすべて捨てる時が来ました。</target>
        </trans-unit>
        <trans-unit id="c1ad2e0efeecec9224ee8d6ce3fbe2b458a354fc" translate="yes" xml:space="preserve">
          <source>JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object's data via the function parameter is synonymous to &quot;pass-by-value&quot;.</source>
          <target state="translated">JavaScriptは参照によるパスバイバリューを行いません。よく読んでみると、すべての反対意見は値渡しの意味を誤解しており、関数パラメータを介してオブジェクトのデータを更新する機能は「値渡し」と同義であると誤って結論づけていることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="d2d80fc6a6ff698bf0fd9cfa17926536bf0021d5" translate="yes" xml:space="preserve">
          <source>JavaScript is always &lt;em&gt;pass-by-value&lt;/em&gt;; everything is of value type.</source>
          <target state="translated">JavaScriptは常に&lt;em&gt;値渡しです&lt;/em&gt; 。 すべてが値型です。</target>
        </trans-unit>
        <trans-unit id="d61aca1d96d43376df88c4a107691b9524026ab9" translate="yes" xml:space="preserve">
          <source>JavaScript passes primitive types by value and object types by reference</source>
          <target state="translated">JavaScript はプリミティブ型を値で、オブジェクト型を参照で渡します。</target>
        </trans-unit>
        <trans-unit id="821543b87e4b4527bdc1a22fea2a59bd6cf89783" translate="yes" xml:space="preserve">
          <source>Javascript is a high level language that does this conversion for you. 
So, although objects are passed by reference, the language converts the reference parameter to the value. You don't need to use &lt;code&gt;&amp;amp;&lt;/code&gt;, on the function definition, to pass it by reference, neither &lt;code&gt;*&lt;/code&gt;, on the function body, to convert the reference to the value, JS does it for you.</source>
          <target state="translated">Javascriptは、この変換を行う高水準言語です。 したがって、オブジェクトは参照によって渡されますが、言語は参照パラメーターを値に変換します。 関数定義で &lt;code&gt;&amp;amp;&lt;/code&gt; を使用する必要はありません。参照で渡すことも、関数本体で &lt;code&gt;*&lt;/code&gt; を使用することも、参照を値に変換することもJSが行います。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">詳細はこちら</target>
        </trans-unit>
        <trans-unit id="e2890eaeaae54ae8213119b094d6eac3b0d0f34d" translate="yes" xml:space="preserve">
          <source>Let arg be GetValue(ref).</source>
          <target state="translated">argをGetValue(ref)とします。</target>
        </trans-unit>
        <trans-unit id="d5b52edd936f17bee3970c4c4428d8bdb2114974" translate="yes" xml:space="preserve">
          <source>Let baseReference be the result of evaluating MemberExpression.</source>
          <target state="translated">MemberExpression の評価結果を baseReference とします。</target>
        </trans-unit>
        <trans-unit id="5793a1bc1d3ece9a28dfc1f7df2511a7f09c3cea" translate="yes" xml:space="preserve">
          <source>Let baseValue be GetValue(baseReference).</source>
          <target state="translated">baseValueをGetValue(baseReference)とします。</target>
        </trans-unit>
        <trans-unit id="0fbb0a339d88c497bca6b7e0e0802f2e1a9e810f" translate="yes" xml:space="preserve">
          <source>Let propertyNameReference be the result of evaluating Expression.</source>
          <target state="translated">式を評価した結果を propertyNameReference とします。</target>
        </trans-unit>
        <trans-unit id="e26b41e64cfc85d8131bd89ab1968cf9b539bc12" translate="yes" xml:space="preserve">
          <source>Let propertyNameString be ToString(propertyNameValue).</source>
          <target state="translated">propertyNameStringをToString(propertyNameValue)とします。</target>
        </trans-unit>
        <trans-unit id="d27739e60a7d1d0ee771b1f518f987ee71282c40" translate="yes" xml:space="preserve">
          <source>Let propertyNameValue be GetValue(propertyNameReference).</source>
          <target state="translated">propertyNameValueをGetValue(propertyNameReference)とします。</target>
        </trans-unit>
        <trans-unit id="765c825fb8ce47d020ac3dcc136c15f73cbaa9d1" translate="yes" xml:space="preserve">
          <source>Let ref be the result of evaluating AssignmentExpression.</source>
          <target state="translated">refをAssignmentExpressionの評価結果とします。</target>
        </trans-unit>
        <trans-unit id="ba443140669d7febc24e1df988b59f67bf1999bc" translate="yes" xml:space="preserve">
          <source>My simple way to understand this...</source>
          <target state="translated">私の簡単な理解方法は</target>
        </trans-unit>
        <trans-unit id="41e399d344b8bb63a9437372496bb38b9ea65720" translate="yes" xml:space="preserve">
          <source>My two cents... This is the way I understand it. (Feel free to correct me if I'm wrong)</source>
          <target state="translated">私の2セントは...これが私の理解している方法です。(間違っていたら遠慮なく訂正してください)</target>
        </trans-unit>
        <trans-unit id="cc50c81892c92e84bb1ae3f1a86483bee39914a6" translate="yes" xml:space="preserve">
          <source>Next, for whatever reason, we decide that we like object 2 better. So, we simply do a little re-assignment.</source>
          <target state="translated">次に、何らかの理由で、オブジェクト2の方が好きだと判断します。そこで、ちょっとした再配置をします。</target>
        </trans-unit>
        <trans-unit id="5983d2311d0216c94667916653cda7009208c7ff" translate="yes" xml:space="preserve">
          <source>Nothing happened to object1 or to object2. We haven't changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.</source>
          <target state="translated">object1にもobject2にも何も起こりませんでした。データも全く変更していません。お気に入りのオブジェクトが何であるかを再設定しただけです。ここで重要なのは、object2とfavoriteObjectはどちらも同じオブジェクトに代入されているということです。そのオブジェクトは、どちらかの変数を使って変更することができます。</target>
        </trans-unit>
        <trans-unit id="b0ed35c065098b7007966c00ae087554253b51c5" translate="yes" xml:space="preserve">
          <source>Now, let's say that we like object1 better... So, we &quot;assign&quot; a new variable.</source>
          <target state="translated">さて、object1の方が好きだとしましょう...そこで、新しい変数を「代入」します。</target>
        </trans-unit>
        <trans-unit id="fefaeda9e706a96b72c3a91f6d46d3d47c7c5900" translate="yes" xml:space="preserve">
          <source>Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you simply assigned using the equal (=) sign.</source>
          <target state="translated">さて、関数とパラメータの渡し方についてですが...。関数を呼び出してパラメータを渡す場合、基本的には新しい変数に「代入」することになりますが、イコール(=)記号を使って代入する場合と全く同じように動作します。</target>
        </trans-unit>
        <trans-unit id="b357112211b094b3237788d525b078423b089167" translate="yes" xml:space="preserve">
          <source>Now, people like to bicker endlessly about whether &quot;pass by reference&quot;
  is the correct way to describe what Java et al. actually do. The point
  is this:</source>
          <target state="translated">さて、人々は「参照によるパス」がJavaなどが実際に行っていることを記述するのに正しい方法であるかどうかについて、延々と議論するのが好きです。ポイントはこうです。</target>
        </trans-unit>
        <trans-unit id="a7538e8091867206be4163070d38a8f2f6e2fc36" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function</source>
          <target state="translated">さて、同じことをしていますが、関数を使って</target>
        </trans-unit>
        <trans-unit id="54f947ec6644ed78ef13a3901e8e53b29b1eae30" translate="yes" xml:space="preserve">
          <source>Now, the same thing, but with a function call</source>
          <target state="translated">さて、同じことをしていますが、関数呼び出しで</target>
        </trans-unit>
        <trans-unit id="85abe287e946ffe23eec095f98389cf0bb761865" translate="yes" xml:space="preserve">
          <source>OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn't matter whether something is passed by reference or by value... What matters is assignment vs mutation.</source>
          <target state="translated">この記事を最後まで読んでいただければ、JavaScriptの関数呼び出しがどのように機能するのか、理解が深まったのではないでしょうか。何かが参照によって渡されるか、値によって渡されるかは問題ではありません...重要なのは、代入と突然変異です。</target>
        </trans-unit>
        <trans-unit id="49aff953ef64c0bfd256e94df786773f165a1a31" translate="yes" xml:space="preserve">
          <source>OK, let me do my best to explain what I mean. Let's say you have a few objects.</source>
          <target state="translated">OK、頑張って説明させてください。例えば、いくつかの物を持っているとします。</target>
        </trans-unit>
        <trans-unit id="d3ac732c421aaa382ba2a7df3b9370ee3d46965c" translate="yes" xml:space="preserve">
          <source>OK, now let&amp;rsquo;s give a few examples using objects instead... first, without the function.</source>
          <target state="translated">では、代わりにオブジェクトを使用した例をいくつか挙げましょう...まず、関数なしで。</target>
        </trans-unit>
        <trans-unit id="55f468caaf302476af028732ffb89566f3834bf7" translate="yes" xml:space="preserve">
          <source>OK, now let's look at primitives like strings for example</source>
          <target state="translated">では、文字列のようなプリミティブを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ed4f6a94ec208043cd9b8120122b92570d99ac3f" translate="yes" xml:space="preserve">
          <source>Objects are passed by reference (the reference is passed by value).</source>
          <target state="translated">オブジェクトは参照で渡されます(参照は値で渡されます)。</target>
        </trans-unit>
        <trans-unit id="a0023dbe18ebfeae7656c8332857dde47f6a7acc" translate="yes" xml:space="preserve">
          <source>Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an &lt;em&gt;object&lt;/em&gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are &lt;em&gt;primitives&lt;/em&gt;.</source>
          <target state="translated">オブジェクトは値であり、オブジェクトのメンバー関数は値自体です（関数はJavaScriptのファーストクラスオブジェクトであることを忘れないでください）。 また、JavaScriptのすべてが&lt;em&gt;オブジェクト&lt;/em&gt;であるという概念に関しては、 これは間違っています。 文字列、記号、数値、ブール値、null、未定義は&lt;em&gt;プリミティブ&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="7c473076e20653740c581b65a9c148582980e1f2" translate="yes" xml:space="preserve">
          <source>On Reference</source>
          <target state="translated">参照</target>
        </trans-unit>
        <trans-unit id="24023d41b24981459776a8deb45dffaf544e073a" translate="yes" xml:space="preserve">
          <source>On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:</source>
          <target state="translated">場合によっては、ベース・プロトタイプから継承されたいくつかのメンバ関数やプロパティを利用することができますが、これは便宜上のものにすぎません。これは、それ自体がオブジェクトであることを意味するものではありません。参考までに以下を試してみてください。</target>
        </trans-unit>
        <trans-unit id="4d12f26544314335beb7af690a37352634d31faf" translate="yes" xml:space="preserve">
          <source>One more example:</source>
          <target state="translated">もう一つの例。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="61d70ce6c0868b0a4084920bfa36265cd2924428" translate="yes" xml:space="preserve">
          <source>PHP does something similar since version 5: all objects are passed by reference, but all primitives &lt;em&gt;may&lt;/em&gt; be passed by reference, if preceded by an ampersand (&amp;amp;). Otherwise primitives are passed by value.</source>
          <target state="translated">PHPはバージョン5以降同様のことを行います。すべてのオブジェクトは参照によって渡されますが、アンパサンド（＆）が前に付いている場合、すべてのプリミティブ&lt;em&gt;は&lt;/em&gt;参照によって渡されます。 それ以外の場合、プリミティブは値で渡されます。</target>
        </trans-unit>
        <trans-unit id="4aa6714b9431fbeb4050db107726bf42359cbd64" translate="yes" xml:space="preserve">
          <source>Passing an object does not copy the object.</source>
          <target state="translated">オブジェクトを渡してもオブジェクトはコピーされません。</target>
        </trans-unit>
        <trans-unit id="177116d45ea2e23710bb7ea3a718654efa24f9bc" translate="yes" xml:space="preserve">
          <source>Passing arguments to a function in JavaScript is analogous to passing
parameters by pointer value in C:</source>
          <target state="translated">JavaScriptで関数に引数を渡すのは、C言語でポインタの値でパラメータを渡すのと似ています。</target>
        </trans-unit>
        <trans-unit id="01f2294132d2e2f2b4566ede86b13262366d51fb" translate="yes" xml:space="preserve">
          <source>Primitives (number, Boolean, etc.) are passed by value.</source>
          <target state="translated">プリミティブ(数値、ブール値など)は値で渡されます。</target>
        </trans-unit>
        <trans-unit id="1fbe034f18e45d911f35c38befd6ffef1237ff9d" translate="yes" xml:space="preserve">
          <source>Primitives are passed by value and objects are passed by reference. This is quite different from other languages like C, Visual Basic, or Delphi. I can't say how they handle objects and primitives exactly, but I know of Visual Basic and Delphi that it can (and should) be specified.</source>
          <target state="translated">プリミティブは値で渡され、オブジェクトは参照で渡されます。これはC言語やVisual Basic、Delphiなどの他の言語とはかなり違います。オブジェクトやプリミティブをどのように扱うのかは正確には言えませんが、Visual BasicやDelphiでは指定できる(はず)ということは知っています。</target>
        </trans-unit>
        <trans-unit id="b3a5e4b79e22cee55b6065ffe3f652237cc7594a" translate="yes" xml:space="preserve">
          <source>Readers
  familiar with the other meaning of
  this term may prefer to say that
  objects and arrays are passed by
  value, but the value that is passed is
  actually a reference rather than the
  object itself.</source>
          <target state="translated">この用語の他の意味に精通している読者は、オブジェクトや配列は値で渡されると言う方が好きかもしれませんが、渡される値は実際にはオブジェクトそのものではなく参照です。</target>
        </trans-unit>
        <trans-unit id="13206fd4fe5b59fc41e3d5a63a6488e8b552facb" translate="yes" xml:space="preserve">
          <source>Reassigning a variable merely points that pointer at a new value.</source>
          <target state="translated">変数の再割り当ては、単にそのポインタを新しい値に向けるだけです。</target>
        </trans-unit>
        <trans-unit id="3207f76b42378372483b9234b1caf6f7a147a617" translate="yes" xml:space="preserve">
          <source>Reassigning a variable will never affect other variables that were pointing at that same object</source>
          <target state="translated">変数の再割り当ては、同じオブジェクトを指していた他の変数に影響を与えることはありません。</target>
        </trans-unit>
        <trans-unit id="d310f078235065dddc3b458e5e588f59ca402bb8" translate="yes" xml:space="preserve">
          <source>Repeating this with an object yields different results:</source>
          <target state="translated">これをオブジェクトで繰り返すと、異なる結果が得られます。</target>
        </trans-unit>
        <trans-unit id="203297a3389833da40302baa74058f84dfb4172b" translate="yes" xml:space="preserve">
          <source>Return a List whose sole item is arg.</source>
          <target state="translated">唯一の項目がargであるリストを返します。</target>
        </trans-unit>
        <trans-unit id="fea577a31c06a6a5a9a25864cabd1f7cd04ffc69" translate="yes" xml:space="preserve">
          <source>Section 11.2.1 &quot;Property Accessors&quot;</source>
          <target state="translated">第11.2.1項 「プロパティアクセサ</target>
        </trans-unit>
        <trans-unit id="e3cdf6da05c63ab4f98f08c709113dc947f4641b" translate="yes" xml:space="preserve">
          <source>Section 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:</source>
          <target state="translated">11.2.4項「引数リスト」では、1つの引数のみで構成される引数リストの作成について、次のように述べられています。</target>
        </trans-unit>
        <trans-unit id="3dffa3d82c957452592ddbe22ee7b9fbabbad396" translate="yes" xml:space="preserve">
          <source>Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).</source>
          <target state="translated">セマンティクス! 具体的な定義を設定すると、同じ言葉やフレーズを使っていても同じことを記述しているわけではないので、必然的に一部の回答やコメントは相容れないものになってしまいますが、その混乱を乗り越えるためには(特に新人プログラマにとっては)重要です。</target>
        </trans-unit>
        <trans-unit id="9042860968c9655fa63ade5546c81f532a616526" translate="yes" xml:space="preserve">
          <source>Simple values inside functions will not change those values outside of the function (they are passed by value), whereas complex ones will (they are passed by reference).</source>
          <target state="translated">関数内の単純な値は、関数外の値を変更することはありません(値で渡されます)が、複雑な値は変更されます(参照で渡されます)。</target>
        </trans-unit>
        <trans-unit id="af00e0ad8adf530d42297d91d90e47a9e641005b" translate="yes" xml:space="preserve">
          <source>Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.</source>
          <target state="translated">簡単に言えば、プリミティブ型の場合は関数呼び出しの最初に値がコピーされ、オブジェクト型の場合は参照がコピーされます。</target>
        </trans-unit>
        <trans-unit id="14e546fc199d754d3c9fb63d6f7e0dc0eda5708f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;inVar2&lt;/code&gt; received the reference of &lt;code&gt;{ prop: 2 }&lt;/code&gt;, you can change the value of the object's property.</source>
          <target state="translated">&lt;code&gt;inVar2&lt;/code&gt; は &lt;code&gt;{ prop: 2 }&lt;/code&gt; の参照を受け取ったので、オブジェクトのプロパティの値を変更できます。</target>
        </trans-unit>
        <trans-unit id="6b26d53b2a6c26d221c34b2ced9596e48f74edf5" translate="yes" xml:space="preserve">
          <source>So changing the value of a variable doesn't affect the other, as they both reside in two different locations.</source>
          <target state="translated">つまり、変数の値を変更しても、どちらも2つの異なる場所に存在しているので、他の変数には影響を与えないということです。</target>
        </trans-unit>
        <trans-unit id="f443d83baee5de8b57871adc873303085a0467cd" translate="yes" xml:space="preserve">
          <source>So in JavaScript, if I pass an object X into a function via a parameter, it will still be X. If you are changing data &lt;em&gt;inside&lt;/em&gt; the function (or any other object, but that's not important) that new value is also available outside the function.</source>
          <target state="translated">したがって、JavaScriptでは、オブジェクトXをパラメーターを介して関数に渡しても、それはXのままです。関数（または他のオブジェクトですが、それは重要ではありません） &lt;em&gt;内&lt;/em&gt;のデータを変更する場合、新しい値は、関数。</target>
        </trans-unit>
        <trans-unit id="8f7623c6dec052db957de7605896e4a2a3e6b647" translate="yes" xml:space="preserve">
          <source>So, &lt;strike&gt;forget about &lt;em&gt;&quot;pass by reference/value&quot;&lt;/em&gt;&lt;/strike&gt; don't get hung up on &quot;pass by reference/value&quot; because:</source>
          <target state="translated">そのため、 &lt;strike&gt;&lt;em&gt;「参照/値による受け渡し」&lt;/em&gt;について忘れないでください&lt;/strike&gt; 。</target>
        </trans-unit>
        <trans-unit id="68d38550c4da9fcceac584158479a156958fb538" translate="yes" xml:space="preserve">
          <source>Some final comments:</source>
          <target state="translated">最終的なコメントをいくつか。</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="26220bb61f95026a6699bda5f772ab5f459fb7d2" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;</source>
          <target state="translated">ソース： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description</target>
        </trans-unit>
        <trans-unit id="00317f5e100f735c8f89f41e078aacbee58460d5" translate="yes" xml:space="preserve">
          <source>Strings are immutable, so it doesn't really matter for them.</source>
          <target state="translated">文字列は不変なので、文字列には関係ありません。</target>
        </trans-unit>
        <trans-unit id="d0020398180c05f3b9f05227c429a1215e0aae80" translate="yes" xml:space="preserve">
          <source>Take these examples.</source>
          <target state="translated">これらの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="96016a84f6ccaa21c0ff5eb49c88180b5839dbb7" translate="yes" xml:space="preserve">
          <source>That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.</source>
          <target state="translated">つまり、パラメータ参照は、パラメータの値自体にアクセスした場合に変更可能です。一方、パラメータへの代入は評価後に消えてしまい、関数呼び出し側からはアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="1e9b208745c0adc4ae130578652525c2f81da6a0" translate="yes" xml:space="preserve">
          <source>That's why when you try to change an object inside a function, by replacing it's value (i.e. &lt;code&gt;age = {value:5}&lt;/code&gt;), the change doesn't persist, but if you change it's properties (i.e. &lt;code&gt;age.value = 5&lt;/code&gt;), it does.</source>
          <target state="translated">そのため、関数内のオブジェクトを変更しようとすると、その値（つまり、 &lt;code&gt;age = {value:5}&lt;/code&gt; ）を置き換えると、変更は持続しませんが、プロパティ（つまり、 &lt;code&gt;age.value = 5&lt;/code&gt; ）を変更すると、します。</target>
        </trans-unit>
        <trans-unit id="ff449e061e42e079c42808abf8dc5c78475c9c12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;age&lt;/code&gt; is a reference to &lt;code&gt;myAge&lt;/code&gt;, but if you want the value you have to convert the reference, using &lt;code&gt;*age&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;age&lt;/code&gt; は &lt;code&gt;myAge&lt;/code&gt; への参照ですが、値が必要な場合は &lt;code&gt;*age&lt;/code&gt; を使用して参照を変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="3cfb912d780ddf9573a7ca91bac5773da514df0e" translate="yes" xml:space="preserve">
          <source>The JavaScript engine assigns the object to the variable &lt;code&gt;c&lt;/code&gt;, and it points to some memory, say (0x012).</source>
          <target state="translated">JavaScriptエンジンはオブジェクトを変数 &lt;code&gt;c&lt;/code&gt; に割り当て、それは（0x012）などのメモリを指します。</target>
        </trans-unit>
        <trans-unit id="54327c1b59eda63c1878391f14ad9c7f807364da" translate="yes" xml:space="preserve">
          <source>The MDN docs explain it clearly, without being too verbose:</source>
          <target state="translated">MDNの先生方は、あまり冗長にならずにわかりやすく説明してくれます。</target>
        </trans-unit>
        <trans-unit id="131abb827464b85b18ae518074aac50427c4fc92" translate="yes" xml:space="preserve">
          <source>The equal(=) operator sets up new memory space or address</source>
          <target state="translated">イコール(=)演算子は、新しいメモリ空間またはアドレスを設定します。</target>
        </trans-unit>
        <trans-unit id="ebfa1ea7372d6f23abc337f70c4f4df97d8a30cd" translate="yes" xml:space="preserve">
          <source>The most succinct explanation I found was in the &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNB style guide&lt;/a&gt;:</source>
          <target state="translated">私が見つけた最も簡潔な説明は&lt;a href=&quot;https://github.com/airbnb/javascript#types&quot;&gt;AirBNBスタイルガイドにありました&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3d021afb081241b899877ae82ca0e06ab382f15" translate="yes" xml:space="preserve">
          <source>The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)</source>
          <target state="translated">唯一の落とし穴は、関数に渡す変数の名前と関数のパラメータの名前が同じ場合です。このような場合は、関数内のパラメータを、あたかも関数のプライベートな新しい変数であるかのように扱わなければなりません (なぜなら、そうだからです)。</target>
        </trans-unit>
        <trans-unit id="2e351bcd6c54bf11efb568e95ee714a771482cbd" translate="yes" xml:space="preserve">
          <source>The only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven't modified the variable, but the object itself.</source>
          <target state="translated">変数の変更」が別の変数に影響を与えるのは、基礎となるオブジェクトが突然変異したときだけです(この場合、変数を変更したのではなく、オブジェクト自体を変更したことになります)。</target>
        </trans-unit>
        <trans-unit id="e117feea80f4052240b302d90852bffb9002a69f" translate="yes" xml:space="preserve">
          <source>The parameters of a function call are the function's &lt;em&gt;arguments&lt;/em&gt;.
  Arguments are passed to functions &lt;em&gt;by value&lt;/em&gt;. If the function changes
  the value of an argument, this change is not reflected globally or in
  the calling function. However, object references are values, too, and
  they are special: if the function changes the referred object's
  properties, that change is visible outside the function, (...)</source>
          <target state="translated">関数呼び出しのパラメーターは、関数の&lt;em&gt;引数&lt;/em&gt;です。 引数は&lt;em&gt;値によって&lt;/em&gt;関数に渡さ&lt;em&gt;れます&lt;/em&gt; 。 関数が引数の値を変更した場合、この変更はグローバルにも、呼び出し元の関数にも反映されません。 ただし、オブジェクト参照も値であり、それらは特別です。関数が参照されたオブジェクトのプロパティを変更した場合、その変更は関数の外に表示されます（...）</target>
        </trans-unit>
        <trans-unit id="df2fd245eb7826b794aeb3d9f1b7a4aa9ba6448f" translate="yes" xml:space="preserve">
          <source>The phrase &quot;pass by
  reference&quot; can have several meanings.
  To some readers, the phrase refers to
  a function invocation technique that
  allows a function to assign new values
  to its arguments and to have those
  modified values visible outside the
  function. This is not the way the term
  is used in this book.</source>
          <target state="translated">参照渡し」というフレーズにはいくつかの意味があります。一部の読者にとっては、このフレーズは、関数がその引数に新しい値を代入し、それらの変更された値を関数の外部に表示することを可能にする関数呼び出しのテクニックを指しています。これは、本書ではこの用語を使用する方法ではありません。</target>
        </trans-unit>
        <trans-unit id="40424125880f7bec8d7f9e5602a94c76e97cd1cc" translate="yes" xml:space="preserve">
          <source>The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).</source>
          <target state="translated">原始型(数や文字列など)は値で渡されますが、オブジェクトは値渡し(オブジェクトを保持している変数が実はオブジェクトへの参照であると考える場合)と参照渡し(オブジェクトへの変数がオブジェクト自体を保持していると考える場合)の両方の可能性があるため不明です。</target>
        </trans-unit>
        <trans-unit id="8fbaf791a543ee22f0fd296541edf5a1bfa479b1" translate="yes" xml:space="preserve">
          <source>The production ArgumentList : AssignmentExpression is evaluated as follows:</source>
          <target state="translated">プロダクションの ArgumentList .AssignmentExpression は、以下のように評価されます。AssignmentExpressionは以下のように評価されます。</target>
        </trans-unit>
        <trans-unit id="ecee46c34e5a0a1af1170066ea3f9a92c40b9de1" translate="yes" xml:space="preserve">
          <source>The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</source>
          <target state="translated">プロデュース MemberExpression:MemberExpression[式]は、以下のように評価されます。</target>
        </trans-unit>
        <trans-unit id="e64cfc5706b868b32b799d93138e5cd834b8bce0" translate="yes" xml:space="preserve">
          <source>The section also enumerate cases where argument list has 0 or &amp;gt;1 arguments.</source>
          <target state="translated">このセクションでは、引数リストに0または&amp;gt; 1の引数がある場合も列挙します。</target>
        </trans-unit>
        <trans-unit id="dbf3ebd42f5ddf6e8a07546545a97d0d73e8f740" translate="yes" xml:space="preserve">
          <source>The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren't visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller's scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned &amp;mdash; it is shared.</source>
          <target state="translated">共有による呼び出しのセマンティクスは、参照内の呼び出しとは異なり、関数内の関数引数への割り当ては呼び出し元には見えません（参照によるセマンティクスとは異なります）。したがって、たとえば、変数が渡された場合、それは不可能です。呼び出し元のスコープでその変数の割り当てをシミュレートします。 ただし、関数は呼び出し元と同じオブジェクトにアクセスできるため（コピーは作成されません）、オブジェクトが変更可能な場合、関数内のそれらのオブジェクトへの変更は呼び出し元に表示され、値による呼び出しとは異なる可能性があります。セマンティクス。 関数内の変更可能なオブジェクトの変更は、オブジェクトがコピーまたは複製されないため、呼び出し元に表示されます&amp;mdash;オブジェクトは共有されます。</target>
        </trans-unit>
        <trans-unit id="8c4316acc1d74e70023ca752c79e9fc23bbbea3d" translate="yes" xml:space="preserve">
          <source>The terms are only used to describe the &lt;em&gt;behavior&lt;/em&gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn't adequately describe the actual behavior and supplementary info has to be provided</source>
          <target state="translated">これらの用語は、言語の&lt;em&gt;動作&lt;/em&gt;を説明するためにのみ使用され、必ずしも実際の基本的な実装ではありません。 この抽象化の結果、きちんとした説明に不可欠な重要な詳細が失われ、必然的に1つの用語では実際の動作が適切に説明されず、補足情報が提供されなければならないという現在の状況につながります</target>
        </trans-unit>
        <trans-unit id="626d24ad73a240837e037855870f41fe70cd5f31" translate="yes" xml:space="preserve">
          <source>The variable doesn't &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It's always pass by value (even when that value is a reference...).</source>
          <target state="translated">変数はオブジェクトを「保持」するのではなく、参照を保持します。その参照を別の変数に代入することができ、今では両方とも同じオブジェクトを参照しています。それは常に値で渡されます(その値が参照であっても...)。</target>
        </trans-unit>
        <trans-unit id="dca56569992ce2b50c87910c0d7c7c9858ba2c6f" translate="yes" xml:space="preserve">
          <source>There is no &quot;pass by reference&quot; available in JavaScript.</source>
          <target state="translated">JavaScriptで利用できる「参照によるパス」はありません。</target>
        </trans-unit>
        <trans-unit id="361031a3f3abf898ac288ca94af4b04c26e7d902" translate="yes" xml:space="preserve">
          <source>There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn't have a function and just used the equal sign to assign to a new variable.</source>
          <target state="translated">オブジェクトとプリミティブを区別することに意味はありません。</target>
        </trans-unit>
        <trans-unit id="1aa166014dcdcbcff2f5f9b82565c5b3c2e956bf" translate="yes" xml:space="preserve">
          <source>There's no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.</source>
          <target state="translated">パラメータとして渡された変数が保持する値を変更する方法はありません。</target>
        </trans-unit>
        <trans-unit id="010934035b63fc110de9e084961250609ba49e08" translate="yes" xml:space="preserve">
          <source>There's some discussion about the use of the term &quot;pass by reference&quot; in JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;here&lt;/a&gt;, but to answer your question:</source>
          <target state="translated">JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Defining_Functions&quot;&gt;での&lt;/a&gt; 「参照渡し」という用語の使用についての議論がここにありますが、あなたの質問に答えるために：</target>
        </trans-unit>
        <trans-unit id="b3971268996a99a5df86f39832ec5539e7dd9d70" translate="yes" xml:space="preserve">
          <source>These concepts were not originally defined with the intent of describing javascript in particular and so I don't feel compelled to use them when they only add to the confusion.</source>
          <target state="translated">これらの概念は元々javascriptを特に記述する意図で定義されたものではないので、混乱を助長するだけなら使わざるを得ないとは思いません。</target>
        </trans-unit>
        <trans-unit id="e16663c0ae48f1219b8db33d73a88db1512811fc" translate="yes" xml:space="preserve">
          <source>Think of it like this: It's always pass by value. However, the value of an object is not the object itself, but a reference to that object.</source>
          <target state="translated">このように考えてみてください。それは常に値で渡されます。しかし、オブジェクトの値はオブジェクトそのものではなく、そのオブジェクトへの参照です。</target>
        </trans-unit>
        <trans-unit id="705df426723dfd9a58e61806d528e760b06fe084" translate="yes" xml:space="preserve">
          <source>This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.</source>
          <target state="translated">値で渡す、参照で渡す(JavaScript)について少し説明します。この概念では、変数を参照で渡すことと、変数を参照で渡すことについて話しています。</target>
        </trans-unit>
        <trans-unit id="3f9efc65382f339c71ef4d14543d364c027db24a" translate="yes" xml:space="preserve">
          <source>This produces the output:</source>
          <target state="translated">これにより、出力が生成されます。</target>
        </trans-unit>
        <trans-unit id="a1116d28bfe37e6545e3ebc5bd2c217059edabe0" translate="yes" xml:space="preserve">
          <source>Thus, everything's are passed by reference.</source>
          <target state="translated">このように、すべてのものは参照によって渡されます。</target>
        </trans-unit>
        <trans-unit id="3678321f62ae967b6f938900843022091b6a3c1b" translate="yes" xml:space="preserve">
          <source>Thus, properties of Objects are always available as reference.</source>
          <target state="translated">このように、オブジェクトのプロパティは常に参照可能です。</target>
        </trans-unit>
        <trans-unit id="0821fb327f2753fc69a24f9f6c10a0a8791e18c7" translate="yes" xml:space="preserve">
          <source>To answer your question: pointers are passed.</source>
          <target state="translated">あなたの質問に答えるために:ポインタは渡されます。</target>
        </trans-unit>
        <trans-unit id="7bbe358444a139cd8eb2208023bd472900f08800" translate="yes" xml:space="preserve">
          <source>To effectively pass a compound value (like an &lt;code&gt;array&lt;/code&gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</source>
          <target state="translated">値のコピーによって（ &lt;code&gt;array&lt;/code&gt; ような）複合値を効果的に渡すには、渡された参照がまだ元の値を指さないように、その値のコピーを手動で作成する必要があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="e1abf81928ceac0fa096e0f4f2795b3ee7f8da32" translate="yes" xml:space="preserve">
          <source>Uh oh.... What has happened. We couldn't change string1 by changing favoriteString... Why?? Because we didn't &lt;em&gt;change&lt;/em&gt; our string &lt;em&gt;object&lt;/em&gt;. All we did was &quot;RE ASSIGN&quot; the favoriteString &lt;em&gt;variable&lt;/em&gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn't assign anything. (Well, not to the &lt;em&gt;variable itself&lt;/em&gt;, ... we did, however, assign the name property to a new string.) Instead, we simply mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or &lt;em&gt;mutate&lt;/em&gt; the string object &lt;em&gt;itself&lt;/em&gt;, we couldn't have, because strings are actually immutable in JavaScript.)</source>
          <target state="translated">ええと...何が起こったのですか。 FavoriteStringを変更してstring1を変更できませんでした...なぜですか？ 文字列&lt;em&gt;オブジェクトを&lt;/em&gt; &lt;em&gt;変更&lt;/em&gt;しなかったためです。 私たちが行ったのは、favoriteString &lt;em&gt;変数&lt;/em&gt;を新しい文字列に「RE ASSIGN」することだけでした。 これは本質的にそれをstring1から切り離しました。 前の例では、オブジェクトの名前を変更するときに、何も割り当てませんでした。 （まあ、 &lt;em&gt;変数自体&lt;/em&gt;ではなく、...ただし、nameプロパティを新しい文字列に割り当てました。）代わりに、2つの変数と基になるオブジェクト間の接続を維持するオブジェクトを単に変更しました。 （文字列オブジェクト&lt;em&gt;自体&lt;/em&gt;を変更または変更したいと思っても、実際にはJavaScriptでは文字列が不変であるため、それを行うことはできませんでした。）</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="ad44083b5ca9c555d81d716126062a61d9fc5f75" translate="yes" xml:space="preserve">
          <source>Variables are &lt;em&gt;pointers&lt;/em&gt; to values in memory.</source>
          <target state="translated">変数は、メモリ内の値への&lt;em&gt;ポインタ&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="678a462c2bd82f3f082479b480f76e063a36fb4b" translate="yes" xml:space="preserve">
          <source>What we have done is &quot;assignment&quot;... We've assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.</source>
          <target state="translated">何をしたかというと、「代入」ですね...。2つの別々の空のオブジェクトを変数 &quot;object1 &quot;と &quot;object2 &quot;に代入しました。</target>
        </trans-unit>
        <trans-unit id="84d66e6463f366bb3793d71142052ebf0b3271b4" translate="yes" xml:space="preserve">
          <source>When calling a function, you are passing the content (reference or
value) of the argument variables, not the the variables themselves.</source>
          <target state="translated">関数を呼び出す際には、引数変数の内容(参照または値)を渡すことになりますが、変数そのものを渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="b675d8ab55a62fa7342693de178ca61efdefdab7" translate="yes" xml:space="preserve">
          <source>When d=c, in this step &lt;code&gt;d&lt;/code&gt; points to the same location (0x012).</source>
          <target state="translated">d = cの場合、このステップで &lt;code&gt;d&lt;/code&gt; は同じ場所（0x012）を指します。</target>
        </trans-unit>
        <trans-unit id="6603f9e15352ae782eb9dbf4dc53a8cacea1f46d" translate="yes" xml:space="preserve">
          <source>When we make the assignment &lt;code&gt;b = [4,5,6]&lt;/code&gt;, we are doing absolutely nothing to affect where &lt;code&gt;a&lt;/code&gt; is still referencing (&lt;code&gt;[1,2,3]&lt;/code&gt;). To do that, &lt;code&gt;b&lt;/code&gt; would have to be a pointer to &lt;code&gt;a&lt;/code&gt; rather than a reference to the &lt;code&gt;array&lt;/code&gt; -- but no such capability exists in JS!</source>
          <target state="translated">割り当て &lt;code&gt;b = [4,5,6]&lt;/code&gt; を作成するとき、 &lt;code&gt;a&lt;/code&gt; が参照している場所に影響を与えることはまったくありません（ &lt;code&gt;[1,2,3]&lt;/code&gt; ）。 そのためには、 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;array&lt;/code&gt; への参照ではなくaへのポインターでなければなりません-しかし、JSにはそのような機能はありません！</target>
        </trans-unit>
        <trans-unit id="13f9dc2555da1b44daf4195c85cac47042d3a3a1" translate="yes" xml:space="preserve">
          <source>When we pass in the argument &lt;code&gt;a&lt;/code&gt;, it assigns a copy of the &lt;code&gt;a&lt;/code&gt; reference to &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are separate references pointing at the same &lt;code&gt;[1,2,3]&lt;/code&gt; value. Now, inside the function, we can use that reference to mutate the value itself (&lt;code&gt;push(4)&lt;/code&gt;). But when we make the assignment &lt;code&gt;x = [4,5,6]&lt;/code&gt;, this is in no way affecting where the initial reference &lt;code&gt;a&lt;/code&gt; is pointing -- still points at the (now modified) &lt;code&gt;[1,2,3,4]&lt;/code&gt; value.</source>
          <target state="translated">引数 &lt;code&gt;a&lt;/code&gt; を渡すと、aのコピーが &lt;code&gt;x&lt;/code&gt; に割り当てられます。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; は、同じ &lt;code&gt;[1,2,3]&lt;/code&gt; 値を指す個別の参照です。 これで、関数内で、その参照を使用して値自体を変更できます（ &lt;code&gt;push(4)&lt;/code&gt; ）。 しかし、代入 &lt;code&gt;x = [4,5,6]&lt;/code&gt; 場合、これは、初期参照 &lt;code&gt;a&lt;/code&gt; が指している場所にはまったく影響を与えません。それでも、（現在は変更されている） &lt;code&gt;[1,2,3,4]&lt;/code&gt; 値を指します。</target>
        </trans-unit>
        <trans-unit id="dc1b4ec703eec5dfe10344c61e1e765e58682a65" translate="yes" xml:space="preserve">
          <source>When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else.</source>
          <target state="translated">その参照を使用してそのオブジェクトを操作すると、外部のオブジェクトも影響を受けます。しかし、関数の内部で参照を他の何かに向けることにした場合、外部のオブジェクトには全く影響を与えません。</target>
        </trans-unit>
        <trans-unit id="a5f72cf83865e4414b2e92fe68d2f91039221270" translate="yes" xml:space="preserve">
          <source>a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).</source>
          <target state="translated">aはメモリを割り当てられ(0x001とします)、bはメモリ内の値のコピーを作成します(0x002とします)。</target>
        </trans-unit>
        <trans-unit id="ba35e803347ae1a6fbb922bb822df3c9557c5075" translate="yes" xml:space="preserve">
          <source>a very confusing situation is where you can't realize how your referenced variable changes, let's take a look at a very good example:</source>
          <target state="translated">非常に紛らわしい状況とは、参照している変数がどのように変化するのかが分からない場合ですが、非常に良い例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="1a91322ba3053b9c0d30aeec04a7ec7d757a54ad" translate="yes" xml:space="preserve">
          <source>and in a more complicated story:</source>
          <target state="translated">と、より複雑な物語の中で</target>
        </trans-unit>
        <trans-unit id="dbe8beff245d88e0093cd5bdb6c0a20809a330d5" translate="yes" xml:space="preserve">
          <source>applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).</source>
          <target state="translated">JavaScriptのすべてのプリミティブ型(文字列、数値、ブール値、未定義、null)に適用されます。</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4e4aeb4d95583c62381700ab3cfbd849ddf35b64" translate="yes" xml:space="preserve">
          <source>but we cant do the same thing with the purple arrow, we may want to move 'john' cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...</source>
          <target state="translated">しかし、紫の矢印と同じことはできません。ここで'john'セルを移動させたり、他の多くのことをしたいと思うかもしれません...。</target>
        </trans-unit>
        <trans-unit id="e4cf40496f043253f0d64368904b930d9b69c16d" translate="yes" xml:space="preserve">
          <source>every type2-value (green) is a &lt;strong&gt;single square&lt;/strong&gt; while a type1-value (blue) is a &lt;strong&gt;group of them&lt;/strong&gt;:</source>
          <target state="translated">すべてのタイプ2の値（緑）は&lt;strong&gt;単一の正方形で&lt;/strong&gt;あり、タイプ1の値（青）は&lt;strong&gt;それらのグループです&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="dd74f54fdfe237acc828874dddffdcfc48e8abc5" translate="yes" xml:space="preserve">
          <source>here you are assigning new object or array to old one.you are not changing the value of property 
of old object.so it is pass by value.</source>
          <target state="translated">ここでは、新しいオブジェクトや配列を古いものに代入しています。</target>
        </trans-unit>
        <trans-unit id="a20f2e836503b1a3b14f37b2c5bd01437f59d8f4" translate="yes" xml:space="preserve">
          <source>here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.</source>
          <target state="translated">新しいオブジェクトや配列を古いものに代入しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="53ff18bfd84d263fea5d0d0003eebc0c7a27a864" translate="yes" xml:space="preserve">
          <source>if you are changing a property value of an object or array then it is pass by Reference.</source>
          <target state="translated">オブジェクトや配列のプロパティ値を変更する場合は、Referenceで渡します。</target>
        </trans-unit>
        <trans-unit id="3e6856e162be438b0b1b28e9475c58786691c0c2" translate="yes" xml:space="preserve">
          <source>if you are changing value of that Object or array with new Object or Array then it is pass by Value.</source>
          <target state="translated">新しいオブジェクトや配列でそのオブジェクトや配列の値を変更している場合、それは Value で渡されます。</target>
        </trans-unit>
        <trans-unit id="37fb1667392900bb5ef5037dd0e0b507e63dc8dd" translate="yes" xml:space="preserve">
          <source>if you imagine memory as below squares which in every one of them just one type2-value can be saved:</source>
          <target state="translated">メモリを以下のような正方形にして、その中に1つのtype2の値だけが保存されているとします。</target>
        </trans-unit>
        <trans-unit id="d4ec615b08c0e036b2bca13e54163fa4149fab8d" translate="yes" xml:space="preserve">
          <source>in javascript we can put values in two layer: &lt;strong&gt;type1&lt;/strong&gt;-&lt;code&gt;objects&lt;/code&gt; and &lt;strong&gt;type2&lt;/strong&gt;-all other types of value such as &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc</source>
          <target state="translated">javascriptでは、2つのレイヤーに値を配置でき &lt;code&gt;objects&lt;/code&gt; &lt;strong&gt;。type1-&lt;/strong&gt; オブジェクトと&lt;strong&gt;type2-&lt;/strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;code&gt;boolean&lt;/code&gt; 値など、その他すべてのタイプの値</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="53b0a1b2fadf4e040cdc2155a7340de24aca93cb" translate="yes" xml:space="preserve">
          <source>number</source>
          <target state="translated">number</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="f0f7f39ec7e62249ee81dac2c3f1b3586a4fd52e" translate="yes" xml:space="preserve">
          <source>objects</source>
          <target state="translated">objects</target>
        </trans-unit>
        <trans-unit id="43c608c48ee77ebcf1192df657480116bb88d93b" translate="yes" xml:space="preserve">
          <source>primitive type variable like string,number are always pass as  pass
by value.</source>
          <target state="translated">文字列や数値のようなプリミティブ型の変数は、常に値を渡して渡されます。</target>
        </trans-unit>
        <trans-unit id="0366c73137f63703a81f4390aa8afe89322b7310" translate="yes" xml:space="preserve">
          <source>sharing what I know of references in JavaScript</source>
          <target state="translated">JavaScriptでの参照について知っていることを共有する</target>
        </trans-unit>
        <trans-unit id="340b6603b7ec42319770e6733e4f6bacbc9b29bb" translate="yes" xml:space="preserve">
          <source>so here &lt;strong&gt;references&lt;/strong&gt; can rescue us:</source>
          <target state="translated">だからここでの&lt;strong&gt;参照&lt;/strong&gt;は私たちを救うことができます：</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="bffc56aa90003a62e1312aa3131fb673e4b8fa39" translate="yes" xml:space="preserve">
          <source>symbol in &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; のシンボル</target>
        </trans-unit>
        <trans-unit id="1a6bbba542e8dfa1abb5d45893298c0eb2f0d406" translate="yes" xml:space="preserve">
          <source>the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that's not easy at all! :</source>
          <target state="translated">ポイントは、type2値を指定したい場合はアドレスがプレーンになっていますが、type1値を指定したい場合には、同じことをするのは簡単ではないということです。:</target>
        </trans-unit>
        <trans-unit id="d5d4cd07616a542891b7ec2d0257b3a24b69856e" translate="yes" xml:space="preserve">
          <source>undefined</source>
          <target state="translated">undefined</target>
        </trans-unit>
        <trans-unit id="c097133877b58bb1a18daa1d045149700ebbbf11" translate="yes" xml:space="preserve">
          <source>well, it's about 'performance' and 'speed' and in the simple word 'memory management' in a programming language.</source>
          <target state="translated">まあ、プログラミング言語でいうところの「性能」と「速度」、そして簡単にいうと「メモリ管理」のことですね。</target>
        </trans-unit>
        <trans-unit id="5ba026f489ec792196a7e8a5a6ac751fc3641db1" translate="yes" xml:space="preserve">
          <source>while the green arrow here is a typical variable, the purple one is an object variable, so &lt;strong&gt;because the green arrow(typical variable) has just one task&lt;/strong&gt; (and that is indicating a typical value) we don't need to separate it's value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...</source>
          <target state="translated">ここで緑の矢印は一般的な変数ですが、紫の矢印はオブジェクト変数です。 &lt;strong&gt;緑の矢印（一般的な変数）にはタスクが1つ&lt;/strong&gt;しかないため（これは一般的な値を示しています）、値を分離する必要はありません。緑色の矢印をその値とともに移動します。どこにでも、すべての割り当て、関数などで...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
