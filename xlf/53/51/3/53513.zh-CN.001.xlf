<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/53513">
    <body>
      <group id="53513">
        <trans-unit id="fa6087ea829d2efe469e42d5b4ea7ef6c710c3b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt;&lt;code&gt;len()&lt;/code&gt; is an O(1) operation&lt;/a&gt; for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</source>
          <target state="translated">&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt; &lt;code&gt;len()&lt;/code&gt; 是&lt;/a&gt;用于Python列表，字符串，字典和集合的O（1）操作 。 Python在内部跟踪这些容器中元素的数量。</target>
        </trans-unit>
        <trans-unit id="85fd292fdea964654b12fcc3bff501372a02fc3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;Patrick's (accepted) answer&lt;/a&gt; is right: &lt;code&gt;if not a:&lt;/code&gt; is the right way to do it. &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;Harley Holcombe's answer&lt;/a&gt; is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom&amp;mdash;even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;帕特里克（已接受）的答案&lt;/a&gt;是正确的： &lt;code&gt;if not a:&lt;/code&gt; 则是正确的方法。 &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;Harley Holcombe的答案&lt;/a&gt;是正确的，因为这在PEP 8样式指南中。 但是，答案没有一个能解释的是为什么遵循这个习惯用法是一个好主意-即使您个人发现它对于Ruby用户或其他任何人来说都不足够明确或令人困惑。</target>
        </trans-unit>
        <trans-unit id="f6bd068dee72f5e7acd72d046b51628d73431616" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt;, the official Python style guide for Python code in Python's standard library, asserts:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt;是Python标准库中Python代码的官方Python样式指南，它断言：</target>
        </trans-unit>
        <trans-unit id="709c05e03db9fe7106ff167bae3e20510ada6c6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; The pretty simple pythonic way:</source>
          <target state="translated">&lt;strong&gt;1）&lt;/strong&gt;非常简单的pythonic方式：</target>
        </trans-unit>
        <trans-unit id="73bff0478225a1ca5de41c8041fd2f172d65b5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; A much explicit way: using the &lt;code&gt;len()&lt;/code&gt; to find the length and check if it equals to &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;2）&lt;/strong&gt;一种非常明确的方法：使用 &lt;code&gt;len()&lt;/code&gt; 查找长度并检查其是否等于 &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f9d4a74112f8906073526e0491135de335a7db27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt; Or comparing it to an anonymous empty list:</source>
          <target state="translated">&lt;strong&gt;3）&lt;/strong&gt;或将其与匿名空列表进行比较：</target>
        </trans-unit>
        <trans-unit id="406daadaa5d41723954f852ca3012418a893aa74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4)&lt;/strong&gt; Another yet &lt;em&gt;silly&lt;/em&gt; way to do is using &lt;code&gt;exception&lt;/code&gt; and &lt;code&gt;iter()&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;4）&lt;/strong&gt;另一种&lt;em&gt;愚蠢的&lt;/em&gt;方法是使用 &lt;code&gt;exception&lt;/code&gt; 和 &lt;code&gt;iter()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2d2003a249df2249cead04ad47fd9076516a663f" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is the first google hit for &quot;python test empty array&quot; and similar queries, plus other people seem to be generalizing the question beyond just lists, so I thought I'd add a caveat for a different type of sequence that a lot of people might use.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;这是google在&amp;ldquo; python测试空数组&amp;rdquo;和类似查询上的首次亮相，再加上其他人似乎在推广问题，不仅限于列表，所以我想为很多人添加另一种类型的序列的警告可能会用。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e08157bc06e9b1d4da704ba91099e16c06508dab" translate="yes" xml:space="preserve">
          <source>@Daren Thomas</source>
          <target state="translated">@Daren Thomas</target>
        </trans-unit>
        <trans-unit id="dbf83e4117a99476070d823064700dc3ed352dc3" translate="yes" xml:space="preserve">
          <source>All values other than what is listed here are considered &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">除此处列出的值外，所有其他值均视为 &lt;code&gt;True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a2a7eec8c7ee8d914fe13445e4f282e1b2a7082" translate="yes" xml:space="preserve">
          <source>Although it's worth nothing that &lt;code&gt;None&lt;/code&gt; is falsy. So if you don't want to separate test for &lt;code&gt;None&lt;/code&gt;-ness, you don't have to do that.</source>
          <target state="translated">尽管没有价值是虚无的，但毫无价值。 因此，如果您不想单独测试 &lt;code&gt;None&lt;/code&gt; -ness，则不必这样做。</target>
        </trans-unit>
        <trans-unit id="a3eda0c093884c5cdf292a4a6958a44bd4e2a71d" translate="yes" xml:space="preserve">
          <source>An empty list is itself considered false in true value testing (see &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;python documentation&lt;/a&gt;):</source>
          <target state="translated">空列表本身在真实值测试中被认为是错误的（请参阅&lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;python文档&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ab5f88a40a649b5bd874e7e3cf70712fe8fcfbfb" translate="yes" xml:space="preserve">
          <source>And for the &lt;code&gt;[] == []&lt;/code&gt; it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</source>
          <target state="translated">对于 &lt;code&gt;[] == []&lt;/code&gt; 它必须建立一个不必要的列表，然后再次在Python的虚拟机（而不是C）中执行比较操作。</target>
        </trans-unit>
        <trans-unit id="44044d9b0333bc1e2793c401ceb8f5611f29a99f" translate="yes" xml:space="preserve">
          <source>And the datamodel documentation:</source>
          <target state="translated">还有数据模型文档。</target>
        </trans-unit>
        <trans-unit id="45af135cc0b7fd22346b0a3dce703ee3a4f1fac5" translate="yes" xml:space="preserve">
          <source>And users of lazy languages may be tempted to do this:</source>
          <target state="translated">而使用懒人语言的用户,可能会有这样的诱惑。</target>
        </trans-unit>
        <trans-unit id="6202056bf6b3d838f4ff8c5b7307d6357e08439f" translate="yes" xml:space="preserve">
          <source>And, of course, there is a very natural way to do it:</source>
          <target state="translated">当然,也有一个很自然的方法。</target>
        </trans-unit>
        <trans-unit id="ff47252d65d441c800203256a95b3a6607509fac" translate="yes" xml:space="preserve">
          <source>As can be seen, empty list &lt;code&gt;[]&lt;/code&gt; is &lt;em&gt;falsy&lt;/em&gt;, so doing what would be done to a boolean value sounds most efficient:</source>
          <target state="translated">可以看出，空列表 &lt;code&gt;[]&lt;/code&gt; 是&lt;em&gt;虚假的&lt;/em&gt; ，因此对布尔值执行的操作听起来最有效：</target>
        </trans-unit>
        <trans-unit id="bba28c4ea8d4854a5cac4c82193c5746abc143e3" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;SciPy FAQ&lt;/a&gt;, the correct method in all cases where you know you have a NumPy array is to use &lt;code&gt;if x.size&lt;/code&gt;:</source>
          <target state="translated">如&lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;SciPy常见问题解答&lt;/a&gt;中所述，在您知道拥有NumPy数组的所有情况下，正确的方法是使用 &lt;code&gt;if x.size&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2a373c95098f9c06da7f59b6f9464570c1f1907" translate="yes" xml:space="preserve">
          <source>Being inspired by @dubiousjim's solution, I propose to use an additional general check of whether is it something iterable</source>
          <target state="translated">受@dubiousjim的解决方案的启发,我建议使用一个额外的一般检查,即是否是可重复的东西。</target>
        </trans-unit>
        <trans-unit id="3ab76bc795d839d5beddbad54e0ccdf03bc826b1" translate="yes" xml:space="preserve">
          <source>Best way to check if a list is empty</source>
          <target state="translated">检查列表是否为空的最佳方法</target>
        </trans-unit>
        <trans-unit id="eca779c7f85faf34e05c115f1686ec19c2ba5f60" translate="yes" xml:space="preserve">
          <source>But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the &lt;code&gt;if&lt;/code&gt; statement will &quot;work&quot;, in the sense that you don't get an error.  However, if that one element happens to be &lt;code&gt;0&lt;/code&gt; (or &lt;code&gt;0.0&lt;/code&gt;, or &lt;code&gt;False&lt;/code&gt;, ...), the &lt;code&gt;if&lt;/code&gt; statement will incorrectly result in &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">但是至少上述情况告诉您它失败了。 如果您碰巧有一个仅包含一个元素的NumPy数组， &lt;code&gt;if&lt;/code&gt; 在没有错误的意义上， if语句将&amp;ldquo;起作用&amp;rdquo;。 但是，如果该元素恰好是 &lt;code&gt;0&lt;/code&gt; （或 &lt;code&gt;0.0&lt;/code&gt; 或 &lt;code&gt;False&lt;/code&gt; ，...），则 &lt;code&gt;if&lt;/code&gt; 语句将错误地导致 &lt;code&gt;False&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="daf538c97712481cae9a4d466b7c25253ade40a8" translate="yes" xml:space="preserve">
          <source>But clearly &lt;code&gt;x&lt;/code&gt; exists and is not empty!  This result is not what you wanted.</source>
          <target state="translated">但是显然 &lt;code&gt;x&lt;/code&gt; 存在并且不为空！ 这个结果不是您想要的。</target>
        </trans-unit>
        <trans-unit id="352789ca029b151d48e5b54d32774d3617bff5aa" translate="yes" xml:space="preserve">
          <source>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</source>
          <target state="translated">但我们认为它不是Python的,因为Python直接在列表对象的接口中通过布尔强制的方式支持这些语义。</target>
        </trans-unit>
        <trans-unit id="b38bccd576f28416712521493d4fcfd148c28f3f" translate="yes" xml:space="preserve">
          <source>But when you don't have anything to be explicit about, anything other than &lt;code&gt;if not a:&lt;/code&gt; is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you &lt;em&gt;habitually&lt;/em&gt; mislead the reader like this, then when you &lt;em&gt;do&lt;/em&gt; need to make a distinction, it's going to pass unnoticed because you've been &quot;crying wolf&quot; all over your code.</source>
          <target state="translated">但是，当您没有任何要明确的内容时，除了 &lt;code&gt;if not a:&lt;/code&gt; 以外的其他任何内容都会误导读者。 当您不重要时，您表示的是重要的事情。 （您可能还会使代码的灵活性降低，变慢，变慢等等，但这并不那么重要。）而且，如果您&lt;em&gt;习惯性地这样&lt;/em&gt;误导读者，那么当您&lt;em&gt;确实&lt;/em&gt;需要区分时，它会被忽略，因为您一直在整个代码中&amp;ldquo;狼吞虎咽&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f3c03b9e169237bd714c4403d329565895990596" translate="yes" xml:space="preserve">
          <source>By default, an object is considered true unless its class defines
  either a &lt;code&gt;__bool__()&lt;/code&gt; method that returns &lt;code&gt;False&lt;/code&gt; or a &lt;code&gt;__len__()&lt;/code&gt; method
  that returns zero, when called with the object. Here are most of the built-in objects considered false:</source>
          <target state="translated">默认情况下，除非对象的类定义了返回 &lt;code&gt;False&lt;/code&gt; 的 &lt;code&gt;__len__()&lt;/code&gt; 方法或与该对象一起调用的返回零的__len __（）方法，否则该对象被视为true。 以下是大多数被认为是错误的内置对象：</target>
        </trans-unit>
        <trans-unit id="0fdcbacfeed5434a99e0a6a9a898a2d1742fc056" translate="yes" xml:space="preserve">
          <source>Called to implement the built-in function &lt;code&gt;len()&lt;/code&gt;. Should return the length of the object, an integer &amp;gt;= 0. Also, an object that doesn&amp;rsquo;t define a &lt;code&gt;__bool__()&lt;/code&gt; method and whose &lt;code&gt;__len__()&lt;/code&gt; method returns zero is considered to be false in a Boolean context.</source>
          <target state="translated">调用以实现内置函数 &lt;code&gt;len()&lt;/code&gt; 。 应该返回对象的长度，即&amp;gt; = 0的整数。此外，在布尔上下文中， &lt;code&gt;__len__()&lt;/code&gt; &lt;code&gt;__bool__()&lt;/code&gt; 方法且其__len __（）方法返回零的对象也被视为false。</target>
        </trans-unit>
        <trans-unit id="e25864a93b493700b01d581e68d0cd82ca932f25" translate="yes" xml:space="preserve">
          <source>Called to implement truth value testing and the built-in operation &lt;code&gt;bool()&lt;/code&gt;; should return &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;. When this method is not defined,
  &lt;code&gt;__len__()&lt;/code&gt; is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither &lt;code&gt;__len__()&lt;/code&gt;
  nor &lt;code&gt;__bool__()&lt;/code&gt;, all its instances are considered true.</source>
          <target state="translated">调用以实现真值测试和内置操作 &lt;code&gt;bool()&lt;/code&gt; ； 应该返回 &lt;code&gt;False&lt;/code&gt; 或 &lt;code&gt;True&lt;/code&gt; 。 如果未定义此方法，则调用 &lt;code&gt;__len__()&lt;/code&gt; （如果已定义），并且如果其结果为非零，则认为该对象为true。 如果一个类 &lt;code&gt;__len__()&lt;/code&gt; 或 &lt;code&gt;__bool__()&lt;/code&gt; ，则其所有实例均被视为true。</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">做到这一点。</target>
        </trans-unit>
        <trans-unit id="f5b5eede35878f55c7d57820131de56da262d55f" translate="yes" xml:space="preserve">
          <source>Does it pay off? (Note that less time to perform an equivalent operation is better:)</source>
          <target state="translated">这样做会有回报吗?(注意少做一个等价操作的时间比较好:)。</target>
        </trans-unit>
        <trans-unit id="373d23c12606180ec0cf1beb638fb73524fadb61" translate="yes" xml:space="preserve">
          <source>Doing what's Pythonic usually pays off in performance:</source>
          <target state="translated">做到Pythonic的事情,通常会在业绩上得到回报。</target>
        </trans-unit>
        <trans-unit id="97f2e93e05fd80db822418cf3feec3652cf3a370" translate="yes" xml:space="preserve">
          <source>EDIT : This works with python2.7 too..</source>
          <target state="translated">EDIT:这也适用于python2.7。</target>
        </trans-unit>
        <trans-unit id="a76d5cc35692d4dad67addbef26267cdf67ffeed" translate="yes" xml:space="preserve">
          <source>EDIT: Another point against testing
  the empty list as False: What about
  polymorphism? You shouldn't depend on
  a list being a list. It should just
  quack like a duck - how are you going
  to get your duckCollection to quack
  ''False'' when it has no elements?</source>
          <target state="translated">EDIT:还有一点,反对把空列表测试为False。那多态性呢?你不应该依赖于一个列表是一个列表。它应该像鸭子一样呱呱叫---当你的duckCollection没有元素的时候,你怎么能让你的duckCollection呱呱叫''False''呢?</target>
        </trans-unit>
        <trans-unit id="dcedc96969a1d0a6f2a233b8f6888a0a00ab7357" translate="yes" xml:space="preserve">
          <source>Evidence from the C source and documentation</source>
          <target state="translated">C来源的证据和文件的证据</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c25e4d6b416a6cd9233a3e845e94921c7430d50d" translate="yes" xml:space="preserve">
          <source>First Python has to check the globals to see if &lt;code&gt;len&lt;/code&gt; is shadowed.</source>
          <target state="translated">首先，Python必须检查全局变量，以查看 &lt;code&gt;len&lt;/code&gt; 是否被遮盖。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f3412712dcaf0e84cb53a746ad7e9f73d9013702" translate="yes" xml:space="preserve">
          <source>For example, if passed the following:</source>
          <target state="translated">例如,如果通过以下几点:</target>
        </trans-unit>
        <trans-unit id="1bad339600e3699390f0ed87a2003eee92c4dfcf" translate="yes" xml:space="preserve">
          <source>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</source>
          <target state="translated">对于规模,这里是调用函数并构造和返回一个空列表的成本,你可以从上面使用的空性检查的成本中减去。</target>
        </trans-unit>
        <trans-unit id="e7f942debb8d0e14241aa308336c922d6775903a" translate="yes" xml:space="preserve">
          <source>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</source>
          <target state="translated">对于序列,(字符串、列表、图腾),使用空序列是假的事实。</target>
        </trans-unit>
        <trans-unit id="bac1c52ffa1b4459d0f919bc355c6d2057242350" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;len(a) == 0&lt;/code&gt; check:</source>
          <target state="translated">对于 &lt;code&gt;len(a) == 0&lt;/code&gt; 检查：</target>
        </trans-unit>
        <trans-unit id="aaaaeb6ed2be6a7373f22ebc411776f617e21985" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;documentation&lt;/a&gt; on truth value testing:</source>
          <target state="translated">从有关真值测试的&lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;文档中&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="609634de36f52ce2e3fd7aa8ecbe7c6e9b48a3be" translate="yes" xml:space="preserve">
          <source>From python3 onwards you can use</source>
          <target state="translated">从python3开始,你可以使用</target>
        </trans-unit>
        <trans-unit id="1232457a90ed6c80cf66104828eec8c675b2e5f6" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;docs&lt;/a&gt; (and note specifically the inclusion of the empty list, &lt;code&gt;[]&lt;/code&gt;):</source>
          <target state="translated">在&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;文档中&lt;/a&gt; （并特别注意空白列表 &lt;code&gt;[]&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="728f688a52623e6d5037d6bbdfb3e7ba80193709" translate="yes" xml:space="preserve">
          <source>From the c source in &lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include/listobject.h&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include / listobject.h中&lt;/a&gt;的c源：</target>
        </trans-unit>
        <trans-unit id="683112e7d730f26c7bccb345b8ef7aaf95794090" translate="yes" xml:space="preserve">
          <source>Here are a few ways you can check if a list is empty:</source>
          <target state="translated">以下是一些检查列表是否为空的方法。</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">希望这对你有帮助。</target>
        </trans-unit>
        <trans-unit id="5ff7fbc89be7316e185d7a00a7ff3d90d022034c" translate="yes" xml:space="preserve">
          <source>How do I check if a list is empty</source>
          <target state="translated">如何检查一个列表是否为空</target>
        </trans-unit>
        <trans-unit id="33c5d06ed9c860acea48b74dc4a823901ef3f8f1" translate="yes" xml:space="preserve">
          <source>How do I check to see if &lt;code&gt;a&lt;/code&gt; is empty?</source>
          <target state="translated">如何检查 &lt;code&gt;a&lt;/code&gt; 是否为空？</target>
        </trans-unit>
        <trans-unit id="e5fcefe7e34c52a1195ed32056bdb1089ea254b1" translate="yes" xml:space="preserve">
          <source>How do I check to see if a is empty?</source>
          <target state="translated">如何检查A是否是空的?</target>
        </trans-unit>
        <trans-unit id="a9f1c0fc9cfe4503ffc9501fffdfcb4226311e22" translate="yes" xml:space="preserve">
          <source>I am not sure why there are so many complicated answers.
It's pretty clear and straightforward</source>
          <target state="translated">我不知道为什么会有那么多复杂的答案。其实很简单明了,也很直接</target>
        </trans-unit>
        <trans-unit id="25ab0752fffc84134368c44c5351c7020c10bf59" translate="yes" xml:space="preserve">
          <source>I frequently see code like this from experienced programmers new to Python:</source>
          <target state="translated">我经常从刚接触Python的资深程序员那里看到这样的代码。</target>
        </trans-unit>
        <trans-unit id="70fe8a86746b4223af6f5c03bf7b7263ef48e957" translate="yes" xml:space="preserve">
          <source>I had written:</source>
          <target state="translated">我曾经写过。</target>
        </trans-unit>
        <trans-unit id="503904ef0bb804cf7a77e21d4237ad21f29e4536" translate="yes" xml:space="preserve">
          <source>I love this way for checking list is empty or not.</source>
          <target state="translated">我喜欢这种检查清单是否为空的方式。</target>
        </trans-unit>
        <trans-unit id="6936816d820ecc9d4d156fa6961e9db56da9a535" translate="yes" xml:space="preserve">
          <source>I prefer it explicitly:</source>
          <target state="translated">我更喜欢它的明文规定。</target>
        </trans-unit>
        <trans-unit id="c822b9b00d42f96380485775d1aabfaff330ecc8" translate="yes" xml:space="preserve">
          <source>I prefer the following:</source>
          <target state="translated">我更喜欢以下几种:</target>
        </trans-unit>
        <trans-unit id="07d7c92c83648b3dcf817f34c2fe61d11e207210" translate="yes" xml:space="preserve">
          <source>I suppose the problem is testing with timeit since just &lt;code&gt;if l:&lt;/code&gt; is sufficient but surprisingly &lt;code&gt;%timeit bool(l)&lt;/code&gt; yields 101 ns &amp;plusmn; 2.64 ns. Interesting there is no way to coerce to bool without this penalty. &lt;code&gt;%timeit l&lt;/code&gt; is useless since no conversion would occur.</source>
          <target state="translated">我想问题是用timeit进行测试，因为 &lt;code&gt;if l:&lt;/code&gt; 是否足够，但令人惊讶的是 &lt;code&gt;%timeit bool(l)&lt;/code&gt; 的输出为 101 ns&amp;plusmn;2.64 ns。 有趣的是，没有这种惩罚就没有办法胁迫。 &lt;code&gt;%timeit l&lt;/code&gt; 没有用，因为不会进行任何转换。</target>
        </trans-unit>
        <trans-unit id="4a53819da8c55112c5bbdb5ec0a8f8c0331eed55" translate="yes" xml:space="preserve">
          <source>I would argue that the &lt;em&gt;most pythonic&lt;/em&gt; way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</source>
          <target state="translated">我认为&lt;em&gt;最Python的&lt;/em&gt;方式是根本不检查，而只是处理列表。 这样，无论是空还是满，它都会做正确的事情。</target>
        </trans-unit>
        <trans-unit id="df53c7c830c1b687f914d825896b14ea3616de2b" translate="yes" xml:space="preserve">
          <source>I would point out that this is also true for the non-empty case though its pretty ugly as with &lt;code&gt;l=[]&lt;/code&gt; then &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90.6 ns &amp;plusmn; 8.3 ns, &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn; 3.09, &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5 ns &amp;plusmn; 0.372. But there is no way anyone is going to enjoy &lt;code&gt;not not l&lt;/code&gt; despite triple the speed. It looks ridiculous. But the speed wins out</source>
          <target state="translated">我要指出的是，对于非空情况也是如此，尽管它非常丑陋，如 &lt;code&gt;l=[]&lt;/code&gt; 然后 &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90.6 ns&amp;plusmn;8.3 ns， &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn;3.09， &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5 ns&amp;plusmn;0.372。 但是，尽管速度提高了三倍，但没有任何人 &lt;code&gt;not not l&lt;/code&gt; 享受它 。 看起来很荒谬。 但是速度胜出</target>
        </trans-unit>
        <trans-unit id="d4412db9669f7d0df447ee505c3d56a16c1a3414" translate="yes" xml:space="preserve">
          <source>IPython magic, &lt;code&gt;%timeit&lt;/code&gt;, is not entirely useless here:</source>
          <target state="translated">IPython的 &lt;code&gt;%timeit&lt;/code&gt; 魔术在这里并非完全没有用：</target>
        </trans-unit>
        <trans-unit id="2a07e4c6e816613379546e213ea347ae1a8fa784" translate="yes" xml:space="preserve">
          <source>If you do actually need to check the array for emptiness, the other answers are sufficient.</source>
          <target state="translated">如果你真的需要检查数组是否空,其他的答案就足够了。</target>
        </trans-unit>
        <trans-unit id="125e68683b69b0a281814ca748de40fb9e6f3516" translate="yes" xml:space="preserve">
          <source>If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input &lt;em&gt;to be&lt;/em&gt; a NumPy array.  There are a few nice functions for doing this quickly &amp;mdash;&amp;nbsp;most importantly &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen &lt;code&gt;dtype&lt;/code&gt;.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">如果您需要做的不仅仅是检查输入是否为空，而且您正在使用其他NumPy功能（例如索引或数学运算），则将输入强制为NumPy数组可能更有效（并且当然更常见）。 有一些不错的函数可以快速完成此任务-最重要的是&lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt; 。 这将接受您的输入，如果已经是数组，则不执行任何操作；如果是列表，元组等，则将您的输入包装到数组中，并有选择地将其转换为您选择的 &lt;code&gt;dtype&lt;/code&gt; 。 因此，它可以在任何时候都非常快，并且可以确保您只是假设输入是NumPy数组。 我们通常甚至只使用相同的名称，因为对数组的转换不会使它返回当前&lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;范围之外&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="8fb952d33272c37411f1179bd271c831539a4522" translate="yes" xml:space="preserve">
          <source>If you want to check if a list is empty:</source>
          <target state="translated">如果你想检查一个列表是否是空的。</target>
        </trans-unit>
        <trans-unit id="40e6c40dc0a9104c2eddd05cdb70a55879c0c1a5" translate="yes" xml:space="preserve">
          <source>If you want to check whether all the values in list is empty. However it will be &lt;code&gt;True&lt;/code&gt; for an empty list:</source>
          <target state="translated">如果要检查列表中的所有值是否为空。 但是，对于空列表，它将为 &lt;code&gt;True&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="536f093032dabe47659c67529b21e5619964a16e" translate="yes" xml:space="preserve">
          <source>If you want to use both cases together:</source>
          <target state="translated">如果你想同时使用这两种情况。</target>
        </trans-unit>
        <trans-unit id="8841134ee2ab08cfb3f81a5ebb9e79b04b2bff1d" translate="yes" xml:space="preserve">
          <source>If you're not sure whether it might be a &lt;code&gt;list&lt;/code&gt;, a NumPy array, or something else, you could combine this approach with &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;the answer @dubiousjim gives&lt;/a&gt; to make sure the right test is used for each type.  Not very &quot;pythonic&quot;, but it turns out that NumPy intentionally broke pythonicity in at least this sense.</source>
          <target state="translated">如果不确定是 &lt;code&gt;list&lt;/code&gt; ，NumPy数组还是其他类型，可以将此方法与&lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;@dubiousjim给出的答案&lt;/a&gt;结合使用，以确保对每种类型使用正确的测试。 并不是很&amp;ldquo; pythonic&amp;rdquo;，但事实证明，NumPy至少在这种意义上有意破坏了pythonicity。</target>
        </trans-unit>
        <trans-unit id="428f7e34ea9af326d1a0f2aad6f147c45fdb55ac" translate="yes" xml:space="preserve">
          <source>In Python, &lt;strong&gt;empty containers&lt;/strong&gt; such as lists,tuples,sets,dicts,variables etc are seen as &lt;code&gt;False&lt;/code&gt;. One could simply treat the list as a predicate (&lt;em&gt;returning a Boolean value&lt;/em&gt;). And  a &lt;code&gt;True&lt;/code&gt; value would indicate that it's non-empty.</source>
          <target state="translated">在Python中， &lt;strong&gt;空容器（&lt;/strong&gt;例如列表，元组，集合，字典，变量等）被视为 &lt;code&gt;False&lt;/code&gt; 。 可以简单地将列表视为谓词（ &lt;em&gt;返回布尔值&lt;/em&gt; ）。 并且 &lt;code&gt;True&lt;/code&gt; 值表示它是非空的。</target>
        </trans-unit>
        <trans-unit id="a160b38c575aa7abd79420a97f3bbb8f340afc2a" translate="yes" xml:space="preserve">
          <source>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just &lt;code&gt;is_empty(any_structure)&lt;/code&gt;.</source>
          <target state="translated">它可以用于任何data_structure，例如列表，元组，字典等。 通过这些，您可以仅使用 &lt;code&gt;is_empty(any_structure)&lt;/code&gt; 多次调用它。</target>
        </trans-unit>
        <trans-unit id="c32bab15a2ee7ad8ba7c6641bb23e238358e1623" translate="yes" xml:space="preserve">
          <source>It is sometimes good to test for &lt;code&gt;None&lt;/code&gt; and for emptiness separately as those are two different states. The code above produces the following output:</source>
          <target state="translated">有时最好分别测试&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 和&amp;ldquo;空&amp;rdquo;，因为这是两个不同的状态。 上面的代码产生以下输出：</target>
        </trans-unit>
        <trans-unit id="c5d891bd3646d03ddb9c17a5be09027bd036ced8" translate="yes" xml:space="preserve">
          <source>It's true that &lt;code&gt;if not a:&lt;/code&gt; doesn't distinguish empty lists from &lt;code&gt;None&lt;/code&gt;, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know &lt;em&gt;what&lt;/em&gt; you want to be explicit about, so you can test for exactly that. For example, &lt;code&gt;if not a and a is not None:&lt;/code&gt; means &quot;anything falsey except None&quot;, while &lt;code&gt;if len(a) != 0:&lt;/code&gt; means &quot;only empty sequences&amp;mdash;and anything besides a sequence is an error here&quot;, and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</source>
          <target state="translated">的确， &lt;code&gt;if not a:&lt;/code&gt; 不会将空列表与 &lt;code&gt;None&lt;/code&gt; ，数字0或空元组，用户创建的空集合类型，用户创建的非相当集合类型或单元素NumPy数组区分开充当带有虚假值等的标量。有时，明确这一点很重要。 在这种情况下，您知道要明确说明的内容，因此可以进行准确测试。 例如， &lt;code&gt;if not a and a is not None:&lt;/code&gt; 表示&amp;ldquo;除None以外为假&amp;rdquo;，而 &lt;code&gt;if len(a) != 0:&lt;/code&gt; &amp;ldquo;仅空序列-除序列外的其他内容在此处都是错误&amp;rdquo;，依此类推。 除了准确测试要测试的内容外，这还向读者表明该测试很重要。</target>
        </trans-unit>
        <trans-unit id="c7b0318d9faa41f53e682c3bbc37b5cfd1c0e726" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;has a similar notion of truthy/falsy&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;具有类似true / falsy的概念&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5142fae3c5db9d1461a71db588118a77074a605f" translate="yes" xml:space="preserve">
          <source>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</source>
          <target state="translated">已经给出了很多答案,而且很多都是相当不错的。我只是想补充一下,检查</target>
        </trans-unit>
        <trans-unit id="bf1a55fc2dfc2923592d18290d8210ac0f8e2701" translate="yes" xml:space="preserve">
          <source>Method 1 (Preferred):</source>
          <target state="translated">方法1(优选):</target>
        </trans-unit>
        <trans-unit id="4e958d4a4b4554ff4a60439e18120188e8915232" translate="yes" xml:space="preserve">
          <source>Method 2 :</source>
          <target state="translated">方法二:</target>
        </trans-unit>
        <trans-unit id="5c1700aea4db454bd25188c6878b4574d94f6e62" translate="yes" xml:space="preserve">
          <source>Method 3:</source>
          <target state="translated">方法三:</target>
        </trans-unit>
        <trans-unit id="4163466ea446b9664c1bdbc1d45e8ba19c39c8f9" translate="yes" xml:space="preserve">
          <source>No one seems to have addressed questioning your &lt;em&gt;need&lt;/em&gt; to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</source>
          <target state="translated">似乎没有人提出质疑，要求您首先测试该列表。 因为您没有提供其他上下文，所以我可以想象您可能不需要首先进行此检查，但是您不熟悉Python中的列表处理。</target>
        </trans-unit>
        <trans-unit id="2ec0c5d4d7981ce6e9ff1b380ca6846b74422e54" translate="yes" xml:space="preserve">
          <source>Note: a string is considered to be iterable. - add &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; if you want the empty string to be excluded</source>
          <target state="translated">注意：字符串被认为是可迭代的。 -如果要排除空字符串，请添加 &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18b642e9538492bb0944a34dd8a2e506f10e19b4" translate="yes" xml:space="preserve">
          <source>Now let's look at the case for an unempty list:</source>
          <target state="translated">现在我们来看看失业人员名单的情况。</target>
        </trans-unit>
        <trans-unit id="9ca01a949b72339ff024541a16acb34d56d5458e" translate="yes" xml:space="preserve">
          <source>Now you can use:</source>
          <target state="translated">现在你可以使用了。</target>
        </trans-unit>
        <trans-unit id="9b84859507e274233a23af1cd06d846a49723981" translate="yes" xml:space="preserve">
          <source>Of course, do &lt;strong&gt;not&lt;/strong&gt; use &lt;code&gt;bool&lt;/code&gt; in &lt;code&gt;if&lt;/code&gt; (i.e., &lt;code&gt;if bool(L):&lt;/code&gt;) because it's implied. But, for the cases when &quot;is not empty&quot; is explicitly needed as a function, &lt;code&gt;bool&lt;/code&gt; is the best choice.</source>
          <target state="translated">当然，不要在 &lt;code&gt;if&lt;/code&gt; 中使用 &lt;code&gt;bool&lt;/code&gt; （即 &lt;code&gt;if bool(L):&lt;/code&gt; ),因为这是隐含的。 但是，对于明确需要&amp;ldquo;不为空&amp;rdquo;作为函数的情况， &lt;code&gt;bool&lt;/code&gt; 是最佳选择。</target>
        </trans-unit>
        <trans-unit id="d62a34899b1789ad0de88de972782e3233f85466" translate="yes" xml:space="preserve">
          <source>Other methods don't work for NumPy arrays</source>
          <target state="translated">其他方法对NumPy数组不起作用</target>
        </trans-unit>
        <trans-unit id="7508036889deb522e760a0d2d530c531b6a2002f" translate="yes" xml:space="preserve">
          <source>PEP 8</source>
          <target state="translated">PEP 8</target>
        </trans-unit>
        <trans-unit id="3ecde6cd436f098db79f5599fdb3667956fcbf60" translate="yes" xml:space="preserve">
          <source>Place the list in a boolean context (for example, with an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement). It will test &lt;code&gt;False&lt;/code&gt; if it is empty, and &lt;code&gt;True&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">将列表放在布尔上下文中（例如，使用 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 语句）。 如果为空，它将测试 &lt;code&gt;False&lt;/code&gt; ，否则为 &lt;code&gt;True&lt;/code&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="d2931340025c9c2fd67ac84f3da9bf695821b222" translate="yes" xml:space="preserve">
          <source>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</source>
          <target state="translated">Python 代码,以及 Python 社区,都有很强的成语。遵循这些成语可以让你的代码更容易让有Python经验的人阅读。而当你违反了这些成语,这就是一个强烈的信号。</target>
        </trans-unit>
        <trans-unit id="d64b6eced566b47a6b2fd33e4bc9acd66737c2c8" translate="yes" xml:space="preserve">
          <source>Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly.</source>
          <target state="translated">Python 是用 C 语言编写的;它在 C 语言层使用逻辑。你用 Python 编写的任何东西都会慢一些。除非你直接使用 Python 中内置的机制,否则它很可能会慢上几个数量级。</target>
        </trans-unit>
        <trans-unit id="420e21b5db5cbb25f52fe0a4ec446fd398e6e2c3" translate="yes" xml:space="preserve">
          <source>Response to comments:</source>
          <target state="translated">对意见的答复:</target>
        </trans-unit>
        <trans-unit id="ea5008a4db7f66da07d14fae6d752831a2ea6498" translate="yes" xml:space="preserve">
          <source>Short Answer:</source>
          <target state="translated">简答:</target>
        </trans-unit>
        <trans-unit id="df611a40b52b245a7619d867739b3da4fbcc5aa9" translate="yes" xml:space="preserve">
          <source>Simple way is checking the length is equal zero.</source>
          <target state="translated">简单的方法是检查长度是否等于零。</target>
        </trans-unit>
        <trans-unit id="799b8c4046e8b1c2ade9b021de07a884f7f35ef8" translate="yes" xml:space="preserve">
          <source>Simply use is_empty() or make function like:-</source>
          <target state="translated">只需使用is_empty()或制作函数如:-。</target>
        </trans-unit>
        <trans-unit id="4259f87fbbe70d265110f62571c4d8eb3fa4ff0c" translate="yes" xml:space="preserve">
          <source>So instead of this:</source>
          <target state="translated">所以用这个代替了。</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="78307d3a12ed5a2b855d5a3f147d8f6260767c8c" translate="yes" xml:space="preserve">
          <source>The &quot;Pythonic&quot; way is a much simpler and faster check since the length of the list is cached in the object instance header:</source>
          <target state="translated">&quot;Pythonic &quot;的方式是一种更简单、更快捷的检查方式,因为列表的长度是在对象实例头中缓存的。</target>
        </trans-unit>
        <trans-unit id="cce1f662637f486e769a258aed0d1f1480d3aae4" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 1</source>
          <target state="translated">&quot;蟒蛇式 &quot;的方法不行了。第一部分</target>
        </trans-unit>
        <trans-unit id="a62e97267f48afa3faa3d59f99bd87e92a95b78d" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 2</source>
          <target state="translated">&quot;蟒蛇式 &quot;的方法行不通。第二部分</target>
        </trans-unit>
        <trans-unit id="228125c176323a97205fc40f5c53dc9e1b8cb415" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way fails with NumPy arrays because NumPy tries to cast the array to an array of &lt;code&gt;bool&lt;/code&gt;s, and &lt;code&gt;if x&lt;/code&gt; tries to evaluate all of those &lt;code&gt;bool&lt;/code&gt;s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a &lt;code&gt;ValueError&lt;/code&gt;:</source>
          <target state="translated">NumPy数组的&amp;ldquo; pythonic&amp;rdquo;方法失败，因为NumPy尝试将数组转换为 &lt;code&gt;bool&lt;/code&gt; 的数组，并且 &lt;code&gt;if x&lt;/code&gt; 尝试一次为某种聚合真值评估所有这些 &lt;code&gt;bool&lt;/code&gt; s。 但这没有任何意义，因此您会遇到 &lt;code&gt;ValueError&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a3f21db414612559e4bd0aa2e9d4ccdd7620a0b" translate="yes" xml:space="preserve">
          <source>The numpythonic way</source>
          <target state="translated">虚无缥缈的方式</target>
        </trans-unit>
        <trans-unit id="839d95ab808bb10053fa88f4716855013b528654" translate="yes" xml:space="preserve">
          <source>The pythonic way to do it is from the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;PEP 8 style guide&lt;/a&gt; (where &lt;strong&gt;Yes&lt;/strong&gt; means &amp;ldquo;recommended&amp;rdquo; and &lt;strong&gt;No&lt;/strong&gt; means &amp;ldquo;not recommended&amp;rdquo;):</source>
          <target state="translated">pythonic的方法来自&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;PEP 8样式指南&lt;/a&gt; （ &lt;strong&gt;&amp;ldquo;&lt;/strong&gt;是&amp;rdquo;表示&amp;ldquo;推荐&amp;rdquo;，&amp;ldquo; &lt;strong&gt;否&amp;rdquo;&lt;/strong&gt;表示&amp;ldquo;不推荐&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="419ef69c944861f78388669cc2be094309f545d1" translate="yes" xml:space="preserve">
          <source>The second way is a &lt;strong&gt;&lt;code&gt;more pythonic&lt;/code&gt;&lt;/strong&gt; one. This method is an implicit way of checking and much more preferable than the previous one.</source>
          <target state="translated">第二种方法是&lt;strong&gt; &lt;code&gt;more pythonic&lt;/code&gt; &lt;/strong&gt; 。 此方法是一种隐式检查方法，比以前的方法更可取。</target>
        </trans-unit>
        <trans-unit id="26bb1f3155a5dcb9fceb486c2448558698ce4333" translate="yes" xml:space="preserve">
          <source>The truth value of an empty list is &lt;code&gt;False&lt;/code&gt; whereas for a non-empty list it is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">空列表的真值是 &lt;code&gt;False&lt;/code&gt; ,而非空列表的真值是 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbc6e8440ee75ab717bf6ec8f427152001e12352" translate="yes" xml:space="preserve">
          <source>Then it must call the function, load &lt;code&gt;0&lt;/code&gt;, and do the equality comparison in Python (instead of with C):</source>
          <target state="translated">然后，它必须调用该函数，加载 &lt;code&gt;0&lt;/code&gt; ，并在Python中（而不是C）进行相等比较：</target>
        </trans-unit>
        <trans-unit id="d90a30ab848b090999fc31f8d7530affde230d5d" translate="yes" xml:space="preserve">
          <source>These are correct in their respective other languages. And this is even semantically correct in Python.</source>
          <target state="translated">这些在它们各自的其他语言中都是正确的。而这在Python中甚至在语义上也是正确的。</target>
        </trans-unit>
        <trans-unit id="e237e40349b5d41720ad35c29c2a146f51cf9485" translate="yes" xml:space="preserve">
          <source>This has the benefit of handling any contents of &lt;strong&gt;a&lt;/strong&gt;, while not requiring a specific check for emptiness.  If &lt;strong&gt;a&lt;/strong&gt; is empty, the dependent block will not execute and the interpreter will fall through to the next line.</source>
          <target state="translated">这样的好处是可以处理的任何内容，而无需对空性进行特定检查。 如果&lt;strong&gt;a&lt;/strong&gt;为空，则将不执行从属块，并且解释器将进入下一行。</target>
        </trans-unit>
        <trans-unit id="e07f7e1c2e6c131a4dd992f68429d70bd4456992" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;code&gt;PyObject&lt;/code&gt; that adds the &lt;code&gt;ob_size&lt;/code&gt; field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; macro.</source>
          <target state="translated">这是 &lt;code&gt;PyObject&lt;/code&gt; 的扩展，添加了 &lt;code&gt;ob_size&lt;/code&gt; 字段。 这仅用于具有长度概念的对象。 此类型通常不会出现在Python / C API中。 它对应于通过扩展 &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; 宏定义的字段。</target>
        </trans-unit>
        <trans-unit id="834cb8e0db15a3974ebe92a788d932cf5c816ae7" translate="yes" xml:space="preserve">
          <source>This way it's 100% clear that &lt;code&gt;li&lt;/code&gt; is a sequence (list) and we want to test its size. My problem with &lt;code&gt;if not li: ...&lt;/code&gt; is that it gives the false impression that &lt;code&gt;li&lt;/code&gt; is a boolean variable.</source>
          <target state="translated">这样，就可以100％清楚地知道 &lt;code&gt;li&lt;/code&gt; 是一个序列（列表），我们想测试其大小。 &lt;code&gt;if not li: ...&lt;/code&gt; 我的问题是：...会给人一种错误的印象，即 &lt;code&gt;li&lt;/code&gt; 是一个布尔变量。</target>
        </trans-unit>
        <trans-unit id="517b32f316ce0d136fe88818f855b9745999ba35" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;x.size&lt;/code&gt; check work in all cases I see on this page.</source>
          <target state="translated">这将使 &lt;code&gt;x.size&lt;/code&gt; 检查在我在此页面上看到的所有情况下均有效。</target>
        </trans-unit>
        <trans-unit id="166295003ca1870a3de65a50bfe6d0b14501234e" translate="yes" xml:space="preserve">
          <source>To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a &lt;strong&gt;&lt;code&gt;less pythonic&lt;/code&gt;&lt;/strong&gt; way):</source>
          <target state="translated">要检查列表是否为空，可以使用以下两种方法。 但是请记住，我们应该避免显式检查序列类型的方法（这是一种&lt;strong&gt; &lt;code&gt;less pythonic&lt;/code&gt; &lt;/strong&gt;方法）：</target>
        </trans-unit>
        <trans-unit id="d88775ff0c4e2103146fa814bf595e1bad3bd121" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;len&lt;/code&gt; can give unexpected results</source>
          <target state="translated">使用 &lt;code&gt;len&lt;/code&gt; 可能会产生意想不到的结果</target>
        </trans-unit>
        <trans-unit id="3210b647602906055a2ea6630c8e3fee2353fdbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;implicit booleanness&lt;/a&gt; of the empty &lt;code&gt;list&lt;/code&gt; is quite pythonic.</source>
          <target state="translated">使用空 &lt;code&gt;list&lt;/code&gt; 的&lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;隐式布尔&lt;/a&gt;值是非常Python的。</target>
        </trans-unit>
        <trans-unit id="e4100216a9aee376fd77c24841324702e83c57b2" translate="yes" xml:space="preserve">
          <source>Very handy and useful.</source>
          <target state="translated">很方便,也很有用。</target>
        </trans-unit>
        <trans-unit id="bec8251989ae95f17e7917e7a4667d9b939024a6" translate="yes" xml:space="preserve">
          <source>We can see there's a bit of linear cost for each additional &lt;code&gt;not&lt;/code&gt; here. We want to see the costs, &lt;em&gt;ceteris paribus&lt;/em&gt;, that is, all else equal - where all else is minimized as far as possible:</source>
          <target state="translated">我们可以看到，每增加一个，这里都有一些线性成本。 我们希望看到成本&lt;em&gt;ceteris paribus&lt;/em&gt; ，即&lt;em&gt;其他&lt;/em&gt;所有条件都相等-尽可能将其他所有条件最小化：</target>
        </trans-unit>
        <trans-unit id="0a1d52cb17cca8e7191f36986558bb72f7957e50" translate="yes" xml:space="preserve">
          <source>We see that &lt;em&gt;either&lt;/em&gt; checking for length with the builtin function &lt;code&gt;len&lt;/code&gt; compared to &lt;code&gt;0&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; checking against an empty list is &lt;strong&gt;much&lt;/strong&gt; less performant than using the builtin syntax of the language as documented.</source>
          <target state="translated">我们看到， &lt;em&gt;使用&lt;/em&gt;内置函数 &lt;code&gt;len&lt;/code&gt; 而&lt;em&gt;不是0来&lt;/em&gt;检查长度， &lt;em&gt;或者&lt;/em&gt;检查一个空列表都比使用所记录的语言的内置语法&lt;strong&gt;要&lt;/strong&gt;差得多。</target>
        </trans-unit>
        <trans-unit id="93defcec033f02c7813b4fa2999f8fa8e135291c" translate="yes" xml:space="preserve">
          <source>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</source>
          <target state="translated">我们应该期望标准库的代码应该尽可能的执行和正确。但为什么是这样,我们为什么需要这样的指导呢?</target>
        </trans-unit>
        <trans-unit id="53f50b6170acffe67cc4616bcd8c695dc5c3e587" translate="yes" xml:space="preserve">
          <source>What brought me here is a special use-case: I actually wanted a &lt;em&gt;function&lt;/em&gt; to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough):</source>
          <target state="translated">带给我的是一个特殊的用例：我实际上想要一个&lt;em&gt;函数&lt;/em&gt;来告诉我列表是否为空。 我想避免在此处编写自己的函数或使用lambda表达式（因为它似乎应该足够简单）：</target>
        </trans-unit>
        <trans-unit id="6c52a1ca8670775a8c8a00491e8712ffcaca818c" translate="yes" xml:space="preserve">
          <source>What we can see here is that it makes little difference whether you pass in an actual &lt;code&gt;bool&lt;/code&gt; to the condition check or the list itself, and if anything, giving the list, as is, is faster.</source>
          <target state="translated">我们在这里看到的是，无论是将实际 &lt;code&gt;bool&lt;/code&gt; 传递给条件检查还是将列表本身传递给您，都没有什么区别，并且如果有的话，按原样提供列表也更快。</target>
        </trans-unit>
        <trans-unit id="0a4d3c26f7312a3bcafab015f36e0c94e6e8659e" translate="yes" xml:space="preserve">
          <source>Why check at all?</source>
          <target state="translated">为什么要检查?</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="3ecc4c96e7de4be0cda6aa9f38dc351865be20e7" translate="yes" xml:space="preserve">
          <source>You can even try using bool() like this</source>
          <target state="translated">你甚至可以尝试使用像这样的bool()</target>
        </trans-unit>
        <trans-unit id="f65dd7b083f4ea2c1ee4f439f364acdec6b47258" translate="yes" xml:space="preserve">
          <source>You can get away without the explicit type check, but only if the surrounding context already assures you that &lt;code&gt;a&lt;/code&gt; is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a &lt;code&gt;TypeError&lt;/code&gt; if you call &lt;code&gt;len&lt;/code&gt; on a value for which it's undefined) that you're prepared to handle. In general, the &quot;pythonic&quot; conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to &lt;em&gt;think&lt;/em&gt; about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on &lt;code&gt;len&lt;/code&gt; or the boolean typecast may not do precisely what you're expecting.</source>
          <target state="translated">您无需进行显式的类型检查就可以逃脱，但前提是周围的上下文已经向您保证了 &lt;code&gt;a&lt;/code&gt; 是您准备处理的类型的值，或者如果您确定不准备处理的类型是将会引发您准备处理的错误（例如，如果对未定义的值调用 &lt;code&gt;len&lt;/code&gt; 则 &lt;code&gt;TypeError&lt;/code&gt; ）。 通常，&amp;ldquo; pythonic&amp;rdquo;约定似乎走到了最后。 像鸭子一样挤压它，如果它不知道如何发出嘎嘎声，则让它引发DuckError。 但是，您仍然必须&lt;em&gt;考虑&lt;/em&gt;要进行哪种类型的假设，以及您是否没有准备好正确处理的情况是否会在正确的地方出错。 Numpy数组是一个很好的例子，仅盲目地依赖 &lt;code&gt;len&lt;/code&gt; 或布尔类型转换可能无法完全满足您的期望。</target>
        </trans-unit>
        <trans-unit id="9083cd48fae65c5b68f6712180202c73821b23fa" translate="yes" xml:space="preserve">
          <source>You need to be careful with NumPy arrays, because other methods that work fine for &lt;code&gt;list&lt;/code&gt;s or other standard containers fail for NumPy arrays.  I explain why below, but in short, the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;preferred method&lt;/a&gt; is to use &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">您需要注意NumPy数组，因为其他适用于 &lt;code&gt;list&lt;/code&gt; 或其他标准容器的方法对NumPy数组均无效。 我在下面解释原因，但总之， &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;首选方法&lt;/a&gt;是使用 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7d227705c28851b3cabdba2c9c370a4f7063204" translate="yes" xml:space="preserve">
          <source>Your duckCollection should implement &lt;code&gt;__nonzero__&lt;/code&gt; or &lt;code&gt;__len__&lt;/code&gt; so the if a: will work without problems.</source>
          <target state="translated">您的duckCollection应该实现 &lt;code&gt;__nonzero__&lt;/code&gt; 或 &lt;code&gt;__len__&lt;/code&gt; ,因此if a：可以正常工作。</target>
        </trans-unit>
        <trans-unit id="e1f11fedb84b9948d72cba30d27c4ba1e5b96b6b" translate="yes" xml:space="preserve">
          <source>a little more practical:</source>
          <target state="translated">更实际一点。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="5fa43287b1c5b62b65463b926344285e74e283b5" translate="yes" xml:space="preserve">
          <source>and shertest version:</source>
          <target state="translated">和最漂亮的版本。</target>
        </trans-unit>
        <trans-unit id="83ab88ee561c2c3fbf9a72f4e64edd6d102bc31c" translate="yes" xml:space="preserve">
          <source>any empty mapping, for example, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">任何空映射，例如 &lt;code&gt;{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2952616e90efb7a6dd44095c44dfdd2377bc3ab" translate="yes" xml:space="preserve">
          <source>any empty sequence, for example, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">任何空序列，例如 &lt;code&gt;''&lt;/code&gt; ， &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b131ef05b1826b4dcf14f5da963e3b8f3d60f6f6" translate="yes" xml:space="preserve">
          <source>constants defined to be false: &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">定义为false的常量： &lt;code&gt;None&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa71fa14fe89fc7eb25cd68186ad53611ebfd167" translate="yes" xml:space="preserve">
          <source>empty sequences and collections: &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;range(0)&lt;/code&gt;</source>
          <target state="translated">空序列和集合： &lt;code&gt;''&lt;/code&gt; ， &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; ， &lt;code&gt;{}&lt;/code&gt; ， &lt;code&gt;set()&lt;/code&gt; ， &lt;code&gt;range(0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="054f2c8e08dfd096608d12043bbc8cd93bbd3d80" translate="yes" xml:space="preserve">
          <source>if you only want to accept instances of particular types (and their subtypes), or with:</source>
          <target state="translated">如果你只想接受特定类型的实例(和它们的子类型),或者用。</target>
        </trans-unit>
        <trans-unit id="bbe92aa90ac3da927a82d780633d2c79550b5147" translate="yes" xml:space="preserve">
          <source>instances of user-defined classes, if the class defines a &lt;code&gt;__bool__()&lt;/code&gt; or &lt;code&gt;__len__()&lt;/code&gt; method, when that method returns the integer zero or bool value &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">用户定义的类的实例，如果该类定义了 &lt;code&gt;__bool__()&lt;/code&gt; 或 &lt;code&gt;__len__()&lt;/code&gt; 方法，则该方法返回整数零或布尔值 &lt;code&gt;False&lt;/code&gt; 时 。</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">或者是这样的。</target>
        </trans-unit>
        <trans-unit id="5fe84e072cb8774215db86ddfc171c8aa9283127" translate="yes" xml:space="preserve">
          <source>produces expected</source>
          <target state="translated">产生预期的</target>
        </trans-unit>
        <trans-unit id="bdb401ea8d165ea2005c10c5877c586d8207bf1a" translate="yes" xml:space="preserve">
          <source>returns 1, even though the array has zero elements.</source>
          <target state="translated">返回1,即使数组有0个元素。</target>
        </trans-unit>
        <trans-unit id="9f03e5ffbf02bb878e6dd52843870f4e01cc42fb" translate="yes" xml:space="preserve">
          <source>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</source>
          <target state="translated">第一个测试是对@Mike的回答的回应,上面。第三行也可以换成:</target>
        </trans-unit>
        <trans-unit id="a818933ef67b2d17d00dabdb02f08102734ba6d7" translate="yes" xml:space="preserve">
          <source>to check if the list is empty</source>
          <target state="translated">来检查列表是否为空</target>
        </trans-unit>
        <trans-unit id="113a8713eff230494f7adff7cabd13b33e7a718c" translate="yes" xml:space="preserve">
          <source>we could use a simple if else:</source>
          <target state="translated">我们可以用一个简单的if else。</target>
        </trans-unit>
        <trans-unit id="75e6b798f41cc1b686d5e5e68f072d8fc897174b" translate="yes" xml:space="preserve">
          <source>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as &quot;pythonic&quot;---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where &lt;code&gt;a&lt;/code&gt; is, for example, &lt;code&gt;False&lt;/code&gt;, you need a test more restrictive than just &lt;code&gt;if not a:&lt;/code&gt;. You could use something like this:</source>
          <target state="translated">被投票为-1。 我不确定这是否是因为读者反对该策略或认为答案对所提供的内容没有帮助。 我会假装是后者，因为-不管什么都算是&amp;ldquo; pythonic&amp;rdquo;-这都是正确的策略。 除非您已经排除或准备处理 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; （例如False）的情况，否则您需要的测试要比 &lt;code&gt;if not a:&lt;/code&gt; 更严格。 您可以使用如下形式：</target>
        </trans-unit>
        <trans-unit id="9c021d12abb7b3e2b39cca48ff8eeeb38bb02d18" translate="yes" xml:space="preserve">
          <source>will also pass for &lt;code&gt;None&lt;/code&gt; and other types of empty structures. If you truly want to check for an empty list, you can do this:</source>
          <target state="translated">也将通过 &lt;code&gt;None&lt;/code&gt; 和其他类型的空结构。 如果您确实要检查一个空列表，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="0e6f0e52997217d3b5a709de67763a194e319b26" translate="yes" xml:space="preserve">
          <source>zero of any numeric type, for example, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;.</source>
          <target state="translated">任何数字类型的零，例如 &lt;code&gt;0j&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a325962fa4501e445c5fc397f589278bbc1b016" translate="yes" xml:space="preserve">
          <source>zero of any numeric type: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;, &lt;code&gt;Decimal(0)&lt;/code&gt;, &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</source>
          <target state="translated">任何数字类型的零： &lt;code&gt;0j&lt;/code&gt; ， &lt;code&gt;Decimal(0)&lt;/code&gt; ， &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
