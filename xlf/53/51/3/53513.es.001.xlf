<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/53513">
    <body>
      <group id="53513">
        <trans-unit id="fa6087ea829d2efe469e42d5b4ea7ef6c710c3b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt;&lt;code&gt;len()&lt;/code&gt; is an O(1) operation&lt;/a&gt; for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</source>
          <target state="translated">&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt; &lt;code&gt;len()&lt;/code&gt; es una operaci&amp;oacute;n O (1)&lt;/a&gt; para listas, cadenas, dictos y conjuntos de Python. Python realiza un seguimiento interno de la cantidad de elementos en estos contenedores.</target>
        </trans-unit>
        <trans-unit id="85fd292fdea964654b12fcc3bff501372a02fc3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;Patrick's (accepted) answer&lt;/a&gt; is right: &lt;code&gt;if not a:&lt;/code&gt; is the right way to do it. &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;Harley Holcombe's answer&lt;/a&gt; is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom&amp;mdash;even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;La respuesta de Patrick (aceptada)&lt;/a&gt; es correcta: &lt;code&gt;if not a:&lt;/code&gt; es la forma correcta de hacerlo. &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;La respuesta de Harley Holcombe&lt;/a&gt; es correcta, esto est&amp;aacute; en la gu&amp;iacute;a de estilo PEP 8. Pero lo que ninguna de las respuestas explica es por qu&amp;eacute; es una buena idea seguir el modismo, incluso si personalmente encuentra que no es lo suficientemente expl&amp;iacute;cito o confuso para los usuarios de Ruby o lo que sea.</target>
        </trans-unit>
        <trans-unit id="f6bd068dee72f5e7acd72d046b51628d73431616" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt;, the official Python style guide for Python code in Python's standard library, asserts:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt; , la gu&amp;iacute;a de estilo oficial de Python para el c&amp;oacute;digo Python en la biblioteca est&amp;aacute;ndar de Python, afirma:</target>
        </trans-unit>
        <trans-unit id="709c05e03db9fe7106ff167bae3e20510ada6c6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; The pretty simple pythonic way:</source>
          <target state="translated">&lt;strong&gt;1)&lt;/strong&gt; La forma pit&amp;oacute;nica bastante simple:</target>
        </trans-unit>
        <trans-unit id="73bff0478225a1ca5de41c8041fd2f172d65b5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; A much explicit way: using the &lt;code&gt;len()&lt;/code&gt; to find the length and check if it equals to &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;2)&lt;/strong&gt; Una forma muy expl&amp;iacute;cita: usando &lt;code&gt;len()&lt;/code&gt; para encontrar la longitud y verificar si es igual a &lt;code&gt;0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9d4a74112f8906073526e0491135de335a7db27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt; Or comparing it to an anonymous empty list:</source>
          <target state="translated">&lt;strong&gt;3)&lt;/strong&gt; O compar&amp;aacute;ndolo con una lista an&amp;oacute;nima vac&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="406daadaa5d41723954f852ca3012418a893aa74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4)&lt;/strong&gt; Another yet &lt;em&gt;silly&lt;/em&gt; way to do is using &lt;code&gt;exception&lt;/code&gt; and &lt;code&gt;iter()&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;4)&lt;/strong&gt; Otra forma de hacerlo es usar la &lt;code&gt;exception&lt;/code&gt; y &lt;code&gt;iter()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d2003a249df2249cead04ad47fd9076516a663f" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is the first google hit for &quot;python test empty array&quot; and similar queries, plus other people seem to be generalizing the question beyond just lists, so I thought I'd add a caveat for a different type of sequence that a lot of people might use.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Este es el primer &amp;eacute;xito de Google para &quot;matriz vac&amp;iacute;a de prueba de Python&quot; y consultas similares, adem&amp;aacute;s de que otras personas parecen estar generalizando la pregunta m&amp;aacute;s all&amp;aacute; de las listas, por lo que pens&amp;eacute; en agregar una advertencia para un tipo diferente de secuencia que mucha gente Puede usar.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e08157bc06e9b1d4da704ba91099e16c06508dab" translate="yes" xml:space="preserve">
          <source>@Daren Thomas</source>
          <target state="translated">@Daren Thomas</target>
        </trans-unit>
        <trans-unit id="dbf83e4117a99476070d823064700dc3ed352dc3" translate="yes" xml:space="preserve">
          <source>All values other than what is listed here are considered &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">Todos los valores que no sean los que se enumeran aqu&amp;iacute; se consideran &lt;code&gt;True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a2a7eec8c7ee8d914fe13445e4f282e1b2a7082" translate="yes" xml:space="preserve">
          <source>Although it's worth nothing that &lt;code&gt;None&lt;/code&gt; is falsy. So if you don't want to separate test for &lt;code&gt;None&lt;/code&gt;-ness, you don't have to do that.</source>
          <target state="translated">Aunque no vale nada que &lt;code&gt;None&lt;/code&gt; sea ​​falso. Entonces, si no desea separar la prueba de &lt;code&gt;None&lt;/code&gt; , no tiene que hacer eso.</target>
        </trans-unit>
        <trans-unit id="a3eda0c093884c5cdf292a4a6958a44bd4e2a71d" translate="yes" xml:space="preserve">
          <source>An empty list is itself considered false in true value testing (see &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;python documentation&lt;/a&gt;):</source>
          <target state="translated">Una lista vac&amp;iacute;a se considera falsa en las pruebas de valor verdadero (consulte la &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;documentaci&amp;oacute;n de Python&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="ab5f88a40a649b5bd874e7e3cf70712fe8fcfbfb" translate="yes" xml:space="preserve">
          <source>And for the &lt;code&gt;[] == []&lt;/code&gt; it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</source>
          <target state="translated">Y para &lt;code&gt;[] == []&lt;/code&gt; tiene que construir una lista innecesaria y luego, nuevamente, hacer la operaci&amp;oacute;n de comparaci&amp;oacute;n en la m&amp;aacute;quina virtual de Python (en lugar de C)</target>
        </trans-unit>
        <trans-unit id="44044d9b0333bc1e2793c401ceb8f5611f29a99f" translate="yes" xml:space="preserve">
          <source>And the datamodel documentation:</source>
          <target state="translated">Y la documentación del modelo de datos:</target>
        </trans-unit>
        <trans-unit id="45af135cc0b7fd22346b0a3dce703ee3a4f1fac5" translate="yes" xml:space="preserve">
          <source>And users of lazy languages may be tempted to do this:</source>
          <target state="translated">Y los usuarios de lenguas perezosas pueden sentirse tentados a hacerlo:</target>
        </trans-unit>
        <trans-unit id="6202056bf6b3d838f4ff8c5b7307d6357e08439f" translate="yes" xml:space="preserve">
          <source>And, of course, there is a very natural way to do it:</source>
          <target state="translated">Y,por supuesto,hay una forma muy natural de hacerlo:</target>
        </trans-unit>
        <trans-unit id="ff47252d65d441c800203256a95b3a6607509fac" translate="yes" xml:space="preserve">
          <source>As can be seen, empty list &lt;code&gt;[]&lt;/code&gt; is &lt;em&gt;falsy&lt;/em&gt;, so doing what would be done to a boolean value sounds most efficient:</source>
          <target state="translated">Como se puede ver, la lista vac&amp;iacute;a &lt;code&gt;[]&lt;/code&gt; es &lt;em&gt;falsa&lt;/em&gt; , por lo que hacer lo que se har&amp;iacute;a con un valor booleano suena m&amp;aacute;s eficiente:</target>
        </trans-unit>
        <trans-unit id="bba28c4ea8d4854a5cac4c82193c5746abc143e3" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;SciPy FAQ&lt;/a&gt;, the correct method in all cases where you know you have a NumPy array is to use &lt;code&gt;if x.size&lt;/code&gt;:</source>
          <target state="translated">Como se explica en las &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;Preguntas frecuentes de SciPy&lt;/a&gt; , el m&amp;eacute;todo correcto en todos los casos en los que sabe que tiene una matriz NumPy es usar &lt;code&gt;if x.size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c2a373c95098f9c06da7f59b6f9464570c1f1907" translate="yes" xml:space="preserve">
          <source>Being inspired by @dubiousjim's solution, I propose to use an additional general check of whether is it something iterable</source>
          <target state="translated">Inspirándome en la solución de @dubiousjim,propongo usar un chequeo general adicional de si es algo iterable</target>
        </trans-unit>
        <trans-unit id="3ab76bc795d839d5beddbad54e0ccdf03bc826b1" translate="yes" xml:space="preserve">
          <source>Best way to check if a list is empty</source>
          <target state="translated">La mejor manera de comprobar si una lista está vacía</target>
        </trans-unit>
        <trans-unit id="eca779c7f85faf34e05c115f1686ec19c2ba5f60" translate="yes" xml:space="preserve">
          <source>But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the &lt;code&gt;if&lt;/code&gt; statement will &quot;work&quot;, in the sense that you don't get an error.  However, if that one element happens to be &lt;code&gt;0&lt;/code&gt; (or &lt;code&gt;0.0&lt;/code&gt;, or &lt;code&gt;False&lt;/code&gt;, ...), the &lt;code&gt;if&lt;/code&gt; statement will incorrectly result in &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">Pero al menos el caso anterior te dice que fall&amp;oacute;. Si tiene una matriz NumPy con exactamente un elemento, la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; &quot;funcionar&amp;aacute;&quot;, en el sentido de que no obtiene un error. Sin embargo, si ese elemento es &lt;code&gt;0&lt;/code&gt; (o &lt;code&gt;0.0&lt;/code&gt; , o &lt;code&gt;False&lt;/code&gt; , ...), la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; resultar&amp;aacute; incorrectamente en &lt;code&gt;False&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="daf538c97712481cae9a4d466b7c25253ade40a8" translate="yes" xml:space="preserve">
          <source>But clearly &lt;code&gt;x&lt;/code&gt; exists and is not empty!  This result is not what you wanted.</source>
          <target state="translated">&amp;iexcl;Pero claramente &lt;code&gt;x&lt;/code&gt; existe y no est&amp;aacute; vac&amp;iacute;o! Este resultado no es lo que quer&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="352789ca029b151d48e5b54d32774d3617bff5aa" translate="yes" xml:space="preserve">
          <source>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</source>
          <target state="translated">Pero lo consideramos no-pitónico porque Python apoya esta semántica directamente en la interfaz del objeto de la lista a través de la coerción booleana.</target>
        </trans-unit>
        <trans-unit id="b38bccd576f28416712521493d4fcfd148c28f3f" translate="yes" xml:space="preserve">
          <source>But when you don't have anything to be explicit about, anything other than &lt;code&gt;if not a:&lt;/code&gt; is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you &lt;em&gt;habitually&lt;/em&gt; mislead the reader like this, then when you &lt;em&gt;do&lt;/em&gt; need to make a distinction, it's going to pass unnoticed because you've been &quot;crying wolf&quot; all over your code.</source>
          <target state="translated">Pero cuando no tienes nada para ser expl&amp;iacute;cito, cualquier otra cosa que &lt;code&gt;if not a:&lt;/code&gt; es enga&amp;ntilde;oso para el lector. Est&amp;aacute;s se&amp;ntilde;alando algo tan importante cuando no lo es. (Tambi&amp;eacute;n puede hacer que el c&amp;oacute;digo sea menos flexible, m&amp;aacute;s lento o lo que sea, pero eso es menos importante). Y si &lt;em&gt;habitualmente&lt;/em&gt; enga&amp;ntilde;a al lector de esta manera, cuando necesite hacer una distinci&amp;oacute;n, pasar&amp;aacute; desapercibido porque has estado &quot;llorando lobo&quot; en todo tu c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="f3c03b9e169237bd714c4403d329565895990596" translate="yes" xml:space="preserve">
          <source>By default, an object is considered true unless its class defines
  either a &lt;code&gt;__bool__()&lt;/code&gt; method that returns &lt;code&gt;False&lt;/code&gt; or a &lt;code&gt;__len__()&lt;/code&gt; method
  that returns zero, when called with the object. Here are most of the built-in objects considered false:</source>
          <target state="translated">Por defecto, un objeto se considera verdadero a menos que su clase defina un &lt;code&gt;__bool__()&lt;/code&gt; que devuelve &lt;code&gt;False&lt;/code&gt; o un &lt;code&gt;__len__()&lt;/code&gt; que devuelve cero, cuando se llama con el objeto. Aqu&amp;iacute; est&amp;aacute;n la mayor&amp;iacute;a de los objetos incorporados considerados falsos:</target>
        </trans-unit>
        <trans-unit id="0fdcbacfeed5434a99e0a6a9a898a2d1742fc056" translate="yes" xml:space="preserve">
          <source>Called to implement the built-in function &lt;code&gt;len()&lt;/code&gt;. Should return the length of the object, an integer &amp;gt;= 0. Also, an object that doesn&amp;rsquo;t define a &lt;code&gt;__bool__()&lt;/code&gt; method and whose &lt;code&gt;__len__()&lt;/code&gt; method returns zero is considered to be false in a Boolean context.</source>
          <target state="translated">Llamado para implementar la funci&amp;oacute;n incorporada &lt;code&gt;len()&lt;/code&gt; . Debe devolver la longitud del objeto, un entero&amp;gt; = 0. Adem&amp;aacute;s, un objeto que no define un &lt;code&gt;__bool__()&lt;/code&gt; y cuyo m&amp;eacute;todo &lt;code&gt;__len__()&lt;/code&gt; devuelve cero se considera falso en un contexto booleano.</target>
        </trans-unit>
        <trans-unit id="e25864a93b493700b01d581e68d0cd82ca932f25" translate="yes" xml:space="preserve">
          <source>Called to implement truth value testing and the built-in operation &lt;code&gt;bool()&lt;/code&gt;; should return &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;. When this method is not defined,
  &lt;code&gt;__len__()&lt;/code&gt; is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither &lt;code&gt;__len__()&lt;/code&gt;
  nor &lt;code&gt;__bool__()&lt;/code&gt;, all its instances are considered true.</source>
          <target state="translated">Llamado para implementar pruebas de valor de verdad y la operaci&amp;oacute;n incorporada &lt;code&gt;bool()&lt;/code&gt; ; deber&amp;iacute;a devolver &lt;code&gt;False&lt;/code&gt; o &lt;code&gt;True&lt;/code&gt; . Cuando este m&amp;eacute;todo no est&amp;aacute; definido, se &lt;code&gt;__len__()&lt;/code&gt; , si est&amp;aacute; definido, y el objeto se considera verdadero si su resultado es distinto de cero. Si una clase no define &lt;code&gt;__len__()&lt;/code&gt; ni &lt;code&gt;__bool__()&lt;/code&gt; , todas sus instancias se consideran verdaderas.</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">Hazlo:</target>
        </trans-unit>
        <trans-unit id="f5b5eede35878f55c7d57820131de56da262d55f" translate="yes" xml:space="preserve">
          <source>Does it pay off? (Note that less time to perform an equivalent operation is better:)</source>
          <target state="translated">¿Vale la pena? (Tenga en cuenta que menos tiempo para realizar una operación equivalente es mejor:)</target>
        </trans-unit>
        <trans-unit id="373d23c12606180ec0cf1beb638fb73524fadb61" translate="yes" xml:space="preserve">
          <source>Doing what's Pythonic usually pays off in performance:</source>
          <target state="translated">Hacer lo que es pythonico suele valer la pena en la actuación:</target>
        </trans-unit>
        <trans-unit id="97f2e93e05fd80db822418cf3feec3652cf3a370" translate="yes" xml:space="preserve">
          <source>EDIT : This works with python2.7 too..</source>
          <target state="translated">EDITORIAL:Esto funciona con pitón 2.7 también...</target>
        </trans-unit>
        <trans-unit id="a76d5cc35692d4dad67addbef26267cdf67ffeed" translate="yes" xml:space="preserve">
          <source>EDIT: Another point against testing
  the empty list as False: What about
  polymorphism? You shouldn't depend on
  a list being a list. It should just
  quack like a duck - how are you going
  to get your duckCollection to quack
  ''False'' when it has no elements?</source>
          <target state="translated">Otro punto en contra de probar la lista vacía como falsa:¿Qué hay del polimorfismo? No deberías depender de que una lista sea una lista.Sólo debería graznar como un pato-¿cómo vas a conseguir que tu colección de patos grazne ''Falso'' cuando no tiene elementos?</target>
        </trans-unit>
        <trans-unit id="dcedc96969a1d0a6f2a233b8f6888a0a00ab7357" translate="yes" xml:space="preserve">
          <source>Evidence from the C source and documentation</source>
          <target state="translated">Pruebas de la fuente C y documentación</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c25e4d6b416a6cd9233a3e845e94921c7430d50d" translate="yes" xml:space="preserve">
          <source>First Python has to check the globals to see if &lt;code&gt;len&lt;/code&gt; is shadowed.</source>
          <target state="translated">Primero Python tiene que verificar las globales para ver si &lt;code&gt;len&lt;/code&gt; est&amp;aacute; sombreado.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="f3412712dcaf0e84cb53a746ad7e9f73d9013702" translate="yes" xml:space="preserve">
          <source>For example, if passed the following:</source>
          <target state="translated">Por ejemplo,si se pasa lo siguiente:</target>
        </trans-unit>
        <trans-unit id="1bad339600e3699390f0ed87a2003eee92c4dfcf" translate="yes" xml:space="preserve">
          <source>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</source>
          <target state="translated">Para la escala,aquí está el costo de llamar la función y la construcción y devolución de una lista vacía,que se podría restar de los costos de los cheques de vacío utilizados anteriormente:</target>
        </trans-unit>
        <trans-unit id="e7f942debb8d0e14241aa308336c922d6775903a" translate="yes" xml:space="preserve">
          <source>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</source>
          <target state="translated">Para las secuencias,(cuerdas,listas,tuplas),usa el hecho de que las secuencias vacías son falsas.</target>
        </trans-unit>
        <trans-unit id="bac1c52ffa1b4459d0f919bc355c6d2057242350" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;len(a) == 0&lt;/code&gt; check:</source>
          <target state="translated">Para el &lt;code&gt;len(a) == 0&lt;/code&gt; verifique:</target>
        </trans-unit>
        <trans-unit id="aaaaeb6ed2be6a7373f22ebc411776f617e21985" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;documentation&lt;/a&gt; on truth value testing:</source>
          <target state="translated">De la &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; sobre la prueba del valor de verdad:</target>
        </trans-unit>
        <trans-unit id="609634de36f52ce2e3fd7aa8ecbe7c6e9b48a3be" translate="yes" xml:space="preserve">
          <source>From python3 onwards you can use</source>
          <target state="translated">Desde python3 en adelante puedes usar</target>
        </trans-unit>
        <trans-unit id="1232457a90ed6c80cf66104828eec8c675b2e5f6" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;docs&lt;/a&gt; (and note specifically the inclusion of the empty list, &lt;code&gt;[]&lt;/code&gt;):</source>
          <target state="translated">De los &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;documentos&lt;/a&gt; (y observe espec&amp;iacute;ficamente la inclusi&amp;oacute;n de la lista vac&amp;iacute;a, &lt;code&gt;[]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="728f688a52623e6d5037d6bbdfb3e7ba80193709" translate="yes" xml:space="preserve">
          <source>From the c source in &lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include/listobject.h&lt;/a&gt;:</source>
          <target state="translated">Desde la fuente c en &lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include / listobject.h&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="683112e7d730f26c7bccb345b8ef7aaf95794090" translate="yes" xml:space="preserve">
          <source>Here are a few ways you can check if a list is empty:</source>
          <target state="translated">Aquí hay algunas formas de comprobar si una lista está vacía:</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">Espero que esto ayude.</target>
        </trans-unit>
        <trans-unit id="5ff7fbc89be7316e185d7a00a7ff3d90d022034c" translate="yes" xml:space="preserve">
          <source>How do I check if a list is empty</source>
          <target state="translated">¿Cómo puedo comprobar si una lista está vacía</target>
        </trans-unit>
        <trans-unit id="33c5d06ed9c860acea48b74dc4a823901ef3f8f1" translate="yes" xml:space="preserve">
          <source>How do I check to see if &lt;code&gt;a&lt;/code&gt; is empty?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo verifico si &lt;code&gt;a&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o?</target>
        </trans-unit>
        <trans-unit id="e5fcefe7e34c52a1195ed32056bdb1089ea254b1" translate="yes" xml:space="preserve">
          <source>How do I check to see if a is empty?</source>
          <target state="translated">¿Cómo puedo comprobar si el a está vacío?</target>
        </trans-unit>
        <trans-unit id="a9f1c0fc9cfe4503ffc9501fffdfcb4226311e22" translate="yes" xml:space="preserve">
          <source>I am not sure why there are so many complicated answers.
It's pretty clear and straightforward</source>
          <target state="translated">No estoy seguro de por qué hay tantas respuestas complicadas.Es bastante claro y directo</target>
        </trans-unit>
        <trans-unit id="25ab0752fffc84134368c44c5351c7020c10bf59" translate="yes" xml:space="preserve">
          <source>I frequently see code like this from experienced programmers new to Python:</source>
          <target state="translated">A menudo veo código como este de programadores experimentados nuevos en Python:</target>
        </trans-unit>
        <trans-unit id="70fe8a86746b4223af6f5c03bf7b7263ef48e957" translate="yes" xml:space="preserve">
          <source>I had written:</source>
          <target state="translated">Yo había escrito:</target>
        </trans-unit>
        <trans-unit id="503904ef0bb804cf7a77e21d4237ad21f29e4536" translate="yes" xml:space="preserve">
          <source>I love this way for checking list is empty or not.</source>
          <target state="translated">Me encanta esta forma porque la lista de control está vacía o no.</target>
        </trans-unit>
        <trans-unit id="6936816d820ecc9d4d156fa6961e9db56da9a535" translate="yes" xml:space="preserve">
          <source>I prefer it explicitly:</source>
          <target state="translated">Lo prefiero explícitamente:</target>
        </trans-unit>
        <trans-unit id="c822b9b00d42f96380485775d1aabfaff330ecc8" translate="yes" xml:space="preserve">
          <source>I prefer the following:</source>
          <target state="translated">Prefiero lo siguiente:</target>
        </trans-unit>
        <trans-unit id="07d7c92c83648b3dcf817f34c2fe61d11e207210" translate="yes" xml:space="preserve">
          <source>I suppose the problem is testing with timeit since just &lt;code&gt;if l:&lt;/code&gt; is sufficient but surprisingly &lt;code&gt;%timeit bool(l)&lt;/code&gt; yields 101 ns &amp;plusmn; 2.64 ns. Interesting there is no way to coerce to bool without this penalty. &lt;code&gt;%timeit l&lt;/code&gt; is useless since no conversion would occur.</source>
          <target state="translated">Supongo que el problema es probar con timeit ya que solo &lt;code&gt;if l:&lt;/code&gt; es suficiente pero sorprendentemente &lt;code&gt;%timeit bool(l)&lt;/code&gt; produce 101 ns &amp;plusmn; 2.64 ns. Interesante no hay forma de obligar a bool sin esta penalizaci&amp;oacute;n. &lt;code&gt;%timeit l&lt;/code&gt; es in&amp;uacute;til ya que no ocurrir&amp;iacute;a ninguna conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4a53819da8c55112c5bbdb5ec0a8f8c0331eed55" translate="yes" xml:space="preserve">
          <source>I would argue that the &lt;em&gt;most pythonic&lt;/em&gt; way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</source>
          <target state="translated">Yo dir&amp;iacute;a que la forma &lt;em&gt;m&amp;aacute;s pit&amp;oacute;nica&lt;/em&gt; es no verificar en absoluto, sino simplemente procesar la lista. De esa manera, har&amp;aacute; lo correcto, ya sea vac&amp;iacute;o o lleno.</target>
        </trans-unit>
        <trans-unit id="df53c7c830c1b687f914d825896b14ea3616de2b" translate="yes" xml:space="preserve">
          <source>I would point out that this is also true for the non-empty case though its pretty ugly as with &lt;code&gt;l=[]&lt;/code&gt; then &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90.6 ns &amp;plusmn; 8.3 ns, &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn; 3.09, &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5 ns &amp;plusmn; 0.372. But there is no way anyone is going to enjoy &lt;code&gt;not not l&lt;/code&gt; despite triple the speed. It looks ridiculous. But the speed wins out</source>
          <target state="translated">&lt;code&gt;%timeit len(l) != 0&lt;/code&gt; que esto tambi&amp;eacute;n es cierto para el caso no vac&amp;iacute;o, aunque es bastante feo como con &lt;code&gt;l=[]&lt;/code&gt; luego % timeit len ​​(l)! = 0 90.6 ns &amp;plusmn; 8.3 ns, &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn; 3.09, &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5 ns &amp;plusmn; 0.372. Pero no hay forma de que nadie lo disfrute, &lt;code&gt;not not l&lt;/code&gt; pesar de triplicar la velocidad. Se ve rid&amp;iacute;culo. Pero la velocidad gana</target>
        </trans-unit>
        <trans-unit id="d4412db9669f7d0df447ee505c3d56a16c1a3414" translate="yes" xml:space="preserve">
          <source>IPython magic, &lt;code&gt;%timeit&lt;/code&gt;, is not entirely useless here:</source>
          <target state="translated">La magia de IPython, &lt;code&gt;%timeit&lt;/code&gt; , no es completamente in&amp;uacute;til aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="2a07e4c6e816613379546e213ea347ae1a8fa784" translate="yes" xml:space="preserve">
          <source>If you do actually need to check the array for emptiness, the other answers are sufficient.</source>
          <target state="translated">Si realmente necesitas comprobar si la matriz está vacía,las otras respuestas son suficientes.</target>
        </trans-unit>
        <trans-unit id="125e68683b69b0a281814ca748de40fb9e6f3516" translate="yes" xml:space="preserve">
          <source>If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input &lt;em&gt;to be&lt;/em&gt; a NumPy array.  There are a few nice functions for doing this quickly &amp;mdash;&amp;nbsp;most importantly &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen &lt;code&gt;dtype&lt;/code&gt;.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">Si necesita hacer m&amp;aacute;s que simplemente verificar si la entrada est&amp;aacute; vac&amp;iacute;a, y est&amp;aacute; utilizando otras caracter&amp;iacute;sticas de NumPy como operaciones de indexaci&amp;oacute;n o matem&amp;aacute;ticas, probablemente sea m&amp;aacute;s eficiente (y ciertamente m&amp;aacute;s com&amp;uacute;n) forzar la entrada &lt;em&gt;para que sea&lt;/em&gt; una matriz NumPy. Hay algunas buenas funciones para hacer esto r&amp;aacute;pidamente, lo m&amp;aacute;s importante &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt; . Esto toma su entrada, no hace nada si ya es una matriz, o envuelve su entrada en una matriz si es una lista, tupla, etc., y opcionalmente la convierte al tipo de &lt;code&gt;dtype&lt;/code&gt; elegido. Por lo tanto, es muy r&amp;aacute;pido siempre que puede ser, y garantiza que asuma que la entrada es una matriz NumPy. Por lo general, incluso usamos el mismo nombre, ya que la conversi&amp;oacute;n a una matriz no volver&amp;aacute; a estar fuera del &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;alcance&lt;/a&gt; actual:</target>
        </trans-unit>
        <trans-unit id="8fb952d33272c37411f1179bd271c831539a4522" translate="yes" xml:space="preserve">
          <source>If you want to check if a list is empty:</source>
          <target state="translated">Si quieres comprobar si una lista está vacía:</target>
        </trans-unit>
        <trans-unit id="40e6c40dc0a9104c2eddd05cdb70a55879c0c1a5" translate="yes" xml:space="preserve">
          <source>If you want to check whether all the values in list is empty. However it will be &lt;code&gt;True&lt;/code&gt; for an empty list:</source>
          <target state="translated">Si desea verificar si todos los valores de la lista est&amp;aacute;n vac&amp;iacute;os. Sin embargo, ser&amp;aacute; &lt;code&gt;True&lt;/code&gt; para una lista vac&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="536f093032dabe47659c67529b21e5619964a16e" translate="yes" xml:space="preserve">
          <source>If you want to use both cases together:</source>
          <target state="translated">Si quieres usar ambos casos juntos:</target>
        </trans-unit>
        <trans-unit id="8841134ee2ab08cfb3f81a5ebb9e79b04b2bff1d" translate="yes" xml:space="preserve">
          <source>If you're not sure whether it might be a &lt;code&gt;list&lt;/code&gt;, a NumPy array, or something else, you could combine this approach with &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;the answer @dubiousjim gives&lt;/a&gt; to make sure the right test is used for each type.  Not very &quot;pythonic&quot;, but it turns out that NumPy intentionally broke pythonicity in at least this sense.</source>
          <target state="translated">Si no est&amp;aacute; seguro de si puede tratarse de una &lt;code&gt;list&lt;/code&gt; a , una matriz NumPy u otra cosa, puede combinar este enfoque con &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;la respuesta que @dubiousjim da&lt;/a&gt; para asegurarse de que se utiliza la prueba correcta para cada tipo. No es muy &quot;pit&amp;oacute;nico&quot;, pero resulta que NumPy rompi&amp;oacute; intencionalmente la pitonicidad al menos en este sentido.</target>
        </trans-unit>
        <trans-unit id="428f7e34ea9af326d1a0f2aad6f147c45fdb55ac" translate="yes" xml:space="preserve">
          <source>In Python, &lt;strong&gt;empty containers&lt;/strong&gt; such as lists,tuples,sets,dicts,variables etc are seen as &lt;code&gt;False&lt;/code&gt;. One could simply treat the list as a predicate (&lt;em&gt;returning a Boolean value&lt;/em&gt;). And  a &lt;code&gt;True&lt;/code&gt; value would indicate that it's non-empty.</source>
          <target state="translated">En Python, &lt;strong&gt;los contenedores vac&amp;iacute;os&lt;/strong&gt; como listas, tuplas, conjuntos, dictos, variables, etc. se ven como &lt;code&gt;False&lt;/code&gt; . Uno podr&amp;iacute;a simplemente tratar la lista como un predicado (que &lt;em&gt;devuelve un valor booleano&lt;/em&gt; ). Y un valor &lt;code&gt;True&lt;/code&gt; indicar&amp;iacute;a que no est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="a160b38c575aa7abd79420a97f3bbb8f340afc2a" translate="yes" xml:space="preserve">
          <source>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just &lt;code&gt;is_empty(any_structure)&lt;/code&gt;.</source>
          <target state="translated">Se puede usar para cualquier estructura de datos como una lista, tuplas, diccionario y muchos m&amp;aacute;s. Con estos, puede llamarlo muchas veces usando solo &lt;code&gt;is_empty(any_structure)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c32bab15a2ee7ad8ba7c6641bb23e238358e1623" translate="yes" xml:space="preserve">
          <source>It is sometimes good to test for &lt;code&gt;None&lt;/code&gt; and for emptiness separately as those are two different states. The code above produces the following output:</source>
          <target state="translated">A veces es bueno probar para &lt;code&gt;None&lt;/code&gt; y para el vac&amp;iacute;o por separado, ya que esos son dos estados diferentes. El c&amp;oacute;digo anterior produce el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="c5d891bd3646d03ddb9c17a5be09027bd036ced8" translate="yes" xml:space="preserve">
          <source>It's true that &lt;code&gt;if not a:&lt;/code&gt; doesn't distinguish empty lists from &lt;code&gt;None&lt;/code&gt;, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know &lt;em&gt;what&lt;/em&gt; you want to be explicit about, so you can test for exactly that. For example, &lt;code&gt;if not a and a is not None:&lt;/code&gt; means &quot;anything falsey except None&quot;, while &lt;code&gt;if len(a) != 0:&lt;/code&gt; means &quot;only empty sequences&amp;mdash;and anything besides a sequence is an error here&quot;, and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</source>
          <target state="translated">Es cierto que &lt;code&gt;if not a:&lt;/code&gt; no distingue las listas vac&amp;iacute;as de &lt;code&gt;None&lt;/code&gt; , o el 0 num&amp;eacute;rico, o las tuplas vac&amp;iacute;as, o los tipos de colecci&amp;oacute;n vac&amp;iacute;os creados por el usuario, o los tipos vac&amp;iacute;os creados por el usuario que no son del todo colecci&amp;oacute;n, o la matriz NumPy de un solo elemento actuando como escalares con valores de falsey, etc. Y a veces es importante ser expl&amp;iacute;cito al respecto. Y en ese caso, sabes de &lt;em&gt;qu&amp;eacute;&lt;/em&gt; quieres ser expl&amp;iacute;cito, por lo que puedes probar exactamente eso. Por ejemplo, &lt;code&gt;if not a and a is not None:&lt;/code&gt; significa &quot;cualquier cosa falsey excepto Ninguno&quot;, mientras que &lt;code&gt;if len(a) != 0:&lt;/code&gt; significa &quot;solo secuencias vac&amp;iacute;as, y cualquier cosa adem&amp;aacute;s de una secuencia es un error aqu&amp;iacute;&quot;, y as&amp;iacute; . Adem&amp;aacute;s de probar exactamente lo que desea probar, esto tambi&amp;eacute;n le indica al lector que esta prueba es importante.</target>
        </trans-unit>
        <trans-unit id="c7b0318d9faa41f53e682c3bbc37b5cfd1c0e726" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;has a similar notion of truthy/falsy&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;tiene una noci&amp;oacute;n similar de verdad / falsedad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5142fae3c5db9d1461a71db588118a77074a605f" translate="yes" xml:space="preserve">
          <source>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</source>
          <target state="translated">Se han dado muchas respuestas,y muchas de ellas son bastante buenas.Sólo quería añadir que el cheque</target>
        </trans-unit>
        <trans-unit id="bf1a55fc2dfc2923592d18290d8210ac0f8e2701" translate="yes" xml:space="preserve">
          <source>Method 1 (Preferred):</source>
          <target state="translated">Método 1 (Preferido):</target>
        </trans-unit>
        <trans-unit id="4e958d4a4b4554ff4a60439e18120188e8915232" translate="yes" xml:space="preserve">
          <source>Method 2 :</source>
          <target state="translated">Método 2 :</target>
        </trans-unit>
        <trans-unit id="5c1700aea4db454bd25188c6878b4574d94f6e62" translate="yes" xml:space="preserve">
          <source>Method 3:</source>
          <target state="translated">Método 3:</target>
        </trans-unit>
        <trans-unit id="4163466ea446b9664c1bdbc1d45e8ba19c39c8f9" translate="yes" xml:space="preserve">
          <source>No one seems to have addressed questioning your &lt;em&gt;need&lt;/em&gt; to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</source>
          <target state="translated">Nadie parece haber abordado cuestionar su &lt;em&gt;necesidad&lt;/em&gt; de probar la lista en primer lugar. Debido a que no proporcion&amp;oacute; ning&amp;uacute;n contexto adicional, me imagino que es posible que no necesite hacer esta verificaci&amp;oacute;n en primer lugar, pero no est&amp;eacute; familiarizado con el procesamiento de listas en Python.</target>
        </trans-unit>
        <trans-unit id="2ec0c5d4d7981ce6e9ff1b380ca6846b74422e54" translate="yes" xml:space="preserve">
          <source>Note: a string is considered to be iterable. - add &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; if you want the empty string to be excluded</source>
          <target state="translated">Nota: una cadena se considera iterable. - agregue &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; si desea excluir la cadena vac&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="18b642e9538492bb0944a34dd8a2e506f10e19b4" translate="yes" xml:space="preserve">
          <source>Now let's look at the case for an unempty list:</source>
          <target state="translated">Ahora veamos el caso para una lista vacía:</target>
        </trans-unit>
        <trans-unit id="9ca01a949b72339ff024541a16acb34d56d5458e" translate="yes" xml:space="preserve">
          <source>Now you can use:</source>
          <target state="translated">Ahora puedes usar:</target>
        </trans-unit>
        <trans-unit id="9b84859507e274233a23af1cd06d846a49723981" translate="yes" xml:space="preserve">
          <source>Of course, do &lt;strong&gt;not&lt;/strong&gt; use &lt;code&gt;bool&lt;/code&gt; in &lt;code&gt;if&lt;/code&gt; (i.e., &lt;code&gt;if bool(L):&lt;/code&gt;) because it's implied. But, for the cases when &quot;is not empty&quot; is explicitly needed as a function, &lt;code&gt;bool&lt;/code&gt; is the best choice.</source>
          <target state="translated">Por supuesto, &lt;strong&gt;no&lt;/strong&gt; use &lt;code&gt;bool&lt;/code&gt; en &lt;code&gt;if&lt;/code&gt; (es decir, &lt;code&gt;if bool(L):&lt;/code&gt; porque est&amp;aacute; impl&amp;iacute;cito. Pero, para los casos en que &quot;no est&amp;aacute; vac&amp;iacute;o&quot; se necesita expl&amp;iacute;citamente como funci&amp;oacute;n, &lt;code&gt;bool&lt;/code&gt; es la mejor opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d62a34899b1789ad0de88de972782e3233f85466" translate="yes" xml:space="preserve">
          <source>Other methods don't work for NumPy arrays</source>
          <target state="translated">Otros métodos no funcionan para las matrices NumPy</target>
        </trans-unit>
        <trans-unit id="7508036889deb522e760a0d2d530c531b6a2002f" translate="yes" xml:space="preserve">
          <source>PEP 8</source>
          <target state="translated">PEP 8</target>
        </trans-unit>
        <trans-unit id="3ecde6cd436f098db79f5599fdb3667956fcbf60" translate="yes" xml:space="preserve">
          <source>Place the list in a boolean context (for example, with an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement). It will test &lt;code&gt;False&lt;/code&gt; if it is empty, and &lt;code&gt;True&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">Coloque la lista en un contexto booleano (por ejemplo, con una declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; o &lt;code&gt;while&lt;/code&gt; ). Probar&amp;aacute; &lt;code&gt;False&lt;/code&gt; si est&amp;aacute; vac&amp;iacute;o, y &lt;code&gt;True&lt;/code&gt; en caso contrario. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d2931340025c9c2fd67ac84f3da9bf695821b222" translate="yes" xml:space="preserve">
          <source>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</source>
          <target state="translated">El código Python,y la comunidad Python,tiene modismos muy fuertes.Seguir esos modismos hace que su código sea más fácil de leer para cualquier persona con experiencia en Python.Y cuando violas esos modismos,es una señal fuerte.</target>
        </trans-unit>
        <trans-unit id="d64b6eced566b47a6b2fd33e4bc9acd66737c2c8" translate="yes" xml:space="preserve">
          <source>Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly.</source>
          <target state="translated">Python está escrito en C;utiliza su lógica en el nivel C.Cualquier cosa que escribas en Python será más lento.Y probablemente será más lento en órdenes de magnitud a menos que estés usando los mecanismos incorporados en Python directamente.</target>
        </trans-unit>
        <trans-unit id="420e21b5db5cbb25f52fe0a4ec446fd398e6e2c3" translate="yes" xml:space="preserve">
          <source>Response to comments:</source>
          <target state="translated">Respuesta a los comentarios:</target>
        </trans-unit>
        <trans-unit id="ea5008a4db7f66da07d14fae6d752831a2ea6498" translate="yes" xml:space="preserve">
          <source>Short Answer:</source>
          <target state="translated">Respuesta corta:</target>
        </trans-unit>
        <trans-unit id="df611a40b52b245a7619d867739b3da4fbcc5aa9" translate="yes" xml:space="preserve">
          <source>Simple way is checking the length is equal zero.</source>
          <target state="translated">La forma simple es comprobar que la longitud es igual a cero.</target>
        </trans-unit>
        <trans-unit id="799b8c4046e8b1c2ade9b021de07a884f7f35ef8" translate="yes" xml:space="preserve">
          <source>Simply use is_empty() or make function like:-</source>
          <target state="translated">Simplemente usa is_empty()o haz la función como:-</target>
        </trans-unit>
        <trans-unit id="4259f87fbbe70d265110f62571c4d8eb3fa4ff0c" translate="yes" xml:space="preserve">
          <source>So instead of this:</source>
          <target state="translated">Así que en lugar de esto:</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="78307d3a12ed5a2b855d5a3f147d8f6260767c8c" translate="yes" xml:space="preserve">
          <source>The &quot;Pythonic&quot; way is a much simpler and faster check since the length of the list is cached in the object instance header:</source>
          <target state="translated">La forma &quot;pitónica&quot; es una comprobación mucho más simple y rápida,ya que la longitud de la lista se almacena en la cabecera de la instancia del objeto:</target>
        </trans-unit>
        <trans-unit id="cce1f662637f486e769a258aed0d1f1480d3aae4" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 1</source>
          <target state="translated">La forma &quot;pitónica&quot; no funciona:Parte 1</target>
        </trans-unit>
        <trans-unit id="a62e97267f48afa3faa3d59f99bd87e92a95b78d" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 2</source>
          <target state="translated">La forma &quot;pitónica&quot; no funciona:Parte 2</target>
        </trans-unit>
        <trans-unit id="228125c176323a97205fc40f5c53dc9e1b8cb415" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way fails with NumPy arrays because NumPy tries to cast the array to an array of &lt;code&gt;bool&lt;/code&gt;s, and &lt;code&gt;if x&lt;/code&gt; tries to evaluate all of those &lt;code&gt;bool&lt;/code&gt;s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a &lt;code&gt;ValueError&lt;/code&gt;:</source>
          <target state="translated">La forma &quot;pit&amp;oacute;nica&quot; falla con las matrices NumPy porque NumPy intenta convertir la matriz en una matriz de &lt;code&gt;bool&lt;/code&gt; s, y &lt;code&gt;if x&lt;/code&gt; intenta evaluar todos esos &lt;code&gt;bool&lt;/code&gt; s a la vez para alg&amp;uacute;n tipo de valor de verdad agregado. Pero esto no tiene ning&amp;uacute;n sentido, por lo que obtienes un &lt;code&gt;ValueError&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a3f21db414612559e4bd0aa2e9d4ccdd7620a0b" translate="yes" xml:space="preserve">
          <source>The numpythonic way</source>
          <target state="translated">La manera numpythonica</target>
        </trans-unit>
        <trans-unit id="839d95ab808bb10053fa88f4716855013b528654" translate="yes" xml:space="preserve">
          <source>The pythonic way to do it is from the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;PEP 8 style guide&lt;/a&gt; (where &lt;strong&gt;Yes&lt;/strong&gt; means &amp;ldquo;recommended&amp;rdquo; and &lt;strong&gt;No&lt;/strong&gt; means &amp;ldquo;not recommended&amp;rdquo;):</source>
          <target state="translated">La forma pit&amp;oacute;nica de hacerlo es de la &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;gu&amp;iacute;a de estilo PEP 8&lt;/a&gt; (donde &lt;strong&gt;S&amp;iacute;&lt;/strong&gt; significa &quot;recomendado&quot; y &lt;strong&gt;No&lt;/strong&gt; significa &quot;no recomendado&quot;):</target>
        </trans-unit>
        <trans-unit id="419ef69c944861f78388669cc2be094309f545d1" translate="yes" xml:space="preserve">
          <source>The second way is a &lt;strong&gt;&lt;code&gt;more pythonic&lt;/code&gt;&lt;/strong&gt; one. This method is an implicit way of checking and much more preferable than the previous one.</source>
          <target state="translated">La segunda forma es &lt;strong&gt; &lt;code&gt;more pythonic&lt;/code&gt; &lt;/strong&gt; . Este m&amp;eacute;todo es una forma impl&amp;iacute;cita de verificaci&amp;oacute;n y mucho m&amp;aacute;s preferible que la anterior.</target>
        </trans-unit>
        <trans-unit id="26bb1f3155a5dcb9fceb486c2448558698ce4333" translate="yes" xml:space="preserve">
          <source>The truth value of an empty list is &lt;code&gt;False&lt;/code&gt; whereas for a non-empty list it is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">El valor de verdad de una lista vac&amp;iacute;a es &lt;code&gt;False&lt;/code&gt; mientras que para una lista no vac&amp;iacute;a es &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc6e8440ee75ab717bf6ec8f427152001e12352" translate="yes" xml:space="preserve">
          <source>Then it must call the function, load &lt;code&gt;0&lt;/code&gt;, and do the equality comparison in Python (instead of with C):</source>
          <target state="translated">Luego debe llamar a la funci&amp;oacute;n, cargar &lt;code&gt;0&lt;/code&gt; y hacer la comparaci&amp;oacute;n de igualdad en Python (en lugar de con C):</target>
        </trans-unit>
        <trans-unit id="d90a30ab848b090999fc31f8d7530affde230d5d" translate="yes" xml:space="preserve">
          <source>These are correct in their respective other languages. And this is even semantically correct in Python.</source>
          <target state="translated">Estos son correctos en sus respectivos otros idiomas.Y esto es incluso semánticamente correcto en Python.</target>
        </trans-unit>
        <trans-unit id="e237e40349b5d41720ad35c29c2a146f51cf9485" translate="yes" xml:space="preserve">
          <source>This has the benefit of handling any contents of &lt;strong&gt;a&lt;/strong&gt;, while not requiring a specific check for emptiness.  If &lt;strong&gt;a&lt;/strong&gt; is empty, the dependent block will not execute and the interpreter will fall through to the next line.</source>
          <target state="translated">Esto tiene la ventaja de manejar cualquier contenido de &lt;strong&gt;a&lt;/strong&gt; , mientras que no requiere una verificaci&amp;oacute;n espec&amp;iacute;fica de vac&amp;iacute;o. Si &lt;strong&gt;a&lt;/strong&gt; est&amp;aacute; vac&amp;iacute;o, el bloque dependiente no se ejecutar&amp;aacute; y el int&amp;eacute;rprete pasar&amp;aacute; a la siguiente l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="e07f7e1c2e6c131a4dd992f68429d70bd4456992" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;code&gt;PyObject&lt;/code&gt; that adds the &lt;code&gt;ob_size&lt;/code&gt; field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; macro.</source>
          <target state="translated">Esta es una extensi&amp;oacute;n de &lt;code&gt;PyObject&lt;/code&gt; que agrega el campo &lt;code&gt;ob_size&lt;/code&gt; . Esto solo se usa para objetos que tienen alguna noci&amp;oacute;n de longitud. Este tipo no suele aparecer en la API de Python / C. Corresponde a los campos definidos por la expansi&amp;oacute;n de la macro &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834cb8e0db15a3974ebe92a788d932cf5c816ae7" translate="yes" xml:space="preserve">
          <source>This way it's 100% clear that &lt;code&gt;li&lt;/code&gt; is a sequence (list) and we want to test its size. My problem with &lt;code&gt;if not li: ...&lt;/code&gt; is that it gives the false impression that &lt;code&gt;li&lt;/code&gt; is a boolean variable.</source>
          <target state="translated">De esta manera, est&amp;aacute; 100% claro que &lt;code&gt;li&lt;/code&gt; es una secuencia (lista) y queremos probar su tama&amp;ntilde;o. Mi problema con &lt;code&gt;if not li: ...&lt;/code&gt; es que da la falsa impresi&amp;oacute;n de que &lt;code&gt;li&lt;/code&gt; es una variable booleana.</target>
        </trans-unit>
        <trans-unit id="517b32f316ce0d136fe88818f855b9745999ba35" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;x.size&lt;/code&gt; check work in all cases I see on this page.</source>
          <target state="translated">Esto har&amp;aacute; que la verificaci&amp;oacute;n &lt;code&gt;x.size&lt;/code&gt; funcione en todos los casos que veo en esta p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="166295003ca1870a3de65a50bfe6d0b14501234e" translate="yes" xml:space="preserve">
          <source>To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a &lt;strong&gt;&lt;code&gt;less pythonic&lt;/code&gt;&lt;/strong&gt; way):</source>
          <target state="translated">Para verificar si una lista est&amp;aacute; vac&amp;iacute;a o no, puede usar las dos formas siguientes. Pero recuerde, debemos evitar la forma de verificar expl&amp;iacute;citamente un tipo de secuencia (es una forma &lt;strong&gt; &lt;code&gt;less pythonic&lt;/code&gt; &lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="d88775ff0c4e2103146fa814bf595e1bad3bd121" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;len&lt;/code&gt; can give unexpected results</source>
          <target state="translated">Usar &lt;code&gt;len&lt;/code&gt; puede dar resultados inesperados</target>
        </trans-unit>
        <trans-unit id="3210b647602906055a2ea6630c8e3fee2353fdbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;implicit booleanness&lt;/a&gt; of the empty &lt;code&gt;list&lt;/code&gt; is quite pythonic.</source>
          <target state="translated">Usar la &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;booleanidad impl&amp;iacute;cita&lt;/a&gt; de la &lt;code&gt;list&lt;/code&gt; a vac&amp;iacute;a es bastante pit&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="e4100216a9aee376fd77c24841324702e83c57b2" translate="yes" xml:space="preserve">
          <source>Very handy and useful.</source>
          <target state="translated">Muy práctico y útil.</target>
        </trans-unit>
        <trans-unit id="bec8251989ae95f17e7917e7a4667d9b939024a6" translate="yes" xml:space="preserve">
          <source>We can see there's a bit of linear cost for each additional &lt;code&gt;not&lt;/code&gt; here. We want to see the costs, &lt;em&gt;ceteris paribus&lt;/em&gt;, that is, all else equal - where all else is minimized as far as possible:</source>
          <target state="translated">Podemos ver que hay un poco de costo lineal por cada adicional que &lt;code&gt;not&lt;/code&gt; aqu&amp;iacute;. Queremos ver los costos, &lt;em&gt;ceteris paribus&lt;/em&gt; , es decir, todo lo dem&amp;aacute;s igual, donde todo lo dem&amp;aacute;s se minimiza en la medida de lo posible:</target>
        </trans-unit>
        <trans-unit id="0a1d52cb17cca8e7191f36986558bb72f7957e50" translate="yes" xml:space="preserve">
          <source>We see that &lt;em&gt;either&lt;/em&gt; checking for length with the builtin function &lt;code&gt;len&lt;/code&gt; compared to &lt;code&gt;0&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; checking against an empty list is &lt;strong&gt;much&lt;/strong&gt; less performant than using the builtin syntax of the language as documented.</source>
          <target state="translated">Vemos que verificar la longitud con la funci&amp;oacute;n incorporada &lt;code&gt;len&lt;/code&gt; en comparaci&amp;oacute;n con &lt;code&gt;0&lt;/code&gt; &lt;em&gt;o&lt;/em&gt; comparar con una lista vac&amp;iacute;a es &lt;strong&gt;mucho&lt;/strong&gt; menos eficaz que usar la sintaxis integrada del lenguaje como se documenta.</target>
        </trans-unit>
        <trans-unit id="93defcec033f02c7813b4fa2999f8fa8e135291c" translate="yes" xml:space="preserve">
          <source>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</source>
          <target state="translated">Debemos esperar que el código estándar de la biblioteca sea lo más eficiente y correcto posible.¿Pero por qué es así,y por qué necesitamos esta orientación?</target>
        </trans-unit>
        <trans-unit id="53f50b6170acffe67cc4616bcd8c695dc5c3e587" translate="yes" xml:space="preserve">
          <source>What brought me here is a special use-case: I actually wanted a &lt;em&gt;function&lt;/em&gt; to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough):</source>
          <target state="translated">Lo que me trajo aqu&amp;iacute; es un caso de uso especial: en realidad quer&amp;iacute;a que una &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; me dijera si una lista est&amp;aacute; vac&amp;iacute;a o no. Quer&amp;iacute;a evitar escribir mi propia funci&amp;oacute;n o usar una expresi&amp;oacute;n lambda aqu&amp;iacute; (porque parec&amp;iacute;a que deber&amp;iacute;a ser lo suficientemente simple):</target>
        </trans-unit>
        <trans-unit id="6c52a1ca8670775a8c8a00491e8712ffcaca818c" translate="yes" xml:space="preserve">
          <source>What we can see here is that it makes little difference whether you pass in an actual &lt;code&gt;bool&lt;/code&gt; to the condition check or the list itself, and if anything, giving the list, as is, is faster.</source>
          <target state="translated">Lo que podemos ver aqu&amp;iacute; es que hace poca diferencia si pasa un &lt;code&gt;bool&lt;/code&gt; real a la verificaci&amp;oacute;n de condici&amp;oacute;n o la lista en s&amp;iacute;, y en todo caso, dar la lista, como es, es m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="0a4d3c26f7312a3bcafab015f36e0c94e6e8659e" translate="yes" xml:space="preserve">
          <source>Why check at all?</source>
          <target state="translated">¿Por qué lo compruebas?</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="3ecc4c96e7de4be0cda6aa9f38dc351865be20e7" translate="yes" xml:space="preserve">
          <source>You can even try using bool() like this</source>
          <target state="translated">Incluso puedes intentar usar bool()de esta manera</target>
        </trans-unit>
        <trans-unit id="f65dd7b083f4ea2c1ee4f439f364acdec6b47258" translate="yes" xml:space="preserve">
          <source>You can get away without the explicit type check, but only if the surrounding context already assures you that &lt;code&gt;a&lt;/code&gt; is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a &lt;code&gt;TypeError&lt;/code&gt; if you call &lt;code&gt;len&lt;/code&gt; on a value for which it's undefined) that you're prepared to handle. In general, the &quot;pythonic&quot; conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to &lt;em&gt;think&lt;/em&gt; about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on &lt;code&gt;len&lt;/code&gt; or the boolean typecast may not do precisely what you're expecting.</source>
          <target state="translated">Puede escapar sin la verificaci&amp;oacute;n expl&amp;iacute;cita de tipos, pero solo si el contexto circundante ya le asegura que &lt;code&gt;a&lt;/code&gt; es un valor de los tipos que est&amp;aacute; preparado para manejar, o si est&amp;aacute; seguro de que los tipos que no est&amp;aacute; preparado para manejar son va a generar errores (por ejemplo, un &lt;code&gt;TypeError&lt;/code&gt; si llama a &lt;code&gt;len&lt;/code&gt; en un valor para el que no est&amp;aacute; definido) que est&amp;aacute; preparado para manejar. En general, las convenciones &quot;pit&amp;oacute;nicas&quot; parecen ir de esta &amp;uacute;ltima manera. Expr&amp;iacute;malo como un pato y d&amp;eacute;jalo levantar un DuckError si no sabe graznar. Sin embargo, todav&amp;iacute;a tiene que &lt;em&gt;pensar&lt;/em&gt; qu&amp;eacute; tipo de suposiciones est&amp;aacute; haciendo y si los casos que no est&amp;aacute; preparado para manejar adecuadamente realmente se equivocar&amp;aacute;n en los lugares correctos. Las matrices de Numpy son un buen ejemplo en el que confiar ciegamente en &lt;code&gt;len&lt;/code&gt; o en el tipo de letra booleano puede no hacer exactamente lo que espera.</target>
        </trans-unit>
        <trans-unit id="9083cd48fae65c5b68f6712180202c73821b23fa" translate="yes" xml:space="preserve">
          <source>You need to be careful with NumPy arrays, because other methods that work fine for &lt;code&gt;list&lt;/code&gt;s or other standard containers fail for NumPy arrays.  I explain why below, but in short, the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;preferred method&lt;/a&gt; is to use &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Debe tener cuidado con las matrices NumPy, porque otros m&amp;eacute;todos que funcionan bien para &lt;code&gt;list&lt;/code&gt; as u otros contenedores est&amp;aacute;ndar fallan para las matrices NumPy. Explico por qu&amp;eacute; a continuaci&amp;oacute;n, pero en resumen, el &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;m&amp;eacute;todo preferido&lt;/a&gt; es usar el &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d227705c28851b3cabdba2c9c370a4f7063204" translate="yes" xml:space="preserve">
          <source>Your duckCollection should implement &lt;code&gt;__nonzero__&lt;/code&gt; or &lt;code&gt;__len__&lt;/code&gt; so the if a: will work without problems.</source>
          <target state="translated">Su duckCollection debe implementar &lt;code&gt;__nonzero__&lt;/code&gt; o &lt;code&gt;__len__&lt;/code&gt; para que if: funcione sin problemas.</target>
        </trans-unit>
        <trans-unit id="e1f11fedb84b9948d72cba30d27c4ba1e5b96b6b" translate="yes" xml:space="preserve">
          <source>a little more practical:</source>
          <target state="translated">un poco más práctico:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="5fa43287b1c5b62b65463b926344285e74e283b5" translate="yes" xml:space="preserve">
          <source>and shertest version:</source>
          <target state="translated">y la versión más segura:</target>
        </trans-unit>
        <trans-unit id="83ab88ee561c2c3fbf9a72f4e64edd6d102bc31c" translate="yes" xml:space="preserve">
          <source>any empty mapping, for example, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">cualquier mapeo vac&amp;iacute;o, por ejemplo, &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2952616e90efb7a6dd44095c44dfdd2377bc3ab" translate="yes" xml:space="preserve">
          <source>any empty sequence, for example, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">cualquier secuencia vac&amp;iacute;a, por ejemplo, &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b131ef05b1826b4dcf14f5da963e3b8f3d60f6f6" translate="yes" xml:space="preserve">
          <source>constants defined to be false: &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">constantes definidas como falsas: &lt;code&gt;None&lt;/code&gt; y &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa71fa14fe89fc7eb25cd68186ad53611ebfd167" translate="yes" xml:space="preserve">
          <source>empty sequences and collections: &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;range(0)&lt;/code&gt;</source>
          <target state="translated">secuencias y colecciones vac&amp;iacute;as: &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , &lt;code&gt;set()&lt;/code&gt; , &lt;code&gt;range(0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="054f2c8e08dfd096608d12043bbc8cd93bbd3d80" translate="yes" xml:space="preserve">
          <source>if you only want to accept instances of particular types (and their subtypes), or with:</source>
          <target state="translated">si sólo quiere aceptar instancias de tipos particulares (y sus subtipos),o con:</target>
        </trans-unit>
        <trans-unit id="bbe92aa90ac3da927a82d780633d2c79550b5147" translate="yes" xml:space="preserve">
          <source>instances of user-defined classes, if the class defines a &lt;code&gt;__bool__()&lt;/code&gt; or &lt;code&gt;__len__()&lt;/code&gt; method, when that method returns the integer zero or bool value &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">instancias de clases definidas por el usuario, si la clase define un &lt;code&gt;__bool__()&lt;/code&gt; o &lt;code&gt;__len__()&lt;/code&gt; , cuando ese m&amp;eacute;todo devuelve el valor entero cero o valor bool &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">o esto:</target>
        </trans-unit>
        <trans-unit id="5fe84e072cb8774215db86ddfc171c8aa9283127" translate="yes" xml:space="preserve">
          <source>produces expected</source>
          <target state="translated">produce esperados</target>
        </trans-unit>
        <trans-unit id="bdb401ea8d165ea2005c10c5877c586d8207bf1a" translate="yes" xml:space="preserve">
          <source>returns 1, even though the array has zero elements.</source>
          <target state="translated">devuelve 1,aunque la matriz tenga cero elementos.</target>
        </trans-unit>
        <trans-unit id="9f03e5ffbf02bb878e6dd52843870f4e01cc42fb" translate="yes" xml:space="preserve">
          <source>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</source>
          <target state="translated">la primera prueba es en respuesta a la respuesta de @Mike,arriba.La tercera línea también podría ser reemplazada por:</target>
        </trans-unit>
        <trans-unit id="a818933ef67b2d17d00dabdb02f08102734ba6d7" translate="yes" xml:space="preserve">
          <source>to check if the list is empty</source>
          <target state="translated">para comprobar si la lista está vacía</target>
        </trans-unit>
        <trans-unit id="113a8713eff230494f7adff7cabd13b33e7a718c" translate="yes" xml:space="preserve">
          <source>we could use a simple if else:</source>
          <target state="translated">podríamos usar un simple si no:</target>
        </trans-unit>
        <trans-unit id="75e6b798f41cc1b686d5e5e68f072d8fc897174b" translate="yes" xml:space="preserve">
          <source>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as &quot;pythonic&quot;---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where &lt;code&gt;a&lt;/code&gt; is, for example, &lt;code&gt;False&lt;/code&gt;, you need a test more restrictive than just &lt;code&gt;if not a:&lt;/code&gt;. You could use something like this:</source>
          <target state="translated">que fue votado -1. No estoy seguro de si eso se debe a que los lectores se opusieron a la estrategia o pensaron que la respuesta no fue &amp;uacute;til tal como se present&amp;oacute;. Voy a fingir que fue lo &amp;uacute;ltimo, ya que --- lo que cuenta como &quot;pit&amp;oacute;nico&quot; --- esta es la estrategia correcta. A menos que ya haya descartado, o est&amp;eacute; preparado para manejar casos donde &lt;code&gt;a&lt;/code&gt; es, por ejemplo, &lt;code&gt;False&lt;/code&gt; , necesita una prueba m&amp;aacute;s restrictiva que solo &lt;code&gt;if not a:&lt;/code&gt; Podr&amp;iacute;as usar algo como esto:</target>
        </trans-unit>
        <trans-unit id="9c021d12abb7b3e2b39cca48ff8eeeb38bb02d18" translate="yes" xml:space="preserve">
          <source>will also pass for &lt;code&gt;None&lt;/code&gt; and other types of empty structures. If you truly want to check for an empty list, you can do this:</source>
          <target state="translated">tambi&amp;eacute;n pasar&amp;aacute; por &lt;code&gt;None&lt;/code&gt; y otros tipos de estructuras vac&amp;iacute;as. Si realmente desea buscar una lista vac&amp;iacute;a, puede hacer esto:</target>
        </trans-unit>
        <trans-unit id="0e6f0e52997217d3b5a709de67763a194e319b26" translate="yes" xml:space="preserve">
          <source>zero of any numeric type, for example, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;.</source>
          <target state="translated">cero de cualquier tipo num&amp;eacute;rico, por ejemplo, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0.0&lt;/code&gt; , &lt;code&gt;0j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a325962fa4501e445c5fc397f589278bbc1b016" translate="yes" xml:space="preserve">
          <source>zero of any numeric type: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;, &lt;code&gt;Decimal(0)&lt;/code&gt;, &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</source>
          <target state="translated">cero de cualquier tipo num&amp;eacute;rico: &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0.0&lt;/code&gt; , &lt;code&gt;0j&lt;/code&gt; , &lt;code&gt;Decimal(0)&lt;/code&gt; , &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
