<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/53513">
    <body>
      <group id="53513">
        <trans-unit id="fa6087ea829d2efe469e42d5b4ea7ef6c710c3b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt;&lt;code&gt;len()&lt;/code&gt; is an O(1) operation&lt;/a&gt; for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</source>
          <target state="translated">&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt; &lt;code&gt;len()&lt;/code&gt; 은&lt;/a&gt; Python 목록, 문자열, dicts 및 세트에 대한 O (1) 연산 입니다. 파이썬은 내부적으로 이러한 컨테이너의 요소 수를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="85fd292fdea964654b12fcc3bff501372a02fc3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;Patrick's (accepted) answer&lt;/a&gt; is right: &lt;code&gt;if not a:&lt;/code&gt; is the right way to do it. &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;Harley Holcombe's answer&lt;/a&gt; is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom&amp;mdash;even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;Patrick의 (허용 된) 대답&lt;/a&gt; 은 옳습니다. &lt;code&gt;if not a:&lt;/code&gt; 올바른 방법입니다. &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;Harley Holcombe의 답변&lt;/a&gt; 은 이것이 PEP 8 스타일 가이드에 있다는 것이 옳습니다. 그러나 어떤 대답도 설명 할 수없는 이유는 개인적으로 루비 사용자 나 기타 사람들에게 명확하지 않거나 혼동되지 않는 경우에도 관용구를 따르는 것이 좋은 생각입니다.</target>
        </trans-unit>
        <trans-unit id="f6bd068dee72f5e7acd72d046b51628d73431616" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt;, the official Python style guide for Python code in Python's standard library, asserts:</source>
          <target state="translated">파이썬의 표준 라이브러리에있는 파이썬 코드를위한 공식 파이썬 스타일 가이드 인 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt; 은 다음과 같이 주장합니다.</target>
        </trans-unit>
        <trans-unit id="709c05e03db9fe7106ff167bae3e20510ada6c6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; The pretty simple pythonic way:</source>
          <target state="translated">&lt;strong&gt;1)&lt;/strong&gt; 꽤 간단한 파이썬 방식 :</target>
        </trans-unit>
        <trans-unit id="73bff0478225a1ca5de41c8041fd2f172d65b5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; A much explicit way: using the &lt;code&gt;len()&lt;/code&gt; to find the length and check if it equals to &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;2)&lt;/strong&gt; 훨씬 명백한 방법 : &lt;code&gt;len()&lt;/code&gt; 을 사용하여 길이를 찾고 길이가 &lt;code&gt;0&lt;/code&gt; 인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f9d4a74112f8906073526e0491135de335a7db27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt; Or comparing it to an anonymous empty list:</source>
          <target state="translated">&lt;strong&gt;3)&lt;/strong&gt; 또는 익명의 빈 목록과 비교 :</target>
        </trans-unit>
        <trans-unit id="406daadaa5d41723954f852ca3012418a893aa74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4)&lt;/strong&gt; Another yet &lt;em&gt;silly&lt;/em&gt; way to do is using &lt;code&gt;exception&lt;/code&gt; and &lt;code&gt;iter()&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;4)&lt;/strong&gt; 또 다른 &lt;em&gt;어리석은&lt;/em&gt; 방법은 &lt;code&gt;exception&lt;/code&gt; 및 &lt;code&gt;iter()&lt;/code&gt; 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d2003a249df2249cead04ad47fd9076516a663f" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is the first google hit for &quot;python test empty array&quot; and similar queries, plus other people seem to be generalizing the question beyond just lists, so I thought I'd add a caveat for a different type of sequence that a lot of people might use.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;이것은 &quot;python test empty array&quot;및 유사한 쿼리에 대한 첫 번째 Google 히트이며 다른 사람들은 목록을 넘어서 질문을 일반화하는 것처럼 보이므로 많은 사람들이 다른 유형의 시퀀스에 대한 경고를 추가 할 것이라고 생각했습니다. 사용할 수 있습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e08157bc06e9b1d4da704ba91099e16c06508dab" translate="yes" xml:space="preserve">
          <source>@Daren Thomas</source>
          <target state="translated">@ 대런 토마스</target>
        </trans-unit>
        <trans-unit id="dbf83e4117a99476070d823064700dc3ed352dc3" translate="yes" xml:space="preserve">
          <source>All values other than what is listed here are considered &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">여기에 나와있는 것 이외의 모든 값은 &lt;code&gt;True&lt;/code&gt; 로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="2a2a7eec8c7ee8d914fe13445e4f282e1b2a7082" translate="yes" xml:space="preserve">
          <source>Although it's worth nothing that &lt;code&gt;None&lt;/code&gt; is falsy. So if you don't want to separate test for &lt;code&gt;None&lt;/code&gt;-ness, you don't have to do that.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 거짓이라는 것은 아무 가치가 없지만. 따라서 &lt;code&gt;None&lt;/code&gt; - ness에 대한 테스트를 분리하지 않으려면 그렇게 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3eda0c093884c5cdf292a4a6958a44bd4e2a71d" translate="yes" xml:space="preserve">
          <source>An empty list is itself considered false in true value testing (see &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;python documentation&lt;/a&gt;):</source>
          <target state="translated">실제 값 테스트에서는 빈 목록 자체가 거짓으로 간주됩니다 ( &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;파이썬 문서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ab5f88a40a649b5bd874e7e3cf70712fe8fcfbfb" translate="yes" xml:space="preserve">
          <source>And for the &lt;code&gt;[] == []&lt;/code&gt; it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</source>
          <target state="translated">그리고 &lt;code&gt;[] == []&lt;/code&gt; 경우 불필요한 목록을 작성하고 다시 파이썬 가상 머신에서 비교 연산을 수행해야합니다 (C와 반대)</target>
        </trans-unit>
        <trans-unit id="44044d9b0333bc1e2793c401ceb8f5611f29a99f" translate="yes" xml:space="preserve">
          <source>And the datamodel documentation:</source>
          <target state="translated">그리고 데이터 모델 문서 :</target>
        </trans-unit>
        <trans-unit id="45af135cc0b7fd22346b0a3dce703ee3a4f1fac5" translate="yes" xml:space="preserve">
          <source>And users of lazy languages may be tempted to do this:</source>
          <target state="translated">그리고 게으른 언어 사용자는 다음과 같이 유혹 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6202056bf6b3d838f4ff8c5b7307d6357e08439f" translate="yes" xml:space="preserve">
          <source>And, of course, there is a very natural way to do it:</source>
          <target state="translated">물론 그렇게하는 매우 자연스러운 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff47252d65d441c800203256a95b3a6607509fac" translate="yes" xml:space="preserve">
          <source>As can be seen, empty list &lt;code&gt;[]&lt;/code&gt; is &lt;em&gt;falsy&lt;/em&gt;, so doing what would be done to a boolean value sounds most efficient:</source>
          <target state="translated">알 수 있듯이 빈 목록 &lt;code&gt;[]&lt;/code&gt; 은 &lt;em&gt;거짓&lt;/em&gt; 이므로 부울 값에 대해 수행하는 것이 가장 효율적으로 들립니다.</target>
        </trans-unit>
        <trans-unit id="bba28c4ea8d4854a5cac4c82193c5746abc143e3" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;SciPy FAQ&lt;/a&gt;, the correct method in all cases where you know you have a NumPy array is to use &lt;code&gt;if x.size&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;SciPy FAQ에&lt;/a&gt; 설명되어 있듯이 NumPy 배열을 알고있는 모든 경우에 올바른 방법은 &lt;code&gt;if x.size&lt;/code&gt; 를 사용 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c2a373c95098f9c06da7f59b6f9464570c1f1907" translate="yes" xml:space="preserve">
          <source>Being inspired by @dubiousjim's solution, I propose to use an additional general check of whether is it something iterable</source>
          <target state="translated">@dubiousjim의 솔루션에서 영감을 얻었으므로 반복 가능한지 여부에 대한 일반적인 추가 확인을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="3ab76bc795d839d5beddbad54e0ccdf03bc826b1" translate="yes" xml:space="preserve">
          <source>Best way to check if a list is empty</source>
          <target state="translated">목록이 비어 있는지 확인하는 가장 좋은 방법</target>
        </trans-unit>
        <trans-unit id="eca779c7f85faf34e05c115f1686ec19c2ba5f60" translate="yes" xml:space="preserve">
          <source>But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the &lt;code&gt;if&lt;/code&gt; statement will &quot;work&quot;, in the sense that you don't get an error.  However, if that one element happens to be &lt;code&gt;0&lt;/code&gt; (or &lt;code&gt;0.0&lt;/code&gt;, or &lt;code&gt;False&lt;/code&gt;, ...), the &lt;code&gt;if&lt;/code&gt; statement will incorrectly result in &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">그러나 적어도 위의 경우는 실패했다고 알려줍니다. 정확히 하나의 요소를 가진 NumPy 배열이 &lt;code&gt;if&lt;/code&gt; 문은 오류가 발생하지 않는다는 의미에서 &quot;작동&quot;합니다. 그러나 한 요소가 &lt;code&gt;0&lt;/code&gt; (또는 &lt;code&gt;0.0&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; , ...)이면 &lt;code&gt;if&lt;/code&gt; 문은 &lt;code&gt;False&lt;/code&gt; 를 잘못 생성합니다.</target>
        </trans-unit>
        <trans-unit id="daf538c97712481cae9a4d466b7c25253ade40a8" translate="yes" xml:space="preserve">
          <source>But clearly &lt;code&gt;x&lt;/code&gt; exists and is not empty!  This result is not what you wanted.</source>
          <target state="translated">그러나 분명히 &lt;code&gt;x&lt;/code&gt; 는 존재하며 비어 있지 않습니다! 이 결과는 당신이 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="352789ca029b151d48e5b54d32774d3617bff5aa" translate="yes" xml:space="preserve">
          <source>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</source>
          <target state="translated">그러나 파이썬은 불리언 강제를 통해 목록 객체의 인터페이스에서 직접 이러한 의미를 지원하기 때문에 비피 토닉으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="b38bccd576f28416712521493d4fcfd148c28f3f" translate="yes" xml:space="preserve">
          <source>But when you don't have anything to be explicit about, anything other than &lt;code&gt;if not a:&lt;/code&gt; is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you &lt;em&gt;habitually&lt;/em&gt; mislead the reader like this, then when you &lt;em&gt;do&lt;/em&gt; need to make a distinction, it's going to pass unnoticed because you've been &quot;crying wolf&quot; all over your code.</source>
          <target state="translated">그러나 명시해야 할 것이 &lt;code&gt;if not a:&lt;/code&gt; 이외의 다른 것이 독자를 오도하는 것입니다. 중요하지 않은 중요한 것을 신호하고 있습니다. (코드를 덜 유연하게, 느리게 또는 기타로 만들 수도 있지만, 그렇게 중요하지는 않습니다.) &lt;em&gt;습관적으로&lt;/em&gt; 독자와 같이 이런 식으로 독자를 오도하면 구별해야 할 때 눈에 띄지 않게됩니다. 당신은 당신의 코드 전체에 &quot;늑대를 울고&quot;있었습니다.</target>
        </trans-unit>
        <trans-unit id="f3c03b9e169237bd714c4403d329565895990596" translate="yes" xml:space="preserve">
          <source>By default, an object is considered true unless its class defines
  either a &lt;code&gt;__bool__()&lt;/code&gt; method that returns &lt;code&gt;False&lt;/code&gt; or a &lt;code&gt;__len__()&lt;/code&gt; method
  that returns zero, when called with the object. Here are most of the built-in objects considered false:</source>
          <target state="translated">기본적으로 객체는 클래스가 &lt;code&gt;False&lt;/code&gt; 를 반환하는 &lt;code&gt;__len__()&lt;/code&gt; 메서드 또는 객체와 함께 호출 될 때 0을 반환하는 __len __ () 메서드를 정의하지 않는 한 true로 간주됩니다. 다음은 거짓으로 간주되는 대부분의 내장 객체입니다.</target>
        </trans-unit>
        <trans-unit id="0fdcbacfeed5434a99e0a6a9a898a2d1742fc056" translate="yes" xml:space="preserve">
          <source>Called to implement the built-in function &lt;code&gt;len()&lt;/code&gt;. Should return the length of the object, an integer &amp;gt;= 0. Also, an object that doesn&amp;rsquo;t define a &lt;code&gt;__bool__()&lt;/code&gt; method and whose &lt;code&gt;__len__()&lt;/code&gt; method returns zero is considered to be false in a Boolean context.</source>
          <target state="translated">내장 함수 &lt;code&gt;len()&lt;/code&gt; 구현을 위해 호출됩니다. 객체의 길이, 정수&amp;gt; = 0을 반환해야합니다. 또한 &lt;code&gt;__bool__()&lt;/code&gt; 메서드를 정의하지 않고 &lt;code&gt;__len__()&lt;/code&gt; 메서드가 0을 반환하는 개체는 부울 컨텍스트에서 false로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e25864a93b493700b01d581e68d0cd82ca932f25" translate="yes" xml:space="preserve">
          <source>Called to implement truth value testing and the built-in operation &lt;code&gt;bool()&lt;/code&gt;; should return &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;. When this method is not defined,
  &lt;code&gt;__len__()&lt;/code&gt; is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither &lt;code&gt;__len__()&lt;/code&gt;
  nor &lt;code&gt;__bool__()&lt;/code&gt;, all its instances are considered true.</source>
          <target state="translated">진리 값 테스트 및 내장 연산 &lt;code&gt;bool()&lt;/code&gt; ; &lt;code&gt;False&lt;/code&gt; 또는 &lt;code&gt;True&lt;/code&gt; 를 반환해야합니다. 이 메소드가 정의되지 않은 경우, 정의 된 경우 &lt;code&gt;__len__()&lt;/code&gt; 이 호출되고 결과가 0이 아닌 경우 오브젝트는 참으로 간주됩니다. 클래스가 &lt;code&gt;__len__()&lt;/code&gt; 또는 &lt;code&gt;__bool__()&lt;/code&gt; 정의하지 않으면 모든 인스턴스가 true로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">이 작업을 수행:</target>
        </trans-unit>
        <trans-unit id="f5b5eede35878f55c7d57820131de56da262d55f" translate="yes" xml:space="preserve">
          <source>Does it pay off? (Note that less time to perform an equivalent operation is better:)</source>
          <target state="translated">돈을 지불합니까? (동일한 작업을 수행하는 데 걸리는 시간이 짧을수록 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="373d23c12606180ec0cf1beb638fb73524fadb61" translate="yes" xml:space="preserve">
          <source>Doing what's Pythonic usually pays off in performance:</source>
          <target state="translated">Pythonic을 수행하면 일반적으로 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="97f2e93e05fd80db822418cf3feec3652cf3a370" translate="yes" xml:space="preserve">
          <source>EDIT : This works with python2.7 too..</source>
          <target state="translated">편집 : 이것은 python2.7에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a76d5cc35692d4dad67addbef26267cdf67ffeed" translate="yes" xml:space="preserve">
          <source>EDIT: Another point against testing
  the empty list as False: What about
  polymorphism? You shouldn't depend on
  a list being a list. It should just
  quack like a duck - how are you going
  to get your duckCollection to quack
  ''False'' when it has no elements?</source>
          <target state="translated">편집 : 빈 목록을 False로 테스트하는 것에 대한 또 다른 요점 : 다형성은 어떻습니까? 리스트 인리스트에 의존해서는 안됩니다. 오리처럼 ck해야합니다-요소가 없을 때 duckCollection을``False ''로 가져 오는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="dcedc96969a1d0a6f2a233b8f6888a0a00ab7357" translate="yes" xml:space="preserve">
          <source>Evidence from the C source and documentation</source>
          <target state="translated">C 소스 및 문서의 증거</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c25e4d6b416a6cd9233a3e845e94921c7430d50d" translate="yes" xml:space="preserve">
          <source>First Python has to check the globals to see if &lt;code&gt;len&lt;/code&gt; is shadowed.</source>
          <target state="translated">먼저 파이썬은 전역을 검사하여 &lt;code&gt;len&lt;/code&gt; 이 음영인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="f3412712dcaf0e84cb53a746ad7e9f73d9013702" translate="yes" xml:space="preserve">
          <source>For example, if passed the following:</source>
          <target state="translated">예를 들어, 다음을 통과 한 경우 :</target>
        </trans-unit>
        <trans-unit id="1bad339600e3699390f0ed87a2003eee92c4dfcf" translate="yes" xml:space="preserve">
          <source>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</source>
          <target state="translated">스케일의 경우, 함수를 호출하고 빈 목록을 작성하고 리턴하는 비용이 있습니다. 위에서 사용한 공허 점검 비용에서 차감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f942debb8d0e14241aa308336c922d6775903a" translate="yes" xml:space="preserve">
          <source>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</source>
          <target state="translated">시퀀스 (문자열, 목록, 튜플)의 경우 빈 시퀀스가 ​​거짓이라는 사실을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bac1c52ffa1b4459d0f919bc355c6d2057242350" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;len(a) == 0&lt;/code&gt; check:</source>
          <target state="translated">&lt;code&gt;len(a) == 0&lt;/code&gt; 확인 :</target>
        </trans-unit>
        <trans-unit id="aaaaeb6ed2be6a7373f22ebc411776f617e21985" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;documentation&lt;/a&gt; on truth value testing:</source>
          <target state="translated">진실 가치 테스트에 관한 &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;문서&lt;/a&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="609634de36f52ce2e3fd7aa8ecbe7c6e9b48a3be" translate="yes" xml:space="preserve">
          <source>From python3 onwards you can use</source>
          <target state="translated">python3부터 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1232457a90ed6c80cf66104828eec8c675b2e5f6" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;docs&lt;/a&gt; (and note specifically the inclusion of the empty list, &lt;code&gt;[]&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;문서에서&lt;/a&gt; (특히 빈 목록 &lt;code&gt;[]&lt;/code&gt; 포함 포함)</target>
        </trans-unit>
        <trans-unit id="728f688a52623e6d5037d6bbdfb3e7ba80193709" translate="yes" xml:space="preserve">
          <source>From the c source in &lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include/listobject.h&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include / listobject.h&lt;/a&gt; 의 c 소스에서 :</target>
        </trans-unit>
        <trans-unit id="683112e7d730f26c7bccb345b8ef7aaf95794090" translate="yes" xml:space="preserve">
          <source>Here are a few ways you can check if a list is empty:</source>
          <target state="translated">목록이 비어 있는지 확인할 수있는 몇 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="5ff7fbc89be7316e185d7a00a7ff3d90d022034c" translate="yes" xml:space="preserve">
          <source>How do I check if a list is empty</source>
          <target state="translated">목록이 비어 있는지 어떻게 확인합니까</target>
        </trans-unit>
        <trans-unit id="33c5d06ed9c860acea48b74dc4a823901ef3f8f1" translate="yes" xml:space="preserve">
          <source>How do I check to see if &lt;code&gt;a&lt;/code&gt; is empty?</source>
          <target state="translated">가 비어 있는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="e5fcefe7e34c52a1195ed32056bdb1089ea254b1" translate="yes" xml:space="preserve">
          <source>How do I check to see if a is empty?</source>
          <target state="translated">가 비어 있는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="a9f1c0fc9cfe4503ffc9501fffdfcb4226311e22" translate="yes" xml:space="preserve">
          <source>I am not sure why there are so many complicated answers.
It's pretty clear and straightforward</source>
          <target state="translated">왜 복잡한 답변이 그렇게 많은지 잘 모르겠습니다. 꽤 명확하고 간단합니다</target>
        </trans-unit>
        <trans-unit id="25ab0752fffc84134368c44c5351c7020c10bf59" translate="yes" xml:space="preserve">
          <source>I frequently see code like this from experienced programmers new to Python:</source>
          <target state="translated">파이썬을 처음 접하는 숙련 된 프로그래머가 다음과 같은 코드를 자주 봅니다.</target>
        </trans-unit>
        <trans-unit id="70fe8a86746b4223af6f5c03bf7b7263ef48e957" translate="yes" xml:space="preserve">
          <source>I had written:</source>
          <target state="translated">나는 다음과 같이 썼다.</target>
        </trans-unit>
        <trans-unit id="503904ef0bb804cf7a77e21d4237ad21f29e4536" translate="yes" xml:space="preserve">
          <source>I love this way for checking list is empty or not.</source>
          <target state="translated">목록이 비어 있는지 여부를 확인하는이 방법을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="6936816d820ecc9d4d156fa6961e9db56da9a535" translate="yes" xml:space="preserve">
          <source>I prefer it explicitly:</source>
          <target state="translated">나는 그것을 명시 적으로 선호한다 :</target>
        </trans-unit>
        <trans-unit id="c822b9b00d42f96380485775d1aabfaff330ecc8" translate="yes" xml:space="preserve">
          <source>I prefer the following:</source>
          <target state="translated">나는 다음을 선호합니다 :</target>
        </trans-unit>
        <trans-unit id="07d7c92c83648b3dcf817f34c2fe61d11e207210" translate="yes" xml:space="preserve">
          <source>I suppose the problem is testing with timeit since just &lt;code&gt;if l:&lt;/code&gt; is sufficient but surprisingly &lt;code&gt;%timeit bool(l)&lt;/code&gt; yields 101 ns &amp;plusmn; 2.64 ns. Interesting there is no way to coerce to bool without this penalty. &lt;code&gt;%timeit l&lt;/code&gt; is useless since no conversion would occur.</source>
          <target state="translated">&lt;code&gt;if l:&lt;/code&gt; 충분하지만 놀랍게도 &lt;code&gt;%timeit bool(l)&lt;/code&gt; 은 101ns &amp;plusmn; 2.64ns를 생성하기 때문에 문제가 timeit로 테스트되고 있다고 가정합니다. 흥미롭게도이 형벌 없이는 강압 할 수있는 방법이 없습니다. 변환이 발생하지 않으므로 &lt;code&gt;%timeit l&lt;/code&gt; 은 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a53819da8c55112c5bbdb5ec0a8f8c0331eed55" translate="yes" xml:space="preserve">
          <source>I would argue that the &lt;em&gt;most pythonic&lt;/em&gt; way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</source>
          <target state="translated">&lt;em&gt;가장 파이썬적인&lt;/em&gt; 방법은 전혀 확인하지 않고 목록을 처리하는 것입니다. 그렇게하면 비어 있거나 가득 차든 올바른 일을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="df53c7c830c1b687f914d825896b14ea3616de2b" translate="yes" xml:space="preserve">
          <source>I would point out that this is also true for the non-empty case though its pretty ugly as with &lt;code&gt;l=[]&lt;/code&gt; then &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90.6 ns &amp;plusmn; 8.3 ns, &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn; 3.09, &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5 ns &amp;plusmn; 0.372. But there is no way anyone is going to enjoy &lt;code&gt;not not l&lt;/code&gt; despite triple the speed. It looks ridiculous. But the speed wins out</source>
          <target state="translated">&lt;code&gt;l=[]&lt;/code&gt; 에서 와 같이 꽤 못생긴 경우에도 비어 있지 않은 경우에도 마찬가지입니다. &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90.6 ns &amp;plusmn; 8.3 ns, &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn; 3.09, &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5ns &amp;plusmn; 0.372. 그러나 세 배의 속도에도 불구하고 누구도 즐기지 &lt;code&gt;not not l&lt;/code&gt; 방법은 없습니다. 어리석어 보인다. 그러나 속도는 이깁니다</target>
        </trans-unit>
        <trans-unit id="d4412db9669f7d0df447ee505c3d56a16c1a3414" translate="yes" xml:space="preserve">
          <source>IPython magic, &lt;code&gt;%timeit&lt;/code&gt;, is not entirely useless here:</source>
          <target state="translated">IPython 매직 &lt;code&gt;%timeit&lt;/code&gt; 은 여기에서 완전히 쓸모없는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2a07e4c6e816613379546e213ea347ae1a8fa784" translate="yes" xml:space="preserve">
          <source>If you do actually need to check the array for emptiness, the other answers are sufficient.</source>
          <target state="translated">실제로 배열의 공허함을 점검해야 할 경우 다른 답변으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="125e68683b69b0a281814ca748de40fb9e6f3516" translate="yes" xml:space="preserve">
          <source>If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input &lt;em&gt;to be&lt;/em&gt; a NumPy array.  There are a few nice functions for doing this quickly &amp;mdash;&amp;nbsp;most importantly &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen &lt;code&gt;dtype&lt;/code&gt;.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">입력이 비어 있는지 확인하는 것 이상을 수행하고 인덱싱 또는 수학 연산과 같은 다른 NumPy 기능을 사용하는 경우 입력 &lt;em&gt;을&lt;/em&gt; NumPy 배열 &lt;em&gt;로&lt;/em&gt; 만드는 것이 더 효율적일 것입니다. 이 작업을 빠르게 수행 할 수있는 몇 가지 유용한 기능이 있습니다. 가장 중요한 것은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt; 입니다. 이것은 입력을 취하거나 이미 배열 인 경우 아무것도하지 않거나 목록, 튜플 등의 경우 입력을 배열로 래핑하고 선택적으로 선택한 &lt;code&gt;dtype&lt;/code&gt; 으로 변환합니다. 따라서 가능할 때마다 매우 빠르며 입력이 NumPy 배열이라고 가정 할 수 있습니다. 배열로 변환해도 현재 &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;범위를 벗어나지&lt;/a&gt; 않기 때문에 일반적으로 동일한 이름 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8fb952d33272c37411f1179bd271c831539a4522" translate="yes" xml:space="preserve">
          <source>If you want to check if a list is empty:</source>
          <target state="translated">목록이 비어 있는지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="40e6c40dc0a9104c2eddd05cdb70a55879c0c1a5" translate="yes" xml:space="preserve">
          <source>If you want to check whether all the values in list is empty. However it will be &lt;code&gt;True&lt;/code&gt; for an empty list:</source>
          <target state="translated">목록의 모든 값이 비어 있는지 확인하려는 경우. 그러나 빈 목록에 대해서는 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="536f093032dabe47659c67529b21e5619964a16e" translate="yes" xml:space="preserve">
          <source>If you want to use both cases together:</source>
          <target state="translated">두 경우를 함께 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="8841134ee2ab08cfb3f81a5ebb9e79b04b2bff1d" translate="yes" xml:space="preserve">
          <source>If you're not sure whether it might be a &lt;code&gt;list&lt;/code&gt;, a NumPy array, or something else, you could combine this approach with &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;the answer @dubiousjim gives&lt;/a&gt; to make sure the right test is used for each type.  Not very &quot;pythonic&quot;, but it turns out that NumPy intentionally broke pythonicity in at least this sense.</source>
          <target state="translated">그것이 &lt;code&gt;list&lt;/code&gt; , NumPy 배열 또는 다른 것이 될 수 있는지 확실하지 않은 경우이 방법을 &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;@dubiousjim이 제공하는 답변&lt;/a&gt; 과 결합하여 각 유형에 올바른 테스트가 사용되도록 할 수 있습니다. &quot;pythonic&quot;은 아니지만 NumPy가 의도적으로 pythonicity를 최소한 깨뜨린 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="428f7e34ea9af326d1a0f2aad6f147c45fdb55ac" translate="yes" xml:space="preserve">
          <source>In Python, &lt;strong&gt;empty containers&lt;/strong&gt; such as lists,tuples,sets,dicts,variables etc are seen as &lt;code&gt;False&lt;/code&gt;. One could simply treat the list as a predicate (&lt;em&gt;returning a Boolean value&lt;/em&gt;). And  a &lt;code&gt;True&lt;/code&gt; value would indicate that it's non-empty.</source>
          <target state="translated">파이썬에서리스트, 튜플, 세트, ​​딕트, 변수 등과 같은 &lt;strong&gt;빈 컨테이너&lt;/strong&gt; 는 &lt;code&gt;False&lt;/code&gt; 로 보입니다. 리스트를 술어로 취급 할 수 있습니다 ( &lt;em&gt;부울 값을 리턴 함&lt;/em&gt; ). 그리고 &lt;code&gt;True&lt;/code&gt; 값은 비어 있지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a160b38c575aa7abd79420a97f3bbb8f340afc2a" translate="yes" xml:space="preserve">
          <source>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just &lt;code&gt;is_empty(any_structure)&lt;/code&gt;.</source>
          <target state="translated">리스트, 튜플, 딕셔너리 등의 모든 data_structure에 사용할 수 있습니다. 이것에 의해, &lt;code&gt;is_empty(any_structure)&lt;/code&gt; 만으로 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32bab15a2ee7ad8ba7c6641bb23e238358e1623" translate="yes" xml:space="preserve">
          <source>It is sometimes good to test for &lt;code&gt;None&lt;/code&gt; and for emptiness separately as those are two different states. The code above produces the following output:</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 과 두 개의 다른 상태이므로 공허함을 별도로 테스트하는 것이 좋은 경우가 있습니다. 위의 코드는 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c5d891bd3646d03ddb9c17a5be09027bd036ced8" translate="yes" xml:space="preserve">
          <source>It's true that &lt;code&gt;if not a:&lt;/code&gt; doesn't distinguish empty lists from &lt;code&gt;None&lt;/code&gt;, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know &lt;em&gt;what&lt;/em&gt; you want to be explicit about, so you can test for exactly that. For example, &lt;code&gt;if not a and a is not None:&lt;/code&gt; means &quot;anything falsey except None&quot;, while &lt;code&gt;if len(a) != 0:&lt;/code&gt; means &quot;only empty sequences&amp;mdash;and anything besides a sequence is an error here&quot;, and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</source>
          <target state="translated">&lt;code&gt;if not a:&lt;/code&gt; 빈 목록을 &lt;code&gt;None&lt;/code&gt; , 숫자 0 또는 빈 튜플, 빈 사용자 작성 컬렉션 유형 또는 빈 사용자 작성 not-quite-collection 유형 또는 단일 요소 NumPy 배열과 구별하지 않는 것이 사실입니다 거짓 값 등을 갖는 스칼라 역할을합니다. 때로는 명시 적으로 설명하는 것이 중요합니다. 이 경우 명시적인 내용을 알고 있으므로 정확하게 테스트 할 수 있습니다. 예를 들어, &lt;code&gt;if not a and a is not None:&lt;/code&gt; &quot;None을 제외하고 잘못된 것&quot;을 의미하고, &lt;code&gt;if len(a) != 0:&lt;/code&gt; &quot;빈 시퀀스 만 있고 시퀀스 이외의 것은 여기에 오류가 있습니다&quot;등을 의미합니다. . 테스트하려는 대상을 정확하게 테스트하는 것 외에도이 테스트가 중요하다는 것을 독자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="c7b0318d9faa41f53e682c3bbc37b5cfd1c0e726" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;has a similar notion of truthy/falsy&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;는 진실 / 거짓이라는 비슷한 개념을 가지고&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5142fae3c5db9d1461a71db588118a77074a605f" translate="yes" xml:space="preserve">
          <source>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</source>
          <target state="translated">많은 답변이 주어졌으며 많은 답변이 꽤 좋습니다. 난 그냥 수표를 추가하고 싶었다</target>
        </trans-unit>
        <trans-unit id="bf1a55fc2dfc2923592d18290d8210ac0f8e2701" translate="yes" xml:space="preserve">
          <source>Method 1 (Preferred):</source>
          <target state="translated">방법 1 (권장) :</target>
        </trans-unit>
        <trans-unit id="4e958d4a4b4554ff4a60439e18120188e8915232" translate="yes" xml:space="preserve">
          <source>Method 2 :</source>
          <target state="translated">방법 2 :</target>
        </trans-unit>
        <trans-unit id="5c1700aea4db454bd25188c6878b4574d94f6e62" translate="yes" xml:space="preserve">
          <source>Method 3:</source>
          <target state="translated">방법 3 :</target>
        </trans-unit>
        <trans-unit id="4163466ea446b9664c1bdbc1d45e8ba19c39c8f9" translate="yes" xml:space="preserve">
          <source>No one seems to have addressed questioning your &lt;em&gt;need&lt;/em&gt; to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</source>
          <target state="translated">우선 목록을 테스트 &lt;em&gt;해야&lt;/em&gt; 할 &lt;em&gt;필요성&lt;/em&gt; 에 대해 의문을 제기 한 사람은 없습니다. 추가 컨텍스트를 제공하지 않았으므로 처음 부터이 검사를 수행 할 필요는 없지만 Python의 목록 처리에 익숙하지 않다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec0c5d4d7981ce6e9ff1b380ca6846b74422e54" translate="yes" xml:space="preserve">
          <source>Note: a string is considered to be iterable. - add &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; if you want the empty string to be excluded</source>
          <target state="translated">참고 : 문자열은 반복 가능한 것으로 간주됩니다. -빈 문자열을 제외하려면 &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; 추가 하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="18b642e9538492bb0944a34dd8a2e506f10e19b4" translate="yes" xml:space="preserve">
          <source>Now let's look at the case for an unempty list:</source>
          <target state="translated">이제 빈 목록에 대한 사례를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9ca01a949b72339ff024541a16acb34d56d5458e" translate="yes" xml:space="preserve">
          <source>Now you can use:</source>
          <target state="translated">이제 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b84859507e274233a23af1cd06d846a49723981" translate="yes" xml:space="preserve">
          <source>Of course, do &lt;strong&gt;not&lt;/strong&gt; use &lt;code&gt;bool&lt;/code&gt; in &lt;code&gt;if&lt;/code&gt; (i.e., &lt;code&gt;if bool(L):&lt;/code&gt;) because it's implied. But, for the cases when &quot;is not empty&quot; is explicitly needed as a function, &lt;code&gt;bool&lt;/code&gt; is the best choice.</source>
          <target state="translated">물론 &lt;code&gt;bool&lt;/code&gt; 을 &lt;code&gt;if&lt;/code&gt; (즉, &lt;code&gt;if bool(L):&lt;/code&gt; :) 에 사용하지 &lt;strong&gt;마십시오&lt;/strong&gt; ( 암시 적이므로). 그러나 함수로 &quot;비어 있지 않다&quot;가 명시 적으로 필요한 경우에는 &lt;code&gt;bool&lt;/code&gt; 이 최선의 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d62a34899b1789ad0de88de972782e3233f85466" translate="yes" xml:space="preserve">
          <source>Other methods don't work for NumPy arrays</source>
          <target state="translated">NumPy 배열에는 다른 방법이 작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7508036889deb522e760a0d2d530c531b6a2002f" translate="yes" xml:space="preserve">
          <source>PEP 8</source>
          <target state="translated">PEP 8</target>
        </trans-unit>
        <trans-unit id="3ecde6cd436f098db79f5599fdb3667956fcbf60" translate="yes" xml:space="preserve">
          <source>Place the list in a boolean context (for example, with an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement). It will test &lt;code&gt;False&lt;/code&gt; if it is empty, and &lt;code&gt;True&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">부울 컨텍스트에 목록을 배치하십시오 (예 : &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 문 사용). 비어 있으면 &lt;code&gt;False&lt;/code&gt; 를 테스트하고 그렇지 않으면 &lt;code&gt;True&lt;/code&gt; 를 테스트합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2931340025c9c2fd67ac84f3da9bf695821b222" translate="yes" xml:space="preserve">
          <source>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</source>
          <target state="translated">파이썬 코드와 파이썬 커뮤니티에는 매우 강력한 관용구가 있습니다. 이러한 관용구를 따르면 파이썬을 경험 한 사람이라면 누구나 쉽게 코드를 읽을 수 있습니다. 그리고 당신이 그 관용구를 위반하면, 그것은 강한 신호입니다.</target>
        </trans-unit>
        <trans-unit id="d64b6eced566b47a6b2fd33e4bc9acd66737c2c8" translate="yes" xml:space="preserve">
          <source>Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly.</source>
          <target state="translated">파이썬은 C로 작성되었습니다. C 레벨에서 논리를 사용합니다. 파이썬으로 쓰는 것은 느려질 것입니다. 그리고 파이썬에 직접 내장 된 메커니즘을 사용하지 않으면 수십 배 느려질 것입니다.</target>
        </trans-unit>
        <trans-unit id="420e21b5db5cbb25f52fe0a4ec446fd398e6e2c3" translate="yes" xml:space="preserve">
          <source>Response to comments:</source>
          <target state="translated">의견에 대한 답변 :</target>
        </trans-unit>
        <trans-unit id="ea5008a4db7f66da07d14fae6d752831a2ea6498" translate="yes" xml:space="preserve">
          <source>Short Answer:</source>
          <target state="translated">짧은 대답:</target>
        </trans-unit>
        <trans-unit id="df611a40b52b245a7619d867739b3da4fbcc5aa9" translate="yes" xml:space="preserve">
          <source>Simple way is checking the length is equal zero.</source>
          <target state="translated">간단한 방법은 길이가 0인지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="799b8c4046e8b1c2ade9b021de07a884f7f35ef8" translate="yes" xml:space="preserve">
          <source>Simply use is_empty() or make function like:-</source>
          <target state="translated">is_empty ()를 사용하거나 다음과 같이 함수를 만드십시오.</target>
        </trans-unit>
        <trans-unit id="4259f87fbbe70d265110f62571c4d8eb3fa4ff0c" translate="yes" xml:space="preserve">
          <source>So instead of this:</source>
          <target state="translated">그래서 이것 대신에 :</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="78307d3a12ed5a2b855d5a3f147d8f6260767c8c" translate="yes" xml:space="preserve">
          <source>The &quot;Pythonic&quot; way is a much simpler and faster check since the length of the list is cached in the object instance header:</source>
          <target state="translated">&quot;Pythonic&quot;방식은 목록의 길이가 객체 인스턴스 헤더에 캐시되므로 훨씬 간단하고 빠른 검사입니다.</target>
        </trans-unit>
        <trans-unit id="cce1f662637f486e769a258aed0d1f1480d3aae4" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 1</source>
          <target state="translated">&quot;pythonic&quot;방식이 작동하지 않습니다 : 1 부</target>
        </trans-unit>
        <trans-unit id="a62e97267f48afa3faa3d59f99bd87e92a95b78d" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 2</source>
          <target state="translated">&quot;pythonic&quot;방식이 작동하지 않습니다 : 2 부</target>
        </trans-unit>
        <trans-unit id="228125c176323a97205fc40f5c53dc9e1b8cb415" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way fails with NumPy arrays because NumPy tries to cast the array to an array of &lt;code&gt;bool&lt;/code&gt;s, and &lt;code&gt;if x&lt;/code&gt; tries to evaluate all of those &lt;code&gt;bool&lt;/code&gt;s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a &lt;code&gt;ValueError&lt;/code&gt;:</source>
          <target state="translated">NumPy가 배열을 &lt;code&gt;bool&lt;/code&gt; 배열로 캐스트하려고 시도하고 &lt;code&gt;if x&lt;/code&gt; 가 특정 &lt;code&gt;bool&lt;/code&gt; 값을 한 번에 모든 bool 값으로 평가하려고 시도하기 때문에 &quot;pythonic&quot;방식은 NumPy 배열에서 실패합니다. 그러나 이것은 의미가 없으므로 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0a3f21db414612559e4bd0aa2e9d4ccdd7620a0b" translate="yes" xml:space="preserve">
          <source>The numpythonic way</source>
          <target state="translated">numpythonic 방법</target>
        </trans-unit>
        <trans-unit id="839d95ab808bb10053fa88f4716855013b528654" translate="yes" xml:space="preserve">
          <source>The pythonic way to do it is from the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;PEP 8 style guide&lt;/a&gt; (where &lt;strong&gt;Yes&lt;/strong&gt; means &amp;ldquo;recommended&amp;rdquo; and &lt;strong&gt;No&lt;/strong&gt; means &amp;ldquo;not recommended&amp;rdquo;):</source>
          <target state="translated">pythonic 방법은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;PEP 8 스타일 가이드&lt;/a&gt; ( &lt;strong&gt;Yes&lt;/strong&gt; 는&amp;ldquo;권장&amp;rdquo;을 의미하고 &lt;strong&gt;No&lt;/strong&gt; 는&amp;ldquo;권장하지 &lt;strong&gt;않음&lt;/strong&gt; &amp;rdquo;을 의미)에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="419ef69c944861f78388669cc2be094309f545d1" translate="yes" xml:space="preserve">
          <source>The second way is a &lt;strong&gt;&lt;code&gt;more pythonic&lt;/code&gt;&lt;/strong&gt; one. This method is an implicit way of checking and much more preferable than the previous one.</source>
          <target state="translated">두 번째 방법은 &lt;strong&gt; &lt;code&gt;more pythonic&lt;/code&gt; &lt;/strong&gt; 방법입니다. 이 방법은 암시적인 확인 방법이며 이전 방법보다 훨씬 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="26bb1f3155a5dcb9fceb486c2448558698ce4333" translate="yes" xml:space="preserve">
          <source>The truth value of an empty list is &lt;code&gt;False&lt;/code&gt; whereas for a non-empty list it is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">비어있는 목록의 실제 값은 &lt;code&gt;False&lt;/code&gt; 이고 비어 있지 않은 목록의 경우 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bbc6e8440ee75ab717bf6ec8f427152001e12352" translate="yes" xml:space="preserve">
          <source>Then it must call the function, load &lt;code&gt;0&lt;/code&gt;, and do the equality comparison in Python (instead of with C):</source>
          <target state="translated">그런 다음 함수를로드하고 &lt;code&gt;0&lt;/code&gt; 을 로드하고 Python에서 C 대신 등식 비교를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d90a30ab848b090999fc31f8d7530affde230d5d" translate="yes" xml:space="preserve">
          <source>These are correct in their respective other languages. And this is even semantically correct in Python.</source>
          <target state="translated">이들은 다른 언어로 정확합니다. 그리고 이것은 파이썬에서 의미 적으로 정확합니다.</target>
        </trans-unit>
        <trans-unit id="e237e40349b5d41720ad35c29c2a146f51cf9485" translate="yes" xml:space="preserve">
          <source>This has the benefit of handling any contents of &lt;strong&gt;a&lt;/strong&gt;, while not requiring a specific check for emptiness.  If &lt;strong&gt;a&lt;/strong&gt; is empty, the dependent block will not execute and the interpreter will fall through to the next line.</source>
          <target state="translated">이것은 공허함을위한 특정 검사를 요구하지 않으면 서의 내용을 처리 할 수 ​​있다는 이점이 있습니다. &lt;strong&gt;a&lt;/strong&gt; 가 비어 있으면 종속 블록이 실행되지 않고 인터프리터가 다음 줄로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="e07f7e1c2e6c131a4dd992f68429d70bd4456992" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;code&gt;PyObject&lt;/code&gt; that adds the &lt;code&gt;ob_size&lt;/code&gt; field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; macro.</source>
          <target state="translated">이것은 &lt;code&gt;ob_size&lt;/code&gt; 필드를 추가하는 &lt;code&gt;PyObject&lt;/code&gt; 의 확장입니다. 길이 개념이있는 객체에만 사용됩니다. 이 유형은 종종 Python / C API에 나타나지 않습니다. &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; 매크로의 확장으로 정의 된 필드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="834cb8e0db15a3974ebe92a788d932cf5c816ae7" translate="yes" xml:space="preserve">
          <source>This way it's 100% clear that &lt;code&gt;li&lt;/code&gt; is a sequence (list) and we want to test its size. My problem with &lt;code&gt;if not li: ...&lt;/code&gt; is that it gives the false impression that &lt;code&gt;li&lt;/code&gt; is a boolean variable.</source>
          <target state="translated">이렇게하면 &lt;code&gt;li&lt;/code&gt; 이 시퀀스 (목록)이며 크기를 테스트하려고한다는 것이 100 % 명확합니다. &lt;code&gt;if not li: ...&lt;/code&gt; 이 아니라면 내 문제는 ... ... &lt;code&gt;li&lt;/code&gt; 이 부울 변수라는 잘못된 인상을 준다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="517b32f316ce0d136fe88818f855b9745999ba35" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;x.size&lt;/code&gt; check work in all cases I see on this page.</source>
          <target state="translated">이렇게하면이 페이지에서 볼 수있는 모든 경우에 &lt;code&gt;x.size&lt;/code&gt; 검사가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="166295003ca1870a3de65a50bfe6d0b14501234e" translate="yes" xml:space="preserve">
          <source>To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a &lt;strong&gt;&lt;code&gt;less pythonic&lt;/code&gt;&lt;/strong&gt; way):</source>
          <target state="translated">목록이 비어 있는지 확인하려면 다음 두 가지 방법을 사용할 수 있습니다. 그러나 시퀀스 유형을 명시 적으로 확인하는 방법을 피해야한다는 것을 명심하십시오 (그것은 &lt;strong&gt; &lt;code&gt;less pythonic&lt;/code&gt; &lt;/strong&gt; 방법입니다).</target>
        </trans-unit>
        <trans-unit id="d88775ff0c4e2103146fa814bf595e1bad3bd121" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;len&lt;/code&gt; can give unexpected results</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 을 사용하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3210b647602906055a2ea6630c8e3fee2353fdbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;implicit booleanness&lt;/a&gt; of the empty &lt;code&gt;list&lt;/code&gt; is quite pythonic.</source>
          <target state="translated">빈 &lt;code&gt;list&lt;/code&gt; 의 &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;암시 적 부울&lt;/a&gt; 을 사용하는 것은 꽤 비판적 입니다.</target>
        </trans-unit>
        <trans-unit id="e4100216a9aee376fd77c24841324702e83c57b2" translate="yes" xml:space="preserve">
          <source>Very handy and useful.</source>
          <target state="translated">매우 편리하고 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bec8251989ae95f17e7917e7a4667d9b939024a6" translate="yes" xml:space="preserve">
          <source>We can see there's a bit of linear cost for each additional &lt;code&gt;not&lt;/code&gt; here. We want to see the costs, &lt;em&gt;ceteris paribus&lt;/em&gt;, that is, all else equal - where all else is minimized as far as possible:</source>
          <target state="translated">여기서 추가 &lt;code&gt;not&lt;/code&gt; 때마다 약간의 선형 비용이 있음을 알 수 있습니다. 우리는 &lt;em&gt;ceteris paribus&lt;/em&gt; 의 비용, 즉 다른 모든 것이 가능한 한 최소화되는 곳을보고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="0a1d52cb17cca8e7191f36986558bb72f7957e50" translate="yes" xml:space="preserve">
          <source>We see that &lt;em&gt;either&lt;/em&gt; checking for length with the builtin function &lt;code&gt;len&lt;/code&gt; compared to &lt;code&gt;0&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; checking against an empty list is &lt;strong&gt;much&lt;/strong&gt; less performant than using the builtin syntax of the language as documented.</source>
          <target state="translated">내장 함수 &lt;code&gt;len&lt;/code&gt; 을 사용하여 길이를 &lt;code&gt;0&lt;/code&gt; 과 비교 &lt;em&gt;하거나&lt;/em&gt; 빈 목록을 검사하는 것이 문서의 언어 내장 구문을 사용하는 것보다 성능이 &lt;strong&gt;훨씬&lt;/strong&gt; 떨어진다는 &lt;strong&gt;것을 알 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="93defcec033f02c7813b4fa2999f8fa8e135291c" translate="yes" xml:space="preserve">
          <source>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</source>
          <target state="translated">표준 라이브러리 코드는 가능한 성능 있고 정확해야합니다. 그러나 왜 그런가, 왜 우리는이 지침이 필요한가?</target>
        </trans-unit>
        <trans-unit id="53f50b6170acffe67cc4616bcd8c695dc5c3e587" translate="yes" xml:space="preserve">
          <source>What brought me here is a special use-case: I actually wanted a &lt;em&gt;function&lt;/em&gt; to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough):</source>
          <target state="translated">여기에 가져온 것은 특별한 유스 케이스입니다. 목록이 비어 있는지 여부를 알려주는 &lt;em&gt;함수&lt;/em&gt; 가 실제로 필요했습니다. 나는 내 자신의 함수를 작성하거나 여기에서 람다 표현을 사용하지 않기를 원했습니다 (충분히 단순해야하기 때문에).</target>
        </trans-unit>
        <trans-unit id="6c52a1ca8670775a8c8a00491e8712ffcaca818c" translate="yes" xml:space="preserve">
          <source>What we can see here is that it makes little difference whether you pass in an actual &lt;code&gt;bool&lt;/code&gt; to the condition check or the list itself, and if anything, giving the list, as is, is faster.</source>
          <target state="translated">여기서 볼 수있는 것은 실제 &lt;code&gt;bool&lt;/code&gt; 을 조건 확인이나 목록 자체에 전달하는지 여부와 거의 상관없이 목록을 제공하는 것이 더 빠르다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a4d3c26f7312a3bcafab015f36e0c94e6e8659e" translate="yes" xml:space="preserve">
          <source>Why check at all?</source>
          <target state="translated">왜 확인해야합니까?</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="3ecc4c96e7de4be0cda6aa9f38dc351865be20e7" translate="yes" xml:space="preserve">
          <source>You can even try using bool() like this</source>
          <target state="translated">이처럼 bool ()을 사용해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65dd7b083f4ea2c1ee4f439f364acdec6b47258" translate="yes" xml:space="preserve">
          <source>You can get away without the explicit type check, but only if the surrounding context already assures you that &lt;code&gt;a&lt;/code&gt; is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a &lt;code&gt;TypeError&lt;/code&gt; if you call &lt;code&gt;len&lt;/code&gt; on a value for which it's undefined) that you're prepared to handle. In general, the &quot;pythonic&quot; conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to &lt;em&gt;think&lt;/em&gt; about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on &lt;code&gt;len&lt;/code&gt; or the boolean typecast may not do precisely what you're expecting.</source>
          <target state="translated">명시 적 유형 검사없이 벗어날 수 있지만 주변 컨텍스트에서 이미 &lt;code&gt;a&lt;/code&gt; 가 처리 할 준비가 된 유형의 값임을 보증하거나 처리 할 준비가되지 않은 유형이 처리 할 준비가 된 오류 (예 : 정의되지 않은 값으로 &lt;code&gt;len&lt;/code&gt; 을 호출하면 &lt;code&gt;TypeError&lt;/code&gt; )가 발생합니다. 일반적으로 &quot;파이 토닉 (pythonic)&quot;규칙은이 마지막 방식으로 진행됩니다. 오리처럼 꽉 쥐고 qua 방법을 모르는 경우 DuckError를 발생 시키십시오. 그래도 어떤 유형의 가정을하고 있는지, 제대로 처리 할 준비가되지 않은 사례가 실제로 올바른 위치에서 오류가 발생하는지에 대해 생각해야합니다. Numpy 배열은 &lt;code&gt;len&lt;/code&gt; 또는 boolean typecast에 맹목적으로 의존하는 것이 예상 한 것을 정확하게 수행하지 못하는 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="9083cd48fae65c5b68f6712180202c73821b23fa" translate="yes" xml:space="preserve">
          <source>You need to be careful with NumPy arrays, because other methods that work fine for &lt;code&gt;list&lt;/code&gt;s or other standard containers fail for NumPy arrays.  I explain why below, but in short, the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;preferred method&lt;/a&gt; is to use &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">NumPy 배열에는주의해야합니다. &lt;code&gt;list&lt;/code&gt; 또는 다른 표준 컨테이너에 대해 잘 작동하는 다른 메소드는 NumPy 배열에 실패하기 때문입니다. 왜 아래에 설명하지만 간단히 말해서 &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;선호하는 방법&lt;/a&gt; 은 &lt;code&gt;size&lt;/code&gt; 를 사용하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="b7d227705c28851b3cabdba2c9c370a4f7063204" translate="yes" xml:space="preserve">
          <source>Your duckCollection should implement &lt;code&gt;__nonzero__&lt;/code&gt; or &lt;code&gt;__len__&lt;/code&gt; so the if a: will work without problems.</source>
          <target state="translated">duckCollection은 &lt;code&gt;__nonzero__&lt;/code&gt; 또는 &lt;code&gt;__len__&lt;/code&gt; 을 구현해야 if a :가 문제없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e1f11fedb84b9948d72cba30d27c4ba1e5b96b6b" translate="yes" xml:space="preserve">
          <source>a little more practical:</source>
          <target state="translated">좀 더 실용적입니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="5fa43287b1c5b62b65463b926344285e74e283b5" translate="yes" xml:space="preserve">
          <source>and shertest version:</source>
          <target state="translated">그리고 shertest 버전 :</target>
        </trans-unit>
        <trans-unit id="83ab88ee561c2c3fbf9a72f4e64edd6d102bc31c" translate="yes" xml:space="preserve">
          <source>any empty mapping, for example, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">빈 매핑 (예 : &lt;code&gt;{}&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f2952616e90efb7a6dd44095c44dfdd2377bc3ab" translate="yes" xml:space="preserve">
          <source>any empty sequence, for example, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">빈 시퀀스 (예 : &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b131ef05b1826b4dcf14f5da963e3b8f3d60f6f6" translate="yes" xml:space="preserve">
          <source>constants defined to be false: &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">false로 정의 된 상수 : &lt;code&gt;None&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa71fa14fe89fc7eb25cd68186ad53611ebfd167" translate="yes" xml:space="preserve">
          <source>empty sequences and collections: &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;range(0)&lt;/code&gt;</source>
          <target state="translated">빈 시퀀스 및 컬렉션 : &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , &lt;code&gt;set()&lt;/code&gt; , &lt;code&gt;range(0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="054f2c8e08dfd096608d12043bbc8cd93bbd3d80" translate="yes" xml:space="preserve">
          <source>if you only want to accept instances of particular types (and their subtypes), or with:</source>
          <target state="translated">특정 유형의 인스턴스 및 하위 유형 만 허용하려는 경우 또는</target>
        </trans-unit>
        <trans-unit id="bbe92aa90ac3da927a82d780633d2c79550b5147" translate="yes" xml:space="preserve">
          <source>instances of user-defined classes, if the class defines a &lt;code&gt;__bool__()&lt;/code&gt; or &lt;code&gt;__len__()&lt;/code&gt; method, when that method returns the integer zero or bool value &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">클래스가 &lt;code&gt;__bool__()&lt;/code&gt; 또는 &lt;code&gt;__len__()&lt;/code&gt; 메서드를 정의하는 경우 해당 메서드가 정수 0 또는 부울 값 &lt;code&gt;False&lt;/code&gt; 를 반환 할 때 사용자 정의 클래스의 인스턴스</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">아니면 이거:</target>
        </trans-unit>
        <trans-unit id="5fe84e072cb8774215db86ddfc171c8aa9283127" translate="yes" xml:space="preserve">
          <source>produces expected</source>
          <target state="translated">예상 생산</target>
        </trans-unit>
        <trans-unit id="bdb401ea8d165ea2005c10c5877c586d8207bf1a" translate="yes" xml:space="preserve">
          <source>returns 1, even though the array has zero elements.</source>
          <target state="translated">배열에 요소가없는 경우에도 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f03e5ffbf02bb878e6dd52843870f4e01cc42fb" translate="yes" xml:space="preserve">
          <source>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</source>
          <target state="translated">첫 번째 테스트는 위의 @Mike의 답변에 대한 응답입니다. 세 번째 줄은 다음과 같이 바꿀 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a818933ef67b2d17d00dabdb02f08102734ba6d7" translate="yes" xml:space="preserve">
          <source>to check if the list is empty</source>
          <target state="translated">목록이 비어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="113a8713eff230494f7adff7cabd13b33e7a718c" translate="yes" xml:space="preserve">
          <source>we could use a simple if else:</source>
          <target state="translated">그렇지 않으면 간단한 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e6b798f41cc1b686d5e5e68f072d8fc897174b" translate="yes" xml:space="preserve">
          <source>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as &quot;pythonic&quot;---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where &lt;code&gt;a&lt;/code&gt; is, for example, &lt;code&gt;False&lt;/code&gt;, you need a test more restrictive than just &lt;code&gt;if not a:&lt;/code&gt;. You could use something like this:</source>
          <target state="translated">-1로 선정되었습니다. 독자가 전략에 반대하거나 답변이 제시된대로 도움이되지 않는다고 생각했기 때문인지 잘 모르겠습니다. 나는 이것이 &quot;파이 토닉 (pythonic)&quot;으로 간주되는 것이기 때문에 후자 인 것처럼 가장 할 것이다. 이것이 올바른 전략이다. 이미 배제하지 않았거나 예를 들어 &lt;code&gt;False&lt;/code&gt; 와 같은 경우를 처리 할 준비가 &lt;code&gt;if not a:&lt;/code&gt; 보다 더 제한적인 테스트가 필요합니다. 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c021d12abb7b3e2b39cca48ff8eeeb38bb02d18" translate="yes" xml:space="preserve">
          <source>will also pass for &lt;code&gt;None&lt;/code&gt; and other types of empty structures. If you truly want to check for an empty list, you can do this:</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 및 다른 유형의 빈 구조도 전달합니다. 빈 목록을 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e6f0e52997217d3b5a709de67763a194e319b26" translate="yes" xml:space="preserve">
          <source>zero of any numeric type, for example, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;.</source>
          <target state="translated">숫자 유형의 &lt;code&gt;0&lt;/code&gt; ( 예 : 0 , &lt;code&gt;0.0&lt;/code&gt; , &lt;code&gt;0j&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9a325962fa4501e445c5fc397f589278bbc1b016" translate="yes" xml:space="preserve">
          <source>zero of any numeric type: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;, &lt;code&gt;Decimal(0)&lt;/code&gt;, &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</source>
          <target state="translated">모든 숫자 유형의 &lt;code&gt;0&lt;/code&gt; : 0 , &lt;code&gt;0.0&lt;/code&gt; , &lt;code&gt;0j&lt;/code&gt; , &lt;code&gt;Decimal(0)&lt;/code&gt; , &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
