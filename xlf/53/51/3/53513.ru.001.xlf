<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/53513">
    <body>
      <group id="53513">
        <trans-unit id="fa6087ea829d2efe469e42d5b4ea7ef6c710c3b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt;&lt;code&gt;len()&lt;/code&gt; is an O(1) operation&lt;/a&gt; for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</source>
          <target state="translated">&lt;a href=&quot;http://books.google.com/books?id=vpTAq4dnmuAC&amp;amp;pg=RA1-PA479&amp;amp;lpg=RA1-PA479&amp;amp;dq=Python+len+big+O&amp;amp;source=web&amp;amp;ots=AOM6A1K9Fy&amp;amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=4&amp;amp;ct=result&quot;&gt; &lt;code&gt;len()&lt;/code&gt; - это операция O (1)&lt;/a&gt; для списков, строк, диктов и множеств Python. Python внутренне отслеживает количество элементов в этих контейнерах.</target>
        </trans-unit>
        <trans-unit id="85fd292fdea964654b12fcc3bff501372a02fc3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;Patrick's (accepted) answer&lt;/a&gt; is right: &lt;code&gt;if not a:&lt;/code&gt; is the right way to do it. &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;Harley Holcombe's answer&lt;/a&gt; is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom&amp;mdash;even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/53522/908494&quot;&gt;Ответ Патрика (принятый)&lt;/a&gt; правильный: &lt;code&gt;if not a:&lt;/code&gt; это правильный способ сделать это. Правильный &lt;a href=&quot;https://stackoverflow.com/a/53752/908494&quot;&gt;ответ Харли Холкомба&lt;/a&gt; - это руководство по стилю PEP 8. Но то, что ни один из ответов не объясняет, - это то, почему это хорошая идея следовать идиоме, даже если вы лично обнаружите, что она недостаточно ясна или сбивает с толку пользователей Ruby или чего-либо еще.</target>
        </trans-unit>
        <trans-unit id="f6bd068dee72f5e7acd72d046b51628d73431616" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt;, the official Python style guide for Python code in Python's standard library, asserts:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot;&gt;PEP 8&lt;/a&gt; , официальное руководство по стилю Python для кода Python в стандартной библиотеке Python, утверждает:</target>
        </trans-unit>
        <trans-unit id="709c05e03db9fe7106ff167bae3e20510ada6c6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; The pretty simple pythonic way:</source>
          <target state="translated">&lt;strong&gt;1)&lt;/strong&gt; Довольно простой питонический способ:</target>
        </trans-unit>
        <trans-unit id="73bff0478225a1ca5de41c8041fd2f172d65b5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; A much explicit way: using the &lt;code&gt;len()&lt;/code&gt; to find the length and check if it equals to &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;2)&lt;/strong&gt; Очень явный способ: с помощью &lt;code&gt;len()&lt;/code&gt; найти длину и проверить, равна ли она &lt;code&gt;0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9d4a74112f8906073526e0491135de335a7db27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt; Or comparing it to an anonymous empty list:</source>
          <target state="translated">&lt;strong&gt;3)&lt;/strong&gt; Или сравнивая его с анонимным пустым списком:</target>
        </trans-unit>
        <trans-unit id="406daadaa5d41723954f852ca3012418a893aa74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4)&lt;/strong&gt; Another yet &lt;em&gt;silly&lt;/em&gt; way to do is using &lt;code&gt;exception&lt;/code&gt; and &lt;code&gt;iter()&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;4)&lt;/strong&gt; Еще один &lt;em&gt;глупый&lt;/em&gt; способ - использовать &lt;code&gt;exception&lt;/code&gt; и &lt;code&gt;iter()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d2003a249df2249cead04ad47fd9076516a663f" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;This is the first google hit for &quot;python test empty array&quot; and similar queries, plus other people seem to be generalizing the question beyond just lists, so I thought I'd add a caveat for a different type of sequence that a lot of people might use.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Это первый хит от Google для &amp;laquo;пустого массива python test&amp;raquo; и аналогичных запросов, плюс другие люди, кажется, обобщают вопрос не только для списков, поэтому я решил добавить предостережение для другого типа последовательности, которую многие люди может использовать.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e08157bc06e9b1d4da704ba91099e16c06508dab" translate="yes" xml:space="preserve">
          <source>@Daren Thomas</source>
          <target state="translated">@Дарен Томас</target>
        </trans-unit>
        <trans-unit id="dbf83e4117a99476070d823064700dc3ed352dc3" translate="yes" xml:space="preserve">
          <source>All values other than what is listed here are considered &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">Все значения, кроме перечисленных здесь, считаются &lt;code&gt;True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a2a7eec8c7ee8d914fe13445e4f282e1b2a7082" translate="yes" xml:space="preserve">
          <source>Although it's worth nothing that &lt;code&gt;None&lt;/code&gt; is falsy. So if you don't want to separate test for &lt;code&gt;None&lt;/code&gt;-ness, you don't have to do that.</source>
          <target state="translated">Хотя это ничего не стоит, что &lt;code&gt;None&lt;/code&gt; является ложным. Так что, если вы не хотите отделить тест на &lt;code&gt;None&lt;/code&gt; , вам не нужно этого делать.</target>
        </trans-unit>
        <trans-unit id="a3eda0c093884c5cdf292a4a6958a44bd4e2a71d" translate="yes" xml:space="preserve">
          <source>An empty list is itself considered false in true value testing (see &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;python documentation&lt;/a&gt;):</source>
          <target state="translated">Пустой список сам по себе считается ложным в тестировании истинного значения (см. &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#truth-value-testing&quot;&gt;Документацию по Python&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="ab5f88a40a649b5bd874e7e3cf70712fe8fcfbfb" translate="yes" xml:space="preserve">
          <source>And for the &lt;code&gt;[] == []&lt;/code&gt; it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</source>
          <target state="translated">А для &lt;code&gt;[] == []&lt;/code&gt; необходимо создать ненужный список, а затем снова выполнить операцию сравнения на виртуальной машине Python (в отличие от C).</target>
        </trans-unit>
        <trans-unit id="44044d9b0333bc1e2793c401ceb8f5611f29a99f" translate="yes" xml:space="preserve">
          <source>And the datamodel documentation:</source>
          <target state="translated">И документация по моделям данных:</target>
        </trans-unit>
        <trans-unit id="45af135cc0b7fd22346b0a3dce703ee3a4f1fac5" translate="yes" xml:space="preserve">
          <source>And users of lazy languages may be tempted to do this:</source>
          <target state="translated">И у пользователей ленивых языков может возникнуть соблазн сделать это:</target>
        </trans-unit>
        <trans-unit id="6202056bf6b3d838f4ff8c5b7307d6357e08439f" translate="yes" xml:space="preserve">
          <source>And, of course, there is a very natural way to do it:</source>
          <target state="translated">И,конечно,есть очень естественный способ сделать это:</target>
        </trans-unit>
        <trans-unit id="ff47252d65d441c800203256a95b3a6607509fac" translate="yes" xml:space="preserve">
          <source>As can be seen, empty list &lt;code&gt;[]&lt;/code&gt; is &lt;em&gt;falsy&lt;/em&gt;, so doing what would be done to a boolean value sounds most efficient:</source>
          <target state="translated">Как можно видеть, пустой список &lt;code&gt;[]&lt;/code&gt; является &lt;em&gt;ложным&lt;/em&gt; , поэтому наиболее эффективным будет то, что будет сделано с логическим значением:</target>
        </trans-unit>
        <trans-unit id="bba28c4ea8d4854a5cac4c82193c5746abc143e3" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;SciPy FAQ&lt;/a&gt;, the correct method in all cases where you know you have a NumPy array is to use &lt;code&gt;if x.size&lt;/code&gt;:</source>
          <target state="translated">Как объясняется в &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;FAQ&lt;/a&gt; по SciPy , правильный метод во всех случаях, когда вы знаете, что у вас есть массив NumPy, должен использовать &lt;code&gt;if x.size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c2a373c95098f9c06da7f59b6f9464570c1f1907" translate="yes" xml:space="preserve">
          <source>Being inspired by @dubiousjim's solution, I propose to use an additional general check of whether is it something iterable</source>
          <target state="translated">Вдохновляясь решением @dubiousjim,я предлагаю использовать дополнительную общую проверку того,является ли это чем-то выполнимым.</target>
        </trans-unit>
        <trans-unit id="3ab76bc795d839d5beddbad54e0ccdf03bc826b1" translate="yes" xml:space="preserve">
          <source>Best way to check if a list is empty</source>
          <target state="translated">Лучший способ проверить,пуст ли список</target>
        </trans-unit>
        <trans-unit id="eca779c7f85faf34e05c115f1686ec19c2ba5f60" translate="yes" xml:space="preserve">
          <source>But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the &lt;code&gt;if&lt;/code&gt; statement will &quot;work&quot;, in the sense that you don't get an error.  However, if that one element happens to be &lt;code&gt;0&lt;/code&gt; (or &lt;code&gt;0.0&lt;/code&gt;, or &lt;code&gt;False&lt;/code&gt;, ...), the &lt;code&gt;if&lt;/code&gt; statement will incorrectly result in &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">Но, по крайней мере, приведенный выше случай говорит вам, что это не удалось. Если у вас есть массив NumPy с ровно одним элементом, оператор &lt;code&gt;if&lt;/code&gt; будет &amp;laquo;работать&amp;raquo; в том смысле, что вы не получите ошибку. Однако, если этот один элемент окажется равным &lt;code&gt;0&lt;/code&gt; (или &lt;code&gt;0.0&lt;/code&gt; , или &lt;code&gt;False&lt;/code&gt; , ...), оператор &lt;code&gt;if&lt;/code&gt; неверно приведет к &lt;code&gt;False&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="daf538c97712481cae9a4d466b7c25253ade40a8" translate="yes" xml:space="preserve">
          <source>But clearly &lt;code&gt;x&lt;/code&gt; exists and is not empty!  This result is not what you wanted.</source>
          <target state="translated">Но ясно, что &lt;code&gt;x&lt;/code&gt; существует и не пусто! Этот результат не то, что вы хотели.</target>
        </trans-unit>
        <trans-unit id="352789ca029b151d48e5b54d32774d3617bff5aa" translate="yes" xml:space="preserve">
          <source>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</source>
          <target state="translated">Но мы считаем его непитоновским,потому что Python поддерживает эту семантику непосредственно в интерфейсе объекта списка с помощью булевого принуждения.</target>
        </trans-unit>
        <trans-unit id="b38bccd576f28416712521493d4fcfd148c28f3f" translate="yes" xml:space="preserve">
          <source>But when you don't have anything to be explicit about, anything other than &lt;code&gt;if not a:&lt;/code&gt; is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you &lt;em&gt;habitually&lt;/em&gt; mislead the reader like this, then when you &lt;em&gt;do&lt;/em&gt; need to make a distinction, it's going to pass unnoticed because you've been &quot;crying wolf&quot; all over your code.</source>
          <target state="translated">Но когда у вас нет ничего, что можно было бы выразить явно, все, кроме, &lt;code&gt;if not a:&lt;/code&gt; вводит читателя в заблуждение. Вы сигнализируете о чем-то важном, когда это не так. (Вы также можете сделать код менее гибким, медленным или каким-то другим, но это все менее важно.) И если вы &lt;em&gt;обычно&lt;/em&gt; вводите читателя в заблуждение, как это, тогда, когда вам нужно будет провести различие, оно пройдет незамеченным, потому что ты был &quot;плачущим волком&quot; по всему твоему коду.</target>
        </trans-unit>
        <trans-unit id="f3c03b9e169237bd714c4403d329565895990596" translate="yes" xml:space="preserve">
          <source>By default, an object is considered true unless its class defines
  either a &lt;code&gt;__bool__()&lt;/code&gt; method that returns &lt;code&gt;False&lt;/code&gt; or a &lt;code&gt;__len__()&lt;/code&gt; method
  that returns zero, when called with the object. Here are most of the built-in objects considered false:</source>
          <target state="translated">По умолчанию объект считается истинным, если его класс не определяет &lt;code&gt;__bool__()&lt;/code&gt; который возвращает &lt;code&gt;False&lt;/code&gt; , или &lt;code&gt;__len__()&lt;/code&gt; который возвращает ноль при вызове с объектом. Вот большинство встроенных объектов, которые считаются ложными:</target>
        </trans-unit>
        <trans-unit id="0fdcbacfeed5434a99e0a6a9a898a2d1742fc056" translate="yes" xml:space="preserve">
          <source>Called to implement the built-in function &lt;code&gt;len()&lt;/code&gt;. Should return the length of the object, an integer &amp;gt;= 0. Also, an object that doesn&amp;rsquo;t define a &lt;code&gt;__bool__()&lt;/code&gt; method and whose &lt;code&gt;__len__()&lt;/code&gt; method returns zero is considered to be false in a Boolean context.</source>
          <target state="translated">Вызывается для реализации встроенной функции &lt;code&gt;len()&lt;/code&gt; . Должен возвращать длину объекта, целое число&amp;gt; = 0. Кроме того, объект, который не определяет &lt;code&gt;__bool__()&lt;/code&gt; и чей метод &lt;code&gt;__len__()&lt;/code&gt; возвращает ноль, считается ложным в логическом контексте.</target>
        </trans-unit>
        <trans-unit id="e25864a93b493700b01d581e68d0cd82ca932f25" translate="yes" xml:space="preserve">
          <source>Called to implement truth value testing and the built-in operation &lt;code&gt;bool()&lt;/code&gt;; should return &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;. When this method is not defined,
  &lt;code&gt;__len__()&lt;/code&gt; is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither &lt;code&gt;__len__()&lt;/code&gt;
  nor &lt;code&gt;__bool__()&lt;/code&gt;, all its instances are considered true.</source>
          <target state="translated">Вызывается для выполнения проверки истинности и встроенной операции &lt;code&gt;bool()&lt;/code&gt; ; должен вернуть &lt;code&gt;False&lt;/code&gt; или &lt;code&gt;True&lt;/code&gt; . Когда этот метод не определен, &lt;code&gt;__len__()&lt;/code&gt; , если он определен, и объект считается истинным, если его результат ненулевой. Если класс не определяет ни &lt;code&gt;__len__()&lt;/code&gt; ни &lt;code&gt;__bool__()&lt;/code&gt; , все его экземпляры считаются истинными.</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">Сделай это:</target>
        </trans-unit>
        <trans-unit id="f5b5eede35878f55c7d57820131de56da262d55f" translate="yes" xml:space="preserve">
          <source>Does it pay off? (Note that less time to perform an equivalent operation is better:)</source>
          <target state="translated">Это окупается? (Обратите внимание,что меньше времени на выполнение эквивалентной операции лучше:)</target>
        </trans-unit>
        <trans-unit id="373d23c12606180ec0cf1beb638fb73524fadb61" translate="yes" xml:space="preserve">
          <source>Doing what's Pythonic usually pays off in performance:</source>
          <target state="translated">Делать то,что Pythonic обычно окупается в исполнении:</target>
        </trans-unit>
        <trans-unit id="97f2e93e05fd80db822418cf3feec3652cf3a370" translate="yes" xml:space="preserve">
          <source>EDIT : This works with python2.7 too..</source>
          <target state="translated">ЭДИТ:Это работает и с питоном 2.7...</target>
        </trans-unit>
        <trans-unit id="a76d5cc35692d4dad67addbef26267cdf67ffeed" translate="yes" xml:space="preserve">
          <source>EDIT: Another point against testing
  the empty list as False: What about
  polymorphism? You shouldn't depend on
  a list being a list. It should just
  quack like a duck - how are you going
  to get your duckCollection to quack
  ''False'' when it has no elements?</source>
          <target state="translated">EDIT:Еще один пункт против тестирования пустого списка как False:Как насчет полиморфизма? Вы не должны зависеть от того,что список является списком.Он должен просто крякать как утка-как вы собираетесь заставить вашу утиную коллекцию крякать ''False'',когда в ней нет элементов?</target>
        </trans-unit>
        <trans-unit id="dcedc96969a1d0a6f2a233b8f6888a0a00ab7357" translate="yes" xml:space="preserve">
          <source>Evidence from the C source and documentation</source>
          <target state="translated">Доказательства из источника на языке С и документация</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c25e4d6b416a6cd9233a3e845e94921c7430d50d" translate="yes" xml:space="preserve">
          <source>First Python has to check the globals to see if &lt;code&gt;len&lt;/code&gt; is shadowed.</source>
          <target state="translated">Сначала Python должен проверить глобальные переменные, чтобы увидеть, не &lt;code&gt;len&lt;/code&gt; ли len .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="f3412712dcaf0e84cb53a746ad7e9f73d9013702" translate="yes" xml:space="preserve">
          <source>For example, if passed the following:</source>
          <target state="translated">Например,если передать следующее:</target>
        </trans-unit>
        <trans-unit id="1bad339600e3699390f0ed87a2003eee92c4dfcf" translate="yes" xml:space="preserve">
          <source>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</source>
          <target state="translated">Для масштаба,вот стоимость вызова функции и построения и возврата пустого списка,которую можно вычесть из стоимости использованных выше проверок на пустоту:</target>
        </trans-unit>
        <trans-unit id="e7f942debb8d0e14241aa308336c922d6775903a" translate="yes" xml:space="preserve">
          <source>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</source>
          <target state="translated">Для последовательностей (строк,списков,кортежей)используйте тот факт,что пустые последовательности ложны.</target>
        </trans-unit>
        <trans-unit id="bac1c52ffa1b4459d0f919bc355c6d2057242350" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;len(a) == 0&lt;/code&gt; check:</source>
          <target state="translated">Для &lt;code&gt;len(a) == 0&lt;/code&gt; проверьте:</target>
        </trans-unit>
        <trans-unit id="aaaaeb6ed2be6a7373f22ebc411776f617e21985" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;documentation&lt;/a&gt; on truth value testing:</source>
          <target state="translated">Из &lt;a href=&quot;https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing&quot;&gt;документации&lt;/a&gt; по проверке истинности стоимости:</target>
        </trans-unit>
        <trans-unit id="609634de36f52ce2e3fd7aa8ecbe7c6e9b48a3be" translate="yes" xml:space="preserve">
          <source>From python3 onwards you can use</source>
          <target state="translated">Начиная с питона 3 и далее вы можете использовать</target>
        </trans-unit>
        <trans-unit id="1232457a90ed6c80cf66104828eec8c675b2e5f6" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;docs&lt;/a&gt; (and note specifically the inclusion of the empty list, &lt;code&gt;[]&lt;/code&gt;):</source>
          <target state="translated">Из &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;документов&lt;/a&gt; (и обратите особое внимание на включение пустого списка, &lt;code&gt;[]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="728f688a52623e6d5037d6bbdfb3e7ba80193709" translate="yes" xml:space="preserve">
          <source>From the c source in &lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include/listobject.h&lt;/a&gt;:</source>
          <target state="translated">Из c источника в &lt;a href=&quot;https://github.com/python/cpython/blob/master/Include/listobject.h&quot;&gt;Include / listobject.h&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="683112e7d730f26c7bccb345b8ef7aaf95794090" translate="yes" xml:space="preserve">
          <source>Here are a few ways you can check if a list is empty:</source>
          <target state="translated">Вот несколько способов проверить,пуст ли список:</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="5ff7fbc89be7316e185d7a00a7ff3d90d022034c" translate="yes" xml:space="preserve">
          <source>How do I check if a list is empty</source>
          <target state="translated">Как проверить,пуст ли список</target>
        </trans-unit>
        <trans-unit id="33c5d06ed9c860acea48b74dc4a823901ef3f8f1" translate="yes" xml:space="preserve">
          <source>How do I check to see if &lt;code&gt;a&lt;/code&gt; is empty?</source>
          <target state="translated">Как проверить, пусто ли?</target>
        </trans-unit>
        <trans-unit id="e5fcefe7e34c52a1195ed32056bdb1089ea254b1" translate="yes" xml:space="preserve">
          <source>How do I check to see if a is empty?</source>
          <target state="translated">Как проверить,не пустая ли она?</target>
        </trans-unit>
        <trans-unit id="a9f1c0fc9cfe4503ffc9501fffdfcb4226311e22" translate="yes" xml:space="preserve">
          <source>I am not sure why there are so many complicated answers.
It's pretty clear and straightforward</source>
          <target state="translated">Я не понимаю,почему так много сложных ответов.Это довольно ясно и прямолинейно.</target>
        </trans-unit>
        <trans-unit id="25ab0752fffc84134368c44c5351c7020c10bf59" translate="yes" xml:space="preserve">
          <source>I frequently see code like this from experienced programmers new to Python:</source>
          <target state="translated">Я часто вижу подобный код у опытных программистов,только что перешедших на Python:</target>
        </trans-unit>
        <trans-unit id="70fe8a86746b4223af6f5c03bf7b7263ef48e957" translate="yes" xml:space="preserve">
          <source>I had written:</source>
          <target state="translated">Я писал:</target>
        </trans-unit>
        <trans-unit id="503904ef0bb804cf7a77e21d4237ad21f29e4536" translate="yes" xml:space="preserve">
          <source>I love this way for checking list is empty or not.</source>
          <target state="translated">Мне нравится этот способ,так как список пуст или нет.</target>
        </trans-unit>
        <trans-unit id="6936816d820ecc9d4d156fa6961e9db56da9a535" translate="yes" xml:space="preserve">
          <source>I prefer it explicitly:</source>
          <target state="translated">Я предпочитаю прямо:</target>
        </trans-unit>
        <trans-unit id="c822b9b00d42f96380485775d1aabfaff330ecc8" translate="yes" xml:space="preserve">
          <source>I prefer the following:</source>
          <target state="translated">Я предпочитаю следующее:</target>
        </trans-unit>
        <trans-unit id="07d7c92c83648b3dcf817f34c2fe61d11e207210" translate="yes" xml:space="preserve">
          <source>I suppose the problem is testing with timeit since just &lt;code&gt;if l:&lt;/code&gt; is sufficient but surprisingly &lt;code&gt;%timeit bool(l)&lt;/code&gt; yields 101 ns &amp;plusmn; 2.64 ns. Interesting there is no way to coerce to bool without this penalty. &lt;code&gt;%timeit l&lt;/code&gt; is useless since no conversion would occur.</source>
          <target state="translated">Я полагаю, что проблема заключается в тестировании с timeit, поскольку только &lt;code&gt;if l:&lt;/code&gt; достаточно, но неожиданно &lt;code&gt;%timeit bool(l)&lt;/code&gt; дает 101 нс &amp;plusmn; 2,64 нс. Интересно, что без этого наказания невозможно навязать бул. &lt;code&gt;%timeit l&lt;/code&gt; бесполезен, так как преобразование не произойдет.</target>
        </trans-unit>
        <trans-unit id="4a53819da8c55112c5bbdb5ec0a8f8c0331eed55" translate="yes" xml:space="preserve">
          <source>I would argue that the &lt;em&gt;most pythonic&lt;/em&gt; way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</source>
          <target state="translated">Я бы сказал, что &lt;em&gt;самый питонский&lt;/em&gt; способ - это вообще не проверять, а просто обрабатывать список. Таким образом, он будет делать правильные вещи, будь то пустой или полный.</target>
        </trans-unit>
        <trans-unit id="df53c7c830c1b687f914d825896b14ea3616de2b" translate="yes" xml:space="preserve">
          <source>I would point out that this is also true for the non-empty case though its pretty ugly as with &lt;code&gt;l=[]&lt;/code&gt; then &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90.6 ns &amp;plusmn; 8.3 ns, &lt;code&gt;%timeit l != []&lt;/code&gt; 55.6 ns &amp;plusmn; 3.09, &lt;code&gt;%timeit not not l&lt;/code&gt; 38.5 ns &amp;plusmn; 0.372. But there is no way anyone is going to enjoy &lt;code&gt;not not l&lt;/code&gt; despite triple the speed. It looks ridiculous. But the speed wins out</source>
          <target state="translated">Я хотел бы отметить, что это также верно для непустого случая, хотя это довольно уродливо, как с &lt;code&gt;l=[]&lt;/code&gt; , тогда &lt;code&gt;%timeit len(l) != 0&lt;/code&gt; 90,6 нс &amp;plusmn; 8,3 нс, &lt;code&gt;%timeit l != []&lt;/code&gt; 55,6 нс &amp;plusmn; 3,09 &lt;code&gt;%timeit not not l&lt;/code&gt; 38,5 нс &amp;plusmn; 0,372. Но никто не получит удовольствия, даже если утроит скорость. Это выглядит смешно. Но скорость выигрывает</target>
        </trans-unit>
        <trans-unit id="d4412db9669f7d0df447ee505c3d56a16c1a3414" translate="yes" xml:space="preserve">
          <source>IPython magic, &lt;code&gt;%timeit&lt;/code&gt;, is not entirely useless here:</source>
          <target state="translated">Волшебство IPython, &lt;code&gt;%timeit&lt;/code&gt; , здесь не совсем бесполезно:</target>
        </trans-unit>
        <trans-unit id="2a07e4c6e816613379546e213ea347ae1a8fa784" translate="yes" xml:space="preserve">
          <source>If you do actually need to check the array for emptiness, the other answers are sufficient.</source>
          <target state="translated">Если на самом деле необходимо проверить массив на пустоту,то других ответов будет достаточно.</target>
        </trans-unit>
        <trans-unit id="125e68683b69b0a281814ca748de40fb9e6f3516" translate="yes" xml:space="preserve">
          <source>If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input &lt;em&gt;to be&lt;/em&gt; a NumPy array.  There are a few nice functions for doing this quickly &amp;mdash;&amp;nbsp;most importantly &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen &lt;code&gt;dtype&lt;/code&gt;.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">Если вам нужно сделать больше, чем просто проверить, является ли ввод пустым, и вы используете другие функции NumPy, такие как индексирование или математические операции, вероятно, более эффективно (и, безусловно, более распространено), чтобы входные данные &lt;em&gt;были&lt;/em&gt; массивом NumPy. Есть несколько хороших функций для быстрого выполнения этой &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt; - самое главное, numpy.asarray . Он принимает ваш ввод, ничего не делает, если он уже является массивом, или упаковывает ваш ввод в массив, если это список, кортеж и т. Д., И при желании преобразует его в выбранный &lt;code&gt;dtype&lt;/code&gt; . Так что это очень быстро, когда это возможно, и это гарантирует, что вы просто предполагаете, что входные данные являются массивом NumPy. Обычно мы даже просто используем одно и то же имя, поскольку преобразование в массив не вернет его за пределы текущей &lt;a href=&quot;http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html&quot;&gt;области&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8fb952d33272c37411f1179bd271c831539a4522" translate="yes" xml:space="preserve">
          <source>If you want to check if a list is empty:</source>
          <target state="translated">Если вы хотите проверить,пуст ли список:</target>
        </trans-unit>
        <trans-unit id="40e6c40dc0a9104c2eddd05cdb70a55879c0c1a5" translate="yes" xml:space="preserve">
          <source>If you want to check whether all the values in list is empty. However it will be &lt;code&gt;True&lt;/code&gt; for an empty list:</source>
          <target state="translated">Если вы хотите проверить, все ли значения в списке пусты. Однако это будет &lt;code&gt;True&lt;/code&gt; для пустого списка:</target>
        </trans-unit>
        <trans-unit id="536f093032dabe47659c67529b21e5619964a16e" translate="yes" xml:space="preserve">
          <source>If you want to use both cases together:</source>
          <target state="translated">Если ты хочешь использовать оба дела вместе:</target>
        </trans-unit>
        <trans-unit id="8841134ee2ab08cfb3f81a5ebb9e79b04b2bff1d" translate="yes" xml:space="preserve">
          <source>If you're not sure whether it might be a &lt;code&gt;list&lt;/code&gt;, a NumPy array, or something else, you could combine this approach with &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;the answer @dubiousjim gives&lt;/a&gt; to make sure the right test is used for each type.  Not very &quot;pythonic&quot;, but it turns out that NumPy intentionally broke pythonicity in at least this sense.</source>
          <target state="translated">Если вы не уверены, что это может быть &lt;code&gt;list&lt;/code&gt; , массив NumPy или что-то еще, вы можете объединить этот подход с &lt;a href=&quot;https://stackoverflow.com/a/10835703/1194883&quot;&gt;ответом, который дает @dubiousjim,&lt;/a&gt; чтобы убедиться, что для каждого типа используется правильный тест. Не очень &quot;pythonic&quot;, но оказывается, что NumPy преднамеренно нарушил pythonicity по крайней мере в этом смысле.</target>
        </trans-unit>
        <trans-unit id="428f7e34ea9af326d1a0f2aad6f147c45fdb55ac" translate="yes" xml:space="preserve">
          <source>In Python, &lt;strong&gt;empty containers&lt;/strong&gt; such as lists,tuples,sets,dicts,variables etc are seen as &lt;code&gt;False&lt;/code&gt;. One could simply treat the list as a predicate (&lt;em&gt;returning a Boolean value&lt;/em&gt;). And  a &lt;code&gt;True&lt;/code&gt; value would indicate that it's non-empty.</source>
          <target state="translated">В Python &lt;strong&gt;пустые контейнеры,&lt;/strong&gt; такие как списки, кортежи, наборы, запросы, переменные и т. Д., Рассматриваются как &lt;code&gt;False&lt;/code&gt; . Можно просто рассматривать список как предикат ( &lt;em&gt;возвращая логическое значение&lt;/em&gt; ). И значение &lt;code&gt;True&lt;/code&gt; будет означать, что оно не пустое.</target>
        </trans-unit>
        <trans-unit id="a160b38c575aa7abd79420a97f3bbb8f340afc2a" translate="yes" xml:space="preserve">
          <source>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just &lt;code&gt;is_empty(any_structure)&lt;/code&gt;.</source>
          <target state="translated">Его можно использовать для любой структуры данных, такой как список, кортежи, словарь и многое другое. Этим вы можете вызывать его много раз, используя просто &lt;code&gt;is_empty(any_structure)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c32bab15a2ee7ad8ba7c6641bb23e238358e1623" translate="yes" xml:space="preserve">
          <source>It is sometimes good to test for &lt;code&gt;None&lt;/code&gt; and for emptiness separately as those are two different states. The code above produces the following output:</source>
          <target state="translated">Иногда полезно проверить &lt;code&gt;None&lt;/code&gt; и пустоту отдельно, поскольку это два разных состояния. Код выше производит следующий вывод:</target>
        </trans-unit>
        <trans-unit id="c5d891bd3646d03ddb9c17a5be09027bd036ced8" translate="yes" xml:space="preserve">
          <source>It's true that &lt;code&gt;if not a:&lt;/code&gt; doesn't distinguish empty lists from &lt;code&gt;None&lt;/code&gt;, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know &lt;em&gt;what&lt;/em&gt; you want to be explicit about, so you can test for exactly that. For example, &lt;code&gt;if not a and a is not None:&lt;/code&gt; means &quot;anything falsey except None&quot;, while &lt;code&gt;if len(a) != 0:&lt;/code&gt; means &quot;only empty sequences&amp;mdash;and anything besides a sequence is an error here&quot;, and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</source>
          <target state="translated">Это правда, что &lt;code&gt;if not a:&lt;/code&gt; не различает пустые списки от &lt;code&gt;None&lt;/code&gt; , или числовой 0, или пустые кортежи, или пустые типы коллекций, созданные пользователем, или пустые созданные пользователем типы не совсем коллекции, или одноэлементный массив NumPy выступая в качестве скаляров с ложными значениями и т. д. И иногда важно четко об этом говорить. И в этом случае вы знаете, &lt;em&gt;о&lt;/em&gt; чем хотите быть явным, поэтому вы можете проверить именно это. Например, &lt;code&gt;if not a and a is not None:&lt;/code&gt; означает &amp;laquo;что-нибудь неверное, кроме None&amp;raquo;, в то время как &lt;code&gt;if len(a) != 0:&lt;/code&gt; означает &amp;laquo;только пустые последовательности - и все, кроме последовательности, является здесь ошибкой&amp;raquo; и т. Д. , Помимо тестирования именно того, что вы хотите проверить, это также сигнализирует читателю, что этот тест важен.</target>
        </trans-unit>
        <trans-unit id="c7b0318d9faa41f53e682c3bbc37b5cfd1c0e726" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;has a similar notion of truthy/falsy&lt;/a&gt;.</source>
          <target state="translated">У JavaScript &lt;a href=&quot;http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting&quot;&gt;есть похожее понятие истина / ложь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5142fae3c5db9d1461a71db588118a77074a605f" translate="yes" xml:space="preserve">
          <source>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</source>
          <target state="translated">Было дано много ответов,и многие из них довольно хороши.Я просто хотел добавить,что чек</target>
        </trans-unit>
        <trans-unit id="bf1a55fc2dfc2923592d18290d8210ac0f8e2701" translate="yes" xml:space="preserve">
          <source>Method 1 (Preferred):</source>
          <target state="translated">Метод 1 (Предпочтительно):</target>
        </trans-unit>
        <trans-unit id="4e958d4a4b4554ff4a60439e18120188e8915232" translate="yes" xml:space="preserve">
          <source>Method 2 :</source>
          <target state="translated">Метод 2 :</target>
        </trans-unit>
        <trans-unit id="5c1700aea4db454bd25188c6878b4574d94f6e62" translate="yes" xml:space="preserve">
          <source>Method 3:</source>
          <target state="translated">Метод 3:</target>
        </trans-unit>
        <trans-unit id="4163466ea446b9664c1bdbc1d45e8ba19c39c8f9" translate="yes" xml:space="preserve">
          <source>No one seems to have addressed questioning your &lt;em&gt;need&lt;/em&gt; to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</source>
          <target state="translated">Похоже, никто не обращался с вопросом о том, &lt;em&gt;нужно&lt;/em&gt; ли вам сначала проверять список. Поскольку вы не предоставили никакого дополнительного контекста, я могу себе представить, что вам может не понадобиться делать эту проверку в первую очередь, но вы не знакомы с обработкой списков в Python.</target>
        </trans-unit>
        <trans-unit id="2ec0c5d4d7981ce6e9ff1b380ca6846b74422e54" translate="yes" xml:space="preserve">
          <source>Note: a string is considered to be iterable. - add &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; if you want the empty string to be excluded</source>
          <target state="translated">Примечание: строка считается повторяемой. - добавить, &lt;code&gt;and not isinstance(a,(str,unicode))&lt;/code&gt; если вы хотите, чтобы пустая строка была исключена</target>
        </trans-unit>
        <trans-unit id="18b642e9538492bb0944a34dd8a2e506f10e19b4" translate="yes" xml:space="preserve">
          <source>Now let's look at the case for an unempty list:</source>
          <target state="translated">Теперь давайте рассмотрим дело о списке безработных:</target>
        </trans-unit>
        <trans-unit id="9ca01a949b72339ff024541a16acb34d56d5458e" translate="yes" xml:space="preserve">
          <source>Now you can use:</source>
          <target state="translated">Теперь ты можешь использовать:</target>
        </trans-unit>
        <trans-unit id="9b84859507e274233a23af1cd06d846a49723981" translate="yes" xml:space="preserve">
          <source>Of course, do &lt;strong&gt;not&lt;/strong&gt; use &lt;code&gt;bool&lt;/code&gt; in &lt;code&gt;if&lt;/code&gt; (i.e., &lt;code&gt;if bool(L):&lt;/code&gt;) because it's implied. But, for the cases when &quot;is not empty&quot; is explicitly needed as a function, &lt;code&gt;bool&lt;/code&gt; is the best choice.</source>
          <target state="translated">Конечно, &lt;strong&gt;не&lt;/strong&gt; используйте &lt;code&gt;bool&lt;/code&gt; в &lt;code&gt;if&lt;/code&gt; (то есть, &lt;code&gt;if bool(L):&lt;/code&gt; потому что это подразумевается. Но для случаев, когда &amp;laquo;не пусто&amp;raquo; явно необходимо как функция, &lt;code&gt;bool&lt;/code&gt; - лучший выбор.</target>
        </trans-unit>
        <trans-unit id="d62a34899b1789ad0de88de972782e3233f85466" translate="yes" xml:space="preserve">
          <source>Other methods don't work for NumPy arrays</source>
          <target state="translated">Другие методы не работают для массивов NumPy</target>
        </trans-unit>
        <trans-unit id="7508036889deb522e760a0d2d530c531b6a2002f" translate="yes" xml:space="preserve">
          <source>PEP 8</source>
          <target state="translated">ПЭП 8</target>
        </trans-unit>
        <trans-unit id="3ecde6cd436f098db79f5599fdb3667956fcbf60" translate="yes" xml:space="preserve">
          <source>Place the list in a boolean context (for example, with an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement). It will test &lt;code&gt;False&lt;/code&gt; if it is empty, and &lt;code&gt;True&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">Поместите список в логический контекст (например, с помощью оператора &lt;code&gt;if&lt;/code&gt; или &lt;code&gt;while&lt;/code&gt; ). Он проверит &lt;code&gt;False&lt;/code&gt; , если он пуст, и &lt;code&gt;True&lt;/code&gt; в противном случае. Например:</target>
        </trans-unit>
        <trans-unit id="d2931340025c9c2fd67ac84f3da9bf695821b222" translate="yes" xml:space="preserve">
          <source>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</source>
          <target state="translated">В кодексе Пайтона и в сообществе Пайтонов есть очень сильные идиомы.Следование этим идиомам облегчает чтение вашего кода любому,кто имеет опыт работы на Python.И когда вы нарушаете эти идиомы,это сильный сигнал.</target>
        </trans-unit>
        <trans-unit id="d64b6eced566b47a6b2fd33e4bc9acd66737c2c8" translate="yes" xml:space="preserve">
          <source>Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly.</source>
          <target state="translated">Python написан на C;он использует свою логику на уровне C.Всё,что вы напишете на Python,будет медленнее.И,скорее всего,будет на порядки медленнее,если только вы не используете механизмы,встроенные непосредственно в Python.</target>
        </trans-unit>
        <trans-unit id="420e21b5db5cbb25f52fe0a4ec446fd398e6e2c3" translate="yes" xml:space="preserve">
          <source>Response to comments:</source>
          <target state="translated">Ответ на замечания:</target>
        </trans-unit>
        <trans-unit id="ea5008a4db7f66da07d14fae6d752831a2ea6498" translate="yes" xml:space="preserve">
          <source>Short Answer:</source>
          <target state="translated">Короткий ответ:</target>
        </trans-unit>
        <trans-unit id="df611a40b52b245a7619d867739b3da4fbcc5aa9" translate="yes" xml:space="preserve">
          <source>Simple way is checking the length is equal zero.</source>
          <target state="translated">Простой способ-проверить,что длина равна нулю.</target>
        </trans-unit>
        <trans-unit id="799b8c4046e8b1c2ade9b021de07a884f7f35ef8" translate="yes" xml:space="preserve">
          <source>Simply use is_empty() or make function like:-</source>
          <target state="translated">Просто используйте is_empty()или сделайте функцию like:-</target>
        </trans-unit>
        <trans-unit id="4259f87fbbe70d265110f62571c4d8eb3fa4ff0c" translate="yes" xml:space="preserve">
          <source>So instead of this:</source>
          <target state="translated">Так что вместо этого:</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="78307d3a12ed5a2b855d5a3f147d8f6260767c8c" translate="yes" xml:space="preserve">
          <source>The &quot;Pythonic&quot; way is a much simpler and faster check since the length of the list is cached in the object instance header:</source>
          <target state="translated">Питонический&quot; способ гораздо проще и быстрее проверяется,так как длина списка кэшируется в заголовке экземпляра объекта:</target>
        </trans-unit>
        <trans-unit id="cce1f662637f486e769a258aed0d1f1480d3aae4" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 1</source>
          <target state="translated">&quot;Питонический&quot; способ не работает:Часть 1</target>
        </trans-unit>
        <trans-unit id="a62e97267f48afa3faa3d59f99bd87e92a95b78d" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way doesn't work: Part 2</source>
          <target state="translated">&quot;Питонический&quot; способ не работает:Часть 2</target>
        </trans-unit>
        <trans-unit id="228125c176323a97205fc40f5c53dc9e1b8cb415" translate="yes" xml:space="preserve">
          <source>The &quot;pythonic&quot; way fails with NumPy arrays because NumPy tries to cast the array to an array of &lt;code&gt;bool&lt;/code&gt;s, and &lt;code&gt;if x&lt;/code&gt; tries to evaluate all of those &lt;code&gt;bool&lt;/code&gt;s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a &lt;code&gt;ValueError&lt;/code&gt;:</source>
          <target state="translated">&amp;laquo;Питонический&amp;raquo; путь не работает с массивами NumPy, потому что NumPy пытается привести массив к массиву &lt;code&gt;bool&lt;/code&gt; s, и &lt;code&gt;if x&lt;/code&gt; пытается вычислить все эти &lt;code&gt;bool&lt;/code&gt; одновременно для некоторого совокупного значения истинности. Но это не имеет никакого смысла, поэтому вы получаете &lt;code&gt;ValueError&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a3f21db414612559e4bd0aa2e9d4ccdd7620a0b" translate="yes" xml:space="preserve">
          <source>The numpythonic way</source>
          <target state="translated">Нумпитонический способ</target>
        </trans-unit>
        <trans-unit id="839d95ab808bb10053fa88f4716855013b528654" translate="yes" xml:space="preserve">
          <source>The pythonic way to do it is from the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;PEP 8 style guide&lt;/a&gt; (where &lt;strong&gt;Yes&lt;/strong&gt; means &amp;ldquo;recommended&amp;rdquo; and &lt;strong&gt;No&lt;/strong&gt; means &amp;ldquo;not recommended&amp;rdquo;):</source>
          <target state="translated">Питонический способ сделать это - из &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008&quot;&gt;руководства по стилю PEP 8&lt;/a&gt; (где &amp;laquo; &lt;strong&gt;Да&amp;raquo;&lt;/strong&gt; означает &amp;laquo;рекомендуется&amp;raquo;, а &amp;laquo; &lt;strong&gt;Нет&amp;raquo;&lt;/strong&gt; означает &amp;laquo;не рекомендуется&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="419ef69c944861f78388669cc2be094309f545d1" translate="yes" xml:space="preserve">
          <source>The second way is a &lt;strong&gt;&lt;code&gt;more pythonic&lt;/code&gt;&lt;/strong&gt; one. This method is an implicit way of checking and much more preferable than the previous one.</source>
          <target state="translated">Второй способ - &lt;strong&gt; &lt;code&gt;more pythonic&lt;/code&gt; &lt;/strong&gt; . Этот метод является неявным способом проверки и гораздо более предпочтителен, чем предыдущий.</target>
        </trans-unit>
        <trans-unit id="26bb1f3155a5dcb9fceb486c2448558698ce4333" translate="yes" xml:space="preserve">
          <source>The truth value of an empty list is &lt;code&gt;False&lt;/code&gt; whereas for a non-empty list it is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Значение истинности пустого списка - &lt;code&gt;False&lt;/code&gt; , тогда как для непустого списка - &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc6e8440ee75ab717bf6ec8f427152001e12352" translate="yes" xml:space="preserve">
          <source>Then it must call the function, load &lt;code&gt;0&lt;/code&gt;, and do the equality comparison in Python (instead of with C):</source>
          <target state="translated">Затем он должен вызвать функцию, загрузить &lt;code&gt;0&lt;/code&gt; и выполнить сравнение на равенство в Python (вместо C):</target>
        </trans-unit>
        <trans-unit id="d90a30ab848b090999fc31f8d7530affde230d5d" translate="yes" xml:space="preserve">
          <source>These are correct in their respective other languages. And this is even semantically correct in Python.</source>
          <target state="translated">Они верны и на других языках.И это даже семантически верно на Питоне.</target>
        </trans-unit>
        <trans-unit id="e237e40349b5d41720ad35c29c2a146f51cf9485" translate="yes" xml:space="preserve">
          <source>This has the benefit of handling any contents of &lt;strong&gt;a&lt;/strong&gt;, while not requiring a specific check for emptiness.  If &lt;strong&gt;a&lt;/strong&gt; is empty, the dependent block will not execute and the interpreter will fall through to the next line.</source>
          <target state="translated">Это дает преимущество обработки любого содержимого, не требуя специальной проверки на пустоту. Если &lt;strong&gt;a&lt;/strong&gt; пусто, зависимый блок не будет выполнен, и интерпретатор перейдет к следующей строке.</target>
        </trans-unit>
        <trans-unit id="e07f7e1c2e6c131a4dd992f68429d70bd4456992" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;code&gt;PyObject&lt;/code&gt; that adds the &lt;code&gt;ob_size&lt;/code&gt; field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; macro.</source>
          <target state="translated">Это расширение &lt;code&gt;PyObject&lt;/code&gt; , которое добавляет поле &lt;code&gt;ob_size&lt;/code&gt; . Это используется только для объектов, которые имеют некоторое представление о длине. Этот тип не часто появляется в Python / C API. Это соответствует полям, определенным расширением макроса &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834cb8e0db15a3974ebe92a788d932cf5c816ae7" translate="yes" xml:space="preserve">
          <source>This way it's 100% clear that &lt;code&gt;li&lt;/code&gt; is a sequence (list) and we want to test its size. My problem with &lt;code&gt;if not li: ...&lt;/code&gt; is that it gives the false impression that &lt;code&gt;li&lt;/code&gt; is a boolean variable.</source>
          <target state="translated">Таким образом, на 100% ясно, что &lt;code&gt;li&lt;/code&gt; - это последовательность (список), и мы хотим проверить ее размер. Моя проблема с, &lt;code&gt;if not li: ...&lt;/code&gt; том, что он создает ложное впечатление, что &lt;code&gt;li&lt;/code&gt; является логической переменной.</target>
        </trans-unit>
        <trans-unit id="517b32f316ce0d136fe88818f855b9745999ba35" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;x.size&lt;/code&gt; check work in all cases I see on this page.</source>
          <target state="translated">Это заставит проверку &lt;code&gt;x.size&lt;/code&gt; работать во всех случаях, которые я вижу на этой странице.</target>
        </trans-unit>
        <trans-unit id="166295003ca1870a3de65a50bfe6d0b14501234e" translate="yes" xml:space="preserve">
          <source>To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a &lt;strong&gt;&lt;code&gt;less pythonic&lt;/code&gt;&lt;/strong&gt; way):</source>
          <target state="translated">Чтобы проверить, является ли список пустым или нет, вы можете использовать два следующих способа. Но помните, мы должны избегать способа явной проверки типа последовательности (это &lt;strong&gt; &lt;code&gt;less pythonic&lt;/code&gt; &lt;/strong&gt; способ):</target>
        </trans-unit>
        <trans-unit id="d88775ff0c4e2103146fa814bf595e1bad3bd121" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;len&lt;/code&gt; can give unexpected results</source>
          <target state="translated">Использование &lt;code&gt;len&lt;/code&gt; может дать неожиданные результаты</target>
        </trans-unit>
        <trans-unit id="3210b647602906055a2ea6630c8e3fee2353fdbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;implicit booleanness&lt;/a&gt; of the empty &lt;code&gt;list&lt;/code&gt; is quite pythonic.</source>
          <target state="translated">Использование &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#truth-value-testing&quot;&gt;неявной логики&lt;/a&gt; пустого &lt;code&gt;list&lt;/code&gt; довольно питонно.</target>
        </trans-unit>
        <trans-unit id="e4100216a9aee376fd77c24841324702e83c57b2" translate="yes" xml:space="preserve">
          <source>Very handy and useful.</source>
          <target state="translated">Очень удобно и полезно.</target>
        </trans-unit>
        <trans-unit id="bec8251989ae95f17e7917e7a4667d9b939024a6" translate="yes" xml:space="preserve">
          <source>We can see there's a bit of linear cost for each additional &lt;code&gt;not&lt;/code&gt; here. We want to see the costs, &lt;em&gt;ceteris paribus&lt;/em&gt;, that is, all else equal - where all else is minimized as far as possible:</source>
          <target state="translated">Мы можем видеть, что есть немного линейной стоимости для каждого дополнительного &lt;code&gt;not&lt;/code&gt; здесь. Мы хотим видеть затраты, &lt;em&gt;при прочих равных условиях&lt;/em&gt; , то есть &lt;em&gt;при прочих равных условиях&lt;/em&gt; , где все остальное сводится к минимуму, насколько это возможно:</target>
        </trans-unit>
        <trans-unit id="0a1d52cb17cca8e7191f36986558bb72f7957e50" translate="yes" xml:space="preserve">
          <source>We see that &lt;em&gt;either&lt;/em&gt; checking for length with the builtin function &lt;code&gt;len&lt;/code&gt; compared to &lt;code&gt;0&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; checking against an empty list is &lt;strong&gt;much&lt;/strong&gt; less performant than using the builtin syntax of the language as documented.</source>
          <target state="translated">Мы видим, что &lt;em&gt;либо&lt;/em&gt; проверка длины с помощью встроенной функции &lt;code&gt;len&lt;/code&gt; по сравнению с &lt;code&gt;0&lt;/code&gt; , &lt;em&gt;либо&lt;/em&gt; проверка по пустому списку &lt;strong&gt;гораздо&lt;/strong&gt; менее производительны, чем использование встроенного синтаксиса языка, как описано в документации.</target>
        </trans-unit>
        <trans-unit id="93defcec033f02c7813b4fa2999f8fa8e135291c" translate="yes" xml:space="preserve">
          <source>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</source>
          <target state="translated">Следует ожидать,что стандартный библиотечный код должен быть максимально работоспособным и корректным.Но почему это так,и зачем нам это руководство?</target>
        </trans-unit>
        <trans-unit id="53f50b6170acffe67cc4616bcd8c695dc5c3e587" translate="yes" xml:space="preserve">
          <source>What brought me here is a special use-case: I actually wanted a &lt;em&gt;function&lt;/em&gt; to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough):</source>
          <target state="translated">Что привело меня сюда, так это особый вариант использования: я на самом деле хотел, чтобы &lt;em&gt;функция&lt;/em&gt; сообщала мне, пустой список или нет. Я хотел избежать написания своей собственной функции или использования лямбда-выражения здесь (потому что казалось, что это должно быть достаточно просто):</target>
        </trans-unit>
        <trans-unit id="6c52a1ca8670775a8c8a00491e8712ffcaca818c" translate="yes" xml:space="preserve">
          <source>What we can see here is that it makes little difference whether you pass in an actual &lt;code&gt;bool&lt;/code&gt; to the condition check or the list itself, and if anything, giving the list, as is, is faster.</source>
          <target state="translated">Здесь мы видим, что не имеет большого значения, передаете ли вы фактическое &lt;code&gt;bool&lt;/code&gt; проверке состояния или самому списку, и, если что-то, предоставление списка, как есть, происходит быстрее.</target>
        </trans-unit>
        <trans-unit id="0a4d3c26f7312a3bcafab015f36e0c94e6e8659e" translate="yes" xml:space="preserve">
          <source>Why check at all?</source>
          <target state="translated">Зачем вообще проверять?</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="3ecc4c96e7de4be0cda6aa9f38dc351865be20e7" translate="yes" xml:space="preserve">
          <source>You can even try using bool() like this</source>
          <target state="translated">Вы даже можете попробовать использовать bool()вот так.</target>
        </trans-unit>
        <trans-unit id="f65dd7b083f4ea2c1ee4f439f364acdec6b47258" translate="yes" xml:space="preserve">
          <source>You can get away without the explicit type check, but only if the surrounding context already assures you that &lt;code&gt;a&lt;/code&gt; is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a &lt;code&gt;TypeError&lt;/code&gt; if you call &lt;code&gt;len&lt;/code&gt; on a value for which it's undefined) that you're prepared to handle. In general, the &quot;pythonic&quot; conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to &lt;em&gt;think&lt;/em&gt; about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on &lt;code&gt;len&lt;/code&gt; or the boolean typecast may not do precisely what you're expecting.</source>
          <target state="translated">Вы можете обойтись без явной проверки типов, но только в том случае, если окружающий контекст уже гарантирует, что &lt;code&gt;a&lt;/code&gt; является значением типов, которые вы готовы обработать, или если вы уверены, что типы, которые вы не готовы обрабатывать, являются будет вызывать ошибки (например, &lt;code&gt;TypeError&lt;/code&gt; , если вы вызываете &lt;code&gt;len&lt;/code&gt; для значения, для которого оно не определено), которое вы готовы обработать. В общем, &quot;питонические&quot; соглашения, кажется, идут этим последним путем. Сожмите его, как утку, и дайте ему поднять ошибку DuckError, если он не знает, как крякать. Тем не менее, вам все еще нужно &lt;em&gt;подумать&lt;/em&gt; о том, какие допущения вы делаете, и действительно ли случаи, которые вы не готовы обрабатывать должным образом, приведут к ошибкам в нужных местах. Массивы Numpy являются хорошим примером, когда просто слепо полагаться на &lt;code&gt;len&lt;/code&gt; или boolean typecast может не совсем то, что вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="9083cd48fae65c5b68f6712180202c73821b23fa" translate="yes" xml:space="preserve">
          <source>You need to be careful with NumPy arrays, because other methods that work fine for &lt;code&gt;list&lt;/code&gt;s or other standard containers fail for NumPy arrays.  I explain why below, but in short, the &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;preferred method&lt;/a&gt; is to use &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Вы должны быть осторожны с массивами NumPy, потому что другие методы, которые отлично работают для &lt;code&gt;list&lt;/code&gt; или других стандартных контейнеров, не работают для массивов NumPy. Я объясню, почему ниже, но вкратце, &lt;a href=&quot;http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array&quot;&gt;предпочтительный метод&lt;/a&gt; заключается в использовании &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d227705c28851b3cabdba2c9c370a4f7063204" translate="yes" xml:space="preserve">
          <source>Your duckCollection should implement &lt;code&gt;__nonzero__&lt;/code&gt; or &lt;code&gt;__len__&lt;/code&gt; so the if a: will work without problems.</source>
          <target state="translated">Ваша duckCollection должна реализовывать &lt;code&gt;__nonzero__&lt;/code&gt; или &lt;code&gt;__len__&lt;/code&gt; , поэтому if a: будет работать без проблем.</target>
        </trans-unit>
        <trans-unit id="e1f11fedb84b9948d72cba30d27c4ba1e5b96b6b" translate="yes" xml:space="preserve">
          <source>a little more practical:</source>
          <target state="translated">немного практичнее:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="5fa43287b1c5b62b65463b926344285e74e283b5" translate="yes" xml:space="preserve">
          <source>and shertest version:</source>
          <target state="translated">и версию для испытаний:</target>
        </trans-unit>
        <trans-unit id="83ab88ee561c2c3fbf9a72f4e64edd6d102bc31c" translate="yes" xml:space="preserve">
          <source>any empty mapping, for example, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">любое пустое отображение, например, &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2952616e90efb7a6dd44095c44dfdd2377bc3ab" translate="yes" xml:space="preserve">
          <source>any empty sequence, for example, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">любая пустая последовательность, например, &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b131ef05b1826b4dcf14f5da963e3b8f3d60f6f6" translate="yes" xml:space="preserve">
          <source>constants defined to be false: &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">константы, определенные как ложные: &lt;code&gt;None&lt;/code&gt; и &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa71fa14fe89fc7eb25cd68186ad53611ebfd167" translate="yes" xml:space="preserve">
          <source>empty sequences and collections: &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;range(0)&lt;/code&gt;</source>
          <target state="translated">пустые последовательности и коллекции: &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , &lt;code&gt;set()&lt;/code&gt; , &lt;code&gt;range(0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="054f2c8e08dfd096608d12043bbc8cd93bbd3d80" translate="yes" xml:space="preserve">
          <source>if you only want to accept instances of particular types (and their subtypes), or with:</source>
          <target state="translated">если вы хотите принимать только экземпляры определенных типов (и их подтипов),или с:</target>
        </trans-unit>
        <trans-unit id="bbe92aa90ac3da927a82d780633d2c79550b5147" translate="yes" xml:space="preserve">
          <source>instances of user-defined classes, if the class defines a &lt;code&gt;__bool__()&lt;/code&gt; or &lt;code&gt;__len__()&lt;/code&gt; method, when that method returns the integer zero or bool value &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">экземпляры пользовательских классов, если класс определяет &lt;code&gt;__bool__()&lt;/code&gt; или &lt;code&gt;__len__()&lt;/code&gt; , когда этот метод возвращает целочисленный ноль или значение bool &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">или это:</target>
        </trans-unit>
        <trans-unit id="5fe84e072cb8774215db86ddfc171c8aa9283127" translate="yes" xml:space="preserve">
          <source>produces expected</source>
          <target state="translated">производит ожидаемый</target>
        </trans-unit>
        <trans-unit id="bdb401ea8d165ea2005c10c5877c586d8207bf1a" translate="yes" xml:space="preserve">
          <source>returns 1, even though the array has zero elements.</source>
          <target state="translated">возвращает 1,даже если массив имеет нулевые элементы.</target>
        </trans-unit>
        <trans-unit id="9f03e5ffbf02bb878e6dd52843870f4e01cc42fb" translate="yes" xml:space="preserve">
          <source>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</source>
          <target state="translated">первый тест-в ответ на ответ @Mike,выше.Третья строка также может быть заменена:</target>
        </trans-unit>
        <trans-unit id="a818933ef67b2d17d00dabdb02f08102734ba6d7" translate="yes" xml:space="preserve">
          <source>to check if the list is empty</source>
          <target state="translated">чтобы проверить,не пуст ли список</target>
        </trans-unit>
        <trans-unit id="113a8713eff230494f7adff7cabd13b33e7a718c" translate="yes" xml:space="preserve">
          <source>we could use a simple if else:</source>
          <target state="translated">нам бы не помешало простое,если бы еще:</target>
        </trans-unit>
        <trans-unit id="75e6b798f41cc1b686d5e5e68f072d8fc897174b" translate="yes" xml:space="preserve">
          <source>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as &quot;pythonic&quot;---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where &lt;code&gt;a&lt;/code&gt; is, for example, &lt;code&gt;False&lt;/code&gt;, you need a test more restrictive than just &lt;code&gt;if not a:&lt;/code&gt;. You could use something like this:</source>
          <target state="translated">за который проголосовали -1. Я не уверен, что это потому, что читатели возражали против стратегии или считали, что ответ не был полезен в представленном виде. Я буду притворяться, что это последнее, поскольку - что бы ни считалось &quot;питоническим&quot; - это правильная стратегия. Если вы уже не исключили или не готовы обрабатывать случаи, когда &lt;code&gt;a&lt;/code&gt; , например, &lt;code&gt;False&lt;/code&gt; , вам нужен тест, более строгий, чем просто &lt;code&gt;if not a:&lt;/code&gt; Вы можете использовать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="9c021d12abb7b3e2b39cca48ff8eeeb38bb02d18" translate="yes" xml:space="preserve">
          <source>will also pass for &lt;code&gt;None&lt;/code&gt; and other types of empty structures. If you truly want to check for an empty list, you can do this:</source>
          <target state="translated">Также пройдет для &lt;code&gt;None&lt;/code&gt; и других типов пустых структур. Если вы действительно хотите проверить пустой список, вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="0e6f0e52997217d3b5a709de67763a194e319b26" translate="yes" xml:space="preserve">
          <source>zero of any numeric type, for example, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;.</source>
          <target state="translated">ноль любого числового типа, например, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0.0&lt;/code&gt; , &lt;code&gt;0j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a325962fa4501e445c5fc397f589278bbc1b016" translate="yes" xml:space="preserve">
          <source>zero of any numeric type: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;, &lt;code&gt;Decimal(0)&lt;/code&gt;, &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</source>
          <target state="translated">ноль любого числового типа: &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0.0&lt;/code&gt; , &lt;code&gt;0j&lt;/code&gt; , &lt;code&gt;Decimal(0)&lt;/code&gt; , &lt;code&gt;Fraction(0, 1)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
