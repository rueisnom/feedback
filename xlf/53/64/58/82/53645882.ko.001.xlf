<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/53645882">
    <body>
      <group id="53645882">
        <trans-unit id="17630139350b3e7225d8e418b422d5ed06fc753d" translate="yes" xml:space="preserve">
          <source>... and more. I've seen these recurring questions asking about various facets of the pandas merge functionality. Most of the information regarding merge and its various use cases today is fragmented across dozens of badly worded, unsearchable posts. The aim here is to collate some of the more important points for posterity.</source>
          <target state="translated">... 그리고 더. 팬더 병합 기능의 다양한 측면에 대해 묻는 반복되는 질문을 보았습니다. 오늘날의 병합 및 다양한 사용 사례에 대한 대부분의 정보는 수십 가지의 나쁜 말로 표현할 수없는 게시물에 조각화되어 있습니다. 여기서 목표는 후손에 대한 더 중요한 요점을 정리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eec9fcbe6ea854a740992411450dcdf6f8edd7f0" translate="yes" xml:space="preserve">
          <source>...specify &lt;code&gt;how='right'&lt;/code&gt;:</source>
          <target state="translated">... &lt;code&gt;how='right'&lt;/code&gt; 지정 :</target>
        </trans-unit>
        <trans-unit id="e91d0b9a8d1fd79f54f0311c1dd355dce9fa9417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/version/0.19.0/generated/pandas.merge_ordered.html&quot;&gt;&lt;code&gt;pd.merge_ordered&lt;/code&gt;&lt;/a&gt; is a useful function for ordered JOINs.</source>
          <target state="translated">&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/version/0.19.0/generated/pandas.merge_ordered.html&quot;&gt; &lt;code&gt;pd.merge_ordered&lt;/code&gt; &lt;/a&gt; 는 정렬 된 JOIN에 유용한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d10a805a9d0d7d9965a63e7b910d7a8c3f61abd1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.merge_asof.html&quot;&gt;&lt;code&gt;pd.merge_asof&lt;/code&gt;&lt;/a&gt; (read: merge_asOf) is useful for &lt;em&gt;approximate&lt;/em&gt; joins.</source>
          <target state="translated">&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.merge_asof.html&quot;&gt; &lt;code&gt;pd.merge_asof&lt;/code&gt; &lt;/a&gt; (읽기 : merge_asOf)는 &lt;em&gt;대략적인&lt;/em&gt; 조인에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="28c5ff345c13c628fb5d311e2c2cc32e431e55e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; is fast, but has its shortcomings. It cannot handle duplicates.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 은 빠르지 만 단점이 있습니다. 중복을 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="4460614c866027117c8c8c9385d2504548e05e58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt;? &lt;code&gt;join&lt;/code&gt;? &lt;code&gt;concat&lt;/code&gt;? &lt;code&gt;update&lt;/code&gt;? Who? What? Why?!</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; ? &lt;code&gt;join&lt;/code&gt; ? &lt;code&gt;concat&lt;/code&gt; ? &lt;code&gt;update&lt;/code&gt; ? WHO? 뭐? 왜?!</target>
        </trans-unit>
        <trans-unit id="6ec62a81b97d644b423766e205649d8771a961ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.join.html&quot;&gt;&lt;code&gt;DataFrame.join&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.join.html&quot;&gt;&lt;code&gt;DataFrame.join&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c785ca1520da60ba628b0d0baabb3b89ef883cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.concat.html&quot;&gt;&lt;code&gt;pd.concat&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.concat.html&quot;&gt;&lt;code&gt;pd.concat&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d02fdd4ce0d83797fe4e621d8cfbfbabc238328a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoiding duplicate key column in output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;출력에서 중복 키 열 피하기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac46b4dfaf8e6e049e7ff30e575d4cc1c3977a38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different names for key columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;키 열의 다른 이름&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08caf8fa8dc9966e5740994b7309a55a049b6828" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merging a DataFrame with Series on index&lt;/strong&gt;: See &lt;a href=&quot;https://stackoverflow.com/a/40762674/4909087&quot;&gt;this answer&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;인덱스에 Series가있는 DataFrame 병합&lt;/strong&gt; : &lt;a href=&quot;https://stackoverflow.com/a/40762674/4909087&quot;&gt;이 답변을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df6d66733b39e43b9b840281ffc96fe2102c0ea4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merging on index of one, column(s) of another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;한 인덱스, 다른 열의 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0079558e65cb33c96f7f6657c4e310db9bfe4f00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merging on multiple columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여러 열에서 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="177f6c9aad46a36c4371a71fac8b8dbc9b627189" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merging only a single column from one of the &lt;code&gt;DataFrames&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;DataFrames&lt;/code&gt; 중 하나에서 단일 열만 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="296352a18ca6182622fa5114df5f98626f311071" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiway merge on keys with duplicates&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중복 키가있는 멀티 웨이 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a62dd8a7573b97e27e86be9e052abd47fa60cb25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiway merge on unique keys (or index)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;고유 키 (또는 인덱스)에서 다자간 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f591633cc3281f270174e16f9f6877d8d814b4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other JOINs - LEFT-Excluding, RIGHT-Excluding, and FULL-Excluding/ANTI JOINs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기타 JOIN-왼쪽 제외, 오른쪽 제외 및 전체 제외 / ANTI 가입&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ab07956011d91a828b5ae0ae16a5e55cb22c79e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other useful &lt;code&gt;merge*&lt;/code&gt; operations and functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 유용한 &lt;code&gt;merge*&lt;/code&gt; 작업 및 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2da519c63e0a0dcb916dcc8106c80db9ce3931b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setup&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Setup&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e85a82d8cece86ac352570af53171e34e12bb8d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Support for index names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인덱스 이름 지원&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b180b82ae57cdd9740a14d39e435987c4d0c7994" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This section only covers the very basics, and is designed to only whet your appetite. For more examples and cases, see the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/merging.html&quot;&gt;documentation on &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;, and &lt;code&gt;concat&lt;/code&gt;&lt;/a&gt; as well as the links to the function specs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 섹션은 매우 기본적인 내용만을 다루며 식욕을 자극하기 위해 고안되었습니다.&lt;/strong&gt; &lt;strong&gt;더 많은 예제와 사례 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/merging.html&quot;&gt;는 &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;join&lt;/code&gt; 및 &lt;code&gt;concat&lt;/code&gt; 문서와&lt;/a&gt; 함수 사양에 대한 링크를 참조하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c4143d307a740578eea9363b7ee0dc20cdd20b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;blue&lt;/strong&gt; indicates rows that are present in the merge result</source>
          <target state="translated">&lt;strong&gt;파란색&lt;/strong&gt; 은 병합 결과에 존재하는 행을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ebb075a6b73a5f2e4c0fa66b302af333ff9d79ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;green&lt;/strong&gt; indicates missing values that are replaced with NaNs in the result</source>
          <target state="translated">&lt;strong&gt;녹색&lt;/strong&gt; 은 결과에서 NaN으로 대체 된 결 측값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bf00c90ec72cb9a9b3e1a0ec7f0259de84f87df8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;red&lt;/strong&gt; indicates rows that are excluded from the result (i.e., removed)</source>
          <target state="translated">&lt;strong&gt;빨간색&lt;/strong&gt; 은 결과에서 제외 된 행을 나타냅니다 (즉, 제거됨)</target>
        </trans-unit>
        <trans-unit id="9b86c7b6f69fb764f0e7920b130d71d4a017120a" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;LEFT OUTER JOIN&lt;/strong&gt;, or LEFT JOIN  is represented by</source>
          <target state="translated">&lt;strong&gt;LEFT OUTER JOIN&lt;/strong&gt; 또는 LEFT JOIN은</target>
        </trans-unit>
        <trans-unit id="e9a27b2f3c7bfdac64a34079608edbe4ea01c07c" translate="yes" xml:space="preserve">
          <source>A supplemental visual view of &lt;code&gt;pd.concat([df0, df1], kwargs)&lt;/code&gt;. 
Notice that, kwarg &lt;code&gt;axis=0&lt;/code&gt; or &lt;code&gt;axis=1&lt;/code&gt; 's meaning is not as intuitive as &lt;code&gt;df.mean()&lt;/code&gt; or &lt;code&gt;df.apply(func)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pd.concat([df0, df1], kwargs)&lt;/code&gt; 의 추가 시각적 뷰. kwarg &lt;code&gt;axis=0&lt;/code&gt; 또는 &lt;code&gt;axis=1&lt;/code&gt; 의 의미는 &lt;code&gt;df.mean()&lt;/code&gt; 또는 &lt;code&gt;df.apply(func)&lt;/code&gt; 만큼 직관적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94f2cab3063433368376386217c101baa9abeebd" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;INNER JOIN&lt;/strong&gt; is represented by</source>
          <target state="translated">&lt;strong&gt;INNER JOIN&lt;/strong&gt; 은</target>
        </trans-unit>
        <trans-unit id="e9091cf59468e96643974cde16da081e8609f612" translate="yes" xml:space="preserve">
          <source>And similarly, for a &lt;strong&gt;RIGHT OUTER JOIN&lt;/strong&gt;, or RIGHT JOIN which is...</source>
          <target state="translated">마찬가지로 &lt;strong&gt;RIGHT OUTER JOIN&lt;/strong&gt; 또는 RIGHT JOIN의 경우 ...</target>
        </trans-unit>
        <trans-unit id="82bc724467589b8b2bd0fa53ab39226055bd70bb" translate="yes" xml:space="preserve">
          <source>And similarly, for a RIGHT-Excluding JOIN,</source>
          <target state="translated">마찬가지로, 오른쪽 제외 조인의 경우</target>
        </trans-unit>
        <trans-unit id="750929d4d227bc27f72a15ebfc6f3db19912b758" translate="yes" xml:space="preserve">
          <source>As mentioned, this is similar to, but faster than</source>
          <target state="translated">언급했듯이 이것은 비슷하지만 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e15196100572013f1e479a2ee46e134fa2da3c3b" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;merge&lt;/code&gt;, &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.update.html&quot;&gt;&lt;code&gt;DataFrame.update&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.combine_first.html&quot;&gt;&lt;code&gt;DataFrame.combine_first&lt;/code&gt;&lt;/a&gt; are also used in certain cases to update one DataFrame with another.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 외에도 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.update.html&quot;&gt; &lt;code&gt;DataFrame.update&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.combine_first.html&quot;&gt; &lt;code&gt;DataFrame.combine_first&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 DataFrame을 다른 DataFrame으로 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b66d7149a515ed4fd46dadc07397c0f8e1237856" translate="yes" xml:space="preserve">
          <source>Besides these, there is another succinct option. You can use &lt;code&gt;DataFrame.join&lt;/code&gt; which defaults to joins on the index. &lt;code&gt;DataFrame.join&lt;/code&gt; does a LEFT OUTER JOIN by default, so &lt;code&gt;how='inner'&lt;/code&gt; is necessary here.</source>
          <target state="translated">이 외에도 간결한 옵션이 있습니다. 기본적으로 인덱스에서 조인하도록 &lt;code&gt;DataFrame.join&lt;/code&gt; 을 사용할 수 있습니다. &lt;code&gt;DataFrame.join&lt;/code&gt; 은 기본적으로 LEFT OUTER JOIN을 수행하므로 &lt;code&gt;how='inner'&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="13fe71ecc6d4e0eb6be5754b473416e673e25d2b" translate="yes" xml:space="preserve">
          <source>Can I merge on the index?</source>
          <target state="translated">인덱스를 병합 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d421ffe931a5d8939bb3a22cbd1d441b730ee596" translate="yes" xml:space="preserve">
          <source>Carefully note the placement of NaNs here. If you specify &lt;code&gt;how='left'&lt;/code&gt;, then only keys from &lt;code&gt;left&lt;/code&gt; are used, and missing data from &lt;code&gt;right&lt;/code&gt; is replaced by NaN.</source>
          <target state="translated">여기에 NaN의 배치에주의하십시오. &lt;code&gt;how='left'&lt;/code&gt; 를 지정하면 왼쪽 에서 키만 사용되며 &lt;code&gt;right&lt;/code&gt; 에서 누락 된 데이터는 NaN으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="37ff10eae33a62d80577c7268a07cb5d75fe23a4" translate="yes" xml:space="preserve">
          <source>Contrast this with the output of the command just before (thst is, the output of &lt;code&gt;left2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')&lt;/code&gt;), you'll notice &lt;code&gt;keyLeft&lt;/code&gt; is missing. You can figure out what column to keep based on which frame's index is set as the key. This may matter when, say, performing some OUTER JOIN operation.</source>
          <target state="translated">이것을 바로 전의 명령 출력과 대조하십시오 (첫 번째는 &lt;code&gt;left2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')&lt;/code&gt; ), &lt;code&gt;keyLeft&lt;/code&gt; 가 누락 되었음을 알 수 있습니다 . 어떤 프레임의 인덱스가 키로 설정되어 있는지에 따라 유지할 열을 파악할 수 있습니다. 이것은 OUTER JOIN 작업을 수행 할 때 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6911880e64b07e30c61bd1281b51b652c63d657" translate="yes" xml:space="preserve">
          <source>Cross join with pandas?</source>
          <target state="translated">팬더와 크로스 조인?</target>
        </trans-unit>
        <trans-unit id="5fe709b52d83b44c5ad1a0b610f602be6043c9a6" translate="yes" xml:space="preserve">
          <source>Enough Talk, just show me how to use &lt;code&gt;merge&lt;/code&gt;!</source>
          <target state="translated">충분한 대화, &lt;code&gt;merge&lt;/code&gt; 사용법을 보여주세요!</target>
        </trans-unit>
        <trans-unit id="94b110ce6912b92039003fb0505a54c7a2279f5e" translate="yes" xml:space="preserve">
          <source>Finally, for the &lt;strong&gt;FULL OUTER JOIN&lt;/strong&gt;, given by</source>
          <target state="translated">마지막으로 &lt;strong&gt;FULL OUTER JOIN의&lt;/strong&gt; 경우</target>
        </trans-unit>
        <trans-unit id="45b4f42646157cfcd12accf3ef065b55b349e96a" translate="yes" xml:space="preserve">
          <source>For LEFT-Excluding JOIN, represented as</source>
          <target state="translated">왼쪽 제외 JOIN의 경우 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="564d28e223efb7b275876009069642af14df75ff" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://stackoverflow.com/questions/49620538/what-are-the-levels-keys-and-names-arguments-for-in-pandas-concat-functio/49620539#49620539&quot;&gt;this canonical post on &lt;code&gt;pd.concat&lt;/code&gt; by @piRSquared&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://stackoverflow.com/questions/49620538/what-are-the-levels-keys-and-names-arguments-for-in-pandas-concat-functio/49620539#49620539&quot;&gt;은 &lt;code&gt;pd.concat&lt;/code&gt; 에 대한 정식 게시물을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="087686c788e93ff2868b9b7aaff5b201828c8550" translate="yes" xml:space="preserve">
          <source>For the sake of simplicity, the key column has the same name (for now).</source>
          <target state="translated">간단하게하기 위해 키 열의 이름은 동일합니다 (현재).</target>
        </trans-unit>
        <trans-unit id="f9f1c0fb75f1a2b5e737067bbbbff4dab30a2670" translate="yes" xml:space="preserve">
          <source>Furthermore, all the DataFrames here can be copied and replicated so
  you can play with them. Also, see &lt;a href=&quot;https://stackoverflow.com/questions/31610889/how-to-copy-paste-dataframe-from-stackoverflow-into-python&quot;&gt;this
  post&lt;/a&gt;
  on how to read DataFrames from your clipboard.</source>
          <target state="translated">또한 여기의 모든 DataFrame을 복사 및 복제하여 재생할 수 있습니다. 또한 클립 보드에서 DataFrames를 읽는 방법에 대한 &lt;a href=&quot;https://stackoverflow.com/questions/31610889/how-to-copy-paste-dataframe-from-stackoverflow-into-python&quot;&gt;이 게시물&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c153d78d3d2a2c310d7a012469fe418febbab3d" translate="yes" xml:space="preserve">
          <source>Generalizing: &lt;code&gt;merge&lt;/code&gt;ing multiple DataFrames</source>
          <target state="translated">일반화 : 여러 DataFrame &lt;code&gt;merge&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="873c999e503879d7d522d0fe39800b9413f6896a" translate="yes" xml:space="preserve">
          <source>Handling suffixes, removing extra columns, renaming outputs, and other specific use cases. There are other (read: better) posts that deal with that, so figure it out!</source>
          <target state="translated">접미사 처리, 추가 열 제거, 출력 이름 바꾸기 및 기타 특정 사용 사례. 그것을 다루는 다른 (읽기 : 더 나은) 게시물이 있으므로 알아 내십시오!</target>
        </trans-unit>
        <trans-unit id="5d4b55e558b6f0cc4949694678b15e19ec7413a5" translate="yes" xml:space="preserve">
          <source>Here I introduce &lt;code&gt;pd.concat&lt;/code&gt; for multi-way joins on &lt;em&gt;unique&lt;/em&gt; keys, and &lt;code&gt;DataFrame.join&lt;/code&gt; for multi-way joins on &lt;em&gt;non-unique&lt;/em&gt; keys. First, the setup.</source>
          <target state="translated">여기에서는 &lt;em&gt;고유&lt;/em&gt; 키의 다 방향 조인을위한 &lt;code&gt;DataFrame.join&lt;/code&gt; 및 &lt;em&gt;고유하지 않은&lt;/em&gt; 키의 다 방향 조인을위한 &lt;code&gt;pd.concat&lt;/code&gt; 을 소개합니다. 먼저 설정입니다.</target>
        </trans-unit>
        <trans-unit id="725d4e11de7f4d12c9dec721677224a202239038" translate="yes" xml:space="preserve">
          <source>Here, keys from &lt;code&gt;right&lt;/code&gt; are used, and missing data from &lt;code&gt;left&lt;/code&gt; is replaced by NaN.</source>
          <target state="translated">여기서 &lt;code&gt;right&lt;/code&gt; 키가 사용되고 &lt;code&gt;left&lt;/code&gt; 에서 누락 된 데이터는 NaN으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d464c60a85d171a37754315bbaaaf6bff05069" translate="yes" xml:space="preserve">
          <source>How do I add NaNs for missing rows after merge?</source>
          <target state="translated">병합 후 누락 된 행에 NaN을 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="c7331e4369e92398c7f2b5c59a8feb8bb1093cc3" translate="yes" xml:space="preserve">
          <source>How do I get rid of NaNs after merging?</source>
          <target state="translated">병합 후 NaN을 제거하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="b70834f508dd99443708d0e6dab1d7661550e144" translate="yes" xml:space="preserve">
          <source>How do I merge multiple DataFrames?</source>
          <target state="translated">여러 DataFrame을 병합하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="ec7ab3eaab1e71110c72a1446f4fca03042f8e88" translate="yes" xml:space="preserve">
          <source>How to perform a (&lt;code&gt;LEFT&lt;/code&gt;|&lt;code&gt;RIGHT&lt;/code&gt;|&lt;code&gt;FULL&lt;/code&gt;) (&lt;code&gt;INNER&lt;/code&gt;|&lt;code&gt;OUTER&lt;/code&gt;) join with pandas?</source>
          <target state="translated">팬더와 ( &lt;code&gt;LEFT&lt;/code&gt; | &lt;code&gt;RIGHT&lt;/code&gt; | &lt;code&gt;FULL&lt;/code&gt; ) ( &lt;code&gt;INNER&lt;/code&gt; | &lt;code&gt;OUTER&lt;/code&gt; ) 조인을 수행하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="590ea4aa1ee90e81d239fc9d56f1b1bedfcc570b" translate="yes" xml:space="preserve">
          <source>However, this quickly gets out of hand for many DataFrames. Furthermore, it may be necessary to generalise for an unknown number of DataFrames.</source>
          <target state="translated">그러나 이것은 많은 DataFrames에서 빨리 사라집니다. 또한 알려지지 않은 수의 DataFrame에 대해 일반화해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeaea9cd92c9ee89083a341170dc06b94b211808" translate="yes" xml:space="preserve">
          <source>If the key columns are named differently&amp;mdash;for example, &lt;code&gt;left&lt;/code&gt; has &lt;code&gt;keyLeft&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; has &lt;code&gt;keyRight&lt;/code&gt; instead of &lt;code&gt;key&lt;/code&gt;&amp;mdash;then you will have to specify &lt;code&gt;left_on&lt;/code&gt; and &lt;code&gt;right_on&lt;/code&gt; as arguments instead of &lt;code&gt;on&lt;/code&gt;:</source>
          <target state="translated">키 열의 이름이 다르게 지정된 경우 (예 : &lt;code&gt;left&lt;/code&gt; 에 &lt;code&gt;keyLeft&lt;/code&gt; 가 있고 &lt;code&gt;right&lt;/code&gt; 에 &lt;code&gt;keyRight&lt;/code&gt; 대신 keyRight 가있는 경우) on 대신에 &lt;code&gt;left_on&lt;/code&gt; 및 &lt;code&gt;right_on&lt;/code&gt; 을 인수로 지정해야 &lt;code&gt;on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb40dfde3892e6aefd5a0155840f14e86b3a2134" translate="yes" xml:space="preserve">
          <source>If you are required to merge only &quot;new_val&quot; (without any of the other columns), you can usually just subset columns before merging:</source>
          <target state="translated">다른 열없이 &quot;new_val&quot;만 병합해야하는 경우 병합하기 전에 열의 하위 집합 만 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d113e3602e0928e0c74900c4991c9e973010b060" translate="yes" xml:space="preserve">
          <source>If you need &lt;strong&gt;LEFT-Excluding JOINs&lt;/strong&gt; and &lt;strong&gt;RIGHT-Excluding JOINs&lt;/strong&gt; in two steps.</source>
          <target state="translated">두 단계로 &lt;strong&gt;왼쪽 제외 조인&lt;/strong&gt; 과 &lt;strong&gt;오른쪽&lt;/strong&gt; &lt;strong&gt;제외 조인&lt;/strong&gt; 이 필요한 경우.</target>
        </trans-unit>
        <trans-unit id="8ade95543cb04e70ba280fc7285da8574914b308" translate="yes" xml:space="preserve">
          <source>If you're doing a LEFT OUTER JOIN, a more performant solution would involve &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">LEFT OUTER JOIN을 수행하는 경우 더 성능이 좋은 솔루션은 &lt;code&gt;map&lt;/code&gt; 과 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="374c93a923b47d925b61c8f1eb876feca873190e" translate="yes" xml:space="preserve">
          <source>If your index is named, then v0.23 users can also specify the level name to &lt;code&gt;on&lt;/code&gt; (or &lt;code&gt;left_on&lt;/code&gt; and &lt;code&gt;right_on&lt;/code&gt; as necessary).</source>
          <target state="translated">인덱스의 이름이 지정된 경우 v0.23 사용자는 레벨 이름을 &lt;code&gt;on&lt;/code&gt; (또는 필요에 따라 &lt;code&gt;left_on&lt;/code&gt; 및 &lt;code&gt;right_on&lt;/code&gt; ) 으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfe10fc9220ec36d81dc169ab757056b92087b6e" translate="yes" xml:space="preserve">
          <source>If your keys (here, the key could either be a column or an index) are unique, then you can use &lt;code&gt;pd.concat&lt;/code&gt;. Note that &lt;strong&gt;&lt;code&gt;pd.concat&lt;/code&gt; joins DataFrames on the index&lt;/strong&gt;.</source>
          <target state="translated">키 (여기서는 키가 열 또는 인덱스 일 수 있음)가 고유 한 경우 &lt;code&gt;pd.concat&lt;/code&gt; 을 사용할 수 있습니다. &lt;strong&gt;pd.concat은 인덱스에서 &lt;code&gt;pd.concat&lt;/code&gt; 조인합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="475b67dd6757ca267b88c4d16cabae3f02a361b7" translate="yes" xml:space="preserve">
          <source>In particular, here's what this post will go through:</source>
          <target state="translated">특히이 게시물의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c159fd1406718489ff83ed0d71cd2f7e4bc5d04" translate="yes" xml:space="preserve">
          <source>In this situation, we can use &lt;code&gt;join&lt;/code&gt; since it can handle non-unique keys (note that &lt;code&gt;join&lt;/code&gt; joins DataFrames on their index; it calls &lt;code&gt;merge&lt;/code&gt; under the hood and does a LEFT OUTER JOIN unless otherwise specified).</source>
          <target state="translated">이 상황에서는 고유하지 않은 키를 처리 할 수 ​​있기 때문에 &lt;code&gt;join&lt;/code&gt; 을 사용할 수 있습니다 ( join 은 인덱스에서 DataFrames를 &lt;code&gt;join&lt;/code&gt; 합니다. 별도로 지정하지 않는 한 후드 아래에서 &lt;code&gt;merge&lt;/code&gt; 를 호출하고 LEFT OUTER JOIN을 수행함).</target>
        </trans-unit>
        <trans-unit id="af4435ecef9107713ea53391fc4f6d4af05456ed" translate="yes" xml:space="preserve">
          <source>In this special case, the index for &lt;code&gt;left&lt;/code&gt; is named, so you can also use the index name with &lt;code&gt;left_on&lt;/code&gt;, like this:</source>
          <target state="translated">이 특수한 경우 &lt;code&gt;left&lt;/code&gt; 의 색인 이름이 지정되므로 다음과 같이 &lt;code&gt;left_on&lt;/code&gt; 과 함께 색인 이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f214ae7602bc4d57e33b5ed62cc98ed8aa5b480" translate="yes" xml:space="preserve">
          <source>Index-based *-JOIN (+ index-column &lt;code&gt;merge&lt;/code&gt;s)</source>
          <target state="translated">인덱스 기반 * -JOIN (+ 인덱스 열 &lt;code&gt;merge&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4a334e4d9dd12b0fb723c5e01702c9fac7403bbd" translate="yes" xml:space="preserve">
          <source>It is possible (and quite simple) to use the index of one, and the column of another, to perform a merge. For example,</source>
          <target state="translated">하나의 인덱스와 다른 열을 사용하여 병합을 수행하는 것이 가능하고 매우 간단합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aba5643a4c6781cbd320a27656e3bc6a5ca4b5ee" translate="yes" xml:space="preserve">
          <source>Lastly, all visual representation of JOIN operations have been hand-drawn using Google Drawings. Inspiration from &lt;a href=&quot;https://stackoverflow.com/a/55858991/4909087&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">마지막으로 JOIN 작업의 모든 시각적 표현은 Google 드로잉을 사용하여 손으로 그린 ​​것입니다. &lt;a href=&quot;https://stackoverflow.com/a/55858991/4909087&quot;&gt;여기&lt;/a&gt; 에서 영감을 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="944b6e27435ef6bcaf6fb0aee9e6a82a89a9f23c" translate="yes" xml:space="preserve">
          <source>Lastly, as an alternative for index-based joins, you can use &lt;code&gt;pd.concat&lt;/code&gt;:</source>
          <target state="translated">마지막으로 인덱스 기반 조인의 대안으로 &lt;code&gt;pd.concat&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad33887bce7987add4e4b4f5ea15086e498e7e0" translate="yes" xml:space="preserve">
          <source>Lastly, if you are required to do a merge that only retains keys from the left or right, but not both (IOW, performing an &lt;strong&gt;ANTI-JOIN&lt;/strong&gt;),</source>
          <target state="translated">마지막으로 왼쪽 또는 오른쪽의 키만 유지하지만 둘다는 아닌 병합을 수행해야하는 경우 (IOW, &lt;strong&gt;ANTI-JOIN&lt;/strong&gt; 수행),</target>
        </trans-unit>
        <trans-unit id="a231b030ef5b726916a9d56a269a8948f80542ea" translate="yes" xml:space="preserve">
          <source>Merging with index under different conditions</source>
          <target state="translated">다른 조건에서 인덱스와 병합</target>
        </trans-unit>
        <trans-unit id="665ccf2127a2028a90e5aa2f1283fcffefa71276" translate="yes" xml:space="preserve">
          <source>Most examples default to INNER JOIN operations while demonstrating various features, unless otherwise specified.</source>
          <target state="translated">달리 명시되지 않는 한, 대부분의 예제는 INNER JOIN 작업을 기본으로하며 다양한 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="607088ecf55db984e56817b21a60a25dd9238d72" translate="yes" xml:space="preserve">
          <source>Multiway merges on columns and indexes (unique and non-unique)</source>
          <target state="translated">열과 인덱스에서 다 방향 병합 (고유 및 비 고유)</target>
        </trans-unit>
        <trans-unit id="f91e95f305e78598f5ca9e66ccaab49424d44ff0" translate="yes" xml:space="preserve">
          <source>Notable alternatives to &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 및 &lt;code&gt;join&lt;/code&gt; 를 위한 주목할만한 대안</target>
        </trans-unit>
        <trans-unit id="0da6066590f5816e8b4d28c0c08e18cd151d9b9d" translate="yes" xml:space="preserve">
          <source>Note that I needed to specify the &lt;code&gt;lsuffix&lt;/code&gt; and &lt;code&gt;rsuffix&lt;/code&gt; arguments since &lt;code&gt;join&lt;/code&gt; would otherwise error out:</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 은 그렇지 않으면 오류가 발생하므로 &lt;code&gt;lsuffix&lt;/code&gt; 및 &lt;code&gt;rsuffix&lt;/code&gt; 인수를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="88cbc228b0687ca19b8944c498764d1c434d3f84" translate="yes" xml:space="preserve">
          <source>Oftentimes, the situation arises when multiple DataFrames are to be merged together. Naively, this can be done by chaining &lt;code&gt;merge&lt;/code&gt; calls:</source>
          <target state="translated">종종 여러 DataFrame을 병합 할 때 상황이 발생합니다. 순진하게 이것은 &lt;code&gt;merge&lt;/code&gt; 호출을 연결 하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74c979837674a946b74074ca27bfd3811cd9853e" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;join='inner'&lt;/code&gt; for a FULL OUTER JOIN. Note that you cannot specify LEFT or RIGHT OUTER joins (if you need these, use &lt;code&gt;join&lt;/code&gt;, described below).</source>
          <target state="translated">전체 외부 &lt;code&gt;join='inner'&lt;/code&gt; 를 생략하십시오. LEFT 또는 RIGHT OUTER 조인을 지정할 수 없습니다 (필요한 경우 아래 설명 된 &lt;code&gt;join&lt;/code&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="102ba545f4946d55666818bd5a280a438b9871fc" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;join='inner'&lt;/code&gt; if you need a FULL OUTER JOIN (the default):</source>
          <target state="translated">FULL OUTER JOIN (기본값)이 필요한 경우 &lt;code&gt;join='inner'&lt;/code&gt; 를 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="05a244424d97a272a0e178b14f5663c7ab9f145b" translate="yes" xml:space="preserve">
          <source>Or vice versa (&lt;code&gt;right_on=...&lt;/code&gt; and &lt;code&gt;left_index=True&lt;/code&gt;).</source>
          <target state="translated">또는 그 반대의 경우도 마찬가지입니다 ( &lt;code&gt;right_on=...&lt;/code&gt; 및 &lt;code&gt;left_index=True&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="07b9054f88e6493d6db0dca4e7f62597c08641a1" translate="yes" xml:space="preserve">
          <source>Or, in the event the names are different,</source>
          <target state="translated">또는 이름이 다른 경우</target>
        </trans-unit>
        <trans-unit id="5697e4cea582b2b53f23941f3c2d227d9322e818" translate="yes" xml:space="preserve">
          <source>Pandas Merging 101</source>
          <target state="translated">팬더 병합 101</target>
        </trans-unit>
        <trans-unit id="dc8916943106d7b8e499dd43d074ae0c311a35b8" translate="yes" xml:space="preserve">
          <source>Performance-related discussions and timings (for now). Mostly notable mentions of better alternatives, wherever appropriate.</source>
          <target state="translated">성능 관련 토론 및 타이밍 (현재) 적절한 경우 더 나은 대안에 대한 언급이 가장 눈에.니다.</target>
        </trans-unit>
        <trans-unit id="80632853c724ac12fe9876adcc1e08b58ab4a279" translate="yes" xml:space="preserve">
          <source>Please note that this post is &lt;em&gt;not&lt;/em&gt; meant to be a replacement for the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html&quot;&gt;documentation&lt;/a&gt;, so please read that as well! Some of the examples are taken from there.</source>
          <target state="translated">이 게시물은 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html&quot;&gt;문서를&lt;/a&gt; 대체하기위한 것이 아니므로 읽어보십시오. 일부 예제는 거기에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8489e90b24906d38129e695e5a6f1ccdee465beb" translate="yes" xml:space="preserve">
          <source>Since the column names are the same. This would not be a problem if they were differently named.</source>
          <target state="translated">열 이름이 동일하므로 이름이 다른 경우에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75ae852b0b33b1eb09e99b09249b149bf95a045e" translate="yes" xml:space="preserve">
          <source>Start by performing a LEFT OUTER JOIN and then filtering (excluding!) rows coming from &lt;code&gt;left&lt;/code&gt; only,</source>
          <target state="translated">LEFT OUTER JOIN을 수행 한 다음 &lt;code&gt;left&lt;/code&gt; 에서 오는 행만 필터링 (제외!)하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef7fad0a1d2eb3b43899aba9c3f570d1c8b5c83" translate="yes" xml:space="preserve">
          <source>The basics - types of joins (LEFT, RIGHT, OUTER, INNER)</source>
          <target state="translated">기본 사항-조인 유형 (LEFT, RIGHT, OUTER, INNER)</target>
        </trans-unit>
        <trans-unit id="d1ba0420df6e09fc4740891e7c29f2d174791a0e" translate="yes" xml:space="preserve">
          <source>The documentation summarises these various merges nicely:</source>
          <target state="translated">문서는 이러한 다양한 병합을 잘 요약합니다.</target>
        </trans-unit>
        <trans-unit id="3ee0fb1a25ec9887a5aef2044120c5fc996e061d" translate="yes" xml:space="preserve">
          <source>This QnA is meant to be the next installment in a series of helpful  user-guides on common pandas idioms (see &lt;a href=&quot;https://stackoverflow.com/questions/47152691/how-to-pivot-a-dataframe&quot;&gt;this post on pivoting&lt;/a&gt;, and &lt;a href=&quot;https://stackoverflow.com/questions/49620538/what-are-the-levels-keys-and-names-arguments-for-in-pandas-concat-functio&quot;&gt;this post on concatenation&lt;/a&gt;, which I will be touching on, later).</source>
          <target state="translated">이 QnA는 일반적인 팬더 관용구에 대한 일련의 유용한 사용자 안내서의 다음 기사입니다 ( &lt;a href=&quot;https://stackoverflow.com/questions/47152691/how-to-pivot-a-dataframe&quot;&gt;피벗에&lt;/a&gt; 대한 이 게시물 및 &lt;a href=&quot;https://stackoverflow.com/questions/49620538/what-are-the-levels-keys-and-names-arguments-for-in-pandas-concat-functio&quot;&gt;연결&lt;/a&gt; 에 대한 이 게시물 참조).</target>
        </trans-unit>
        <trans-unit id="a5cbb6fc6632e6905b083b15b2b57d191ad83caa" translate="yes" xml:space="preserve">
          <source>This can be performed by specifying &lt;code&gt;how='left'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;how='left'&lt;/code&gt; 를 지정하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="561301843ee27f81fddd1193d439d6a5da314284" translate="yes" xml:space="preserve">
          <source>This post aims to give readers a primer on SQL-flavoured merging with pandas, how to use it, and when not to use it.</source>
          <target state="translated">이 글은 독자들에게 판다와의 SQL 맛 병합, 사용법, 사용하지 않을 때의 입문서를 제공하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="f193809b1a64b2973b3e40ae02f4b26fb4d73d57" translate="yes" xml:space="preserve">
          <source>This returns only rows from &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; which share a common key (in this example, &quot;B&quot; and &quot;D).</source>
          <target state="translated">이렇게하면 공통 키 (이 예에서는 &quot;B&quot;및 &quot;D)를 공유하는 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 행만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc20f80d1910041d16cd3186a7ab719db61a4bfb" translate="yes" xml:space="preserve">
          <source>This uses the keys from both frames, and NaNs are inserted for missing rows in both.</source>
          <target state="translated">이것은 두 프레임의 키를 사용하며 NaN은 두 행에서 누락 된 행에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="abadcbef4b514c4a331c1cf4eab5e3e066a38df0" translate="yes" xml:space="preserve">
          <source>This, along with the forthcoming figures all follow this convention:</source>
          <target state="translated">이것은 곧 나오는 수치와 함께이 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="890a900af7bfca6e4a52648b6c1c0096f237c414" translate="yes" xml:space="preserve">
          <source>To join on more than one column, specify a list for &lt;code&gt;on&lt;/code&gt; (or &lt;code&gt;left_on&lt;/code&gt; and &lt;code&gt;right_on&lt;/code&gt;, as appropriate).</source>
          <target state="translated">둘 이상의 열을 결합하려면 on에 대한 목록을 지정하십시오 (또는 적절한 경우 &lt;code&gt;left_on&lt;/code&gt; 및 &lt;code&gt;right_on&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="200e8b079f37dea5c7a91c3d92c2bd10bfa61aa2" translate="yes" xml:space="preserve">
          <source>To perform an INNER JOIN, call &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; on the left DataFrame, specifying the right DataFrame and the join key (at the very least) as arguments.</source>
          <target state="translated">INNER JOIN을 수행하려면 오른쪽 DataFrame과 조인 키 (최소한)를 인수로 지정하여 왼쪽 DataFrame에서 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt; 를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="76cdd0dfbcd4a1c2aff2ffc1892c6899234862d0" translate="yes" xml:space="preserve">
          <source>Typically, a merge on index would look like this:</source>
          <target state="translated">일반적으로 인덱스 병합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3088c6fd3fa1b783ed77e813a11ff11a652eda1a" translate="yes" xml:space="preserve">
          <source>What this post will not go through:</source>
          <target state="translated">이 게시물에서 다루지 않을 내용 :</target>
        </trans-unit>
        <trans-unit id="3babbd75789aa7b7e12f76e54df0e1ec56f5a0d8" translate="yes" xml:space="preserve">
          <source>When merging on &lt;code&gt;keyLeft&lt;/code&gt; from &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;keyRight&lt;/code&gt; from &lt;code&gt;right&lt;/code&gt;, if you only want either of the &lt;code&gt;keyLeft&lt;/code&gt; or &lt;code&gt;keyRight&lt;/code&gt; (but not both) in the output, you can start by setting the index as a preliminary step.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 에서 &lt;code&gt;keyLeft&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 에서 keyRight 를 병합 할 때 출력 에서 &lt;code&gt;keyLeft&lt;/code&gt; 또는 &lt;code&gt;keyRight&lt;/code&gt; 중 하나만 원할 경우 색인을 예비 단계로 설정하여 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="80c6e7b90aacc40077e84fbf4d87db5eb023661d" translate="yes" xml:space="preserve">
          <source>You can do this in similar fashion&amp;mdash;</source>
          <target state="translated">비슷한 방식으로이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d586ffef63f25ff69cedaa357339a3bfd5dacf05" translate="yes" xml:space="preserve">
          <source>avoiding duplicate merge key column in output</source>
          <target state="translated">출력에서 중복 병합 키 열 피하기</target>
        </trans-unit>
        <trans-unit id="9df2bcf0d0a2d35c9f9ffb76e1e055b890da273d" translate="yes" xml:space="preserve">
          <source>effectively using your named index</source>
          <target state="translated">효과적으로 명명 된 인덱스를 사용하여</target>
        </trans-unit>
        <trans-unit id="ad17b4441f01dcecc445d9760594d4b98953d51b" translate="yes" xml:space="preserve">
          <source>merge key as the index of one and column of another</source>
          <target state="translated">하나의 인덱스와 다른 열의 병합 키</target>
        </trans-unit>
        <trans-unit id="a0964be3b9c53f48ca1c8047562588e85b354d89" translate="yes" xml:space="preserve">
          <source>merging with different column names</source>
          <target state="translated">다른 열 이름과 병합</target>
        </trans-unit>
        <trans-unit id="23fdc7c2a84f93183ba1783be773c30afeb92477" translate="yes" xml:space="preserve">
          <source>specify &lt;code&gt;how='outer'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;how='outer'&lt;/code&gt; 를 지정하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
