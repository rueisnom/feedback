<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3295496">
    <body>
      <group id="3295496">
        <trans-unit id="0c720cf1be2b9537b354e91f7a3787de5331d609" translate="yes" xml:space="preserve">
          <source>&amp;bull; It is not an inner class.
&amp;bull; It is a non-abstract class, or is annotated @Decorator.
&amp;bull; It does not implement javax.enterprise.inject.spi.Extension.
&amp;bull; It is not annotated @Vetoed or in a package annotated @Vetoed.
&amp;bull; It has an appropriate constructor, either: the class has a constructor with    no parameters, or the class declares a constructor annotated @Inject.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull; 내부 수업이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull; 비 추상적 인 클래스이거나 @Decorator로 주석이 달렸습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull; javax.enterprise.inject.spi.Extension을 구현하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull; @Vetoed 또는 @Vetoed로 주석이 달린 패키지에는 주석이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull; 적절한 생성자가 있습니다. 클래스에 매개 변수가없는 생성자가 있거나 클래스가 @Inject로 주석이 달린 생성자를 선언합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="318e496067fd62a66317acc990767262643a180e" translate="yes" xml:space="preserve">
          <source>&amp;bull; It is not annotated with an EJB component-defining annotation or declared as an EJB bean class
in ejb-jar.xml.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull; EJB 구성 요소 정의 주석으로 주석을 달거나 ejb-jar.xml에서 EJB Bean 클래스로 선언되지 않았습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fe65bf0c3eacef06df91fc4cf361d736a8084b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=365&quot;&gt;The CDI specification&lt;/a&gt; re-defines managed beans as:
When running in Java EE, A top-level Java class is a managed bean if it meets requirements:</source>
          <target state="translated">&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=365&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CDI 스펙&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 관리 Bean을 다음과 같이 재정의합니다. Java EE에서 실행될 때 최상위 Java 클래스는 요구 사항을 충족시키는 경우 관리 Bean입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38ed6cbe8aed300abef020fdadb5bcde73fee055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. import java.io.Serializable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1. java.io.Serializable 가져 오기&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a49ecf03c903cc3a6f83326b48867007e08a740a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. private fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2. 개인 분야&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a758db005e282d406bf62f2118dfdb233ae8c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3. 생성자&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="872f893a46991a54114d46bdfdef55453c8b29cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. getter/setter&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4. 게터 / 세터&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a26334708d80ce05d587475829e9fc057f2497ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typical uses of Beans in real world:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제 콩의 일반적인 용도 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d918238982e54950b68a3c920d828b0c968d423" translate="yes" xml:space="preserve">
          <source>A Java Bean is a java class [conceptual] that should follow following conventions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Bean은 다음 규칙을 따라야하는 Java 클래스 [개념적]입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="136fc13f09b8c954f8e4f0e3eaa8c82c441d505e" translate="yes" xml:space="preserve">
          <source>A Java Bean is essentially a class, what classifies a class as a bean is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Bean은 본질적으로 클래스이며, 클래스를 Bean으로 분류하는 것은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2df1ae47eb0577a2972cbb68c03f1736120b653a" translate="yes" xml:space="preserve">
          <source>A JavaBean is a Java object that satisfies certain programming conventions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean은 특정 프로그래밍 규칙을 만족시키는 Java 객체입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="943d73a0fc0f89137bcf6abba6ddd867beb03874" translate="yes" xml:space="preserve">
          <source>A JavaBean is just a &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html&quot;&gt;standard&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean은 단지 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표준입니다&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f7f11c17e1ad6e05c056d7c1b5b633cdfb32a50" translate="yes" xml:space="preserve">
          <source>A bean &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;is&lt;/a&gt; a Java class with method names that follow the Java Bean guidelines (also called design patterns) for &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;properties&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/methods.html&quot;&gt;methods&lt;/a&gt;, and &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/events.html&quot;&gt;events&lt;/a&gt; . Thus, any public method of the bean class that is not part of a property definition is a bean method. Minimally, a Java class even with either a property as the sole member (of course, accompanying public getter and setter required), a public method as the sole member or just one public event listener registration method is a Java bean. Furthermore, the property can either be read-only property (has a getter method but no setter) or write-only property (has a setter method only). The Java bean needs to be a public class to be visible to any beanbox tool or container. The container must be able to instantiate it; thus, it must have a public constructor too. The &lt;a href=&quot;https://www.oracle.com/technetwork/articles/javaee/spec-136004.html&quot;&gt;JavaBeans specification&lt;/a&gt; doesn&amp;rsquo;t  require a bean to have a public zero-args constructor, explicit or default, for a container to instantiate it. If you could provide a file (with extension .ser) containing a serialized instance, a beanbox tool could use that file to instantiate a prototype bean. Otherwise, the bean must have a public zero-args constructor, either explicit or default.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bean &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특성&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/methods.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/events.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이벤트에&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 Java Bean 지침 (디자인 패턴이라고도 함)을 따르는 메소드 이름을 가진 Java 클래스입니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 따라서 특성 정의의 일부가 아닌 Bean 클래스의 공용 메소드는 Bean 메소드입니다. 최소한 단일 멤버 (물론 공개 getter 및 setter가 동반 됨)로서 특성이 있거나 단일 멤버로서 공용 메소드이거나 하나의 공개 이벤트 리스너 등록 메소드 만있는 Java 클래스는 Java Bean입니다. 또한이 속성은 읽기 전용 속성 (게터 메서드는 있지만 세터는 없음) 또는 쓰기 전용 속성 (세터는 메서드 만) 일 수 있습니다. Java bean은 모든 beanbox 도구 또는 컨테이너에 표시 될 수있는 공용 클래스 여야합니다. 컨테이너는 인스턴스화 할 수 있어야합니다. 따라서 공용 생성자도 있어야합니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/articles/javaee/spec-136004.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바 빈즈 사양&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컨테이너가 인스턴스화하기 위해 Bean에 명시 적 또는 기본값의 공개 0 인수 생성자를 가질 필요는 없습니다. 직렬화 된 인스턴스를 포함하는 파일 (확장명이 .ser 인 파일)을 제공 할 수있는 경우 Beanbox 도구는 해당 파일을 사용하여 프로토 타입 Bean을 인스턴스화 할 수 있습니다. 그렇지 않으면, Bean에는 명시 적 또는 기본값 인 공용 0-args 생성자가 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="840c31e8b502d6a3ccab76ae17bb2028d031a853" translate="yes" xml:space="preserve">
          <source>A class that can not abide by those limitations should not implement &lt;code&gt;Serializable&lt;/code&gt; (and, IIRC, the Java compiler won't even &lt;em&gt;let&lt;/em&gt; it do so.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 제한 사항을 준수 할 수없는 클래스는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구현해서는 안됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(IIRC의 경우 Java 컴파일러는이를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;허용&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하지 않습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9747d0a45d4adc924ab9127cfa96048b5c2663b0" translate="yes" xml:space="preserve">
          <source>A public &lt;a href=&quot;http://en.wikipedia.org/wiki/Nullary_constructor&quot;&gt;no-argument constructor&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Nullary_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인수없는&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 공개 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b87bd7deae485bab9140383355afab0efe2f97c" translate="yes" xml:space="preserve">
          <source>A public constructor without any argument.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인수가없는 공개 생성자&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e68b27213f4f51dde87904a41d77b1a46d4e5820" translate="yes" xml:space="preserve">
          <source>About Serialization:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 정보 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d70cdc7ecce4b58b0bf4d276d3442a5efd9554f2" translate="yes" xml:space="preserve">
          <source>After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 된 객체가 파일에 기록 된 후 파일에서 읽고 직렬화 해제 할 수 있습니다. 즉 객체와 해당 데이터를 나타내는 유형 정보와 바이트를 사용하여 객체를 메모리에 다시 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc7d5f7f6aa1b17a4491e1a08b0ff9891e56d860" translate="yes" xml:space="preserve">
          <source>All Java classes that meet these conditions are managed beans and thus no special declaration is
required to define a managed bean. &lt;strong&gt;Or&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 조건을 만족하는 모든 Java 클래스는 관리 Bean이므로 관리 Bean을 정의하기 위해 특별한 선언이 필요하지 않습니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ff27e94ce8d1aa5a258d0c287f6edd1ae9139cc" translate="yes" xml:space="preserve">
          <source>All JavaBean instance variables should be private</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 JavaBean 인스턴스 변수는 개인용이어야합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46a62eae4314ebe2f79eb24fb004f645071fe3cc" translate="yes" xml:space="preserve">
          <source>All JavaBean properties must have public setter and getter methods</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 JavaBean 특성에는 공용 setter 및 getter 메소드가 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="583c6f767c8fbd15748949b1c4e7cc8e91812e00" translate="yes" xml:space="preserve">
          <source>All properties private (use &lt;a href=&quot;http://en.wikipedia.org/wiki/Mutator_method&quot;&gt;getters/setters&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 개인 속성 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mutator_method&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터 / 세터 사용&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4c99079d28d0aa72365f1b4f85a989bd3a2434e" translate="yes" xml:space="preserve">
          <source>Also what does the &lt;code&gt;Serializable&lt;/code&gt; interface mean?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인터페이스는 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6a19841937b5de90672f912f7b8de17a63df1abc" translate="yes" xml:space="preserve">
          <source>Also, is there a real &lt;em&gt;syntactic&lt;/em&gt; difference between a bean and a regular class? Is there any special definition or an interface?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빈과 정규 클래스 사이에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실질적인 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구문상의&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 차이가 있습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특별한 정의 나 인터페이스가 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fbcd1a65323b37839ca533fa3b075c3ddc7b5ef" translate="yes" xml:space="preserve">
          <source>Also, there is no syntactic difference between a JavaBean and another class -- a class is a JavaBean if it follows the standards.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 JavaBean과 다른 클래스 간에는 구문상의 차이가 없습니다. 클래스는 표준을 따르는 경우 JavaBean입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4afcbba96c1537542cb5c45aa89095555d34b237" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;Serializable&lt;/code&gt;:  That is nothing but a &quot;marker interface&quot; (an interface that doesn't declare any functions) that tells Java that the implementing class consents to (and implies that it is capable of) &quot;serialization&quot; -- a process that converts an instance into a stream of bytes.  Those bytes can be stored in files, sent over a network connection, etc, and have enough info to allow a JVM (at least, one that knows about the object's type) to reconstruct the object later -- possibly in a different instance of the application, or even on a whole other machine!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 관해서는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : 그것은 아무것도하지만 자바를 알려주는 &quot;마커 인터페이스&quot;(어떤 함수를 선언하지 않는 인터페이스)를 구현하는 클래스 동의는 &quot;직렬화&quot;(그것은 할 수 있음을 의미한다) 것이 없다 - 프로세스가 인스턴스를 바이트 스트림으로 변환합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 바이트는 파일에 저장되거나 네트워크 연결을 통해 전송 될 수 있으며 JVM (적어도 객체 유형에 대해 알고있는 것)이 나중에 객체를 나중에 재구성 할 수 있도록 충분한 정보를 가질 수 있습니다. 응용 프로그램 또는 전체 다른 시스템에서도!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13e8118270c12b1dcfe8b170b320c042cb236f40" translate="yes" xml:space="preserve">
          <source>As for the Serialization, see the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화에 대해서는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문서를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca67d9ce952533251528bc96a99a40477e0d80de" translate="yes" xml:space="preserve">
          <source>As per the Wikipedia:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia에 따라 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6a6aa35f3845de7a4a3ee993dcb66442b8fd4612" translate="yes" xml:space="preserve">
          <source>As the tools evolved, they moved more towards annotations and away from pulling apart the setter/getter names.  Now most systems don't require beans, they can take any plain old java object with annotated properties to tell them how to manipulate them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도구가 발전함에 따라, 주석쪽으로 더 나아가서 setter / getter 이름을 분리하지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 대부분의 시스템은 Bean을 필요로하지 않으며, 주석 처리 된 속성이있는 일반 오래된 Java 오브젝트를 사용하여 조작 방법을 알려줄 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f79e211af28e9fa77cb803b2bfc3232f21e5d6f" translate="yes" xml:space="preserve">
          <source>Basically, a &quot;Bean&quot;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 &quot;Bean&quot;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77c8cb4cf6d1a687f851297788111874673f9c84" translate="yes" xml:space="preserve">
          <source>Basically, why is there a term for this?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 왜 이것에 대한 용어가 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c46a4c9432c3f3300b98f5468f7facb82b723f5" translate="yes" xml:space="preserve">
          <source>Beans themselves are not a healthy pattern.  They destroy encapsulation by their nature since they expose all their properties to external manipulation and as they are used there is a tendency (by no means a requirement) to create code to manipulate the bean externally instead of creating code inside the bean (violates &quot;don't ask an object for it's values, ask an object to do something for you&quot;).  Using annotated pojos with minimal getters and no setters is much more OO restoring encapsulation and with the possibility of immutability.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;콩 자체는 건강한 패턴이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것들은 모든 속성을 외부 조작에 노출시키기 때문에 본질적으로 캡슐화를 파괴합니다. 그것들이 사용됨에 따라 빈 내부에서 코드를 생성하는 대신 외부에서 빈을 조작하는 코드를 생성하는 경향이 있습니다 (필수는 아님). '객체에게 가치를 요구하지 말고, 당신에게 무언가를 해달라고 부탁하십시오 &quot;). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터가 최소이고 세터가없는 주석이 달린 포조를 사용하면 캡슐화를 훨씬 더 잘 복원하고 불변의 가능성이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47dd15199c6b5bc8e4b7ee1df2206d7d5a498067" translate="yes" xml:space="preserve">
          <source>By the way, as all this stuff was happening someone extended the concept to something called Enterprise Java Beans.  These are... different.  and they are complicated enough that many people felt they didn't understand the entire Bean concept and stopped using the term.  This is, I think, why you generally hear beans referred to as POJOs (since every java object is a POJO this is technically OK, but when you hear someone say POJO they are most often thinking about something that follows the bean pattern)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그건 그렇고,이 모든 일이 일어나면서 누군가가 개념을 Enterprise Java Beans로 확장했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것들은 ... 다르다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 그들은 많은 사람들이 Bean 개념 전체를 이해하지 못한다고 생각하고 용어 사용을 중단 할 정도로 복잡합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 일반적으로 POJO라고 불리는 Bean을 듣는 이유입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b079abf5db9c4f0b675aa9c186b7bd92441d4bd8" translate="yes" xml:space="preserve">
          <source>EJB (Enterprise Java Beans), more complex objects, like JSF Beans (JSF is old quite outdated technology) or JSP Beans</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EJB (Enterprise Java Beans), JSF Bean (JSF는 매우 오래된 기술 임) 또는 JSP Bean과 같은보다 복잡한 객체&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7446953410d8a1127870a9faa024ad22c3158780" translate="yes" xml:space="preserve">
          <source>EJBs run in an EJB container.  Its &lt;a href=&quot;https://jcp.org/aboutJava/communityprocess/final/jsr345/index.html&quot;&gt;specification&lt;/a&gt; says: &amp;ldquo;A session bean component is a Managed Bean.&quot; &amp;ldquo;The class must have a public constructor that takes no arguments,&amp;rdquo; it says for both session bean and message-driven bean.  Further, it says, &amp;ldquo;The session bean class is not required to implement the SessionBean interface or the Serializable interface.&amp;rdquo; For the same reason as JSF beans, that EJB3 dependency injection is basically resource injection, JSF beans do not support constructors with arguments, that is, via dependency injection.  However, if the EJB container implements CDI, &amp;ldquo; Optionally: The class may have an additional constructor annotated with the Inject annotation, &amp;ldquo; it says for both session bean and message-driven bean because, &amp;ldquo;An EJB packaged into a CDI bean archive and not annotated with javax.enterprise.inject.Vetoed annotation, is considered a CDI-enabled bean.&amp;rdquo;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EJB는 EJB 컨테이너에서 실행됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jcp.org/aboutJava/communityprocess/final/jsr345/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사양&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;세션 Bean 구성 요소는 관리 Bean입니다.&quot; &quot;클래스에는 Bean을 사용하지 않는 공용 생성자가 있어야합니다.&quot;세션 Bean과 메시지 구동 Bean 모두에 대해 &quot;세션 Bean 클래스는 SessionBean 인터페이스 나 Serializable 인터페이스를 구현할 필요가 없습니다.&amp;rdquo; EJBF 의존성 주입은 기본적으로 자원 주입이라는 JSF bean과 같은 이유로 JSF bean은 인수가있는 생성자, 즉 의존성 주입을 통해 생성자를 지원하지 않지만 EJB 컨테이너가 CDI를 구현하는 경우&amp;ldquo;선택적으로 : 클래스에는 Inject 주석으로 주석이 추가 된 추가 생성자 &quot;세션 Bean과 메시지 구동 Bean 모두에 대해 말합니다. 콩.&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4031d069633ae6036f6bfbdbea649d071e5b38ba" translate="yes" xml:space="preserve">
          <source>Example of JavaBeans</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바 빈즈의 예&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad1f18b813307b3689532f8691c6c325bd135aa7" translate="yes" xml:space="preserve">
          <source>Explanation with an example.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 설명하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46e8f66328748c5a2f75957e8799c069ad64a0fa" translate="yes" xml:space="preserve">
          <source>Fields should be private for prevent outer classes to easily modify those fields.
Instead of directly accesing to those fields, usuagly getter/setter methods are used.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;외부 클래스가 해당 필드를 쉽게 수정할 수 없도록 필드는 개인용이어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 필드에 직접 액세스하는 대신 일반적으로 getter / setter 메소드가 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84c6880e63e95c7bded8292f072de4945bf71312" translate="yes" xml:space="preserve">
          <source>For more information follow this &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaBean&quot;&gt;link.&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 내용은이 &lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaBean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;링크&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 참조하십시오 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="69d0558fac25bebb38553b9bc8c4b9654e4b5344" translate="yes" xml:space="preserve">
          <source>Getter and setter methods for accessing and modifying private fields.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인 필드에 액세스하고 수정하기위한 Getter 및 Setter 메소드&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ac3ddba09730353ccbd893d3c22cd6cefb88ed8" translate="yes" xml:space="preserve">
          <source>Good to note the serialVersionUID field is important for maintaining object state.
Below code qualifies as a bean:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;serialVersionUID 필드는 객체 상태를 유지 관리하는 데 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 코드는 Bean으로 규정됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc2a15fb6add8845ca719b9881253fe96b7197b5" translate="yes" xml:space="preserve">
          <source>Here is an extract from the &lt;a href=&quot;https://download.oracle.com/otndocs/jcp/managed_beans-1.0-fr-eval-oth-JSpec/&quot;&gt;Managed Bean specification&lt;/a&gt;
&amp;ldquo; Managed Beans are container-managed objects with minimal requirements,
otherwise known under the acronym &amp;ldquo;POJOs&amp;rdquo; (Plain Old Java Objects)&amp;hellip;they can be seen as a Java EE platform-enhanced version of the JavaBeans component model found on the Java SE platform&amp;hellip;. It won&amp;rsquo;t be missed by the reader that Managed Beans have a precursor in the homonymous facility found in the JavaServer Faces (JSF) technology&amp;hellip;Managed Beans as defined in this specification represent a generalization of those found in JSF; in particular, Managed Beans can be used anywhere in a Java EE application, not just in web modules. For example, in the basic component model, Managed Beans must provide a no-argument constructor, but a specification that builds on Managed Beans, such as CDI (JSR-299), can relax that requirement and allow Managed Beans to provide constructors with more complex signatures, as long as they follow some well-defined rules...A Managed Bean must not be: a final class, an abstract class, a non-static inner class. A Managed Bean may not be serializable unlike a regular JavaBean component.&amp;rdquo;
Thus, the specification for Managed Beans, otherwise known as POJOs or POJO beans, allows extension as in CDI.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 &lt;/font&gt;&lt;a href=&quot;https://download.oracle.com/otndocs/jcp/managed_beans-1.0-fr-eval-oth-JSpec/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;관리 Bean 스펙&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 추출한 것입니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;관리 Bean은 최소한의 요구 사항을 가진 컨테이너 관리 오브젝트이며,&quot;POJO &quot;(일반적인 Java 오브젝트)라는 약어로 알려져 있습니다. Java SE 플랫폼에서 찾을 수있는 Java EE 플랫폼 향상 버전의 JavaBeans 컴포넌트 모델로 볼 수 있습니다. &amp;hellip;. Managed Beans는 JSF (JavaServer Faces) 기술에서 볼 수있는 동종 설비에 선구자가 있다는 사실을 잊지 못할 것입니다.이 스펙에 정의 된대로 관리되는 Bean은 JSF에서 발견 된 것의 일반화를 나타냅니다. 특히, Managed Beans는 웹 모듈뿐만 아니라 Java EE 애플리케이션의 어느 곳에서나 사용할 수 있습니다. 예를 들어, 기본 컴포넌트 모델에서 관리 Bean은 인수가없는 생성자를 제공해야하지만 CDI (JSR-299)와 같이 관리 Bean을 기반으로하는 스펙을 제공해야합니다.잘 정의 된 규칙을 따르는 한 Managed Beans가 요구 사항을 완화하고 Managed Beans가 생성자에게 더 복잡한 서명을 제공 할 수 있도록합니다 ... Managed Bean은 최종 클래스, 추상 클래스, 비 정적 내부 클래스가 아니어야합니다. . 관리되는 Bean은 일반 JavaBean 구성 요소와 달리 직렬화 할 수 없습니다.&amp;rdquo; 따라서 POJO 또는 POJO Bean으로 알려진 관리 Bean의 스펙은 CDI에서와 같이 확장을 허용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="217401a02b941df9e7269aa8987d0dc791e3faac" translate="yes" xml:space="preserve">
          <source>How to use them, is just your invention, but most common cases I enlisted above.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것들을 사용하는 방법은 당신의 발명 일 뿐이지 만, 내가 입대 한 가장 일반적인 경우입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="132f01fd38954ec747060bf12719260879342b93" translate="yes" xml:space="preserve">
          <source>However, IMO, it is more than a simple syntax standard. The real meaning or intended usage of Java Beans is, together with various tool supports around the standard,  to facilitate code reuse and component-based software engineering, i.e. enable developers to build applications by assembling existing components (classes) and without having to write any code (or only have to write a little glue code). Unfortunately this technology is way under-estimated and under-utilized by the industry, which can be told from the answers in this thread.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 IMO는 단순한 구문 표준 이상입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Beans의 진정한 의미 또는 의도 된 사용법은 표준을 중심으로 다양한 도구 지원과 함께 코드 재사용 및 구성 요소 기반 소프트웨어 엔지니어링을 용이하게합니다. 즉, 개발자가 기존 구성 요소 (클래스)를 조립하거나 작성하지 않고도 응용 프로그램을 빌드 할 수 있도록합니다. 코드 (또는 작은 접착제 코드 만 작성하면 됨). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행히도이 기술은 업계에서 과소 평가되고 활용도가 낮 으며이 스레드의 답변에서 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f7b5bf6e1eb2b8c5d9e495927c3f26777a4f3d9" translate="yes" xml:space="preserve">
          <source>I understood, I think, that a &quot;Bean&quot; is a Java class with properties and getters/setters. As much as I understand, it is the equivalent of a C struct. Is that true?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 &quot;Bean&quot;이 속성과 getter / setter를 가진 Java 클래스라는 것을 이해했다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 이해하는 한 C 구조체와 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그게 사실입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a4de59b80377dafe9abca055f20cd53f95c3b3f" translate="yes" xml:space="preserve">
          <source>If you read Oracle's &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/index.html&quot;&gt;tutorial on Java Beans&lt;/a&gt;, you can get a better understanding in that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Beans에 대한&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Oracle의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자습서&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 읽으면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 잘 이해할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="487d65f0cdd670ecba4efce16570bfd0cd1b5ad5" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt; &lt;code&gt;Serializable&lt;/code&gt; 을&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구현 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d842393b0b58f41bdc74fe0276a7770f498b136d" translate="yes" xml:space="preserve">
          <source>In object serialization an object can be represented as a sequence of bytes that includes the object's data as well as information about the object's type and the types of data stored in the object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 직렬화에서 객체는 객체의 유형과 객체에 저장된 데이터 유형에 대한 정보뿐만 아니라 객체의 데이터를 포함하는 일련의 바이트로 표현 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e9f7889e439155833eb47c33695d0e651aef43e" translate="yes" xml:space="preserve">
          <source>In other words, serializable objects can be written to streams, and hence files, object databases, anything really.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다시 말해, 직렬화 가능 객체는 스트림, 따라서 파일, 객체 데이터베이스 등에 실제로 기록 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c82538de50cd66977535d30c5f50dfb1fd98dfa" translate="yes" xml:space="preserve">
          <source>In practice, Beans are just objects which are handy to use. Serializing them means to be able easily to persist them (store in a form that is easily recovered).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 Bean은 사용하기 편리한 객체 일뿐입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것들을 직렬화한다는 것은 그것들을 쉽게 유지할 수 있다는 것을 의미합니다 (쉽게 복구되는 형태로 저장).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cfd8a07163911715251e5fe480435b5ac4ea0c99" translate="yes" xml:space="preserve">
          <source>It is a reusable software component. It can encapsulate many object into one object so that same object can be accessed from multiples places and is a step towards easy maintenance of code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재사용 가능한 소프트웨어 구성 요소입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 개체를 하나의 개체로 캡슐화하여 여러 개체에서 동일한 개체에 액세스 할 수 있으며 코드를 쉽게 유지 관리하기위한 단계입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c95fba0c5f1c0807a6b0b6c9e7c78555a297496b" translate="yes" xml:space="preserve">
          <source>It should be Serializable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 가능해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bdf417910c9cd2ee31c632a3320a394c6e915215" translate="yes" xml:space="preserve">
          <source>It should have a no-arg constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인수가없는 생성자가 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c50498f3df224d809cc4c33e52e6abc86fce44c" translate="yes" xml:space="preserve">
          <source>It should have getter and setters.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터와 세터가 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dde74edd26e8d91a7f0fd68a9f94d0eaf69d087a" translate="yes" xml:space="preserve">
          <source>It should implement serializable interface (A Marker interface).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 가능 인터페이스 (Marker 인터페이스)를 구현해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d6b67638120ceead2afc1dc40516395855ba3d42" translate="yes" xml:space="preserve">
          <source>It should provide methods to set and get the values of the properties, known as getter and setter methods.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 및 setter 메소드라고하는 특성 값을 설정하고 가져 오는 메소드를 제공해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80df53906b4d96fbb996894573f6918076ecac61" translate="yes" xml:space="preserve">
          <source>JSF managed beans run in a web container. They can be configured either with @ManagedBean annotation or  with an application configuration resource file managed-bean.xml.  However, it supports injection via resource injection (not typesafe) only; not fit for injection on constructors. The &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=372&quot;&gt;JSF spec&lt;/a&gt; requires that managed beans must have a public zero-argument constructors . Further it says, &amp;ldquo;As of version 2.3 of this specification, use of the managed bean facility as specified in this section is strongly
discouraged. A better and more cohesively integrated solution for solving the same problem is to use Contexts and Dependency Injection (CDI), as specified in JSR-365.&quot; In other words, CDI managed beans to be used, which offers typesafe dependency injection on constructors akin to Spring beans.  The CDI specification adopts the Managed Beans specification, which applies to all containers of the JEE platform, not just web tier. Thus, the web container needs to implement CDI specification.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSF 관리 Bean은 웹 컨테이너에서 실행됩니다. @ManagedBean 어노테이션 또는 애플리케이션 구성 자원 파일 managed-bean.xml을 사용하여 구성 할 수 있습니다. 그러나 리소스 주입 (유형 안전 아님)을 통한 주입 만 지원합니다. 생성자에 주입하기에 적합하지 않습니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=372&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSF 사양&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;관리 Bean에는 공용 0 인수 생성자가 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한이 스펙의 버전 2.3에서이 섹션에 지정된대로 관리 Bean 기능을 사용하지 않는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한 문제를 해결하기위한보다 강력하고 응집력있는 통합 솔루션은 JSR-365에 지정된대로 CDI (Contexts and Dependency Injection)를 사용하는 것입니다. &quot;다시 말해 CDI 관리 Bean을 사용하여 생성자에 대해 유형 안전성 종속성 주입을 제공합니다. CDI 스펙은 웹 티어가 아닌 JEE 플랫폼의 모든 컨테이너에 적용되는 관리 Beans 스펙을 채택하므로 웹 컨테이너는 CDI 스펙을 구현해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f06dd2e12d43ff81497ada376a9dd0a96b32fbc" translate="yes" xml:space="preserve">
          <source>Java Beans are using for less code and more work approach... 
Java Beans are used throughout Java EE as a universal contract for runtime discovery and access. For example, JavaServer Pages (JSP) uses Java Beans as data transfer objects between pages or between servlets and JSPs. Java EE's JavaBeans Activation Framework uses Java Beans for integrating support for MIME data types into Java EE. The Java EE Management API uses JavaBeans as the foundation for the instrumentation of resources to be managed in a Java EE environment.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Beans는 적은 코드와 더 많은 작업 접근 방식을 사용하고 있습니다 ... Java Beans는 Java EE 전체에서 런타임 발견 및 액세스를위한 범용 계약으로 사용됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, JSP (JavaServer Pages)는 페이지 간 또는 서블릿과 JSP 간의 데이터 전송 오브젝트로 Java Bean을 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java EE의 JavaBeans Activation Framework는 MIME 데이터 유형에 대한 지원을 Java EE에 통합하기 위해 Java Bean을 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java EE 관리 API는 Java EE 환경에서 관리 할 자원을 계측하기위한 기초로 JavaBeans를 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4fe52d529d685dcd20b5bb6bb18b59658689c6d4" translate="yes" xml:space="preserve">
          <source>Java Beans is a standard, and its basic syntax requirements have been clearly explained by the other answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Beans는 표준이며 기본 구문 요구 사항은 다른 답변에서 명확하게 설명되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b33a1a821d93319a7c70a389e1ebd7d57f9da26" translate="yes" xml:space="preserve">
          <source>JavaBean is a development tool can be visualized in the operation of reusable software components</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean은 재사용 가능한 소프트웨어 구성 요소의 작동에서 시각화 할 수있는 개발 도구입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acb9654b482066659ee3afb750687ff58cd3d85b" translate="yes" xml:space="preserve">
          <source>JavaBean is based on the Sun JavaBeans specification and can be  reusable components. Its biggest feature is the re-usability.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean은 Sun JavaBeans 사양을 기반으로하며 재사용 가능한 구성 요소 일 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 큰 특징은 재사용 성입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1297f3b73908b93b716b86938bfb365c7ab1e041" translate="yes" xml:space="preserve">
          <source>JavaBeans are Java classes which adhere to an extremely simple coding convention.
All you have to do is to</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBeans는 매우 간단한 코딩 규칙을 준수하는 Java 클래스입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 할 일은&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7dd0769a4baaeaa8daf9f73ba76d158326390750" translate="yes" xml:space="preserve">
          <source>Just a little background/update on the bean concept.  Many other answers actually have the what but not so much why of them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빈 개념에 대한 약간의 배경 / 업데이트. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 많은 답변들은 실제로 그 이유는 있지만 그다지 많은 이유는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8ca55e89ecf957dc3d18dfbff29aa4a8720073f" translate="yes" xml:space="preserve">
          <source>Now I see beans as annotated property balls--they are really only useful for the annotations they carry.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 콩을 주석이 달린 속성 볼로 간주합니다. 실제로 주석이 달린 주석에만 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2016e213092c8c9b4efbe0ab01ea7bfea7548ff" translate="yes" xml:space="preserve">
          <source>Of course, in order to do that, the class has to abide by certain limitations.  Chief among them is that all instance fields must be either primitive types (int, bool, etc), instances of some class that is also serializable, or marked as &lt;code&gt;transient&lt;/code&gt; so that Java won't try to include them.  (This of course means that &lt;code&gt;transient&lt;/code&gt; fields will not survive the trip over a stream.  A class that has &lt;code&gt;transient&lt;/code&gt; fields should be prepared to reinitialize them if necessary.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 그렇게하기 위해서는 클래스는 특정 제한 사항을 준수해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그중에서도 모든 인스턴스 필드는 기본 유형 (int, bool 등)이거나 직렬화 가능한 일부 클래스의 인스턴스이거나 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java로 포함시키지 않도록 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;transient&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 표시 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(이 있음을 물론 수단의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;transient&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드가있는 스트림입니다. 클래스를 통해 여행 살아남지 못할 것이다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;transient&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드를 필요한 경우를 다시 초기화 할 준비를해야한다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c28b70c958ab8c8fca656187c98e4e3b35de03d2" translate="yes" xml:space="preserve">
          <source>Once the bean is instantiated, the Java Bean API ( java.beans.*) can introspect it and call methods on it.  If no class implementing the interface BeanInfo or extending a BeanInfo implementation , SimpleBeanInfo class, is available, the introspection involves using reflection (implicit introspection)  to study the methods supported by a target bean and then apply simple design patterns(the guidelines) to deduce from those methods what properties, events, and public methods are supported. If a class implementing the interface BeanInfo (for a bean Foo, it must be named FooBeanInfo) is available, the API bypasses implicit introspection and uses public methods (getPropertyDescriptor(), getMethodDescriptors(), getEventSetDescriptors() ) of this class to get the information. If a class extending SimpleBeanInfo is available, depending on which of the SimpleBeanInfo public methods (getPropertyDescriptor(), getMethodDescriptors(), getEventSetDescriptors() )  are overridden, it will use those overridden methods(s) to get information; for a method that is not overridden, it&amp;rsquo;ll  default to the corresponding implicit introspection. A bean needs to be instantiated anyway even if no implicit introspection is carried on it. Thus, the requirement  of a public zeri-args constructor. But, of course, the Serializable or Externalizable interface isn&amp;rsquo;t necessary for it to be recognized. However the Java Bean specification says, &amp;lsquo;We&amp;rsquo;d also like it to be &amp;ldquo;trivial&amp;rdquo; for the common case of a tiny Bean that simply wants to have its internal state saved and doesn&amp;rsquo;t want to think about it.&amp;rsquo; So, all beans must implement Serializable or Externalizable interface. 
Overall, JavaBeans specification isn&amp;rsquo;t hard and fast about what constitutes a bean. &quot;Writing JavaBeans components is surprisingly easy. You don't need a special tool and you don't have to implement any interfaces. Writing beans is simply a matter of following certain coding conventions. All you have to do is make your class look like a bean &amp;mdash; tools that use beans will be able to recognize and use your bean.&quot; Trivially, even the following class is a Java Bean,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bean이 인스턴스화되면 Java Bean API (java.beans. *)가이를 조사하고 메소드를 호출 할 수 있습니다. BeanInfo 인터페이스를 구현하거나 BeanInfo 구현 인 SimpleBeanInfo 클래스를 확장하는 클래스가없는 경우, 내부 검사에는 리플렉션 (암시 적 내부 검사)을 사용하여 대상 Bean이 지원하는 메소드를 연구 한 후 간단한 설계 패턴 (지침)을 적용하여 추론 할 수 있습니다. 속성, 이벤트 및 공용 메서드가 지원되는 메서드 BeanInfo 인터페이스 (Bean Foo의 경우 FooBeanInfo로 이름 지정되어야 함)를 구현하는 클래스를 사용할 수있는 경우, API는 내재적 인내성을 무시하고이 클래스의 공용 메소드 (getPropertyDescriptor (), getMethodDescriptors (), getEventSetDescriptors ())를 사용하여 정보. SimpleBeanInfo를 확장하는 클래스가 사용 가능한 경우재정의 된 SimpleBeanInfo 공용 메소드 (getPropertyDescriptor (), getMethodDescriptors (), getEventSetDescriptors ())에 따라 대체 된 메소드를 사용하여 정보를 가져옵니다. 재정의되지 않은 메서드의 경우 해당 암시 적 내부 검사로 기본 설정됩니다. 암묵적인 내부 검사가 수행되지 않더라도 빈은 인스턴스화되어야합니다. 따라서 공개 zeri-args 생성자의 요구 사항입니다. 그러나 Serializable 또는 Externalizable 인터페이스는 인식하기 위해 필요하지 않습니다. 그러나 Java Bean 사양에 따르면 &quot;내부 상태를 저장하고 생각하지 않는 작은 Bean의 일반적인 경우에는&quot;사소한 것 &quot;이되기를 바랍니다. 따라서 모든 Bean은 Serializable 또는 Externalizable 인터페이스를 구현해야합니다. 사무용 겉옷,JavaBeans 사양은 Bean을 구성하는 요소에 대해 어렵고 빠르지 않습니다. &quot;JavaBeans 컴포넌트 작성은 놀라 울 정도로 쉽습니다. 특별한 도구가 필요하지 않으며 인터페이스를 구현할 필요가 없습니다. Bean 작성은 단순히 특정 코딩 규칙을 따르는 문제입니다. 클래스를 다음과 같이 작성하면됩니다. 콩 &amp;mdash; 콩을 사용하는 도구는 콩을 인식하고 사용할 수 있습니다. &quot; 사소하게, 다음 클래스조차 Java Bean입니다.당신이해야 할 일은 당신의 클래스를 빈처럼 보이게하는 것입니다. &amp;ndash; 빈을 사용하는 도구는 당신의 빈을 인식하고 사용할 수 있습니다. &quot;당신이해야 할 일은 당신의 클래스를 빈처럼 보이게하는 것입니다. &amp;ndash; 빈을 사용하는 도구는 당신의 빈을 인식하고 사용할 수 있습니다. &quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9963e8cb9651e24589c69ac1ab2d725e8e221120" translate="yes" xml:space="preserve">
          <source>Over time these became useful for lots of tools that used the same type of access (For example, Hibernate to persist data structures to the database)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간이 지남에 따라 동일한 유형의 액세스를 사용하는 많은 도구에 유용하게되었습니다 (예 : 데이터베이스에 데이터 구조를 유지하기 위해 최대 절전 모드).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb890b8d14da97d7c84a98d91240a6bfdc92eacd" translate="yes" xml:space="preserve">
          <source>Properties of JavaBeans</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바 빈즈의 속성&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c86ab952e1e5a0cb1746da17f6a42c5991b338f4" translate="yes" xml:space="preserve">
          <source>Regarding the second part of your question, Serialization is a persistence mechanism used to store objects as a sequence of signed bytes. Put less formally, it stores the state of an object so you can retrieve it later, by de-serialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;질문의 두 번째 부분과 관련하여 직렬화는 객체를 부호있는 바이트 시퀀스로 저장하는 데 사용되는 지속성 메커니즘입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;덜 공식적으로 말하면 객체의 상태를 저장하므로 나중에 직렬화 해제를 통해 객체를 검색 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be330141ddb636e10697456283aaa177c791ee47" translate="yes" xml:space="preserve">
          <source>Say, a bean constructor has some parameters. Suppose some are simple types. The container might not know what values to assign to them; even if it does, the resulting instance might not be reusable. It may make sense only if the user can configure (specify values) by say annotations or xml configuration files as in Spring beans. And suppose some parameters are class or interface types.  Again, the container might not know what values to assign to it. It may make sense only if the user can configure (specify specific objects) by say annotations or xml configuration files. However, even in Spring (via xml configuration files), assigning specific objects (with string names) to constructor arguments (  attribute or  element of constructor arguments)is not typesafe;it is basically like resource injection.  Making references to other Spring beans(called collaborators; via  element in a constructor argument element) is basically dependency injection and thus typesafe.  Obviously, a dependency(collaborator bean) might have a constructor with injected parameters; those injected dependency(ies) might have a constructor with parameters and so on. In this scenario, ultimately, you would need some bean classes (e.g, MyBean.class) that the container can instantiate by simply calling new MyBean() before it can construct the other collaborating beans via dependency injection on constructors&amp;mdash;thus, the requirement for the beans to have public zero-args constructor.  Suppose, if a container doesn&amp;rsquo;t support dependency injection and/or doesn&amp;rsquo;t allow assigning simple-type values to constructor via some annotations or xml config files as in Spring, bean constructors shouldn&amp;rsquo;t have parameters. Even a Spring beans application would need some beans to have public zero-args constructor (e.g., in a scenario where your Spring application has no bean with just simple types as constructor arguments).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빈 생성자에는 몇 가지 매개 변수가 있습니다. 일부가 간단한 유형이라고 가정하십시오. 컨테이너는 할당 할 값을 모를 수 있습니다. 그렇게하더라도 결과 인스턴스는 재사용 할 수 없습니다. 사용자가 Spring Bean에서와 같이 주석 또는 XML 구성 파일로 구성 (값 지정) 할 수있는 경우에만 의미가 있습니다. 그리고 일부 매개 변수가 클래스 또는 인터페이스 유형이라고 가정하십시오. 다시, 컨테이너는 어떤 값을 할당할지 알지 못할 수 있습니다. 사용자가 주석 또는 XML 구성 파일로 구성 (특정 객체 지정) 할 수있는 경우에만 의미가 있습니다. 그러나 XML (XML 구성 파일을 통해) 에서조차도 특정 객체 (문자열 이름 포함)를 생성자 인수 (생성자 인수의 속성 또는 요소)에 할당하는 것은 유형 안전하지 않습니다. 기본적으로 리소스 주입과 같습니다.다른 Spring bean (생성자 인자 element의 element를 통해)이라고하는 다른 Spring bean에 대한 참조는 기본적으로 의존성 주입이므로 타입 안전합니다. 분명히, 의존성 (collaborator bean)에는 매개 변수가 삽입 된 생성자가있을 수 있습니다. 주입 된 의존성에는 매개 변수 등이있는 생성자가있을 수 있습니다. 이 시나리오에서는 궁극적으로 생성자에 대한 의존성 주입을 통해 다른 협업 Bean을 생성하기 전에 단순히 새로운 MyBean ()을 호출하여 컨테이너가 인스턴스화 할 수있는 Bean 클래스 (예 : MyBean.class)가 필요합니다. public zero-args 생성자를 갖는 Bean 컨테이너가 의존성 주입을 지원하지 않거나 Spring에서와 같이 일부 주석 또는 xml 구성 파일을 통해 간단한 유형 값을 생성자에 할당하도록 허용하지 않는 경우,bean 생성자에는 매개 변수가 없어야합니다. Spring Bean 애플리케이션조차도 public zero-args 생성자를 갖기 위해 일부 bean이 필요할 것입니다 (예 : Spring 애플리케이션에 단순한 유형의 생성자 인수가있는 Bean이없는 시나리오의 경우).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="065bce9fb10afa66f81a4ac0b8666f0864171dc6" translate="yes" xml:space="preserve">
          <source>Serializability of a class is enabled by the class implementing the
  java.io.Serializable interface. Classes that do not implement this
  interface will not have any of their state serialized or deserialized.
  All subtypes of a serializable class are themselves serializable. The
  serialization interface has no methods or fields and serves only to
  identify the semantics of being serializable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스의 직렬화 기능은 java.io.Serializable 인터페이스를 구현하는 클래스에 의해 가능합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 인터페이스를 구현하지 않는 클래스는 직렬화 또는 직렬화 해제 된 상태가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 가능 클래스의 모든 하위 유형은 직렬화 가능합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 인터페이스에는 메소드 또는 필드가 없으며 직렬화 가능의 의미를 식별하는 역할 만합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dc15525a7ed769a14cceef22b82b8173524795b" translate="yes" xml:space="preserve">
          <source>So in fact, Beans are &lt;strong&gt;just a convention / standard&lt;/strong&gt; to expect something from a Java object that it would behave (serialization) and give some ways to change it (setters for properties) in a certain way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 Beans는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 객체에서 동작 (일련 화)하고 특정 방식으로 변경 (속성 설정) 할 수있는 방법을 제공 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 규칙 / 표준 일뿐&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e2e8124fa6c1fd0049dfa058db0f51fa2420434" translate="yes" xml:space="preserve">
          <source>Spring uses Beans for objects to handle (for instance, User object that needs to be serialized in session)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring은 처리 할 객체에 Bean을 사용합니다 (예 : 세션에서 직렬화해야하는 User 객체).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acdab3c6cbd01dc85b9cc89f692b8d479cfab4a9" translate="yes" xml:space="preserve">
          <source>That's it. It's just a convention.  Lots of libraries depend on it though.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그게 다야. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컨벤션 일뿐입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 라이브러리가 그것에 의존합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16a7de9c763ff0935eb2a7212c9861a8549432e1" translate="yes" xml:space="preserve">
          <source>The JavaBean class must have a no-arg constructor</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean 클래스에는 인수가없는 생성자가 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f0d6b363ae0861665ac6aa95f25dd72a744da04" translate="yes" xml:space="preserve">
          <source>The JavaBean class must implement either &lt;code&gt;Serializable&lt;/code&gt; or
&lt;code&gt;Externalizable&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean 클래스는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt; &lt;code&gt;Externalizable&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구현해야합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="813f50b564fdc9a27b83a1135aa3919c3b1ba21a" translate="yes" xml:space="preserve">
          <source>The class must have a public default constructor (with no arguments). This allows easy instantiation within editing and activation frameworks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스에는 공개 기본 생성자가 있어야합니다 (인수 없음). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 통해 편집 및 활성화 프레임 워크 내에서 쉽게 인스턴스화 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cde4c7e4fad81c80d24677c7d920b4e55b94a0bf" translate="yes" xml:space="preserve">
          <source>The class properties must be accessible using get, set, is (can be used for boolean properties instead of get), and other methods (so-called accessor methods and mutator methods) according to a standard naming convention. This allows easy automated inspection and updating of bean state within frameworks, many of which include custom editors for various types of properties. Setters can have one or more than one argument.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 속성은 get, set, is (get 대신 부울 속성에 사용할 수 있음) 및 표준 명명 규칙에 따라 다른 메서드 (소위 접근 자 메서드 및 변경자 메서드)를 사용하여 액세스 할 수 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 통해 프레임 워크 내에서 빈 상태를 쉽게 자동으로 검사하고 업데이트 할 수 있으며, 여기에는 다양한 유형의 특성에 대한 사용자 정의 편집기가 포함됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세터는 하나 이상의 인수를 가질 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dac5c199f9057ffe657f76a192e02e00e6e747e0" translate="yes" xml:space="preserve">
          <source>The class should be serializable. [This allows applications and frameworks to reliably save, store, and restore the bean's state in a manner independent of the VM and of the platform.]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스는 직렬화 가능해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[이것은 애플리케이션 및 프레임 워크가 VM 및 플랫폼과 독립적 인 방식으로 Bean의 상태를 안정적으로 저장, 저장 및 복원 할 수있게합니다.]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24b7978ed25dd8181961b7ef0846a5307e0e4c37" translate="yes" xml:space="preserve">
          <source>The constructor should be public and have no arguments (What other people call it a no-arg constructor).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자는 공용이어야하고 인수가 없어야합니다 (다른 사람들은이를 인수없는 생성자라고 부릅니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37cf012b64e5f8d8acdc1fb76f92437ad78d65a2" translate="yes" xml:space="preserve">
          <source>The objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. 
&lt;code&gt;according to&lt;/code&gt;&lt;a href=&quot;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/beans.html&quot;&gt;spring io&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;애플리케이션의 백본을 형성하고 Spring IoC 컨테이너에 의해 관리되는 객체를 Bean이라고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bean은 Spring IoC 컨테이너에 의해 인스턴스화, 조립 및 관리되는 객체입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않으면, Bean은 단순히 응용 프로그램의 많은 오브젝트 중 하나입니다. &lt;/font&gt;&lt;a href=&quot;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/beans.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;봄 io &lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;according to&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="790f9becf38ff05a64a89e433ffc86abae1ec6c4" translate="yes" xml:space="preserve">
          <source>There is a term for it because the standard allows libraries to programmatically do things with class instances you define in a predefined way. For example, if a library wants to stream any object you pass into it, it knows it can because your object is serializable (assuming the lib requires your objects be proper JavaBeans).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표준은 라이브러리가 미리 정의 된 방식으로 정의한 클래스 인스턴스를 사용하여 프로그래밍 방식으로 작업을 수행 할 수 있도록 허용하기 때문에 용어가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 라이브러리가 전달한 객체를 스트리밍하려는 경우 라이브러리가 객체를 직렬화 할 수 있기 때문에 라이브러리가 가능하다는 것을 알고 있습니다 (lib는 객체가 올바른 JavaBeans 여야한다고 가정).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46a20fd7d231d2db0bd411c2f826d528fc46ee0f" translate="yes" xml:space="preserve">
          <source>There's a term for it to make it sound special.  The reality is nowhere near so mysterious.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 특별하게 들리게하는 용어가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;현실은 그렇게 신비로운 곳은 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="020c0aed9294d862e05a39597fe06961a0a4f8fa" translate="yes" xml:space="preserve">
          <source>They are serializable, have a zero-argument constructor, and allow access to properties using getter and setter methods. The name &quot;Bean&quot; was given to encompass this standard, which aims to create reusable software components for Java.&lt;code&gt;according to&lt;/code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaBeans&quot;&gt;wiki&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것들은 직렬화 가능하고 인수가없는 생성자를 가지며 getter 및 setter 메소드를 사용하여 특성에 액세스 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Bean&quot;이라는 이름은이 표준을 포함하도록 주어졌으며, 이는 Java 용 재사용 가능한 소프트웨어 구성 요소를 작성하는 것을 목표로합니다. &lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaBeans&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위키 &lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;according to&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c0cb01b1ab0d58a1065e68c28978974af6fbed1" translate="yes" xml:space="preserve">
          <source>They were invented early on in Java as part of building GUIs.  They followed patterns that were easy for tools to pull apart letting them create a properties panel so you could edit the attributes of the Bean.  In general, the Bean properties represented a control on the screen (Think x,y,width,height,text,..)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이들은 GUI 구축의 일부로 Java에서 초기에 발명되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이들은 도구가 쉽게 분리 할 수있는 패턴을 따랐기 때문에 Bean의 속성을 편집 할 수 있도록 특성 패널을 작성할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 Bean 속성은 화면의 컨트롤을 나타냅니다 (x, y, width, height, text, ..)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="475b689ed4ac32075ffabd646b337f9971c60951" translate="yes" xml:space="preserve">
          <source>To understand JavaBean you need to notice the followings:
JavaBean is a conceptual stuff and can not represent a class of specific things</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean을 이해하려면 다음 사항에주의해야합니다. JavaBean은 개념적인 것이므로 특정 것의 클래스를 나타낼 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3d908b24c52a9088e9615d60b068586c3fa4c64a" translate="yes" xml:space="preserve">
          <source>Unlike Spring beans it doesn&amp;rsquo;t support constructors with simple-types, which might be possible if it supported configuration with xml config files like in Spring or any annotations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring bean과 달리 단순 유형의 생성자를 지원하지 않습니다. Spring 또는 주석과 같은 xml 구성 파일을 사용하여 구성을 지원 한 경우 가능할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="d9c47d9c856a0455d2cf64866993e2892263d895" translate="yes" xml:space="preserve">
          <source>What is a JavaBean exactly</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBean이란 무엇입니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93cf2f27c84573f1e71e679859e50bd288bcc2a9" translate="yes" xml:space="preserve">
          <source>With respect to &lt;code&gt;Serializable&lt;/code&gt;, from the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;API documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;API 문서&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 관련하여 다음 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을 수행하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0afa35ff0cd8074a8bb16973d77094139f5c4984" translate="yes" xml:space="preserve">
          <source>You can also think of it as a strongly typed data structure.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 강력한 형식의 데이터 구조로 생각할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5eb12b688111ab8c5889f2bb69b9289d6804606a" translate="yes" xml:space="preserve">
          <source>You will find Serialization useful when deploying your project across multiple servers since beans will be persisted and transferred across them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bean이 지속되어 서버간에 전송되므로 여러 서버에 프로젝트를 배치 할 때 직렬화가 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d96a33bf833bec64d9ae971cf31f2d5ca8f212a" translate="yes" xml:space="preserve">
          <source>has &quot;properties&quot; whose getters and setters are just methods with certain names (like, say, &lt;code&gt;getFoo()&lt;/code&gt; is the getter for the &quot;Foo&quot; property), and</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter와 setter가 특정 이름을 가진 메소드 인 &quot;properties&quot;를 가지고 있습니다 (예 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getFoo()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &quot;Foo&quot;속성의 getter입니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e13b280ea2f8522453f7c556f614cc47244dcb1" translate="yes" xml:space="preserve">
          <source>has a public 0-arg constructor (so it can be created at will and configured by setting its properties).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;public 0-arg 생성자를가집니다 (따라서 자유롭게 생성하고 속성을 설정하여 구성 할 수 있음).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b500312c107ed051b5075a6bc7a0afcf73b6caa" translate="yes" xml:space="preserve">
          <source>if it is defined to be a managed bean by any
other Java EE specification and if</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 Java EE 스펙에 의해 관리 Bean으로 정의 된 경우&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ecce28b81c9eb791b949024e3d37b66a88b3f2c" translate="yes" xml:space="preserve">
          <source>implement &lt;code&gt;java.io.Serializable&lt;/code&gt; interface - to save the state of an
object</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인터페이스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-객체 상태 저장&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03c80a053a0c7279c874b2c9a156a9afa786dd3a" translate="yes" xml:space="preserve">
          <source>is a serializable object (that is, it implements &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;code&gt;java.io.Serializable&lt;/code&gt;&lt;/a&gt;, and does so correctly), that</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 가능한 객체입니다 (즉, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구현 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 올바르게 수행합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b8b1b88700cece3204b5fd605a8ce1ed12e0b91" translate="yes" xml:space="preserve">
          <source>provide public getter/setter methods -  to get and set the values of private variables (properties ).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공개 getter / setter 메소드 제공-개인 변수 (properties)의 값을 가져오고 설정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc7bf56d06d60fbcd9f3fd370b65b021682810fc" translate="yes" xml:space="preserve">
          <source>simple reusable objects POJO (Plain Old Java Objects)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재사용이 가능한 간단한 객체 POJO (Plain Old Java Objects)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa75676b8043c71cc6532ad5aa3150ba355867c7" translate="yes" xml:space="preserve">
          <source>use a public empty argument constructor - to instantiate the object</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공개 빈 인수 생성자를 사용하여 객체를 인스턴스화하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5fccda843ae48daffcada380e31f65f4d96f042a" translate="yes" xml:space="preserve">
          <source>visual objects</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시각적 개체&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
