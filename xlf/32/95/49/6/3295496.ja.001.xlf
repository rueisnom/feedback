<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3295496">
    <body>
      <group id="3295496">
        <trans-unit id="0c720cf1be2b9537b354e91f7a3787de5331d609" translate="yes" xml:space="preserve">
          <source>&amp;bull; It is not an inner class.
&amp;bull; It is a non-abstract class, or is annotated @Decorator.
&amp;bull; It does not implement javax.enterprise.inject.spi.Extension.
&amp;bull; It is not annotated @Vetoed or in a package annotated @Vetoed.
&amp;bull; It has an appropriate constructor, either: the class has a constructor with    no parameters, or the class declares a constructor annotated @Inject.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull;内部クラスではありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull;非抽象クラスであるか、@ Decoratorアノテーションが付けられています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull;javax.enterprise.inject.spi.Extensionを実装していません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull;@Vetoedと注釈されていないか、@ Vetoedと注釈されたパッケージ内にあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull;適切なコンストラクターがある。クラスにパラメーターのないコンストラクターがあるか、クラスが@Injectアノテーションが付けられたコンストラクターを宣言している。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="318e496067fd62a66317acc990767262643a180e" translate="yes" xml:space="preserve">
          <source>&amp;bull; It is not annotated with an EJB component-defining annotation or declared as an EJB bean class
in ejb-jar.xml.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;bull;EJBコンポーネントを定義するアノテーションが付いていない、またはejb-jar.xmlでEJB Beanクラスとして宣言されていない。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fe65bf0c3eacef06df91fc4cf361d736a8084b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=365&quot;&gt;The CDI specification&lt;/a&gt; re-defines managed beans as:
When running in Java EE, A top-level Java class is a managed bean if it meets requirements:</source>
          <target state="translated">&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=365&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CDI仕様&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;では、マネージドBeanを次のように再定義しています。JavaEEで実行する場合、要件を満たす場合、トップレベルのJavaクラスはマネージドBeanです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38ed6cbe8aed300abef020fdadb5bcde73fee055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. import java.io.Serializable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1. java.io.Serializableをインポートする&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a49ecf03c903cc3a6f83326b48867007e08a740a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. private fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2.プライベートフィールド&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a758db005e282d406bf62f2118dfdb233ae8c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3.コンストラクタ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="872f893a46991a54114d46bdfdef55453c8b29cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. getter/setter&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4.ゲッター/セッター&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a26334708d80ce05d587475829e9fc057f2497ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typical uses of Beans in real world:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実世界でのBeanの一般的な使用法：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d918238982e54950b68a3c920d828b0c968d423" translate="yes" xml:space="preserve">
          <source>A Java Bean is a java class [conceptual] that should follow following conventions:</source>
          <target state="translated">Java Beanは,以下の規約に従うべきJavaクラス[概念]である。</target>
        </trans-unit>
        <trans-unit id="136fc13f09b8c954f8e4f0e3eaa8c82c441d505e" translate="yes" xml:space="preserve">
          <source>A Java Bean is essentially a class, what classifies a class as a bean is:</source>
          <target state="translated">Java Beanは基本的にクラスであり、何がクラスをBeanとして分類しているのか。</target>
        </trans-unit>
        <trans-unit id="2df1ae47eb0577a2972cbb68c03f1736120b653a" translate="yes" xml:space="preserve">
          <source>A JavaBean is a Java object that satisfies certain programming conventions:</source>
          <target state="translated">JavaBeanは、特定のプログラミング規約を満たすJavaオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="943d73a0fc0f89137bcf6abba6ddd867beb03874" translate="yes" xml:space="preserve">
          <source>A JavaBean is just a &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html&quot;&gt;standard&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBeanは単なる&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;標準です&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f7f11c17e1ad6e05c056d7c1b5b633cdfb32a50" translate="yes" xml:space="preserve">
          <source>A bean &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;is&lt;/a&gt; a Java class with method names that follow the Java Bean guidelines (also called design patterns) for &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;properties&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/methods.html&quot;&gt;methods&lt;/a&gt;, and &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/events.html&quot;&gt;events&lt;/a&gt; . Thus, any public method of the bean class that is not part of a property definition is a bean method. Minimally, a Java class even with either a property as the sole member (of course, accompanying public getter and setter required), a public method as the sole member or just one public event listener registration method is a Java bean. Furthermore, the property can either be read-only property (has a getter method but no setter) or write-only property (has a setter method only). The Java bean needs to be a public class to be visible to any beanbox tool or container. The container must be able to instantiate it; thus, it must have a public constructor too. The &lt;a href=&quot;https://www.oracle.com/technetwork/articles/javaee/spec-136004.html&quot;&gt;JavaBeans specification&lt;/a&gt; doesn&amp;rsquo;t  require a bean to have a public zero-args constructor, explicit or default, for a container to instantiate it. If you could provide a file (with extension .ser) containing a serialized instance, a beanbox tool could use that file to instantiate a prototype bean. Otherwise, the bean must have a public zero-args constructor, either explicit or default.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bean &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プロパティ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/methods.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、および&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/writing/events.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;イベント&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のJava Beanガイドライン（デザインパターンとも呼ばれる）に準拠したメソッド名を持つJavaクラスです&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。したがって、プロパティ定義の一部ではないBeanクラスのパブリックメソッドはすべてBeanメソッドです。最低でも、プロパティを唯一のメンバーとして持つJavaクラス（もちろん、必要なパブリックゲッターとセッターが必要です）、唯一のメンバーとしてのパブリックメソッド、または1つのパブリックイベントリスナー登録メソッドだけがJava Beanです。さらに、このプロパティは、読み取り専用プロパティ（getterメソッドはあるが、setterはない）または書き込み専用プロパティ（setterメソッドのみを持つ）のいずれかになります。 Java Beanは、任意のBeanboxツールまたはコンテナから見えるようにパブリッククラスである必要があります。コンテナはそれをインスタンス化できなければなりません。したがって、パブリックコンストラクタも必要です。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/articles/javaee/spec-136004.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBeans仕様&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンテナがインスタンス化するために、Beanに明示的またはデフォルトのパブリックなゼロ引数コンストラクターが必要ではありません。シリアル化されたインスタンスを含むファイル（拡張子.ser）を提供できる場合、Beanboxツールはそのファイルを使用してプロトタイプBeanをインスタンス化できます。それ以外の場合、Beanには、明示的またはデフォルトのパブリック引数なしのコンストラクターが必要です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="840c31e8b502d6a3ccab76ae17bb2028d031a853" translate="yes" xml:space="preserve">
          <source>A class that can not abide by those limitations should not implement &lt;code&gt;Serializable&lt;/code&gt; (and, IIRC, the Java compiler won't even &lt;em&gt;let&lt;/em&gt; it do so.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらの制限を遵守することはできませんクラスが実装してはならない&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（および、IIRCを、Javaコンパイラでもないだろう&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しましょう&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、それはそう。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9747d0a45d4adc924ab9127cfa96048b5c2663b0" translate="yes" xml:space="preserve">
          <source>A public &lt;a href=&quot;http://en.wikipedia.org/wiki/Nullary_constructor&quot;&gt;no-argument constructor&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Nullary_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引数なし&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のパブリック&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンストラクタ&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b87bd7deae485bab9140383355afab0efe2f97c" translate="yes" xml:space="preserve">
          <source>A public constructor without any argument.</source>
          <target state="translated">引数を持たないパブリックコンストラクタ。</target>
        </trans-unit>
        <trans-unit id="e68b27213f4f51dde87904a41d77b1a46d4e5820" translate="yes" xml:space="preserve">
          <source>About Serialization:</source>
          <target state="translated">連載について。</target>
        </trans-unit>
        <trans-unit id="d70cdc7ecce4b58b0bf4d276d3442a5efd9554f2" translate="yes" xml:space="preserve">
          <source>After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.</source>
          <target state="translated">直列化されたオブジェクトをファイルに書き込んだ後、ファイルから読み込んでデシリアライズ、つまりオブジェクトを表す型情報やバイトとそのデータを使ってメモリ上にオブジェクトを再作成することができます。</target>
        </trans-unit>
        <trans-unit id="bc7d5f7f6aa1b17a4491e1a08b0ff9891e56d860" translate="yes" xml:space="preserve">
          <source>All Java classes that meet these conditions are managed beans and thus no special declaration is
required to define a managed bean. &lt;strong&gt;Or&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらの条件を満たすすべてのJavaクラスは管理Beanであるため、管理Beanを定義するために特別な宣言は必要ありません。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ff27e94ce8d1aa5a258d0c287f6edd1ae9139cc" translate="yes" xml:space="preserve">
          <source>All JavaBean instance variables should be private</source>
          <target state="translated">すべてのJavaBeanインスタンス変数はプライベートでなければなりません。</target>
        </trans-unit>
        <trans-unit id="46a62eae4314ebe2f79eb24fb004f645071fe3cc" translate="yes" xml:space="preserve">
          <source>All JavaBean properties must have public setter and getter methods</source>
          <target state="translated">すべてのJavaBeanプロパティは、パブリック・セッターとゲッター・メソッドを持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="583c6f767c8fbd15748949b1c4e7cc8e91812e00" translate="yes" xml:space="preserve">
          <source>All properties private (use &lt;a href=&quot;http://en.wikipedia.org/wiki/Mutator_method&quot;&gt;getters/setters&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのプロパティはプライベート（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mutator_method&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッター/セッターを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4c99079d28d0aa72365f1b4f85a989bd3a2434e" translate="yes" xml:space="preserve">
          <source>Also what does the &lt;code&gt;Serializable&lt;/code&gt; interface mean?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インターフェイスはどういう意味ですか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6a19841937b5de90672f912f7b8de17a63df1abc" translate="yes" xml:space="preserve">
          <source>Also, is there a real &lt;em&gt;syntactic&lt;/em&gt; difference between a bean and a regular class? Is there any special definition or an interface?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Beanと通常のクラスの間に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際の&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;構文の&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;違い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はあり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ますか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特別な定義やインターフェースはありますか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fbcd1a65323b37839ca533fa3b075c3ddc7b5ef" translate="yes" xml:space="preserve">
          <source>Also, there is no syntactic difference between a JavaBean and another class -- a class is a JavaBean if it follows the standards.</source>
          <target state="translated">また、JavaBeanと他のクラスの間には構文的な違いはありません。</target>
        </trans-unit>
        <trans-unit id="4afcbba96c1537542cb5c45aa89095555d34b237" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;Serializable&lt;/code&gt;:  That is nothing but a &quot;marker interface&quot; (an interface that doesn't declare any functions) that tells Java that the implementing class consents to (and implies that it is capable of) &quot;serialization&quot; -- a process that converts an instance into a stream of bytes.  Those bytes can be stored in files, sent over a network connection, etc, and have enough info to allow a JVM (at least, one that knows about the object's type) to reconstruct the object later -- possibly in a different instance of the application, or even on a whole other machine!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用として&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：それは何もが、Javaを伝える「マーカーインタフェース」（任意の関数を宣言していないインタフェースが）に実装したクラスの同意が「シリアライズ」（と、それが可能であることを意味する）ということではありません-プロセスそのインスタンスをバイトのストリームに変換します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらのバイトは、ファイルに保存したり、ネットワーク接続を介して送信したりすることができ、JVM（少なくとも、オブジェクトのタイプを知っているもの）が後でオブジェクトを再構築できるようにするのに十分な情報があります-おそらく別のインスタンスでアプリケーション、または他のマシン全体でも！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13e8118270c12b1dcfe8b170b320c042cb236f40" translate="yes" xml:space="preserve">
          <source>As for the Serialization, see the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シリアライゼーションについては、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ドキュメントを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca67d9ce952533251528bc96a99a40477e0d80de" translate="yes" xml:space="preserve">
          <source>As per the Wikipedia:</source>
          <target state="translated">ウィキペディアの通り。</target>
        </trans-unit>
        <trans-unit id="6a6aa35f3845de7a4a3ee993dcb66442b8fd4612" translate="yes" xml:space="preserve">
          <source>As the tools evolved, they moved more towards annotations and away from pulling apart the setter/getter names.  Now most systems don't require beans, they can take any plain old java object with annotated properties to tell them how to manipulate them.</source>
          <target state="translated">ツールが進化するにつれ、ツールはアノテーションに向かって移動し、セッターゲッター名を分離することから離れていきました。現在では、ほとんどのシステムではビーンを必要とせず、アノテーションされたプロパティを持つ古いjavaオブジェクトを使用して、それらの操作方法を指示することができます。</target>
        </trans-unit>
        <trans-unit id="0f79e211af28e9fa77cb803b2bfc3232f21e5d6f" translate="yes" xml:space="preserve">
          <source>Basically, a &quot;Bean&quot;:</source>
          <target state="translated">基本的には「豆」です。</target>
        </trans-unit>
        <trans-unit id="77c8cb4cf6d1a687f851297788111874673f9c84" translate="yes" xml:space="preserve">
          <source>Basically, why is there a term for this?</source>
          <target state="translated">基本的には、なぜこのような言葉があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="1c46a4c9432c3f3300b98f5468f7facb82b723f5" translate="yes" xml:space="preserve">
          <source>Beans themselves are not a healthy pattern.  They destroy encapsulation by their nature since they expose all their properties to external manipulation and as they are used there is a tendency (by no means a requirement) to create code to manipulate the bean externally instead of creating code inside the bean (violates &quot;don't ask an object for it's values, ask an object to do something for you&quot;).  Using annotated pojos with minimal getters and no setters is much more OO restoring encapsulation and with the possibility of immutability.</source>
          <target state="translated">ビーン自体は健全なパターンではありません。なぜなら、すべてのプロパティを外部からの操作に晒しているからです。また、ビーンが使われると、ビーンの内部でコードを作成するのではなく、ビーンを外部から操作するためのコードを作成する傾向があります(「オブジェクトに値を求めるな、オブジェクトに何かをしてもらう」に違反します)。最小限のゲッターとセッターを持たないアノテーションされたpojosを使用することは、カプセル化を復元し、不変性の可能性を持つ、より多くのOOOになります。</target>
        </trans-unit>
        <trans-unit id="47dd15199c6b5bc8e4b7ee1df2206d7d5a498067" translate="yes" xml:space="preserve">
          <source>By the way, as all this stuff was happening someone extended the concept to something called Enterprise Java Beans.  These are... different.  and they are complicated enough that many people felt they didn't understand the entire Bean concept and stopped using the term.  This is, I think, why you generally hear beans referred to as POJOs (since every java object is a POJO this is technically OK, but when you hear someone say POJO they are most often thinking about something that follows the bean pattern)</source>
          <target state="translated">ところで、このようなことが起こっている間に、誰かがその概念をエンタープライズJavaビーンと呼ばれるものに拡張しました。これらは...異なるもので、多くの人がBeanの概念全体を理解していないと感じ、この用語の使用を止めてしまうほど複雑です。これは、私が思うに、一般的にPOJOと呼ばれるビーンを聞く理由です(すべてのJavaオブジェクトがPOJOなので、これは技術的には問題ありませんが、誰かがPOJOと言うのを聞くとき、彼らはほとんどの場合、ビーンパターンに従う何かについて考えています)。</target>
        </trans-unit>
        <trans-unit id="b079abf5db9c4f0b675aa9c186b7bd92441d4bd8" translate="yes" xml:space="preserve">
          <source>EJB (Enterprise Java Beans), more complex objects, like JSF Beans (JSF is old quite outdated technology) or JSP Beans</source>
          <target state="translated">EJB (Enterprise Java Beans)、より複雑なオブジェクト、JSF Beans (JSFはかなり時代遅れの古い技術です)やJSP Beansのような。</target>
        </trans-unit>
        <trans-unit id="7446953410d8a1127870a9faa024ad22c3158780" translate="yes" xml:space="preserve">
          <source>EJBs run in an EJB container.  Its &lt;a href=&quot;https://jcp.org/aboutJava/communityprocess/final/jsr345/index.html&quot;&gt;specification&lt;/a&gt; says: &amp;ldquo;A session bean component is a Managed Bean.&quot; &amp;ldquo;The class must have a public constructor that takes no arguments,&amp;rdquo; it says for both session bean and message-driven bean.  Further, it says, &amp;ldquo;The session bean class is not required to implement the SessionBean interface or the Serializable interface.&amp;rdquo; For the same reason as JSF beans, that EJB3 dependency injection is basically resource injection, JSF beans do not support constructors with arguments, that is, via dependency injection.  However, if the EJB container implements CDI, &amp;ldquo; Optionally: The class may have an additional constructor annotated with the Inject annotation, &amp;ldquo; it says for both session bean and message-driven bean because, &amp;ldquo;An EJB packaged into a CDI bean archive and not annotated with javax.enterprise.inject.Vetoed annotation, is considered a CDI-enabled bean.&amp;rdquo;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EJBはEJBコンテナで実行されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jcp.org/aboutJava/communityprocess/final/jsr345/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仕様&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「セッションBeanコンポーネントはマネージドBeanです。」「クラスには、引数を取らないパブリックコンストラクターが必要です」と、セッションBeanとメッセージ駆動型Beanの両方について述べています。さらに、「セッションBeanクラスはSessionBeanインターフェースやSerializableインターフェースを実装する必要はありません。」 JSF Beanと同じ理由で、EJB3の依存性注入は基本的にリソースの注入であるため、JSF Beanは引数を持つコンストラクターをサポートしません。つまり、依存性の注入を介します。ただし、EJBコンテナーがCDIを実装する場合、 Injectアノテーションが付けられた追加のコンストラクター。これは、セッションBeanとメッセージ駆動型Beanの両方を意味します。豆。&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4031d069633ae6036f6bfbdbea649d071e5b38ba" translate="yes" xml:space="preserve">
          <source>Example of JavaBeans</source>
          <target state="translated">JavaBeansの例</target>
        </trans-unit>
        <trans-unit id="ad1f18b813307b3689532f8691c6c325bd135aa7" translate="yes" xml:space="preserve">
          <source>Explanation with an example.</source>
          <target state="translated">例を挙げて説明。</target>
        </trans-unit>
        <trans-unit id="46e8f66328748c5a2f75957e8799c069ad64a0fa" translate="yes" xml:space="preserve">
          <source>Fields should be private for prevent outer classes to easily modify those fields.
Instead of directly accesing to those fields, usuagly getter/setter methods are used.</source>
          <target state="translated">フィールドは外部のクラスが簡単に変更できないように、プライベートなものでなければなりません。これらのフィールドに直接アクセスする代わりに、ゲッターセッターメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="84c6880e63e95c7bded8292f072de4945bf71312" translate="yes" xml:space="preserve">
          <source>For more information follow this &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaBean&quot;&gt;link.&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;詳細については、この&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaBean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リンクをクリックしてください。&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69d0558fac25bebb38553b9bc8c4b9654e4b5344" translate="yes" xml:space="preserve">
          <source>Getter and setter methods for accessing and modifying private fields.</source>
          <target state="translated">プライベート・フィールドにアクセスして変更するためのゲッターおよびセッター・メソッド。</target>
        </trans-unit>
        <trans-unit id="0ac3ddba09730353ccbd893d3c22cd6cefb88ed8" translate="yes" xml:space="preserve">
          <source>Good to note the serialVersionUID field is important for maintaining object state.
Below code qualifies as a bean:</source>
          <target state="translated">serialVersionUIDフィールドは、オブジェクトの状態を維持するために重要であることに注意してください。以下のコードはビーンとして適格です。</target>
        </trans-unit>
        <trans-unit id="fc2a15fb6add8845ca719b9881253fe96b7197b5" translate="yes" xml:space="preserve">
          <source>Here is an extract from the &lt;a href=&quot;https://download.oracle.com/otndocs/jcp/managed_beans-1.0-fr-eval-oth-JSpec/&quot;&gt;Managed Bean specification&lt;/a&gt;
&amp;ldquo; Managed Beans are container-managed objects with minimal requirements,
otherwise known under the acronym &amp;ldquo;POJOs&amp;rdquo; (Plain Old Java Objects)&amp;hellip;they can be seen as a Java EE platform-enhanced version of the JavaBeans component model found on the Java SE platform&amp;hellip;. It won&amp;rsquo;t be missed by the reader that Managed Beans have a precursor in the homonymous facility found in the JavaServer Faces (JSF) technology&amp;hellip;Managed Beans as defined in this specification represent a generalization of those found in JSF; in particular, Managed Beans can be used anywhere in a Java EE application, not just in web modules. For example, in the basic component model, Managed Beans must provide a no-argument constructor, but a specification that builds on Managed Beans, such as CDI (JSR-299), can relax that requirement and allow Managed Beans to provide constructors with more complex signatures, as long as they follow some well-defined rules...A Managed Bean must not be: a final class, an abstract class, a non-static inner class. A Managed Bean may not be serializable unlike a regular JavaBean component.&amp;rdquo;
Thus, the specification for Managed Beans, otherwise known as POJOs or POJO beans, allows extension as in CDI.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、&lt;/font&gt;&lt;a href=&quot;https://download.oracle.com/otndocs/jcp/managed_beans-1.0-fr-eval-oth-JSpec/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;マネージドBean仕様&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;からの抜粋です。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 「マネージドBeanは、最小限の要件を持つコンテナ管理オブジェクトであり、頭字語「POJOs」（Plain Old Java Objects）で知られています...これらは、Java SEプラットフォームで見られるJava BeansコンポーネントモデルのJava EEプラットフォーム拡張バージョンと見なすことができます。 &amp;hellip;。マネージドBeanがJavaServer Faces（JSF）テクノロジーにある同名機能の前身であるという読者には見逃されません。この仕様で定義されているマネージドBeanは、JSFにあるものの一般化を表しています。特に、マネージドBeanは、Webモジュールだけでなく、Java EEアプリケーションのどこでも使用できます。たとえば、基本コンポーネントモデルでは、マネージドBeanは引数なしのコンストラクタを提供する必要がありますが、CDI（JSR-299）などのマネージドBeanに基づいて構築される仕様です。明確に定義されたルールに従っている限り、その要件を緩和し、マネージドBeanがより複雑なシグネチャをコンストラクタに提供できるようにします...マネージドBeanは、最終クラス、抽象クラス、非静的内部クラスであってはなりません。 。マネージドBeanは、通常のJavaBeanコンポーネントとは異なり、シリアル化できない場合があります。」したがって、マネージドBean（POJOまたはPOJO Beanとも呼ばれます）の仕様では、CDIと同様に拡張が可能です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="217401a02b941df9e7269aa8987d0dc791e3faac" translate="yes" xml:space="preserve">
          <source>How to use them, is just your invention, but most common cases I enlisted above.</source>
          <target state="translated">どのようにそれらを使用する方法は、単にあなたの発明ですが、私は上記に参加した最も一般的なケース。</target>
        </trans-unit>
        <trans-unit id="132f01fd38954ec747060bf12719260879342b93" translate="yes" xml:space="preserve">
          <source>However, IMO, it is more than a simple syntax standard. The real meaning or intended usage of Java Beans is, together with various tool supports around the standard,  to facilitate code reuse and component-based software engineering, i.e. enable developers to build applications by assembling existing components (classes) and without having to write any code (or only have to write a little glue code). Unfortunately this technology is way under-estimated and under-utilized by the industry, which can be told from the answers in this thread.</source>
          <target state="translated">しかし、IMOでは、Java Beansは単純な構文標準以上のものです。Java Beansの本当の意味や意図された使い方は、標準規格の周りにある様々なツールサポートと共に、コードの再利用やコンポーネントベースのソフトウェアエンジニアリングを促進すること、つまり、開発者が既存のコンポーネント(クラス)を組み立てることで、コードを書かなくてもアプリケーションを構築できるようにすることです(あるいは、少しの接着剤コードを書く必要があるだけです)。残念ながら、この技術は業界では過小評価されており、十分に活用されていません。</target>
        </trans-unit>
        <trans-unit id="0f7b5bf6e1eb2b8c5d9e495927c3f26777a4f3d9" translate="yes" xml:space="preserve">
          <source>I understood, I think, that a &quot;Bean&quot; is a Java class with properties and getters/setters. As much as I understand, it is the equivalent of a C struct. Is that true?</source>
          <target state="translated">私が理解していたのは、「Bean」はプロパティとゲッターセッターを持つJavaクラスだということだと思います。私が理解している範囲では、Cの構造体に相当します。というのは本当なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="5a4de59b80377dafe9abca055f20cd53f95c3b3f" translate="yes" xml:space="preserve">
          <source>If you read Oracle's &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/index.html&quot;&gt;tutorial on Java Beans&lt;/a&gt;, you can get a better understanding in that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/javabeans/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Beansに関する&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Oracleの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;チュートリアル&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を読むと&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、理解を深めることができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="487d65f0cdd670ecba4efce16570bfd0cd1b5ad5" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt; &lt;code&gt;Serializable&lt;/code&gt; を&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d842393b0b58f41bdc74fe0276a7770f498b136d" translate="yes" xml:space="preserve">
          <source>In object serialization an object can be represented as a sequence of bytes that includes the object's data as well as information about the object's type and the types of data stored in the object.</source>
          <target state="translated">オブジェクトのシリアライズでは、オブジェクトは、オブジェクトのデータだけでなく、オブジェクトのタイプやオブジェクトに格納されているデータのタイプに関する情報を含むバイト列として表現することができます。</target>
        </trans-unit>
        <trans-unit id="3e9f7889e439155833eb47c33695d0e651aef43e" translate="yes" xml:space="preserve">
          <source>In other words, serializable objects can be written to streams, and hence files, object databases, anything really.</source>
          <target state="translated">言い換えれば、シリアル化可能なオブジェクトは、ストリーム、つまりファイル、オブジェクトデータベース、実際には何でも書き込めます。</target>
        </trans-unit>
        <trans-unit id="6c82538de50cd66977535d30c5f50dfb1fd98dfa" translate="yes" xml:space="preserve">
          <source>In practice, Beans are just objects which are handy to use. Serializing them means to be able easily to persist them (store in a form that is easily recovered).</source>
          <target state="translated">実際には、Beansは便利に使えるオブジェクトにすぎません。それらをシリアライズするということは、それらを簡単に永続化できるようにする(復元しやすい形で保存する)ということです。</target>
        </trans-unit>
        <trans-unit id="cfd8a07163911715251e5fe480435b5ac4ea0c99" translate="yes" xml:space="preserve">
          <source>It is a reusable software component. It can encapsulate many object into one object so that same object can be accessed from multiples places and is a step towards easy maintenance of code.</source>
          <target state="translated">これは再利用可能なソフトウェアコンポーネントです。多くのオブジェクトを一つのオブジェクトにカプセル化し、同じオブジェクトを複数の場所からアクセスできるようにすることができ、コードのメンテナンスを容易にするための一歩となります。</target>
        </trans-unit>
        <trans-unit id="c95fba0c5f1c0807a6b0b6c9e7c78555a297496b" translate="yes" xml:space="preserve">
          <source>It should be Serializable.</source>
          <target state="translated">Serializableである必要があります。</target>
        </trans-unit>
        <trans-unit id="bdf417910c9cd2ee31c632a3320a394c6e915215" translate="yes" xml:space="preserve">
          <source>It should have a no-arg constructor.</source>
          <target state="translated">これは、引数なしのコンストラクタを持つべきです。</target>
        </trans-unit>
        <trans-unit id="6c50498f3df224d809cc4c33e52e6abc86fce44c" translate="yes" xml:space="preserve">
          <source>It should have getter and setters.</source>
          <target state="translated">ゲッターとセッターが必要です。</target>
        </trans-unit>
        <trans-unit id="dde74edd26e8d91a7f0fd68a9f94d0eaf69d087a" translate="yes" xml:space="preserve">
          <source>It should implement serializable interface (A Marker interface).</source>
          <target state="translated">シリアライズ可能なインタフェース(A Markerインタフェース)を実装していること。</target>
        </trans-unit>
        <trans-unit id="d6b67638120ceead2afc1dc40516395855ba3d42" translate="yes" xml:space="preserve">
          <source>It should provide methods to set and get the values of the properties, known as getter and setter methods.</source>
          <target state="translated">ゲッターメソッドやセッターメソッドとして知られるプロパティの値を設定したり取得したりするメソッドを提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="80df53906b4d96fbb996894573f6918076ecac61" translate="yes" xml:space="preserve">
          <source>JSF managed beans run in a web container. They can be configured either with @ManagedBean annotation or  with an application configuration resource file managed-bean.xml.  However, it supports injection via resource injection (not typesafe) only; not fit for injection on constructors. The &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=372&quot;&gt;JSF spec&lt;/a&gt; requires that managed beans must have a public zero-argument constructors . Further it says, &amp;ldquo;As of version 2.3 of this specification, use of the managed bean facility as specified in this section is strongly
discouraged. A better and more cohesively integrated solution for solving the same problem is to use Contexts and Dependency Injection (CDI), as specified in JSR-365.&quot; In other words, CDI managed beans to be used, which offers typesafe dependency injection on constructors akin to Spring beans.  The CDI specification adopts the Managed Beans specification, which applies to all containers of the JEE platform, not just web tier. Thus, the web container needs to implement CDI specification.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSF管理Beanは、Webコンテナーで実行されます。 @ManagedBeanアノテーションまたはアプリケーション構成リソースファイルmanaged-bean.xmlを使用して構成できます。ただし、リソースインジェクション（タイプセーフではない）によるインジェクションのみをサポートします。コンストラクターへの注入には適していません。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=372&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSF仕様&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;マネージドBeanには、引数なしのパブリックコンストラクターが必要です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さらに、「この仕様のバージョン2.3では、このセクションで指定されている管理対象Bean機能の使用は強く推奨されていません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じ問題を解決するためのより適切でより統合されたソリューションは、JSR-365で指定されているように、Contexts and Dependency Injection（CDI）を使用することです。 Spring Bean。CDI仕様は、Web層だけでなく、JEEプラットフォームのすべてのコンテナーに適用されるManaged Beans仕様を採用しているため、WebコンテナーはCDI仕様を実装する必要があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f06dd2e12d43ff81497ada376a9dd0a96b32fbc" translate="yes" xml:space="preserve">
          <source>Java Beans are using for less code and more work approach... 
Java Beans are used throughout Java EE as a universal contract for runtime discovery and access. For example, JavaServer Pages (JSP) uses Java Beans as data transfer objects between pages or between servlets and JSPs. Java EE's JavaBeans Activation Framework uses Java Beans for integrating support for MIME data types into Java EE. The Java EE Management API uses JavaBeans as the foundation for the instrumentation of resources to be managed in a Java EE environment.</source>
          <target state="translated">Java Beansは、より少ないコードとより多くの作業アプローチのために使用されています...Java Beansは、ランタイムの発見とアクセスのための普遍的な契約として、Java EE全体で使用されています。例えば、JavaServer Pages (JSP)では、ページ間またはサーブレットとJSPの間のデータ転送オブジェクトとしてJava Beansを使用しています。Java EEのJavaBeans Activation Frameworkは、MIMEデータタイプのサポートをJava EEに統合するためにJava Beansを使用しています。Java EE管理APIは、Java EE環境で管理されるリソースの計装の基礎としてJavaBeansを使用しています。</target>
        </trans-unit>
        <trans-unit id="4fe52d529d685dcd20b5bb6bb18b59658689c6d4" translate="yes" xml:space="preserve">
          <source>Java Beans is a standard, and its basic syntax requirements have been clearly explained by the other answers.</source>
          <target state="translated">Java Beansは標準であり、その基本的な構文要件は他の回答でも明確に説明されています。</target>
        </trans-unit>
        <trans-unit id="2b33a1a821d93319a7c70a389e1ebd7d57f9da26" translate="yes" xml:space="preserve">
          <source>JavaBean is a development tool can be visualized in the operation of reusable software components</source>
          <target state="translated">JavaBeanは、再利用可能なソフトウェアコンポーネントの動作を可視化することができる開発ツールです。</target>
        </trans-unit>
        <trans-unit id="acb9654b482066659ee3afb750687ff58cd3d85b" translate="yes" xml:space="preserve">
          <source>JavaBean is based on the Sun JavaBeans specification and can be  reusable components. Its biggest feature is the re-usability.</source>
          <target state="translated">JavaBeanはSunのJavaBeans仕様に基づいており、再利用可能なコンポーネントにすることができます。その最大の特徴は再利用性です。</target>
        </trans-unit>
        <trans-unit id="1297f3b73908b93b716b86938bfb365c7ab1e041" translate="yes" xml:space="preserve">
          <source>JavaBeans are Java classes which adhere to an extremely simple coding convention.
All you have to do is to</source>
          <target state="translated">JavaBeansは、非常にシンプルなコーディング規約を遵守するJavaクラスです。あなたがしなければならないことは</target>
        </trans-unit>
        <trans-unit id="7dd0769a4baaeaa8daf9f73ba76d158326390750" translate="yes" xml:space="preserve">
          <source>Just a little background/update on the bean concept.  Many other answers actually have the what but not so much why of them.</source>
          <target state="translated">豆の概念について少しだけ背景を説明します。他の多くの回答には、実際には何が何であるかが書かれていますが、なぜそうなのかはあまり書かれていません。</target>
        </trans-unit>
        <trans-unit id="d8ca55e89ecf957dc3d18dfbff29aa4a8720073f" translate="yes" xml:space="preserve">
          <source>Now I see beans as annotated property balls--they are really only useful for the annotations they carry.</source>
          <target state="translated">今、私はビーンズをアノテーションされたプロパティボールとして見ています--彼らは本当に彼らが持っているアノテーションのためだけに有用です。</target>
        </trans-unit>
        <trans-unit id="d2016e213092c8c9b4efbe0ab01ea7bfea7548ff" translate="yes" xml:space="preserve">
          <source>Of course, in order to do that, the class has to abide by certain limitations.  Chief among them is that all instance fields must be either primitive types (int, bool, etc), instances of some class that is also serializable, or marked as &lt;code&gt;transient&lt;/code&gt; so that Java won't try to include them.  (This of course means that &lt;code&gt;transient&lt;/code&gt; fields will not survive the trip over a stream.  A class that has &lt;code&gt;transient&lt;/code&gt; fields should be prepared to reinitialize them if necessary.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、それを行うには、クラスは特定の制限に従う必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらの主なものは、すべてのインスタンスフィールドがプリミティブ型（int、boolなど）、シリアライズ可能なクラスのインスタンス、または&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Javaがそれらを含めないように&lt;/font&gt;&lt;/font&gt; &lt;code&gt;transient&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;としてマーク&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する必要があることです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（これはもちろん、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;transient&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールドがストリーム上を移動しても存続しないことを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;transient&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を持つクラスは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、必要に応じて再初期化できるように準備する必要があります。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c28b70c958ab8c8fca656187c98e4e3b35de03d2" translate="yes" xml:space="preserve">
          <source>Once the bean is instantiated, the Java Bean API ( java.beans.*) can introspect it and call methods on it.  If no class implementing the interface BeanInfo or extending a BeanInfo implementation , SimpleBeanInfo class, is available, the introspection involves using reflection (implicit introspection)  to study the methods supported by a target bean and then apply simple design patterns(the guidelines) to deduce from those methods what properties, events, and public methods are supported. If a class implementing the interface BeanInfo (for a bean Foo, it must be named FooBeanInfo) is available, the API bypasses implicit introspection and uses public methods (getPropertyDescriptor(), getMethodDescriptors(), getEventSetDescriptors() ) of this class to get the information. If a class extending SimpleBeanInfo is available, depending on which of the SimpleBeanInfo public methods (getPropertyDescriptor(), getMethodDescriptors(), getEventSetDescriptors() )  are overridden, it will use those overridden methods(s) to get information; for a method that is not overridden, it&amp;rsquo;ll  default to the corresponding implicit introspection. A bean needs to be instantiated anyway even if no implicit introspection is carried on it. Thus, the requirement  of a public zeri-args constructor. But, of course, the Serializable or Externalizable interface isn&amp;rsquo;t necessary for it to be recognized. However the Java Bean specification says, &amp;lsquo;We&amp;rsquo;d also like it to be &amp;ldquo;trivial&amp;rdquo; for the common case of a tiny Bean that simply wants to have its internal state saved and doesn&amp;rsquo;t want to think about it.&amp;rsquo; So, all beans must implement Serializable or Externalizable interface. 
Overall, JavaBeans specification isn&amp;rsquo;t hard and fast about what constitutes a bean. &quot;Writing JavaBeans components is surprisingly easy. You don't need a special tool and you don't have to implement any interfaces. Writing beans is simply a matter of following certain coding conventions. All you have to do is make your class look like a bean &amp;mdash; tools that use beans will be able to recognize and use your bean.&quot; Trivially, even the following class is a Java Bean,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Beanがインスタンス化されると、Java Bean API（java.beans。*）はそれをイントロスペクトし、そのメソッドを呼び出すことができます。インタフェースBeanInfoを実装するクラスまたはBeanInfo実装を拡張するクラスSimpleBeanInfoクラスが使用できない場合、イントロスペクションには、リフレクション（暗黙のイントロスペクション）を使用してターゲットBeanでサポートされるメソッドを調査し、シンプルなデザインパターン（ガイドライン）を適用して、これらのメソッドでサポートされているプロパティ、イベント、およびパブリックメソッド。インターフェースBeanInfo（Bean Fooの場合、名前はFooBeanInfo）を実装するクラスが使用可能な場合、APIは暗黙的なイントロスペクションをバイパスし、このクラスのパブリックメソッド（getPropertyDescriptor（）、getMethodDescriptors（）、getEventSetDescriptors（））を使用して情報。 SimpleBeanInfoを拡張するクラスが利用可能な場合、SimpleBeanInfoパブリックメソッド（getPropertyDescriptor（）、getMethodDescriptors（）、getEventSetDescriptors（））のどれがオーバーライドされているかに応じて、オーバーライドされたメソッドを使用して情報を取得します。オーバーライドされないメソッドの場合、対応する暗黙的なイントロスペクションがデフォルトになります。暗黙的な内省が行われていなくても、Beanはとにかくインスタンス化する必要があります。したがって、パブリックzeri-argsコンストラクターの要件。ただし、もちろん、SerializableまたはExternalizableインターフェースが認識される必要はありません。ただし、Java Beanの仕様には、「内部状態を保存したいだけで、それについて考えたくない小さなBeanの一般的なケースについては、「簡単なもの」にしたいと考えています。」したがって、すべてのBeanはSerializableまたはExternalizableインターフェースを実装する必要があります。全体、JavaBeansの仕様は、何がBeanを構成するのかについて、難しくも速くもありません。 「JavaBeansコンポーネントの作成は驚くほど簡単です。特別なツールは必要なく、インターフェースを実装する必要もありません。Beanの作成は、特定のコーディング規約に従うだけの問題です。クラスを次のようにするだけです。豆&amp;mdash;豆を使用するツールは、あなたの豆を認識して使用することができます。」当然、次のクラスもJava Beanです。あなたがしなければならないのは、クラスをBeanのように見せるだけです&amp;mdash; Beanを使用するツールは、Beanを認識して使用できるようになります。」あなたがしなければならないのは、クラスをBeanのように見せるだけです&amp;mdash; Beanを使用するツールは、Beanを認識して使用できるようになります。」&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9963e8cb9651e24589c69ac1ab2d725e8e221120" translate="yes" xml:space="preserve">
          <source>Over time these became useful for lots of tools that used the same type of access (For example, Hibernate to persist data structures to the database)</source>
          <target state="translated">時間が経つにつれて、これらは同じタイプのアクセスを使用する多くのツールで便利になりました(例えば、データ構造をデータベースに永続化するためのHibernateなど)。</target>
        </trans-unit>
        <trans-unit id="eb890b8d14da97d7c84a98d91240a6bfdc92eacd" translate="yes" xml:space="preserve">
          <source>Properties of JavaBeans</source>
          <target state="translated">JavaBeansのプロパティ</target>
        </trans-unit>
        <trans-unit id="c86ab952e1e5a0cb1746da17f6a42c5991b338f4" translate="yes" xml:space="preserve">
          <source>Regarding the second part of your question, Serialization is a persistence mechanism used to store objects as a sequence of signed bytes. Put less formally, it stores the state of an object so you can retrieve it later, by de-serialization.</source>
          <target state="translated">ご質問の2番目の部分についてですが、シリアライズは永続化のメカニズムで、オブジェクトを符号付きバイトのシーケンスとして保存するために使用されます。より正式に言うと、オブジェクトの状態を保存しているので、後でデシリアライゼーションによってそれを取り出すことができます。</target>
        </trans-unit>
        <trans-unit id="be330141ddb636e10697456283aaa177c791ee47" translate="yes" xml:space="preserve">
          <source>Say, a bean constructor has some parameters. Suppose some are simple types. The container might not know what values to assign to them; even if it does, the resulting instance might not be reusable. It may make sense only if the user can configure (specify values) by say annotations or xml configuration files as in Spring beans. And suppose some parameters are class or interface types.  Again, the container might not know what values to assign to it. It may make sense only if the user can configure (specify specific objects) by say annotations or xml configuration files. However, even in Spring (via xml configuration files), assigning specific objects (with string names) to constructor arguments (  attribute or  element of constructor arguments)is not typesafe;it is basically like resource injection.  Making references to other Spring beans(called collaborators; via  element in a constructor argument element) is basically dependency injection and thus typesafe.  Obviously, a dependency(collaborator bean) might have a constructor with injected parameters; those injected dependency(ies) might have a constructor with parameters and so on. In this scenario, ultimately, you would need some bean classes (e.g, MyBean.class) that the container can instantiate by simply calling new MyBean() before it can construct the other collaborating beans via dependency injection on constructors&amp;mdash;thus, the requirement for the beans to have public zero-args constructor.  Suppose, if a container doesn&amp;rsquo;t support dependency injection and/or doesn&amp;rsquo;t allow assigning simple-type values to constructor via some annotations or xml config files as in Spring, bean constructors shouldn&amp;rsquo;t have parameters. Even a Spring beans application would need some beans to have public zero-args constructor (e.g., in a scenario where your Spring application has no bean with just simple types as constructor arguments).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、Beanコンストラクターにはいくつかのパラメーターがあります。いくつかは単純型であるとします。コンテナはそれらに割り当てる値を知らない場合があります。たとえそうであっても、結果のインスタンスは再利用できない可能性があります。これは、ユーザーがSpring Beanのように注釈またはXML構成ファイルで構成（値を指定）できる場合にのみ意味があります。また、一部のパラメーターがクラスまたはインターフェース型であるとします。繰り返しになりますが、コンテナはどの値をそれに割り当てるかを知らないかもしれません。これは、ユーザーが注釈やxml構成ファイルなどで構成（特定のオブジェクトを指定）できる場合にのみ意味があります。ただし、Spring（xml構成ファイルを使用）でも、特定のオブジェクト（文字列名付き）をコンストラクター引数（属性またはコンストラクター引数の要素）に割り当てることはタイプセーフではなく、基本的にリソースインジェクションのようです。他のSpring Bean（コラボレーターと呼ばれる;コンストラクターの引数要素の要素を介して）への参照は、基本的に依存関係の注入であり、したがって型保証されています。明らかに、依存関係（コラボレーターBean）には、パラメーターが注入されたコンストラクターがある場合があります。これらの注入された依存関係には、パラメーターなどを含むコンストラクターがある場合があります。このシナリオでは、最終的に、コンテナーがコンストラクターの依存性注入を介して他の協調Beanを構築する前にnew MyBean（）を呼び出すだけでインスタンス化できるいくつかのBeanクラス（たとえば、MyBean.class）が必要になります。ゼロ引数のパブリックコンストラクターを持つBean。コンテナーが依存関係の注入をサポートしていない、および/またはSpringのようにいくつかの注釈またはxml構成ファイルを介してコンストラクターに単純型の値を割り当てることができない場合、Beanコンストラクターにはパラメーターがあってはなりません。 Spring Beanアプリケーションでも、引数なしのパブリックコンストラクターを持つBeanがいくつか必要になります（たとえば、Springアプリケーションに、コンストラクターの引数として単純型のみのBeanがないシナリオでは）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="065bce9fb10afa66f81a4ac0b8666f0864171dc6" translate="yes" xml:space="preserve">
          <source>Serializability of a class is enabled by the class implementing the
  java.io.Serializable interface. Classes that do not implement this
  interface will not have any of their state serialized or deserialized.
  All subtypes of a serializable class are themselves serializable. The
  serialization interface has no methods or fields and serves only to
  identify the semantics of being serializable.</source>
          <target state="translated">クラスのシリアライズ可能性は、java.io.Serializable インターフェースを実装したクラスによって有効になります。このインターフェイスを実装していないクラスは、その状態のいずれもシリアライズまたはデシリアライズされません。シリアライズ可能なクラスのすべてのサブタイプは、それ自体がシリアライズ可能です。シリアライズ・インターフェースは、メソッドやフィールドを持たず、シリアライズ可能であることのセマンティクスを識別するだけの役割を果たします。</target>
        </trans-unit>
        <trans-unit id="4dc15525a7ed769a14cceef22b82b8173524795b" translate="yes" xml:space="preserve">
          <source>So in fact, Beans are &lt;strong&gt;just a convention / standard&lt;/strong&gt; to expect something from a Java object that it would behave (serialization) and give some ways to change it (setters for properties) in a certain way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、実際には、Beanは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Javaオブジェクトから振る舞う（シリアライズ）ことを期待し、それを特定の方法で変更するいくつかの方法（プロパティのセッター）を提供するための&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;単なる規則/標準&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e2e8124fa6c1fd0049dfa058db0f51fa2420434" translate="yes" xml:space="preserve">
          <source>Spring uses Beans for objects to handle (for instance, User object that needs to be serialized in session)</source>
          <target state="translated">Springはオブジェクトを扱うためにBeansを使用しています(例えば、セッションでシリアライズする必要があるUserオブジェクトなど)。</target>
        </trans-unit>
        <trans-unit id="acdab3c6cbd01dc85b9cc89f692b8d479cfab4a9" translate="yes" xml:space="preserve">
          <source>That's it. It's just a convention.  Lots of libraries depend on it though.</source>
          <target state="translated">それだけだ ただの慣習だ 多くの図書館がそれに依存している</target>
        </trans-unit>
        <trans-unit id="16a7de9c763ff0935eb2a7212c9861a8549432e1" translate="yes" xml:space="preserve">
          <source>The JavaBean class must have a no-arg constructor</source>
          <target state="translated">JavaBeanクラスは、引数なしのコンストラクタを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="1f0d6b363ae0861665ac6aa95f25dd72a744da04" translate="yes" xml:space="preserve">
          <source>The JavaBean class must implement either &lt;code&gt;Serializable&lt;/code&gt; or
&lt;code&gt;Externalizable&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaBeanクラスは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または &lt;/font&gt; &lt;code&gt;Externalizable&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装する必要があります&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="813f50b564fdc9a27b83a1135aa3919c3b1ba21a" translate="yes" xml:space="preserve">
          <source>The class must have a public default constructor (with no arguments). This allows easy instantiation within editing and activation frameworks.</source>
          <target state="translated">クラスは、パブリックなデフォルトのコンストラクタ(引数なし)を持つ必要があります。これにより、編集フレームワークや活性化フレームワーク内でのインスタンス化が容易になります。</target>
        </trans-unit>
        <trans-unit id="cde4c7e4fad81c80d24677c7d920b4e55b94a0bf" translate="yes" xml:space="preserve">
          <source>The class properties must be accessible using get, set, is (can be used for boolean properties instead of get), and other methods (so-called accessor methods and mutator methods) according to a standard naming convention. This allows easy automated inspection and updating of bean state within frameworks, many of which include custom editors for various types of properties. Setters can have one or more than one argument.</source>
          <target state="translated">クラスのプロパティは、標準的な命名規則に従って、get、set、is(getの代わりにブール値のプロパティに使用することができます)、および他のメソッド(いわゆるアクセサメソッドとミューテータメソッド)を使用してアクセス可能でなければなりません。これにより、フレームワーク内でのビーンの状態の自動検査と更新が容易になり、その多くは様々なタイプのプロパティのためのカスタムエディタを含んでいます。セッターは1つまたは複数の引数を持つことができます。</target>
        </trans-unit>
        <trans-unit id="dac5c199f9057ffe657f76a192e02e00e6e747e0" translate="yes" xml:space="preserve">
          <source>The class should be serializable. [This allows applications and frameworks to reliably save, store, and restore the bean's state in a manner independent of the VM and of the platform.]</source>
          <target state="translated">クラスはシリアライズ可能でなければなりません。これにより、アプリケーションやフレームワークは、VMやプラットフォームに依存しない方法で、ビーンの状態を確実に保存、保存、復元することができます]。</target>
        </trans-unit>
        <trans-unit id="24b7978ed25dd8181961b7ef0846a5307e0e4c37" translate="yes" xml:space="preserve">
          <source>The constructor should be public and have no arguments (What other people call it a no-arg constructor).</source>
          <target state="translated">コンストラクタはパブリックで引数を持たないものでなければなりません (他の人はこれを no-arg コンストラクタと呼んでいます)。</target>
        </trans-unit>
        <trans-unit id="37cf012b64e5f8d8acdc1fb76f92437ad78d65a2" translate="yes" xml:space="preserve">
          <source>The objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. 
&lt;code&gt;according to&lt;/code&gt;&lt;a href=&quot;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/beans.html&quot;&gt;spring io&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アプリケーションのバックボーンを形成し、Spring IoCコンテナによって管理されるオブジェクトは、Beanと呼ばれます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Beanは、インスタンス化、アセンブル、およびその他の方法でSpring IoCコンテナによって管理されるオブジェクトです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それ以外の場合、Beanはアプリケーション内の多くのオブジェクトの1つにすぎません。 &lt;/font&gt;&lt;a href=&quot;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/beans.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;春のIOに&lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;according to&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="790f9becf38ff05a64a89e433ffc86abae1ec6c4" translate="yes" xml:space="preserve">
          <source>There is a term for it because the standard allows libraries to programmatically do things with class instances you define in a predefined way. For example, if a library wants to stream any object you pass into it, it knows it can because your object is serializable (assuming the lib requires your objects be proper JavaBeans).</source>
          <target state="translated">この用語があるのは、標準ではライブラリが事前定義された方法で定義したクラス・インスタンスを使ってプログラム的に何かを行うことを可能にしているからです。例えば、ライブラリがあなたが渡したオブジェクトをストリームしたい場合、あなたのオブジェクトはシリアライズ可能なので、ライブラリはそれが可能であることを知っています (lib がオブジェクトが適切な JavaBeans であることを要求していると仮定しています)。</target>
        </trans-unit>
        <trans-unit id="46a20fd7d231d2db0bd411c2f826d528fc46ee0f" translate="yes" xml:space="preserve">
          <source>There's a term for it to make it sound special.  The reality is nowhere near so mysterious.</source>
          <target state="translated">特別に聞こえるようにするための言葉がありますが 現実はどこもかしこも謎に包まれている。</target>
        </trans-unit>
        <trans-unit id="020c0aed9294d862e05a39597fe06961a0a4f8fa" translate="yes" xml:space="preserve">
          <source>They are serializable, have a zero-argument constructor, and allow access to properties using getter and setter methods. The name &quot;Bean&quot; was given to encompass this standard, which aims to create reusable software components for Java.&lt;code&gt;according to&lt;/code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaBeans&quot;&gt;wiki&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらはシリアル化可能で、引数のないコンストラクターがあり、ゲッターメソッドとセッターメソッドを使用してプロパティにアクセスできます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「Bean」という名前は、Javaの再利用可能なソフトウェアコンポーネントを作成することを目的としたこの標準を包括するために付けられました。&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaBeans&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;wikiに&lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;according to&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c0cb01b1ab0d58a1065e68c28978974af6fbed1" translate="yes" xml:space="preserve">
          <source>They were invented early on in Java as part of building GUIs.  They followed patterns that were easy for tools to pull apart letting them create a properties panel so you could edit the attributes of the Bean.  In general, the Bean properties represented a control on the screen (Think x,y,width,height,text,..)</source>
          <target state="translated">JavaではGUI構築の一部として早くから発明されていました。それらは、Beanの属性を編集できるようにプロパティパネルを作成することで、ツールが簡単に分離できるパターンに従っていました。一般的に、Beanプロパティは画面上のコントロールを表します(x,y,幅,高さ,テキストを考えてください)。</target>
        </trans-unit>
        <trans-unit id="475b689ed4ac32075ffabd646b337f9971c60951" translate="yes" xml:space="preserve">
          <source>To understand JavaBean you need to notice the followings:
JavaBean is a conceptual stuff and can not represent a class of specific things</source>
          <target state="translated">JavaBeanを理解するためには、以下のことに気づく必要があります。JavaBeanは概念的なものであり、特定のもののクラスを表すことはできません。</target>
        </trans-unit>
        <trans-unit id="3d908b24c52a9088e9615d60b068586c3fa4c64a" translate="yes" xml:space="preserve">
          <source>Unlike Spring beans it doesn&amp;rsquo;t support constructors with simple-types, which might be possible if it supported configuration with xml config files like in Spring or any annotations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring Beanとは異なり、simple-typesのコンストラクターはサポートされていません。これは、Springやアノテーションなどのxml構成ファイルによる構成をサポートしている場合に可能です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="d9c47d9c856a0455d2cf64866993e2892263d895" translate="yes" xml:space="preserve">
          <source>What is a JavaBean exactly</source>
          <target state="translated">JavaBeanとは具体的に何か</target>
        </trans-unit>
        <trans-unit id="93cf2f27c84573f1e71e679859e50bd288bcc2a9" translate="yes" xml:space="preserve">
          <source>With respect to &lt;code&gt;Serializable&lt;/code&gt;, from the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;API documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に関して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;APIドキュメント&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0afa35ff0cd8074a8bb16973d77094139f5c4984" translate="yes" xml:space="preserve">
          <source>You can also think of it as a strongly typed data structure.</source>
          <target state="translated">強く型付けされたデータ構造と考えることもできます。</target>
        </trans-unit>
        <trans-unit id="5eb12b688111ab8c5889f2bb69b9289d6804606a" translate="yes" xml:space="preserve">
          <source>You will find Serialization useful when deploying your project across multiple servers since beans will be persisted and transferred across them.</source>
          <target state="translated">複数のサーバにプロジェクトをデプロイする際には、ビーンが永続化され、それらのサーバ間で転送されるので、Serialization が便利です。</target>
        </trans-unit>
        <trans-unit id="2d96a33bf833bec64d9ae971cf31f2d5ca8f212a" translate="yes" xml:space="preserve">
          <source>has &quot;properties&quot; whose getters and setters are just methods with certain names (like, say, &lt;code&gt;getFoo()&lt;/code&gt; is the getter for the &quot;Foo&quot; property), and</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッターとセッターが特定の名前を持つメソッドである「プロパティ」があります（たとえば、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getFoo()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は「Foo」プロパティのゲッターです）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e13b280ea2f8522453f7c556f614cc47244dcb1" translate="yes" xml:space="preserve">
          <source>has a public 0-arg constructor (so it can be created at will and configured by setting its properties).</source>
          <target state="translated">には 0-arg のパブリックなコンストラクタがあります (自由に作成し、そのプロパティを設定して設定することができます)。</target>
        </trans-unit>
        <trans-unit id="9b500312c107ed051b5075a6bc7a0afcf73b6caa" translate="yes" xml:space="preserve">
          <source>if it is defined to be a managed bean by any
other Java EE specification and if</source>
          <target state="translated">他のJava EE仕様で管理されたビーンとして定義されている場合、そして</target>
        </trans-unit>
        <trans-unit id="4ecce28b81c9eb791b949024e3d37b66a88b3f2c" translate="yes" xml:space="preserve">
          <source>implement &lt;code&gt;java.io.Serializable&lt;/code&gt; interface - to save the state of an
object</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インターフェースを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する-オブジェクトの状態を保存する&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03c80a053a0c7279c874b2c9a156a9afa786dd3a" translate="yes" xml:space="preserve">
          <source>is a serializable object (that is, it implements &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt;&lt;code&gt;java.io.Serializable&lt;/code&gt;&lt;/a&gt;, and does so correctly), that</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シリアライズ可能なオブジェクトです（つまり、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html&quot;&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; を&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;し、正しく&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しています）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b8b1b88700cece3204b5fd605a8ce1ed12e0b91" translate="yes" xml:space="preserve">
          <source>provide public getter/setter methods -  to get and set the values of private variables (properties ).</source>
          <target state="translated">プライベート変数 (プロパティ)の値を取得したり設定したりするための、パブリックなゲッターセッターメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="fc7bf56d06d60fbcd9f3fd370b65b021682810fc" translate="yes" xml:space="preserve">
          <source>simple reusable objects POJO (Plain Old Java Objects)</source>
          <target state="translated">単純な再利用可能オブジェクト POJO (Plain Old Java Objects)</target>
        </trans-unit>
        <trans-unit id="aa75676b8043c71cc6532ad5aa3150ba355867c7" translate="yes" xml:space="preserve">
          <source>use a public empty argument constructor - to instantiate the object</source>
          <target state="translated">オブジェクトのインスタンスを作成するために、パブリックな空引数のコンストラクタを使用します。</target>
        </trans-unit>
        <trans-unit id="5fccda843ae48daffcada380e31f65f4d96f042a" translate="yes" xml:space="preserve">
          <source>visual objects</source>
          <target state="translated">ビジュアルオブジェクト</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
