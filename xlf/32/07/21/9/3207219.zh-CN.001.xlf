<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3207219">
    <body>
      <group id="3207219">
        <trans-unit id="77059d38755dc28322fe681063b9a72b79deb724" translate="yes" xml:space="preserve">
          <source>(New) Find all files and open them with tkinter GUI</source>
          <target state="translated">(新增)找到所有文件并使用tkinter GUI打开它们</target>
        </trans-unit>
        <trans-unit id="67cd3a55333326a6b15634b60cb3b5069796d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt;&lt;code&gt;os.scandir()&lt;/code&gt;&lt;/a&gt;: &lt;em&gt;New in version 3.5.&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt; &lt;code&gt;os.scandir()&lt;/code&gt; &lt;/a&gt; ： &lt;em&gt;3.5版中的新功能。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76e31b0052e0928376cce7dbc235ffa3927a14ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt;: &lt;em&gt;New in version 3.4.&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt; ： &lt;em&gt;版本3.4中的新增功能。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0dfff635d12269d90056ce5a01710406836b3e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]: OPENDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]: READDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]: CLOSEDIR(3)&lt;/a&gt; via &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]: ctypes - A foreign function library for Python&lt;/a&gt; (&lt;em&gt;POSIX&lt;/em&gt; specific)</source>
          <target state="translated">&lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]：OPENDIR（3）&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]：READDIR（3）&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]：CLOSEDIR（3）&lt;/a&gt;通过&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]：ctypes-Python的外部函数库&lt;/a&gt; （特定于 &lt;em&gt;POSIX&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="55ff2d95daa24f77a476a59c1d9797a78d9a2821" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html&quot;&gt;[ActiveState.Docs]: win32file.FindFilesW&lt;/a&gt; (&lt;em&gt;Win&lt;/em&gt; specific)</source>
          <target state="translated">&lt;a href=&quot;https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html&quot;&gt;[ActiveState.Docs]：win32file.FindFilesW&lt;/a&gt; （特定于 &lt;em&gt;Win&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="e1307db6c8784e163a1c98d061a8979c2812cf85" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/2/library/dircache.html#dircache.listdir&quot;&gt;[Python 2]: dircache.listdir(path)&lt;/a&gt; (&lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt; only)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/dircache.html#dircache.listdir&quot;&gt;[Python 2]：dircache.listdir（path）&lt;/a&gt; （仅适用于&lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="a80e40355c109f480b5de975f53594fc753ed27d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;ctypes&lt;/a&gt; is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;ctypes&lt;/a&gt;是Python的外部函数库。 它提供C兼容的数据类型，并允许在DLL或共享库中调用函数。 它可以用于将这些库包装在纯Python中。</target>
        </trans-unit>
        <trans-unit id="170038f3a75b60c3f752b7b295615e5298dcc157" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3]: glob.&lt;strong&gt;glob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt; (&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3]: glob.&lt;strong&gt;iglob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3]：glob。&lt;/a&gt; &lt;strong&gt;glob&lt;/strong&gt; （ &lt;em&gt;pathname，*，recursive = False&lt;/em&gt; ） （ &lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3]： &lt;strong&gt;glob。iglob&lt;/strong&gt; （ &lt;em&gt;pathname，*，recursive = False&lt;/em&gt; ）&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="f1ba420698c81c401d7a71e0b321fd9a1eff7ba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]: os.&lt;strong&gt;scandir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; (&lt;em&gt;Python &lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]: scandir&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]：操作系统。&lt;/a&gt; &lt;strong&gt;scandir&lt;/strong&gt; （ &lt;em&gt;path ='。'&lt;/em&gt; ） （ &lt;em&gt;Python &lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt; +，backport： &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]：scandir&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="25214d61526c1beabb3be3a8daf83746c6c5bb57" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;[Python 3]: class pathlib.&lt;strong&gt;Path&lt;/strong&gt;(&lt;em&gt;*pathsegments&lt;/em&gt;)&lt;/a&gt; (&lt;em&gt;Python &lt;strong&gt;3.4&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/pathlib2&quot;&gt;[PyPI]: pathlib2&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;[Python 3]：类pathlib。&lt;/a&gt; &lt;strong&gt;路径&lt;/strong&gt; （ &lt;em&gt;* pathsegments&lt;/em&gt; ） （ &lt;em&gt;Python &lt;strong&gt;3.4&lt;/strong&gt;&lt;/em&gt; +，backport： &lt;a href=&quot;https://pypi.org/project/pathlib2&quot;&gt;[PyPI]：pathlib2&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="00bfac63f5953b8d7d3175a2be4c2cb1af98f031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; extending the previous code</source>
          <target state="translated">扩展先前代码的 &lt;code&gt;glob&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4329bf1dd0de2a9c7ce95cb896a2ca69f2fca31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; with a function</source>
          <target state="translated">具有功能的 &lt;code&gt;glob&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f41c772121c3b9dac96db970710ae0e9758db1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; with list comprehension</source>
          <target state="translated">具有列表理解的 &lt;code&gt;glob&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dcbfe0b43a64a22dce191e3e967d279181bfe07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next(os.walk('.'))&lt;/code&gt; and &lt;code&gt;os.path.join('dir', 'file')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;next(os.walk('.'))&lt;/code&gt; 和 &lt;code&gt;os.path.join('dir', 'file')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec118b3d19b3f81eadfd29c639432a32582c075e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next(os.walk('F:\\')&lt;/code&gt; - get the full path - list comprehension</source>
          <target state="translated">&lt;code&gt;next(os.walk('F:\\')&lt;/code&gt; -获取完整路径-列表理解</target>
        </trans-unit>
        <trans-unit id="2b1167731ef7f25bc92c2b3982a46a3ed14cc811" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.listdir()&lt;/code&gt; - get only txt files</source>
          <target state="translated">&lt;code&gt;os.listdir()&lt;/code&gt; -仅获取txt文件</target>
        </trans-unit>
        <trans-unit id="e52b734b3e4a4f970785af5ff1bf2c6d6f133377" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.listdir()&lt;/code&gt;: get files in the current directory (Python 2)</source>
          <target state="translated">&lt;code&gt;os.listdir()&lt;/code&gt; ：获取当前目录中的文件（Python 2）</target>
        </trans-unit>
        <trans-unit id="a4d501d5911962500c47e2fcc04cafbc207fd782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.listdir&lt;/code&gt; and &lt;code&gt;os.scandir&lt;/code&gt; use &lt;em&gt;opendir&lt;/em&gt; / &lt;em&gt;readdir&lt;/em&gt; / &lt;em&gt;closedir&lt;/em&gt; (&lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]: FindFirstFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]: FindNextFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]: FindClose function&lt;/a&gt;) (via &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;os.listdir&lt;/code&gt; 和 &lt;code&gt;os.scandir&lt;/code&gt; 使用&lt;em&gt;opendir&lt;/em&gt; / &lt;em&gt;readdir&lt;/em&gt; / &lt;em&gt;closedir&lt;/em&gt; （ &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]：FindFirstFileW函数&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]：FindNextFileW函数&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]：FindClose函数&lt;/a&gt; ）（通过&lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]：python / cpython -（主）cpython / Modules / posixmodule.c&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="911e0e0ce1d9d3f7eadd150f395af1fe2acb2281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.scandir()&lt;/code&gt; from Python 3.5 and greater</source>
          <target state="translated">python 3.5及更高版本中的 &lt;code&gt;os.scandir()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e279c9e348196deece32d5a5d26532642206320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.walk('.')&lt;/code&gt; - current directory</source>
          <target state="translated">&lt;code&gt;os.walk('.')&lt;/code&gt; -当前目录</target>
        </trans-unit>
        <trans-unit id="2e2eefd877c594ba3c3651f5ba65c863026c498c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.walk&lt;/code&gt; - get full path - all files in sub dirs**</source>
          <target state="translated">&lt;code&gt;os.walk&lt;/code&gt; -获取完整路径-sub dirs中的所有文件**</target>
        </trans-unit>
        <trans-unit id="61d2f87c70c7e8c413baa40c3a55d9c085030ce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print full_file_paths&lt;/code&gt; which will print the list:</source>
          <target state="translated">&lt;code&gt;print full_file_paths&lt;/code&gt; 将打印列表：</target>
        </trans-unit>
        <trans-unit id="5718278766a0afe1d9442f96e1788b8c6b1aa4a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;win32file.FindFilesW&lt;/code&gt; is part of &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions&lt;/a&gt;, which is a &lt;em&gt;Python&lt;/em&gt; wrapper over &lt;em&gt;WINAPI&lt;/em&gt;s</source>
          <target state="translated">&lt;code&gt;win32file.FindFilesW&lt;/code&gt; 是&lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]的&lt;/a&gt;一部分：mhammond / pywin32-Windows的Python（pywin32）扩展 ，它是&lt;em&gt;WINAPI&lt;/em&gt;的&lt;em&gt;Python&lt;/em&gt;包装器</target>
        </trans-unit>
        <trans-unit id="ec2464c59bc77af55917a9107e99a96a64cb299b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;win32file.FindFilesW&lt;/code&gt; uses those (&lt;em&gt;Win&lt;/em&gt; specific) functions as well (via &lt;a href=&quot;https://github.com/mhammond/pywin32/blob/master/win32/src/win32file.i&quot;&gt;[GitHub]: mhammond/pywin32 - (master) pywin32/win32/src/win32file.i&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;win32file.FindFilesW&lt;/code&gt; 也使用这些（特定于&lt;em&gt;Win的&lt;/em&gt; ）函数（通过&lt;a href=&quot;https://github.com/mhammond/pywin32/blob/master/win32/src/win32file.i&quot;&gt;[GitHub]：mhammond / pywin32-（主）pywin32 / win32 / src / win32file.i&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="967369ece668c40d77459a43aa74854d100b236c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://docs.python.org/release/2.6.7/library/dircache.html&quot;&gt;dircache&lt;/a&gt; is  &quot;Deprecated since version 2.6: The dircache module has been removed in Python 3.0.&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://docs.python.org/release/2.6.7/library/dircache.html&quot;&gt;dircache&lt;/a&gt;是&amp;ldquo;自2.6版起不推荐使用：dircache模块已在Python 3.0中删除。&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95ac707ebadead9c005ea35708f927732b3658f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alternatively, use &lt;code&gt;pathlib.Path()&lt;/code&gt; instead of &lt;code&gt;pathlib.Path(&quot;.&quot;)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;或者，使用 &lt;code&gt;pathlib.Path()&lt;/code&gt; 代替 &lt;code&gt;pathlib.Path(&quot;.&quot;)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d169b18dc1029ec7a5a06d6082c7fbbc8a987fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I found glob easier to select the file of the same type or with something in common. Look at the following example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;我发现glob更容易选择相同类型或相同的文件。&lt;/em&gt; &lt;em&gt;看下面的例子：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4dac21df5aa700d6abc10cb8734fe3bf0a3f201" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinuxDirent64&lt;/em&gt; is the &lt;em&gt;ctypes&lt;/em&gt; representation of &lt;em&gt;struct dirent64&lt;/em&gt; from &lt;a href=&quot;http://man7.org/linux/man-pages/man0/dirent.h.0p.html&quot;&gt;[man7]: dirent.h(0P)&lt;/a&gt; (so are the &lt;em&gt;DT_&lt;/em&gt; constants) from my machine: &lt;em&gt;Ubtu 16 x64&lt;/em&gt; (&lt;em&gt;4.10.0-40-generic&lt;/em&gt; and &lt;em&gt;libc6-dev:amd64&lt;/em&gt;). On other flavors/versions, the struct definition might differ, and if so, the &lt;em&gt;ctypes&lt;/em&gt; alias should be updated, otherwise it will yield &lt;strong&gt;Undefined Behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;LinuxDirent64&lt;/em&gt;是来自&lt;a href=&quot;http://man7.org/linux/man-pages/man0/dirent.h.0p.html&quot;&gt;[man7]&lt;/a&gt;的&lt;em&gt;struct dirent64&lt;/em&gt;的&lt;em&gt;ctypes&lt;/em&gt;表示形式：我的机器上的dirent.h（0P） （ &lt;em&gt;DT_&lt;/em&gt;常量也是如此）： &lt;em&gt;Ubtu 16 x64&lt;/em&gt; （ &lt;em&gt;4.10.0-40-generic&lt;/em&gt;和&lt;em&gt;libc6-dev：amd64&lt;/em&gt; ）。 在其他风味/版本上，结构定义可能会有所不同，如果有，则应更新&lt;em&gt;ctypes&lt;/em&gt;别名，否则将产生&lt;strong&gt;未定义行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2607498abaee4d65262b0bddee1f3ea8c158fcc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python&lt;/em&gt; version (2, 3, )</source>
          <target state="translated">&lt;em&gt;Python&lt;/em&gt;版本（2、3，）</target>
        </trans-unit>
        <trans-unit id="b9a7ecb806c918f13af940395a94bc6be131239d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;_get_dir_content&lt;/em&gt; (from point &lt;strong&gt;&lt;em&gt;#1.&lt;/em&gt;&lt;/strong&gt;) can be implemented using any of these approaches (some will require more work and some less)</source>
          <target state="translated">&lt;em&gt;_get_dir_content&lt;/em&gt; （从&lt;strong&gt;&lt;em&gt;第1&lt;/em&gt;&lt;/strong&gt;点开始）可以使用以下任何一种方法来实现（有些需要更多的工作，有些需要更少的工作）</target>
        </trans-unit>
        <trans-unit id="51c4642373e690d325c7ad82b464877082b573af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;code_ctypes.py&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;code_ctypes.py&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="4ce19a6e839999d658d2189b0e2e6cfd1a994d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; will get you everything that's in a directory - &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;directories&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;将为您提供目录中的所有内容- &lt;strong&gt;文件&lt;/strong&gt;和&lt;strong&gt;目录&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6908731fb32533dc511dc58bc31f693b16e0a6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Changed in version 3.5&lt;/em&gt;&lt;/strong&gt;: Support for recursive globs using &amp;ldquo;&lt;code&gt;**&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;在版本3.5中更改&lt;/em&gt;&lt;/strong&gt; ：支持使用&amp;ldquo; &lt;code&gt;**&lt;/code&gt; &amp;rdquo;的递归glob。</target>
        </trans-unit>
        <trans-unit id="80c9eeb957a9dcaf420ae2704e8bae60f417cce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting Full File Paths From a Directory and All Its Subdirectories&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;从目录及其所有子目录获取完整的文件路径&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed3b34369d6c831eda3203fea591c57c95c623c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nota bene!&lt;/strong&gt; Since recursion is used, I must mention that I did some tests on my laptop (&lt;em&gt;Win 10 x64&lt;/em&gt;), totally unrelated to this problem, and when the recursion level was reaching values somewhere in the &lt;em&gt;(990 .. 1000)&lt;/em&gt; range (&lt;em&gt;recursionlimit&lt;/em&gt; - 1000 (default)), I got &lt;em&gt;StackOverflow&lt;/em&gt; :). If the directory tree exceeds that limit (I am not an &lt;em&gt;FS&lt;/em&gt; expert, so I don't know if that is even possible), that could be a problem.</source>
          <target state="translated">&lt;strong&gt;诺娜&amp;middot;贝恩！&lt;/strong&gt; 由于使用了递归，因此必须提及，我在笔记本电脑上做了一些测试（ &lt;em&gt;Win 10 x64&lt;/em&gt; ），与该问题完全无关，并且当递归级别达到&lt;em&gt;（990 .. 1000）&lt;/em&gt;范围内的某个值时（ &lt;em&gt;recursionlimit&lt;/em&gt; -1000 （默认）），我得到了&lt;em&gt;StackOverflow&lt;/em&gt; :)。 如果目录树超过了该限制（我不是&lt;em&gt;FS&lt;/em&gt;专家，那么我什至不知道那是不可能的），那可能是个问题。</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="226c6d195092d25e48f4779200988ceb25b71b01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="dd4fa00e1e26bc6e3309dc337769a5de63e91abb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a list of absolute filepaths, does not recurse into subdirectories&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;返回绝对文件路径的列表，不会递归到子目录中&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa5e2e67d3cc1bef43276434c369d329c225d671" translate="yes" xml:space="preserve">
          <source>A more elaborate example (&lt;em&gt;code_os_listdir.py&lt;/em&gt;):</source>
          <target state="translated">一个更详细的示例（ &lt;em&gt;code_os_listdir.py&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="8ed1a1caaa3d9b2ea4444233183eb102f593b692" translate="yes" xml:space="preserve">
          <source>A one-line solution to get &lt;strong&gt;only list of files&lt;/strong&gt; (no subdirectories):</source>
          <target state="translated">一种&lt;strong&gt;仅&lt;/strong&gt;获取&lt;strong&gt;文件列表&lt;/strong&gt; （不包含子目录）的单行解决方案：</target>
        </trans-unit>
        <trans-unit id="3f7baacb87cbc70334d95d8dad8015e84d265360" translate="yes" xml:space="preserve">
          <source>A script to make order in your computer finding all files of a type (default: pptx) and copying them in a new folder.</source>
          <target state="translated">在你的计算机中寻找所有类型的文件(默认:pptx)并复制到一个新的文件夹中。</target>
        </trans-unit>
        <trans-unit id="18a031b8608ba4b689ddd883ad50ff533b9c06ea" translate="yes" xml:space="preserve">
          <source>A wise teacher told me once that:</source>
          <target state="translated">一个聪明的老师曾经告诉我,。</target>
        </trans-unit>
        <trans-unit id="265800892490fb1601fd167bbb05c9a077f6f925" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://www.python.org/dev/peps/pep-0428/&quot;&gt;PEP 428&lt;/a&gt;, the aim of the &lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt; library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them.</source>
          <target state="translated">根据&lt;a href=&quot;http://www.python.org/dev/peps/pep-0428/&quot;&gt;PEP 428&lt;/a&gt; ， &lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt;库的目的是提供一个简单的类层次结构，以处理文件系统路径以及用户对其进行的常见操作。</target>
        </trans-unit>
        <trans-unit id="fe1b805fa41865e2a141d056f31e274b81ddcf59" translate="yes" xml:space="preserve">
          <source>All &lt;strong&gt;direct&lt;/strong&gt; (or level 1) descendants &lt;strong&gt;only&lt;/strong&gt;</source>
          <target state="translated">仅所有&lt;strong&gt;直接&lt;/strong&gt; （或1级）后代</target>
        </trans-unit>
        <trans-unit id="7b0dd3dc06a999c149acccf660c3c3b5e0948936" translate="yes" xml:space="preserve">
          <source>All descendants in the whole directory tree (including the ones in sub-directories)</source>
          <target state="translated">整个目录树中的所有子目录(包括子目录中的子目录)中的所有子目录</target>
        </trans-unit>
        <trans-unit id="795b001e462ca70c4701a577b0fd48553b937462" translate="yes" xml:space="preserve">
          <source>All the file of C:\ in one text file</source>
          <target state="translated">所有的C:?</target>
        </trans-unit>
        <trans-unit id="4f60f646333a3fcbbb5abc8a20d45f9d6a825c64" translate="yes" xml:space="preserve">
          <source>Allows advanced filtering based on name (due to the wildcard)</source>
          <target state="translated">允许根据名称进行高级过滤(由于通配符的缘故)。</target>
        </trans-unit>
        <trans-unit id="c76c29bde082ce11b0bea8f181c56b87461dd256" translate="yes" xml:space="preserve">
          <source>Although there's a clear differentiation between &lt;em&gt;file&lt;/em&gt; and &lt;em&gt;directory&lt;/em&gt; terms in the question text, some may argue that directories are actually special files</source>
          <target state="translated">尽管问题文本中的&lt;em&gt;文件&lt;/em&gt;和&lt;em&gt;目录&lt;/em&gt;术语之间存在明显区别，但有些人可能会认为目录实际上是特殊文件</target>
        </trans-unit>
        <trans-unit id="f9a1b06084ad18eacff39d734675db236d0e924a" translate="yes" xml:space="preserve">
          <source>Another great example that works perfectly across platforms and does something a bit different:</source>
          <target state="translated">另一个很好的例子,可以完美地跨平台工作,做一些不同的事情。</target>
        </trans-unit>
        <trans-unit id="9c74cca7bc2607ab72c18ce116e088a6a731b392" translate="yes" xml:space="preserve">
          <source>Another very readable variant for Python 3.4+ is using pathlib.Path.glob:</source>
          <target state="translated">Python 3.4+的另一个非常可读的变体是使用pathlib.Path.glob。</target>
        </trans-unit>
        <trans-unit id="2b0828f2db598ba89be096f4660295ec0a22850d" translate="yes" xml:space="preserve">
          <source>As examples:</source>
          <target state="translated">作为例子:</target>
        </trans-unit>
        <trans-unit id="6e64b0571c3fdb7731788760b1d43cfee74e79de" translate="yes" xml:space="preserve">
          <source>As you noticed, you don't have the full path of the file in the code above. If you need to have the absolute path, you can use another function of the &lt;code&gt;os.path&lt;/code&gt; module called &lt;code&gt;_getfullpathname&lt;/code&gt;, putting the file that you get from &lt;code&gt;os.listdir()&lt;/code&gt; as an argument. There are other ways to have the full path, as we will check later (I replaced, as suggested by mexmex, _getfullpathname with &lt;code&gt;abspath&lt;/code&gt;).</source>
          <target state="translated">如您所见，上面的代码中没有文件的完整路径。 如果需要绝对路径，则可以使用 &lt;code&gt;os.path&lt;/code&gt; 模块的另一个函数 &lt;code&gt;_getfullpathname&lt;/code&gt; ，将从 &lt;code&gt;os.listdir()&lt;/code&gt; 获得的文件作为参数。 还有其他完整路径的方法，稍后我们将进行检查（如mexmex所建议，我将_getfullpathname替换为 &lt;code&gt;abspath&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d1fe60df39e99b31631ea38ad2e4ff59ea3443b7" translate="yes" xml:space="preserve">
          <source>But as other people pointed out in the comments, &lt;code&gt;glob()&lt;/code&gt; can get tripped up over inconsistent slash directions. To help with that, I suggest you use the &lt;code&gt;join()&lt;/code&gt; and &lt;code&gt;expanduser()&lt;/code&gt; functions in the &lt;code&gt;os.path&lt;/code&gt; module, and perhaps the &lt;code&gt;getcwd()&lt;/code&gt; function in the &lt;code&gt;os&lt;/code&gt; module, as well.</source>
          <target state="translated">但是正如其他人在评论中指出的那样， &lt;code&gt;glob()&lt;/code&gt; 可能会在不一致的斜杠方向上绊倒。 为了解决这个问题，我建议您使用 &lt;code&gt;os.path&lt;/code&gt; 模块中的 &lt;code&gt;join()&lt;/code&gt; 和 &lt;code&gt;expanduser()&lt;/code&gt; 函数，以及 &lt;code&gt;os&lt;/code&gt; 模块中的 &lt;code&gt;getcwd()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0729ebe50ef5a012a64664a3c418b8dca0914fd5" translate="yes" xml:space="preserve">
          <source>But it's also more flexible (and offers more functionality), more &lt;em&gt;Python&lt;/em&gt;ic (and in some cases, faster)</source>
          <target state="translated">但是它也更灵活（并提供更多功能），更多&lt;em&gt;Python&lt;/em&gt; ic（在某些情况下还更快）</target>
        </trans-unit>
        <trans-unit id="2c42e1c593cf111f9e0d87e8ab97c21021343c62" translate="yes" xml:space="preserve">
          <source>But, according to &lt;a href=&quot;https://github.com/python/cpython/blob/2.7/Lib/dircache.py&quot;&gt;[GitHub]: python/cpython - (2.7) cpython/Lib/dircache.py&lt;/a&gt;, it's just a (thin) wrapper over &lt;code&gt;os.listdir&lt;/code&gt; with caching</source>
          <target state="translated">但是，根据&lt;a href=&quot;https://github.com/python/cpython/blob/2.7/Lib/dircache.py&quot;&gt;[GitHub]：python / cpython-（2.7）cpython / Lib / dircache.py&lt;/a&gt; ，它只是 &lt;code&gt;os.listdir&lt;/code&gt; 上的一个（薄）包装器，带有缓存</target>
        </trans-unit>
        <trans-unit id="ca6363bb22ea7785526fe7ee19319ed341d533c7" translate="yes" xml:space="preserve">
          <source>Code is meant to be portable (except places that target a specific area - which are marked) or cross:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14112f5c3007f7f556cbb25d16858a3f899f203a" translate="yes" xml:space="preserve">
          <source>Everything is doable on &lt;em&gt;Win&lt;/em&gt; as well, the data (libraries, functions, structs, constants, ...) differ</source>
          <target state="translated">一切在&lt;em&gt;Win&lt;/em&gt;上也是可行的，数据（库，函数，结构，常量等）不同</target>
        </trans-unit>
        <trans-unit id="a834153c43f41ea14afdf02c080d7570ce816614" translate="yes" xml:space="preserve">
          <source>Everything is done using another technology</source>
          <target state="translated">一切都是用另一种技术来完成的</target>
        </trans-unit>
        <trans-unit id="44f628d265c86d2e9a4860f7ae47e80830fd8645" translate="yes" xml:space="preserve">
          <source>Ex. 1: How many files are there in the subdirectories?</source>
          <target state="translated">例子 1、子目录里有多少个文件?</target>
        </trans-unit>
        <trans-unit id="b904f62fed90570ad0db161a005ad7c414f4b009" translate="yes" xml:space="preserve">
          <source>Ex. 3: How to get all the files in a txt file</source>
          <target state="translated">例子 3:如何获取一个txt文件中的所有文件?</target>
        </trans-unit>
        <trans-unit id="01735532fe2614938285a1b062e4f88f2656f6a0" translate="yes" xml:space="preserve">
          <source>Ex.2: How to copy all files from a directory to another?</source>
          <target state="translated">Ex.2:如何将所有文件从一个目录复制到另一个目录?</target>
        </trans-unit>
        <trans-unit id="fc0677d0f3b0f61b8c1fc76c570287407e2d6097" translate="yes" xml:space="preserve">
          <source>Example: txt with all the files of an hard drive</source>
          <target state="translated">例子:txt与硬盘中的所有文件的txt</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="8a8b976b0df2bf4d588554936815b3b855407347" translate="yes" xml:space="preserve">
          <source>Filtering (&lt;code&gt;grep&lt;/code&gt; / &lt;code&gt;findstr&lt;/code&gt;) or output formatting could be done on both sides, but I'm not going to insist on it. Also, I deliberately used &lt;code&gt;os.system&lt;/code&gt; instead of &lt;code&gt;subprocess.Popen&lt;/code&gt;.</source>
          <target state="translated">过滤（ &lt;code&gt;grep&lt;/code&gt; / &lt;code&gt;findstr&lt;/code&gt; ）或输出格式化都可以在两面进行，但是我不会坚持使用它。 另外，我故意使用 &lt;code&gt;os.system&lt;/code&gt; 而不是subprocess.Popen 。</target>
        </trans-unit>
        <trans-unit id="69f5a9e089e418b3efecf9214fb21040f3b48494" translate="yes" xml:space="preserve">
          <source>Following, are simple methods to retrieve only files in the current directory, using &lt;code&gt;os&lt;/code&gt;  and the &lt;code&gt;listdir()&lt;/code&gt; function, in Python 3.  Further exploration, will demonstrate how to return folders in the directory, but you will not have the file in the subdirectory, for that you can use walk - discussed later).</source>
          <target state="translated">以下是在Python 3中使用 &lt;code&gt;os&lt;/code&gt; 和 &lt;code&gt;listdir()&lt;/code&gt; 函数仅检索当前目录中文件的简单方法。进一步的探索，将演示如何返回目录中的文件夹，但子目录中没有文件，为此您可以使用步行-稍后讨论）。</target>
        </trans-unit>
        <trans-unit id="e773a2ec04cc7a36b772553f62d5753f78393dcd" translate="yes" xml:space="preserve">
          <source>For each implementation there are two functions:</source>
          <target state="translated">对于每个实施方案都有两个函数。</target>
        </trans-unit>
        <trans-unit id="d4f7f653d6c2441aac3e3ed746a48f87664bbd31" translate="yes" xml:space="preserve">
          <source>For greater results, you can use &lt;code&gt;listdir()&lt;/code&gt; method of the &lt;code&gt;os&lt;/code&gt; module along with a generator (a generator is a powerful iterator that keeps its state, remember?). The following code works fine with both versions: Python 2 and Python 3.</source>
          <target state="translated">为了获得更好的结果，可以将 &lt;code&gt;os&lt;/code&gt; 模块的 &lt;code&gt;listdir()&lt;/code&gt; 方法与生成器一起使用（生成器是一个强大的迭代器，可以保持其状态，还记得吗？）。 以下代码在两个版本上均可正常使用：Python 2和Python 3。</target>
        </trans-unit>
        <trans-unit id="83916e29a54dc89e3b07e97c71360ffb35c763e2" translate="yes" xml:space="preserve">
          <source>For large trees (especially if &lt;em&gt;recursive&lt;/em&gt; is on), &lt;em&gt;iglob&lt;/em&gt; is preferred</source>
          <target state="translated">对于大树（尤其是在启用&lt;em&gt;递归的&lt;/em&gt;情况下），首选&lt;em&gt;iglob&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa300c01afab3863769d5e47da2d31fbf81c8768" translate="yes" xml:space="preserve">
          <source>For python2:
pip install rglob</source>
          <target state="translated">对于python2:pip install rglob</target>
        </trans-unit>
        <trans-unit id="d59fce7ea7058689b5d814b70a95463df2a403ec" translate="yes" xml:space="preserve">
          <source>Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory &lt;em&gt;top&lt;/em&gt; (including &lt;em&gt;top&lt;/em&gt; itself), it yields a 3-tuple (&lt;code&gt;dirpath&lt;/code&gt;, &lt;code&gt;dirnames&lt;/code&gt;, &lt;code&gt;filenames&lt;/code&gt;).</source>
          <target state="translated">通过自上而下或自下而上浏览目录树来生成目录树中的文件名。 对于以目录&lt;em&gt;顶部&lt;/em&gt; （包括&lt;em&gt;顶部&lt;/em&gt;本身）为根的树中的每个目录，它会生成一个 &lt;code&gt;dirpath&lt;/code&gt; 组（ dirpath ， &lt;code&gt;dirnames&lt;/code&gt; ， &lt;code&gt;filenames&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="163ba5c6d0c0bfc2725c96022859ecdd60969671" translate="yes" xml:space="preserve">
          <source>Get a list of files with Python 2 and 3</source>
          <target state="translated">获取一个带有Python 2和3的文件列表</target>
        </trans-unit>
        <trans-unit id="6257a890b65001f1ef7d31cb16b75441121bed4a" translate="yes" xml:space="preserve">
          <source>Get all and only files with os.walk</source>
          <target state="translated">获取所有且仅获取带有os.walk的文件</target>
        </trans-unit>
        <trans-unit id="c639fadedf5f863ca84f4bfb3b55705f569f214d" translate="yes" xml:space="preserve">
          <source>Get all the subdir names with &lt;code&gt;walk&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;walk&lt;/code&gt; 获取所有子目录名称</target>
        </trans-unit>
        <trans-unit id="e536a5ca14a01f5cf5fc68d326659f5a972bbf1e" translate="yes" xml:space="preserve">
          <source>Get files of a particular subdirectory with &lt;code&gt;os.listdir()&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;os.listdir()&lt;/code&gt; 获取特定子目录的文件</target>
        </trans-unit>
        <trans-unit id="f62d1e5b33944f43de78cff30f836d727879227a" translate="yes" xml:space="preserve">
          <source>Get files: &lt;code&gt;os.listdir()&lt;/code&gt; in a particular directory (Python 2 and 3)</source>
          <target state="translated">获取文件：特定目录中的 &lt;code&gt;os.listdir()&lt;/code&gt; （Python 2和3）</target>
        </trans-unit>
        <trans-unit id="66320026929e9da850bcd144e598ddc44b848310" translate="yes" xml:space="preserve">
          <source>Get only directories with next and walk in a directory</source>
          <target state="translated">只获取有下一个目录的目录,并在目录中行走</target>
        </trans-unit>
        <trans-unit id="c00678ff9f6bba9c2717d09eadc7b1f9850745a5" translate="yes" xml:space="preserve">
          <source>Get only files with next and walk in a directory</source>
          <target state="translated">只获取具有下一个文件,并在目录中行走的文件</target>
        </trans-unit>
        <trans-unit id="75c7b090b484f4acebe7677b04b66ec377f1a94c" translate="yes" xml:space="preserve">
          <source>Get the full path name of a type of file into all subdirectories with &lt;code&gt;walk&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;walk&lt;/code&gt; 获取所有子目录中文件类型的完整路径名</target>
        </trans-unit>
        <trans-unit id="c08178a1ecc2f8cfa76124569230327f5915fa27" translate="yes" xml:space="preserve">
          <source>Getting the full path name with &lt;code&gt;os.path.abspath&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;os.path.abspath&lt;/code&gt; 获取完整的路径名</target>
        </trans-unit>
        <trans-unit id="1265e3f180b7b368ca2800ec8fdf7e6c187619f8" translate="yes" xml:space="preserve">
          <source>Here I use a recursive structure.</source>
          <target state="translated">这里我用的是递归结构。</target>
        </trans-unit>
        <trans-unit id="00ef9b46e5f4c780b426f0c720644fad71347af7" translate="yes" xml:space="preserve">
          <source>Here's a code:</source>
          <target state="translated">这里有一个代码。</target>
        </trans-unit>
        <trans-unit id="a54a06c1c610aa488919f6dc7fc05ce2c447996d" translate="yes" xml:space="preserve">
          <source>Here's my general-purpose function for this.  It returns a list of file paths rather than filenames since I found that to be more useful.  It has a few optional arguments that make it versatile.  For instance, I often use it with arguments like &lt;code&gt;pattern='*.txt'&lt;/code&gt; or &lt;code&gt;subfolders=True&lt;/code&gt;.</source>
          <target state="translated">这是我的通用功能。 它返回文件路径列表而不是文件名，因为我发现它更有用。 它具有一些可选参数，使其具有通用性。 例如，我经常将其与 &lt;code&gt;pattern='*.txt'&lt;/code&gt; 或 &lt;code&gt;subfolders=True&lt;/code&gt; 之类的参数一起使用 。</target>
        </trans-unit>
        <trans-unit id="c9271b1ddd962b6f47925cd53436434c79ece0b6" translate="yes" xml:space="preserve">
          <source>Hope these examples help you see the power of a few of the functions you can find in the standard Python library modules.</source>
          <target state="translated">希望这些例子能帮助你看到标准Python库模块中的一些功能的力量。</target>
        </trans-unit>
        <trans-unit id="b729e7cb29089e1d1996b3976225d3674a6c6592" translate="yes" xml:space="preserve">
          <source>How can I list all files of a directory in Python and add them to a &lt;code&gt;list&lt;/code&gt;?</source>
          <target state="translated">如何在Python中列出目录的所有文件并将其添加到 &lt;code&gt;list&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="c3b2884f2713aaea630efe656daa4c05252175dc" translate="yes" xml:space="preserve">
          <source>How do I list all files of a directory</source>
          <target state="translated">如何列出目录中的所有文件</target>
        </trans-unit>
        <trans-unit id="e00653909a179a310baee836b27cd1476870a6e6" translate="yes" xml:space="preserve">
          <source>How to get all the files (and directories) in the current directory (Python 3)</source>
          <target state="translated">如何获取当前目录中的所有文件 (和目录)(Python 3)</target>
        </trans-unit>
        <trans-unit id="fd6af8b0eb49675d34e8d60ce4056ca2c1f720f7" translate="yes" xml:space="preserve">
          <source>How to write a file with all paths in a folder of a type</source>
          <target state="translated">如何写一个文件夹中的所有路径类型的文件?</target>
        </trans-unit>
        <trans-unit id="794d18e6fd0010efc6f9a94b2d73107816f6daf8" translate="yes" xml:space="preserve">
          <source>I consider it more like a lame workaround (&lt;em&gt;gainarie&lt;/em&gt;), as the action per se is performed from &lt;em&gt;shell&lt;/em&gt; (&lt;em&gt;cmd&lt;/em&gt; in this case), and thus doesn't have anything to do with &lt;em&gt;Python&lt;/em&gt;.</source>
          <target state="translated">我认为它更像是一种&lt;em&gt;me脚的&lt;/em&gt;解决方法（ &lt;em&gt;gainarie&lt;/em&gt; ），因为操作本身是从&lt;em&gt;shell&lt;/em&gt; （在这种情况下为&lt;em&gt;cmd&lt;/em&gt; ）执行的，因此与&lt;em&gt;Python&lt;/em&gt;没有任何关系。</target>
        </trans-unit>
        <trans-unit id="059dffa5982f14f193e723dafe03b7bef365a77f" translate="yes" xml:space="preserve">
          <source>I find this very useful to find stuff in many directories, and it helped me find a file about which I didn't remember the name:</source>
          <target state="translated">我发现这个东西在很多目录中找东西非常有用,它帮我找到了一个我不记得名字的文件。</target>
        </trans-unit>
        <trans-unit id="88e1cbd9dfb68f6906eee88c036d857911cb35e8" translate="yes" xml:space="preserve">
          <source>I just wanted to add in this 2019 a little app to search for all files in a dir and be able to open them by doubleclicking on the name of the file in the list.</source>
          <target state="translated">我只是想在这个2019年的小程序中加入一个小程序,可以搜索到一个dir中的所有文件,并且能够通过双击列表中的文件名来打开它们。</target>
        </trans-unit>
        <trans-unit id="8d5e9a5d82d50a1d89c5b7978729e29f78cb73f6" translate="yes" xml:space="preserve">
          <source>I must also mention that I didn't try to increase &lt;em&gt;recursionlimit&lt;/em&gt; because I have no experience in the area (how much can I increase it before having to also increase the stack at &lt;em&gt;OS&lt;/em&gt; level), but in theory there will always be the possibility for failure, if the dir depth is larger than the highest possible &lt;em&gt;recursionlimit&lt;/em&gt; (on that machine)</source>
          <target state="translated">我还必须提到，我没有尝试增加&lt;em&gt;递归限制，&lt;/em&gt;因为我没有该领域的经验（在必须同时增加&lt;em&gt;OS&lt;/em&gt;级别的堆栈之前可以增加多少），​​但是从理论上讲，总有可能如果dir深度大于最大可能的&lt;em&gt;递归限制&lt;/em&gt; （在该计算机上），则失败</target>
        </trans-unit>
        <trans-unit id="29d4b69808fadc3012ed98af41b908d9f5790171" translate="yes" xml:space="preserve">
          <source>I prefer using the &lt;a href=&quot;https://docs.python.org/library/glob.html&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; module, as it does pattern matching and expansion.</source>
          <target state="translated">我更喜欢使用&lt;a href=&quot;https://docs.python.org/library/glob.html&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt;模块，因为它可以进行模式匹配和扩展。</target>
        </trans-unit>
        <trans-unit id="7252a35f48c90033d98d1297755bdce37ce77d37" translate="yes" xml:space="preserve">
          <source>I really liked &lt;a href=&quot;https://stackoverflow.com/a/3215392/901641&quot;&gt;adamk's answer&lt;/a&gt;, suggesting that you use &lt;code&gt;glob()&lt;/code&gt;, from the module of the same name. This allows you to have pattern matching with &lt;code&gt;*&lt;/code&gt;s.</source>
          <target state="translated">我真的很喜欢&lt;a href=&quot;https://stackoverflow.com/a/3215392/901641&quot;&gt;adamk的答案&lt;/a&gt; ，建议您使用同名模块中的 &lt;code&gt;glob()&lt;/code&gt; 。 这使您可以使用 &lt;code&gt;*&lt;/code&gt; s进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="afd9cb8b94d7a0c43d11c42336cf3c11bc88d35a" translate="yes" xml:space="preserve">
          <source>I will provide a sample one liner where sourcepath and file type can be provided as input. The code returns a list of filenames with csv extension. Use &lt;em&gt;.&lt;/em&gt; in case all files needs to be returned. This will also recursively scans the subdirectories.</source>
          <target state="translated">我将提供一个示例liner，其中可以提供sourcepath和文件类型作为输入。 该代码返回带有csv扩展名的文件名列表。 使用&lt;em&gt;。&lt;/em&gt; 万一需要返回所有文件。 这还将递归扫描子目录。</target>
        </trans-unit>
        <trans-unit id="1ca5a4cfabdcec4ef79ccc257fe2ed9a1b431600" translate="yes" xml:space="preserve">
          <source>I will thus add a solution for a &lt;strong&gt;subset&lt;/strong&gt; of the problem: quite often, we only want to check whether a file matches a start string and an end string, without going into subdirectories. We would thus like a function that returns a list of filenames, like:</source>
          <target state="translated">因此，我将为问题的一个&lt;strong&gt;子集&lt;/strong&gt;添加一个解决方案：很多时候，我们只想检查文件是否匹配开始字符串和结束字符串，而无需进入子目录。 因此，我们想要一个返回文件名列表的函数，例如：</target>
        </trans-unit>
        <trans-unit id="5a165b3cd12a8d0d4f0217514b1e68179cc8bf55" translate="yes" xml:space="preserve">
          <source>If I should need the absolute path of the files:</source>
          <target state="translated">如果我应该需要文件的绝对路径。</target>
        </trans-unit>
        <trans-unit id="ed52a277b510cfd0dcd6fa8f392432a26551de26" translate="yes" xml:space="preserve">
          <source>If you are looking for a Python implementation of &lt;strong&gt;find&lt;/strong&gt;, this is a recipe I use rather frequently:</source>
          <target state="translated">如果您正在寻找&lt;strong&gt;find&lt;/strong&gt;的Python实现，这是我经常使用的食谱：</target>
        </trans-unit>
        <trans-unit id="90f100f9c3bc23151bbf759b25b9915bdc5e944f" translate="yes" xml:space="preserve">
          <source>If you care to first declare two functions, this can be done:</source>
          <target state="translated">如果你关心先声明两个函数,这一点可以做到。</target>
        </trans-unit>
        <trans-unit id="bb80ffde24b3466cf70bca6ff6e24ccdda603187" translate="yes" xml:space="preserve">
          <source>If you want &lt;em&gt;just&lt;/em&gt; files, you could either filter this down using &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#module-os.path&quot;&gt;&lt;strong&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">如果&lt;em&gt;只需要&lt;/em&gt;文件，则可以使用&lt;a href=&quot;https://docs.python.org/2/library/os.path.html#module-os.path&quot;&gt;&lt;strong&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;将其过滤掉：</target>
        </trans-unit>
        <trans-unit id="2f42b390755c693476bbd7b012e8c56a6646aaf8" translate="yes" xml:space="preserve">
          <source>If you'd like, you can open and read the contents, or focus only on files with the extension &quot;.dat&quot; like in the code below:</source>
          <target state="translated">如果你愿意,你可以打开并读取内容,或者只关注扩展名为&quot;.dat &quot;的文件,比如下面的代码。</target>
        </trans-unit>
        <trans-unit id="5ec8177c7394be1e7c3936ea15de0cd2de2f58ea" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;Python 2.2&lt;/em&gt;, the concept of &lt;strong&gt;generator&lt;/strong&gt; (&lt;a href=&quot;https://wiki.python.org/moin/Generators&quot;&gt;[Python.Wiki]: Generators&lt;/a&gt;) - courtesy of &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement&quot;&gt;[Python 3]: The yield statement&lt;/a&gt;) - was introduced. As time passed, generator counterparts started to appear for functions that returned/worked with lists</source>
          <target state="translated">在&lt;em&gt;Python 2.2中&lt;/em&gt; ， &lt;a href=&quot;https://wiki.python.org/moin/Generators&quot;&gt;引入&lt;/a&gt;了&lt;strong&gt;生成器&lt;/strong&gt; （ [Python.Wiki]：Generators ）的概念-由&lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement&quot;&gt;[Python 3]：yield语句提供&lt;/a&gt; 。 随着时间的流逝，对于返回/使用列表的函数，生成器对应对象开始出现</target>
        </trans-unit>
        <trans-unit id="941678e560913790233b5aa5cd7389c01878b95f" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;Python 3&lt;/em&gt;, generator is the default behavior</source>
          <target state="translated">在&lt;em&gt;Python 3中&lt;/em&gt; ，generator是默认行为</target>
        </trans-unit>
        <trans-unit id="77e8769e42712522036d94b7b3c78ef5ae7612ed" translate="yes" xml:space="preserve">
          <source>In Python 2, if you want the list of the files in the current directory, you have to give the argument as '.' or os.getcwd() in the os.listdir method.</source>
          <target state="translated">在Python 2中,如果你想要当前目录中的文件列表,必须在os.listdir方法中给出参数为'.'或os.getcwd()。</target>
        </trans-unit>
        <trans-unit id="1bf007beb38c4e9235e1737e3e3177509d6c7c43" translate="yes" xml:space="preserve">
          <source>In case you want to create a txt file with all the file names:</source>
          <target state="translated">以防你想用所有的文件名创建一个txt文件。</target>
        </trans-unit>
        <trans-unit id="0f5d050a4f8bb3031f5f9e13a6748a7392e69ca5" translate="yes" xml:space="preserve">
          <source>In general this approach is to be avoided, since if some command output format slightly differs between &lt;em&gt;OS&lt;/em&gt; versions/flavors, the parsing code should be adapted as well; not to mention differences between locales).</source>
          <target state="translated">通常应避免使用此方法，因为如果某些命令输出格式在&lt;em&gt;OS&lt;/em&gt;版本/版本之间略有不同，则解析代码也应进行调整；否则，可能会导致错误。 更不用说语言环境之间的差异了）。</target>
        </trans-unit>
        <trans-unit id="4da2721c7f32a55a30ed1e1cdcbe7c7110817904" translate="yes" xml:space="preserve">
          <source>In pre &lt;em&gt;Python 2.2&lt;/em&gt; versions, sequences (iterables) were mostly represented by lists (tuples, sets, ...)</source>
          <target state="translated">在&lt;em&gt;Python 2.2之前的&lt;/em&gt;版本中，序列（可迭代）主要由列表（元组，集合等）表示。</target>
        </trans-unit>
        <trans-unit id="63c6634f856645f142e10f863b59c7c875566996" translate="yes" xml:space="preserve">
          <source>In terms of performance, generators are generally a little bit faster (considering both &lt;em&gt;creation&lt;/em&gt; and  &lt;em&gt;iteration&lt;/em&gt; times), but I didn't test them in recursive functions, and also I am iterating inside the function over inner generators - don't know how performance friendly is that</source>
          <target state="translated">在性能方面，生成器通常要快一些（考虑&lt;em&gt;创建&lt;/em&gt;和&lt;em&gt;迭代&lt;/em&gt;时间），但是我没有在递归函数中对其进行测试，而且我也在内部生成器上迭代了函数-不知道性能如何友好的是</target>
        </trans-unit>
        <trans-unit id="9fd1ec8d3629be0ce71e52d7e9222d123494250b" translate="yes" xml:space="preserve">
          <source>In this example, we look for the number of files that are included in all the directory and its subdirectories.</source>
          <target state="translated">在这个例子中,我们寻找所有目录及其子目录中包含的文件数量。</target>
        </trans-unit>
        <trans-unit id="9f9c1666d6fb24da9547d74890628916241d2319" translate="yes" xml:space="preserve">
          <source>Install some (other) third-party package that does the trick</source>
          <target state="translated">安装一些(其他)第三方的软件包,这样做的效果很好</target>
        </trans-unit>
        <trans-unit id="d56ef1a5a7ed51dfab5117ea0a28d045166fe0bf" translate="yes" xml:space="preserve">
          <source>It does the heavy lifting by recurring in subfolders</source>
          <target state="translated">它通过在子文件夹中重复出现的方式来完成繁重的工作。</target>
        </trans-unit>
        <trans-unit id="7cbdb41b0d45ef09c31105cfa4a37433afd9eef5" translate="yes" xml:space="preserve">
          <source>It is simple to make more specific, e.g. only look for Python source files which are not symbolic links, also in all subdirectories:</source>
          <target state="translated">很简单,可以做得更具体一些,比如只找不是符号链接的Python源文件,也是在所有的子目录中找。</target>
        </trans-unit>
        <trans-unit id="3cbdf226190d6816dae21afe946a062e1c1c39d7" translate="yes" xml:space="preserve">
          <source>It loads the three functions from &lt;em&gt;libc&lt;/em&gt; (loaded in the current process) and calls them (for more details check &lt;a href=&quot;https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python/44661513#44661513&quot;&gt;[SO]: How do I check whether a file exists without exceptions? (@CristiFati's answer)&lt;/a&gt; - last notes from item &lt;strong&gt;&lt;em&gt;#4.&lt;/em&gt;&lt;/strong&gt;). That would place this approach very close to the &lt;em&gt;Python&lt;/em&gt; / &lt;em&gt;C&lt;/em&gt; edge</source>
          <target state="translated">它从&lt;em&gt;libc&lt;/em&gt;加载三个函数（在当前进程中加载​​）并调用它们（有关更多详细信息，请检查&lt;a href=&quot;https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python/44661513#44661513&quot;&gt;[SO]：如何检查文件是否存在无异常？（@ CristiFati的回答）&lt;/a&gt; - &lt;strong&gt;&lt;em&gt;第4&lt;/em&gt;&lt;/strong&gt;项的最后说明&lt;strong&gt;&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt; ）。 这将使这种方法非常接近&lt;em&gt;Python&lt;/em&gt; / &lt;em&gt;C&lt;/em&gt;边缘</target>
        </trans-unit>
        <trans-unit id="c2c25c0e9aac0187cd9a8df39fc91736f708a691" translate="yes" xml:space="preserve">
          <source>It returns data in the &lt;code&gt;os.walk&lt;/code&gt;'s format. I didn't bother to make it recursive, but starting from the existing code, that would be a fairly trivial task</source>
          <target state="translated">它以 &lt;code&gt;os.walk&lt;/code&gt; 的格式返回数据。 我没有麻烦使其递归，但是从现有代码开始，这将是一件相当琐碎的任务</target>
        </trans-unit>
        <trans-unit id="4525df15d3072b34e880ab3a342cc68304ca97e8" translate="yes" xml:space="preserve">
          <source>It will return a list with the queried files:</source>
          <target state="translated">它将返回一个包含被查询文件的列表。</target>
        </trans-unit>
        <trans-unit id="8de9859a57cc42b18329ec8459329c1376b161fe" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">它类似于 &lt;code&gt;os.listdir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8b169f69f815666e2a48dbd2a337af6d2d3ac89" translate="yes" xml:space="preserve">
          <source>It's the &lt;em&gt;OOP&lt;/em&gt; style of handling paths</source>
          <target state="translated">这是处理路径的&lt;em&gt;OOP&lt;/em&gt;风格</target>
        </trans-unit>
        <trans-unit id="5a3f2285980cec4dcc0334534e1165949da510e0" translate="yes" xml:space="preserve">
          <source>Let me also recommend reading ShadowRanger's comment below.</source>
          <target state="translated">让我也推荐大家看看ShadowRanger在下面的评论。</target>
        </trans-unit>
        <trans-unit id="2f11e0e14c1417ab4165bb45bcafbebb61e0ebf2" translate="yes" xml:space="preserve">
          <source>Modify file extensions and source path as needed.</source>
          <target state="translated">根据需要修改文件扩展名和源路径。</target>
        </trans-unit>
        <trans-unit id="0108e5063d896e4acb61bd29dd84e7c04a286618" translate="yes" xml:space="preserve">
          <source>Most likely, will rely on one (or more) of the above (maybe with slight customizations)</source>
          <target state="translated">最有可能的是,将依靠上述的一个(或多个)(也许有轻微的定制化)。</target>
        </trans-unit>
        <trans-unit id="c9f6848eeecc84445de53d0bf42da05a4a1371ff" translate="yes" xml:space="preserve">
          <source>Multiple path styles (absolute, relatives) were used across the above variants, to illustrate the fact that the &quot;tools&quot; used are flexible in this direction</source>
          <target state="translated">在上述变体中使用了多种路径样式(绝对式、亲属式),以说明所使用的 &quot;工具 &quot;在这一方向上是灵活的</target>
        </trans-unit>
        <trans-unit id="45d635954f958ec2e3e526c6c1bf2736318c4c8b" translate="yes" xml:space="preserve">
          <source>Not sure if returning a list is still mandatory (or a generator would do as well), but passing a generator to the &lt;em&gt;list&lt;/em&gt; constructor, will create a list out of it (and also consume it). The example below illustrates the differences on &lt;a href=&quot;https://docs.python.org/3/library/functions.html#map&quot;&gt;[Python 3]: &lt;strong&gt;map&lt;/strong&gt;(&lt;em&gt;function, iterable, ...&lt;/em&gt;)&lt;/a&gt;</source>
          <target state="translated">不知道返回列表是否仍然是强制性的（或者生成器也可以执行），但是将生成器传递给&lt;em&gt;列表&lt;/em&gt;构造函数会从列表中创建一个列表（并使用它）。 下面的示例说明了&lt;a href=&quot;https://docs.python.org/3/library/functions.html#map&quot;&gt;[Python 3]&lt;/a&gt;的区别： &lt;strong&gt;map&lt;/strong&gt; （ &lt;em&gt;function，iterable，...&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="76684f5c591f9e77105544503001782cbd1fa281" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.walk&quot;&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt;&lt;code&gt;os.scandir()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt; from version 3.5, and its speed got increased by 2-20 times according to &lt;a href=&quot;http://www.python.org/dev/peps/pep-0471/&quot;&gt;PEP 471&lt;/a&gt;.</source>
          <target state="translated">请注意，从3.5版开始， &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.walk&quot;&gt; &lt;code&gt;os.walk()&lt;/code&gt; &lt;/a&gt;使用&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt; &lt;code&gt;os.scandir()&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; ，根据&lt;a href=&quot;http://www.python.org/dev/peps/pep-0471/&quot;&gt;PEP 471&lt;/a&gt; ，其速度提高了2-20倍。</target>
        </trans-unit>
        <trans-unit id="717ed41e89e1d28f1116c7b65c2db4e7963f0a67" translate="yes" xml:space="preserve">
          <source>Offers lots of functionalities</source>
          <target state="translated">提供了很多功能</target>
        </trans-unit>
        <trans-unit id="da503e6e497b8e0204fa6cc99972651747ef2f98" translate="yes" xml:space="preserve">
          <source>One that starts with an &lt;em&gt;underscore&lt;/em&gt; (&lt;strong&gt;_&lt;/strong&gt;): &quot;private&quot; (should not be called directly) - that does all the work</source>
          <target state="translated">以&lt;em&gt;下划线&lt;/em&gt; （ &lt;strong&gt;_&lt;/strong&gt; ） &lt;em&gt;开头的代码&lt;/em&gt; ：&amp;ldquo; private&amp;rdquo;（不应直接调用）-完成所有工作</target>
        </trans-unit>
        <trans-unit id="f668c22f829b531f83c4e8c14822ced5de586def" translate="yes" xml:space="preserve">
          <source>One that uses generators (of course here it seems useless, since I immediately convert the result to a list)</source>
          <target state="translated">一个使用生成器(当然在这里似乎没有用,因为我立即将结果转换为列表)。</target>
        </trans-unit>
        <trans-unit id="54dd98245eb94a5511e854146666976f5eab6029" translate="yes" xml:space="preserve">
          <source>Other approaches:</source>
          <target state="translated">其他方法:</target>
        </trans-unit>
        <trans-unit id="8982de0f87f5a64b5d2a43e140c7d1284ef222a9" translate="yes" xml:space="preserve">
          <source>Play with the arguments to get different results</source>
          <target state="translated">玩转论点,得到不同的结果</target>
        </trans-unit>
        <trans-unit id="a2334d3b78606fb37d97982e921c201ebc52a874" translate="yes" xml:space="preserve">
          <source>Preliminary notes</source>
          <target state="translated">初步说明</target>
        </trans-unit>
        <trans-unit id="c31fb60399d7d99c4a5f5c96a1b65920b8659a3c" translate="yes" xml:space="preserve">
          <source>Programmatic approaches:</source>
          <target state="translated">方案性的方法。</target>
        </trans-unit>
        <trans-unit id="3b2106740c196b5c51ebc11173417a1ff3c74077" translate="yes" xml:space="preserve">
          <source>Recursion is used (to get into subdirectories)</source>
          <target state="translated">递归的使用(进入子目录</target>
        </trans-unit>
        <trans-unit id="79da5d61c75dc4fb7461217fb85e3fc01b5d813e" translate="yes" xml:space="preserve">
          <source>Retrieves a list of matching filenames, using the Windows Unicode API. An interface to the API FindFirstFileW/FindNextFileW/Find close functions.</source>
          <target state="translated">使用 Windows Unicode API 检索匹配的文件名列表。一个API FindFirstFileWFindNextFileWFind关闭函数的接口。</target>
        </trans-unit>
        <trans-unit id="582be600686ad7e319795122c6738abaf4b1acf1" translate="yes" xml:space="preserve">
          <source>Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order, and does not include the special entries &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; ...</source>
          <target state="translated">返回一个列表，其中包含由path给出的目录中条目的名称。 该列表按任意顺序排列，并且不包括特殊条目 &lt;code&gt;'.'&lt;/code&gt; 和 &lt;code&gt;'..'&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="2f072b75d44d6a733fac5a3200b5894a255faa0e" translate="yes" xml:space="preserve">
          <source>Return a possibly-empty list of path names that match &lt;em&gt;pathname&lt;/em&gt;, which must be a string containing a path specification. &lt;em&gt;pathname&lt;/em&gt; can be either absolute (like &lt;code&gt;/usr/src/Python-1.5/Makefile&lt;/code&gt;) or relative (like &lt;code&gt;../../Tools/*/*.gif&lt;/code&gt;), and can contain shell-style wildcards. Broken symlinks are included in the results (as in the shell).</source>
          <target state="translated">返回与&lt;em&gt;pathname&lt;/em&gt;匹配的路径名的可能为空的列表，该列表必须是包含路径说明的字符串。 &lt;em&gt;路径名&lt;/em&gt;可以是绝对&lt;em&gt;路径&lt;/em&gt; （例如 &lt;code&gt;/usr/src/Python-1.5/Makefile&lt;/code&gt; ），也可以是相对&lt;em&gt;路径&lt;/em&gt; （例如 &lt;code&gt;../../Tools/*/*.gif&lt;/code&gt; ），并且可以包含shell样式的通配符。 损坏的符号链接包含在结果中（如在shell中）。</target>
        </trans-unit>
        <trans-unit id="f0ce9f6d0622c1638c21f97c4b621614044f0b11" translate="yes" xml:space="preserve">
          <source>Return an iterator of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects corresponding to the entries in the directory given by &lt;em&gt;path&lt;/em&gt;. The entries are yielded in arbitrary order, and the special entries &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; are not included.</source>
          <target state="translated">返回与&lt;em&gt;path&lt;/em&gt;指定的目录中的条目相对应的&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt;对象的迭代器。 条目以任意顺序产生，特殊条目为 &lt;code&gt;'.'&lt;/code&gt; 和 &lt;code&gt;'..'&lt;/code&gt; 不包括在内。</target>
        </trans-unit>
        <trans-unit id="077432006ccd924f3e84db4a09f99df379bd4be9" translate="yes" xml:space="preserve">
          <source>Since version 3.4 there are builtin &lt;em&gt;iterators&lt;/em&gt; for this which are a lot more efficient than &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">从3.4版开始，有内置的&lt;em&gt;迭代器&lt;/em&gt; ，它比&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt;效率更高：</target>
        </trans-unit>
        <trans-unit id="e0182e165e36f3ef5412a702725b8fd761ec234c" translate="yes" xml:space="preserve">
          <source>So I made a PyPI &lt;a href=&quot;https://pypi.python.org/pypi/findtools/&quot;&gt;package&lt;/a&gt; out of it and there is also a &lt;a href=&quot;https://github.com/ewiger/findtools&quot;&gt;GitHub repository&lt;/a&gt;. I hope that someone finds it potentially useful for this code.</source>
          <target state="translated">所以我用它制作了一个PyPI &lt;a href=&quot;https://pypi.python.org/pypi/findtools/&quot;&gt;包&lt;/a&gt; ，还有一个&lt;a href=&quot;https://github.com/ewiger/findtools&quot;&gt;GitHub存储库&lt;/a&gt; 。 我希望有人发现它可能对该代码有用。</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="c9cfd1ae92b0fb56af44351245614b36eb7da00f" translate="yes" xml:space="preserve">
          <source>Some advanced filtering (instead of just file &lt;em&gt;vs.&lt;/em&gt; dir) could be done: e.g. the &lt;em&gt;include_folders&lt;/em&gt; argument could be replaced by another one (e.g. &lt;em&gt;filter_func&lt;/em&gt;) which would be a function that takes a path as an argument: &lt;code&gt;filter_func=lambda x: True&lt;/code&gt; (this doesn't strip out anything) and inside &lt;em&gt;_get_dir_content&lt;/em&gt; something like: &lt;code&gt;if not filter_func(entry_with_path): continue&lt;/code&gt; (if the function fails for one entry, it will be skipped), but the more complex the code becomes, the longer it will take to execute</source>
          <target state="translated">可以执行一些高级过滤（而不只是文件或目录）：例如， &lt;em&gt;include_folders&lt;/em&gt;参数可以被另一个参数（例如&lt;em&gt;filter_func&lt;/em&gt; ）代替，该参数将是一个将路径作为参数的函数： &lt;code&gt;filter_func=lambda x: True&lt;/code&gt; （这不会删除任何内容），并且在&lt;em&gt;_get_dir_content&lt;/em&gt;内部类似： &lt;code&gt;if not filter_func(entry_with_path): continue&lt;/code&gt; （如果该函数对一项失败，则将被跳过），但是代码越复杂，花费的时间就越长执行</target>
        </trans-unit>
        <trans-unit id="50ca8e6b16dd6e1652134dcd18d09f91fd597149" translate="yes" xml:space="preserve">
          <source>Some consider this a neat hack</source>
          <target state="translated">有人认为这是个很好的黑客</target>
        </trans-unit>
        <trans-unit id="a2c18de198a22ba809f588bc8b14ec52c40280db" translate="yes" xml:space="preserve">
          <source>That technology is invoked from &lt;em&gt;Python&lt;/em&gt;</source>
          <target state="translated">该技术是从&lt;em&gt;Python&lt;/em&gt;调用的</target>
        </trans-unit>
        <trans-unit id="984a1dd63f81000a751cb4379badf365cb11099e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;listdir()&lt;/code&gt; method returns the list of entries for the given directory. The method &lt;code&gt;os.path.isfile()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; if the given entry is a file. And the &lt;code&gt;yield&lt;/code&gt; operator quits the func but keeps its current state, and it returns only the name of the entry detected as a file. All the above allows us to loop over the generator function.</source>
          <target state="translated">&lt;code&gt;listdir()&lt;/code&gt; 方法返回给定目录的条目列表。 如果给定的条目是文件，则方法 &lt;code&gt;os.path.isfile()&lt;/code&gt; 返回 &lt;code&gt;True&lt;/code&gt; 。 并且 &lt;code&gt;yield&lt;/code&gt; 运算符退出功能但保持其当前状态，并且仅返回检测为文件的条目的名称。 以上所有内容使我们可以循环生成器功能。</target>
        </trans-unit>
        <trans-unit id="ddcc5552d357d16f4d04b6b8fcf0c7ad4ebcade4" translate="yes" xml:space="preserve">
          <source>The above is terrible - the path has been hardcoded and will only ever work on Windows between the drive name and the &lt;code&gt;\&lt;/code&gt;s being hardcoded into the path.</source>
          <target state="translated">上面的代码很糟糕-路径已经过硬编码，并且只能在Windows中的驱动器名称和被硬编码到路径之间的 &lt;code&gt;\&lt;/code&gt; 上使用 。</target>
        </trans-unit>
        <trans-unit id="34a84e7d808c73e5816d9c5f644714391da08644" translate="yes" xml:space="preserve">
          <source>The above works better, but it relies on the folder name &lt;code&gt;Users&lt;/code&gt; which is often found on Windows and not so often found on other OSs. It also relies on the user having a specific name, &lt;code&gt;admin&lt;/code&gt;.</source>
          <target state="translated">上面的方法效果更好，但是它依赖于Windows上常见的文件夹名称&amp;ldquo; &lt;code&gt;Users&lt;/code&gt; &amp;rdquo; ，而在其他OS上则不常见。 它还依赖于具有特定名称 &lt;code&gt;admin&lt;/code&gt; 的用户。</target>
        </trans-unit>
        <trans-unit id="a5efb4f05d0af1ea2fc7d5aded2f175627849834" translate="yes" xml:space="preserve">
          <source>The classic one (function names ending in &lt;strong&gt;_old&lt;/strong&gt;)</source>
          <target state="translated">经典的（函数名称以&lt;strong&gt;_old&lt;/strong&gt;结尾）</target>
        </trans-unit>
        <trans-unit id="97ce4a8e2e1c748e1512dd6a514db079e8da4db5" translate="yes" xml:space="preserve">
          <source>The code samples are for demonstrative purposes only. That means that I didn't take into account error handling (I don't think there's any &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; block), so the code is not robust (the reason is: to keep it as simple and short as possible). For &lt;em&gt;production&lt;/em&gt;, error handling should be added as well</source>
          <target state="translated">代码示例仅用于说明目的。 这意味着我没有考虑错误处理（我不认为有任何&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;除了&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt;块），因此代码并不健壮（原因是：使其尽可能简单和简短） ）。 对于&lt;em&gt;生产&lt;/em&gt; ，还应添加错误处理</target>
        </trans-unit>
        <trans-unit id="67da2a3716eaa60f772589f94e3b92d99311f82d" translate="yes" xml:space="preserve">
          <source>The documentation link is from &lt;a href=&quot;https://www.activestate.com&quot;&gt;ActiveState&lt;/a&gt;, as I didn't find any &lt;em&gt;PyWin32&lt;/em&gt; official documentation</source>
          <target state="translated">文档链接来自&lt;a href=&quot;https://www.activestate.com&quot;&gt;ActiveState&lt;/a&gt; ，因为我没有找到任何&lt;em&gt;PyWin32&lt;/em&gt;官方文档</target>
        </trans-unit>
        <trans-unit id="72a7531c0e841449871b731f13a1ff92ce1aee1f" translate="yes" xml:space="preserve">
          <source>The examples will be based on a directory called &lt;em&gt;root_dir&lt;/em&gt; with the following structure (this example is for &lt;em&gt;Win&lt;/em&gt;, but I'm using the same tree on &lt;em&gt;Lnx&lt;/em&gt; as well):</source>
          <target state="translated">这些示例将基于具有以下结构的名为&lt;em&gt;root_dir&lt;/em&gt;的目录（此示例适用于&lt;em&gt;Win&lt;/em&gt; ，但我也在&lt;em&gt;Lnx&lt;/em&gt;上使用同一棵树）：</target>
        </trans-unit>
        <trans-unit id="3e381581ca6c685f3cab612a470ca71cd33d9f8d" translate="yes" xml:space="preserve">
          <source>The function now returns a list of file that matched with the string you pass as argument</source>
          <target state="translated">该函数现在返回一个与你传递的字符串匹配的文件列表。</target>
        </trans-unit>
        <trans-unit id="b44ca6221ff33c07b43c340fd9b727e5d43741f4" translate="yes" xml:space="preserve">
          <source>The function returns a list of the given extension (.txt, .docx ecc.) in the argument</source>
          <target state="translated">该函数返回参数中给定的扩展名(.txt、.docx等)的列表。</target>
        </trans-unit>
        <trans-unit id="bff076f64e415e92b28eefc66672b4bbb04ba0f5" translate="yes" xml:space="preserve">
          <source>The most famous flavor that I know is what I call the &lt;em&gt;system administrator&lt;/em&gt; approach:</source>
          <target state="translated">我所知道的最著名的味道是我所说的&lt;em&gt;系统管理员&lt;/em&gt;方法：</target>
        </trans-unit>
        <trans-unit id="0a6b782490002196a2329ad3481974c99420998b" translate="yes" xml:space="preserve">
          <source>The path I provided in the above function contained 3 files&amp;mdash; two of them in the root directory, and another in a subfolder called &quot;SUBFOLDER.&quot;  You can now do things like:</source>
          <target state="translated">我在上述函数中提供的路径包含3个文件-其中两个在根目录中，另一个在子文件夹&amp;ldquo; SUBFOLDER&amp;rdquo;中。 您现在可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="e43335d7cd1ee1be4d33ec1c5e8400190fdf6456" translate="yes" xml:space="preserve">
          <source>The public one (wrapper over previous): it just strips off the initial path (if required) from the returned entries. It's an ugly implementation, but it's the only idea that I could come with at this point</source>
          <target state="translated">公共的(在前面的包装器上):它只是从返回的条目的初始路径(如果需要的话)中剥离掉。这是个很难看的实现,但这是我目前唯一能想到的点子</target>
        </trans-unit>
        <trans-unit id="5cb12071056bcb42b9fc0f988ee71ec74b111c62" translate="yes" xml:space="preserve">
          <source>The statement: &quot;&lt;em&gt;all files of a directory&lt;/em&gt;&quot; can be interpreted in two ways:</source>
          <target state="translated">语句：&amp;ldquo; &lt;em&gt;目录的所有文件&lt;/em&gt; &amp;rdquo;可以用两种方式解释：</target>
        </trans-unit>
        <trans-unit id="2292e3df0a0f2e83012ca2a2c609cc82bea4dfd6" translate="yes" xml:space="preserve">
          <source>There are two implementations:</source>
          <target state="translated">有两种实现方式。</target>
        </trans-unit>
        <trans-unit id="5c929a3860b937c949d26a208230c2d0f7712cbd" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;one&lt;/em&gt; way of achieving our goal</source>
          <target state="translated">这是实现我们目标的&lt;em&gt;一种&lt;/em&gt;方式</target>
        </trans-unit>
        <trans-unit id="821003fc981444da5a481089df7b23f8c27b28c3" translate="yes" xml:space="preserve">
          <source>This is a shorter version of the previous code. Change the folder where to start finding the files if you need to start from another position. This code generate a 50 mb on text file on my computer with something less then 500.000 lines with files with the complete path.</source>
          <target state="translated">这是前一个代码的简短版本。如果你需要从另一个位置开始查找文件,请更改文件夹。这段代码在我的电脑上生成一个50MB的文本文件,在我的电脑上生成的文本文件少于500.000行,文件有完整的路径。</target>
        </trans-unit>
        <trans-unit id="3d13557d689d8a3adf5877b55d33c0d2b4d7c265" translate="yes" xml:space="preserve">
          <source>This solution could be easily generalized with regular expressions (and you might want to add a &lt;code&gt;pattern&lt;/code&gt; argument, if you do not want your patterns to always stick to the start or end of the filename).</source>
          <target state="translated">此解决方案可以使用正则表达式轻松进行一般化（如果您不希望模式始终坚持文件名的开头或结尾，则可能需要添加 &lt;code&gt;pattern&lt;/code&gt; 参数。）</target>
        </trans-unit>
        <trans-unit id="55f2ad7673e7660434283f70da80f18b6ccef8a3" translate="yes" xml:space="preserve">
          <source>This works perfectly across all platforms.</source>
          <target state="translated">这在所有平台上都能完美地实现。</target>
        </trans-unit>
        <trans-unit id="5b26a5f61adbf2dc12a1e448638766977078aed1" translate="yes" xml:space="preserve">
          <source>To go up in the directory tree</source>
          <target state="translated">要在目录树中往上走</target>
        </trans-unit>
        <trans-unit id="64f9b00db14ed02adc874ae17ab1ca0fd942076e" translate="yes" xml:space="preserve">
          <source>Under the scenes, it uses &lt;code&gt;os.scandir&lt;/code&gt; (&lt;code&gt;os.listdir&lt;/code&gt; on older versions)</source>
          <target state="translated">在幕后，它使用 &lt;code&gt;os.scandir&lt;/code&gt; （旧版本上为 &lt;code&gt;os.listdir&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="cd65c2d67dece60963b8de40a3a24454e912a835" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;Python&lt;/em&gt; (or any programming language for that matter) in order to execute &lt;em&gt;shell&lt;/em&gt; commands (and parse their outputs)</source>
          <target state="translated">使用&lt;em&gt;Python&lt;/em&gt; （或与此相关的任何编程语言）以执行&lt;em&gt;Shell&lt;/em&gt;命令（并解析其输出）</target>
        </trans-unit>
        <trans-unit id="c226bbc07d59db598114cede264cde6f3b89fc89" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;Python&lt;/em&gt; only as a wrapper</source>
          <target state="translated">仅将&lt;em&gt;Python&lt;/em&gt;用作包装器</target>
        </trans-unit>
        <trans-unit id="41688114f6359ccacea86a89625b311705d53f70" translate="yes" xml:space="preserve">
          <source>Use glob method in pathlib.Path()</source>
          <target state="translated">使用 pathlib.Path()中的 glob 方法。</target>
        </trans-unit>
        <trans-unit id="8ff6af64dd6be56bd7353670e77103fb708b4cd5" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;os.listdir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a09130d4064cb71241e9c92eb3d5f5998cbbe1e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir()&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir()&lt;/a&gt; can significantly increase the performance of code that also needs file type or file attribute information, because &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects expose this information if the operating system provides it when scanning a directory. All &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; methods may perform a system call, but &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file()&lt;/a&gt; usually only require a system call for symbolic links; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat()&lt;/a&gt; always requires a system call on Unix but only requires one for symbolic links on Windows.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir（）&lt;/a&gt;而不是&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir（）&lt;/a&gt;可以大大提高还需要文件类型或文件属性信息的代码的性能，因为如果操作系统在扫描目录时提供了&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt;对象，则os.DirEntry对象将公开此信息。 所有&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt;方法都可以执行系统调用，但是&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir（）&lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file（）&lt;/a&gt;通常只需要系统调用即可进行符号链接。 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat（）&lt;/a&gt;在Unix上始终需要系统调用，而在Windows上只需要一个系统调用即可。</target>
        </trans-unit>
        <trans-unit id="a78436732f1a3d9a5ef51ed738e4a262db3bb8ca" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;glob&lt;/code&gt; to get the full path of the files</source>
          <target state="translated">使用 &lt;code&gt;glob&lt;/code&gt; 获取文件的完整路径</target>
        </trans-unit>
        <trans-unit id="612cdb119d7c05fd21faac9981e16bf2c2695847" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;os.path.isfile&lt;/code&gt; to avoid directories in the list</source>
          <target state="translated">使用 &lt;code&gt;os.path.isfile&lt;/code&gt; 避免列表中的目录</target>
        </trans-unit>
        <trans-unit id="2534d35f39302b5dc41c46d30c7c0d17be04995d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pathlib&lt;/code&gt; from Python 3.4</source>
          <target state="translated">从Python 3.4使用 &lt;code&gt;pathlib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afa1cd5a306219cebbf55166624ed633b8d4f90f" translate="yes" xml:space="preserve">
          <source>Using generators</source>
          <target state="translated">使用发电机</target>
        </trans-unit>
        <trans-unit id="09cefc7b06a9f30509334ba0aed651b2279a6dfd" translate="yes" xml:space="preserve">
          <source>When the question was asked, I imagine that &lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt;, was the &lt;em&gt;LTS&lt;/em&gt; version, however the code samples will be run by &lt;em&gt;Python &lt;strong&gt;3&lt;/strong&gt;(&lt;strong&gt;.5&lt;/strong&gt;)&lt;/em&gt; (I'll keep them as &lt;em&gt;Python 2&lt;/em&gt; compliant as possible; also, any code belonging to &lt;em&gt;Python&lt;/em&gt; that I'm going to post, is from &lt;strong&gt;v3.5.4&lt;/strong&gt; - unless otherwise specified). That has consequences related to another keyword in the question: &quot;&lt;em&gt;add them into a &lt;strong&gt;list&lt;/strong&gt;&lt;/em&gt;&quot;:</source>
          <target state="translated">提出问题时，我认为&lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt;是&lt;em&gt;LTS&lt;/em&gt;版本，但是代码示例将由&lt;em&gt;Python &lt;strong&gt;3&lt;/strong&gt; （ &lt;strong&gt;.5&lt;/strong&gt; ）运行&lt;/em&gt; （我将尽可能使它们与&lt;em&gt;Python 2&lt;/em&gt;兼容；并且，属于我要发布的&lt;em&gt;Python&lt;/em&gt;来自&lt;strong&gt;v3.5.4-&lt;/strong&gt;除非另有说明）。 结果与问题中的另一个关键字相关：&amp;ldquo; &lt;em&gt;将它们添加到&lt;strong&gt;列表中&lt;/strong&gt;&lt;/em&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="e939fe6c637dd49301b395a0239bfffae8c70695" translate="yes" xml:space="preserve">
          <source>When there are several established ways to do something, none of them is good for all cases.</source>
          <target state="translated">当有几种既定的方法时,没有一种是适合所有情况的。</target>
        </trans-unit>
        <trans-unit id="ec6f24c79a6fa64dcca56cd1eb077390119500b5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list comprehension&lt;/code&gt;:</source>
          <target state="translated">具有 &lt;code&gt;list comprehension&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="178f0407f497a7401fd2c33476574fa704ae8d90" translate="yes" xml:space="preserve">
          <source>With this function you can create a txt file that will have the name of a type of file that you look for (ex. pngfile.txt) with all the full path of all the files of that type. It can be useful sometimes, I think.</source>
          <target state="translated">有了这个功能,你可以创建一个txt文件,其中包含你要找的文件类型的名称(例如:pngfile.txt),并包含该类型文件的全部路径。我想,这有时会很有用。</target>
        </trans-unit>
        <trans-unit id="76d707d20ae5e178466dfff371974f199051dc34" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;listdir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)</source>
          <target state="translated">[Python 3]：操作系统。 &lt;strong&gt;listdir&lt;/strong&gt; （ &lt;em&gt;path ='。'&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="ea7a34811c2492dcaa209ef15806e5b61c87b16f" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;walk&lt;/strong&gt;(&lt;em&gt;top, topdown=True, onerror=None, followlinks=False&lt;/em&gt;)</source>
          <target state="translated">[Python 3]：操作系统。 &lt;strong&gt;步行&lt;/strong&gt; （ &lt;em&gt;top，topdown = True，onerror = None，followlinks = False&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="d6aff5adcd46c5e905b3a5b17eeff0904a88b4c8" translate="yes" xml:space="preserve">
          <source>or absolute pathnames:</source>
          <target state="translated">或绝对路径名。</target>
        </trans-unit>
        <trans-unit id="3cb11137ad88c943901b8f5bc845b94149d59c9a" translate="yes" xml:space="preserve">
          <source>or you could use &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.walk&quot;&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; which will &lt;strong&gt;yield two lists&lt;/strong&gt; for each directory it visits - splitting into &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;dirs&lt;/strong&gt; for you. If you only want the top directory you can just break the first time it yields</source>
          <target state="translated">或者，您可以使用&lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.walk&quot;&gt; &lt;code&gt;os.walk()&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; ，它将为它访问的每个目录生成&lt;strong&gt;两个列表&lt;/strong&gt; -为您拆分为&lt;strong&gt;文件&lt;/strong&gt;和&lt;strong&gt;目录&lt;/strong&gt; 。 如果只需要顶层目录，则可以在第一次生成目录时中断</target>
        </trans-unit>
        <trans-unit id="1029d67644815d428f554e390aa966d57a0b29b8" translate="yes" xml:space="preserve">
          <source>output</source>
          <target state="translated">output</target>
        </trans-unit>
        <trans-unit id="083e33cc5cdd52fb9d26ae0f284ca1be68944566" translate="yes" xml:space="preserve">
          <source>platform (&lt;em&gt;Nix&lt;/em&gt;, &lt;em&gt;Win&lt;/em&gt;, )</source>
          <target state="translated">平台（ &lt;em&gt;Nix&lt;/em&gt; ， &lt;em&gt;Win&lt;/em&gt; ，）</target>
        </trans-unit>
        <trans-unit id="f4f6e2f05a83d0b597bd40911d336686420756c7" translate="yes" xml:space="preserve">
          <source>will return a list of all files and directories in &quot;somedirectory&quot;.</source>
          <target state="translated">将返回 &quot;somedirectory &quot;中所有文件和目录的列表。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
