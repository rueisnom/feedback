<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3207219">
    <body>
      <group id="3207219">
        <trans-unit id="77059d38755dc28322fe681063b9a72b79deb724" translate="yes" xml:space="preserve">
          <source>(New) Find all files and open them with tkinter GUI</source>
          <target state="translated">(New) 모든 파일을 찾아 tkinter GUI로 열기</target>
        </trans-unit>
        <trans-unit id="67cd3a55333326a6b15634b60cb3b5069796d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt;&lt;code&gt;os.scandir()&lt;/code&gt;&lt;/a&gt;: &lt;em&gt;New in version 3.5.&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt; &lt;code&gt;os.scandir()&lt;/code&gt; &lt;/a&gt; : &lt;em&gt;버전 3.5의 새로운 기능.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76e31b0052e0928376cce7dbc235ffa3927a14ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt;: &lt;em&gt;New in version 3.4.&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt; : &lt;em&gt;버전 3.4의 새로운 기능.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0dfff635d12269d90056ce5a01710406836b3e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]: OPENDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]: READDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]: CLOSEDIR(3)&lt;/a&gt; via &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]: ctypes - A foreign function library for Python&lt;/a&gt; (&lt;em&gt;POSIX&lt;/em&gt; specific)</source>
          <target state="translated">&lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7] : OPENDIR (3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7] : READDIR (3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7] :&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]을&lt;/a&gt; 통한 CLOSEDIR (3) : ctypes-Python 용 외부 함수 라이브러리 ( &lt;em&gt;POSIX&lt;/em&gt; 특정)</target>
        </trans-unit>
        <trans-unit id="55ff2d95daa24f77a476a59c1d9797a78d9a2821" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html&quot;&gt;[ActiveState.Docs]: win32file.FindFilesW&lt;/a&gt; (&lt;em&gt;Win&lt;/em&gt; specific)</source>
          <target state="translated">&lt;a href=&quot;https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html&quot;&gt;[ActiveState.Docs] : win32file.FindFilesW&lt;/a&gt; ( &lt;em&gt;Win&lt;/em&gt; 특정)</target>
        </trans-unit>
        <trans-unit id="e1307db6c8784e163a1c98d061a8979c2812cf85" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/2/library/dircache.html#dircache.listdir&quot;&gt;[Python 2]: dircache.listdir(path)&lt;/a&gt; (&lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt; only)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/dircache.html#dircache.listdir&quot;&gt;[파이썬 2] : dircache.listdir (path)&lt;/a&gt; ( &lt;em&gt;파이썬 &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt; 전용)</target>
        </trans-unit>
        <trans-unit id="a80e40355c109f480b5de975f53594fc753ed27d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;ctypes&lt;/a&gt; is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;ctypes&lt;/a&gt; 는 파이썬을위한 외부 함수 라이브러리입니다. C 호환 데이터 형식을 제공하며 DLL 또는 공유 라이브러리에서 함수를 호출 할 수 있습니다. 이 라이브러리를 순수한 파이썬으로 감싸는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="170038f3a75b60c3f752b7b295615e5298dcc157" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3]: glob.&lt;strong&gt;glob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt; (&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3]: glob.&lt;strong&gt;iglob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[파이썬 3] : glob.&lt;/a&gt; &lt;strong&gt;glob&lt;/strong&gt; ( &lt;em&gt;pathname, *, 재귀 = False&lt;/em&gt; ) ( &lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.glob&quot;&gt;[Python 3] : glob. &lt;strong&gt;iglob&lt;/strong&gt; ( &lt;em&gt;pathname, *, 재귀 = False&lt;/em&gt; )&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f1ba420698c81c401d7a71e0b321fd9a1eff7ba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]: os.&lt;strong&gt;scandir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; (&lt;em&gt;Python &lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]: scandir&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[파이썬 3] : os.&lt;/a&gt; &lt;strong&gt;scandir&lt;/strong&gt; ( &lt;em&gt;path = '.'&lt;/em&gt; ) ( &lt;em&gt;Python &lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt; +, 백 포트 : &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI] : scandir&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="25214d61526c1beabb3be3a8daf83746c6c5bb57" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;[Python 3]: class pathlib.&lt;strong&gt;Path&lt;/strong&gt;(&lt;em&gt;*pathsegments&lt;/em&gt;)&lt;/a&gt; (&lt;em&gt;Python &lt;strong&gt;3.4&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/pathlib2&quot;&gt;[PyPI]: pathlib2&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;[파이썬 3] : class pathlib.&lt;/a&gt; &lt;strong&gt;경로&lt;/strong&gt; ( &lt;em&gt;* pathsegments&lt;/em&gt; ) ( &lt;em&gt;Python &lt;strong&gt;3.4&lt;/strong&gt;&lt;/em&gt; +, 백 포트 : &lt;a href=&quot;https://pypi.org/project/pathlib2&quot;&gt;[PyPI] : pathlib2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="00bfac63f5953b8d7d3175a2be4c2cb1af98f031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; extending the previous code</source>
          <target state="translated">이전 코드를 확장하는 &lt;code&gt;glob&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4329bf1dd0de2a9c7ce95cb896a2ca69f2fca31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; with a function</source>
          <target state="translated">기능을 가진 &lt;code&gt;glob&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f41c772121c3b9dac96db970710ae0e9758db1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; with list comprehension</source>
          <target state="translated">리스트 이해력이있는 &lt;code&gt;glob&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dcbfe0b43a64a22dce191e3e967d279181bfe07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next(os.walk('.'))&lt;/code&gt; and &lt;code&gt;os.path.join('dir', 'file')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;next(os.walk('.'))&lt;/code&gt; 및 &lt;code&gt;os.path.join('dir', 'file')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec118b3d19b3f81eadfd29c639432a32582c075e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next(os.walk('F:\\')&lt;/code&gt; - get the full path - list comprehension</source>
          <target state="translated">&lt;code&gt;next(os.walk('F:\\')&lt;/code&gt; -전체 경로 확인-목록 이해</target>
        </trans-unit>
        <trans-unit id="2b1167731ef7f25bc92c2b3982a46a3ed14cc811" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.listdir()&lt;/code&gt; - get only txt files</source>
          <target state="translated">&lt;code&gt;os.listdir()&lt;/code&gt; 파일 만 가져옵니다</target>
        </trans-unit>
        <trans-unit id="e52b734b3e4a4f970785af5ff1bf2c6d6f133377" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.listdir()&lt;/code&gt;: get files in the current directory (Python 2)</source>
          <target state="translated">&lt;code&gt;os.listdir()&lt;/code&gt; : 현재 디렉토리에 파일을 가져옵니다 (Python 2)</target>
        </trans-unit>
        <trans-unit id="a4d501d5911962500c47e2fcc04cafbc207fd782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.listdir&lt;/code&gt; and &lt;code&gt;os.scandir&lt;/code&gt; use &lt;em&gt;opendir&lt;/em&gt; / &lt;em&gt;readdir&lt;/em&gt; / &lt;em&gt;closedir&lt;/em&gt; (&lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]: FindFirstFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]: FindNextFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]: FindClose function&lt;/a&gt;) (via &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;os.listdir&lt;/code&gt; 및 &lt;code&gt;os.scandir&lt;/code&gt; 은 &lt;em&gt;opendir&lt;/em&gt; / &lt;em&gt;readdir&lt;/em&gt; / &lt;em&gt;closedir를 사용합니다&lt;/em&gt; ( &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs] : FindFirstFileW 함수&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs] : FindNextFileW 함수&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs] : FindClose 함수&lt;/a&gt; ) ( &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]&lt;/a&gt; 를 통해) : python / cpython -(마스터) cpython / Modules / posixmodule.c )</target>
        </trans-unit>
        <trans-unit id="911e0e0ce1d9d3f7eadd150f395af1fe2acb2281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.scandir()&lt;/code&gt; from Python 3.5 and greater</source>
          <target state="translated">Python 3.5 &lt;code&gt;os.scandir()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e279c9e348196deece32d5a5d26532642206320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.walk('.')&lt;/code&gt; - current directory</source>
          <target state="translated">&lt;code&gt;os.walk('.')&lt;/code&gt; -현재 디렉토리</target>
        </trans-unit>
        <trans-unit id="2e2eefd877c594ba3c3651f5ba65c863026c498c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.walk&lt;/code&gt; - get full path - all files in sub dirs**</source>
          <target state="translated">&lt;code&gt;os.walk&lt;/code&gt; - 전체 경로 가져 오기-하위 디렉토리의 모든 파일 **</target>
        </trans-unit>
        <trans-unit id="61d2f87c70c7e8c413baa40c3a55d9c085030ce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print full_file_paths&lt;/code&gt; which will print the list:</source>
          <target state="translated">리스트를 인쇄 할 &lt;code&gt;print full_file_paths&lt;/code&gt; 를 출력하십시오 :</target>
        </trans-unit>
        <trans-unit id="5718278766a0afe1d9442f96e1788b8c6b1aa4a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;win32file.FindFilesW&lt;/code&gt; is part of &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions&lt;/a&gt;, which is a &lt;em&gt;Python&lt;/em&gt; wrapper over &lt;em&gt;WINAPI&lt;/em&gt;s</source>
          <target state="translated">&lt;code&gt;win32file.FindFilesW&lt;/code&gt; 는 &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]의&lt;/a&gt; 일부입니다 : mhammond / pywin32-Windows 용 Python (pywin32) Extensions , 이는 &lt;em&gt;WINAPI&lt;/em&gt; 의 &lt;em&gt;Python&lt;/em&gt; 래퍼입니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec2464c59bc77af55917a9107e99a96a64cb299b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;win32file.FindFilesW&lt;/code&gt; uses those (&lt;em&gt;Win&lt;/em&gt; specific) functions as well (via &lt;a href=&quot;https://github.com/mhammond/pywin32/blob/master/win32/src/win32file.i&quot;&gt;[GitHub]: mhammond/pywin32 - (master) pywin32/win32/src/win32file.i&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;win32file.FindFilesW&lt;/code&gt; 는 ( &lt;em&gt;Win&lt;/em&gt; 특정) 기능도 사용합니다 ( &lt;a href=&quot;https://github.com/mhammond/pywin32/blob/master/win32/src/win32file.i&quot;&gt;[GitHub]&lt;/a&gt; 를 통해 : mhammond / pywin32-(마스터) pywin32 / win32 / src / win32file.i )</target>
        </trans-unit>
        <trans-unit id="967369ece668c40d77459a43aa74854d100b236c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://docs.python.org/release/2.6.7/library/dircache.html&quot;&gt;dircache&lt;/a&gt; is  &quot;Deprecated since version 2.6: The dircache module has been removed in Python 3.0.&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://docs.python.org/release/2.6.7/library/dircache.html&quot;&gt;dircache&lt;/a&gt; 는 &quot;버전 2.6부터 사용되지 않습니다 : dircache 모듈은 Python 3.0에서 제거되었습니다.&quot;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95ac707ebadead9c005ea35708f927732b3658f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alternatively, use &lt;code&gt;pathlib.Path()&lt;/code&gt; instead of &lt;code&gt;pathlib.Path(&quot;.&quot;)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;또는 &lt;code&gt;pathlib.Path(&quot;.&quot;)&lt;/code&gt; 대신 &lt;code&gt;pathlib.Path()&lt;/code&gt; 를 사용 하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d169b18dc1029ec7a5a06d6082c7fbbc8a987fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I found glob easier to select the file of the same type or with something in common. Look at the following example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;같은 유형의 파일이나 공통된 파일을 선택하는 것이 더 쉽다는 것을 알았습니다.&lt;/em&gt; &lt;em&gt;다음 예를보십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4dac21df5aa700d6abc10cb8734fe3bf0a3f201" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinuxDirent64&lt;/em&gt; is the &lt;em&gt;ctypes&lt;/em&gt; representation of &lt;em&gt;struct dirent64&lt;/em&gt; from &lt;a href=&quot;http://man7.org/linux/man-pages/man0/dirent.h.0p.html&quot;&gt;[man7]: dirent.h(0P)&lt;/a&gt; (so are the &lt;em&gt;DT_&lt;/em&gt; constants) from my machine: &lt;em&gt;Ubtu 16 x64&lt;/em&gt; (&lt;em&gt;4.10.0-40-generic&lt;/em&gt; and &lt;em&gt;libc6-dev:amd64&lt;/em&gt;). On other flavors/versions, the struct definition might differ, and if so, the &lt;em&gt;ctypes&lt;/em&gt; alias should be updated, otherwise it will yield &lt;strong&gt;Undefined Behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;LinuxDirent64&lt;/em&gt; 는 &lt;a href=&quot;http://man7.org/linux/man-pages/man0/dirent.h.0p.html&quot;&gt;[man7]&lt;/a&gt; 에서 &lt;em&gt;struct dirent64&lt;/em&gt; 의 &lt;em&gt;ctypes&lt;/em&gt; 표현입니다. 내 컴퓨터의 dirent.h (0P) ( &lt;em&gt;DT_ 상수도 마찬가지&lt;/em&gt; 임) : &lt;em&gt;Ubtu 16 x64&lt;/em&gt; ( &lt;em&gt;4.10.0-40-generic&lt;/em&gt; 및 &lt;em&gt;libc6-dev : amd64&lt;/em&gt; ). 다른 특징 / 버전에서는 struct 정의가 다를 수 있으며, 그렇다면 &lt;em&gt;ctypes&lt;/em&gt; 별칭이 업데이트되어야합니다. 그렇지 않으면 &lt;strong&gt;정의되지 않은 동작&lt;/strong&gt; 이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2607498abaee4d65262b0bddee1f3ea8c158fcc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python&lt;/em&gt; version (2, 3, )</source>
          <target state="translated">&lt;em&gt;파이썬&lt;/em&gt; 버전 (2, 3,)</target>
        </trans-unit>
        <trans-unit id="b9a7ecb806c918f13af940395a94bc6be131239d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;_get_dir_content&lt;/em&gt; (from point &lt;strong&gt;&lt;em&gt;#1.&lt;/em&gt;&lt;/strong&gt;) can be implemented using any of these approaches (some will require more work and some less)</source>
          <target state="translated">&lt;em&gt;_get_dir_content&lt;/em&gt; (포인트 &lt;strong&gt;&lt;em&gt;# 1에서&lt;/em&gt;&lt;/strong&gt; )는 이러한 접근 방식 중 하나를 사용하여 구현할 수 있습니다 (일부는 더 많은 작업이 필요하고 더 적은 작업이 필요함)</target>
        </trans-unit>
        <trans-unit id="51c4642373e690d325c7ad82b464877082b573af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;code_ctypes.py&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;code_ctypes.py&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="4ce19a6e839999d658d2189b0e2e6cfd1a994d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; will get you everything that's in a directory - &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;directories&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; 은 디렉토리 &lt;strong&gt;파일&lt;/strong&gt; 과 &lt;strong&gt;디렉토리&lt;/strong&gt; 에있는 모든 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6908731fb32533dc511dc58bc31f693b16e0a6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Changed in version 3.5&lt;/em&gt;&lt;/strong&gt;: Support for recursive globs using &amp;ldquo;&lt;code&gt;**&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;버전 3.5으로 변경&lt;/em&gt;&lt;/strong&gt; :&amp;ldquo; &lt;code&gt;**&lt;/code&gt; &amp;rdquo;를 사용한 재귀 글로브 지원.</target>
        </trans-unit>
        <trans-unit id="80c9eeb957a9dcaf420ae2704e8bae60f417cce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting Full File Paths From a Directory and All Its Subdirectories&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;디렉토리 및 모든 서브 디렉토리에서 전체 파일 경로 가져 오기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed3b34369d6c831eda3203fea591c57c95c623c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nota bene!&lt;/strong&gt; Since recursion is used, I must mention that I did some tests on my laptop (&lt;em&gt;Win 10 x64&lt;/em&gt;), totally unrelated to this problem, and when the recursion level was reaching values somewhere in the &lt;em&gt;(990 .. 1000)&lt;/em&gt; range (&lt;em&gt;recursionlimit&lt;/em&gt; - 1000 (default)), I got &lt;em&gt;StackOverflow&lt;/em&gt; :). If the directory tree exceeds that limit (I am not an &lt;em&gt;FS&lt;/em&gt; expert, so I don't know if that is even possible), that could be a problem.</source>
          <target state="translated">&lt;strong&gt;노 타네!&lt;/strong&gt; 재귀가 사용되기 때문에이 문제와 전혀 관련이 없으며 내 노트북 ​​수준 ( &lt;em&gt;Win 10 x64&lt;/em&gt; )에서 일부 테스트를 수행했으며 재귀 수준이 &lt;em&gt;(990 .. 1000)&lt;/em&gt; 범위 ( &lt;em&gt;recursionlimit&lt;/em&gt; -1000 &lt;em&gt;)의&lt;/em&gt; 어딘가에 도달했을 때 언급해야합니다 &lt;em&gt;.&lt;/em&gt; (기본값)), &lt;em&gt;StackOverflow가 있습니다&lt;/em&gt; :). 디렉토리 트리가 해당 한계를 초과하면 ( &lt;em&gt;FS&lt;/em&gt; 전문가가 아니므로 가능한지 모르겠습니다) 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="226c6d195092d25e48f4779200988ceb25b71b01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="dd4fa00e1e26bc6e3309dc337769a5de63e91abb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a list of absolute filepaths, does not recurse into subdirectories&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;절대 파일 경로 목록을 리턴하면 하위 디렉토리로 재귀하지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa5e2e67d3cc1bef43276434c369d329c225d671" translate="yes" xml:space="preserve">
          <source>A more elaborate example (&lt;em&gt;code_os_listdir.py&lt;/em&gt;):</source>
          <target state="translated">보다 정교한 예 ( &lt;em&gt;code_os_listdir.py&lt;/em&gt; ) :</target>
        </trans-unit>
        <trans-unit id="8ed1a1caaa3d9b2ea4444233183eb102f593b692" translate="yes" xml:space="preserve">
          <source>A one-line solution to get &lt;strong&gt;only list of files&lt;/strong&gt; (no subdirectories):</source>
          <target state="translated">&lt;strong&gt;파일 목록 만&lt;/strong&gt; 가져 오는 한 줄 솔루션 (하위 디렉토리 없음) :</target>
        </trans-unit>
        <trans-unit id="3f7baacb87cbc70334d95d8dad8015e84d265360" translate="yes" xml:space="preserve">
          <source>A script to make order in your computer finding all files of a type (default: pptx) and copying them in a new folder.</source>
          <target state="translated">컴퓨터에서 형식을 가진 모든 파일 (기본값 : pptx)을 찾아서 새 폴더에 복사하는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="18a031b8608ba4b689ddd883ad50ff533b9c06ea" translate="yes" xml:space="preserve">
          <source>A wise teacher told me once that:</source>
          <target state="translated">현명한 선생님이 한 번 말해 주셨습니다.</target>
        </trans-unit>
        <trans-unit id="265800892490fb1601fd167bbb05c9a077f6f925" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://www.python.org/dev/peps/pep-0428/&quot;&gt;PEP 428&lt;/a&gt;, the aim of the &lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt; library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them.</source>
          <target state="translated">&lt;a href=&quot;http://www.python.org/dev/peps/pep-0428/&quot;&gt;PEP 428&lt;/a&gt; 에 따르면 &lt;a href=&quot;http://docs.python.org/3/library/pathlib.html&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt; 라이브러리의 목적은 파일 시스템 경로와 사용자가 수행하는 일반적인 작업을 처리하기위한 간단한 클래스 계층을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe1b805fa41865e2a141d056f31e274b81ddcf59" translate="yes" xml:space="preserve">
          <source>All &lt;strong&gt;direct&lt;/strong&gt; (or level 1) descendants &lt;strong&gt;only&lt;/strong&gt;</source>
          <target state="translated">모든 &lt;strong&gt;직계&lt;/strong&gt; (또는 1 급) 자손 &lt;strong&gt;만&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b0dd3dc06a999c149acccf660c3c3b5e0948936" translate="yes" xml:space="preserve">
          <source>All descendants in the whole directory tree (including the ones in sub-directories)</source>
          <target state="translated">전체 디렉토리 트리의 모든 하위 항목 (하위 디렉토리의 하위 항목 포함)</target>
        </trans-unit>
        <trans-unit id="795b001e462ca70c4701a577b0fd48553b937462" translate="yes" xml:space="preserve">
          <source>All the file of C:\ in one text file</source>
          <target state="translated">하나의 텍스트 파일에있는 C : \의 모든 파일</target>
        </trans-unit>
        <trans-unit id="4f60f646333a3fcbbb5abc8a20d45f9d6a825c64" translate="yes" xml:space="preserve">
          <source>Allows advanced filtering based on name (due to the wildcard)</source>
          <target state="translated">와일드 카드로 인해 이름을 기준으로 고급 필터링 허용</target>
        </trans-unit>
        <trans-unit id="c76c29bde082ce11b0bea8f181c56b87461dd256" translate="yes" xml:space="preserve">
          <source>Although there's a clear differentiation between &lt;em&gt;file&lt;/em&gt; and &lt;em&gt;directory&lt;/em&gt; terms in the question text, some may argue that directories are actually special files</source>
          <target state="translated">질문 텍스트에서 &lt;em&gt;파일&lt;/em&gt; 과 &lt;em&gt;디렉토리&lt;/em&gt; 용어가 분명히 다르지만 일부는 디렉토리가 실제로 특수 파일이라고 주장 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f9a1b06084ad18eacff39d734675db236d0e924a" translate="yes" xml:space="preserve">
          <source>Another great example that works perfectly across platforms and does something a bit different:</source>
          <target state="translated">플랫폼에서 완벽하게 작동하고 약간 다른 기능을 수행하는 또 다른 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="9c74cca7bc2607ab72c18ce116e088a6a731b392" translate="yes" xml:space="preserve">
          <source>Another very readable variant for Python 3.4+ is using pathlib.Path.glob:</source>
          <target state="translated">Python 3.4+의 또 다른 읽기 쉬운 변형은 pathlib.Path.glob를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b0828f2db598ba89be096f4660295ec0a22850d" translate="yes" xml:space="preserve">
          <source>As examples:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="6e64b0571c3fdb7731788760b1d43cfee74e79de" translate="yes" xml:space="preserve">
          <source>As you noticed, you don't have the full path of the file in the code above. If you need to have the absolute path, you can use another function of the &lt;code&gt;os.path&lt;/code&gt; module called &lt;code&gt;_getfullpathname&lt;/code&gt;, putting the file that you get from &lt;code&gt;os.listdir()&lt;/code&gt; as an argument. There are other ways to have the full path, as we will check later (I replaced, as suggested by mexmex, _getfullpathname with &lt;code&gt;abspath&lt;/code&gt;).</source>
          <target state="translated">알다시피, 위의 코드에는 파일의 전체 경로가 없습니다. 절대 경로가 필요한 경우 &lt;code&gt;os.listdir()&lt;/code&gt; 에서 가져온 파일을 인수로 사용하여 &lt;code&gt;_getfullpathname&lt;/code&gt; 이라는 &lt;code&gt;os.path&lt;/code&gt; 모듈의 다른 함수를 사용할 수 있습니다. 나중에 확인할 것처럼 전체 경로를 갖는 다른 방법이 있습니다 (mexmex에서 제안한대로 _getfullpathname을 abspath로 &lt;code&gt;abspath&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1fe60df39e99b31631ea38ad2e4ff59ea3443b7" translate="yes" xml:space="preserve">
          <source>But as other people pointed out in the comments, &lt;code&gt;glob()&lt;/code&gt; can get tripped up over inconsistent slash directions. To help with that, I suggest you use the &lt;code&gt;join()&lt;/code&gt; and &lt;code&gt;expanduser()&lt;/code&gt; functions in the &lt;code&gt;os.path&lt;/code&gt; module, and perhaps the &lt;code&gt;getcwd()&lt;/code&gt; function in the &lt;code&gt;os&lt;/code&gt; module, as well.</source>
          <target state="translated">그러나 다른 사람들이 의견에서 지적했듯이 &lt;code&gt;glob()&lt;/code&gt; 는 일관되지 않은 슬래시 방향으로 넘어 질 수 있습니다. 이를 돕기 위해 &lt;code&gt;os.path&lt;/code&gt; 모듈에서 &lt;code&gt;join()&lt;/code&gt; 및 &lt;code&gt;expanduser()&lt;/code&gt; &lt;code&gt;getcwd()&lt;/code&gt; 함수를 사용하고 &lt;code&gt;os&lt;/code&gt; 모듈에서 getcwd () 함수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0729ebe50ef5a012a64664a3c418b8dca0914fd5" translate="yes" xml:space="preserve">
          <source>But it's also more flexible (and offers more functionality), more &lt;em&gt;Python&lt;/em&gt;ic (and in some cases, faster)</source>
          <target state="translated">그러나 더 유연하고 더 많은 기능을 제공하며 더 많은 &lt;em&gt;Python&lt;/em&gt; ic (일부 경우 더 빠름)</target>
        </trans-unit>
        <trans-unit id="2c42e1c593cf111f9e0d87e8ab97c21021343c62" translate="yes" xml:space="preserve">
          <source>But, according to &lt;a href=&quot;https://github.com/python/cpython/blob/2.7/Lib/dircache.py&quot;&gt;[GitHub]: python/cpython - (2.7) cpython/Lib/dircache.py&lt;/a&gt;, it's just a (thin) wrapper over &lt;code&gt;os.listdir&lt;/code&gt; with caching</source>
          <target state="translated">그러나 &lt;a href=&quot;https://github.com/python/cpython/blob/2.7/Lib/dircache.py&quot;&gt;[GitHub] : python / cpython-(2.7) cpython / Lib / dircache.py에 따르면&lt;/a&gt; , 캐싱을 사용하는 &lt;code&gt;os.listdir&lt;/code&gt; 에 대한 (얇은) ​​래퍼 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="ca6363bb22ea7785526fe7ee19319ed341d533c7" translate="yes" xml:space="preserve">
          <source>Code is meant to be portable (except places that target a specific area - which are marked) or cross:</source>
          <target state="translated">코드는 휴대 가능해야합니다 (표시된 특정 영역을 대상으로하는 장소는 제외).</target>
        </trans-unit>
        <trans-unit id="14112f5c3007f7f556cbb25d16858a3f899f203a" translate="yes" xml:space="preserve">
          <source>Everything is doable on &lt;em&gt;Win&lt;/em&gt; as well, the data (libraries, functions, structs, constants, ...) differ</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt; 에서도 모든 것이 가능하며 데이터 (라이브러리, 함수, 구조체, 상수 등)는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a834153c43f41ea14afdf02c080d7570ce816614" translate="yes" xml:space="preserve">
          <source>Everything is done using another technology</source>
          <target state="translated">다른 기술을 사용하여 모든 것이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="44f628d265c86d2e9a4860f7ae47e80830fd8645" translate="yes" xml:space="preserve">
          <source>Ex. 1: How many files are there in the subdirectories?</source>
          <target state="translated">전의. 1 : 서브 디렉토리에 몇 개의 파일이 있습니까?</target>
        </trans-unit>
        <trans-unit id="b904f62fed90570ad0db161a005ad7c414f4b009" translate="yes" xml:space="preserve">
          <source>Ex. 3: How to get all the files in a txt file</source>
          <target state="translated">전의. 3 : txt 파일의 모든 파일을 가져 오는 방법</target>
        </trans-unit>
        <trans-unit id="01735532fe2614938285a1b062e4f88f2656f6a0" translate="yes" xml:space="preserve">
          <source>Ex.2: How to copy all files from a directory to another?</source>
          <target state="translated">예 2 : 디렉토리에서 다른 파일로 모든 파일을 복사하는 방법?</target>
        </trans-unit>
        <trans-unit id="fc0677d0f3b0f61b8c1fc76c570287407e2d6097" translate="yes" xml:space="preserve">
          <source>Example: txt with all the files of an hard drive</source>
          <target state="translated">예 : 하드 드라이브의 모든 파일이 포함 된 txt</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="8a8b976b0df2bf4d588554936815b3b855407347" translate="yes" xml:space="preserve">
          <source>Filtering (&lt;code&gt;grep&lt;/code&gt; / &lt;code&gt;findstr&lt;/code&gt;) or output formatting could be done on both sides, but I'm not going to insist on it. Also, I deliberately used &lt;code&gt;os.system&lt;/code&gt; instead of &lt;code&gt;subprocess.Popen&lt;/code&gt;.</source>
          <target state="translated">필터링 ( &lt;code&gt;grep&lt;/code&gt; / &lt;code&gt;findstr&lt;/code&gt; ) 또는 출력 형식은 양면에서 수행 할 수 있지만 고집하지는 않을 것입니다. 또한 &lt;code&gt;subprocess.Popen&lt;/code&gt; 대신 &lt;code&gt;os.system&lt;/code&gt; 을 의도적으로 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="69f5a9e089e418b3efecf9214fb21040f3b48494" translate="yes" xml:space="preserve">
          <source>Following, are simple methods to retrieve only files in the current directory, using &lt;code&gt;os&lt;/code&gt;  and the &lt;code&gt;listdir()&lt;/code&gt; function, in Python 3.  Further exploration, will demonstrate how to return folders in the directory, but you will not have the file in the subdirectory, for that you can use walk - discussed later).</source>
          <target state="translated">다음은 Python 3에서 &lt;code&gt;os&lt;/code&gt; 및 &lt;code&gt;listdir()&lt;/code&gt; 함수를 사용하여 현재 디렉토리에서 파일 만 검색하는 간단한 방법입니다. 추가 탐색에서는 디렉토리에서 폴더를 리턴하는 방법을 보여 주지만 서브 디렉토리에는 파일이 없습니다. , 나중에 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e773a2ec04cc7a36b772553f62d5753f78393dcd" translate="yes" xml:space="preserve">
          <source>For each implementation there are two functions:</source>
          <target state="translated">각 구현에는 두 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f7f653d6c2441aac3e3ed746a48f87664bbd31" translate="yes" xml:space="preserve">
          <source>For greater results, you can use &lt;code&gt;listdir()&lt;/code&gt; method of the &lt;code&gt;os&lt;/code&gt; module along with a generator (a generator is a powerful iterator that keeps its state, remember?). The following code works fine with both versions: Python 2 and Python 3.</source>
          <target state="translated">더 큰 결과를 얻으려면 &lt;code&gt;os&lt;/code&gt; 모듈의 &lt;code&gt;listdir()&lt;/code&gt; 메소드를 생성기와 함께 사용할 수 있습니다 ( 생성기는 상태를 유지하는 강력한 반복기입니다. 기억하십니까?). 다음 코드는 Python 2와 Python 3 모두에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="83916e29a54dc89e3b07e97c71360ffb35c763e2" translate="yes" xml:space="preserve">
          <source>For large trees (especially if &lt;em&gt;recursive&lt;/em&gt; is on), &lt;em&gt;iglob&lt;/em&gt; is preferred</source>
          <target state="translated">큰 나무의 경우 (특히 &lt;em&gt;재귀&lt;/em&gt; 가 켜져있는 경우) &lt;em&gt;이글 롭&lt;/em&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="aa300c01afab3863769d5e47da2d31fbf81c8768" translate="yes" xml:space="preserve">
          <source>For python2:
pip install rglob</source>
          <target state="translated">python2의 경우 : pip install rglob</target>
        </trans-unit>
        <trans-unit id="d59fce7ea7058689b5d814b70a95463df2a403ec" translate="yes" xml:space="preserve">
          <source>Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory &lt;em&gt;top&lt;/em&gt; (including &lt;em&gt;top&lt;/em&gt; itself), it yields a 3-tuple (&lt;code&gt;dirpath&lt;/code&gt;, &lt;code&gt;dirnames&lt;/code&gt;, &lt;code&gt;filenames&lt;/code&gt;).</source>
          <target state="translated">트리를 하향식 또는 상향식으로 이동하여 디렉토리 트리에서 파일 이름을 생성하십시오. 디렉토리 &lt;em&gt;상단을&lt;/em&gt; 루트로하는 트리의 각 디렉토리 ( &lt;em&gt;상단&lt;/em&gt; 자체 포함)에 대해 3 개의 튜플 ( &lt;code&gt;dirpath&lt;/code&gt; , &lt;code&gt;dirnames&lt;/code&gt; , &lt;code&gt;filenames&lt;/code&gt; )이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="163ba5c6d0c0bfc2725c96022859ecdd60969671" translate="yes" xml:space="preserve">
          <source>Get a list of files with Python 2 and 3</source>
          <target state="translated">Python 2 및 3으로 파일 목록 가져 오기</target>
        </trans-unit>
        <trans-unit id="6257a890b65001f1ef7d31cb16b75441121bed4a" translate="yes" xml:space="preserve">
          <source>Get all and only files with os.walk</source>
          <target state="translated">os.walk로 모든 파일 만 가져 오기</target>
        </trans-unit>
        <trans-unit id="c639fadedf5f863ca84f4bfb3b55705f569f214d" translate="yes" xml:space="preserve">
          <source>Get all the subdir names with &lt;code&gt;walk&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;walk&lt;/code&gt; 모든 하위 디렉토리 이름 가져 오기</target>
        </trans-unit>
        <trans-unit id="e536a5ca14a01f5cf5fc68d326659f5a972bbf1e" translate="yes" xml:space="preserve">
          <source>Get files of a particular subdirectory with &lt;code&gt;os.listdir()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os.listdir()&lt;/code&gt; 을 사용하여 특정 하위 디렉토리의 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f62d1e5b33944f43de78cff30f836d727879227a" translate="yes" xml:space="preserve">
          <source>Get files: &lt;code&gt;os.listdir()&lt;/code&gt; in a particular directory (Python 2 and 3)</source>
          <target state="translated">파일 가져 &lt;code&gt;os.listdir()&lt;/code&gt; : 특정 디렉토리 (Python 2 및 3)에 os.listdir ( )</target>
        </trans-unit>
        <trans-unit id="66320026929e9da850bcd144e598ddc44b848310" translate="yes" xml:space="preserve">
          <source>Get only directories with next and walk in a directory</source>
          <target state="translated">다음 디렉토리 만 가져 와서 디렉토리로 이동</target>
        </trans-unit>
        <trans-unit id="c00678ff9f6bba9c2717d09eadc7b1f9850745a5" translate="yes" xml:space="preserve">
          <source>Get only files with next and walk in a directory</source>
          <target state="translated">다음 파일 만 가져와 디렉토리로 이동</target>
        </trans-unit>
        <trans-unit id="75c7b090b484f4acebe7677b04b66ec377f1a94c" translate="yes" xml:space="preserve">
          <source>Get the full path name of a type of file into all subdirectories with &lt;code&gt;walk&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;walk&lt;/code&gt; 로 모든 하위 디렉토리에 파일 유형의 전체 경로 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c08178a1ecc2f8cfa76124569230327f5915fa27" translate="yes" xml:space="preserve">
          <source>Getting the full path name with &lt;code&gt;os.path.abspath&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os.path.abspath&lt;/code&gt; 로 전체 경로 이름 얻기</target>
        </trans-unit>
        <trans-unit id="1265e3f180b7b368ca2800ec8fdf7e6c187619f8" translate="yes" xml:space="preserve">
          <source>Here I use a recursive structure.</source>
          <target state="translated">여기서는 재귀 구조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="00ef9b46e5f4c780b426f0c720644fad71347af7" translate="yes" xml:space="preserve">
          <source>Here's a code:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a54a06c1c610aa488919f6dc7fc05ce2c447996d" translate="yes" xml:space="preserve">
          <source>Here's my general-purpose function for this.  It returns a list of file paths rather than filenames since I found that to be more useful.  It has a few optional arguments that make it versatile.  For instance, I often use it with arguments like &lt;code&gt;pattern='*.txt'&lt;/code&gt; or &lt;code&gt;subfolders=True&lt;/code&gt;.</source>
          <target state="translated">여기 내 범용 기능이 있습니다. 더 유용하다는 것을 알았으므로 파일 이름 대신 파일 경로 목록을 반환합니다. 다목적 성을 제공하는 몇 가지 선택적 인수가 있습니다. 예를 들어, 종종 &lt;code&gt;pattern='*.txt'&lt;/code&gt; 또는 &lt;code&gt;subfolders=True&lt;/code&gt; 와 같은 인수와 함께 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c9271b1ddd962b6f47925cd53436434c79ece0b6" translate="yes" xml:space="preserve">
          <source>Hope these examples help you see the power of a few of the functions you can find in the standard Python library modules.</source>
          <target state="translated">이 예제들이 표준 파이썬 라이브러리 모듈에서 찾을 수있는 몇 가지 함수의 힘을 볼 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="b729e7cb29089e1d1996b3976225d3674a6c6592" translate="yes" xml:space="preserve">
          <source>How can I list all files of a directory in Python and add them to a &lt;code&gt;list&lt;/code&gt;?</source>
          <target state="translated">파이썬에서 디렉토리의 모든 파일을 &lt;code&gt;list&lt;/code&gt; 하고 목록에 추가하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="c3b2884f2713aaea630efe656daa4c05252175dc" translate="yes" xml:space="preserve">
          <source>How do I list all files of a directory</source>
          <target state="translated">디렉토리의 모든 파일을 나열하는 방법</target>
        </trans-unit>
        <trans-unit id="e00653909a179a310baee836b27cd1476870a6e6" translate="yes" xml:space="preserve">
          <source>How to get all the files (and directories) in the current directory (Python 3)</source>
          <target state="translated">현재 디렉토리의 모든 파일 및 디렉토리를 얻는 방법 (Python 3)</target>
        </trans-unit>
        <trans-unit id="fd6af8b0eb49675d34e8d60ce4056ca2c1f720f7" translate="yes" xml:space="preserve">
          <source>How to write a file with all paths in a folder of a type</source>
          <target state="translated">유형의 폴더에 모든 경로를 가진 파일을 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="794d18e6fd0010efc6f9a94b2d73107816f6daf8" translate="yes" xml:space="preserve">
          <source>I consider it more like a lame workaround (&lt;em&gt;gainarie&lt;/em&gt;), as the action per se is performed from &lt;em&gt;shell&lt;/em&gt; (&lt;em&gt;cmd&lt;/em&gt; in this case), and thus doesn't have anything to do with &lt;em&gt;Python&lt;/em&gt;.</source>
          <target state="translated">나는 액션 자체가 &lt;em&gt;쉘&lt;/em&gt; (이 경우 &lt;em&gt;cmd)&lt;/em&gt; 에서 수행되므로 &lt;em&gt;Python&lt;/em&gt; 과 관련이 없으므로 절름발이 해결 방법 ( &lt;em&gt;gainarie&lt;/em&gt; )과 같이 생각합니다.</target>
        </trans-unit>
        <trans-unit id="059dffa5982f14f193e723dafe03b7bef365a77f" translate="yes" xml:space="preserve">
          <source>I find this very useful to find stuff in many directories, and it helped me find a file about which I didn't remember the name:</source>
          <target state="translated">많은 디렉토리에서 물건을 찾는 데 매우 유용하며 이름을 기억하지 못하는 파일을 찾는 데 도움이되었습니다.</target>
        </trans-unit>
        <trans-unit id="88e1cbd9dfb68f6906eee88c036d857911cb35e8" translate="yes" xml:space="preserve">
          <source>I just wanted to add in this 2019 a little app to search for all files in a dir and be able to open them by doubleclicking on the name of the file in the list.</source>
          <target state="translated">나는이 2019 년에 디렉토리에있는 모든 파일을 검색하고 목록에서 파일 이름을 두 번 클릭하여 열 수있는 작은 응용 프로그램을 추가하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="8d5e9a5d82d50a1d89c5b7978729e29f78cb73f6" translate="yes" xml:space="preserve">
          <source>I must also mention that I didn't try to increase &lt;em&gt;recursionlimit&lt;/em&gt; because I have no experience in the area (how much can I increase it before having to also increase the stack at &lt;em&gt;OS&lt;/em&gt; level), but in theory there will always be the possibility for failure, if the dir depth is larger than the highest possible &lt;em&gt;recursionlimit&lt;/em&gt; (on that machine)</source>
          <target state="translated">또한 영역에 대한 경험이 없기 때문에 &lt;em&gt;재귀 제한&lt;/em&gt; 을 늘리지 않았다고 언급해야합니다 ( &lt;em&gt;OS&lt;/em&gt; 수준에서 스택을 늘리기 전에 얼마나 많이 늘릴 수 있는지). 그러나 이론적으로는 항상 가능성이 있습니다. dir 깊이가 가능한 최대 &lt;em&gt;재귀 한계&lt;/em&gt; (해당 머신에서)보다 큰 경우 실패</target>
        </trans-unit>
        <trans-unit id="29d4b69808fadc3012ed98af41b908d9f5790171" translate="yes" xml:space="preserve">
          <source>I prefer using the &lt;a href=&quot;https://docs.python.org/library/glob.html&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; module, as it does pattern matching and expansion.</source>
          <target state="translated">패턴 일치 및 확장을 수행하므로 &lt;a href=&quot;https://docs.python.org/library/glob.html&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7252a35f48c90033d98d1297755bdce37ce77d37" translate="yes" xml:space="preserve">
          <source>I really liked &lt;a href=&quot;https://stackoverflow.com/a/3215392/901641&quot;&gt;adamk's answer&lt;/a&gt;, suggesting that you use &lt;code&gt;glob()&lt;/code&gt;, from the module of the same name. This allows you to have pattern matching with &lt;code&gt;*&lt;/code&gt;s.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/3215392/901641&quot;&gt;adamk의 답변이&lt;/a&gt; 정말 마음에 들었 습니다 . 동일한 이름의 모듈에서 &lt;code&gt;glob()&lt;/code&gt; 을 사용하는 것이 좋습니다. 이를 통해 &lt;code&gt;*&lt;/code&gt; s와 패턴을 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd9cb8b94d7a0c43d11c42336cf3c11bc88d35a" translate="yes" xml:space="preserve">
          <source>I will provide a sample one liner where sourcepath and file type can be provided as input. The code returns a list of filenames with csv extension. Use &lt;em&gt;.&lt;/em&gt; in case all files needs to be returned. This will also recursively scans the subdirectories.</source>
          <target state="translated">소스 경로 및 파일 유형을 입력으로 제공 할 수있는 샘플 하나의 라이너를 제공합니다. 이 코드는 csv 확장자를 가진 파일 이름 목록을 반환합니다. 사용하십시오 &lt;em&gt;.&lt;/em&gt; 모든 파일을 반환해야하는 경우 또한 서브 디렉토리를 재귀 적으로 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="1ca5a4cfabdcec4ef79ccc257fe2ed9a1b431600" translate="yes" xml:space="preserve">
          <source>I will thus add a solution for a &lt;strong&gt;subset&lt;/strong&gt; of the problem: quite often, we only want to check whether a file matches a start string and an end string, without going into subdirectories. We would thus like a function that returns a list of filenames, like:</source>
          <target state="translated">따라서 문제의 &lt;strong&gt;하위 집합&lt;/strong&gt; 에 대한 해결책을 추가 할 것입니다. 우리는 파일이 하위 디렉토리로 이동하지 않고 시작 문자열과 끝 문자열과 일치하는지 여부 만 확인하려고합니다. 따라서 다음과 같이 파일 이름 목록을 반환하는 함수를 원합니다.</target>
        </trans-unit>
        <trans-unit id="5a165b3cd12a8d0d4f0217514b1e68179cc8bf55" translate="yes" xml:space="preserve">
          <source>If I should need the absolute path of the files:</source>
          <target state="translated">파일의 절대 경로가 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="ed52a277b510cfd0dcd6fa8f392432a26551de26" translate="yes" xml:space="preserve">
          <source>If you are looking for a Python implementation of &lt;strong&gt;find&lt;/strong&gt;, this is a recipe I use rather frequently:</source>
          <target state="translated">&lt;strong&gt;find&lt;/strong&gt; 의 파이썬 구현을 찾고 있다면, 이것은 내가 자주 사용하는 레시피입니다.</target>
        </trans-unit>
        <trans-unit id="90f100f9c3bc23151bbf759b25b9915bdc5e944f" translate="yes" xml:space="preserve">
          <source>If you care to first declare two functions, this can be done:</source>
          <target state="translated">두 개의 함수를 먼저 선언하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb80ffde24b3466cf70bca6ff6e24ccdda603187" translate="yes" xml:space="preserve">
          <source>If you want &lt;em&gt;just&lt;/em&gt; files, you could either filter this down using &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#module-os.path&quot;&gt;&lt;strong&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">파일 &lt;em&gt;만&lt;/em&gt; 원한다면 &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#module-os.path&quot;&gt;&lt;strong&gt; &lt;code&gt;os.path&lt;/code&gt; 를&lt;/strong&gt;&lt;/a&gt; 사용하여이를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f42b390755c693476bbd7b012e8c56a6646aaf8" translate="yes" xml:space="preserve">
          <source>If you'd like, you can open and read the contents, or focus only on files with the extension &quot;.dat&quot; like in the code below:</source>
          <target state="translated">원하는 경우 내용을 열고 읽거나 아래 코드와 같이 확장자가 &quot;.dat&quot;인 파일에만 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec8177c7394be1e7c3936ea15de0cd2de2f58ea" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;Python 2.2&lt;/em&gt;, the concept of &lt;strong&gt;generator&lt;/strong&gt; (&lt;a href=&quot;https://wiki.python.org/moin/Generators&quot;&gt;[Python.Wiki]: Generators&lt;/a&gt;) - courtesy of &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement&quot;&gt;[Python 3]: The yield statement&lt;/a&gt;) - was introduced. As time passed, generator counterparts started to appear for functions that returned/worked with lists</source>
          <target state="translated">&lt;em&gt;Python 2.2&lt;/em&gt; 에서는 &lt;strong&gt;generator&lt;/strong&gt; ( &lt;a href=&quot;https://wiki.python.org/moin/Generators&quot;&gt;[Python.Wiki] : Generators&lt;/a&gt; )- &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement&quot;&gt;[Python 3] : yield 문&lt;/a&gt; )의 개념이 도입되었습니다. 시간이 지남에 따라 목록으로 반환 / 작업 된 함수에 생성기 대응 항목이 나타나기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="941678e560913790233b5aa5cd7389c01878b95f" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;Python 3&lt;/em&gt;, generator is the default behavior</source>
          <target state="translated">&lt;em&gt;Python 3&lt;/em&gt; 에서 generator는 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="77e8769e42712522036d94b7b3c78ef5ae7612ed" translate="yes" xml:space="preserve">
          <source>In Python 2, if you want the list of the files in the current directory, you have to give the argument as '.' or os.getcwd() in the os.listdir method.</source>
          <target state="translated">Python 2에서 현재 디렉토리에있는 파일 목록을 원하면 인수를 '.'로 지정해야합니다. 또는 os.listdir 메소드의 os.getcwd ().</target>
        </trans-unit>
        <trans-unit id="1bf007beb38c4e9235e1737e3e3177509d6c7c43" translate="yes" xml:space="preserve">
          <source>In case you want to create a txt file with all the file names:</source>
          <target state="translated">모든 파일 이름으로 txt 파일을 작성하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="0f5d050a4f8bb3031f5f9e13a6748a7392e69ca5" translate="yes" xml:space="preserve">
          <source>In general this approach is to be avoided, since if some command output format slightly differs between &lt;em&gt;OS&lt;/em&gt; versions/flavors, the parsing code should be adapted as well; not to mention differences between locales).</source>
          <target state="translated">일반적으로이 접근 방식은 피해야합니다. 일부 명령 출력 형식이 &lt;em&gt;OS&lt;/em&gt; 버전 / 맛에 따라 약간 다르면 구문 분석 코드도 조정해야합니다. 로케일 간의 차이점은 말할 것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="4da2721c7f32a55a30ed1e1cdcbe7c7110817904" translate="yes" xml:space="preserve">
          <source>In pre &lt;em&gt;Python 2.2&lt;/em&gt; versions, sequences (iterables) were mostly represented by lists (tuples, sets, ...)</source>
          <target state="translated">&lt;em&gt;파이썬 2.2&lt;/em&gt; 이전 버전에서 시퀀스 (iterables)는 대부분리스트 (튜플, 세트 등)로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="63c6634f856645f142e10f863b59c7c875566996" translate="yes" xml:space="preserve">
          <source>In terms of performance, generators are generally a little bit faster (considering both &lt;em&gt;creation&lt;/em&gt; and  &lt;em&gt;iteration&lt;/em&gt; times), but I didn't test them in recursive functions, and also I am iterating inside the function over inner generators - don't know how performance friendly is that</source>
          <target state="translated">성능 측면에서 생성기는 일반적으로 &lt;em&gt;생성&lt;/em&gt; 속도와 &lt;em&gt;반복&lt;/em&gt; 시간을 모두 고려하여 조금 더 빠르지 만 재귀 함수에서 테스트하지 않았으며 내부 생성기보다 함수 내부에서 반복하고 있습니다. 성능을 모릅니다. 친근하다</target>
        </trans-unit>
        <trans-unit id="9fd1ec8d3629be0ce71e52d7e9222d123494250b" translate="yes" xml:space="preserve">
          <source>In this example, we look for the number of files that are included in all the directory and its subdirectories.</source>
          <target state="translated">이 예에서는 모든 디렉토리와 해당 서브 디렉토리에 포함 된 파일 수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9f9c1666d6fb24da9547d74890628916241d2319" translate="yes" xml:space="preserve">
          <source>Install some (other) third-party package that does the trick</source>
          <target state="translated">트릭을 수행하는 일부 (다른) 타사 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="d56ef1a5a7ed51dfab5117ea0a28d045166fe0bf" translate="yes" xml:space="preserve">
          <source>It does the heavy lifting by recurring in subfolders</source>
          <target state="translated">하위 폴더에서 되풀이하여 무거운 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7cbdb41b0d45ef09c31105cfa4a37433afd9eef5" translate="yes" xml:space="preserve">
          <source>It is simple to make more specific, e.g. only look for Python source files which are not symbolic links, also in all subdirectories:</source>
          <target state="translated">예를 들어 모든 하위 디렉토리에서 심볼릭 링크가 아닌 Python 소스 파일 만 찾으면됩니다.</target>
        </trans-unit>
        <trans-unit id="3cbdf226190d6816dae21afe946a062e1c1c39d7" translate="yes" xml:space="preserve">
          <source>It loads the three functions from &lt;em&gt;libc&lt;/em&gt; (loaded in the current process) and calls them (for more details check &lt;a href=&quot;https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python/44661513#44661513&quot;&gt;[SO]: How do I check whether a file exists without exceptions? (@CristiFati's answer)&lt;/a&gt; - last notes from item &lt;strong&gt;&lt;em&gt;#4.&lt;/em&gt;&lt;/strong&gt;). That would place this approach very close to the &lt;em&gt;Python&lt;/em&gt; / &lt;em&gt;C&lt;/em&gt; edge</source>
          <target state="translated">&lt;em&gt;libc&lt;/em&gt; (현재 프로세스에로드 됨)에서 세 가지 함수를로드하고이를 호출합니다 (자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python/44661513#44661513&quot;&gt;[SO] : 예외없이 파일이 존재하는지 어떻게 확인합니까? (@ CristiFati의 답변)&lt;/a&gt; -항목 &lt;strong&gt;&lt;em&gt;# 4의&lt;/em&gt;&lt;/strong&gt; 마지막 메모 ) &lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt; ). 이 접근 방식은 &lt;em&gt;Python&lt;/em&gt; / &lt;em&gt;C&lt;/em&gt; 가장자리에 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="c2c25c0e9aac0187cd9a8df39fc91736f708a691" translate="yes" xml:space="preserve">
          <source>It returns data in the &lt;code&gt;os.walk&lt;/code&gt;'s format. I didn't bother to make it recursive, but starting from the existing code, that would be a fairly trivial task</source>
          <target state="translated">&lt;code&gt;os.walk&lt;/code&gt; 형식으로 데이터를 리턴합니다. 나는 그것을 재귀 적으로 만들지 않았지만 기존 코드에서 시작하여 상당히 사소한 작업 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="4525df15d3072b34e880ab3a342cc68304ca97e8" translate="yes" xml:space="preserve">
          <source>It will return a list with the queried files:</source>
          <target state="translated">쿼리 된 파일이있는 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8de9859a57cc42b18329ec8459329c1376b161fe" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os.listdir&lt;/code&gt; 과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e8b169f69f815666e2a48dbd2a337af6d2d3ac89" translate="yes" xml:space="preserve">
          <source>It's the &lt;em&gt;OOP&lt;/em&gt; style of handling paths</source>
          <target state="translated">처리 경로의 &lt;em&gt;OOP&lt;/em&gt; 스타일입니다</target>
        </trans-unit>
        <trans-unit id="5a3f2285980cec4dcc0334534e1165949da510e0" translate="yes" xml:space="preserve">
          <source>Let me also recommend reading ShadowRanger's comment below.</source>
          <target state="translated">아래 ShadowRanger의 의견을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2f11e0e14c1417ab4165bb45bcafbebb61e0ebf2" translate="yes" xml:space="preserve">
          <source>Modify file extensions and source path as needed.</source>
          <target state="translated">필요에 따라 파일 확장자와 소스 경로를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="0108e5063d896e4acb61bd29dd84e7c04a286618" translate="yes" xml:space="preserve">
          <source>Most likely, will rely on one (or more) of the above (maybe with slight customizations)</source>
          <target state="translated">위의 것 중 하나 이상에 의존 할 가능성이 높습니다 (약간의 사용자 정의가있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="c9f6848eeecc84445de53d0bf42da05a4a1371ff" translate="yes" xml:space="preserve">
          <source>Multiple path styles (absolute, relatives) were used across the above variants, to illustrate the fact that the &quot;tools&quot; used are flexible in this direction</source>
          <target state="translated">사용 된 &quot;도구&quot;가이 방향으로 유연하다는 사실을 설명하기 위해 위의 변형에서 여러 경로 스타일 (절대, 상대)이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="45d635954f958ec2e3e526c6c1bf2736318c4c8b" translate="yes" xml:space="preserve">
          <source>Not sure if returning a list is still mandatory (or a generator would do as well), but passing a generator to the &lt;em&gt;list&lt;/em&gt; constructor, will create a list out of it (and also consume it). The example below illustrates the differences on &lt;a href=&quot;https://docs.python.org/3/library/functions.html#map&quot;&gt;[Python 3]: &lt;strong&gt;map&lt;/strong&gt;(&lt;em&gt;function, iterable, ...&lt;/em&gt;)&lt;/a&gt;</source>
          <target state="translated">목록 반환이 여전히 필수인지 확실하지 않은 경우 (또는 생성기에서도 마찬가지 임) 생성기를 &lt;em&gt;목록&lt;/em&gt; 생성자에 전달하면 &lt;em&gt;목록&lt;/em&gt; 에서 &lt;em&gt;목록&lt;/em&gt; 을 생성 (및 소비)합니다. 아래 예제는 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#map&quot;&gt;[Python 3]&lt;/a&gt; 의 차이점을 보여줍니다 : &lt;strong&gt;map&lt;/strong&gt; ( &lt;em&gt;function, iterable, ...&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="76684f5c591f9e77105544503001782cbd1fa281" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.walk&quot;&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt;&lt;code&gt;os.scandir()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt; from version 3.5, and its speed got increased by 2-20 times according to &lt;a href=&quot;http://www.python.org/dev/peps/pep-0471/&quot;&gt;PEP 471&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3/library/os.html#os.walk&quot;&gt; &lt;code&gt;os.walk()&lt;/code&gt; &lt;/a&gt; 는 버전 3.5의 &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.scandir&quot;&gt; &lt;code&gt;os.scandir()&lt;/code&gt; &lt;/a&gt; 대신 os.scandir ()을 사용하며 &lt;a href=&quot;http://www.python.org/dev/peps/pep-0471/&quot;&gt;PEP 471&lt;/a&gt; 에 따라 속도가 2-20 배 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="717ed41e89e1d28f1116c7b65c2db4e7963f0a67" translate="yes" xml:space="preserve">
          <source>Offers lots of functionalities</source>
          <target state="translated">많은 기능 제공</target>
        </trans-unit>
        <trans-unit id="da503e6e497b8e0204fa6cc99972651747ef2f98" translate="yes" xml:space="preserve">
          <source>One that starts with an &lt;em&gt;underscore&lt;/em&gt; (&lt;strong&gt;_&lt;/strong&gt;): &quot;private&quot; (should not be called directly) - that does all the work</source>
          <target state="translated">&lt;em&gt;밑줄&lt;/em&gt; ( &lt;strong&gt;_&lt;/strong&gt; )로 시작하는 것 : &quot;private&quot;(직접 호출해서는 안 됨)-모든 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f668c22f829b531f83c4e8c14822ced5de586def" translate="yes" xml:space="preserve">
          <source>One that uses generators (of course here it seems useless, since I immediately convert the result to a list)</source>
          <target state="translated">생성기를 사용하는 것 (물론 여기서 결과를 즉시 목록으로 변환하기 때문에 쓸모없는 것 같습니다)</target>
        </trans-unit>
        <trans-unit id="54dd98245eb94a5511e854146666976f5eab6029" translate="yes" xml:space="preserve">
          <source>Other approaches:</source>
          <target state="translated">다른 접근법 :</target>
        </trans-unit>
        <trans-unit id="8982de0f87f5a64b5d2a43e140c7d1284ef222a9" translate="yes" xml:space="preserve">
          <source>Play with the arguments to get different results</source>
          <target state="translated">다른 결과를 얻기 위해 논증을 가지고 노는</target>
        </trans-unit>
        <trans-unit id="a2334d3b78606fb37d97982e921c201ebc52a874" translate="yes" xml:space="preserve">
          <source>Preliminary notes</source>
          <target state="translated">예비 메모</target>
        </trans-unit>
        <trans-unit id="c31fb60399d7d99c4a5f5c96a1b65920b8659a3c" translate="yes" xml:space="preserve">
          <source>Programmatic approaches:</source>
          <target state="translated">프로그래밍 방식 :</target>
        </trans-unit>
        <trans-unit id="3b2106740c196b5c51ebc11173417a1ff3c74077" translate="yes" xml:space="preserve">
          <source>Recursion is used (to get into subdirectories)</source>
          <target state="translated">재귀가 사용됩니다 (하위 디렉토리로 들어가기 위해).</target>
        </trans-unit>
        <trans-unit id="79da5d61c75dc4fb7461217fb85e3fc01b5d813e" translate="yes" xml:space="preserve">
          <source>Retrieves a list of matching filenames, using the Windows Unicode API. An interface to the API FindFirstFileW/FindNextFileW/Find close functions.</source>
          <target state="translated">Windows Unicode API를 사용하여 일치하는 파일 이름 목록을 검색합니다. API FindFirstFileW / FindNextFileW / Find close 함수에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="582be600686ad7e319795122c6738abaf4b1acf1" translate="yes" xml:space="preserve">
          <source>Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order, and does not include the special entries &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; ...</source>
          <target state="translated">경로로 주어진 디렉토리에있는 항목의 이름이 포함 된 목록을 반환하십시오. 목록은 임의의 순서이며 특수 항목 &lt;code&gt;'.'&lt;/code&gt; 은 포함하지 않습니다 . 그리고 &lt;code&gt;'..'&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="2f072b75d44d6a733fac5a3200b5894a255faa0e" translate="yes" xml:space="preserve">
          <source>Return a possibly-empty list of path names that match &lt;em&gt;pathname&lt;/em&gt;, which must be a string containing a path specification. &lt;em&gt;pathname&lt;/em&gt; can be either absolute (like &lt;code&gt;/usr/src/Python-1.5/Makefile&lt;/code&gt;) or relative (like &lt;code&gt;../../Tools/*/*.gif&lt;/code&gt;), and can contain shell-style wildcards. Broken symlinks are included in the results (as in the shell).</source>
          <target state="translated">&lt;em&gt;pathname&lt;/em&gt; 과 일치하는 비어있는 경로 이름 목록을 리턴합니다. 경로 이름은 경로 스펙을 포함하는 문자열이어야합니다. &lt;em&gt;경로 이름&lt;/em&gt; 은 절대 &lt;em&gt;경로&lt;/em&gt; ( &lt;code&gt;/usr/src/Python-1.5/Makefile&lt;/code&gt; 등 )이거나 상대 경로 ( &lt;code&gt;../../Tools/*/*.gif&lt;/code&gt; 등 ) 일 수 있으며 쉘 스타일 와일드 카드를 포함 할 수 있습니다. 깨진 심볼릭 링크가 결과에 포함됩니다 (쉘에서와 같이).</target>
        </trans-unit>
        <trans-unit id="f0ce9f6d0622c1638c21f97c4b621614044f0b11" translate="yes" xml:space="preserve">
          <source>Return an iterator of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects corresponding to the entries in the directory given by &lt;em&gt;path&lt;/em&gt;. The entries are yielded in arbitrary order, and the special entries &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; are not included.</source>
          <target state="translated">&lt;em&gt;path로&lt;/em&gt; 지정된 디렉토리 내의 엔트리에 대응하는 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; 객체의 반복자를 돌려줍니다. 항목은 임의의 순서로 생성되며 특수 항목 &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;'..'&lt;/code&gt; 은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="077432006ccd924f3e84db4a09f99df379bd4be9" translate="yes" xml:space="preserve">
          <source>Since version 3.4 there are builtin &lt;em&gt;iterators&lt;/em&gt; for this which are a lot more efficient than &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">버전 3.4부터는 &lt;a href=&quot;http://docs.python.org/3/library/os.html#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; 보다 훨씬 효율적인 내장 &lt;em&gt;반복자&lt;/em&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0182e165e36f3ef5412a702725b8fd761ec234c" translate="yes" xml:space="preserve">
          <source>So I made a PyPI &lt;a href=&quot;https://pypi.python.org/pypi/findtools/&quot;&gt;package&lt;/a&gt; out of it and there is also a &lt;a href=&quot;https://github.com/ewiger/findtools&quot;&gt;GitHub repository&lt;/a&gt;. I hope that someone finds it potentially useful for this code.</source>
          <target state="translated">그래서 PyPI &lt;a href=&quot;https://pypi.python.org/pypi/findtools/&quot;&gt;패키지를&lt;/a&gt; 만들었고 &lt;a href=&quot;https://github.com/ewiger/findtools&quot;&gt;GitHub 저장소도&lt;/a&gt; 있습니다. 누군가 가이 코드에 유용 할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="c9cfd1ae92b0fb56af44351245614b36eb7da00f" translate="yes" xml:space="preserve">
          <source>Some advanced filtering (instead of just file &lt;em&gt;vs.&lt;/em&gt; dir) could be done: e.g. the &lt;em&gt;include_folders&lt;/em&gt; argument could be replaced by another one (e.g. &lt;em&gt;filter_func&lt;/em&gt;) which would be a function that takes a path as an argument: &lt;code&gt;filter_func=lambda x: True&lt;/code&gt; (this doesn't strip out anything) and inside &lt;em&gt;_get_dir_content&lt;/em&gt; something like: &lt;code&gt;if not filter_func(entry_with_path): continue&lt;/code&gt; (if the function fails for one entry, it will be skipped), but the more complex the code becomes, the longer it will take to execute</source>
          <target state="translated">일부 고급 필터링 (파일 대신 dir 대신)이 수행 될 수 있습니다. 예를 들어 &lt;em&gt;include_folders&lt;/em&gt; 인수는 경로를 인수로 사용하는 함수 인 다른 &lt;em&gt;필터&lt;/em&gt; (예 : &lt;em&gt;filter_func&lt;/em&gt; )로 대체 될 수 있습니다. &lt;code&gt;filter_func=lambda x: True&lt;/code&gt; ( &lt;code&gt;if not filter_func(entry_with_path): continue&lt;/code&gt; (한 항목에 대해 함수가 실패하면 건너 뜁니다), 코드가 복잡해지면 시간이 오래 걸립니다. 실행하다</target>
        </trans-unit>
        <trans-unit id="50ca8e6b16dd6e1652134dcd18d09f91fd597149" translate="yes" xml:space="preserve">
          <source>Some consider this a neat hack</source>
          <target state="translated">일부는 이것을 깔끔한 핵으로 간주합니다</target>
        </trans-unit>
        <trans-unit id="a2c18de198a22ba809f588bc8b14ec52c40280db" translate="yes" xml:space="preserve">
          <source>That technology is invoked from &lt;em&gt;Python&lt;/em&gt;</source>
          <target state="translated">그 기술은 &lt;em&gt;파이썬&lt;/em&gt; 에서 불러옵니다</target>
        </trans-unit>
        <trans-unit id="984a1dd63f81000a751cb4379badf365cb11099e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;listdir()&lt;/code&gt; method returns the list of entries for the given directory. The method &lt;code&gt;os.path.isfile()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; if the given entry is a file. And the &lt;code&gt;yield&lt;/code&gt; operator quits the func but keeps its current state, and it returns only the name of the entry detected as a file. All the above allows us to loop over the generator function.</source>
          <target state="translated">&lt;code&gt;listdir()&lt;/code&gt; 메소드는 주어진 디렉토리에 대한 항목 목록을 리턴합니다. 주어진 항목이 파일 인 경우 &lt;code&gt;os.path.isfile()&lt;/code&gt; 메소드는 &lt;code&gt;True&lt;/code&gt; 를 리턴합니다. &lt;code&gt;yield&lt;/code&gt; 연산자는 func을 종료하지만 현재 상태를 유지하며 파일로 탐지 된 항목의 이름 만 반환합니다. 위의 모든 내용을 통해 생성기 기능을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddcc5552d357d16f4d04b6b8fcf0c7ad4ebcade4" translate="yes" xml:space="preserve">
          <source>The above is terrible - the path has been hardcoded and will only ever work on Windows between the drive name and the &lt;code&gt;\&lt;/code&gt;s being hardcoded into the path.</source>
          <target state="translated">위의 내용은 끔찍합니다. 경로는 하드 코딩되었으며 드라이브 이름과 경로 사이에 하드 코딩 된 &lt;code&gt;\&lt;/code&gt; 사이에서만 Windows에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34a84e7d808c73e5816d9c5f644714391da08644" translate="yes" xml:space="preserve">
          <source>The above works better, but it relies on the folder name &lt;code&gt;Users&lt;/code&gt; which is often found on Windows and not so often found on other OSs. It also relies on the user having a specific name, &lt;code&gt;admin&lt;/code&gt;.</source>
          <target state="translated">위의 방법은 더 잘 작동하지만 Windows에서 자주 발견되고 다른 OS에서는 그렇지 않은 폴더 이름 &lt;code&gt;Users&lt;/code&gt; 를 사용합니다. 또한 특정 이름 &lt;code&gt;admin&lt;/code&gt; 을 가진 사용자에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="a5efb4f05d0af1ea2fc7d5aded2f175627849834" translate="yes" xml:space="preserve">
          <source>The classic one (function names ending in &lt;strong&gt;_old&lt;/strong&gt;)</source>
          <target state="translated">고전적인 것 ( &lt;strong&gt;_old로&lt;/strong&gt; 끝나는 함수 이름)</target>
        </trans-unit>
        <trans-unit id="97ce4a8e2e1c748e1512dd6a514db079e8da4db5" translate="yes" xml:space="preserve">
          <source>The code samples are for demonstrative purposes only. That means that I didn't take into account error handling (I don't think there's any &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; block), so the code is not robust (the reason is: to keep it as simple and short as possible). For &lt;em&gt;production&lt;/em&gt;, error handling should be added as well</source>
          <target state="translated">코드 샘플은 설명을위한 것입니다. 즉, 오류 처리를 고려하지 않았다는 것을 의미합니다 ( &lt;strong&gt;&lt;em&gt;시도&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;제외&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; 블록이 없다고 생각합니다). 코드가 강력하지 않습니다 (이유 : 가능한 한 간단하고 짧게 유지해야 함) ). &lt;em&gt;생산&lt;/em&gt; 을 위해서는 오류 처리 기능도 추가해야합니다</target>
        </trans-unit>
        <trans-unit id="67da2a3716eaa60f772589f94e3b92d99311f82d" translate="yes" xml:space="preserve">
          <source>The documentation link is from &lt;a href=&quot;https://www.activestate.com&quot;&gt;ActiveState&lt;/a&gt;, as I didn't find any &lt;em&gt;PyWin32&lt;/em&gt; official documentation</source>
          <target state="translated">&lt;em&gt;PyWin32&lt;/em&gt; 공식 문서를 찾지 못했기 때문에 문서 링크는 &lt;a href=&quot;https://www.activestate.com&quot;&gt;ActiveState&lt;/a&gt; 에서 온 것입니다.</target>
        </trans-unit>
        <trans-unit id="72a7531c0e841449871b731f13a1ff92ce1aee1f" translate="yes" xml:space="preserve">
          <source>The examples will be based on a directory called &lt;em&gt;root_dir&lt;/em&gt; with the following structure (this example is for &lt;em&gt;Win&lt;/em&gt;, but I'm using the same tree on &lt;em&gt;Lnx&lt;/em&gt; as well):</source>
          <target state="translated">예제는 다음 구조의 &lt;em&gt;root_dir&lt;/em&gt; 디렉토리를 기반으로합니다 (이 예제는 &lt;em&gt;Win&lt;/em&gt; 용이지만 &lt;em&gt;Lnx&lt;/em&gt; 에서도 동일한 트리를 사용하고 있습니다).</target>
        </trans-unit>
        <trans-unit id="3e381581ca6c685f3cab612a470ca71cd33d9f8d" translate="yes" xml:space="preserve">
          <source>The function now returns a list of file that matched with the string you pass as argument</source>
          <target state="translated">이 함수는 인수로 전달한 문자열과 일치하는 파일 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b44ca6221ff33c07b43c340fd9b727e5d43741f4" translate="yes" xml:space="preserve">
          <source>The function returns a list of the given extension (.txt, .docx ecc.) in the argument</source>
          <target state="translated">이 함수는 인수에 주어진 확장자 (.txt, .docx 등)의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bff076f64e415e92b28eefc66672b4bbb04ba0f5" translate="yes" xml:space="preserve">
          <source>The most famous flavor that I know is what I call the &lt;em&gt;system administrator&lt;/em&gt; approach:</source>
          <target state="translated">내가 아는 가장 유명한 특징은 &lt;em&gt;시스템 관리자&lt;/em&gt; 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="0a6b782490002196a2329ad3481974c99420998b" translate="yes" xml:space="preserve">
          <source>The path I provided in the above function contained 3 files&amp;mdash; two of them in the root directory, and another in a subfolder called &quot;SUBFOLDER.&quot;  You can now do things like:</source>
          <target state="translated">위 함수에서 제공 한 경로에는 3 개의 파일이 포함되어 있습니다. 그 중 2 개는 루트 디렉토리에 있고 다른 하나는 &quot;SUBFOLDER&quot;라는 하위 폴더에 있습니다. 이제 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e43335d7cd1ee1be4d33ec1c5e8400190fdf6456" translate="yes" xml:space="preserve">
          <source>The public one (wrapper over previous): it just strips off the initial path (if required) from the returned entries. It's an ugly implementation, but it's the only idea that I could come with at this point</source>
          <target state="translated">공개 경로 (이전의 래퍼) : 반환 된 항목에서 초기 경로 (필요한 경우)를 제거합니다. 추악한 구현이지만이 시점에서 내가 올 수있는 유일한 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="5cb12071056bcb42b9fc0f988ee71ec74b111c62" translate="yes" xml:space="preserve">
          <source>The statement: &quot;&lt;em&gt;all files of a directory&lt;/em&gt;&quot; can be interpreted in two ways:</source>
          <target state="translated">&quot; &lt;em&gt;디렉토리의 모든 파일&lt;/em&gt; &quot;명령문은 다음 두 가지 방식으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2292e3df0a0f2e83012ca2a2c609cc82bea4dfd6" translate="yes" xml:space="preserve">
          <source>There are two implementations:</source>
          <target state="translated">두 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c929a3860b937c949d26a208230c2d0f7712cbd" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;one&lt;/em&gt; way of achieving our goal</source>
          <target state="translated">이것이 우리의 목표를 달성하는 &lt;em&gt;한 가지&lt;/em&gt; 방법입니다</target>
        </trans-unit>
        <trans-unit id="821003fc981444da5a481089df7b23f8c27b28c3" translate="yes" xml:space="preserve">
          <source>This is a shorter version of the previous code. Change the folder where to start finding the files if you need to start from another position. This code generate a 50 mb on text file on my computer with something less then 500.000 lines with files with the complete path.</source>
          <target state="translated">이것은 이전 코드의 짧은 버전입니다. 다른 위치에서 시작해야하는 경우 파일 찾기를 시작할 폴더를 변경하십시오. 이 코드는 컴퓨터의 텍스트 파일에 50MB 미만의 완전한 경로를 가진 파일이있는 500.000 줄 이하를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3d13557d689d8a3adf5877b55d33c0d2b4d7c265" translate="yes" xml:space="preserve">
          <source>This solution could be easily generalized with regular expressions (and you might want to add a &lt;code&gt;pattern&lt;/code&gt; argument, if you do not want your patterns to always stick to the start or end of the filename).</source>
          <target state="translated">이 솔루션은 정규 표현식을 사용하여 쉽게 일반화 할 수 있습니다 (패턴이 항상 파일 이름의 시작 또는 끝에 붙어 있지 않게하려면 &lt;code&gt;pattern&lt;/code&gt; 인수를 추가 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="55f2ad7673e7660434283f70da80f18b6ccef8a3" translate="yes" xml:space="preserve">
          <source>This works perfectly across all platforms.</source>
          <target state="translated">이것은 모든 플랫폼에서 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5b26a5f61adbf2dc12a1e448638766977078aed1" translate="yes" xml:space="preserve">
          <source>To go up in the directory tree</source>
          <target state="translated">디렉토리 트리에서 위로 이동하려면</target>
        </trans-unit>
        <trans-unit id="64f9b00db14ed02adc874ae17ab1ca0fd942076e" translate="yes" xml:space="preserve">
          <source>Under the scenes, it uses &lt;code&gt;os.scandir&lt;/code&gt; (&lt;code&gt;os.listdir&lt;/code&gt; on older versions)</source>
          <target state="translated">장면에서 &lt;code&gt;os.scandir&lt;/code&gt; (이전 버전의 &lt;code&gt;os.listdir&lt;/code&gt; )을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd65c2d67dece60963b8de40a3a24454e912a835" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;Python&lt;/em&gt; (or any programming language for that matter) in order to execute &lt;em&gt;shell&lt;/em&gt; commands (and parse their outputs)</source>
          <target state="translated">&lt;em&gt;쉘&lt;/em&gt; 명령을 실행하고 출력을 구문 분석하려면 &lt;em&gt;Python&lt;/em&gt; (또는 그 문제에 대한 프로그래밍 언어)을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="c226bbc07d59db598114cede264cde6f3b89fc89" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;Python&lt;/em&gt; only as a wrapper</source>
          <target state="translated">랩퍼로만 &lt;em&gt;Python을&lt;/em&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="41688114f6359ccacea86a89625b311705d53f70" translate="yes" xml:space="preserve">
          <source>Use glob method in pathlib.Path()</source>
          <target state="translated">pathlib.Path ()에서 glob 메소드 사용</target>
        </trans-unit>
        <trans-unit id="8ff6af64dd6be56bd7353670e77103fb708b4cd5" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os.listdir&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="a09130d4064cb71241e9c92eb3d5f5998cbbe1e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir()&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir()&lt;/a&gt; can significantly increase the performance of code that also needs file type or file attribute information, because &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects expose this information if the operating system provides it when scanning a directory. All &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; methods may perform a system call, but &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file()&lt;/a&gt; usually only require a system call for symbolic links; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat()&lt;/a&gt; always requires a system call on Unix but only requires one for symbolic links on Windows.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; 객체는 디렉토리를 스캔 할 때 운영 체제에서 정보를 제공하는 경우 os.DirEntry 객체가이 정보를 노출하므로 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;()&lt;/a&gt; 대신 scandir ()을 사용하면 파일 유형 또는 파일 속성 정보가 필요한 코드의 성능이 크게 향상 될 수 있습니다. 모든 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; 메소드는 시스템 호출을 수행 할 수 있지만 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir ()&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file ()은&lt;/a&gt; 일반적으로 기호 링크에 대한 시스템 호출 만 필요합니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat ()는&lt;/a&gt; 항상 Unix에서 시스템 호출이 필요하지만 Windows에서는 기호 링크에 대한 호출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a78436732f1a3d9a5ef51ed738e4a262db3bb8ca" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;glob&lt;/code&gt; to get the full path of the files</source>
          <target state="translated">&lt;code&gt;glob&lt;/code&gt; 을 사용하여 파일의 전체 경로 가져 오기</target>
        </trans-unit>
        <trans-unit id="612cdb119d7c05fd21faac9981e16bf2c2695847" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;os.path.isfile&lt;/code&gt; to avoid directories in the list</source>
          <target state="translated">목록에서 디렉토리를 피하기 위해 &lt;code&gt;os.path.isfile&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="2534d35f39302b5dc41c46d30c7c0d17be04995d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pathlib&lt;/code&gt; from Python 3.4</source>
          <target state="translated">Python 3.4에서 &lt;code&gt;pathlib&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="afa1cd5a306219cebbf55166624ed633b8d4f90f" translate="yes" xml:space="preserve">
          <source>Using generators</source>
          <target state="translated">발전기 사용</target>
        </trans-unit>
        <trans-unit id="09cefc7b06a9f30509334ba0aed651b2279a6dfd" translate="yes" xml:space="preserve">
          <source>When the question was asked, I imagine that &lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt;, was the &lt;em&gt;LTS&lt;/em&gt; version, however the code samples will be run by &lt;em&gt;Python &lt;strong&gt;3&lt;/strong&gt;(&lt;strong&gt;.5&lt;/strong&gt;)&lt;/em&gt; (I'll keep them as &lt;em&gt;Python 2&lt;/em&gt; compliant as possible; also, any code belonging to &lt;em&gt;Python&lt;/em&gt; that I'm going to post, is from &lt;strong&gt;v3.5.4&lt;/strong&gt; - unless otherwise specified). That has consequences related to another keyword in the question: &quot;&lt;em&gt;add them into a &lt;strong&gt;list&lt;/strong&gt;&lt;/em&gt;&quot;:</source>
          <target state="translated">질문을 받았을 때 &lt;em&gt;Python &lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt; 가 &lt;em&gt;LTS&lt;/em&gt; 버전이라고 생각하지만 코드 샘플은 &lt;em&gt;Python &lt;strong&gt;3&lt;/strong&gt; ( &lt;strong&gt;.5&lt;/strong&gt; )에&lt;/em&gt; 의해 실행됩니다 &lt;em&gt;(&lt;/em&gt; 가능한 한 &lt;em&gt;Python 2와&lt;/em&gt; 호환되도록 유지합니다. 게시 할 &lt;em&gt;Python&lt;/em&gt; 은 &lt;strong&gt;v3.5.4&lt;/strong&gt; 에서 가져 왔습니다-달리 지정하지 않는 한). 그 결과 질문에있는 다른 키워드와 관련된 결과 &lt;em&gt;가 나타 &lt;strong&gt;납니다.&lt;/strong&gt;&lt;/em&gt; &quot; &lt;em&gt;&lt;strong&gt;목록에&lt;/strong&gt;&lt;/em&gt; 키워드 &lt;em&gt;추가&lt;/em&gt; &quot;:</target>
        </trans-unit>
        <trans-unit id="e939fe6c637dd49301b395a0239bfffae8c70695" translate="yes" xml:space="preserve">
          <source>When there are several established ways to do something, none of them is good for all cases.</source>
          <target state="translated">어떤 일을하는 몇 가지 확실한 방법이있을 때, 그 중 어느 것도 모든 경우에 좋은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ec6f24c79a6fa64dcca56cd1eb077390119500b5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list comprehension&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;list comprehension&lt;/code&gt; 와 함께 :</target>
        </trans-unit>
        <trans-unit id="178f0407f497a7401fd2c33476574fa704ae8d90" translate="yes" xml:space="preserve">
          <source>With this function you can create a txt file that will have the name of a type of file that you look for (ex. pngfile.txt) with all the full path of all the files of that type. It can be useful sometimes, I think.</source>
          <target state="translated">이 기능을 사용하면 찾고자하는 파일 형식 (예 : pngfile.txt)의 이름을 가진 txt 파일을 해당 형식의 모든 파일의 전체 경로와 함께 만들 수 있습니다. 때로는 유용 할 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="76d707d20ae5e178466dfff371974f199051dc34" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;listdir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)</source>
          <target state="translated">[파이썬 3] : os. &lt;strong&gt;listdir&lt;/strong&gt; ( &lt;em&gt;path = '.'&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="ea7a34811c2492dcaa209ef15806e5b61c87b16f" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;walk&lt;/strong&gt;(&lt;em&gt;top, topdown=True, onerror=None, followlinks=False&lt;/em&gt;)</source>
          <target state="translated">[파이썬 3] : os. &lt;strong&gt;도보&lt;/strong&gt; ( &lt;em&gt;top, topdown = True, onerror = None, followlinks = False&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="d6aff5adcd46c5e905b3a5b17eeff0904a88b4c8" translate="yes" xml:space="preserve">
          <source>or absolute pathnames:</source>
          <target state="translated">또는 절대 경로 이름 :</target>
        </trans-unit>
        <trans-unit id="3cb11137ad88c943901b8f5bc845b94149d59c9a" translate="yes" xml:space="preserve">
          <source>or you could use &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.walk&quot;&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; which will &lt;strong&gt;yield two lists&lt;/strong&gt; for each directory it visits - splitting into &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;dirs&lt;/strong&gt; for you. If you only want the top directory you can just break the first time it yields</source>
          <target state="translated">또는 &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.walk&quot;&gt; &lt;code&gt;os.walk()&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; 를 사용하여 방문하는 각 디렉토리마다 &lt;strong&gt;두 개의 목록&lt;/strong&gt; 을 &lt;strong&gt;생성합니다&lt;/strong&gt; - &lt;strong&gt;파일&lt;/strong&gt; 과 &lt;strong&gt;디렉토리&lt;/strong&gt; 로 나눕니다. 최상위 디렉토리 만 원하면 처음 생성 할 때 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1029d67644815d428f554e390aa966d57a0b29b8" translate="yes" xml:space="preserve">
          <source>output</source>
          <target state="translated">output</target>
        </trans-unit>
        <trans-unit id="083e33cc5cdd52fb9d26ae0f284ca1be68944566" translate="yes" xml:space="preserve">
          <source>platform (&lt;em&gt;Nix&lt;/em&gt;, &lt;em&gt;Win&lt;/em&gt;, )</source>
          <target state="translated">플랫폼 ( &lt;em&gt;Nix&lt;/em&gt; , &lt;em&gt;Win&lt;/em&gt; ,)</target>
        </trans-unit>
        <trans-unit id="f4f6e2f05a83d0b597bd40911d336686420756c7" translate="yes" xml:space="preserve">
          <source>will return a list of all files and directories in &quot;somedirectory&quot;.</source>
          <target state="translated">&quot;somedirectory&quot;의 모든 파일 및 디렉토리 목록을 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
