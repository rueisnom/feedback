<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3279543">
    <body>
      <group id="3279543">
        <trans-unit id="6c226e8c6cc9d76ab83c602a00d6e4dc0fc4f9d3" translate="yes" xml:space="preserve">
          <source>&amp;Dagger; assignment operator implementation that seems sane when assigning from a distinct object can easily fail for self-assignment.  While it might seem unimaginable that client code would even attempt self-assignment, it can happen relatively easily during algo operations on containers, with &lt;code&gt;x = f(x);&lt;/code&gt; code where &lt;code&gt;f&lt;/code&gt; is (perhaps only for some &lt;code&gt;#ifdef&lt;/code&gt; branches) a macro ala &lt;code&gt;#define f(x) x&lt;/code&gt; or a function returning a reference to &lt;code&gt;x&lt;/code&gt;, or even (likely inefficient but concise) code like &lt;code&gt;x = c1 ? x * 2 : c2 ? x / 2 : x;&lt;/code&gt;).  For example:</source>
          <target state="translated">&amp;bull;当从一个不同的对象进行分配时，似乎很理智的分配运算符实现很容易因自赋值而失败。 尽管客户端代码甚至尝试自我分配似乎是不可想象的，但在容器上进行算法操作时，它相对容易发生， &lt;code&gt;x = f(x);&lt;/code&gt; 其中 &lt;code&gt;f&lt;/code&gt; 是（也许仅用于某些 &lt;code&gt;#ifdef&lt;/code&gt; 分支）宏ala &lt;code&gt;#define f(x) x&lt;/code&gt; 或返回对 &lt;code&gt;x&lt;/code&gt; 的引用的函数 ，或者甚至是 &lt;code&gt;x = c1 ? x * 2 : c2 ? x / 2 : x;&lt;/code&gt; 类的（可能效率低下但简洁的）代码？ &amp;times;2：c2？ x / 2：x； ）。 例如：</target>
        </trans-unit>
        <trans-unit id="bb7374700aafe18beca629b3c0f274d8e62aa193" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;The reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.</source>
          <target state="translated">&amp;Dagger;原因很简单：一旦拥有了自己的资源，就可以在需要的任何地方交换和/或移动它（C ++ 11）。 通过在参数列表中创建副本，可以最大程度地优化。</target>
        </trans-unit>
        <trans-unit id="163368ac3c34ec2c83983583f0414ca3308b0713" translate="yes" xml:space="preserve">
          <source>&amp;dagger; &lt;code&gt;swap&lt;/code&gt; throwing: it's generally possible to reliably swap data members that the objects track by pointer, but non-pointer data members that don't have a throw-free swap, or for which swapping has to be implemented as &lt;code&gt;X tmp = lhs; lhs = rhs; rhs = tmp;&lt;/code&gt; and copy-construction or assignment may throw, still have the potential to fail leaving some data members swapped and others not.  This potential applies even to C++03 &lt;code&gt;std::string&lt;/code&gt;'s as James comments on another answer:</source>
          <target state="translated">&amp;dagger; &lt;code&gt;swap&lt;/code&gt; 抛出：通常可以可靠地交换对象按指针跟踪的数据成员，但是没有无抛出交换或必须将交换实现为 &lt;code&gt;X tmp = lhs; lhs = rhs; rhs = tmp;&lt;/code&gt; 非指针数据成员； lhs = rhs; rhs = tmp; 并且复制构造或分配可能会抛出，仍然有可能失败，导​​致某些数据成员被交换而另一些数据成员没有交换。 当詹姆斯评论另一个答案时，这种潜力甚至适用于C ++ 03 &lt;code&gt;std::string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f199a37b50d8112edd59b2da2ef5d80d8b29454" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&amp;dagger;The move constructor should generally be &lt;code&gt;noexcept&lt;/code&gt;, otherwise some code (e.g. &lt;code&gt;std::vector&lt;/code&gt; resizing logic) will use the copy constructor even when a move would make sense. Of course, only mark it noexcept if the code inside doesn't throw exceptions.</source>
          <target state="translated">&amp;dagger;&amp;dagger;move构造函数通常应为 &lt;code&gt;noexcept&lt;/code&gt; ，否则即使在有意义的情况下 ，某些代码（例如 &lt;code&gt;std::vector&lt;/code&gt; 大小调整逻辑）也将使用副本构造函数。 当然，如果内部代码未引发异常，则仅将其标记为noexcept。</target>
        </trans-unit>
        <trans-unit id="75fc32cb0b6c21685002f255ba8bd3b417167a6f" translate="yes" xml:space="preserve">
          <source>&amp;dagger;There are other claims that we should specialize &lt;code&gt;std::swap&lt;/code&gt; for our type, provide an in-class &lt;code&gt;swap&lt;/code&gt; along-side a free-function &lt;code&gt;swap&lt;/code&gt;, etc. But this is all unnecessary: any proper use of &lt;code&gt;swap&lt;/code&gt; will be through an unqualified call, and our function will be found through &lt;a href=&quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;ADL&lt;/a&gt;. One function will do.</source>
          <target state="translated">&amp;dagger;还有其他主张，我们应该针对我们的类型专门使用 &lt;code&gt;std::swap&lt;/code&gt; ，在提供免费 &lt;code&gt;swap&lt;/code&gt; 功能的同时提供类内 &lt;code&gt;swap&lt;/code&gt; 功能，等等。但这都是不必要的：对 &lt;code&gt;swap&lt;/code&gt; 任何正确使用都将通过不合格的使用调用，我们的功能将通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;ADL&lt;/a&gt;找到。 一种功能将起作用。</target>
        </trans-unit>
        <trans-unit id="d2f8a6a9ff582b62e6b05e0ec952e18a7cba21f7" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/questions/5695548/public-friend-swap-member-function&quot;&gt;Here&lt;/a&gt; is the explanation why &lt;code&gt;public friend swap&lt;/code&gt;.) Now not only can we swap our &lt;code&gt;dumb_array&lt;/code&gt;'s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.</source>
          <target state="translated">（ &lt;a href=&quot;https://stackoverflow.com/questions/5695548/public-friend-swap-member-function&quot;&gt;这&lt;/a&gt;是为什么 &lt;code&gt;public friend swap&lt;/code&gt; 。）现在，我们不仅可以交换 &lt;code&gt;dumb_array&lt;/code&gt; 的交换，而且一般而言交换可以更有效； 它仅交换指针和大小，而不分配和复制整个数组。 除了在功能和效率上获得这种奖励外，我们现在还可以实现复制和交换的习惯用法。</target>
        </trans-unit>
        <trans-unit id="e3d46a3ef24d9ab6012b40252b69014fa5aa5434" translate="yes" xml:space="preserve">
          <source>(Not only that, but unqualified calls to &lt;code&gt;swap&lt;/code&gt; will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that &lt;code&gt;std::swap&lt;/code&gt; would entail.)</source>
          <target state="translated">（不仅如此，对 &lt;code&gt;swap&lt;/code&gt; 的不合格调用将使用我们的自定义swap运算符，跳过不必要的构造和销毁 &lt;code&gt;std::swap&lt;/code&gt; 所需的类。）</target>
        </trans-unit>
        <trans-unit id="fc5de9386b1a45a3cfcfa383e680e501a72d73b4" translate="yes" xml:space="preserve">
          <source>(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)</source>
          <target state="translated">(注意,有些编译器不支持构造函数委托;在这种情况下,我们必须手动默认构造类。这是一个不幸的任务,但幸运的是,这是一个琐碎的任务。)</target>
        </trans-unit>
        <trans-unit id="5e19805a2e15f201ad87bd588181abb3d0cc728b" translate="yes" xml:space="preserve">
          <source>(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one? While this may seem to be a valid concern, and indeed it requires non-trivial &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; clauses, this is a non-issue. That's because a class should manage &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;em&gt;one resource only&lt;/em&gt;&lt;/a&gt;!)</source>
          <target state="translated">（一个人可能想知道：如果需要大量的代码来正确地管理一种资源，那么如果我的类可以管理多个资源呢？这似乎是一个有效的问题，并且确实需要非平凡的 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 子句，但这是一个非问题。这是因为一个类&lt;a href=&quot;http://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;em&gt;只能&lt;/em&gt;&lt;/a&gt;管理&lt;em&gt;一个资源&lt;/em&gt; ！）</target>
        </trans-unit>
        <trans-unit id="5f022b51a041ef6021d6448cd154d99898408496" translate="yes" xml:space="preserve">
          <source>*Why do we set &lt;code&gt;mArray&lt;/code&gt; to null? Because if any further code in the operator throws, the destructor of &lt;code&gt;dumb_array&lt;/code&gt; might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</source>
          <target state="translated">*为什么我们将 &lt;code&gt;mArray&lt;/code&gt; 设置为null？ 因为如果操作符中的任何其他代码抛出，则可能会调用 &lt;code&gt;dumb_array&lt;/code&gt; 的析构函数； 如果在没有将其设置为null的情况下发生这种情况，我们将尝试删除已经删除的内存！ 我们通过将其设置为null来避免这种情况，因为删除null是无操作的。</target>
        </trans-unit>
        <trans-unit id="b66b8649c482abfc519d6e23ca6ba54f66162dcc" translate="yes" xml:space="preserve">
          <source>... the compiler will yell at you when you call the &lt;code&gt;swap&lt;/code&gt; function:</source>
          <target state="translated">...当您调用 &lt;code&gt;swap&lt;/code&gt; 函数时，编译器会大喊大叫：</target>
        </trans-unit>
        <trans-unit id="739480efc6308b236632d75a12d950aab5506d77" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616&quot;&gt;Conceptually&lt;/a&gt;, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a &lt;code&gt;swap&lt;/code&gt; function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616&quot;&gt;从概念上讲&lt;/a&gt; ，它通过使用复制构造函数的功能来创建数据的本地副本，然后使用 &lt;code&gt;swap&lt;/code&gt; 功能获取复制的数据，将旧数据与新数据交换，从而进行工作。 然后，临时副本将销毁，并随身携带旧数据。 我们剩下的是新数据的副本。</target>
        </trans-unit>
        <trans-unit id="d8e39573869dabdfb98f89cc9b39812879c351fd" translate="yes" xml:space="preserve">
          <source>@wilhelmtell: In C++03, there is no mention of exceptions potentially thrown by std::string::swap (which is called by std::swap). In C++0x, std::string::swap is noexcept and must not throw exceptions. &amp;ndash; James McNellis Dec 22 '10 at 15:24</source>
          <target state="translated">@wilhelmtell：在C ++ 03中，没有提到std :: string :: swap（由std :: swap调用）可能引发的异常。 在C ++ 0x中，std :: string :: swap为noexcept且不得引发异常。 &amp;ndash; James McNellis 10年12月22日在15:24</target>
        </trans-unit>
        <trans-unit id="8a6f040aeb295117c1efb68678f192378c4a33b9" translate="yes" xml:space="preserve">
          <source>A failed solution</source>
          <target state="translated">一个失败的解决方案</target>
        </trans-unit>
        <trans-unit id="1f123ac936e30fe0974c20eefdb479af236b59d9" translate="yes" xml:space="preserve">
          <source>A successful solution</source>
          <target state="translated">一个成功的解决方案</target>
        </trans-unit>
        <trans-unit id="0a8b69bb09bc2425818b674879026645aff63337" translate="yes" xml:space="preserve">
          <source>A swap function is a &lt;em&gt;non-throwing&lt;/em&gt; function that swaps two objects of a class, member for member. We might be tempted to use &lt;code&gt;std::swap&lt;/code&gt; instead of providing our own, but this would be impossible; &lt;code&gt;std::swap&lt;/code&gt; uses the copy-constructor and copy-assignment operator within its implementation, and we'd ultimately be trying to define the assignment operator in terms of itself!</source>
          <target state="translated">交换函数是一种&lt;em&gt;非抛出&lt;/em&gt;函数，它交换一个类的两个对象，一个成员一个成员。 我们可能很想使用 &lt;code&gt;std::swap&lt;/code&gt; 而不是提供我们自己的，但是这是不可能的。 &lt;code&gt;std::swap&lt;/code&gt; 使用了copy-constructor和copy-assignment运算符，我们最终将尝试根据自身定义赋值运算符！</target>
        </trans-unit>
        <trans-unit id="18c04be3fc2a0bcac1f0511d9edd72d5489a05de" translate="yes" xml:space="preserve">
          <source>A way around this is to not use &lt;code&gt;friend&lt;/code&gt; keyword and redefine the &lt;code&gt;swap&lt;/code&gt; function:</source>
          <target state="translated">一种解决方法是不使用 &lt;code&gt;friend&lt;/code&gt; 关键字并重新定义 &lt;code&gt;swap&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="96739476d5a5d3d0fbe5f2e1e80ac733b38525c4" translate="yes" xml:space="preserve">
          <source>A way of implementing the assignment operator in terms of a swap function:</source>
          <target state="translated">用交换函数实现赋值运算器的一种方法。</target>
        </trans-unit>
        <trans-unit id="099a6586cd9d3a08c5d495a2db19fa35488b71be" translate="yes" xml:space="preserve">
          <source>After all, you don't &lt;em&gt;need&lt;/em&gt; to use a &lt;code&gt;friend&lt;/code&gt; function to swap 2 objects. It makes just as much sense to make &lt;code&gt;swap&lt;/code&gt; a member function that has one &lt;code&gt;other&lt;/code&gt; object as a parameter.</source>
          <target state="translated">毕竟，您&lt;em&gt;不需要&lt;/em&gt;使用 &lt;code&gt;friend&lt;/code&gt; 函数来交换2个对象。 使 &lt;code&gt;swap&lt;/code&gt; 成为具有 &lt;code&gt;other&lt;/code&gt; 对象作为参数的成员函数同样有意义。</target>
        </trans-unit>
        <trans-unit id="c864fce5142351dfaef1c82c9c081e821224b89b" translate="yes" xml:space="preserve">
          <source>Although it's been mentioned in many places, we didn't have any singular &quot;what is it&quot; question and answer, so here it is. Here is a partial list of places where it was previously mentioned:</source>
          <target state="translated">虽然在很多地方都有提到过,但我们并没有单数的 &quot;是什么 &quot;问答,所以就在这里。下面是之前提到它的部分地方。</target>
        </trans-unit>
        <trans-unit id="e9671eba126f32f76a109bf11cdbf7cf819ba06b" translate="yes" xml:space="preserve">
          <source>An in-depth explanation</source>
          <target state="translated">深入的解释</target>
        </trans-unit>
        <trans-unit id="c73d2a01cb43ee42c7ec7bce3573c7cec34d6cdc" translate="yes" xml:space="preserve">
          <source>And so concludes the copy-and-swap idiom.</source>
          <target state="translated">抄袭互换这个成语就这样结束了。</target>
        </trans-unit>
        <trans-unit id="9b5dace86273f14ab55c392c7b880a011ead98aa" translate="yes" xml:space="preserve">
          <source>And that is the copy-and-swap idiom.</source>
          <target state="translated">而这就是复制交换的成语。</target>
        </trans-unit>
        <trans-unit id="2c207f27020378f00a7220d5874fff08752c57e7" translate="yes" xml:space="preserve">
          <source>And that's it! With one fell swoop, all three problems are elegantly tackled at once.</source>
          <target state="translated">就这么简单! 一下子就能优雅地解决这三个问题。</target>
        </trans-unit>
        <trans-unit id="a253fea1b4ead859fd72efb21cf1f3617ee2fe71" translate="yes" xml:space="preserve">
          <source>And we say we're finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as &lt;code&gt;(n)&lt;/code&gt;.</source>
          <target state="translated">我们说我们完成了； 现在，它可以管理阵列，而不会泄漏。 但是，它存在三个问题，在代码中依次标记为 &lt;code&gt;(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46cb3e743fce8064b54f7c24bedac5fd2b065252" translate="yes" xml:space="preserve">
          <source>Any class that manages a resource (a &lt;em&gt;wrapper&lt;/em&gt;, like a smart pointer) needs to implement &lt;a href=&quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three&quot;&gt;The Big Three&lt;/a&gt;. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?</source>
          <target state="translated">任何管理资源的类（ &lt;em&gt;包装器&lt;/em&gt; ，如智能指针）都需要实现&lt;a href=&quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three&quot;&gt;&amp;ldquo;三巨头&amp;rdquo;&lt;/a&gt; 。 尽管复制构造函数和析构函数的目标和实现很简单，但是复制分配运算符无疑是最细微和最困难的。 应该怎么做？ 需要避免什么陷阱？</target>
        </trans-unit>
        <trans-unit id="b5f0db215ce832cd77e56cc7229f8e1b22ecb595" translate="yes" xml:space="preserve">
          <source>As mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a &lt;code&gt;swap&lt;/code&gt; function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called &quot;The Big Three and A Half&quot;: any time your class manages a resource it also makes sense to provide a &lt;code&gt;swap&lt;/code&gt; function.</source>
          <target state="translated">如前所述，复制和交换惯用语将解决所有这些问题。 但是现在，除了一个需求之外，我们还有所有其他需求： &lt;code&gt;swap&lt;/code&gt; 功能。 尽管&amp;ldquo;三规则&amp;rdquo;成功地意味着我们必须存在复制构造函数，赋值运算符和析构函数，但它实际上应该被称为&amp;ldquo;三大一半&amp;rdquo;：每当您的班级管理资源时，提供 &lt;code&gt;swap&lt;/code&gt; 也是有意义的。功能。</target>
        </trans-unit>
        <trans-unit id="89e4ca10b74850fc9016dbb8310675a1462b938c" translate="yes" xml:space="preserve">
          <source>Assignment, at its heart, is two steps: &lt;strong&gt;&lt;em&gt;tearing down the object's old state&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;building its new state as a copy&lt;/em&gt;&lt;/strong&gt; of some other object's state.</source>
          <target state="translated">分配从&lt;strong&gt;&lt;em&gt;本质上讲分&lt;/em&gt;&lt;/strong&gt;两个步骤： &lt;strong&gt;&lt;em&gt;拆除对象的旧状态&lt;/em&gt;&lt;/strong&gt;和将&lt;strong&gt;&lt;em&gt;其新状态构建为&lt;/em&gt;&lt;/strong&gt;其他对象状态&lt;strong&gt;&lt;em&gt;的副本&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4de93db789fe9ea751b9c3c9f7efc0214b87843" translate="yes" xml:space="preserve">
          <source>At this point we are home-free, because &lt;code&gt;swap&lt;/code&gt; is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter's scope ends and its destructor is called.)</source>
          <target state="translated">在这一点上，我们是无家可归的，因为 &lt;code&gt;swap&lt;/code&gt; 是无用的。 我们将当前数据与复制的数据交换，安全地更改状态，并将旧数据放入临时数据中。 函数返回时，将释放旧数据。 （在该参数的作用域终止并调用其析构函数的位置。）</target>
        </trans-unit>
        <trans-unit id="22b41cb12332be04aca21ea73d3c777d0bbc2bc4" translate="yes" xml:space="preserve">
          <source>Basically, that's what the &lt;strong&gt;&lt;em&gt;destructor&lt;/em&gt;&lt;/strong&gt; and the &lt;strong&gt;&lt;em&gt;copy constructor&lt;/em&gt;&lt;/strong&gt; do, so the first idea would be to delegate the work to them. However, since destruction mustn't fail, while construction might, &lt;em&gt;we actually want to do it the other way around&lt;/em&gt;: &lt;strong&gt;&lt;em&gt;first perform the constructive part&lt;/em&gt;&lt;/strong&gt; and, if that succeeded, &lt;strong&gt;&lt;em&gt;then do the destructive part&lt;/em&gt;&lt;/strong&gt;. The copy-and-swap idiom is a way to do just that: It first calls a class' copy constructor to create a temporary object, then swaps its data with the temporary's, and then lets the temporary's destructor destroy the old state.</source>
          <target state="translated">基本上，这就是&lt;strong&gt;&lt;em&gt;析构函数&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;复制构造函数的工作&lt;/em&gt;&lt;/strong&gt; ，因此第一个想法是将工作委托给他们。 但是，由于销毁一定不会失败，而在构建可能会失败的情况下， &lt;em&gt;我们实际上希望以另一种方式进行&lt;/em&gt; ： &lt;strong&gt;&lt;em&gt;首先执行建设性部分&lt;/em&gt;&lt;/strong&gt; ，如果成功， &lt;strong&gt;&lt;em&gt;则进行破坏性部分&lt;/em&gt;&lt;/strong&gt; 。 复制和交换惯用语是一种做到这一点的方法：它首先调用类的复制构造函数以创建一个临时对象，然后将其数据与该临时对象交换，然后让该临时对象的析构函数销毁旧状态。</target>
        </trans-unit>
        <trans-unit id="21f3313cd21a2541f96630aa3e2a0cf47d569892" translate="yes" xml:space="preserve">
          <source>Because the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of &lt;code&gt;operator=&lt;/code&gt;. (Additionally, we no longer have a performance penalty on non-self-assignments.)</source>
          <target state="translated">由于该惯用语不重复任何代码，因此我们无法在运算符内引入错误。 请注意，这意味着我们不再需要进行自赋值检查，而只需要统一执行 &lt;code&gt;operator=&lt;/code&gt; 。 （此外，我们不再对非自我分配给予绩效惩罚。）</target>
        </trans-unit>
        <trans-unit id="ee86d87c6e42b253320f7528f74891164bb782f1" translate="yes" xml:space="preserve">
          <source>C++: dynamically allocating an array of objects?</source>
          <target state="translated">C++:动态分配对象数组?</target>
        </trans-unit>
        <trans-unit id="e729ebfbf18123cb9c8f157732414fc00291bf88" translate="yes" xml:space="preserve">
          <source>Copy constructor and = operator overload in C++: is a common function possible?</source>
          <target state="translated">在C++中复制构造函数和=操作符重载:是否可以用通用函数?</target>
        </trans-unit>
        <trans-unit id="94f8c0f65181c1bf410e4113cb80538a2f639df0" translate="yes" xml:space="preserve">
          <source>Either way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.</source>
          <target state="translated">不管是哪种方式,这种获取资源的方法都是消除代码重复的关键:我们可以使用复制构造器中的代码来进行复制,而且永远不需要重复任何一点。现在,副本做完了,我们就可以进行交换了。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="79202c91683120bfb6ddb6c07a5bad7dc7c88c9b" translate="yes" xml:space="preserve">
          <source>For concreteness, let us consider a container &lt;code&gt;std::vector&amp;lt;T, A&amp;gt;&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is some stateful allocator type, and we'll compare the following functions:</source>
          <target state="translated">为了具体起见，让我们考虑一个容器 &lt;code&gt;std::vector&amp;lt;T, A&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一些有状态的分配器类型，我们将比较以下函数：</target>
        </trans-unit>
        <trans-unit id="f160b70becf0b5d89fbecbeb4ad05cafa0e60064" translate="yes" xml:space="preserve">
          <source>Here's how a naive implementation might look:</source>
          <target state="translated">下面是一个天真的实现方式。</target>
        </trans-unit>
        <trans-unit id="bec44ad24b77ebad1653d346d85b618d564afd9f" translate="yes" xml:space="preserve">
          <source>Here, a hand-written &lt;code&gt;Client::operator=&lt;/code&gt; might check if &lt;code&gt;*this&lt;/code&gt; is already connected to the same server as &lt;code&gt;rhs&lt;/code&gt; (perhaps sending a &quot;reset&quot; code if useful), whereas the copy-and-swap approach would invoke the copy-constructor which would likely be written to open a distinct socket connection then close the original one.  Not only could that mean a remote network interaction instead of a simple in-process variable copy, it could run afoul of client or server limits on socket resources or connections.  (Of course this class has a pretty horrid interface, but that's another matter ;-P).</source>
          <target state="translated">在这里，手写的 &lt;code&gt;Client::operator=&lt;/code&gt; 可能会检查 &lt;code&gt;*this&lt;/code&gt; 是否已与 &lt;code&gt;rhs&lt;/code&gt; 连接到同一服务器（如果有用，可能会发送&amp;ldquo;重置&amp;rdquo;代码），而复制和交换方法将调用复制-构造函数，可能会被用来打开一个独特的套接字连接，然后关闭原始套接字连接。 这不仅意味着远程网络交互，而不是简单的进程内变量副本，还可能违反客户端或服务器对套接字资源或连接的限制。 （当然，此类有一个非常恐怖的界面，但这是另一回事；-P）。</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">它是如何运作的?</target>
        </trans-unit>
        <trans-unit id="fc088e1a9c9b7f4c8a1d611a7ecd41e9c5e1abfa" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt;, the program has &lt;em&gt;undefined behaviour&lt;/em&gt; (cf. [container.requirements.general/8].</source>
          <target state="translated">但是，如果 &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt; ，则程序具有&lt;em&gt;未定义的行为&lt;/em&gt; （参见[container.requirements.general / 8]。</target>
        </trans-unit>
        <trans-unit id="236be016134b3d1b54ff3ee12c4a2f9cc364e3e2" translate="yes" xml:space="preserve">
          <source>I would like to add a word of warning when you are dealing with C++11-style allocator-aware containers. Swapping and assignment have subtly different semantics.</source>
          <target state="translated">当你在处理C++11风格的allocator-aware容器时,我想补充一句警告。交换和赋值有微妙的不同语义。</target>
        </trans-unit>
        <trans-unit id="3f28ca2de2b68eac16c3d42e71f3ac049eaef11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_move_assignment&lt;/code&gt; is &lt;code&gt;std::true_type&lt;/code&gt;, then &lt;code&gt;fm&lt;/code&gt; reassigns the allocator of &lt;code&gt;a&lt;/code&gt; with the value of &lt;code&gt;b.get_allocator()&lt;/code&gt;, otherwise it does not, and &lt;code&gt;a&lt;/code&gt; continues to use its original allocator. In that case, the data elements need to be swapped individually, since the storage of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is not compatible.</source>
          <target state="translated">如果 &lt;code&gt;AT::propagate_on_container_move_assignment&lt;/code&gt; 是 &lt;code&gt;std::true_type&lt;/code&gt; ，则 &lt;code&gt;fm&lt;/code&gt; 会使用 &lt;code&gt;b.get_allocator()&lt;/code&gt; 的值重新分配 &lt;code&gt;a&lt;/code&gt; 的分配器，否则它将不分配，并且 &lt;code&gt;a&lt;/code&gt; 继续使用其原始分配器。 在那种情况下，数据元素需要单独交换，因为 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的存储不兼容。</target>
        </trans-unit>
        <trans-unit id="4510757f293d56b7a112af8252c4984d58f759e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;std::false_type&lt;/code&gt;, then we need a dynamic check.</source>
          <target state="translated">如果 &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; 是 &lt;code&gt;std::false_type&lt;/code&gt; ，那么我们需要动态检查。</target>
        </trans-unit>
        <trans-unit id="b3573d07a320cef433ba754980663abfd331a87f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;std::true_type&lt;/code&gt;, then &lt;code&gt;fs&lt;/code&gt; swaps both data and allocators in the expected fashion.</source>
          <target state="translated">如果 &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; 是 &lt;code&gt;std::true_type&lt;/code&gt; ，则 &lt;code&gt;fs&lt;/code&gt; 会以预期的方式交换数据和分配器。</target>
        </trans-unit>
        <trans-unit id="73d3a4270600b651da25bd4b3260fe77df37829f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.get_allocator() == b.get_allocator()&lt;/code&gt;, then the two containers use compatible storage, and swapping proceeds in the usual fashion.</source>
          <target state="translated">如果 &lt;code&gt;a.get_allocator() == b.get_allocator()&lt;/code&gt; ，则这两个容器将使用兼容的存储，并且交换将以通常的方式进行。</target>
        </trans-unit>
        <trans-unit id="b8d03c15d57131584a2028550fb794a9339e9cad" translate="yes" xml:space="preserve">
          <source>In its refined form, copy-and-swap is implemented by having the copy performed by initializing the (non-reference) parameter of the assignment operator:</source>
          <target state="translated">在其完善的形式中,复制和交换是通过初始化赋值运算符的(非参考)参数来实现的。</target>
        </trans-unit>
        <trans-unit id="9f37decf779a75710e40ed5c33a2089302cd7911" translate="yes" xml:space="preserve">
          <source>In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a &lt;code&gt;swap&lt;/code&gt; function.</source>
          <target state="translated">为了使用复制和交换的习惯用法，我们需要三件事：一个有效的复制构造函数，一个有效的析构函数（两者都是任何包装程序的基础，因此无论如何都应完整）以及 &lt;code&gt;swap&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="8c6f02b160b536e0af64d17d3f8eab3f4e9be471" translate="yes" xml:space="preserve">
          <source>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.</source>
          <target state="translated">在我们的案例中,它的核心只有两行(分配和复制),但对于更复杂的资源,这种代码的臃肿会让人觉得相当麻烦。我们应该努力做到永远不重复。</target>
        </trans-unit>
        <trans-unit id="41bf38d748ecfa54c2c45421d2ad416833ae458b" translate="yes" xml:space="preserve">
          <source>In some versions of Visual Studio (and possibly other compilers) there is a bug that is really annoying and doesn't make sense. So if you declare/define your &lt;code&gt;swap&lt;/code&gt; function like this:</source>
          <target state="translated">在某些版本的Visual Studio（可能还有其他编译器）中，存在一个确实令人讨厌且没有道理的错误。 因此，如果您这样声明/定义 &lt;code&gt;swap&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a9821302f3683bd9875458d7b470497ba0484ef2" translate="yes" xml:space="preserve">
          <source>Let's consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:</source>
          <target state="translated">让我们考虑一个具体的案例。我们想在一个无用的类中管理一个动态数组。我们从一个工作的构造函数、复制构造函数和解析器开始。</target>
        </trans-unit>
        <trans-unit id="27c808c7552dbd2cdeb49163a8d2a3c074f0dbac" translate="yes" xml:space="preserve">
          <source>Luckily for us, this is easy:</source>
          <target state="translated">幸运的是,这对我们来说很容易。</target>
        </trans-unit>
        <trans-unit id="7402c1a7b7b4cd8a707b425e610cbcb74419bc20" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;other&lt;/code&gt; is being initialized with an rvalue, &lt;em&gt;it will be move-constructed&lt;/em&gt;. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will &lt;em&gt;automatically&lt;/em&gt; pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)</source>
          <target state="translated">现在，如果 &lt;code&gt;other&lt;/code&gt; 正在使用右值初始化， &lt;em&gt;则它将被移动构造&lt;/em&gt; 。 完善。 以相同的方式，C ++ 03让我们通过按值获取参数来重用复制构造函数的功能，C ++ 11也会在适当时&lt;em&gt;自动&lt;/em&gt;选择move-constructor。 （并且，当然，如先前链接的文章中所述，可以完全省去复制/移动值的过程。）</target>
        </trans-unit>
        <trans-unit id="dcbeb7c58de6f8ef2e5b152493010bd5fba66a2c" translate="yes" xml:space="preserve">
          <source>Observe that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won't even enter the function if construction of the copy fails, and it's therefore not possible to alter the state of &lt;code&gt;*this&lt;/code&gt;. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)</source>
          <target state="translated">观察到进入该功能后，所有新数据都已被分配，复制并准备使用。 这就是免费提供强大的异常保证的原因：如果复制的构造失败，我们甚至都不会输入该函数，因此无法更改 &lt;code&gt;*this&lt;/code&gt; 的状态。 （我们以前为确保强大的异常保证而手动进行的工作，现在编译器正在为我们做；这是多么友好。）</target>
        </trans-unit>
        <trans-unit id="e6868ab3511bcd3b27c0685657d0cf94d4a5c6ed" translate="yes" xml:space="preserve">
          <source>On self-assignment, the above code delete's &lt;code&gt;x.p_;&lt;/code&gt;, points &lt;code&gt;p_&lt;/code&gt; at a newly allocated heap region, then attempts to read the &lt;em&gt;uninitialised&lt;/em&gt; data therein (Undefined Behaviour), if that doesn't do anything too weird, &lt;code&gt;copy&lt;/code&gt; attempts a self-assignment to every just-destructed 'T'!</source>
          <target state="translated">在自我分配时，上述代码删除了 &lt;code&gt;x.p_;&lt;/code&gt; ，将 &lt;code&gt;p_&lt;/code&gt; 指向新分配的堆区域，然后尝试读取其中的&lt;em&gt;未初始化&lt;/em&gt;数据（未定义行为），如果这样做没有什么奇怪之处，则 &lt;code&gt;copy&lt;/code&gt; 尝试对每个刚破坏的&amp;ldquo; T&amp;rdquo;进行自我分配！</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9c234a83c1275c3ee466e4738c02c7633c54a69e" translate="yes" xml:space="preserve">
          <source>Self-assignment done as a copy-and-swap avoids oft-overlooked edge cases.&amp;Dagger;</source>
          <target state="translated">通过复制和交换进行自我分配可以避免经常被忽视的边缘情况。&amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="6f659bc43bf7db07f752a5d1512e544f94e1af00" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;swap()&lt;/code&gt; is supposed to never fail, the only part which might fail is the copy-construction. That is performed first, and if it fails, nothing will be changed in the targeted object.</source>
          <target state="translated">由于 &lt;code&gt;swap()&lt;/code&gt; 应该永远不会失败，因此唯一可能失败的部分就是复制构造。 首先执行该操作，如果失败，则目标对象将保持不变。</target>
        </trans-unit>
        <trans-unit id="26f7740f7272c6a37203cde27ca0ef723ebbbf32" translate="yes" xml:space="preserve">
          <source>So what we've done is simple: initialize via the default constructor (a C++11 feature), then swap with &lt;code&gt;other&lt;/code&gt;; we know a default constructed instance of our class can safely be assigned and destructed, so we know &lt;code&gt;other&lt;/code&gt; will be able to do the same, after swapping.</source>
          <target state="translated">因此，我们所做的很简单：通过默认构造函数（C ++ 11功能）进行初始化，然后与 &lt;code&gt;other&lt;/code&gt; 交换； 我们知道可以安全地分配和销毁我们类的默认构造实例，因此我们知道 &lt;code&gt;other&lt;/code&gt; 人可以在交换后执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="2b5693bc5962ed6f9799bbcb35014ba8ea8fefd0" translate="yes" xml:space="preserve">
          <source>That is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:</source>
          <target state="translated">这是我们唯一需要对我们的类做的改变,那么为什么它能成功呢?还记得我们做了一个永远重要的决定,那就是把参数作为一个值而不是引用。</target>
        </trans-unit>
        <trans-unit id="9ef6aff2994558c1366be20966048a47a804bb07" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;copy-and-swap idiom&lt;/em&gt; is the solution, and elegantly assists the assignment operator in achieving two things: avoiding &lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;code duplication&lt;/a&gt;, and providing a &lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_guarantees&quot;&gt;strong exception guarantee&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;复制和交换惯用语&lt;/em&gt;是解决方案，可以&lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_guarantees&quot;&gt;很好&lt;/a&gt;地协助赋值运算符实现两件事：避免&lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;代码重复&lt;/a&gt; ，并提供强大的异常保证 。</target>
        </trans-unit>
        <trans-unit id="42e54c42a60d22bc2d5ac75e35558832e40d8bb3" translate="yes" xml:space="preserve">
          <source>The code has expanded! Which leads us to the third problem: code duplication. Our assignment operator effectively duplicates all the code we've already written elsewhere, and that's a terrible thing.</source>
          <target state="translated">代码扩大了! 这就引出了第三个问题:代码重复。我们的赋值运算器有效地重复了我们在其他地方已经写过的所有代码,这是很糟糕的事情。</target>
        </trans-unit>
        <trans-unit id="63d41c6ca1535180248065869d3328499b07b825" translate="yes" xml:space="preserve">
          <source>The first  is the self-assignment test. This check serves two purposes: it's an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste. It would be better if the operator could work properly without it.</source>
          <target state="translated">首先是自分配测试。这个检查有两个目的:它是防止我们在自分配上运行不必要的代码的一个简单方法,它可以保护我们免受微妙的bug(比如删除数组只是为了尝试复制它)。但在所有其他情况下,它只是起到了拖慢程序速度的作用,在代码中充当噪音的作用;自分配很少发生,所以大多数时候这种检查是一种浪费。如果没有它,操作者能正常工作就更好了。</target>
        </trans-unit>
        <trans-unit id="6f60ff23b795c7da205d246f356a1def07956d8e" translate="yes" xml:space="preserve">
          <source>The fundamental idea is that:</source>
          <target state="translated">其基本思路是:</target>
        </trans-unit>
        <trans-unit id="83588406b98957bd4b1f640c1bf0685f68308d07" translate="yes" xml:space="preserve">
          <source>The goal</source>
          <target state="translated">目标</target>
        </trans-unit>
        <trans-unit id="fd746b321830bfc8609d2fd310324c39c1c7bf04" translate="yes" xml:space="preserve">
          <source>The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now &lt;strong&gt;The Rule of Four&lt;/strong&gt; (and a half). Why? Because not only do we need to be able to copy-construct our resource, &lt;a href=&quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me&quot;&gt;we need to move-construct it as well&lt;/a&gt;.</source>
          <target state="translated">C ++的下一个版本C ++ 11对我们管理资源的方式进行了非常重要的更改：&amp;ldquo;三个规则&amp;rdquo;现在&lt;strong&gt;是&amp;ldquo;四个规则&lt;/strong&gt; （一个半）&amp;rdquo;。 为什么？ 因为我们不仅需要能够复制构建资源，还&lt;a href=&quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me&quot;&gt;需要移动构建&lt;/a&gt;资源。</target>
        </trans-unit>
        <trans-unit id="150781c474b203c76af89ffc1927280c58bbd0ff" translate="yes" xml:space="preserve">
          <source>The purpose of both functions &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;fm&lt;/code&gt; is to give &lt;code&gt;a&lt;/code&gt; the state that &lt;code&gt;b&lt;/code&gt; had initially. However, there is a hidden question: What happens if &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt;? The answer is: It depends. Let's write &lt;code&gt;AT = std::allocator_traits&amp;lt;A&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;fs&lt;/code&gt; 和 &lt;code&gt;fm&lt;/code&gt; 的目的是使 &lt;code&gt;a&lt;/code&gt; 最初具有 &lt;code&gt;b&lt;/code&gt; 的状态。 但是，存在一个隐藏的问题：如果 &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt; 会发生什么？ 答案是：这取决于。 让我们写 &lt;code&gt;AT = std::allocator_traits&amp;lt;A&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e8b0eb32111093ee430fedf7a03880593d06a45" translate="yes" xml:space="preserve">
          <source>The second is that it only provides a basic exception guarantee. If &lt;code&gt;new int[mSize]&lt;/code&gt; fails, &lt;code&gt;*this&lt;/code&gt; will have been modified. (Namely, the size is wrong and the data is gone!) For a strong exception guarantee, it would need to be something akin to:</source>
          <target state="translated">第二个是它仅提供基本的异常保证。 如果 &lt;code&gt;new int[mSize]&lt;/code&gt; 失败，则 &lt;code&gt;*this&lt;/code&gt; 将被修改。 （即，大小错误，数据不见了！）要获得强大的异常保证，它必须类似于以下内容：</target>
        </trans-unit>
        <trans-unit id="2c6fcc3a8c5ecf729853f999132fcff2680df339" translate="yes" xml:space="preserve">
          <source>The upshot is that swapping has become a non-trivial operation in C++11 as soon as your container starts supporting stateful allocators. That's a somewhat &quot;advanced use case&quot;, but it's not entirely unlikely, since move optimizations usually only become interesting once your class manages a resource, and memory is one of the most popular resources.</source>
          <target state="translated">其结果是,只要你的容器开始支持有状态的分配器,那么在C++11中,swapping已经成为了一个不简单的操作。这是一个有点 &quot;高级用例&quot;,但也不是完全不可能,因为通常只有当你的类管理一个资源时,移动优化才会变得有趣,而内存是最受欢迎的资源之一。</target>
        </trans-unit>
        <trans-unit id="388be71290411a46bfa3cef8cea4ebaa96d6633d" translate="yes" xml:space="preserve">
          <source>There are some good answers already.  I'll focus &lt;em&gt;mainly&lt;/em&gt; on what I think they lack - an explanation of the &quot;cons&quot; with the copy-and-swap idiom....</source>
          <target state="translated">已经有一些好的答案。 我将&lt;em&gt;主要集中&lt;/em&gt;在我认为它们缺少的内容上-对&amp;ldquo;复制和交换&amp;rdquo;习语的&amp;ldquo;缺点&amp;rdquo;进行解释。</target>
        </trans-unit>
        <trans-unit id="cbe63039ab446d86b4ac167fd16b3d3dadd41365" translate="yes" xml:space="preserve">
          <source>This answer is more like an addition and a slight modification to the answers above.</source>
          <target state="translated">这个答案更像是一个加法,对上面的答案稍作修改。</target>
        </trans-unit>
        <trans-unit id="c1083ee173869cd02574e5832d5f7c99145ada0e" translate="yes" xml:space="preserve">
          <source>This class almost manages the array successfully, but it needs &lt;code&gt;operator=&lt;/code&gt; to work correctly.</source>
          <target state="translated">此类几乎成功地管理了阵列，但是需要 &lt;code&gt;operator=&lt;/code&gt; 才能正常工作。</target>
        </trans-unit>
        <trans-unit id="29f80c1b07d0671e4a256b348ff66c1e913f3c22" translate="yes" xml:space="preserve">
          <source>This has something to do with a &lt;code&gt;friend&lt;/code&gt; function being called and &lt;code&gt;this&lt;/code&gt; object being passed as a parameter.</source>
          <target state="translated">这与调用一个 &lt;code&gt;friend&lt;/code&gt; 函数以及 &lt;code&gt;this&lt;/code&gt; 对象作为参数传递有关。</target>
        </trans-unit>
        <trans-unit id="5aa765f67fd688a1ba7150d96a03c571fde7ba09" translate="yes" xml:space="preserve">
          <source>This time, you can just call &lt;code&gt;swap&lt;/code&gt; and pass in &lt;code&gt;other&lt;/code&gt;, thus making the compiler happy:</source>
          <target state="translated">这次，您可以调用 &lt;code&gt;swap&lt;/code&gt; 并传递 &lt;code&gt;other&lt;/code&gt; ，从而使编译器满意：</target>
        </trans-unit>
        <trans-unit id="633375af64a272c488ff9c504c74dbb8f98b646a" translate="yes" xml:space="preserve">
          <source>We first notice an important choice: the parameter argument is taken &lt;em&gt;by-value&lt;/em&gt;. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):</source>
          <target state="translated">我们首先注意到一个重要的选择：参数自变量采用&lt;em&gt;by-value&lt;/em&gt; 。 尽管可以很容易地完成以下操作（事实上，许多成语的幼稚实现都可以做到）：</target>
        </trans-unit>
        <trans-unit id="63217325aa31565f08b4e39b47c1e5fc48d70a30" translate="yes" xml:space="preserve">
          <source>We lose an &lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;important optimization opportunity&lt;/a&gt;. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list.&amp;Dagger;)</source>
          <target state="translated">我们失去了&lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;重要的优化机会&lt;/a&gt; 。 不仅如此，这种选择在C ++ 11中至关重要，稍后将进行讨论。 （一般来说，非常有用的准则如下：如果要在函数中复制某些内容，请让编译器在参数列表中进行。）</target>
        </trans-unit>
        <trans-unit id="9edc40ca06ad2a68fa87b0a4a4acc15e97ae9f73" translate="yes" xml:space="preserve">
          <source>We need to add swap functionality to our class, and we do that as follows&amp;dagger;:</source>
          <target state="translated">我们需要将交换功能添加到我们的类中，我们这样做如下&amp;dagger;：</target>
        </trans-unit>
        <trans-unit id="c2edab5c5da4b7e0cb43225936cb000f569c92ee" translate="yes" xml:space="preserve">
          <source>What about C++11?</source>
          <target state="translated">那么C++11呢?</target>
        </trans-unit>
        <trans-unit id="787ffecc94ae151e431f132b817ebb5ac7bd5b64" translate="yes" xml:space="preserve">
          <source>What are your favorite C++ Coding Style idioms:  Copy-swap</source>
          <target state="translated">你最喜欢的C++编码风格的成语有哪些。复制交换</target>
        </trans-unit>
        <trans-unit id="6dc672ff6eb837cd0bbe834afc644c2d587d212d" translate="yes" xml:space="preserve">
          <source>What is copy elision and how it optimizes copy-and-swap idiom</source>
          <target state="translated">什么是复制脱模,以及如何优化复制交换成语</target>
        </trans-unit>
        <trans-unit id="3f800a7430fd4c0527c40982197ac647fe2c18a0" translate="yes" xml:space="preserve">
          <source>What is the copy-and-swap idiom</source>
          <target state="translated">什么是复制交换的成语</target>
        </trans-unit>
        <trans-unit id="a8f471015362e9a261fa62137612c1258db68efb" translate="yes" xml:space="preserve">
          <source>What is the copy-and-swap idiom?</source>
          <target state="translated">什么是抄袭交换的成语?</target>
        </trans-unit>
        <trans-unit id="ede6b7eaf3770f7b7b840f5f578c287f11e2cccd" translate="yes" xml:space="preserve">
          <source>What is this idiom and when should it be used? Which problems does it solve? Does the idiom change when C++11 is used?</source>
          <target state="translated">这个成语是什么,应该在什么时候使用?它能解决哪些问题?使用C++11时,这个成语会改变吗?</target>
        </trans-unit>
        <trans-unit id="aa7922596966a3f09ff20d40921994a57ffd3b96" translate="yes" xml:space="preserve">
          <source>What's going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.</source>
          <target state="translated">这到底是怎么回事?回想一下移动构造的目标:从类的另一个实例中获取资源,使其处于保证可分配和可破坏的状态。</target>
        </trans-unit>
        <trans-unit id="10170890d98f9c422d746d6a228ebc44fc0a6ee0" translate="yes" xml:space="preserve">
          <source>When any performance penalty or momentarily higher resource usage created by having an extra temporary object during the assignment is not important to your application. ⁂</source>
          <target state="translated">当在分配过程中,如果有一个额外的临时对象所产生的任何性能惩罚或暂时性的高资源使用量对您的应用程序来说并不重要。⁂</target>
        </trans-unit>
        <trans-unit id="60f80e0ee25da3bc05679b2ff44dd7fcf6b5baef" translate="yes" xml:space="preserve">
          <source>When should it be used?  (Which problems does it solve &lt;strong&gt;[/create]&lt;/strong&gt;?)</source>
          <target state="translated">什么时候应该使用？ （它可以解决&lt;strong&gt;[/ create]&lt;/strong&gt;哪些问题？）</target>
        </trans-unit>
        <trans-unit id="2634e1acfb3bf9e69b4daa989e044e2431bc5a1b" translate="yes" xml:space="preserve">
          <source>When you want a clean, easy to understand, robust way to define the assignment operator in terms of (simpler) copy constructor, &lt;code&gt;swap&lt;/code&gt; and destructor functions.</source>
          <target state="translated">当您想要一种简洁，易于理解，健壮的方式来根据（更简单的）复制构造函数， &lt;code&gt;swap&lt;/code&gt; 函数和析构函数来定义赋值运算符时。</target>
        </trans-unit>
        <trans-unit id="29733bade5cab23e00e5d05e6412f95b30d5413f" translate="yes" xml:space="preserve">
          <source>When you want the assigned-to objected unaffected by an assignment that throws an exception, assuming you have or can write a &lt;code&gt;swap&lt;/code&gt; with strong exception guarantee, and ideally one that can't fail/&lt;code&gt;throw&lt;/code&gt;..&amp;dagger;</source>
          <target state="translated">如果您希望被分配的对象不受抛出异常的赋值的影响，则假定您具有或可以编写具有强异常保证的 &lt;code&gt;swap&lt;/code&gt; ，并且理想情况下，该交换不能失败/ &lt;code&gt;throw&lt;/code&gt; ..&amp;dagger;</target>
        </trans-unit>
        <trans-unit id="62b4affc932ffa8cde8f9a8bc7cc83fb3e7fe0f0" translate="yes" xml:space="preserve">
          <source>Why do we need the copy-and-swap idiom?</source>
          <target state="translated">我们为什么要用复制交换这个成语?</target>
        </trans-unit>
        <trans-unit id="d1974d73fa36fa9b1fe2996664091dd361d57f96" translate="yes" xml:space="preserve">
          <source>Why does it work?</source>
          <target state="translated">为什么会有这样的效果?</target>
        </trans-unit>
        <trans-unit id="9c9b118f04e39a7318e3a5798cdcb9006d842f63" translate="yes" xml:space="preserve">
          <source>Why does that work?</source>
          <target state="translated">为什么会有这样的效果?</target>
        </trans-unit>
        <trans-unit id="b2665c67e419327eea773cca5cbb1ebf91e5f8c3" translate="yes" xml:space="preserve">
          <source>Without further ado, our assignment operator is:</source>
          <target state="translated">不用多说,我们的任务操作者是:</target>
        </trans-unit>
        <trans-unit id="e464362a2570aee7cf3bb10e5f052520cacc687e" translate="yes" xml:space="preserve">
          <source>You already have access to &lt;code&gt;this&lt;/code&gt; object, so passing it in as a parameter is technically redundant.</source>
          <target state="translated">您已经可以访问 &lt;code&gt;this&lt;/code&gt; 对象，因此将其作为参数传递在技术上是多余的。</target>
        </trans-unit>
        <trans-unit id="a945bce89ff4bd35449cef3d57b6ca6c27388c0e" translate="yes" xml:space="preserve">
          <source>swapping the state of the local copy &lt;code&gt;rhs&lt;/code&gt; and &lt;code&gt;*this&lt;/code&gt; is &lt;em&gt;usually&lt;/em&gt; relatively easy to do without potential failure/exceptions, given the local copy doesn't need any particular state afterwards (just needs state fit for the destructor to run, much as for an object being &lt;em&gt;moved&lt;/em&gt; from in &amp;gt;= C++11)</source>
          <target state="translated">交换本地副本 &lt;code&gt;rhs&lt;/code&gt; 和 &lt;code&gt;*this&lt;/code&gt; 的状态&lt;em&gt;通常&lt;/em&gt;相对容易，并且没有潜在的失败/异常，因为之后本地副本不需要任何特定的状态（只需要适合析构函数运行的状态即可，就像对象从&amp;gt; = C ++ 11中&lt;em&gt;移出&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="59f71233e3c4ef85ebf3d7a582670676fcefbffa" translate="yes" xml:space="preserve">
          <source>that acquisition can be attempted &lt;em&gt;before&lt;/em&gt; modifying the current state of the object (i.e. &lt;code&gt;*this&lt;/code&gt;) if a copy of the new value is made, which is why &lt;code&gt;rhs&lt;/code&gt; is accepted &lt;em&gt;by value&lt;/em&gt; (i.e. copied) rather than &lt;em&gt;by reference&lt;/em&gt;</source>
          <target state="translated">如果进行了新值的复制，则可以&lt;em&gt;在&lt;/em&gt;修改对象的当前状态（即 &lt;code&gt;*this&lt;/code&gt; ） &lt;em&gt;之前&lt;/em&gt;尝试&lt;em&gt;进行&lt;/em&gt;获取，这就是为什么 &lt;code&gt;rhs&lt;/code&gt; 被&lt;em&gt;值&lt;/em&gt; （即复制）而不是&lt;em&gt;引用&lt;/em&gt;所接受&lt;em&gt;的&lt;/em&gt;原因</target>
        </trans-unit>
        <trans-unit id="325605391ecda9b9100aa948f683600e372575dc" translate="yes" xml:space="preserve">
          <source>the most error-prone part of assigning to an object is ensuring any resources the new state needs are acquired (e.g. memory, descriptors)</source>
          <target state="translated">分配给一个对象最容易出错的部分是确保新状态所需的任何资源(如内存、描述符等)被获取。</target>
        </trans-unit>
        <trans-unit id="33fd9e929e77e0dfd3e85632f2f3ada808c62662" translate="yes" xml:space="preserve">
          <source>⁂ The copy-and-swap idiom can introduce inefficiencies or limitations due to the use of an extra temporary (when the operator's parameter is copy-constructed):</source>
          <target state="translated">⁂ 复制和交换的成语,由于使用了额外的临时性(当操作者的参数被复制构造时),可能会引入低效率或限制。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
