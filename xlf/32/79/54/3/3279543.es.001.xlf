<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/3279543">
    <body>
      <group id="3279543">
        <trans-unit id="6c226e8c6cc9d76ab83c602a00d6e4dc0fc4f9d3" translate="yes" xml:space="preserve">
          <source>&amp;Dagger; assignment operator implementation that seems sane when assigning from a distinct object can easily fail for self-assignment.  While it might seem unimaginable that client code would even attempt self-assignment, it can happen relatively easily during algo operations on containers, with &lt;code&gt;x = f(x);&lt;/code&gt; code where &lt;code&gt;f&lt;/code&gt; is (perhaps only for some &lt;code&gt;#ifdef&lt;/code&gt; branches) a macro ala &lt;code&gt;#define f(x) x&lt;/code&gt; or a function returning a reference to &lt;code&gt;x&lt;/code&gt;, or even (likely inefficient but concise) code like &lt;code&gt;x = c1 ? x * 2 : c2 ? x / 2 : x;&lt;/code&gt;).  For example:</source>
          <target state="translated">&amp;bull; La implementaci&amp;oacute;n del operador de asignaci&amp;oacute;n que parece sensata cuando se asigna desde un objeto distinto puede fallar f&amp;aacute;cilmente para la autoasignaci&amp;oacute;n. Si bien puede parecer inimaginable que el c&amp;oacute;digo del cliente incluso intente la autoasignaci&amp;oacute;n, puede ocurrir con relativa facilidad durante las operaciones de algo en contenedores, con &lt;code&gt;x = f(x);&lt;/code&gt; c&amp;oacute;digo donde &lt;code&gt;f&lt;/code&gt; es (quiz&amp;aacute;s solo para algunas ramas &lt;code&gt;#ifdef&lt;/code&gt; ) una macro ala &lt;code&gt;#define f(x) x&lt;/code&gt; o una funci&amp;oacute;n que devuelve una referencia a &lt;code&gt;x&lt;/code&gt; , o incluso un c&amp;oacute;digo (probablemente ineficiente pero conciso) como &lt;code&gt;x = c1 ? x * 2 : c2 ? x / 2 : x;&lt;/code&gt; x * 2: c2? x / 2: x; ) Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bb7374700aafe18beca629b3c0f274d8e62aa193" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;The reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.</source>
          <target state="translated">&amp;Dagger; La raz&amp;oacute;n es simple: una vez que tenga el recurso para usted, puede intercambiarlo y / o moverlo (C ++ 11) a donde sea necesario. Y al hacer la copia en la lista de par&amp;aacute;metros, maximiza la optimizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="163368ac3c34ec2c83983583f0414ca3308b0713" translate="yes" xml:space="preserve">
          <source>&amp;dagger; &lt;code&gt;swap&lt;/code&gt; throwing: it's generally possible to reliably swap data members that the objects track by pointer, but non-pointer data members that don't have a throw-free swap, or for which swapping has to be implemented as &lt;code&gt;X tmp = lhs; lhs = rhs; rhs = tmp;&lt;/code&gt; and copy-construction or assignment may throw, still have the potential to fail leaving some data members swapped and others not.  This potential applies even to C++03 &lt;code&gt;std::string&lt;/code&gt;'s as James comments on another answer:</source>
          <target state="translated">&amp;dagger; lanzamiento de &lt;code&gt;swap&lt;/code&gt; : generalmente es posible intercambiar de manera confiable miembros de datos que los objetos rastrean por puntero, pero miembros de datos sin puntero que no tienen un intercambio de lanzamiento libre, o para el cual el intercambio debe implementarse como &lt;code&gt;X tmp = lhs; lhs = rhs; rhs = tmp;&lt;/code&gt; lhs = rhs; rhs = tmp; y la construcci&amp;oacute;n de la copia o la asignaci&amp;oacute;n pueden arrojarse, a&amp;uacute;n tienen el potencial de fallar dejando algunos miembros de datos intercambiados y otros no. Este potencial se aplica incluso a C ++ 03 &lt;code&gt;std::string&lt;/code&gt; 'como James comenta en otra respuesta:</target>
        </trans-unit>
        <trans-unit id="7f199a37b50d8112edd59b2da2ef5d80d8b29454" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&amp;dagger;The move constructor should generally be &lt;code&gt;noexcept&lt;/code&gt;, otherwise some code (e.g. &lt;code&gt;std::vector&lt;/code&gt; resizing logic) will use the copy constructor even when a move would make sense. Of course, only mark it noexcept if the code inside doesn't throw exceptions.</source>
          <target state="translated">&amp;dagger;&amp;dagger; El constructor de movimiento generalmente no debe ser &lt;code&gt;noexcept&lt;/code&gt; , de lo contrario, alg&amp;uacute;n c&amp;oacute;digo (por ejemplo, l&amp;oacute;gica de cambio de tama&amp;ntilde;o &lt;code&gt;std::vector&lt;/code&gt; ) usar&amp;aacute; el constructor de copia incluso cuando un movimiento tenga sentido. Por supuesto, solo m&amp;aacute;rquelo sin excepci&amp;oacute;n, si el c&amp;oacute;digo interno no arroja excepciones.</target>
        </trans-unit>
        <trans-unit id="75fc32cb0b6c21685002f255ba8bd3b417167a6f" translate="yes" xml:space="preserve">
          <source>&amp;dagger;There are other claims that we should specialize &lt;code&gt;std::swap&lt;/code&gt; for our type, provide an in-class &lt;code&gt;swap&lt;/code&gt; along-side a free-function &lt;code&gt;swap&lt;/code&gt;, etc. But this is all unnecessary: any proper use of &lt;code&gt;swap&lt;/code&gt; will be through an unqualified call, and our function will be found through &lt;a href=&quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;ADL&lt;/a&gt;. One function will do.</source>
          <target state="translated">&amp;dagger; Hay otras afirmaciones de que deber&amp;iacute;amos especializarnos en &lt;code&gt;std::swap&lt;/code&gt; para nuestro tipo, proporcionar un &lt;code&gt;swap&lt;/code&gt; en su clase junto a un &lt;code&gt;swap&lt;/code&gt; funci&amp;oacute;n libre, etc. Pero todo esto es innecesario: cualquier uso adecuado de &lt;code&gt;swap&lt;/code&gt; se realizar&amp;aacute; a trav&amp;eacute;s de un no calificado llame, y nuestra funci&amp;oacute;n se encontrar&amp;aacute; a trav&amp;eacute;s de &lt;a href=&quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;ADL&lt;/a&gt; . Una funci&amp;oacute;n servir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="d2f8a6a9ff582b62e6b05e0ec952e18a7cba21f7" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/questions/5695548/public-friend-swap-member-function&quot;&gt;Here&lt;/a&gt; is the explanation why &lt;code&gt;public friend swap&lt;/code&gt;.) Now not only can we swap our &lt;code&gt;dumb_array&lt;/code&gt;'s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.</source>
          <target state="translated">( &lt;a href=&quot;https://stackoverflow.com/questions/5695548/public-friend-swap-member-function&quot;&gt;Aqu&amp;iacute;&lt;/a&gt; est&amp;aacute; la explicaci&amp;oacute;n de por qu&amp;eacute; &lt;code&gt;public friend swap&lt;/code&gt; ). Ahora no solo podemos intercambiar nuestros &lt;code&gt;dumb_array&lt;/code&gt; , sino que los intercambios en general pueden ser m&amp;aacute;s eficientes; simplemente intercambia punteros y tama&amp;ntilde;os, en lugar de asignar y copiar matrices enteras. Adem&amp;aacute;s de este bono en funcionalidad y eficiencia, ahora estamos listos para implementar el idioma de copiar y cambiar.</target>
        </trans-unit>
        <trans-unit id="e3d46a3ef24d9ab6012b40252b69014fa5aa5434" translate="yes" xml:space="preserve">
          <source>(Not only that, but unqualified calls to &lt;code&gt;swap&lt;/code&gt; will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that &lt;code&gt;std::swap&lt;/code&gt; would entail.)</source>
          <target state="translated">(No solo eso, sino que las llamadas no calificadas al &lt;code&gt;swap&lt;/code&gt; utilizar&amp;aacute;n nuestro operador de intercambio personalizado, omitiendo la construcci&amp;oacute;n innecesaria y la destrucci&amp;oacute;n de nuestra clase que implicar&amp;iacute;a &lt;code&gt;std::swap&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc5de9386b1a45a3cfcfa383e680e501a72d73b4" translate="yes" xml:space="preserve">
          <source>(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)</source>
          <target state="translated">(Nótese que algunos compiladores no apoyan la delegación de constructores;en este caso,tenemos que construir manualmente la clase por defecto.Esta es una desafortunada pero afortunadamente trivial tarea).</target>
        </trans-unit>
        <trans-unit id="5e19805a2e15f201ad87bd588181abb3d0cc728b" translate="yes" xml:space="preserve">
          <source>(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one? While this may seem to be a valid concern, and indeed it requires non-trivial &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; clauses, this is a non-issue. That's because a class should manage &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;em&gt;one resource only&lt;/em&gt;&lt;/a&gt;!)</source>
          <target state="translated">(Uno podr&amp;iacute;a preguntarse: si se necesita tanto c&amp;oacute;digo para administrar un recurso correctamente, &amp;iquest;qu&amp;eacute; pasa si mi clase administra m&amp;aacute;s de uno? Si bien esto puede parecer una preocupaci&amp;oacute;n v&amp;aacute;lida, y de hecho requiere cl&amp;aacute;usulas de &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; no triviales, esto es no es un problema. &amp;iexcl;Esto se debe a que una clase debe administrar &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;em&gt;un solo recurso&lt;/em&gt;&lt;/a&gt; !)</target>
        </trans-unit>
        <trans-unit id="5f022b51a041ef6021d6448cd154d99898408496" translate="yes" xml:space="preserve">
          <source>*Why do we set &lt;code&gt;mArray&lt;/code&gt; to null? Because if any further code in the operator throws, the destructor of &lt;code&gt;dumb_array&lt;/code&gt; might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</source>
          <target state="translated">* &amp;iquest;Por qu&amp;eacute; configuramos &lt;code&gt;mArray&lt;/code&gt; en nulo? Porque si se arroja alg&amp;uacute;n c&amp;oacute;digo adicional en el operador, se podr&amp;iacute;a llamar al destructor de &lt;code&gt;dumb_array&lt;/code&gt; ; y si eso sucede sin configurarlo como nulo, intentaremos eliminar la memoria que ya se ha eliminado. Evitamos esto estableci&amp;eacute;ndolo en nulo, ya que eliminar nulo no es una operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b66b8649c482abfc519d6e23ca6ba54f66162dcc" translate="yes" xml:space="preserve">
          <source>... the compiler will yell at you when you call the &lt;code&gt;swap&lt;/code&gt; function:</source>
          <target state="translated">... el compilador le gritar&amp;aacute; cuando llame a la funci&amp;oacute;n de &lt;code&gt;swap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="739480efc6308b236632d75a12d950aab5506d77" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616&quot;&gt;Conceptually&lt;/a&gt;, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a &lt;code&gt;swap&lt;/code&gt; function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616&quot;&gt;Conceptualmente&lt;/a&gt; , funciona utilizando la funcionalidad del constructor de copias para crear una copia local de los datos, luego toma los datos copiados con una funci&amp;oacute;n de intercambio, intercambiando los datos antiguos con los nuevos. La copia temporal se destruye y se lleva los datos antiguos. Nos queda una copia de los nuevos datos.</target>
        </trans-unit>
        <trans-unit id="d8e39573869dabdfb98f89cc9b39812879c351fd" translate="yes" xml:space="preserve">
          <source>@wilhelmtell: In C++03, there is no mention of exceptions potentially thrown by std::string::swap (which is called by std::swap). In C++0x, std::string::swap is noexcept and must not throw exceptions. &amp;ndash; James McNellis Dec 22 '10 at 15:24</source>
          <target state="translated">@wilhelmtell: En C ++ 03, no se mencionan las excepciones potencialmente lanzadas por std :: string :: swap (que es llamado por std :: swap). En C ++ 0x, std :: string :: swap no es excepto y no debe lanzar excepciones. - James McNellis 22 de diciembre '10 a las 15:24</target>
        </trans-unit>
        <trans-unit id="8a6f040aeb295117c1efb68678f192378c4a33b9" translate="yes" xml:space="preserve">
          <source>A failed solution</source>
          <target state="translated">Una solución fallida</target>
        </trans-unit>
        <trans-unit id="1f123ac936e30fe0974c20eefdb479af236b59d9" translate="yes" xml:space="preserve">
          <source>A successful solution</source>
          <target state="translated">Una solución exitosa</target>
        </trans-unit>
        <trans-unit id="0a8b69bb09bc2425818b674879026645aff63337" translate="yes" xml:space="preserve">
          <source>A swap function is a &lt;em&gt;non-throwing&lt;/em&gt; function that swaps two objects of a class, member for member. We might be tempted to use &lt;code&gt;std::swap&lt;/code&gt; instead of providing our own, but this would be impossible; &lt;code&gt;std::swap&lt;/code&gt; uses the copy-constructor and copy-assignment operator within its implementation, and we'd ultimately be trying to define the assignment operator in terms of itself!</source>
          <target state="translated">Una funci&amp;oacute;n de intercambio es una funci&amp;oacute;n de &lt;em&gt;no lanzamiento&lt;/em&gt; que intercambia dos objetos de una clase, miembro por miembro. Podr&amp;iacute;amos sentir la tentaci&amp;oacute;n de usar &lt;code&gt;std::swap&lt;/code&gt; lugar de proporcionar el nuestro, pero esto ser&amp;iacute;a imposible; &lt;code&gt;std::swap&lt;/code&gt; usa el constructor de copia y el operador de asignaci&amp;oacute;n de copia dentro de su implementaci&amp;oacute;n, &amp;iexcl;y finalmente intentaremos definir el operador de asignaci&amp;oacute;n en t&amp;eacute;rminos de s&amp;iacute; mismo!</target>
        </trans-unit>
        <trans-unit id="18c04be3fc2a0bcac1f0511d9edd72d5489a05de" translate="yes" xml:space="preserve">
          <source>A way around this is to not use &lt;code&gt;friend&lt;/code&gt; keyword and redefine the &lt;code&gt;swap&lt;/code&gt; function:</source>
          <target state="translated">Una forma de evitar esto es no usar la palabra clave &lt;code&gt;friend&lt;/code&gt; y redefinir la funci&amp;oacute;n de &lt;code&gt;swap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="96739476d5a5d3d0fbe5f2e1e80ac733b38525c4" translate="yes" xml:space="preserve">
          <source>A way of implementing the assignment operator in terms of a swap function:</source>
          <target state="translated">Una forma de implementar el operador de asignación en términos de una función de intercambio:</target>
        </trans-unit>
        <trans-unit id="099a6586cd9d3a08c5d495a2db19fa35488b71be" translate="yes" xml:space="preserve">
          <source>After all, you don't &lt;em&gt;need&lt;/em&gt; to use a &lt;code&gt;friend&lt;/code&gt; function to swap 2 objects. It makes just as much sense to make &lt;code&gt;swap&lt;/code&gt; a member function that has one &lt;code&gt;other&lt;/code&gt; object as a parameter.</source>
          <target state="translated">Despu&amp;eacute;s de todo, no &lt;em&gt;necesita&lt;/em&gt; usar una funci&amp;oacute;n de &lt;code&gt;friend&lt;/code&gt; para intercambiar 2 objetos. Tiene tanto sentido hacer &lt;code&gt;swap&lt;/code&gt; una funci&amp;oacute;n miembro que tiene &lt;code&gt;other&lt;/code&gt; objeto como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="c864fce5142351dfaef1c82c9c081e821224b89b" translate="yes" xml:space="preserve">
          <source>Although it's been mentioned in many places, we didn't have any singular &quot;what is it&quot; question and answer, so here it is. Here is a partial list of places where it was previously mentioned:</source>
          <target state="translated">Aunque se ha mencionado en muchos lugares,no teníamos ninguna pregunta y respuesta singular de &quot;qué es&quot;,así que aquí está.Aquí hay una lista parcial de los lugares donde se mencionó anteriormente:</target>
        </trans-unit>
        <trans-unit id="e9671eba126f32f76a109bf11cdbf7cf819ba06b" translate="yes" xml:space="preserve">
          <source>An in-depth explanation</source>
          <target state="translated">Una explicación detallada</target>
        </trans-unit>
        <trans-unit id="c73d2a01cb43ee42c7ec7bce3573c7cec34d6cdc" translate="yes" xml:space="preserve">
          <source>And so concludes the copy-and-swap idiom.</source>
          <target state="translated">Y así concluye el modismo de copiar e intercambiar.</target>
        </trans-unit>
        <trans-unit id="9b5dace86273f14ab55c392c7b880a011ead98aa" translate="yes" xml:space="preserve">
          <source>And that is the copy-and-swap idiom.</source>
          <target state="translated">Y ese es el idioma para copiar e intercambiar.</target>
        </trans-unit>
        <trans-unit id="2c207f27020378f00a7220d5874fff08752c57e7" translate="yes" xml:space="preserve">
          <source>And that's it! With one fell swoop, all three problems are elegantly tackled at once.</source>
          <target state="translated">¡Y eso es todo! De un solo golpe,los tres problemas se abordan elegantemente a la vez.</target>
        </trans-unit>
        <trans-unit id="a253fea1b4ead859fd72efb21cf1f3617ee2fe71" translate="yes" xml:space="preserve">
          <source>And we say we're finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as &lt;code&gt;(n)&lt;/code&gt;.</source>
          <target state="translated">Y decimos que hemos terminado; esto ahora gestiona una matriz, sin fugas. Sin embargo, tiene tres problemas, marcados secuencialmente en el c&amp;oacute;digo como &lt;code&gt;(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46cb3e743fce8064b54f7c24bedac5fd2b065252" translate="yes" xml:space="preserve">
          <source>Any class that manages a resource (a &lt;em&gt;wrapper&lt;/em&gt;, like a smart pointer) needs to implement &lt;a href=&quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three&quot;&gt;The Big Three&lt;/a&gt;. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?</source>
          <target state="translated">Cualquier clase que administre un recurso (un &lt;em&gt;contenedor&lt;/em&gt; , como un puntero inteligente) necesita implementar &lt;a href=&quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three&quot;&gt;The Big Three&lt;/a&gt; . Si bien los objetivos y la implementaci&amp;oacute;n del constructor y destructor de copia son sencillos, el operador de asignaci&amp;oacute;n de copia es posiblemente el m&amp;aacute;s matizado y dif&amp;iacute;cil. &amp;iquest;C&amp;oacute;mo deberia hacerse? &amp;iquest;Qu&amp;eacute; trampas deben evitarse?</target>
        </trans-unit>
        <trans-unit id="b5f0db215ce832cd77e56cc7229f8e1b22ecb595" translate="yes" xml:space="preserve">
          <source>As mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a &lt;code&gt;swap&lt;/code&gt; function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called &quot;The Big Three and A Half&quot;: any time your class manages a resource it also makes sense to provide a &lt;code&gt;swap&lt;/code&gt; function.</source>
          <target state="translated">Como se mencion&amp;oacute;, el idioma de copiar e intercambiar solucionar&amp;aacute; todos estos problemas. Pero en este momento, tenemos todos los requisitos excepto uno: una funci&amp;oacute;n de &lt;code&gt;swap&lt;/code&gt; . Si bien La regla de los tres implica con &amp;eacute;xito la existencia de nuestro constructor de copia, operador de asignaci&amp;oacute;n y destructor, realmente deber&amp;iacute;a llamarse &quot;Los tres grandes y medio&quot;: cada vez que su clase maneja un recurso, tambi&amp;eacute;n tiene sentido proporcionar un &lt;code&gt;swap&lt;/code&gt; funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="89e4ca10b74850fc9016dbb8310675a1462b938c" translate="yes" xml:space="preserve">
          <source>Assignment, at its heart, is two steps: &lt;strong&gt;&lt;em&gt;tearing down the object's old state&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;building its new state as a copy&lt;/em&gt;&lt;/strong&gt; of some other object's state.</source>
          <target state="translated">La asignaci&amp;oacute;n, en esencia, son dos pasos: &lt;strong&gt;&lt;em&gt;derribar el estado anterior del objeto&lt;/em&gt;&lt;/strong&gt; y &lt;strong&gt;&lt;em&gt;construir su nuevo estado como una copia&lt;/em&gt;&lt;/strong&gt; del &lt;strong&gt;&lt;em&gt;estado&lt;/em&gt;&lt;/strong&gt; de alg&amp;uacute;n otro objeto.</target>
        </trans-unit>
        <trans-unit id="d4de93db789fe9ea751b9c3c9f7efc0214b87843" translate="yes" xml:space="preserve">
          <source>At this point we are home-free, because &lt;code&gt;swap&lt;/code&gt; is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter's scope ends and its destructor is called.)</source>
          <target state="translated">En este punto estamos sin hogar, porque el &lt;code&gt;swap&lt;/code&gt; no es arrojar. Intercambiamos nuestros datos actuales con los datos copiados, alterando de manera segura nuestro estado, y los datos antiguos se colocan en el temporal. Los datos antiguos se liberan cuando vuelve la funci&amp;oacute;n. (Donde termina el alcance del par&amp;aacute;metro y se llama a su destructor).</target>
        </trans-unit>
        <trans-unit id="22b41cb12332be04aca21ea73d3c777d0bbc2bc4" translate="yes" xml:space="preserve">
          <source>Basically, that's what the &lt;strong&gt;&lt;em&gt;destructor&lt;/em&gt;&lt;/strong&gt; and the &lt;strong&gt;&lt;em&gt;copy constructor&lt;/em&gt;&lt;/strong&gt; do, so the first idea would be to delegate the work to them. However, since destruction mustn't fail, while construction might, &lt;em&gt;we actually want to do it the other way around&lt;/em&gt;: &lt;strong&gt;&lt;em&gt;first perform the constructive part&lt;/em&gt;&lt;/strong&gt; and, if that succeeded, &lt;strong&gt;&lt;em&gt;then do the destructive part&lt;/em&gt;&lt;/strong&gt;. The copy-and-swap idiom is a way to do just that: It first calls a class' copy constructor to create a temporary object, then swaps its data with the temporary's, and then lets the temporary's destructor destroy the old state.</source>
          <target state="translated">B&amp;aacute;sicamente, eso es lo que hacen el &lt;strong&gt;&lt;em&gt;destructor&lt;/em&gt;&lt;/strong&gt; y el &lt;strong&gt;&lt;em&gt;constructor de&lt;/em&gt;&lt;/strong&gt; la &lt;strong&gt;&lt;em&gt;copia&lt;/em&gt;&lt;/strong&gt; , por lo que la primera idea ser&amp;iacute;a delegarles el trabajo. Sin embargo, dado que la destrucci&amp;oacute;n no debe fallar, mientras que la construcci&amp;oacute;n podr&amp;iacute;a, en &lt;em&gt;realidad queremos hacerlo al rev&amp;eacute;s&lt;/em&gt; : &lt;strong&gt;&lt;em&gt;primero realice la parte constructiva&lt;/em&gt;&lt;/strong&gt; y, si eso tuvo &amp;eacute;xito, &lt;strong&gt;&lt;em&gt;luego haga la parte destructiva&lt;/em&gt;&lt;/strong&gt; . El modismo de copiar y cambiar es una forma de hacer exactamente eso: primero llama al constructor de copias de una clase para crear un objeto temporal, luego intercambia sus datos con los temporales y luego deja que el destructor del temporal destruya el estado anterior.</target>
        </trans-unit>
        <trans-unit id="21f3313cd21a2541f96630aa3e2a0cf47d569892" translate="yes" xml:space="preserve">
          <source>Because the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of &lt;code&gt;operator=&lt;/code&gt;. (Additionally, we no longer have a performance penalty on non-self-assignments.)</source>
          <target state="translated">Debido a que el idioma no repite ning&amp;uacute;n c&amp;oacute;digo, no podemos introducir errores dentro del operador. Tenga en cuenta que esto significa que nos libramos de la necesidad de una verificaci&amp;oacute;n de autoasignaci&amp;oacute;n, lo que permite una implementaci&amp;oacute;n uniforme &amp;uacute;nica de &lt;code&gt;operator=&lt;/code&gt; . (Adem&amp;aacute;s, ya no tenemos una penalizaci&amp;oacute;n de rendimiento por no autoasignaciones).</target>
        </trans-unit>
        <trans-unit id="ee86d87c6e42b253320f7528f74891164bb782f1" translate="yes" xml:space="preserve">
          <source>C++: dynamically allocating an array of objects?</source>
          <target state="translated">C++:¿asignando dinámicamente un conjunto de objetos?</target>
        </trans-unit>
        <trans-unit id="e729ebfbf18123cb9c8f157732414fc00291bf88" translate="yes" xml:space="preserve">
          <source>Copy constructor and = operator overload in C++: is a common function possible?</source>
          <target state="translated">Copiar constructor y=sobrecarga del operador en C++:¿es posible una función común?</target>
        </trans-unit>
        <trans-unit id="94f8c0f65181c1bf410e4113cb80538a2f639df0" translate="yes" xml:space="preserve">
          <source>Either way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.</source>
          <target state="translated">De cualquier manera,este método de obtener nuestro recurso es la clave para eliminar la duplicación de código:podemos usar el código del constructor de la copia para hacer la copia,y nunca necesitamos repetir ningún pedazo de él.Ahora que la copia está hecha,estamos listos para intercambiar.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="79202c91683120bfb6ddb6c07a5bad7dc7c88c9b" translate="yes" xml:space="preserve">
          <source>For concreteness, let us consider a container &lt;code&gt;std::vector&amp;lt;T, A&amp;gt;&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is some stateful allocator type, and we'll compare the following functions:</source>
          <target state="translated">Para concreci&amp;oacute;n, consideremos un contenedor &lt;code&gt;std::vector&amp;lt;T, A&amp;gt;&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un tipo de asignador con estado, y compararemos las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="f160b70becf0b5d89fbecbeb4ad05cafa0e60064" translate="yes" xml:space="preserve">
          <source>Here's how a naive implementation might look:</source>
          <target state="translated">Así es como podría parecer una implementación ingenua:</target>
        </trans-unit>
        <trans-unit id="bec44ad24b77ebad1653d346d85b618d564afd9f" translate="yes" xml:space="preserve">
          <source>Here, a hand-written &lt;code&gt;Client::operator=&lt;/code&gt; might check if &lt;code&gt;*this&lt;/code&gt; is already connected to the same server as &lt;code&gt;rhs&lt;/code&gt; (perhaps sending a &quot;reset&quot; code if useful), whereas the copy-and-swap approach would invoke the copy-constructor which would likely be written to open a distinct socket connection then close the original one.  Not only could that mean a remote network interaction instead of a simple in-process variable copy, it could run afoul of client or server limits on socket resources or connections.  (Of course this class has a pretty horrid interface, but that's another matter ;-P).</source>
          <target state="translated">Aqu&amp;iacute;, un &lt;code&gt;Client::operator=&lt;/code&gt; escrito a mano podr&amp;iacute;a verificar si &lt;code&gt;*this&lt;/code&gt; ya est&amp;aacute; conectado al mismo servidor que &lt;code&gt;rhs&lt;/code&gt; (quiz&amp;aacute;s enviando un c&amp;oacute;digo de &quot;reinicio&quot; si es &amp;uacute;til), mientras que el enfoque de copiar e intercambiar invocar&amp;iacute;a la copia constructor que probablemente se escribir&amp;iacute;a para abrir una conexi&amp;oacute;n de socket distinta y luego cerrar la original. Esto no solo podr&amp;iacute;a significar una interacci&amp;oacute;n de red remota en lugar de una simple copia de variables en proceso, sino que podr&amp;iacute;a estar en conflicto con los l&amp;iacute;mites del cliente o del servidor en los recursos del socket o las conexiones. (Por supuesto, esta clase tiene una interfaz bastante horrible, pero ese es otro asunto ;-P).</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">¿Cómo funciona?</target>
        </trans-unit>
        <trans-unit id="fc088e1a9c9b7f4c8a1d611a7ecd41e9c5e1abfa" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt;, the program has &lt;em&gt;undefined behaviour&lt;/em&gt; (cf. [container.requirements.general/8].</source>
          <target state="translated">Sin embargo, si &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt; , el programa tiene &lt;em&gt;un comportamiento indefinido&lt;/em&gt; (cf. [container.requirements.general / 8].</target>
        </trans-unit>
        <trans-unit id="236be016134b3d1b54ff3ee12c4a2f9cc364e3e2" translate="yes" xml:space="preserve">
          <source>I would like to add a word of warning when you are dealing with C++11-style allocator-aware containers. Swapping and assignment have subtly different semantics.</source>
          <target state="translated">Me gustaría añadir una advertencia cuando se trata de contenedores de estilo C++11.El intercambio y la asignación tienen una semántica sutilmente diferente.</target>
        </trans-unit>
        <trans-unit id="3f28ca2de2b68eac16c3d42e71f3ac049eaef11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_move_assignment&lt;/code&gt; is &lt;code&gt;std::true_type&lt;/code&gt;, then &lt;code&gt;fm&lt;/code&gt; reassigns the allocator of &lt;code&gt;a&lt;/code&gt; with the value of &lt;code&gt;b.get_allocator()&lt;/code&gt;, otherwise it does not, and &lt;code&gt;a&lt;/code&gt; continues to use its original allocator. In that case, the data elements need to be swapped individually, since the storage of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is not compatible.</source>
          <target state="translated">Si &lt;code&gt;AT::propagate_on_container_move_assignment&lt;/code&gt; es &lt;code&gt;std::true_type&lt;/code&gt; , entonces &lt;code&gt;fm&lt;/code&gt; reasigna el asignador de &lt;code&gt;a&lt;/code&gt; con el valor de &lt;code&gt;b.get_allocator()&lt;/code&gt; , de lo contrario no lo hace, y &lt;code&gt;a&lt;/code&gt; contin&amp;uacute;a utilizando su asignador original. En ese caso, los elementos de datos deben intercambiarse individualmente, ya que el almacenamiento de &lt;code&gt;b&lt;/code&gt; no es compatible.</target>
        </trans-unit>
        <trans-unit id="4510757f293d56b7a112af8252c4984d58f759e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;std::false_type&lt;/code&gt;, then we need a dynamic check.</source>
          <target state="translated">Si &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; es &lt;code&gt;std::false_type&lt;/code&gt; , entonces necesitamos una verificaci&amp;oacute;n din&amp;aacute;mica.</target>
        </trans-unit>
        <trans-unit id="b3573d07a320cef433ba754980663abfd331a87f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;std::true_type&lt;/code&gt;, then &lt;code&gt;fs&lt;/code&gt; swaps both data and allocators in the expected fashion.</source>
          <target state="translated">Si &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; es &lt;code&gt;std::true_type&lt;/code&gt; , entonces &lt;code&gt;fs&lt;/code&gt; intercambia datos y asignadores de la manera esperada.</target>
        </trans-unit>
        <trans-unit id="73d3a4270600b651da25bd4b3260fe77df37829f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.get_allocator() == b.get_allocator()&lt;/code&gt;, then the two containers use compatible storage, and swapping proceeds in the usual fashion.</source>
          <target state="translated">Si &lt;code&gt;a.get_allocator() == b.get_allocator()&lt;/code&gt; , entonces los dos contenedores usan almacenamiento compatible y el intercambio contin&amp;uacute;a de la manera habitual.</target>
        </trans-unit>
        <trans-unit id="b8d03c15d57131584a2028550fb794a9339e9cad" translate="yes" xml:space="preserve">
          <source>In its refined form, copy-and-swap is implemented by having the copy performed by initializing the (non-reference) parameter of the assignment operator:</source>
          <target state="translated">En su forma refinada,la copia e intercambio se realiza mediante la inicialización del parámetro (no de referencia)del operador de la asignación:</target>
        </trans-unit>
        <trans-unit id="9f37decf779a75710e40ed5c33a2089302cd7911" translate="yes" xml:space="preserve">
          <source>In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a &lt;code&gt;swap&lt;/code&gt; function.</source>
          <target state="translated">Para usar la expresi&amp;oacute;n copiar y intercambiar, necesitamos tres cosas: un constructor de copias que funcione, un destructor que funcione (ambos son la base de cualquier contenedor, por lo que deber&amp;iacute;an estar completos de todos modos) y una funci&amp;oacute;n de &lt;code&gt;swap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c6f02b160b536e0af64d17d3f8eab3f4e9be471" translate="yes" xml:space="preserve">
          <source>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.</source>
          <target state="translated">En nuestro caso,el núcleo del mismo es sólo de dos líneas (la asignación y la copia),pero con recursos más complejos este hinchamiento del código puede ser bastante molesto.Deberíamos esforzarnos por no repetirlo nunca.</target>
        </trans-unit>
        <trans-unit id="41bf38d748ecfa54c2c45421d2ad416833ae458b" translate="yes" xml:space="preserve">
          <source>In some versions of Visual Studio (and possibly other compilers) there is a bug that is really annoying and doesn't make sense. So if you declare/define your &lt;code&gt;swap&lt;/code&gt; function like this:</source>
          <target state="translated">En algunas versiones de Visual Studio (y posiblemente en otros compiladores) hay un error que es realmente molesto y no tiene sentido. Entonces, si declara / define su funci&amp;oacute;n de &lt;code&gt;swap&lt;/code&gt; esta manera:</target>
        </trans-unit>
        <trans-unit id="a9821302f3683bd9875458d7b470497ba0484ef2" translate="yes" xml:space="preserve">
          <source>Let's consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:</source>
          <target state="translated">Consideremos un caso concreto.Queremos manejar,en una clase inútil,un conjunto dinámico.Empezamos con un constructor,un copiador y un destructor en funcionamiento:</target>
        </trans-unit>
        <trans-unit id="27c808c7552dbd2cdeb49163a8d2a3c074f0dbac" translate="yes" xml:space="preserve">
          <source>Luckily for us, this is easy:</source>
          <target state="translated">Por suerte para nosotros,esto es fácil:</target>
        </trans-unit>
        <trans-unit id="7402c1a7b7b4cd8a707b425e610cbcb74419bc20" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;other&lt;/code&gt; is being initialized with an rvalue, &lt;em&gt;it will be move-constructed&lt;/em&gt;. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will &lt;em&gt;automatically&lt;/em&gt; pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)</source>
          <target state="translated">Ahora, si se est&amp;aacute; inicializando otro con un valor r, &lt;em&gt;se construir&amp;aacute; en movimiento&lt;/em&gt; . Perfecto. Del mismo modo, C ++ 03 nos permite reutilizar nuestra funcionalidad de constructor de copia tomando el argumento por valor, C ++ 11 tambi&amp;eacute;n elegir&amp;aacute; &lt;em&gt;autom&amp;aacute;ticamente&lt;/em&gt; el constructor de movimiento cuando sea apropiado. (Y, por supuesto, como se mencion&amp;oacute; en el art&amp;iacute;culo vinculado anteriormente, la copia / movimiento del valor simplemente puede eludirse por completo).</target>
        </trans-unit>
        <trans-unit id="dcbeb7c58de6f8ef2e5b152493010bd5fba66a2c" translate="yes" xml:space="preserve">
          <source>Observe that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won't even enter the function if construction of the copy fails, and it's therefore not possible to alter the state of &lt;code&gt;*this&lt;/code&gt;. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)</source>
          <target state="translated">Observe que al ingresar a la funci&amp;oacute;n todos los datos nuevos ya est&amp;aacute;n asignados, copiados y listos para ser utilizados. Esto es lo que nos da una fuerte garant&amp;iacute;a de excepci&amp;oacute;n de forma gratuita: ni siquiera ingresaremos a la funci&amp;oacute;n si falla la construcci&amp;oacute;n de la copia, y por lo tanto no es posible alterar el estado de &lt;code&gt;*this&lt;/code&gt; . (Lo que hicimos manualmente antes para una fuerte garant&amp;iacute;a de excepci&amp;oacute;n, el compilador est&amp;aacute; haciendo por nosotros ahora; qu&amp;eacute; amable).</target>
        </trans-unit>
        <trans-unit id="e6868ab3511bcd3b27c0685657d0cf94d4a5c6ed" translate="yes" xml:space="preserve">
          <source>On self-assignment, the above code delete's &lt;code&gt;x.p_;&lt;/code&gt;, points &lt;code&gt;p_&lt;/code&gt; at a newly allocated heap region, then attempts to read the &lt;em&gt;uninitialised&lt;/em&gt; data therein (Undefined Behaviour), if that doesn't do anything too weird, &lt;code&gt;copy&lt;/code&gt; attempts a self-assignment to every just-destructed 'T'!</source>
          <target state="translated">En la &lt;code&gt;x.p_;&lt;/code&gt; , el c&amp;oacute;digo anterior elimina x.p_; , apunta &lt;code&gt;p_&lt;/code&gt; a una regi&amp;oacute;n de mont&amp;oacute;n reci&amp;eacute;n asignada, luego intenta leer los datos &lt;em&gt;no inicializados en&lt;/em&gt; ella (Comportamiento indefinido), si eso no hace nada extra&amp;ntilde;o, &amp;iexcl; &lt;code&gt;copy&lt;/code&gt; intentos de autoasignaci&amp;oacute;n a cada 'T' reci&amp;eacute;n destruida!</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9c234a83c1275c3ee466e4738c02c7633c54a69e" translate="yes" xml:space="preserve">
          <source>Self-assignment done as a copy-and-swap avoids oft-overlooked edge cases.&amp;Dagger;</source>
          <target state="translated">La autoasignaci&amp;oacute;n realizada como copia e intercambio evita los casos l&amp;iacute;mite que se pasan por alto con frecuencia. &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="6f659bc43bf7db07f752a5d1512e544f94e1af00" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;swap()&lt;/code&gt; is supposed to never fail, the only part which might fail is the copy-construction. That is performed first, and if it fails, nothing will be changed in the targeted object.</source>
          <target state="translated">Dado que se supone que &lt;code&gt;swap()&lt;/code&gt; nunca fallar&amp;aacute;, la &amp;uacute;nica parte que podr&amp;iacute;a fallar es la construcci&amp;oacute;n de copia. Eso se realiza primero, y si falla, no se cambiar&amp;aacute; nada en el objeto de destino.</target>
        </trans-unit>
        <trans-unit id="26f7740f7272c6a37203cde27ca0ef723ebbbf32" translate="yes" xml:space="preserve">
          <source>So what we've done is simple: initialize via the default constructor (a C++11 feature), then swap with &lt;code&gt;other&lt;/code&gt;; we know a default constructed instance of our class can safely be assigned and destructed, so we know &lt;code&gt;other&lt;/code&gt; will be able to do the same, after swapping.</source>
          <target state="translated">Entonces, lo que hemos hecho es simple: inicializar a trav&amp;eacute;s del constructor predeterminado (una caracter&amp;iacute;stica de C ++ 11), luego intercambiar con &lt;code&gt;other&lt;/code&gt; ; sabemos que una instancia construida por defecto de nuestra clase puede asignarse y destruirse de manera segura, por lo que sabemos que &lt;code&gt;other&lt;/code&gt; podr&amp;aacute;n hacer lo mismo, despu&amp;eacute;s del intercambio.</target>
        </trans-unit>
        <trans-unit id="2b5693bc5962ed6f9799bbcb35014ba8ea8fefd0" translate="yes" xml:space="preserve">
          <source>That is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:</source>
          <target state="translated">Ese es el único cambio que tenemos que hacer en nuestra clase,así que ¿por qué funciona? Recuerda la siempre importante decisión que tomamos de hacer del parámetro un valor y no una referencia:</target>
        </trans-unit>
        <trans-unit id="9ef6aff2994558c1366be20966048a47a804bb07" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;copy-and-swap idiom&lt;/em&gt; is the solution, and elegantly assists the assignment operator in achieving two things: avoiding &lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;code duplication&lt;/a&gt;, and providing a &lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_guarantees&quot;&gt;strong exception guarantee&lt;/a&gt;.</source>
          <target state="translated">El &lt;em&gt;modismo de copiar y cambiar&lt;/em&gt; es la soluci&amp;oacute;n, y ayuda elegantemente al operador de asignaci&amp;oacute;n a lograr dos cosas: evitar la &lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;duplicaci&amp;oacute;n de c&amp;oacute;digo&lt;/a&gt; y proporcionar una &lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_guarantees&quot;&gt;garant&amp;iacute;a de excepci&amp;oacute;n fuerte&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42e54c42a60d22bc2d5ac75e35558832e40d8bb3" translate="yes" xml:space="preserve">
          <source>The code has expanded! Which leads us to the third problem: code duplication. Our assignment operator effectively duplicates all the code we've already written elsewhere, and that's a terrible thing.</source>
          <target state="translated">¡El código se ha expandido! Lo que nos lleva al tercer problema:la duplicación del código.Nuestro operador de asignación duplica efectivamente todo el código que ya hemos escrito en otro lugar,y eso es algo terrible.</target>
        </trans-unit>
        <trans-unit id="63d41c6ca1535180248065869d3328499b07b825" translate="yes" xml:space="preserve">
          <source>The first  is the self-assignment test. This check serves two purposes: it's an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste. It would be better if the operator could work properly without it.</source>
          <target state="translated">La primera es la prueba de auto-asignación.Esta prueba tiene dos propósitos:es una forma fácil de evitar que ejecutemos código innecesario en la auto-asignación,y nos protege de sutiles errores (como borrar el array sólo para intentar copiarlo).Pero en todos los demás casos sólo sirve para ralentizar el programa,y actuar como ruido en el código;la auto-asignación rara vez ocurre,así que la mayoría de las veces esta comprobación es un desperdicio.Sería mejor si el operador pudiera trabajar correctamente sin ella.</target>
        </trans-unit>
        <trans-unit id="6f60ff23b795c7da205d246f356a1def07956d8e" translate="yes" xml:space="preserve">
          <source>The fundamental idea is that:</source>
          <target state="translated">La idea fundamental es que:</target>
        </trans-unit>
        <trans-unit id="83588406b98957bd4b1f640c1bf0685f68308d07" translate="yes" xml:space="preserve">
          <source>The goal</source>
          <target state="translated">El objetivo</target>
        </trans-unit>
        <trans-unit id="fd746b321830bfc8609d2fd310324c39c1c7bf04" translate="yes" xml:space="preserve">
          <source>The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now &lt;strong&gt;The Rule of Four&lt;/strong&gt; (and a half). Why? Because not only do we need to be able to copy-construct our resource, &lt;a href=&quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me&quot;&gt;we need to move-construct it as well&lt;/a&gt;.</source>
          <target state="translated">La pr&amp;oacute;xima versi&amp;oacute;n de C ++, C ++ 11, hace un cambio muy importante en la forma en que administramos los recursos: la regla de tres es ahora &lt;strong&gt;la regla de cuatro&lt;/strong&gt; (y medio). &amp;iquest;Por qu&amp;eacute;? Porque no solo necesitamos poder copiar-construir nuestro recurso, tambi&amp;eacute;n &lt;a href=&quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me&quot;&gt;necesitamos moverlo-construirlo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="150781c474b203c76af89ffc1927280c58bbd0ff" translate="yes" xml:space="preserve">
          <source>The purpose of both functions &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;fm&lt;/code&gt; is to give &lt;code&gt;a&lt;/code&gt; the state that &lt;code&gt;b&lt;/code&gt; had initially. However, there is a hidden question: What happens if &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt;? The answer is: It depends. Let's write &lt;code&gt;AT = std::allocator_traits&amp;lt;A&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El prop&amp;oacute;sito de ambas funciones &lt;code&gt;fs&lt;/code&gt; y &lt;code&gt;fm&lt;/code&gt; es dar &lt;code&gt;a&lt;/code&gt; el estado que &lt;code&gt;b&lt;/code&gt; ten&amp;iacute;a inicialmente. Sin embargo, hay una pregunta oculta: &amp;iquest;Qu&amp;eacute; sucede si &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt; ? La respuesta es, depende. Escribamos &lt;code&gt;AT = std::allocator_traits&amp;lt;A&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8b0eb32111093ee430fedf7a03880593d06a45" translate="yes" xml:space="preserve">
          <source>The second is that it only provides a basic exception guarantee. If &lt;code&gt;new int[mSize]&lt;/code&gt; fails, &lt;code&gt;*this&lt;/code&gt; will have been modified. (Namely, the size is wrong and the data is gone!) For a strong exception guarantee, it would need to be something akin to:</source>
          <target state="translated">El segundo es que solo proporciona una garant&amp;iacute;a de excepci&amp;oacute;n b&amp;aacute;sica. Si el &lt;code&gt;new int[mSize]&lt;/code&gt; falla, &lt;code&gt;*this&lt;/code&gt; habr&amp;aacute; sido modificado. (Es decir, &amp;iexcl;el tama&amp;ntilde;o es incorrecto y los datos se han ido!) Para una fuerte garant&amp;iacute;a de excepci&amp;oacute;n, deber&amp;iacute;a ser algo similar a:</target>
        </trans-unit>
        <trans-unit id="2c6fcc3a8c5ecf729853f999132fcff2680df339" translate="yes" xml:space="preserve">
          <source>The upshot is that swapping has become a non-trivial operation in C++11 as soon as your container starts supporting stateful allocators. That's a somewhat &quot;advanced use case&quot;, but it's not entirely unlikely, since move optimizations usually only become interesting once your class manages a resource, and memory is one of the most popular resources.</source>
          <target state="translated">El resultado es que el intercambio se ha convertido en una operación no trivial en C++11 tan pronto como su contenedor empieza a soportar asignadores de estado.Ese es un &quot;caso de uso avanzado&quot;,pero no es del todo improbable,ya que las optimizaciones de movimiento normalmente sólo se vuelven interesantes una vez que tu clase gestiona un recurso,y la memoria es uno de los recursos más populares.</target>
        </trans-unit>
        <trans-unit id="388be71290411a46bfa3cef8cea4ebaa96d6633d" translate="yes" xml:space="preserve">
          <source>There are some good answers already.  I'll focus &lt;em&gt;mainly&lt;/em&gt; on what I think they lack - an explanation of the &quot;cons&quot; with the copy-and-swap idiom....</source>
          <target state="translated">Ya hay algunas buenas respuestas. Me centrar&amp;eacute; &lt;em&gt;principalmente&lt;/em&gt; en lo que creo que les falta: una explicaci&amp;oacute;n de los &quot;contras&quot; con el modismo de copiar e intercambiar ...</target>
        </trans-unit>
        <trans-unit id="cbe63039ab446d86b4ac167fd16b3d3dadd41365" translate="yes" xml:space="preserve">
          <source>This answer is more like an addition and a slight modification to the answers above.</source>
          <target state="translated">Esta respuesta es más bien una adición y una ligera modificación a las respuestas anteriores.</target>
        </trans-unit>
        <trans-unit id="c1083ee173869cd02574e5832d5f7c99145ada0e" translate="yes" xml:space="preserve">
          <source>This class almost manages the array successfully, but it needs &lt;code&gt;operator=&lt;/code&gt; to work correctly.</source>
          <target state="translated">Esta clase casi gestiona la matriz con &amp;eacute;xito, pero necesita &lt;code&gt;operator=&lt;/code&gt; para funcionar correctamente.</target>
        </trans-unit>
        <trans-unit id="29f80c1b07d0671e4a256b348ff66c1e913f3c22" translate="yes" xml:space="preserve">
          <source>This has something to do with a &lt;code&gt;friend&lt;/code&gt; function being called and &lt;code&gt;this&lt;/code&gt; object being passed as a parameter.</source>
          <target state="translated">Esto tiene algo que ver con una funci&amp;oacute;n de &lt;code&gt;friend&lt;/code&gt; que se llama y &lt;code&gt;this&lt;/code&gt; objeto se pasa como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="5aa765f67fd688a1ba7150d96a03c571fde7ba09" translate="yes" xml:space="preserve">
          <source>This time, you can just call &lt;code&gt;swap&lt;/code&gt; and pass in &lt;code&gt;other&lt;/code&gt;, thus making the compiler happy:</source>
          <target state="translated">Esta vez, puede llamar a &lt;code&gt;swap&lt;/code&gt; y pasar en &lt;code&gt;other&lt;/code&gt; , haciendo feliz al compilador:</target>
        </trans-unit>
        <trans-unit id="633375af64a272c488ff9c504c74dbb8f98b646a" translate="yes" xml:space="preserve">
          <source>We first notice an important choice: the parameter argument is taken &lt;em&gt;by-value&lt;/em&gt;. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):</source>
          <target state="translated">Primero notamos una elecci&amp;oacute;n importante: el argumento del par&amp;aacute;metro se toma &lt;em&gt;por valor&lt;/em&gt; . Si bien uno podr&amp;iacute;a hacer lo siguiente con la misma facilidad (y, de hecho, muchas implementaciones ingenuas del idioma hacen):</target>
        </trans-unit>
        <trans-unit id="63217325aa31565f08b4e39b47c1e5fc48d70a30" translate="yes" xml:space="preserve">
          <source>We lose an &lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;important optimization opportunity&lt;/a&gt;. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list.&amp;Dagger;)</source>
          <target state="translated">Perdemos una &lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;importante oportunidad de optimizaci&amp;oacute;n&lt;/a&gt; . No solo eso, sino que esta elecci&amp;oacute;n es cr&amp;iacute;tica en C ++ 11, que se analiza m&amp;aacute;s adelante. (En una nota general, una gu&amp;iacute;a notablemente &amp;uacute;til es la siguiente: si va a hacer una copia de algo en una funci&amp;oacute;n, deje que el compilador lo haga en la lista de par&amp;aacute;metros. &amp;Dagger;)</target>
        </trans-unit>
        <trans-unit id="9edc40ca06ad2a68fa87b0a4a4acc15e97ae9f73" translate="yes" xml:space="preserve">
          <source>We need to add swap functionality to our class, and we do that as follows&amp;dagger;:</source>
          <target state="translated">Necesitamos agregar funcionalidad de intercambio a nuestra clase, y lo hacemos de la siguiente manera &amp;dagger;:</target>
        </trans-unit>
        <trans-unit id="c2edab5c5da4b7e0cb43225936cb000f569c92ee" translate="yes" xml:space="preserve">
          <source>What about C++11?</source>
          <target state="translated">¿Qué hay de C++11?</target>
        </trans-unit>
        <trans-unit id="787ffecc94ae151e431f132b817ebb5ac7bd5b64" translate="yes" xml:space="preserve">
          <source>What are your favorite C++ Coding Style idioms:  Copy-swap</source>
          <target state="translated">¿Cuáles son tus modismos favoritos del estilo de codificación C++:Copy-swap</target>
        </trans-unit>
        <trans-unit id="6dc672ff6eb837cd0bbe834afc644c2d587d212d" translate="yes" xml:space="preserve">
          <source>What is copy elision and how it optimizes copy-and-swap idiom</source>
          <target state="translated">¿Qué es la elisión de copia y cómo optimiza el lenguaje de copia e intercambio</target>
        </trans-unit>
        <trans-unit id="3f800a7430fd4c0527c40982197ac647fe2c18a0" translate="yes" xml:space="preserve">
          <source>What is the copy-and-swap idiom</source>
          <target state="translated">¿Cuál es el idioma de copia e intercambio</target>
        </trans-unit>
        <trans-unit id="a8f471015362e9a261fa62137612c1258db68efb" translate="yes" xml:space="preserve">
          <source>What is the copy-and-swap idiom?</source>
          <target state="translated">¿Cuál es el modismo de copiar e intercambiar?</target>
        </trans-unit>
        <trans-unit id="ede6b7eaf3770f7b7b840f5f578c287f11e2cccd" translate="yes" xml:space="preserve">
          <source>What is this idiom and when should it be used? Which problems does it solve? Does the idiom change when C++11 is used?</source>
          <target state="translated">¿Qué es esta expresión y cuándo debe ser usada? ¿Qué problemas resuelve? ¿Cambia el idioma cuando se usa C++11?</target>
        </trans-unit>
        <trans-unit id="aa7922596966a3f09ff20d40921994a57ffd3b96" translate="yes" xml:space="preserve">
          <source>What's going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.</source>
          <target state="translated">¿Qué está pasando aquí? Recordemos el objetivo de la mudanza-construcción:tomar los recursos de otra instancia de la clase,dejándola en un estado garantizado de ser asignable y destructible.</target>
        </trans-unit>
        <trans-unit id="10170890d98f9c422d746d6a228ebc44fc0a6ee0" translate="yes" xml:space="preserve">
          <source>When any performance penalty or momentarily higher resource usage created by having an extra temporary object during the assignment is not important to your application. ⁂</source>
          <target state="translated">Cuando cualquier penalización de rendimiento o uso de recursos momentáneamente más altos creados por tener un objeto temporal extra durante la asignación no es importante para su aplicación.⁂</target>
        </trans-unit>
        <trans-unit id="60f80e0ee25da3bc05679b2ff44dd7fcf6b5baef" translate="yes" xml:space="preserve">
          <source>When should it be used?  (Which problems does it solve &lt;strong&gt;[/create]&lt;/strong&gt;?)</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo deber&amp;iacute;a usarse? (&amp;iquest;Qu&amp;eacute; problemas resuelve &lt;strong&gt;[/ create]&lt;/strong&gt; ?)</target>
        </trans-unit>
        <trans-unit id="2634e1acfb3bf9e69b4daa989e044e2431bc5a1b" translate="yes" xml:space="preserve">
          <source>When you want a clean, easy to understand, robust way to define the assignment operator in terms of (simpler) copy constructor, &lt;code&gt;swap&lt;/code&gt; and destructor functions.</source>
          <target state="translated">Cuando desee una manera limpia, f&amp;aacute;cil de entender y robusta de definir el operador de asignaci&amp;oacute;n en t&amp;eacute;rminos de funciones de constructor, &lt;code&gt;swap&lt;/code&gt; y destructor de copia (m&amp;aacute;s simples).</target>
        </trans-unit>
        <trans-unit id="29733bade5cab23e00e5d05e6412f95b30d5413f" translate="yes" xml:space="preserve">
          <source>When you want the assigned-to objected unaffected by an assignment that throws an exception, assuming you have or can write a &lt;code&gt;swap&lt;/code&gt; with strong exception guarantee, and ideally one that can't fail/&lt;code&gt;throw&lt;/code&gt;..&amp;dagger;</source>
          <target state="translated">Cuando desee que el asignado se oponga sin verse afectado por una tarea que arroje una excepci&amp;oacute;n, suponiendo que tenga o pueda escribir un &lt;code&gt;swap&lt;/code&gt; con una fuerte garant&amp;iacute;a de excepci&amp;oacute;n, e idealmente uno que no pueda fallar / &lt;code&gt;throw&lt;/code&gt; .. &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="62b4affc932ffa8cde8f9a8bc7cc83fb3e7fe0f0" translate="yes" xml:space="preserve">
          <source>Why do we need the copy-and-swap idiom?</source>
          <target state="translated">¿Por qué necesitamos el idioma de copiar e intercambiar?</target>
        </trans-unit>
        <trans-unit id="d1974d73fa36fa9b1fe2996664091dd361d57f96" translate="yes" xml:space="preserve">
          <source>Why does it work?</source>
          <target state="translated">¿Por qué funciona?</target>
        </trans-unit>
        <trans-unit id="9c9b118f04e39a7318e3a5798cdcb9006d842f63" translate="yes" xml:space="preserve">
          <source>Why does that work?</source>
          <target state="translated">¿Por qué funciona eso?</target>
        </trans-unit>
        <trans-unit id="b2665c67e419327eea773cca5cbb1ebf91e5f8c3" translate="yes" xml:space="preserve">
          <source>Without further ado, our assignment operator is:</source>
          <target state="translated">Sin más preámbulos,nuestro operador de asignación es:</target>
        </trans-unit>
        <trans-unit id="e464362a2570aee7cf3bb10e5f052520cacc687e" translate="yes" xml:space="preserve">
          <source>You already have access to &lt;code&gt;this&lt;/code&gt; object, so passing it in as a parameter is technically redundant.</source>
          <target state="translated">Ya tiene acceso a &lt;code&gt;this&lt;/code&gt; objeto, por lo que pasarlo como par&amp;aacute;metro es t&amp;eacute;cnicamente redundante.</target>
        </trans-unit>
        <trans-unit id="a945bce89ff4bd35449cef3d57b6ca6c27388c0e" translate="yes" xml:space="preserve">
          <source>swapping the state of the local copy &lt;code&gt;rhs&lt;/code&gt; and &lt;code&gt;*this&lt;/code&gt; is &lt;em&gt;usually&lt;/em&gt; relatively easy to do without potential failure/exceptions, given the local copy doesn't need any particular state afterwards (just needs state fit for the destructor to run, much as for an object being &lt;em&gt;moved&lt;/em&gt; from in &amp;gt;= C++11)</source>
          <target state="translated">intercambiando el estado de la copia local &lt;code&gt;rhs&lt;/code&gt; y &lt;code&gt;*this&lt;/code&gt; &lt;em&gt;generalmente&lt;/em&gt; es relativamente f&amp;aacute;cil de hacer sin posibles fallas / excepciones, dado que la copia local no necesita ning&amp;uacute;n estado particular despu&amp;eacute;s (solo necesita un estado adecuado para que se ejecute el destructor, al igual que para un objeto &lt;em&gt;movido&lt;/em&gt; desde en&amp;gt; = C ++ 11)</target>
        </trans-unit>
        <trans-unit id="59f71233e3c4ef85ebf3d7a582670676fcefbffa" translate="yes" xml:space="preserve">
          <source>that acquisition can be attempted &lt;em&gt;before&lt;/em&gt; modifying the current state of the object (i.e. &lt;code&gt;*this&lt;/code&gt;) if a copy of the new value is made, which is why &lt;code&gt;rhs&lt;/code&gt; is accepted &lt;em&gt;by value&lt;/em&gt; (i.e. copied) rather than &lt;em&gt;by reference&lt;/em&gt;</source>
          <target state="translated">esa adquisici&amp;oacute;n se puede intentar &lt;em&gt;antes de&lt;/em&gt; modificar el estado actual del objeto (es decir, &lt;code&gt;*this&lt;/code&gt; ) si se realiza una copia del nuevo valor, raz&amp;oacute;n por la cual se acepta &lt;code&gt;rhs&lt;/code&gt; &lt;em&gt;por valor&lt;/em&gt; (es decir, copiado) en lugar de &lt;em&gt;por referencia&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="325605391ecda9b9100aa948f683600e372575dc" translate="yes" xml:space="preserve">
          <source>the most error-prone part of assigning to an object is ensuring any resources the new state needs are acquired (e.g. memory, descriptors)</source>
          <target state="translated">la parte más propensa a errores en la asignación de un objeto es asegurar que se adquieran los recursos que el nuevo estado necesita (por ejemplo,memoria,descriptores)</target>
        </trans-unit>
        <trans-unit id="33fd9e929e77e0dfd3e85632f2f3ada808c62662" translate="yes" xml:space="preserve">
          <source>⁂ The copy-and-swap idiom can introduce inefficiencies or limitations due to the use of an extra temporary (when the operator's parameter is copy-constructed):</source>
          <target state="translated">⁂ La expresión &quot;copiar e intercambiar&quot; puede introducir ineficiencias o limitaciones debido a la utilización de una temporalidad extra (cuando el parámetro del operador está construido en forma de copia):</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
