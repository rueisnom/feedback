<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3279543">
    <body>
      <group id="3279543">
        <trans-unit id="6c226e8c6cc9d76ab83c602a00d6e4dc0fc4f9d3" translate="yes" xml:space="preserve">
          <source>&amp;Dagger; assignment operator implementation that seems sane when assigning from a distinct object can easily fail for self-assignment.  While it might seem unimaginable that client code would even attempt self-assignment, it can happen relatively easily during algo operations on containers, with &lt;code&gt;x = f(x);&lt;/code&gt; code where &lt;code&gt;f&lt;/code&gt; is (perhaps only for some &lt;code&gt;#ifdef&lt;/code&gt; branches) a macro ala &lt;code&gt;#define f(x) x&lt;/code&gt; or a function returning a reference to &lt;code&gt;x&lt;/code&gt;, or even (likely inefficient but concise) code like &lt;code&gt;x = c1 ? x * 2 : c2 ? x / 2 : x;&lt;/code&gt;).  For example:</source>
          <target state="translated">distinct個別のオブジェクトからの割り当て時に正気に見える割り当て演算子の実装は、自己割り当てが失敗する可能性があります。 クライアントコードが自己割り当てを試みることさえ想像できないように思えるかもしれませんが、 &lt;code&gt;x = f(x);&lt;/code&gt; して、コンテナーのアルゴ操作中に比較的簡単に発生する可能性があります。 ここで、 &lt;code&gt;f&lt;/code&gt; は（おそらく一部の &lt;code&gt;#ifdef&lt;/code&gt; ブランチのみ）マクロala &lt;code&gt;#define f(x) x&lt;/code&gt; または &lt;code&gt;x&lt;/code&gt; への参照を返す関数、または &lt;code&gt;x = c1 ? x * 2 : c2 ? x / 2 : x;&lt;/code&gt; x * 2：c2？ x / 2：x; ）。 例えば：</target>
        </trans-unit>
        <trans-unit id="bb7374700aafe18beca629b3c0f274d8e62aa193" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;The reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.</source>
          <target state="translated">&amp;Dagger;理由は簡単です。リソースを自分に割り当てたら、それを必要な場所に入れ替えたり移動したりできます（C ++ 11）。 パラメータリストにコピーを作成することで、最適化を最大化できます。</target>
        </trans-unit>
        <trans-unit id="163368ac3c34ec2c83983583f0414ca3308b0713" translate="yes" xml:space="preserve">
          <source>&amp;dagger; &lt;code&gt;swap&lt;/code&gt; throwing: it's generally possible to reliably swap data members that the objects track by pointer, but non-pointer data members that don't have a throw-free swap, or for which swapping has to be implemented as &lt;code&gt;X tmp = lhs; lhs = rhs; rhs = tmp;&lt;/code&gt; and copy-construction or assignment may throw, still have the potential to fail leaving some data members swapped and others not.  This potential applies even to C++03 &lt;code&gt;std::string&lt;/code&gt;'s as James comments on another answer:</source>
          <target state="translated">&amp;dagger; &lt;code&gt;swap&lt;/code&gt; スロー：一般に、オブジェクトがポインターで追跡するデータメンバーを確実にスワップできますが、スローフリースワップを持たない、またはスワップを &lt;code&gt;X tmp = lhs; lhs = rhs; rhs = tmp;&lt;/code&gt; として実装する必要がある非ポインターデータメンバー; lhs = rhs; rhs = tmp; コピー構築または割り当てがスローされる場合がありますが、一部のデータメンバーがスワップされたままになり、他のメンバーはスワップされないままになる可能性があります。 この可能性は、Jamesが別の回答にコメントするC ++ 03 &lt;code&gt;std::string&lt;/code&gt; も当てはまります。</target>
        </trans-unit>
        <trans-unit id="7f199a37b50d8112edd59b2da2ef5d80d8b29454" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&amp;dagger;The move constructor should generally be &lt;code&gt;noexcept&lt;/code&gt;, otherwise some code (e.g. &lt;code&gt;std::vector&lt;/code&gt; resizing logic) will use the copy constructor even when a move would make sense. Of course, only mark it noexcept if the code inside doesn't throw exceptions.</source>
          <target state="translated">&amp;dagger;&amp;dagger;ムーブコンストラクターは通常 &lt;code&gt;noexcept&lt;/code&gt; でなければなりません 。そうでない場合、一部のコード（例： &lt;code&gt;std::vector&lt;/code&gt; リサイジングロジック）は、ムーブが意味をなす場合でもコピーコンストラクターを使用します。 もちろん、内部のコードが例外をスローしない場合を除いて、それをnoとマークするだけです。</target>
        </trans-unit>
        <trans-unit id="75fc32cb0b6c21685002f255ba8bd3b417167a6f" translate="yes" xml:space="preserve">
          <source>&amp;dagger;There are other claims that we should specialize &lt;code&gt;std::swap&lt;/code&gt; for our type, provide an in-class &lt;code&gt;swap&lt;/code&gt; along-side a free-function &lt;code&gt;swap&lt;/code&gt;, etc. But this is all unnecessary: any proper use of &lt;code&gt;swap&lt;/code&gt; will be through an unqualified call, and our function will be found through &lt;a href=&quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;ADL&lt;/a&gt;. One function will do.</source>
          <target state="translated">&amp;dagger;タイプに &lt;code&gt;std::swap&lt;/code&gt; を特化したり、自由関数 &lt;code&gt;swap&lt;/code&gt; と並んでクラス内 &lt;code&gt;swap&lt;/code&gt; 提供したりする必要があるという他の主張があります。しかし、これはすべて不要です。 &lt;code&gt;swap&lt;/code&gt; 適切な使用は、無資格によるものです。呼び出すと、関数が&lt;a href=&quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;ADL&lt;/a&gt;を通じて見つかります。 1つの関数が行います。</target>
        </trans-unit>
        <trans-unit id="d2f8a6a9ff582b62e6b05e0ec952e18a7cba21f7" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/questions/5695548/public-friend-swap-member-function&quot;&gt;Here&lt;/a&gt; is the explanation why &lt;code&gt;public friend swap&lt;/code&gt;.) Now not only can we swap our &lt;code&gt;dumb_array&lt;/code&gt;'s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.</source>
          <target state="translated">（これが &lt;code&gt;public friend swap&lt;/code&gt; 理由です。）これで、 &lt;code&gt;dumb_array&lt;/code&gt; をスワップできるだけでなく、スワップ全般がより効率的になります。 配列全体を割り当ててコピーするのではなく、ポインタとサイズを交換するだけです。 機能性と効率性におけるこのボーナスを除けば、コピーアンドスワップイディオムを実装する準備が整いました。</target>
        </trans-unit>
        <trans-unit id="e3d46a3ef24d9ab6012b40252b69014fa5aa5434" translate="yes" xml:space="preserve">
          <source>(Not only that, but unqualified calls to &lt;code&gt;swap&lt;/code&gt; will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that &lt;code&gt;std::swap&lt;/code&gt; would entail.)</source>
          <target state="translated">（それだけでなく、 &lt;code&gt;swap&lt;/code&gt; への修飾されていない呼び出しは、カスタムスワップオペレーターを使用し、 &lt;code&gt;std::swap&lt;/code&gt; が必要とするクラスの不要な構築と破棄をスキップします。）</target>
        </trans-unit>
        <trans-unit id="fc5de9386b1a45a3cfcfa383e680e501a72d73b4" translate="yes" xml:space="preserve">
          <source>(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)</source>
          <target state="translated">(コンパイラによってはコンストラクタのデリゲーションをサポートしていないものがあることに注意してください。これは不幸なことですが、幸いにも簡単な作業です)。</target>
        </trans-unit>
        <trans-unit id="5e19805a2e15f201ad87bd588181abb3d0cc728b" translate="yes" xml:space="preserve">
          <source>(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one? While this may seem to be a valid concern, and indeed it requires non-trivial &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; clauses, this is a non-issue. That's because a class should manage &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;em&gt;one resource only&lt;/em&gt;&lt;/a&gt;!)</source>
          <target state="translated">（1つのリソースを正しく管理するためにこれだけ多くのコードが必要な場合、クラスが複数のリソースを管理する場合はどうなりますか？これは有効な懸念事項であるように見えるかもしれませんが、実際には重要な &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 句が必要ですが、これは問題ではありません。これは、クラスは&lt;a href=&quot;http://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;em&gt;1つのリソースのみ&lt;/em&gt;&lt;/a&gt;を管理する必要があるためです！）</target>
        </trans-unit>
        <trans-unit id="5f022b51a041ef6021d6448cd154d99898408496" translate="yes" xml:space="preserve">
          <source>*Why do we set &lt;code&gt;mArray&lt;/code&gt; to null? Because if any further code in the operator throws, the destructor of &lt;code&gt;dumb_array&lt;/code&gt; might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</source>
          <target state="translated">* &lt;code&gt;mArray&lt;/code&gt; をnullに設定するのはなぜですか？ 演算子のコードがさらにスローされると、 &lt;code&gt;dumb_array&lt;/code&gt; のデストラクタが呼び出される可能性があるためです。 nullに設定せずにそれが発生した場合、すでに削除されているメモリを削除しようとします！ nullを削除することは操作ではないので、nullに設定することでこれを回避します。</target>
        </trans-unit>
        <trans-unit id="b66b8649c482abfc519d6e23ca6ba54f66162dcc" translate="yes" xml:space="preserve">
          <source>... the compiler will yell at you when you call the &lt;code&gt;swap&lt;/code&gt; function:</source>
          <target state="translated">... &lt;code&gt;swap&lt;/code&gt; 関数を呼び出すと、コンパイラはあなたに怒鳴りつけます：</target>
        </trans-unit>
        <trans-unit id="739480efc6308b236632d75a12d950aab5506d77" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616&quot;&gt;Conceptually&lt;/a&gt;, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a &lt;code&gt;swap&lt;/code&gt; function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616&quot;&gt;概念的に&lt;/a&gt;は、コピーコンストラクターの機能を使用してデータのローカルコピーを作成し、次にコピーされたデータを &lt;code&gt;swap&lt;/code&gt; 関数で取得して、古いデータを新しいデータと交換します。 その後、一時的なコピーは破棄され、古いデータが一緒に破棄されます。 新しいデータのコピーが残ります。</target>
        </trans-unit>
        <trans-unit id="d8e39573869dabdfb98f89cc9b39812879c351fd" translate="yes" xml:space="preserve">
          <source>@wilhelmtell: In C++03, there is no mention of exceptions potentially thrown by std::string::swap (which is called by std::swap). In C++0x, std::string::swap is noexcept and must not throw exceptions. &amp;ndash; James McNellis Dec 22 '10 at 15:24</source>
          <target state="translated">@wilhelmtell：C ++ 03では、std :: string :: swap（std :: swapによって呼び出される）によってスローされる可能性のある例外については言及されていません。 C ++ 0xでは、std :: string :: swapはnoexceptであり、例外をスローしてはなりません。 &amp;ndash; James McNellis、2010年12月22日15:24</target>
        </trans-unit>
        <trans-unit id="8a6f040aeb295117c1efb68678f192378c4a33b9" translate="yes" xml:space="preserve">
          <source>A failed solution</source>
          <target state="translated">失敗した解決策</target>
        </trans-unit>
        <trans-unit id="1f123ac936e30fe0974c20eefdb479af236b59d9" translate="yes" xml:space="preserve">
          <source>A successful solution</source>
          <target state="translated">成功したソリューション</target>
        </trans-unit>
        <trans-unit id="0a8b69bb09bc2425818b674879026645aff63337" translate="yes" xml:space="preserve">
          <source>A swap function is a &lt;em&gt;non-throwing&lt;/em&gt; function that swaps two objects of a class, member for member. We might be tempted to use &lt;code&gt;std::swap&lt;/code&gt; instead of providing our own, but this would be impossible; &lt;code&gt;std::swap&lt;/code&gt; uses the copy-constructor and copy-assignment operator within its implementation, and we'd ultimately be trying to define the assignment operator in terms of itself!</source>
          <target state="translated">スワップ関数は、クラスの2つのオブジェクト（メンバーごと）をスワップする&lt;em&gt;非スロー&lt;/em&gt;関数です。 独自のものを提供する代わりに &lt;code&gt;std::swap&lt;/code&gt; を使用したくなるかもしれませんが、これは不可能です。 &lt;code&gt;std::swap&lt;/code&gt; は、その実装内でcopy-constructorおよびcopy-assignment演算子を使用しており、最終的には代入演算子をそれ自体で定義しようとしています！</target>
        </trans-unit>
        <trans-unit id="18c04be3fc2a0bcac1f0511d9edd72d5489a05de" translate="yes" xml:space="preserve">
          <source>A way around this is to not use &lt;code&gt;friend&lt;/code&gt; keyword and redefine the &lt;code&gt;swap&lt;/code&gt; function:</source>
          <target state="translated">これを回避する方法は、 &lt;code&gt;friend&lt;/code&gt; キーワードを使用せずに &lt;code&gt;swap&lt;/code&gt; 関数を再定義することです。</target>
        </trans-unit>
        <trans-unit id="96739476d5a5d3d0fbe5f2e1e80ac733b38525c4" translate="yes" xml:space="preserve">
          <source>A way of implementing the assignment operator in terms of a swap function:</source>
          <target state="translated">スワップ関数の観点から代入演算子を実装する方法。</target>
        </trans-unit>
        <trans-unit id="099a6586cd9d3a08c5d495a2db19fa35488b71be" translate="yes" xml:space="preserve">
          <source>After all, you don't &lt;em&gt;need&lt;/em&gt; to use a &lt;code&gt;friend&lt;/code&gt; function to swap 2 objects. It makes just as much sense to make &lt;code&gt;swap&lt;/code&gt; a member function that has one &lt;code&gt;other&lt;/code&gt; object as a parameter.</source>
          <target state="translated">結局のところ、 &lt;code&gt;friend&lt;/code&gt; 関数を使用して2つのオブジェクトを交換する&lt;em&gt;必要&lt;/em&gt;は&lt;em&gt;あり&lt;/em&gt;ません。 &lt;code&gt;other&lt;/code&gt; 1つのオブジェクトをパラメーターとして持つメンバー関数を &lt;code&gt;swap&lt;/code&gt; するのと同じくらい意味があります。</target>
        </trans-unit>
        <trans-unit id="c864fce5142351dfaef1c82c9c081e821224b89b" translate="yes" xml:space="preserve">
          <source>Although it's been mentioned in many places, we didn't have any singular &quot;what is it&quot; question and answer, so here it is. Here is a partial list of places where it was previously mentioned:</source>
          <target state="translated">いろいろなところで言及されていますが、単数形の「それは何か」という質問と回答はありませんでしたので、こちらになります。以前に言及されていた場所の一部をご紹介します。</target>
        </trans-unit>
        <trans-unit id="e9671eba126f32f76a109bf11cdbf7cf819ba06b" translate="yes" xml:space="preserve">
          <source>An in-depth explanation</source>
          <target state="translated">徹底した解説</target>
        </trans-unit>
        <trans-unit id="c73d2a01cb43ee42c7ec7bce3573c7cec34d6cdc" translate="yes" xml:space="preserve">
          <source>And so concludes the copy-and-swap idiom.</source>
          <target state="translated">そして、コピー&amp;スワップという慣用句は、このように結論づけられています。</target>
        </trans-unit>
        <trans-unit id="9b5dace86273f14ab55c392c7b880a011ead98aa" translate="yes" xml:space="preserve">
          <source>And that is the copy-and-swap idiom.</source>
          <target state="translated">そして、それがコピーアンドスワップという慣用句です。</target>
        </trans-unit>
        <trans-unit id="2c207f27020378f00a7220d5874fff08752c57e7" translate="yes" xml:space="preserve">
          <source>And that's it! With one fell swoop, all three problems are elegantly tackled at once.</source>
          <target state="translated">そして、これだ! 3つの問題に一気にエレガントに取り組むことができます。</target>
        </trans-unit>
        <trans-unit id="a253fea1b4ead859fd72efb21cf1f3617ee2fe71" translate="yes" xml:space="preserve">
          <source>And we say we're finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as &lt;code&gt;(n)&lt;/code&gt;.</source>
          <target state="translated">そして、私たちは完成したと言います。 これはリークなしでアレイを管理します。 ただし、コード内で &lt;code&gt;(n)&lt;/code&gt; と順次マークされている3つの問題があります。</target>
        </trans-unit>
        <trans-unit id="46cb3e743fce8064b54f7c24bedac5fd2b065252" translate="yes" xml:space="preserve">
          <source>Any class that manages a resource (a &lt;em&gt;wrapper&lt;/em&gt;, like a smart pointer) needs to implement &lt;a href=&quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three&quot;&gt;The Big Three&lt;/a&gt;. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?</source>
          <target state="translated">リソースを管理するクラス（スマートポインターのような&lt;em&gt;ラッパー&lt;/em&gt; ）は、 &lt;a href=&quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three&quot;&gt;The Big Three&lt;/a&gt;を実装する必要があります。 コピーコンストラクタとデストラクタの目標と実装は単純ですが、コピー割り当て演算子は、おそらく最も微妙で難しいものです。 それはどのように行うべきですか？ どのような落とし穴を避ける必要がありますか？</target>
        </trans-unit>
        <trans-unit id="b5f0db215ce832cd77e56cc7229f8e1b22ecb595" translate="yes" xml:space="preserve">
          <source>As mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a &lt;code&gt;swap&lt;/code&gt; function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called &quot;The Big Three and A Half&quot;: any time your class manages a resource it also makes sense to provide a &lt;code&gt;swap&lt;/code&gt; function.</source>
          <target state="translated">前述のように、コピーアンドスワップイディオムはこれらの問題をすべて修正します。 しかし、現時点では、1つを除くすべての要件があります。それは、 &lt;code&gt;swap&lt;/code&gt; 関数です。 3つのルールは、コピーコンストラクター、代入演算子、およびデストラクターの存在を伴うことに成功していますが、実際には「ビッグスリーアンドハーフ」と呼ばれるべきです。クラスがリソースを管理するときはいつでも、 &lt;code&gt;swap&lt;/code&gt; を提供することにも意味があります。関数。</target>
        </trans-unit>
        <trans-unit id="89e4ca10b74850fc9016dbb8310675a1462b938c" translate="yes" xml:space="preserve">
          <source>Assignment, at its heart, is two steps: &lt;strong&gt;&lt;em&gt;tearing down the object's old state&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;building its new state as a copy&lt;/em&gt;&lt;/strong&gt; of some other object's state.</source>
          <target state="translated">基本的に、割り当ては2つのステップで行われます。 &lt;strong&gt;&lt;em&gt;オブジェクトの古い状態&lt;/em&gt;&lt;/strong&gt;を&lt;strong&gt;&lt;em&gt;破棄し、&lt;/em&gt;&lt;/strong&gt;他のオブジェクトの状態の&lt;strong&gt;&lt;em&gt;コピーとして新しい状態を構築し&lt;/em&gt;&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d4de93db789fe9ea751b9c3c9f7efc0214b87843" translate="yes" xml:space="preserve">
          <source>At this point we are home-free, because &lt;code&gt;swap&lt;/code&gt; is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter's scope ends and its destructor is called.)</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; はスローされないため、この時点ではホームフリーです。 現在のデータをコピーしたデータと入れ替えて、安全に状態を変更し、古いデータを一時的に入れます。 関数が戻ると、古いデータが解放されます。 （パラメーターのスコープが終了し、そのデストラクターが呼び出される場所。）</target>
        </trans-unit>
        <trans-unit id="22b41cb12332be04aca21ea73d3c777d0bbc2bc4" translate="yes" xml:space="preserve">
          <source>Basically, that's what the &lt;strong&gt;&lt;em&gt;destructor&lt;/em&gt;&lt;/strong&gt; and the &lt;strong&gt;&lt;em&gt;copy constructor&lt;/em&gt;&lt;/strong&gt; do, so the first idea would be to delegate the work to them. However, since destruction mustn't fail, while construction might, &lt;em&gt;we actually want to do it the other way around&lt;/em&gt;: &lt;strong&gt;&lt;em&gt;first perform the constructive part&lt;/em&gt;&lt;/strong&gt; and, if that succeeded, &lt;strong&gt;&lt;em&gt;then do the destructive part&lt;/em&gt;&lt;/strong&gt;. The copy-and-swap idiom is a way to do just that: It first calls a class' copy constructor to create a temporary object, then swaps its data with the temporary's, and then lets the temporary's destructor destroy the old state.</source>
          <target state="translated">基本的に、それは&lt;strong&gt;&lt;em&gt;デストラクタ&lt;/em&gt;&lt;/strong&gt;と&lt;strong&gt;&lt;em&gt;コピーコンストラクタが&lt;/em&gt;&lt;/strong&gt;行うことなので、最初のアイデアは、作業をそれらに委任することです。 ただし、破壊が失敗してはならないので、構築は可能ですが、 &lt;em&gt;実際には逆にしたいと思います&lt;/em&gt; 。 &lt;strong&gt;&lt;em&gt;最初に構築部分&lt;/em&gt;&lt;/strong&gt;を&lt;strong&gt;&lt;em&gt;実行し、&lt;/em&gt;&lt;/strong&gt;成功した場合&lt;strong&gt;&lt;em&gt;は破壊部分を実行し&lt;/em&gt;&lt;/strong&gt;ます。 コピーアンドスワップイディオムは、まさにそれを行う方法です。最初にクラスのコピーコンストラクターを呼び出して一時オブジェクトを作成し、次にそのデータを一時オブジェクトと交換し、一時オブジェクトのデストラクタに古い状態を破棄させます。</target>
        </trans-unit>
        <trans-unit id="21f3313cd21a2541f96630aa3e2a0cf47d569892" translate="yes" xml:space="preserve">
          <source>Because the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of &lt;code&gt;operator=&lt;/code&gt;. (Additionally, we no longer have a performance penalty on non-self-assignments.)</source>
          <target state="translated">イディオムはコードを繰り返さないため、オペレーター内にバグを導入することはできません。 これは、自己代入チェックの必要がなくなるため、 &lt;code&gt;operator=&lt;/code&gt; 単一の均一な実装が可能になることを意味しています。 （さらに、非自己割り当てのパフォーマンスペナルティはなくなりました。）</target>
        </trans-unit>
        <trans-unit id="ee86d87c6e42b253320f7528f74891164bb782f1" translate="yes" xml:space="preserve">
          <source>C++: dynamically allocating an array of objects?</source>
          <target state="translated">C++:オブジェクトの配列を動的に割り当てる?</target>
        </trans-unit>
        <trans-unit id="e729ebfbf18123cb9c8f157732414fc00291bf88" translate="yes" xml:space="preserve">
          <source>Copy constructor and = operator overload in C++: is a common function possible?</source>
          <target state="translated">C++でコンストラクタと=演算子のオーバーロードをコピーする:共通関数は可能ですか?</target>
        </trans-unit>
        <trans-unit id="94f8c0f65181c1bf410e4113cb80538a2f639df0" translate="yes" xml:space="preserve">
          <source>Either way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.</source>
          <target state="translated">どちらにしても、この方法でリソースを取得することが、コードの重複をなくす鍵となります:コピーを作成するためにコピーコンストラクタのコードを使うことができます。これでコピーができたので、スワップの準備ができました。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="79202c91683120bfb6ddb6c07a5bad7dc7c88c9b" translate="yes" xml:space="preserve">
          <source>For concreteness, let us consider a container &lt;code&gt;std::vector&amp;lt;T, A&amp;gt;&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is some stateful allocator type, and we'll compare the following functions:</source>
          <target state="translated">具体的には、コンテナー &lt;code&gt;std::vector&amp;lt;T, A&amp;gt;&lt;/code&gt; 考えてみましょう。ここで、 &lt;code&gt;A&lt;/code&gt; はステートフルアロケータータイプであり、次の関数を比較します。</target>
        </trans-unit>
        <trans-unit id="f160b70becf0b5d89fbecbeb4ad05cafa0e60064" translate="yes" xml:space="preserve">
          <source>Here's how a naive implementation might look:</source>
          <target state="translated">ナイーブな実装がどのように見えるかというと、こんな感じです。</target>
        </trans-unit>
        <trans-unit id="bec44ad24b77ebad1653d346d85b618d564afd9f" translate="yes" xml:space="preserve">
          <source>Here, a hand-written &lt;code&gt;Client::operator=&lt;/code&gt; might check if &lt;code&gt;*this&lt;/code&gt; is already connected to the same server as &lt;code&gt;rhs&lt;/code&gt; (perhaps sending a &quot;reset&quot; code if useful), whereas the copy-and-swap approach would invoke the copy-constructor which would likely be written to open a distinct socket connection then close the original one.  Not only could that mean a remote network interaction instead of a simple in-process variable copy, it could run afoul of client or server limits on socket resources or connections.  (Of course this class has a pretty horrid interface, but that's another matter ;-P).</source>
          <target state="translated">ここで、手書きの &lt;code&gt;Client::operator=&lt;/code&gt; は、 &lt;code&gt;*this&lt;/code&gt; がすでに &lt;code&gt;rhs&lt;/code&gt; と同じサーバーに接続されているかどうかをチェックする可能性があります（おそらく、「リセット」コードを送信すると便利です）。一方、コピーアンドスワップアプローチでは、コピー別個のソケット接続を開いてから元のソケット接続を閉じるように作成される可能性が高いコンストラクター。 これは、単純なインプロセス変数のコピーではなく、リモートネットワークの相互作用を意味するだけでなく、ソケットリソースまたは接続でクライアントまたはサーバーの制限を超えて実行される可能性があります。 （もちろん、このクラスには恐ろしいインターフェースがありますが、それは別の問題です;-P）。</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">どうやって使うのか?</target>
        </trans-unit>
        <trans-unit id="fc088e1a9c9b7f4c8a1d611a7ecd41e9c5e1abfa" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt;, the program has &lt;em&gt;undefined behaviour&lt;/em&gt; (cf. [container.requirements.general/8].</source>
          <target state="translated">ただし、 &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt; 場合、プログラムの&lt;em&gt;動作&lt;/em&gt;は&lt;em&gt;未定義です&lt;/em&gt; （cf. [container.requirements.general / 8]。</target>
        </trans-unit>
        <trans-unit id="236be016134b3d1b54ff3ee12c4a2f9cc364e3e2" translate="yes" xml:space="preserve">
          <source>I would like to add a word of warning when you are dealing with C++11-style allocator-aware containers. Swapping and assignment have subtly different semantics.</source>
          <target state="translated">C++11 スタイルのアロケータ対応コンテナを扱う際には、一言注意を加えておきたいと思います。スワッピングと代入は微妙に異なるセマンティクスを持っています。</target>
        </trans-unit>
        <trans-unit id="3f28ca2de2b68eac16c3d42e71f3ac049eaef11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_move_assignment&lt;/code&gt; is &lt;code&gt;std::true_type&lt;/code&gt;, then &lt;code&gt;fm&lt;/code&gt; reassigns the allocator of &lt;code&gt;a&lt;/code&gt; with the value of &lt;code&gt;b.get_allocator()&lt;/code&gt;, otherwise it does not, and &lt;code&gt;a&lt;/code&gt; continues to use its original allocator. In that case, the data elements need to be swapped individually, since the storage of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is not compatible.</source>
          <target state="translated">&lt;code&gt;AT::propagate_on_container_move_assignment&lt;/code&gt; が &lt;code&gt;std::true_type&lt;/code&gt; 場合、 &lt;code&gt;fm&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; のアロケーターを &lt;code&gt;b.get_allocator()&lt;/code&gt; の値で再割り当てします。それ以外の場合は割り当てず、元のアロケーターを引き続き使用します。 その場合、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; のストレージには互換性がないため、データ要素を個別に交換する必要があります。</target>
        </trans-unit>
        <trans-unit id="4510757f293d56b7a112af8252c4984d58f759e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;std::false_type&lt;/code&gt;, then we need a dynamic check.</source>
          <target state="translated">&lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; が &lt;code&gt;std::false_type&lt;/code&gt; 場合、動的チェックが必要です。</target>
        </trans-unit>
        <trans-unit id="b3573d07a320cef433ba754980663abfd331a87f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;std::true_type&lt;/code&gt;, then &lt;code&gt;fs&lt;/code&gt; swaps both data and allocators in the expected fashion.</source>
          <target state="translated">&lt;code&gt;AT::propagate_on_container_swap&lt;/code&gt; が &lt;code&gt;std::true_type&lt;/code&gt; 場合、 &lt;code&gt;fs&lt;/code&gt; はデータとアロケーターの両方を予想どおりにスワップします。</target>
        </trans-unit>
        <trans-unit id="73d3a4270600b651da25bd4b3260fe77df37829f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.get_allocator() == b.get_allocator()&lt;/code&gt;, then the two containers use compatible storage, and swapping proceeds in the usual fashion.</source>
          <target state="translated">&lt;code&gt;a.get_allocator() == b.get_allocator()&lt;/code&gt; 場合、2つのコンテナは互換性のあるストレージを使用し、スワッピングは通常の方法で進行します。</target>
        </trans-unit>
        <trans-unit id="b8d03c15d57131584a2028550fb794a9339e9cad" translate="yes" xml:space="preserve">
          <source>In its refined form, copy-and-swap is implemented by having the copy performed by initializing the (non-reference) parameter of the assignment operator:</source>
          <target state="translated">洗練された形では、コピーアンドスワップは、代入演算子の(非参照)パラメータを初期化することでコピーを実行させることで実装されます。</target>
        </trans-unit>
        <trans-unit id="9f37decf779a75710e40ed5c33a2089302cd7911" translate="yes" xml:space="preserve">
          <source>In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a &lt;code&gt;swap&lt;/code&gt; function.</source>
          <target state="translated">コピーアンドスワップイディオムを使用するには、3つのものが必要です。有効なコピーコンストラクター、有効なデストラクタ（どちらもラッパーの基礎であるため、とにかく完全でなければなりません）、および &lt;code&gt;swap&lt;/code&gt; 関数です。</target>
        </trans-unit>
        <trans-unit id="8c6f02b160b536e0af64d17d3f8eab3f4e9be471" translate="yes" xml:space="preserve">
          <source>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.</source>
          <target state="translated">私たちの場合、その核心部分は2行(割り当てとコピー)だけですが、より複雑なリソースでは、このコードの肥大化はかなり面倒なものになります。決して繰り返さないように努力すべきです。</target>
        </trans-unit>
        <trans-unit id="41bf38d748ecfa54c2c45421d2ad416833ae458b" translate="yes" xml:space="preserve">
          <source>In some versions of Visual Studio (and possibly other compilers) there is a bug that is really annoying and doesn't make sense. So if you declare/define your &lt;code&gt;swap&lt;/code&gt; function like this:</source>
          <target state="translated">Visual Studioの一部のバージョン（およびおそらく他のコンパイラー）には、本当に煩わしいバグがあり、意味がありません。 したがって、次のように &lt;code&gt;swap&lt;/code&gt; 関数を宣言/定義すると、</target>
        </trans-unit>
        <trans-unit id="a9821302f3683bd9875458d7b470497ba0484ef2" translate="yes" xml:space="preserve">
          <source>Let's consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:</source>
          <target state="translated">具体的なケースを考えてみましょう。何の役にも立たないクラスで、動的な配列を管理したいとします。まず、作業用のコンストラクタ、コピーコンストラクタ、デストラクタから始めます。</target>
        </trans-unit>
        <trans-unit id="27c808c7552dbd2cdeb49163a8d2a3c074f0dbac" translate="yes" xml:space="preserve">
          <source>Luckily for us, this is easy:</source>
          <target state="translated">幸いなことに、これは簡単です。</target>
        </trans-unit>
        <trans-unit id="7402c1a7b7b4cd8a707b425e610cbcb74419bc20" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;other&lt;/code&gt; is being initialized with an rvalue, &lt;em&gt;it will be move-constructed&lt;/em&gt;. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will &lt;em&gt;automatically&lt;/em&gt; pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)</source>
          <target state="translated">これで、 &lt;code&gt;other&lt;/code&gt; が右辺値で初期化されている場合は、 &lt;em&gt;move-constructedになり&lt;/em&gt;ます。 完璧です。 C ++ 03が引数by-valueを使用してコピーコンストラクター機能を再利用できるように、C ++ 11も適切な場合にmove-constructorを&lt;em&gt;自動的に&lt;/em&gt;選択します。 （そしてもちろん、以前にリンクされた記事で述べたように、値のコピー/移動は単に完全に省略されるかもしれません。）</target>
        </trans-unit>
        <trans-unit id="dcbeb7c58de6f8ef2e5b152493010bd5fba66a2c" translate="yes" xml:space="preserve">
          <source>Observe that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won't even enter the function if construction of the copy fails, and it's therefore not possible to alter the state of &lt;code&gt;*this&lt;/code&gt;. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)</source>
          <target state="translated">関数に入ると、すべての新しいデータがすでに割り当てられ、コピーされており、使用する準備ができていることに注意してください。 これが、私たちに強力な例外保証を無料で提供するものです。コピーの構築が失敗した場合、関数に入ることさえないため、 &lt;code&gt;*this&lt;/code&gt; の状態を変更することはできません。 （以前は強力な例外保証のために手動で行っていましたが、コンパイラーは現在私たちのために行っています。</target>
        </trans-unit>
        <trans-unit id="e6868ab3511bcd3b27c0685657d0cf94d4a5c6ed" translate="yes" xml:space="preserve">
          <source>On self-assignment, the above code delete's &lt;code&gt;x.p_;&lt;/code&gt;, points &lt;code&gt;p_&lt;/code&gt; at a newly allocated heap region, then attempts to read the &lt;em&gt;uninitialised&lt;/em&gt; data therein (Undefined Behaviour), if that doesn't do anything too weird, &lt;code&gt;copy&lt;/code&gt; attempts a self-assignment to every just-destructed 'T'!</source>
          <target state="translated">自己割り当てでは、上記のコードは &lt;code&gt;x.p_;&lt;/code&gt; 削除します。 、 &lt;code&gt;p_&lt;/code&gt; を新しく割り当てられたヒープ領域に向け、そこで&lt;em&gt;初期化さ&lt;/em&gt;れて&lt;em&gt;いない&lt;/em&gt;データ（未定義の動作）を読み取ろうとします。それが奇妙なことを何も行わない場合、 &lt;code&gt;copy&lt;/code&gt; は破壊されたすべての「T」に自己割り当てを試みます！</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9c234a83c1275c3ee466e4738c02c7633c54a69e" translate="yes" xml:space="preserve">
          <source>Self-assignment done as a copy-and-swap avoids oft-overlooked edge cases.&amp;Dagger;</source>
          <target state="translated">コピーアンドスワップとして行われる自己割り当てにより、見過ごされがちなエッジケースが回避されます。&amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="6f659bc43bf7db07f752a5d1512e544f94e1af00" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;swap()&lt;/code&gt; is supposed to never fail, the only part which might fail is the copy-construction. That is performed first, and if it fails, nothing will be changed in the targeted object.</source>
          <target state="translated">&lt;code&gt;swap()&lt;/code&gt; は決して失敗しないことが想定されているため、失敗する可能性のある唯一の部分はコピー構築です。 それが最初に実行され、失敗した場合、ターゲットオブジェクトでは何も変更されません。</target>
        </trans-unit>
        <trans-unit id="26f7740f7272c6a37203cde27ca0ef723ebbbf32" translate="yes" xml:space="preserve">
          <source>So what we've done is simple: initialize via the default constructor (a C++11 feature), then swap with &lt;code&gt;other&lt;/code&gt;; we know a default constructed instance of our class can safely be assigned and destructed, so we know &lt;code&gt;other&lt;/code&gt; will be able to do the same, after swapping.</source>
          <target state="translated">したがって、私たちが行ったことは単純です。デフォルトのコンストラクター（C ++ 11機能）を介して初期化してから、 &lt;code&gt;other&lt;/code&gt; と交換します。 クラスのデフォルトで構築されたインスタンスを安全に割り当て、破棄できることがわかっているので、スワッピング後に &lt;code&gt;other&lt;/code&gt; インスタンスでも同じことができるようになります。</target>
        </trans-unit>
        <trans-unit id="2b5693bc5962ed6f9799bbcb35014ba8ea8fefd0" translate="yes" xml:space="preserve">
          <source>That is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:</source>
          <target state="translated">クラスに変更を加える必要があるのはこれだけです。パラメータを参照ではなく値にするという重要な決定を忘れないでください。</target>
        </trans-unit>
        <trans-unit id="9ef6aff2994558c1366be20966048a47a804bb07" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;copy-and-swap idiom&lt;/em&gt; is the solution, and elegantly assists the assignment operator in achieving two things: avoiding &lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;code duplication&lt;/a&gt;, and providing a &lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_guarantees&quot;&gt;strong exception guarantee&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;コピーアンドスワップイディオム&lt;/em&gt;がソリューションであり、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;コードの重複&lt;/a&gt;を回避することと、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_guarantees&quot;&gt;強力な例外保証&lt;/a&gt;を提供することの2つを達成するために、割り当て演算子をエレガントに支援します。</target>
        </trans-unit>
        <trans-unit id="42e54c42a60d22bc2d5ac75e35558832e40d8bb3" translate="yes" xml:space="preserve">
          <source>The code has expanded! Which leads us to the third problem: code duplication. Our assignment operator effectively duplicates all the code we've already written elsewhere, and that's a terrible thing.</source>
          <target state="translated">コードが拡張された!これが3つ目の問題、コードの重複です。私たちの代入演算子は、私たちがすでに他の場所で書いたすべてのコードを効果的に複製してしまいます。</target>
        </trans-unit>
        <trans-unit id="63d41c6ca1535180248065869d3328499b07b825" translate="yes" xml:space="preserve">
          <source>The first  is the self-assignment test. This check serves two purposes: it's an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste. It would be better if the operator could work properly without it.</source>
          <target state="translated">1つ目は自己割当テストです。このチェックには2つの目的があります:自己割り当てで不要なコードを実行しないようにする簡単な方法です。しかし、それ以外のすべての場合において、これは単にプログラムを遅くし、コード内のノイズとして機能するだけです。演算子がこのチェックなしで正常に動作するようになれば、より良いでしょう。</target>
        </trans-unit>
        <trans-unit id="6f60ff23b795c7da205d246f356a1def07956d8e" translate="yes" xml:space="preserve">
          <source>The fundamental idea is that:</source>
          <target state="translated">というのが基本的な考え方です。</target>
        </trans-unit>
        <trans-unit id="83588406b98957bd4b1f640c1bf0685f68308d07" translate="yes" xml:space="preserve">
          <source>The goal</source>
          <target state="translated">目標</target>
        </trans-unit>
        <trans-unit id="fd746b321830bfc8609d2fd310324c39c1c7bf04" translate="yes" xml:space="preserve">
          <source>The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now &lt;strong&gt;The Rule of Four&lt;/strong&gt; (and a half). Why? Because not only do we need to be able to copy-construct our resource, &lt;a href=&quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me&quot;&gt;we need to move-construct it as well&lt;/a&gt;.</source>
          <target state="translated">C ++の次のバージョンであるC ++ 11は、リソースの管理方法に1つの非常に重要な変更を加えます。3つ&lt;strong&gt;のルールは4つのルール&lt;/strong&gt; （および半分）になりました。 どうして？ リソースをコピー構築できる必要があるだけでなく、リソースも&lt;a href=&quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me&quot;&gt;移動構築する必要があります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="150781c474b203c76af89ffc1927280c58bbd0ff" translate="yes" xml:space="preserve">
          <source>The purpose of both functions &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;fm&lt;/code&gt; is to give &lt;code&gt;a&lt;/code&gt; the state that &lt;code&gt;b&lt;/code&gt; had initially. However, there is a hidden question: What happens if &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt;? The answer is: It depends. Let's write &lt;code&gt;AT = std::allocator_traits&amp;lt;A&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;fs&lt;/code&gt; と &lt;code&gt;fm&lt;/code&gt; の両方の目的は、 &lt;code&gt;b&lt;/code&gt; が最初に持っていた状態を与えることです。 ただし、隠れた質問があります &lt;code&gt;a.get_allocator() != b.get_allocator()&lt;/code&gt; どうなりますか？ 答えは次のとおりです。 &lt;code&gt;AT = std::allocator_traits&amp;lt;A&amp;gt;&lt;/code&gt; 書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="8e8b0eb32111093ee430fedf7a03880593d06a45" translate="yes" xml:space="preserve">
          <source>The second is that it only provides a basic exception guarantee. If &lt;code&gt;new int[mSize]&lt;/code&gt; fails, &lt;code&gt;*this&lt;/code&gt; will have been modified. (Namely, the size is wrong and the data is gone!) For a strong exception guarantee, it would need to be something akin to:</source>
          <target state="translated">2つ目は、基本的な例外保証のみを提供することです。 &lt;code&gt;new int[mSize]&lt;/code&gt; が失敗した場合、 &lt;code&gt;*this&lt;/code&gt; は変更されています。 （つまり、サイズが間違っていて、データがなくなっています！）強力な例外保証のためには、次のようなものである必要があります。</target>
        </trans-unit>
        <trans-unit id="2c6fcc3a8c5ecf729853f999132fcff2680df339" translate="yes" xml:space="preserve">
          <source>The upshot is that swapping has become a non-trivial operation in C++11 as soon as your container starts supporting stateful allocators. That's a somewhat &quot;advanced use case&quot;, but it's not entirely unlikely, since move optimizations usually only become interesting once your class manages a resource, and memory is one of the most popular resources.</source>
          <target state="translated">結果として、コンテナがステートフル アロケータのサポートを開始するとすぐに、C++11 ではスワップの操作が非自明なものになってしまいます。これはやや「高度なユースケース」ですが、まったく可能性がないわけではありません。なぜなら、移動の最適化は通常、クラスがリソースを管理するようになって初めて面白くなるからです。</target>
        </trans-unit>
        <trans-unit id="388be71290411a46bfa3cef8cea4ebaa96d6633d" translate="yes" xml:space="preserve">
          <source>There are some good answers already.  I'll focus &lt;em&gt;mainly&lt;/em&gt; on what I think they lack - an explanation of the &quot;cons&quot; with the copy-and-swap idiom....</source>
          <target state="translated">すでにいくつかの良い答えがあります。 私は&lt;em&gt;主&lt;/em&gt;にそれらが欠けていると思うものに焦点を当てます-コピーアンドスワップイディオムの「短所」の説明...</target>
        </trans-unit>
        <trans-unit id="cbe63039ab446d86b4ac167fd16b3d3dadd41365" translate="yes" xml:space="preserve">
          <source>This answer is more like an addition and a slight modification to the answers above.</source>
          <target state="translated">この回答は、どちらかというと上記の回答に加筆・修正を加えたようなものです。</target>
        </trans-unit>
        <trans-unit id="c1083ee173869cd02574e5832d5f7c99145ada0e" translate="yes" xml:space="preserve">
          <source>This class almost manages the array successfully, but it needs &lt;code&gt;operator=&lt;/code&gt; to work correctly.</source>
          <target state="translated">このクラスは配列をほぼ正常に管理しますが、 &lt;code&gt;operator=&lt;/code&gt; が正しく機能する必要があります。</target>
        </trans-unit>
        <trans-unit id="29f80c1b07d0671e4a256b348ff66c1e913f3c22" translate="yes" xml:space="preserve">
          <source>This has something to do with a &lt;code&gt;friend&lt;/code&gt; function being called and &lt;code&gt;this&lt;/code&gt; object being passed as a parameter.</source>
          <target state="translated">これは、 &lt;code&gt;friend&lt;/code&gt; 関数が呼び出され、 &lt;code&gt;this&lt;/code&gt; オブジェクトがパラメーターとして渡されることと関係があります。</target>
        </trans-unit>
        <trans-unit id="5aa765f67fd688a1ba7150d96a03c571fde7ba09" translate="yes" xml:space="preserve">
          <source>This time, you can just call &lt;code&gt;swap&lt;/code&gt; and pass in &lt;code&gt;other&lt;/code&gt;, thus making the compiler happy:</source>
          <target state="translated">今回は、単に &lt;code&gt;swap&lt;/code&gt; を呼び出して &lt;code&gt;other&lt;/code&gt; を渡すことができるため、コンパイラーを満足させることができます。</target>
        </trans-unit>
        <trans-unit id="633375af64a272c488ff9c504c74dbb8f98b646a" translate="yes" xml:space="preserve">
          <source>We first notice an important choice: the parameter argument is taken &lt;em&gt;by-value&lt;/em&gt;. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):</source>
          <target state="translated">最初に重要な選択に気づき&lt;em&gt;ます&lt;/em&gt; 。パラメーター引数は&lt;em&gt;by-valueを&lt;/em&gt;取り&lt;em&gt;ます&lt;/em&gt; 。 同じように簡単に次のことを実行できます（実際、イディオムの単純な実装の多くが実行します）。</target>
        </trans-unit>
        <trans-unit id="63217325aa31565f08b4e39b47c1e5fc48d70a30" translate="yes" xml:space="preserve">
          <source>We lose an &lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;important optimization opportunity&lt;/a&gt;. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list.&amp;Dagger;)</source>
          <target state="translated">&lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;重要な最適化の機会&lt;/a&gt;を失う。 それだけでなく、この選択は、後で説明するC ++ 11では重要です。 （一般的な注意として、非常に便利なガイドラインは次のとおりです：関数内の何かのコピーを作成する場合は、コンパイラーにパラメーターリストで実行させます。&amp;Dagger;）</target>
        </trans-unit>
        <trans-unit id="9edc40ca06ad2a68fa87b0a4a4acc15e97ae9f73" translate="yes" xml:space="preserve">
          <source>We need to add swap functionality to our class, and we do that as follows&amp;dagger;:</source>
          <target state="translated">クラスにスワップ機能を追加する必要があります。これは次のように行います&amp;dagger;：</target>
        </trans-unit>
        <trans-unit id="c2edab5c5da4b7e0cb43225936cb000f569c92ee" translate="yes" xml:space="preserve">
          <source>What about C++11?</source>
          <target state="translated">C++11はどうですか?</target>
        </trans-unit>
        <trans-unit id="787ffecc94ae151e431f132b817ebb5ac7bd5b64" translate="yes" xml:space="preserve">
          <source>What are your favorite C++ Coding Style idioms:  Copy-swap</source>
          <target state="translated">あなたの好きなC++Coding Styleの熟語は何ですか?コピースワップ</target>
        </trans-unit>
        <trans-unit id="6dc672ff6eb837cd0bbe834afc644c2d587d212d" translate="yes" xml:space="preserve">
          <source>What is copy elision and how it optimizes copy-and-swap idiom</source>
          <target state="translated">コピーエリシオンとは何か、コピーアンドスワップのイディオムを最適化する方法</target>
        </trans-unit>
        <trans-unit id="3f800a7430fd4c0527c40982197ac647fe2c18a0" translate="yes" xml:space="preserve">
          <source>What is the copy-and-swap idiom</source>
          <target state="translated">コピーアンドスワップの慣用句とは</target>
        </trans-unit>
        <trans-unit id="a8f471015362e9a261fa62137612c1258db68efb" translate="yes" xml:space="preserve">
          <source>What is the copy-and-swap idiom?</source>
          <target state="translated">コピーアンドスワップの慣用句とは?</target>
        </trans-unit>
        <trans-unit id="ede6b7eaf3770f7b7b840f5f578c287f11e2cccd" translate="yes" xml:space="preserve">
          <source>What is this idiom and when should it be used? Which problems does it solve? Does the idiom change when C++11 is used?</source>
          <target state="translated">この慣用句は何で、どんな時に使うべきなのか?どのような問題を解決するのですか?C++11を使うとイディオムは変わりますか?</target>
        </trans-unit>
        <trans-unit id="aa7922596966a3f09ff20d40921994a57ffd3b96" translate="yes" xml:space="preserve">
          <source>What's going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.</source>
          <target state="translated">ここで何が起こっているのでしょうか?移動-構築の目的を思い出してください:クラスの別のインスタンスからリソースを取り、それを割り当て可能で破壊可能であることが保証された状態に残すことです。</target>
        </trans-unit>
        <trans-unit id="10170890d98f9c422d746d6a228ebc44fc0a6ee0" translate="yes" xml:space="preserve">
          <source>When any performance penalty or momentarily higher resource usage created by having an extra temporary object during the assignment is not important to your application. ⁂</source>
          <target state="translated">割り当て中に余分な一時的なオブジェクトを持つことで生じるパフォーマンスの低下や一時的なリソース使用量の増加が、アプリケーションにとって重要ではない場合。⁂</target>
        </trans-unit>
        <trans-unit id="60f80e0ee25da3bc05679b2ff44dd7fcf6b5baef" translate="yes" xml:space="preserve">
          <source>When should it be used?  (Which problems does it solve &lt;strong&gt;[/create]&lt;/strong&gt;?)</source>
          <target state="translated">いつ使用すべきですか？ （どの問題が&lt;strong&gt;[/ create]を&lt;/strong&gt;解決し&lt;strong&gt;ます&lt;/strong&gt;か？）</target>
        </trans-unit>
        <trans-unit id="2634e1acfb3bf9e69b4daa989e044e2431bc5a1b" translate="yes" xml:space="preserve">
          <source>When you want a clean, easy to understand, robust way to define the assignment operator in terms of (simpler) copy constructor, &lt;code&gt;swap&lt;/code&gt; and destructor functions.</source>
          <target state="translated">（より単純な）コピーコンストラクター、 &lt;code&gt;swap&lt;/code&gt; 関数、およびデストラクタ関数の観点から代入演算子を定義する、クリーンで理解しやすく、堅牢な方法が必要な場合。</target>
        </trans-unit>
        <trans-unit id="29733bade5cab23e00e5d05e6412f95b30d5413f" translate="yes" xml:space="preserve">
          <source>When you want the assigned-to objected unaffected by an assignment that throws an exception, assuming you have or can write a &lt;code&gt;swap&lt;/code&gt; with strong exception guarantee, and ideally one that can't fail/&lt;code&gt;throw&lt;/code&gt;..&amp;dagger;</source>
          <target state="translated">割り当てられたオブジェクトを、例外をスローする割り当ての影響を受けないようにしたい場合は、強力な例外保証付きの &lt;code&gt;swap&lt;/code&gt; を持っている、または書き込めると想定して、失敗/ &lt;code&gt;throw&lt;/code&gt; できないものが理想的です。&amp;dagger;</target>
        </trans-unit>
        <trans-unit id="62b4affc932ffa8cde8f9a8bc7cc83fb3e7fe0f0" translate="yes" xml:space="preserve">
          <source>Why do we need the copy-and-swap idiom?</source>
          <target state="translated">なんでコピーアンドスワップの慣用句が必要なんだ?</target>
        </trans-unit>
        <trans-unit id="d1974d73fa36fa9b1fe2996664091dd361d57f96" translate="yes" xml:space="preserve">
          <source>Why does it work?</source>
          <target state="translated">なぜ効果があるのか?</target>
        </trans-unit>
        <trans-unit id="9c9b118f04e39a7318e3a5798cdcb9006d842f63" translate="yes" xml:space="preserve">
          <source>Why does that work?</source>
          <target state="translated">なぜそれが効くのか?</target>
        </trans-unit>
        <trans-unit id="b2665c67e419327eea773cca5cbb1ebf91e5f8c3" translate="yes" xml:space="preserve">
          <source>Without further ado, our assignment operator is:</source>
          <target state="translated">さらっと説明すると、私たちの代入演算子は</target>
        </trans-unit>
        <trans-unit id="e464362a2570aee7cf3bb10e5f052520cacc687e" translate="yes" xml:space="preserve">
          <source>You already have access to &lt;code&gt;this&lt;/code&gt; object, so passing it in as a parameter is technically redundant.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; オブジェクトにはすでにアクセスしているため、パラメーターとして渡すことは技術的に冗長です。</target>
        </trans-unit>
        <trans-unit id="a945bce89ff4bd35449cef3d57b6ca6c27388c0e" translate="yes" xml:space="preserve">
          <source>swapping the state of the local copy &lt;code&gt;rhs&lt;/code&gt; and &lt;code&gt;*this&lt;/code&gt; is &lt;em&gt;usually&lt;/em&gt; relatively easy to do without potential failure/exceptions, given the local copy doesn't need any particular state afterwards (just needs state fit for the destructor to run, much as for an object being &lt;em&gt;moved&lt;/em&gt; from in &amp;gt;= C++11)</source>
          <target state="translated">ローカルコピーの状態をスワップする &lt;code&gt;rhs&lt;/code&gt; と &lt;code&gt;*this&lt;/code&gt; は、ローカルコピーが後で特定の状態を必要としないことを考えると、 &lt;em&gt;通常、&lt;/em&gt;比較的簡単に潜在的な失敗/例外なしに実行できます（デストラクタを実行するのに適した状態が必要です） &amp;gt; = C ++ 11で&lt;em&gt;移動元の&lt;/em&gt;オブジェクト）</target>
        </trans-unit>
        <trans-unit id="59f71233e3c4ef85ebf3d7a582670676fcefbffa" translate="yes" xml:space="preserve">
          <source>that acquisition can be attempted &lt;em&gt;before&lt;/em&gt; modifying the current state of the object (i.e. &lt;code&gt;*this&lt;/code&gt;) if a copy of the new value is made, which is why &lt;code&gt;rhs&lt;/code&gt; is accepted &lt;em&gt;by value&lt;/em&gt; (i.e. copied) rather than &lt;em&gt;by reference&lt;/em&gt;</source>
          <target state="translated">新しい値のコピーが作成される場合、オブジェクト（つまり &lt;code&gt;*this&lt;/code&gt; ）の現在の状態を変更する&lt;em&gt;前に&lt;/em&gt;取得を試行できます。これは、 &lt;code&gt;rhs&lt;/code&gt; が&lt;em&gt;参照&lt;/em&gt;ではなく&lt;em&gt;値&lt;/em&gt; （つまりコピー） &lt;em&gt;によって&lt;/em&gt;受け入れられる理由&lt;em&gt;です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="325605391ecda9b9100aa948f683600e372575dc" translate="yes" xml:space="preserve">
          <source>the most error-prone part of assigning to an object is ensuring any resources the new state needs are acquired (e.g. memory, descriptors)</source>
          <target state="translated">オブジェクトへの代入で最もエラーを起こしやすいのは、新しい状態が必要とするリソース(メモリ、ディスクリプタなど)を確実に取得することです。</target>
        </trans-unit>
        <trans-unit id="33fd9e929e77e0dfd3e85632f2f3ada808c62662" translate="yes" xml:space="preserve">
          <source>⁂ The copy-and-swap idiom can introduce inefficiencies or limitations due to the use of an extra temporary (when the operator's parameter is copy-constructed):</source>
          <target state="translated">⁂ コピーアンドスワップイディオムは、(演算子のパラメータがコピー構造化されている場合に)余分なテンポラリを使用することによる非効率性や制限を導入することができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
