<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/322715">
    <body>
      <group id="322715">
        <trans-unit id="823154fd74560a83cc6bee588649f9eab42ae643" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;Search:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; search operation is pretty fast compared to the &lt;code&gt;LinkedList&lt;/code&gt; search operation. &lt;code&gt;get(int index)&lt;/code&gt; in &lt;code&gt;ArrayList&lt;/code&gt; gives the performance of &lt;code&gt;O(1)&lt;/code&gt; while &lt;code&gt;LinkedList&lt;/code&gt; performance is &lt;code&gt;O(n)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;Search:&lt;/code&gt; операция поиска &lt;code&gt;ArrayList&lt;/code&gt; выполняется довольно быстро по сравнению с операцией поиска &lt;code&gt;LinkedList&lt;/code&gt; . &lt;code&gt;get(int index)&lt;/code&gt; в &lt;code&gt;ArrayList&lt;/code&gt; дает производительность &lt;code&gt;O(1)&lt;/code&gt; а &lt;code&gt;LinkedList&lt;/code&gt; - &lt;code&gt;O(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9dd8e774bff097745b7775bb8d0ce9bb80f0d5" translate="yes" xml:space="preserve">
          <source>1. Implementation</source>
          <target state="translated">1.Реализация</target>
        </trans-unit>
        <trans-unit id="39e90e34901690aa4761ad905d14ac1d3dfdc5d3" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;Deletion:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; remove operation gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives variable performance: &lt;code&gt;O(n)&lt;/code&gt; in worst case (while removing first element) and &lt;code&gt;O(1)&lt;/code&gt; in best case (While removing last element).</source>
          <target state="translated">2) &lt;code&gt;Deletion:&lt;/code&gt; операция удаления &lt;code&gt;LinkedList&lt;/code&gt; дает производительность &lt;code&gt;O(1)&lt;/code&gt; то время как &lt;code&gt;ArrayList&lt;/code&gt; дает переменную производительность: &lt;code&gt;O(n)&lt;/code&gt; в худшем случае (при удалении первого элемента) и &lt;code&gt;O(1)&lt;/code&gt; в лучшем случае (при удалении последнего элемента).</target>
        </trans-unit>
        <trans-unit id="e5e97190dfb614f2fbe264bd76660de27ae359f6" translate="yes" xml:space="preserve">
          <source>2. Performance</source>
          <target state="translated">2.Производительность .</target>
        </trans-unit>
        <trans-unit id="35be33e4f01930f4341e2e90cad04e8ccd9b9340" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;Inserts Performance:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; add method gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives &lt;code&gt;O(n)&lt;/code&gt; in worst case. Reason is same as explained for remove.</source>
          <target state="translated">3) &lt;code&gt;Inserts Performance:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; : метод добавления LinkedList дает производительность &lt;code&gt;O(1)&lt;/code&gt; а &lt;code&gt;ArrayList&lt;/code&gt; в худшем случае - &lt;code&gt;O(n)&lt;/code&gt; . Причина та же, что и для удаления.</target>
        </trans-unit>
        <trans-unit id="cad09e39292bee8a79b011228fe0514e7c225093" translate="yes" xml:space="preserve">
          <source>3. Reverse  Iterator</source>
          <target state="translated">3.Обратный итератор</target>
        </trans-unit>
        <trans-unit id="ab7a005ac90b45cd9b3e91e6392f71a58ed5d6f3" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;Memory Overhead:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains indexes and element data while &lt;code&gt;LinkedList&lt;/code&gt; maintains element data and two pointers for neighbor nodes</source>
          <target state="translated">4) &lt;code&gt;Memory Overhead:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; поддерживает индексы и данные элемента, в то время как &lt;code&gt;LinkedList&lt;/code&gt; поддерживает данные элемента и два указателя для соседних узлов.</target>
        </trans-unit>
        <trans-unit id="e450f6c0e8ad7231222f9efe27918d977874a66a" translate="yes" xml:space="preserve">
          <source>4. Initial Capacity</source>
          <target state="translated">4.Начальная мощность</target>
        </trans-unit>
        <trans-unit id="d9ff1d6f80c80852e98b6ef3bb0fc8224d5df608" translate="yes" xml:space="preserve">
          <source>5. Memory Overhead</source>
          <target state="translated">5.Надбавка памяти</target>
        </trans-unit>
        <trans-unit id="127cf06445897840aec95708ef603d3e04a0e331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; goes more in depth, as does 
&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Массив vs ArrayList vs LinkedList vs Vector&lt;/a&gt; более детален, как и &lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b43a5b05b6e36c0f963a65dff5cbbba5dd87c900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt;, btw, is a custom ArrayList implementation holding &lt;code&gt;Int&lt;/code&gt; (primitive type) and not Objects - hence all data is really stored adjacently - hence even more efficient.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt; , кстати, является пользовательской реализацией ArrayList, содержащей &lt;code&gt;Int&lt;/code&gt; (примитивный тип), а не Objects - следовательно, все данные действительно хранятся смежно - следовательно, еще более эффективно.</target>
        </trans-unit>
        <trans-unit id="a60af0233530522d0db70105194d2d6809d47074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an &lt;code&gt;ArrayList&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; in the worst case but constant on average.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; , с другой стороны, разрешает быстрый произвольный доступ для чтения, так что вы можете получить любой элемент за постоянное время. Но добавление или удаление из любого места, кроме конца, требует сдвига всех последних элементов, чтобы сделать отверстие или заполнить пробел. Кроме того, если вы добавляете больше элементов, чем емкость базового массива, выделяется новый массив (в 1,5 раза больше размера), и старый массив копируется в новый, поэтому добавление в &lt;code&gt;ArrayList&lt;/code&gt; равно &lt;em&gt;O (n)&lt;/em&gt; в худший случай, но постоянный в среднем.</target>
        </trans-unit>
        <trans-unit id="a7d8b017cec005f28991d76ebeb6880b6882d238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; both implements &lt;code&gt;List interface&lt;/code&gt;  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; и &lt;code&gt;LinkedList&lt;/code&gt; реализуют &lt;code&gt;List interface&lt;/code&gt; а их методы и результаты практически идентичны. Однако между ними мало различий, которые делают одно лучше другого в зависимости от требования.</target>
        </trans-unit>
        <trans-unit id="c5b77accd97f06a73806437d14b939ebde6071c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is essentially an array. &lt;code&gt;LinkedList&lt;/code&gt; is implemented as a double linked list.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; по сути является массивом. &lt;code&gt;LinkedList&lt;/code&gt; реализован в виде двойного связанного списка.</target>
        </trans-unit>
        <trans-unit id="d80057e73ae69c2b5a916affaa4a8498705114f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is faster to access an indexed value. It is much worse when inserting or deleting objects.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; быстрее получает доступ к индексированному значению. Это гораздо хуже при вставке или удалении объектов.</target>
        </trans-unit>
        <trans-unit id="6b2e4c61036a69b6af002dcf70738ee96dffaaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is randomly accessible, while &lt;code&gt;LinkedList&lt;/code&gt; is really cheap to expand and remove elements from. For most cases, &lt;code&gt;ArrayList&lt;/code&gt; is fine.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; доступен случайным образом, тогда как &lt;code&gt;LinkedList&lt;/code&gt; действительно дешев для расширения и удаления элементов. В большинстве случаев &lt;code&gt;ArrayList&lt;/code&gt; подходит.</target>
        </trans-unit>
        <trans-unit id="8235411525223988a507c26abd524b3fcfeb5bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is what you want. &lt;code&gt;LinkedList&lt;/code&gt; is almost always a (performance) bug.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; - это то, что вы хотите. &lt;code&gt;LinkedList&lt;/code&gt; почти всегда является ошибкой (производительности).</target>
        </trans-unit>
        <trans-unit id="33b5deb58c1b5ecdbe2ecc3db08d5de6dd151430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt;, backed by &lt;code&gt;Array&lt;/code&gt;, which needs to be double the size, is worse in large volume application.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; , поддерживаемый &lt;code&gt;Array&lt;/code&gt; , который должен быть в два раза больше, хуже в приложениях большого объема.</target>
        </trans-unit>
        <trans-unit id="333d27970508614bdfa9c0f502286bf30e92e307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; - это &lt;em&gt;O (1)&lt;/em&gt; . &amp;lt;--- главное преимущество &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="034b1b506c582e5f2d8814254ec183017ef9f60e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; - это &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 2&lt;/em&gt; шага)</target>
        </trans-unit>
        <trans-unit id="beaa8d551243d49b4d1eee05d6432e391eb33d16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; allows for constant-time insertions or removals &lt;em&gt;using iterators&lt;/em&gt;, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says &lt;em&gt;&quot;operations that index into the list will traverse the list from the beginning or the end, whichever is closer&quot;&lt;/em&gt;, so those methods are &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/4&lt;/em&gt; steps) on average, though &lt;em&gt;O(1)&lt;/em&gt; for &lt;code&gt;index = 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; допускает вставки или удаления в постоянное время &lt;em&gt;с использованием итераторов&lt;/em&gt; , но только последовательный доступ к элементам. Другими словами, вы можете перемещаться по списку вперед или назад, но нахождение позиции в списке занимает время, пропорциональное размеру списка. В Javadoc говорится, что &lt;em&gt;&amp;laquo;операции, индексирующие в списке, будут проходить по списку с начала или конца, в зависимости от того, что ближе&amp;raquo;&lt;/em&gt; , поэтому эти методы в среднем &lt;em&gt;O (n)&lt;/em&gt; ( &lt;em&gt;n / 4&lt;/em&gt; шага), хотя &lt;em&gt;O (1)&lt;/em&gt; для &lt;code&gt;index = 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16d80efc38b7c2ea0ff720019ddcf6be70e20363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are two different implementations of the List interface. &lt;code&gt;LinkedList&lt;/code&gt; implements it with a doubly-linked list. &lt;code&gt;ArrayList&lt;/code&gt; implements it with a dynamically re-sizing array.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; и &lt;code&gt;ArrayList&lt;/code&gt; - это две разные реализации интерфейса List. &lt;code&gt;LinkedList&lt;/code&gt; реализует его с помощью двусвязного списка. &lt;code&gt;ArrayList&lt;/code&gt; реализует его с помощью динамически изменяемого размера массива.</target>
        </trans-unit>
        <trans-unit id="d9fecaf7b1171739d7cbdff1716ddbff9a310553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; is faster in add and remove, but slower in get. In brief, &lt;code&gt;LinkedList&lt;/code&gt; should be preferred if:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; быстрее в добавлении и удалении, но медленнее в получении. Вкратце, &lt;code&gt;LinkedList&lt;/code&gt; должен быть предпочтительным, если:</target>
        </trans-unit>
        <trans-unit id="7dee07befa9756327e6f1f9ab15fa468c808e73e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  This is one of the main benefits of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; - &lt;em&gt;O (1)&lt;/em&gt; Это одно из главных преимуществ &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e64862c3a1c0b96095da40a2294754310124b801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; - это &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 2&lt;/em&gt; шага)</target>
        </trans-unit>
        <trans-unit id="25bc6fa8f8ff344c68d917a97611b91fe8f94bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reason:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side &lt;code&gt;LinkedList&lt;/code&gt; implements doubly linked list which requires the traversal through all the elements for searching an element.</source>
          <target state="translated">&lt;code&gt;Reason:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; поддерживает систему на основе индекса для своих элементов, поскольку она неявно использует структуру данных массива, что ускоряет поиск элемента в списке. С другой стороны, &lt;code&gt;LinkedList&lt;/code&gt; реализует двусвязный список, который требует обхода всех элементов для поиска элемента.</target>
        </trans-unit>
        <trans-unit id="48481a079aa4dc0b62b86309c5b1f4c4656a27cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; - &lt;em&gt;O (1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86bcfe7042d55fdf6be9e4fe7feab45ac45db87d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt; amortized, but &lt;em&gt;O(n)&lt;/em&gt; worst-case since the array must be resized and copied</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; - &lt;em&gt;O (1)&lt;/em&gt; амортизируется, но &lt;em&gt;O (n)&lt;/em&gt; худший случай, так как размер массива должен быть изменен и скопирован</target>
        </trans-unit>
        <trans-unit id="f30395d9afdb07d74da12292c1d66f1727a434a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; равно &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 2&lt;/em&gt; шага)</target>
        </trans-unit>
        <trans-unit id="c772faf78eb3c02de68edab5a6179904996ef451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average),
but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt;  &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; - это &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 4&lt;/em&gt; шага), но &lt;em&gt;O (1),&lt;/em&gt; когда &lt;code&gt;index = 0&lt;/code&gt; &amp;lt;--- основное преимущество &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe559a7d7843b54392656da159db0507b58dd66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.add()&lt;/code&gt; is  O(1) and &lt;code&gt;linkedlist.add()&lt;/code&gt; is 0(1)</source>
          <target state="translated">&lt;code&gt;arraylist.add()&lt;/code&gt; - это O (1), а &lt;code&gt;linkedlist.add()&lt;/code&gt; - 0 (1).</target>
        </trans-unit>
        <trans-unit id="03269f8a98a307f7cfd06520bf46af87990ad50c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.contains()&lt;/code&gt; is O(n) and&lt;code&gt;linkedlist.contains()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.contains()&lt;/code&gt; = O (n), а связанный &lt;code&gt;linkedlist.contains()&lt;/code&gt; - O (n)</target>
        </trans-unit>
        <trans-unit id="618dfb209f4f59dfc35a87398c91f4408414c5e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.get()&lt;/code&gt; is  O(1) whereas &lt;code&gt;linkedlist.get()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.get()&lt;/code&gt; - это O (1), тогда как связанный &lt;code&gt;linkedlist.get()&lt;/code&gt; - это O (n)</target>
        </trans-unit>
        <trans-unit id="c747b2aa8edd29531dda369e30693d8e367bf978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.next()&lt;/code&gt; is O(1) and &lt;code&gt;linkedlist.next()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.next()&lt;/code&gt; - это O (1), а связанный &lt;code&gt;linkedlist.next()&lt;/code&gt; - O (1).</target>
        </trans-unit>
        <trans-unit id="10d74fef85d164534c516cace70835405c829375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.remove()&lt;/code&gt; is O(n) whereas &lt;code&gt;linkedlist.remove()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.remove()&lt;/code&gt; - это O (n), тогда как связанный &lt;code&gt;linkedlist.remove()&lt;/code&gt; - это O (1)</target>
        </trans-unit>
        <trans-unit id="83cf5e81c843d7f1b9ec0ebf7d3ce303ed679233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  &amp;lt;--- main benefit of &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; - это &lt;em&gt;O (1)&lt;/em&gt; &amp;lt;--- главное преимущество &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="076d7c0a115bbd75984dc63de232ffd83355229d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; равно &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 4&lt;/em&gt; шага)</target>
        </trans-unit>
        <trans-unit id="c46760af862228653fd1838c5478b7b0940fecd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; - это O (n)</target>
        </trans-unit>
        <trans-unit id="7b106c9b6bde2953f3d1daf9d5119c83d5410807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt;is O(1)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; - это O (1)</target>
        </trans-unit>
        <trans-unit id="ddd6b224b5ccf09e47bc373ca347dfe7075c1356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; равно &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 2&lt;/em&gt; шага)</target>
        </trans-unit>
        <trans-unit id="cf4c56aa9b5498f71eb6ce9320a3051ac4546259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; равно &lt;em&gt;O (n)&lt;/em&gt; (в среднем &lt;em&gt;n / 4&lt;/em&gt; шага)</target>
        </trans-unit>
        <trans-unit id="e0e4246aea749c2db7c4d23e708786328b04d5d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; get(int index) operation runs in constant time i.e O(1)  while</source>
          <target state="translated">Операция &lt;em&gt;ArrayList&lt;/em&gt; get (int index) выполняется за постоянное время, т.е. O (1), в то время как</target>
        </trans-unit>
        <trans-unit id="5d33e09a0584a1ed7c3021a69aa36ebc1ffbaeb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; is the resizable array implementation of list interface , while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; - реализация массива интерфейса списка с изменяемым размером, в то время как</target>
        </trans-unit>
        <trans-unit id="c124a2a77d14e556f2817e5cd608afeed22dbfe5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt;  only constructs the empty list without any initial capacity.</source>
          <target state="translated">&lt;em&gt;LinkedList создает&lt;/em&gt; только пустой список без какой-либо начальной емкости.</target>
        </trans-unit>
        <trans-unit id="f4ee2569862439dbb15b3ae92435d3a68c160616" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; can be iterated in reverse direction using descendingIterator() while</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; может быть повторен в обратном направлении, используя downndingIterator (), в то время как</target>
        </trans-unit>
        <trans-unit id="c54e2d819276cdac9c5f9629b5f33af6e5719be2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; does not provide index-based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; не предоставляет доступ к элементам на основе индекса, поскольку он выполняет итерацию с начала или до конца (в зависимости от того, что ближе), чтобы получить узел с указанным индексом элемента.</target>
        </trans-unit>
        <trans-unit id="8bb16f32491a07a1a25788ce7789be628df88f90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; get(int index) operation run time is O(n) .</source>
          <target state="translated">Время выполнения операции get (int index) &lt;em&gt;LinkedList&lt;/em&gt; равно O (n).</target>
        </trans-unit>
        <trans-unit id="b58ac9358b965d629640277808e5c5aa9d8d6726" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; is the Doubly-linked list implementation of the list interface.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; - реализация списка с двойными связями интерфейса списка.</target>
        </trans-unit>
        <trans-unit id="2a8c0d7f347fae173c91da41a72879346a94ba06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Underlying Data Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) Базовая структура данных&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433009e1632a58f1c005d11c5b98f0de53409d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) LinkedList implements Deque&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) LinkedList реализует Deque&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8263acaceffe6556cde46deb5cd970572e9e42c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Removing an element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4) Удаление элемента из позиции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47f28efd57ef00e2c87c16894875d71e8b597837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5) Iterating over ArrayList or LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5) Итерации по ArrayList или LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bc5d37009869c02f222a403c214d3c17b0e706b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6) Retrieving element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6) Извлечение элемента из позиции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="462f50e91da5f54cbf63fd99a90f80e12a0505fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7) Memory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7) Память&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da1ffd583c2ad7be3699d0c0677415f869d74146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f05e8ad2e27a21a899fecd88f6a21aacab0d7ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt; Resizable-array implementation of the List interface</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt; реализация массива &lt;strong&gt;изменяемого&lt;/strong&gt; размера интерфейса List</target>
        </trans-unit>
        <trans-unit id="6af5a946c3943e163e4208c39ac575e870dcd320" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2269f0870ce22b776e94b551a51a669b55a88029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46534f184f1b21f4eddf5b75c18076e27fc2851f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: For Java its &lt;code&gt;LinkedList&lt;/code&gt; this is not true! See &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Is there a fast concat method for linked list in Java?&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Важно&lt;/strong&gt; : для Java его &lt;code&gt;LinkedList&lt;/code&gt; это не так! См. &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Есть ли быстрый метод concat для связанного списка в Java?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3e70a2309d967cc0183810bd32e9751566d788e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e04cb44a3754508f40774fb3722cf1f644583432" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt; Doubly-linked list implementation of the List and Deque interfaces</source>
          <target state="translated">&lt;strong&gt;LinkedList: реализация&lt;/strong&gt; двусвязных списков интерфейсов List и Deque</target>
        </trans-unit>
        <trans-unit id="4cfbebcdacd3a1fd25d71fd2c7e3bba3a64e9924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb54ee6bc49f7f8f58707bdd0ffe2bb21f75ea60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mainly&lt;/strong&gt; - that the nodes of the &lt;code&gt;LinkedList&lt;/code&gt; are scattered randomly across the memory. RAM (&quot;Random Access Memory&quot;) isn't really random and blocks of memory need to be fetched to cache. This operation takes time, and when such fetches happen frequently - the memory pages in the cache need to be replaced all the time -&amp;gt; Cache misses -&amp;gt; Cache is not efficient.
&lt;code&gt;ArrayList&lt;/code&gt; elements are stored on continuous memory - which is exactly what the modern CPU architecture is optimizing for.</source>
          <target state="translated">&lt;strong&gt;Главным образом&lt;/strong&gt; - то, что узлы &lt;code&gt;LinkedList&lt;/code&gt; случайно разбросаны по памяти. ОЗУ (&amp;laquo;Память с произвольным доступом&amp;raquo;) на самом деле не является случайным, и блоки памяти должны быть извлечены для кэширования. Эта операция требует времени, и когда такие выборки происходят часто - страницы памяти в кеше необходимо постоянно заменять -&amp;gt; Cache misses -&amp;gt; Cache неэффективен. Элементы &lt;code&gt;ArrayList&lt;/code&gt; хранятся в непрерывной памяти - именно для этого оптимизируется современная архитектура ЦП.</target>
        </trans-unit>
        <trans-unit id="737ee1d3842d6b6aa7c27ab74975e8879b369c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note 2:&lt;/strong&gt;&lt;em&gt;(thanks BeeOnRope)&lt;/em&gt; As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.</source>
          <target state="translated">&lt;strong&gt;Примечание 2:&lt;/strong&gt; &lt;em&gt;(спасибо BeeOnRope)&lt;/em&gt; Так как CompressedOops теперь используется по умолчанию начиная с середины JDK6 и выше, приведенные ниже значения для 64-битных машин будут в основном соответствовать их 32-битным аналогам, если, конечно, вы специально не отключите его.</target>
        </trans-unit>
        <trans-unit id="d44e01d24f2f947ad59025026aafcb6509358644" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The sizes shown for the &lt;code&gt;ArrayList&lt;/code&gt; lines are for &lt;em&gt;trimmed lists&lt;/em&gt; - In practice, the capacity of the backing array in an &lt;code&gt;ArrayList&lt;/code&gt; is generally larger than its current element count.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Размеры, показанные для строк &lt;code&gt;ArrayList&lt;/code&gt; , предназначены для &lt;em&gt;усеченных списков.&lt;/em&gt; На практике емкость резервного массива в &lt;code&gt;ArrayList&lt;/code&gt; обычно больше, чем его текущее количество элементов.</target>
        </trans-unit>
        <trans-unit id="12af4b8c2156f8719580823656e7a54b8c2d6d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Secondary&lt;/strong&gt;&lt;code&gt;LinkedList&lt;/code&gt; required to hold back/forward pointers, which means 3 times the memory consumption per value stored compared to &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Вторичный&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; требуется для удержания указателей назад / вперед, что означает 3-х кратное потребление памяти на хранимое значение по сравнению с &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1846b926ec6f26796aa1d815b9ecb79355628a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;&lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;ArrayDeque&lt;/code&gt; are preferable in &lt;em&gt;many&lt;/em&gt; more use-cases than &lt;code&gt;LinkedList&lt;/code&gt;. If you're not sure&amp;nbsp;&amp;mdash; just start with &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Резюме&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; с &lt;code&gt;ArrayDeque&lt;/code&gt; предпочтительнее во &lt;em&gt;многих&lt;/em&gt; случаях использования, чем &lt;code&gt;LinkedList&lt;/code&gt; . Если вы не уверены - просто начните с &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f13ec4830a4dab71f8b2f8ddb84bf2925c9db1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt; due to modern computer architecture, &lt;code&gt;ArrayList&lt;/code&gt; will be significantly more efficient for nearly any possible use-case - and therefore &lt;code&gt;LinkedList&lt;/code&gt; should be avoided except some very unique and extreme cases.</source>
          <target state="translated">&lt;strong&gt;TL; DR&lt;/strong&gt; из-за современной компьютерной архитектуры, &lt;code&gt;ArrayList&lt;/code&gt; будет значительно более эффективен практически для любого возможного варианта использования - и поэтому следует избегать &lt;code&gt;LinkedList&lt;/code&gt; , за исключением некоторых очень уникальных и экстремальных случаев.</target>
        </trans-unit>
        <trans-unit id="18c5c15402cf358ebe73222367ef252aff38be6e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/2&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (end of list), &lt;em&gt;n&lt;/em&gt; steps in the worst case (start of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Примечание. Многие операции требуют в среднем &lt;em&gt;n / 2&lt;/em&gt; шагов, &lt;em&gt;постоянное&lt;/em&gt; количество шагов в лучшем случае (конец списка), &lt;em&gt;n&lt;/em&gt; шагов в худшем случае (начало списка)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e66437897a99b75d7aacd4ff7c0bab63bf960599" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/4&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (e.g. index = 0), and &lt;em&gt;n/2&lt;/em&gt; steps in worst case (middle of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Примечание. Многие операции требуют в среднем &lt;em&gt;n / 4&lt;/em&gt; шагов, в лучшем случае &lt;em&gt;постоянное&lt;/em&gt; количество шагов (например, index = 0) и &lt;em&gt;n / 2&lt;/em&gt; шагов в худшем случае (середина списка)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b9d61654aa4c588b3965ecb02516b604046e37b" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="afb8a95f2210ccfc23ec59f145c584c9c6d9cbca" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="bfbcd797a68fe86413865e4a0cee9ebbb8dc882a" translate="yes" xml:space="preserve">
          <source>A key elements to remember is that the cost of fetching memory block, is more significant than the cost accessing a single memory cell. That's why reader 1MB of sequential memory is up to x400 times faster than reading this amount of data from different blocks of memory:</source>
          <target state="translated">Ключевым моментом,который следует запомнить,является то,что стоимость извлечения блока памяти,более существенна,чем стоимость доступа к одной ячейке памяти.Поэтому считыватель 1МБ последовательной памяти до x400 раз быстрее,чем считыватель этого объема данных из разных блоков памяти:</target>
        </trans-unit>
        <trans-unit id="964ab287d1b2674c3006a9a40f27cc8c75ad7689" translate="yes" xml:space="preserve">
          <source>A linked list specifies a progression from one item to the next (Item a -&amp;gt; item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one.</source>
          <target state="translated">Связанный список определяет переход от одного элемента к другому (Элемент a -&amp;gt; элемент b). Вы можете получить тот же эффект со списком массивов, но связанный список абсолютно говорит, какой элемент должен следовать за предыдущим.</target>
        </trans-unit>
        <trans-unit id="b210113b5c71ae47be12eff9c831066664d10253" translate="yes" xml:space="preserve">
          <source>Algorithms: Big-Oh Notation</source>
          <target state="translated">Алгоритмы:Большая Нотация</target>
        </trans-unit>
        <trans-unit id="89aa0aee53d5aa7fcca1da8190329ab378539fc9" translate="yes" xml:space="preserve">
          <source>Also adding an element in the mid of a list should be very efficient.</source>
          <target state="translated">Также добавление элемента в середине списка должно быть очень эффективным.</target>
        </trans-unit>
        <trans-unit id="61b3b2ef28066e4746dc4b1bff67b83b191c168c" translate="yes" xml:space="preserve">
          <source>Also, if you have large lists, keep in mind that memory usage is also different. Each element of a &lt;code&gt;LinkedList&lt;/code&gt; has more overhead since pointers to the next and previous elements are also stored. &lt;code&gt;ArrayLists&lt;/code&gt; don't have this overhead. However, &lt;code&gt;ArrayLists&lt;/code&gt; take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.</source>
          <target state="translated">Кроме того, если у вас большие списки, имейте в виду, что использование памяти также отличается. Каждый элемент &lt;code&gt;LinkedList&lt;/code&gt; имеет больше накладных расходов, так как указатели на следующий и предыдущий элементы также сохраняются. &lt;code&gt;ArrayLists&lt;/code&gt; не имеют этих накладных расходов. Однако &lt;code&gt;ArrayLists&lt;/code&gt; занимают столько памяти, сколько выделяется для емкости, независимо от того, были ли элементы фактически добавлены.</target>
        </trans-unit>
        <trans-unit id="2906ab1d13eae009cd628e69b029557fe9f42802" translate="yes" xml:space="preserve">
          <source>An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.</source>
          <target state="translated">Список массивов,по сути,представляет собой массив с методами добавления элементов и т.д.(и вместо этого следует использовать общий список).Это набор элементов,доступ к которым можно получить через индексатор (например,[0]).Он подразумевает переход от одного элемента к другому.</target>
        </trans-unit>
        <trans-unit id="928353d571ab22df35197d82101926d8b0eefa4a" translate="yes" xml:space="preserve">
          <source>An important feature of a linked list (which I didn't read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)</source>
          <target state="translated">Важной особенностью связанного списка (которую я не читал в другом ответе)является объединение двух списков.С массивом это O(n)(+накладные расходы некоторых перераспределений)со связанным списком это только O(1)или O(2);-)</target>
        </trans-unit>
        <trans-unit id="440b1f956dfeafd90ff94cb080bd1ba1475ed504" translate="yes" xml:space="preserve">
          <source>And of course, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; is your best friend.</source>
          <target state="translated">И, конечно же, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guam&lt;/a&gt; 's &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; - ваш лучший друг.</target>
        </trans-unit>
        <trans-unit id="73a833ab20503a4ddda3951abeecfe30b58c944c" translate="yes" xml:space="preserve">
          <source>Another benefit of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you add or remove from the head of the list, since those operations are &lt;em&gt;O(1)&lt;/em&gt;, while they are &lt;em&gt;O(n)&lt;/em&gt; for &lt;code&gt;ArrayList&lt;/code&gt;. Note that &lt;code&gt;ArrayDeque&lt;/code&gt; may be a good alternative to &lt;code&gt;LinkedList&lt;/code&gt; for adding and removing from the head, but it is not a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">Другое преимущество использования &lt;code&gt;LinkedList&lt;/code&gt; возникает, когда вы добавляете или удаляете из заголовка списка, так как эти операции &lt;em&gt;O (1)&lt;/em&gt; , а &lt;em&gt;O (n)&lt;/em&gt; для &lt;code&gt;ArrayList&lt;/code&gt; . Обратите внимание, что &lt;code&gt;ArrayDeque&lt;/code&gt; может быть хорошей альтернативой &lt;code&gt;LinkedList&lt;/code&gt; для добавления и удаления из заголовка , но это не &lt;code&gt;List&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30b3a7720a85a27ef41bbfc97676b4e2de8896a" translate="yes" xml:space="preserve">
          <source>Another difference between ArrayList and LinkedList is that apart from the List interface, LinkedList also implements Deque interface, which provides first in first out operations for add() and poll() and several other Deque functions. 3) Adding elements in ArrayList Adding element in ArrayList is O(1) operation if it doesn't trigger re-size of Array, in which case it becomes O(log(n)), On the other hand, appending an element in LinkedList is O(1) operation, as it doesn't require any navigation.</source>
          <target state="translated">Другое различие между ArrayList и LinkedList заключается в том,что кроме интерфейса Списка,LinkedList также реализует интерфейс Deque,который обеспечивает первые операции при первом выходе для функций add()и poll()и нескольких других функций Deque.3)Добавление элементов в LinkedList-это операция O(1),если она не приводит к изменению размера массива,и в этом случае он становится O(log(n)),с другой стороны,добавление элемента в LinkedList-это операция O(1),так как она не требует никакой навигации.</target>
        </trans-unit>
        <trans-unit id="1e86137c9ac677ec1de04c6463f5afe991a7e829" translate="yes" xml:space="preserve">
          <source>Any indexed operation requires a traversal, i.e. has O(n) performance. This is not obvious in the source code, leading to algorithms O(n) slower than if &lt;code&gt;ArrayList&lt;/code&gt; was used.</source>
          <target state="translated">Любая индексированная операция требует обхода, то есть имеет производительность O (n). Это не очевидно в исходном коде, что приводит к тому, что алгоритмы O (n) работают медленнее, чем при использовании &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="245a7f4435e5cb39a22d5f24ebfff9bf323d2ce3" translate="yes" xml:space="preserve">
          <source>ArrayList Vs LinkedList</source>
          <target state="translated">Массивный список Vs Связанный список</target>
        </trans-unit>
        <trans-unit id="fe0ac6572af91b6c617d95528d2b396ca2837309" translate="yes" xml:space="preserve">
          <source>ArrayList and LinkedList have their own pros and cons.</source>
          <target state="translated">У ArrayList и LinkedList есть свои плюсы и минусы.</target>
        </trans-unit>
        <trans-unit id="5b6785e144c9307049f97a69a012d7795245d88d" translate="yes" xml:space="preserve">
          <source>ArrayList extends AbstractList and implements the List Interface. ArrayList is dynamic array.</source>
          <target state="translated">ArrayList расширяет AbstractList и реализует интерфейс List Interface.ArrayList является динамическим массивом.</target>
        </trans-unit>
        <trans-unit id="437431a42628c440c8c8ddba7824d9ba269abd04" translate="yes" xml:space="preserve">
          <source>ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.</source>
          <target state="translated">ArrayList-это только лучший выбор для производительности,если все,что вы имеете в виду под производительностью,это пропускная способность,и вы можете игнорировать задержки.По своему опыту работы я не могу игнорировать худшие задержки.</target>
        </trans-unit>
        <trans-unit id="1913d3898d20247f47f9e0c995812cdb4b8d08d7" translate="yes" xml:space="preserve">
          <source>ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList is faster than doing n iterations with LinkedList.</source>
          <target state="translated">ArrayList использует адрес сопрягаемой памяти по сравнению с LinkedList'ом,который использует указатели на следующий узел.Таким образом,когда вы хотите просмотреть элемент в массиве ArrayList,это быстрее,чем делать n итераций со связным списком.</target>
        </trans-unit>
        <trans-unit id="d9b713914a6a1ace02a2eecb0047e6799c67666f" translate="yes" xml:space="preserve">
          <source>ArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.</source>
          <target state="translated">ArrayLists хорош для write-once-read-many или appenders,но плохо для addremove с передней или средней стороны.</target>
        </trans-unit>
        <trans-unit id="459e94cfdff5088a8182f4ad9a0d304b933bf06b" translate="yes" xml:space="preserve">
          <source>As explained above the insert and remove operations give good performance &lt;code&gt;(O(1))&lt;/code&gt; in &lt;code&gt;LinkedList&lt;/code&gt; compared to &lt;code&gt;ArrayList(O(n))&lt;/code&gt;.</source>
          <target state="translated">Как объяснено выше, операции вставки и удаления дают хорошую производительность &lt;code&gt;(O(1))&lt;/code&gt; в &lt;code&gt;LinkedList&lt;/code&gt; по сравнению с &lt;code&gt;ArrayList(O(n))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bafe9e2667a408bbc28c0a3d0896d45d6514421" translate="yes" xml:space="preserve">
          <source>As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.</source>
          <target state="translated">Что касается ArrayList'а,то я согласен,что,по крайней мере,всегда следует использовать конструктор с начальной емкостью,чтобы максимально минимизировать дублирование массивов.</target>
        </trans-unit>
        <trans-unit id="41b881749d840dd577c03a0d047dddf4b9b4432c" translate="yes" xml:space="preserve">
          <source>As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.</source>
          <target state="translated">Как человек,который занимается инжинирингом операционной производительности на очень крупных SOA веб-сервисах в течение примерно десяти лет,я бы предпочел поведение LinkedList,а не ArrayList.В то время как стационарная пропускная способность LinkedList хуже и поэтому может привести к покупке большего количества оборудования-поведение ArrayList под давлением может привести к тому,что приложения в кластере будут расширять свои массивы практически синхронно и для больших размеров массивов может привести к отсутствию отклика в приложении и перебоям в работе,в то время как под давлением,что является катастрофическим поведением.</target>
        </trans-unit>
        <trans-unit id="7cc15a8cb6e4f67393413b50f7e19ba95f084ea2" translate="yes" xml:space="preserve">
          <source>As with standard linked list and array operations, the various methods will have different algorithmic runtimes.</source>
          <target state="translated">Как и при работе со стандартными связанными списками и массивами,различные методы будут иметь разное алгоритмическое время выполнения.</target>
        </trans-unit>
        <trans-unit id="17f7102d3affee7b74333eccc3786b17d7b95f92" translate="yes" xml:space="preserve">
          <source>Based on these you have to decide what to choose. :)</source>
          <target state="translated">На основании этого вы должны решить,что выбрать.:)</target>
        </trans-unit>
        <trans-unit id="f4ba92067d77f8ad1cdde8d5185b8e7ead37b68b" translate="yes" xml:space="preserve">
          <source>Below is the unit test result for each operation.Timing is given in Nanoseconds.</source>
          <target state="translated">Ниже приведен результат модульного теста для каждой операции.Сроки указаны в наносекундах.</target>
        </trans-unit>
        <trans-unit id="7f46f0e6a343f897fd8216fe946eeff647289350" translate="yes" xml:space="preserve">
          <source>Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Let's say we want to go through the entire List removing and inserting elements on our way. Usually, you would start from the very beginning for each element using the LinkedList, we could also &quot;save&quot; the current element we're working on with an Iterator. With the help of the Iterator, we get an O(1) efficiency for remove() and insert() when working in a LinkedList. Making it the only performance benefit I'm aware of where a LinkedList is always better than an ArrayList.</source>
          <target state="translated">Бонус:Хотя нет способа сделать эти два метода O(1)для ArrayList'а,на самом деле есть способ сделать это в LinkedList'е.Допустим,мы хотим пройтись по всему списку,удаляя и вставляя элементы на нашем пути.Обычно,вы начинаете с самого начала для каждого элемента,используя LinkedList,мы также можем &quot;сохранить&quot; текущий элемент,над которым мы работаем с итератором.С помощью итератора мы получаем эффективность O(1)для delete()и insert()при работе в LinkedList'е.Делая это единственным преимуществом производительности,я знаю,где LinkedList всегда лучше,чем ArrayList.</target>
        </trans-unit>
        <trans-unit id="f37c5042d81ce8b4bbe2d96a4545bbab34eb146f" translate="yes" xml:space="preserve">
          <source>Both ArrayList and LinkedList are implementation of List interface.</source>
          <target state="translated">Как ArrayList,так и LinkedList являются реализацией интерфейса List.</target>
        </trans-unit>
        <trans-unit id="71f1ed7fc912117c5c42591efe3f6f8fa7782142" translate="yes" xml:space="preserve">
          <source>Both remove() and insert() have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However, the reason behind the linear processing time comes from two very different reasons:</source>
          <target state="translated">И функция remove(),и функция insert()имеют эффективность работы O(n)как для ArrayLists,так и для LinkedLists.Тем не менее,причина,лежащая в основе линейного времени обработки,связана с двумя совершенно разными причинами:</target>
        </trans-unit>
        <trans-unit id="daf0773dc6de1ad67b93748501d5e5e954fbb69d" translate="yes" xml:space="preserve">
          <source>Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.</source>
          <target state="translated">Оба этих класса несинхронизированы и могут быть сделаны синхронизированными явно с помощью метода Collections.synchronizedList.</target>
        </trans-unit>
        <trans-unit id="de704239e812c1c915cb01038eee251cbcaf16df" translate="yes" xml:space="preserve">
          <source>Conclusion: LinkedList element deletion is faster compared to
  ArrayList.</source>
          <target state="translated">Вывод:Удаление элементов LinkedList происходит быстрее по сравнению с ArrayList.</target>
        </trans-unit>
        <trans-unit id="f180d58cc543a593a06f0503cdd233ebc9c5759c" translate="yes" xml:space="preserve">
          <source>Copying a sequential bulk of memory is an operation optimized by the modern CPUs - changing theory and actually making, again, &lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;Vector&lt;/code&gt; much more efficient</source>
          <target state="translated">Копирование последовательного объема памяти - это операция, оптимизированная современными процессорами. Она меняет теорию и фактически делает &lt;code&gt;ArrayList&lt;/code&gt; / &lt;code&gt;Vector&lt;/code&gt; намного более эффективной.</target>
        </trans-unit>
        <trans-unit id="1f74715932ed85186b45cbf00a18b0aa012ba91d" translate="yes" xml:space="preserve">
          <source>Correct or Incorrect: Please execute test locally and decide for yourself!</source>
          <target state="translated">Правильно или неправильно:Пожалуйста,выполните тест на месте и решите сами!</target>
        </trans-unit>
        <trans-unit id="78ddc4712fca5a2025e62dc663ca11c5d278f6c7" translate="yes" xml:space="preserve">
          <source>Credits: All benchmarks posted here are created by &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt;. Even more data can be found on &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;his blog&lt;/a&gt;</source>
          <target state="translated">Кредиты: Все опубликованные тесты созданы &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt; . Еще больше данных можно найти в &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;его блоге&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="779504bb746658eb51a895ef325a2c35e22145fa" translate="yes" xml:space="preserve">
          <source>Does anyone actually use LinkedList?  I wrote it, and I never use it.</source>
          <target state="translated">Кто-нибудь на самом деле использует LinkedList? Я написал его,и никогда им не пользуюсь.</target>
        </trans-unit>
        <trans-unit id="c5b4ee91f9f7d7536fb951869ce3310ca5d5e5c8" translate="yes" xml:space="preserve">
          <source>Edit/Remove is faster in &lt;code&gt;LinkedList&lt;/code&gt; than &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">Редактировать / Удалить быстрее в &lt;code&gt;LinkedList&lt;/code&gt; , чем &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4bd4d47e6eb0dd8326522867ae2cebb9d911a9" translate="yes" xml:space="preserve">
          <source>Even when big-O performance is the same as &lt;code&gt;ArrayList&lt;/code&gt;, it is probably going to be significantly slower anyway.</source>
          <target state="translated">Даже если производительность big-O такая же, как у &lt;code&gt;ArrayList&lt;/code&gt; , она все равно будет значительно медленнее.</target>
        </trans-unit>
        <trans-unit id="a717e212f108315f6468fbbac65115039dbc3186" translate="yes" xml:space="preserve">
          <source>Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.</source>
          <target state="translated">Каждый раз,когда у меня есть метод,который возвращает список данных,полученных из БД,я всегда использую LinkedList.</target>
        </trans-unit>
        <trans-unit id="d98c1a4ef5e0db31dd47ee47986d318181c0c1aa" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85cdf2bee1991274487c8b867c3e971ab9c35e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e02d61f3770600b7462828f335d485c3c7c88fd7" translate="yes" xml:space="preserve">
          <source>From all the above differences between ArrayList vs LinkedList, It looks ArrayList is the better choice than LinkedList in almost all cases, except when you do a frequent add() operation than remove(), or get().</source>
          <target state="translated">Из всех вышеуказанных различий между ArrayList и LinkedList,похоже,что ArrayList является лучшим выбором,чем LinkedList почти во всех случаях,за исключением тех,когда вы делаете частую операцию add(),чем remove(),или get().</target>
        </trans-unit>
        <trans-unit id="ecc2eafc3ac7b3d6cdad7d496b20ef438cc7c71b" translate="yes" xml:space="preserve">
          <source>Getting good performance is tricky.</source>
          <target state="translated">Получить хорошую производительность-это сложно.</target>
        </trans-unit>
        <trans-unit id="d872e08fee24bf8c30e8defc229caebca0ba87ad" translate="yes" xml:space="preserve">
          <source>Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.</source>
          <target state="translated">Следовательно,если есть требование частого добавления и удаления в приложении,то LinkedList является лучшим выбором.</target>
        </trans-unit>
        <trans-unit id="05cae6319d9059efe74860e4a0c6f790d26f64fc" translate="yes" xml:space="preserve">
          <source>Here are results of a benchmark testing inserting elements in random locations. As you can see - the array list if much more efficient, although in theory each insert in the middle of the list will require &quot;move&quot; the &lt;em&gt;n&lt;/em&gt; later elements of the array (lower values are better):</source>
          <target state="translated">Вот результаты тестового тестирования вставки элементов в случайных местах. Как видите, список массивов гораздо эффективнее, хотя теоретически каждая вставка в середине списка потребует &amp;laquo;переместить&amp;raquo; более поздние элементы массива (чем меньше значение, тем лучше):</target>
        </trans-unit>
        <trans-unit id="4231cb0b09e1f7b1f49c5e13010868f22f729203" translate="yes" xml:space="preserve">
          <source>Here is a figure from &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; (&lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):</source>
          <target state="translated">Вот фигура из &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; ( &lt;code&gt;add&lt;/code&gt; и &lt;code&gt;remove&lt;/code&gt; - это первый тип, т. Е. Добавление элемента в конец списка и удаление элемента в указанной позиции в списке.):</target>
        </trans-unit>
        <trans-unit id="72459064f382e49943817106fc4f16a28f18d010" translate="yes" xml:space="preserve">
          <source>Here is the Big-O notation in both &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; and also &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt;:</source>
          <target state="translated">Вот обозначение Big-O в &lt;code&gt;ArrayList&lt;/code&gt; и &lt;code&gt;LinkedList&lt;/code&gt; , а также в &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">Вот код:</target>
        </trans-unit>
        <trans-unit id="204bd2319ad6f28782c2fd4eac0f1c63e947287c" translate="yes" xml:space="preserve">
          <source>I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:</source>
          <target state="translated">Я прочитал ответы,но есть один сценарий,когда я всегда использую LinkedList поверх ArrayList,которым хочу поделиться,чтобы услышать мнение:</target>
        </trans-unit>
        <trans-unit id="2909da23de10e510a463c3326c00b280592d1c12" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I honestly can't believe nobody mentioned that &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Deque&lt;/code&gt;.  Just look at the methods in &lt;code&gt;Deque&lt;/code&gt; (and &lt;code&gt;Queue&lt;/code&gt;); if you want a fair comparison, try running &lt;code&gt;LinkedList&lt;/code&gt; against &lt;code&gt;ArrayDeque&lt;/code&gt; and do a feature-for-feature comparison.</source>
          <target state="translated">Я знаю, что это старый пост, но я, честно говоря, не могу поверить, что никто не упомянул, что &lt;code&gt;LinkedList&lt;/code&gt; реализует &lt;code&gt;Deque&lt;/code&gt; . Просто посмотрите на методы в &lt;code&gt;Deque&lt;/code&gt; (и &lt;code&gt;Queue&lt;/code&gt; ); если вы хотите честное сравнение, попробуйте запустить &lt;code&gt;LinkedList&lt;/code&gt; для &lt;code&gt;ArrayDeque&lt;/code&gt; и выполнить сравнение по функциям.</target>
        </trans-unit>
        <trans-unit id="f0b70ff5fa7c09103b8eab96c986f91401d87676" translate="yes" xml:space="preserve">
          <source>I use the interface as the type name for &lt;em&gt;portability&lt;/em&gt;, so that when I ask questions such as these I can rework my code.</source>
          <target state="translated">Я использую интерфейс в качестве имени типа для &lt;em&gt;переносимости&lt;/em&gt; , поэтому, когда я задаю такие вопросы, я могу переделать свой код.</target>
        </trans-unit>
        <trans-unit id="c1dae44cf928d176bc4a73ed2740108af2b90993" translate="yes" xml:space="preserve">
          <source>I usually use one over the other based on the time complexities of the operations that I'd perform on that particular List.</source>
          <target state="translated">Обычно я использую одну над другой,основываясь на временных сложностях операций,которые я бы выполнял в этом конкретном Списке.</target>
        </trans-unit>
        <trans-unit id="6102d6038b559d5fad73832038782bbb5796e2a3" translate="yes" xml:space="preserve">
          <source>I'm sorry for the answer for being not that informative as the other answers, but I thought it would be the most interesting and self-explanatory.</source>
          <target state="translated">Извините,что ответ не такой информативный,как другие ответы,но я подумал,что он будет наиболее интересным и понятным.</target>
        </trans-unit>
        <trans-unit id="a4a379c9c8db61dd6b7c09706346097b32a64868" translate="yes" xml:space="preserve">
          <source>I've always been one to simply use:</source>
          <target state="translated">Я всегда был одним из тех,кого можно просто использовать:</target>
        </trans-unit>
        <trans-unit id="eb6b619bb59e99c5145eebdb33b065006bef1e99" translate="yes" xml:space="preserve">
          <source>If Array is large enough it may take a lot of memory at that point and trigger Garbage collection, which can slow response time.</source>
          <target state="translated">Если массив достаточно большой,то в этот момент может потребоваться много памяти и запустить сбор мусора,что может замедлить время отклика.</target>
        </trans-unit>
        <trans-unit id="559de205fa8eb76d7699b1783f2b0ac89bcc4d52" translate="yes" xml:space="preserve">
          <source>If the constructor  is not overloaded, then &lt;em&gt;ArrayList&lt;/em&gt; creates an empty list of initial capacity 10, while</source>
          <target state="translated">Если конструктор не перегружен, &lt;em&gt;ArrayList&lt;/em&gt; создает пустой список начальной емкости 10, а</target>
        </trans-unit>
        <trans-unit id="c0e9fb39f596736adacc32d734e4edfa0a46ec4b" translate="yes" xml:space="preserve">
          <source>If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList.</source>
          <target state="translated">Если в вашем приложении часто выполняются операции по извлечению информации,используйте ArrayList.Если вы часто вставляете и удаляете приложения,используйте LinkedList.</target>
        </trans-unit>
        <trans-unit id="aaba92fb463b8690a69e81dfffc7a5658f1bd75e" translate="yes" xml:space="preserve">
          <source>If your code has &lt;code&gt;add(0)&lt;/code&gt; and &lt;code&gt;remove(0)&lt;/code&gt;, use a &lt;code&gt;LinkedList&lt;/code&gt; and it's prettier &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;removeFirst()&lt;/code&gt; methods. Otherwise, use &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">Если в вашем коде есть &lt;code&gt;add(0)&lt;/code&gt; и &lt;code&gt;remove(0)&lt;/code&gt; , используйте &lt;code&gt;LinkedList&lt;/code&gt; , а его &lt;code&gt;addFirst()&lt;/code&gt; и &lt;code&gt;removeFirst()&lt;/code&gt; красивее. В противном случае используйте &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ab91dd60a4bdc4332a1f000c5a31d8298e3443" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;ArrayList&lt;/em&gt;  each index only holds the actual object(data).</source>
          <target state="translated">В &lt;em&gt;ArrayList&lt;/em&gt; каждый индекс содержит только фактический объект (данные).</target>
        </trans-unit>
        <trans-unit id="4e651e52f60a7d33d19241c9b84a7e5ebf5e0d7c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;LinkedList&lt;/em&gt;, there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1). The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as a parameter. This method traverses the LinkedList until it found the Object and unlink it from the original list. Hence this method runtime is O(n).</source>
          <target state="translated">В &lt;em&gt;LinkedList&lt;/em&gt; есть два перегруженных метода удаления. один - это remove () без какого-либо параметра, который удаляет заголовок списка и работает в постоянном времени O (1). Другой перегруженный метод удаления в LinkedList - это метод remove (int) или remove (Object), который удаляет Object или int, переданные в качестве параметра. Этот метод пересекает LinkedList до тех пор, пока не найдет объект и не отсоединит его от исходного списка. Следовательно, время выполнения этого метода O (n).</target>
        </trans-unit>
        <trans-unit id="4035507a1bd4880689b50032e852bc42590238de" translate="yes" xml:space="preserve">
          <source>In a LinkedList, it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for remove() and 2 references for insert().</source>
          <target state="translated">В LinkedList'е требуется O(n),чтобы действительно добраться до желаемого элемента,потому что мы должны начать с самого начала,пока не достигнем желаемого индекса.На самом деле удаление или вставка является постоянной,потому что мы должны изменить только 1 ссылку для функции remove()и 2 ссылки для функции insert().</target>
        </trans-unit>
        <trans-unit id="6d3d827792739e9f193e4b6dedde2b63bd92348f" translate="yes" xml:space="preserve">
          <source>In addition to the other good arguments above, you should notice &lt;code&gt;ArrayList&lt;/code&gt; implements &lt;code&gt;RandomAccess&lt;/code&gt; interface, while &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Queue&lt;/code&gt;.</source>
          <target state="translated">В дополнение к другим хорошим аргументам выше, вы должны заметить, что &lt;code&gt;ArrayList&lt;/code&gt; реализует интерфейс &lt;code&gt;RandomAccess&lt;/code&gt; , в то время как &lt;code&gt;LinkedList&lt;/code&gt; реализует &lt;code&gt;Queue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35842b5d82e361cdd7f51df865bca0c300db2026" translate="yes" xml:space="preserve">
          <source>In an ArrayList, you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.</source>
          <target state="translated">В массиве ArrayList вы попадаете на элемент в O(1),но на самом деле удаление или вставка чего-то делает его O(n),потому что все следующие элементы должны быть изменены.</target>
        </trans-unit>
        <trans-unit id="e8946d8d5170bc375bf87f8b5c440661d618b2c2" translate="yes" xml:space="preserve">
          <source>In arraylist</source>
          <target state="translated">В арайлисте</target>
        </trans-unit>
        <trans-unit id="4a8bb3c134e78f4fa8de3dd3133fe5675a10a71e" translate="yes" xml:space="preserve">
          <source>In my opinion, use ArrayList over LinkedList for most of the practical purpose in Java.</source>
          <target state="translated">На мой взгляд,использовать ArrayList поверх LinkedList для большинства практических целей на Java.</target>
        </trans-unit>
        <trans-unit id="60daaf72544dd78c2fbc88ad20ed774a9a6e7cea" translate="yes" xml:space="preserve">
          <source>In order to remove an element from a particular index e.g. by calling remove(index), ArrayList performs a copy operation which makes it close to O(n) while LinkedList needs to traverse to that point which also makes it O(n/2), as it can traverse from either direction based upon proximity.</source>
          <target state="translated">Чтобы удалить элемент из определенного индекса,например,вызовом delete(index),ArrayList выполняет операцию копирования,которая делает его близким к O(n),в то время как LinkedList должен перемещаться в ту точку,которая также делает его O(n2),так как он может перемещаться в любом направлении в зависимости от близости.</target>
        </trans-unit>
        <trans-unit id="13af662866647dd21beac5b84de614ccdd269669" translate="yes" xml:space="preserve">
          <source>In other words, you don't need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes O(n) operation. For example, inserting or deleting an element in the middle of a linked list.</source>
          <target state="translated">Другими словами,вам не нужно перемещаться по связанному списку,чтобы достичь позиции,в которую вы хотите добавить элементы,в этом случае добавление становится операцией O(n).Например,вставка или удаление элемента в середине связанного списка.</target>
        </trans-unit>
        <trans-unit id="469c98ead6182a42fb433736049690f3bc9751a6" translate="yes" xml:space="preserve">
          <source>In theory, LinkedList has an O(1) for the &lt;code&gt;add(E element)&lt;/code&gt;</source>
          <target state="translated">Теоретически, LinkedList имеет O (1) для &lt;code&gt;add(E element)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c381b0a433efc57cbfa3356f3a84f33fb983fb0" translate="yes" xml:space="preserve">
          <source>Insertions in &lt;em&gt;LinkedList&lt;/em&gt; are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation .</source>
          <target state="translated">Вставки в &lt;em&gt;LinkedList&lt;/em&gt; обычно бывают быстрыми по сравнению с ArrayList. В LinkedList добавление или вставка является операцией O (1).</target>
        </trans-unit>
        <trans-unit id="c767ed4fab63fed391201351f4e44d98a283934b" translate="yes" xml:space="preserve">
          <source>It can be said that it was basically created to overcome the drawbacks of arrays</source>
          <target state="translated">Можно сказать,что он был создан,в основном,для преодоления недостатков массивов.</target>
        </trans-unit>
        <trans-unit id="67433abb43ee77013dd1057bd5c859af9a33433f" translate="yes" xml:space="preserve">
          <source>It depends upon what operations you will be doing more on the List.</source>
          <target state="translated">Это зависит от того,какие операции вы будете делать больше в Списке.</target>
        </trans-unit>
        <trans-unit id="23b28df1a3e51ae95f5d0a5b0aa39bb036813e19" translate="yes" xml:space="preserve">
          <source>It uses lots of small memory objects, and therefore impacts performance across the process.</source>
          <target state="translated">Он использует много маленьких объектов памяти,и,следовательно,влияет на производительность в течение всего процесса.</target>
        </trans-unit>
        <trans-unit id="8809d3c8954d5fee422f743b686ee6e92e9dc70a" translate="yes" xml:space="preserve">
          <source>It's an efficiency question. &lt;code&gt;LinkedList&lt;/code&gt; is fast for adding and deleting elements, but slow to access a specific element. &lt;code&gt;ArrayList&lt;/code&gt; is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.</source>
          <target state="translated">Это вопрос эффективности. &lt;code&gt;LinkedList&lt;/code&gt; быстр для добавления и удаления элементов, но медленный доступ к определенному элементу. &lt;code&gt;ArrayList&lt;/code&gt; быстр для доступа к определенному элементу, но может быть медленным, чтобы добавить к любому концу, и особенно медленным, чтобы удалить в середине.</target>
        </trans-unit>
        <trans-unit id="4b15e68efa8079d20e58d4612e98609845672742" translate="yes" xml:space="preserve">
          <source>It's easier to modify a linked list than ArrayList, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in O(1) time.</source>
          <target state="translated">Легче модифицировать связанный список,чем ArrayList,особенно если вы добавляете или удаляете элементы из начала или конца,потому что связанный список внутренне хранит ссылки на эти позиции,и они доступны во время O(1).</target>
        </trans-unit>
        <trans-unit id="adc8d1e49ddd7e5e06471d7adc23a73d72dc8d87" translate="yes" xml:space="preserve">
          <source>It's jarring to see &lt;code&gt;LinkedList&lt;/code&gt; in source because it is probably the wrong choice.</source>
          <target state="translated">Очень неприятно видеть &lt;code&gt;LinkedList&lt;/code&gt; в источнике, потому что это, вероятно, неправильный выбор.</target>
        </trans-unit>
        <trans-unit id="6e438c304d6715de1cd8a3be3097d2b636828262" translate="yes" xml:space="preserve">
          <source>Iteration is the O(n) operation for both LinkedList and ArrayList where n is a number of an element.</source>
          <target state="translated">Итерация-это операция O(n)как для LinkedList'а,так и для ArrayList'а,где n-это число элемента.</target>
        </trans-unit>
        <trans-unit id="196cfc0783541b18906b878964f90c2beb521995" translate="yes" xml:space="preserve">
          <source>Joshua Bloch, the author of LinkedList:</source>
          <target state="translated">Джошуа Блок,автор LinkedList:</target>
        </trans-unit>
        <trans-unit id="b6bf53be71cb03cefc9204127bcad931b18969a2" translate="yes" xml:space="preserve">
          <source>Just to make the point even clearer, please check the benchmark of adding elements to the beginning of the list. This is a use-case where, in-theory, the &lt;code&gt;LinkedList&lt;/code&gt; should really shine, and &lt;code&gt;ArrayList&lt;/code&gt; should present poor or even worse-case results:</source>
          <target state="translated">Просто чтобы сделать это еще более понятным, пожалуйста, проверьте эталон добавления элементов в начало списка. Это вариант использования, в котором, по идее, &lt;code&gt;LinkedList&lt;/code&gt; должен действительно сиять, а &lt;code&gt;ArrayList&lt;/code&gt; должен представлять плохие или даже худшие результаты:</target>
        </trans-unit>
        <trans-unit id="1f2e1c89c968aef7dc16623190b3a9a9cabbc8b4" translate="yes" xml:space="preserve">
          <source>Let's compare LinkedList and ArrayList w.r.t. below parameters:</source>
          <target state="translated">Сравним LinkedList и ArrayList w.r.t.,приведенные ниже параметры:</target>
        </trans-unit>
        <trans-unit id="93306f9c4f0e542bbb9a628ab7325be853345914" translate="yes" xml:space="preserve">
          <source>Link: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</source>
          <target state="translated">Ссылка: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a422cc360ccdd0ef7b3dda2d174720a459804d83" translate="yes" xml:space="preserve">
          <source>LinkedList is &lt;em&gt;almost always&lt;/em&gt; the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList's ability to insert and delete elements in the middle of the list relatively quickly, once you've navigated there with a ListIterator.</source>
          <target state="translated">LinkedList - &lt;em&gt;почти всегда&lt;/em&gt; неправильный выбор с точки зрения производительности. Существует несколько очень специфических алгоритмов, для которых требуется LinkedList, но они очень, очень редки, и алгоритм обычно будет конкретно зависеть от способности LinkedList относительно быстро вставлять и удалять элементы в середине списка, как только вы перейдете туда с ListIterator.</target>
        </trans-unit>
        <trans-unit id="10b1b645b01085ffebf0f6f3f088eea7172b5aa1" translate="yes" xml:space="preserve">
          <source>LinkedList takes much more time to accomplish the same job. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">LinkedList занимает гораздо больше времени, чтобы выполнить ту же работу. &lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;Исходный код&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f79cef427b354d9b9780eab17c5d356d4a5b006e" translate="yes" xml:space="preserve">
          <source>LinkedList uses a wrapper object, Entry, which is a static nested class for storing data and two nodes next and previous while ArrayList just stores data in Array.</source>
          <target state="translated">LinkedList использует объект-обертку Entry,которая представляет собой статический вложенный класс для хранения данных и два следующих и предыдущих узла,в то время как ArrayList просто хранит данные в массиве.</target>
        </trans-unit>
        <trans-unit id="7e1c7bcef7896ae52260cfcb6d33ba65b28b0065" translate="yes" xml:space="preserve">
          <source>Lots of small objects are bad for cache-locality.</source>
          <target state="translated">Множество мелких объектов вредно для кэш-локальности.</target>
        </trans-unit>
        <trans-unit id="d1ac372c327cce8ede5e07a803bfe591166259d1" translate="yes" xml:space="preserve">
          <source>Memory overhead in &lt;em&gt;LinkedList&lt;/em&gt; is more as compared to ArrayList as a node in LinkedList needs to maintain the addresses of the next and previous node. While</source>
          <target state="translated">&lt;em&gt;Перерасход&lt;/em&gt; памяти в &lt;em&gt;LinkedList&lt;/em&gt; больше по сравнению с ArrayList, так как узел в LinkedList должен поддерживать адреса следующего и предыдущего узла. Пока</target>
        </trans-unit>
        <trans-unit id="e5657da09258adb4a01a06b7e549b6f276681445" translate="yes" xml:space="preserve">
          <source>My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.</source>
          <target state="translated">Моим обоснованием было то,что из-за невозможности точно знать,сколько результатов я получаю,не будет потеряна память (как в ArrayList с разницей между емкостью и фактическим количеством элементов),и не будет потрачено время на дублирование емкости.</target>
        </trans-unit>
        <trans-unit id="d7c000eee7e0c05260bee34ed1a23873f4661337" translate="yes" xml:space="preserve">
          <source>Note: this is a benchmark of the C++ Std lib, but my previous experience shown the C++ and Java results are very similar. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">Примечание: это тест C ++ Std lib, но мой предыдущий опыт показал, что результаты C ++ и Java очень похожи. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;Исходный код&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="43117d0643c36e2f29277032a262d30828a4ea76" translate="yes" xml:space="preserve">
          <source>O(n) worst, O(1) amortized</source>
          <target state="translated">O(n)худшее,O(1)амортизировано</target>
        </trans-unit>
        <trans-unit id="2613d66d9e3e9d1d2cb152a0c8c768f97ed252f6" translate="yes" xml:space="preserve">
          <source>On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.</source>
          <target state="translated">С другой стороны,вставка и удаление в LinkedList'е намного проще,потому что нужно просто изменить указатели,в то время как ArrayList'е подразумевает использование операции сдвига для любой вставки или удаления.</target>
        </trans-unit>
        <trans-unit id="33a2811cec1cd04c38e25706ff20270bb3aa420c" translate="yes" xml:space="preserve">
          <source>One of the tests I saw on here only conducts the test once.  But what I have noticed is that you need to run these tests many times and eventually their times will converge.  Basically the JVM needs to warm up.  For my particular use case I needed to add/remove items to a list that grows to about 500 items.  In my tests &lt;code&gt;LinkedList&lt;/code&gt; came out faster, with &lt;code&gt;LinkedList&lt;/code&gt; coming in around 50,000 NS and &lt;code&gt;ArrayList&lt;/code&gt; coming in at around 90,000 NS... give or take.  See the code below.</source>
          <target state="translated">Один из тестов, которые я видел здесь, проводит тест только один раз. Но что я заметил, так это то, что вам нужно запускать эти тесты много раз, и в итоге их время будет сходиться. По сути, JVM необходимо разогреть. Для моего конкретного случая использования мне нужно было добавить / удалить элементы в список, который увеличивается примерно до 500 элементов. В моих тестах &lt;code&gt;LinkedList&lt;/code&gt; вышел быстрее, с &lt;code&gt;LinkedList&lt;/code&gt; около 50 000 NS и &lt;code&gt;ArrayList&lt;/code&gt; около 90 000 NS ... дай или возьми. Смотрите код ниже.</target>
        </trans-unit>
        <trans-unit id="65dac500e2d3e9f09ada76f29721043fd8c863b6" translate="yes" xml:space="preserve">
          <source>Operation get(i) in ArrayList is faster than LinkedList, because:</source>
          <target state="translated">Операция get(i)в ArrayList быстрее,чем LinkedList,потому что:</target>
        </trans-unit>
        <trans-unit id="0a5c295d42604c7d58d32363d3f4396711e52d07" translate="yes" xml:space="preserve">
          <source>Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</source>
          <target state="translated">Операции,которые индексируют в список,будут проходить по списку от начала или конца,в зависимости от того,что ближе к указанному индексу.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b3bfed3bf17cc4ccb5b52051ae69c0e7857b3e8" translate="yes" xml:space="preserve">
          <source>Practice is very different, as LinkedList is a &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data structure. From performance POV - there are very little cases where &lt;code&gt;LinkedList&lt;/code&gt; could be better performing than the &lt;em&gt;Cache-friendly&lt;/em&gt;&lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">Практика совсем иная, так как LinkedList - это структура данных &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data. От производительности POV - очень мало случаев, когда &lt;code&gt;LinkedList&lt;/code&gt; мог бы работать лучше, чем &lt;em&gt;дружественный к&lt;/em&gt; &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cca9612e17514e1ec64192796cfa4e74465f72b1" translate="yes" xml:space="preserve">
          <source>Reason: LinkedList&amp;rsquo;s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.</source>
          <target state="translated">Причина: каждый элемент LinkedList поддерживает два указателя (адреса), которые указывают на оба соседних элемента в списке. Следовательно, удаление требует только изменения местоположения указателя в двух соседних узлах (элементах) узла, который будет удален. В то время как в ArrayList все элементы должны быть сдвинуты, чтобы заполнить пространство, созданное удаленным элементом.</target>
        </trans-unit>
        <trans-unit id="f68c820e0a45856c839ded9a5dcddfe8ab72ecae" translate="yes" xml:space="preserve">
          <source>Remove operation in LinkedList is generally the same as ArrayList i.e. O(n).</source>
          <target state="translated">Удаление операции в LinkedList'е,как правило,такое же,как и в ArrayList'е,т.е.O(n).</target>
        </trans-unit>
        <trans-unit id="73ae9a70388443373dde5d5fe2540131469bd3ca" translate="yes" xml:space="preserve">
          <source>Search (&lt;code&gt;get method&lt;/code&gt;) operations are fast in &lt;code&gt;Arraylist (O(1))&lt;/code&gt; but not in &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</source>
          <target state="translated">Операции поиска ( &lt;code&gt;get method&lt;/code&gt; ) выполняются быстро в &lt;code&gt;Arraylist (O(1))&lt;/code&gt; но не в &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="beb9ed0bbc3bb6fd7e6c2e425c684fb4a813730a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;the Java Tutorials - List Implementations&lt;/a&gt;.</source>
          <target state="translated">Посмотрите &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;Учебные руководства Java - Список Реализаций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f41eea01e67c4b4218cd4f1b61ae00436827205" translate="yes" xml:space="preserve">
          <source>Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.</source>
          <target state="translated">Аналогичным образом,вы можете получить лучшую пропускную способность в приложении из стандартной пропускной способности сборщика мусора,но как только вы получите java-приложения с 10 ГБ кучи,вы можете закончить блокировку приложения на 25 секунд во время Full GCs,что приводит к таймаутам и сбоям в SOA-приложениях и выдувает ваши SLA,если это происходит слишком часто.Несмотря на то,что сборщик CMS занимает больше ресурсов и не достигает той же пропускной способности,это гораздо лучший выбор,потому что он имеет более предсказуемые и меньшие задержки.</target>
        </trans-unit>
        <trans-unit id="c7f07cd9a6f95a46d6ba5320ac3e54b3e0920e1e" translate="yes" xml:space="preserve">
          <source>Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit &lt;code&gt;LinkedLists&lt;/code&gt; and &lt;code&gt;ArrayLists&lt;/code&gt;.</source>
          <target state="translated">Поскольку в их относительных системах ссылки бывают 32- или 64-битными (даже если они равны нулю), я включил 4 набора данных для 32- и 64-битных &lt;code&gt;LinkedLists&lt;/code&gt; и &lt;code&gt;ArrayLists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69eebcd50b0954ecfc33ccabe9d8b7d4f9117ee9" translate="yes" xml:space="preserve">
          <source>So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an &lt;code&gt;ArrayList&lt;/code&gt; is technically faster, but unless you're doing something really performance-sensitive, you shouldn't worry about this -- they're both constants.)</source>
          <target state="translated">Таким образом, в зависимости от операций, которые вы намереваетесь выполнить, вы должны выбрать соответствующие реализации. Перебор любого из списков практически одинаково дешев. (Итерация по &lt;code&gt;ArrayList&lt;/code&gt; технически быстрее, но если вы не делаете что-то действительно чувствительное к производительности, вам не стоит об этом беспокоиться - они обе константы.)</target>
        </trans-unit>
        <trans-unit id="9d8873955ed68a6d3afa3fc542ef7842e5776761" translate="yes" xml:space="preserve">
          <source>So memory requirement seems less in the case of ArrayList than LinkedList except for the case where Array performs the re-size operation when it copies content from one Array to another.</source>
          <target state="translated">Поэтому в случае ArrayList'а потребность в памяти кажется меньше,чем в случае LinkedList'а,за исключением случая,когда Array выполняет операцию изменения размера при копировании содержимого из одного массива в другой.</target>
        </trans-unit>
        <trans-unit id="d29bcb90791eb28700c5ec8a4791f07074a61ec0" translate="yes" xml:space="preserve">
          <source>So, somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).</source>
          <target state="translated">Таким образом,они каким-то образом решают несколько иные проблемы,с разницей в эффективности и поведении (см.их список методов).</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="2723794bb959da323543cd3bc1ef514d3209ea99" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;</source>
          <target state="translated">Источник: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;числа задержек, которые должен знать каждый программист&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12d5ff1ccac20df183eacef481ad79a3b1d74a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; is pretty clear. O(1) for &lt;code&gt;ArrayList&lt;/code&gt;, because &lt;code&gt;ArrayList&lt;/code&gt; allow random access by using index. O(n) for &lt;code&gt;LinkedList&lt;/code&gt;, because it needs to find the index first. Note: there are different versions of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; довольно ясно. O (1) для &lt;code&gt;ArrayList&lt;/code&gt; , потому что &lt;code&gt;ArrayList&lt;/code&gt; разрешает произвольный доступ с использованием индекса. O (n) для &lt;code&gt;LinkedList&lt;/code&gt; , потому что он должен сначала найти индекс. Примечание. Существуют разные версии &lt;code&gt;add&lt;/code&gt; и &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f4576a7bc64b7bfc1b683a9a061390ec3813c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; returned by these classes are &lt;code&gt;fail-fast&lt;/code&gt; (if list is structurally modified at any time after the iterator is created, in any way except through the &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; own remove or add methods, the iterator will &lt;code&gt;throw&lt;/code&gt; a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; и &lt;code&gt;listIterator&lt;/code&gt; , возвращаемые этими классами, &lt;code&gt;fail-fast&lt;/code&gt; подвержены сбоям (если список структурно изменяется в любое время после создания итератора, любым способом, кроме использования собственных методов удаления или добавления итератора, итератор создает исключение &lt;code&gt;ConcurrentModificationException&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e215678d488569b16687c62fc0c1cecd7a06b204" translate="yes" xml:space="preserve">
          <source>The LinkedList class extends AbstractSequentialList and implements List,Deque, and Queue interface.</source>
          <target state="translated">Класс LinkedList расширяет AbstractSequentialList и реализует интерфейс List,Deque и Queue.</target>
        </trans-unit>
        <trans-unit id="a584c17550a71fdd1f4452edc00d3a4572783158" translate="yes" xml:space="preserve">
          <source>The default initial capacity of an &lt;code&gt;ArrayList&lt;/code&gt; is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you're going to add a lot of elements, construct the &lt;code&gt;ArrayList&lt;/code&gt; with a higher initial capacity.</source>
          <target state="translated">Начальная емкость &lt;code&gt;ArrayList&lt;/code&gt; по умолчанию довольно мала (10 из Java 1.4 - 1.8). Но поскольку базовая реализация представляет собой массив, размер массива должен быть изменен, если вы добавите много элементов. Чтобы избежать высокой стоимости изменения размера, когда вы знаете, что собираетесь добавить много элементов, &lt;code&gt;ArrayList&lt;/code&gt; с более высокой начальной емкостью.</target>
        </trans-unit>
        <trans-unit id="6a73759baa6b5937448572841c9e25224f4a4466" translate="yes" xml:space="preserve">
          <source>The first difference between ArrayList and LinkedList comes with the fact that ArrayList is backed by Array while LinkedList is backed by LinkedList. This will lead to further differences in performance.</source>
          <target state="translated">Первая разница между ArrayList и LinkedList заключается в том,что ArrayList поддерживается массивом,в то время как LinkedList поддерживается LinkedList.Это приведет к дальнейшим различиям в производительности.</target>
        </trans-unit>
        <trans-unit id="405c38f8ac19fd59375c5014403c7ab61e163b10" translate="yes" xml:space="preserve">
          <source>The formulas I used follow, let me know if I have done anything wrong and I will fix it up. 'b' is either 4 or 8 for 32 or 64 bit systems, and 'n' is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.</source>
          <target state="translated">Формулы,которые я использовал,следуют,дайте мне знать,если я сделал что-то не так,и я все исправлю.'b'-это 4 или 8 для 32-х или 64-х битных систем,а 'n'-это количество элементов.Обратите внимание,что причина модов в том,что все объекты в java займут кратное 8 байт пространство,независимо от того,все ли они используются или нет.</target>
        </trans-unit>
        <trans-unit id="c67ed32e3dd5ebe3398abf72bee54241312ba5f5" translate="yes" xml:space="preserve">
          <source>The get(index) operation is O(1) in ArrayList while its O(n/2) in LinkedList, as it needs to traverse till that entry. Though, in Big O notation O(n/2) is just O(n) because we ignore constants there.</source>
          <target state="translated">Операция get(index)-это O(1)в массиве ArrayList,в то время как его O(n2)в LinkedList,так как ему нужно пройти до этой записи.Хотя,в нотации Big O O O(n2)-это просто O(n),потому что там мы игнорируем константы.</target>
        </trans-unit>
        <trans-unit id="ebbe3e7e54ca846d40859c9cd5c54f9e245ba147" translate="yes" xml:space="preserve">
          <source>The main benefits of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you re-use existing iterators to insert and remove elements. These operations can then be done in &lt;em&gt;O(1)&lt;/em&gt; by changing the list locally only. In an array list, the remainder of the array needs to be &lt;em&gt;moved&lt;/em&gt; (i.e. copied). On the other side, seeking in a &lt;code&gt;LinkedList&lt;/code&gt; means following the links in &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/2&lt;/em&gt; steps) for worst case, whereas in an &lt;code&gt;ArrayList&lt;/code&gt; the desired position can be computed mathematically and accessed in &lt;em&gt;O(1)&lt;/em&gt;.</source>
          <target state="translated">Основные преимущества использования &lt;code&gt;LinkedList&lt;/code&gt; возникают при повторном использовании существующих итераторов для вставки и удаления элементов. Эти операции затем можно выполнить в &lt;em&gt;O (1)&lt;/em&gt; , изменив список только локально. В списке массивов остаток массива необходимо &lt;em&gt;переместить&lt;/em&gt; (т.е. скопировать). С другой стороны, поиск в &lt;code&gt;LinkedList&lt;/code&gt; означает переход по ссылкам в &lt;em&gt;O (n)&lt;/em&gt; ( &lt;em&gt;n / 2&lt;/em&gt; шага) для наихудшего случая, тогда как в &lt;code&gt;ArrayList&lt;/code&gt; желаемая позиция может быть вычислена математически и доступна в &lt;em&gt;O (1)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b74b1e781ca90526e83c42ffc3d14526c49736ab" translate="yes" xml:space="preserve">
          <source>The reason behind &lt;em&gt;ArrayList&lt;/em&gt; being faster than LinkedList is that ArrayList uses an index based system for its elements as it internally uses an array data structure, on the other hand,</source>
          <target state="translated">Причина, по которой &lt;em&gt;ArrayList&lt;/em&gt; быстрее, чем LinkedList, заключается в том, что ArrayList использует систему на основе индекса для своих элементов, поскольку он внутренне использует структуру данных массива, с другой стороны,</target>
        </trans-unit>
        <trans-unit id="2f3082915f897c89bedc037a984915a010f1935c" translate="yes" xml:space="preserve">
          <source>The result clearly shows that &lt;code&gt;LinkedList&lt;/code&gt; is a whole lot more than &lt;code&gt;ArrayList&lt;/code&gt;, especially with a very high element count. If memory is a factor, steer clear of &lt;code&gt;LinkedLists&lt;/code&gt;.</source>
          <target state="translated">Результат ясно показывает, что &lt;code&gt;LinkedList&lt;/code&gt; намного больше, чем &lt;code&gt;ArrayList&lt;/code&gt; , особенно с очень большим количеством элементов. Если память является фактором, держитесь подальше от &lt;code&gt;LinkedLists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55e26f9f49b3d7c9c3c97a405002150b730e9d84" translate="yes" xml:space="preserve">
          <source>There are few similarities between these classes which are as follows:</source>
          <target state="translated">Сходства между этими классами немногочисленны:</target>
        </trans-unit>
        <trans-unit id="979f5bb981358561639406265c29e3fa18c87f2d" translate="yes" xml:space="preserve">
          <source>There are two main reasons for this:</source>
          <target state="translated">Есть две основные причины для этого:</target>
        </trans-unit>
        <trans-unit id="51e22a50ad3da080a9975903475702d34ba04615" translate="yes" xml:space="preserve">
          <source>There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList implementation&lt;/a&gt;.  (Yes, it's from 2001, so you'll need to generify it, but I got comparable performance ratios to what's quoted in the article just now in a recent JVM)</source>
          <target state="translated">Существует один общий случай использования, в котором LinkedList превосходит ArrayList: это очереди. Однако, если ваша цель - производительность, вместо LinkedList вы также должны рассмотреть возможность использования ArrayBlockingQueue (если вы можете заранее определить верхнюю границу размера очереди и можете позволить себе выделять всю память заранее) или эту &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;реализацию CircularArrayList&lt;/a&gt; , (Да, это с 2001 года, поэтому вам нужно будет его обобщить, но я получил сопоставимые коэффициенты производительности с тем, что только что цитировалось в статье в недавней JVM)</target>
        </trans-unit>
        <trans-unit id="bb24115d041e92964431dc2a9a4c804a8c2714b7" translate="yes" xml:space="preserve">
          <source>They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.</source>
          <target state="translated">Оба они поддерживают порядок вставки элементов,что означает,что при отображении элементов ArrayList и LinkedList набор результатов будет иметь тот же порядок,в котором элементы были вставлены в Список.</target>
        </trans-unit>
        <trans-unit id="a7393aee9cdbf2240709c5e92b61bea76f07fd0d" translate="yes" xml:space="preserve">
          <source>Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a &lt;code&gt;LinkedList&lt;/code&gt; is &quot;lots more&quot; than an &lt;code&gt;ArrayList&lt;/code&gt; so I did some number crunching to demonstrate exactly how much both lists take up for N null references.</source>
          <target state="translated">До сих пор, похоже, никто не обращал внимания на объем памяти каждого из этих списков, кроме общего мнения, что &lt;code&gt;LinkedList&lt;/code&gt; &amp;laquo;намного больше&amp;raquo;, чем &lt;code&gt;ArrayList&lt;/code&gt; , поэтому я немного разбирал числа, чтобы продемонстрировать, насколько точно оба списка занимают N пустых ссылок ,</target>
        </trans-unit>
        <trans-unit id="5f0ebd31014e6d03e89c2e7c5de3ae7e005b1340" translate="yes" xml:space="preserve">
          <source>To find out more, read any article that talks about the difference between arrays and linked lists.</source>
          <target state="translated">Чтобы узнать больше,прочитайте любую статью,в которой говорится о различии между массивами и связанными списками.</target>
        </trans-unit>
        <trans-unit id="29ca1dbcdfa1f09ca0ddfee47c7f010975f7b16f" translate="yes" xml:space="preserve">
          <source>Unless you've created large lists and measured a bottleneck, you'll probably never need to worry about the difference.</source>
          <target state="translated">Если вы не создали большие списки и не измерили узкое место,вам,вероятно,никогда не придется беспокоиться о разнице.</target>
        </trans-unit>
        <trans-unit id="445928a04da6390fbfe641573eb932e5cdb28769" translate="yes" xml:space="preserve">
          <source>When should &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; be used over &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and vice-versa?</source>
          <target state="translated">Когда &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; должен использоваться поверх &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; и наоборот?</target>
        </trans-unit>
        <trans-unit id="78753f704c5e896d437844d3fb47088744b55cf9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList and when to use ArrayList?</source>
          <target state="translated">Когда использовать LinkedList и когда использовать ArrayList?</target>
        </trans-unit>
        <trans-unit id="38de968ae17bb38f4696d5acc9b08397e7f206f9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList over ArrayList in Java</source>
          <target state="translated">Когда использовать LinkedList поверх ArrayList в Java</target>
        </trans-unit>
        <trans-unit id="8e108c13808368fe0f3f3e721de63a230cc41edf" translate="yes" xml:space="preserve">
          <source>Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.</source>
          <target state="translated">Какой из них быстрее вставлять и удалять,зависит от того,где это происходит.Если мы будем ближе к началу,то LinkedList будет быстрее,потому что мы должны пройти через относительно небольшое количество элементов.Если мы находимся ближе к концу,ArrayList будет быстрее,потому что мы попадаем туда в постоянном времени и нам приходится менять только те немногие оставшиеся элементы,которые следуют за ним.Когда мы делаем это точно посередине,LinkedList будет быстрее,потому что прохождение через n элементов быстрее,чем перемещение n значений.</target>
        </trans-unit>
        <trans-unit id="aa1559133ba9f967b51fb87c9d69f02e2d34fd11" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt; remove(int) method involves copying elements from the old array to new updated array, hence its runtime is O(n).</source>
          <target state="translated">В то время как в методе &lt;em&gt;ArrayList&lt;/em&gt; метод remove (int) включает копирование элементов из старого массива в новый обновленный массив, следовательно, его время выполнения равно O (n).</target>
        </trans-unit>
        <trans-unit id="22fb9822109a567e96dc1961a1c75216ea996026" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt;, if the array is the full i.e worst case,  there is an extra cost of resizing array and copying elements to the new array, which makes runtime of add operation in ArrayList O(n), otherwise it is O(1).</source>
          <target state="translated">В то время как в &lt;em&gt;ArrayList&lt;/em&gt; , если массив является полным, т.е. наихудшим случаем, существует дополнительная стоимость изменения размера массива и копирования элементов в новый массив, что делает время выполнения операции добавления в ArrayList O (n), в противном случае это O (1) ,</target>
        </trans-unit>
        <trans-unit id="da14c4f26f81795e276c6bd693c6d365161bbd6f" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;LinkedList&lt;/code&gt; sucks:</source>
          <target state="translated">Почему &lt;code&gt;LinkedList&lt;/code&gt; отстой:</target>
        </trans-unit>
        <trans-unit id="55541df4dcf152a08b381822d996bdf2502bee11" translate="yes" xml:space="preserve">
          <source>Working on a later generation hardware (bigger, more efficient caches) - the results are even more conclusive:</source>
          <target state="translated">Работа на аппаратном обеспечении более позднего поколения (большие,более эффективные кэши)-результаты еще более убедительны:</target>
        </trans-unit>
        <trans-unit id="a96e6d2490d18f0fcecefd52716013baa2282e27" translate="yes" xml:space="preserve">
          <source>Yeah, I know, this is an ancient question, but I'll throw in my two cents:</source>
          <target state="translated">Да,я знаю,это древний вопрос,но я брошу свои два цента:</target>
        </trans-unit>
        <trans-unit id="3421ce1baebeb5f24f380dc68763a8fa7781e99b" translate="yes" xml:space="preserve">
          <source>add at the end of ArrayList</source>
          <target state="translated">добавить в конце списка ArrayList</target>
        </trans-unit>
        <trans-unit id="d2221c6840ebc04f909e2dcc5cd06ad7d8f6932a" translate="yes" xml:space="preserve">
          <source>add to a specific index position</source>
          <target state="translated">добавить к определённой позиции индекса</target>
        </trans-unit>
        <trans-unit id="b281534d3156b92bf772720eb3f8efc8a069ba16" translate="yes" xml:space="preserve">
          <source>add to the end of the list</source>
          <target state="translated">добавить в конец списка</target>
        </trans-unit>
        <trans-unit id="4f6fa4b826aa66326567de6e0de9a55c1c55a1f6" translate="yes" xml:space="preserve">
          <source>add(E e)</source>
          <target state="translated">добавить(е)</target>
        </trans-unit>
        <trans-unit id="72b84dc9449f12507c91ba8d78cb41d5e51adf02" translate="yes" xml:space="preserve">
          <source>add(int index, E element)</source>
          <target state="translated">add(int index,Element)</target>
        </trans-unit>
        <trans-unit id="844ba48b6f4d03efb77ea996bee561e0383f6609" translate="yes" xml:space="preserve">
          <source>get(int index) or search operation</source>
          <target state="translated">get(int index)или поисковая операция</target>
        </trans-unit>
        <trans-unit id="3471d553186e51c7dfeab01069130c02fa1f5d6e" translate="yes" xml:space="preserve">
          <source>hence the memory consumption is high in LinkedList comparatively.</source>
          <target state="translated">Следовательно,потребление памяти в LinkedList сравнительно велико.</target>
        </trans-unit>
        <trans-unit id="c097d2b9e6029ded8d9e023c043cc1fd76009367" translate="yes" xml:space="preserve">
          <source>insert at specified position</source>
          <target state="translated">вставка в указанном положении</target>
        </trans-unit>
        <trans-unit id="a9e8151e5167b5af037785aa4dc339561be644f1" translate="yes" xml:space="preserve">
          <source>insert() or add(Object) operation</source>
          <target state="translated">операция insert()или add(Object)</target>
        </trans-unit>
        <trans-unit id="9c1204571198e8877ebce850c1dfb52bd2b5a592" translate="yes" xml:space="preserve">
          <source>need to find the element first</source>
          <target state="translated">нужно сначала найти элемент</target>
        </trans-unit>
        <trans-unit id="a191f25905b311a0a098953a475e0fe58a39f999" translate="yes" xml:space="preserve">
          <source>need to find the position first</source>
          <target state="translated">нужно сначала найти позицию</target>
        </trans-unit>
        <trans-unit id="847ad4fb3598032da7663514a73890f0201a0804" translate="yes" xml:space="preserve">
          <source>need to search the element first, and then shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">нужно сначала поискать элемент, а затем сдвиг и возможные изменения размера памяти</target>
        </trans-unit>
        <trans-unit id="aa3f74c9a865d4ab8e22742926357ae39d210034" translate="yes" xml:space="preserve">
          <source>remove a specified element</source>
          <target state="translated">удалить указанный элемент</target>
        </trans-unit>
        <trans-unit id="bb34c3a95d3f5f993e01a9c524699f01d857b2bc" translate="yes" xml:space="preserve">
          <source>remove element with specified index</source>
          <target state="translated">удалить элемент с указанным индексом</target>
        </trans-unit>
        <trans-unit id="4ac73d56678223d75eda9aae361f03cbb4efb477" translate="yes" xml:space="preserve">
          <source>remove first element of the list</source>
          <target state="translated">удалить первый элемент списка</target>
        </trans-unit>
        <trans-unit id="247a8156822c95c4f1d9153b4b6e8f6be6811d4d" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element</source>
          <target state="translated">удалить первое появление указанного элемента</target>
        </trans-unit>
        <trans-unit id="52a10c2f057161132a26d20ded67b637c1fbd40b" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element from this list</source>
          <target state="translated">удалить первое появление указанного элемента из этого списка</target>
        </trans-unit>
        <trans-unit id="bd3be8adf5ced4095cfe468b4bc677c15a10ae09" translate="yes" xml:space="preserve">
          <source>remove()</source>
          <target state="translated">remove()</target>
        </trans-unit>
        <trans-unit id="e44f21ff188d5fffffea502864836471078eb47b" translate="yes" xml:space="preserve">
          <source>remove(Object o)</source>
          <target state="translated">удалять(Объект o)</target>
        </trans-unit>
        <trans-unit id="e60165c5083078c6a746b52139fb9f6097486ada" translate="yes" xml:space="preserve">
          <source>remove(int index)</source>
          <target state="translated">индекс удалённости</target>
        </trans-unit>
        <trans-unit id="57ef2c48f4ed0634600c52ceb1e6d3dd7a4f0537" translate="yes" xml:space="preserve">
          <source>remove(int) operation</source>
          <target state="translated">операция удаления</target>
        </trans-unit>
        <trans-unit id="abaf93324a2d63d24596456a9a769ee878da2d71" translate="yes" xml:space="preserve">
          <source>require memory resizing cost.</source>
          <target state="translated">требуют затрат на изменение размера памяти.</target>
        </trans-unit>
        <trans-unit id="624f26f7a70b9282abd23807374f9ad938d82f14" translate="yes" xml:space="preserve">
          <source>require shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">требуется сдвиг и возможная стоимость изменения размера памяти</target>
        </trans-unit>
        <trans-unit id="830739c4a912c77e621eacfa69ff1a2e20904588" translate="yes" xml:space="preserve">
          <source>so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.</source>
          <target state="translated">Поэтому,если будет меньше операций добавления и удаления и больше требований к поисковым операциям,ArrayList будет вашим лучшим вариантом.</target>
        </trans-unit>
        <trans-unit id="8afac9dd157c540d08e836d87cf840122340a4c0" translate="yes" xml:space="preserve">
          <source>there are a large number of add/remove operations</source>
          <target state="translated">существует большое количество операций по удалению адресов</target>
        </trans-unit>
        <trans-unit id="8156fdb9f5fc9c9f8388d191c22e989ad6fd729e" translate="yes" xml:space="preserve">
          <source>there are no large number of random access of element</source>
          <target state="translated">нет большого количества случайного доступа к элементам</target>
        </trans-unit>
        <trans-unit id="33e994a94f2f973adcc52b6ab5eb6c4835a3b486" translate="yes" xml:space="preserve">
          <source>there is no descendingIterator() in &lt;em&gt;ArrayList&lt;/em&gt; , so we need to write our own code to iterate over the ArrayList in reverse direction.</source>
          <target state="translated">в &lt;em&gt;ArrayList&lt;/em&gt; нет нисходящегоIterator (), поэтому нам нужно написать собственный код для перебора ArrayList в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="aacb03ae7534d3764f83b010045b893210f65a4b" translate="yes" xml:space="preserve">
          <source>whereas In linkedlist</source>
          <target state="translated">в то время как в компоновочном перечне</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
