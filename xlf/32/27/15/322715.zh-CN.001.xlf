<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/322715">
    <body>
      <group id="322715">
        <trans-unit id="823154fd74560a83cc6bee588649f9eab42ae643" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;Search:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; search operation is pretty fast compared to the &lt;code&gt;LinkedList&lt;/code&gt; search operation. &lt;code&gt;get(int index)&lt;/code&gt; in &lt;code&gt;ArrayList&lt;/code&gt; gives the performance of &lt;code&gt;O(1)&lt;/code&gt; while &lt;code&gt;LinkedList&lt;/code&gt; performance is &lt;code&gt;O(n)&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;Search:&lt;/code&gt; 与 &lt;code&gt;LinkedList&lt;/code&gt; 搜索操作相比， &lt;code&gt;ArrayList&lt;/code&gt; 搜索操作非常快。 &lt;code&gt;ArrayList&lt;/code&gt; 中的 &lt;code&gt;get(int index)&lt;/code&gt; 给出 &lt;code&gt;O(1)&lt;/code&gt; 的性能，而 &lt;code&gt;LinkedList&lt;/code&gt; 性能是 &lt;code&gt;O(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d9dd8e774bff097745b7775bb8d0ce9bb80f0d5" translate="yes" xml:space="preserve">
          <source>1. Implementation</source>
          <target state="translated">1.1.执行情况</target>
        </trans-unit>
        <trans-unit id="39e90e34901690aa4761ad905d14ac1d3dfdc5d3" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;Deletion:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; remove operation gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives variable performance: &lt;code&gt;O(n)&lt;/code&gt; in worst case (while removing first element) and &lt;code&gt;O(1)&lt;/code&gt; in best case (While removing last element).</source>
          <target state="translated">2） &lt;code&gt;Deletion:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; 删除操作提供 &lt;code&gt;O(1)&lt;/code&gt; 性能，而 &lt;code&gt;ArrayList&lt;/code&gt; 提供可变性能：在最坏情况下（删除第一个元素时）为 &lt;code&gt;O(n)&lt;/code&gt; ，在最佳情况下（删除最后一个元素时）为 &lt;code&gt;O(1)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e5e97190dfb614f2fbe264bd76660de27ae359f6" translate="yes" xml:space="preserve">
          <source>2. Performance</source>
          <target state="translated">2.绩效</target>
        </trans-unit>
        <trans-unit id="35be33e4f01930f4341e2e90cad04e8ccd9b9340" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;Inserts Performance:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; add method gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives &lt;code&gt;O(n)&lt;/code&gt; in worst case. Reason is same as explained for remove.</source>
          <target state="translated">3） &lt;code&gt;Inserts Performance:&lt;/code&gt; 在最坏的情况下， &lt;code&gt;LinkedList&lt;/code&gt; add方法提供 &lt;code&gt;O(1)&lt;/code&gt; 性能，而 &lt;code&gt;ArrayList&lt;/code&gt; 提供 &lt;code&gt;O(n)&lt;/code&gt; 。 原因与删除原因相同。</target>
        </trans-unit>
        <trans-unit id="cad09e39292bee8a79b011228fe0514e7c225093" translate="yes" xml:space="preserve">
          <source>3. Reverse  Iterator</source>
          <target state="translated">3.反向迭代器</target>
        </trans-unit>
        <trans-unit id="ab7a005ac90b45cd9b3e91e6392f71a58ed5d6f3" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;Memory Overhead:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains indexes and element data while &lt;code&gt;LinkedList&lt;/code&gt; maintains element data and two pointers for neighbor nodes</source>
          <target state="translated">4） &lt;code&gt;Memory Overhead:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; 维护索引和元素数据，而 &lt;code&gt;LinkedList&lt;/code&gt; 维护元素数据和两个邻居节点指针</target>
        </trans-unit>
        <trans-unit id="e450f6c0e8ad7231222f9efe27918d977874a66a" translate="yes" xml:space="preserve">
          <source>4. Initial Capacity</source>
          <target state="translated">4.初期能力</target>
        </trans-unit>
        <trans-unit id="d9ff1d6f80c80852e98b6ef3bb0fc8224d5df608" translate="yes" xml:space="preserve">
          <source>5. Memory Overhead</source>
          <target state="translated">5.记忆头顶</target>
        </trans-unit>
        <trans-unit id="127cf06445897840aec95708ef603d3e04a0e331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; goes more in depth, as does 
&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt;以及&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;都更深入。</target>
        </trans-unit>
        <trans-unit id="b43a5b05b6e36c0f963a65dff5cbbba5dd87c900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt;, btw, is a custom ArrayList implementation holding &lt;code&gt;Int&lt;/code&gt; (primitive type) and not Objects - hence all data is really stored adjacently - hence even more efficient.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt; btw是一个自定义ArrayList实现，它保存 &lt;code&gt;Int&lt;/code&gt; （原始类型）而不是Objects-因此，所有数据实际上都是相邻存储的，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="a60af0233530522d0db70105194d2d6809d47074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an &lt;code&gt;ArrayList&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; in the worst case but constant on average.</source>
          <target state="translated">另一方面， &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 允许快速随机读取访问，因此您可以在恒定时间内获取任何元素。 但是，从末端开始的任何地方添加或删除，都需要将后面的所有元素移开，以打开或填补空白。 同样，如果添加的元素多于基础数组的容量，则会分配一个新数组（大小的1.5倍），并将旧数组复制到新数组，因此添加到 &lt;code&gt;ArrayList&lt;/code&gt; 中的是&lt;em&gt;O（n）&lt;/em&gt;最坏的情况，但平均保持不变。</target>
        </trans-unit>
        <trans-unit id="a7d8b017cec005f28991d76ebeb6880b6882d238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; both implements &lt;code&gt;List interface&lt;/code&gt;  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 都实现了 &lt;code&gt;List interface&lt;/code&gt; ，它们的方法和结果几乎相同。 但是，根据需要，它们之间几乎没有什么区别，一个可以使另一个更好。</target>
        </trans-unit>
        <trans-unit id="c5b77accd97f06a73806437d14b939ebde6071c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is essentially an array. &lt;code&gt;LinkedList&lt;/code&gt; is implemented as a double linked list.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 本质上是一个数组。 &lt;code&gt;LinkedList&lt;/code&gt; 被实现为双链表。</target>
        </trans-unit>
        <trans-unit id="d80057e73ae69c2b5a916affaa4a8498705114f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is faster to access an indexed value. It is much worse when inserting or deleting objects.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 可以更快地访问索引值。 当插入或删除对象时，情况更糟。</target>
        </trans-unit>
        <trans-unit id="6b2e4c61036a69b6af002dcf70738ee96dffaaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is randomly accessible, while &lt;code&gt;LinkedList&lt;/code&gt; is really cheap to expand and remove elements from. For most cases, &lt;code&gt;ArrayList&lt;/code&gt; is fine.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 是可随机访问的，而 &lt;code&gt;LinkedList&lt;/code&gt; 对于扩展和删除元素确实很便宜。 对于大多数情况， &lt;code&gt;ArrayList&lt;/code&gt; 很好。</target>
        </trans-unit>
        <trans-unit id="8235411525223988a507c26abd524b3fcfeb5bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is what you want. &lt;code&gt;LinkedList&lt;/code&gt; is almost always a (performance) bug.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 是您想要的。 &lt;code&gt;LinkedList&lt;/code&gt; 几乎总是一个（性能）错误。</target>
        </trans-unit>
        <trans-unit id="33b5deb58c1b5ecdbe2ecc3db08d5de6dd151430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt;, backed by &lt;code&gt;Array&lt;/code&gt;, which needs to be double the size, is worse in large volume application.</source>
          <target state="translated">由 &lt;code&gt;Array&lt;/code&gt; 支持的 &lt;code&gt;ArrayList&lt;/code&gt; 需要大一倍，在大容量应用程序中更糟。</target>
        </trans-unit>
        <trans-unit id="333d27970508614bdfa9c0f502286bf30e92e307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; 是&lt;em&gt;O（1）&lt;/em&gt; 。 &amp;lt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 主要优点</target>
        </trans-unit>
        <trans-unit id="034b1b506c582e5f2d8814254ec183017ef9f60e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; 为&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 2个&lt;/em&gt;步骤）</target>
        </trans-unit>
        <trans-unit id="beaa8d551243d49b4d1eee05d6432e391eb33d16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; allows for constant-time insertions or removals &lt;em&gt;using iterators&lt;/em&gt;, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says &lt;em&gt;&quot;operations that index into the list will traverse the list from the beginning or the end, whichever is closer&quot;&lt;/em&gt;, so those methods are &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/4&lt;/em&gt; steps) on average, though &lt;em&gt;O(1)&lt;/em&gt; for &lt;code&gt;index = 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 允许&lt;em&gt;使用迭代器&lt;/em&gt;进行固定时间的插入或删除，但只能顺序访问元素。 换句话说，您可以向前或向后浏览列表，但是在列表中查找位置所花费的时间与列表的大小成正比。 Javadoc说： &lt;em&gt;&amp;ldquo;索引到列表中的操作将从头或尾开始遍历列表，以较近者为准&amp;rdquo;&lt;/em&gt; ，因此这些方法的平均值为&lt;em&gt;O（n）&lt;/em&gt; （ &lt;em&gt;n / 4&lt;/em&gt;步），尽管 &lt;code&gt;index = 0&lt;/code&gt; &lt;em&gt;O（1）&lt;/em&gt; = 0 。</target>
        </trans-unit>
        <trans-unit id="16d80efc38b7c2ea0ff720019ddcf6be70e20363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are two different implementations of the List interface. &lt;code&gt;LinkedList&lt;/code&gt; implements it with a doubly-linked list. &lt;code&gt;ArrayList&lt;/code&gt; implements it with a dynamically re-sizing array.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 和 &lt;code&gt;ArrayList&lt;/code&gt; 是List接口的两种不同实现。 &lt;code&gt;LinkedList&lt;/code&gt; 使用双向链接列表来实现它。 &lt;code&gt;ArrayList&lt;/code&gt; 使用动态调整大小的数组来实现它。</target>
        </trans-unit>
        <trans-unit id="d9fecaf7b1171739d7cbdff1716ddbff9a310553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; is faster in add and remove, but slower in get. In brief, &lt;code&gt;LinkedList&lt;/code&gt; should be preferred if:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 的添加和删​​除速度更快，但获取速度较慢。 简而言之，如果满足以下条件，应首选 &lt;code&gt;LinkedList&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dee07befa9756327e6f1f9ab15fa468c808e73e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  This is one of the main benefits of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; 为&lt;em&gt;O（1）。&lt;/em&gt;这是 &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 的主要优点之一。</target>
        </trans-unit>
        <trans-unit id="e64862c3a1c0b96095da40a2294754310124b801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; 为&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 2&lt;/em&gt;步）</target>
        </trans-unit>
        <trans-unit id="25bc6fa8f8ff344c68d917a97611b91fe8f94bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reason:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side &lt;code&gt;LinkedList&lt;/code&gt; implements doubly linked list which requires the traversal through all the elements for searching an element.</source>
          <target state="translated">&lt;code&gt;Reason:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; 为其元素维护基于索引的系统，因为它隐式使用数组数据结构，这使得在列表中搜索元素的速度更快。 另一方面， &lt;code&gt;LinkedList&lt;/code&gt; 实现了双向链接列表，该列表需要遍历所有元素以搜索元素。</target>
        </trans-unit>
        <trans-unit id="48481a079aa4dc0b62b86309c5b1f4c4656a27cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; 是&lt;em&gt;O（1）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86bcfe7042d55fdf6be9e4fe7feab45ac45db87d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt; amortized, but &lt;em&gt;O(n)&lt;/em&gt; worst-case since the array must be resized and copied</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; 被分摊为&lt;em&gt;O（1）&lt;/em&gt; ，但最差的情况是&lt;em&gt;O（n），&lt;/em&gt;因为必须调整数组大小并复制它</target>
        </trans-unit>
        <trans-unit id="f30395d9afdb07d74da12292c1d66f1727a434a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; 为&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 2&lt;/em&gt;步）</target>
        </trans-unit>
        <trans-unit id="c772faf78eb3c02de68edab5a6179904996ef451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average),
but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt;  &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; 为&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 4&lt;/em&gt;步），但当 &lt;code&gt;index = 0&lt;/code&gt; 时为 &lt;em&gt;O（1）&lt;/em&gt; &amp;lt;- &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 主要优点</target>
        </trans-unit>
        <trans-unit id="fe559a7d7843b54392656da159db0507b58dd66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.add()&lt;/code&gt; is  O(1) and &lt;code&gt;linkedlist.add()&lt;/code&gt; is 0(1)</source>
          <target state="translated">&lt;code&gt;arraylist.add()&lt;/code&gt; 为O（1）和 &lt;code&gt;linkedlist.add()&lt;/code&gt; 为0（1）</target>
        </trans-unit>
        <trans-unit id="03269f8a98a307f7cfd06520bf46af87990ad50c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.contains()&lt;/code&gt; is O(n) and&lt;code&gt;linkedlist.contains()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.contains()&lt;/code&gt; 为O（n）和 &lt;code&gt;linkedlist.contains()&lt;/code&gt; 为O（n）</target>
        </trans-unit>
        <trans-unit id="618dfb209f4f59dfc35a87398c91f4408414c5e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.get()&lt;/code&gt; is  O(1) whereas &lt;code&gt;linkedlist.get()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.get()&lt;/code&gt; 为O（1），而 &lt;code&gt;linkedlist.get()&lt;/code&gt; 为O（n）</target>
        </trans-unit>
        <trans-unit id="c747b2aa8edd29531dda369e30693d8e367bf978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.next()&lt;/code&gt; is O(1) and &lt;code&gt;linkedlist.next()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.next()&lt;/code&gt; 为O（1）和 &lt;code&gt;linkedlist.next()&lt;/code&gt; 为O（1）</target>
        </trans-unit>
        <trans-unit id="10d74fef85d164534c516cace70835405c829375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.remove()&lt;/code&gt; is O(n) whereas &lt;code&gt;linkedlist.remove()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.remove()&lt;/code&gt; 为O（n），而 &lt;code&gt;linkedlist.remove()&lt;/code&gt; 为O（1）</target>
        </trans-unit>
        <trans-unit id="83cf5e81c843d7f1b9ec0ebf7d3ce303ed679233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  &amp;lt;--- main benefit of &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; 是&lt;em&gt;O（1）&lt;/em&gt; &amp;lt;- &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 主要优点</target>
        </trans-unit>
        <trans-unit id="076d7c0a115bbd75984dc63de232ffd83355229d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; 是&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 4&lt;/em&gt;步）</target>
        </trans-unit>
        <trans-unit id="c46760af862228653fd1838c5478b7b0940fecd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; 为O（n）</target>
        </trans-unit>
        <trans-unit id="7b106c9b6bde2953f3d1daf9d5119c83d5410807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt;is O(1)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; 为O（1）</target>
        </trans-unit>
        <trans-unit id="ddd6b224b5ccf09e47bc373ca347dfe7075c1356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; 是&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 2个&lt;/em&gt;步骤）</target>
        </trans-unit>
        <trans-unit id="cf4c56aa9b5498f71eb6ce9320a3051ac4546259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; 为&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 4&lt;/em&gt;步）</target>
        </trans-unit>
        <trans-unit id="e0e4246aea749c2db7c4d23e708786328b04d5d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; get(int index) operation runs in constant time i.e O(1)  while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; get（int index）操作以恒定时间运行，即O（1）而</target>
        </trans-unit>
        <trans-unit id="5d33e09a0584a1ed7c3021a69aa36ebc1ffbaeb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; is the resizable array implementation of list interface , while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt;是list接口的可调整大小的数组实现，而</target>
        </trans-unit>
        <trans-unit id="c124a2a77d14e556f2817e5cd608afeed22dbfe5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt;  only constructs the empty list without any initial capacity.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;仅构造没有任何初始容量的空列表。</target>
        </trans-unit>
        <trans-unit id="f4ee2569862439dbb15b3ae92435d3a68c160616" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; can be iterated in reverse direction using descendingIterator() while</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;可以使用下降的Iterator（）反向反向迭代，而</target>
        </trans-unit>
        <trans-unit id="c54e2d819276cdac9c5f9629b5f33af6e5719be2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; does not provide index-based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;不为其元素提供基于索引的访问，因为它从头开始或结尾（以较近者为准）进行迭代以检索指定元素索引处的节点。</target>
        </trans-unit>
        <trans-unit id="8bb16f32491a07a1a25788ce7789be628df88f90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; get(int index) operation run time is O(n) .</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; get（int index）操作的运行时间为O（n）。</target>
        </trans-unit>
        <trans-unit id="b58ac9358b965d629640277808e5c5aa9d8d6726" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; is the Doubly-linked list implementation of the list interface.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;是列表接口的双链列表实现。</target>
        </trans-unit>
        <trans-unit id="2a8c0d7f347fae173c91da41a72879346a94ba06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Underlying Data Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）基础数据结构&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433009e1632a58f1c005d11c5b98f0de53409d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) LinkedList implements Deque&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）LinkedList实现双端队列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8263acaceffe6556cde46deb5cd970572e9e42c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Removing an element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4）从位置移除元素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47f28efd57ef00e2c87c16894875d71e8b597837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5) Iterating over ArrayList or LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5）遍历ArrayList或LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bc5d37009869c02f222a403c214d3c17b0e706b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6) Retrieving element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6）从位置检索元素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="462f50e91da5f54cbf63fd99a90f80e12a0505fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7) Memory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7）记忆&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da1ffd583c2ad7be3699d0c0677415f869d74146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f05e8ad2e27a21a899fecd88f6a21aacab0d7ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt; Resizable-array implementation of the List interface</source>
          <target state="translated">&lt;strong&gt;ArrayList：&lt;/strong&gt; List接口的可调整大小的数组实现</target>
        </trans-unit>
        <trans-unit id="6af5a946c3943e163e4208c39ac575e870dcd320" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2269f0870ce22b776e94b551a51a669b55a88029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46534f184f1b21f4eddf5b75c18076e27fc2851f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: For Java its &lt;code&gt;LinkedList&lt;/code&gt; this is not true! See &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Is there a fast concat method for linked list in Java?&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;重要说明&lt;/strong&gt; ：对于Java，其 &lt;code&gt;LinkedList&lt;/code&gt; 并非如此！ 请参阅&lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Java中是否有用于链接列表的快速concat方法？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3e70a2309d967cc0183810bd32e9751566d788e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e04cb44a3754508f40774fb3722cf1f644583432" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt; Doubly-linked list implementation of the List and Deque interfaces</source>
          <target state="translated">&lt;strong&gt;LinkedList：&lt;/strong&gt; List和Deque接口的双链接列表实现</target>
        </trans-unit>
        <trans-unit id="4cfbebcdacd3a1fd25d71fd2c7e3bba3a64e9924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb54ee6bc49f7f8f58707bdd0ffe2bb21f75ea60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mainly&lt;/strong&gt; - that the nodes of the &lt;code&gt;LinkedList&lt;/code&gt; are scattered randomly across the memory. RAM (&quot;Random Access Memory&quot;) isn't really random and blocks of memory need to be fetched to cache. This operation takes time, and when such fetches happen frequently - the memory pages in the cache need to be replaced all the time -&amp;gt; Cache misses -&amp;gt; Cache is not efficient.
&lt;code&gt;ArrayList&lt;/code&gt; elements are stored on continuous memory - which is exactly what the modern CPU architecture is optimizing for.</source>
          <target state="translated">&lt;strong&gt;主要&lt;/strong&gt;是 &lt;code&gt;LinkedList&lt;/code&gt; 的节点随机分布在整个内存中。 RAM（&amp;ldquo;随机访问内存&amp;rdquo;）并不是真正随机的，需要获取内存块以进行缓存。 此操作需要时间，并且当此类提取频繁发生时，需要一直替换高速缓存中的内存页面-&amp;gt;高速缓存未命中-&amp;gt;高速缓存效率不高。 &lt;code&gt;ArrayList&lt;/code&gt; 元素存储在连续内存中-这正是现代CPU体系结构正在优化的内容。</target>
        </trans-unit>
        <trans-unit id="737ee1d3842d6b6aa7c27ab74975e8879b369c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note 2:&lt;/strong&gt;&lt;em&gt;(thanks BeeOnRope)&lt;/em&gt; As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.</source>
          <target state="translated">&lt;strong&gt;注意2 ：（&lt;/strong&gt; &lt;em&gt;感谢BeeOnRope）&lt;/em&gt;由于CompressedOops现在是JDK6或更高版本的默认值，因此下面的64位计算机的值将基本上与32位计算机匹配，除非您明确地将其关闭。</target>
        </trans-unit>
        <trans-unit id="d44e01d24f2f947ad59025026aafcb6509358644" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The sizes shown for the &lt;code&gt;ArrayList&lt;/code&gt; lines are for &lt;em&gt;trimmed lists&lt;/em&gt; - In practice, the capacity of the backing array in an &lt;code&gt;ArrayList&lt;/code&gt; is generally larger than its current element count.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; 行中显示的大小适用于&lt;em&gt;修剪后的列表&lt;/em&gt; -实际上， &lt;code&gt;ArrayList&lt;/code&gt; 中的后备数组的容量通常大于其当前元素数。</target>
        </trans-unit>
        <trans-unit id="12af4b8c2156f8719580823656e7a54b8c2d6d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Secondary&lt;/strong&gt;&lt;code&gt;LinkedList&lt;/code&gt; required to hold back/forward pointers, which means 3 times the memory consumption per value stored compared to &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;次要&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; 需要保留后退/前进指针，这意味着与 &lt;code&gt;ArrayList&lt;/code&gt; 相比，每个存储值的内存消耗是其三倍。</target>
        </trans-unit>
        <trans-unit id="1846b926ec6f26796aa1d815b9ecb79355628a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;&lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;ArrayDeque&lt;/code&gt; are preferable in &lt;em&gt;many&lt;/em&gt; more use-cases than &lt;code&gt;LinkedList&lt;/code&gt;. If you're not sure&amp;nbsp;&amp;mdash; just start with &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;总结&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;ArrayDeque&lt;/code&gt; 在比用链接表更多的用例中更可取。 如果不确定，请从 &lt;code&gt;ArrayList&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="5f13ec4830a4dab71f8b2f8ddb84bf2925c9db1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt; due to modern computer architecture, &lt;code&gt;ArrayList&lt;/code&gt; will be significantly more efficient for nearly any possible use-case - and therefore &lt;code&gt;LinkedList&lt;/code&gt; should be avoided except some very unique and extreme cases.</source>
          <target state="translated">&lt;strong&gt;TL; DR&lt;/strong&gt;由于现代计算机体系结构的缘故，在几乎所有可能的用例中， &lt;code&gt;ArrayList&lt;/code&gt; 的效率都将大大提高-因此，除了一些非常独特和极端的情况外，应避免使用 &lt;code&gt;LinkedList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c5c15402cf358ebe73222367ef252aff38be6e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/2&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (end of list), &lt;em&gt;n&lt;/em&gt; steps in the worst case (start of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;注意：许多操作平均需要&lt;em&gt;n / 2&lt;/em&gt;步，在最佳情况下（列表结尾）需要&lt;em&gt;恒定&lt;/em&gt;的步数，在最坏情况下（列表开始）需要&lt;em&gt;n&lt;/em&gt;步&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e66437897a99b75d7aacd4ff7c0bab63bf960599" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/4&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (e.g. index = 0), and &lt;em&gt;n/2&lt;/em&gt; steps in worst case (middle of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;注意：许多操作平均需要&lt;em&gt;n / 4&lt;/em&gt;步，在最佳情况下（例如，索引= 0）需要&lt;em&gt;恒定&lt;/em&gt;的步数，在最坏情况下（列表的中间）需要&lt;em&gt;n / 2&lt;/em&gt;步&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b9d61654aa4c588b3965ecb02516b604046e37b" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="afb8a95f2210ccfc23ec59f145c584c9c6d9cbca" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="bfbcd797a68fe86413865e4a0cee9ebbb8dc882a" translate="yes" xml:space="preserve">
          <source>A key elements to remember is that the cost of fetching memory block, is more significant than the cost accessing a single memory cell. That's why reader 1MB of sequential memory is up to x400 times faster than reading this amount of data from different blocks of memory:</source>
          <target state="translated">需要记住的一个关键要素是,获取内存块的成本,比访问单个内存单元的成本要大。这就是为什么读取1MB的顺序内存比从不同的内存块中读取这个量的数据要快x400倍。</target>
        </trans-unit>
        <trans-unit id="964ab287d1b2674c3006a9a40f27cc8c75ad7689" translate="yes" xml:space="preserve">
          <source>A linked list specifies a progression from one item to the next (Item a -&amp;gt; item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one.</source>
          <target state="translated">链接列表指定从一个项目到下一个项目（项目a-&amp;gt;项目b）的进度。 您可以使用数组列表获得相同的效果，但是链接列表绝对表明应该遵循上一个项目的项目。</target>
        </trans-unit>
        <trans-unit id="b210113b5c71ae47be12eff9c831066664d10253" translate="yes" xml:space="preserve">
          <source>Algorithms: Big-Oh Notation</source>
          <target state="translated">算法。Big-Oh Notation</target>
        </trans-unit>
        <trans-unit id="89aa0aee53d5aa7fcca1da8190329ab378539fc9" translate="yes" xml:space="preserve">
          <source>Also adding an element in the mid of a list should be very efficient.</source>
          <target state="translated">同时在列表的中间增加一个元素,应该是非常有效的。</target>
        </trans-unit>
        <trans-unit id="61b3b2ef28066e4746dc4b1bff67b83b191c168c" translate="yes" xml:space="preserve">
          <source>Also, if you have large lists, keep in mind that memory usage is also different. Each element of a &lt;code&gt;LinkedList&lt;/code&gt; has more overhead since pointers to the next and previous elements are also stored. &lt;code&gt;ArrayLists&lt;/code&gt; don't have this overhead. However, &lt;code&gt;ArrayLists&lt;/code&gt; take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.</source>
          <target state="translated">另外，如果列表很大，请记住，内存使用情况也有所不同。 &lt;code&gt;LinkedList&lt;/code&gt; 的每个元素都有更多的开销，因为还存储了指向下一个和上一个元素的指针。 &lt;code&gt;ArrayLists&lt;/code&gt; 没有此开销。 但是， &lt;code&gt;ArrayLists&lt;/code&gt; 占用的内存与为该容量分配的内存一样多，无论是否实际添加了元素。</target>
        </trans-unit>
        <trans-unit id="2906ab1d13eae009cd628e69b029557fe9f42802" translate="yes" xml:space="preserve">
          <source>An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.</source>
          <target state="translated">一个数组列表本质上就是一个数组,带有添加项目等的方法。而你应该使用一个通用的列表来代替)。它是一个可以通过索引器(例如[0])访问的项的集合。它意味着从一个项到下一个项的递进。</target>
        </trans-unit>
        <trans-unit id="928353d571ab22df35197d82101926d8b0eefa4a" translate="yes" xml:space="preserve">
          <source>An important feature of a linked list (which I didn't read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)</source>
          <target state="translated">链接式列表的一个重要特征(我在另一个答案中没有读到)是两个列表的串联。如果是数组,这需要O(n)(+一些重新分配的开销),如果是链接列表,这只需要O(1)或O(2);-)</target>
        </trans-unit>
        <trans-unit id="440b1f956dfeafd90ff94cb080bd1ba1475ed504" translate="yes" xml:space="preserve">
          <source>And of course, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; is your best friend.</source>
          <target state="translated">当然， &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;的&lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt;是您最好的朋友。</target>
        </trans-unit>
        <trans-unit id="73a833ab20503a4ddda3951abeecfe30b58c944c" translate="yes" xml:space="preserve">
          <source>Another benefit of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you add or remove from the head of the list, since those operations are &lt;em&gt;O(1)&lt;/em&gt;, while they are &lt;em&gt;O(n)&lt;/em&gt; for &lt;code&gt;ArrayList&lt;/code&gt;. Note that &lt;code&gt;ArrayDeque&lt;/code&gt; may be a good alternative to &lt;code&gt;LinkedList&lt;/code&gt; for adding and removing from the head, but it is not a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">当您从列表的开头添加或删除列表时，使用 &lt;code&gt;LinkedList&lt;/code&gt; 的另一个好处是，因为对于 &lt;code&gt;ArrayList&lt;/code&gt; 来说 ，这些操作是&lt;em&gt;O（1）&lt;/em&gt; ，而它们是&lt;em&gt;O（n）&lt;/em&gt; 。 请注意， &lt;code&gt;ArrayDeque&lt;/code&gt; 可能是 &lt;code&gt;LinkedList&lt;/code&gt; 从头添加和从头删除的一个很好的选择，但它不是 &lt;code&gt;List&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e30b3a7720a85a27ef41bbfc97676b4e2de8896a" translate="yes" xml:space="preserve">
          <source>Another difference between ArrayList and LinkedList is that apart from the List interface, LinkedList also implements Deque interface, which provides first in first out operations for add() and poll() and several other Deque functions. 3) Adding elements in ArrayList Adding element in ArrayList is O(1) operation if it doesn't trigger re-size of Array, in which case it becomes O(log(n)), On the other hand, appending an element in LinkedList is O(1) operation, as it doesn't require any navigation.</source>
          <target state="translated">ArrayList和LinkedList的另一个区别是,除了List接口,LinkedList还实现了Deque接口,它为add()和poll()以及其他几个Deque函数提供了先入先出操作。3)在ArrayList中添加元素 在ArrayList中添加元素,如果不触发Array的大小调整,那么在ArrayList中添加元素是O(1)操作,在这种情况下,它就变成了O(log(n));另一方面,在LinkedList中添加元素是O(1)操作,因为它不需要任何导航。</target>
        </trans-unit>
        <trans-unit id="1e86137c9ac677ec1de04c6463f5afe991a7e829" translate="yes" xml:space="preserve">
          <source>Any indexed operation requires a traversal, i.e. has O(n) performance. This is not obvious in the source code, leading to algorithms O(n) slower than if &lt;code&gt;ArrayList&lt;/code&gt; was used.</source>
          <target state="translated">任何索引操作都需要遍历，即具有O（n）性能。 这在源代码中并不明显，这导致算法O（n）的速度比使用 &lt;code&gt;ArrayList&lt;/code&gt; 的速度慢。</target>
        </trans-unit>
        <trans-unit id="245a7f4435e5cb39a22d5f24ebfff9bf323d2ce3" translate="yes" xml:space="preserve">
          <source>ArrayList Vs LinkedList</source>
          <target state="translated">ArrayList Vs LinkedList</target>
        </trans-unit>
        <trans-unit id="fe0ac6572af91b6c617d95528d2b396ca2837309" translate="yes" xml:space="preserve">
          <source>ArrayList and LinkedList have their own pros and cons.</source>
          <target state="translated">ArrayList和LinkedList各有各的优点和缺点。</target>
        </trans-unit>
        <trans-unit id="5b6785e144c9307049f97a69a012d7795245d88d" translate="yes" xml:space="preserve">
          <source>ArrayList extends AbstractList and implements the List Interface. ArrayList is dynamic array.</source>
          <target state="translated">ArrayList扩展了AbstractList,实现了List接口。ArrayList是动态数组。</target>
        </trans-unit>
        <trans-unit id="437431a42628c440c8c8ddba7824d9ba269abd04" translate="yes" xml:space="preserve">
          <source>ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.</source>
          <target state="translated">如果你所说的性能是指吞吐量,而你可以忽略延迟,那么ArrayList才是一个更好的性能选择。根据我的工作经验,我不能忽略最坏的延迟。</target>
        </trans-unit>
        <trans-unit id="1913d3898d20247f47f9e0c995812cdb4b8d08d7" translate="yes" xml:space="preserve">
          <source>ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList is faster than doing n iterations with LinkedList.</source>
          <target state="translated">ArrayList使用连续的内存地址,而LinkedList使用指向下一个节点的指针。所以当你想在ArrayList中查找一个元素时,比用LinkedList进行n次迭代要快。</target>
        </trans-unit>
        <trans-unit id="d9b713914a6a1ace02a2eecb0047e6799c67666f" translate="yes" xml:space="preserve">
          <source>ArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.</source>
          <target state="translated">ArrayLists对写一读多或附录者很好,但对前面或中间的addremove很差。</target>
        </trans-unit>
        <trans-unit id="459e94cfdff5088a8182f4ad9a0d304b933bf06b" translate="yes" xml:space="preserve">
          <source>As explained above the insert and remove operations give good performance &lt;code&gt;(O(1))&lt;/code&gt; in &lt;code&gt;LinkedList&lt;/code&gt; compared to &lt;code&gt;ArrayList(O(n))&lt;/code&gt;.</source>
          <target state="translated">如上所述，与 &lt;code&gt;ArrayList(O(n))&lt;/code&gt; 相比，插入和删除操作在 &lt;code&gt;LinkedList&lt;/code&gt; 中具有良好的性能 &lt;code&gt;(O(1))&lt;/code&gt; ）） 。</target>
        </trans-unit>
        <trans-unit id="5bafe9e2667a408bbc28c0a3d0896d45d6514421" translate="yes" xml:space="preserve">
          <source>As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.</source>
          <target state="translated">至于ArrayList,我同意至少你应该始终使用初始容量的构造函数,尽量减少数组的重复。</target>
        </trans-unit>
        <trans-unit id="41b881749d840dd577c03a0d047dddf4b9b4432c" translate="yes" xml:space="preserve">
          <source>As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.</source>
          <target state="translated">作为一个在非常大规模的SOA网络服务上做了大约十年的运营性能工程的人,我更喜欢LinkedList的行为而不是ArrayList。虽然LinkedList的稳态吞吐量更差,因此可能会导致购买更多的硬件--而ArrayList在压力下的行为可能会导致集群中的应用程序以近乎同步的方式扩展他们的阵列,而对于大的阵列规模,可能会导致应用程序缺乏响应性,在压力下出现中断,这是灾难性的行为。</target>
        </trans-unit>
        <trans-unit id="7cc15a8cb6e4f67393413b50f7e19ba95f084ea2" translate="yes" xml:space="preserve">
          <source>As with standard linked list and array operations, the various methods will have different algorithmic runtimes.</source>
          <target state="translated">与标准的链接列表和数组操作一样,不同的方法会有不同的算法运行时间。</target>
        </trans-unit>
        <trans-unit id="17f7102d3affee7b74333eccc3786b17d7b95f92" translate="yes" xml:space="preserve">
          <source>Based on these you have to decide what to choose. :)</source>
          <target state="translated">根据这些,你必须决定如何选择。)</target>
        </trans-unit>
        <trans-unit id="f4ba92067d77f8ad1cdde8d5185b8e7ead37b68b" translate="yes" xml:space="preserve">
          <source>Below is the unit test result for each operation.Timing is given in Nanoseconds.</source>
          <target state="translated">以下是各操作的单位测试结果,时间以纳秒为单位。</target>
        </trans-unit>
        <trans-unit id="7f46f0e6a343f897fd8216fe946eeff647289350" translate="yes" xml:space="preserve">
          <source>Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Let's say we want to go through the entire List removing and inserting elements on our way. Usually, you would start from the very beginning for each element using the LinkedList, we could also &quot;save&quot; the current element we're working on with an Iterator. With the help of the Iterator, we get an O(1) efficiency for remove() and insert() when working in a LinkedList. Making it the only performance benefit I'm aware of where a LinkedList is always better than an ArrayList.</source>
          <target state="translated">Bonus:虽然没有办法让这两个方法对ArrayList来说是O(1),但实际上在LinkedLists中是有办法做到这一点的。假设我们想通过删除和插入元素的方式来完成整个List。通常情况下,你会使用LinkedList从一开始就开始对每个元素进行操作,我们也可以用一个迭代器来 &quot;保存 &quot;我们正在处理的当前元素。在迭代器的帮助下,当我们在LinkedList中工作时,我们可以得到一个O(1)的效率。这也是我所知道的唯一的性能优势,即LinkedList总是比ArrayList好。</target>
        </trans-unit>
        <trans-unit id="f37c5042d81ce8b4bbe2d96a4545bbab34eb146f" translate="yes" xml:space="preserve">
          <source>Both ArrayList and LinkedList are implementation of List interface.</source>
          <target state="translated">ArrayList和LinkedList都是List接口的实现。</target>
        </trans-unit>
        <trans-unit id="71f1ed7fc912117c5c42591efe3f6f8fa7782142" translate="yes" xml:space="preserve">
          <source>Both remove() and insert() have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However, the reason behind the linear processing time comes from two very different reasons:</source>
          <target state="translated">对于ArrayLists和LinkedLists来说,remove()和insert()的运行时间效率都是O(n)。然而,线性处理时间背后的原因来自于两个截然不同的原因。</target>
        </trans-unit>
        <trans-unit id="daf0773dc6de1ad67b93748501d5e5e954fbb69d" translate="yes" xml:space="preserve">
          <source>Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.</source>
          <target state="translated">这两个类都是非同步的,可以通过使用Collections.synchronizedList方法显式同步。</target>
        </trans-unit>
        <trans-unit id="de704239e812c1c915cb01038eee251cbcaf16df" translate="yes" xml:space="preserve">
          <source>Conclusion: LinkedList element deletion is faster compared to
  ArrayList.</source>
          <target state="translated">总结。LinkedList元素的删除速度比ArrayList快。</target>
        </trans-unit>
        <trans-unit id="f180d58cc543a593a06f0503cdd233ebc9c5759c" translate="yes" xml:space="preserve">
          <source>Copying a sequential bulk of memory is an operation optimized by the modern CPUs - changing theory and actually making, again, &lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;Vector&lt;/code&gt; much more efficient</source>
          <target state="translated">复制连续的内存是现代CPU进行的一项优化操作-更改了理论，实际上又使 &lt;code&gt;ArrayList&lt;/code&gt; / &lt;code&gt;Vector&lt;/code&gt; 更加高效</target>
        </trans-unit>
        <trans-unit id="1f74715932ed85186b45cbf00a18b0aa012ba91d" translate="yes" xml:space="preserve">
          <source>Correct or Incorrect: Please execute test locally and decide for yourself!</source>
          <target state="translated">正确或不正确。请在本地执行测试,并自行决定!</target>
        </trans-unit>
        <trans-unit id="78ddc4712fca5a2025e62dc663ca11c5d278f6c7" translate="yes" xml:space="preserve">
          <source>Credits: All benchmarks posted here are created by &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt;. Even more data can be found on &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;his blog&lt;/a&gt;</source>
          <target state="translated">鸣谢：此处发布的所有基准都是由&lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;KjellHedstr&amp;ouml;m&lt;/a&gt;创建的。 可以在&lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;他的博客&lt;/a&gt;上找到更多数据</target>
        </trans-unit>
        <trans-unit id="779504bb746658eb51a895ef325a2c35e22145fa" translate="yes" xml:space="preserve">
          <source>Does anyone actually use LinkedList?  I wrote it, and I never use it.</source>
          <target state="translated">有人真的会用LinkedList吗?我写过,而且我从来没有用过它。</target>
        </trans-unit>
        <trans-unit id="c5b4ee91f9f7d7536fb951869ce3310ca5d5e5c8" translate="yes" xml:space="preserve">
          <source>Edit/Remove is faster in &lt;code&gt;LinkedList&lt;/code&gt; than &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 中的 Edit / Remove比 &lt;code&gt;ArrayList&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="aa4bd4d47e6eb0dd8326522867ae2cebb9d911a9" translate="yes" xml:space="preserve">
          <source>Even when big-O performance is the same as &lt;code&gt;ArrayList&lt;/code&gt;, it is probably going to be significantly slower anyway.</source>
          <target state="translated">即使big-O性能与 &lt;code&gt;ArrayList&lt;/code&gt; 相同，无论如何它都可能会明显变慢。</target>
        </trans-unit>
        <trans-unit id="a717e212f108315f6468fbbac65115039dbc3186" translate="yes" xml:space="preserve">
          <source>Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.</source>
          <target state="translated">每当我有一个方法返回一个从DB中获得的数据列表时,我总是使用LinkedList。</target>
        </trans-unit>
        <trans-unit id="d98c1a4ef5e0db31dd47ee47986d318181c0c1aa" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">对于&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85cdf2bee1991274487c8b867c3e971ab9c35e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">对于&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e02d61f3770600b7462828f335d485c3c7c88fd7" translate="yes" xml:space="preserve">
          <source>From all the above differences between ArrayList vs LinkedList, It looks ArrayList is the better choice than LinkedList in almost all cases, except when you do a frequent add() operation than remove(), or get().</source>
          <target state="translated">从以上ArrayList与LinkedList之间的所有区别来看,看起来ArrayList在几乎所有的情况下都比LinkedList更好,除了当你做一个频繁的add()操作而不是remove()或get()操作时,ArrayList是更好的选择。</target>
        </trans-unit>
        <trans-unit id="ecc2eafc3ac7b3d6cdad7d496b20ef438cc7c71b" translate="yes" xml:space="preserve">
          <source>Getting good performance is tricky.</source>
          <target state="translated">取得好的成绩是很棘手的。</target>
        </trans-unit>
        <trans-unit id="d872e08fee24bf8c30e8defc229caebca0ba87ad" translate="yes" xml:space="preserve">
          <source>Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.</source>
          <target state="translated">因此,如果在应用中需要频繁的添加和删除,那么LinkedList是最好的选择。</target>
        </trans-unit>
        <trans-unit id="05cae6319d9059efe74860e4a0c6f790d26f64fc" translate="yes" xml:space="preserve">
          <source>Here are results of a benchmark testing inserting elements in random locations. As you can see - the array list if much more efficient, although in theory each insert in the middle of the list will require &quot;move&quot; the &lt;em&gt;n&lt;/em&gt; later elements of the array (lower values are better):</source>
          <target state="translated">这是基准测试在随机位置插入元素的结果。 如您所见-数组列表效率更高，尽管从理论上讲，列表中间的每个插入都需要&amp;ldquo;移动&amp;rdquo;数组的后&lt;em&gt;n个&lt;/em&gt;元素（值越低越好）：</target>
        </trans-unit>
        <trans-unit id="4231cb0b09e1f7b1f49c5e13010868f22f729203" translate="yes" xml:space="preserve">
          <source>Here is a figure from &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; (&lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):</source>
          <target state="translated">这是来自&lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt;的图（ &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;remove&lt;/code&gt; 是第一种类型，即，在列表的末尾添加一个元素，然后在列表中的指定位置删除该元素。）：</target>
        </trans-unit>
        <trans-unit id="72459064f382e49943817106fc4f16a28f18d010" translate="yes" xml:space="preserve">
          <source>Here is the Big-O notation in both &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; and also &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 以及 &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt; 中的Big-O表示法：</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">代码是这样的。</target>
        </trans-unit>
        <trans-unit id="204bd2319ad6f28782c2fd4eac0f1c63e947287c" translate="yes" xml:space="preserve">
          <source>I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:</source>
          <target state="translated">我看过回复,但有一种情况,我总是用LinkedList代替ArrayList,想分享给大家听听意见。</target>
        </trans-unit>
        <trans-unit id="2909da23de10e510a463c3326c00b280592d1c12" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I honestly can't believe nobody mentioned that &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Deque&lt;/code&gt;.  Just look at the methods in &lt;code&gt;Deque&lt;/code&gt; (and &lt;code&gt;Queue&lt;/code&gt;); if you want a fair comparison, try running &lt;code&gt;LinkedList&lt;/code&gt; against &lt;code&gt;ArrayDeque&lt;/code&gt; and do a feature-for-feature comparison.</source>
          <target state="translated">我知道这是一篇旧文章，但老实说，我不敢相信没有人提到 &lt;code&gt;LinkedList&lt;/code&gt; 实现 &lt;code&gt;Deque&lt;/code&gt; 。 只需查看 &lt;code&gt;Deque&lt;/code&gt; （和 &lt;code&gt;Queue&lt;/code&gt; ）中的方法即可； 如果您想进行公平的比较，请尝试对 &lt;code&gt;ArrayDeque&lt;/code&gt; 运行 &lt;code&gt;LinkedList&lt;/code&gt; 并进行功能对比。</target>
        </trans-unit>
        <trans-unit id="f0b70ff5fa7c09103b8eab96c986f91401d87676" translate="yes" xml:space="preserve">
          <source>I use the interface as the type name for &lt;em&gt;portability&lt;/em&gt;, so that when I ask questions such as these I can rework my code.</source>
          <target state="translated">我将接口用作&lt;em&gt;可移植性&lt;/em&gt;的类型名称，这样当我问诸如此类的问题时，便可以重新编写代码。</target>
        </trans-unit>
        <trans-unit id="c1dae44cf928d176bc4a73ed2740108af2b90993" translate="yes" xml:space="preserve">
          <source>I usually use one over the other based on the time complexities of the operations that I'd perform on that particular List.</source>
          <target state="translated">我通常会根据我对那个特定列表的操作的时间复杂程度来选择一个而不是另一个。</target>
        </trans-unit>
        <trans-unit id="6102d6038b559d5fad73832038782bbb5796e2a3" translate="yes" xml:space="preserve">
          <source>I'm sorry for the answer for being not that informative as the other answers, but I thought it would be the most interesting and self-explanatory.</source>
          <target state="translated">我很抱歉这个答案没有其他答案那么丰富,但我觉得这个答案是最有意思的,也是最能说明问题的,我觉得很抱歉。</target>
        </trans-unit>
        <trans-unit id="a4a379c9c8db61dd6b7c09706346097b32a64868" translate="yes" xml:space="preserve">
          <source>I've always been one to simply use:</source>
          <target state="translated">我一直以来都是简单地使用。</target>
        </trans-unit>
        <trans-unit id="eb6b619bb59e99c5145eebdb33b065006bef1e99" translate="yes" xml:space="preserve">
          <source>If Array is large enough it may take a lot of memory at that point and trigger Garbage collection, which can slow response time.</source>
          <target state="translated">如果Array足够大,可能会在这个时候占用大量内存,并触发Garbage收集,这样会导致响应时间变慢。</target>
        </trans-unit>
        <trans-unit id="559de205fa8eb76d7699b1783f2b0ac89bcc4d52" translate="yes" xml:space="preserve">
          <source>If the constructor  is not overloaded, then &lt;em&gt;ArrayList&lt;/em&gt; creates an empty list of initial capacity 10, while</source>
          <target state="translated">如果构造函数未过载，则&lt;em&gt;ArrayList将&lt;/em&gt;创建一个初始容量为10的空列表，而</target>
        </trans-unit>
        <trans-unit id="c0e9fb39f596736adacc32d734e4edfa0a46ec4b" translate="yes" xml:space="preserve">
          <source>If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList.</source>
          <target state="translated">如果你的应用程序中频繁地进行检索操作,请使用ArrayList。如果你有频繁的插入和删除操作,请使用链接列表。</target>
        </trans-unit>
        <trans-unit id="aaba92fb463b8690a69e81dfffc7a5658f1bd75e" translate="yes" xml:space="preserve">
          <source>If your code has &lt;code&gt;add(0)&lt;/code&gt; and &lt;code&gt;remove(0)&lt;/code&gt;, use a &lt;code&gt;LinkedList&lt;/code&gt; and it's prettier &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;removeFirst()&lt;/code&gt; methods. Otherwise, use &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">如果您的代码具有 &lt;code&gt;add(0)&lt;/code&gt; 和 &lt;code&gt;remove(0)&lt;/code&gt; ，请使用 &lt;code&gt;LinkedList&lt;/code&gt; ，它是更漂亮的 &lt;code&gt;addFirst()&lt;/code&gt; 和 &lt;code&gt;removeFirst()&lt;/code&gt; 方法。 否则，请使用 &lt;code&gt;ArrayList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5ab91dd60a4bdc4332a1f000c5a31d8298e3443" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;ArrayList&lt;/em&gt;  each index only holds the actual object(data).</source>
          <target state="translated">在&lt;em&gt;ArrayList中，&lt;/em&gt;每个索引仅保存实际的对象（数据）。</target>
        </trans-unit>
        <trans-unit id="4e651e52f60a7d33d19241c9b84a7e5ebf5e0d7c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;LinkedList&lt;/em&gt;, there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1). The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as a parameter. This method traverses the LinkedList until it found the Object and unlink it from the original list. Hence this method runtime is O(n).</source>
          <target state="translated">在&lt;em&gt;LinkedList中&lt;/em&gt; ，有两个重载的remove方法。 一个是remove（），不带任何参数，该参数删除列表的开头并以恒定时间O（1）运行。 LinkedList中另一个重载的remove方法是remove（int）或remove（Object），它删除作为参数传递的Object或int。 此方法遍历LinkedList，直到找到对象并将其与原始列表取消链接。 因此，此方法的运行时间为O（n）。</target>
        </trans-unit>
        <trans-unit id="4035507a1bd4880689b50032e852bc42590238de" translate="yes" xml:space="preserve">
          <source>In a LinkedList, it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for remove() and 2 references for insert().</source>
          <target state="translated">在LinkedList中,实际到达想要的元素需要O(n),因为我们必须从一开始就开始,直到到达想要的索引。实际上,删除或插入是不变的,因为我们只需要改变1个remove()的引用和2个insert()的引用。</target>
        </trans-unit>
        <trans-unit id="6d3d827792739e9f193e4b6dedde2b63bd92348f" translate="yes" xml:space="preserve">
          <source>In addition to the other good arguments above, you should notice &lt;code&gt;ArrayList&lt;/code&gt; implements &lt;code&gt;RandomAccess&lt;/code&gt; interface, while &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Queue&lt;/code&gt;.</source>
          <target state="translated">除了上面的其他好参数之外，您还应该注意到 &lt;code&gt;ArrayList&lt;/code&gt; 实现了 &lt;code&gt;RandomAccess&lt;/code&gt; 接口，而 &lt;code&gt;LinkedList&lt;/code&gt; 实现了 &lt;code&gt;Queue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35842b5d82e361cdd7f51df865bca0c300db2026" translate="yes" xml:space="preserve">
          <source>In an ArrayList, you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.</source>
          <target state="translated">在一个ArrayList中,你可以在O(1)中得到元素,但实际上删除或插入一些东西会使它变成O(n),因为下面所有的元素都需要改变。</target>
        </trans-unit>
        <trans-unit id="e8946d8d5170bc375bf87f8b5c440661d618b2c2" translate="yes" xml:space="preserve">
          <source>In arraylist</source>
          <target state="translated">在数组列表中</target>
        </trans-unit>
        <trans-unit id="4a8bb3c134e78f4fa8de3dd3133fe5675a10a71e" translate="yes" xml:space="preserve">
          <source>In my opinion, use ArrayList over LinkedList for most of the practical purpose in Java.</source>
          <target state="translated">在我看来,在Java的大部分实际用途中,使用ArrayList而不是LinkedList。</target>
        </trans-unit>
        <trans-unit id="60daaf72544dd78c2fbc88ad20ed774a9a6e7cea" translate="yes" xml:space="preserve">
          <source>In order to remove an element from a particular index e.g. by calling remove(index), ArrayList performs a copy operation which makes it close to O(n) while LinkedList needs to traverse to that point which also makes it O(n/2), as it can traverse from either direction based upon proximity.</source>
          <target state="translated">为了从一个特定的索引中删除一个元素,例如通过调用remove(index),ArrayList执行复制操作,使其接近于O(n),而LinkedList需要遍历到该点,这也使其接近于O(n2),因为它可以根据接近程度从两个方向遍历。</target>
        </trans-unit>
        <trans-unit id="13af662866647dd21beac5b84de614ccdd269669" translate="yes" xml:space="preserve">
          <source>In other words, you don't need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes O(n) operation. For example, inserting or deleting an element in the middle of a linked list.</source>
          <target state="translated">换句话说,你不需要遍历链接的列表,就可以到达你想要添加元素的位置,在这种情况下,加法就变成了O(n)操作。例如,在链接列表的中间插入或删除一个元素。</target>
        </trans-unit>
        <trans-unit id="469c98ead6182a42fb433736049690f3bc9751a6" translate="yes" xml:space="preserve">
          <source>In theory, LinkedList has an O(1) for the &lt;code&gt;add(E element)&lt;/code&gt;</source>
          <target state="translated">理论上，LinkedList的 &lt;code&gt;add(E element)&lt;/code&gt; 具有O（1 ）</target>
        </trans-unit>
        <trans-unit id="8c381b0a433efc57cbfa3356f3a84f33fb983fb0" translate="yes" xml:space="preserve">
          <source>Insertions in &lt;em&gt;LinkedList&lt;/em&gt; are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation .</source>
          <target state="translated">与ArrayList相比， &lt;em&gt;LinkedList&lt;/em&gt;中的插入通常较快。 在LinkedList中，添加或插入是O（1）操作。</target>
        </trans-unit>
        <trans-unit id="c767ed4fab63fed391201351f4e44d98a283934b" translate="yes" xml:space="preserve">
          <source>It can be said that it was basically created to overcome the drawbacks of arrays</source>
          <target state="translated">可以说,它的产生基本上可以说是为了克服阵列的弊端而产生的</target>
        </trans-unit>
        <trans-unit id="67433abb43ee77013dd1057bd5c859af9a33433f" translate="yes" xml:space="preserve">
          <source>It depends upon what operations you will be doing more on the List.</source>
          <target state="translated">这要看你在List上多做哪些操作。</target>
        </trans-unit>
        <trans-unit id="23b28df1a3e51ae95f5d0a5b0aa39bb036813e19" translate="yes" xml:space="preserve">
          <source>It uses lots of small memory objects, and therefore impacts performance across the process.</source>
          <target state="translated">它使用大量的小内存对象,因此影响了整个过程的性能。</target>
        </trans-unit>
        <trans-unit id="8809d3c8954d5fee422f743b686ee6e92e9dc70a" translate="yes" xml:space="preserve">
          <source>It's an efficiency question. &lt;code&gt;LinkedList&lt;/code&gt; is fast for adding and deleting elements, but slow to access a specific element. &lt;code&gt;ArrayList&lt;/code&gt; is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.</source>
          <target state="translated">这是一个效率问题。 &lt;code&gt;LinkedList&lt;/code&gt; 用于添加和删除元素的速度很快，但是访问特定元素的速度很慢。 &lt;code&gt;ArrayList&lt;/code&gt; 用于访问特定元素的速度很快，但添加到任一端的速度可能很慢，尤其是在中间删除时，速度特别慢。</target>
        </trans-unit>
        <trans-unit id="4b15e68efa8079d20e58d4612e98609845672742" translate="yes" xml:space="preserve">
          <source>It's easier to modify a linked list than ArrayList, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in O(1) time.</source>
          <target state="translated">修改linked list比ArrayList更容易,特别是当你要添加或删除起始或结束的元素时,因为linked list内部保留了这些位置的引用,而且它们在O(1)时间内就可以访问。</target>
        </trans-unit>
        <trans-unit id="adc8d1e49ddd7e5e06471d7adc23a73d72dc8d87" translate="yes" xml:space="preserve">
          <source>It's jarring to see &lt;code&gt;LinkedList&lt;/code&gt; in source because it is probably the wrong choice.</source>
          <target state="translated">在源代码中看到 &lt;code&gt;LinkedList&lt;/code&gt; 令人不快 ，因为这可能是错误的选择。</target>
        </trans-unit>
        <trans-unit id="6e438c304d6715de1cd8a3be3097d2b636828262" translate="yes" xml:space="preserve">
          <source>Iteration is the O(n) operation for both LinkedList and ArrayList where n is a number of an element.</source>
          <target state="translated">对于LinkedList和ArrayList来说,迭代都是O(n)操作,其中n是元素的一个数字。</target>
        </trans-unit>
        <trans-unit id="196cfc0783541b18906b878964f90c2beb521995" translate="yes" xml:space="preserve">
          <source>Joshua Bloch, the author of LinkedList:</source>
          <target state="translated">LinkedList》的作者Joshua Bloch。</target>
        </trans-unit>
        <trans-unit id="b6bf53be71cb03cefc9204127bcad931b18969a2" translate="yes" xml:space="preserve">
          <source>Just to make the point even clearer, please check the benchmark of adding elements to the beginning of the list. This is a use-case where, in-theory, the &lt;code&gt;LinkedList&lt;/code&gt; should really shine, and &lt;code&gt;ArrayList&lt;/code&gt; should present poor or even worse-case results:</source>
          <target state="translated">为了使观点更清楚，请检查将元素添加到列表开头的基准。 从理论上讲，这是一个用例，其中 &lt;code&gt;LinkedList&lt;/code&gt; 应该真正发光，而 &lt;code&gt;ArrayList&lt;/code&gt; 应该给出较差甚至更差的结果：</target>
        </trans-unit>
        <trans-unit id="1f2e1c89c968aef7dc16623190b3a9a9cabbc8b4" translate="yes" xml:space="preserve">
          <source>Let's compare LinkedList and ArrayList w.r.t. below parameters:</source>
          <target state="translated">让我们来比较一下LinkedList和ArrayList和下面的参数。</target>
        </trans-unit>
        <trans-unit id="93306f9c4f0e542bbb9a628ab7325be853345914" translate="yes" xml:space="preserve">
          <source>Link: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</source>
          <target state="translated">链接： &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https&lt;/a&gt; ： //twitter.com/joshbloch/status/583813919019573248</target>
        </trans-unit>
        <trans-unit id="a422cc360ccdd0ef7b3dda2d174720a459804d83" translate="yes" xml:space="preserve">
          <source>LinkedList is &lt;em&gt;almost always&lt;/em&gt; the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList's ability to insert and delete elements in the middle of the list relatively quickly, once you've navigated there with a ListIterator.</source>
          <target state="translated">从性能角度来看，LinkedList &lt;em&gt;几乎总是&lt;/em&gt;错误的选择。 有一些非常特定的算法需要使用LinkedList，但是这种算法非常非常少见，该算法通常具体取决于LinkedList在列表中导航后相对快速地在列表中间插入和删除元素的能力。与ListIterator。</target>
        </trans-unit>
        <trans-unit id="10b1b645b01085ffebf0f6f3f088eea7172b5aa1" translate="yes" xml:space="preserve">
          <source>LinkedList takes much more time to accomplish the same job. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">LinkedList需要更多的时间来完成相同的工作。 &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;源&lt;/a&gt; &lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;代码&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f79cef427b354d9b9780eab17c5d356d4a5b006e" translate="yes" xml:space="preserve">
          <source>LinkedList uses a wrapper object, Entry, which is a static nested class for storing data and two nodes next and previous while ArrayList just stores data in Array.</source>
          <target state="translated">LinkedList使用了一个封装对象Entry,它是一个静态的嵌套类,用于存储数据和下一个和上一个两个节点,而ArrayList只是在Array中存储数据。</target>
        </trans-unit>
        <trans-unit id="7e1c7bcef7896ae52260cfcb6d33ba65b28b0065" translate="yes" xml:space="preserve">
          <source>Lots of small objects are bad for cache-locality.</source>
          <target state="translated">大量的小对象对缓存定位不利。</target>
        </trans-unit>
        <trans-unit id="d1ac372c327cce8ede5e07a803bfe591166259d1" translate="yes" xml:space="preserve">
          <source>Memory overhead in &lt;em&gt;LinkedList&lt;/em&gt; is more as compared to ArrayList as a node in LinkedList needs to maintain the addresses of the next and previous node. While</source>
          <target state="translated">与ArrayList相比， &lt;em&gt;LinkedList中的&lt;/em&gt;内存开销更多，因为&lt;em&gt;LinkedList&lt;/em&gt;中的一个节点需要维护下一个和上一个节点的地址。 而</target>
        </trans-unit>
        <trans-unit id="e5657da09258adb4a01a06b7e549b6f276681445" translate="yes" xml:space="preserve">
          <source>My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.</source>
          <target state="translated">我的理由是,因为不可能知道我到底得到多少个结果,所以不会浪费内存(就像ArrayList中的容量和实际元素数量的差异一样),也不会浪费时间去复制容量。</target>
        </trans-unit>
        <trans-unit id="d7c000eee7e0c05260bee34ed1a23873f4661337" translate="yes" xml:space="preserve">
          <source>Note: this is a benchmark of the C++ Std lib, but my previous experience shown the C++ and Java results are very similar. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">注意：这是C ++ Std库的基准，但是我以前的经验表明C ++和Java的结果非常相似。 &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;源代码&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="43117d0643c36e2f29277032a262d30828a4ea76" translate="yes" xml:space="preserve">
          <source>O(n) worst, O(1) amortized</source>
          <target state="translated">O(n)最差,O(1)摊销的</target>
        </trans-unit>
        <trans-unit id="2613d66d9e3e9d1d2cb152a0c8c768f97ed252f6" translate="yes" xml:space="preserve">
          <source>On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.</source>
          <target state="translated">另一方面,在LinkedList中的插入和删除要容易得多,因为你只需要改变指针就可以了,而ArrayList意味着任何插入或删除都需要使用移位操作。</target>
        </trans-unit>
        <trans-unit id="33a2811cec1cd04c38e25706ff20270bb3aa420c" translate="yes" xml:space="preserve">
          <source>One of the tests I saw on here only conducts the test once.  But what I have noticed is that you need to run these tests many times and eventually their times will converge.  Basically the JVM needs to warm up.  For my particular use case I needed to add/remove items to a list that grows to about 500 items.  In my tests &lt;code&gt;LinkedList&lt;/code&gt; came out faster, with &lt;code&gt;LinkedList&lt;/code&gt; coming in around 50,000 NS and &lt;code&gt;ArrayList&lt;/code&gt; coming in at around 90,000 NS... give or take.  See the code below.</source>
          <target state="translated">我在这里看到的一项测试仅执行一次测试。 但是我注意到，您需要多次运行这些测试，最终它们的时间会收敛。 基本上，JVM需要预热。 对于我的特定用例，我需要将项目添加/删除到增加到约500个项目的列表中。 在我的测试中， &lt;code&gt;LinkedList&lt;/code&gt; 的速度更快，其中 &lt;code&gt;LinkedList&lt;/code&gt; 的速度大约为50,000 NS，而 &lt;code&gt;ArrayList&lt;/code&gt; 的速度大约为90,000 NS。 请参见下面的代码。</target>
        </trans-unit>
        <trans-unit id="65dac500e2d3e9f09ada76f29721043fd8c863b6" translate="yes" xml:space="preserve">
          <source>Operation get(i) in ArrayList is faster than LinkedList, because:</source>
          <target state="translated">ArrayList中的get(i)操作比LinkedList快,因为。</target>
        </trans-unit>
        <trans-unit id="0a5c295d42604c7d58d32363d3f4396711e52d07" translate="yes" xml:space="preserve">
          <source>Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</source>
          <target state="translated">索引到列表中的操作将从列表的开头或结尾(以更接近指定索引的位置为准)进行遍历。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b3bfed3bf17cc4ccb5b52051ae69c0e7857b3e8" translate="yes" xml:space="preserve">
          <source>Practice is very different, as LinkedList is a &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data structure. From performance POV - there are very little cases where &lt;code&gt;LinkedList&lt;/code&gt; could be better performing than the &lt;em&gt;Cache-friendly&lt;/em&gt;&lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">实际情况大不相同，因为LinkedList是&lt;strong&gt;缓存敌对&lt;/strong&gt;数据结构。 从性能POV来看-在极少数情况下， &lt;code&gt;LinkedList&lt;/code&gt; 的性能比对&lt;em&gt;Cache友好的&lt;/em&gt; &lt;code&gt;ArrayList&lt;/code&gt; 更好。</target>
        </trans-unit>
        <trans-unit id="cca9612e17514e1ec64192796cfa4e74465f72b1" translate="yes" xml:space="preserve">
          <source>Reason: LinkedList&amp;rsquo;s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.</source>
          <target state="translated">原因：LinkedList的每个元素都维护两个指针（地址），这些指针指向列表中的两个相邻元素。 因此，删除仅需要更改将要删除的节点的两个相邻节点（元素）中的指针位置。 而在ArrayList中，所有元素都需要移动以填充由删除的元素创建的空间。</target>
        </trans-unit>
        <trans-unit id="f68c820e0a45856c839ded9a5dcddfe8ab72ecae" translate="yes" xml:space="preserve">
          <source>Remove operation in LinkedList is generally the same as ArrayList i.e. O(n).</source>
          <target state="translated">LinkedList中的删除操作一般与ArrayList相同,即O(n)。</target>
        </trans-unit>
        <trans-unit id="73ae9a70388443373dde5d5fe2540131469bd3ca" translate="yes" xml:space="preserve">
          <source>Search (&lt;code&gt;get method&lt;/code&gt;) operations are fast in &lt;code&gt;Arraylist (O(1))&lt;/code&gt; but not in &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</source>
          <target state="translated">搜索（ &lt;code&gt;get method&lt;/code&gt; ）操作在 &lt;code&gt;Arraylist (O(1))&lt;/code&gt; 中很快，但在 &lt;code&gt;LinkedList (O(n))&lt;/code&gt; 却不快</target>
        </trans-unit>
        <trans-unit id="beb9ed0bbc3bb6fd7e6c2e425c684fb4a813730a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;the Java Tutorials - List Implementations&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;Java教程-列表实现&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f41eea01e67c4b4218cd4f1b61ae00436827205" translate="yes" xml:space="preserve">
          <source>Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.</source>
          <target state="translated">同样的,你可以从默认的吞吐量tenured garbage collector中获得更好的吞吐量,但是一旦你获得了10GB堆的java应用,你可能会在Full GCs期间将应用锁定25秒,这将导致SOA应用的超时和失败,如果太频繁地发生,会破坏你的SLA。即使CMS采集器需要更多的资源,并且不能实现相同的原始吞吐量,但它是一个更好的选择,因为它有更多的可预测性和更小的延迟。</target>
        </trans-unit>
        <trans-unit id="c7f07cd9a6f95a46d6ba5320ac3e54b3e0920e1e" translate="yes" xml:space="preserve">
          <source>Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit &lt;code&gt;LinkedLists&lt;/code&gt; and &lt;code&gt;ArrayLists&lt;/code&gt;.</source>
          <target state="translated">由于引用在它们的相对系统上是32位还是64位（即使为null），因此我为32位和64位 &lt;code&gt;LinkedLists&lt;/code&gt; 和 &lt;code&gt;ArrayLists&lt;/code&gt; 提供了 4组数据。</target>
        </trans-unit>
        <trans-unit id="69eebcd50b0954ecfc33ccabe9d8b7d4f9117ee9" translate="yes" xml:space="preserve">
          <source>So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an &lt;code&gt;ArrayList&lt;/code&gt; is technically faster, but unless you're doing something really performance-sensitive, you shouldn't worry about this -- they're both constants.)</source>
          <target state="translated">因此，根据您打算执行的操作，您应该相应地选择实现。 在任何一种List上进行迭代实际上都是同样便宜的。 （从技术上讲，遍历 &lt;code&gt;ArrayList&lt;/code&gt; 的速度更快，但是除非您执行的操作确实对性能敏感，否则您不必为此担心-它们都是常量。）</target>
        </trans-unit>
        <trans-unit id="9d8873955ed68a6d3afa3fc542ef7842e5776761" translate="yes" xml:space="preserve">
          <source>So memory requirement seems less in the case of ArrayList than LinkedList except for the case where Array performs the re-size operation when it copies content from one Array to another.</source>
          <target state="translated">所以在ArrayList的情况下,除了Array在将内容从一个Array复制到另一个Array时执行重新大小操作外,对内存的要求似乎比LinkedList要低。</target>
        </trans-unit>
        <trans-unit id="d29bcb90791eb28700c5ec8a4791f07074a61ec0" translate="yes" xml:space="preserve">
          <source>So, somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).</source>
          <target state="translated">所以,在某种程度上,他们解决的问题略有不同,效率和行为的差异(见他们的方法清单)。</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="2723794bb959da323543cd3bc1ef514d3209ea99" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;每个程序员都应该知道的延迟数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12d5ff1ccac20df183eacef481ad79a3b1d74a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; is pretty clear. O(1) for &lt;code&gt;ArrayList&lt;/code&gt;, because &lt;code&gt;ArrayList&lt;/code&gt; allow random access by using index. O(n) for &lt;code&gt;LinkedList&lt;/code&gt;, because it needs to find the index first. Note: there are different versions of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 的很清楚。 &lt;code&gt;ArrayList&lt;/code&gt; 的 O（1），因为 &lt;code&gt;ArrayList&lt;/code&gt; 允许通过使用索引进行随机访问。 O（n）为 &lt;code&gt;LinkedList&lt;/code&gt; ，因为它需要首先找到索引。 注意： &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;remove&lt;/code&gt; 有不同版本。</target>
        </trans-unit>
        <trans-unit id="6f4576a7bc64b7bfc1b683a9a061390ec3813c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; returned by these classes are &lt;code&gt;fail-fast&lt;/code&gt; (if list is structurally modified at any time after the iterator is created, in any way except through the &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; own remove or add methods, the iterator will &lt;code&gt;throw&lt;/code&gt; a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;).</source>
          <target state="translated">这些类返回的 &lt;code&gt;iterator&lt;/code&gt; 和 &lt;code&gt;listIterator&lt;/code&gt; 都是 &lt;code&gt;fail-fast&lt;/code&gt; （如果在创建迭代器之后的任何时候都对列表进行了结构修改，除非通过 &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; 自己的remove或add方法，否则迭代器将 &lt;code&gt;throw&lt;/code&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e215678d488569b16687c62fc0c1cecd7a06b204" translate="yes" xml:space="preserve">
          <source>The LinkedList class extends AbstractSequentialList and implements List,Deque, and Queue interface.</source>
          <target state="translated">LinkedList类扩展了AbstractSequentialList,并实现了List、Deque和Queueue接口。</target>
        </trans-unit>
        <trans-unit id="a584c17550a71fdd1f4452edc00d3a4572783158" translate="yes" xml:space="preserve">
          <source>The default initial capacity of an &lt;code&gt;ArrayList&lt;/code&gt; is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you're going to add a lot of elements, construct the &lt;code&gt;ArrayList&lt;/code&gt; with a higher initial capacity.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 的默认初始容量很小（Java 1.4-1.8中为10）。 但是由于底层实现是一个数组，因此如果添加很多元素，则必须调整数组的大小。 为了避免在确定要添加许多元素时调整大小的高成本，请使用较高的初始容量构造 &lt;code&gt;ArrayList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a73759baa6b5937448572841c9e25224f4a4466" translate="yes" xml:space="preserve">
          <source>The first difference between ArrayList and LinkedList comes with the fact that ArrayList is backed by Array while LinkedList is backed by LinkedList. This will lead to further differences in performance.</source>
          <target state="translated">ArrayList和LinkedList之间的第一个区别来自于ArrayList是由Array支持的,而LinkedList是由LinkedList支持的。这将导致性能上的进一步差异。</target>
        </trans-unit>
        <trans-unit id="405c38f8ac19fd59375c5014403c7ab61e163b10" translate="yes" xml:space="preserve">
          <source>The formulas I used follow, let me know if I have done anything wrong and I will fix it up. 'b' is either 4 or 8 for 32 or 64 bit systems, and 'n' is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.</source>
          <target state="translated">我使用的公式如下,如果我做错了什么,请告诉我,我会修改。'b'是32位或64位系统的4或8,'n'是元素的数量。需要注意的是,之所以会有这样的修改,是因为java中所有的对象都会占用8的倍数空间,无论是否全部使用,都是8的倍数。</target>
        </trans-unit>
        <trans-unit id="c67ed32e3dd5ebe3398abf72bee54241312ba5f5" translate="yes" xml:space="preserve">
          <source>The get(index) operation is O(1) in ArrayList while its O(n/2) in LinkedList, as it needs to traverse till that entry. Though, in Big O notation O(n/2) is just O(n) because we ignore constants there.</source>
          <target state="translated">在ArrayList中,get(index)操作是O(1),而在LinkedList中是O(n2),因为它需要遍历到那个条目。不过,在大O的记号中,O(n2)只是O(n),因为我们忽略了那里的常量。</target>
        </trans-unit>
        <trans-unit id="ebbe3e7e54ca846d40859c9cd5c54f9e245ba147" translate="yes" xml:space="preserve">
          <source>The main benefits of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you re-use existing iterators to insert and remove elements. These operations can then be done in &lt;em&gt;O(1)&lt;/em&gt; by changing the list locally only. In an array list, the remainder of the array needs to be &lt;em&gt;moved&lt;/em&gt; (i.e. copied). On the other side, seeking in a &lt;code&gt;LinkedList&lt;/code&gt; means following the links in &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/2&lt;/em&gt; steps) for worst case, whereas in an &lt;code&gt;ArrayList&lt;/code&gt; the desired position can be computed mathematically and accessed in &lt;em&gt;O(1)&lt;/em&gt;.</source>
          <target state="translated">当您重复使用现有的迭代器来插入和删除元素时，使用 &lt;code&gt;LinkedList&lt;/code&gt; 的主要好处就会显现出来。 然后可以通过仅在本地更改列表在&lt;em&gt;O（1）中&lt;/em&gt;完成这些操作。 在阵列列表中，阵列的其余部分需要&lt;em&gt;移动&lt;/em&gt; （即复制）。 另一方面，在 &lt;code&gt;LinkedList&lt;/code&gt; 中查找意味着在最坏的情况下遵循&lt;em&gt;O（n）中&lt;/em&gt;的链接（ &lt;em&gt;n / 2个&lt;/em&gt;步骤），而在 &lt;code&gt;ArrayList&lt;/code&gt; 中 ，可以数学计算所需位置并在&lt;em&gt;O（1）中进行&lt;/em&gt;访问。</target>
        </trans-unit>
        <trans-unit id="b74b1e781ca90526e83c42ffc3d14526c49736ab" translate="yes" xml:space="preserve">
          <source>The reason behind &lt;em&gt;ArrayList&lt;/em&gt; being faster than LinkedList is that ArrayList uses an index based system for its elements as it internally uses an array data structure, on the other hand,</source>
          <target state="translated">另一方面，ArrayList比LinkedList快的原因是ArrayList对其元素使用基于索引的系统，因为它内部使用数组数据结构，</target>
        </trans-unit>
        <trans-unit id="2f3082915f897c89bedc037a984915a010f1935c" translate="yes" xml:space="preserve">
          <source>The result clearly shows that &lt;code&gt;LinkedList&lt;/code&gt; is a whole lot more than &lt;code&gt;ArrayList&lt;/code&gt;, especially with a very high element count. If memory is a factor, steer clear of &lt;code&gt;LinkedLists&lt;/code&gt;.</source>
          <target state="translated">结果清楚地表明， &lt;code&gt;LinkedList&lt;/code&gt; 比 &lt;code&gt;ArrayList&lt;/code&gt; 大得多，尤其是元素数量很高时。 如果内存是一个因素，请避免使用 &lt;code&gt;LinkedLists&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55e26f9f49b3d7c9c3c97a405002150b730e9d84" translate="yes" xml:space="preserve">
          <source>There are few similarities between these classes which are as follows:</source>
          <target state="translated">这几个类别之间的相似之处如下:</target>
        </trans-unit>
        <trans-unit id="979f5bb981358561639406265c29e3fa18c87f2d" translate="yes" xml:space="preserve">
          <source>There are two main reasons for this:</source>
          <target state="translated">这主要有两个原因。</target>
        </trans-unit>
        <trans-unit id="51e22a50ad3da080a9975903475702d34ba04615" translate="yes" xml:space="preserve">
          <source>There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList implementation&lt;/a&gt;.  (Yes, it's from 2001, so you'll need to generify it, but I got comparable performance ratios to what's quoted in the article just now in a recent JVM)</source>
          <target state="translated">在一种常见的使用情况下，LinkedList的性能优于ArrayList：队列的性能。 但是，如果您的目标是性能，那么您还应该考虑使用ArrayBlockingQueue（如果可以提前确定队列大小的上限，并且可以负担所有内存的分配），而不是LinkedList，或者使用此&lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList实现&lt;/a&gt; 。 （是的，它是从2001年开始的，因此您需要对其进行泛化，但是我得到的性能比与最近在JVM中的这篇文章中引用的性能比相当）</target>
        </trans-unit>
        <trans-unit id="bb24115d041e92964431dc2a9a4c804a8c2714b7" translate="yes" xml:space="preserve">
          <source>They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.</source>
          <target state="translated">它们都保持了元素的插入顺序,这意味着在显示ArrayList和LinkedList元素的时候,结果集将具有相同的元素插入到List中的顺序。</target>
        </trans-unit>
        <trans-unit id="a7393aee9cdbf2240709c5e92b61bea76f07fd0d" translate="yes" xml:space="preserve">
          <source>Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a &lt;code&gt;LinkedList&lt;/code&gt; is &quot;lots more&quot; than an &lt;code&gt;ArrayList&lt;/code&gt; so I did some number crunching to demonstrate exactly how much both lists take up for N null references.</source>
          <target state="translated">到目前为止，除了人们普遍认为 &lt;code&gt;LinkedList&lt;/code&gt; 比 &lt;code&gt;ArrayList&lt;/code&gt; &amp;ldquo;要多得多&amp;rdquo;外，似乎没有人解决过这些列表的内存占用问题，因此我进行了一些数字运算来证明这两个列表占用了N个空引用的确切数量。 。</target>
        </trans-unit>
        <trans-unit id="5f0ebd31014e6d03e89c2e7c5de3ae7e005b1340" translate="yes" xml:space="preserve">
          <source>To find out more, read any article that talks about the difference between arrays and linked lists.</source>
          <target state="translated">要了解更多信息,请阅读任何关于数组和链接列表的区别的文章。</target>
        </trans-unit>
        <trans-unit id="29ca1dbcdfa1f09ca0ddfee47c7f010975f7b16f" translate="yes" xml:space="preserve">
          <source>Unless you've created large lists and measured a bottleneck, you'll probably never need to worry about the difference.</source>
          <target state="translated">除非你创建过大的单子,也测过瓶颈,否则你可能永远都不需要担心有什么区别。</target>
        </trans-unit>
        <trans-unit id="445928a04da6390fbfe641573eb932e5cdb28769" translate="yes" xml:space="preserve">
          <source>When should &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; be used over &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and vice-versa?</source>
          <target state="translated">什么时候应该在&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;上使用&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; ，反之亦然？</target>
        </trans-unit>
        <trans-unit id="78753f704c5e896d437844d3fb47088744b55cf9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList and when to use ArrayList?</source>
          <target state="translated">什么时候使用LinkedList,什么时候使用ArrayList?</target>
        </trans-unit>
        <trans-unit id="38de968ae17bb38f4696d5acc9b08397e7f206f9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList over ArrayList in Java</source>
          <target state="translated">什么时候在Java中使用LinkedList而不是ArrayList?</target>
        </trans-unit>
        <trans-unit id="8e108c13808368fe0f3f3e721de63a230cc41edf" translate="yes" xml:space="preserve">
          <source>Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.</source>
          <target state="translated">插入和删除哪一个更快取决于它发生的位置。如果我们更接近于开头,那么LinkedList会更快,因为我们必须经过相对较少的元素。如果我们更接近尾部,那么ArrayList会更快,因为我们可以在固定的时间内到达那里,并且只需要改变它后面的少数元素。当精确到中间的时候,LinkedList会更快,因为通过n个元素比移动n个值要快。</target>
        </trans-unit>
        <trans-unit id="aa1559133ba9f967b51fb87c9d69f02e2d34fd11" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt; remove(int) method involves copying elements from the old array to new updated array, hence its runtime is O(n).</source>
          <target state="translated">在&lt;em&gt;ArrayList中，&lt;/em&gt; remove（int）方法涉及将元素从旧数组复制到新的更新数组，因此其运行时间为O（n）。</target>
        </trans-unit>
        <trans-unit id="22fb9822109a567e96dc1961a1c75216ea996026" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt;, if the array is the full i.e worst case,  there is an extra cost of resizing array and copying elements to the new array, which makes runtime of add operation in ArrayList O(n), otherwise it is O(1).</source>
          <target state="translated">在&lt;em&gt;ArrayList中&lt;/em&gt; ，如果数组是完整的（即最坏的情况），则需要调整数组大小并将元素复制到新数组中，这会产生额外的开销，这会使ArrayList中的添加操作运行时间为O（n），否则为O（1） 。</target>
        </trans-unit>
        <trans-unit id="da14c4f26f81795e276c6bd693c6d365161bbd6f" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;LinkedList&lt;/code&gt; sucks:</source>
          <target state="translated">为什么 &lt;code&gt;LinkedList&lt;/code&gt; 很烂：</target>
        </trans-unit>
        <trans-unit id="55541df4dcf152a08b381822d996bdf2502bee11" translate="yes" xml:space="preserve">
          <source>Working on a later generation hardware (bigger, more efficient caches) - the results are even more conclusive:</source>
          <target state="translated">在晚期的硬件(更大、更高效的缓存)上工作--结果更有定论。</target>
        </trans-unit>
        <trans-unit id="a96e6d2490d18f0fcecefd52716013baa2282e27" translate="yes" xml:space="preserve">
          <source>Yeah, I know, this is an ancient question, but I'll throw in my two cents:</source>
          <target state="translated">是啊,我知道,这是一个古老的问题,但我还是要投点我的两分钱。</target>
        </trans-unit>
        <trans-unit id="3421ce1baebeb5f24f380dc68763a8fa7781e99b" translate="yes" xml:space="preserve">
          <source>add at the end of ArrayList</source>
          <target state="translated">加在ArrayList末尾</target>
        </trans-unit>
        <trans-unit id="d2221c6840ebc04f909e2dcc5cd06ad7d8f6932a" translate="yes" xml:space="preserve">
          <source>add to a specific index position</source>
          <target state="translated">加到指定索引位置</target>
        </trans-unit>
        <trans-unit id="b281534d3156b92bf772720eb3f8efc8a069ba16" translate="yes" xml:space="preserve">
          <source>add to the end of the list</source>
          <target state="translated">补上</target>
        </trans-unit>
        <trans-unit id="4f6fa4b826aa66326567de6e0de9a55c1c55a1f6" translate="yes" xml:space="preserve">
          <source>add(E e)</source>
          <target state="translated">添加(E e)</target>
        </trans-unit>
        <trans-unit id="72b84dc9449f12507c91ba8d78cb41d5e51adf02" translate="yes" xml:space="preserve">
          <source>add(int index, E element)</source>
          <target state="translated">add(int index,E元素)</target>
        </trans-unit>
        <trans-unit id="844ba48b6f4d03efb77ea996bee561e0383f6609" translate="yes" xml:space="preserve">
          <source>get(int index) or search operation</source>
          <target state="translated">get(int index)或搜索操作</target>
        </trans-unit>
        <trans-unit id="3471d553186e51c7dfeab01069130c02fa1f5d6e" translate="yes" xml:space="preserve">
          <source>hence the memory consumption is high in LinkedList comparatively.</source>
          <target state="translated">因此,相对而言,LinkedList的内存消耗是很高的。</target>
        </trans-unit>
        <trans-unit id="c097d2b9e6029ded8d9e023c043cc1fd76009367" translate="yes" xml:space="preserve">
          <source>insert at specified position</source>
          <target state="translated">插在指定位置</target>
        </trans-unit>
        <trans-unit id="a9e8151e5167b5af037785aa4dc339561be644f1" translate="yes" xml:space="preserve">
          <source>insert() or add(Object) operation</source>
          <target state="translated">插入()操作</target>
        </trans-unit>
        <trans-unit id="9c1204571198e8877ebce850c1dfb52bd2b5a592" translate="yes" xml:space="preserve">
          <source>need to find the element first</source>
          <target state="translated">先要找到元素</target>
        </trans-unit>
        <trans-unit id="a191f25905b311a0a098953a475e0fe58a39f999" translate="yes" xml:space="preserve">
          <source>need to find the position first</source>
          <target state="translated">先要找准位置</target>
        </trans-unit>
        <trans-unit id="847ad4fb3598032da7663514a73890f0201a0804" translate="yes" xml:space="preserve">
          <source>need to search the element first, and then shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">需要首先搜索元素，然后转移和可能的内存调整大小成本</target>
        </trans-unit>
        <trans-unit id="aa3f74c9a865d4ab8e22742926357ae39d210034" translate="yes" xml:space="preserve">
          <source>remove a specified element</source>
          <target state="translated">移除指定元素</target>
        </trans-unit>
        <trans-unit id="bb34c3a95d3f5f993e01a9c524699f01d857b2bc" translate="yes" xml:space="preserve">
          <source>remove element with specified index</source>
          <target state="translated">移除指定索引的元素</target>
        </trans-unit>
        <trans-unit id="4ac73d56678223d75eda9aae361f03cbb4efb477" translate="yes" xml:space="preserve">
          <source>remove first element of the list</source>
          <target state="translated">删去榜首元素</target>
        </trans-unit>
        <trans-unit id="247a8156822c95c4f1d9153b4b6e8f6be6811d4d" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element</source>
          <target state="translated">移除指定元素的第一个出现的元素</target>
        </trans-unit>
        <trans-unit id="52a10c2f057161132a26d20ded67b637c1fbd40b" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element from this list</source>
          <target state="translated">从这个列表中删除指定元素的第一个出现的元素。</target>
        </trans-unit>
        <trans-unit id="bd3be8adf5ced4095cfe468b4bc677c15a10ae09" translate="yes" xml:space="preserve">
          <source>remove()</source>
          <target state="translated">remove()</target>
        </trans-unit>
        <trans-unit id="e44f21ff188d5fffffea502864836471078eb47b" translate="yes" xml:space="preserve">
          <source>remove(Object o)</source>
          <target state="translated">移除(Object o)</target>
        </trans-unit>
        <trans-unit id="e60165c5083078c6a746b52139fb9f6097486ada" translate="yes" xml:space="preserve">
          <source>remove(int index)</source>
          <target state="translated">移除(int index)</target>
        </trans-unit>
        <trans-unit id="57ef2c48f4ed0634600c52ceb1e6d3dd7a4f0537" translate="yes" xml:space="preserve">
          <source>remove(int) operation</source>
          <target state="translated">移除操作</target>
        </trans-unit>
        <trans-unit id="abaf93324a2d63d24596456a9a769ee878da2d71" translate="yes" xml:space="preserve">
          <source>require memory resizing cost.</source>
          <target state="translated">需要调整内存大小的成本。</target>
        </trans-unit>
        <trans-unit id="624f26f7a70b9282abd23807374f9ad938d82f14" translate="yes" xml:space="preserve">
          <source>require shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">需要转移并可能调整内存大小</target>
        </trans-unit>
        <trans-unit id="830739c4a912c77e621eacfa69ff1a2e20904588" translate="yes" xml:space="preserve">
          <source>so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.</source>
          <target state="translated">所以,如果有较少的添加和删除操作,而对搜索操作的要求较高,ArrayList是你最好的选择。</target>
        </trans-unit>
        <trans-unit id="8afac9dd157c540d08e836d87cf840122340a4c0" translate="yes" xml:space="preserve">
          <source>there are a large number of add/remove operations</source>
          <target state="translated">有大量的增删操作</target>
        </trans-unit>
        <trans-unit id="8156fdb9f5fc9c9f8388d191c22e989ad6fd729e" translate="yes" xml:space="preserve">
          <source>there are no large number of random access of element</source>
          <target state="translated">元素的随机存取次数不多</target>
        </trans-unit>
        <trans-unit id="33e994a94f2f973adcc52b6ab5eb6c4835a3b486" translate="yes" xml:space="preserve">
          <source>there is no descendingIterator() in &lt;em&gt;ArrayList&lt;/em&gt; , so we need to write our own code to iterate over the ArrayList in reverse direction.</source>
          <target state="translated">&lt;em&gt;ArrayList中&lt;/em&gt;没有下降的Iterator（），因此我们需要编写自己的代码以反向遍历ArrayList。</target>
        </trans-unit>
        <trans-unit id="aacb03ae7534d3764f83b010045b893210f65a4b" translate="yes" xml:space="preserve">
          <source>whereas In linkedlist</source>
          <target state="translated">而在linkedlist中</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
