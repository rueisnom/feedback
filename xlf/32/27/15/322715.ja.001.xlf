<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/322715">
    <body>
      <group id="322715">
        <trans-unit id="823154fd74560a83cc6bee588649f9eab42ae643" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;Search:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; search operation is pretty fast compared to the &lt;code&gt;LinkedList&lt;/code&gt; search operation. &lt;code&gt;get(int index)&lt;/code&gt; in &lt;code&gt;ArrayList&lt;/code&gt; gives the performance of &lt;code&gt;O(1)&lt;/code&gt; while &lt;code&gt;LinkedList&lt;/code&gt; performance is &lt;code&gt;O(n)&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;Search:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; 検索操作は、 &lt;code&gt;LinkedList&lt;/code&gt; 検索操作に比べてかなり高速です 。 &lt;code&gt;ArrayList&lt;/code&gt; の &lt;code&gt;get(int index)&lt;/code&gt; は &lt;code&gt;O(1)&lt;/code&gt; のパフォーマンスを &lt;code&gt;LinkedList&lt;/code&gt; ますが、 LinkedListのパフォーマンスは &lt;code&gt;O(n)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9d9dd8e774bff097745b7775bb8d0ce9bb80f0d5" translate="yes" xml:space="preserve">
          <source>1. Implementation</source>
          <target state="translated">1.実施状況</target>
        </trans-unit>
        <trans-unit id="39e90e34901690aa4761ad905d14ac1d3dfdc5d3" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;Deletion:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; remove operation gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives variable performance: &lt;code&gt;O(n)&lt;/code&gt; in worst case (while removing first element) and &lt;code&gt;O(1)&lt;/code&gt; in best case (While removing last element).</source>
          <target state="translated">2） &lt;code&gt;Deletion:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; の削除操作では &lt;code&gt;O(1)&lt;/code&gt; のパフォーマンスが得られますが、 &lt;code&gt;ArrayList&lt;/code&gt; では変数のパフォーマンスが得られます。最悪の場合（最初の要素を削除する場合 &lt;code&gt;O(n)&lt;/code&gt; はO（n）で、最良の場合（最後の要素を削除する場合 &lt;code&gt;O(1)&lt;/code&gt; はO（1 ）です。</target>
        </trans-unit>
        <trans-unit id="e5e97190dfb614f2fbe264bd76660de27ae359f6" translate="yes" xml:space="preserve">
          <source>2. Performance</source>
          <target state="translated">2.パフォーマンス</target>
        </trans-unit>
        <trans-unit id="35be33e4f01930f4341e2e90cad04e8ccd9b9340" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;Inserts Performance:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; add method gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives &lt;code&gt;O(n)&lt;/code&gt; in worst case. Reason is same as explained for remove.</source>
          <target state="translated">3） &lt;code&gt;Inserts Performance:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; addメソッドは &lt;code&gt;O(1)&lt;/code&gt; パフォーマンスを提供し、 &lt;code&gt;ArrayList&lt;/code&gt; は最悪の場合 &lt;code&gt;O(n)&lt;/code&gt; を提供します。 理由は、削除について説明したものと同じです。</target>
        </trans-unit>
        <trans-unit id="cad09e39292bee8a79b011228fe0514e7c225093" translate="yes" xml:space="preserve">
          <source>3. Reverse  Iterator</source>
          <target state="translated">3.逆イテレータ</target>
        </trans-unit>
        <trans-unit id="ab7a005ac90b45cd9b3e91e6392f71a58ed5d6f3" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;Memory Overhead:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains indexes and element data while &lt;code&gt;LinkedList&lt;/code&gt; maintains element data and two pointers for neighbor nodes</source>
          <target state="translated">4） &lt;code&gt;Memory Overhead:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; はインデックスと要素データを維持し、 &lt;code&gt;LinkedList&lt;/code&gt; は要素データと隣接ノードの2つのポインタを維持します。</target>
        </trans-unit>
        <trans-unit id="e450f6c0e8ad7231222f9efe27918d977874a66a" translate="yes" xml:space="preserve">
          <source>4. Initial Capacity</source>
          <target state="translated">4.初期容量</target>
        </trans-unit>
        <trans-unit id="d9ff1d6f80c80852e98b6ef3bb0fc8224d5df608" translate="yes" xml:space="preserve">
          <source>5. Memory Overhead</source>
          <target state="translated">5.メモリオーバーヘッド</target>
        </trans-unit>
        <trans-unit id="127cf06445897840aec95708ef603d3e04a0e331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; goes more in depth, as does 
&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt;は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;と同様に、より深くなります。</target>
        </trans-unit>
        <trans-unit id="b43a5b05b6e36c0f963a65dff5cbbba5dd87c900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt;, btw, is a custom ArrayList implementation holding &lt;code&gt;Int&lt;/code&gt; (primitive type) and not Objects - hence all data is really stored adjacently - hence even more efficient.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt;は、オブジェクトではなく &lt;code&gt;Int&lt;/code&gt; （プリミティブ型）を保持するカスタムArrayList実装です。したがって、すべてのデータは実際に隣接して保存されるため、さらに効率的です。</target>
        </trans-unit>
        <trans-unit id="a60af0233530522d0db70105194d2d6809d47074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an &lt;code&gt;ArrayList&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; in the worst case but constant on average.</source>
          <target state="translated">一方、 &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; は高速のランダム読み取りアクセスを許可するため、一定の時間で任意の要素を取得できます。 ただし、最後以外の場所から追加または削除するには、開口部を作成するか、ギャップを埋めるために、後の要素をすべてシフトする必要があります。 また、基になる配列の容量よりも多くの要素を追加すると、新しい配列（サイズの1.5倍）が割り当てられ、古い配列が新しい配列にコピーされるため、 &lt;code&gt;ArrayList&lt;/code&gt; への追加は&lt;em&gt;O（n）&lt;/em&gt;になります。最悪のケースですが、平均して一定です。</target>
        </trans-unit>
        <trans-unit id="a7d8b017cec005f28991d76ebeb6880b6882d238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; both implements &lt;code&gt;List interface&lt;/code&gt;  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; と &lt;code&gt;LinkedList&lt;/code&gt; はどちらも &lt;code&gt;List interface&lt;/code&gt; を実装しており、それらのメソッドと結果はほとんど同じです。 ただし、要件によっては、両者の違いが少なく、どちらがより優れているかが異なります。</target>
        </trans-unit>
        <trans-unit id="c5b77accd97f06a73806437d14b939ebde6071c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is essentially an array. &lt;code&gt;LinkedList&lt;/code&gt; is implemented as a double linked list.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; は基本的に配列です。 &lt;code&gt;LinkedList&lt;/code&gt; は、二重リンクリストとして実装されます。</target>
        </trans-unit>
        <trans-unit id="d80057e73ae69c2b5a916affaa4a8498705114f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is faster to access an indexed value. It is much worse when inserting or deleting objects.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; は、インデックス付きの値へのアクセスが高速です 。 オブジェクトを挿入または削除する場合は、はるかに悪くなります。</target>
        </trans-unit>
        <trans-unit id="6b2e4c61036a69b6af002dcf70738ee96dffaaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is randomly accessible, while &lt;code&gt;LinkedList&lt;/code&gt; is really cheap to expand and remove elements from. For most cases, &lt;code&gt;ArrayList&lt;/code&gt; is fine.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; はランダムにアクセス可能ですが、 &lt;code&gt;LinkedList&lt;/code&gt; は要素の拡張と削除が非常に簡単です。 ほとんどの場合、 &lt;code&gt;ArrayList&lt;/code&gt; で問題ありません 。</target>
        </trans-unit>
        <trans-unit id="8235411525223988a507c26abd524b3fcfeb5bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is what you want. &lt;code&gt;LinkedList&lt;/code&gt; is almost always a (performance) bug.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; が必要です。 &lt;code&gt;LinkedList&lt;/code&gt; は、ほとんどの場合（パフォーマンス）バグです。</target>
        </trans-unit>
        <trans-unit id="33b5deb58c1b5ecdbe2ecc3db08d5de6dd151430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt;, backed by &lt;code&gt;Array&lt;/code&gt;, which needs to be double the size, is worse in large volume application.</source>
          <target state="translated">サイズが2倍である必要がある &lt;code&gt;Array&lt;/code&gt; に裏打ちされた &lt;code&gt;ArrayList&lt;/code&gt; は、大容量アプリケーションではより悪いものになります。</target>
        </trans-unit>
        <trans-unit id="333d27970508614bdfa9c0f502286bf30e92e307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; は&lt;em&gt;O（1）&lt;/em&gt;です。 &amp;lt;--- &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 主な利点</target>
        </trans-unit>
        <trans-unit id="034b1b506c582e5f2d8814254ec183017ef9f60e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; は&lt;em&gt;O（n）です&lt;/em&gt; （平均&lt;em&gt;n / 2&lt;/em&gt;ステップ）</target>
        </trans-unit>
        <trans-unit id="beaa8d551243d49b4d1eee05d6432e391eb33d16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; allows for constant-time insertions or removals &lt;em&gt;using iterators&lt;/em&gt;, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says &lt;em&gt;&quot;operations that index into the list will traverse the list from the beginning or the end, whichever is closer&quot;&lt;/em&gt;, so those methods are &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/4&lt;/em&gt; steps) on average, though &lt;em&gt;O(1)&lt;/em&gt; for &lt;code&gt;index = 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; は、 &lt;em&gt;反復子を使用&lt;/em&gt;した一定時間の挿入または削除&lt;em&gt;を&lt;/em&gt;可能にしますが、要素への順次アクセスのみが可能です。 つまり、リストを前後に移動できますが、リスト内の位置を見つけるには、リストのサイズに比例して時間がかかります。 Javadocは、 &lt;em&gt;「リストにインデックスを&lt;/em&gt;付ける&lt;em&gt;操作は、リストを最初または最後のどちらか近い方からトラバースする」&lt;/em&gt;と述べているため、これらのメソッドは、平均で&lt;em&gt;O（n）&lt;/em&gt; （ &lt;em&gt;n / 4&lt;/em&gt;ステップ）ですが、 &lt;code&gt;index = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16d80efc38b7c2ea0ff720019ddcf6be70e20363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are two different implementations of the List interface. &lt;code&gt;LinkedList&lt;/code&gt; implements it with a doubly-linked list. &lt;code&gt;ArrayList&lt;/code&gt; implements it with a dynamically re-sizing array.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; と &lt;code&gt;ArrayList&lt;/code&gt; は、Listインターフェースの2つの異なる実装です 。 &lt;code&gt;LinkedList&lt;/code&gt; は、二重にリンクされたリストを使用してそれを実装します。 &lt;code&gt;ArrayList&lt;/code&gt; は、動的にサイズ変更する配列でそれを実装します。</target>
        </trans-unit>
        <trans-unit id="d9fecaf7b1171739d7cbdff1716ddbff9a310553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; is faster in add and remove, but slower in get. In brief, &lt;code&gt;LinkedList&lt;/code&gt; should be preferred if:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; は追加と削除では高速ですが、取得では低速です。 簡単に言うと、 &lt;code&gt;LinkedList&lt;/code&gt; は次の場合に推奨されます。</target>
        </trans-unit>
        <trans-unit id="7dee07befa9756327e6f1f9ab15fa468c808e73e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  This is one of the main benefits of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O（1）&lt;/em&gt;これは &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 主な利点の1つです</target>
        </trans-unit>
        <trans-unit id="e64862c3a1c0b96095da40a2294754310124b801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; は&lt;em&gt;O（n）です&lt;/em&gt; （平均&lt;em&gt;n / 2&lt;/em&gt;ステップ）</target>
        </trans-unit>
        <trans-unit id="25bc6fa8f8ff344c68d917a97611b91fe8f94bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reason:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side &lt;code&gt;LinkedList&lt;/code&gt; implements doubly linked list which requires the traversal through all the elements for searching an element.</source>
          <target state="translated">&lt;code&gt;Reason:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; は、配列データ構造を暗黙的に使用するため、要素のインデックスベースのシステムを維持し、リスト内の要素の検索を高速化します。 一方、 &lt;code&gt;LinkedList&lt;/code&gt; は、要素を検索するためにすべての要素を走査する必要がある二重リンクリストを実装します。</target>
        </trans-unit>
        <trans-unit id="48481a079aa4dc0b62b86309c5b1f4c4656a27cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; は&lt;em&gt;O（1）です&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86bcfe7042d55fdf6be9e4fe7feab45ac45db87d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt; amortized, but &lt;em&gt;O(n)&lt;/em&gt; worst-case since the array must be resized and copied</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; は&lt;em&gt;O（1）が&lt;/em&gt;償却されますが、配列のサイズを変更してコピーする必要があるため、 &lt;em&gt;O（n）が&lt;/em&gt;最悪の場合</target>
        </trans-unit>
        <trans-unit id="f30395d9afdb07d74da12292c1d66f1727a434a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; は&lt;em&gt;O（n）です&lt;/em&gt; （平均&lt;em&gt;n / 2&lt;/em&gt;ステップ）</target>
        </trans-unit>
        <trans-unit id="c772faf78eb3c02de68edab5a6179904996ef451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average),
but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt;  &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; は&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 4&lt;/em&gt;ステップ）ですが、 &lt;code&gt;index = 0&lt;/code&gt; 場合は&lt;em&gt;O（1）&lt;/em&gt; &amp;lt;--- &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 主な利点</target>
        </trans-unit>
        <trans-unit id="fe559a7d7843b54392656da159db0507b58dd66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.add()&lt;/code&gt; is  O(1) and &lt;code&gt;linkedlist.add()&lt;/code&gt; is 0(1)</source>
          <target state="translated">&lt;code&gt;arraylist.add()&lt;/code&gt; はO（1）で、 &lt;code&gt;linkedlist.add()&lt;/code&gt; は0（1）です</target>
        </trans-unit>
        <trans-unit id="03269f8a98a307f7cfd06520bf46af87990ad50c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.contains()&lt;/code&gt; is O(n) and&lt;code&gt;linkedlist.contains()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.contains()&lt;/code&gt; はO（n）で、 &lt;code&gt;linkedlist.contains()&lt;/code&gt; はO（n）です</target>
        </trans-unit>
        <trans-unit id="618dfb209f4f59dfc35a87398c91f4408414c5e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.get()&lt;/code&gt; is  O(1) whereas &lt;code&gt;linkedlist.get()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.get()&lt;/code&gt; はO（1）ですが、 &lt;code&gt;linkedlist.get()&lt;/code&gt; はO（n）です</target>
        </trans-unit>
        <trans-unit id="c747b2aa8edd29531dda369e30693d8e367bf978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.next()&lt;/code&gt; is O(1) and &lt;code&gt;linkedlist.next()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.next()&lt;/code&gt; はO（1）で、 &lt;code&gt;linkedlist.next()&lt;/code&gt; はO（1）です</target>
        </trans-unit>
        <trans-unit id="10d74fef85d164534c516cace70835405c829375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.remove()&lt;/code&gt; is O(n) whereas &lt;code&gt;linkedlist.remove()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.remove()&lt;/code&gt; はO（n）ですが、 &lt;code&gt;linkedlist.remove()&lt;/code&gt; はO（1）です</target>
        </trans-unit>
        <trans-unit id="83cf5e81c843d7f1b9ec0ebf7d3ce303ed679233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  &amp;lt;--- main benefit of &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; は&lt;em&gt;O（1）&lt;/em&gt; &amp;lt;--- &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 主な利点</target>
        </trans-unit>
        <trans-unit id="076d7c0a115bbd75984dc63de232ffd83355229d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; は&lt;em&gt;O（n）です&lt;/em&gt; （平均&lt;em&gt;n / 4&lt;/em&gt;ステップ）</target>
        </trans-unit>
        <trans-unit id="c46760af862228653fd1838c5478b7b0940fecd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; はO（n）です</target>
        </trans-unit>
        <trans-unit id="7b106c9b6bde2953f3d1daf9d5119c83d5410807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt;is O(1)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; はO（1）です</target>
        </trans-unit>
        <trans-unit id="ddd6b224b5ccf09e47bc373ca347dfe7075c1356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; は&lt;em&gt;O（n）&lt;/em&gt; （平均&lt;em&gt;n / 2&lt;/em&gt;ステップ）</target>
        </trans-unit>
        <trans-unit id="cf4c56aa9b5498f71eb6ce9320a3051ac4546259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; は&lt;em&gt;O（n）です&lt;/em&gt; （平均&lt;em&gt;n / 4&lt;/em&gt;ステップ）</target>
        </trans-unit>
        <trans-unit id="e0e4246aea749c2db7c4d23e708786328b04d5d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; get(int index) operation runs in constant time i.e O(1)  while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; get（int index）操作は一定時間、つまりO（1）で実行されますが、</target>
        </trans-unit>
        <trans-unit id="5d33e09a0584a1ed7c3021a69aa36ebc1ffbaeb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; is the resizable array implementation of list interface , while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt;は、リストインターフェイスのサイズ変更可能な配列実装&lt;em&gt;です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c124a2a77d14e556f2817e5cd608afeed22dbfe5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt;  only constructs the empty list without any initial capacity.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;は、初期容量なしで空のリストのみを作成します。</target>
        </trans-unit>
        <trans-unit id="f4ee2569862439dbb15b3ae92435d3a68c160616" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; can be iterated in reverse direction using descendingIterator() while</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;は、descendingIterator（）を使用して逆方向に反復できます。</target>
        </trans-unit>
        <trans-unit id="c54e2d819276cdac9c5f9629b5f33af6e5719be2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; does not provide index-based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;は、指定された要素のインデックスにあるノードを取得するために最初または最後（どちらか近い方）から反復するため、要素にインデックスベースのアクセスを提供しません。</target>
        </trans-unit>
        <trans-unit id="8bb16f32491a07a1a25788ce7789be628df88f90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; get(int index) operation run time is O(n) .</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; get（int index）操作の実行時はO（n）です。</target>
        </trans-unit>
        <trans-unit id="b58ac9358b965d629640277808e5c5aa9d8d6726" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; is the Doubly-linked list implementation of the list interface.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;は、リストインターフェイスの二重リンクリストの実装です。</target>
        </trans-unit>
        <trans-unit id="2a8c0d7f347fae173c91da41a72879346a94ba06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Underlying Data Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）基礎となるデータ構造&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433009e1632a58f1c005d11c5b98f0de53409d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) LinkedList implements Deque&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）LinkedListはDequeを実装します&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8263acaceffe6556cde46deb5cd970572e9e42c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Removing an element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4）位置から要素を削除する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47f28efd57ef00e2c87c16894875d71e8b597837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5) Iterating over ArrayList or LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5）ArrayListまたはLinkedListの反復&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bc5d37009869c02f222a403c214d3c17b0e706b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6) Retrieving element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6）位置から要素を取得する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="462f50e91da5f54cbf63fd99a90f80e12a0505fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7) Memory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7）メモリ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da1ffd583c2ad7be3699d0c0677415f869d74146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f05e8ad2e27a21a899fecd88f6a21aacab0d7ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt; Resizable-array implementation of the List interface</source>
          <target state="translated">&lt;strong&gt;ArrayList：&lt;/strong&gt; Listインターフェースのサイズ変更可能な配列の実装</target>
        </trans-unit>
        <trans-unit id="6af5a946c3943e163e4208c39ac575e870dcd320" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2269f0870ce22b776e94b551a51a669b55a88029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46534f184f1b21f4eddf5b75c18076e27fc2851f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: For Java its &lt;code&gt;LinkedList&lt;/code&gt; this is not true! See &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Is there a fast concat method for linked list in Java?&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;重要&lt;/strong&gt; ：Javaの &lt;code&gt;LinkedList&lt;/code&gt; の場合、これは正しくありません。 &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Javaのリンクリストに高速のconcatメソッドはありますか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3e70a2309d967cc0183810bd32e9751566d788e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e04cb44a3754508f40774fb3722cf1f644583432" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt; Doubly-linked list implementation of the List and Deque interfaces</source>
          <target state="translated">&lt;strong&gt;LinkedList：&lt;/strong&gt; ListおよびDequeインターフェースの二重リンクリストの実装</target>
        </trans-unit>
        <trans-unit id="4cfbebcdacd3a1fd25d71fd2c7e3bba3a64e9924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb54ee6bc49f7f8f58707bdd0ffe2bb21f75ea60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mainly&lt;/strong&gt; - that the nodes of the &lt;code&gt;LinkedList&lt;/code&gt; are scattered randomly across the memory. RAM (&quot;Random Access Memory&quot;) isn't really random and blocks of memory need to be fetched to cache. This operation takes time, and when such fetches happen frequently - the memory pages in the cache need to be replaced all the time -&amp;gt; Cache misses -&amp;gt; Cache is not efficient.
&lt;code&gt;ArrayList&lt;/code&gt; elements are stored on continuous memory - which is exactly what the modern CPU architecture is optimizing for.</source>
          <target state="translated">&lt;strong&gt;主に&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; のノードはメモリ全体にランダムに散在しています。 RAM（「ランダムアクセスメモリ」）は実際にはランダムではなく、メモリのブロックをキャッシュにフェッチする必要があります。 この操作には時間がかかり、そのようなフェッチが頻繁に発生する場合、キャッシュ内のメモリページを常に交換する必要がある-&amp;gt;キャッシュミス-&amp;gt;キャッシュは効率的ではありません。 &lt;code&gt;ArrayList&lt;/code&gt; 要素は連続メモリに格納されます-これはまさに最新のCPUアーキテクチャが最適化しているものです。</target>
        </trans-unit>
        <trans-unit id="737ee1d3842d6b6aa7c27ab74975e8879b369c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note 2:&lt;/strong&gt;&lt;em&gt;(thanks BeeOnRope)&lt;/em&gt; As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.</source>
          <target state="translated">&lt;strong&gt;注2：&lt;/strong&gt; &lt;em&gt;（BeeOnRopeに感謝）&lt;/em&gt; CompressedOopsはデフォルトでJDK6の中間以降になっているため、64ビットマシンの以下の値は、特にオフにしない限り、基本的に32ビットマシンと一致します。</target>
        </trans-unit>
        <trans-unit id="d44e01d24f2f947ad59025026aafcb6509358644" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The sizes shown for the &lt;code&gt;ArrayList&lt;/code&gt; lines are for &lt;em&gt;trimmed lists&lt;/em&gt; - In practice, the capacity of the backing array in an &lt;code&gt;ArrayList&lt;/code&gt; is generally larger than its current element count.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; 行に表示されるサイズは&lt;em&gt;トリミングされたリスト&lt;/em&gt;用です -実際には、 &lt;code&gt;ArrayList&lt;/code&gt; のバッキング配列の容量は通常、現在の要素数よりも大きくなります。</target>
        </trans-unit>
        <trans-unit id="12af4b8c2156f8719580823656e7a54b8c2d6d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Secondary&lt;/strong&gt;&lt;code&gt;LinkedList&lt;/code&gt; required to hold back/forward pointers, which means 3 times the memory consumption per value stored compared to &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;セカンダリ&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; 、ポインターのバック/フォワードを保持するために必要 &lt;code&gt;ArrayList&lt;/code&gt; 。つまり、格納された値あたりのメモリ消費量はArrayListと比較して3倍になります。</target>
        </trans-unit>
        <trans-unit id="1846b926ec6f26796aa1d815b9ecb79355628a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;&lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;ArrayDeque&lt;/code&gt; are preferable in &lt;em&gt;many&lt;/em&gt; more use-cases than &lt;code&gt;LinkedList&lt;/code&gt;. If you're not sure&amp;nbsp;&amp;mdash; just start with &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayDeque&lt;/code&gt; を含む &lt;code&gt;ArrayList&lt;/code&gt; は 、 LinkedListより&lt;em&gt;も&lt;/em&gt;多くのユースケースで &lt;code&gt;LinkedList&lt;/code&gt; ます。 よくわからない場合は、 &lt;code&gt;ArrayList&lt;/code&gt; から始めてください。</target>
        </trans-unit>
        <trans-unit id="5f13ec4830a4dab71f8b2f8ddb84bf2925c9db1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt; due to modern computer architecture, &lt;code&gt;ArrayList&lt;/code&gt; will be significantly more efficient for nearly any possible use-case - and therefore &lt;code&gt;LinkedList&lt;/code&gt; should be avoided except some very unique and extreme cases.</source>
          <target state="translated">&lt;strong&gt;TL; DR&lt;/strong&gt;は最新のコンピューターアーキテクチャにより、 &lt;code&gt;ArrayList&lt;/code&gt; はほとんどすべての可能なユースケースで非常に効率的です。そのため、非常にユニークで極端な場合を除いて、 &lt;code&gt;LinkedList&lt;/code&gt; は避けてください。</target>
        </trans-unit>
        <trans-unit id="18c5c15402cf358ebe73222367ef252aff38be6e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/2&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (end of list), &lt;em&gt;n&lt;/em&gt; steps in the worst case (start of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;注：操作の多くは、平均で&lt;em&gt;n / 2&lt;/em&gt;ステップ、最良の場合は&lt;em&gt;一定&lt;/em&gt;のステップ数（リストの最後）、最悪の場合は&lt;em&gt;n&lt;/em&gt;ステップ（リストの最初）を必要とします。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e66437897a99b75d7aacd4ff7c0bab63bf960599" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/4&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (e.g. index = 0), and &lt;em&gt;n/2&lt;/em&gt; steps in worst case (middle of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;注：操作の多くは、平均で&lt;em&gt;n / 4&lt;/em&gt;ステップ、最良の場合は&lt;em&gt;一定&lt;/em&gt;のステップ数（たとえば、インデックス= 0）、最悪の場合は&lt;em&gt;n / 2&lt;/em&gt;ステップ（リストの中央）を必要とします。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b9d61654aa4c588b3965ecb02516b604046e37b" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="afb8a95f2210ccfc23ec59f145c584c9c6d9cbca" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="bfbcd797a68fe86413865e4a0cee9ebbb8dc882a" translate="yes" xml:space="preserve">
          <source>A key elements to remember is that the cost of fetching memory block, is more significant than the cost accessing a single memory cell. That's why reader 1MB of sequential memory is up to x400 times faster than reading this amount of data from different blocks of memory:</source>
          <target state="translated">覚えておくべき重要な要素は、メモリブロックをフェッチするコストは、単一のメモリセルにアクセスするコストよりも重要であるということです。それは、シーケンシャルメモリのリーダー1MBは、メモリの異なるブロックからこの量のデータを読み取るよりも、最大x400倍高速である理由です。</target>
        </trans-unit>
        <trans-unit id="964ab287d1b2674c3006a9a40f27cc8c75ad7689" translate="yes" xml:space="preserve">
          <source>A linked list specifies a progression from one item to the next (Item a -&amp;gt; item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one.</source>
          <target state="translated">リンクされたリストは、あるアイテムから次のアイテムへの進行を指定します（アイテムa-&amp;gt;アイテムb）。 配列リストを使用しても同じ効果を得ることができますが、リンクされたリストは、前のリストの後に続くはずのアイテムを絶対に示しています。</target>
        </trans-unit>
        <trans-unit id="b210113b5c71ae47be12eff9c831066664d10253" translate="yes" xml:space="preserve">
          <source>Algorithms: Big-Oh Notation</source>
          <target state="translated">アルゴリズム。大王記法</target>
        </trans-unit>
        <trans-unit id="89aa0aee53d5aa7fcca1da8190329ab378539fc9" translate="yes" xml:space="preserve">
          <source>Also adding an element in the mid of a list should be very efficient.</source>
          <target state="translated">また、リストの途中で要素を追加すると非常に効率的なはずです。</target>
        </trans-unit>
        <trans-unit id="61b3b2ef28066e4746dc4b1bff67b83b191c168c" translate="yes" xml:space="preserve">
          <source>Also, if you have large lists, keep in mind that memory usage is also different. Each element of a &lt;code&gt;LinkedList&lt;/code&gt; has more overhead since pointers to the next and previous elements are also stored. &lt;code&gt;ArrayLists&lt;/code&gt; don't have this overhead. However, &lt;code&gt;ArrayLists&lt;/code&gt; take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.</source>
          <target state="translated">また、大きなリストがある場合は、メモリ使用量も異なることに注意してください。 &lt;code&gt;LinkedList&lt;/code&gt; の各要素には、次の要素と前の要素へのポインタも格納されるため、オーバーヘッドが大きくなります。 &lt;code&gt;ArrayLists&lt;/code&gt; はこのオーバーヘッドはありません。 ただし、 &lt;code&gt;ArrayLists&lt;/code&gt; は、要素が実際に追加されたかどうかに関係なく、容量に割り当てられているのと同じ量のメモリを使用します。</target>
        </trans-unit>
        <trans-unit id="2906ab1d13eae009cd628e69b029557fe9f42802" translate="yes" xml:space="preserve">
          <source>An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.</source>
          <target state="translated">配列リストは、基本的には項目を追加するメソッドなどを持つ配列です。(そして、代わりに一般的なリストを使うべきです)。これは、インデクサ(例えば [0]など)を使ってアクセスできる項目のコレクションです。これは、ある項目から次の項目への進行を意味します。</target>
        </trans-unit>
        <trans-unit id="928353d571ab22df35197d82101926d8b0eefa4a" translate="yes" xml:space="preserve">
          <source>An important feature of a linked list (which I didn't read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)</source>
          <target state="translated">リンクリストの重要な特徴は(別の回答では読んでいませんでしたが)、2つのリストを連結することです。配列では、これはO(n)(+いくつかの再割り当てのオーバーヘッド)リンクリストでは、これはO(1)かO(2)だけです ;-)</target>
        </trans-unit>
        <trans-unit id="440b1f956dfeafd90ff94cb080bd1ba1475ed504" translate="yes" xml:space="preserve">
          <source>And of course, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; is your best friend.</source>
          <target state="translated">そしてもちろん、 &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;の&lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt;はあなたの親友です。</target>
        </trans-unit>
        <trans-unit id="73a833ab20503a4ddda3951abeecfe30b58c944c" translate="yes" xml:space="preserve">
          <source>Another benefit of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you add or remove from the head of the list, since those operations are &lt;em&gt;O(1)&lt;/em&gt;, while they are &lt;em&gt;O(n)&lt;/em&gt; for &lt;code&gt;ArrayList&lt;/code&gt;. Note that &lt;code&gt;ArrayDeque&lt;/code&gt; may be a good alternative to &lt;code&gt;LinkedList&lt;/code&gt; for adding and removing from the head, but it is not a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">これらの操作は&lt;em&gt;O（1）&lt;/em&gt;であり、 &lt;code&gt;ArrayList&lt;/code&gt; の &lt;em&gt;O（n）である&lt;/em&gt;ため、リストの先頭から追加または削除すると、 &lt;code&gt;LinkedList&lt;/code&gt; を使用する別の利点が生じます。 &lt;code&gt;ArrayDeque&lt;/code&gt; はLinkedListの代わりに &lt;code&gt;LinkedList&lt;/code&gt; に追加したりヘッドから削除したりするのに適しているかもしれませんが、 &lt;code&gt;List&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="e30b3a7720a85a27ef41bbfc97676b4e2de8896a" translate="yes" xml:space="preserve">
          <source>Another difference between ArrayList and LinkedList is that apart from the List interface, LinkedList also implements Deque interface, which provides first in first out operations for add() and poll() and several other Deque functions. 3) Adding elements in ArrayList Adding element in ArrayList is O(1) operation if it doesn't trigger re-size of Array, in which case it becomes O(log(n)), On the other hand, appending an element in LinkedList is O(1) operation, as it doesn't require any navigation.</source>
          <target state="translated">また、ArrayList と LinkedList の違いは、List インターフェースとは別に、LinkedList は Deque インターフェースを実装しており、 add()や poll()などの先入れ先出しの操作が可能な点です。3)ArrayListへの要素の追加 ArrayListへの要素の追加は、Arrayのサイズ変更を伴わなければO(1)の操作となり、その場合はO(log(n))となります。</target>
        </trans-unit>
        <trans-unit id="1e86137c9ac677ec1de04c6463f5afe991a7e829" translate="yes" xml:space="preserve">
          <source>Any indexed operation requires a traversal, i.e. has O(n) performance. This is not obvious in the source code, leading to algorithms O(n) slower than if &lt;code&gt;ArrayList&lt;/code&gt; was used.</source>
          <target state="translated">インデックス付きの操作はすべてトラバーサルが必要です。 これはソースコードでは明らかではないため、 &lt;code&gt;ArrayList&lt;/code&gt; を使用した場合よりもアルゴリズムO（n）が遅くなります。</target>
        </trans-unit>
        <trans-unit id="245a7f4435e5cb39a22d5f24ebfff9bf323d2ce3" translate="yes" xml:space="preserve">
          <source>ArrayList Vs LinkedList</source>
          <target state="translated">ArrayList対LinkedList</target>
        </trans-unit>
        <trans-unit id="fe0ac6572af91b6c617d95528d2b396ca2837309" translate="yes" xml:space="preserve">
          <source>ArrayList and LinkedList have their own pros and cons.</source>
          <target state="translated">ArrayListとLinkedListにはそれぞれ長所と短所があります。</target>
        </trans-unit>
        <trans-unit id="5b6785e144c9307049f97a69a012d7795245d88d" translate="yes" xml:space="preserve">
          <source>ArrayList extends AbstractList and implements the List Interface. ArrayList is dynamic array.</source>
          <target state="translated">ArrayListはAbstractListを継承し、Listインタフェースを実装しています。ArrayListは動的配列です。</target>
        </trans-unit>
        <trans-unit id="437431a42628c440c8c8ddba7824d9ba269abd04" translate="yes" xml:space="preserve">
          <source>ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.</source>
          <target state="translated">ArrayListは、パフォーマンスの意味するところがスループットであり、レイテンシを無視できるのであれば、パフォーマンスのためにはより良い選択となります。私の仕事の経験上、最悪の場合のレイテンシを無視することはできません。</target>
        </trans-unit>
        <trans-unit id="1913d3898d20247f47f9e0c995812cdb4b8d08d7" translate="yes" xml:space="preserve">
          <source>ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList is faster than doing n iterations with LinkedList.</source>
          <target state="translated">ArrayListは、次のノードへのポインタを使用するLinkedListに比べて、連続したメモリアドレスを使用します。そのため、ArrayListの中の要素を探したいときには、LinkedListでn回繰り返すよりも、ArrayListの方が高速です。</target>
        </trans-unit>
        <trans-unit id="d9b713914a6a1ace02a2eecb0047e6799c67666f" translate="yes" xml:space="preserve">
          <source>ArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.</source>
          <target state="translated">ArrayListsは多読やアペンダーなどの書き込みには向いていますが、前や真ん中からの追記は苦手です。</target>
        </trans-unit>
        <trans-unit id="459e94cfdff5088a8182f4ad9a0d304b933bf06b" translate="yes" xml:space="preserve">
          <source>As explained above the insert and remove operations give good performance &lt;code&gt;(O(1))&lt;/code&gt; in &lt;code&gt;LinkedList&lt;/code&gt; compared to &lt;code&gt;ArrayList(O(n))&lt;/code&gt;.</source>
          <target state="translated">上記で説明したように、挿入操作と削除操作は、 &lt;code&gt;ArrayList(O(n))&lt;/code&gt; と比較して &lt;code&gt;LinkedList&lt;/code&gt; で良好なパフォーマンス &lt;code&gt;(O(1))&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="5bafe9e2667a408bbc28c0a3d0896d45d6514421" translate="yes" xml:space="preserve">
          <source>As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.</source>
          <target state="translated">ArrayListとしては、少なくともあなたは常に可能な限り配列の重複を最小限に抑えるために、初期容量のコンストラクタを使用するべきであることに同意します。</target>
        </trans-unit>
        <trans-unit id="41b881749d840dd577c03a0d047dddf4b9b4432c" translate="yes" xml:space="preserve">
          <source>As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.</source>
          <target state="translated">大規模なSOAウェブサービスの運用パフォーマンスエンジニアリングを10年ほど行ってきた者としては、ArrayListよりもLinkedListの挙動の方が良いと思います。LinkedList の定常状態のスループットは悪化しているため、ハードウェアの買い増しにつながるかもしれませんが、プレッシャーがかかっているときの ArrayList の挙動は、クラスタ内のアプリが同期に近い状態でアレイを拡張することにつながり、大きなアレイサイズの場合はアプリの応答性の欠如や、プレッシャーがかかっているときの停止につながる可能性があり、これは破滅的な挙動です。</target>
        </trans-unit>
        <trans-unit id="7cc15a8cb6e4f67393413b50f7e19ba95f084ea2" translate="yes" xml:space="preserve">
          <source>As with standard linked list and array operations, the various methods will have different algorithmic runtimes.</source>
          <target state="translated">標準的なリンクされたリストや配列操作と同様に、さまざまな方法でアルゴリズムの実行時間が異なります。</target>
        </trans-unit>
        <trans-unit id="17f7102d3affee7b74333eccc3786b17d7b95f92" translate="yes" xml:space="preserve">
          <source>Based on these you have to decide what to choose. :)</source>
          <target state="translated">これらを踏まえて、何を選ぶかを決める必要があります。)</target>
        </trans-unit>
        <trans-unit id="f4ba92067d77f8ad1cdde8d5185b8e7ead37b68b" translate="yes" xml:space="preserve">
          <source>Below is the unit test result for each operation.Timing is given in Nanoseconds.</source>
          <target state="translated">以下に各動作の単位試験結果を示します。</target>
        </trans-unit>
        <trans-unit id="7f46f0e6a343f897fd8216fe946eeff647289350" translate="yes" xml:space="preserve">
          <source>Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Let's say we want to go through the entire List removing and inserting elements on our way. Usually, you would start from the very beginning for each element using the LinkedList, we could also &quot;save&quot; the current element we're working on with an Iterator. With the help of the Iterator, we get an O(1) efficiency for remove() and insert() when working in a LinkedList. Making it the only performance benefit I'm aware of where a LinkedList is always better than an ArrayList.</source>
          <target state="translated">ボーナス:ArrayListではこれら2つのメソッドをO(1)にする方法はありませんが、LinkedListsでは実際にこれを行う方法があります。例えば、リスト全体の要素を削除したり挿入したりしながら、リスト全体を見ていきたいとしましょう。通常は、LinkedList を使用して各要素の最初から始めることになりますが、Iterator を使用して現在作業中の要素を「保存」することもできます。イテレータの助けを借りて、LinkedList で作業する際の remove()と insert()の効率は O(1)になりました。これが、LinkedList が常に ArrayList よりも優れている唯一のパフォーマンス上の利点となっています。</target>
        </trans-unit>
        <trans-unit id="f37c5042d81ce8b4bbe2d96a4545bbab34eb146f" translate="yes" xml:space="preserve">
          <source>Both ArrayList and LinkedList are implementation of List interface.</source>
          <target state="translated">ArrayListもLinkedListもListインターフェースの実装です。</target>
        </trans-unit>
        <trans-unit id="71f1ed7fc912117c5c42591efe3f6f8fa7782142" translate="yes" xml:space="preserve">
          <source>Both remove() and insert() have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However, the reason behind the linear processing time comes from two very different reasons:</source>
          <target state="translated">remove()とinsert()は、ArrayListsとLinkedListsの両方でO(n)の実行効率を持っています。しかし、直線的な処理時間の理由は、2つの全く異なる理由から来ています。</target>
        </trans-unit>
        <trans-unit id="daf0773dc6de1ad67b93748501d5e5e954fbb69d" translate="yes" xml:space="preserve">
          <source>Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.</source>
          <target state="translated">これらのクラスはどちらも非同期化されており、Collections.synchronizedListメソッドを使用して明示的に同期化することができます。</target>
        </trans-unit>
        <trans-unit id="de704239e812c1c915cb01038eee251cbcaf16df" translate="yes" xml:space="preserve">
          <source>Conclusion: LinkedList element deletion is faster compared to
  ArrayList.</source>
          <target state="translated">結論。LinkedListの要素削除はArrayListに比べて高速である。</target>
        </trans-unit>
        <trans-unit id="f180d58cc543a593a06f0503cdd233ebc9c5759c" translate="yes" xml:space="preserve">
          <source>Copying a sequential bulk of memory is an operation optimized by the modern CPUs - changing theory and actually making, again, &lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;Vector&lt;/code&gt; much more efficient</source>
          <target state="translated">メモリのシーケンシャルバルクのコピーは、最新のCPUによって最適化された操作です-理論を変更し、実際には、 &lt;code&gt;ArrayList&lt;/code&gt; / &lt;code&gt;Vector&lt;/code&gt; をはるかに効率的にします</target>
        </trans-unit>
        <trans-unit id="1f74715932ed85186b45cbf00a18b0aa012ba91d" translate="yes" xml:space="preserve">
          <source>Correct or Incorrect: Please execute test locally and decide for yourself!</source>
          <target state="translated">正解か不正解か ローカルでテストを実行して、ご自身で判断してください</target>
        </trans-unit>
        <trans-unit id="78ddc4712fca5a2025e62dc663ca11c5d278f6c7" translate="yes" xml:space="preserve">
          <source>Credits: All benchmarks posted here are created by &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt;. Even more data can be found on &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;his blog&lt;/a&gt;</source>
          <target state="translated">クレジット：ここに掲載されているすべてのベンチマークは、 &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;KjellHedstr&amp;ouml;m&lt;/a&gt;が作成したものです 。 &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;彼のブログ&lt;/a&gt;でさらに多くのデータを見つけることができます</target>
        </trans-unit>
        <trans-unit id="779504bb746658eb51a895ef325a2c35e22145fa" translate="yes" xml:space="preserve">
          <source>Does anyone actually use LinkedList?  I wrote it, and I never use it.</source>
          <target state="translated">LinkedListを実際に使っている人はいますか?書いたけど、私は絶対に使わない。</target>
        </trans-unit>
        <trans-unit id="c5b4ee91f9f7d7536fb951869ce3310ca5d5e5c8" translate="yes" xml:space="preserve">
          <source>Edit/Remove is faster in &lt;code&gt;LinkedList&lt;/code&gt; than &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の方が &lt;code&gt;ArrayList&lt;/code&gt; よりも編集/削除の方が高速です 。</target>
        </trans-unit>
        <trans-unit id="aa4bd4d47e6eb0dd8326522867ae2cebb9d911a9" translate="yes" xml:space="preserve">
          <source>Even when big-O performance is the same as &lt;code&gt;ArrayList&lt;/code&gt;, it is probably going to be significantly slower anyway.</source>
          <target state="translated">big-Oのパフォーマンスが &lt;code&gt;ArrayList&lt;/code&gt; と同じである場合でも、とにかくかなり遅くなるでしょう。</target>
        </trans-unit>
        <trans-unit id="a717e212f108315f6468fbbac65115039dbc3186" translate="yes" xml:space="preserve">
          <source>Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.</source>
          <target state="translated">DBから取得したデータのリストを返すメソッドがあるたびに、いつもLinkedListを使っていました。</target>
        </trans-unit>
        <trans-unit id="d98c1a4ef5e0db31dd47ee47986d318181c0c1aa" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85cdf2bee1991274487c8b867c3e971ab9c35e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e02d61f3770600b7462828f335d485c3c7c88fd7" translate="yes" xml:space="preserve">
          <source>From all the above differences between ArrayList vs LinkedList, It looks ArrayList is the better choice than LinkedList in almost all cases, except when you do a frequent add() operation than remove(), or get().</source>
          <target state="translated">ArrayListとLinkedListの間の上記のすべての違いから、それはほとんどすべてのケースでLinkedListよりもArrayListの方が良い選択であるように見えますが、それはあなたが削除()または取得()よりも頻繁にadd()操作を行う場合を除いて。</target>
        </trans-unit>
        <trans-unit id="ecc2eafc3ac7b3d6cdad7d496b20ef438cc7c71b" translate="yes" xml:space="preserve">
          <source>Getting good performance is tricky.</source>
          <target state="translated">良いパフォーマンスを得るのは難しい。</target>
        </trans-unit>
        <trans-unit id="d872e08fee24bf8c30e8defc229caebca0ba87ad" translate="yes" xml:space="preserve">
          <source>Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.</source>
          <target state="translated">したがって、アプリケーションで頻繁に追加と削除の要件がある場合は、LinkedListは最良の選択です。</target>
        </trans-unit>
        <trans-unit id="05cae6319d9059efe74860e4a0c6f790d26f64fc" translate="yes" xml:space="preserve">
          <source>Here are results of a benchmark testing inserting elements in random locations. As you can see - the array list if much more efficient, although in theory each insert in the middle of the list will require &quot;move&quot; the &lt;em&gt;n&lt;/em&gt; later elements of the array (lower values are better):</source>
          <target state="translated">以下は、ランダムな場所に要素を挿入するベンチマークテストの結果です。 ご覧のとおり-配列リストの方がはるかに効率的ですが、理論的にはリストの中央に挿入するたびに、配列の&lt;em&gt;n個&lt;/em&gt;後の要素を「移動」する必要があります（値が小さいほど優れています）。</target>
        </trans-unit>
        <trans-unit id="4231cb0b09e1f7b1f49c5e13010868f22f729203" translate="yes" xml:space="preserve">
          <source>Here is a figure from &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; (&lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):</source>
          <target state="translated">これは、 &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt;からの図です （ &lt;code&gt;add&lt;/code&gt; と &lt;code&gt;remove&lt;/code&gt; は最初のタイプです。つまり、リストの最後に要素を追加し、リストの指定された位置にある要素を削除します）。</target>
        </trans-unit>
        <trans-unit id="72459064f382e49943817106fc4f16a28f18d010" translate="yes" xml:space="preserve">
          <source>Here is the Big-O notation in both &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; and also &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; と &lt;code&gt;LinkedList&lt;/code&gt; の両方のBig-O表記と、 &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt; は次のとおりです 。</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">これがコードだ</target>
        </trans-unit>
        <trans-unit id="204bd2319ad6f28782c2fd4eac0f1c63e947287c" translate="yes" xml:space="preserve">
          <source>I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:</source>
          <target state="translated">回答を読ませていただきましたが、意見を聞くために共有したいArrayListよりもLinkedListをいつも使っているシナリオがあります。</target>
        </trans-unit>
        <trans-unit id="2909da23de10e510a463c3326c00b280592d1c12" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I honestly can't believe nobody mentioned that &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Deque&lt;/code&gt;.  Just look at the methods in &lt;code&gt;Deque&lt;/code&gt; (and &lt;code&gt;Queue&lt;/code&gt;); if you want a fair comparison, try running &lt;code&gt;LinkedList&lt;/code&gt; against &lt;code&gt;ArrayDeque&lt;/code&gt; and do a feature-for-feature comparison.</source>
          <target state="translated">私はこれが古い投稿であることを知っていますが、 &lt;code&gt;LinkedList&lt;/code&gt; が &lt;code&gt;Deque&lt;/code&gt; を実装していると誰も言っていないのは正直信じられません。 &lt;code&gt;Deque&lt;/code&gt; （および &lt;code&gt;Queue&lt;/code&gt; ）のメソッドを見てください。 公平な比較が必要な場合は、 &lt;code&gt;LinkedList&lt;/code&gt; に対して &lt;code&gt;ArrayDeque&lt;/code&gt; を実行して、機能ごとの比較を行ってください。</target>
        </trans-unit>
        <trans-unit id="f0b70ff5fa7c09103b8eab96c986f91401d87676" translate="yes" xml:space="preserve">
          <source>I use the interface as the type name for &lt;em&gt;portability&lt;/em&gt;, so that when I ask questions such as these I can rework my code.</source>
          <target state="translated">&lt;em&gt;移植性&lt;/em&gt;のタイプ名としてインターフェースを使用しているので、このような質問をしたときにコードを書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="c1dae44cf928d176bc4a73ed2740108af2b90993" translate="yes" xml:space="preserve">
          <source>I usually use one over the other based on the time complexities of the operations that I'd perform on that particular List.</source>
          <target state="translated">私は通常、そのリストで行う操作の時間的な複雑さに基づいて1つを使い分けています。</target>
        </trans-unit>
        <trans-unit id="6102d6038b559d5fad73832038782bbb5796e2a3" translate="yes" xml:space="preserve">
          <source>I'm sorry for the answer for being not that informative as the other answers, but I thought it would be the most interesting and self-explanatory.</source>
          <target state="translated">他の回答と比べてもそこまで参考にならない回答で申し訳ないのですが、自分なりに一番面白いと思った回答でした。</target>
        </trans-unit>
        <trans-unit id="a4a379c9c8db61dd6b7c09706346097b32a64868" translate="yes" xml:space="preserve">
          <source>I've always been one to simply use:</source>
          <target state="translated">私は昔からシンプルに使うことが多いです。</target>
        </trans-unit>
        <trans-unit id="eb6b619bb59e99c5145eebdb33b065006bef1e99" translate="yes" xml:space="preserve">
          <source>If Array is large enough it may take a lot of memory at that point and trigger Garbage collection, which can slow response time.</source>
          <target state="translated">Arrayが大きいと、その時点でメモリを大量に消費してしまい、ガーベッジコレクションを誘発してしまい、応答速度が遅くなってしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="559de205fa8eb76d7699b1783f2b0ac89bcc4d52" translate="yes" xml:space="preserve">
          <source>If the constructor  is not overloaded, then &lt;em&gt;ArrayList&lt;/em&gt; creates an empty list of initial capacity 10, while</source>
          <target state="translated">コンストラクターがオーバーロードされていない場合、 &lt;em&gt;ArrayList&lt;/em&gt;は初期容量10の空のリストを作成しますが、</target>
        </trans-unit>
        <trans-unit id="c0e9fb39f596736adacc32d734e4edfa0a46ec4b" translate="yes" xml:space="preserve">
          <source>If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList.</source>
          <target state="translated">アプリ内で検索操作を頻繁に行う場合は、ArrayListを使用します。挿入や削除を頻繁に行う場合は、LinkedListを使用します。</target>
        </trans-unit>
        <trans-unit id="aaba92fb463b8690a69e81dfffc7a5658f1bd75e" translate="yes" xml:space="preserve">
          <source>If your code has &lt;code&gt;add(0)&lt;/code&gt; and &lt;code&gt;remove(0)&lt;/code&gt;, use a &lt;code&gt;LinkedList&lt;/code&gt; and it's prettier &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;removeFirst()&lt;/code&gt; methods. Otherwise, use &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">コードに &lt;code&gt;add(0)&lt;/code&gt; と &lt;code&gt;remove(0)&lt;/code&gt; がある場合は、 &lt;code&gt;LinkedList&lt;/code&gt; を使用すると、 addFirst &lt;code&gt;removeFirst()&lt;/code&gt; メソッドとremoveFirst（）メソッドがより &lt;code&gt;addFirst()&lt;/code&gt; なります 。 それ以外の場合は、 &lt;code&gt;ArrayList&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c5ab91dd60a4bdc4332a1f000c5a31d8298e3443" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;ArrayList&lt;/em&gt;  each index only holds the actual object(data).</source>
          <target state="translated">&lt;em&gt;ArrayListでは、&lt;/em&gt;各インデックスは実際のオブジェクト（データ）のみを保持します。</target>
        </trans-unit>
        <trans-unit id="4e651e52f60a7d33d19241c9b84a7e5ebf5e0d7c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;LinkedList&lt;/em&gt;, there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1). The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as a parameter. This method traverses the LinkedList until it found the Object and unlink it from the original list. Hence this method runtime is O(n).</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt;には、2つのオーバーロードされた削除メソッドがあります。 1つはパラメーターのないremove（）で、リストの先頭を削除し、一定時間O（1）で実行されます。 LinkedListの他のオーバーロードされたremoveメソッドは、パラメーターとして渡されたObjectまたはintを削除するremove（int）またはremove（Object）です。 このメソッドは、オブジェクトが見つかるまでLinkedListを走査し、元のリストからリンクを解除します。 したがって、このメソッドのランタイムはO（n）です。</target>
        </trans-unit>
        <trans-unit id="4035507a1bd4880689b50032e852bc42590238de" translate="yes" xml:space="preserve">
          <source>In a LinkedList, it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for remove() and 2 references for insert().</source>
          <target state="translated">LinkedListでは、実際に目的の要素に到達するまでにはO(n)が必要です。実際に削除や挿入を行う際には、remove()で 1 つの参照を、insert()で 2 つの参照を変更するだけなので、一定です。</target>
        </trans-unit>
        <trans-unit id="6d3d827792739e9f193e4b6dedde2b63bd92348f" translate="yes" xml:space="preserve">
          <source>In addition to the other good arguments above, you should notice &lt;code&gt;ArrayList&lt;/code&gt; implements &lt;code&gt;RandomAccess&lt;/code&gt; interface, while &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Queue&lt;/code&gt;.</source>
          <target state="translated">上記の他の適切な引数に加えて、 &lt;code&gt;LinkedList&lt;/code&gt; が &lt;code&gt;Queue&lt;/code&gt; を実装するのに対して、 &lt;code&gt;ArrayList&lt;/code&gt; は &lt;code&gt;RandomAccess&lt;/code&gt; インターフェースを実装していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="35842b5d82e361cdd7f51df865bca0c300db2026" translate="yes" xml:space="preserve">
          <source>In an ArrayList, you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.</source>
          <target state="translated">ArrayListでは、O(1)で要素にたどり着きますが、実際に何かを削除したり挿入したりすると、それに続くすべての要素を変更する必要があるため、O(n)になってしまいます。</target>
        </trans-unit>
        <trans-unit id="e8946d8d5170bc375bf87f8b5c440661d618b2c2" translate="yes" xml:space="preserve">
          <source>In arraylist</source>
          <target state="translated">アレイリストでは</target>
        </trans-unit>
        <trans-unit id="4a8bb3c134e78f4fa8de3dd3133fe5675a10a71e" translate="yes" xml:space="preserve">
          <source>In my opinion, use ArrayList over LinkedList for most of the practical purpose in Java.</source>
          <target state="translated">私の考えでは、JavaではLinkedListよりもArrayListを使った方が実用的だと思います。</target>
        </trans-unit>
        <trans-unit id="60daaf72544dd78c2fbc88ad20ed774a9a6e7cea" translate="yes" xml:space="preserve">
          <source>In order to remove an element from a particular index e.g. by calling remove(index), ArrayList performs a copy operation which makes it close to O(n) while LinkedList needs to traverse to that point which also makes it O(n/2), as it can traverse from either direction based upon proximity.</source>
          <target state="translated">remove(index)を呼び出して特定のインデックスから要素を削除するためには、ArrayListはO(n)に近いO(n)になるようにコピー操作を行い、LinkedListは近接性に基づいてどちらの方向からもトラバースすることができるので、その点までトラバースする必要があります。</target>
        </trans-unit>
        <trans-unit id="13af662866647dd21beac5b84de614ccdd269669" translate="yes" xml:space="preserve">
          <source>In other words, you don't need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes O(n) operation. For example, inserting or deleting an element in the middle of a linked list.</source>
          <target state="translated">つまり、要素を追加したい位置までリンクされたリストを辿る必要がなく、その場合、追加はO(n)演算になります。例えば、リンクされたリストの途中で要素を挿入したり削除したりする場合です。</target>
        </trans-unit>
        <trans-unit id="469c98ead6182a42fb433736049690f3bc9751a6" translate="yes" xml:space="preserve">
          <source>In theory, LinkedList has an O(1) for the &lt;code&gt;add(E element)&lt;/code&gt;</source>
          <target state="translated">理論的には、LinkedListには &lt;code&gt;add(E element)&lt;/code&gt; O（1）があります。</target>
        </trans-unit>
        <trans-unit id="8c381b0a433efc57cbfa3356f3a84f33fb983fb0" translate="yes" xml:space="preserve">
          <source>Insertions in &lt;em&gt;LinkedList&lt;/em&gt; are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation .</source>
          <target state="translated">&lt;em&gt;LinkedListへの&lt;/em&gt;挿入は、ArrayListに比べて一般的に高速です。 LinkedListでは、追加または挿入はO（1）操作です。</target>
        </trans-unit>
        <trans-unit id="c767ed4fab63fed391201351f4e44d98a283934b" translate="yes" xml:space="preserve">
          <source>It can be said that it was basically created to overcome the drawbacks of arrays</source>
          <target state="translated">基本的には配列の欠点を克服するために作られたと言えます。</target>
        </trans-unit>
        <trans-unit id="67433abb43ee77013dd1057bd5c859af9a33433f" translate="yes" xml:space="preserve">
          <source>It depends upon what operations you will be doing more on the List.</source>
          <target state="translated">それは、あなたがリスト上でより多くの操作を行うかどうかに依存しています。</target>
        </trans-unit>
        <trans-unit id="23b28df1a3e51ae95f5d0a5b0aa39bb036813e19" translate="yes" xml:space="preserve">
          <source>It uses lots of small memory objects, and therefore impacts performance across the process.</source>
          <target state="translated">小さなメモリ・オブジェクトを大量に使用するため、プロセス全体のパフォーマンスに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="8809d3c8954d5fee422f743b686ee6e92e9dc70a" translate="yes" xml:space="preserve">
          <source>It's an efficiency question. &lt;code&gt;LinkedList&lt;/code&gt; is fast for adding and deleting elements, but slow to access a specific element. &lt;code&gt;ArrayList&lt;/code&gt; is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.</source>
          <target state="translated">効率の問題です。 &lt;code&gt;LinkedList&lt;/code&gt; は要素の追加と削除には高速ですが、特定の要素へのアクセスには時間がかかります。 &lt;code&gt;ArrayList&lt;/code&gt; は特定の要素へのアクセスは高速ですが、どちらかの端に追加するのが遅く、特に途中で削除するのが遅くなる場合があります。</target>
        </trans-unit>
        <trans-unit id="4b15e68efa8079d20e58d4612e98609845672742" translate="yes" xml:space="preserve">
          <source>It's easier to modify a linked list than ArrayList, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in O(1) time.</source>
          <target state="translated">リンクされたリストは内部的にそれらの位置の参照を保持しており、O(1)時間でアクセス可能なので、リンクされたリストを変更するのはArrayListよりも簡単です。</target>
        </trans-unit>
        <trans-unit id="adc8d1e49ddd7e5e06471d7adc23a73d72dc8d87" translate="yes" xml:space="preserve">
          <source>It's jarring to see &lt;code&gt;LinkedList&lt;/code&gt; in source because it is probably the wrong choice.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; をソースに表示するのは、おそらく間違った選択であるため、 耳障りです。</target>
        </trans-unit>
        <trans-unit id="6e438c304d6715de1cd8a3be3097d2b636828262" translate="yes" xml:space="preserve">
          <source>Iteration is the O(n) operation for both LinkedList and ArrayList where n is a number of an element.</source>
          <target state="translated">イテレーションは LinkedList と ArrayList の両方において O(n)の演算であり、n は要素の数です。</target>
        </trans-unit>
        <trans-unit id="196cfc0783541b18906b878964f90c2beb521995" translate="yes" xml:space="preserve">
          <source>Joshua Bloch, the author of LinkedList:</source>
          <target state="translated">LinkedListの著者であるJoshua Bloch氏。</target>
        </trans-unit>
        <trans-unit id="b6bf53be71cb03cefc9204127bcad931b18969a2" translate="yes" xml:space="preserve">
          <source>Just to make the point even clearer, please check the benchmark of adding elements to the beginning of the list. This is a use-case where, in-theory, the &lt;code&gt;LinkedList&lt;/code&gt; should really shine, and &lt;code&gt;ArrayList&lt;/code&gt; should present poor or even worse-case results:</source>
          <target state="translated">ポイントをより明確にするために、リストの最初に要素を追加するベンチマークを確認してください。 これは、理論的には &lt;code&gt;LinkedList&lt;/code&gt; が本当に輝き、 &lt;code&gt;ArrayList&lt;/code&gt; が不十分またはさらに悪い場合の結果を示すはずのユースケースです。</target>
        </trans-unit>
        <trans-unit id="1f2e1c89c968aef7dc16623190b3a9a9cabbc8b4" translate="yes" xml:space="preserve">
          <source>Let's compare LinkedList and ArrayList w.r.t. below parameters:</source>
          <target state="translated">LinkedListとArrayListを以下のパラメータで比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="93306f9c4f0e542bbb9a628ab7325be853345914" translate="yes" xml:space="preserve">
          <source>Link: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</source>
          <target state="translated">リンク： &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https&lt;/a&gt; : //twitter.com/joshbloch/status/583813919019573248</target>
        </trans-unit>
        <trans-unit id="a422cc360ccdd0ef7b3dda2d174720a459804d83" translate="yes" xml:space="preserve">
          <source>LinkedList is &lt;em&gt;almost always&lt;/em&gt; the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList's ability to insert and delete elements in the middle of the list relatively quickly, once you've navigated there with a ListIterator.</source>
          <target state="translated">LinkedListは、 &lt;em&gt;ほとんどの場合&lt;/em&gt; 、パフォーマンスの点で間違った選択です。 LinkedListが要求される非常に特殊なアルゴリズムがいくつかありますが、それらは非常にまれであり、アルゴリズムは通常、リストの中央にある要素を比較的迅速に挿入および削除するLinkedListの機能に特に依存します。 ListIteratorを使用します。</target>
        </trans-unit>
        <trans-unit id="10b1b645b01085ffebf0f6f3f088eea7172b5aa1" translate="yes" xml:space="preserve">
          <source>LinkedList takes much more time to accomplish the same job. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">LinkedListが同じ作業を完了するには、さらに時間がかかります。 &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;ソース&lt;/a&gt; &lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;ソースコード&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f79cef427b354d9b9780eab17c5d356d4a5b006e" translate="yes" xml:space="preserve">
          <source>LinkedList uses a wrapper object, Entry, which is a static nested class for storing data and two nodes next and previous while ArrayList just stores data in Array.</source>
          <target state="translated">LinkedListではラッパーオブジェクトであるEntryを使用していますが、ArrayListではArrayにデータを格納するだけです。</target>
        </trans-unit>
        <trans-unit id="7e1c7bcef7896ae52260cfcb6d33ba65b28b0065" translate="yes" xml:space="preserve">
          <source>Lots of small objects are bad for cache-locality.</source>
          <target state="translated">小さなオブジェクトが多いとキャッシュの局所性が悪くなります。</target>
        </trans-unit>
        <trans-unit id="d1ac372c327cce8ede5e07a803bfe591166259d1" translate="yes" xml:space="preserve">
          <source>Memory overhead in &lt;em&gt;LinkedList&lt;/em&gt; is more as compared to ArrayList as a node in LinkedList needs to maintain the addresses of the next and previous node. While</source>
          <target state="translated">&lt;em&gt;LinkedListの&lt;/em&gt;ノードは次のノードと前のノードのアドレスを維持する必要があるため、 &lt;em&gt;LinkedListの&lt;/em&gt;メモリオーバーヘッドはArrayListに比べて多くなります。 ながら</target>
        </trans-unit>
        <trans-unit id="e5657da09258adb4a01a06b7e549b6f276681445" translate="yes" xml:space="preserve">
          <source>My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.</source>
          <target state="translated">私の理論的根拠は、それは私が取得している正確にどのように多くの結果を知ることは不可能であるため、(容量と実際の要素数の違いを持つArrayListのように)無駄なメモリがないだろうし、容量を複製しようとする無駄な時間がないだろうということでした。</target>
        </trans-unit>
        <trans-unit id="d7c000eee7e0c05260bee34ed1a23873f4661337" translate="yes" xml:space="preserve">
          <source>Note: this is a benchmark of the C++ Std lib, but my previous experience shown the C++ and Java results are very similar. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">注：これはC ++ Std libのベンチマークですが、以前の経験では、C ++とJavaの結果は非常によく似ています。 &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;ソースコード&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="43117d0643c36e2f29277032a262d30828a4ea76" translate="yes" xml:space="preserve">
          <source>O(n) worst, O(1) amortized</source>
          <target state="translated">O(n)ワースト、O(1)償却</target>
        </trans-unit>
        <trans-unit id="2613d66d9e3e9d1d2cb152a0c8c768f97ed252f6" translate="yes" xml:space="preserve">
          <source>On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.</source>
          <target state="translated">一方、LinkedListではポインタを変更するだけなので、挿入や削除が非常に簡単ですが、ArrayListでは挿入や削除にシフト操作が必要になります。</target>
        </trans-unit>
        <trans-unit id="33a2811cec1cd04c38e25706ff20270bb3aa420c" translate="yes" xml:space="preserve">
          <source>One of the tests I saw on here only conducts the test once.  But what I have noticed is that you need to run these tests many times and eventually their times will converge.  Basically the JVM needs to warm up.  For my particular use case I needed to add/remove items to a list that grows to about 500 items.  In my tests &lt;code&gt;LinkedList&lt;/code&gt; came out faster, with &lt;code&gt;LinkedList&lt;/code&gt; coming in around 50,000 NS and &lt;code&gt;ArrayList&lt;/code&gt; coming in at around 90,000 NS... give or take.  See the code below.</source>
          <target state="translated">ここで見たテストの1つは、テストを1回だけ実行します。 しかし、私が気づいたのは、これらのテストを何度も実行する必要があり、最終的にはそれらの時間が収束することです。 基本的に、JVMはウォームアップする必要があります。 私の特定のユースケースでは、約500アイテムに増えるリストにアイテムを追加/削除する必要がありました。 私のテストでは、 &lt;code&gt;LinkedList&lt;/code&gt; の方が速く出ており、 &lt;code&gt;LinkedList&lt;/code&gt; は約50,000 NS、 &lt;code&gt;ArrayList&lt;/code&gt; は約90,000 NSでした。 以下のコードを参照してください。</target>
        </trans-unit>
        <trans-unit id="65dac500e2d3e9f09ada76f29721043fd8c863b6" translate="yes" xml:space="preserve">
          <source>Operation get(i) in ArrayList is faster than LinkedList, because:</source>
          <target state="translated">ArrayListのget(i)はLinkedListよりも高速です。</target>
        </trans-unit>
        <trans-unit id="0a5c295d42604c7d58d32363d3f4396711e52d07" translate="yes" xml:space="preserve">
          <source>Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</source>
          <target state="translated">リストにインデックスを付ける操作は、指定されたインデックスに近い方の先頭または末尾からリストを辿ります。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b3bfed3bf17cc4ccb5b52051ae69c0e7857b3e8" translate="yes" xml:space="preserve">
          <source>Practice is very different, as LinkedList is a &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data structure. From performance POV - there are very little cases where &lt;code&gt;LinkedList&lt;/code&gt; could be better performing than the &lt;em&gt;Cache-friendly&lt;/em&gt;&lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">LinkedListは悪意のあるデータの&lt;strong&gt;キャッシュ&lt;/strong&gt;構造であるため、実際は非常に異なります。 パフォーマンスPOVから &lt;code&gt;LinkedList&lt;/code&gt; が&lt;em&gt;キャッシュフレンドリーな&lt;/em&gt; &lt;code&gt;ArrayList&lt;/code&gt; よりも優れている場合はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="cca9612e17514e1ec64192796cfa4e74465f72b1" translate="yes" xml:space="preserve">
          <source>Reason: LinkedList&amp;rsquo;s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.</source>
          <target state="translated">理由：LinkedListの各要素は、リスト内の両方の隣接要素を指す2つのポインター（アドレス）を保持しています。 したがって、削除する必要があるのは、削除するノードの2つの隣接ノード（要素）のポインター位置を変更することだけです。 ArrayListでは、削除された要素によって作成されたスペースを埋めるために、すべての要素をシフトする必要があります。</target>
        </trans-unit>
        <trans-unit id="f68c820e0a45856c839ded9a5dcddfe8ab72ecae" translate="yes" xml:space="preserve">
          <source>Remove operation in LinkedList is generally the same as ArrayList i.e. O(n).</source>
          <target state="translated">LinkedList の削除操作は、ArrayList と同様に O(n)です。</target>
        </trans-unit>
        <trans-unit id="73ae9a70388443373dde5d5fe2540131469bd3ca" translate="yes" xml:space="preserve">
          <source>Search (&lt;code&gt;get method&lt;/code&gt;) operations are fast in &lt;code&gt;Arraylist (O(1))&lt;/code&gt; but not in &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Arraylist (O(1))&lt;/code&gt; では検索（ &lt;code&gt;get method&lt;/code&gt; ）操作は高速ですが、 &lt;code&gt;LinkedList (O(n))&lt;/code&gt; 高速ではありません</target>
        </trans-unit>
        <trans-unit id="beb9ed0bbc3bb6fd7e6c2e425c684fb4a813730a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;the Java Tutorials - List Implementations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;Javaチュートリアル-リスト実装を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8f41eea01e67c4b4218cd4f1b61ae00436827205" translate="yes" xml:space="preserve">
          <source>Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.</source>
          <target state="translated">同様に、デフォルトのスループットのテナントガベージコレクタからアプリのスループットを向上させることができますが、10GBのヒープを持つjavaアプリを取得すると、フルGC中に25秒間アプリをロックすることになり、SOAアプリでタイムアウトや障害が発生し、それが頻繁に発生するとSLAを吹き飛ばすことになります。CMSコレクターは、より多くのリソースを必要とし、同じ生のスループットを達成していないにもかかわらず、より予測可能でレイテンシが小さいので、CMSコレクターははるかに良い選択です。</target>
        </trans-unit>
        <trans-unit id="c7f07cd9a6f95a46d6ba5320ac3e54b3e0920e1e" translate="yes" xml:space="preserve">
          <source>Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit &lt;code&gt;LinkedLists&lt;/code&gt; and &lt;code&gt;ArrayLists&lt;/code&gt;.</source>
          <target state="translated">相対システムでは参照が32ビットまたは64ビット（nullの場合でも）であるため、32ビットおよび64ビットの &lt;code&gt;LinkedLists&lt;/code&gt; および &lt;code&gt;ArrayLists&lt;/code&gt; の 4セットのデータを含めました。</target>
        </trans-unit>
        <trans-unit id="69eebcd50b0954ecfc33ccabe9d8b7d4f9117ee9" translate="yes" xml:space="preserve">
          <source>So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an &lt;code&gt;ArrayList&lt;/code&gt; is technically faster, but unless you're doing something really performance-sensitive, you shouldn't worry about this -- they're both constants.)</source>
          <target state="translated">したがって、実行する操作に応じて、実装を適宜選択する必要があります。 どちらの種類のリストの繰り返し処理も、実質的に同等に安価です。 （ &lt;code&gt;ArrayList&lt;/code&gt; を反復処理することは技術的には高速ですが、本当にパフォーマンスに敏感なことをしているのでない限り、これについて心配する必要はありません。どちらも定数です。）</target>
        </trans-unit>
        <trans-unit id="9d8873955ed68a6d3afa3fc542ef7842e5776761" translate="yes" xml:space="preserve">
          <source>So memory requirement seems less in the case of ArrayList than LinkedList except for the case where Array performs the re-size operation when it copies content from one Array to another.</source>
          <target state="translated">そのため、ArrayList の場合は、ある Array から別の Array に内容をコピーする際にリサイズ操作を行う場合を除いて、LinkedList よりもメモリの必要量が少ないように思われる。</target>
        </trans-unit>
        <trans-unit id="d29bcb90791eb28700c5ec8a4791f07074a61ec0" translate="yes" xml:space="preserve">
          <source>So, somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).</source>
          <target state="translated">だから、どういうわけか、彼らは効率と行動の違い(彼らのメソッドのリストを参照してください)で、少し異なる問題に対処しています。</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="2723794bb959da323543cd3bc1ef514d3209ea99" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;</source>
          <target state="translated">出典： &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;すべてのプログラマーが知っておくべき待ち時間の数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12d5ff1ccac20df183eacef481ad79a3b1d74a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; is pretty clear. O(1) for &lt;code&gt;ArrayList&lt;/code&gt;, because &lt;code&gt;ArrayList&lt;/code&gt; allow random access by using index. O(n) for &lt;code&gt;LinkedList&lt;/code&gt;, because it needs to find the index first. Note: there are different versions of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; はかなり明確です。 &lt;code&gt;ArrayList&lt;/code&gt; の O（1）。これは、 ArrayListがインデックスを使用してランダムアクセスを許可するため &lt;code&gt;ArrayList&lt;/code&gt; 。 最初にインデックスを見つける必要があるため、 &lt;code&gt;LinkedList&lt;/code&gt; の O（n）。 注： &lt;code&gt;add&lt;/code&gt; と &lt;code&gt;remove&lt;/code&gt; にはさまざまなバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="6f4576a7bc64b7bfc1b683a9a061390ec3813c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; returned by these classes are &lt;code&gt;fail-fast&lt;/code&gt; (if list is structurally modified at any time after the iterator is created, in any way except through the &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; own remove or add methods, the iterator will &lt;code&gt;throw&lt;/code&gt; a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;).</source>
          <target state="translated">これらのクラスによって返される &lt;code&gt;iterator&lt;/code&gt; と &lt;code&gt;listIterator&lt;/code&gt; は &lt;code&gt;fail-fast&lt;/code&gt; （イテレーターが作成された後、リストが構造的にいつでも変更された場合、 &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; 自体の削除または追加メソッドを使用しない限り、イテレーターは &lt;code&gt;ConcurrentModificationException&lt;/code&gt; を &lt;code&gt;throw&lt;/code&gt; します）。</target>
        </trans-unit>
        <trans-unit id="e215678d488569b16687c62fc0c1cecd7a06b204" translate="yes" xml:space="preserve">
          <source>The LinkedList class extends AbstractSequentialList and implements List,Deque, and Queue interface.</source>
          <target state="translated">LinkedListクラスはAbstractSequentialListを継承し、List,Deque,Queueインターフェースを実装しています。</target>
        </trans-unit>
        <trans-unit id="a584c17550a71fdd1f4452edc00d3a4572783158" translate="yes" xml:space="preserve">
          <source>The default initial capacity of an &lt;code&gt;ArrayList&lt;/code&gt; is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you're going to add a lot of elements, construct the &lt;code&gt;ArrayList&lt;/code&gt; with a higher initial capacity.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; のデフォルトの初期容量はかなり小さい（Java 1.4-1.8から10）。 ただし、基本となる実装は配列であるため、多くの要素を追加する場合は、配列のサイズを変更する必要があります。 多くの要素を追加することがわかっている場合にサイズ変更の高コストを回避するには、より高い初期容量で &lt;code&gt;ArrayList&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="6a73759baa6b5937448572841c9e25224f4a4466" translate="yes" xml:space="preserve">
          <source>The first difference between ArrayList and LinkedList comes with the fact that ArrayList is backed by Array while LinkedList is backed by LinkedList. This will lead to further differences in performance.</source>
          <target state="translated">ArrayListとLinkedListの最初の違いは、ArrayListがArrayでバックアップされているのに対し、LinkedListはLinkedListでバックアップされているという点にあります。これにより、さらにパフォーマンスの違いが出てきます。</target>
        </trans-unit>
        <trans-unit id="405c38f8ac19fd59375c5014403c7ab61e163b10" translate="yes" xml:space="preserve">
          <source>The formulas I used follow, let me know if I have done anything wrong and I will fix it up. 'b' is either 4 or 8 for 32 or 64 bit systems, and 'n' is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.</source>
          <target state="translated">私が使用した数式は以下の通りです。何か間違ったことがあれば教えてください。b」は32ビットまたは64ビットのシステムでは4または8、「n」は要素の数です。修正の理由は、javaのすべてのオブジェクトは、それがすべて使用されているかどうかにかかわらず、8バイトの倍数のスペースを取るからです。</target>
        </trans-unit>
        <trans-unit id="c67ed32e3dd5ebe3398abf72bee54241312ba5f5" translate="yes" xml:space="preserve">
          <source>The get(index) operation is O(1) in ArrayList while its O(n/2) in LinkedList, as it needs to traverse till that entry. Though, in Big O notation O(n/2) is just O(n) because we ignore constants there.</source>
          <target state="translated">get(index)はArrayListではO(1)ですが、LinkedListではO(n2)です。しかし、Big O記法では定数を無視しているので、O(n2)はO(n)に過ぎません。</target>
        </trans-unit>
        <trans-unit id="ebbe3e7e54ca846d40859c9cd5c54f9e245ba147" translate="yes" xml:space="preserve">
          <source>The main benefits of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you re-use existing iterators to insert and remove elements. These operations can then be done in &lt;em&gt;O(1)&lt;/em&gt; by changing the list locally only. In an array list, the remainder of the array needs to be &lt;em&gt;moved&lt;/em&gt; (i.e. copied). On the other side, seeking in a &lt;code&gt;LinkedList&lt;/code&gt; means following the links in &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/2&lt;/em&gt; steps) for worst case, whereas in an &lt;code&gt;ArrayList&lt;/code&gt; the desired position can be computed mathematically and accessed in &lt;em&gt;O(1)&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; を使用する主な利点は、既存のイテレータを再利用して要素を挿入および削除するときに発生します。 これらの操作は、リストをローカルでのみ変更することにより、 &lt;em&gt;O（1）&lt;/em&gt;で実行できます。 配列リストでは、配列の残りの部分を&lt;em&gt;移動&lt;/em&gt; （つまり、コピー）する必要があります。 一方、 &lt;code&gt;LinkedList&lt;/code&gt; でのシークは、最悪の場合、 &lt;em&gt;O（n）&lt;/em&gt; （ &lt;em&gt;n / 2&lt;/em&gt;ステップ）でリンクをたどることを意味しますが、 &lt;code&gt;ArrayList&lt;/code&gt; では、希望の位置を数学的に計算し、 &lt;em&gt;O（1）で&lt;/em&gt;アクセスできます。</target>
        </trans-unit>
        <trans-unit id="b74b1e781ca90526e83c42ffc3d14526c49736ab" translate="yes" xml:space="preserve">
          <source>The reason behind &lt;em&gt;ArrayList&lt;/em&gt; being faster than LinkedList is that ArrayList uses an index based system for its elements as it internally uses an array data structure, on the other hand,</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt;がLinkedListよりも高速である理由は、ArrayListは内部的に配列データ構造を使用するため、要素にインデックスベースのシステムを使用するためです。</target>
        </trans-unit>
        <trans-unit id="2f3082915f897c89bedc037a984915a010f1935c" translate="yes" xml:space="preserve">
          <source>The result clearly shows that &lt;code&gt;LinkedList&lt;/code&gt; is a whole lot more than &lt;code&gt;ArrayList&lt;/code&gt;, especially with a very high element count. If memory is a factor, steer clear of &lt;code&gt;LinkedLists&lt;/code&gt;.</source>
          <target state="translated">結果は、 &lt;code&gt;LinkedList&lt;/code&gt; が &lt;code&gt;ArrayList&lt;/code&gt; よりもはるかに多く、特に要素数が非常に多いことを明確に示しています。 メモリが重要な場合は、 &lt;code&gt;LinkedLists&lt;/code&gt; を避けてください 。</target>
        </trans-unit>
        <trans-unit id="55e26f9f49b3d7c9c3c97a405002150b730e9d84" translate="yes" xml:space="preserve">
          <source>There are few similarities between these classes which are as follows:</source>
          <target state="translated">これらのクラスの間には、次のようないくつかの類似点があります。</target>
        </trans-unit>
        <trans-unit id="979f5bb981358561639406265c29e3fa18c87f2d" translate="yes" xml:space="preserve">
          <source>There are two main reasons for this:</source>
          <target state="translated">その理由は大きく分けて2つあります。</target>
        </trans-unit>
        <trans-unit id="51e22a50ad3da080a9975903475702d34ba04615" translate="yes" xml:space="preserve">
          <source>There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList implementation&lt;/a&gt;.  (Yes, it's from 2001, so you'll need to generify it, but I got comparable performance ratios to what's quoted in the article just now in a recent JVM)</source>
          <target state="translated">LinkedListがArrayListよりも優れている一般的な使用例として、キューの使用例があります。 ただし、目標がパフォーマンスである場合は、LinkedListの代わりに、ArrayBlockingQueue（キューサイズの上限を事前に決定でき、すべてのメモリを事前に割り当てる余裕がある場合）、またはこの&lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList実装の&lt;/a&gt;使用も検討する必要があります。 。 （はい、それは2001年からです。したがって、それを一般化する必要がありますが、最近のJVMで今の記事で引用されているものと同等のパフォーマンス比を得ました）</target>
        </trans-unit>
        <trans-unit id="bb24115d041e92964431dc2a9a4c804a8c2714b7" translate="yes" xml:space="preserve">
          <source>They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.</source>
          <target state="translated">どちらも要素の挿入順序を保持しています。つまり、ArrayListとLinkedListの要素を表示している間、結果セットはリストに要素が挿入された順序と同じ順序を持っていることになります。</target>
        </trans-unit>
        <trans-unit id="a7393aee9cdbf2240709c5e92b61bea76f07fd0d" translate="yes" xml:space="preserve">
          <source>Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a &lt;code&gt;LinkedList&lt;/code&gt; is &quot;lots more&quot; than an &lt;code&gt;ArrayList&lt;/code&gt; so I did some number crunching to demonstrate exactly how much both lists take up for N null references.</source>
          <target state="translated">これまでのところ、 &lt;code&gt;LinkedList&lt;/code&gt; は &lt;code&gt;ArrayList&lt;/code&gt; よりも「はるかに多い」という一般的なコンセンサスを除いて、これらの各リストのメモリフットプリントに対処した人はいないようです。 。</target>
        </trans-unit>
        <trans-unit id="5f0ebd31014e6d03e89c2e7c5de3ae7e005b1340" translate="yes" xml:space="preserve">
          <source>To find out more, read any article that talks about the difference between arrays and linked lists.</source>
          <target state="translated">もっと詳しく知りたい方は、配列とリンクされたリストの違いについて語っている記事があれば読んでみてください。</target>
        </trans-unit>
        <trans-unit id="29ca1dbcdfa1f09ca0ddfee47c7f010975f7b16f" translate="yes" xml:space="preserve">
          <source>Unless you've created large lists and measured a bottleneck, you'll probably never need to worry about the difference.</source>
          <target state="translated">大きなリストを作ってボトルネックを計測しない限り、その差を気にする必要はないでしょう。</target>
        </trans-unit>
        <trans-unit id="445928a04da6390fbfe641573eb932e5cdb28769" translate="yes" xml:space="preserve">
          <source>When should &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; be used over &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and vice-versa?</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;はいつ &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;で使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="78753f704c5e896d437844d3fb47088744b55cf9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList and when to use ArrayList?</source>
          <target state="translated">LinkedListを使うタイミングとArrayListを使うタイミングは?</target>
        </trans-unit>
        <trans-unit id="38de968ae17bb38f4696d5acc9b08397e7f206f9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList over ArrayList in Java</source>
          <target state="translated">JavaでArrayListよりもLinkedListを使う場合</target>
        </trans-unit>
        <trans-unit id="8e108c13808368fe0f3f3e721de63a230cc41edf" translate="yes" xml:space="preserve">
          <source>Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.</source>
          <target state="translated">どちらの方が挿入・削除が速いかは、挿入・削除する場所によって異なります。最初の方に近い場合は、LinkedListの方が高速になります。終点に近い場合は、ArrayListの方が速くなります。中間で正確に行う場合は、n 個の値を移動するよりも n 個の要素を通過する方が早いため、LinkedList の方が高速になります。</target>
        </trans-unit>
        <trans-unit id="aa1559133ba9f967b51fb87c9d69f02e2d34fd11" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt; remove(int) method involves copying elements from the old array to new updated array, hence its runtime is O(n).</source>
          <target state="translated">&lt;em&gt;ArrayListでは、&lt;/em&gt; remove（int）メソッドは古い配列から新しい更新された配列に要素をコピーするため、実行時間はO（n）です。</target>
        </trans-unit>
        <trans-unit id="22fb9822109a567e96dc1961a1c75216ea996026" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt;, if the array is the full i.e worst case,  there is an extra cost of resizing array and copying elements to the new array, which makes runtime of add operation in ArrayList O(n), otherwise it is O(1).</source>
          <target state="translated">&lt;em&gt;ArrayListの&lt;/em&gt;場合、配列がいっぱい、つまり最悪の場合、配列のサイズを変更して要素を新しい配列にコピーするための追加コストが発生します。これにより、ArrayListでの追加操作の実行時間がO（n）になり、それ以外の場合はO（1）になります。 。</target>
        </trans-unit>
        <trans-unit id="da14c4f26f81795e276c6bd693c6d365161bbd6f" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;LinkedList&lt;/code&gt; sucks:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; が悪い理由：</target>
        </trans-unit>
        <trans-unit id="55541df4dcf152a08b381822d996bdf2502bee11" translate="yes" xml:space="preserve">
          <source>Working on a later generation hardware (bigger, more efficient caches) - the results are even more conclusive:</source>
          <target state="translated">後の世代のハードウェア(より大きく、より効率的なキャッシュ)での作業-結果はさらに決定的なものになっています。</target>
        </trans-unit>
        <trans-unit id="a96e6d2490d18f0fcecefd52716013baa2282e27" translate="yes" xml:space="preserve">
          <source>Yeah, I know, this is an ancient question, but I'll throw in my two cents:</source>
          <target state="translated">古い質問ですが、私の意見を言わせてもらいます。</target>
        </trans-unit>
        <trans-unit id="3421ce1baebeb5f24f380dc68763a8fa7781e99b" translate="yes" xml:space="preserve">
          <source>add at the end of ArrayList</source>
          <target state="translated">ArrayListの最後に追加</target>
        </trans-unit>
        <trans-unit id="d2221c6840ebc04f909e2dcc5cd06ad7d8f6932a" translate="yes" xml:space="preserve">
          <source>add to a specific index position</source>
          <target state="translated">特定のインデックス位置に追加する</target>
        </trans-unit>
        <trans-unit id="b281534d3156b92bf772720eb3f8efc8a069ba16" translate="yes" xml:space="preserve">
          <source>add to the end of the list</source>
          <target state="translated">書き足す</target>
        </trans-unit>
        <trans-unit id="4f6fa4b826aa66326567de6e0de9a55c1c55a1f6" translate="yes" xml:space="preserve">
          <source>add(E e)</source>
          <target state="translated">加算(E e)</target>
        </trans-unit>
        <trans-unit id="72b84dc9449f12507c91ba8d78cb41d5e51adf02" translate="yes" xml:space="preserve">
          <source>add(int index, E element)</source>
          <target state="translated">add(int index,E element)</target>
        </trans-unit>
        <trans-unit id="844ba48b6f4d03efb77ea996bee561e0383f6609" translate="yes" xml:space="preserve">
          <source>get(int index) or search operation</source>
          <target state="translated">get(int index)または検索操作</target>
        </trans-unit>
        <trans-unit id="3471d553186e51c7dfeab01069130c02fa1f5d6e" translate="yes" xml:space="preserve">
          <source>hence the memory consumption is high in LinkedList comparatively.</source>
          <target state="translated">そのため、LinkedListでは比較的メモリ消費量が多いです。</target>
        </trans-unit>
        <trans-unit id="c097d2b9e6029ded8d9e023c043cc1fd76009367" translate="yes" xml:space="preserve">
          <source>insert at specified position</source>
          <target state="translated">指定位置に挿入</target>
        </trans-unit>
        <trans-unit id="a9e8151e5167b5af037785aa4dc339561be644f1" translate="yes" xml:space="preserve">
          <source>insert() or add(Object) operation</source>
          <target state="translated">挿入操作または追加操作</target>
        </trans-unit>
        <trans-unit id="9c1204571198e8877ebce850c1dfb52bd2b5a592" translate="yes" xml:space="preserve">
          <source>need to find the element first</source>
          <target state="translated">最初に要素を見つける必要があります</target>
        </trans-unit>
        <trans-unit id="a191f25905b311a0a098953a475e0fe58a39f999" translate="yes" xml:space="preserve">
          <source>need to find the position first</source>
          <target state="translated">先ずは位置を見極める必要がある</target>
        </trans-unit>
        <trans-unit id="847ad4fb3598032da7663514a73890f0201a0804" translate="yes" xml:space="preserve">
          <source>need to search the element first, and then shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">最初に要素を検索し、次にシフトと可能なメモリサイズ変更コストを必要とする</target>
        </trans-unit>
        <trans-unit id="aa3f74c9a865d4ab8e22742926357ae39d210034" translate="yes" xml:space="preserve">
          <source>remove a specified element</source>
          <target state="translated">指定された要素を削除する</target>
        </trans-unit>
        <trans-unit id="bb34c3a95d3f5f993e01a9c524699f01d857b2bc" translate="yes" xml:space="preserve">
          <source>remove element with specified index</source>
          <target state="translated">指定されたインデックスを持つ要素を削除します。</target>
        </trans-unit>
        <trans-unit id="4ac73d56678223d75eda9aae361f03cbb4efb477" translate="yes" xml:space="preserve">
          <source>remove first element of the list</source>
          <target state="translated">リストの最初の要素を削除</target>
        </trans-unit>
        <trans-unit id="247a8156822c95c4f1d9153b4b6e8f6be6811d4d" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element</source>
          <target state="translated">指定された要素の最初の出現を削除します。</target>
        </trans-unit>
        <trans-unit id="52a10c2f057161132a26d20ded67b637c1fbd40b" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element from this list</source>
          <target state="translated">このリストから指定された要素の最初の出現を削除します。</target>
        </trans-unit>
        <trans-unit id="bd3be8adf5ced4095cfe468b4bc677c15a10ae09" translate="yes" xml:space="preserve">
          <source>remove()</source>
          <target state="translated">remove()</target>
        </trans-unit>
        <trans-unit id="e44f21ff188d5fffffea502864836471078eb47b" translate="yes" xml:space="preserve">
          <source>remove(Object o)</source>
          <target state="translated">remove(Object o)</target>
        </trans-unit>
        <trans-unit id="e60165c5083078c6a746b52139fb9f6097486ada" translate="yes" xml:space="preserve">
          <source>remove(int index)</source>
          <target state="translated">削除(整数インデックス)</target>
        </trans-unit>
        <trans-unit id="57ef2c48f4ed0634600c52ceb1e6d3dd7a4f0537" translate="yes" xml:space="preserve">
          <source>remove(int) operation</source>
          <target state="translated">除去演算</target>
        </trans-unit>
        <trans-unit id="abaf93324a2d63d24596456a9a769ee878da2d71" translate="yes" xml:space="preserve">
          <source>require memory resizing cost.</source>
          <target state="translated">メモリリサイズのコストが必要です。</target>
        </trans-unit>
        <trans-unit id="624f26f7a70b9282abd23807374f9ad938d82f14" translate="yes" xml:space="preserve">
          <source>require shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">シフトとメモリのサイズ変更に必要なコストが必要</target>
        </trans-unit>
        <trans-unit id="830739c4a912c77e621eacfa69ff1a2e20904588" translate="yes" xml:space="preserve">
          <source>so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.</source>
          <target state="translated">なので、追加・削除操作が少なく、検索操作が必要な場合は、ArrayListがベストベターでしょう。</target>
        </trans-unit>
        <trans-unit id="8afac9dd157c540d08e836d87cf840122340a4c0" translate="yes" xml:space="preserve">
          <source>there are a large number of add/remove operations</source>
          <target state="translated">沢山の削除操作がある</target>
        </trans-unit>
        <trans-unit id="8156fdb9f5fc9c9f8388d191c22e989ad6fd729e" translate="yes" xml:space="preserve">
          <source>there are no large number of random access of element</source>
          <target state="translated">要素のランダムアクセス数が多くない</target>
        </trans-unit>
        <trans-unit id="33e994a94f2f973adcc52b6ab5eb6c4835a3b486" translate="yes" xml:space="preserve">
          <source>there is no descendingIterator() in &lt;em&gt;ArrayList&lt;/em&gt; , so we need to write our own code to iterate over the ArrayList in reverse direction.</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt;にはdescendingIterator（）がないため、逆方向にArrayListを反復処理する独自のコードを記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="aacb03ae7534d3764f83b010045b893210f65a4b" translate="yes" xml:space="preserve">
          <source>whereas In linkedlist</source>
          <target state="translated">一方、リンクリストでは</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
