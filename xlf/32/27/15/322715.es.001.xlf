<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/322715">
    <body>
      <group id="322715">
        <trans-unit id="823154fd74560a83cc6bee588649f9eab42ae643" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;Search:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; search operation is pretty fast compared to the &lt;code&gt;LinkedList&lt;/code&gt; search operation. &lt;code&gt;get(int index)&lt;/code&gt; in &lt;code&gt;ArrayList&lt;/code&gt; gives the performance of &lt;code&gt;O(1)&lt;/code&gt; while &lt;code&gt;LinkedList&lt;/code&gt; performance is &lt;code&gt;O(n)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;Search:&lt;/code&gt; operaci&amp;oacute;n de b&amp;uacute;squeda &lt;code&gt;ArrayList&lt;/code&gt; es bastante r&amp;aacute;pida en comparaci&amp;oacute;n con la operaci&amp;oacute;n de b&amp;uacute;squeda &lt;code&gt;LinkedList&lt;/code&gt; . &lt;code&gt;get(int index)&lt;/code&gt; en &lt;code&gt;ArrayList&lt;/code&gt; proporciona el rendimiento de &lt;code&gt;O(1)&lt;/code&gt; mientras que el rendimiento de &lt;code&gt;LinkedList&lt;/code&gt; es &lt;code&gt;O(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9dd8e774bff097745b7775bb8d0ce9bb80f0d5" translate="yes" xml:space="preserve">
          <source>1. Implementation</source>
          <target state="translated">1.Aplicación</target>
        </trans-unit>
        <trans-unit id="39e90e34901690aa4761ad905d14ac1d3dfdc5d3" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;Deletion:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; remove operation gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives variable performance: &lt;code&gt;O(n)&lt;/code&gt; in worst case (while removing first element) and &lt;code&gt;O(1)&lt;/code&gt; in best case (While removing last element).</source>
          <target state="translated">2) &lt;code&gt;Deletion:&lt;/code&gt; operaci&amp;oacute;n de eliminaci&amp;oacute;n de &lt;code&gt;LinkedList&lt;/code&gt; proporciona &lt;code&gt;O(1)&lt;/code&gt; rendimiento O (1) mientras que &lt;code&gt;ArrayList&lt;/code&gt; proporciona un rendimiento variable: &lt;code&gt;O(n)&lt;/code&gt; en el peor de los casos (al eliminar el primer elemento) y &lt;code&gt;O(1)&lt;/code&gt; en el mejor de los casos (al eliminar el &amp;uacute;ltimo elemento).</target>
        </trans-unit>
        <trans-unit id="e5e97190dfb614f2fbe264bd76660de27ae359f6" translate="yes" xml:space="preserve">
          <source>2. Performance</source>
          <target state="translated">2.2.Rendimiento</target>
        </trans-unit>
        <trans-unit id="35be33e4f01930f4341e2e90cad04e8ccd9b9340" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;Inserts Performance:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; add method gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives &lt;code&gt;O(n)&lt;/code&gt; in worst case. Reason is same as explained for remove.</source>
          <target state="translated">3) &lt;code&gt;Inserts Performance:&lt;/code&gt; m&amp;eacute;todo de adici&amp;oacute;n &lt;code&gt;LinkedList&lt;/code&gt; proporciona el rendimiento &lt;code&gt;O(1)&lt;/code&gt; mientras que &lt;code&gt;ArrayList&lt;/code&gt; proporciona &lt;code&gt;O(n)&lt;/code&gt; en el peor de los casos. La raz&amp;oacute;n es la misma que la explicada para eliminar.</target>
        </trans-unit>
        <trans-unit id="cad09e39292bee8a79b011228fe0514e7c225093" translate="yes" xml:space="preserve">
          <source>3. Reverse  Iterator</source>
          <target state="translated">3.Iteración inversa</target>
        </trans-unit>
        <trans-unit id="ab7a005ac90b45cd9b3e91e6392f71a58ed5d6f3" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;Memory Overhead:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains indexes and element data while &lt;code&gt;LinkedList&lt;/code&gt; maintains element data and two pointers for neighbor nodes</source>
          <target state="translated">4) &lt;code&gt;Memory Overhead:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; mantiene &amp;iacute;ndices y datos de elementos, mientras que &lt;code&gt;LinkedList&lt;/code&gt; mantiene datos de elementos y dos punteros para nodos vecinos</target>
        </trans-unit>
        <trans-unit id="e450f6c0e8ad7231222f9efe27918d977874a66a" translate="yes" xml:space="preserve">
          <source>4. Initial Capacity</source>
          <target state="translated">4.Capacidad inicial</target>
        </trans-unit>
        <trans-unit id="d9ff1d6f80c80852e98b6ef3bb0fc8224d5df608" translate="yes" xml:space="preserve">
          <source>5. Memory Overhead</source>
          <target state="translated">5.5.Memoria de los gastos generales</target>
        </trans-unit>
        <trans-unit id="127cf06445897840aec95708ef603d3e04a0e331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; goes more in depth, as does 
&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; va m&amp;aacute;s en profundidad, al igual que &lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b43a5b05b6e36c0f963a65dff5cbbba5dd87c900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt;, btw, is a custom ArrayList implementation holding &lt;code&gt;Int&lt;/code&gt; (primitive type) and not Objects - hence all data is really stored adjacently - hence even more efficient.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt; , por cierto, es una implementaci&amp;oacute;n personalizada de ArrayList que contiene &lt;code&gt;Int&lt;/code&gt; (tipo primitivo) y no Objetos, por lo tanto, todos los datos se almacenan de forma adyacente, por lo tanto, son a&amp;uacute;n m&amp;aacute;s eficientes.</target>
        </trans-unit>
        <trans-unit id="a60af0233530522d0db70105194d2d6809d47074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an &lt;code&gt;ArrayList&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; in the worst case but constant on average.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; , por otro lado, permite un acceso de lectura aleatorio r&amp;aacute;pido, por lo que puede tomar cualquier elemento en tiempo constante. Pero agregar o eliminar de cualquier lugar que no sea el final requiere cambiar todos los &amp;uacute;ltimos elementos, ya sea para hacer una abertura o llenar el vac&amp;iacute;o. Adem&amp;aacute;s, si agrega m&amp;aacute;s elementos que la capacidad de la matriz subyacente, se asigna una nueva matriz (1,5 veces el tama&amp;ntilde;o) y la matriz anterior se copia en la nueva, por lo que agregar a una &lt;code&gt;ArrayList&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; en el peor caso pero constante en promedio.</target>
        </trans-unit>
        <trans-unit id="a7d8b017cec005f28991d76ebeb6880b6882d238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; both implements &lt;code&gt;List interface&lt;/code&gt;  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; y &lt;code&gt;LinkedList&lt;/code&gt; implementan la &lt;code&gt;List interface&lt;/code&gt; y sus m&amp;eacute;todos y resultados son casi id&amp;eacute;nticos. Sin embargo, hay pocas diferencias entre ellos que hacen que uno sea mejor que otro dependiendo del requisito.</target>
        </trans-unit>
        <trans-unit id="c5b77accd97f06a73806437d14b939ebde6071c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is essentially an array. &lt;code&gt;LinkedList&lt;/code&gt; is implemented as a double linked list.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; es esencialmente una matriz. &lt;code&gt;LinkedList&lt;/code&gt; se implementa como una lista de doble enlace .</target>
        </trans-unit>
        <trans-unit id="d80057e73ae69c2b5a916affaa4a8498705114f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is faster to access an indexed value. It is much worse when inserting or deleting objects.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pido para acceder a un valor indexado. Es mucho peor al insertar o eliminar objetos.</target>
        </trans-unit>
        <trans-unit id="6b2e4c61036a69b6af002dcf70738ee96dffaaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is randomly accessible, while &lt;code&gt;LinkedList&lt;/code&gt; is really cheap to expand and remove elements from. For most cases, &lt;code&gt;ArrayList&lt;/code&gt; is fine.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; es accesible al azar, mientras que &lt;code&gt;LinkedList&lt;/code&gt; es realmente barato para expandir y eliminar elementos. Para la mayor&amp;iacute;a de los casos, &lt;code&gt;ArrayList&lt;/code&gt; est&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="8235411525223988a507c26abd524b3fcfeb5bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is what you want. &lt;code&gt;LinkedList&lt;/code&gt; is almost always a (performance) bug.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; es lo que quieres. &lt;code&gt;LinkedList&lt;/code&gt; es casi siempre un error (de rendimiento).</target>
        </trans-unit>
        <trans-unit id="33b5deb58c1b5ecdbe2ecc3db08d5de6dd151430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt;, backed by &lt;code&gt;Array&lt;/code&gt;, which needs to be double the size, is worse in large volume application.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; , respaldado por &lt;code&gt;Array&lt;/code&gt; , que debe ser el doble del tama&amp;ntilde;o, es peor en aplicaciones de gran volumen.</target>
        </trans-unit>
        <trans-unit id="333d27970508614bdfa9c0f502286bf30e92e307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; es &lt;em&gt;O (1)&lt;/em&gt; . &amp;lt;--- beneficio principal de &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="034b1b506c582e5f2d8814254ec183017ef9f60e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 2&lt;/em&gt; pasos en promedio)</target>
        </trans-unit>
        <trans-unit id="beaa8d551243d49b4d1eee05d6432e391eb33d16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; allows for constant-time insertions or removals &lt;em&gt;using iterators&lt;/em&gt;, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says &lt;em&gt;&quot;operations that index into the list will traverse the list from the beginning or the end, whichever is closer&quot;&lt;/em&gt;, so those methods are &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/4&lt;/em&gt; steps) on average, though &lt;em&gt;O(1)&lt;/em&gt; for &lt;code&gt;index = 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; permite inserciones o eliminaciones de tiempo constante &lt;em&gt;utilizando iteradores&lt;/em&gt; , pero solo acceso secuencial de elementos. En otras palabras, puede caminar la lista hacia adelante o hacia atr&amp;aacute;s, pero encontrar una posici&amp;oacute;n en la lista lleva tiempo proporcional al tama&amp;ntilde;o de la lista. Javadoc dice que &lt;em&gt;&quot;las operaciones que se indexan en la lista atravesar&amp;aacute;n la lista desde el principio o el final, lo que est&amp;eacute; m&amp;aacute;s cerca&quot;&lt;/em&gt; , por lo que esos m&amp;eacute;todos son &lt;em&gt;O (n)&lt;/em&gt; ( &lt;em&gt;n / 4&lt;/em&gt; pasos) en promedio, aunque &lt;em&gt;O (1)&lt;/em&gt; para &lt;code&gt;index = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16d80efc38b7c2ea0ff720019ddcf6be70e20363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are two different implementations of the List interface. &lt;code&gt;LinkedList&lt;/code&gt; implements it with a doubly-linked list. &lt;code&gt;ArrayList&lt;/code&gt; implements it with a dynamically re-sizing array.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; y &lt;code&gt;ArrayList&lt;/code&gt; son dos implementaciones diferentes de la interfaz List. &lt;code&gt;LinkedList&lt;/code&gt; lo implementa con una lista doblemente vinculada. &lt;code&gt;ArrayList&lt;/code&gt; lo implementa con una matriz de redimensionamiento din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="d9fecaf7b1171739d7cbdff1716ddbff9a310553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; is faster in add and remove, but slower in get. In brief, &lt;code&gt;LinkedList&lt;/code&gt; should be preferred if:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pido en agregar y quitar, pero m&amp;aacute;s lento en obtener. En resumen, &lt;code&gt;LinkedList&lt;/code&gt; deber&amp;iacute;a preferirse si:</target>
        </trans-unit>
        <trans-unit id="7dee07befa9756327e6f1f9ab15fa468c808e73e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  This is one of the main benefits of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; es &lt;em&gt;O (1)&lt;/em&gt; Este es uno de los principales beneficios de &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e64862c3a1c0b96095da40a2294754310124b801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 2&lt;/em&gt; pasos en promedio)</target>
        </trans-unit>
        <trans-unit id="25bc6fa8f8ff344c68d917a97611b91fe8f94bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reason:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side &lt;code&gt;LinkedList&lt;/code&gt; implements doubly linked list which requires the traversal through all the elements for searching an element.</source>
          <target state="translated">&lt;code&gt;Reason:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; mantiene un sistema basado en &amp;iacute;ndices para sus elementos, ya que utiliza la estructura de datos de la matriz impl&amp;iacute;citamente, lo que lo hace m&amp;aacute;s r&amp;aacute;pido para buscar un elemento en la lista. Por otro lado, &lt;code&gt;LinkedList&lt;/code&gt; implementa una lista doblemente vinculada que requiere el recorrido a trav&amp;eacute;s de todos los elementos para buscar un elemento.</target>
        </trans-unit>
        <trans-unit id="48481a079aa4dc0b62b86309c5b1f4c4656a27cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; es &lt;em&gt;O (1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86bcfe7042d55fdf6be9e4fe7feab45ac45db87d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt; amortized, but &lt;em&gt;O(n)&lt;/em&gt; worst-case since the array must be resized and copied</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; es &lt;em&gt;O (1)&lt;/em&gt; amortizado, pero &lt;em&gt;O (n) en el&lt;/em&gt; peor de los casos ya que la matriz debe ser redimensionada y copiada</target>
        </trans-unit>
        <trans-unit id="f30395d9afdb07d74da12292c1d66f1727a434a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 2&lt;/em&gt; pasos en promedio)</target>
        </trans-unit>
        <trans-unit id="c772faf78eb3c02de68edab5a6179904996ef451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average),
but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt;  &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 4&lt;/em&gt; pasos en promedio), pero &lt;em&gt;O (1)&lt;/em&gt; cuando &lt;code&gt;index = 0&lt;/code&gt; &amp;lt;--- beneficio principal de &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe559a7d7843b54392656da159db0507b58dd66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.add()&lt;/code&gt; is  O(1) and &lt;code&gt;linkedlist.add()&lt;/code&gt; is 0(1)</source>
          <target state="translated">&lt;code&gt;arraylist.add()&lt;/code&gt; es O (1) y &lt;code&gt;linkedlist.add()&lt;/code&gt; es 0 (1)</target>
        </trans-unit>
        <trans-unit id="03269f8a98a307f7cfd06520bf46af87990ad50c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.contains()&lt;/code&gt; is O(n) and&lt;code&gt;linkedlist.contains()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.contains()&lt;/code&gt; es O (n) y &lt;code&gt;linkedlist.contains()&lt;/code&gt; es O (n)</target>
        </trans-unit>
        <trans-unit id="618dfb209f4f59dfc35a87398c91f4408414c5e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.get()&lt;/code&gt; is  O(1) whereas &lt;code&gt;linkedlist.get()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.get()&lt;/code&gt; es O (1) mientras que &lt;code&gt;linkedlist.get()&lt;/code&gt; es O (n)</target>
        </trans-unit>
        <trans-unit id="c747b2aa8edd29531dda369e30693d8e367bf978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.next()&lt;/code&gt; is O(1) and &lt;code&gt;linkedlist.next()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.next()&lt;/code&gt; es O (1) y &lt;code&gt;linkedlist.next()&lt;/code&gt; es O (1)</target>
        </trans-unit>
        <trans-unit id="10d74fef85d164534c516cace70835405c829375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.remove()&lt;/code&gt; is O(n) whereas &lt;code&gt;linkedlist.remove()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.remove()&lt;/code&gt; es O (n) mientras que &lt;code&gt;linkedlist.remove()&lt;/code&gt; es O (1)</target>
        </trans-unit>
        <trans-unit id="83cf5e81c843d7f1b9ec0ebf7d3ce303ed679233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  &amp;lt;--- main benefit of &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; es &lt;em&gt;O (1)&lt;/em&gt; &amp;lt;--- beneficio principal de &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="076d7c0a115bbd75984dc63de232ffd83355229d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 4&lt;/em&gt; pasos en promedio)</target>
        </trans-unit>
        <trans-unit id="c46760af862228653fd1838c5478b7b0940fecd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; es O (n)</target>
        </trans-unit>
        <trans-unit id="7b106c9b6bde2953f3d1daf9d5119c83d5410807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt;is O(1)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; es O (1)</target>
        </trans-unit>
        <trans-unit id="ddd6b224b5ccf09e47bc373ca347dfe7075c1356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 2&lt;/em&gt; pasos en promedio)</target>
        </trans-unit>
        <trans-unit id="cf4c56aa9b5498f71eb6ce9320a3051ac4546259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; es &lt;em&gt;O (n)&lt;/em&gt; (con &lt;em&gt;n / 4&lt;/em&gt; pasos en promedio)</target>
        </trans-unit>
        <trans-unit id="e0e4246aea749c2db7c4d23e708786328b04d5d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; get(int index) operation runs in constant time i.e O(1)  while</source>
          <target state="translated">&lt;em&gt;La&lt;/em&gt; operaci&amp;oacute;n get (int index) de &lt;em&gt;ArrayList&lt;/em&gt; se ejecuta en tiempo constante, es decir, O (1) mientras</target>
        </trans-unit>
        <trans-unit id="5d33e09a0584a1ed7c3021a69aa36ebc1ffbaeb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; is the resizable array implementation of list interface , while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; es la implementaci&amp;oacute;n de matriz redimensionable de la interfaz de lista, mientras que</target>
        </trans-unit>
        <trans-unit id="c124a2a77d14e556f2817e5cd608afeed22dbfe5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt;  only constructs the empty list without any initial capacity.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; solo construye la lista vac&amp;iacute;a sin ninguna capacidad inicial.</target>
        </trans-unit>
        <trans-unit id="f4ee2569862439dbb15b3ae92435d3a68c160616" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; can be iterated in reverse direction using descendingIterator() while</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; se puede iterar en direcci&amp;oacute;n inversa usando descendingIterator () mientras</target>
        </trans-unit>
        <trans-unit id="c54e2d819276cdac9c5f9629b5f33af6e5719be2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; does not provide index-based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; no proporciona acceso basado en &amp;iacute;ndices para sus elementos, ya que itera desde el principio o el final (lo que est&amp;eacute; m&amp;aacute;s cerca) para recuperar el nodo en el &amp;iacute;ndice del elemento especificado.</target>
        </trans-unit>
        <trans-unit id="8bb16f32491a07a1a25788ce7789be628df88f90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; get(int index) operation run time is O(n) .</source>
          <target state="translated">&lt;em&gt;El&lt;/em&gt; tiempo de ejecuci&amp;oacute;n de la operaci&amp;oacute;n &lt;em&gt;LinkedList&lt;/em&gt; get (int index) es O (n).</target>
        </trans-unit>
        <trans-unit id="b58ac9358b965d629640277808e5c5aa9d8d6726" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; is the Doubly-linked list implementation of the list interface.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; es la implementaci&amp;oacute;n de lista doblemente vinculada de la interfaz de lista.</target>
        </trans-unit>
        <trans-unit id="2a8c0d7f347fae173c91da41a72879346a94ba06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Underlying Data Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) Estructura de datos subyacente&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433009e1632a58f1c005d11c5b98f0de53409d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) LinkedList implements Deque&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) LinkedList implementa Deque&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8263acaceffe6556cde46deb5cd970572e9e42c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Removing an element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4) Eliminar un elemento de una posici&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47f28efd57ef00e2c87c16894875d71e8b597837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5) Iterating over ArrayList or LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5) Iterando sobre ArrayList o LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bc5d37009869c02f222a403c214d3c17b0e706b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6) Retrieving element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6) Recuperar elemento de una posici&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="462f50e91da5f54cbf63fd99a90f80e12a0505fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7) Memory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7) memoria&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da1ffd583c2ad7be3699d0c0677415f869d74146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f05e8ad2e27a21a899fecd88f6a21aacab0d7ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt; Resizable-array implementation of the List interface</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt; implementaci&amp;oacute;n de matriz redimensionable de la interfaz List</target>
        </trans-unit>
        <trans-unit id="6af5a946c3943e163e4208c39ac575e870dcd320" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2269f0870ce22b776e94b551a51a669b55a88029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46534f184f1b21f4eddf5b75c18076e27fc2851f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: For Java its &lt;code&gt;LinkedList&lt;/code&gt; this is not true! See &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Is there a fast concat method for linked list in Java?&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Importante&lt;/strong&gt; : &amp;iexcl;Para Java su &lt;code&gt;LinkedList&lt;/code&gt; esto no es cierto! Consulte &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;&amp;iquest;Existe un m&amp;eacute;todo r&amp;aacute;pido de concat para la lista vinculada en Java?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3e70a2309d967cc0183810bd32e9751566d788e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e04cb44a3754508f40774fb3722cf1f644583432" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt; Doubly-linked list implementation of the List and Deque interfaces</source>
          <target state="translated">&lt;strong&gt;LinkedList:&lt;/strong&gt; implementaci&amp;oacute;n de lista doblemente vinculada de las interfaces List y Deque</target>
        </trans-unit>
        <trans-unit id="4cfbebcdacd3a1fd25d71fd2c7e3bba3a64e9924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb54ee6bc49f7f8f58707bdd0ffe2bb21f75ea60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mainly&lt;/strong&gt; - that the nodes of the &lt;code&gt;LinkedList&lt;/code&gt; are scattered randomly across the memory. RAM (&quot;Random Access Memory&quot;) isn't really random and blocks of memory need to be fetched to cache. This operation takes time, and when such fetches happen frequently - the memory pages in the cache need to be replaced all the time -&amp;gt; Cache misses -&amp;gt; Cache is not efficient.
&lt;code&gt;ArrayList&lt;/code&gt; elements are stored on continuous memory - which is exactly what the modern CPU architecture is optimizing for.</source>
          <target state="translated">&lt;strong&gt;Principalmente&lt;/strong&gt; : que los nodos de &lt;code&gt;LinkedList&lt;/code&gt; est&amp;aacute;n dispersos aleatoriamente en la memoria. La RAM (&quot;Memoria de acceso aleatorio&quot;) no es realmente aleatoria y los bloques de memoria deben recuperarse en la memoria cach&amp;eacute;. Esta operaci&amp;oacute;n lleva tiempo, y cuando tales recuperaciones ocurren con frecuencia: las p&amp;aacute;ginas de memoria en la memoria cach&amp;eacute; deben reemplazarse todo el tiempo -&amp;gt; La memoria cach&amp;eacute; falla -&amp;gt; La memoria cach&amp;eacute; no es eficiente. &lt;code&gt;ArrayList&lt;/code&gt; elementos ArrayList se almacenan en memoria continua, que es exactamente para lo que est&amp;aacute; optimizando la arquitectura moderna de la CPU.</target>
        </trans-unit>
        <trans-unit id="737ee1d3842d6b6aa7c27ab74975e8879b369c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note 2:&lt;/strong&gt;&lt;em&gt;(thanks BeeOnRope)&lt;/em&gt; As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.</source>
          <target state="translated">&lt;strong&gt;Nota 2:&lt;/strong&gt; &lt;em&gt;(gracias BeeOnRope)&lt;/em&gt; Como CompressedOops est&amp;aacute; predeterminado ahora desde mediados de JDK6 en adelante, los valores a continuaci&amp;oacute;n para m&amp;aacute;quinas de 64 bits b&amp;aacute;sicamente coincidir&amp;aacute;n con sus contrapartes de 32 bits, a menos que, por supuesto, lo desactive espec&amp;iacute;ficamente.</target>
        </trans-unit>
        <trans-unit id="d44e01d24f2f947ad59025026aafcb6509358644" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The sizes shown for the &lt;code&gt;ArrayList&lt;/code&gt; lines are for &lt;em&gt;trimmed lists&lt;/em&gt; - In practice, the capacity of the backing array in an &lt;code&gt;ArrayList&lt;/code&gt; is generally larger than its current element count.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Los tama&amp;ntilde;os que se muestran para las l&amp;iacute;neas &lt;code&gt;ArrayList&lt;/code&gt; son para &lt;em&gt;listas recortadas&lt;/em&gt; : en la pr&amp;aacute;ctica, la capacidad de la matriz de respaldo en una &lt;code&gt;ArrayList&lt;/code&gt; es generalmente mayor que su recuento de elementos actual.</target>
        </trans-unit>
        <trans-unit id="12af4b8c2156f8719580823656e7a54b8c2d6d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Secondary&lt;/strong&gt;&lt;code&gt;LinkedList&lt;/code&gt; required to hold back/forward pointers, which means 3 times the memory consumption per value stored compared to &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Se&lt;/strong&gt; requiere &lt;code&gt;LinkedList&lt;/code&gt; &lt;strong&gt;secundaria&lt;/strong&gt; para mantener apuntadores hacia atr&amp;aacute;s / adelante, lo que significa 3 veces el consumo de memoria por valor almacenado en comparaci&amp;oacute;n con &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1846b926ec6f26796aa1d815b9ecb79355628a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;&lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;ArrayDeque&lt;/code&gt; are preferable in &lt;em&gt;many&lt;/em&gt; more use-cases than &lt;code&gt;LinkedList&lt;/code&gt;. If you're not sure&amp;nbsp;&amp;mdash; just start with &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Resumen&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; con &lt;code&gt;ArrayDeque&lt;/code&gt; son preferibles en &lt;em&gt;muchos&lt;/em&gt; m&amp;aacute;s casos de uso que &lt;code&gt;LinkedList&lt;/code&gt; . Si no est&amp;aacute; seguro, simplemente comience con &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f13ec4830a4dab71f8b2f8ddb84bf2925c9db1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt; due to modern computer architecture, &lt;code&gt;ArrayList&lt;/code&gt; will be significantly more efficient for nearly any possible use-case - and therefore &lt;code&gt;LinkedList&lt;/code&gt; should be avoided except some very unique and extreme cases.</source>
          <target state="translated">&lt;strong&gt;TL; DR&lt;/strong&gt; debido a la arquitectura moderna de la computadora, &lt;code&gt;ArrayList&lt;/code&gt; ser&amp;aacute; significativamente m&amp;aacute;s eficiente para casi cualquier posible caso de uso, y por lo tanto se debe evitar &lt;code&gt;LinkedList&lt;/code&gt; , excepto algunos casos muy &amp;uacute;nicos y extremos.</target>
        </trans-unit>
        <trans-unit id="18c5c15402cf358ebe73222367ef252aff38be6e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/2&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (end of list), &lt;em&gt;n&lt;/em&gt; steps in the worst case (start of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Nota: Muchas de las operaciones necesitan &lt;em&gt;n / 2&lt;/em&gt; pasos en promedio, &lt;em&gt;un&lt;/em&gt; n&amp;uacute;mero &lt;em&gt;constante&lt;/em&gt; de pasos en el mejor de los casos (final de la lista), &lt;em&gt;n&lt;/em&gt; pasos en el peor de los casos (inicio de la lista)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e66437897a99b75d7aacd4ff7c0bab63bf960599" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/4&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (e.g. index = 0), and &lt;em&gt;n/2&lt;/em&gt; steps in worst case (middle of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Nota: Muchas de las operaciones necesitan &lt;em&gt;n / 4&lt;/em&gt; pasos en promedio, &lt;em&gt;un&lt;/em&gt; n&amp;uacute;mero &lt;em&gt;constante&lt;/em&gt; de pasos en el mejor de los casos (p. Ej., &amp;Iacute;ndice = 0) y &lt;em&gt;n / 2&lt;/em&gt; pasos en el peor de los casos (centro de la lista)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b9d61654aa4c588b3965ecb02516b604046e37b" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="afb8a95f2210ccfc23ec59f145c584c9c6d9cbca" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="bfbcd797a68fe86413865e4a0cee9ebbb8dc882a" translate="yes" xml:space="preserve">
          <source>A key elements to remember is that the cost of fetching memory block, is more significant than the cost accessing a single memory cell. That's why reader 1MB of sequential memory is up to x400 times faster than reading this amount of data from different blocks of memory:</source>
          <target state="translated">Un elemento clave a recordar es que el costo de buscar el bloque de memoria,es más significativo que el costo de acceder a una sola célula de memoria.Por eso el lector de 1MB de memoria secuencial es hasta x400 veces más rápido que leer esta cantidad de datos de diferentes bloques de memoria:</target>
        </trans-unit>
        <trans-unit id="964ab287d1b2674c3006a9a40f27cc8c75ad7689" translate="yes" xml:space="preserve">
          <source>A linked list specifies a progression from one item to the next (Item a -&amp;gt; item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one.</source>
          <target state="translated">Una lista vinculada especifica una progresi&amp;oacute;n de un elemento al siguiente (Elemento a -&amp;gt; elemento b). Puede obtener el mismo efecto con una lista de matriz, pero una lista vinculada dice absolutamente qu&amp;eacute; elemento se supone que debe seguir al anterior.</target>
        </trans-unit>
        <trans-unit id="b210113b5c71ae47be12eff9c831066664d10253" translate="yes" xml:space="preserve">
          <source>Algorithms: Big-Oh Notation</source>
          <target state="translated">Algoritmos:Notación Big-Oh</target>
        </trans-unit>
        <trans-unit id="89aa0aee53d5aa7fcca1da8190329ab378539fc9" translate="yes" xml:space="preserve">
          <source>Also adding an element in the mid of a list should be very efficient.</source>
          <target state="translated">También añadir un elemento en medio de una lista debería ser muy eficiente.</target>
        </trans-unit>
        <trans-unit id="61b3b2ef28066e4746dc4b1bff67b83b191c168c" translate="yes" xml:space="preserve">
          <source>Also, if you have large lists, keep in mind that memory usage is also different. Each element of a &lt;code&gt;LinkedList&lt;/code&gt; has more overhead since pointers to the next and previous elements are also stored. &lt;code&gt;ArrayLists&lt;/code&gt; don't have this overhead. However, &lt;code&gt;ArrayLists&lt;/code&gt; take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.</source>
          <target state="translated">Adem&amp;aacute;s, si tiene listas grandes, tenga en cuenta que el uso de la memoria tambi&amp;eacute;n es diferente. Cada elemento de una &lt;code&gt;LinkedList&lt;/code&gt; tiene m&amp;aacute;s sobrecarga, ya que tambi&amp;eacute;n se almacenan los punteros a los elementos siguientes y anteriores. &lt;code&gt;ArrayLists&lt;/code&gt; no tienen esta sobrecarga. Sin embargo, las &lt;code&gt;ArrayLists&lt;/code&gt; ocupan tanta memoria como se asigna para la capacidad, independientemente de si los elementos se han agregado realmente.</target>
        </trans-unit>
        <trans-unit id="2906ab1d13eae009cd628e69b029557fe9f42802" translate="yes" xml:space="preserve">
          <source>An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.</source>
          <target state="translated">Una lista de arreglos es esencialmente un arreglo con métodos para agregar elementos,etc.(y en su lugar se debería utilizar una lista genérica).Es una colección de elementos a los que se puede acceder a través de un indexador (por ejemplo [0]).Implica una progresión de un elemento a otro.</target>
        </trans-unit>
        <trans-unit id="928353d571ab22df35197d82101926d8b0eefa4a" translate="yes" xml:space="preserve">
          <source>An important feature of a linked list (which I didn't read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)</source>
          <target state="translated">Una característica importante de una lista vinculada (que no leí en otra respuesta)es la concatenación de dos listas.Con una matriz esto es O(n)(+sobrecarga de algunas reasignaciones)con una lista enlazada esto es sólo O(1)u O(2);-)</target>
        </trans-unit>
        <trans-unit id="440b1f956dfeafd90ff94cb080bd1ba1475ed504" translate="yes" xml:space="preserve">
          <source>And of course, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; is your best friend.</source>
          <target state="translated">Y, por supuesto, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;ImmutableList&lt;/a&gt; de Guava es tu mejor amigo.</target>
        </trans-unit>
        <trans-unit id="73a833ab20503a4ddda3951abeecfe30b58c944c" translate="yes" xml:space="preserve">
          <source>Another benefit of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you add or remove from the head of the list, since those operations are &lt;em&gt;O(1)&lt;/em&gt;, while they are &lt;em&gt;O(n)&lt;/em&gt; for &lt;code&gt;ArrayList&lt;/code&gt;. Note that &lt;code&gt;ArrayDeque&lt;/code&gt; may be a good alternative to &lt;code&gt;LinkedList&lt;/code&gt; for adding and removing from the head, but it is not a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">Otro beneficio de usar un &lt;code&gt;LinkedList&lt;/code&gt; surge cuando agrega o elimina del encabezado de la lista, ya que esas operaciones son &lt;em&gt;O (1)&lt;/em&gt; , mientras que son &lt;em&gt;O (n)&lt;/em&gt; para &lt;code&gt;ArrayList&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;ArrayDeque&lt;/code&gt; puede ser una buena alternativa a &lt;code&gt;LinkedList&lt;/code&gt; para agregar y quitar del encabezado, pero no es una &lt;code&gt;List&lt;/code&gt; a .</target>
        </trans-unit>
        <trans-unit id="e30b3a7720a85a27ef41bbfc97676b4e2de8896a" translate="yes" xml:space="preserve">
          <source>Another difference between ArrayList and LinkedList is that apart from the List interface, LinkedList also implements Deque interface, which provides first in first out operations for add() and poll() and several other Deque functions. 3) Adding elements in ArrayList Adding element in ArrayList is O(1) operation if it doesn't trigger re-size of Array, in which case it becomes O(log(n)), On the other hand, appending an element in LinkedList is O(1) operation, as it doesn't require any navigation.</source>
          <target state="translated">Otra diferencia entre ArrayList y LinkedList es que,además de la interfaz de la Lista,LinkedList también implementa la interfaz Deque,que proporciona operaciones de primero en primero en salir para add()y poll()y varias otras funciones Deque.3)Agregar elementos en ArrayList Agregar un elemento en ArrayList es una operación O(1)si no dispara el redimensionamiento del Array,en cuyo caso se convierte en O(log(n)),Por otro lado,agregar un elemento en LinkedList es una operación O(1),ya que no requiere ninguna navegación.</target>
        </trans-unit>
        <trans-unit id="1e86137c9ac677ec1de04c6463f5afe991a7e829" translate="yes" xml:space="preserve">
          <source>Any indexed operation requires a traversal, i.e. has O(n) performance. This is not obvious in the source code, leading to algorithms O(n) slower than if &lt;code&gt;ArrayList&lt;/code&gt; was used.</source>
          <target state="translated">Cualquier operaci&amp;oacute;n indexada requiere un recorrido, es decir, tiene un rendimiento O (n). Esto no es obvio en el c&amp;oacute;digo fuente, lo que lleva a algoritmos O (n) m&amp;aacute;s lentos que si se usara &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="245a7f4435e5cb39a22d5f24ebfff9bf323d2ce3" translate="yes" xml:space="preserve">
          <source>ArrayList Vs LinkedList</source>
          <target state="translated">ArrayList Vs LinkedList</target>
        </trans-unit>
        <trans-unit id="fe0ac6572af91b6c617d95528d2b396ca2837309" translate="yes" xml:space="preserve">
          <source>ArrayList and LinkedList have their own pros and cons.</source>
          <target state="translated">ArrayList y LinkedList tienen sus propios pros y contras.</target>
        </trans-unit>
        <trans-unit id="5b6785e144c9307049f97a69a012d7795245d88d" translate="yes" xml:space="preserve">
          <source>ArrayList extends AbstractList and implements the List Interface. ArrayList is dynamic array.</source>
          <target state="translated">ArrayList amplía AbstractList e implementa la Interfaz de la Lista.ArrayList es una matriz dinámica.</target>
        </trans-unit>
        <trans-unit id="437431a42628c440c8c8ddba7824d9ba269abd04" translate="yes" xml:space="preserve">
          <source>ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.</source>
          <target state="translated">ArrayList sólo es una mejor opción para el rendimiento si todo lo que quieres decir con rendimiento es rendimiento y puedes ignorar la latencia.En mi experiencia en mi trabajo no puedo ignorar la latencia en el peor de los casos.</target>
        </trans-unit>
        <trans-unit id="1913d3898d20247f47f9e0c995812cdb4b8d08d7" translate="yes" xml:space="preserve">
          <source>ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList is faster than doing n iterations with LinkedList.</source>
          <target state="translated">ArrayList utiliza la dirección de la memoria contigua en comparación con LinkedList que utiliza punteros hacia el siguiente nodo.Así que cuando quieres buscar un elemento en una ArrayList es más rápido que hacer n iteraciones con LinkedList.</target>
        </trans-unit>
        <trans-unit id="d9b713914a6a1ace02a2eecb0047e6799c67666f" translate="yes" xml:space="preserve">
          <source>ArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.</source>
          <target state="translated">Las listas de arreglos son buenas para escribir una vez-leer-muchos o apéndices,pero malas para agregar-eliminar desde el frente o el medio.</target>
        </trans-unit>
        <trans-unit id="459e94cfdff5088a8182f4ad9a0d304b933bf06b" translate="yes" xml:space="preserve">
          <source>As explained above the insert and remove operations give good performance &lt;code&gt;(O(1))&lt;/code&gt; in &lt;code&gt;LinkedList&lt;/code&gt; compared to &lt;code&gt;ArrayList(O(n))&lt;/code&gt;.</source>
          <target state="translated">Como se explic&amp;oacute; anteriormente, las operaciones de inserci&amp;oacute;n y eliminaci&amp;oacute;n proporcionan un buen rendimiento &lt;code&gt;(O(1))&lt;/code&gt; en &lt;code&gt;LinkedList&lt;/code&gt; en comparaci&amp;oacute;n con &lt;code&gt;ArrayList(O(n))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bafe9e2667a408bbc28c0a3d0896d45d6514421" translate="yes" xml:space="preserve">
          <source>As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.</source>
          <target state="translated">En cuanto a la lista de matrices,estoy de acuerdo en que al menos debería utilizar siempre el constructor con la capacidad inicial,para minimizar la duplicación de las matrices tanto como sea posible.</target>
        </trans-unit>
        <trans-unit id="41b881749d840dd577c03a0d047dddf4b9b4432c" translate="yes" xml:space="preserve">
          <source>As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.</source>
          <target state="translated">Como alguien que ha estado haciendo ingeniería de rendimiento operacional en servicios web SOA a gran escala durante una década,preferiría el comportamiento de LinkedList sobre ArrayList.Mientras que el rendimiento en estado estable de LinkedList es peor y por lo tanto podría conducir a la compra de más hardware-el comportamiento de ArrayList bajo presión podría conducir a que las aplicaciones en un clúster expandieran sus arreglos en casi sincronía y para los grandes tamaños de arreglos podría conducir a la falta de respuesta en la aplicación y a una interrupción,mientras se está bajo presión,lo cual es un comportamiento catastrófico.</target>
        </trans-unit>
        <trans-unit id="7cc15a8cb6e4f67393413b50f7e19ba95f084ea2" translate="yes" xml:space="preserve">
          <source>As with standard linked list and array operations, the various methods will have different algorithmic runtimes.</source>
          <target state="translated">Al igual que con las operaciones estándar de listas y matrices enlazadas,los diversos métodos tendrán diferentes tiempos de ejecución algorítmica.</target>
        </trans-unit>
        <trans-unit id="17f7102d3affee7b74333eccc3786b17d7b95f92" translate="yes" xml:space="preserve">
          <source>Based on these you have to decide what to choose. :)</source>
          <target state="translated">En base a esto tienes que decidir qué elegir.:)</target>
        </trans-unit>
        <trans-unit id="f4ba92067d77f8ad1cdde8d5185b8e7ead37b68b" translate="yes" xml:space="preserve">
          <source>Below is the unit test result for each operation.Timing is given in Nanoseconds.</source>
          <target state="translated">A continuación se muestra el resultado de la prueba de la unidad para cada operación.El tiempo se da en Nanosegundos.</target>
        </trans-unit>
        <trans-unit id="7f46f0e6a343f897fd8216fe946eeff647289350" translate="yes" xml:space="preserve">
          <source>Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Let's say we want to go through the entire List removing and inserting elements on our way. Usually, you would start from the very beginning for each element using the LinkedList, we could also &quot;save&quot; the current element we're working on with an Iterator. With the help of the Iterator, we get an O(1) efficiency for remove() and insert() when working in a LinkedList. Making it the only performance benefit I'm aware of where a LinkedList is always better than an ArrayList.</source>
          <target state="translated">Bono:Aunque no hay manera de hacer estos dos métodos O(1)para una Lista de Arreglos,en realidad hay una manera de hacerlo en las Listas de Enlaces.Digamos que queremos recorrer toda la Lista quitando e insertando elementos en nuestro camino.Normalmente,se empezaría desde el principio para cada elemento usando la LinkedList,también podríamos &quot;guardar&quot; el elemento actual en el que estamos trabajando con un Iterator.Con la ayuda del Iterator,obtenemos una eficiencia O(1)para quitar()e insertar()cuando trabajamos en una LinkedList.Haciendo de esto el único beneficio de rendimiento que conozco,donde una LinkedList es siempre mejor que una ArrayList.</target>
        </trans-unit>
        <trans-unit id="f37c5042d81ce8b4bbe2d96a4545bbab34eb146f" translate="yes" xml:space="preserve">
          <source>Both ArrayList and LinkedList are implementation of List interface.</source>
          <target state="translated">Tanto el ArrayList como el LinkedList son una implementación de la interfaz de la Lista.</target>
        </trans-unit>
        <trans-unit id="71f1ed7fc912117c5c42591efe3f6f8fa7782142" translate="yes" xml:space="preserve">
          <source>Both remove() and insert() have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However, the reason behind the linear processing time comes from two very different reasons:</source>
          <target state="translated">Tanto remove()como insert()tienen una eficiencia de tiempo de ejecución de O(n)tanto para ArrayLists como LinkedLists.Sin embargo,la razón detrás del tiempo de procesamiento lineal proviene de dos razones muy diferentes:</target>
        </trans-unit>
        <trans-unit id="daf0773dc6de1ad67b93748501d5e5e954fbb69d" translate="yes" xml:space="preserve">
          <source>Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.</source>
          <target state="translated">Ambas clases no están sincronizadas y pueden sincronizarse explícitamente mediante el método Collections.synchronizedList.</target>
        </trans-unit>
        <trans-unit id="de704239e812c1c915cb01038eee251cbcaf16df" translate="yes" xml:space="preserve">
          <source>Conclusion: LinkedList element deletion is faster compared to
  ArrayList.</source>
          <target state="translated">Conclusión:La eliminación de elementos de LinkedList es más rápida comparada con la de ArrayList.</target>
        </trans-unit>
        <trans-unit id="f180d58cc543a593a06f0503cdd233ebc9c5759c" translate="yes" xml:space="preserve">
          <source>Copying a sequential bulk of memory is an operation optimized by the modern CPUs - changing theory and actually making, again, &lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;Vector&lt;/code&gt; much more efficient</source>
          <target state="translated">Copiar una gran cantidad de memoria secuencial es una operaci&amp;oacute;n optimizada por las CPU modernas, cambiando la teor&amp;iacute;a y haciendo que, nuevamente, &lt;code&gt;ArrayList&lt;/code&gt; / &lt;code&gt;Vector&lt;/code&gt; sea mucho m&amp;aacute;s eficiente</target>
        </trans-unit>
        <trans-unit id="1f74715932ed85186b45cbf00a18b0aa012ba91d" translate="yes" xml:space="preserve">
          <source>Correct or Incorrect: Please execute test locally and decide for yourself!</source>
          <target state="translated">Correcto o incorrecto:Por favor,ejecute la prueba localmente y decida por usted mismo!</target>
        </trans-unit>
        <trans-unit id="78ddc4712fca5a2025e62dc663ca11c5d278f6c7" translate="yes" xml:space="preserve">
          <source>Credits: All benchmarks posted here are created by &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt;. Even more data can be found on &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;his blog&lt;/a&gt;</source>
          <target state="translated">Cr&amp;eacute;ditos: todos los puntos de referencia publicados aqu&amp;iacute; son creados por &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt; . Incluso se pueden encontrar m&amp;aacute;s datos en &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;su blog&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="779504bb746658eb51a895ef325a2c35e22145fa" translate="yes" xml:space="preserve">
          <source>Does anyone actually use LinkedList?  I wrote it, and I never use it.</source>
          <target state="translated">¿Alguien usa realmente LinkedList? Yo la escribí y nunca la uso.</target>
        </trans-unit>
        <trans-unit id="c5b4ee91f9f7d7536fb951869ce3310ca5d5e5c8" translate="yes" xml:space="preserve">
          <source>Edit/Remove is faster in &lt;code&gt;LinkedList&lt;/code&gt; than &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">Editar / Eliminar es m&amp;aacute;s r&amp;aacute;pido en &lt;code&gt;LinkedList&lt;/code&gt; que &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4bd4d47e6eb0dd8326522867ae2cebb9d911a9" translate="yes" xml:space="preserve">
          <source>Even when big-O performance is the same as &lt;code&gt;ArrayList&lt;/code&gt;, it is probably going to be significantly slower anyway.</source>
          <target state="translated">Incluso cuando el rendimiento big-O es el mismo que &lt;code&gt;ArrayList&lt;/code&gt; , probablemente ser&amp;aacute; significativamente m&amp;aacute;s lento de todos modos.</target>
        </trans-unit>
        <trans-unit id="a717e212f108315f6468fbbac65115039dbc3186" translate="yes" xml:space="preserve">
          <source>Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.</source>
          <target state="translated">Cada vez que tengo un método que devuelve una lista de datos obtenidos de una BD siempre uso una LinkedList.</target>
        </trans-unit>
        <trans-unit id="d98c1a4ef5e0db31dd47ee47986d318181c0c1aa" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Para &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85cdf2bee1991274487c8b867c3e971ab9c35e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Para &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e02d61f3770600b7462828f335d485c3c7c88fd7" translate="yes" xml:space="preserve">
          <source>From all the above differences between ArrayList vs LinkedList, It looks ArrayList is the better choice than LinkedList in almost all cases, except when you do a frequent add() operation than remove(), or get().</source>
          <target state="translated">De todas las diferencias anteriores entre ArrayList y LinkedList,parece que ArrayList es la mejor opción que LinkedList en casi todos los casos,excepto cuando se hace una operación frecuente de add()que de remove(),o get().</target>
        </trans-unit>
        <trans-unit id="ecc2eafc3ac7b3d6cdad7d496b20ef438cc7c71b" translate="yes" xml:space="preserve">
          <source>Getting good performance is tricky.</source>
          <target state="translated">Conseguir un buen rendimiento es difícil.</target>
        </trans-unit>
        <trans-unit id="d872e08fee24bf8c30e8defc229caebca0ba87ad" translate="yes" xml:space="preserve">
          <source>Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.</source>
          <target state="translated">Por lo tanto,si hay un requisito de adición y eliminación frecuente en la aplicación,entonces LinkedList es la mejor opción.</target>
        </trans-unit>
        <trans-unit id="05cae6319d9059efe74860e4a0c6f790d26f64fc" translate="yes" xml:space="preserve">
          <source>Here are results of a benchmark testing inserting elements in random locations. As you can see - the array list if much more efficient, although in theory each insert in the middle of the list will require &quot;move&quot; the &lt;em&gt;n&lt;/em&gt; later elements of the array (lower values are better):</source>
          <target state="translated">Estos son los resultados de una prueba de referencia que inserta elementos en ubicaciones aleatorias. Como puede ver, la lista de la matriz es mucho m&amp;aacute;s eficiente, aunque en teor&amp;iacute;a cada inserci&amp;oacute;n en el medio de la lista requerir&amp;aacute; &quot;mover&quot; los &lt;em&gt;n&lt;/em&gt; elementos posteriores de la matriz (los valores m&amp;aacute;s bajos son mejores):</target>
        </trans-unit>
        <trans-unit id="4231cb0b09e1f7b1f49c5e13010868f22f729203" translate="yes" xml:space="preserve">
          <source>Here is a figure from &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; (&lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):</source>
          <target state="translated">Aqu&amp;iacute; hay una figura de &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; ( &lt;code&gt;add&lt;/code&gt; y &lt;code&gt;remove&lt;/code&gt; son el primer tipo, es decir, agregar un elemento al final de la lista y eliminar el elemento en la posici&amp;oacute;n especificada en la lista):</target>
        </trans-unit>
        <trans-unit id="72459064f382e49943817106fc4f16a28f18d010" translate="yes" xml:space="preserve">
          <source>Here is the Big-O notation in both &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; and also &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la notaci&amp;oacute;n Big-O en &lt;code&gt;ArrayList&lt;/code&gt; y &lt;code&gt;LinkedList&lt;/code&gt; y tambi&amp;eacute;n en &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">Aquí está el código:</target>
        </trans-unit>
        <trans-unit id="204bd2319ad6f28782c2fd4eac0f1c63e947287c" translate="yes" xml:space="preserve">
          <source>I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:</source>
          <target state="translated">He leído las respuestas,pero hay un escenario en el que siempre uso una LinkedList sobre una ArrayList que quiero compartir para escuchar opiniones:</target>
        </trans-unit>
        <trans-unit id="2909da23de10e510a463c3326c00b280592d1c12" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I honestly can't believe nobody mentioned that &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Deque&lt;/code&gt;.  Just look at the methods in &lt;code&gt;Deque&lt;/code&gt; (and &lt;code&gt;Queue&lt;/code&gt;); if you want a fair comparison, try running &lt;code&gt;LinkedList&lt;/code&gt; against &lt;code&gt;ArrayDeque&lt;/code&gt; and do a feature-for-feature comparison.</source>
          <target state="translated">S&amp;eacute; que esta es una publicaci&amp;oacute;n antigua, pero sinceramente, no puedo creer que nadie haya mencionado que &lt;code&gt;LinkedList&lt;/code&gt; implementa &lt;code&gt;Deque&lt;/code&gt; . Solo mira los m&amp;eacute;todos en &lt;code&gt;Deque&lt;/code&gt; (y &lt;code&gt;Queue&lt;/code&gt; ); si desea una comparaci&amp;oacute;n justa, intente ejecutar &lt;code&gt;LinkedList&lt;/code&gt; contra &lt;code&gt;ArrayDeque&lt;/code&gt; y haga una comparaci&amp;oacute;n de caracter&amp;iacute;stica por caracter&amp;iacute;stica.</target>
        </trans-unit>
        <trans-unit id="f0b70ff5fa7c09103b8eab96c986f91401d87676" translate="yes" xml:space="preserve">
          <source>I use the interface as the type name for &lt;em&gt;portability&lt;/em&gt;, so that when I ask questions such as these I can rework my code.</source>
          <target state="translated">Utilizo la interfaz como el nombre del tipo para la &lt;em&gt;portabilidad&lt;/em&gt; , de modo que cuando hago preguntas como estas, puedo modificar mi c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="c1dae44cf928d176bc4a73ed2740108af2b90993" translate="yes" xml:space="preserve">
          <source>I usually use one over the other based on the time complexities of the operations that I'd perform on that particular List.</source>
          <target state="translated">Normalmente utilizo una sobre otra en función de las complejidades temporales de las operaciones que realizaría en esa Lista en particular.</target>
        </trans-unit>
        <trans-unit id="6102d6038b559d5fad73832038782bbb5796e2a3" translate="yes" xml:space="preserve">
          <source>I'm sorry for the answer for being not that informative as the other answers, but I thought it would be the most interesting and self-explanatory.</source>
          <target state="translated">Lamento que la respuesta no sea tan informativa como las otras respuestas,pero pensé que sería la más interesante y auto-explicativa.</target>
        </trans-unit>
        <trans-unit id="a4a379c9c8db61dd6b7c09706346097b32a64868" translate="yes" xml:space="preserve">
          <source>I've always been one to simply use:</source>
          <target state="translated">Siempre he sido de los que simplemente usan:</target>
        </trans-unit>
        <trans-unit id="eb6b619bb59e99c5145eebdb33b065006bef1e99" translate="yes" xml:space="preserve">
          <source>If Array is large enough it may take a lot of memory at that point and trigger Garbage collection, which can slow response time.</source>
          <target state="translated">Si el Array es lo suficientemente grande puede tomar mucha memoria en ese punto y desencadenar la recogida de basura,lo que puede ralentizar el tiempo de respuesta.</target>
        </trans-unit>
        <trans-unit id="559de205fa8eb76d7699b1783f2b0ac89bcc4d52" translate="yes" xml:space="preserve">
          <source>If the constructor  is not overloaded, then &lt;em&gt;ArrayList&lt;/em&gt; creates an empty list of initial capacity 10, while</source>
          <target state="translated">Si el constructor no est&amp;aacute; sobrecargado, &lt;em&gt;ArrayList&lt;/em&gt; crea una lista vac&amp;iacute;a de capacidad inicial 10, mientras que</target>
        </trans-unit>
        <trans-unit id="c0e9fb39f596736adacc32d734e4edfa0a46ec4b" translate="yes" xml:space="preserve">
          <source>If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList.</source>
          <target state="translated">Si tiene operaciones de recuperación frecuentes en su aplicación,use una lista de arreglos.Si tienes frecuentes inserciones y eliminaciones usa una LinkedList.</target>
        </trans-unit>
        <trans-unit id="aaba92fb463b8690a69e81dfffc7a5658f1bd75e" translate="yes" xml:space="preserve">
          <source>If your code has &lt;code&gt;add(0)&lt;/code&gt; and &lt;code&gt;remove(0)&lt;/code&gt;, use a &lt;code&gt;LinkedList&lt;/code&gt; and it's prettier &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;removeFirst()&lt;/code&gt; methods. Otherwise, use &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">Si su c&amp;oacute;digo tiene &lt;code&gt;add(0)&lt;/code&gt; y &lt;code&gt;remove(0)&lt;/code&gt; , use un &lt;code&gt;LinkedList&lt;/code&gt; y es m&amp;aacute;s bonito &lt;code&gt;addFirst()&lt;/code&gt; y &lt;code&gt;removeFirst()&lt;/code&gt; m&amp;eacute;todos. De lo contrario, use &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ab91dd60a4bdc4332a1f000c5a31d8298e3443" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;ArrayList&lt;/em&gt;  each index only holds the actual object(data).</source>
          <target state="translated">En &lt;em&gt;ArrayList,&lt;/em&gt; cada &amp;iacute;ndice solo contiene el objeto real (datos).</target>
        </trans-unit>
        <trans-unit id="4e651e52f60a7d33d19241c9b84a7e5ebf5e0d7c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;LinkedList&lt;/em&gt;, there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1). The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as a parameter. This method traverses the LinkedList until it found the Object and unlink it from the original list. Hence this method runtime is O(n).</source>
          <target state="translated">En &lt;em&gt;LinkedList&lt;/em&gt; , hay dos m&amp;eacute;todos de eliminaci&amp;oacute;n sobrecargados. uno es remove () sin ning&amp;uacute;n par&amp;aacute;metro que elimine el encabezado de la lista y se ejecute en tiempo constante O (1). El otro m&amp;eacute;todo de eliminaci&amp;oacute;n sobrecargado en LinkedList es remove (int) o remove (Object) que elimina el Object o int pasado como par&amp;aacute;metro. Este m&amp;eacute;todo atraviesa LinkedList hasta que encuentra el Object y lo desvincula de la lista original. Por lo tanto, este m&amp;eacute;todo de tiempo de ejecuci&amp;oacute;n es O (n).</target>
        </trans-unit>
        <trans-unit id="4035507a1bd4880689b50032e852bc42590238de" translate="yes" xml:space="preserve">
          <source>In a LinkedList, it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for remove() and 2 references for insert().</source>
          <target state="translated">En una ListaEnlazada,se necesita O(n)para llegar realmente al elemento deseado,porque tenemos que empezar desde el principio hasta que alcancemos el índice deseado.La extracción o inserción es constante,porque sólo tenemos que cambiar 1 referencia para extraer()y 2 referencias para insertar().</target>
        </trans-unit>
        <trans-unit id="6d3d827792739e9f193e4b6dedde2b63bd92348f" translate="yes" xml:space="preserve">
          <source>In addition to the other good arguments above, you should notice &lt;code&gt;ArrayList&lt;/code&gt; implements &lt;code&gt;RandomAccess&lt;/code&gt; interface, while &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Queue&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de los otros buenos argumentos anteriores, debe notar que &lt;code&gt;ArrayList&lt;/code&gt; implementa la interfaz &lt;code&gt;RandomAccess&lt;/code&gt; , mientras que &lt;code&gt;LinkedList&lt;/code&gt; implementa &lt;code&gt;Queue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35842b5d82e361cdd7f51df865bca0c300db2026" translate="yes" xml:space="preserve">
          <source>In an ArrayList, you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.</source>
          <target state="translated">En una ArrayList,se llega al elemento en O(1),pero en realidad quitar o insertar algo lo convierte en O(n)porque todos los siguientes elementos deben ser cambiados.</target>
        </trans-unit>
        <trans-unit id="e8946d8d5170bc375bf87f8b5c440661d618b2c2" translate="yes" xml:space="preserve">
          <source>In arraylist</source>
          <target state="translated">En la lista</target>
        </trans-unit>
        <trans-unit id="4a8bb3c134e78f4fa8de3dd3133fe5675a10a71e" translate="yes" xml:space="preserve">
          <source>In my opinion, use ArrayList over LinkedList for most of the practical purpose in Java.</source>
          <target state="translated">En mi opinión,usar ArrayList sobre LinkedList para la mayoría de los propósitos prácticos en Java.</target>
        </trans-unit>
        <trans-unit id="60daaf72544dd78c2fbc88ad20ed774a9a6e7cea" translate="yes" xml:space="preserve">
          <source>In order to remove an element from a particular index e.g. by calling remove(index), ArrayList performs a copy operation which makes it close to O(n) while LinkedList needs to traverse to that point which also makes it O(n/2), as it can traverse from either direction based upon proximity.</source>
          <target state="translated">Para eliminar un elemento de un índice determinado,por ejemplo,llamando a remove(index),ArrayList realiza una operación de copia que lo hace cercano a O(n),mientras que LinkedList necesita atravesar hasta ese punto que también lo hace O(n2),ya que puede atravesar desde cualquier dirección basándose en la proximidad.</target>
        </trans-unit>
        <trans-unit id="13af662866647dd21beac5b84de614ccdd269669" translate="yes" xml:space="preserve">
          <source>In other words, you don't need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes O(n) operation. For example, inserting or deleting an element in the middle of a linked list.</source>
          <target state="translated">En otras palabras,no es necesario atravesar la lista de enlaces para llegar a la posición en la que se desea añadir elementos,en ese caso,la adición se convierte en operación O(n).Por ejemplo,insertar o eliminar un elemento en medio de una lista vinculada.</target>
        </trans-unit>
        <trans-unit id="469c98ead6182a42fb433736049690f3bc9751a6" translate="yes" xml:space="preserve">
          <source>In theory, LinkedList has an O(1) for the &lt;code&gt;add(E element)&lt;/code&gt;</source>
          <target state="translated">En teor&amp;iacute;a, LinkedList tiene un O (1) para el &lt;code&gt;add(E element)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c381b0a433efc57cbfa3356f3a84f33fb983fb0" translate="yes" xml:space="preserve">
          <source>Insertions in &lt;em&gt;LinkedList&lt;/em&gt; are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation .</source>
          <target state="translated">Las inserciones en &lt;em&gt;LinkedList&lt;/em&gt; son generalmente r&amp;aacute;pidas en comparaci&amp;oacute;n con ArrayList. En LinkedList, agregar o insertar es una operaci&amp;oacute;n O (1).</target>
        </trans-unit>
        <trans-unit id="c767ed4fab63fed391201351f4e44d98a283934b" translate="yes" xml:space="preserve">
          <source>It can be said that it was basically created to overcome the drawbacks of arrays</source>
          <target state="translated">Se puede decir que fue creado básicamente para superar los inconvenientes de las matrices</target>
        </trans-unit>
        <trans-unit id="67433abb43ee77013dd1057bd5c859af9a33433f" translate="yes" xml:space="preserve">
          <source>It depends upon what operations you will be doing more on the List.</source>
          <target state="translated">Depende de las operaciones que haga más en la Lista.</target>
        </trans-unit>
        <trans-unit id="23b28df1a3e51ae95f5d0a5b0aa39bb036813e19" translate="yes" xml:space="preserve">
          <source>It uses lots of small memory objects, and therefore impacts performance across the process.</source>
          <target state="translated">Utiliza muchos objetos pequeños de memoria,y por lo tanto impacta en el rendimiento a lo largo del proceso.</target>
        </trans-unit>
        <trans-unit id="8809d3c8954d5fee422f743b686ee6e92e9dc70a" translate="yes" xml:space="preserve">
          <source>It's an efficiency question. &lt;code&gt;LinkedList&lt;/code&gt; is fast for adding and deleting elements, but slow to access a specific element. &lt;code&gt;ArrayList&lt;/code&gt; is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.</source>
          <target state="translated">Es una pregunta de eficiencia. &lt;code&gt;LinkedList&lt;/code&gt; es r&amp;aacute;pido para agregar y eliminar elementos, pero lento para acceder a un elemento espec&amp;iacute;fico. &lt;code&gt;ArrayList&lt;/code&gt; es r&amp;aacute;pido para acceder a un elemento espec&amp;iacute;fico, pero puede ser lento para agregar a cualquier extremo, y especialmente lento para eliminar en el medio.</target>
        </trans-unit>
        <trans-unit id="4b15e68efa8079d20e58d4612e98609845672742" translate="yes" xml:space="preserve">
          <source>It's easier to modify a linked list than ArrayList, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in O(1) time.</source>
          <target state="translated">Es más fácil modificar una lista enlazada que la ArrayList,especialmente si se están añadiendo o eliminando elementos desde el principio o el final,porque la lista enlazada guarda internamente referencias de esas posiciones y son accesibles en tiempo O(1).</target>
        </trans-unit>
        <trans-unit id="adc8d1e49ddd7e5e06471d7adc23a73d72dc8d87" translate="yes" xml:space="preserve">
          <source>It's jarring to see &lt;code&gt;LinkedList&lt;/code&gt; in source because it is probably the wrong choice.</source>
          <target state="translated">Es discordante ver &lt;code&gt;LinkedList&lt;/code&gt; en la fuente porque probablemente sea la elecci&amp;oacute;n incorrecta.</target>
        </trans-unit>
        <trans-unit id="6e438c304d6715de1cd8a3be3097d2b636828262" translate="yes" xml:space="preserve">
          <source>Iteration is the O(n) operation for both LinkedList and ArrayList where n is a number of an element.</source>
          <target state="translated">La iteración es la operación O(n)tanto para LinkedList como para ArrayList donde n es un número de un elemento.</target>
        </trans-unit>
        <trans-unit id="196cfc0783541b18906b878964f90c2beb521995" translate="yes" xml:space="preserve">
          <source>Joshua Bloch, the author of LinkedList:</source>
          <target state="translated">Joshua Bloch,el autor de LinkedList:</target>
        </trans-unit>
        <trans-unit id="b6bf53be71cb03cefc9204127bcad931b18969a2" translate="yes" xml:space="preserve">
          <source>Just to make the point even clearer, please check the benchmark of adding elements to the beginning of the list. This is a use-case where, in-theory, the &lt;code&gt;LinkedList&lt;/code&gt; should really shine, and &lt;code&gt;ArrayList&lt;/code&gt; should present poor or even worse-case results:</source>
          <target state="translated">Solo para aclarar el punto, verifique el punto de referencia de agregar elementos al comienzo de la lista. Este es un caso de uso en el que, en teor&amp;iacute;a, &lt;code&gt;LinkedList&lt;/code&gt; realmente deber&amp;iacute;a brillar, y &lt;code&gt;ArrayList&lt;/code&gt; deber&amp;iacute;a presentar resultados pobres o incluso peores:</target>
        </trans-unit>
        <trans-unit id="1f2e1c89c968aef7dc16623190b3a9a9cabbc8b4" translate="yes" xml:space="preserve">
          <source>Let's compare LinkedList and ArrayList w.r.t. below parameters:</source>
          <target state="translated">Comparemos LinkedList y ArrayList w.r.t.bajo los parámetros:</target>
        </trans-unit>
        <trans-unit id="93306f9c4f0e542bbb9a628ab7325be853345914" translate="yes" xml:space="preserve">
          <source>Link: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</source>
          <target state="translated">Enlace: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a422cc360ccdd0ef7b3dda2d174720a459804d83" translate="yes" xml:space="preserve">
          <source>LinkedList is &lt;em&gt;almost always&lt;/em&gt; the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList's ability to insert and delete elements in the middle of the list relatively quickly, once you've navigated there with a ListIterator.</source>
          <target state="translated">LinkedList es &lt;em&gt;casi siempre&lt;/em&gt; la elecci&amp;oacute;n incorrecta, en cuanto al rendimiento. Hay algunos algoritmos muy espec&amp;iacute;ficos en los que se requiere LinkedList, pero son muy, muy raros y el algoritmo generalmente depender&amp;aacute; espec&amp;iacute;ficamente de la capacidad de LinkedList para insertar y eliminar elementos en el medio de la lista relativamente r&amp;aacute;pido, una vez que haya navegado all&amp;iacute;. con un ListIterator.</target>
        </trans-unit>
        <trans-unit id="10b1b645b01085ffebf0f6f3f088eea7172b5aa1" translate="yes" xml:space="preserve">
          <source>LinkedList takes much more time to accomplish the same job. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">LinkedList tarda mucho m&amp;aacute;s tiempo en realizar el mismo trabajo. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;c&amp;oacute;digo&lt;/a&gt; &lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;fuente&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f79cef427b354d9b9780eab17c5d356d4a5b006e" translate="yes" xml:space="preserve">
          <source>LinkedList uses a wrapper object, Entry, which is a static nested class for storing data and two nodes next and previous while ArrayList just stores data in Array.</source>
          <target state="translated">LinkedList utiliza un objeto de envoltura,Entry,que es una clase estática anidada para almacenar datos y dos nodos siguientes y anteriores,mientras que ArrayList sólo almacena datos en Array.</target>
        </trans-unit>
        <trans-unit id="7e1c7bcef7896ae52260cfcb6d33ba65b28b0065" translate="yes" xml:space="preserve">
          <source>Lots of small objects are bad for cache-locality.</source>
          <target state="translated">Muchos objetos pequeños son malos para la localidad del caché.</target>
        </trans-unit>
        <trans-unit id="d1ac372c327cce8ede5e07a803bfe591166259d1" translate="yes" xml:space="preserve">
          <source>Memory overhead in &lt;em&gt;LinkedList&lt;/em&gt; is more as compared to ArrayList as a node in LinkedList needs to maintain the addresses of the next and previous node. While</source>
          <target state="translated">La sobrecarga de memoria en &lt;em&gt;LinkedList&lt;/em&gt; es m&amp;aacute;s en comparaci&amp;oacute;n con ArrayList, ya que un nodo en LinkedList necesita mantener las direcciones del nodo siguiente y anterior. Mientras</target>
        </trans-unit>
        <trans-unit id="e5657da09258adb4a01a06b7e549b6f276681445" translate="yes" xml:space="preserve">
          <source>My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.</source>
          <target state="translated">Mi razonamiento era que,como es imposible saber exactamente cuántos resultados estoy obteniendo,no se desperdiciará la memoria (como en ArrayList con la diferencia entre la capacidad y el número real de elementos),y no se perderá tiempo tratando de duplicar la capacidad.</target>
        </trans-unit>
        <trans-unit id="d7c000eee7e0c05260bee34ed1a23873f4661337" translate="yes" xml:space="preserve">
          <source>Note: this is a benchmark of the C++ Std lib, but my previous experience shown the C++ and Java results are very similar. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">Nota: este es un punto de referencia de C ++ Std lib, pero mi experiencia previa mostr&amp;oacute; que los resultados de C ++ y Java son muy similares. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;C&amp;oacute;digo fuente&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="43117d0643c36e2f29277032a262d30828a4ea76" translate="yes" xml:space="preserve">
          <source>O(n) worst, O(1) amortized</source>
          <target state="translated">O(n)peor,O(1)amortizado</target>
        </trans-unit>
        <trans-unit id="2613d66d9e3e9d1d2cb152a0c8c768f97ed252f6" translate="yes" xml:space="preserve">
          <source>On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.</source>
          <target state="translated">Por otro lado,la inserción y la eliminación en una ListaEnlazada son mucho más fáciles porque sólo hay que cambiar los punteros mientras que una ListaEnlazada implica el uso de la operación de cambio para cualquier inserción o eliminación.</target>
        </trans-unit>
        <trans-unit id="33a2811cec1cd04c38e25706ff20270bb3aa420c" translate="yes" xml:space="preserve">
          <source>One of the tests I saw on here only conducts the test once.  But what I have noticed is that you need to run these tests many times and eventually their times will converge.  Basically the JVM needs to warm up.  For my particular use case I needed to add/remove items to a list that grows to about 500 items.  In my tests &lt;code&gt;LinkedList&lt;/code&gt; came out faster, with &lt;code&gt;LinkedList&lt;/code&gt; coming in around 50,000 NS and &lt;code&gt;ArrayList&lt;/code&gt; coming in at around 90,000 NS... give or take.  See the code below.</source>
          <target state="translated">Una de las pruebas que vi aqu&amp;iacute; solo realiza la prueba una vez. Pero lo que he notado es que necesita ejecutar estas pruebas muchas veces y, finalmente, sus tiempos converger&amp;aacute;n. B&amp;aacute;sicamente, la JVM necesita calentarse. Para mi caso de uso particular, necesitaba agregar / eliminar elementos a una lista que crezca a unos 500 elementos. En mis pruebas, &lt;code&gt;LinkedList&lt;/code&gt; sali&amp;oacute; m&amp;aacute;s r&amp;aacute;pido, con &lt;code&gt;LinkedList&lt;/code&gt; llegando a alrededor de 50,000 NS y &lt;code&gt;ArrayList&lt;/code&gt; llegando a alrededor de 90,000 NS ... m&amp;aacute;s o menos. Ver el c&amp;oacute;digo a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="65dac500e2d3e9f09ada76f29721043fd8c863b6" translate="yes" xml:space="preserve">
          <source>Operation get(i) in ArrayList is faster than LinkedList, because:</source>
          <target state="translated">La operación get(i)en ArrayList es más rápida que LinkedList,porque:</target>
        </trans-unit>
        <trans-unit id="0a5c295d42604c7d58d32363d3f4396711e52d07" translate="yes" xml:space="preserve">
          <source>Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</source>
          <target state="translated">Las operaciones que se indexan en la lista recorrerán la lista desde el principio o el final,lo que se acerque más al índice especificado.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b3bfed3bf17cc4ccb5b52051ae69c0e7857b3e8" translate="yes" xml:space="preserve">
          <source>Practice is very different, as LinkedList is a &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data structure. From performance POV - there are very little cases where &lt;code&gt;LinkedList&lt;/code&gt; could be better performing than the &lt;em&gt;Cache-friendly&lt;/em&gt;&lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">La pr&amp;aacute;ctica es muy diferente, ya que LinkedList es una estructura de datos &lt;strong&gt;hostiles de cach&amp;eacute;&lt;/strong&gt; . Desde el punto de vista del rendimiento: hay muy pocos casos en los que &lt;code&gt;LinkedList&lt;/code&gt; podr&amp;iacute;a tener un mejor rendimiento que el &lt;code&gt;ArrayList&lt;/code&gt; compatible con &lt;em&gt;cach&amp;eacute;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cca9612e17514e1ec64192796cfa4e74465f72b1" translate="yes" xml:space="preserve">
          <source>Reason: LinkedList&amp;rsquo;s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.</source>
          <target state="translated">Motivo: cada elemento de LinkedList mantiene dos punteros (direcciones) que apuntan a los dos elementos vecinos en la lista. Por lo tanto, la eliminaci&amp;oacute;n solo requiere un cambio en la ubicaci&amp;oacute;n del puntero en los dos nodos vecinos (elementos) del nodo que se va a eliminar. Mientras que en ArrayList, todos los elementos deben desplazarse para completar el espacio creado por el elemento eliminado.</target>
        </trans-unit>
        <trans-unit id="f68c820e0a45856c839ded9a5dcddfe8ab72ecae" translate="yes" xml:space="preserve">
          <source>Remove operation in LinkedList is generally the same as ArrayList i.e. O(n).</source>
          <target state="translated">La operación de eliminación en LinkedList es generalmente la misma que en ArrayList,es decir,O(n).</target>
        </trans-unit>
        <trans-unit id="73ae9a70388443373dde5d5fe2540131469bd3ca" translate="yes" xml:space="preserve">
          <source>Search (&lt;code&gt;get method&lt;/code&gt;) operations are fast in &lt;code&gt;Arraylist (O(1))&lt;/code&gt; but not in &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</source>
          <target state="translated">Las operaciones de b&amp;uacute;squeda ( &lt;code&gt;get method&lt;/code&gt; ) son r&amp;aacute;pidas en &lt;code&gt;Arraylist (O(1))&lt;/code&gt; pero no en &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="beb9ed0bbc3bb6fd7e6c2e425c684fb4a813730a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;the Java Tutorials - List Implementations&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;los Tutoriales de Java - Implementaciones de listas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f41eea01e67c4b4218cd4f1b61ae00436827205" translate="yes" xml:space="preserve">
          <source>Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.</source>
          <target state="translated">Del mismo modo,puedes obtener un mejor rendimiento en una aplicación a partir del rendimiento predeterminado del recolector de basura permanente,pero una vez que obtienes aplicaciones de Java con montones de 10 GB puedes terminar bloqueando la aplicación durante 25 segundos durante un GC completo,lo que provoca tiempos muertos y fallos en las aplicaciones SOA y estropea tus SLA si ocurre con demasiada frecuencia.A pesar de que el colector de CMS requiere más recursos y no logra el mismo rendimiento bruto,es una opción mucho mejor porque tiene una latencia más predecible y más pequeña.</target>
        </trans-unit>
        <trans-unit id="c7f07cd9a6f95a46d6ba5320ac3e54b3e0920e1e" translate="yes" xml:space="preserve">
          <source>Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit &lt;code&gt;LinkedLists&lt;/code&gt; and &lt;code&gt;ArrayLists&lt;/code&gt;.</source>
          <target state="translated">Como las referencias son de 32 o 64 bits (incluso cuando son nulas) en sus sistemas relativos, he incluido 4 conjuntos de datos para &lt;code&gt;LinkedLists&lt;/code&gt; y &lt;code&gt;ArrayLists&lt;/code&gt; de 32 y 64 bits.</target>
        </trans-unit>
        <trans-unit id="69eebcd50b0954ecfc33ccabe9d8b7d4f9117ee9" translate="yes" xml:space="preserve">
          <source>So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an &lt;code&gt;ArrayList&lt;/code&gt; is technically faster, but unless you're doing something really performance-sensitive, you shouldn't worry about this -- they're both constants.)</source>
          <target state="translated">Entonces, dependiendo de las operaciones que pretenda hacer, debe elegir las implementaciones en consecuencia. Iterar sobre cualquier tipo de Lista es pr&amp;aacute;cticamente igual de barato. (Iterar sobre una &lt;code&gt;ArrayList&lt;/code&gt; es t&amp;eacute;cnicamente m&amp;aacute;s r&amp;aacute;pido, pero a menos que est&amp;eacute; haciendo algo realmente sensible al rendimiento, no debe preocuparse por esto: ambas son constantes).</target>
        </trans-unit>
        <trans-unit id="9d8873955ed68a6d3afa3fc542ef7842e5776761" translate="yes" xml:space="preserve">
          <source>So memory requirement seems less in the case of ArrayList than LinkedList except for the case where Array performs the re-size operation when it copies content from one Array to another.</source>
          <target state="translated">Por lo tanto,el requisito de memoria parece menor en el caso de ArrayList que en el de LinkedList,excepto en el caso de que Array realice la operación de redimensionamiento cuando copie el contenido de un Array a otro.</target>
        </trans-unit>
        <trans-unit id="d29bcb90791eb28700c5ec8a4791f07074a61ec0" translate="yes" xml:space="preserve">
          <source>So, somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).</source>
          <target state="translated">Así que,de alguna manera abordan problemas ligeramente diferentes,con diferencias de eficiencia y comportamiento (ver su lista de métodos).</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="2723794bb959da323543cd3bc1ef514d3209ea99" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;</source>
          <target state="translated">Fuente: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;N&amp;uacute;meros de latencia que todo programador debe saber&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12d5ff1ccac20df183eacef481ad79a3b1d74a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; is pretty clear. O(1) for &lt;code&gt;ArrayList&lt;/code&gt;, because &lt;code&gt;ArrayList&lt;/code&gt; allow random access by using index. O(n) for &lt;code&gt;LinkedList&lt;/code&gt;, because it needs to find the index first. Note: there are different versions of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;get&lt;/code&gt; es bastante claro. O (1) para &lt;code&gt;ArrayList&lt;/code&gt; , porque &lt;code&gt;ArrayList&lt;/code&gt; permite el acceso aleatorio mediante el uso de index. O (n) para &lt;code&gt;LinkedList&lt;/code&gt; , porque primero necesita encontrar el &amp;iacute;ndice. Nota: hay diferentes versiones de &lt;code&gt;add&lt;/code&gt; y &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f4576a7bc64b7bfc1b683a9a061390ec3813c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; returned by these classes are &lt;code&gt;fail-fast&lt;/code&gt; (if list is structurally modified at any time after the iterator is created, in any way except through the &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; own remove or add methods, the iterator will &lt;code&gt;throw&lt;/code&gt; a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;).</source>
          <target state="translated">El &lt;code&gt;iterator&lt;/code&gt; y el &lt;code&gt;listIterator&lt;/code&gt; devueltos por estas clases son &lt;code&gt;fail-fast&lt;/code&gt; (si la lista se modifica estructuralmente en cualquier momento despu&amp;eacute;s de que se crea el iterador, de cualquier manera, excepto a trav&amp;eacute;s de los propios m&amp;eacute;todos remove o add del iterador, el iterador &lt;code&gt;throw&lt;/code&gt; una &lt;code&gt;ConcurrentModificationException&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e215678d488569b16687c62fc0c1cecd7a06b204" translate="yes" xml:space="preserve">
          <source>The LinkedList class extends AbstractSequentialList and implements List,Deque, and Queue interface.</source>
          <target state="translated">La clase LinkedList extiende AbstractSequentialList e implementa la interfaz List,Deque y Queue.</target>
        </trans-unit>
        <trans-unit id="a584c17550a71fdd1f4452edc00d3a4572783158" translate="yes" xml:space="preserve">
          <source>The default initial capacity of an &lt;code&gt;ArrayList&lt;/code&gt; is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you're going to add a lot of elements, construct the &lt;code&gt;ArrayList&lt;/code&gt; with a higher initial capacity.</source>
          <target state="translated">La capacidad inicial predeterminada de una &lt;code&gt;ArrayList&lt;/code&gt; es bastante peque&amp;ntilde;a (10 de Java 1.4 - 1.8). Pero dado que la implementaci&amp;oacute;n subyacente es una matriz, se debe cambiar el tama&amp;ntilde;o de la matriz si agrega muchos elementos. Para evitar el alto costo de cambiar el tama&amp;ntilde;o cuando sabe que va a agregar muchos elementos, &lt;code&gt;ArrayList&lt;/code&gt; con una capacidad inicial m&amp;aacute;s alta.</target>
        </trans-unit>
        <trans-unit id="6a73759baa6b5937448572841c9e25224f4a4466" translate="yes" xml:space="preserve">
          <source>The first difference between ArrayList and LinkedList comes with the fact that ArrayList is backed by Array while LinkedList is backed by LinkedList. This will lead to further differences in performance.</source>
          <target state="translated">La primera diferencia entre ArrayList y LinkedList viene con el hecho de que ArrayList está respaldada por Array mientras que LinkedList está respaldada por LinkedList.Esto llevará a más diferencias en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="405c38f8ac19fd59375c5014403c7ab61e163b10" translate="yes" xml:space="preserve">
          <source>The formulas I used follow, let me know if I have done anything wrong and I will fix it up. 'b' is either 4 or 8 for 32 or 64 bit systems, and 'n' is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.</source>
          <target state="translated">Las fórmulas que he usado siguen,hazme saber si he hecho algo malo y lo arreglaré.&quot;b&quot; es 4 u 8 para sistemas de 32 o 64 bits,y &quot;n&quot; es el número de elementos.Tengan en cuenta que la razón de los mods es que todos los objetos en java ocuparán un múltiplo de 8 bytes de espacio independientemente de si se usan todos o no.</target>
        </trans-unit>
        <trans-unit id="c67ed32e3dd5ebe3398abf72bee54241312ba5f5" translate="yes" xml:space="preserve">
          <source>The get(index) operation is O(1) in ArrayList while its O(n/2) in LinkedList, as it needs to traverse till that entry. Though, in Big O notation O(n/2) is just O(n) because we ignore constants there.</source>
          <target state="translated">La operación get(index)es O(1)en ArrayList mientras que su O(n2)en LinkedList,ya que necesita recorrer hasta esa entrada.Sin embargo,en la notación Big O,O(n2)es sólo O(n)porque ignoramos las constantes allí.</target>
        </trans-unit>
        <trans-unit id="ebbe3e7e54ca846d40859c9cd5c54f9e245ba147" translate="yes" xml:space="preserve">
          <source>The main benefits of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you re-use existing iterators to insert and remove elements. These operations can then be done in &lt;em&gt;O(1)&lt;/em&gt; by changing the list locally only. In an array list, the remainder of the array needs to be &lt;em&gt;moved&lt;/em&gt; (i.e. copied). On the other side, seeking in a &lt;code&gt;LinkedList&lt;/code&gt; means following the links in &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/2&lt;/em&gt; steps) for worst case, whereas in an &lt;code&gt;ArrayList&lt;/code&gt; the desired position can be computed mathematically and accessed in &lt;em&gt;O(1)&lt;/em&gt;.</source>
          <target state="translated">Los principales beneficios del uso de &lt;code&gt;LinkedList&lt;/code&gt; surgen cuando reutiliza los iteradores existentes para insertar y eliminar elementos. Estas operaciones se pueden hacer en &lt;em&gt;O (1)&lt;/em&gt; cambiando la lista solo localmente. En una lista de matriz, el resto de la matriz debe &lt;em&gt;moverse&lt;/em&gt; (es decir, copiarse). Por otro lado, buscar en un &lt;code&gt;LinkedList&lt;/code&gt; significa seguir los enlaces en &lt;em&gt;O (n)&lt;/em&gt; ( &lt;em&gt;n / 2&lt;/em&gt; pasos) para el peor de los casos, mientras que en un &lt;code&gt;ArrayList&lt;/code&gt; la posici&amp;oacute;n deseada se puede calcular matem&amp;aacute;ticamente y acceder a ella en &lt;em&gt;O (1)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b74b1e781ca90526e83c42ffc3d14526c49736ab" translate="yes" xml:space="preserve">
          <source>The reason behind &lt;em&gt;ArrayList&lt;/em&gt; being faster than LinkedList is that ArrayList uses an index based system for its elements as it internally uses an array data structure, on the other hand,</source>
          <target state="translated">La raz&amp;oacute;n por la que &lt;em&gt;ArrayList&lt;/em&gt; es m&amp;aacute;s r&amp;aacute;pido que LinkedList es que ArrayList usa un sistema basado en &amp;iacute;ndices para sus elementos, ya que internamente usa una estructura de datos de matriz, por otro lado,</target>
        </trans-unit>
        <trans-unit id="2f3082915f897c89bedc037a984915a010f1935c" translate="yes" xml:space="preserve">
          <source>The result clearly shows that &lt;code&gt;LinkedList&lt;/code&gt; is a whole lot more than &lt;code&gt;ArrayList&lt;/code&gt;, especially with a very high element count. If memory is a factor, steer clear of &lt;code&gt;LinkedLists&lt;/code&gt;.</source>
          <target state="translated">El resultado muestra claramente que &lt;code&gt;LinkedList&lt;/code&gt; es mucho m&amp;aacute;s que &lt;code&gt;ArrayList&lt;/code&gt; , especialmente con un recuento de elementos muy alto. Si la memoria es un factor, mant&amp;eacute;ngase alejado de &lt;code&gt;LinkedLists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55e26f9f49b3d7c9c3c97a405002150b730e9d84" translate="yes" xml:space="preserve">
          <source>There are few similarities between these classes which are as follows:</source>
          <target state="translated">Hay pocas similitudes entre estas clases que son las siguientes:</target>
        </trans-unit>
        <trans-unit id="979f5bb981358561639406265c29e3fa18c87f2d" translate="yes" xml:space="preserve">
          <source>There are two main reasons for this:</source>
          <target state="translated">Hay dos razones principales para esto:</target>
        </trans-unit>
        <trans-unit id="51e22a50ad3da080a9975903475702d34ba04615" translate="yes" xml:space="preserve">
          <source>There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList implementation&lt;/a&gt;.  (Yes, it's from 2001, so you'll need to generify it, but I got comparable performance ratios to what's quoted in the article just now in a recent JVM)</source>
          <target state="translated">Hay un caso de uso com&amp;uacute;n en el que LinkedList supera a ArrayList: el de una cola. Sin embargo, si su objetivo es el rendimiento, en lugar de LinkedList, tambi&amp;eacute;n deber&amp;iacute;a considerar usar un ArrayBlockingQueue (si puede determinar un l&amp;iacute;mite superior en el tama&amp;ntilde;o de la cola con anticipaci&amp;oacute;n y puede permitirse asignar toda la memoria por adelantado), o esta &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;implementaci&amp;oacute;n CircularArrayList&lt;/a&gt; . (S&amp;iacute;, es de 2001, por lo que deber&amp;aacute; generarlo, pero obtuve &amp;iacute;ndices de rendimiento comparables a lo que se cita en el art&amp;iacute;culo en una reciente JVM)</target>
        </trans-unit>
        <trans-unit id="bb24115d041e92964431dc2a9a4c804a8c2714b7" translate="yes" xml:space="preserve">
          <source>They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.</source>
          <target state="translated">Ambos mantienen el orden de inserción de los elementos,lo que significa que mientras se muestran los elementos de la Lista de Arreglos y de la Lista de Enlaces,el conjunto de resultados tendría el mismo orden en el que los elementos se insertaron en la Lista.</target>
        </trans-unit>
        <trans-unit id="a7393aee9cdbf2240709c5e92b61bea76f07fd0d" translate="yes" xml:space="preserve">
          <source>Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a &lt;code&gt;LinkedList&lt;/code&gt; is &quot;lots more&quot; than an &lt;code&gt;ArrayList&lt;/code&gt; so I did some number crunching to demonstrate exactly how much both lists take up for N null references.</source>
          <target state="translated">Hasta ahora, nadie parece haber abordado la huella de memoria de cada una de estas listas adem&amp;aacute;s del consenso general de que una &lt;code&gt;LinkedList&lt;/code&gt; es &quot;mucho m&amp;aacute;s&quot; que una &lt;code&gt;ArrayList&lt;/code&gt; , por lo que hice algunos c&amp;aacute;lculos num&amp;eacute;ricos para demostrar exactamente cu&amp;aacute;nto ocupan ambas listas para N referencias nulas .</target>
        </trans-unit>
        <trans-unit id="5f0ebd31014e6d03e89c2e7c5de3ae7e005b1340" translate="yes" xml:space="preserve">
          <source>To find out more, read any article that talks about the difference between arrays and linked lists.</source>
          <target state="translated">Para saber más,lee cualquier artículo que hable de la diferencia entre las matrices y las listas vinculadas.</target>
        </trans-unit>
        <trans-unit id="29ca1dbcdfa1f09ca0ddfee47c7f010975f7b16f" translate="yes" xml:space="preserve">
          <source>Unless you've created large lists and measured a bottleneck, you'll probably never need to worry about the difference.</source>
          <target state="translated">A menos que hayas creado grandes listas y medido un cuello de botella,probablemente nunca tendrás que preocuparte por la diferencia.</target>
        </trans-unit>
        <trans-unit id="445928a04da6390fbfe641573eb932e5cdb28769" translate="yes" xml:space="preserve">
          <source>When should &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; be used over &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and vice-versa?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo debe usarse &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; sobre &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; y viceversa?</target>
        </trans-unit>
        <trans-unit id="78753f704c5e896d437844d3fb47088744b55cf9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList and when to use ArrayList?</source>
          <target state="translated">¿Cuándo usar LinkedList y cuándo usar ArrayList?</target>
        </trans-unit>
        <trans-unit id="38de968ae17bb38f4696d5acc9b08397e7f206f9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList over ArrayList in Java</source>
          <target state="translated">Cuándo usar LinkedList sobre ArrayList en Java</target>
        </trans-unit>
        <trans-unit id="8e108c13808368fe0f3f3e721de63a230cc41edf" translate="yes" xml:space="preserve">
          <source>Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.</source>
          <target state="translated">Cuál de los dos es más rápido para insertar y quitar depende de dónde ocurra.Si estamos más cerca del principio,la Lista de Enlaces será más rápida,porque tenemos que pasar por relativamente pocos elementos.Si estamos más cerca del final,la ListaEnlazada será más rápida,porque llegamos en tiempo constante y sólo tenemos que cambiar los pocos elementos restantes que le siguen.Cuando se hace precisamente en el medio,la ListaEnlazada será más rápida porque pasar por n elementos es más rápido que mover n valores.</target>
        </trans-unit>
        <trans-unit id="aa1559133ba9f967b51fb87c9d69f02e2d34fd11" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt; remove(int) method involves copying elements from the old array to new updated array, hence its runtime is O(n).</source>
          <target state="translated">Mientras que en &lt;em&gt;ArrayList, el&lt;/em&gt; m&amp;eacute;todo remove (int) implica copiar elementos de la matriz anterior a una nueva matriz actualizada, por lo tanto, su tiempo de ejecuci&amp;oacute;n es O (n).</target>
        </trans-unit>
        <trans-unit id="22fb9822109a567e96dc1961a1c75216ea996026" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt;, if the array is the full i.e worst case,  there is an extra cost of resizing array and copying elements to the new array, which makes runtime of add operation in ArrayList O(n), otherwise it is O(1).</source>
          <target state="translated">Mientras que en &lt;em&gt;ArrayList&lt;/em&gt; , si la matriz est&amp;aacute; llena, es decir, en el peor de los casos, hay un costo adicional por cambiar el tama&amp;ntilde;o de la matriz y copiar elementos a la nueva matriz, lo que hace que el tiempo de ejecuci&amp;oacute;n de la operaci&amp;oacute;n de agregar en ArrayList O (n), de lo contrario es O (1) .</target>
        </trans-unit>
        <trans-unit id="da14c4f26f81795e276c6bd693c6d365161bbd6f" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;LinkedList&lt;/code&gt; sucks:</source>
          <target state="translated">Por qu&amp;eacute; &lt;code&gt;LinkedList&lt;/code&gt; apesta:</target>
        </trans-unit>
        <trans-unit id="55541df4dcf152a08b381822d996bdf2502bee11" translate="yes" xml:space="preserve">
          <source>Working on a later generation hardware (bigger, more efficient caches) - the results are even more conclusive:</source>
          <target state="translated">Trabajando en un hardware de última generación (cachés más grandes y eficientes),los resultados son aún más concluyentes:</target>
        </trans-unit>
        <trans-unit id="a96e6d2490d18f0fcecefd52716013baa2282e27" translate="yes" xml:space="preserve">
          <source>Yeah, I know, this is an ancient question, but I'll throw in my two cents:</source>
          <target state="translated">Sí,lo sé,esta es una pregunta antigua,pero voy a tirar mis dos centavos:</target>
        </trans-unit>
        <trans-unit id="3421ce1baebeb5f24f380dc68763a8fa7781e99b" translate="yes" xml:space="preserve">
          <source>add at the end of ArrayList</source>
          <target state="translated">añadir al final de ArrayList</target>
        </trans-unit>
        <trans-unit id="d2221c6840ebc04f909e2dcc5cd06ad7d8f6932a" translate="yes" xml:space="preserve">
          <source>add to a specific index position</source>
          <target state="translated">añadir a una posición de índice específica</target>
        </trans-unit>
        <trans-unit id="b281534d3156b92bf772720eb3f8efc8a069ba16" translate="yes" xml:space="preserve">
          <source>add to the end of the list</source>
          <target state="translated">añadir al final de la lista</target>
        </trans-unit>
        <trans-unit id="4f6fa4b826aa66326567de6e0de9a55c1c55a1f6" translate="yes" xml:space="preserve">
          <source>add(E e)</source>
          <target state="translated">añadir (E e)</target>
        </trans-unit>
        <trans-unit id="72b84dc9449f12507c91ba8d78cb41d5e51adf02" translate="yes" xml:space="preserve">
          <source>add(int index, E element)</source>
          <target state="translated">add(int índice,elemento E)</target>
        </trans-unit>
        <trans-unit id="844ba48b6f4d03efb77ea996bee561e0383f6609" translate="yes" xml:space="preserve">
          <source>get(int index) or search operation</source>
          <target state="translated">get(int index)o la operación de búsqueda</target>
        </trans-unit>
        <trans-unit id="3471d553186e51c7dfeab01069130c02fa1f5d6e" translate="yes" xml:space="preserve">
          <source>hence the memory consumption is high in LinkedList comparatively.</source>
          <target state="translated">por lo que el consumo de memoria es alto en LinkedList comparativamente.</target>
        </trans-unit>
        <trans-unit id="c097d2b9e6029ded8d9e023c043cc1fd76009367" translate="yes" xml:space="preserve">
          <source>insert at specified position</source>
          <target state="translated">insertar en la posición especificada</target>
        </trans-unit>
        <trans-unit id="a9e8151e5167b5af037785aa4dc339561be644f1" translate="yes" xml:space="preserve">
          <source>insert() or add(Object) operation</source>
          <target state="translated">operación insert()o add(Object)</target>
        </trans-unit>
        <trans-unit id="9c1204571198e8877ebce850c1dfb52bd2b5a592" translate="yes" xml:space="preserve">
          <source>need to find the element first</source>
          <target state="translated">necesidad de encontrar el elemento primero</target>
        </trans-unit>
        <trans-unit id="a191f25905b311a0a098953a475e0fe58a39f999" translate="yes" xml:space="preserve">
          <source>need to find the position first</source>
          <target state="translated">necesitan encontrar la posición primero...</target>
        </trans-unit>
        <trans-unit id="847ad4fb3598032da7663514a73890f0201a0804" translate="yes" xml:space="preserve">
          <source>need to search the element first, and then shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">primero debe buscar el elemento, y luego cambiar y el posible costo de cambio de tama&amp;ntilde;o de la memoria</target>
        </trans-unit>
        <trans-unit id="aa3f74c9a865d4ab8e22742926357ae39d210034" translate="yes" xml:space="preserve">
          <source>remove a specified element</source>
          <target state="translated">eliminar un elemento específico...</target>
        </trans-unit>
        <trans-unit id="bb34c3a95d3f5f993e01a9c524699f01d857b2bc" translate="yes" xml:space="preserve">
          <source>remove element with specified index</source>
          <target state="translated">eliminar el elemento con el índice especificado</target>
        </trans-unit>
        <trans-unit id="4ac73d56678223d75eda9aae361f03cbb4efb477" translate="yes" xml:space="preserve">
          <source>remove first element of the list</source>
          <target state="translated">eliminar el primer elemento de la lista</target>
        </trans-unit>
        <trans-unit id="247a8156822c95c4f1d9153b4b6e8f6be6811d4d" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element</source>
          <target state="translated">eliminar la primera aparición del elemento especificado</target>
        </trans-unit>
        <trans-unit id="52a10c2f057161132a26d20ded67b637c1fbd40b" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element from this list</source>
          <target state="translated">eliminar la primera ocurrencia del elemento especificado de esta lista</target>
        </trans-unit>
        <trans-unit id="bd3be8adf5ced4095cfe468b4bc677c15a10ae09" translate="yes" xml:space="preserve">
          <source>remove()</source>
          <target state="translated">remove()</target>
        </trans-unit>
        <trans-unit id="e44f21ff188d5fffffea502864836471078eb47b" translate="yes" xml:space="preserve">
          <source>remove(Object o)</source>
          <target state="translated">remover(Objeto o)</target>
        </trans-unit>
        <trans-unit id="e60165c5083078c6a746b52139fb9f6097486ada" translate="yes" xml:space="preserve">
          <source>remove(int index)</source>
          <target state="translated">remove(int index)</target>
        </trans-unit>
        <trans-unit id="57ef2c48f4ed0634600c52ceb1e6d3dd7a4f0537" translate="yes" xml:space="preserve">
          <source>remove(int) operation</source>
          <target state="translated">operación de extracción (int)</target>
        </trans-unit>
        <trans-unit id="abaf93324a2d63d24596456a9a769ee878da2d71" translate="yes" xml:space="preserve">
          <source>require memory resizing cost.</source>
          <target state="translated">requieren un costo de redimensionamiento de la memoria.</target>
        </trans-unit>
        <trans-unit id="624f26f7a70b9282abd23807374f9ad938d82f14" translate="yes" xml:space="preserve">
          <source>require shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">requieren cambios y posible costo de cambio de tama&amp;ntilde;o de la memoria</target>
        </trans-unit>
        <trans-unit id="830739c4a912c77e621eacfa69ff1a2e20904588" translate="yes" xml:space="preserve">
          <source>so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.</source>
          <target state="translated">así que si hay menos operaciones de adición y eliminación y más operaciones de búsqueda requeridas,ArrayList sería su mejor apuesta.</target>
        </trans-unit>
        <trans-unit id="8afac9dd157c540d08e836d87cf840122340a4c0" translate="yes" xml:space="preserve">
          <source>there are a large number of add/remove operations</source>
          <target state="translated">hay un gran número de operaciones de adición</target>
        </trans-unit>
        <trans-unit id="8156fdb9f5fc9c9f8388d191c22e989ad6fd729e" translate="yes" xml:space="preserve">
          <source>there are no large number of random access of element</source>
          <target state="translated">no hay un gran número de acceso aleatorio al elemento</target>
        </trans-unit>
        <trans-unit id="33e994a94f2f973adcc52b6ab5eb6c4835a3b486" translate="yes" xml:space="preserve">
          <source>there is no descendingIterator() in &lt;em&gt;ArrayList&lt;/em&gt; , so we need to write our own code to iterate over the ArrayList in reverse direction.</source>
          <target state="translated">no hay descendingIterator () en &lt;em&gt;ArrayList&lt;/em&gt; , por lo que debemos escribir nuestro propio c&amp;oacute;digo para iterar sobre ArrayList en direcci&amp;oacute;n inversa.</target>
        </trans-unit>
        <trans-unit id="aacb03ae7534d3764f83b010045b893210f65a4b" translate="yes" xml:space="preserve">
          <source>whereas In linkedlist</source>
          <target state="translated">mientras que en la lista de enlaces</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
