<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/322715">
    <body>
      <group id="322715">
        <trans-unit id="823154fd74560a83cc6bee588649f9eab42ae643" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;Search:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; search operation is pretty fast compared to the &lt;code&gt;LinkedList&lt;/code&gt; search operation. &lt;code&gt;get(int index)&lt;/code&gt; in &lt;code&gt;ArrayList&lt;/code&gt; gives the performance of &lt;code&gt;O(1)&lt;/code&gt; while &lt;code&gt;LinkedList&lt;/code&gt; performance is &lt;code&gt;O(n)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;Search:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; 검색 작업은 &lt;code&gt;LinkedList&lt;/code&gt; 검색 작업에 비해 매우 빠릅니다. &lt;code&gt;ArrayList&lt;/code&gt; 의 &lt;code&gt;get(int index)&lt;/code&gt; 는 &lt;code&gt;O(1)&lt;/code&gt; 의 성능을 제공하는 반면 &lt;code&gt;LinkedList&lt;/code&gt; 성능은 &lt;code&gt;O(n)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d9dd8e774bff097745b7775bb8d0ce9bb80f0d5" translate="yes" xml:space="preserve">
          <source>1. Implementation</source>
          <target state="translated">1. 구현</target>
        </trans-unit>
        <trans-unit id="39e90e34901690aa4761ad905d14ac1d3dfdc5d3" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;Deletion:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; remove operation gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives variable performance: &lt;code&gt;O(n)&lt;/code&gt; in worst case (while removing first element) and &lt;code&gt;O(1)&lt;/code&gt; in best case (While removing last element).</source>
          <target state="translated">2) &lt;code&gt;Deletion:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; 제거 작업은 &lt;code&gt;O(1)&lt;/code&gt; 성능을 제공하고 &lt;code&gt;ArrayList&lt;/code&gt; 는 가변 성능을 제공합니다. 최악의 경우 &lt;code&gt;O(n)&lt;/code&gt; (첫 번째 요소 제거 중) 및 &lt;code&gt;O(1)&lt;/code&gt; (최상의 요소 제거 중)입니다.</target>
        </trans-unit>
        <trans-unit id="e5e97190dfb614f2fbe264bd76660de27ae359f6" translate="yes" xml:space="preserve">
          <source>2. Performance</source>
          <target state="translated">2. 성능</target>
        </trans-unit>
        <trans-unit id="35be33e4f01930f4341e2e90cad04e8ccd9b9340" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;Inserts Performance:&lt;/code&gt;&lt;code&gt;LinkedList&lt;/code&gt; add method gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives &lt;code&gt;O(n)&lt;/code&gt; in worst case. Reason is same as explained for remove.</source>
          <target state="translated">3) &lt;code&gt;Inserts Performance:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; add 메소드는 &lt;code&gt;O(1)&lt;/code&gt; 성능을 제공하고 &lt;code&gt;ArrayList&lt;/code&gt; 는 최악의 경우 &lt;code&gt;O(n)&lt;/code&gt; 을 제공합니다. 이유는 제거에 대해 설명 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cad09e39292bee8a79b011228fe0514e7c225093" translate="yes" xml:space="preserve">
          <source>3. Reverse  Iterator</source>
          <target state="translated">3. 역 반복자</target>
        </trans-unit>
        <trans-unit id="ab7a005ac90b45cd9b3e91e6392f71a58ed5d6f3" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;Memory Overhead:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains indexes and element data while &lt;code&gt;LinkedList&lt;/code&gt; maintains element data and two pointers for neighbor nodes</source>
          <target state="translated">4) &lt;code&gt;Memory Overhead:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; 는 인덱스와 요소 데이터를 유지하고 &lt;code&gt;LinkedList&lt;/code&gt; 는 요소 데이터와 인접 노드에 대한 두 개의 포인터를 유지합니다</target>
        </trans-unit>
        <trans-unit id="e450f6c0e8ad7231222f9efe27918d977874a66a" translate="yes" xml:space="preserve">
          <source>4. Initial Capacity</source>
          <target state="translated">4. 초기 용량</target>
        </trans-unit>
        <trans-unit id="d9ff1d6f80c80852e98b6ef3bb0fc8224d5df608" translate="yes" xml:space="preserve">
          <source>5. Memory Overhead</source>
          <target state="translated">5. 메모리 오버 헤드</target>
        </trans-unit>
        <trans-unit id="127cf06445897840aec95708ef603d3e04a0e331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; goes more in depth, as does 
&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot;&gt;Linked List&lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;http://www.javafaq.nu/java-article1111.html&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; 는 더 깊이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b43a5b05b6e36c0f963a65dff5cbbba5dd87c900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt;, btw, is a custom ArrayList implementation holding &lt;code&gt;Int&lt;/code&gt; (primitive type) and not Objects - hence all data is really stored adjacently - hence even more efficient.</source>
          <target state="translated">btw 인 &lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot;&gt;DynamicIntArray&lt;/a&gt; 는 Object가 아닌 &lt;code&gt;Int&lt;/code&gt; (primitive type)를 보유한 사용자 정의 ArrayList 구현이므로 모든 데이터가 실제로 인접하게 저장되므로 훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a60af0233530522d0db70105194d2d6809d47074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an &lt;code&gt;ArrayList&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; in the worst case but constant on average.</source>
          <target state="translated">반면에 &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 는 빠른 임의 읽기 액세스를 허용하므로 일정한 시간에 모든 요소를 ​​가져올 수 있습니다. 그러나 끝을 제외하고 어디에서나 추가하거나 제거하려면 개구부를 만들거나 간격을 채우기 위해 모든 후자 요소를 위로 이동해야합니다. 또한 기본 배열의 용량보다 많은 요소를 추가하면 새 배열 (크기의 1.5 배)이 할당되고 이전 배열이 새 배열로 복사되므로 &lt;code&gt;ArrayList&lt;/code&gt; 에 추가하는 것은 &lt;em&gt;O (n)&lt;/em&gt; 입니다. 최악의 경우이지만 평균은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="a7d8b017cec005f28991d76ebeb6880b6882d238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; both implements &lt;code&gt;List interface&lt;/code&gt;  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 와 &lt;code&gt;LinkedList&lt;/code&gt; 는 모두 &lt;code&gt;List interface&lt;/code&gt; 구현하며 메서드와 결과는 거의 동일합니다. 그러나 요구 사항에 따라 다른 것보다 더 나은 차이점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5b77accd97f06a73806437d14b939ebde6071c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is essentially an array. &lt;code&gt;LinkedList&lt;/code&gt; is implemented as a double linked list.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 는 본질적으로 배열입니다. &lt;code&gt;LinkedList&lt;/code&gt; 는 이중 연결 목록으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d80057e73ae69c2b5a916affaa4a8498705114f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is faster to access an indexed value. It is much worse when inserting or deleting objects.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 가 인덱스 값에 액세스하는 것이 더 빠릅니다. 개체를 삽입하거나 삭제할 때 훨씬 더 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="6b2e4c61036a69b6af002dcf70738ee96dffaaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is randomly accessible, while &lt;code&gt;LinkedList&lt;/code&gt; is really cheap to expand and remove elements from. For most cases, &lt;code&gt;ArrayList&lt;/code&gt; is fine.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 는 무작위로 액세스 가능하지만 &lt;code&gt;LinkedList&lt;/code&gt; 는 요소를 확장하고 제거하기에 실제로 저렴합니다. 대부분의 경우 &lt;code&gt;ArrayList&lt;/code&gt; 가 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8235411525223988a507c26abd524b3fcfeb5bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt; is what you want. &lt;code&gt;LinkedList&lt;/code&gt; is almost always a (performance) bug.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 는 당신이 원하는 것입니다. &lt;code&gt;LinkedList&lt;/code&gt; 는 거의 항상 (성능) 버그입니다.</target>
        </trans-unit>
        <trans-unit id="33b5deb58c1b5ecdbe2ecc3db08d5de6dd151430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&lt;/code&gt;, backed by &lt;code&gt;Array&lt;/code&gt;, which needs to be double the size, is worse in large volume application.</source>
          <target state="translated">두 배 크기가 필요한 &lt;code&gt;Array&lt;/code&gt; 로 지원되는 &lt;code&gt;ArrayList&lt;/code&gt; 는 대량 응용 프로그램에서 더 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="333d27970508614bdfa9c0f502286bf30e92e307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; 는 &lt;em&gt;O (1)&lt;/em&gt; 입니다. &amp;lt;--- &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 주요 이점 &amp;lt;E&amp;gt;</target>
        </trans-unit>
        <trans-unit id="034b1b506c582e5f2d8814254ec183017ef9f60e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;Iterator.remove()&lt;/code&gt; 는 &lt;em&gt;O (n)입니다&lt;/em&gt; (평균 &lt;em&gt;n / 2&lt;/em&gt; 단계).</target>
        </trans-unit>
        <trans-unit id="beaa8d551243d49b4d1eee05d6432e391eb33d16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; allows for constant-time insertions or removals &lt;em&gt;using iterators&lt;/em&gt;, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says &lt;em&gt;&quot;operations that index into the list will traverse the list from the beginning or the end, whichever is closer&quot;&lt;/em&gt;, so those methods are &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/4&lt;/em&gt; steps) on average, though &lt;em&gt;O(1)&lt;/em&gt; for &lt;code&gt;index = 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 는 &lt;em&gt;반복자를 사용하여&lt;/em&gt; 상수 삽입 또는 제거 &lt;em&gt;를&lt;/em&gt; 허용하지만 요소의 순차적 액세스 만 허용합니다. 즉, 목록을 앞뒤로 걸을 수 있지만 목록에서 위치를 찾는 것은 목록의 크기에 비례하여 시간이 걸립니다. Javadoc에 따르면 &lt;em&gt;&quot;목록에 색인을 생성하는 작업은 시작 또는 끝에서 목록을 순회합니다. 더 가까운 쪽&quot;&lt;/em&gt; 이라고 말하지만, 해당 메소드는 평균 &lt;em&gt;O (n)&lt;/em&gt; ( &lt;em&gt;n / 4&lt;/em&gt; 단계)이지만 &lt;em&gt;O&lt;/em&gt; &lt;code&gt;index = 0&lt;/code&gt; &lt;em&gt;(1)&lt;/em&gt; 은 index = 0</target>
        </trans-unit>
        <trans-unit id="16d80efc38b7c2ea0ff720019ddcf6be70e20363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are two different implementations of the List interface. &lt;code&gt;LinkedList&lt;/code&gt; implements it with a doubly-linked list. &lt;code&gt;ArrayList&lt;/code&gt; implements it with a dynamically re-sizing array.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 와 &lt;code&gt;ArrayList&lt;/code&gt; 는 두 가지 다른 List 인터페이스 구현입니다. &lt;code&gt;LinkedList&lt;/code&gt; 는 이중 연결 목록으로이를 구현합니다. &lt;code&gt;ArrayList&lt;/code&gt; 는 동적 크기 조정 배열로이를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d9fecaf7b1171739d7cbdff1716ddbff9a310553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinkedList&lt;/code&gt; is faster in add and remove, but slower in get. In brief, &lt;code&gt;LinkedList&lt;/code&gt; should be preferred if:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 는 추가 및 제거 속도가 빠르지 만 가져 오기 속도가 느립니다. 간단히 말해 다음과 같은 경우 &lt;code&gt;LinkedList&lt;/code&gt; 를 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dee07befa9756327e6f1f9ab15fa468c808e73e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  This is one of the main benefits of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O (1)&lt;/em&gt; 이것은 &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 의 주요 이점 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="e64862c3a1c0b96095da40a2294754310124b801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; 는 &lt;em&gt;O (n)입니다&lt;/em&gt; (평균 &lt;em&gt;n / 2&lt;/em&gt; 단계).</target>
        </trans-unit>
        <trans-unit id="25bc6fa8f8ff344c68d917a97611b91fe8f94bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reason:&lt;/code&gt;&lt;code&gt;ArrayList&lt;/code&gt; maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side &lt;code&gt;LinkedList&lt;/code&gt; implements doubly linked list which requires the traversal through all the elements for searching an element.</source>
          <target state="translated">&lt;code&gt;Reason:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; 는 목록에서 요소를 더 빨리 검색 할 수 있도록 배열 데이터 구조를 내재적으로 사용하므로 요소에 대한 색인 기반 시스템을 유지 보수합니다. 반면에 &lt;code&gt;LinkedList&lt;/code&gt; 는 요소를 검색하기 위해 모든 요소를 ​​순회해야하는 이중 연결 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="48481a079aa4dc0b62b86309c5b1f4c4656a27cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; 는 &lt;em&gt;O (1)입니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86bcfe7042d55fdf6be9e4fe7feab45ac45db87d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt; amortized, but &lt;em&gt;O(n)&lt;/em&gt; worst-case since the array must be resized and copied</source>
          <target state="translated">&lt;code&gt;add(E element)&lt;/code&gt; 는 &lt;em&gt;O (1)&lt;/em&gt; 상각되지만 배열의 크기를 조정하고 복사해야하므로 &lt;em&gt;O (n)&lt;/em&gt; 최악의 경우</target>
        </trans-unit>
        <trans-unit id="f30395d9afdb07d74da12292c1d66f1727a434a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; 는 &lt;em&gt;O (n)입니다&lt;/em&gt; (평균 &lt;em&gt;n / 2&lt;/em&gt; 단계).</target>
        </trans-unit>
        <trans-unit id="c772faf78eb3c02de68edab5a6179904996ef451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average),
but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt;  &amp;lt;--- main benefit of &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;add(int index, E element)&lt;/code&gt; 는 &lt;em&gt;O (n)&lt;/em&gt; (평균 &lt;em&gt;n / 4&lt;/em&gt; 단계)이지만 &lt;code&gt;index = 0&lt;/code&gt; 때 &lt;em&gt;O (1)&lt;/em&gt; &amp;lt;--- &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; 의 주요 이점</target>
        </trans-unit>
        <trans-unit id="fe559a7d7843b54392656da159db0507b58dd66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.add()&lt;/code&gt; is  O(1) and &lt;code&gt;linkedlist.add()&lt;/code&gt; is 0(1)</source>
          <target state="translated">&lt;code&gt;arraylist.add()&lt;/code&gt; 는 O (1)이고 &lt;code&gt;linkedlist.add()&lt;/code&gt; 는 0 (1)</target>
        </trans-unit>
        <trans-unit id="03269f8a98a307f7cfd06520bf46af87990ad50c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.contains()&lt;/code&gt; is O(n) and&lt;code&gt;linkedlist.contains()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.contains()&lt;/code&gt; 는 O (n)이고 &lt;code&gt;linkedlist.contains()&lt;/code&gt; 는 O (n)</target>
        </trans-unit>
        <trans-unit id="618dfb209f4f59dfc35a87398c91f4408414c5e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.get()&lt;/code&gt; is  O(1) whereas &lt;code&gt;linkedlist.get()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;arraylist.get()&lt;/code&gt; 은 O (1)이지만 &lt;code&gt;linkedlist.get()&lt;/code&gt; 은 O (n)</target>
        </trans-unit>
        <trans-unit id="c747b2aa8edd29531dda369e30693d8e367bf978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.next()&lt;/code&gt; is O(1) and &lt;code&gt;linkedlist.next()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.next()&lt;/code&gt; 는 O (1)이고 &lt;code&gt;linkedlist.next()&lt;/code&gt; 는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="10d74fef85d164534c516cace70835405c829375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arraylist.remove()&lt;/code&gt; is O(n) whereas &lt;code&gt;linkedlist.remove()&lt;/code&gt; is O(1)</source>
          <target state="translated">&lt;code&gt;arraylist.remove()&lt;/code&gt; 는 O (n) 인 반면 &lt;code&gt;linkedlist.remove()&lt;/code&gt; 는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="83cf5e81c843d7f1b9ec0ebf7d3ce303ed679233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;  &amp;lt;--- main benefit of &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O (1)&lt;/em&gt; &amp;lt;--- &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 주요 이점 &amp;lt;E&amp;gt;</target>
        </trans-unit>
        <trans-unit id="076d7c0a115bbd75984dc63de232ffd83355229d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;get(int index)&lt;/code&gt; 은 &lt;em&gt;O (n)입니다&lt;/em&gt; (평균 &lt;em&gt;n / 4&lt;/em&gt; 단계).</target>
        </trans-unit>
        <trans-unit id="c46760af862228653fd1838c5478b7b0940fecd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt; is O(n)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; 는 O (n)입니다.</target>
        </trans-unit>
        <trans-unit id="7b106c9b6bde2953f3d1daf9d5119c83d5410807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator.remove()&lt;/code&gt;is O(1)</source>
          <target state="translated">&lt;code&gt;iterator.remove()&lt;/code&gt; 는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="ddd6b224b5ccf09e47bc373ca347dfe7075c1356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; 는 &lt;em&gt;O (n)입니다&lt;/em&gt; (평균 &lt;em&gt;n / 2&lt;/em&gt; 단계).</target>
        </trans-unit>
        <trans-unit id="cf4c56aa9b5498f71eb6ce9320a3051ac4546259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average)</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; 는 &lt;em&gt;O (n)입니다&lt;/em&gt; (평균 &lt;em&gt;n / 4&lt;/em&gt; 단계).</target>
        </trans-unit>
        <trans-unit id="e0e4246aea749c2db7c4d23e708786328b04d5d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; get(int index) operation runs in constant time i.e O(1)  while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; get (int index) 연산은 상수 시간, 즉 O (1)에서 실행되는 동안</target>
        </trans-unit>
        <trans-unit id="5d33e09a0584a1ed7c3021a69aa36ebc1ffbaeb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ArrayList&lt;/em&gt; is the resizable array implementation of list interface , while</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; 는 목록 인터페이스의 크기 조정이 가능한 배열 구현입니다.</target>
        </trans-unit>
        <trans-unit id="c124a2a77d14e556f2817e5cd608afeed22dbfe5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt;  only constructs the empty list without any initial capacity.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; 는 초기 용량없이 빈 목록 만 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f4ee2569862439dbb15b3ae92435d3a68c160616" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; can be iterated in reverse direction using descendingIterator() while</source>
          <target state="translated">&lt;em&gt;DownedIterator&lt;/em&gt; ()를 사용하여 &lt;em&gt;LinkedList&lt;/em&gt; 를 역방향으로 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54e2d819276cdac9c5f9629b5f33af6e5719be2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; does not provide index-based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; 는 지정된 요소 인덱스에서 노드를 검색하기 위해 시작 또는 끝 (둘 중 더 가까운 쪽)을 반복하므로 요소에 대한 인덱스 기반 액세스를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bb16f32491a07a1a25788ce7789be628df88f90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; get(int index) operation run time is O(n) .</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; get (int index) 작업 런타임은 O (n)입니다.</target>
        </trans-unit>
        <trans-unit id="b58ac9358b965d629640277808e5c5aa9d8d6726" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LinkedList&lt;/em&gt; is the Doubly-linked list implementation of the list interface.</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; 는 목록 인터페이스의 이중 연결 목록 구현입니다.</target>
        </trans-unit>
        <trans-unit id="2a8c0d7f347fae173c91da41a72879346a94ba06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Underlying Data Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 기본 데이터 구조&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433009e1632a58f1c005d11c5b98f0de53409d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) LinkedList implements Deque&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) LinkedList는 Deque를 구현합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8263acaceffe6556cde46deb5cd970572e9e42c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Removing an element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4) 위치에서 요소 제거&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47f28efd57ef00e2c87c16894875d71e8b597837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5) Iterating over ArrayList or LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5) ArrayList 또는 LinkedList를 반복&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bc5d37009869c02f222a403c214d3c17b0e706b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6) Retrieving element from a position&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6) 위치에서 요소 검색&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="462f50e91da5f54cbf63fd99a90f80e12a0505fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7) Memory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7) 기억&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da1ffd583c2ad7be3699d0c0677415f869d74146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f05e8ad2e27a21a899fecd88f6a21aacab0d7ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList:&lt;/strong&gt; Resizable-array implementation of the List interface</source>
          <target state="translated">&lt;strong&gt;ArrayList :&lt;/strong&gt; List 인터페이스의 크기 조정 가능 배열 구현</target>
        </trans-unit>
        <trans-unit id="6af5a946c3943e163e4208c39ac575e870dcd320" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2269f0870ce22b776e94b551a51a669b55a88029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46534f184f1b21f4eddf5b75c18076e27fc2851f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: For Java its &lt;code&gt;LinkedList&lt;/code&gt; this is not true! See &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Is there a fast concat method for linked list in Java?&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; : Java의 경우 &lt;code&gt;LinkedList&lt;/code&gt; 는 사실이 아닙니다! &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Java에 링크 된 목록에 빠른 연결 방법이 있습니까?를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3e70a2309d967cc0183810bd32e9751566d788e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e04cb44a3754508f40774fb3722cf1f644583432" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList:&lt;/strong&gt; Doubly-linked list implementation of the List and Deque interfaces</source>
          <target state="translated">&lt;strong&gt;LinkedList :&lt;/strong&gt; List 및 Deque 인터페이스의 이중 연결 목록 구현</target>
        </trans-unit>
        <trans-unit id="4cfbebcdacd3a1fd25d71fd2c7e3bba3a64e9924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LinkedList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LinkedList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb54ee6bc49f7f8f58707bdd0ffe2bb21f75ea60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mainly&lt;/strong&gt; - that the nodes of the &lt;code&gt;LinkedList&lt;/code&gt; are scattered randomly across the memory. RAM (&quot;Random Access Memory&quot;) isn't really random and blocks of memory need to be fetched to cache. This operation takes time, and when such fetches happen frequently - the memory pages in the cache need to be replaced all the time -&amp;gt; Cache misses -&amp;gt; Cache is not efficient.
&lt;code&gt;ArrayList&lt;/code&gt; elements are stored on continuous memory - which is exactly what the modern CPU architecture is optimizing for.</source>
          <target state="translated">&lt;strong&gt;주로&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; 의 노드가 메모리에 무작위로 흩어져 있습니다. RAM ( &quot;Random Access Memory&quot;)은 실제로 임의적이지 않으며 캐시하기 위해 메모리 블록을 가져와야합니다. 이 작업에는 시간이 걸리고 이러한 페치가 자주 발생하면 캐시의 메모리 페이지를 항상 교체해야합니다.-&amp;gt; 캐시 누락-&amp;gt; 캐시가 효율적이지 않습니다. &lt;code&gt;ArrayList&lt;/code&gt; 요소는 연속 메모리에 저장됩니다. 이것은 현대 CPU 아키텍처가 최적화하는 것과 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="737ee1d3842d6b6aa7c27ab74975e8879b369c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note 2:&lt;/strong&gt;&lt;em&gt;(thanks BeeOnRope)&lt;/em&gt; As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.</source>
          <target state="translated">&lt;strong&gt;참고 2 :&lt;/strong&gt; &lt;em&gt;(BeOnRope 덕분에) JDK6&lt;/em&gt; 중반부터 CompressedOops가 기본값으로 기본 설정되었으므로 64 비트 시스템의 경우 아래 값은 기본적으로 32 비트에 해당합니다 (물론 특별히 끄지 않는 한).</target>
        </trans-unit>
        <trans-unit id="d44e01d24f2f947ad59025026aafcb6509358644" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The sizes shown for the &lt;code&gt;ArrayList&lt;/code&gt; lines are for &lt;em&gt;trimmed lists&lt;/em&gt; - In practice, the capacity of the backing array in an &lt;code&gt;ArrayList&lt;/code&gt; is generally larger than its current element count.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; 행에 표시되는 크기는 &lt;em&gt;트리밍 된 목록&lt;/em&gt; 의 크기입니다. 실제로 &lt;code&gt;ArrayList&lt;/code&gt; 의 백업 배열 용량은 일반적으로 현재 요소 수보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="12af4b8c2156f8719580823656e7a54b8c2d6d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Secondary&lt;/strong&gt;&lt;code&gt;LinkedList&lt;/code&gt; required to hold back/forward pointers, which means 3 times the memory consumption per value stored compared to &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;2 차&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; 는 포인터를 뒤로 / 앞으로 유지하는 데 필요합니다. 이는 &lt;code&gt;ArrayList&lt;/code&gt; 와 비교하여 저장된 값당 메모리 소비의 3 배를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1846b926ec6f26796aa1d815b9ecb79355628a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;&lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;ArrayDeque&lt;/code&gt; are preferable in &lt;em&gt;many&lt;/em&gt; more use-cases than &lt;code&gt;LinkedList&lt;/code&gt;. If you're not sure&amp;nbsp;&amp;mdash; just start with &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayDeque&lt;/code&gt; 가 포함 된 &lt;code&gt;ArrayList&lt;/code&gt; 가 &lt;code&gt;LinkedList&lt;/code&gt; 보다 더 많은 사용 사례에서 선호됩니다. 확실하지 않은 경우 &lt;code&gt;ArrayList&lt;/code&gt; 로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5f13ec4830a4dab71f8b2f8ddb84bf2925c9db1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt; due to modern computer architecture, &lt;code&gt;ArrayList&lt;/code&gt; will be significantly more efficient for nearly any possible use-case - and therefore &lt;code&gt;LinkedList&lt;/code&gt; should be avoided except some very unique and extreme cases.</source>
          <target state="translated">&lt;strong&gt;TL; DR&lt;/strong&gt; 현대 컴퓨터 아키텍처로 인해 &lt;code&gt;ArrayList&lt;/code&gt; 는 거의 모든 사용 사례에서 훨씬 더 효율적이므로 매우 독특하고 극단적 인 경우를 제외하고 &lt;code&gt;LinkedList&lt;/code&gt; 를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="18c5c15402cf358ebe73222367ef252aff38be6e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/2&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (end of list), &lt;em&gt;n&lt;/em&gt; steps in the worst case (start of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;참고 : 많은 작업에는 평균 &lt;em&gt;n / 2&lt;/em&gt; 스텝이 필요하며 최상의 경우에는 &lt;em&gt;일정한&lt;/em&gt; 수의 단계 (목록 끝), 최악의 경우에는 &lt;em&gt;n&lt;/em&gt; 단계 (목록의 시작)가 필요합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e66437897a99b75d7aacd4ff7c0bab63bf960599" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/4&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (e.g. index = 0), and &lt;em&gt;n/2&lt;/em&gt; steps in worst case (middle of list)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;참고 : 많은 작업에는 평균 &lt;em&gt;n / 4&lt;/em&gt; 단계, 최상의 경우 &lt;em&gt;일정한&lt;/em&gt; 수의 단계 (예 : 인덱스 = 0) 및 최악의 경우 &lt;em&gt;n / 2&lt;/em&gt; 단계 (중간 목록)가 필요합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b9d61654aa4c588b3965ecb02516b604046e37b" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</source>
          <target state="translated">=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===</target>
        </trans-unit>
        <trans-unit id="afb8a95f2210ccfc23ec59f145c584c9c6d9cbca" translate="yes" xml:space="preserve">
          <source>=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===</source>
          <target state="translated">=== 링크 된 목록 ===</target>
        </trans-unit>
        <trans-unit id="bfbcd797a68fe86413865e4a0cee9ebbb8dc882a" translate="yes" xml:space="preserve">
          <source>A key elements to remember is that the cost of fetching memory block, is more significant than the cost accessing a single memory cell. That's why reader 1MB of sequential memory is up to x400 times faster than reading this amount of data from different blocks of memory:</source>
          <target state="translated">기억해야 할 핵심 요소는 메모리 블록 페치 비용이 단일 메모리 셀 액세스 비용보다 중요하다는 것입니다. 따라서 1MB의 순차 메모리 리더가 다른 메모리 블록에서이 양의 데이터를 읽는 것보다 최대 x400 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="964ab287d1b2674c3006a9a40f27cc8c75ad7689" translate="yes" xml:space="preserve">
          <source>A linked list specifies a progression from one item to the next (Item a -&amp;gt; item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one.</source>
          <target state="translated">연결된 목록은 한 항목에서 다음 항목으로의 진행을 지정합니다 (항목 a-&amp;gt; 항목 b). 배열 목록과 동일한 효과를 얻을 수 있지만 연결된 목록은 이전 항목을 따라야 할 항목을 절대적으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b210113b5c71ae47be12eff9c831066664d10253" translate="yes" xml:space="preserve">
          <source>Algorithms: Big-Oh Notation</source>
          <target state="translated">알고리즘 : 빅오 표기법</target>
        </trans-unit>
        <trans-unit id="89aa0aee53d5aa7fcca1da8190329ab378539fc9" translate="yes" xml:space="preserve">
          <source>Also adding an element in the mid of a list should be very efficient.</source>
          <target state="translated">또한 목록 중간에 요소를 추가하는 것이 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="61b3b2ef28066e4746dc4b1bff67b83b191c168c" translate="yes" xml:space="preserve">
          <source>Also, if you have large lists, keep in mind that memory usage is also different. Each element of a &lt;code&gt;LinkedList&lt;/code&gt; has more overhead since pointers to the next and previous elements are also stored. &lt;code&gt;ArrayLists&lt;/code&gt; don't have this overhead. However, &lt;code&gt;ArrayLists&lt;/code&gt; take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.</source>
          <target state="translated">또한 큰 목록이있는 경우 메모리 사용량도 다릅니다. 다음 및 이전 요소에 대한 포인터도 저장되므로 &lt;code&gt;LinkedList&lt;/code&gt; 의 각 요소에 더 많은 오버 헤드가 있습니다. &lt;code&gt;ArrayLists&lt;/code&gt; 에는이 오버 헤드가 없습니다. 그러나 &lt;code&gt;ArrayLists&lt;/code&gt; 는 요소가 실제로 추가되었는지 여부에 관계없이 용량에 할당 된 메모리를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="2906ab1d13eae009cd628e69b029557fe9f42802" translate="yes" xml:space="preserve">
          <source>An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.</source>
          <target state="translated">배열 목록은 본질적으로 항목 등을 추가하는 메소드가있는 배열입니다 (대신 일반 목록을 사용해야합니다). 인덱서를 통해 액세스 할 수있는 항목의 모음입니다 (예 : [0]). 한 항목에서 다음 항목으로의 진행을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="928353d571ab22df35197d82101926d8b0eefa4a" translate="yes" xml:space="preserve">
          <source>An important feature of a linked list (which I didn't read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)</source>
          <target state="translated">링크 된 목록의 중요한 기능 (다른 답변에서 읽지 않은)은 두 목록의 연결입니다. 배열을 사용하면 연결된 목록이있는 O (n) (+ 일부 재 할당의 오버 헤드)이며 이것은 O (1) 또는 O (2) ;-)입니다.</target>
        </trans-unit>
        <trans-unit id="440b1f956dfeafd90ff94cb080bd1ba1475ed504" translate="yes" xml:space="preserve">
          <source>And of course, &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; is your best friend.</source>
          <target state="translated">물론 &lt;a href=&quot;https://github.com/google/guava&quot;&gt;구아바&lt;/a&gt; 의 &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot;&gt;ImmutableList&lt;/a&gt; 는 가장 친한 친구입니다.</target>
        </trans-unit>
        <trans-unit id="73a833ab20503a4ddda3951abeecfe30b58c944c" translate="yes" xml:space="preserve">
          <source>Another benefit of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you add or remove from the head of the list, since those operations are &lt;em&gt;O(1)&lt;/em&gt;, while they are &lt;em&gt;O(n)&lt;/em&gt; for &lt;code&gt;ArrayList&lt;/code&gt;. Note that &lt;code&gt;ArrayDeque&lt;/code&gt; may be a good alternative to &lt;code&gt;LinkedList&lt;/code&gt; for adding and removing from the head, but it is not a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 사용의 또 다른 이점은 목록의 헤드에서 추가하거나 제거 할 때 발생합니다. 이러한 조작은 &lt;em&gt;O (1)&lt;/em&gt; 이고 &lt;code&gt;ArrayList&lt;/code&gt; 의 경우 &lt;em&gt;O (n)&lt;/em&gt; 이기 때문입니다. &lt;code&gt;ArrayDeque&lt;/code&gt; 는 헤드에서 추가 및 제거를 위해 &lt;code&gt;LinkedList&lt;/code&gt; 대신 사용할 수 있지만 &lt;code&gt;List&lt;/code&gt; 는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e30b3a7720a85a27ef41bbfc97676b4e2de8896a" translate="yes" xml:space="preserve">
          <source>Another difference between ArrayList and LinkedList is that apart from the List interface, LinkedList also implements Deque interface, which provides first in first out operations for add() and poll() and several other Deque functions. 3) Adding elements in ArrayList Adding element in ArrayList is O(1) operation if it doesn't trigger re-size of Array, in which case it becomes O(log(n)), On the other hand, appending an element in LinkedList is O(1) operation, as it doesn't require any navigation.</source>
          <target state="translated">ArrayList와 LinkedList의 또 다른 차이점은 LinkedList는 List 인터페이스와 별도로 add () 및 poll () 및 기타 여러 Deque 함수에 대한 첫 번째 작업을 제공하는 Deque 인터페이스도 구현한다는 것입니다. 3) ArrayList에 요소 추가 ArrayList에 요소를 추가하는 것은 Array의 크기 조정을 트리거하지 않으면 O (1) 작업입니다.이 경우 O (log (n))가됩니다. 반면에 LinkedList는 탐색이 필요하지 않으므로 O (1) 조작입니다.</target>
        </trans-unit>
        <trans-unit id="1e86137c9ac677ec1de04c6463f5afe991a7e829" translate="yes" xml:space="preserve">
          <source>Any indexed operation requires a traversal, i.e. has O(n) performance. This is not obvious in the source code, leading to algorithms O(n) slower than if &lt;code&gt;ArrayList&lt;/code&gt; was used.</source>
          <target state="translated">인덱스 작업에는 순회가 필요합니다. 즉, O (n) 성능을 갖습니다. 이는 소스 코드에서 분명하지 않으므로 &lt;code&gt;ArrayList&lt;/code&gt; 를 사용하는 경우보다 알고리즘 O (n)이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="245a7f4435e5cb39a22d5f24ebfff9bf323d2ce3" translate="yes" xml:space="preserve">
          <source>ArrayList Vs LinkedList</source>
          <target state="translated">ArrayList 대 LinkedList</target>
        </trans-unit>
        <trans-unit id="fe0ac6572af91b6c617d95528d2b396ca2837309" translate="yes" xml:space="preserve">
          <source>ArrayList and LinkedList have their own pros and cons.</source>
          <target state="translated">ArrayList 및 LinkedList에는 고유 한 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6785e144c9307049f97a69a012d7795245d88d" translate="yes" xml:space="preserve">
          <source>ArrayList extends AbstractList and implements the List Interface. ArrayList is dynamic array.</source>
          <target state="translated">ArrayList는 AbstractList를 확장하고 목록 인터페이스를 구현합니다. ArrayList는 동적 배열입니다.</target>
        </trans-unit>
        <trans-unit id="437431a42628c440c8c8ddba7824d9ba269abd04" translate="yes" xml:space="preserve">
          <source>ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.</source>
          <target state="translated">성능이 의미하는 전부가 처리량이고 대기 시간을 무시할 수있는 경우 ArrayList는 성능을위한 더 나은 선택입니다. 직장에서의 경험에서 최악의 대기 시간을 무시할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1913d3898d20247f47f9e0c995812cdb4b8d08d7" translate="yes" xml:space="preserve">
          <source>ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList is faster than doing n iterations with LinkedList.</source>
          <target state="translated">ArrayList는 다음 노드에 대한 포인터를 사용하는 LinkedList와 비교하여 연속 메모리 주소를 사용합니다. 따라서 ArrayList에서 요소를 찾으려면 LinkedList로 n 반복을 수행하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d9b713914a6a1ace02a2eecb0047e6799c67666f" translate="yes" xml:space="preserve">
          <source>ArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.</source>
          <target state="translated">ArrayLists는 한 번만 읽을 수있는 많은 또는 어 펜더에는 좋지만 추가 또는 제거는 앞면 또는 가운데에는 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="459e94cfdff5088a8182f4ad9a0d304b933bf06b" translate="yes" xml:space="preserve">
          <source>As explained above the insert and remove operations give good performance &lt;code&gt;(O(1))&lt;/code&gt; in &lt;code&gt;LinkedList&lt;/code&gt; compared to &lt;code&gt;ArrayList(O(n))&lt;/code&gt;.</source>
          <target state="translated">위에서 설명한 것처럼 삽입 및 제거 작업은 &lt;code&gt;ArrayList(O(n))&lt;/code&gt; 비해 &lt;code&gt;LinkedList&lt;/code&gt; 에서 우수한 성능 &lt;code&gt;(O(1))&lt;/code&gt; 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5bafe9e2667a408bbc28c0a3d0896d45d6514421" translate="yes" xml:space="preserve">
          <source>As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.</source>
          <target state="translated">ArrayList까지는 배열의 중복을 최소화하기 위해 항상 초기 용량의 생성자를 사용해야한다는 데 동의합니다.</target>
        </trans-unit>
        <trans-unit id="41b881749d840dd577c03a0d047dddf4b9b4432c" translate="yes" xml:space="preserve">
          <source>As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.</source>
          <target state="translated">약 10 년 동안 대규모 SOA 웹 서비스에서 운영 성능 엔지니어링을 수행 한 사람으로서 ArrayList보다 LinkedList의 동작을 선호합니다. LinkedList의 정상 상태 처리량은 더 나빠서 더 많은 하드웨어를 구매할 수 있지만 압력이 가해지면 ArrayList의 동작으로 인해 클러스터의 앱이 거의 동 기적으로 배열을 확장하고 큰 배열 크기의 경우 응답 성이 떨어질 수 있습니다. 압력이 가해지면 앱에서 중단이 발생하고 이는 심각한 행동입니다.</target>
        </trans-unit>
        <trans-unit id="7cc15a8cb6e4f67393413b50f7e19ba95f084ea2" translate="yes" xml:space="preserve">
          <source>As with standard linked list and array operations, the various methods will have different algorithmic runtimes.</source>
          <target state="translated">표준 링크리스트 및 배열 연산과 마찬가지로 다양한 메소드는 서로 다른 알고리즘 런타임을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="17f7102d3affee7b74333eccc3786b17d7b95f92" translate="yes" xml:space="preserve">
          <source>Based on these you have to decide what to choose. :)</source>
          <target state="translated">이를 바탕으로 무엇을 선택해야하는지 결정해야합니다. :)</target>
        </trans-unit>
        <trans-unit id="f4ba92067d77f8ad1cdde8d5185b8e7ead37b68b" translate="yes" xml:space="preserve">
          <source>Below is the unit test result for each operation.Timing is given in Nanoseconds.</source>
          <target state="translated">아래는 각 작업에 대한 단위 테스트 결과입니다. 타이밍은 나노초 단위로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7f46f0e6a343f897fd8216fe946eeff647289350" translate="yes" xml:space="preserve">
          <source>Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Let's say we want to go through the entire List removing and inserting elements on our way. Usually, you would start from the very beginning for each element using the LinkedList, we could also &quot;save&quot; the current element we're working on with an Iterator. With the help of the Iterator, we get an O(1) efficiency for remove() and insert() when working in a LinkedList. Making it the only performance benefit I'm aware of where a LinkedList is always better than an ArrayList.</source>
          <target state="translated">보너스 : ArrayList에 대해이 두 가지 방법을 O (1)로 만드는 방법은 없지만 실제로 LinkedLists에는이를 수행하는 방법이 있습니다. 도중에 요소를 제거하고 삽입하는 전체 List를 살펴보고 싶다고 가정 해 봅시다. 일반적으로 LinkedList를 사용하여 각 요소의 맨 처음부터 시작합니다. Iterator로 작업중인 현재 요소를 &quot;저장&quot;할 수도 있습니다. Iterator의 도움으로 LinkedList에서 작업 할 때 remove () 및 insert ()에 대한 O (1) 효율성을 얻습니다. 그것이 LinkedList가 ArrayList보다 항상 좋은 곳이라는 것을 알고있는 유일한 성능 이점입니다.</target>
        </trans-unit>
        <trans-unit id="f37c5042d81ce8b4bbe2d96a4545bbab34eb146f" translate="yes" xml:space="preserve">
          <source>Both ArrayList and LinkedList are implementation of List interface.</source>
          <target state="translated">ArrayList와 LinkedList는 모두 List 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="71f1ed7fc912117c5c42591efe3f6f8fa7782142" translate="yes" xml:space="preserve">
          <source>Both remove() and insert() have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However, the reason behind the linear processing time comes from two very different reasons:</source>
          <target state="translated">remove ()와 insert ()는 모두 ArrayList와 LinkedList에 대해 런타임 효율이 O (n)입니다. 그러나 선형 처리 시간의 배후에있는 이유는 두 가지 매우 다른 이유 때문입니다.</target>
        </trans-unit>
        <trans-unit id="daf0773dc6de1ad67b93748501d5e5e954fbb69d" translate="yes" xml:space="preserve">
          <source>Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.</source>
          <target state="translated">이 두 클래스는 동기화되지 않으며 Collections.synchronizedList 메소드를 사용하여 명시 적으로 동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de704239e812c1c915cb01038eee251cbcaf16df" translate="yes" xml:space="preserve">
          <source>Conclusion: LinkedList element deletion is faster compared to
  ArrayList.</source>
          <target state="translated">결론 : LinkedList 요소 삭제는 ArrayList에 비해 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f180d58cc543a593a06f0503cdd233ebc9c5759c" translate="yes" xml:space="preserve">
          <source>Copying a sequential bulk of memory is an operation optimized by the modern CPUs - changing theory and actually making, again, &lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;Vector&lt;/code&gt; much more efficient</source>
          <target state="translated">순차적 인 대량의 메모리를 복사하는 것은 최신 CPU에 의해 최적화 된 작업입니다. 이론을 바꾸고 실제로 다시 &lt;code&gt;ArrayList&lt;/code&gt; / &lt;code&gt;Vector&lt;/code&gt; 를 훨씬 더 효율적으로 만드는 것</target>
        </trans-unit>
        <trans-unit id="1f74715932ed85186b45cbf00a18b0aa012ba91d" translate="yes" xml:space="preserve">
          <source>Correct or Incorrect: Please execute test locally and decide for yourself!</source>
          <target state="translated">정확하거나 잘못됨 : 테스트를 로컬에서 실행하고 스스로 결정하십시오!</target>
        </trans-unit>
        <trans-unit id="78ddc4712fca5a2025e62dc663ca11c5d278f6c7" translate="yes" xml:space="preserve">
          <source>Credits: All benchmarks posted here are created by &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m&lt;/a&gt;. Even more data can be found on &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;his blog&lt;/a&gt;</source>
          <target state="translated">크레딧 : 여기에 게시 된 모든 벤치 마크는 &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot;&gt;Kjell Hedstr&amp;ouml;m에&lt;/a&gt; 의해 작성되었습니다. &lt;a href=&quot;https://kjellkod.wordpress.com/&quot;&gt;그의 블로그&lt;/a&gt; 에서 더 많은 데이터를 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="779504bb746658eb51a895ef325a2c35e22145fa" translate="yes" xml:space="preserve">
          <source>Does anyone actually use LinkedList?  I wrote it, and I never use it.</source>
          <target state="translated">누구든지 실제로 LinkedList를 사용합니까? 나는 그것을 썼고 결코 사용하지 않았다.</target>
        </trans-unit>
        <trans-unit id="c5b4ee91f9f7d7536fb951869ce3310ca5d5e5c8" translate="yes" xml:space="preserve">
          <source>Edit/Remove is faster in &lt;code&gt;LinkedList&lt;/code&gt; than &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 보다 Edited / Remove가 &lt;code&gt;LinkedList&lt;/code&gt; 보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="aa4bd4d47e6eb0dd8326522867ae2cebb9d911a9" translate="yes" xml:space="preserve">
          <source>Even when big-O performance is the same as &lt;code&gt;ArrayList&lt;/code&gt;, it is probably going to be significantly slower anyway.</source>
          <target state="translated">big-O 성능이 &lt;code&gt;ArrayList&lt;/code&gt; 와 동일하더라도 어쨌든 상당히 느려질 것입니다.</target>
        </trans-unit>
        <trans-unit id="a717e212f108315f6468fbbac65115039dbc3186" translate="yes" xml:space="preserve">
          <source>Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.</source>
          <target state="translated">DB에서 얻은 데이터 목록을 반환하는 메서드를 사용할 때마다 항상 LinkedList를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d98c1a4ef5e0db31dd47ee47986d318181c0c1aa" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85cdf2bee1991274487c8b867c3e971ab9c35e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">링크 된 목록의 경우 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e02d61f3770600b7462828f335d485c3c7c88fd7" translate="yes" xml:space="preserve">
          <source>From all the above differences between ArrayList vs LinkedList, It looks ArrayList is the better choice than LinkedList in almost all cases, except when you do a frequent add() operation than remove(), or get().</source>
          <target state="translated">ArrayList와 LinkedList의 위의 모든 차이점에서 ArrayList가 remove () 또는 get ()보다 자주 add () 작업을 수행하는 경우를 제외하고 거의 모든 경우 LinkedList보다 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="ecc2eafc3ac7b3d6cdad7d496b20ef438cc7c71b" translate="yes" xml:space="preserve">
          <source>Getting good performance is tricky.</source>
          <target state="translated">좋은 성능을 얻는 것은 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="d872e08fee24bf8c30e8defc229caebca0ba87ad" translate="yes" xml:space="preserve">
          <source>Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.</source>
          <target state="translated">따라서 응용 프로그램에 빈번한 추가 및 삭제가 필요한 경우 LinkedList가 최선의 선택입니다.</target>
        </trans-unit>
        <trans-unit id="05cae6319d9059efe74860e4a0c6f790d26f64fc" translate="yes" xml:space="preserve">
          <source>Here are results of a benchmark testing inserting elements in random locations. As you can see - the array list if much more efficient, although in theory each insert in the middle of the list will require &quot;move&quot; the &lt;em&gt;n&lt;/em&gt; later elements of the array (lower values are better):</source>
          <target state="translated">다음은 임의의 위치에 요소를 삽입하는 벤치 마크 테스트 결과입니다. 보다시피, 배열 목록은 훨씬 더 효율적이지만 이론적으로 목록 중간에있는 각 삽입물은 배열의 &lt;em&gt;n 개&lt;/em&gt; 이후 요소를 &quot;이동&quot;해야합니다 (낮은 값이 더 낫습니다).</target>
        </trans-unit>
        <trans-unit id="4231cb0b09e1f7b1f49c5e13010868f22f729203" translate="yes" xml:space="preserve">
          <source>Here is a figure from &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; (&lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):</source>
          <target state="translated">다음은 &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot;&gt;programcreek.com&lt;/a&gt; 의 그림입니다. &lt;code&gt;add&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 는 첫 번째 유형입니다. 즉, 목록 끝에 요소를 추가하고 목록의 지정된 위치에서 요소를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="72459064f382e49943817106fc4f16a28f18d010" translate="yes" xml:space="preserve">
          <source>Here is the Big-O notation in both &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; and also &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;ArrayList&lt;/code&gt; 와 &lt;code&gt;LinkedList&lt;/code&gt; 및 &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt; 의 Big-O 표기법입니다.</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="204bd2319ad6f28782c2fd4eac0f1c63e947287c" translate="yes" xml:space="preserve">
          <source>I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:</source>
          <target state="translated">응답을 읽었지만 의견을 듣기 위해 공유하려는 ArrayList에 대해 항상 LinkedList를 사용하는 시나리오가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2909da23de10e510a463c3326c00b280592d1c12" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I honestly can't believe nobody mentioned that &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Deque&lt;/code&gt;.  Just look at the methods in &lt;code&gt;Deque&lt;/code&gt; (and &lt;code&gt;Queue&lt;/code&gt;); if you want a fair comparison, try running &lt;code&gt;LinkedList&lt;/code&gt; against &lt;code&gt;ArrayDeque&lt;/code&gt; and do a feature-for-feature comparison.</source>
          <target state="translated">나는 이것이 오래된 게시물이라는 것을 알고 있지만 솔직히 &lt;code&gt;LinkedList&lt;/code&gt; 가 &lt;code&gt;Deque&lt;/code&gt; 구현한다고 언급 한 사람은 아무도 없다. &lt;code&gt;Deque&lt;/code&gt; (및 &lt;code&gt;Queue&lt;/code&gt; )의 메소드를 살펴보십시오. 공정한 비교를 원하면 &lt;code&gt;ArrayDeque&lt;/code&gt; 에 대해 &lt;code&gt;LinkedList&lt;/code&gt; 를 실행하고 기능별 비교를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f0b70ff5fa7c09103b8eab96c986f91401d87676" translate="yes" xml:space="preserve">
          <source>I use the interface as the type name for &lt;em&gt;portability&lt;/em&gt;, so that when I ask questions such as these I can rework my code.</source>
          <target state="translated">인터페이스를 &lt;em&gt;이식성&lt;/em&gt; 의 유형 이름으로 사용하므로 이와 같은 질문을 할 때 코드를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1dae44cf928d176bc4a73ed2740108af2b90993" translate="yes" xml:space="preserve">
          <source>I usually use one over the other based on the time complexities of the operations that I'd perform on that particular List.</source>
          <target state="translated">나는 일반적으로 특정 목록에서 수행 할 작업의 시간 복잡성에 따라 다른 것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6102d6038b559d5fad73832038782bbb5796e2a3" translate="yes" xml:space="preserve">
          <source>I'm sorry for the answer for being not that informative as the other answers, but I thought it would be the most interesting and self-explanatory.</source>
          <target state="translated">다른 답변만큼 유익하지 않은 답변에 대해 유감스럽게 생각하지만 가장 흥미롭고 설명이 필요하다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="a4a379c9c8db61dd6b7c09706346097b32a64868" translate="yes" xml:space="preserve">
          <source>I've always been one to simply use:</source>
          <target state="translated">나는 항상 간단하게 사용하는 사람이었습니다.</target>
        </trans-unit>
        <trans-unit id="eb6b619bb59e99c5145eebdb33b065006bef1e99" translate="yes" xml:space="preserve">
          <source>If Array is large enough it may take a lot of memory at that point and trigger Garbage collection, which can slow response time.</source>
          <target state="translated">배열이 충분히 크면 해당 시점에서 많은 메모리가 소비되고 가비지 수집이 트리거되어 응답 시간이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="559de205fa8eb76d7699b1783f2b0ac89bcc4d52" translate="yes" xml:space="preserve">
          <source>If the constructor  is not overloaded, then &lt;em&gt;ArrayList&lt;/em&gt; creates an empty list of initial capacity 10, while</source>
          <target state="translated">생성자가 오버로드되지 않으면 &lt;em&gt;ArrayList&lt;/em&gt; 는 초기 용량 10의 빈 목록을 작성하지만</target>
        </trans-unit>
        <trans-unit id="c0e9fb39f596736adacc32d734e4edfa0a46ec4b" translate="yes" xml:space="preserve">
          <source>If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList.</source>
          <target state="translated">앱에서 빈번한 검색 작업이있는 경우 ArrayList를 사용하십시오. 자주 삽입하고 삭제하는 경우 LinkedList를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aaba92fb463b8690a69e81dfffc7a5658f1bd75e" translate="yes" xml:space="preserve">
          <source>If your code has &lt;code&gt;add(0)&lt;/code&gt; and &lt;code&gt;remove(0)&lt;/code&gt;, use a &lt;code&gt;LinkedList&lt;/code&gt; and it's prettier &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;removeFirst()&lt;/code&gt; methods. Otherwise, use &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">코드에 &lt;code&gt;add(0)&lt;/code&gt; 및 &lt;code&gt;remove(0)&lt;/code&gt; 있는 경우 &lt;code&gt;LinkedList&lt;/code&gt; 를 사용하면 &lt;code&gt;addFirst()&lt;/code&gt; 및 &lt;code&gt;removeFirst()&lt;/code&gt; 메서드가 더 좋습니다. 그렇지 않으면 &lt;code&gt;ArrayList&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c5ab91dd60a4bdc4332a1f000c5a31d8298e3443" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;ArrayList&lt;/em&gt;  each index only holds the actual object(data).</source>
          <target state="translated">&lt;em&gt;ArrayList에서&lt;/em&gt; 각 인덱스는 실제 객체 (데이터) 만 보유합니다.</target>
        </trans-unit>
        <trans-unit id="4e651e52f60a7d33d19241c9b84a7e5ebf5e0d7c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;LinkedList&lt;/em&gt;, there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1). The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as a parameter. This method traverses the LinkedList until it found the Object and unlink it from the original list. Hence this method runtime is O(n).</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; 에는 두 가지 오버로드 된 remove 메소드가 있습니다. 하나는 목록의 헤드를 제거하고 상수 시간 O (1)에서 실행되는 매개 변수가없는 remove ()입니다. LinkedList의 다른 오버로드 된 remove 메소드는 remove (int) 또는 remove (Object)로, Object 또는 int를 매개 변수로 제거합니다. 이 메소드는 오브젝트를 찾을 때까지 LinkedList를 순회하고 원래 목록에서 링크를 해제합니다. 따라서이 메소드 런타임은 O (n)입니다.</target>
        </trans-unit>
        <trans-unit id="4035507a1bd4880689b50032e852bc42590238de" translate="yes" xml:space="preserve">
          <source>In a LinkedList, it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for remove() and 2 references for insert().</source>
          <target state="translated">LinkedList에서 원하는 요소에 실제로 도달하려면 O (n)이 필요합니다. 원하는 인덱스에 도달 할 때까지 맨 처음부터 시작해야하기 때문입니다. remove ()에 대한 1 개의 참조와 insert ()에 대한 2 개의 참조 만 변경하면되기 때문에 실제로 제거하거나 삽입하는 것은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="6d3d827792739e9f193e4b6dedde2b63bd92348f" translate="yes" xml:space="preserve">
          <source>In addition to the other good arguments above, you should notice &lt;code&gt;ArrayList&lt;/code&gt; implements &lt;code&gt;RandomAccess&lt;/code&gt; interface, while &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Queue&lt;/code&gt;.</source>
          <target state="translated">위의 다른 좋은 인수 외에도 &lt;code&gt;ArrayList&lt;/code&gt; 는 &lt;code&gt;RandomAccess&lt;/code&gt; 인터페이스를 구현하고 &lt;code&gt;LinkedList&lt;/code&gt; 는 &lt;code&gt;Queue&lt;/code&gt; 를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="35842b5d82e361cdd7f51df865bca0c300db2026" translate="yes" xml:space="preserve">
          <source>In an ArrayList, you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.</source>
          <target state="translated">ArrayList에서는 O (1)의 요소에 도달하지만 실제로 다음 항목을 모두 변경해야하기 때문에 무언가를 제거하거나 삽입하면 O (n)이됩니다.</target>
        </trans-unit>
        <trans-unit id="e8946d8d5170bc375bf87f8b5c440661d618b2c2" translate="yes" xml:space="preserve">
          <source>In arraylist</source>
          <target state="translated">arraylist에서</target>
        </trans-unit>
        <trans-unit id="4a8bb3c134e78f4fa8de3dd3133fe5675a10a71e" translate="yes" xml:space="preserve">
          <source>In my opinion, use ArrayList over LinkedList for most of the practical purpose in Java.</source>
          <target state="translated">제 생각에는 Java의 실질적인 목적을 위해 LinkedList보다 ArrayList를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="60daaf72544dd78c2fbc88ad20ed774a9a6e7cea" translate="yes" xml:space="preserve">
          <source>In order to remove an element from a particular index e.g. by calling remove(index), ArrayList performs a copy operation which makes it close to O(n) while LinkedList needs to traverse to that point which also makes it O(n/2), as it can traverse from either direction based upon proximity.</source>
          <target state="translated">특정 인덱스에서 요소를 제거하기 위해 (예 : remove (index)를 호출하여) ArrayList는 복사 작업을 수행하여 O (n)에 가깝게 만드는 반면 LinkedList는 해당 지점으로 이동하여 O (n / 2)로 만듭니다. 근접성에 따라 어느 방향에서나 이동할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="13af662866647dd21beac5b84de614ccdd269669" translate="yes" xml:space="preserve">
          <source>In other words, you don't need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes O(n) operation. For example, inserting or deleting an element in the middle of a linked list.</source>
          <target state="translated">즉, 요소를 추가하려는 위치에 도달하기 위해 링크 된 목록을 탐색 할 필요가 없습니다.이 경우 추가는 O (n) 연산이됩니다. 예를 들어, 링크 된 목록의 중간에 요소를 삽입하거나 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="469c98ead6182a42fb433736049690f3bc9751a6" translate="yes" xml:space="preserve">
          <source>In theory, LinkedList has an O(1) for the &lt;code&gt;add(E element)&lt;/code&gt;</source>
          <target state="translated">이론적으로 LinkedList에는 &lt;code&gt;add(E element)&lt;/code&gt; 대한 O (1)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c381b0a433efc57cbfa3356f3a84f33fb983fb0" translate="yes" xml:space="preserve">
          <source>Insertions in &lt;em&gt;LinkedList&lt;/em&gt; are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation .</source>
          <target state="translated">&lt;em&gt;LinkedList의&lt;/em&gt; 삽입은 일반적으로 ArrayList에 비해 빠릅니다. LinkedList에서 추가 또는 삽입은 O (1) 연산입니다.</target>
        </trans-unit>
        <trans-unit id="c767ed4fab63fed391201351f4e44d98a283934b" translate="yes" xml:space="preserve">
          <source>It can be said that it was basically created to overcome the drawbacks of arrays</source>
          <target state="translated">기본적으로 배열의 단점을 극복하기 위해 만들어 졌다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67433abb43ee77013dd1057bd5c859af9a33433f" translate="yes" xml:space="preserve">
          <source>It depends upon what operations you will be doing more on the List.</source>
          <target state="translated">목록에서 더 많은 작업을 수행 할 작업에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="23b28df1a3e51ae95f5d0a5b0aa39bb036813e19" translate="yes" xml:space="preserve">
          <source>It uses lots of small memory objects, and therefore impacts performance across the process.</source>
          <target state="translated">많은 작은 메모리 개체를 사용하므로 프로세스 전체의 성능에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="8809d3c8954d5fee422f743b686ee6e92e9dc70a" translate="yes" xml:space="preserve">
          <source>It's an efficiency question. &lt;code&gt;LinkedList&lt;/code&gt; is fast for adding and deleting elements, but slow to access a specific element. &lt;code&gt;ArrayList&lt;/code&gt; is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.</source>
          <target state="translated">효율성 문제입니다. &lt;code&gt;LinkedList&lt;/code&gt; 는 요소를 추가하고 삭제하는 데 빠르지 만 특정 요소에 액세스하는 데 느립니다. &lt;code&gt;ArrayList&lt;/code&gt; 는 특정 요소에 액세스하는 데 빠르지 만 양쪽 끝에 추가하는 데 느리게, 특히 가운데에서 삭제하는 데 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b15e68efa8079d20e58d4612e98609845672742" translate="yes" xml:space="preserve">
          <source>It's easier to modify a linked list than ArrayList, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in O(1) time.</source>
          <target state="translated">연결된 목록이 내부적으로 해당 위치에 대한 참조를 유지하고 O (1) 시간에 액세스 할 수 있기 때문에 시작 또는 끝에서 요소를 추가하거나 제거하는 경우 ArrayList보다 연결 목록을 수정하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="adc8d1e49ddd7e5e06471d7adc23a73d72dc8d87" translate="yes" xml:space="preserve">
          <source>It's jarring to see &lt;code&gt;LinkedList&lt;/code&gt; in source because it is probably the wrong choice.</source>
          <target state="translated">아마도 잘못된 선택이기 때문에 소스에서 &lt;code&gt;LinkedList&lt;/code&gt; 를 보는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e438c304d6715de1cd8a3be3097d2b636828262" translate="yes" xml:space="preserve">
          <source>Iteration is the O(n) operation for both LinkedList and ArrayList where n is a number of an element.</source>
          <target state="translated">반복은 LinkedList 및 ArrayList 둘 다에 대한 O (n) 연산입니다. 여기서 n은 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="196cfc0783541b18906b878964f90c2beb521995" translate="yes" xml:space="preserve">
          <source>Joshua Bloch, the author of LinkedList:</source>
          <target state="translated">LinkedList의 저자 인 Joshua Bloch :</target>
        </trans-unit>
        <trans-unit id="b6bf53be71cb03cefc9204127bcad931b18969a2" translate="yes" xml:space="preserve">
          <source>Just to make the point even clearer, please check the benchmark of adding elements to the beginning of the list. This is a use-case where, in-theory, the &lt;code&gt;LinkedList&lt;/code&gt; should really shine, and &lt;code&gt;ArrayList&lt;/code&gt; should present poor or even worse-case results:</source>
          <target state="translated">요점을 더 명확하게하기 위해 목록의 시작 부분에 요소를 추가하는 기준을 확인하십시오. 이론적으로 &lt;code&gt;LinkedList&lt;/code&gt; 가 실제로 빛나고 &lt;code&gt;ArrayList&lt;/code&gt; 가 열악하거나 더 나쁜 경우 결과를 제공하는 유스 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="1f2e1c89c968aef7dc16623190b3a9a9cabbc8b4" translate="yes" xml:space="preserve">
          <source>Let's compare LinkedList and ArrayList w.r.t. below parameters:</source>
          <target state="translated">매개 변수 아래에서 LinkedList와 ArrayList wrt를 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="93306f9c4f0e542bbb9a628ab7325be853345914" translate="yes" xml:space="preserve">
          <source>Link: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</source>
          <target state="translated">링크 : &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a422cc360ccdd0ef7b3dda2d174720a459804d83" translate="yes" xml:space="preserve">
          <source>LinkedList is &lt;em&gt;almost always&lt;/em&gt; the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList's ability to insert and delete elements in the middle of the list relatively quickly, once you've navigated there with a ListIterator.</source>
          <target state="translated">LinkedList는 성능 측면에서 &lt;em&gt;거의 항상&lt;/em&gt; 잘못된 선택입니다. LinkedList가 호출되는 매우 특정한 알고리즘이 있지만 매우 드물며, 알고리즘은 일반적으로 LinkedList의 목록 중간에 요소를 빠르게 삽입하고 삭제하는 기능에 의존합니다. ListIterator와 함께.</target>
        </trans-unit>
        <trans-unit id="10b1b645b01085ffebf0f6f3f088eea7172b5aa1" translate="yes" xml:space="preserve">
          <source>LinkedList takes much more time to accomplish the same job. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">LinkedList는 동일한 작업을 수행하는 데 훨씬 더 많은 시간이 걸립니다. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot;&gt;소스&lt;/a&gt; &lt;a href=&quot;https://ideone.com/JOJ05&quot;&gt;소스 코드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f79cef427b354d9b9780eab17c5d356d4a5b006e" translate="yes" xml:space="preserve">
          <source>LinkedList uses a wrapper object, Entry, which is a static nested class for storing data and two nodes next and previous while ArrayList just stores data in Array.</source>
          <target state="translated">LinkedList는 랩퍼 오브젝트 인 Entry를 사용하여 데이터를 저장하기위한 정적 중첩 클래스이며 다음과 이전에 두 개의 노드를 저장하는 반면 ArrayList는 데이터를 Array에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7e1c7bcef7896ae52260cfcb6d33ba65b28b0065" translate="yes" xml:space="preserve">
          <source>Lots of small objects are bad for cache-locality.</source>
          <target state="translated">많은 작은 개체는 캐시 로컬성에 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1ac372c327cce8ede5e07a803bfe591166259d1" translate="yes" xml:space="preserve">
          <source>Memory overhead in &lt;em&gt;LinkedList&lt;/em&gt; is more as compared to ArrayList as a node in LinkedList needs to maintain the addresses of the next and previous node. While</source>
          <target state="translated">&lt;em&gt;LinkedList&lt;/em&gt; 의 노드는 다음 및 이전 노드의 주소를 유지해야하므로 &lt;em&gt;LinkedList의&lt;/em&gt; 메모리 오버 헤드는 ArrayList에 비해 더 높습니다. 동안</target>
        </trans-unit>
        <trans-unit id="e5657da09258adb4a01a06b7e549b6f276681445" translate="yes" xml:space="preserve">
          <source>My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.</source>
          <target state="translated">내 근거는 내가 얻는 결과의 수를 정확히 알 수 없기 때문에 (메모리 용량과 실제 요소 수의 차이가있는 ArrayList에서와 같이) 메모리 낭비가 없으며, 시도하는 데 시간이 낭비되지 않는다는 것입니다 용량을 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="d7c000eee7e0c05260bee34ed1a23873f4661337" translate="yes" xml:space="preserve">
          <source>Note: this is a benchmark of the C++ Std lib, but my previous experience shown the C++ and Java results are very similar. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">참고 : 이것은 C ++ Std lib의 벤치 마크이지만 이전 경험에서는 C ++ 및 Java 결과가 매우 유사하다는 것을 보여주었습니다. &lt;a href=&quot;https://ideone.com/DDEJF&quot;&gt;소스 코드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="43117d0643c36e2f29277032a262d30828a4ea76" translate="yes" xml:space="preserve">
          <source>O(n) worst, O(1) amortized</source>
          <target state="translated">O (n) 최악, O (1) 상각</target>
        </trans-unit>
        <trans-unit id="2613d66d9e3e9d1d2cb152a0c8c768f97ed252f6" translate="yes" xml:space="preserve">
          <source>On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.</source>
          <target state="translated">반면, LinkedList의 삽입 및 삭제는 포인터를 변경하기 만하면되기 때문에 훨씬 쉽습니다. ArrayList는 삽입 또는 삭제를 위해 shift 연산을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="33a2811cec1cd04c38e25706ff20270bb3aa420c" translate="yes" xml:space="preserve">
          <source>One of the tests I saw on here only conducts the test once.  But what I have noticed is that you need to run these tests many times and eventually their times will converge.  Basically the JVM needs to warm up.  For my particular use case I needed to add/remove items to a list that grows to about 500 items.  In my tests &lt;code&gt;LinkedList&lt;/code&gt; came out faster, with &lt;code&gt;LinkedList&lt;/code&gt; coming in around 50,000 NS and &lt;code&gt;ArrayList&lt;/code&gt; coming in at around 90,000 NS... give or take.  See the code below.</source>
          <target state="translated">여기서 본 테스트 중 하나는 테스트를 한 번만 수행합니다. 그러나 내가 주목 한 것은 이러한 테스트를 여러 번 실행해야하며 결국에는 시간이 수렴한다는 것입니다. 기본적으로 JVM은 예열해야합니다. 내 특정 유스 케이스의 경우 약 500 개의 항목으로 확장되는 목록에 항목을 추가 / 제거해야했습니다. 내 테스트에서 &lt;code&gt;LinkedList&lt;/code&gt; 가 더 빨리 나왔고 LinkedList 는 약 50,000 NS에, &lt;code&gt;ArrayList&lt;/code&gt; 는 약 90,000 NS에 들어갔습니다. 아래 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65dac500e2d3e9f09ada76f29721043fd8c863b6" translate="yes" xml:space="preserve">
          <source>Operation get(i) in ArrayList is faster than LinkedList, because:</source>
          <target state="translated">ArrayList의 get (i) 작업이 LinkedList보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0a5c295d42604c7d58d32363d3f4396711e52d07" translate="yes" xml:space="preserve">
          <source>Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</source>
          <target state="translated">목록에 색인을 생성하는 작업은 목록을 시작 또는 끝에서 지정된 색인에 더 가까운 쪽을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b3bfed3bf17cc4ccb5b52051ae69c0e7857b3e8" translate="yes" xml:space="preserve">
          <source>Practice is very different, as LinkedList is a &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data structure. From performance POV - there are very little cases where &lt;code&gt;LinkedList&lt;/code&gt; could be better performing than the &lt;em&gt;Cache-friendly&lt;/em&gt;&lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">LinkedList는 &lt;strong&gt;캐시 적대적&lt;/strong&gt; 데이터 구조이므로 실습은 매우 다릅니다. 성능 POV에서 &lt;code&gt;LinkedList&lt;/code&gt; 가 &lt;em&gt;Cache-friendly&lt;/em&gt; &lt;code&gt;ArrayList&lt;/code&gt; 보다 성능이 좋은 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="cca9612e17514e1ec64192796cfa4e74465f72b1" translate="yes" xml:space="preserve">
          <source>Reason: LinkedList&amp;rsquo;s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.</source>
          <target state="translated">이유 : LinkedList의 각 요소는 목록의 두 인접 요소를 가리키는 두 개의 포인터 (주소)를 유지합니다. 따라서 제거하려면 제거 할 노드의 두 인접 노드 (요소)에서 포인터 위치 만 변경하면됩니다. ArrayList에있는 동안 모든 요소는 제거 된 요소로 생성 된 공간을 채우기 위해 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="f68c820e0a45856c839ded9a5dcddfe8ab72ecae" translate="yes" xml:space="preserve">
          <source>Remove operation in LinkedList is generally the same as ArrayList i.e. O(n).</source>
          <target state="translated">LinkedList의 제거 작업은 일반적으로 ArrayList와 동일합니다 (예 : O (n)).</target>
        </trans-unit>
        <trans-unit id="73ae9a70388443373dde5d5fe2540131469bd3ca" translate="yes" xml:space="preserve">
          <source>Search (&lt;code&gt;get method&lt;/code&gt;) operations are fast in &lt;code&gt;Arraylist (O(1))&lt;/code&gt; but not in &lt;code&gt;LinkedList (O(n))&lt;/code&gt;</source>
          <target state="translated">검색 ( &lt;code&gt;get method&lt;/code&gt; ) 조작은 &lt;code&gt;Arraylist (O(1))&lt;/code&gt; 에서 빠르지 만 &lt;code&gt;LinkedList (O(n))&lt;/code&gt; 에서는 빠르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="beb9ed0bbc3bb6fd7e6c2e425c684fb4a813730a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;the Java Tutorials - List Implementations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot;&gt;Java Tutorials-List 구현을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f41eea01e67c4b4218cd4f1b61ae00436827205" translate="yes" xml:space="preserve">
          <source>Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.</source>
          <target state="translated">마찬가지로 기본 처리량 tenured 가비지 수집기에서 응용 프로그램의 처리량을 향상시킬 수 있지만 10GB 힙이있는 Java 응용 프로그램을 가져 오면 전체 GC 중에 25 초 동안 응용 프로그램을 잠그면 SOA 응용 프로그램에서 시간 초과 및 실패가 발생할 수 있습니다 SLA가 너무 자주 발생하면 SLA를 날려 버립니다. CMS 수집기는 더 많은 리소스를 사용하고 동일한 원시 처리량을 달성하지 않더라도 예측 가능하고 대기 시간이 짧기 때문에 훨씬 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="c7f07cd9a6f95a46d6ba5320ac3e54b3e0920e1e" translate="yes" xml:space="preserve">
          <source>Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit &lt;code&gt;LinkedLists&lt;/code&gt; and &lt;code&gt;ArrayLists&lt;/code&gt;.</source>
          <target state="translated">참조는 상대 시스템에서 32 또는 64 비트 (널 경우에도)이므로 32 및 64 비트 &lt;code&gt;LinkedLists&lt;/code&gt; 및 &lt;code&gt;ArrayLists&lt;/code&gt; 에 대한 4 개의 데이터 세트를 포함했습니다.</target>
        </trans-unit>
        <trans-unit id="69eebcd50b0954ecfc33ccabe9d8b7d4f9117ee9" translate="yes" xml:space="preserve">
          <source>So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an &lt;code&gt;ArrayList&lt;/code&gt; is technically faster, but unless you're doing something really performance-sensitive, you shouldn't worry about this -- they're both constants.)</source>
          <target state="translated">따라서 수행하려는 작업에 따라 구현을 선택해야합니다. 두 종류의 List를 반복하는 것은 실질적으로 저렴합니다. &lt;code&gt;ArrayList&lt;/code&gt; 를 반복적으로 처리하는 것은 기술적으로 더 빠르지 만 실제로 성능에 민감한 작업을 수행하지 않는 한 걱정할 필요가 없습니다. 두 상수입니다.</target>
        </trans-unit>
        <trans-unit id="9d8873955ed68a6d3afa3fc542ef7842e5776761" translate="yes" xml:space="preserve">
          <source>So memory requirement seems less in the case of ArrayList than LinkedList except for the case where Array performs the re-size operation when it copies content from one Array to another.</source>
          <target state="translated">따라서 Array가 한 배열에서 다른 배열로 내용을 복사 할 때 크기 조정 작업을 수행하는 경우를 제외하고 LinkedList보다 ArrayList의 경우 메모리 요구 사항이 적습니다.</target>
        </trans-unit>
        <trans-unit id="d29bcb90791eb28700c5ec8a4791f07074a61ec0" translate="yes" xml:space="preserve">
          <source>So, somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).</source>
          <target state="translated">따라서 효율성과 행동의 차이와 함께 약간 다른 문제를 해결합니다 (방법 목록 참조).</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="2723794bb959da323543cd3bc1ef514d3209ea99" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;모든 프로그래머가 알아야 할 지연 시간&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12d5ff1ccac20df183eacef481ad79a3b1d74a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; is pretty clear. O(1) for &lt;code&gt;ArrayList&lt;/code&gt;, because &lt;code&gt;ArrayList&lt;/code&gt; allow random access by using index. O(n) for &lt;code&gt;LinkedList&lt;/code&gt;, because it needs to find the index first. Note: there are different versions of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 것은 매우 분명하다. &lt;code&gt;ArrayList&lt;/code&gt; 의 경우 인덱스를 사용하여 임의 액세스를 허용하므로 &lt;code&gt;ArrayList&lt;/code&gt; 의 경우 O (1)입니다. 먼저 인덱스를 찾아야하므로 &lt;code&gt;LinkedList&lt;/code&gt; 의 O (n) 참고 : 서로 다른 버전의 &lt;code&gt;add&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4576a7bc64b7bfc1b683a9a061390ec3813c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; returned by these classes are &lt;code&gt;fail-fast&lt;/code&gt; (if list is structurally modified at any time after the iterator is created, in any way except through the &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; own remove or add methods, the iterator will &lt;code&gt;throw&lt;/code&gt; a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;).</source>
          <target state="translated">이 클래스들에 의해 리턴 된 &lt;code&gt;iterator&lt;/code&gt; 와 &lt;code&gt;listIterator&lt;/code&gt; 는 &lt;code&gt;fail-fast&lt;/code&gt; ( &lt;code&gt;iterator&amp;rsquo;s&lt;/code&gt; 자신의 remove 또는 add 메소드를 제외하고 어떤 방식 으로든 반복자가 작성된 후 목록이 구조적으로 수정되면 반복자는 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 &lt;code&gt;throw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e215678d488569b16687c62fc0c1cecd7a06b204" translate="yes" xml:space="preserve">
          <source>The LinkedList class extends AbstractSequentialList and implements List,Deque, and Queue interface.</source>
          <target state="translated">LinkedList 클래스는 AbstractSequentialList를 확장하고 List, Deque 및 Queue 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a584c17550a71fdd1f4452edc00d3a4572783158" translate="yes" xml:space="preserve">
          <source>The default initial capacity of an &lt;code&gt;ArrayList&lt;/code&gt; is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you're going to add a lot of elements, construct the &lt;code&gt;ArrayList&lt;/code&gt; with a higher initial capacity.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 의 기본 초기 용량은 매우 작습니다 (Java 1.4-1.8에서 10). 그러나 기본 구현은 배열이므로 많은 요소를 추가하면 배열의 크기를 조정해야합니다. 많은 요소를 추가 할 것임을 알 때 높은 크기 조정 비용을 피하려면 초기 용량이 더 높은 &lt;code&gt;ArrayList&lt;/code&gt; 를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6a73759baa6b5937448572841c9e25224f4a4466" translate="yes" xml:space="preserve">
          <source>The first difference between ArrayList and LinkedList comes with the fact that ArrayList is backed by Array while LinkedList is backed by LinkedList. This will lead to further differences in performance.</source>
          <target state="translated">ArrayList와 LinkedList의 첫 번째 차이점은 ArrayList는 Array에 의해 지원되고 LinkedList는 LinkedList에 의해 지원된다는 사실입니다. 이로 인해 성능에 차이가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="405c38f8ac19fd59375c5014403c7ab61e163b10" translate="yes" xml:space="preserve">
          <source>The formulas I used follow, let me know if I have done anything wrong and I will fix it up. 'b' is either 4 or 8 for 32 or 64 bit systems, and 'n' is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.</source>
          <target state="translated">내가 사용한 공식은 내가 잘못한 것을 알려 주면 고칠 것입니다. 'b'는 32 또는 64 비트 시스템에서 4 또는 8이며 'n'은 요소 수입니다. mod의 이유는 java의 모든 객체가 모두 사용되는지 여부에 관계없이 8 바이트의 배수를 차지하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c67ed32e3dd5ebe3398abf72bee54241312ba5f5" translate="yes" xml:space="preserve">
          <source>The get(index) operation is O(1) in ArrayList while its O(n/2) in LinkedList, as it needs to traverse till that entry. Though, in Big O notation O(n/2) is just O(n) because we ignore constants there.</source>
          <target state="translated">get (index) 연산은 ArrayList에서 O (1)이고 LinkedList에서 O (n / 2)는 해당 항목까지 통과해야하기 때문에 필요합니다. 비록 큰 O 표기법에서 O (n / 2)는 상수를 무시하기 때문에 O (n) 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="ebbe3e7e54ca846d40859c9cd5c54f9e245ba147" translate="yes" xml:space="preserve">
          <source>The main benefits of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you re-use existing iterators to insert and remove elements. These operations can then be done in &lt;em&gt;O(1)&lt;/em&gt; by changing the list locally only. In an array list, the remainder of the array needs to be &lt;em&gt;moved&lt;/em&gt; (i.e. copied). On the other side, seeking in a &lt;code&gt;LinkedList&lt;/code&gt; means following the links in &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/2&lt;/em&gt; steps) for worst case, whereas in an &lt;code&gt;ArrayList&lt;/code&gt; the desired position can be computed mathematically and accessed in &lt;em&gt;O(1)&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 사용의 주요 이점은 기존 반복기를 재사용하여 요소를 삽입하고 제거 할 때 발생합니다. 그런 다음 목록을 로컬로만 변경하여 &lt;em&gt;O (1)&lt;/em&gt; 에서 이러한 작업을 수행 할 수 있습니다. 배열 목록에서 배열의 나머지 부분을 &lt;em&gt;이동&lt;/em&gt; (즉, 복사)해야합니다. 다른 한편으로, &lt;code&gt;LinkedList&lt;/code&gt; 를 찾는 것은 최악의 경우 &lt;em&gt;O (n)&lt;/em&gt; ( &lt;em&gt;n / 2&lt;/em&gt; 단계)의 링크를 따르는 것을 의미하지만, &lt;code&gt;ArrayList&lt;/code&gt; 에서는 원하는 위치를 수학적으로 계산하고 &lt;em&gt;O (1)&lt;/em&gt; 에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74b1e781ca90526e83c42ffc3d14526c49736ab" translate="yes" xml:space="preserve">
          <source>The reason behind &lt;em&gt;ArrayList&lt;/em&gt; being faster than LinkedList is that ArrayList uses an index based system for its elements as it internally uses an array data structure, on the other hand,</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; 가 LinkedList보다 빠른 이유는 &lt;em&gt;ArrayList&lt;/em&gt; 가 내부적으로 배열 데이터 구조를 사용하기 때문에 요소에 인덱스 기반 시스템을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2f3082915f897c89bedc037a984915a010f1935c" translate="yes" xml:space="preserve">
          <source>The result clearly shows that &lt;code&gt;LinkedList&lt;/code&gt; is a whole lot more than &lt;code&gt;ArrayList&lt;/code&gt;, especially with a very high element count. If memory is a factor, steer clear of &lt;code&gt;LinkedLists&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;LinkedList&lt;/code&gt; 가 &lt;code&gt;ArrayList&lt;/code&gt; 보다 훨씬 많으며 특히 요소 수가 매우 많음을 분명히 보여줍니다. 메모리가 중요한 요소 인 경우 &lt;code&gt;LinkedLists&lt;/code&gt; 를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="55e26f9f49b3d7c9c3c97a405002150b730e9d84" translate="yes" xml:space="preserve">
          <source>There are few similarities between these classes which are as follows:</source>
          <target state="translated">이 클래스들 사이에는 다음과 같은 유사점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="979f5bb981358561639406265c29e3fa18c87f2d" translate="yes" xml:space="preserve">
          <source>There are two main reasons for this:</source>
          <target state="translated">이에 대한 두 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e22a50ad3da080a9975903475702d34ba04615" translate="yes" xml:space="preserve">
          <source>There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList implementation&lt;/a&gt;.  (Yes, it's from 2001, so you'll need to generify it, but I got comparable performance ratios to what's quoted in the article just now in a recent JVM)</source>
          <target state="translated">LinkedList가 ArrayList를 능가하는 일반적인 사용 사례가 하나 있습니다. 그러나 목표가 성능 인 경우 LinkedList 대신 ArrayBlockingQueue (대기열 큐 크기의 상한을 미리 결정하고 모든 메모리를 미리 할당 할 수있는 경우) 또는이 &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot;&gt;CircularArrayList 구현을&lt;/a&gt; 사용하는 것도 고려해야 합니다. . (예, 2001 년부터 생성되었으므로 생성해야하지만 최근 JVM의 기사에서 인용 한 것과 비슷한 성능 비율을 얻었습니다)</target>
        </trans-unit>
        <trans-unit id="bb24115d041e92964431dc2a9a4c804a8c2714b7" translate="yes" xml:space="preserve">
          <source>They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.</source>
          <target state="translated">둘 다 요소 삽입 순서를 유지합니다. 즉, ArrayList 및 LinkedList 요소를 표시하는 동안 결과 집합은 요소가 List에 삽입 된 순서와 동일한 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a7393aee9cdbf2240709c5e92b61bea76f07fd0d" translate="yes" xml:space="preserve">
          <source>Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a &lt;code&gt;LinkedList&lt;/code&gt; is &quot;lots more&quot; than an &lt;code&gt;ArrayList&lt;/code&gt; so I did some number crunching to demonstrate exactly how much both lists take up for N null references.</source>
          <target state="translated">지금까지 아무도 &lt;code&gt;LinkedList&lt;/code&gt; 가 &lt;code&gt;ArrayList&lt;/code&gt; 보다 &quot;많이 더 많다&quot;는 일반적인 의견 외에도 이러한 각 목록의 메모리 풋 프린트를 다루지 않은 것으로 보이 므로 N null 참조에 대해 두 목록이 얼마나 많이 차지하는지 정확하게 보여주기 위해 약간의 크 런칭을 수행했습니다. .</target>
        </trans-unit>
        <trans-unit id="5f0ebd31014e6d03e89c2e7c5de3ae7e005b1340" translate="yes" xml:space="preserve">
          <source>To find out more, read any article that talks about the difference between arrays and linked lists.</source>
          <target state="translated">자세한 내용을 보려면 배열과 연결된 목록의 차이점에 대한 기사를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="29ca1dbcdfa1f09ca0ddfee47c7f010975f7b16f" translate="yes" xml:space="preserve">
          <source>Unless you've created large lists and measured a bottleneck, you'll probably never need to worry about the difference.</source>
          <target state="translated">큰 목록을 작성하고 병목 현상을 측정하지 않으면 차이에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="445928a04da6390fbfe641573eb932e5cdb28769" translate="yes" xml:space="preserve">
          <source>When should &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; be used over &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and vice-versa?</source>
          <target state="translated">언제 &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; 를&lt;/a&gt; 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="78753f704c5e896d437844d3fb47088744b55cf9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList and when to use ArrayList?</source>
          <target state="translated">LinkedList를 언제 사용하고 언제 ArrayList를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="38de968ae17bb38f4696d5acc9b08397e7f206f9" translate="yes" xml:space="preserve">
          <source>When to use LinkedList over ArrayList in Java</source>
          <target state="translated">Java에서 ArrayList보다 LinkedList를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="8e108c13808368fe0f3f3e721de63a230cc41edf" translate="yes" xml:space="preserve">
          <source>Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.</source>
          <target state="translated">삽입 및 제거에 더 빠른 두 가지 중 어느 것이 발생하는지에 따라 다릅니다. 시작에 가까워지면 비교적 적은 수의 요소를 거쳐야하므로 LinkedList가 더 빠릅니다. 우리가 끝에 가까워지면 ArrayList가 더 빠를 것입니다. 왜냐하면 우리는 일정한 시간에 도착하고 그 뒤에 나오는 몇 개의 나머지 요소 만 변경하면되기 때문입니다. 중간에서 정확하게 수행하면 n 개의 요소를 통과하는 것이 n 값을 이동하는 것보다 빠르기 때문에 LinkedList가 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="aa1559133ba9f967b51fb87c9d69f02e2d34fd11" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt; remove(int) method involves copying elements from the old array to new updated array, hence its runtime is O(n).</source>
          <target state="translated">&lt;em&gt;ArrayList에서&lt;/em&gt; remove (int) 메서드는 이전 배열에서 새로운 업데이트 된 배열로 요소를 복사하는 것을 포함하므로 런타임은 O (n)입니다.</target>
        </trans-unit>
        <trans-unit id="22fb9822109a567e96dc1961a1c75216ea996026" translate="yes" xml:space="preserve">
          <source>While in &lt;em&gt;ArrayList&lt;/em&gt;, if the array is the full i.e worst case,  there is an extra cost of resizing array and copying elements to the new array, which makes runtime of add operation in ArrayList O(n), otherwise it is O(1).</source>
          <target state="translated">&lt;em&gt;ArrayList에&lt;/em&gt; 있는 동안 배열이 전체 즉 최악의 경우 배열의 크기를 조정하고 새 배열에 요소를 복사하는 추가 비용이 발생하여 ArrayList O (n)에서 추가 작업을 런타임으로 수행합니다. 그렇지 않으면 O (1)입니다 .</target>
        </trans-unit>
        <trans-unit id="da14c4f26f81795e276c6bd693c6d365161bbd6f" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;LinkedList&lt;/code&gt; sucks:</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 가 짜증나는 이유 :</target>
        </trans-unit>
        <trans-unit id="55541df4dcf152a08b381822d996bdf2502bee11" translate="yes" xml:space="preserve">
          <source>Working on a later generation hardware (bigger, more efficient caches) - the results are even more conclusive:</source>
          <target state="translated">차세대 하드웨어 (더 크고 효율적인 캐시)에서 작업-결과는 더욱 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="a96e6d2490d18f0fcecefd52716013baa2282e27" translate="yes" xml:space="preserve">
          <source>Yeah, I know, this is an ancient question, but I'll throw in my two cents:</source>
          <target state="translated">그래, 나는 이것이 고대의 질문이라는 것을 알고 있지만, 나는 2 센트를 넣을 것이다.</target>
        </trans-unit>
        <trans-unit id="3421ce1baebeb5f24f380dc68763a8fa7781e99b" translate="yes" xml:space="preserve">
          <source>add at the end of ArrayList</source>
          <target state="translated">ArrayList의 끝에 추가</target>
        </trans-unit>
        <trans-unit id="d2221c6840ebc04f909e2dcc5cd06ad7d8f6932a" translate="yes" xml:space="preserve">
          <source>add to a specific index position</source>
          <target state="translated">특정 인덱스 위치에 추가</target>
        </trans-unit>
        <trans-unit id="b281534d3156b92bf772720eb3f8efc8a069ba16" translate="yes" xml:space="preserve">
          <source>add to the end of the list</source>
          <target state="translated">목록의 끝에 추가</target>
        </trans-unit>
        <trans-unit id="4f6fa4b826aa66326567de6e0de9a55c1c55a1f6" translate="yes" xml:space="preserve">
          <source>add(E e)</source>
          <target state="translated">추가 (E e)</target>
        </trans-unit>
        <trans-unit id="72b84dc9449f12507c91ba8d78cb41d5e51adf02" translate="yes" xml:space="preserve">
          <source>add(int index, E element)</source>
          <target state="translated">추가 (int index, E element)</target>
        </trans-unit>
        <trans-unit id="844ba48b6f4d03efb77ea996bee561e0383f6609" translate="yes" xml:space="preserve">
          <source>get(int index) or search operation</source>
          <target state="translated">get (int index) 또는 검색 작업</target>
        </trans-unit>
        <trans-unit id="3471d553186e51c7dfeab01069130c02fa1f5d6e" translate="yes" xml:space="preserve">
          <source>hence the memory consumption is high in LinkedList comparatively.</source>
          <target state="translated">따라서 LinkedList에서 메모리 소비가 비교적 높습니다.</target>
        </trans-unit>
        <trans-unit id="c097d2b9e6029ded8d9e023c043cc1fd76009367" translate="yes" xml:space="preserve">
          <source>insert at specified position</source>
          <target state="translated">지정된 위치에 삽입</target>
        </trans-unit>
        <trans-unit id="a9e8151e5167b5af037785aa4dc339561be644f1" translate="yes" xml:space="preserve">
          <source>insert() or add(Object) operation</source>
          <target state="translated">insert () 또는 add (Object) 연산</target>
        </trans-unit>
        <trans-unit id="9c1204571198e8877ebce850c1dfb52bd2b5a592" translate="yes" xml:space="preserve">
          <source>need to find the element first</source>
          <target state="translated">요소를 먼저 찾아야합니다</target>
        </trans-unit>
        <trans-unit id="a191f25905b311a0a098953a475e0fe58a39f999" translate="yes" xml:space="preserve">
          <source>need to find the position first</source>
          <target state="translated">위치를 먼저 찾아야합니다</target>
        </trans-unit>
        <trans-unit id="847ad4fb3598032da7663514a73890f0201a0804" translate="yes" xml:space="preserve">
          <source>need to search the element first, and then shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">먼저 요소를 검색 한 다음 이동 및 가능한 메모리 크기 조정 비용</target>
        </trans-unit>
        <trans-unit id="aa3f74c9a865d4ab8e22742926357ae39d210034" translate="yes" xml:space="preserve">
          <source>remove a specified element</source>
          <target state="translated">지정된 요소를 제거</target>
        </trans-unit>
        <trans-unit id="bb34c3a95d3f5f993e01a9c524699f01d857b2bc" translate="yes" xml:space="preserve">
          <source>remove element with specified index</source>
          <target state="translated">지정된 인덱스를 가진 요소를 제거</target>
        </trans-unit>
        <trans-unit id="4ac73d56678223d75eda9aae361f03cbb4efb477" translate="yes" xml:space="preserve">
          <source>remove first element of the list</source>
          <target state="translated">목록의 첫 번째 요소를 제거</target>
        </trans-unit>
        <trans-unit id="247a8156822c95c4f1d9153b4b6e8f6be6811d4d" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element</source>
          <target state="translated">지정된 요소의 첫 항목을 제거</target>
        </trans-unit>
        <trans-unit id="52a10c2f057161132a26d20ded67b637c1fbd40b" translate="yes" xml:space="preserve">
          <source>remove the first occurrence of the specified element from this list</source>
          <target state="translated">이 목록에서 지정된 요소의 첫 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="bd3be8adf5ced4095cfe468b4bc677c15a10ae09" translate="yes" xml:space="preserve">
          <source>remove()</source>
          <target state="translated">remove()</target>
        </trans-unit>
        <trans-unit id="e44f21ff188d5fffffea502864836471078eb47b" translate="yes" xml:space="preserve">
          <source>remove(Object o)</source>
          <target state="translated">제거 (오브젝트 o)</target>
        </trans-unit>
        <trans-unit id="e60165c5083078c6a746b52139fb9f6097486ada" translate="yes" xml:space="preserve">
          <source>remove(int index)</source>
          <target state="translated">제거 (INT 인덱스)</target>
        </trans-unit>
        <trans-unit id="57ef2c48f4ed0634600c52ceb1e6d3dd7a4f0537" translate="yes" xml:space="preserve">
          <source>remove(int) operation</source>
          <target state="translated">제거 (int) 작업</target>
        </trans-unit>
        <trans-unit id="abaf93324a2d63d24596456a9a769ee878da2d71" translate="yes" xml:space="preserve">
          <source>require memory resizing cost.</source>
          <target state="translated">메모리 크기 조정 비용이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="624f26f7a70b9282abd23807374f9ad938d82f14" translate="yes" xml:space="preserve">
          <source>require shifting &amp;amp; possible memory resizing cost</source>
          <target state="translated">이동 및 가능한 메모리 크기 조정 비용 필요</target>
        </trans-unit>
        <trans-unit id="830739c4a912c77e621eacfa69ff1a2e20904588" translate="yes" xml:space="preserve">
          <source>so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.</source>
          <target state="translated">따라서 추가 및 제거 작업이 적고 검색 작업 요구 사항이 더 많으면 ArrayList가 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8afac9dd157c540d08e836d87cf840122340a4c0" translate="yes" xml:space="preserve">
          <source>there are a large number of add/remove operations</source>
          <target state="translated">많은 추가 / 제거 작업이 있습니다</target>
        </trans-unit>
        <trans-unit id="8156fdb9f5fc9c9f8388d191c22e989ad6fd729e" translate="yes" xml:space="preserve">
          <source>there are no large number of random access of element</source>
          <target state="translated">요소에 대한 많은 랜덤 액세스가 없습니다</target>
        </trans-unit>
        <trans-unit id="33e994a94f2f973adcc52b6ab5eb6c4835a3b486" translate="yes" xml:space="preserve">
          <source>there is no descendingIterator() in &lt;em&gt;ArrayList&lt;/em&gt; , so we need to write our own code to iterate over the ArrayList in reverse direction.</source>
          <target state="translated">&lt;em&gt;ArrayList&lt;/em&gt; 에는 내려가는 Iterator ()가 없으므로 ArrayList를 역순으로 반복하려면 자체 코드를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="aacb03ae7534d3764f83b010045b893210f65a4b" translate="yes" xml:space="preserve">
          <source>whereas In linkedlist</source>
          <target state="translated">반면 linkedlist에서</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
