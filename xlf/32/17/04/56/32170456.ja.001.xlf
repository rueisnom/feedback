<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/32170456">
    <body>
      <group id="32170456">
        <trans-unit id="d3a244fb54042f2dbf42e3fe5fb600311a47bd44" translate="yes" xml:space="preserve">
          <source>1. Explicit Force Unwrapping</source>
          <target state="translated">1.明示的な強制解禁</target>
        </trans-unit>
        <trans-unit id="635c6e54ef549bf1619585c9acdb06d314adaf23" translate="yes" xml:space="preserve">
          <source>2. Implicitly Unwrapped Optionals</source>
          <target state="translated">2.暗黙的にアンラップされたオプショナル</target>
        </trans-unit>
        <trans-unit id="18d21910bcbc1da8e1aa11e251dedd0b06352cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; has a single method called &lt;code&gt;init(nilLiteral:)&lt;/code&gt; which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with &lt;code&gt;nil&lt;/code&gt; literal.</source>
          <target state="translated">&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; には、インスタンスをnilで初期化する &lt;code&gt;init(nilLiteral:)&lt;/code&gt; と呼ばれる単一のメソッドがあります。 通常、このメソッドを呼び出すことはありません。迅速なドキュメントによると、 &lt;code&gt;nil&lt;/code&gt; リテラルでOptional型を初期化するときはいつでもコンパイラーがこの初期化子を呼び出すため、この初期化子を直接呼び出すことはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="5a9772727897bd3ca247cb46b7f9cb451241ee24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works similarly to &lt;code&gt;map&lt;/code&gt;, except it allows you to return &lt;em&gt;another&lt;/em&gt; optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; は &lt;code&gt;map&lt;/code&gt; と同様に機能しますが、クロージャー本体内から&lt;em&gt;別の&lt;/em&gt;オプションを返すことができます。 つまり、オプションではない入力が必要なプロセスにオプションを入力できますが、オプション自体を出力できます。</target>
        </trans-unit>
        <trans-unit id="25b1070a11e663243cc897c90af46f99c6df445c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; および &lt;code&gt;flatMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c46dee75d89e56932987294e4ff7e4232b363930" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You should only ever use &lt;code&gt;try!&lt;/code&gt; if you can prove that its result will never fail in your context - and this is very rare.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;あなただけの &lt;code&gt;try!&lt;/code&gt; 使うべきです！&lt;/em&gt; &lt;em&gt;あなたがその結果があなたの文脈で決して失敗しないことを証明できれば-そしてこれは非常にまれです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b7730d90c9b2349ff66ee31e8785e67ba52fb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you now tell me which object it is that was &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;どのオブジェクトが &lt;code&gt;nil&lt;/code&gt; だったか教えてください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37a5bcf391e8ccb209c28d5fceb142b218d5b019" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you tell me which object is &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;どのオブジェクトが &lt;code&gt;nil&lt;/code&gt; であるか教えていただけますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f283be4efc0664716ddd69d9cdc7df0c17dbd693" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that this &lt;code&gt;nil&lt;/code&gt; is not the same as the &lt;code&gt;nil&lt;/code&gt; in Objective-C. In Objective-C, &lt;code&gt;nil&lt;/code&gt; is the absence of a valid &lt;em&gt;object pointer&lt;/em&gt;; in Swift, Optionals are not restricted to objects/reference types. Optional behaves similarly to Haskell's &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Maybe&lt;/a&gt;.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（この &lt;code&gt;nil&lt;/code&gt; はObjective-Cの &lt;code&gt;nil&lt;/code&gt; と同じではないことに注意してください。Objective-Cでは、 &lt;code&gt;nil&lt;/code&gt; は有効な&lt;em&gt;オブジェクトポインターの&lt;/em&gt;欠如です。Swiftでは、オプションはオブジェクト/参照型に制限されません。オプションはHaskellの動作と同様に動作します。 &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;多分&lt;/a&gt; 。）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d516eb97f8385312f77ef9000f049aeddc35663f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that within the guard body, you &lt;strong&gt;must&lt;/strong&gt; use one of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;control transfer statements&lt;/a&gt; in order to exit the scope of the currently executing code).&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（ガード本文内では、現在実行中のコードのスコープを終了するために、 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;制御転送ステートメントの&lt;/a&gt; 1つを使用する&lt;strong&gt;必要がある&lt;/strong&gt;ことに注意してください）。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5b87ee6fe147c52e17815abd3b0ac225686bc372" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is because an optional value will return &lt;code&gt;Void?&lt;/code&gt; rather than &lt;code&gt;Void&lt;/code&gt; on a method that doesn&amp;rsquo;t return anything)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（これは、オプションの値が、何も返さないメソッドでは &lt;code&gt;Void&lt;/code&gt; ではなく &lt;code&gt;Void?&lt;/code&gt; を返すためです）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8d73db717d8e4390f76c6acdf864843b513507e2" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is similar behaviour to sending messages to &lt;code&gt;nil&lt;/code&gt; in Objective-C)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（これはObjective-Cで &lt;code&gt;nil&lt;/code&gt; にメッセージを送信するのと同様の動作です）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8404a61e69301e260a8bda1a58f0ce7110e7cc50" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This answer is &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;community wiki&lt;/a&gt;. If you feel it could be made better, feel free to &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit it&lt;/a&gt;!&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;この回答は&lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;コミュニティWiki&lt;/a&gt;です。&lt;/sup&gt; &lt;sup&gt;改善できると感じた場合は、自由に&lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;編集して&lt;/a&gt;ください。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d92a649ecca38db770e2ea85dae9072443b3c79f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit&lt;/a&gt; the existing wiki answer.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;この投稿は、「予期せず発見されたnil」問題への回答を収集することを目的としています。そのため、それらは散らばり、見つけにくくなりません。&lt;/sup&gt; &lt;sup&gt;独自の回答を追加するか、既存のWiki回答を&lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;編集し&lt;/a&gt;てください。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eae132614e41cb087afb2d1c01f40480f4698746" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;guard statement&lt;/a&gt; allows you to define a condition for success &amp;ndash; and the current scope will only continue executing if that condition is met. They are defined with the syntax &lt;code&gt;guard condition else {...}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;ガードステートメントを&lt;/a&gt;使用すると、成功の条件を定義できます。現在のスコープは、その条件が満たされた場合にのみ実行を継続します。 それらは構文 &lt;code&gt;guard condition else {...}&lt;/code&gt; 定義されます。</target>
        </trans-unit>
        <trans-unit id="8dd03209df27cf5183ea0c4aad3e184b5a067c77" translate="yes" xml:space="preserve">
          <source>According to swift, 'nil' is the absence of value.
And to create an instance initialized with &lt;code&gt;nil&lt;/code&gt; We have to conform to a protocol called &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and great if you guessed it, only &lt;code&gt;Optionals&lt;/code&gt; conform to &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and conforming to other types is discouraged.</source>
          <target state="translated">迅速によれば、「nil」は価値の欠如です。 そして &lt;code&gt;nil&lt;/code&gt; で初期化されたインスタンスを作成するには &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; と呼ばれるプロトコルに準拠する必要があります。推測した場合、 &lt;code&gt;Optionals&lt;/code&gt; のみが &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; に準拠し、他のタイプへの準拠は推奨されません。</target>
        </trans-unit>
        <trans-unit id="45073dbf8f3ef81afe07094beb4f6608a541d353" translate="yes" xml:space="preserve">
          <source>Again, because &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are optional, the value returned from &lt;code&gt;qux&lt;/code&gt; will always be an optional regardless of whether &lt;code&gt;qux&lt;/code&gt; itself is optional.</source>
          <target state="translated">繰り返しますが、 &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;baz&lt;/code&gt; はオプションであるため、 &lt;code&gt;qux&lt;/code&gt; 自体がオプションかどうかに関係なく、 &lt;code&gt;qux&lt;/code&gt; から返される値は常にオプションになります。</target>
        </trans-unit>
        <trans-unit id="04b74eddaac2e0ff122721a98735cd4f4241cab6" translate="yes" xml:space="preserve">
          <source>Again, nothing bad will happen here if &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Your code will simply continue executing.</source>
          <target state="translated">繰り返しになりますが、 &lt;code&gt;foo&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、ここでは何も問題は発生しません。 コードは実行を継続します。</target>
        </trans-unit>
        <trans-unit id="9e19419202a958c9e2c652dec63d96656df38091" translate="yes" xml:space="preserve">
          <source>Also, as the name suggests, you can &amp;lsquo;chain&amp;rsquo; these statements together. This means that if &lt;code&gt;foo&lt;/code&gt; has an optional property &lt;code&gt;baz&lt;/code&gt;, which has a property &lt;code&gt;qux&lt;/code&gt; &amp;ndash; you could write the following:</source>
          <target state="translated">また、名前が示すように、これらのステートメントを一緒に「チェーン」することができます。 これは、 &lt;code&gt;foo&lt;/code&gt; にオプションプロパティ &lt;code&gt;baz&lt;/code&gt; があり、プロパティ &lt;code&gt;qux&lt;/code&gt; がある場合、次のように記述できることを意味します。</target>
        </trans-unit>
        <trans-unit id="3231de44e5b6f036b78301686d6ee18d12703f6b" translate="yes" xml:space="preserve">
          <source>Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:</source>
          <target state="translated">別の方法として、変数がnilの場合に関数を終了させるためのガード文を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="5df38dfc408955dbdd3d7167930749d99834f562" translate="yes" xml:space="preserve">
          <source>An often underused feature with optionals is the ability to use the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesn&amp;rsquo;t have a value, it will remain &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">オプションでよく使用され &lt;code&gt;flatMap&lt;/code&gt; 機能は、 &lt;code&gt;map&lt;/code&gt; 関数とflatMap関数を使用する機能です。 これらにより、オプション変数に非オプション変換を適用できます。 オプションに値がある場合、それに任意の変換を適用できます。 値がない場合は &lt;code&gt;nil&lt;/code&gt; のままです。</target>
        </trans-unit>
        <trans-unit id="7475dbf59ea659fe38624a59d7089f9c937ce515" translate="yes" xml:space="preserve">
          <source>An optional is actually a container than contains either a variable of a given type, or nothing.</source>
          <target state="translated">オプショナルは実際には、指定された型の変数を含むコンテナであり、何も含まれていません。</target>
        </trans-unit>
        <trans-unit id="3c0e7f41650898afdecfa4b26246b1d90eee328c" translate="yes" xml:space="preserve">
          <source>An optional needs to be &quot;unwrapped&quot; in order to fetch the value inside.</source>
          <target state="translated">オプションは、内部の値を取得するために &quot;unwrapped&quot; する必要があります。</target>
        </trans-unit>
        <trans-unit id="d26f01d2167b0ccd73f5ca8a245ba70fa537337b" translate="yes" xml:space="preserve">
          <source>And Optional type is nothing but an enumeration with two cases, i.e</source>
          <target state="translated">また、Optional型は2つのケースを持つ列挙に過ぎません。</target>
        </trans-unit>
        <trans-unit id="0c9267177db8f82598d60f708a0d70d575d72d06" translate="yes" xml:space="preserve">
          <source>Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.</source>
          <target state="translated">また、カンマを使って、値をほぐした後に特定の条件があるかどうかをチェックすることもできるのが、もうひとつのコツです。</target>
        </trans-unit>
        <trans-unit id="6ddb885b2b01e4ba63f81165812deb39af75a71c" translate="yes" xml:space="preserve">
          <source>Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">オプションのチェーンで実行できるもう1つの巧妙なトリックは、プロパティの設定またはメソッドの呼び出しが成功したかどうかを確認することです。 これを行うには、戻り値を &lt;code&gt;nil&lt;/code&gt; と比較します。</target>
        </trans-unit>
        <trans-unit id="32470d176ca6dd8f034dc5807b14e045ee20d3c6" translate="yes" xml:space="preserve">
          <source>Another way to declare an optional variable is</source>
          <target state="translated">オプション変数を宣言するもう一つの方法は</target>
        </trans-unit>
        <trans-unit id="443f7eb7f273a4e9c8d9c7fa2251a9bd082d81a0" translate="yes" xml:space="preserve">
          <source>Another, slightly more subtle gotcha with optionals is &quot;implicitly unwrapped optionals. When we declare foo, we could say:</source>
          <target state="translated">もうひとつの、もう少し微妙なオプショナルの問題は、「暗黙のうちにアンラップされたオプショナル」です。foo を宣言すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="52474acee09818b60266e64bb250148f3409b9d7" translate="yes" xml:space="preserve">
          <source>Apple documentation on Swift Optionals</source>
          <target state="translated">Swift Optionalsに関するAppleのドキュメント</target>
        </trans-unit>
        <trans-unit id="515515b53e442d6c0ac9c382069d83edc146839b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;anOptionalString&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; here, you will get a crash on the line where you force unwrap it.</source>
          <target state="translated">ここでは &lt;code&gt;anOptionalString&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; であるため、強制的にアンラップする行でクラッシュが発生します。</target>
        </trans-unit>
        <trans-unit id="6401b89cf6e7b504f6a51a78043447e304db2acc" translate="yes" xml:space="preserve">
          <source>As a general rule, you should never explicitly force unwrap an optional with the &lt;code&gt;!&lt;/code&gt; operator. There may be cases where using &lt;code&gt;!&lt;/code&gt; is acceptable &amp;ndash; but you should only ever be using it if you are 100% sure that the optional contains a value.</source>
          <target state="translated">一般的な規則として、オプションを明示的に強制的にアンラップしないでください &lt;code&gt;!&lt;/code&gt; オペレーター。 &lt;code&gt;!&lt;/code&gt; 許容できますが、オプションに値が含まれていることを100％確信している場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="e63c2b6a3158f2d5901a2d116e700ecadd6e8ac7" translate="yes" xml:space="preserve">
          <source>Avoid use of &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">の使用は避けてください &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="48ec3975808ef63d21f693479b688b665f317562" translate="yes" xml:space="preserve">
          <source>Background: What&amp;rsquo;s an Optional?</source>
          <target state="translated">背景：オプションとは何ですか？</target>
        </trans-unit>
        <trans-unit id="000712677e846810968631694b8782eea505d28e" translate="yes" xml:space="preserve">
          <source>Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.</source>
          <target state="translated">基本的には、Swiftではnilではないものしか使えない場所でnil値を使おうとしたのです。</target>
        </trans-unit>
        <trans-unit id="6510cebf85c73b91f042a999279b8ecb4a6cfde5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;stringByAppendingString&lt;/code&gt; takes a non-optional string argument, we cannot input our optional string directly. However, by using &lt;code&gt;map&lt;/code&gt;, we can use allow &lt;code&gt;stringByAppendingString&lt;/code&gt; to be used if &lt;code&gt;anOptionalString&lt;/code&gt; has a value.</source>
          <target state="translated">&lt;code&gt;stringByAppendingString&lt;/code&gt; はオプションではない文字列引数を取るため、オプションの文字列を直接入力することはできません。 ただし、 &lt;code&gt;map&lt;/code&gt; を使用することで、 &lt;code&gt;stringByAppendingString&lt;/code&gt; に値がある場合に、 &lt;code&gt;anOptionalString&lt;/code&gt; 使用を許可できます。</target>
        </trans-unit>
        <trans-unit id="3981488e6abb1cb399b600a4e20bcc5f6c58686a" translate="yes" xml:space="preserve">
          <source>Bottom line: When you are first learning Swift, pretend the &quot;!&quot; character is not part of the language. It's likely to get you into trouble.</source>
          <target state="translated">結論から言います。あなたが最初にSwiftを学習しているとき、「!」という文字は言語の一部ではないふりをしましょう。それはあなたをトラブルに巻き込む可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="270c4892a016f64b1f29e7cd37c444a555dc7d7d" translate="yes" xml:space="preserve">
          <source>But Swift's error handling system also provides a way to &quot;force try&quot; with &lt;code&gt;try!&lt;/code&gt;:</source>
          <target state="translated">しかし、Swiftのエラー処理システムは、tryで「強制的に試行」する方法も提供します &lt;code&gt;try!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8e2f129952b7df6d9c9137de5fc26c084032ef61" translate="yes" xml:space="preserve">
          <source>By applying the &lt;code&gt;map&lt;/code&gt; function to it &amp;ndash; we can use the &lt;code&gt;stringByAppendingString&lt;/code&gt; function in order to concatenate it to another string.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 関数をそれに適用することによって&amp;ndash;別の文字列に連結するために &lt;code&gt;stringByAppendingString&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="890392cd814cb51a3ec19620be5a911041086aa9" translate="yes" xml:space="preserve">
          <source>Declare variable optional (&lt;code&gt;?&lt;/code&gt;), not implicitly unwrapped optionals (IUO) (&lt;code&gt;!&lt;/code&gt;)</source>
          <target state="translated">暗黙的にアンラップされたオプション（IUO）ではなく、変数オプション（ &lt;code&gt;?&lt;/code&gt; ）を宣言します（ &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2259c1bef40d9a2d2466c01f96f672a698d0443" translate="yes" xml:space="preserve">
          <source>Destination Controller:</source>
          <target state="translated">デスティネーションコントローラ。</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="202b26ba321fbfe7f81ed7bbc6b02aef082dc6be" translate="yes" xml:space="preserve">
          <source>Either unwrap variable like this:</source>
          <target state="translated">このように変数をアンラップするか</target>
        </trans-unit>
        <trans-unit id="ca0a491616073f375fc6c16bc6cdb928b2718880" translate="yes" xml:space="preserve">
          <source>Even myself has to wrap (no pun intended) my head around Optionals :D
&lt;em&gt;Happy Swfting All&lt;/em&gt;.</source>
          <target state="translated">私でさえ私の頭をOptionals：D &lt;em&gt;Happy Swfting Allに巻き付ける&lt;/em&gt;必要があります（しゃれは意図していません）。</target>
        </trans-unit>
        <trans-unit id="d5e49c1f7f49b51d3c469b5d6175ea1c5c2c0403" translate="yes" xml:space="preserve">
          <source>Explicit Force Unwrapping</source>
          <target state="translated">明示的な強制解除</target>
        </trans-unit>
        <trans-unit id="7e9c689c33f3c0bb551be00e08e8e196af6dd530" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while &lt;strong&gt;implicitly&lt;/strong&gt; unwrapping an Optional value</source>
          <target state="translated">致命的エラー：オプション値を&lt;strong&gt;暗黙的に&lt;/strong&gt;アンラップしているときに予期せずnilが見つかりました</target>
        </trans-unit>
        <trans-unit id="63b2f6bd19b28c7b1987bcb9dd32336331c79410" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</source>
          <target state="translated">致命的なエラー。暗黙的にオプション値をアンラップしているときに予期せず nil が見つかりました。</target>
        </trans-unit>
        <trans-unit id="5ee449f8148453a77ee10bc85af161a2bf6904d0" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while unwrapping an Optional value</source>
          <target state="translated">致命的なエラー。オプション値のアンラップ中に予期せず nil が見つかりました。</target>
        </trans-unit>
        <trans-unit id="5c2c4179c8fff9ca83b586e12a580e908e386c5c" translate="yes" xml:space="preserve">
          <source>First, you should know what an Optional value is.
You can step to &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;The Swift Programming Language&lt;/a&gt; for detail.</source>
          <target state="translated">まず、オプションの値が何であるかを知っておく必要があります。 詳細については、 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;Swiftプログラミング言語&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fe3fb55243316c9dc924d99b807f5717582eeb12" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have an optional string:</source>
          <target state="translated">たとえば、オプションの文字列があるとします。</target>
        </trans-unit>
        <trans-unit id="8bd561982c688335d8305fd365ca075aba1100cc" translate="yes" xml:space="preserve">
          <source>For example, say we have a variable &lt;code&gt;foo&lt;/code&gt;, of type an optional &lt;code&gt;Foo&lt;/code&gt; instance.</source>
          <target state="translated">たとえば、オプションの &lt;code&gt;Foo&lt;/code&gt; インスタンス型の変数 &lt;code&gt;foo&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="4fe78f7c529115814a0589403fb98c66ea73e508" translate="yes" xml:space="preserve">
          <source>Guard statements were added in Swift 2. Guard lets you preserve the &quot;golden path&quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using &quot;if let&quot; optional binding.</source>
          <target state="translated">Guard ステートメントは Swift 2 で追加されました。Guardを使用することで、コードを通して「黄金の道」を維持することができ、「if let」オプションのバインディングを使用することで時々発生する入れ子になったifsのレベルが増え続けるのを避けることができます。</target>
        </trans-unit>
        <trans-unit id="93edce2bfc57c7c54e7fd4b314121e6beb589d57" translate="yes" xml:space="preserve">
          <source>Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">Guardは、ifステートメントがサポートするのと同じ巧妙なトリック（複数のオプションを同時にアンラップしたり、 &lt;code&gt;where&lt;/code&gt; 句を使用するなど）もサポートします。</target>
        </trans-unit>
        <trans-unit id="ad08562b159908e3b05f037b3e013647aba536b4" translate="yes" xml:space="preserve">
          <source>Hence it's better to write as such:</source>
          <target state="translated">だからこそ、そのように書いた方がいいのです。</target>
        </trans-unit>
        <trans-unit id="fd4007c3ff26895e5bb5fb48507590600d2502eb" translate="yes" xml:space="preserve">
          <source>Here by force casting you tell the compiler to no longer worry, as you'll always have a &lt;code&gt;Rectangle&lt;/code&gt; instance there. And as long as that holds, you don't have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.</source>
          <target state="translated">ここでは、強制キャストにより、常に &lt;code&gt;Rectangle&lt;/code&gt; インスタンスが存在するため、心配する必要がないようコンパイラーに指示します。 そしてそれが続く限り、あなたは心配する必要はありません。 問題は、プロジェクトのあなたや同僚が長方形以外の値を循環させ始めたときに始まります。</target>
        </trans-unit>
        <trans-unit id="a10432c3dfc4ac875e419233a429110d852331d9" translate="yes" xml:space="preserve">
          <source>Here is an example of optional binding with our &lt;code&gt;foo&lt;/code&gt; optional:</source>
          <target state="translated">以下は、オプションの &lt;code&gt;foo&lt;/code&gt; を使用したオプションのバインディングの例です。</target>
        </trans-unit>
        <trans-unit id="f1995e5026962d6c02dca7e583fc61ef9cd31d6c" translate="yes" xml:space="preserve">
          <source>How can I safely deal with Optionals?</source>
          <target state="translated">オプティカルを安全に扱うにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="e484fea1c47d9e20459264fe14e22be925d72d1b" translate="yes" xml:space="preserve">
          <source>How to deal with optionals:</source>
          <target state="translated">オプショナルとの付き合い方。</target>
        </trans-unit>
        <trans-unit id="8633d1988d44234fa26b09689d230a24a81c00ff" translate="yes" xml:space="preserve">
          <source>However, 99.9% of the time when working with optionals, you&amp;rsquo;ll actually want to access the value it contains, if it contains one at all. To do this, you can use &lt;em&gt;Optional Binding&lt;/em&gt;.</source>
          <target state="translated">ただし、オプションを使用する場合は、99.9％の時間で、実際に含まれている値にアクセスしたい場合があります。 これを行うには、 &lt;em&gt;オプションのバインド&lt;/em&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="9bcd13ba1c830e1eb8ee339d08e57ceccdcf9a16" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;anOptionalString&lt;/code&gt; doesn&amp;rsquo;t have a value, &lt;code&gt;map&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">ただし、 &lt;code&gt;anOptionalString&lt;/code&gt; に値がない場合、 &lt;code&gt;map&lt;/code&gt; は &lt;code&gt;nil&lt;/code&gt; を返します。 例えば：</target>
        </trans-unit>
        <trans-unit id="a00cf22dac7a818231c0ff4ab31cff56b029afeb" translate="yes" xml:space="preserve">
          <source>However, there are a &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;few scenarios where implicitly unwrapped optionals are beneficial&lt;/a&gt;, and you are still able to use various ways of safely unwrapping them as listed below &amp;ndash; but you should &lt;em&gt;always&lt;/em&gt; use them with due caution.</source>
          <target state="translated">ただし、 &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;暗黙的にアンラップされたオプションが有益&lt;/a&gt;であるシナリオがいくつかあり、以下にリストされているように安全にアンラップするさまざまな方法を使用できますが、 &lt;em&gt;常に&lt;/em&gt;十分に注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="045cfcd48cc9a7581c9554c6d0db82a58d3a86d5" translate="yes" xml:space="preserve">
          <source>However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because &lt;code&gt;foo&lt;/code&gt; is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods &amp;ndash; or unwrap &lt;code&gt;foo&lt;/code&gt; itself before accessing methods or calling methods that return values.</source>
          <target state="translated">ただし、プロパティにアクセスしたり、値を返すメソッドを呼び出したりしようとすると、状況が少しトリッキーになります。 &lt;code&gt;foo&lt;/code&gt; はオプションなので、そこから返されるものもすべてオプションになります。 これに対処するには、上記のメソッドのいずれかを使用して返されるオプションをアンラップするか、メソッドにアクセスするか、値を返すメソッドを呼び出す前に &lt;code&gt;foo&lt;/code&gt; 自体をアンラップします。</target>
        </trans-unit>
        <trans-unit id="8925a8490bf5fd57f3e11be4c68ec114afe4face" translate="yes" xml:space="preserve">
          <source>I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.</source>
          <target state="translated">テーブルビューコントローラからビューコントローラに移行する際に、メインストーリーボードでビューコントローラのカスタムクラス名を指定するのを忘れていたため、このようなエラーに遭遇しました。</target>
        </trans-unit>
        <trans-unit id="961d19ccc70f1d74e0009e3c081c86736529fa59" translate="yes" xml:space="preserve">
          <source>I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:</source>
          <target state="translated">以下のようにprepare for segueメソッドからOutletsの値を設定しようとしたときに一度だけこのエラーが出ました。</target>
        </trans-unit>
        <trans-unit id="c9821ba4ff1ad0757f5f86a478e8819368f2e4a1" translate="yes" xml:space="preserve">
          <source>I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn't addressed the issue itself directly.</source>
          <target state="translated">私はこの答えが同じ問題でそこに誰かを助けることを願っています私はマークされた答えは、オプションとどのように動作するかを理解するための偉大なリソースであることがわかりましたが、問題自体に直接対処していませんでした。</target>
        </trans-unit>
        <trans-unit id="687e27bcc1f747e004946e97f14c1a09937a1708" translate="yes" xml:space="preserve">
          <source>IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, &lt;em&gt;after&lt;/em&gt; initialization. You should therefore ensure that you&amp;rsquo;re not accessing outlets before they're loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be &lt;code&gt;nil&lt;/code&gt; at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.</source>
          <target state="translated">特にIBOutletsは通常、暗黙的にアンラップされたオプションです。 これは、初期化&lt;em&gt;後&lt;/em&gt; 、実行時にxibまたはストーリーボードがアウトレットをリンクするためです。 したがって、コンセントがロードされる前にアウトレットにアクセスしていないことを確認する必要があります。また、ストーリーボード/ xibファイルで接続が正しいことを確認する必要があります。そうでない場合、実行時に値が &lt;code&gt;nil&lt;/code&gt; になるため、暗黙的にクラッシュします包まれていない。 接続を修正するときは、アウトレットを定義するコード行を削除してから、再接続してください。</target>
        </trans-unit>
        <trans-unit id="cbf8b026a781fcaf4a77cedd0a311b396615b39b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;anOptionalInt&lt;/code&gt; contains a value, it will be unwrapped and assigned to the new &lt;code&gt;number&lt;/code&gt; constant. The code &lt;em&gt;after&lt;/em&gt; the guard will then continue executing. If it doesn&amp;rsquo;t contain a value &amp;ndash; the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.</source>
          <target state="translated">&lt;code&gt;anOptionalInt&lt;/code&gt; に値が含まれている場合、その値はラップ解除され、新しい &lt;code&gt;number&lt;/code&gt; 定数に割り当てられます。 ガード&lt;em&gt;後&lt;/em&gt;のコードは実行を継続します。 値が含まれていない場合&amp;ndash;ガードは括弧内のコードを実行します。これにより、制御が移るため、直後のコードは実行されません。</target>
        </trans-unit>
        <trans-unit id="555b9e1b03e3ef819963d13f4ad1e9cd6291d3bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;foo&lt;/code&gt; contains a value, this method will be called on it. If it doesn&amp;rsquo;t, nothing bad will happen &amp;ndash; the code will simply continue executing.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; に値が含まれている場合、このメソッドが呼び出されます。 そうでない場合、問題は何も起こりません。コードは単に実行を継続します。</target>
        </trans-unit>
        <trans-unit id="bfd5e74dcdb489bc0ac5f2ed761961f64038c09a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someThrowingFunc()&lt;/code&gt; throws an error, the error will be safely caught in the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;someThrowingFunc()&lt;/code&gt; がエラーをスローした場合、エラーは安全に &lt;code&gt;catch&lt;/code&gt; ブロックでキャッチされます。</target>
        </trans-unit>
        <trans-unit id="d952b11c89cd854be27de0d0f65ed17e3c578f0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someVariable&lt;/code&gt; is nil, then you'll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you're guaranteeing to the compiler that you'll never have nil values there. And guess what it happens if somehow a nil value ends in in &lt;code&gt;someVariable&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;someVariable&lt;/code&gt; がnilの場合、クラッシュします。 強制アンラップを行うことで、nilチェックの責任をコンパイラーからユーザーに移しました。基本的に強制アンラップを行うことで、コンパイラーにnil値が決してないことを保証します。 そして、どういうわけかnil値が &lt;code&gt;someVariable&lt;/code&gt; で終わっているとどうなるでしょうか？</target>
        </trans-unit>
        <trans-unit id="c01ad95af312c93699d0f265e3b3b0b10e9f23a1" translate="yes" xml:space="preserve">
          <source>If we wanted to call a method on &lt;code&gt;foo&lt;/code&gt; that doesn&amp;rsquo;t return anything, we can simply do:</source>
          <target state="translated">何も返さない &lt;code&gt;foo&lt;/code&gt; のメソッドを呼び出したい場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="78da2ff6a4b5799b4addacf92cf6d2b26fb23cc8" translate="yes" xml:space="preserve">
          <source>If you get this error in CollectionView try to create CustomCell file and Custom xib also.</source>
          <target state="translated">CollectionViewでこのエラーが出た場合は、CustomCellファイルとCustom xibも作成してみてください。</target>
        </trans-unit>
        <trans-unit id="0127a3535a0583ab1a79af7eea2befd762a366e7" translate="yes" xml:space="preserve">
          <source>Implicitly Unwrapped Optionals</source>
          <target state="translated">暗黙的にアンラップされたオプショナル</target>
        </trans-unit>
        <trans-unit id="051898db5718d1ca1229f4edae90fa5baa7e3071" translate="yes" xml:space="preserve">
          <source>Implicitly unwrapped optionals. Let's assume you have the following class definition:</source>
          <target state="translated">暗黙のうちにアンラップされたオプショナル。以下のようなクラス定義があるとしましょう。</target>
        </trans-unit>
        <trans-unit id="484536419577c05bc013ad78ac088dd3099a07ed" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;generic type&lt;/a&gt; that can contain a value (of any kind), or no value at all.</source>
          <target state="translated">Swiftの&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;は、（任意の種類の）値を含むか、まったく値を含まない&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;ジェネリック型&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="79a7dee40b7721bf417ab75a0b14f771e29d4b3d" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;strong&gt;&lt;em&gt;any type&lt;/em&gt; can be made optional&lt;/strong&gt;. An optional value can take on any value from the original type, &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;or&lt;/em&gt;&lt;/a&gt; the special value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Swiftでは、 &lt;strong&gt;&lt;em&gt;どのタイプ&lt;/em&gt;もオプションにすることができます&lt;/strong&gt; 。 オプションの値は、元のタイプの任意の値、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;または&lt;/em&gt;&lt;/a&gt;特別な値 &lt;code&gt;nil&lt;/code&gt; を取ることができます。</target>
        </trans-unit>
        <trans-unit id="04774461a3612ca563f0e36ff0dbf0f0ec4fa74c" translate="yes" xml:space="preserve">
          <source>In many other programming languages, a particular &quot;sentinel&quot; value is often used to indicate a &lt;em&gt;lack of a value&lt;/em&gt;. In Objective-C, for example, &lt;code&gt;nil&lt;/code&gt; (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;null pointer&lt;/a&gt;) indicates the lack of an object. But this gets more tricky when working with primitive types &amp;mdash; should &lt;code&gt;-1&lt;/code&gt; be used to indicate the absence of an integer, or perhaps &lt;code&gt;INT_MIN&lt;/code&gt;, or some other integer? If any particular value is chosen to mean &quot;no integer&quot;, that means it can no longer be treated as a &lt;em&gt;valid&lt;/em&gt; value.</source>
          <target state="translated">他の多くのプログラミング言語では、特定の「センチネル」値が値の&lt;em&gt;欠如&lt;/em&gt;を示すためによく使用され&lt;em&gt;ます&lt;/em&gt; 。 たとえば、Objective-Cでは、 &lt;code&gt;nil&lt;/code&gt; （ &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;nullポインター&lt;/a&gt; ）はオブジェクトがないことを示します。 しかし、プリミティブ型を操作する場合はこれはよりトリッキーになります。整数、またはおそらく &lt;code&gt;INT_MIN&lt;/code&gt; 、またはその他の整数がないことを示すために &lt;code&gt;-1&lt;/code&gt; を使用する必要がありますか？ 特定の値が「整数なし」を意味するように選択された場合、それはもはや&lt;em&gt;有効な&lt;/em&gt;値として扱うことができないことを意味します。</target>
        </trans-unit>
        <trans-unit id="46b85b18ba2133633a4afcab43ae7743b50be6e2" translate="yes" xml:space="preserve">
          <source>In order to access an optional&amp;rsquo;s value (if it has one at all), you need to &lt;strong&gt;unwrap&lt;/strong&gt; it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it &lt;em&gt;didn't&lt;/em&gt; have a value, your program will crash with the above message.</source>
          <target state="translated">オプションの値にアクセスするには（値がある場合）、それを&lt;strong&gt;アンラップ&lt;/strong&gt;する必要があります。 オプションの値は、安全または強制的にラップ解除できます。 オプションを強制アンラップし、それに値&lt;em&gt;がない&lt;/em&gt;場合、プログラムは上記のメッセージでクラッシュします。</target>
        </trans-unit>
        <trans-unit id="2870a2cd345396e3c49f99168c09a7038d33fa6f" translate="yes" xml:space="preserve">
          <source>In order to work out which variable caused the crash, you can hold</source>
          <target state="translated">クラッシュの原因となった変数を調べるには</target>
        </trans-unit>
        <trans-unit id="ee021373ae2b52768be006a0a1a52dc063c5b011" translate="yes" xml:space="preserve">
          <source>In other words, rather use:</source>
          <target state="translated">言い換えれば、むしろ使う。</target>
        </trans-unit>
        <trans-unit id="c40e8f1772cb4a16417b4c1962c3c56e76be0301" translate="yes" xml:space="preserve">
          <source>In that case foo is still an optional, but you don't have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it's nil.</source>
          <target state="translated">この場合、foo はまだオプションですが、参照するためにそれをアンラップする必要はありません。つまり、foo を参照しようとすると、それが nil だとクラッシュするということです。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">代わりに</target>
        </trans-unit>
        <trans-unit id="8bedbb9a541d4d033efb3e04645647ad1c32d4d3" translate="yes" xml:space="preserve">
          <source>It essentially lets you say &amp;ldquo;If &lt;code&gt;a&lt;/code&gt; contains a value, unwrap it. If it doesn&amp;rsquo;t then return &lt;code&gt;b&lt;/code&gt; instead&amp;rdquo;. For example, you could use it like this:</source>
          <target state="translated">基本的に &lt;code&gt;a&lt;/code&gt; 「aに値が含まれている場合は、ラップを解除します。 そうでない場合は、代わりに &lt;code&gt;b&lt;/code&gt; を返します。」 たとえば、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="ad0ef45d1f8d084087d25064193cc17d964245ca" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s just shorthand for:</source>
          <target state="translated">これは以下の略記です：</target>
        </trans-unit>
        <trans-unit id="459fe8274d538afa06b4cd892cfc12fa3846a208" translate="yes" xml:space="preserve">
          <source>Learn how to debug an iOS app crash</source>
          <target state="translated">iOSアプリのクラッシュをデバッグする方法を学ぶ</target>
        </trans-unit>
        <trans-unit id="aaee9b9adb35ca322a119d776bbbe533b4d1fb20" translate="yes" xml:space="preserve">
          <source>Long story short by using &lt;code&gt;var address : Address!&lt;/code&gt; you're &lt;strong&gt;hiding&lt;/strong&gt; the possibility that a variable can be &lt;code&gt;nil&lt;/code&gt; from other readers. And when it crashes you're like &quot;what the hell?! my &lt;code&gt;address&lt;/code&gt; isn't an optional, so why am I crashing?!.</source>
          <target state="translated">&lt;code&gt;var address : Address!&lt;/code&gt; 変数が他のリーダーから &lt;code&gt;nil&lt;/code&gt; になる可能性を&lt;strong&gt;隠してい&lt;/strong&gt;ます。 そして、それがクラッシュするとき、あなたは「一体何なんだ!!私の &lt;code&gt;address&lt;/code&gt; はオプションではないので、なぜ私はクラッシュするのか？！</target>
        </trans-unit>
        <trans-unit id="78cef24b9706680cc584904b5e88b79801d759b5" translate="yes" xml:space="preserve">
          <source>Most of the time you will use the complete Do-Try-Catch system - and the optional one, &lt;code&gt;try?&lt;/code&gt;, in the rare cases where handling the error is not important.</source>
          <target state="translated">ほとんどの場合、完全なDo-Try-Catchシステムとオプションのシステムを使用し &lt;code&gt;try?&lt;/code&gt; 、エラーの処理が重要ではないまれなケース。</target>
        </trans-unit>
        <trans-unit id="35e9fc497ab02ab074e552f7be54dc7f776c210a" translate="yes" xml:space="preserve">
          <source>My Swift program is crashing with &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and one of the following similar errors. What does this error mean, and how do I fix it?</source>
          <target state="translated">私のSwiftプログラムは、 &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; と次の類似したエラーのいずれかでクラッシュします。 このエラーはどういう意味ですか、どうすれば修正できますか？</target>
        </trans-unit>
        <trans-unit id="56a078777cdf9213e116547d03f394624b748e2b" translate="yes" xml:space="preserve">
          <source>Nil Coalescing Operator</source>
          <target state="translated">ニル 合体オペレータ</target>
        </trans-unit>
        <trans-unit id="9b06cd01bf313f728f850e8f6dfbc9e6120741e5" translate="yes" xml:space="preserve">
          <source>Note that the variable you define when you use optional biding only exists (is only &quot;in scope&quot;) in the body of the if statement.</source>
          <target state="translated">オプションのバイディングを使用する際に定義した変数は、if文の本文にしか存在しない(&quot;スコープ内 &quot;にしか存在しない)ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4c10eb68d56cba105bdf477429d00aea854d4ccd" translate="yes" xml:space="preserve">
          <source>Now if no nullability annotations are specified (either explicitly or via &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt;/&lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;), then the &lt;code&gt;name&lt;/code&gt; property will be imported in Swift as &lt;code&gt;String!&lt;/code&gt; (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if &lt;code&gt;name&lt;/code&gt; is nil.</source>
          <target state="translated">&lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; 可能性の注釈が指定されていない場合（明示的に、またはNS_ASSUME_NONNULL_BEGIN / &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt; を介して）、 &lt;code&gt;name&lt;/code&gt; プロパティはSwiftに &lt;code&gt;String!&lt;/code&gt; としてインポートされます！ （IUO-暗黙的にアンラップされたオプション）。 一部の迅速なコードが値を使用するようになるとすぐに、 &lt;code&gt;name&lt;/code&gt; がnilの場合はクラッシュします。</target>
        </trans-unit>
        <trans-unit id="16ffd92502b92b7dab0de459501aee70aad84527" translate="yes" xml:space="preserve">
          <source>Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you'll want to use the outlet.
Solution? Make sure all outlets are connected. Or use the &lt;code&gt;?&lt;/code&gt; operator on them: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.</source>
          <target state="translated">ここで、XIBエディターからのコンセントの接続を忘れた場合、そのコンセントを使用するようになるとすぐにアプリがクラッシュします。 解決？ すべてのコンセントが接続されていることを確認してください。 または &lt;code&gt;?&lt;/code&gt; それらの演算子： &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt; 。 または、アウトレットをオプションとして宣言します。ただし、この場合、コンパイラーはコード全体でアンラップするように強制します。</target>
        </trans-unit>
        <trans-unit id="f75a096d58dde4b74701e26c90ea72ae64747b35" translate="yes" xml:space="preserve">
          <source>Now, if no-one messes up with the &lt;code&gt;name&lt;/code&gt; property by setting it to &lt;code&gt;nil&lt;/code&gt;, then it works as expected, however if &lt;code&gt;User&lt;/code&gt; is initialized from a JSON that lacks the &lt;code&gt;name&lt;/code&gt; key, then you get the fatal error when trying to use the property.</source>
          <target state="translated">これで、誰も &lt;code&gt;name&lt;/code&gt; プロパティを &lt;code&gt;nil&lt;/code&gt; に設定してごちゃごちゃにしないと、期待どおりに機能し &lt;code&gt;User&lt;/code&gt; が、 Userが &lt;code&gt;name&lt;/code&gt; キーのないJSONから初期化されると、プロパティを使用しようとすると致命的なエラーが発生します。 。</target>
        </trans-unit>
        <trans-unit id="936cf8bab3f747e065f42e3415906001fcaec17a" translate="yes" xml:space="preserve">
          <source>One other way, if you don't want to check the variable state before your implementation, you can also use &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; instead.</source>
          <target state="translated">別の方法として、実装前に変数の状態を確認したくない場合は、 &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; 使用することもできます。 代わりに「buildingName」 。</target>
        </trans-unit>
        <trans-unit id="4a3f188326fc444bc42e44fa25a0acf6b3ccac81" translate="yes" xml:space="preserve">
          <source>Optional Binding</source>
          <target state="translated">オプションのバインディング</target>
        </trans-unit>
        <trans-unit id="7a826a948d8f9ecc960c32ca6f545004bbd4247e" translate="yes" xml:space="preserve">
          <source>Optional Binding allows you to check if an optional contains a value &amp;ndash; and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; or &lt;code&gt;if var x = anOptional {...}&lt;/code&gt;, depending if you need to modify the value of the new variable after binding it.</source>
          <target state="translated">オプションのバインドを使用すると、オプションに値が含まれているかどうかを確認でき、ラップされていない値を新しい変数または定数に割り当てることができます。 バインド後に新しい変数の値を変更する必要があるかどうかに応じて &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; または &lt;code&gt;if var x = anOptional {...}&lt;/code&gt; の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">オプションのチェイニング</target>
        </trans-unit>
        <trans-unit id="1661a949efe8ce7e832a8022541343bb817a5148" translate="yes" xml:space="preserve">
          <source>Optionals are defined with a &lt;code&gt;?&lt;/code&gt; suffix on the type:</source>
          <target state="translated">オプションは &lt;code&gt;?&lt;/code&gt; タイプのサフィックス：</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">あるいはこんな感じで。</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="54833e81302d6311cef1a28ed09adc3690301a62" translate="yes" xml:space="preserve">
          <source>Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.</source>
          <target state="translated">次に、オプション値には2つのステータスがあることを知っておく必要があります。1つは完全な値で、もう1つはnil値です。ですから、オプション値を実装する前に、それがどちらの状態であるかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="03c6c8c8bdb83cd4b0856641a961cecbc0c85b85" translate="yes" xml:space="preserve">
          <source>Since the above answers clearly explains how to play safely with Optionals.
I will try explain what Optionals are really in swift.</source>
          <target state="translated">上記の回答では、オプショナルを安全にプレイする方法が明確に説明されているので、ここではオプショナルとは何かを説明してみます。ここでは、スイフトにおけるOptionalとは何かを説明してみたいと思います。</target>
        </trans-unit>
        <trans-unit id="dad624a90b7df3a23e5bb578feeeabdd12ee8888" translate="yes" xml:space="preserve">
          <source>So I solved it this way:</source>
          <target state="translated">ということで、このように解いてみました。</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">だからこのコードは</target>
        </trans-unit>
        <trans-unit id="afb1b762e29712aa3b112a22ea2e06690f91025a" translate="yes" xml:space="preserve">
          <source>So to assign a nil to our variable 'i'. We can do 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt;
or to assign a value, we will pass some value 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</source>
          <target state="translated">したがって、変数 'i'にnilを割り当てます。 &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt; か、値を割り当てるには、いくつかの値を渡します &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a43ac01380800da0acd970a8b899fd1a1eb60e8" translate="yes" xml:space="preserve">
          <source>So you could use code like this:</source>
          <target state="translated">だから、このようなコードを使うことができます。</target>
        </trans-unit>
        <trans-unit id="b04e4285f916f64b8ec1d071584592d993d42c35" translate="yes" xml:space="preserve">
          <source>So, to use them with an optional binding, you can do this:</source>
          <target state="translated">そこで、オプションのバインディングで使用するには、このようにします。</target>
        </trans-unit>
        <trans-unit id="7547ba07041dcef70d621cc40b5c4a45b8ce5e45" translate="yes" xml:space="preserve">
          <source>Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as &lt;code&gt;nonnull&lt;/code&gt;.</source>
          <target state="translated">解決？ null可能性アノテーションをObjective-Cコードに追加します。 ただし、Objective-Cコンパイラーは、 &lt;code&gt;nonnull&lt;/code&gt; 可能性に関しては少し寛容です。明示的にnonnullとしてマークしたとしても、nil値になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="52e5455e8973ef67576894c1d0ab773692ab9e50" translate="yes" xml:space="preserve">
          <source>Solution? Don't use them :) Unless you're 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property</source>
          <target state="translated">解決策は?使わないでください :)使用する必要がある時までに、そのプロパティが常に非nil値を持つことを102%確信しているのでなければ、使用しないでください。ほとんどの場合、オプショナルまたは非オプショナルに変換しても問題ありません。また、非オプションにすることで、そのプロパティに値を与えなかったことをコード・パスに伝えることで、コンパイラが助けてくれることになります。</target>
        </trans-unit>
        <trans-unit id="dbbb73b74bb82fd31f9eda3643a242450fdeebf5" translate="yes" xml:space="preserve">
          <source>Solution? Use optional binding (aka if-let), do the variable processing there:</source>
          <target state="translated">解決策は?オプションのバインディング(別名if-let)を使用し、そこで変数の処理を行います。</target>
        </trans-unit>
        <trans-unit id="f6514760b09d36bf6238bb6b2eecdafcf283abf2" translate="yes" xml:space="preserve">
          <source>Something simple that is worth checking if all else looks ok</source>
          <target state="translated">他のすべてが大丈夫そうであれば、チェックする価値がある簡単なもの</target>
        </trans-unit>
        <trans-unit id="d9bf36cacd5682e9de59257e72eab5c7866cf9e7" translate="yes" xml:space="preserve">
          <source>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake.</source>
          <target state="translated">Swiftは型安全な言語であり、コードで使用できる値の型を明確にするのに役立ちます。コードの一部が String を期待している場合、型安全性により、誤って Int を渡すことを防ぎます。</target>
        </trans-unit>
        <trans-unit id="0191ce146a46db014aa0959a5ad6aab2ad0a906a" translate="yes" xml:space="preserve">
          <source>Swift optionals let you set up a variable of any type to contain either a valid value, or no value.</source>
          <target state="translated">Swiftのオプションでは、有効な値を含むか、値を含まないかのいずれかを含むように、任意の型の変数を設定することができます。</target>
        </trans-unit>
        <trans-unit id="9f50948ddb6a9405af006b565688093e07e7df89" translate="yes" xml:space="preserve">
          <source>Swift uses the concept of &quot;Optionals&quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.</source>
          <target state="translated">Swiftでは、値を含むことができる値、または含まない値を扱うために「Optional」の概念を使用しています。C言語のような他の言語では、値を含まないことを示すために0の値を変数に格納することがあります。しかし、0 が有効な値であった場合はどうでしょうか?また、-1 が有効な値だったら?といった具合です。</target>
        </trans-unit>
        <trans-unit id="8733a9d6eaaff2ad81a4c469105c4f2aa8f27191" translate="yes" xml:space="preserve">
          <source>Swift's error handling system can be safely used with &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;:</source>
          <target state="translated">Swiftのエラー処理システムは、 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;で安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="aab6e4d9938362d2634e37c6d271130b036be9f7" translate="yes" xml:space="preserve">
          <source>TL;DR answer</source>
          <target state="translated">TL;DRの答え</target>
        </trans-unit>
        <trans-unit id="5910011e369d233145df2614ffbb9258f70e2bc9" translate="yes" xml:space="preserve">
          <source>The &quot;!&quot; operator is a &quot;force unwrap&quot; operator. It says &quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.&quot; If you are wrong, you crash.</source>
          <target state="translated">&quot;!&quot;演算子は「強制的に解きほぐす」演算子です。これは「私を信じてください。何をしているか分かっています。このコードが実行されたとき、変数にnilが含まれないことを保証します。&quot; 間違っていたらクラッシュします。</target>
        </trans-unit>
        <trans-unit id="cc8497513f48b57bcdbd220d3e716cb1d4a6b09b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; is a nifty shorthand version of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;ternary conditional operator&lt;/a&gt;, primarily designed to convert optionals to non-optionals. It has the syntax &lt;code&gt;a ?? b&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an optional type and &lt;code&gt;b&lt;/code&gt; is the same type as &lt;code&gt;a&lt;/code&gt; (although usually non-optional).</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing演算子&lt;/a&gt;は、 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;三項条件演算子の&lt;/a&gt;気の利いた簡略版であり、主にオプションを非オプションに変換するように設計されています。 構文 &lt;code&gt;a ?? b&lt;/code&gt; b 、ここで &lt;code&gt;a&lt;/code&gt; はオプションのタイプであり、 &lt;code&gt;b&lt;/code&gt; はaと同じタイプです（ただし、通常はオプションではありません）。</target>
        </trans-unit>
        <trans-unit id="4f39a8383e521eac4930320b3f781463d412042a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; constant you see in the &lt;code&gt;catch&lt;/code&gt; block has not been declared by us - it's automatically generated by &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; ブロックに表示される &lt;code&gt;error&lt;/code&gt; 定数は、私たちによって宣言されていません-これは &lt;code&gt;catch&lt;/code&gt; によって自動的に生成されます。</target>
        </trans-unit>
        <trans-unit id="cd0c0cb00ef66003262f22de70ce81e5de3dbebd" translate="yes" xml:space="preserve">
          <source>The concepts explained in this post also apply here: if an error is thrown, the application will crash.</source>
          <target state="translated">この記事で説明した概念はここでも適用されます:エラーがスローされると、アプリケーションはクラッシュします。</target>
        </trans-unit>
        <trans-unit id="cc4353dc8328b849dd5eee0ba9343f34b63353af" translate="yes" xml:space="preserve">
          <source>The errors &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; appears the most when you have declared an &lt;code&gt;@IBOutlet&lt;/code&gt;, but not connected to the &lt;strong&gt;storyboard&lt;/strong&gt;.</source>
          <target state="translated">エラー &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; および &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; が検出されたのは、 &lt;code&gt;@IBOutlet&lt;/code&gt; を宣言したが、 &lt;strong&gt;ストーリーボードに&lt;/strong&gt;接続していない場合に最も多く表示されます。</target>
        </trans-unit>
        <trans-unit id="f944bc0d51db4c42e0ab501ffaf2c9361c58f7c9" translate="yes" xml:space="preserve">
          <source>The full code would be :</source>
          <target state="translated">フルコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="39947ad748876c5ade4da078e8c8623048e5ffc6" translate="yes" xml:space="preserve">
          <source>The full code would be:</source>
          <target state="translated">フルコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="49a1afbffea19fea31c8bef0f4563791d58a8dc2" translate="yes" xml:space="preserve">
          <source>The lack of a value in an optional is indicated by &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">オプションに値がないことは &lt;code&gt;nil&lt;/code&gt; で示されます。</target>
        </trans-unit>
        <trans-unit id="37d4ab0d4c249a69f4593634c7af51c35f6f73fc" translate="yes" xml:space="preserve">
          <source>The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a &lt;em&gt;guard statement&lt;/em&gt;.</source>
          <target state="translated">ifステートメント内でオプションのバインディングを使用する唯一の問題は、ステートメントのスコープ内からのみラップされていない値にアクセスできることです。 ステートメントのスコープ外から値にアクセスする必要がある場合は、 &lt;em&gt;ガードステートメントを&lt;/em&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="77a167b0cfc56774bff7d7b752b55f5f670e549d" translate="yes" xml:space="preserve">
          <source>The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can &lt;em&gt;only&lt;/em&gt; execute if the optional has a value). This is a great for eliminating &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;&amp;lsquo;pyramids of doom&amp;rsquo;&lt;/a&gt; created by nesting multiple if statements.</source>
          <target state="translated">ガードステートメントの本当の利点は、ラップされていない値がステートメントに続くコードで使用できるようになったことです（将来のコードはオプションが値を持つ場合に&lt;em&gt;のみ&lt;/em&gt;実行できることがわかっているため）。 これは、複数のifステートメントをネストすることによって作成された&lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;「運命のピラミッド」&lt;/a&gt;を排除するのに最適です。</target>
        </trans-unit>
        <trans-unit id="f70e19cc299904e989d46111669248e2d6297b5a" translate="yes" xml:space="preserve">
          <source>The simplest way to check whether an optional contains a value, is to compare it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">オプションに値が含まれているかどうかを確認する最も簡単な方法は、 &lt;code&gt;nil&lt;/code&gt; と比較することです。</target>
        </trans-unit>
        <trans-unit id="2ad7c64f5b093e808ba67d8a73670ba71bd4ebd5" translate="yes" xml:space="preserve">
          <source>Then I found out that I can't set the values of the destination controller outlets because the controller hasn't been loaded or initialized yet.</source>
          <target state="translated">そうしたら、コントローラがまだロードされていなかったり、初期化されていなかったりして、デスティネーションコントローラのアウトレットの値を設定できないことがわかりました。</target>
        </trans-unit>
        <trans-unit id="1ec67f9dd2cfab174b6b515c3d0d4747bf7293ec" translate="yes" xml:space="preserve">
          <source>There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)</source>
          <target state="translated">他にも、より安全なオプションを扱う方法はたくさんあります。以下にいくつかの方法を紹介します (網羅的なリストではありません)。</target>
        </trans-unit>
        <trans-unit id="0d60f2d11c0f746729eec725020f1feabe53897f" translate="yes" xml:space="preserve">
          <source>There are several scenarios that lead to this kind of fatal error:</source>
          <target state="translated">このような致命的なエラーにつながるシナリオがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="3cc4935148dd3d0a4d88768551d67d938c2ebaf2" translate="yes" xml:space="preserve">
          <source>There is also a construct called the &quot;nil coalescing operator&quot;. It takes the form &quot;optional_var ?? replacement_val&quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the &quot;??&quot; symbol.</source>
          <target state="translated">また、&quot;nil合体演算子 &quot;と呼ばれる構文もあります。これは &quot;optional_var ? replacement_val&quot; という形式をとります。これは、optionalに含まれるデータと同じ型の非optional変数を返します。optional に nil が含まれている場合は、&quot;?&quot; 記号の後の式の値を返します。</target>
        </trans-unit>
        <trans-unit id="b6b6bf923d0fa956d7f5415f78e183319a28b7b6" translate="yes" xml:space="preserve">
          <source>There's also &lt;code&gt;try?&lt;/code&gt; which absorbs the error:</source>
          <target state="translated">&lt;code&gt;try?&lt;/code&gt; もありますか？ エラーを吸収します：</target>
        </trans-unit>
        <trans-unit id="051cef13b0cd111883df939c5644ba59bbe86947" translate="yes" xml:space="preserve">
          <source>These are defined with  a &lt;code&gt;!&lt;/code&gt;, rather than a &lt;code&gt;?&lt;/code&gt; after the type.</source>
          <target state="translated">これらは &lt;code&gt;!&lt;/code&gt; ではなく、 タイプの後。</target>
        </trans-unit>
        <trans-unit id="228d647e0bd3a874c5246256241ffafbe0dae63f" translate="yes" xml:space="preserve">
          <source>These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesn&amp;rsquo;t contain a value, it will crash.</source>
          <target state="translated">これらのオプションには値が含まれていると想定されます。 したがって、暗黙的にアンラップされたオプションにアクセスすると、自動的に強制的にアンラップされます。 値が含まれていない場合、クラッシュします。</target>
        </trans-unit>
        <trans-unit id="03d3193f66062a0894aa6946a0e2b6f22b829634" translate="yes" xml:space="preserve">
          <source>These variables are designed so that you can defer their assignment until later in your code. It is &lt;em&gt;your&lt;/em&gt; responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe &amp;ndash; as they &lt;em&gt;assume&lt;/em&gt; your value is non-nil, even though assigning nil is valid.</source>
          <target state="translated">これらの変数は、コードの後半までそれらの割り当てを延期できるように設計されています。 あなたがそれらにアクセスする前にそれらが価値を持っていることを確認するのは&lt;em&gt;あなたの&lt;/em&gt;責任です。 ただし、強制アンラップが含まれるため、nilの割り当てが有効であっても、値が非nilである&lt;em&gt;と想定し&lt;/em&gt;ている&lt;em&gt;ため&lt;/em&gt; 、本質的に安全ではありません。</target>
        </trans-unit>
        <trans-unit id="e2a9aff700fd23b1fa64684c86c11f3e64379b3e" translate="yes" xml:space="preserve">
          <source>Think of the following code: 
It compiles with no errors/warnings:</source>
          <target state="translated">以下のコードを考えてみてください。これはエラー警告なしでコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="09d8ef10eee293feb35c82626771fa027ffe930b" translate="yes" xml:space="preserve">
          <source>This answer was intended to be concise, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;for full comprehension read accepted answer&lt;/a&gt;</source>
          <target state="translated">この回答は簡潔にすることを目的としており、 &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;完全に理解&lt;/a&gt;できるように、回答は承認されました。</target>
        </trans-unit>
        <trans-unit id="518b372f5b167794f9cb85ed9cffe42f1420058a" translate="yes" xml:space="preserve">
          <source>This can therefore also be used to set properties as well as call methods. For example:</source>
          <target state="translated">そのため、これはメソッドの呼び出しだけでなく、プロパティの設定にも使用できます。例えば</target>
        </trans-unit>
        <trans-unit id="8a756f40b006c215a6765390c6966fd17d773cb9" translate="yes" xml:space="preserve">
          <source>This crash can occur with two different kinds of force-unwrap:</source>
          <target state="translated">このクラッシュは、2種類の異なるフォースアンラップで発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8f0250df27448e385747e9a13ccb5651fe27b21d" translate="yes" xml:space="preserve">
          <source>This is done with the &lt;code&gt;!&lt;/code&gt; operator on an optional. For example:</source>
          <target state="translated">これは &lt;code&gt;!&lt;/code&gt; オプションの演算子。 例えば：</target>
        </trans-unit>
        <trans-unit id="e414f3b50562e4d895870d8df98dbad24cb92fae" translate="yes" xml:space="preserve">
          <source>This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">これはより重要なコメントであり、 &lt;code&gt;nil&lt;/code&gt; 値のデバッグに関しては、暗黙的にアンラップされたオプションが誤っている可能性がある理由です。</target>
        </trans-unit>
        <trans-unit id="0cb38c500378f3659b7d36d8d3cb7a2ed2377409" translate="yes" xml:space="preserve">
          <source>This question comes up &lt;strong&gt;ALL THE TIME&lt;/strong&gt; on SO. It's one of the first things that new Swift developers struggle with.</source>
          <target state="translated">この質問は&lt;strong&gt;いつでも&lt;/strong&gt;出てきます。 これは、新しいSwift開発者が最初に苦労することの1つです。</target>
        </trans-unit>
        <trans-unit id="fe5ac8dc15cee70308d149380af17fd09b2dcd0b" translate="yes" xml:space="preserve">
          <source>This time the code has been made more clear to you. You can rationalize and think that likely it's the &lt;code&gt;address&lt;/code&gt; parameter that was forcefully unwrapped.</source>
          <target state="translated">今回はコードがより明確になりました。 合理化して、強制的にアンラップされたのは &lt;code&gt;address&lt;/code&gt; パラメータであると考えることができます。</target>
        </trans-unit>
        <trans-unit id="f93b94e3333c14bc5a8e2daea487de2fd080c3a5" translate="yes" xml:space="preserve">
          <source>This will define a &lt;code&gt;number&lt;/code&gt; constant of &lt;code&gt;Int&lt;/code&gt; type, that will either contain the value of &lt;code&gt;anOptionalInt&lt;/code&gt;, if it contains a value, or &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">これは &lt;code&gt;Int&lt;/code&gt; 型の &lt;code&gt;number&lt;/code&gt; 定数を定義し、値が含まれている場合は &lt;code&gt;anOptionalInt&lt;/code&gt; の値が含まれ、そうでない場合は &lt;code&gt;0&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="36079ad7315babb9e3cfd31e04a6700ff9a65fd1" translate="yes" xml:space="preserve">
          <source>Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)</source>
          <target state="translated">このように、暗黙のうちにラップされていないオプショナルには本当に注意したいものです。(そして、オプショナルをしっかりと理解するまでは、完全に避けたほうがいいかもしれません)。</target>
        </trans-unit>
        <trans-unit id="bf4f5d672e4353189b2590d59428129d4a05faa6" translate="yes" xml:space="preserve">
          <source>Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.</source>
          <target state="translated">接続されていない、またはまだ接続されていないコンセント。これはシナリオ#3の特殊なケースです。基本的にはXIBを搭載したクラスを持っていて、それを使用したいとします。</target>
        </trans-unit>
        <trans-unit id="7fbb993222752244a9f031c8c1d545ed152b2357" translate="yes" xml:space="preserve">
          <source>Unless you really &lt;strong&gt;do&lt;/strong&gt; know what you are doing, avoid the &quot;!&quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.</source>
          <target state="translated">あなたが本当にあなたが何をしているかを知らない限り、「！」を避けてください。 アンラップ演算子を強制します。 これはおそらく、Swiftプログラマの初心者にとってクラッシュの最大の原因です。</target>
        </trans-unit>
        <trans-unit id="af66b528b3a5e4db51aa7414b4854d62642ea64a" translate="yes" xml:space="preserve">
          <source>Unwrap optional variable using &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;guard let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; または &lt;code&gt;guard let&lt;/code&gt; を使用してオプション変数をアンラップします</target>
        </trans-unit>
        <trans-unit id="bd4b5387dfce9931cda3017dc45ec2e24c2238c6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try&lt;/code&gt; this way is the proper way to try, catch and handle errors coming from throwing functions.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; this wayを使用することは、関数をスローすることから生じるエラーを試行、キャッチ、および処理する適切な方法です。</target>
        </trans-unit>
        <trans-unit id="da6d8e9893a791f4319490b2d723d4806a84568f" translate="yes" xml:space="preserve">
          <source>Values coming from Objective-C, and that don't have nullability annotations. Let's assume we have the following Objective-C class:</source>
          <target state="translated">Objective-C から来た値で、ヌル可能性アノテーションを持たないもの。以下のような Objective-C クラスがあるとします。</target>
        </trans-unit>
        <trans-unit id="9d11739af047f16216d738c322733a87037f743f" translate="yes" xml:space="preserve">
          <source>What does “Fatal error: Unexpectedly found nil while unwrapping an Optional value” mean</source>
          <target state="translated">Fatal error.オプション値のアンラップ中に予期せず nil が見つかりました。</target>
        </trans-unit>
        <trans-unit id="5e6a210b7a4319c69606343ec4904762d1eff5e8" translate="yes" xml:space="preserve">
          <source>What this does is first check that the optional contains a value. If it &lt;em&gt;does&lt;/em&gt;, then the &amp;lsquo;unwrapped&amp;rsquo; value is assigned to  a new variable (&lt;code&gt;number&lt;/code&gt;) &amp;ndash; which you can then freely use as if it were non-optional. If the optional &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; contain a value, then the else clause will be invoked, as you would expect.</source>
          <target state="translated">これが行うことは、最初にオプションに値が含まれていることを確認することです。 含まれている場合、「ラップされていない」値が新しい変数（ &lt;code&gt;number&lt;/code&gt; ）に割り当てられます。これは、オプションではないかのように自由に使用できます。 オプションに値が含まれて&lt;em&gt;いない&lt;/em&gt;場合、予想どおり、else句が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="10db728e68ab2e61caf6c0b29942fb92bfcc5927" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.</source>
          <target state="translated">オプションのバインディングの優れている点は、複数のオプションを同時にアンラップできることです。 ステートメントをコンマで区切ることができます。 すべてのオプションがアンラップされた場合、ステートメントは成功します。</target>
        </trans-unit>
        <trans-unit id="1373ba269d2cc3b83a01653ae7e2e71286d08529" translate="yes" xml:space="preserve">
          <source>When should I ever force unwrap an Optional?</source>
          <target state="translated">いつまでにオプションを強制的にアンラップする必要がありますか?</target>
        </trans-unit>
        <trans-unit id="317e17e5c488981811996349a91cb8951d0d1759" translate="yes" xml:space="preserve">
          <source>When to use and when not to use implicitly unwrapped optionals</source>
          <target state="translated">暗黙的にラップされていないオプショナルを使用するタイミングと使用しないタイミング</target>
        </trans-unit>
        <trans-unit id="1f3a4ea673b0a5e8dc1d2d64df7cf20d096e7fe0" translate="yes" xml:space="preserve">
          <source>Whether you use an if or guard statement completely depends on whether any future code &lt;em&gt;requires&lt;/em&gt; the optional to contain a value.</source>
          <target state="translated">ifステートメントまたはguardステートメントを使用するかどうかは、将来のコードに値を含める&lt;em&gt;ため&lt;/em&gt;のオプション&lt;em&gt;が必要&lt;/em&gt;かどうかに完全に依存します。</target>
        </trans-unit>
        <trans-unit id="c54b591d9a12bd724553adb14722d899feefcb1f" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;may&lt;/em&gt; be an occasion where you can use force unwrapping, as you know for a &lt;em&gt;fact&lt;/em&gt; that an optional contains a value &amp;ndash; there is not a &lt;em&gt;single&lt;/em&gt; place where you cannot safely unwrap that optional instead.</source>
          <target state="translated">オプションに値が含まれているという&lt;em&gt;事実&lt;/em&gt;からわかるように、強制アンラップを使用できる場合もありますが、そのオプションを安全にアンラップできない場所は&lt;em&gt;1&lt;/em&gt;つではありません。</target>
        </trans-unit>
        <trans-unit id="87bd0f61bb6e6865c8ad7d95e74d3227791bcb36" translate="yes" xml:space="preserve">
          <source>Why did I get &amp;ldquo;&lt;em&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;&amp;rdquo;?</source>
          <target state="translated">なぜ「 &lt;em&gt;致命的なエラー：オプション値のラップ解除中に予期せずnilが検出された&lt;/em&gt; 」のですか？</target>
        </trans-unit>
        <trans-unit id="4ed62fc8759885174a5e1c44082b865686115a7c" translate="yes" xml:space="preserve">
          <source>Will crash on reference to foo's capitalizedString property even though we're not force-unwrapping foo. the print looks fine, but it's not.</source>
          <target state="translated">foo を強制的にアンラップしていないのに、foo の capitalizedString プロパティを参照するとクラッシュします。</target>
        </trans-unit>
        <trans-unit id="e425b6ac11a3cf5713fb75b070bc494a5c64679e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;very few exceptions&lt;/a&gt;, this rule is golden:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;非常に少数の例外を除いて&lt;/a&gt; 、このルールはゴールデンです。</target>
        </trans-unit>
        <trans-unit id="c496ef8337514f41cb37fdccdcb7d50ad577dff9" translate="yes" xml:space="preserve">
          <source>Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.</source>
          <target state="translated">Xcodeはコードの一行をハイライトしてクラッシュを表示してくれます。問題はこの行で発生しています。</target>
        </trans-unit>
        <trans-unit id="839c55483e3111c1ca07f84d7891a2c9b7b1beae" translate="yes" xml:space="preserve">
          <source>Yet at runtime it gives the following error: &lt;em&gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;</source>
          <target state="translated">それでも実行時に次のエラーが発生します： &lt;em&gt;致命的なエラー：オプション値のラップ解除中に予期せずnilが見つかりました&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e9ce0757b971a4c196d317850c0dbdf450d7e30" translate="yes" xml:space="preserve">
          <source>You can also declare &lt;code&gt;error&lt;/code&gt; yourself, it has the advantage of being able to cast it to a useful format, for example:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 自分で宣言することもできます。たとえば、次のように、 エラーを有用な形式にキャストできるという利点があります。</target>
        </trans-unit>
        <trans-unit id="1350d18d0403c656c2c06ac9d6b05eba79938d9b" translate="yes" xml:space="preserve">
          <source>You can use &quot;optional binding&quot; or &quot;if let&quot; to say &quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement&quot;.</source>
          <target state="translated">&quot;optional binding&quot; や &quot;if let&quot; を使用して、「このオプションに値が含まれている場合は、その値をオプションではない新しい変数に保存します。オプションに値が含まれていない場合は、この if 文の本文をスキップします。</target>
        </trans-unit>
        <trans-unit id="5d1b249ef279beb59a5d567f45b0c019278cedef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;Optional Chaining&lt;/a&gt; in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a &lt;code&gt;?&lt;/code&gt; when using it.</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;オプションのチェーン&lt;/a&gt;を使用して、メソッドを呼び出したり、オプションのプロパティにアクセスしたりできます。 これは、変数名の末尾に &lt;code&gt;?&lt;/code&gt; それを使用するとき。</target>
        </trans-unit>
        <trans-unit id="aaff60ab9a0fe1d4638638d4410b990a62bde2cf" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;if let ...&lt;/code&gt; or &lt;code&gt;guard let ... else&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;code&gt;if let ...&lt;/code&gt; または &lt;code&gt;guard let ... else&lt;/code&gt; 場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="5d9ba10c8d2d8d6b1b597f11d55cc435237669ae" translate="yes" xml:space="preserve">
          <source>You can't!</source>
          <target state="translated">無理だ!</target>
        </trans-unit>
        <trans-unit id="6ec1cc83396860fe0f710055f9d7e89e1c8bc165" translate="yes" xml:space="preserve">
          <source>You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.</source>
          <target state="translated">また、トライキャッチやガードエラー処理を使うこともできますが、一般的には上記の他のテクニックのいずれかの方がクリーンです。</target>
        </trans-unit>
        <trans-unit id="c4dc5e8cd9f1e69573167fc61cd53e581b19c500" translate="yes" xml:space="preserve">
          <source>You put a question mark after the type when you declare a variable to mean (type x, or no value).</source>
          <target state="translated">変数を宣言する際に、型の後にクエスチョンマークを付けます。</target>
        </trans-unit>
        <trans-unit id="bf8513637bc93a619e697f6a9595807f32954dc5" translate="yes" xml:space="preserve">
          <source>You should also learn about how &lt;strong&gt;Optionals&lt;/strong&gt; work, mentioned in other answers, but this is the only time that mostly appears to me.</source>
          <target state="translated">他の回答で言及されているように、 &lt;strong&gt;オプションが&lt;/strong&gt;どのように機能するかについても学ぶ必要がありますが、これはほとんど私に見える唯一の時間です。</target>
        </trans-unit>
        <trans-unit id="af1087f6530251ae6d010a9f21750da1ea79e979" translate="yes" xml:space="preserve">
          <source>You should only be using implicitly unwrapped optionals as a &lt;em&gt;last resort&lt;/em&gt;. If you can use a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;lazy variable&lt;/a&gt;, or provide a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;default value&lt;/a&gt; for a variable &amp;ndash; you should do so instead of using an implicitly unwrapped optional.</source>
          <target state="translated">&lt;em&gt;最後の手段&lt;/em&gt;として、暗黙的にアンラップされたオプションを使用する必要があります。 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;遅延変数&lt;/a&gt;を使用できる場合、または変数の&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;デフォルト値&lt;/a&gt;を提供できる場合&amp;ndash;暗黙的にラップされていないオプションを使用する代わりに、そうする必要があります。</target>
        </trans-unit>
        <trans-unit id="94f331b5b5c0ba72a4cfb9cf99bdd31fd6ae82d0" translate="yes" xml:space="preserve">
          <source>add this code in ViewDidLoad() at mainVC.</source>
          <target state="translated">このコードをmainVCのViewDidLoad()に追加します。</target>
        </trans-unit>
        <trans-unit id="7f66728a6d981314d1e4ec43c0a4f6c970120d38" translate="yes" xml:space="preserve">
          <source>forced (down)casts:</source>
          <target state="translated">強制的な</target>
        </trans-unit>
        <trans-unit id="fad23c2241f2181a2dba20635bf0879e56728e33" translate="yes" xml:space="preserve">
          <source>forced unwraps:</source>
          <target state="translated">強制解禁。</target>
        </trans-unit>
        <trans-unit id="958603fb1a0a0dac8fad299a6be3fb83ef2ce3f9" translate="yes" xml:space="preserve">
          <source>while clicking to show the definition, where you might find the optional type.</source>
          <target state="translated">をクリックして定義を表示している間に、オプションの型を見つけることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="4e8e6ff2989841893307b09e3c62d4b5ade13d31" translate="yes" xml:space="preserve">
          <source>⌥</source>
          <target state="translated">⌥</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
