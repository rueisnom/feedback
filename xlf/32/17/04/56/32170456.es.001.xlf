<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/32170456">
    <body>
      <group id="32170456">
        <trans-unit id="d3a244fb54042f2dbf42e3fe5fb600311a47bd44" translate="yes" xml:space="preserve">
          <source>1. Explicit Force Unwrapping</source>
          <target state="translated">1.Desenvolvimiento de la fuerza explícita</target>
        </trans-unit>
        <trans-unit id="635c6e54ef549bf1619585c9acdb06d314adaf23" translate="yes" xml:space="preserve">
          <source>2. Implicitly Unwrapped Optionals</source>
          <target state="translated">2.Opcionales implícitamente desenvueltos</target>
        </trans-unit>
        <trans-unit id="18d21910bcbc1da8e1aa11e251dedd0b06352cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; has a single method called &lt;code&gt;init(nilLiteral:)&lt;/code&gt; which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with &lt;code&gt;nil&lt;/code&gt; literal.</source>
          <target state="translated">&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; tiene un m&amp;eacute;todo &amp;uacute;nico llamado &lt;code&gt;init(nilLiteral:)&lt;/code&gt; que inicializa una instancia con nil. Por lo general, no llamar&amp;aacute; a este m&amp;eacute;todo y, seg&amp;uacute;n la documentaci&amp;oacute;n r&amp;aacute;pida, se desaconseja llamar a este inicializador directamente, ya que el compilador lo llama cada vez que inicializa un tipo Opcional con literal &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9772727897bd3ca247cb46b7f9cb451241ee24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works similarly to &lt;code&gt;map&lt;/code&gt;, except it allows you to return &lt;em&gt;another&lt;/em&gt; optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; funciona de manera similar al &lt;code&gt;map&lt;/code&gt; a , excepto que le permite devolver &lt;em&gt;otro&lt;/em&gt; opcional desde el cuerpo del cierre. Esto significa que puede ingresar un opcional en un proceso que requiere una entrada no opcional, pero puede generar un opcional en s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="25b1070a11e663243cc897c90af46f99c6df445c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; a y &lt;code&gt;flatMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c46dee75d89e56932987294e4ff7e4232b363930" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You should only ever use &lt;code&gt;try!&lt;/code&gt; if you can prove that its result will never fail in your context - and this is very rare.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iexcl;Solo debes usar &lt;code&gt;try!&lt;/code&gt; &lt;/em&gt; &lt;em&gt;si puede probar que su resultado nunca fallar&amp;aacute; en su contexto, y esto es muy raro.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b7730d90c9b2349ff66ee31e8785e67ba52fb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you now tell me which object it is that was &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Puedes decirme qu&amp;eacute; objeto es que fue &lt;code&gt;nil&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37a5bcf391e8ccb209c28d5fceb142b218d5b019" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you tell me which object is &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Me puede decir qu&amp;eacute; objeto es &lt;code&gt;nil&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f283be4efc0664716ddd69d9cdc7df0c17dbd693" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that this &lt;code&gt;nil&lt;/code&gt; is not the same as the &lt;code&gt;nil&lt;/code&gt; in Objective-C. In Objective-C, &lt;code&gt;nil&lt;/code&gt; is the absence of a valid &lt;em&gt;object pointer&lt;/em&gt;; in Swift, Optionals are not restricted to objects/reference types. Optional behaves similarly to Haskell's &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Maybe&lt;/a&gt;.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Tenga en cuenta que este valor &lt;code&gt;nil&lt;/code&gt; no es igual al &lt;code&gt;nil&lt;/code&gt; en Objective-C. En Objective-C, &lt;code&gt;nil&lt;/code&gt; es la ausencia de un &lt;em&gt;puntero de objeto&lt;/em&gt; v&amp;aacute;lido; en Swift, los opcionales no est&amp;aacute;n restringidos a objetos / tipos de referencia. El comportamiento opcional es similar al de Haskell &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Tal vez&lt;/a&gt; )&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d516eb97f8385312f77ef9000f049aeddc35663f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that within the guard body, you &lt;strong&gt;must&lt;/strong&gt; use one of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;control transfer statements&lt;/a&gt; in order to exit the scope of the currently executing code).&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Tenga en cuenta que dentro del cuerpo de guardia, &lt;strong&gt;debe&lt;/strong&gt; usar una de las &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;declaraciones de transferencia de control&lt;/a&gt; para salir del alcance del c&amp;oacute;digo que se est&amp;aacute; ejecutando actualmente).&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5b87ee6fe147c52e17815abd3b0ac225686bc372" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is because an optional value will return &lt;code&gt;Void?&lt;/code&gt; rather than &lt;code&gt;Void&lt;/code&gt; on a method that doesn&amp;rsquo;t return anything)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Esto se debe a que un valor opcional devolver&amp;aacute; &lt;code&gt;Void?&lt;/code&gt; En lugar de &lt;code&gt;Void&lt;/code&gt; en un m&amp;eacute;todo que no devuelve nada)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8d73db717d8e4390f76c6acdf864843b513507e2" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is similar behaviour to sending messages to &lt;code&gt;nil&lt;/code&gt; in Objective-C)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Este es un comportamiento similar al env&amp;iacute;o de mensajes a &lt;code&gt;nil&lt;/code&gt; en Objective-C)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8404a61e69301e260a8bda1a58f0ce7110e7cc50" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This answer is &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;community wiki&lt;/a&gt;. If you feel it could be made better, feel free to &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit it&lt;/a&gt;!&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Esta respuesta es &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;wiki comunitaria&lt;/a&gt; .&lt;/sup&gt; &lt;sup&gt;Si cree que podr&amp;iacute;a mejorarse, &amp;iexcl; &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;ed&amp;iacute;telo&lt;/a&gt; !&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d92a649ecca38db770e2ea85dae9072443b3c79f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit&lt;/a&gt; the existing wiki answer.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Esta publicaci&amp;oacute;n est&amp;aacute; destinada a recopilar respuestas a problemas &quot;inesperadamente encontrados&quot;, para que no est&amp;eacute;n dispersos y sean dif&amp;iacute;ciles de encontrar.&lt;/sup&gt; &lt;sup&gt;Si&amp;eacute;ntase libre de agregar su propia respuesta o &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;editar&lt;/a&gt; la respuesta wiki existente.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eae132614e41cb087afb2d1c01f40480f4698746" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;guard statement&lt;/a&gt; allows you to define a condition for success &amp;ndash; and the current scope will only continue executing if that condition is met. They are defined with the syntax &lt;code&gt;guard condition else {...}&lt;/code&gt;.</source>
          <target state="translated">Una &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;declaraci&amp;oacute;n de protecci&amp;oacute;n le&lt;/a&gt; permite definir una condici&amp;oacute;n para el &amp;eacute;xito, y el alcance actual solo continuar&amp;aacute; ejecut&amp;aacute;ndose si se cumple esa condici&amp;oacute;n. Se definen con la &lt;code&gt;guard condition else {...}&lt;/code&gt; sintaxis else {...} .</target>
        </trans-unit>
        <trans-unit id="8dd03209df27cf5183ea0c4aad3e184b5a067c77" translate="yes" xml:space="preserve">
          <source>According to swift, 'nil' is the absence of value.
And to create an instance initialized with &lt;code&gt;nil&lt;/code&gt; We have to conform to a protocol called &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and great if you guessed it, only &lt;code&gt;Optionals&lt;/code&gt; conform to &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and conforming to other types is discouraged.</source>
          <target state="translated">Seg&amp;uacute;n swift, 'nulo' es la ausencia de valor. Y para crear una instancia inicializada con &lt;code&gt;nil&lt;/code&gt; Tenemos que cumplir con un protocolo llamado &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; y excelente si lo adivin&amp;oacute;, solo los &lt;code&gt;Optionals&lt;/code&gt; ajustan a &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; y se desaconseja la conformidad con otros tipos.</target>
        </trans-unit>
        <trans-unit id="45073dbf8f3ef81afe07094beb4f6608a541d353" translate="yes" xml:space="preserve">
          <source>Again, because &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are optional, the value returned from &lt;code&gt;qux&lt;/code&gt; will always be an optional regardless of whether &lt;code&gt;qux&lt;/code&gt; itself is optional.</source>
          <target state="translated">Nuevamente, debido a que &lt;code&gt;foo&lt;/code&gt; y &lt;code&gt;baz&lt;/code&gt; son opcionales, el valor devuelto por &lt;code&gt;qux&lt;/code&gt; siempre ser&amp;aacute; opcional, independientemente de si &lt;code&gt;qux&lt;/code&gt; es opcional.</target>
        </trans-unit>
        <trans-unit id="04b74eddaac2e0ff122721a98735cd4f4241cab6" translate="yes" xml:space="preserve">
          <source>Again, nothing bad will happen here if &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Your code will simply continue executing.</source>
          <target state="translated">Nuevamente, nada malo suceder&amp;aacute; aqu&amp;iacute; si &lt;code&gt;foo&lt;/code&gt; es &lt;code&gt;nil&lt;/code&gt; . Su c&amp;oacute;digo simplemente continuar&amp;aacute; ejecut&amp;aacute;ndose.</target>
        </trans-unit>
        <trans-unit id="9e19419202a958c9e2c652dec63d96656df38091" translate="yes" xml:space="preserve">
          <source>Also, as the name suggests, you can &amp;lsquo;chain&amp;rsquo; these statements together. This means that if &lt;code&gt;foo&lt;/code&gt; has an optional property &lt;code&gt;baz&lt;/code&gt;, which has a property &lt;code&gt;qux&lt;/code&gt; &amp;ndash; you could write the following:</source>
          <target state="translated">Adem&amp;aacute;s, como su nombre lo indica, puede 'encadenar' estas declaraciones juntas. Esto significa que si &lt;code&gt;foo&lt;/code&gt; tiene una propiedad opcional &lt;code&gt;baz&lt;/code&gt; , que tiene una propiedad &lt;code&gt;qux&lt;/code&gt; , puede escribir lo siguiente:</target>
        </trans-unit>
        <trans-unit id="3231de44e5b6f036b78301686d6ee18d12703f6b" translate="yes" xml:space="preserve">
          <source>Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:</source>
          <target state="translated">Alternativamente,podrías usar una declaración de guardia,que te permite salir de tu función si la variable es nula:</target>
        </trans-unit>
        <trans-unit id="5df38dfc408955dbdd3d7167930749d99834f562" translate="yes" xml:space="preserve">
          <source>An often underused feature with optionals is the ability to use the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesn&amp;rsquo;t have a value, it will remain &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Una caracter&amp;iacute;stica a menudo infrautilizada con opciones es la capacidad de usar las funciones &lt;code&gt;map&lt;/code&gt; y &lt;code&gt;flatMap&lt;/code&gt; . Estos le permiten aplicar transformaciones no opcionales a variables opcionales. Si un opcional tiene un valor, puede aplicarle una transformaci&amp;oacute;n determinada. Si no tiene un valor, permanecer&amp;aacute; &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7475dbf59ea659fe38624a59d7089f9c937ce515" translate="yes" xml:space="preserve">
          <source>An optional is actually a container than contains either a variable of a given type, or nothing.</source>
          <target state="translated">Un opcional es en realidad un contenedor que contiene una variable de un tipo determinado,o nada.</target>
        </trans-unit>
        <trans-unit id="3c0e7f41650898afdecfa4b26246b1d90eee328c" translate="yes" xml:space="preserve">
          <source>An optional needs to be &quot;unwrapped&quot; in order to fetch the value inside.</source>
          <target state="translated">Un opcional necesita ser &quot;desenvuelto&quot; para poder obtener el valor en el interior.</target>
        </trans-unit>
        <trans-unit id="d26f01d2167b0ccd73f5ca8a245ba70fa537337b" translate="yes" xml:space="preserve">
          <source>And Optional type is nothing but an enumeration with two cases, i.e</source>
          <target state="translated">Y el tipo opcional no es más que una enumeración con dos casos,es decir</target>
        </trans-unit>
        <trans-unit id="0c9267177db8f82598d60f708a0d70d575d72d06" translate="yes" xml:space="preserve">
          <source>Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.</source>
          <target state="translated">Otro truco ingenioso es que también puedes usar comas para comprobar una cierta condición en el valor,después de desenvolverlo.</target>
        </trans-unit>
        <trans-unit id="6ddb885b2b01e4ba63f81165812deb39af75a71c" translate="yes" xml:space="preserve">
          <source>Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Otro buen truco que el encadenamiento opcional le permite hacer es verificar si establecer una propiedad o llamar a un m&amp;eacute;todo fue exitoso. Puede hacer esto comparando el valor de retorno a &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32470d176ca6dd8f034dc5807b14e045ee20d3c6" translate="yes" xml:space="preserve">
          <source>Another way to declare an optional variable is</source>
          <target state="translated">Otra forma de declarar una variable opcional es</target>
        </trans-unit>
        <trans-unit id="443f7eb7f273a4e9c8d9c7fa2251a9bd082d81a0" translate="yes" xml:space="preserve">
          <source>Another, slightly more subtle gotcha with optionals is &quot;implicitly unwrapped optionals. When we declare foo, we could say:</source>
          <target state="translated">Otro,un poco más sutil &quot;gotcha&quot; con opcionales es &quot;opcionales implícitamente desenvueltos&quot;.Cuando declaramos foo,podríamos decir:</target>
        </trans-unit>
        <trans-unit id="52474acee09818b60266e64bb250148f3409b9d7" translate="yes" xml:space="preserve">
          <source>Apple documentation on Swift Optionals</source>
          <target state="translated">Documentación de Apple sobre los opcionales de Swift</target>
        </trans-unit>
        <trans-unit id="515515b53e442d6c0ac9c382069d83edc146839b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;anOptionalString&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; here, you will get a crash on the line where you force unwrap it.</source>
          <target state="translated">Como &lt;code&gt;anOptionalString&lt;/code&gt; es &lt;code&gt;nil&lt;/code&gt; aqu&amp;iacute;, obtendr&amp;aacute; un bloqueo en la l&amp;iacute;nea donde fuerza desenvolverlo.</target>
        </trans-unit>
        <trans-unit id="6401b89cf6e7b504f6a51a78043447e304db2acc" translate="yes" xml:space="preserve">
          <source>As a general rule, you should never explicitly force unwrap an optional with the &lt;code&gt;!&lt;/code&gt; operator. There may be cases where using &lt;code&gt;!&lt;/code&gt; is acceptable &amp;ndash; but you should only ever be using it if you are 100% sure that the optional contains a value.</source>
          <target state="translated">Como regla general, nunca debe forzar expl&amp;iacute;citamente el desenvolvimiento de un opcional con el &lt;code&gt;!&lt;/code&gt; operador. &amp;iexcl;Puede haber casos donde usar &lt;code&gt;!&lt;/code&gt; es aceptable, pero solo deber&amp;iacute;a usarlo si est&amp;aacute; 100% seguro de que lo opcional contiene un valor.</target>
        </trans-unit>
        <trans-unit id="e63c2b6a3158f2d5901a2d116e700ecadd6e8ac7" translate="yes" xml:space="preserve">
          <source>Avoid use of &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">Evite el uso de &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="48ec3975808ef63d21f693479b688b665f317562" translate="yes" xml:space="preserve">
          <source>Background: What&amp;rsquo;s an Optional?</source>
          <target state="translated">Antecedentes: &amp;iquest;Qu&amp;eacute; es un opcional?</target>
        </trans-unit>
        <trans-unit id="000712677e846810968631694b8782eea505d28e" translate="yes" xml:space="preserve">
          <source>Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.</source>
          <target state="translated">Básicamente trataste de usar un valor nulo en los lugares donde Swift sólo permite los que no son nulos,diciéndole al compilador que confiara en ti que nunca habrá un valor nulo allí,permitiendo así que tu aplicación compilara.</target>
        </trans-unit>
        <trans-unit id="6510cebf85c73b91f042a999279b8ecb4a6cfde5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;stringByAppendingString&lt;/code&gt; takes a non-optional string argument, we cannot input our optional string directly. However, by using &lt;code&gt;map&lt;/code&gt;, we can use allow &lt;code&gt;stringByAppendingString&lt;/code&gt; to be used if &lt;code&gt;anOptionalString&lt;/code&gt; has a value.</source>
          <target state="translated">Debido a que &lt;code&gt;stringByAppendingString&lt;/code&gt; toma un argumento de cadena no opcional, no podemos ingresar nuestra cadena opcional directamente. Sin embargo, al usar &lt;code&gt;map&lt;/code&gt; , podemos usar allow &lt;code&gt;stringByAppendingString&lt;/code&gt; para usar si &lt;code&gt;anOptionalString&lt;/code&gt; tiene un valor.</target>
        </trans-unit>
        <trans-unit id="3981488e6abb1cb399b600a4e20bcc5f6c58686a" translate="yes" xml:space="preserve">
          <source>Bottom line: When you are first learning Swift, pretend the &quot;!&quot; character is not part of the language. It's likely to get you into trouble.</source>
          <target state="translated">En resumen:Cuando aprendas Swift,haz de cuenta que el carácter &quot;!&quot; no es parte del idioma.Es probable que te meta en problemas.</target>
        </trans-unit>
        <trans-unit id="270c4892a016f64b1f29e7cd37c444a555dc7d7d" translate="yes" xml:space="preserve">
          <source>But Swift's error handling system also provides a way to &quot;force try&quot; with &lt;code&gt;try!&lt;/code&gt;:</source>
          <target state="translated">&amp;iexcl;Pero el sistema de manejo de errores de Swift tambi&amp;eacute;n proporciona una forma de &quot;forzar el intento&quot; con el &lt;code&gt;try!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e2f129952b7df6d9c9137de5fc26c084032ef61" translate="yes" xml:space="preserve">
          <source>By applying the &lt;code&gt;map&lt;/code&gt; function to it &amp;ndash; we can use the &lt;code&gt;stringByAppendingString&lt;/code&gt; function in order to concatenate it to another string.</source>
          <target state="translated">Al aplicarle la funci&amp;oacute;n de &lt;code&gt;map&lt;/code&gt; a , podemos usar la funci&amp;oacute;n &lt;code&gt;stringByAppendingString&lt;/code&gt; para concatenarla a otra cadena.</target>
        </trans-unit>
        <trans-unit id="890392cd814cb51a3ec19620be5a911041086aa9" translate="yes" xml:space="preserve">
          <source>Declare variable optional (&lt;code&gt;?&lt;/code&gt;), not implicitly unwrapped optionals (IUO) (&lt;code&gt;!&lt;/code&gt;)</source>
          <target state="translated">Declarar variable opcional ( &lt;code&gt;?&lt;/code&gt; ), No impl&amp;iacute;citamente opciones opcionales sin envolver (IUO) ( &lt;code&gt;!&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2259c1bef40d9a2d2466c01f96f672a698d0443" translate="yes" xml:space="preserve">
          <source>Destination Controller:</source>
          <target state="translated">Controlador de destino:</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="202b26ba321fbfe7f81ed7bbc6b02aef082dc6be" translate="yes" xml:space="preserve">
          <source>Either unwrap variable like this:</source>
          <target state="translated">O desenvuelve una variable como esta:</target>
        </trans-unit>
        <trans-unit id="ca0a491616073f375fc6c16bc6cdb928b2718880" translate="yes" xml:space="preserve">
          <source>Even myself has to wrap (no pun intended) my head around Optionals :D
&lt;em&gt;Happy Swfting All&lt;/em&gt;.</source>
          <target state="translated">Incluso yo mismo tengo que envolver (sin juego de palabras) mi cabeza. Opcionales: D &lt;em&gt;Happy Swfting All&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e49c1f7f49b51d3c469b5d6175ea1c5c2c0403" translate="yes" xml:space="preserve">
          <source>Explicit Force Unwrapping</source>
          <target state="translated">Desenvolvimiento de la Fuerza Explícita</target>
        </trans-unit>
        <trans-unit id="7e9c689c33f3c0bb551be00e08e8e196af6dd530" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while &lt;strong&gt;implicitly&lt;/strong&gt; unwrapping an Optional value</source>
          <target state="translated">Error grave: se encontr&amp;oacute; inesperadamente nulo al desenvolver &lt;strong&gt;impl&amp;iacute;citamente&lt;/strong&gt; un valor opcional</target>
        </trans-unit>
        <trans-unit id="63b2f6bd19b28c7b1987bcb9dd32336331c79410" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</source>
          <target state="translated">Error fatal:Inesperadamente se encuentra cero mientras que implícitamente se desenvuelve un valor Opcional</target>
        </trans-unit>
        <trans-unit id="5ee449f8148453a77ee10bc85af161a2bf6904d0" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while unwrapping an Optional value</source>
          <target state="translated">Error fatal:Inesperadamente se encontró cero al desenvolver un valor opcional</target>
        </trans-unit>
        <trans-unit id="5c2c4179c8fff9ca83b586e12a580e908e386c5c" translate="yes" xml:space="preserve">
          <source>First, you should know what an Optional value is.
You can step to &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;The Swift Programming Language&lt;/a&gt; for detail.</source>
          <target state="translated">Primero, debe saber qu&amp;eacute; es un valor opcional. Puede pasar al &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;lenguaje de programaci&amp;oacute;n Swift&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="fe3fb55243316c9dc924d99b807f5717582eeb12" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have an optional string:</source>
          <target state="translated">Por ejemplo, supongamos que tiene una cadena opcional:</target>
        </trans-unit>
        <trans-unit id="8bd561982c688335d8305fd365ca075aba1100cc" translate="yes" xml:space="preserve">
          <source>For example, say we have a variable &lt;code&gt;foo&lt;/code&gt;, of type an optional &lt;code&gt;Foo&lt;/code&gt; instance.</source>
          <target state="translated">Por ejemplo, supongamos que tenemos una variable &lt;code&gt;foo&lt;/code&gt; , de tipo una instancia opcional de &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4fe78f7c529115814a0589403fb98c66ea73e508" translate="yes" xml:space="preserve">
          <source>Guard statements were added in Swift 2. Guard lets you preserve the &quot;golden path&quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using &quot;if let&quot; optional binding.</source>
          <target state="translated">Las declaraciones de los guardias se añadieron en el Swift 2.Guard te permite preservar el &quot;camino dorado&quot; a través de tu código,y evitar los crecientes niveles de &quot;ifs&quot; anidados que a veces resultan del uso de la vinculación opcional de &quot;if let&quot;.</target>
        </trans-unit>
        <trans-unit id="93edce2bfc57c7c54e7fd4b314121e6beb589d57" translate="yes" xml:space="preserve">
          <source>Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">Los guardias tambi&amp;eacute;n admiten los mismos trucos que la declaraci&amp;oacute;n if admite, como desenvolver m&amp;uacute;ltiples opciones al mismo tiempo y usar la cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad08562b159908e3b05f037b3e013647aba536b4" translate="yes" xml:space="preserve">
          <source>Hence it's better to write as such:</source>
          <target state="translated">Por lo tanto,es mejor escribir como tal:</target>
        </trans-unit>
        <trans-unit id="fd4007c3ff26895e5bb5fb48507590600d2502eb" translate="yes" xml:space="preserve">
          <source>Here by force casting you tell the compiler to no longer worry, as you'll always have a &lt;code&gt;Rectangle&lt;/code&gt; instance there. And as long as that holds, you don't have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.</source>
          <target state="translated">Aqu&amp;iacute;, al forzar el lanzamiento, le dice al compilador que ya no se preocupe, ya que siempre tendr&amp;aacute; una instancia de &lt;code&gt;Rectangle&lt;/code&gt; all&amp;iacute;. Y mientras eso se mantenga, no tiene que preocuparse. Los problemas comienzan cuando usted o sus colegas del proyecto comienzan a circular valores no rectangulares.</target>
        </trans-unit>
        <trans-unit id="a10432c3dfc4ac875e419233a429110d852331d9" translate="yes" xml:space="preserve">
          <source>Here is an example of optional binding with our &lt;code&gt;foo&lt;/code&gt; optional:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de enlace opcional con nuestro &lt;code&gt;foo&lt;/code&gt; opcional:</target>
        </trans-unit>
        <trans-unit id="f1995e5026962d6c02dca7e583fc61ef9cd31d6c" translate="yes" xml:space="preserve">
          <source>How can I safely deal with Optionals?</source>
          <target state="translated">¿Cómo puedo tratar con seguridad a los opcionales?</target>
        </trans-unit>
        <trans-unit id="e484fea1c47d9e20459264fe14e22be925d72d1b" translate="yes" xml:space="preserve">
          <source>How to deal with optionals:</source>
          <target state="translated">Cómo tratar con los opcionales:</target>
        </trans-unit>
        <trans-unit id="8633d1988d44234fa26b09689d230a24a81c00ff" translate="yes" xml:space="preserve">
          <source>However, 99.9% of the time when working with optionals, you&amp;rsquo;ll actually want to access the value it contains, if it contains one at all. To do this, you can use &lt;em&gt;Optional Binding&lt;/em&gt;.</source>
          <target state="translated">Sin embargo, el 99.9% del tiempo cuando trabaje con opciones, en realidad querr&amp;aacute; acceder al valor que contiene, si es que contiene uno. Para hacer esto, puede usar &lt;em&gt;Enlace opcional&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9bcd13ba1c830e1eb8ee339d08e57ceccdcf9a16" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;anOptionalString&lt;/code&gt; doesn&amp;rsquo;t have a value, &lt;code&gt;map&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">Sin embargo, si &lt;code&gt;anOptionalString&lt;/code&gt; no tiene un valor, &lt;code&gt;map&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;nil&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a00cf22dac7a818231c0ff4ab31cff56b029afeb" translate="yes" xml:space="preserve">
          <source>However, there are a &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;few scenarios where implicitly unwrapped optionals are beneficial&lt;/a&gt;, and you are still able to use various ways of safely unwrapping them as listed below &amp;ndash; but you should &lt;em&gt;always&lt;/em&gt; use them with due caution.</source>
          <target state="translated">Sin embargo, hay &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;algunos escenarios en los que las opciones opcionales&lt;/a&gt; sin envoltura son beneficiosas , y a&amp;uacute;n puede usar varias formas de desenvolverlas de manera segura como se enumera a continuaci&amp;oacute;n, pero &lt;em&gt;siempre&lt;/em&gt; debe usarlas con la debida precauci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="045cfcd48cc9a7581c9554c6d0db82a58d3a86d5" translate="yes" xml:space="preserve">
          <source>However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because &lt;code&gt;foo&lt;/code&gt; is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods &amp;ndash; or unwrap &lt;code&gt;foo&lt;/code&gt; itself before accessing methods or calling methods that return values.</source>
          <target state="translated">Sin embargo, las cosas se vuelven un poco m&amp;aacute;s dif&amp;iacute;ciles cuando se trata de acceder a propiedades o m&amp;eacute;todos de llamada que devuelven un valor. Debido a que &lt;code&gt;foo&lt;/code&gt; es opcional, todo lo que devuelva tambi&amp;eacute;n ser&amp;aacute; opcional. Para lidiar con esto, puede desenvolver las opciones que se devuelven utilizando uno de los m&amp;eacute;todos anteriores, o desenvolverlas antes de acceder a los m&amp;eacute;todos o llamar a los m&amp;eacute;todos que devuelven valores.</target>
        </trans-unit>
        <trans-unit id="8925a8490bf5fd57f3e11be4c68ec114afe4face" translate="yes" xml:space="preserve">
          <source>I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.</source>
          <target state="translated">Me encontré con este error mientras hacía una transición de un controlador de vista de mesa a un controlador de vista porque había olvidado especificar el nombre de clase personalizado para el controlador de vista en el storyboard principal.</target>
        </trans-unit>
        <trans-unit id="961d19ccc70f1d74e0009e3c081c86736529fa59" translate="yes" xml:space="preserve">
          <source>I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:</source>
          <target state="translated">Tuve este error una vez cuando trataba de establecer los valores de mis salidas del método de preparación para la transición de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="c9821ba4ff1ad0757f5f86a478e8819368f2e4a1" translate="yes" xml:space="preserve">
          <source>I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn't addressed the issue itself directly.</source>
          <target state="translated">Espero que esta respuesta ayude a cualquiera que tenga el mismo problema,ya que la respuesta marcada es un gran recurso para la comprensión de los opcionales y cómo funcionan,pero no ha abordado el problema en sí mismo directamente.</target>
        </trans-unit>
        <trans-unit id="687e27bcc1f747e004946e97f14c1a09937a1708" translate="yes" xml:space="preserve">
          <source>IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, &lt;em&gt;after&lt;/em&gt; initialization. You should therefore ensure that you&amp;rsquo;re not accessing outlets before they're loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be &lt;code&gt;nil&lt;/code&gt; at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.</source>
          <target state="translated">Los IBOutlets, en particular, generalmente son opciones impl&amp;iacute;citas sin envolver. Esto se debe a que su xib o storyboard vincular&amp;aacute;n las salidas en tiempo de ejecuci&amp;oacute;n, &lt;em&gt;despu&amp;eacute;s de la&lt;/em&gt; inicializaci&amp;oacute;n. Por lo tanto, debe asegurarse de no acceder a los puntos de venta antes de que se carguen. Tambi&amp;eacute;n debe verificar que las conexiones sean correctas en su archivo storyboard / xib, de lo contrario, los valores ser&amp;aacute;n &lt;code&gt;nil&lt;/code&gt; en el tiempo de ejecuci&amp;oacute;n y, por lo tanto, se bloquear&amp;aacute;n cuando est&amp;eacute;n impl&amp;iacute;citamente sin envolver Al arreglar las conexiones, intente eliminar las l&amp;iacute;neas de c&amp;oacute;digo que definen sus puntos de venta, luego vuelva a conectarlos.</target>
        </trans-unit>
        <trans-unit id="cbf8b026a781fcaf4a77cedd0a311b396615b39b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;anOptionalInt&lt;/code&gt; contains a value, it will be unwrapped and assigned to the new &lt;code&gt;number&lt;/code&gt; constant. The code &lt;em&gt;after&lt;/em&gt; the guard will then continue executing. If it doesn&amp;rsquo;t contain a value &amp;ndash; the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.</source>
          <target state="translated">Si &lt;code&gt;anOptionalInt&lt;/code&gt; contiene un valor, se desenvolver&amp;aacute; y se asignar&amp;aacute; a la nueva constante de &lt;code&gt;number&lt;/code&gt; . El c&amp;oacute;digo &lt;em&gt;despu&amp;eacute;s&lt;/em&gt; del guardia continuar&amp;aacute; ejecut&amp;aacute;ndose. Si no contiene un valor, el guardia ejecutar&amp;aacute; el c&amp;oacute;digo entre par&amp;eacute;ntesis, lo que conducir&amp;aacute; a la transferencia de control, de modo que el c&amp;oacute;digo inmediatamente posterior no se ejecutar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="555b9e1b03e3ef819963d13f4ad1e9cd6291d3bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;foo&lt;/code&gt; contains a value, this method will be called on it. If it doesn&amp;rsquo;t, nothing bad will happen &amp;ndash; the code will simply continue executing.</source>
          <target state="translated">Si &lt;code&gt;foo&lt;/code&gt; contiene un valor, se llamar&amp;aacute; a este m&amp;eacute;todo. Si no es as&amp;iacute;, no pasar&amp;aacute; nada malo: el c&amp;oacute;digo simplemente continuar&amp;aacute; ejecut&amp;aacute;ndose.</target>
        </trans-unit>
        <trans-unit id="bfd5e74dcdb489bc0ac5f2ed761961f64038c09a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someThrowingFunc()&lt;/code&gt; throws an error, the error will be safely caught in the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">Si &lt;code&gt;someThrowingFunc()&lt;/code&gt; arroja un error, el error se capturar&amp;aacute; de forma segura en el bloque &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d952b11c89cd854be27de0d0f65ed17e3c578f0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someVariable&lt;/code&gt; is nil, then you'll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you're guaranteeing to the compiler that you'll never have nil values there. And guess what it happens if somehow a nil value ends in in &lt;code&gt;someVariable&lt;/code&gt;?</source>
          <target state="translated">Si &lt;code&gt;someVariable&lt;/code&gt; es nulo, obtendr&amp;aacute; un bloqueo. Al realizar un desenvolvimiento forzado, movi&amp;oacute; la responsabilidad de verificaci&amp;oacute;n nula del compilador hacia usted, b&amp;aacute;sicamente al realizar un desenvolvimiento forzado, le garantiza al compilador que nunca tendr&amp;aacute; valores nulos all&amp;iacute;. &amp;iquest;Y adivina qu&amp;eacute; sucede si de alguna manera un valor nulo termina en &lt;code&gt;someVariable&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c01ad95af312c93699d0f265e3b3b0b10e9f23a1" translate="yes" xml:space="preserve">
          <source>If we wanted to call a method on &lt;code&gt;foo&lt;/code&gt; that doesn&amp;rsquo;t return anything, we can simply do:</source>
          <target state="translated">Si quisi&amp;eacute;ramos llamar a un m&amp;eacute;todo en &lt;code&gt;foo&lt;/code&gt; que no devuelve nada, simplemente podemos hacer:</target>
        </trans-unit>
        <trans-unit id="78da2ff6a4b5799b4addacf92cf6d2b26fb23cc8" translate="yes" xml:space="preserve">
          <source>If you get this error in CollectionView try to create CustomCell file and Custom xib also.</source>
          <target state="translated">Si obtienes este error en CollectionView intenta crear el archivo CustomCell y el Custom xib también.</target>
        </trans-unit>
        <trans-unit id="0127a3535a0583ab1a79af7eea2befd762a366e7" translate="yes" xml:space="preserve">
          <source>Implicitly Unwrapped Optionals</source>
          <target state="translated">Opcionales implícitamente desenvueltos</target>
        </trans-unit>
        <trans-unit id="051898db5718d1ca1229f4edae90fa5baa7e3071" translate="yes" xml:space="preserve">
          <source>Implicitly unwrapped optionals. Let's assume you have the following class definition:</source>
          <target state="translated">Opcionales implícitamente desenvueltos.Asumamos que tienes la siguiente definición de clase:</target>
        </trans-unit>
        <trans-unit id="484536419577c05bc013ad78ac088dd3099a07ed" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;generic type&lt;/a&gt; that can contain a value (of any kind), or no value at all.</source>
          <target state="translated">En Swift, &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; es un &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;tipo gen&amp;eacute;rico&lt;/a&gt; que puede contener un valor (de cualquier tipo), o ning&amp;uacute;n valor en absoluto.</target>
        </trans-unit>
        <trans-unit id="79a7dee40b7721bf417ab75a0b14f771e29d4b3d" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;strong&gt;&lt;em&gt;any type&lt;/em&gt; can be made optional&lt;/strong&gt;. An optional value can take on any value from the original type, &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;or&lt;/em&gt;&lt;/a&gt; the special value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">En Swift, &lt;strong&gt;&lt;em&gt;cualquier tipo&lt;/em&gt; puede hacerse opcional&lt;/strong&gt; . Un valor opcional puede tomar cualquier valor del tipo original &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;o&lt;/em&gt;&lt;/a&gt; el valor especial &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04774461a3612ca563f0e36ff0dbf0f0ec4fa74c" translate="yes" xml:space="preserve">
          <source>In many other programming languages, a particular &quot;sentinel&quot; value is often used to indicate a &lt;em&gt;lack of a value&lt;/em&gt;. In Objective-C, for example, &lt;code&gt;nil&lt;/code&gt; (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;null pointer&lt;/a&gt;) indicates the lack of an object. But this gets more tricky when working with primitive types &amp;mdash; should &lt;code&gt;-1&lt;/code&gt; be used to indicate the absence of an integer, or perhaps &lt;code&gt;INT_MIN&lt;/code&gt;, or some other integer? If any particular value is chosen to mean &quot;no integer&quot;, that means it can no longer be treated as a &lt;em&gt;valid&lt;/em&gt; value.</source>
          <target state="translated">En muchos otros lenguajes de programaci&amp;oacute;n, a menudo se usa &lt;em&gt;un valor&lt;/em&gt; &quot;centinela&quot; particular para indicar la &lt;em&gt;falta de un valor&lt;/em&gt; . En Objective-C, por ejemplo, &lt;code&gt;nil&lt;/code&gt; (el &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;puntero nulo&lt;/a&gt; ) indica la falta de un objeto. Pero esto se vuelve m&amp;aacute;s complicado cuando se trabaja con tipos primitivos. &amp;iquest;Deber&amp;iacute;a usarse &lt;code&gt;-1&lt;/code&gt; para indicar la ausencia de un n&amp;uacute;mero entero, o tal vez &lt;code&gt;INT_MIN&lt;/code&gt; , o alg&amp;uacute;n otro n&amp;uacute;mero entero? Si se elige cualquier valor particular para que signifique &quot;sin n&amp;uacute;mero entero&quot;, eso significa que ya no puede tratarse como un valor &lt;em&gt;v&amp;aacute;lido&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46b85b18ba2133633a4afcab43ae7743b50be6e2" translate="yes" xml:space="preserve">
          <source>In order to access an optional&amp;rsquo;s value (if it has one at all), you need to &lt;strong&gt;unwrap&lt;/strong&gt; it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it &lt;em&gt;didn't&lt;/em&gt; have a value, your program will crash with the above message.</source>
          <target state="translated">Para acceder al valor de un opcional (si tiene uno), debe &lt;strong&gt;desenvolverlo&lt;/strong&gt; . Un valor opcional se puede desenvolver de forma segura o forzada. Si desenvuelve a la fuerza un opcional, y &lt;em&gt;no&lt;/em&gt; ten&amp;iacute;a un valor, su programa se bloquear&amp;aacute; con el mensaje anterior.</target>
        </trans-unit>
        <trans-unit id="2870a2cd345396e3c49f99168c09a7038d33fa6f" translate="yes" xml:space="preserve">
          <source>In order to work out which variable caused the crash, you can hold</source>
          <target state="translated">Para averiguar qué variable causó el accidente,puedes mantener</target>
        </trans-unit>
        <trans-unit id="ee021373ae2b52768be006a0a1a52dc063c5b011" translate="yes" xml:space="preserve">
          <source>In other words, rather use:</source>
          <target state="translated">En otras palabras,más bien usar:</target>
        </trans-unit>
        <trans-unit id="c40e8f1772cb4a16417b4c1962c3c56e76be0301" translate="yes" xml:space="preserve">
          <source>In that case foo is still an optional, but you don't have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it's nil.</source>
          <target state="translated">En ese caso,el foo sigue siendo opcional,pero no tienes que desenvolverlo para referirte a él.Eso significa que cada vez que intentas hacer referencia a la Foo,te caes si es nula.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">En lugar de:</target>
        </trans-unit>
        <trans-unit id="8bedbb9a541d4d033efb3e04645647ad1c32d4d3" translate="yes" xml:space="preserve">
          <source>It essentially lets you say &amp;ldquo;If &lt;code&gt;a&lt;/code&gt; contains a value, unwrap it. If it doesn&amp;rsquo;t then return &lt;code&gt;b&lt;/code&gt; instead&amp;rdquo;. For example, you could use it like this:</source>
          <target state="translated">B&amp;aacute;sicamente te permite decir &quot;Si &lt;code&gt;a&lt;/code&gt; contiene un valor, desenvu&amp;eacute;lvelo. Si no es as&amp;iacute;, devuelve &lt;code&gt;b&lt;/code&gt; en su lugar &quot; Por ejemplo, podr&amp;iacute;a usarlo as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ad0ef45d1f8d084087d25064193cc17d964245ca" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s just shorthand for:</source>
          <target state="translated">Es solo una abreviatura de:</target>
        </trans-unit>
        <trans-unit id="459fe8274d538afa06b4cd892cfc12fa3846a208" translate="yes" xml:space="preserve">
          <source>Learn how to debug an iOS app crash</source>
          <target state="translated">Aprende a depurar una caída de la aplicación iOS</target>
        </trans-unit>
        <trans-unit id="aaee9b9adb35ca322a119d776bbbe533b4d1fb20" translate="yes" xml:space="preserve">
          <source>Long story short by using &lt;code&gt;var address : Address!&lt;/code&gt; you're &lt;strong&gt;hiding&lt;/strong&gt; the possibility that a variable can be &lt;code&gt;nil&lt;/code&gt; from other readers. And when it crashes you're like &quot;what the hell?! my &lt;code&gt;address&lt;/code&gt; isn't an optional, so why am I crashing?!.</source>
          <target state="translated">Larga historia corta usando la &lt;code&gt;var address : Address!&lt;/code&gt; est&amp;aacute; &lt;strong&gt;ocultando&lt;/strong&gt; la posibilidad de que una variable pueda ser &lt;code&gt;nil&lt;/code&gt; de otros lectores. Y cuando se bloquea, dices &quot;&amp;iexcl;&amp;iquest;Qu&amp;eacute; demonios ?! &amp;iexcl;Mi &lt;code&gt;address&lt;/code&gt; no es opcional, as&amp;iacute; que, &amp;iquest;por qu&amp;eacute; me estrello ?!</target>
        </trans-unit>
        <trans-unit id="78cef24b9706680cc584904b5e88b79801d759b5" translate="yes" xml:space="preserve">
          <source>Most of the time you will use the complete Do-Try-Catch system - and the optional one, &lt;code&gt;try?&lt;/code&gt;, in the rare cases where handling the error is not important.</source>
          <target state="translated">La mayor&amp;iacute;a de las veces utilizar&amp;aacute; el sistema completo Do-Try-Catch, y el opcional, &lt;code&gt;try?&lt;/code&gt; , en los raros casos en los que manejar el error no es importante.</target>
        </trans-unit>
        <trans-unit id="35e9fc497ab02ab074e552f7be54dc7f776c210a" translate="yes" xml:space="preserve">
          <source>My Swift program is crashing with &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and one of the following similar errors. What does this error mean, and how do I fix it?</source>
          <target state="translated">Mi programa Swift se bloquea con &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; y uno de los siguientes errores similares. &amp;iquest;Qu&amp;eacute; significa este error y c&amp;oacute;mo lo soluciono?</target>
        </trans-unit>
        <trans-unit id="56a078777cdf9213e116547d03f394624b748e2b" translate="yes" xml:space="preserve">
          <source>Nil Coalescing Operator</source>
          <target state="translated">Nulo Operador Coalescente</target>
        </trans-unit>
        <trans-unit id="9b06cd01bf313f728f850e8f6dfbc9e6120741e5" translate="yes" xml:space="preserve">
          <source>Note that the variable you define when you use optional biding only exists (is only &quot;in scope&quot;) in the body of the if statement.</source>
          <target state="translated">Tenga en cuenta que la variable que se define cuando se utiliza la oferta opcional sólo existe (sólo está &quot;en el ámbito de aplicación&quot;)en el cuerpo de la declaración if.</target>
        </trans-unit>
        <trans-unit id="4c10eb68d56cba105bdf477429d00aea854d4ccd" translate="yes" xml:space="preserve">
          <source>Now if no nullability annotations are specified (either explicitly or via &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt;/&lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;), then the &lt;code&gt;name&lt;/code&gt; property will be imported in Swift as &lt;code&gt;String!&lt;/code&gt; (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if &lt;code&gt;name&lt;/code&gt; is nil.</source>
          <target state="translated">Ahora, si no se especifican anotaciones de nulabilidad (ya sea expl&amp;iacute;citamente o mediante &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; / &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt; ), &amp;iexcl;la propiedad del &lt;code&gt;name&lt;/code&gt; se importar&amp;aacute; en Swift as &lt;code&gt;String!&lt;/code&gt; (un IUO - opcional sin envoltura impl&amp;iacute;cita) Tan pronto como un c&amp;oacute;digo r&amp;aacute;pido quiera usar el valor, se bloquear&amp;aacute; si el &lt;code&gt;name&lt;/code&gt; es nulo.</target>
        </trans-unit>
        <trans-unit id="16ffd92502b92b7dab0de459501aee70aad84527" translate="yes" xml:space="preserve">
          <source>Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you'll want to use the outlet.
Solution? Make sure all outlets are connected. Or use the &lt;code&gt;?&lt;/code&gt; operator on them: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.</source>
          <target state="translated">Ahora, si no conect&amp;oacute; la salida desde el editor XIB, la aplicaci&amp;oacute;n se bloquear&amp;aacute; tan pronto como quiera usar la salida. &amp;iquest;Soluci&amp;oacute;n? Aseg&amp;uacute;rese de que todos los enchufes est&amp;eacute;n conectados. O usar el &lt;code&gt;?&lt;/code&gt; operador en ellos: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt; . O declare la salida como opcional, aunque en este caso el compilador lo obligar&amp;aacute; a desenvolverlo en todo el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="f75a096d58dde4b74701e26c90ea72ae64747b35" translate="yes" xml:space="preserve">
          <source>Now, if no-one messes up with the &lt;code&gt;name&lt;/code&gt; property by setting it to &lt;code&gt;nil&lt;/code&gt;, then it works as expected, however if &lt;code&gt;User&lt;/code&gt; is initialized from a JSON that lacks the &lt;code&gt;name&lt;/code&gt; key, then you get the fatal error when trying to use the property.</source>
          <target state="translated">Ahora, si nadie se equivoca con la propiedad de &lt;code&gt;name&lt;/code&gt; configur&amp;aacute;ndola como &lt;code&gt;nil&lt;/code&gt; , entonces funciona como se esperaba, sin embargo, si el &lt;code&gt;User&lt;/code&gt; se inicializa desde un JSON que carece de la clave de &lt;code&gt;name&lt;/code&gt; , entonces obtiene el error fatal al intentar usar la propiedad .</target>
        </trans-unit>
        <trans-unit id="936cf8bab3f747e065f42e3415906001fcaec17a" translate="yes" xml:space="preserve">
          <source>One other way, if you don't want to check the variable state before your implementation, you can also use &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; instead.</source>
          <target state="translated">Otra forma, si no desea verificar el estado de la variable antes de su implementaci&amp;oacute;n, tambi&amp;eacute;n puede usar &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; &quot;buildingName&quot; en su lugar.</target>
        </trans-unit>
        <trans-unit id="4a3f188326fc444bc42e44fa25a0acf6b3ccac81" translate="yes" xml:space="preserve">
          <source>Optional Binding</source>
          <target state="translated">Vinculación Opcional</target>
        </trans-unit>
        <trans-unit id="7a826a948d8f9ecc960c32ca6f545004bbd4247e" translate="yes" xml:space="preserve">
          <source>Optional Binding allows you to check if an optional contains a value &amp;ndash; and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; or &lt;code&gt;if var x = anOptional {...}&lt;/code&gt;, depending if you need to modify the value of the new variable after binding it.</source>
          <target state="translated">El enlace opcional le permite verificar si un opcional contiene un valor, y le permite asignar el valor sin envolver a una nueva variable o constante. Utiliza la sintaxis &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; o &lt;code&gt;if var x = anOptional {...}&lt;/code&gt; , dependiendo de si necesita modificar el valor de la nueva variable despu&amp;eacute;s de vincularla.</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">Encadenamiento opcional</target>
        </trans-unit>
        <trans-unit id="1661a949efe8ce7e832a8022541343bb817a5148" translate="yes" xml:space="preserve">
          <source>Optionals are defined with a &lt;code&gt;?&lt;/code&gt; suffix on the type:</source>
          <target state="translated">Los opcionales se definen con un &lt;code&gt;?&lt;/code&gt; sufijo en el tipo:</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">O así:</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="54833e81302d6311cef1a28ed09adc3690301a62" translate="yes" xml:space="preserve">
          <source>Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.</source>
          <target state="translated">En segundo lugar,debes saber que el valor opcional tiene dos estados.Uno es el valor completo,y el otro es un valor nulo.Así que antes de implementar un valor opcional,deberías comprobar en qué estado se encuentra.</target>
        </trans-unit>
        <trans-unit id="03c6c8c8bdb83cd4b0856641a961cecbc0c85b85" translate="yes" xml:space="preserve">
          <source>Since the above answers clearly explains how to play safely with Optionals.
I will try explain what Optionals are really in swift.</source>
          <target state="translated">Ya que las respuestas anteriores explican claramente cómo jugar con seguridad con los Opcionales.Trataré de explicar lo que los Opcionales son realmente en rápido.</target>
        </trans-unit>
        <trans-unit id="dad624a90b7df3a23e5bb578feeeabdd12ee8888" translate="yes" xml:space="preserve">
          <source>So I solved it this way:</source>
          <target state="translated">Así que lo resolví de esta manera:</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">Así que este código:</target>
        </trans-unit>
        <trans-unit id="afb1b762e29712aa3b112a22ea2e06690f91025a" translate="yes" xml:space="preserve">
          <source>So to assign a nil to our variable 'i'. We can do 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt;
or to assign a value, we will pass some value 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</source>
          <target state="translated">Entonces, para asignar un nulo a nuestra variable 'i'. Podemos hacer &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt; o para asignar un valor, pasaremos alg&amp;uacute;n valor &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a43ac01380800da0acd970a8b899fd1a1eb60e8" translate="yes" xml:space="preserve">
          <source>So you could use code like this:</source>
          <target state="translated">Así que podrías usar un código como este:</target>
        </trans-unit>
        <trans-unit id="b04e4285f916f64b8ec1d071584592d993d42c35" translate="yes" xml:space="preserve">
          <source>So, to use them with an optional binding, you can do this:</source>
          <target state="translated">Así que,para usarlos con una encuadernación opcional,puedes hacer esto:</target>
        </trans-unit>
        <trans-unit id="7547ba07041dcef70d621cc40b5c4a45b8ce5e45" translate="yes" xml:space="preserve">
          <source>Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as &lt;code&gt;nonnull&lt;/code&gt;.</source>
          <target state="translated">&amp;iquest;Soluci&amp;oacute;n? Agregue anotaciones de nulabilidad a su c&amp;oacute;digo Objective-C. Sin embargo, tenga en cuenta que el compilador Objective-C es un poco permisivo cuando se trata de nulabilidad, puede terminar con valores nulos, incluso si los marc&amp;oacute; expl&amp;iacute;citamente como no &lt;code&gt;nonnull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52e5455e8973ef67576894c1d0ab773692ab9e50" translate="yes" xml:space="preserve">
          <source>Solution? Don't use them :) Unless you're 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property</source>
          <target state="translated">¿Solución? No las uses :)A menos que estés 102% seguro de que la propiedad siempre tendrá un valor no nulo para cuando necesite ser usada.En la mayoría de los casos,convertirla en opcional o no opcional funcionará.Hacerlo no opcional también hará que el compilador le ayude diciéndole a las rutas de código que se perdió dar un valor a esa propiedad</target>
        </trans-unit>
        <trans-unit id="dbbb73b74bb82fd31f9eda3643a242450fdeebf5" translate="yes" xml:space="preserve">
          <source>Solution? Use optional binding (aka if-let), do the variable processing there:</source>
          <target state="translated">¿Solución? Usar la encuadernación opcional (alias &quot;if-let&quot;),hacer el procesamiento de las variables allí:</target>
        </trans-unit>
        <trans-unit id="f6514760b09d36bf6238bb6b2eecdafcf283abf2" translate="yes" xml:space="preserve">
          <source>Something simple that is worth checking if all else looks ok</source>
          <target state="translated">Algo simple que vale la pena comprobar si todo lo demás se ve bien.</target>
        </trans-unit>
        <trans-unit id="d9bf36cacd5682e9de59257e72eab5c7866cf9e7" translate="yes" xml:space="preserve">
          <source>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake.</source>
          <target state="translated">Swift es un lenguaje seguro,lo que significa que el lenguaje te ayuda a ser claro sobre los tipos de valores con los que tu código puede funcionar.Si parte de tu código espera una cadena,la seguridad de tipo evita que le pases un Int por error.</target>
        </trans-unit>
        <trans-unit id="0191ce146a46db014aa0959a5ad6aab2ad0a906a" translate="yes" xml:space="preserve">
          <source>Swift optionals let you set up a variable of any type to contain either a valid value, or no value.</source>
          <target state="translated">Las opciones rápidas le permiten configurar una variable de cualquier tipo para que contenga un valor válido o ningún valor.</target>
        </trans-unit>
        <trans-unit id="9f50948ddb6a9405af006b565688093e07e7df89" translate="yes" xml:space="preserve">
          <source>Swift uses the concept of &quot;Optionals&quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.</source>
          <target state="translated">Swift utiliza el concepto de &quot;Opcionales&quot; para tratar con valores que podrían contener un valor,o no.En otros idiomas como C,podría almacenar un valor de 0 en una variable para indicar que no contiene ningún valor.Sin embargo,¿qué pasa si 0 es un valor válido? Entonces podrías usar -1.¿Y si -1 es un valor válido? Y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="8733a9d6eaaff2ad81a4c469105c4f2aa8f27191" translate="yes" xml:space="preserve">
          <source>Swift's error handling system can be safely used with &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;:</source>
          <target state="translated">El sistema de manejo de errores de Swift se puede usar de manera segura con &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="aab6e4d9938362d2634e37c6d271130b036be9f7" translate="yes" xml:space="preserve">
          <source>TL;DR answer</source>
          <target state="translated">Respuesta de TL;DR</target>
        </trans-unit>
        <trans-unit id="5910011e369d233145df2614ffbb9258f70e2bc9" translate="yes" xml:space="preserve">
          <source>The &quot;!&quot; operator is a &quot;force unwrap&quot; operator. It says &quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.&quot; If you are wrong, you crash.</source>
          <target state="translated">El operador &quot;!&quot; es un operador de &quot;desenvolver por la fuerza&quot;.Dice &quot;confía en mí.Sé lo que estoy haciendo.Garantizo que cuando este código se ejecute,la variable no contendrá cero&quot;.Si te equivocas,te caes.</target>
        </trans-unit>
        <trans-unit id="cc8497513f48b57bcdbd220d3e716cb1d4a6b09b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; is a nifty shorthand version of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;ternary conditional operator&lt;/a&gt;, primarily designed to convert optionals to non-optionals. It has the syntax &lt;code&gt;a ?? b&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an optional type and &lt;code&gt;b&lt;/code&gt; is the same type as &lt;code&gt;a&lt;/code&gt; (although usually non-optional).</source>
          <target state="translated">El &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Operador de fusi&amp;oacute;n nula&lt;/a&gt; es una ingeniosa versi&amp;oacute;n abreviada del &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;operador condicional ternario&lt;/a&gt; , dise&amp;ntilde;ado principalmente para convertir opcionales en no opcionales. Tiene la sintaxis &lt;code&gt;a ?? b&lt;/code&gt; b , donde &lt;code&gt;a&lt;/code&gt; es un tipo opcional &lt;code&gt;b&lt;/code&gt; es el mismo tipo que &lt;code&gt;a&lt;/code&gt; (aunque generalmente no es opcional).</target>
        </trans-unit>
        <trans-unit id="4f39a8383e521eac4930320b3f781463d412042a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; constant you see in the &lt;code&gt;catch&lt;/code&gt; block has not been declared by us - it's automatically generated by &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">La constante de &lt;code&gt;error&lt;/code&gt; que ve en el bloque &lt;code&gt;catch&lt;/code&gt; no ha sido declarada por nosotros, se genera autom&amp;aacute;ticamente por &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0c0cb00ef66003262f22de70ce81e5de3dbebd" translate="yes" xml:space="preserve">
          <source>The concepts explained in this post also apply here: if an error is thrown, the application will crash.</source>
          <target state="translated">Los conceptos explicados en este post también se aplican aquí:si se arroja un error,la aplicación se bloqueará.</target>
        </trans-unit>
        <trans-unit id="cc4353dc8328b849dd5eee0ba9343f34b63353af" translate="yes" xml:space="preserve">
          <source>The errors &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; appears the most when you have declared an &lt;code&gt;@IBOutlet&lt;/code&gt;, but not connected to the &lt;strong&gt;storyboard&lt;/strong&gt;.</source>
          <target state="translated">Los errores &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; y &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; aparece m&amp;aacute;s cuando se declara un &lt;code&gt;@IBOutlet&lt;/code&gt; , pero no est&amp;aacute; conectado al &lt;strong&gt;gui&amp;oacute;n gr&amp;aacute;fico&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f944bc0d51db4c42e0ab501ffaf2c9361c58f7c9" translate="yes" xml:space="preserve">
          <source>The full code would be :</source>
          <target state="translated">El código completo sería..:</target>
        </trans-unit>
        <trans-unit id="39947ad748876c5ade4da078e8c8623048e5ffc6" translate="yes" xml:space="preserve">
          <source>The full code would be:</source>
          <target state="translated">El código completo sería:</target>
        </trans-unit>
        <trans-unit id="49a1afbffea19fea31c8bef0f4563791d58a8dc2" translate="yes" xml:space="preserve">
          <source>The lack of a value in an optional is indicated by &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">La falta de un valor en un opcional se indica por &lt;code&gt;nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37d4ab0d4c249a69f4593634c7af51c35f6f73fc" translate="yes" xml:space="preserve">
          <source>The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a &lt;em&gt;guard statement&lt;/em&gt;.</source>
          <target state="translated">El &amp;uacute;nico inconveniente con el uso del enlace opcional dentro de una declaraci&amp;oacute;n if es que solo puede acceder al valor sin envolver dentro del alcance de la declaraci&amp;oacute;n. Si necesita acceder al valor desde fuera del alcance de la declaraci&amp;oacute;n, puede usar una &lt;em&gt;declaraci&amp;oacute;n de protecci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="77a167b0cfc56774bff7d7b752b55f5f670e549d" translate="yes" xml:space="preserve">
          <source>The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can &lt;em&gt;only&lt;/em&gt; execute if the optional has a value). This is a great for eliminating &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;&amp;lsquo;pyramids of doom&amp;rsquo;&lt;/a&gt; created by nesting multiple if statements.</source>
          <target state="translated">Lo realmente bueno de las declaraciones de guardia es que el valor sin envolver ahora est&amp;aacute; disponible para usar en el c&amp;oacute;digo que sigue a la declaraci&amp;oacute;n (ya que sabemos que el c&amp;oacute;digo futuro &lt;em&gt;solo&lt;/em&gt; puede ejecutarse si el opcional tiene un valor). Esto es ideal para eliminar las &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;'pir&amp;aacute;mides de la fatalidad'&lt;/a&gt; creadas al anidar m&amp;uacute;ltiples sentencias if.</target>
        </trans-unit>
        <trans-unit id="f70e19cc299904e989d46111669248e2d6297b5a" translate="yes" xml:space="preserve">
          <source>The simplest way to check whether an optional contains a value, is to compare it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s sencilla de verificar si un opcional contiene un valor, es compararlo con &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad7c64f5b093e808ba67d8a73670ba71bd4ebd5" translate="yes" xml:space="preserve">
          <source>Then I found out that I can't set the values of the destination controller outlets because the controller hasn't been loaded or initialized yet.</source>
          <target state="translated">Luego descubrí que no puedo establecer los valores de las salidas del controlador de destino porque el controlador no ha sido cargado o inicializado todavía.</target>
        </trans-unit>
        <trans-unit id="1ec67f9dd2cfab174b6b515c3d0d4747bf7293ec" translate="yes" xml:space="preserve">
          <source>There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)</source>
          <target state="translated">Hay muchas otras formas de tratar con los opcionales que son más seguras.Aquí hay algunas (no es una lista exhaustiva)</target>
        </trans-unit>
        <trans-unit id="0d60f2d11c0f746729eec725020f1feabe53897f" translate="yes" xml:space="preserve">
          <source>There are several scenarios that lead to this kind of fatal error:</source>
          <target state="translated">Hay varios escenarios que conducen a este tipo de error fatal:</target>
        </trans-unit>
        <trans-unit id="3cc4935148dd3d0a4d88768551d67d938c2ebaf2" translate="yes" xml:space="preserve">
          <source>There is also a construct called the &quot;nil coalescing operator&quot;. It takes the form &quot;optional_var ?? replacement_val&quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the &quot;??&quot; symbol.</source>
          <target state="translated">También hay una construcción llamada &quot;operador de fusión nula&quot;.Toma la forma de &quot;opcional_var ?? reemplazo_val&quot;.Devuelve una variable no opcional del mismo tipo que los datos contenidos en la opcional.Si el opcional contiene nil,devuelve el valor de la expresión después del símbolo &quot;??&quot;.</target>
        </trans-unit>
        <trans-unit id="b6b6bf923d0fa956d7f5415f78e183319a28b7b6" translate="yes" xml:space="preserve">
          <source>There's also &lt;code&gt;try?&lt;/code&gt; which absorbs the error:</source>
          <target state="translated">Tambi&amp;eacute;n hay &lt;code&gt;try?&lt;/code&gt; que absorbe el error:</target>
        </trans-unit>
        <trans-unit id="051cef13b0cd111883df939c5644ba59bbe86947" translate="yes" xml:space="preserve">
          <source>These are defined with  a &lt;code&gt;!&lt;/code&gt;, rather than a &lt;code&gt;?&lt;/code&gt; after the type.</source>
          <target state="translated">Estos se definen con un &lt;code&gt;!&lt;/code&gt; , en lugar de un &lt;code&gt;?&lt;/code&gt; despu&amp;eacute;s del tipo.</target>
        </trans-unit>
        <trans-unit id="228d647e0bd3a874c5246256241ffafbe0dae63f" translate="yes" xml:space="preserve">
          <source>These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesn&amp;rsquo;t contain a value, it will crash.</source>
          <target state="translated">Se supone que estos opcionales contienen un valor. Por lo tanto, cada vez que acceda a una opci&amp;oacute;n sin envoltura impl&amp;iacute;cita, autom&amp;aacute;ticamente se desenvolver&amp;aacute; forzosamente para usted. Si no contiene un valor, se bloquear&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="03d3193f66062a0894aa6946a0e2b6f22b829634" translate="yes" xml:space="preserve">
          <source>These variables are designed so that you can defer their assignment until later in your code. It is &lt;em&gt;your&lt;/em&gt; responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe &amp;ndash; as they &lt;em&gt;assume&lt;/em&gt; your value is non-nil, even though assigning nil is valid.</source>
          <target state="translated">Estas variables est&amp;aacute;n dise&amp;ntilde;adas para que pueda diferir su asignaci&amp;oacute;n hasta m&amp;aacute;s adelante en su c&amp;oacute;digo. Es &lt;em&gt;su&lt;/em&gt; responsabilidad asegurarse de que tengan un valor antes de acceder a ellos. Sin embargo, debido a que implican un desenvolvimiento forzado, siguen siendo inseguros por naturaleza, ya que &lt;em&gt;suponen que&lt;/em&gt; su valor no es nulo, aunque la asignaci&amp;oacute;n de nulo es v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="e2a9aff700fd23b1fa64684c86c11f3e64379b3e" translate="yes" xml:space="preserve">
          <source>Think of the following code: 
It compiles with no errors/warnings:</source>
          <target state="translated">Piensa en el siguiente código:Se compila sin advertencias de error:</target>
        </trans-unit>
        <trans-unit id="09d8ef10eee293feb35c82626771fa027ffe930b" translate="yes" xml:space="preserve">
          <source>This answer was intended to be concise, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;for full comprehension read accepted answer&lt;/a&gt;</source>
          <target state="translated">Esta respuesta pretend&amp;iacute;a ser concisa, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;para una comprensi&amp;oacute;n completa, lea la respuesta aceptada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="518b372f5b167794f9cb85ed9cffe42f1420058a" translate="yes" xml:space="preserve">
          <source>This can therefore also be used to set properties as well as call methods. For example:</source>
          <target state="translated">Por lo tanto,también puede utilizarse para establecer propiedades así como métodos de llamada.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8a756f40b006c215a6765390c6966fd17d773cb9" translate="yes" xml:space="preserve">
          <source>This crash can occur with two different kinds of force-unwrap:</source>
          <target state="translated">Este choque puede ocurrir con dos tipos diferentes de fuerza de desenvolvimiento:</target>
        </trans-unit>
        <trans-unit id="8f0250df27448e385747e9a13ccb5651fe27b21d" translate="yes" xml:space="preserve">
          <source>This is done with the &lt;code&gt;!&lt;/code&gt; operator on an optional. For example:</source>
          <target state="translated">Esto se hace con el &lt;code&gt;!&lt;/code&gt; operador de forma opcional. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e414f3b50562e4d895870d8df98dbad24cb92fae" translate="yes" xml:space="preserve">
          <source>This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">Este es un comentario m&amp;aacute;s importante y por eso las opciones impl&amp;iacute;citamente desenvueltas pueden ser enga&amp;ntilde;osas cuando se trata de depurar valores &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb38c500378f3659b7d36d8d3cb7a2ed2377409" translate="yes" xml:space="preserve">
          <source>This question comes up &lt;strong&gt;ALL THE TIME&lt;/strong&gt; on SO. It's one of the first things that new Swift developers struggle with.</source>
          <target state="translated">Esta pregunta surge &lt;strong&gt;TODO EL TIEMPO&lt;/strong&gt; en SO. Es una de las primeras cosas con las que luchan los nuevos desarrolladores de Swift.</target>
        </trans-unit>
        <trans-unit id="fe5ac8dc15cee70308d149380af17fd09b2dcd0b" translate="yes" xml:space="preserve">
          <source>This time the code has been made more clear to you. You can rationalize and think that likely it's the &lt;code&gt;address&lt;/code&gt; parameter that was forcefully unwrapped.</source>
          <target state="translated">Esta vez, el c&amp;oacute;digo se te ha dejado m&amp;aacute;s claro. Puede racionalizar y pensar que probablemente es el par&amp;aacute;metro de &lt;code&gt;address&lt;/code&gt; que se desenvolvi&amp;oacute; con fuerza.</target>
        </trans-unit>
        <trans-unit id="f93b94e3333c14bc5a8e2daea487de2fd080c3a5" translate="yes" xml:space="preserve">
          <source>This will define a &lt;code&gt;number&lt;/code&gt; constant of &lt;code&gt;Int&lt;/code&gt; type, that will either contain the value of &lt;code&gt;anOptionalInt&lt;/code&gt;, if it contains a value, or &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">Esto definir&amp;aacute; una constante de &lt;code&gt;number&lt;/code&gt; de tipo &lt;code&gt;Int&lt;/code&gt; , que contendr&amp;aacute; el valor de &lt;code&gt;anOptionalInt&lt;/code&gt; , si contiene un valor, o &lt;code&gt;0&lt;/code&gt; en caso contrario.</target>
        </trans-unit>
        <trans-unit id="36079ad7315babb9e3cfd31e04a6700ff9a65fd1" translate="yes" xml:space="preserve">
          <source>Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)</source>
          <target state="translated">Por lo tanto,debes tener mucho cuidado con los opcionales implícitos que no están envueltos.(y tal vez incluso evitarlos completamente hasta que tengas una sólida comprensión de los opcionales.)</target>
        </trans-unit>
        <trans-unit id="bf4f5d672e4353189b2590d59428129d4a05faa6" translate="yes" xml:space="preserve">
          <source>Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.</source>
          <target state="translated">Salidas no conectadas,o aún no conectadas.Este es un caso particular del escenario #3.Básicamente tienes una clase cargada de XIB que quieres usar.</target>
        </trans-unit>
        <trans-unit id="7fbb993222752244a9f031c8c1d545ed152b2357" translate="yes" xml:space="preserve">
          <source>Unless you really &lt;strong&gt;do&lt;/strong&gt; know what you are doing, avoid the &quot;!&quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.</source>
          <target state="translated">A menos que realmente sepa lo que est&amp;aacute; haciendo, evite el &quot;!&quot; forzar al operador de desenvolver. Es probablemente la mayor fuente de accidentes para los programadores principiantes de Swift.</target>
        </trans-unit>
        <trans-unit id="af66b528b3a5e4db51aa7414b4854d62642ea64a" translate="yes" xml:space="preserve">
          <source>Unwrap optional variable using &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;guard let&lt;/code&gt;</source>
          <target state="translated">Desenvuelva la variable opcional usando &lt;code&gt;if let&lt;/code&gt; o &lt;code&gt;guard let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd4b5387dfce9931cda3017dc45ec2e24c2238c6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try&lt;/code&gt; this way is the proper way to try, catch and handle errors coming from throwing functions.</source>
          <target state="translated">Usar &lt;code&gt;try&lt;/code&gt; de esta manera es la forma correcta de probar, capturar y manejar errores provenientes de funciones de lanzamiento.</target>
        </trans-unit>
        <trans-unit id="da6d8e9893a791f4319490b2d723d4806a84568f" translate="yes" xml:space="preserve">
          <source>Values coming from Objective-C, and that don't have nullability annotations. Let's assume we have the following Objective-C class:</source>
          <target state="translated">Valores que vienen del Objetivo-C,y que no tienen anotaciones de anulabilidad.Supongamos que tenemos la siguiente clase de Objetivo-C:</target>
        </trans-unit>
        <trans-unit id="9d11739af047f16216d738c322733a87037f743f" translate="yes" xml:space="preserve">
          <source>What does “Fatal error: Unexpectedly found nil while unwrapping an Optional value” mean</source>
          <target state="translated">¿Qué significa &quot;Error fatal:Inesperadamente encontrado nulo al desenvolver un valor opcional&quot; significa</target>
        </trans-unit>
        <trans-unit id="5e6a210b7a4319c69606343ec4904762d1eff5e8" translate="yes" xml:space="preserve">
          <source>What this does is first check that the optional contains a value. If it &lt;em&gt;does&lt;/em&gt;, then the &amp;lsquo;unwrapped&amp;rsquo; value is assigned to  a new variable (&lt;code&gt;number&lt;/code&gt;) &amp;ndash; which you can then freely use as if it were non-optional. If the optional &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; contain a value, then the else clause will be invoked, as you would expect.</source>
          <target state="translated">Lo que esto hace es comprobar primero que el opcional contiene un valor. Si lo &lt;em&gt;hace&lt;/em&gt; , el valor 'sin envolver' se asigna a una nueva variable ( &lt;code&gt;number&lt;/code&gt; ), que luego puede usar libremente como si no fuera opcional. Si el opcional &lt;em&gt;no&lt;/em&gt; contiene un valor, se invocar&amp;aacute; la cl&amp;aacute;usula else, como era de esperar.</target>
        </trans-unit>
        <trans-unit id="10db728e68ab2e61caf6c0b29942fb92bfcc5927" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.</source>
          <target state="translated">Lo bueno de la encuadernaci&amp;oacute;n opcional es que puede desenvolver m&amp;uacute;ltiples opcionales al mismo tiempo. Simplemente puede separar las declaraciones con una coma. La declaraci&amp;oacute;n tendr&amp;aacute; &amp;eacute;xito si todas las opciones se desenvolvieran.</target>
        </trans-unit>
        <trans-unit id="1373ba269d2cc3b83a01653ae7e2e71286d08529" translate="yes" xml:space="preserve">
          <source>When should I ever force unwrap an Optional?</source>
          <target state="translated">¿Cuándo debería forzar a desenvolver un Opcional?</target>
        </trans-unit>
        <trans-unit id="317e17e5c488981811996349a91cb8951d0d1759" translate="yes" xml:space="preserve">
          <source>When to use and when not to use implicitly unwrapped optionals</source>
          <target state="translated">Cuándo usar y cuándo no usar los opcionales implícitamente desenvueltos</target>
        </trans-unit>
        <trans-unit id="1f3a4ea673b0a5e8dc1d2d64df7cf20d096e7fe0" translate="yes" xml:space="preserve">
          <source>Whether you use an if or guard statement completely depends on whether any future code &lt;em&gt;requires&lt;/em&gt; the optional to contain a value.</source>
          <target state="translated">Si usa una declaraci&amp;oacute;n if o guard depende completamente de si alg&amp;uacute;n c&amp;oacute;digo futuro &lt;em&gt;requiere que&lt;/em&gt; lo opcional contenga un valor.</target>
        </trans-unit>
        <trans-unit id="c54b591d9a12bd724553adb14722d899feefcb1f" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;may&lt;/em&gt; be an occasion where you can use force unwrapping, as you know for a &lt;em&gt;fact&lt;/em&gt; that an optional contains a value &amp;ndash; there is not a &lt;em&gt;single&lt;/em&gt; place where you cannot safely unwrap that optional instead.</source>
          <target state="translated">Si bien &lt;em&gt;puede&lt;/em&gt; haber una ocasi&amp;oacute;n en la que pueda usar el desenvolvimiento forzado, como sabe con certeza que un opcional contiene un valor, no hay un &lt;em&gt;solo&lt;/em&gt; lugar donde no pueda desenvolver ese opcional de manera segura.</target>
        </trans-unit>
        <trans-unit id="87bd0f61bb6e6865c8ad7d95e74d3227791bcb36" translate="yes" xml:space="preserve">
          <source>Why did I get &amp;ldquo;&lt;em&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;&amp;rdquo;?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; recib&amp;iacute; &quot; &lt;em&gt;error fatal: inesperadamente encontrado nulo al desenvolver un valor opcional&lt;/em&gt; &quot;?</target>
        </trans-unit>
        <trans-unit id="4ed62fc8759885174a5e1c44082b865686115a7c" translate="yes" xml:space="preserve">
          <source>Will crash on reference to foo's capitalizedString property even though we're not force-unwrapping foo. the print looks fine, but it's not.</source>
          <target state="translated">Se estrellará en referencia a la propiedad de cuerdas capitalizadas de Foo aunque no estamos desenvolviendo Foo a la fuerza.La huella se ve bien,pero no lo es.</target>
        </trans-unit>
        <trans-unit id="e425b6ac11a3cf5713fb75b070bc494a5c64679e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;very few exceptions&lt;/a&gt;, this rule is golden:</source>
          <target state="translated">Con &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;muy pocas excepciones&lt;/a&gt; , esta regla es dorada:</target>
        </trans-unit>
        <trans-unit id="c496ef8337514f41cb37fdccdcb7d50ad577dff9" translate="yes" xml:space="preserve">
          <source>Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.</source>
          <target state="translated">Xcode te mostrará el choque resaltando una línea de código.El problema ocurre en esta línea.</target>
        </trans-unit>
        <trans-unit id="839c55483e3111c1ca07f84d7891a2c9b7b1beae" translate="yes" xml:space="preserve">
          <source>Yet at runtime it gives the following error: &lt;em&gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;</source>
          <target state="translated">Sin embargo, en tiempo de ejecuci&amp;oacute;n da el siguiente error: &lt;em&gt;Error fatal: se encontr&amp;oacute; inesperadamente nulo al desenvolver un valor opcional&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e9ce0757b971a4c196d317850c0dbdf450d7e30" translate="yes" xml:space="preserve">
          <source>You can also declare &lt;code&gt;error&lt;/code&gt; yourself, it has the advantage of being able to cast it to a useful format, for example:</source>
          <target state="translated">Tambi&amp;eacute;n puede declarar el &lt;code&gt;error&lt;/code&gt; usted mismo, tiene la ventaja de poder transmitirlo a un formato &amp;uacute;til, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1350d18d0403c656c2c06ac9d6b05eba79938d9b" translate="yes" xml:space="preserve">
          <source>You can use &quot;optional binding&quot; or &quot;if let&quot; to say &quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement&quot;.</source>
          <target state="translated">Puedes usar &quot;vinculante opcional&quot; o &quot;si se permite&quot; para decir &quot;si este opcional contiene un valor,guarda ese valor en una nueva variable no opcional&quot;.Si la opcional no contiene un valor,salta el cuerpo de esta declaración if&quot;.</target>
        </trans-unit>
        <trans-unit id="5d1b249ef279beb59a5d567f45b0c019278cedef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;Optional Chaining&lt;/a&gt; in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a &lt;code&gt;?&lt;/code&gt; when using it.</source>
          <target state="translated">Puede usar el &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;encadenamiento opcional&lt;/a&gt; para llamar a un m&amp;eacute;todo o acceder a una propiedad en un opcional. Esto se hace simplemente sufijando el nombre de la variable con un &lt;code&gt;?&lt;/code&gt; al usarlo</target>
        </trans-unit>
        <trans-unit id="aaff60ab9a0fe1d4638638d4410b990a62bde2cf" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;if let ...&lt;/code&gt; or &lt;code&gt;guard let ... else&lt;/code&gt; and so on.</source>
          <target state="translated">Puede usar &lt;code&gt;if let ...&lt;/code&gt; o &lt;code&gt;guard let ... else&lt;/code&gt; y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="5d9ba10c8d2d8d6b1b597f11d55cc435237669ae" translate="yes" xml:space="preserve">
          <source>You can't!</source>
          <target state="translated">No se puede.</target>
        </trans-unit>
        <trans-unit id="6ec1cc83396860fe0f710055f9d7e89e1c8bc165" translate="yes" xml:space="preserve">
          <source>You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.</source>
          <target state="translated">También se podría utilizar el manejo de errores de truco o de guardia,pero generalmente una de las otras técnicas anteriores es más limpia.</target>
        </trans-unit>
        <trans-unit id="c4dc5e8cd9f1e69573167fc61cd53e581b19c500" translate="yes" xml:space="preserve">
          <source>You put a question mark after the type when you declare a variable to mean (type x, or no value).</source>
          <target state="translated">Pones un signo de interrogación después del tipo cuando declaras una variable como media (tipo x,o sin valor).</target>
        </trans-unit>
        <trans-unit id="bf8513637bc93a619e697f6a9595807f32954dc5" translate="yes" xml:space="preserve">
          <source>You should also learn about how &lt;strong&gt;Optionals&lt;/strong&gt; work, mentioned in other answers, but this is the only time that mostly appears to me.</source>
          <target state="translated">Tambi&amp;eacute;n debe aprender c&amp;oacute;mo funcionan los &lt;strong&gt;opcionales&lt;/strong&gt; , mencionados en otras respuestas, pero esta es la &amp;uacute;nica vez que me parece mayormente.</target>
        </trans-unit>
        <trans-unit id="af1087f6530251ae6d010a9f21750da1ea79e979" translate="yes" xml:space="preserve">
          <source>You should only be using implicitly unwrapped optionals as a &lt;em&gt;last resort&lt;/em&gt;. If you can use a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;lazy variable&lt;/a&gt;, or provide a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;default value&lt;/a&gt; for a variable &amp;ndash; you should do so instead of using an implicitly unwrapped optional.</source>
          <target state="translated">Solo debe utilizar opciones opcionales impl&amp;iacute;citamente sin envolver como &lt;em&gt;&amp;uacute;ltimo recurso&lt;/em&gt; . Si puede usar una &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;variable diferida&lt;/a&gt; o proporcionar un &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;valor predeterminado&lt;/a&gt; para una variable, debe hacerlo en lugar de usar una opci&amp;oacute;n impl&amp;iacute;cita sin envolver.</target>
        </trans-unit>
        <trans-unit id="94f331b5b5c0ba72a4cfb9cf99bdd31fd6ae82d0" translate="yes" xml:space="preserve">
          <source>add this code in ViewDidLoad() at mainVC.</source>
          <target state="translated">añade este código en ViewDidLoad()en mainVC.</target>
        </trans-unit>
        <trans-unit id="7f66728a6d981314d1e4ec43c0a4f6c970120d38" translate="yes" xml:space="preserve">
          <source>forced (down)casts:</source>
          <target state="translated">...yesos forzados:</target>
        </trans-unit>
        <trans-unit id="fad23c2241f2181a2dba20635bf0879e56728e33" translate="yes" xml:space="preserve">
          <source>forced unwraps:</source>
          <target state="translated">...se desenvuelve a la fuerza:</target>
        </trans-unit>
        <trans-unit id="958603fb1a0a0dac8fad299a6be3fb83ef2ce3f9" translate="yes" xml:space="preserve">
          <source>while clicking to show the definition, where you might find the optional type.</source>
          <target state="translated">mientras hace clic para mostrar la definición,donde puede encontrar el tipo opcional.</target>
        </trans-unit>
        <trans-unit id="4e8e6ff2989841893307b09e3c62d4b5ade13d31" translate="yes" xml:space="preserve">
          <source>⌥</source>
          <target state="translated">⌥</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
