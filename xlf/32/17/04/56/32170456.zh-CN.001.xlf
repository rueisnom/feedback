<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/32170456">
    <body>
      <group id="32170456">
        <trans-unit id="d3a244fb54042f2dbf42e3fe5fb600311a47bd44" translate="yes" xml:space="preserve">
          <source>1. Explicit Force Unwrapping</source>
          <target state="translated">1.明确的力的解套</target>
        </trans-unit>
        <trans-unit id="635c6e54ef549bf1619585c9acdb06d314adaf23" translate="yes" xml:space="preserve">
          <source>2. Implicitly Unwrapped Optionals</source>
          <target state="translated">2.隐含的解套选择题</target>
        </trans-unit>
        <trans-unit id="18d21910bcbc1da8e1aa11e251dedd0b06352cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; has a single method called &lt;code&gt;init(nilLiteral:)&lt;/code&gt; which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with &lt;code&gt;nil&lt;/code&gt; literal.</source>
          <target state="translated">&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; 具有一个称为 &lt;code&gt;init(nilLiteral:)&lt;/code&gt; 的单一方法，该方法用nil初始化一个实例。 通常，您不会调用此方法，并且根据swift文档，建议您每当使用 &lt;code&gt;nil&lt;/code&gt; 文字量初始化Optional类型时，就不建议直接调用此初始化方法，因为编译器会调用它。</target>
        </trans-unit>
        <trans-unit id="5a9772727897bd3ca247cb46b7f9cb451241ee24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works similarly to &lt;code&gt;map&lt;/code&gt;, except it allows you to return &lt;em&gt;another&lt;/em&gt; optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; 的工作方式与 &lt;code&gt;map&lt;/code&gt; 相似，但它允许您从闭包体内返回&lt;em&gt;另一个&lt;/em&gt;可选参数。 这意味着您可以将可选项输入到需要非可选输入的过程中，但可以输出可选项本身。</target>
        </trans-unit>
        <trans-unit id="25b1070a11e663243cc897c90af46f99c6df445c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;flatMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c46dee75d89e56932987294e4ff7e4232b363930" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You should only ever use &lt;code&gt;try!&lt;/code&gt; if you can prove that its result will never fail in your context - and this is very rare.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;您只能使用 &lt;code&gt;try!&lt;/code&gt; &lt;/em&gt; &lt;em&gt;如果您可以证明其结果在您的情况下永远不会失败-这是非常罕见的。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b7730d90c9b2349ff66ee31e8785e67ba52fb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you now tell me which object it is that was &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您现在能告诉我那是哪个对象是 &lt;code&gt;nil&lt;/code&gt; 吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37a5bcf391e8ccb209c28d5fceb142b218d5b019" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you tell me which object is &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;你能告诉我哪个对象是 &lt;code&gt;nil&lt;/code&gt; 吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f283be4efc0664716ddd69d9cdc7df0c17dbd693" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that this &lt;code&gt;nil&lt;/code&gt; is not the same as the &lt;code&gt;nil&lt;/code&gt; in Objective-C. In Objective-C, &lt;code&gt;nil&lt;/code&gt; is the absence of a valid &lt;em&gt;object pointer&lt;/em&gt;; in Swift, Optionals are not restricted to objects/reference types. Optional behaves similarly to Haskell's &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Maybe&lt;/a&gt;.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（请注意，此 &lt;code&gt;nil&lt;/code&gt; 与Objective-C中的 &lt;code&gt;nil&lt;/code&gt; 不同 。在Objective-C中， &lt;code&gt;nil&lt;/code&gt; 是缺少有效的&lt;em&gt;对象指针&lt;/em&gt; ；在Swift中，Optionals不仅限于对象/引用类型。Optional的行为类似于Haskell的行为&lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;也许&lt;/a&gt; 。）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d516eb97f8385312f77ef9000f049aeddc35663f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that within the guard body, you &lt;strong&gt;must&lt;/strong&gt; use one of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;control transfer statements&lt;/a&gt; in order to exit the scope of the currently executing code).&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（请注意，在保护体内， &lt;strong&gt;必须&lt;/strong&gt;使用&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;控制传递语句&lt;/a&gt;之一才能退出当前正在执行的代码的范围）。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5b87ee6fe147c52e17815abd3b0ac225686bc372" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is because an optional value will return &lt;code&gt;Void?&lt;/code&gt; rather than &lt;code&gt;Void&lt;/code&gt; on a method that doesn&amp;rsquo;t return anything)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（这是因为可选值将返回 &lt;code&gt;Void?&lt;/code&gt; 而不是不返回任何内容的方法上的 &lt;code&gt;Void&lt;/code&gt; ）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8d73db717d8e4390f76c6acdf864843b513507e2" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is similar behaviour to sending messages to &lt;code&gt;nil&lt;/code&gt; in Objective-C)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（这类似于在Objective-C中将消息发送到 &lt;code&gt;nil&lt;/code&gt; 的行为）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8404a61e69301e260a8bda1a58f0ce7110e7cc50" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This answer is &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;community wiki&lt;/a&gt;. If you feel it could be made better, feel free to &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit it&lt;/a&gt;!&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;这个答案是&lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;社区维基&lt;/a&gt; 。&lt;/sup&gt; &lt;sup&gt;如果您觉得可以做得更好，请随时对其进行&lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;编辑&lt;/a&gt; ！&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d92a649ecca38db770e2ea85dae9072443b3c79f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit&lt;/a&gt; the existing wiki answer.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;这篇文章旨在收集&amp;ldquo;意外发现零&amp;rdquo;问题的答案，以使它们不会分散且很难找到。&lt;/sup&gt; &lt;sup&gt;随意添加您自己的答案或&lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;编辑&lt;/a&gt;现有的Wiki答案。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eae132614e41cb087afb2d1c01f40480f4698746" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;guard statement&lt;/a&gt; allows you to define a condition for success &amp;ndash; and the current scope will only continue executing if that condition is met. They are defined with the syntax &lt;code&gt;guard condition else {...}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;保护性语句&lt;/a&gt;使您可以定义成功的条件-只有满足该条件，当前作用域才会继续执行。 它们用语法 &lt;code&gt;guard condition else {...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dd03209df27cf5183ea0c4aad3e184b5a067c77" translate="yes" xml:space="preserve">
          <source>According to swift, 'nil' is the absence of value.
And to create an instance initialized with &lt;code&gt;nil&lt;/code&gt; We have to conform to a protocol called &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and great if you guessed it, only &lt;code&gt;Optionals&lt;/code&gt; conform to &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and conforming to other types is discouraged.</source>
          <target state="translated">根据斯威夫特的说法，&amp;ldquo;零&amp;rdquo;是价值的缺失。 并创建一个以 &lt;code&gt;nil&lt;/code&gt; 初始化的实例，我们必须遵守一个称为 &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; 的协议，如果您猜对了，那就太好了，只有 &lt;code&gt;Optionals&lt;/code&gt; 符合 &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; 并且不鼓励与其他类型兼容。</target>
        </trans-unit>
        <trans-unit id="45073dbf8f3ef81afe07094beb4f6608a541d353" translate="yes" xml:space="preserve">
          <source>Again, because &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are optional, the value returned from &lt;code&gt;qux&lt;/code&gt; will always be an optional regardless of whether &lt;code&gt;qux&lt;/code&gt; itself is optional.</source>
          <target state="translated">同样，由于 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 是可选的，因此无论 &lt;code&gt;qux&lt;/code&gt; 本身是否可选，从 &lt;code&gt;qux&lt;/code&gt; 返回的值始终是可选的。</target>
        </trans-unit>
        <trans-unit id="04b74eddaac2e0ff122721a98735cd4f4241cab6" translate="yes" xml:space="preserve">
          <source>Again, nothing bad will happen here if &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Your code will simply continue executing.</source>
          <target state="translated">同样，如果 &lt;code&gt;foo&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ,那么这里也不会发生任何不好的事情。 您的代码将继续执行。</target>
        </trans-unit>
        <trans-unit id="9e19419202a958c9e2c652dec63d96656df38091" translate="yes" xml:space="preserve">
          <source>Also, as the name suggests, you can &amp;lsquo;chain&amp;rsquo; these statements together. This means that if &lt;code&gt;foo&lt;/code&gt; has an optional property &lt;code&gt;baz&lt;/code&gt;, which has a property &lt;code&gt;qux&lt;/code&gt; &amp;ndash; you could write the following:</source>
          <target state="translated">同样，顾名思义，您可以将这些语句&amp;ldquo;链接&amp;rdquo;在一起。 这意味着，如果 &lt;code&gt;foo&lt;/code&gt; 具有可选属性 &lt;code&gt;baz&lt;/code&gt; ，而该属性具有属性 &lt;code&gt;qux&lt;/code&gt; ，则可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="3231de44e5b6f036b78301686d6ee18d12703f6b" translate="yes" xml:space="preserve">
          <source>Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:</source>
          <target state="translated">另外,你也可以使用一个守护语句,如果变量为nil,可以让你退出你的函数。</target>
        </trans-unit>
        <trans-unit id="5df38dfc408955dbdd3d7167930749d99834f562" translate="yes" xml:space="preserve">
          <source>An often underused feature with optionals is the ability to use the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesn&amp;rsquo;t have a value, it will remain &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">可选功能经常使用不足的功能是可以使用 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;flatMap&lt;/code&gt; 函数。 这些允许您将非可选转换应用于可选变量。 如果可选值具有值，则可以对其应用给定的转换。 如果没有值，它将保持 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7475dbf59ea659fe38624a59d7089f9c937ce515" translate="yes" xml:space="preserve">
          <source>An optional is actually a container than contains either a variable of a given type, or nothing.</source>
          <target state="translated">可选项实际上是一个容器,它既可以包含一个给定类型的变量,也可以不包含任何变量。</target>
        </trans-unit>
        <trans-unit id="3c0e7f41650898afdecfa4b26246b1d90eee328c" translate="yes" xml:space="preserve">
          <source>An optional needs to be &quot;unwrapped&quot; in order to fetch the value inside.</source>
          <target state="translated">可选项需要被 &quot;解封&quot;,以便获取里面的值。</target>
        </trans-unit>
        <trans-unit id="d26f01d2167b0ccd73f5ca8a245ba70fa537337b" translate="yes" xml:space="preserve">
          <source>And Optional type is nothing but an enumeration with two cases, i.e</source>
          <target state="translated">而Optional类型不过是一个枚举,有两种情况,即</target>
        </trans-unit>
        <trans-unit id="0c9267177db8f82598d60f708a0d70d575d72d06" translate="yes" xml:space="preserve">
          <source>Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.</source>
          <target state="translated">另一个巧妙的技巧是,你还可以用逗号来检查值上的某个条件,在解开后,也可以用逗号来检查。</target>
        </trans-unit>
        <trans-unit id="6ddb885b2b01e4ba63f81165812deb39af75a71c" translate="yes" xml:space="preserve">
          <source>Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">可选链接允许您执行的另一种巧妙技巧是检查设置属性或调用方法是否成功。 您可以通过将返回值与 &lt;code&gt;nil&lt;/code&gt; 进行比较来做到这一点。</target>
        </trans-unit>
        <trans-unit id="32470d176ca6dd8f034dc5807b14e045ee20d3c6" translate="yes" xml:space="preserve">
          <source>Another way to declare an optional variable is</source>
          <target state="translated">另一种声明可选变量的方法是</target>
        </trans-unit>
        <trans-unit id="443f7eb7f273a4e9c8d9c7fa2251a9bd082d81a0" translate="yes" xml:space="preserve">
          <source>Another, slightly more subtle gotcha with optionals is &quot;implicitly unwrapped optionals. When we declare foo, we could say:</source>
          <target state="translated">另一个稍显微妙的问题是 &quot;隐含的未封装的 optionals&quot;。当我们声明foo时,我们可以这样说。</target>
        </trans-unit>
        <trans-unit id="52474acee09818b60266e64bb250148f3409b9d7" translate="yes" xml:space="preserve">
          <source>Apple documentation on Swift Optionals</source>
          <target state="translated">关于Swift Optionals的苹果文档</target>
        </trans-unit>
        <trans-unit id="515515b53e442d6c0ac9c382069d83edc146839b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;anOptionalString&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; here, you will get a crash on the line where you force unwrap it.</source>
          <target state="translated">由于 &lt;code&gt;anOptionalString&lt;/code&gt; 在此处为 &lt;code&gt;nil&lt;/code&gt; ，因此在您强制展开它的行上会导致崩溃。</target>
        </trans-unit>
        <trans-unit id="6401b89cf6e7b504f6a51a78043447e304db2acc" translate="yes" xml:space="preserve">
          <source>As a general rule, you should never explicitly force unwrap an optional with the &lt;code&gt;!&lt;/code&gt; operator. There may be cases where using &lt;code&gt;!&lt;/code&gt; is acceptable &amp;ndash; but you should only ever be using it if you are 100% sure that the optional contains a value.</source>
          <target state="translated">通常，永远不要用 &lt;code&gt;!&lt;/code&gt; 显式强行打开可选选项。 操作员。 在某些情况下，可能会使用 &lt;code&gt;!&lt;/code&gt; 是可以接受的-但只有在100％确定可选值包含一个值的情况下，才应使用它。</target>
        </trans-unit>
        <trans-unit id="e63c2b6a3158f2d5901a2d116e700ecadd6e8ac7" translate="yes" xml:space="preserve">
          <source>Avoid use of &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">避免使用 &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="48ec3975808ef63d21f693479b688b665f317562" translate="yes" xml:space="preserve">
          <source>Background: What&amp;rsquo;s an Optional?</source>
          <target state="translated">背景：什么是可选的？</target>
        </trans-unit>
        <trans-unit id="000712677e846810968631694b8782eea505d28e" translate="yes" xml:space="preserve">
          <source>Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.</source>
          <target state="translated">基本上,你试图在Swift只允许非零值的地方使用nil值,方法是告诉编译器相信你,那里永远不会有nil值,从而允许你的应用程序编译。</target>
        </trans-unit>
        <trans-unit id="6510cebf85c73b91f042a999279b8ecb4a6cfde5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;stringByAppendingString&lt;/code&gt; takes a non-optional string argument, we cannot input our optional string directly. However, by using &lt;code&gt;map&lt;/code&gt;, we can use allow &lt;code&gt;stringByAppendingString&lt;/code&gt; to be used if &lt;code&gt;anOptionalString&lt;/code&gt; has a value.</source>
          <target state="translated">由于 &lt;code&gt;stringByAppendingString&lt;/code&gt; 采用非可选字符串参数，因此我们无法直接输入可选字符串。 但是，通过使用 &lt;code&gt;map&lt;/code&gt; ，如果 &lt;code&gt;anOptionalString&lt;/code&gt; 具有值，我们可以使用allow &lt;code&gt;stringByAppendingString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3981488e6abb1cb399b600a4e20bcc5f6c58686a" translate="yes" xml:space="preserve">
          <source>Bottom line: When you are first learning Swift, pretend the &quot;!&quot; character is not part of the language. It's likely to get you into trouble.</source>
          <target state="translated">底线:&quot;!当你刚开始学习Swift时,假装&quot;!&quot;字符不是语言的一部分。这很可能会给你带来麻烦。</target>
        </trans-unit>
        <trans-unit id="270c4892a016f64b1f29e7cd37c444a555dc7d7d" translate="yes" xml:space="preserve">
          <source>But Swift's error handling system also provides a way to &quot;force try&quot; with &lt;code&gt;try!&lt;/code&gt;:</source>
          <target state="translated">但是Swift的错误处理系统还提供了一种通过try来&amp;ldquo;强制尝试&amp;rdquo;的方法 &lt;code&gt;try!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8e2f129952b7df6d9c9137de5fc26c084032ef61" translate="yes" xml:space="preserve">
          <source>By applying the &lt;code&gt;map&lt;/code&gt; function to it &amp;ndash; we can use the &lt;code&gt;stringByAppendingString&lt;/code&gt; function in order to concatenate it to another string.</source>
          <target state="translated">通过将 &lt;code&gt;map&lt;/code&gt; 函数应用于该函数，我们可以使用 &lt;code&gt;stringByAppendingString&lt;/code&gt; 函数将其连接到另一个字符串。</target>
        </trans-unit>
        <trans-unit id="890392cd814cb51a3ec19620be5a911041086aa9" translate="yes" xml:space="preserve">
          <source>Declare variable optional (&lt;code&gt;?&lt;/code&gt;), not implicitly unwrapped optionals (IUO) (&lt;code&gt;!&lt;/code&gt;)</source>
          <target state="translated">声明变量optional（ &lt;code&gt;?&lt;/code&gt; ），而不是隐式解包的optional（IUO）（ &lt;code&gt;!&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2259c1bef40d9a2d2466c01f96f672a698d0443" translate="yes" xml:space="preserve">
          <source>Destination Controller:</source>
          <target state="translated">目的地控制器。</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="202b26ba321fbfe7f81ed7bbc6b02aef082dc6be" translate="yes" xml:space="preserve">
          <source>Either unwrap variable like this:</source>
          <target state="translated">要不就是这样的解包变量。</target>
        </trans-unit>
        <trans-unit id="ca0a491616073f375fc6c16bc6cdb928b2718880" translate="yes" xml:space="preserve">
          <source>Even myself has to wrap (no pun intended) my head around Optionals :D
&lt;em&gt;Happy Swfting All&lt;/em&gt;.</source>
          <target state="translated">甚至我自己也不得不把头缠住（不要双关语）。可选：D &lt;em&gt;Happy Swfting All&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e49c1f7f49b51d3c469b5d6175ea1c5c2c0403" translate="yes" xml:space="preserve">
          <source>Explicit Force Unwrapping</source>
          <target state="translated">明确的力量解套</target>
        </trans-unit>
        <trans-unit id="7e9c689c33f3c0bb551be00e08e8e196af6dd530" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while &lt;strong&gt;implicitly&lt;/strong&gt; unwrapping an Optional value</source>
          <target state="translated">致命错误：意外发现nil，同时&lt;strong&gt;隐式&lt;/strong&gt;展开Optional值</target>
        </trans-unit>
        <trans-unit id="63b2f6bd19b28c7b1987bcb9dd32336331c79410" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</source>
          <target state="translated">致命的错误。在隐式解压一个可选值时意外地发现nil</target>
        </trans-unit>
        <trans-unit id="5ee449f8148453a77ee10bc85af161a2bf6904d0" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while unwrapping an Optional value</source>
          <target state="translated">致命的错误。错误:在解开可选值时意外地发现nil。</target>
        </trans-unit>
        <trans-unit id="5c2c4179c8fff9ca83b586e12a580e908e386c5c" translate="yes" xml:space="preserve">
          <source>First, you should know what an Optional value is.
You can step to &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;The Swift Programming Language&lt;/a&gt; for detail.</source>
          <target state="translated">首先，您应该知道什么是可选值。 您可以转到&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;Swift编程语言&lt;/a&gt;以获取详细信息。</target>
        </trans-unit>
        <trans-unit id="fe3fb55243316c9dc924d99b807f5717582eeb12" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have an optional string:</source>
          <target state="translated">例如，假设您有一个可选的字符串：</target>
        </trans-unit>
        <trans-unit id="8bd561982c688335d8305fd365ca075aba1100cc" translate="yes" xml:space="preserve">
          <source>For example, say we have a variable &lt;code&gt;foo&lt;/code&gt;, of type an optional &lt;code&gt;Foo&lt;/code&gt; instance.</source>
          <target state="translated">例如，假设我们有一个变量 &lt;code&gt;foo&lt;/code&gt; ，其类型为可选的 &lt;code&gt;Foo&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="4fe78f7c529115814a0589403fb98c66ea73e508" translate="yes" xml:space="preserve">
          <source>Guard statements were added in Swift 2. Guard lets you preserve the &quot;golden path&quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using &quot;if let&quot; optional binding.</source>
          <target state="translated">在 Swift 2 中加入了 Guard 语句。Guard 可以让你在代码中保留 &quot;黄金路径&quot;,并避免有时因使用 &quot;if let &quot;可选绑定而导致嵌套的ifs越来越多。</target>
        </trans-unit>
        <trans-unit id="93edce2bfc57c7c54e7fd4b314121e6beb589d57" translate="yes" xml:space="preserve">
          <source>Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">警卫队还支持if语句支持的相同技巧，例如同时展开多个可选对象并使用 &lt;code&gt;where&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="ad08562b159908e3b05f037b3e013647aba536b4" translate="yes" xml:space="preserve">
          <source>Hence it's better to write as such:</source>
          <target state="translated">因此,还是写成这样比较好。</target>
        </trans-unit>
        <trans-unit id="fd4007c3ff26895e5bb5fb48507590600d2502eb" translate="yes" xml:space="preserve">
          <source>Here by force casting you tell the compiler to no longer worry, as you'll always have a &lt;code&gt;Rectangle&lt;/code&gt; instance there. And as long as that holds, you don't have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.</source>
          <target state="translated">在这里，通过强制转换可以使编译器不再担心，因为您将始终在其中拥有 &lt;code&gt;Rectangle&lt;/code&gt; 实例。 只要这样，您就不必担心。 当您或您的同事从项目开始循环非矩形值时，问题就开始了。</target>
        </trans-unit>
        <trans-unit id="a10432c3dfc4ac875e419233a429110d852331d9" translate="yes" xml:space="preserve">
          <source>Here is an example of optional binding with our &lt;code&gt;foo&lt;/code&gt; optional:</source>
          <target state="translated">这是我们的 &lt;code&gt;foo&lt;/code&gt; 可选的可选绑定的示例：</target>
        </trans-unit>
        <trans-unit id="f1995e5026962d6c02dca7e583fc61ef9cd31d6c" translate="yes" xml:space="preserve">
          <source>How can I safely deal with Optionals?</source>
          <target state="translated">如何才能安全地处理Optionals?</target>
        </trans-unit>
        <trans-unit id="e484fea1c47d9e20459264fe14e22be925d72d1b" translate="yes" xml:space="preserve">
          <source>How to deal with optionals:</source>
          <target state="translated">如何处理好期权的问题。</target>
        </trans-unit>
        <trans-unit id="8633d1988d44234fa26b09689d230a24a81c00ff" translate="yes" xml:space="preserve">
          <source>However, 99.9% of the time when working with optionals, you&amp;rsquo;ll actually want to access the value it contains, if it contains one at all. To do this, you can use &lt;em&gt;Optional Binding&lt;/em&gt;.</source>
          <target state="translated">但是，使用可选选项时，实际上99.9％的时间都需要访问它包含的值（如果它包含一个值）。 为此，您可以使用&lt;em&gt;Optional Binding&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bcd13ba1c830e1eb8ee339d08e57ceccdcf9a16" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;anOptionalString&lt;/code&gt; doesn&amp;rsquo;t have a value, &lt;code&gt;map&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">但是，如果 &lt;code&gt;anOptionalString&lt;/code&gt; 没有值，则 &lt;code&gt;map&lt;/code&gt; 将返回 &lt;code&gt;nil&lt;/code&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="a00cf22dac7a818231c0ff4ab31cff56b029afeb" translate="yes" xml:space="preserve">
          <source>However, there are a &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;few scenarios where implicitly unwrapped optionals are beneficial&lt;/a&gt;, and you are still able to use various ways of safely unwrapping them as listed below &amp;ndash; but you should &lt;em&gt;always&lt;/em&gt; use them with due caution.</source>
          <target state="translated">但是，在某些&lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;情况下，隐式展开的可选内容是有好处的&lt;/a&gt; ，并且您仍然可以使用下面列出的各种方式来安全地展开它们，但&lt;em&gt;始终&lt;/em&gt;应谨慎使用。</target>
        </trans-unit>
        <trans-unit id="045cfcd48cc9a7581c9554c6d0db82a58d3a86d5" translate="yes" xml:space="preserve">
          <source>However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because &lt;code&gt;foo&lt;/code&gt; is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods &amp;ndash; or unwrap &lt;code&gt;foo&lt;/code&gt; itself before accessing methods or calling methods that return values.</source>
          <target state="translated">但是，在尝试访问属性或调用返回值的方法时，事情变得有些棘手。 因为 &lt;code&gt;foo&lt;/code&gt; 是可选的，所以从它返回的任何内容也将是可选的。 为了解决这个问题，您可以解开使用上述方法之一返回的可选选项&amp;ndash;或在访问返回值的方法或调用返回值的方法之前解开 &lt;code&gt;foo&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="8925a8490bf5fd57f3e11be4c68ec114afe4face" translate="yes" xml:space="preserve">
          <source>I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.</source>
          <target state="translated">我在做一个从表视图控制器到视图控制器的segue时遇到了这个错误,因为我忘了在主故事板中指定视图控制器的自定义类名。</target>
        </trans-unit>
        <trans-unit id="961d19ccc70f1d74e0009e3c081c86736529fa59" translate="yes" xml:space="preserve">
          <source>I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:</source>
          <target state="translated">有一次,当我试图从准备segue方法中设置Outlets值时,我遇到了这样的错误,如下所示。</target>
        </trans-unit>
        <trans-unit id="c9821ba4ff1ad0757f5f86a478e8819368f2e4a1" translate="yes" xml:space="preserve">
          <source>I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn't addressed the issue itself directly.</source>
          <target state="translated">我希望这个答案能帮助到有同样问题的人,因为我发现标出的答案对理解选项和如何工作有很大的帮助,但并没有直接解决这个问题。</target>
        </trans-unit>
        <trans-unit id="687e27bcc1f747e004946e97f14c1a09937a1708" translate="yes" xml:space="preserve">
          <source>IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, &lt;em&gt;after&lt;/em&gt; initialization. You should therefore ensure that you&amp;rsquo;re not accessing outlets before they're loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be &lt;code&gt;nil&lt;/code&gt; at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.</source>
          <target state="translated">特别是IBOutlet，通常是隐式解包的可选。 这是因为初始化&lt;em&gt;后&lt;/em&gt; ，您的xib或情节提要板将在运行时链接出口。 因此，您应该确保在装入插座之前不要访问插座。还应该检查故事板/ xib文件中的连接是否正确，否则值在运行时将为 &lt;code&gt;nil&lt;/code&gt; ，因此当它们隐式崩溃时会崩溃。解开。 固定连接时，请尝试删除定义插座的代码行，然后重新连接它们。</target>
        </trans-unit>
        <trans-unit id="cbf8b026a781fcaf4a77cedd0a311b396615b39b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;anOptionalInt&lt;/code&gt; contains a value, it will be unwrapped and assigned to the new &lt;code&gt;number&lt;/code&gt; constant. The code &lt;em&gt;after&lt;/em&gt; the guard will then continue executing. If it doesn&amp;rsquo;t contain a value &amp;ndash; the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.</source>
          <target state="translated">如果 &lt;code&gt;anOptionalInt&lt;/code&gt; 包含一个值，则它将被拆开并分配给新的 &lt;code&gt;number&lt;/code&gt; 常量。 保护&lt;em&gt;后&lt;/em&gt;的代码将继续执行。 如果它不包含值，则防护程序将执行方括号内的代码，这将导致控制权的转移，因此紧随其后的代码将不会执行。</target>
        </trans-unit>
        <trans-unit id="555b9e1b03e3ef819963d13f4ad1e9cd6291d3bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;foo&lt;/code&gt; contains a value, this method will be called on it. If it doesn&amp;rsquo;t, nothing bad will happen &amp;ndash; the code will simply continue executing.</source>
          <target state="translated">如果 &lt;code&gt;foo&lt;/code&gt; 包含一个值，则将在其上调用此方法。 如果没有，则不会发生任何不好的事情-代码将继续继续执行。</target>
        </trans-unit>
        <trans-unit id="bfd5e74dcdb489bc0ac5f2ed761961f64038c09a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someThrowingFunc()&lt;/code&gt; throws an error, the error will be safely caught in the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">如果 &lt;code&gt;someThrowingFunc()&lt;/code&gt; 引发错误，该错误将被安全地捕获在 &lt;code&gt;catch&lt;/code&gt; 块中。</target>
        </trans-unit>
        <trans-unit id="d952b11c89cd854be27de0d0f65ed17e3c578f0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someVariable&lt;/code&gt; is nil, then you'll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you're guaranteeing to the compiler that you'll never have nil values there. And guess what it happens if somehow a nil value ends in in &lt;code&gt;someVariable&lt;/code&gt;?</source>
          <target state="translated">如果 &lt;code&gt;someVariable&lt;/code&gt; 为nil，则会崩溃。 通过强制解包，您将nil检查责任从编译器移到了您，基本上通过进行强制解包，您向编译器保证了那里永远不会有nil值。 并猜测如果某个nil值以 &lt;code&gt;someVariable&lt;/code&gt; 结尾会发生什么情况？</target>
        </trans-unit>
        <trans-unit id="c01ad95af312c93699d0f265e3b3b0b10e9f23a1" translate="yes" xml:space="preserve">
          <source>If we wanted to call a method on &lt;code&gt;foo&lt;/code&gt; that doesn&amp;rsquo;t return anything, we can simply do:</source>
          <target state="translated">如果我们想在 &lt;code&gt;foo&lt;/code&gt; 上调用不返回任何内容的方法，则可以简单地执行以下操作：</target>
        </trans-unit>
        <trans-unit id="78da2ff6a4b5799b4addacf92cf6d2b26fb23cc8" translate="yes" xml:space="preserve">
          <source>If you get this error in CollectionView try to create CustomCell file and Custom xib also.</source>
          <target state="translated">如果你在CollectionView中得到这个错误,请尝试创建CustomCell文件和Custom xib。</target>
        </trans-unit>
        <trans-unit id="0127a3535a0583ab1a79af7eea2befd762a366e7" translate="yes" xml:space="preserve">
          <source>Implicitly Unwrapped Optionals</source>
          <target state="translated">隐含解套的期权组合</target>
        </trans-unit>
        <trans-unit id="051898db5718d1ca1229f4edae90fa5baa7e3071" translate="yes" xml:space="preserve">
          <source>Implicitly unwrapped optionals. Let's assume you have the following class definition:</source>
          <target state="translated">隐式解包的optionals。假设你有以下类的定义。</target>
        </trans-unit>
        <trans-unit id="484536419577c05bc013ad78ac088dd3099a07ed" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;generic type&lt;/a&gt; that can contain a value (of any kind), or no value at all.</source>
          <target state="translated">在Swift中， &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;是一个&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;泛型类型&lt;/a&gt; ，可以包含一个值（任何类型），或者根本不包含任何值。</target>
        </trans-unit>
        <trans-unit id="79a7dee40b7721bf417ab75a0b14f771e29d4b3d" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;strong&gt;&lt;em&gt;any type&lt;/em&gt; can be made optional&lt;/strong&gt;. An optional value can take on any value from the original type, &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;or&lt;/em&gt;&lt;/a&gt; the special value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在Swift中， &lt;strong&gt;&lt;em&gt;任何类型&lt;/em&gt;都可以设为optional&lt;/strong&gt; 。 可选值可以采用原始类型中的任何值，也可以采用特殊值 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04774461a3612ca563f0e36ff0dbf0f0ec4fa74c" translate="yes" xml:space="preserve">
          <source>In many other programming languages, a particular &quot;sentinel&quot; value is often used to indicate a &lt;em&gt;lack of a value&lt;/em&gt;. In Objective-C, for example, &lt;code&gt;nil&lt;/code&gt; (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;null pointer&lt;/a&gt;) indicates the lack of an object. But this gets more tricky when working with primitive types &amp;mdash; should &lt;code&gt;-1&lt;/code&gt; be used to indicate the absence of an integer, or perhaps &lt;code&gt;INT_MIN&lt;/code&gt;, or some other integer? If any particular value is chosen to mean &quot;no integer&quot;, that means it can no longer be treated as a &lt;em&gt;valid&lt;/em&gt; value.</source>
          <target state="translated">在许多其他编程语言中，特定的&amp;ldquo;前哨&amp;rdquo;值通常用于指示&lt;em&gt;缺少值&lt;/em&gt; 。 例如，在Objective-C中， &lt;code&gt;nil&lt;/code&gt; （ &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;空指针&lt;/a&gt; ）指示缺少对象。 但这在处理原始类型时变得更加棘手-是否应使用 &lt;code&gt;-1&lt;/code&gt; 来指示缺少整数，或者可能 &lt;code&gt;INT_MIN&lt;/code&gt; 或其他某个整数？ 如果选择任何特定值表示&amp;ldquo;无整数&amp;rdquo;，则意味着它不再可以视为&lt;em&gt;有效值&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="46b85b18ba2133633a4afcab43ae7743b50be6e2" translate="yes" xml:space="preserve">
          <source>In order to access an optional&amp;rsquo;s value (if it has one at all), you need to &lt;strong&gt;unwrap&lt;/strong&gt; it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it &lt;em&gt;didn't&lt;/em&gt; have a value, your program will crash with the above message.</source>
          <target state="translated">为了访问可选值（如果它有一个值），您需要将其&lt;strong&gt;拆开&lt;/strong&gt; 。 可以安全或强制打开可选值。 如果强行解开一个可选值，但它&lt;em&gt;没有&lt;/em&gt;值，则程序将崩溃，并显示以上消息。</target>
        </trans-unit>
        <trans-unit id="2870a2cd345396e3c49f99168c09a7038d33fa6f" translate="yes" xml:space="preserve">
          <source>In order to work out which variable caused the crash, you can hold</source>
          <target state="translated">为了计算出是哪个变量导致的崩溃,你可以按住</target>
        </trans-unit>
        <trans-unit id="ee021373ae2b52768be006a0a1a52dc063c5b011" translate="yes" xml:space="preserve">
          <source>In other words, rather use:</source>
          <target state="translated">换句话说,宁可用。</target>
        </trans-unit>
        <trans-unit id="c40e8f1772cb4a16417b4c1962c3c56e76be0301" translate="yes" xml:space="preserve">
          <source>In that case foo is still an optional, but you don't have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it's nil.</source>
          <target state="translated">在这种情况下,foo仍然是一个可选的,但你不需要解开它来引用它。这就意味着当你试图引用foo时,如果它是nil,你就会崩溃。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="8bedbb9a541d4d033efb3e04645647ad1c32d4d3" translate="yes" xml:space="preserve">
          <source>It essentially lets you say &amp;ldquo;If &lt;code&gt;a&lt;/code&gt; contains a value, unwrap it. If it doesn&amp;rsquo;t then return &lt;code&gt;b&lt;/code&gt; instead&amp;rdquo;. For example, you could use it like this:</source>
          <target state="translated">从本质上讲，您可以说&amp;ldquo;如果 &lt;code&gt;a&lt;/code&gt; 包含一个值，则将其取消包装。 如果没有，则返回 &lt;code&gt;b&lt;/code&gt; &amp;rdquo;。 例如，您可以这样使用它：</target>
        </trans-unit>
        <trans-unit id="ad0ef45d1f8d084087d25064193cc17d964245ca" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s just shorthand for:</source>
          <target state="translated">它只是以下方面的简写：</target>
        </trans-unit>
        <trans-unit id="459fe8274d538afa06b4cd892cfc12fa3846a208" translate="yes" xml:space="preserve">
          <source>Learn how to debug an iOS app crash</source>
          <target state="translated">学习如何调试iOS应用崩溃</target>
        </trans-unit>
        <trans-unit id="aaee9b9adb35ca322a119d776bbbe533b4d1fb20" translate="yes" xml:space="preserve">
          <source>Long story short by using &lt;code&gt;var address : Address!&lt;/code&gt; you're &lt;strong&gt;hiding&lt;/strong&gt; the possibility that a variable can be &lt;code&gt;nil&lt;/code&gt; from other readers. And when it crashes you're like &quot;what the hell?! my &lt;code&gt;address&lt;/code&gt; isn't an optional, so why am I crashing?!.</source>
          <target state="translated">长话短说，使用 &lt;code&gt;var address : Address!&lt;/code&gt; 您&lt;strong&gt;隐藏&lt;/strong&gt;了其他读者看 &lt;code&gt;nil&lt;/code&gt; 变量的可能性。 当它崩溃时，您就像&amp;ldquo;到底是什么？！我的 &lt;code&gt;address&lt;/code&gt; 不是可选的，所以我为什么崩溃？！。</target>
        </trans-unit>
        <trans-unit id="78cef24b9706680cc584904b5e88b79801d759b5" translate="yes" xml:space="preserve">
          <source>Most of the time you will use the complete Do-Try-Catch system - and the optional one, &lt;code&gt;try?&lt;/code&gt;, in the rare cases where handling the error is not important.</source>
          <target state="translated">大多数时候，您将使用完整的Do-Try-Catch系统-可选系统，请 &lt;code&gt;try?&lt;/code&gt; ，在极少数情况下，处理错误并不重要。</target>
        </trans-unit>
        <trans-unit id="35e9fc497ab02ab074e552f7be54dc7f776c210a" translate="yes" xml:space="preserve">
          <source>My Swift program is crashing with &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and one of the following similar errors. What does this error mean, and how do I fix it?</source>
          <target state="translated">我的Swift程序因 &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; 和以下类似错误之一而崩溃。 此错误是什么意思，我该如何解决？</target>
        </trans-unit>
        <trans-unit id="56a078777cdf9213e116547d03f394624b748e2b" translate="yes" xml:space="preserve">
          <source>Nil Coalescing Operator</source>
          <target state="translated">无 凝聚器操作员</target>
        </trans-unit>
        <trans-unit id="9b06cd01bf313f728f850e8f6dfbc9e6120741e5" translate="yes" xml:space="preserve">
          <source>Note that the variable you define when you use optional biding only exists (is only &quot;in scope&quot;) in the body of the if statement.</source>
          <target state="translated">请注意,当你使用可选的biding时,你定义的变量只存在于if语句的正文中(只在 &quot;范围内&quot;)。</target>
        </trans-unit>
        <trans-unit id="4c10eb68d56cba105bdf477429d00aea854d4ccd" translate="yes" xml:space="preserve">
          <source>Now if no nullability annotations are specified (either explicitly or via &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt;/&lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;), then the &lt;code&gt;name&lt;/code&gt; property will be imported in Swift as &lt;code&gt;String!&lt;/code&gt; (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if &lt;code&gt;name&lt;/code&gt; is nil.</source>
          <target state="translated">现在，如果未指定可空性注释（显式或通过 &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; / &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt; ），则 &lt;code&gt;name&lt;/code&gt; 属性将在Swift中作为 &lt;code&gt;String!&lt;/code&gt; 导入！ （IUO-隐式展开的可选）。 一旦某些快速代码想要使用该值，如果 &lt;code&gt;name&lt;/code&gt; 为nil，它将崩溃。</target>
        </trans-unit>
        <trans-unit id="16ffd92502b92b7dab0de459501aee70aad84527" translate="yes" xml:space="preserve">
          <source>Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you'll want to use the outlet.
Solution? Make sure all outlets are connected. Or use the &lt;code&gt;?&lt;/code&gt; operator on them: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.</source>
          <target state="translated">现在，如果您错过了通过XIB编辑器连接插座的操作，则一旦您要使用插座，该应用程序就会崩溃。 解？ 确保所有插座均已连接。 还是用 &lt;code&gt;?&lt;/code&gt; 运算符： &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt; 。 或将出口声明为可选，尽管在这种情况下，编译器将迫使您在整个代码中对其进行包装。</target>
        </trans-unit>
        <trans-unit id="f75a096d58dde4b74701e26c90ea72ae64747b35" translate="yes" xml:space="preserve">
          <source>Now, if no-one messes up with the &lt;code&gt;name&lt;/code&gt; property by setting it to &lt;code&gt;nil&lt;/code&gt;, then it works as expected, however if &lt;code&gt;User&lt;/code&gt; is initialized from a JSON that lacks the &lt;code&gt;name&lt;/code&gt; key, then you get the fatal error when trying to use the property.</source>
          <target state="translated">现在，如果没有人通过将 &lt;code&gt;name&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 来弄乱name属性，那么它将按预期工作，但是，如果 &lt;code&gt;User&lt;/code&gt; 是从缺少 &lt;code&gt;name&lt;/code&gt; 键的JSON初始化的，那么在尝试使用该属性时会出现致命错误。</target>
        </trans-unit>
        <trans-unit id="936cf8bab3f747e065f42e3415906001fcaec17a" translate="yes" xml:space="preserve">
          <source>One other way, if you don't want to check the variable state before your implementation, you can also use &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; instead.</source>
          <target state="translated">另一种方法，如果您不想在实现之前检查变量状态，则还可以使用 &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; 改为使用&amp;ldquo; buildingName&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="4a3f188326fc444bc42e44fa25a0acf6b3ccac81" translate="yes" xml:space="preserve">
          <source>Optional Binding</source>
          <target state="translated">可选装订</target>
        </trans-unit>
        <trans-unit id="7a826a948d8f9ecc960c32ca6f545004bbd4247e" translate="yes" xml:space="preserve">
          <source>Optional Binding allows you to check if an optional contains a value &amp;ndash; and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; or &lt;code&gt;if var x = anOptional {...}&lt;/code&gt;, depending if you need to modify the value of the new variable after binding it.</source>
          <target state="translated">可选绑定允许您检查可选项是否包含值&amp;ndash;并允许您将展开的值分配给新变量或常量。 &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; 或 &lt;code&gt;if var x = anOptional {...}&lt;/code&gt; ，则使用语法，具体取决于绑定后是否需要修改新变量的值。</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">可选连锁</target>
        </trans-unit>
        <trans-unit id="1661a949efe8ce7e832a8022541343bb817a5148" translate="yes" xml:space="preserve">
          <source>Optionals are defined with a &lt;code&gt;?&lt;/code&gt; suffix on the type:</source>
          <target state="translated">可选用 &lt;code&gt;?&lt;/code&gt; 定义。 类型的后缀：</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">或者像这样。</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="54833e81302d6311cef1a28ed09adc3690301a62" translate="yes" xml:space="preserve">
          <source>Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.</source>
          <target state="translated">其次,要知道可选的值有两种状态。一种是全值,另一种是零值。所以在实现一个可选值之前,你应该检查一下它是哪种状态。</target>
        </trans-unit>
        <trans-unit id="03c6c8c8bdb83cd4b0856641a961cecbc0c85b85" translate="yes" xml:space="preserve">
          <source>Since the above answers clearly explains how to play safely with Optionals.
I will try explain what Optionals are really in swift.</source>
          <target state="translated">既然上面的答案已经清楚的说明了如何安全的玩好Optionals。我将试着解释一下什么是Optionals在Swift中的真正含义。</target>
        </trans-unit>
        <trans-unit id="dad624a90b7df3a23e5bb578feeeabdd12ee8888" translate="yes" xml:space="preserve">
          <source>So I solved it this way:</source>
          <target state="translated">于是我就这样解决了。</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">所以这个代码。</target>
        </trans-unit>
        <trans-unit id="afb1b762e29712aa3b112a22ea2e06690f91025a" translate="yes" xml:space="preserve">
          <source>So to assign a nil to our variable 'i'. We can do 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt;
or to assign a value, we will pass some value 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</source>
          <target state="translated">因此，给变量&amp;ldquo; i&amp;rdquo;分配零。 我们可以做 &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt; 或分配一个值，我们将传递一些值 &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a43ac01380800da0acd970a8b899fd1a1eb60e8" translate="yes" xml:space="preserve">
          <source>So you could use code like this:</source>
          <target state="translated">所以你可以用这样的代码。</target>
        </trans-unit>
        <trans-unit id="b04e4285f916f64b8ec1d071584592d993d42c35" translate="yes" xml:space="preserve">
          <source>So, to use them with an optional binding, you can do this:</source>
          <target state="translated">所以,要想使用它们与可选的绑定,可以这样做。</target>
        </trans-unit>
        <trans-unit id="7547ba07041dcef70d621cc40b5c4a45b8ce5e45" translate="yes" xml:space="preserve">
          <source>Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as &lt;code&gt;nonnull&lt;/code&gt;.</source>
          <target state="translated">解？ 在您的Objective-C代码中添加可空性注释。 但是请注意，就可空性而言，Objective-C编译器有点宽容，即使您明确将它们标记为 &lt;code&gt;nonnull&lt;/code&gt; ，您也可能会得到nil值。</target>
        </trans-unit>
        <trans-unit id="52e5455e8973ef67576894c1d0ab773692ab9e50" translate="yes" xml:space="preserve">
          <source>Solution? Don't use them :) Unless you're 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property</source>
          <target state="translated">解决办法?不要使用它们:)除非你有102%的把握在需要使用的时候,属性总是有一个非零值。在大多数情况下,转换为可选或非可选就可以了。将其转换为非可选项也会让编译器帮助你,告诉你的代码路径,你错过了给该属性赋值的时间。</target>
        </trans-unit>
        <trans-unit id="dbbb73b74bb82fd31f9eda3643a242450fdeebf5" translate="yes" xml:space="preserve">
          <source>Solution? Use optional binding (aka if-let), do the variable processing there:</source>
          <target state="translated">解决办法?使用可选的绑定(又名if-let),在那里做变量处理。</target>
        </trans-unit>
        <trans-unit id="f6514760b09d36bf6238bb6b2eecdafcf283abf2" translate="yes" xml:space="preserve">
          <source>Something simple that is worth checking if all else looks ok</source>
          <target state="translated">一些简单的东西,如果其他方面看起来还不错的话,值得检查一下</target>
        </trans-unit>
        <trans-unit id="d9bf36cacd5682e9de59257e72eab5c7866cf9e7" translate="yes" xml:space="preserve">
          <source>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake.</source>
          <target state="translated">Swift是一种类型安全语言,这意味着该语言可以帮助你清楚地了解你的代码可以使用的值类型。如果你的代码的一部分期望值是String,类型安全可以防止你错误地传递一个Int。</target>
        </trans-unit>
        <trans-unit id="0191ce146a46db014aa0959a5ad6aab2ad0a906a" translate="yes" xml:space="preserve">
          <source>Swift optionals let you set up a variable of any type to contain either a valid value, or no value.</source>
          <target state="translated">Swift optionals允许你设置一个任意类型的变量,可以包含一个有效值,也可以不包含任何值。</target>
        </trans-unit>
        <trans-unit id="9f50948ddb6a9405af006b565688093e07e7df89" translate="yes" xml:space="preserve">
          <source>Swift uses the concept of &quot;Optionals&quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.</source>
          <target state="translated">Swift使用 &quot;Optionals &quot;的概念来处理可能包含值的值,也可能不包含值。在其他语言如C语言中,你可能会在一个变量中存储一个0的值,以表示它不包含值。但是,如果0是一个有效值呢?那么你可能会使用-1,如果-1是一个有效值呢?以此类推。</target>
        </trans-unit>
        <trans-unit id="8733a9d6eaaff2ad81a4c469105c4f2aa8f27191" translate="yes" xml:space="preserve">
          <source>Swift's error handling system can be safely used with &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;:</source>
          <target state="translated">Swift的错误处理系统可以与&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;一起安全地使用：</target>
        </trans-unit>
        <trans-unit id="aab6e4d9938362d2634e37c6d271130b036be9f7" translate="yes" xml:space="preserve">
          <source>TL;DR answer</source>
          <target state="translated">答案</target>
        </trans-unit>
        <trans-unit id="5910011e369d233145df2614ffbb9258f70e2bc9" translate="yes" xml:space="preserve">
          <source>The &quot;!&quot; operator is a &quot;force unwrap&quot; operator. It says &quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.&quot; If you are wrong, you crash.</source>
          <target state="translated">&quot;!&quot;操作符是一个 &quot;强行拆解 &quot;的操作符。它说:&quot;相信我。我知道我在做什么。我保证当这段代码运行时,变量不会包含nil。&quot; 如果你错了,你就会崩溃。</target>
        </trans-unit>
        <trans-unit id="cc8497513f48b57bcdbd220d3e716cb1d4a6b09b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; is a nifty shorthand version of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;ternary conditional operator&lt;/a&gt;, primarily designed to convert optionals to non-optionals. It has the syntax &lt;code&gt;a ?? b&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an optional type and &lt;code&gt;b&lt;/code&gt; is the same type as &lt;code&gt;a&lt;/code&gt; (although usually non-optional).</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil合并运算符&lt;/a&gt;是&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;三元条件运算符&lt;/a&gt;的精简版本，主要用于将可选选项转换为非可选选项。 它具有语法 &lt;code&gt;a ?? b&lt;/code&gt; b ，其中 &lt;code&gt;a&lt;/code&gt; 是可选类型， &lt;code&gt;b&lt;/code&gt; 是与a相同的类型（尽管通常是非可选的）。</target>
        </trans-unit>
        <trans-unit id="4f39a8383e521eac4930320b3f781463d412042a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; constant you see in the &lt;code&gt;catch&lt;/code&gt; block has not been declared by us - it's automatically generated by &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">您未在 &lt;code&gt;catch&lt;/code&gt; 块中看到的 &lt;code&gt;error&lt;/code&gt; 常量已由我们声明-由 &lt;code&gt;catch&lt;/code&gt; 自动生成。</target>
        </trans-unit>
        <trans-unit id="cd0c0cb00ef66003262f22de70ce81e5de3dbebd" translate="yes" xml:space="preserve">
          <source>The concepts explained in this post also apply here: if an error is thrown, the application will crash.</source>
          <target state="translated">这个帖子中解释的概念在这里也适用:如果抛出错误,应用程序将崩溃。</target>
        </trans-unit>
        <trans-unit id="cc4353dc8328b849dd5eee0ba9343f34b63353af" translate="yes" xml:space="preserve">
          <source>The errors &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; appears the most when you have declared an &lt;code&gt;@IBOutlet&lt;/code&gt;, but not connected to the &lt;strong&gt;storyboard&lt;/strong&gt;.</source>
          <target state="translated">错误 &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; 和 &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; 在声明 &lt;code&gt;@IBOutlet&lt;/code&gt; 但未连接到&lt;strong&gt;Storyboard&lt;/strong&gt;时， 在隐式展开Optional值时意外发现nil出现最多。</target>
        </trans-unit>
        <trans-unit id="f944bc0d51db4c42e0ab501ffaf2c9361c58f7c9" translate="yes" xml:space="preserve">
          <source>The full code would be :</source>
          <target state="translated">完整的代码将是:。</target>
        </trans-unit>
        <trans-unit id="39947ad748876c5ade4da078e8c8623048e5ffc6" translate="yes" xml:space="preserve">
          <source>The full code would be:</source>
          <target state="translated">完整的代码将是:</target>
        </trans-unit>
        <trans-unit id="49a1afbffea19fea31c8bef0f4563791d58a8dc2" translate="yes" xml:space="preserve">
          <source>The lack of a value in an optional is indicated by &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示可选字段中缺少值：</target>
        </trans-unit>
        <trans-unit id="37d4ab0d4c249a69f4593634c7af51c35f6f73fc" translate="yes" xml:space="preserve">
          <source>The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a &lt;em&gt;guard statement&lt;/em&gt;.</source>
          <target state="translated">在if语句中使用可选绑定的唯一陷阱是，您只能从该语句的范围内访问未包装的值。 如果需要从语句范围之外访问该值，则可以使用&lt;em&gt;guard语句&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="77a167b0cfc56774bff7d7b752b55f5f670e549d" translate="yes" xml:space="preserve">
          <source>The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can &lt;em&gt;only&lt;/em&gt; execute if the optional has a value). This is a great for eliminating &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;&amp;lsquo;pyramids of doom&amp;rsquo;&lt;/a&gt; created by nesting multiple if statements.</source>
          <target state="translated">关于保护语句的真正精巧之处在于，展开后的值现在可以在该语句后的代码中使用（因为我们知道，将来的代码&lt;em&gt;仅&lt;/em&gt;在可选值具有值时&lt;em&gt;才能&lt;/em&gt;执行）。 这对于消除通过嵌套多个if语句创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;的&amp;ldquo;厄运金字塔&amp;rdquo;非常有用&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f70e19cc299904e989d46111669248e2d6297b5a" translate="yes" xml:space="preserve">
          <source>The simplest way to check whether an optional contains a value, is to compare it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">检查可选值是否包含值的最简单方法是将其与 &lt;code&gt;nil&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="2ad7c64f5b093e808ba67d8a73670ba71bd4ebd5" translate="yes" xml:space="preserve">
          <source>Then I found out that I can't set the values of the destination controller outlets because the controller hasn't been loaded or initialized yet.</source>
          <target state="translated">后来我发现,因为控制器还没有加载和初始化,所以无法设置目的地控制器的出口值。</target>
        </trans-unit>
        <trans-unit id="1ec67f9dd2cfab174b6b515c3d0d4747bf7293ec" translate="yes" xml:space="preserve">
          <source>There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)</source>
          <target state="translated">还有很多其他更安全的处理期权的方法。以下是一些(并非详尽无遗)。</target>
        </trans-unit>
        <trans-unit id="0d60f2d11c0f746729eec725020f1feabe53897f" translate="yes" xml:space="preserve">
          <source>There are several scenarios that lead to this kind of fatal error:</source>
          <target state="translated">有几种情况会导致这种致命的错误。</target>
        </trans-unit>
        <trans-unit id="3cc4935148dd3d0a4d88768551d67d938c2ebaf2" translate="yes" xml:space="preserve">
          <source>There is also a construct called the &quot;nil coalescing operator&quot;. It takes the form &quot;optional_var ?? replacement_val&quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the &quot;??&quot; symbol.</source>
          <target state="translated">还有一个构造叫做 &quot;nil coalescing operator&quot;。它的形式为 &quot;optional_var ? ? replacement_val&quot;。它返回一个与可选项中包含的数据类型相同的非可选项变量。如果可选项包含nil,则返回&quot;? &quot;符号后的表达式的值。</target>
        </trans-unit>
        <trans-unit id="b6b6bf923d0fa956d7f5415f78e183319a28b7b6" translate="yes" xml:space="preserve">
          <source>There's also &lt;code&gt;try?&lt;/code&gt; which absorbs the error:</source>
          <target state="translated">还有 &lt;code&gt;try?&lt;/code&gt; 吸收错误：</target>
        </trans-unit>
        <trans-unit id="051cef13b0cd111883df939c5644ba59bbe86947" translate="yes" xml:space="preserve">
          <source>These are defined with  a &lt;code&gt;!&lt;/code&gt;, rather than a &lt;code&gt;?&lt;/code&gt; after the type.</source>
          <target state="translated">这些用 &lt;code&gt;!&lt;/code&gt; 定义。 ，而不是 &lt;code&gt;?&lt;/code&gt; 类型之后。</target>
        </trans-unit>
        <trans-unit id="228d647e0bd3a874c5246256241ffafbe0dae63f" translate="yes" xml:space="preserve">
          <source>These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesn&amp;rsquo;t contain a value, it will crash.</source>
          <target state="translated">假定这些可选参数包含一个值。 因此，每当您访问隐式解包的可选内容时，它将自动为您强制解包。 如果不包含值，它将崩溃。</target>
        </trans-unit>
        <trans-unit id="03d3193f66062a0894aa6946a0e2b6f22b829634" translate="yes" xml:space="preserve">
          <source>These variables are designed so that you can defer their assignment until later in your code. It is &lt;em&gt;your&lt;/em&gt; responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe &amp;ndash; as they &lt;em&gt;assume&lt;/em&gt; your value is non-nil, even though assigning nil is valid.</source>
          <target state="translated">设计这些变量是为了使您可以将它们的分配推迟到以后的代码中。 &lt;em&gt;您有&lt;/em&gt;责任在访问它们之前确保它们具有价值。 但是，由于它们涉及强制展开，因此它们本质上仍然是不安全的，因为即使您指定nil有效，它们也会&lt;em&gt;假定&lt;/em&gt;您的值不为nil。</target>
        </trans-unit>
        <trans-unit id="e2a9aff700fd23b1fa64684c86c11f3e64379b3e" translate="yes" xml:space="preserve">
          <source>Think of the following code: 
It compiles with no errors/warnings:</source>
          <target state="translated">想想看下面的代码。它在编译时没有错误警告。</target>
        </trans-unit>
        <trans-unit id="09d8ef10eee293feb35c82626771fa027ffe930b" translate="yes" xml:space="preserve">
          <source>This answer was intended to be concise, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;for full comprehension read accepted answer&lt;/a&gt;</source>
          <target state="translated">此答案旨在简明扼要， &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;以便全面理解已接受的答案&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="518b372f5b167794f9cb85ed9cffe42f1420058a" translate="yes" xml:space="preserve">
          <source>This can therefore also be used to set properties as well as call methods. For example:</source>
          <target state="translated">因此,这也可以用来设置属性以及调用方法。比如说。</target>
        </trans-unit>
        <trans-unit id="8a756f40b006c215a6765390c6966fd17d773cb9" translate="yes" xml:space="preserve">
          <source>This crash can occur with two different kinds of force-unwrap:</source>
          <target state="translated">这种撞车的情况,有两种不同的力道解包会出现。</target>
        </trans-unit>
        <trans-unit id="8f0250df27448e385747e9a13ccb5651fe27b21d" translate="yes" xml:space="preserve">
          <source>This is done with the &lt;code&gt;!&lt;/code&gt; operator on an optional. For example:</source>
          <target state="translated">这是用 &lt;code&gt;!&lt;/code&gt; 可选的运算符。 例如：</target>
        </trans-unit>
        <trans-unit id="e414f3b50562e4d895870d8df98dbad24cb92fae" translate="yes" xml:space="preserve">
          <source>This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">这更是一个重要的注释，这就是为什么在调试 &lt;code&gt;nil&lt;/code&gt; 值时隐式解开的可选变量可能会引起欺骗。</target>
        </trans-unit>
        <trans-unit id="0cb38c500378f3659b7d36d8d3cb7a2ed2377409" translate="yes" xml:space="preserve">
          <source>This question comes up &lt;strong&gt;ALL THE TIME&lt;/strong&gt; on SO. It's one of the first things that new Swift developers struggle with.</source>
          <target state="translated">这个问题一直都在出现。 这是新的Swift开发人员首先要面对的事情之一。</target>
        </trans-unit>
        <trans-unit id="fe5ac8dc15cee70308d149380af17fd09b2dcd0b" translate="yes" xml:space="preserve">
          <source>This time the code has been made more clear to you. You can rationalize and think that likely it's the &lt;code&gt;address&lt;/code&gt; parameter that was forcefully unwrapped.</source>
          <target state="translated">这次代码对您来说更加清晰了。 您可以合理化并认为可能是强行解开了 &lt;code&gt;address&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="f93b94e3333c14bc5a8e2daea487de2fd080c3a5" translate="yes" xml:space="preserve">
          <source>This will define a &lt;code&gt;number&lt;/code&gt; constant of &lt;code&gt;Int&lt;/code&gt; type, that will either contain the value of &lt;code&gt;anOptionalInt&lt;/code&gt;, if it contains a value, or &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">这将定义一个 &lt;code&gt;Int&lt;/code&gt; 类型的 &lt;code&gt;number&lt;/code&gt; 常量，如果包含一个值，则将包含 &lt;code&gt;anOptionalInt&lt;/code&gt; 的值，否则将包含 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36079ad7315babb9e3cfd31e04a6700ff9a65fd1" translate="yes" xml:space="preserve">
          <source>Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)</source>
          <target state="translated">因此,你要真正小心地对待隐含的未封装的期权。(甚至可能完全避免它们,直到你对期权的理解有了一定的把握为止)。</target>
        </trans-unit>
        <trans-unit id="bf4f5d672e4353189b2590d59428129d4a05faa6" translate="yes" xml:space="preserve">
          <source>Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.</source>
          <target state="translated">未连接,或尚未连接的插座。这是一个特殊情况下的场景#3。基本上,你有一些XIB加载的类,你想使用。</target>
        </trans-unit>
        <trans-unit id="7fbb993222752244a9f031c8c1d545ed152b2357" translate="yes" xml:space="preserve">
          <source>Unless you really &lt;strong&gt;do&lt;/strong&gt; know what you are doing, avoid the &quot;!&quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.</source>
          <target state="translated">除非您真的知道自己在做什么，否则请避免使用&amp;ldquo;！&amp;rdquo; 强制解开操作符。 对于新手Swift程序员来说，这可能是最大的崩溃源。</target>
        </trans-unit>
        <trans-unit id="af66b528b3a5e4db51aa7414b4854d62642ea64a" translate="yes" xml:space="preserve">
          <source>Unwrap optional variable using &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;guard let&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;if let&lt;/code&gt; 或 &lt;code&gt;guard let&lt;/code&gt; 解开可选变量</target>
        </trans-unit>
        <trans-unit id="bd4b5387dfce9931cda3017dc45ec2e24c2238c6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try&lt;/code&gt; this way is the proper way to try, catch and handle errors coming from throwing functions.</source>
          <target state="translated">以这种方式使用 &lt;code&gt;try&lt;/code&gt; 是尝试，捕获和处理来自throwing函数的错误的正确方法。</target>
        </trans-unit>
        <trans-unit id="da6d8e9893a791f4319490b2d723d4806a84568f" translate="yes" xml:space="preserve">
          <source>Values coming from Objective-C, and that don't have nullability annotations. Let's assume we have the following Objective-C class:</source>
          <target state="translated">来自Objective-C的值,并且没有nullability注释。让我们假设我们有以下Objective-C类。</target>
        </trans-unit>
        <trans-unit id="9d11739af047f16216d738c322733a87037f743f" translate="yes" xml:space="preserve">
          <source>What does “Fatal error: Unexpectedly found nil while unwrapping an Optional value” mean</source>
          <target state="translated">什么是 &quot;Fatal error:在解开可选值时意外发现零 &quot;是什么意思?</target>
        </trans-unit>
        <trans-unit id="5e6a210b7a4319c69606343ec4904762d1eff5e8" translate="yes" xml:space="preserve">
          <source>What this does is first check that the optional contains a value. If it &lt;em&gt;does&lt;/em&gt;, then the &amp;lsquo;unwrapped&amp;rsquo; value is assigned to  a new variable (&lt;code&gt;number&lt;/code&gt;) &amp;ndash; which you can then freely use as if it were non-optional. If the optional &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; contain a value, then the else clause will be invoked, as you would expect.</source>
          <target state="translated">首先，请检查可选内容是否包含值。 如果&lt;em&gt;是&lt;/em&gt; ，则将&amp;ldquo; unwrapped&amp;rdquo;值分配给新变量（ &lt;code&gt;number&lt;/code&gt; ）&amp;ndash;然后您可以自由使用它，就像它是非可选的一样。 如果可选参数&lt;em&gt;不&lt;/em&gt;包含值，则将按您期望的那样调用else子句。</target>
        </trans-unit>
        <trans-unit id="10db728e68ab2e61caf6c0b29942fb92bfcc5927" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.</source>
          <target state="translated">关于可选绑定的巧妙之处在于，您可以同时解开多个可选对象。 您可以只用逗号分隔语句。 如果所有可选选项均未包装，则该语句将成功。</target>
        </trans-unit>
        <trans-unit id="1373ba269d2cc3b83a01653ae7e2e71286d08529" translate="yes" xml:space="preserve">
          <source>When should I ever force unwrap an Optional?</source>
          <target state="translated">我应该在什么时候强行拆封一个Optional?</target>
        </trans-unit>
        <trans-unit id="317e17e5c488981811996349a91cb8951d0d1759" translate="yes" xml:space="preserve">
          <source>When to use and when not to use implicitly unwrapped optionals</source>
          <target state="translated">什么时候使用,什么时候不使用,什么时候不使用隐含的未封装选项</target>
        </trans-unit>
        <trans-unit id="1f3a4ea673b0a5e8dc1d2d64df7cf20d096e7fe0" translate="yes" xml:space="preserve">
          <source>Whether you use an if or guard statement completely depends on whether any future code &lt;em&gt;requires&lt;/em&gt; the optional to contain a value.</source>
          <target state="translated">是否使用if或guard语句完全取决于将来的任何代码是否&lt;em&gt;要求&lt;/em&gt;可选值包含值。</target>
        </trans-unit>
        <trans-unit id="c54b591d9a12bd724553adb14722d899feefcb1f" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;may&lt;/em&gt; be an occasion where you can use force unwrapping, as you know for a &lt;em&gt;fact&lt;/em&gt; that an optional contains a value &amp;ndash; there is not a &lt;em&gt;single&lt;/em&gt; place where you cannot safely unwrap that optional instead.</source>
          <target state="translated">虽然有时您可以使用强制展开，但众所周知，一个可选内容包含一个值，但在一个地方，您无法安全地展开该可选内容。</target>
        </trans-unit>
        <trans-unit id="87bd0f61bb6e6865c8ad7d95e74d3227791bcb36" translate="yes" xml:space="preserve">
          <source>Why did I get &amp;ldquo;&lt;em&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;&amp;rdquo;?</source>
          <target state="translated">为什么会出现&amp;ldquo; &lt;em&gt;致命错误：在展开可选值时意外发现nil&lt;/em&gt; &amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="4ed62fc8759885174a5e1c44082b865686115a7c" translate="yes" xml:space="preserve">
          <source>Will crash on reference to foo's capitalizedString property even though we're not force-unwrapping foo. the print looks fine, but it's not.</source>
          <target state="translated">在引用foo的capitalizedString属性的时候会崩溃,即使我们没有强制解包foo。</target>
        </trans-unit>
        <trans-unit id="e425b6ac11a3cf5713fb75b070bc494a5c64679e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;very few exceptions&lt;/a&gt;, this rule is golden:</source>
          <target state="translated">除了&lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;极少数例外&lt;/a&gt; ，此规则是黄金：</target>
        </trans-unit>
        <trans-unit id="c496ef8337514f41cb37fdccdcb7d50ad577dff9" translate="yes" xml:space="preserve">
          <source>Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.</source>
          <target state="translated">Xcode会通过突出显示一行代码来显示崩溃。问题发生在这一行。</target>
        </trans-unit>
        <trans-unit id="839c55483e3111c1ca07f84d7891a2c9b7b1beae" translate="yes" xml:space="preserve">
          <source>Yet at runtime it gives the following error: &lt;em&gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;</source>
          <target state="translated">但是在运行时，它会出现以下错误： &lt;em&gt;致命错误：展开一个Optional值时意外地找到nil&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e9ce0757b971a4c196d317850c0dbdf450d7e30" translate="yes" xml:space="preserve">
          <source>You can also declare &lt;code&gt;error&lt;/code&gt; yourself, it has the advantage of being able to cast it to a useful format, for example:</source>
          <target state="translated">您还可以自己声明 &lt;code&gt;error&lt;/code&gt; ，它具有将其转换为有用格式的优点，例如：</target>
        </trans-unit>
        <trans-unit id="1350d18d0403c656c2c06ac9d6b05eba79938d9b" translate="yes" xml:space="preserve">
          <source>You can use &quot;optional binding&quot; or &quot;if let&quot; to say &quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement&quot;.</source>
          <target state="translated">你可以使用 &quot;可选的绑定 &quot;或 &quot;if let &quot;来表示 &quot;如果这个可选的包含一个值,就把这个值保存到一个新的非可选的变量中。如果这个可选项不包含值,则跳过这个if语句的正文&quot;。</target>
        </trans-unit>
        <trans-unit id="5d1b249ef279beb59a5d567f45b0c019278cedef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;Optional Chaining&lt;/a&gt; in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a &lt;code&gt;?&lt;/code&gt; when using it.</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;可选链接&lt;/a&gt;来调用方法或访问可选属性。 只需在变量名后加上 &lt;code&gt;?&lt;/code&gt; 即可完成此操作。 使用时。</target>
        </trans-unit>
        <trans-unit id="aaff60ab9a0fe1d4638638d4410b990a62bde2cf" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;if let ...&lt;/code&gt; or &lt;code&gt;guard let ... else&lt;/code&gt; and so on.</source>
          <target state="translated">您可以使用 &lt;code&gt;if let ...&lt;/code&gt; 或 &lt;code&gt;guard let ... else&lt;/code&gt; 等等。</target>
        </trans-unit>
        <trans-unit id="5d9ba10c8d2d8d6b1b597f11d55cc435237669ae" translate="yes" xml:space="preserve">
          <source>You can't!</source>
          <target state="translated">你不能!</target>
        </trans-unit>
        <trans-unit id="6ec1cc83396860fe0f710055f9d7e89e1c8bc165" translate="yes" xml:space="preserve">
          <source>You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.</source>
          <target state="translated">你也可以使用trycatch或 guard 错误处理,但一般来说,上面的其他技术中的一种比较干净。</target>
        </trans-unit>
        <trans-unit id="c4dc5e8cd9f1e69573167fc61cd53e581b19c500" translate="yes" xml:space="preserve">
          <source>You put a question mark after the type when you declare a variable to mean (type x, or no value).</source>
          <target state="translated">当你声明一个变量的含义(类型为x,或无值)时,在类型后打上问号。</target>
        </trans-unit>
        <trans-unit id="bf8513637bc93a619e697f6a9595807f32954dc5" translate="yes" xml:space="preserve">
          <source>You should also learn about how &lt;strong&gt;Optionals&lt;/strong&gt; work, mentioned in other answers, but this is the only time that mostly appears to me.</source>
          <target state="translated">您还应该了解其他答案中提到的&lt;strong&gt;Optionals的&lt;/strong&gt;工作原理，但这是对我来说唯一的一次。</target>
        </trans-unit>
        <trans-unit id="af1087f6530251ae6d010a9f21750da1ea79e979" translate="yes" xml:space="preserve">
          <source>You should only be using implicitly unwrapped optionals as a &lt;em&gt;last resort&lt;/em&gt;. If you can use a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;lazy variable&lt;/a&gt;, or provide a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;default value&lt;/a&gt; for a variable &amp;ndash; you should do so instead of using an implicitly unwrapped optional.</source>
          <target state="translated">您应仅将隐式解包的可选内容用作&lt;em&gt;最后的选择&lt;/em&gt; 。 如果您可以使用&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;惰性变量&lt;/a&gt;或为变量提供&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;默认值&lt;/a&gt; ，则应这样做，而不要使用隐式展开的可选变量。</target>
        </trans-unit>
        <trans-unit id="94f331b5b5c0ba72a4cfb9cf99bdd31fd6ae82d0" translate="yes" xml:space="preserve">
          <source>add this code in ViewDidLoad() at mainVC.</source>
          <target state="translated">在mainVC处的ViewDidLoad()中添加这段代码。</target>
        </trans-unit>
        <trans-unit id="7f66728a6d981314d1e4ec43c0a4f6c970120d38" translate="yes" xml:space="preserve">
          <source>forced (down)casts:</source>
          <target state="translated">强制(下)投。</target>
        </trans-unit>
        <trans-unit id="fad23c2241f2181a2dba20635bf0879e56728e33" translate="yes" xml:space="preserve">
          <source>forced unwraps:</source>
          <target state="translated">强行开包。</target>
        </trans-unit>
        <trans-unit id="958603fb1a0a0dac8fad299a6be3fb83ef2ce3f9" translate="yes" xml:space="preserve">
          <source>while clicking to show the definition, where you might find the optional type.</source>
          <target state="translated">而点击显示定义,在这里你可能会找到可选的类型。</target>
        </trans-unit>
        <trans-unit id="4e8e6ff2989841893307b09e3c62d4b5ade13d31" translate="yes" xml:space="preserve">
          <source>⌥</source>
          <target state="translated">⌥</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
