<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/32170456">
    <body>
      <group id="32170456">
        <trans-unit id="d3a244fb54042f2dbf42e3fe5fb600311a47bd44" translate="yes" xml:space="preserve">
          <source>1. Explicit Force Unwrapping</source>
          <target state="translated">1. 명시 적 포스 풀기</target>
        </trans-unit>
        <trans-unit id="635c6e54ef549bf1619585c9acdb06d314adaf23" translate="yes" xml:space="preserve">
          <source>2. Implicitly Unwrapped Optionals</source>
          <target state="translated">2. 암시 적으로 랩핑되지 않은 옵션</target>
        </trans-unit>
        <trans-unit id="18d21910bcbc1da8e1aa11e251dedd0b06352cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; has a single method called &lt;code&gt;init(nilLiteral:)&lt;/code&gt; which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with &lt;code&gt;nil&lt;/code&gt; literal.</source>
          <target state="translated">&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; 에는 &lt;code&gt;init(nilLiteral:)&lt;/code&gt; 라는 단일 메소드가 있는데,이 메소드는 nil로 instace를 초기화합니다. 일반적으로이 메소드를 호출하지 않으며 신속한 문서에 따르면 &lt;code&gt;nil&lt;/code&gt; 리터럴로 Optional 유형을 초기화 할 때마다 컴파일러가 호출 할 때이 이니셜 라이저를 직접 호출하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5a9772727897bd3ca247cb46b7f9cb451241ee24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works similarly to &lt;code&gt;map&lt;/code&gt;, except it allows you to return &lt;em&gt;another&lt;/em&gt; optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; 은 클로저 본문 내에서 &lt;em&gt;다른&lt;/em&gt; 옵션을 반환 할 수 있다는 점을 제외하고 &lt;code&gt;map&lt;/code&gt; 과 유사하게 작동합니다. 즉, 선택 사항이 아닌 입력이 필요한 프로세스에 선택 사항을 입력 할 수 있지만 선택 사항 자체를 출력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b1070a11e663243cc897c90af46f99c6df445c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 및 &lt;code&gt;flatMap&lt;/code&gt; 지도</target>
        </trans-unit>
        <trans-unit id="c46dee75d89e56932987294e4ff7e4232b363930" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You should only ever use &lt;code&gt;try!&lt;/code&gt; if you can prove that its result will never fail in your context - and this is very rare.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;당신은 항상 &lt;code&gt;try!&lt;/code&gt; 사용해야 합니다!&lt;/em&gt; &lt;em&gt;결과가 컨텍스트에서 절대 실패하지 않는다는 것을 증명할 수 있다면 매우 드 rare니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b7730d90c9b2349ff66ee31e8785e67ba52fb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you now tell me which object it is that was &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;당신은 이제 그것이 어떤 객체인지 알 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37a5bcf391e8ccb209c28d5fceb142b218d5b019" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you tell me which object is &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떤 객체가 &lt;code&gt;nil&lt;/code&gt; 인지 말해 줄 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f283be4efc0664716ddd69d9cdc7df0c17dbd693" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that this &lt;code&gt;nil&lt;/code&gt; is not the same as the &lt;code&gt;nil&lt;/code&gt; in Objective-C. In Objective-C, &lt;code&gt;nil&lt;/code&gt; is the absence of a valid &lt;em&gt;object pointer&lt;/em&gt;; in Swift, Optionals are not restricted to objects/reference types. Optional behaves similarly to Haskell's &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Maybe&lt;/a&gt;.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(이 &lt;code&gt;nil&lt;/code&gt; 은 Objective-C의 &lt;code&gt;nil&lt;/code&gt; 과 동일하지 않습니다. Objective-C에서 &lt;code&gt;nil&lt;/code&gt; 은 유효한 &lt;em&gt;객체 포인터&lt;/em&gt; 가 없습니다 .Swift에서 Optionals는 객체 / 참조 유형으로 제한되지 않습니다. Optional은 Haskell과 유사합니다. &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;아마&lt;/a&gt; .)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d516eb97f8385312f77ef9000f049aeddc35663f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that within the guard body, you &lt;strong&gt;must&lt;/strong&gt; use one of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;control transfer statements&lt;/a&gt; in order to exit the scope of the currently executing code).&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;가드 본문 내에서 현재 실행중인 코드의 범위를 종료하려면 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;제어 전송 문&lt;/a&gt; 중 하나를 &lt;strong&gt;사용해야합니다&lt;/strong&gt; .&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5b87ee6fe147c52e17815abd3b0ac225686bc372" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is because an optional value will return &lt;code&gt;Void?&lt;/code&gt; rather than &lt;code&gt;Void&lt;/code&gt; on a method that doesn&amp;rsquo;t return anything)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(이것은 선택적 값이 아무것도 반환하지 않는 메소드에서 &lt;code&gt;Void&lt;/code&gt; 대신 &lt;code&gt;Void?&lt;/code&gt; 를 반환하기 때문입니다)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8d73db717d8e4390f76c6acdf864843b513507e2" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is similar behaviour to sending messages to &lt;code&gt;nil&lt;/code&gt; in Objective-C)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(이것은 Objective-C에서 메시지를 &lt;code&gt;nil&lt;/code&gt; 로 보내는 것과 유사합니다)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8404a61e69301e260a8bda1a58f0ce7110e7cc50" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This answer is &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;community wiki&lt;/a&gt;. If you feel it could be made better, feel free to &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit it&lt;/a&gt;!&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;이 답변은 &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;커뮤니티 위키&lt;/a&gt; 입니다.&lt;/sup&gt; &lt;sup&gt;더 나아질 수 있다고 생각되면 자유롭게 &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;편집하십시오&lt;/a&gt; !&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d92a649ecca38db770e2ea85dae9072443b3c79f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit&lt;/a&gt; the existing wiki answer.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;이 게시물은 &quot;예기치 않은 nil 발견&quot;문제에 대한 답변을 수집하여 흩어지지 않고 찾기 어렵도록하기위한 것입니다.&lt;/sup&gt; &lt;sup&gt;자유롭게 답변을 추가하거나 기존 위키 답변을 &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;편집&lt;/a&gt; 하십시오.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eae132614e41cb087afb2d1c01f40480f4698746" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;guard statement&lt;/a&gt; allows you to define a condition for success &amp;ndash; and the current scope will only continue executing if that condition is met. They are defined with the syntax &lt;code&gt;guard condition else {...}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;가드 문을&lt;/a&gt; 사용하면 성공 조건을 정의 할 수 있으며 해당 조건이 충족되는 경우에만 현재 범위가 계속 실행됩니다. 구문 &lt;code&gt;guard condition else {...}&lt;/code&gt; 로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd03209df27cf5183ea0c4aad3e184b5a067c77" translate="yes" xml:space="preserve">
          <source>According to swift, 'nil' is the absence of value.
And to create an instance initialized with &lt;code&gt;nil&lt;/code&gt; We have to conform to a protocol called &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and great if you guessed it, only &lt;code&gt;Optionals&lt;/code&gt; conform to &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and conforming to other types is discouraged.</source>
          <target state="translated">스위프트에 따르면 'nil'은 가치가 없다는 것입니다. &lt;code&gt;nil&lt;/code&gt; 로 초기화 된 인스턴스를 생성하려면 &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; 이라는 프로토콜을 준수해야합니다. 추측 할 수있는 경우에만 &lt;code&gt;Optionals&lt;/code&gt; 사항이 &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; 을 준수하고 다른 유형을 따르는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45073dbf8f3ef81afe07094beb4f6608a541d353" translate="yes" xml:space="preserve">
          <source>Again, because &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are optional, the value returned from &lt;code&gt;qux&lt;/code&gt; will always be an optional regardless of whether &lt;code&gt;qux&lt;/code&gt; itself is optional.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;baz&lt;/code&gt; 는 선택 사항이므로 &lt;code&gt;qux&lt;/code&gt; 에서 반환 된 값은 &lt;code&gt;qux&lt;/code&gt; 자체가 선택 사항인지 여부에 관계없이 항상 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="04b74eddaac2e0ff122721a98735cd4f4241cab6" translate="yes" xml:space="preserve">
          <source>Again, nothing bad will happen here if &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Your code will simply continue executing.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 여기서도 나쁜 일이 발생하지 않습니다. 코드는 단순히 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9e19419202a958c9e2c652dec63d96656df38091" translate="yes" xml:space="preserve">
          <source>Also, as the name suggests, you can &amp;lsquo;chain&amp;rsquo; these statements together. This means that if &lt;code&gt;foo&lt;/code&gt; has an optional property &lt;code&gt;baz&lt;/code&gt;, which has a property &lt;code&gt;qux&lt;/code&gt; &amp;ndash; you could write the following:</source>
          <target state="translated">또한 이름에서 알 수 있듯이 이러한 진술을 '연결'할 수 있습니다. 즉, &lt;code&gt;foo&lt;/code&gt; 에 선택적 &lt;code&gt;qux&lt;/code&gt; 속성이있는 선택적 &lt;code&gt;baz&lt;/code&gt; 속성이있는 경우 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3231de44e5b6f036b78301686d6ee18d12703f6b" translate="yes" xml:space="preserve">
          <source>Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:</source>
          <target state="translated">또는 변수가 nil 인 경우 함수를 종료 할 수있는 guard 문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df38dfc408955dbdd3d7167930749d99834f562" translate="yes" xml:space="preserve">
          <source>An often underused feature with optionals is the ability to use the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesn&amp;rsquo;t have a value, it will remain &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">옵션과 함께 자주 사용되지 &lt;code&gt;flatMap&lt;/code&gt; 기능은 &lt;code&gt;map&lt;/code&gt; 및 flatMap 함수를 사용하는 기능입니다. 이를 통해 선택적 변수에 비 선택적 변환을 적용 할 수 있습니다. 옵션에 값이 있으면 주어진 변환을 적용 할 수 있습니다. 값이 없으면 &lt;code&gt;nil&lt;/code&gt; 로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7475dbf59ea659fe38624a59d7089f9c937ce515" translate="yes" xml:space="preserve">
          <source>An optional is actually a container than contains either a variable of a given type, or nothing.</source>
          <target state="translated">옵션은 실제로 주어진 유형의 변수를 포함하거나 아무것도 포함하지 않는 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="3c0e7f41650898afdecfa4b26246b1d90eee328c" translate="yes" xml:space="preserve">
          <source>An optional needs to be &quot;unwrapped&quot; in order to fetch the value inside.</source>
          <target state="translated">내부에서 값을 가져 오려면 옵션을 &quot;포장 해제&quot;해야합니다.</target>
        </trans-unit>
        <trans-unit id="d26f01d2167b0ccd73f5ca8a245ba70fa537337b" translate="yes" xml:space="preserve">
          <source>And Optional type is nothing but an enumeration with two cases, i.e</source>
          <target state="translated">그리고 선택적 유형은 두 가지 경우를 가진 열거에 지나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c9267177db8f82598d60f708a0d70d575d72d06" translate="yes" xml:space="preserve">
          <source>Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.</source>
          <target state="translated">또 다른 깔끔한 요령은 쉼표를 사용하여 값을 푼 후 값의 특정 조건을 확인할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ddb885b2b01e4ba63f81165812deb39af75a71c" translate="yes" xml:space="preserve">
          <source>Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">선택적 체인을 사용하여 수행 할 수있는 또 하나의 깔끔한 트릭은 속성 설정 또는 메서드 호출의 성공 여부를 확인하는 것입니다. 리턴 값을 &lt;code&gt;nil&lt;/code&gt; 과 비교하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32470d176ca6dd8f034dc5807b14e045ee20d3c6" translate="yes" xml:space="preserve">
          <source>Another way to declare an optional variable is</source>
          <target state="translated">선택적 변수를 선언하는 또 다른 방법은</target>
        </trans-unit>
        <trans-unit id="443f7eb7f273a4e9c8d9c7fa2251a9bd082d81a0" translate="yes" xml:space="preserve">
          <source>Another, slightly more subtle gotcha with optionals is &quot;implicitly unwrapped optionals. When we declare foo, we could say:</source>
          <target state="translated">옵 셔널을 사용하는 또 다른 미묘한 차이는 &quot;암시 적으로 래핑되지 않은 옵 셔널입니다. foo를 선언하면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52474acee09818b60266e64bb250148f3409b9d7" translate="yes" xml:space="preserve">
          <source>Apple documentation on Swift Optionals</source>
          <target state="translated">스위프트 옵션에 관한 Apple 문서</target>
        </trans-unit>
        <trans-unit id="515515b53e442d6c0ac9c382069d83edc146839b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;anOptionalString&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; here, you will get a crash on the line where you force unwrap it.</source>
          <target state="translated">&lt;code&gt;anOptionalString&lt;/code&gt; 이 여기에 없기 때문에 강제로 줄을 바꾸는 줄에 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6401b89cf6e7b504f6a51a78043447e304db2acc" translate="yes" xml:space="preserve">
          <source>As a general rule, you should never explicitly force unwrap an optional with the &lt;code&gt;!&lt;/code&gt; operator. There may be cases where using &lt;code&gt;!&lt;/code&gt; is acceptable &amp;ndash; but you should only ever be using it if you are 100% sure that the optional contains a value.</source>
          <target state="translated">일반적으로 &lt;code&gt;!&lt;/code&gt; 운영자. &lt;code&gt;!&lt;/code&gt; 를 사용하는 경우가있을 수 있습니다 . 허용되지만 &amp;ndash; 옵션에 값이 포함되어 있다고 100 % 확신하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e63c2b6a3158f2d5901a2d116e700ecadd6e8ac7" translate="yes" xml:space="preserve">
          <source>Avoid use of &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">사용을 피하십시오 &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="48ec3975808ef63d21f693479b688b665f317562" translate="yes" xml:space="preserve">
          <source>Background: What&amp;rsquo;s an Optional?</source>
          <target state="translated">배경 : 옵션은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="000712677e846810968631694b8782eea505d28e" translate="yes" xml:space="preserve">
          <source>Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.</source>
          <target state="translated">기본적으로 Swift는 nil이 아닌 값만 허용하는 곳에서 nil 값을 사용하려고 시도했습니다. 컴파일러는 nil 값이 절대로 없을 것이라고 컴파일러에 신뢰하여 앱을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6510cebf85c73b91f042a999279b8ecb4a6cfde5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;stringByAppendingString&lt;/code&gt; takes a non-optional string argument, we cannot input our optional string directly. However, by using &lt;code&gt;map&lt;/code&gt;, we can use allow &lt;code&gt;stringByAppendingString&lt;/code&gt; to be used if &lt;code&gt;anOptionalString&lt;/code&gt; has a value.</source>
          <target state="translated">&lt;code&gt;stringByAppendingString&lt;/code&gt; 은 선택 사항이 아닌 문자열 인수를 사용하므로 선택적 문자열을 직접 입력 할 수 없습니다. 그러나 &lt;code&gt;map&lt;/code&gt; 을 사용하면 &lt;code&gt;anOptionalString&lt;/code&gt; 에 값이있는 경우 allow &lt;code&gt;stringByAppendingString&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3981488e6abb1cb399b600a4e20bcc5f6c58686a" translate="yes" xml:space="preserve">
          <source>Bottom line: When you are first learning Swift, pretend the &quot;!&quot; character is not part of the language. It's likely to get you into trouble.</source>
          <target state="translated">결론 : Swift를 처음 배울 때는 &quot;!&quot; 문자는 언어의 일부가 아닙니다. 문제가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270c4892a016f64b1f29e7cd37c444a555dc7d7d" translate="yes" xml:space="preserve">
          <source>But Swift's error handling system also provides a way to &quot;force try&quot; with &lt;code&gt;try!&lt;/code&gt;:</source>
          <target state="translated">그러나 Swift의 오류 처리 시스템은 try를 사용하여 &quot;강제 시도&quot;하는 방법을 제공합니다 &lt;code&gt;try!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e2f129952b7df6d9c9137de5fc26c084032ef61" translate="yes" xml:space="preserve">
          <source>By applying the &lt;code&gt;map&lt;/code&gt; function to it &amp;ndash; we can use the &lt;code&gt;stringByAppendingString&lt;/code&gt; function in order to concatenate it to another string.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 함수를 적용하면 &amp;ndash; &lt;code&gt;stringByAppendingString&lt;/code&gt; 함수를 사용하여 다른 문자열에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890392cd814cb51a3ec19620be5a911041086aa9" translate="yes" xml:space="preserve">
          <source>Declare variable optional (&lt;code&gt;?&lt;/code&gt;), not implicitly unwrapped optionals (IUO) (&lt;code&gt;!&lt;/code&gt;)</source>
          <target state="translated">암시 적으로 래핑되지 않은 옵션 (IUO)이 아닌 변수 옵션 ( &lt;code&gt;?&lt;/code&gt; ) 선언 ( &lt;code&gt;!&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2259c1bef40d9a2d2466c01f96f672a698d0443" translate="yes" xml:space="preserve">
          <source>Destination Controller:</source>
          <target state="translated">대상 컨트롤러 :</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="202b26ba321fbfe7f81ed7bbc6b02aef082dc6be" translate="yes" xml:space="preserve">
          <source>Either unwrap variable like this:</source>
          <target state="translated">다음과 같이 변수 랩핑을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="ca0a491616073f375fc6c16bc6cdb928b2718880" translate="yes" xml:space="preserve">
          <source>Even myself has to wrap (no pun intended) my head around Optionals :D
&lt;em&gt;Happy Swfting All&lt;/em&gt;.</source>
          <target state="translated">내 자신조차도 선택 사항 : D &lt;em&gt;Happy Swfting All으로&lt;/em&gt; 내 머리를 감싸 &lt;em&gt;야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d5e49c1f7f49b51d3c469b5d6175ea1c5c2c0403" translate="yes" xml:space="preserve">
          <source>Explicit Force Unwrapping</source>
          <target state="translated">명백한 힘 풀기</target>
        </trans-unit>
        <trans-unit id="7e9c689c33f3c0bb551be00e08e8e196af6dd530" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while &lt;strong&gt;implicitly&lt;/strong&gt; unwrapping an Optional value</source>
          <target state="translated">치명적 오류 : &lt;strong&gt;암시 적&lt;/strong&gt; 으로 선택적 값을 래핑 해제하는 동안 예기치 않게 nil이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="63b2f6bd19b28c7b1987bcb9dd32336331c79410" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</source>
          <target state="translated">치명적 오류 : 암시 적으로 선택적 값을 래핑 해제하는 동안 예기치 않게 nil이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="5ee449f8148453a77ee10bc85af161a2bf6904d0" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while unwrapping an Optional value</source>
          <target state="translated">치명적인 오류 : 선택적 값을 래핑 해제하는 동안 예기치 않게 nil이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c2c4179c8fff9ca83b586e12a580e908e386c5c" translate="yes" xml:space="preserve">
          <source>First, you should know what an Optional value is.
You can step to &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;The Swift Programming Language&lt;/a&gt; for detail.</source>
          <target state="translated">먼저 선택적 값이 무엇인지 알아야합니다. 자세한 내용 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;은 Swift Programming Language&lt;/a&gt; 로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="fe3fb55243316c9dc924d99b807f5717582eeb12" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have an optional string:</source>
          <target state="translated">예를 들어, 선택적 문자열이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="8bd561982c688335d8305fd365ca075aba1100cc" translate="yes" xml:space="preserve">
          <source>For example, say we have a variable &lt;code&gt;foo&lt;/code&gt;, of type an optional &lt;code&gt;Foo&lt;/code&gt; instance.</source>
          <target state="translated">예를 들어, 선택적 &lt;code&gt;Foo&lt;/code&gt; 인스턴스 유형의 변수 &lt;code&gt;foo&lt;/code&gt; 가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fe78f7c529115814a0589403fb98c66ea73e508" translate="yes" xml:space="preserve">
          <source>Guard statements were added in Swift 2. Guard lets you preserve the &quot;golden path&quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using &quot;if let&quot; optional binding.</source>
          <target state="translated">Guard 문은 Swift 2에 추가되었습니다. Guard를 사용하면 코드를 통해 &quot;골든 경로&quot;를 보존 할 수 있으며 &quot;if let&quot;옵션 바인딩을 사용하여 가끔씩 증가하는 중첩 된 if 수준을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93edce2bfc57c7c54e7fd4b314121e6beb589d57" translate="yes" xml:space="preserve">
          <source>Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">또한 Guard는 여러 개의 옵션을 동시에 래핑 해제하고 &lt;code&gt;where&lt;/code&gt; 절을 사용하는 등 if 문이 지원하는 것과 동일한 깔끔한 트릭을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ad08562b159908e3b05f037b3e013647aba536b4" translate="yes" xml:space="preserve">
          <source>Hence it's better to write as such:</source>
          <target state="translated">따라서 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fd4007c3ff26895e5bb5fb48507590600d2502eb" translate="yes" xml:space="preserve">
          <source>Here by force casting you tell the compiler to no longer worry, as you'll always have a &lt;code&gt;Rectangle&lt;/code&gt; instance there. And as long as that holds, you don't have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.</source>
          <target state="translated">여기서 강제 캐스팅을 사용하면 항상 &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스가 있으므로 컴파일러에 더 이상 걱정하지 않아도됩니다. 그리고 그것이 유지되는 한, 당신은 걱정할 필요가 없습니다. 프로젝트의 사용자 또는 동료가 직사각형이 아닌 값을 순환하기 시작할 때 문제가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="a10432c3dfc4ac875e419233a429110d852331d9" translate="yes" xml:space="preserve">
          <source>Here is an example of optional binding with our &lt;code&gt;foo&lt;/code&gt; optional:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; optional과의 선택적 바인딩 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1995e5026962d6c02dca7e583fc61ef9cd31d6c" translate="yes" xml:space="preserve">
          <source>How can I safely deal with Optionals?</source>
          <target state="translated">옵션을 어떻게 안전하게 다룰 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e484fea1c47d9e20459264fe14e22be925d72d1b" translate="yes" xml:space="preserve">
          <source>How to deal with optionals:</source>
          <target state="translated">옵션을 다루는 방법 :</target>
        </trans-unit>
        <trans-unit id="8633d1988d44234fa26b09689d230a24a81c00ff" translate="yes" xml:space="preserve">
          <source>However, 99.9% of the time when working with optionals, you&amp;rsquo;ll actually want to access the value it contains, if it contains one at all. To do this, you can use &lt;em&gt;Optional Binding&lt;/em&gt;.</source>
          <target state="translated">그러나 옵션을 사용하여 작업하는 경우 시간의 99.9 %가 실제로 포함 된 값에 액세스하려는 경우 실제로 값에 액세스하려고합니다. 이를 위해 &lt;em&gt;Optional Binding을&lt;/em&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bcd13ba1c830e1eb8ee339d08e57ceccdcf9a16" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;anOptionalString&lt;/code&gt; doesn&amp;rsquo;t have a value, &lt;code&gt;map&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">그러나 &lt;code&gt;anOptionalString&lt;/code&gt; 에 값이 없으면 &lt;code&gt;map&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a00cf22dac7a818231c0ff4ab31cff56b029afeb" translate="yes" xml:space="preserve">
          <source>However, there are a &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;few scenarios where implicitly unwrapped optionals are beneficial&lt;/a&gt;, and you are still able to use various ways of safely unwrapping them as listed below &amp;ndash; but you should &lt;em&gt;always&lt;/em&gt; use them with due caution.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;암시 적으로 래핑되지 않은 옵션이 유리한 몇 가지 시나리오가 있으며&lt;/a&gt; 아래 나열된대로 안전하게 래핑 해제하는 다양한 방법을 계속 사용할 수 있습니다. 그러나 &lt;em&gt;항상&lt;/em&gt; 주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="045cfcd48cc9a7581c9554c6d0db82a58d3a86d5" translate="yes" xml:space="preserve">
          <source>However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because &lt;code&gt;foo&lt;/code&gt; is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods &amp;ndash; or unwrap &lt;code&gt;foo&lt;/code&gt; itself before accessing methods or calling methods that return values.</source>
          <target state="translated">그러나 속성에 액세스하거나 값을 반환하는 메서드를 호출하려고하면 상황이 조금 더 까다로워집니다. &lt;code&gt;foo&lt;/code&gt; 는 선택 사항이므로, foo 에서 리턴 된 것은 선택 사항입니다. 이 문제를 해결하기 위해 위의 방법 중 하나를 사용하여 반환 된 옵션을 래핑 해제하거나 메서드에 액세스하거나 값을 반환하는 메서드를 호출하기 전에 &lt;code&gt;foo&lt;/code&gt; 자체를 래핑 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8925a8490bf5fd57f3e11be4c68ec114afe4face" translate="yes" xml:space="preserve">
          <source>I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.</source>
          <target state="translated">메인 스토리 보드에서 뷰 컨트롤러의 사용자 정의 클래스 이름을 지정하지 않았기 때문에 테이블 뷰 컨트롤러에서 뷰 컨트롤러로 segue를 만드는 동안이 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="961d19ccc70f1d74e0009e3c081c86736529fa59" translate="yes" xml:space="preserve">
          <source>I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:</source>
          <target state="translated">다음과 같이 segue 준비 방법에서 Outlets 값을 설정하려고 할 때이 오류가 한 번 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c9821ba4ff1ad0757f5f86a478e8819368f2e4a1" translate="yes" xml:space="preserve">
          <source>I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn't addressed the issue itself directly.</source>
          <target state="translated">이 답변이 표시된 답변이 선택 사항을 이해하고 작동 방식을 이해하는 데 큰 도움이되지만 문제 자체를 직접 해결하지는 못했음을 발견 한 것과 동일한 문제로 누군가를 도울 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="687e27bcc1f747e004946e97f14c1a09937a1708" translate="yes" xml:space="preserve">
          <source>IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, &lt;em&gt;after&lt;/em&gt; initialization. You should therefore ensure that you&amp;rsquo;re not accessing outlets before they're loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be &lt;code&gt;nil&lt;/code&gt; at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.</source>
          <target state="translated">특히 IBOutlet은 일반적으로 암시 적으로 래핑되지 않은 옵션입니다. 초기화 &lt;em&gt;후&lt;/em&gt; xib 또는 스토리 보드가 런타임에 콘센트를 연결하기 때문입니다. 따라서 콘센트가로드되기 전에 콘센트에 액세스하지 않는지 확인해야합니다. 또한 스토리 보드 / xib 파일에서 연결이 올바른지 확인해야합니다. 그렇지 않으면 런타임시 값이 &lt;code&gt;nil&lt;/code&gt; 아니므로 암시 적으로 충돌하면 충돌합니다. 래핑되지 않은. 연결을 수정할 때 콘센트를 정의하는 코드 줄을 삭제 한 다음 다시 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="cbf8b026a781fcaf4a77cedd0a311b396615b39b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;anOptionalInt&lt;/code&gt; contains a value, it will be unwrapped and assigned to the new &lt;code&gt;number&lt;/code&gt; constant. The code &lt;em&gt;after&lt;/em&gt; the guard will then continue executing. If it doesn&amp;rsquo;t contain a value &amp;ndash; the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.</source>
          <target state="translated">&lt;code&gt;anOptionalInt&lt;/code&gt; 에 값이 포함되어 있으면 값이 래핑되지 않고 새 &lt;code&gt;number&lt;/code&gt; 상수에 할당됩니다. 가드 &lt;em&gt;이후&lt;/em&gt; 의 코드는 계속 실행됩니다. 값을 포함하지 않는 경우 &amp;ndash; 가드는 괄호 안에있는 코드를 실행하여 제어권을 양도하므로 즉시 코드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="555b9e1b03e3ef819963d13f4ad1e9cd6291d3bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;foo&lt;/code&gt; contains a value, this method will be called on it. If it doesn&amp;rsquo;t, nothing bad will happen &amp;ndash; the code will simply continue executing.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 에 값이 포함되어 있으면이 메소드가 호출됩니다. 그렇지 않으면 나쁜 일이 발생하지 않습니다. 코드는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd5e74dcdb489bc0ac5f2ed761961f64038c09a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someThrowingFunc()&lt;/code&gt; throws an error, the error will be safely caught in the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;someThrowingFunc()&lt;/code&gt; 에서 오류가 발생하면 &lt;code&gt;catch&lt;/code&gt; 블록에서 오류가 안전하게 잡 힙니다.</target>
        </trans-unit>
        <trans-unit id="d952b11c89cd854be27de0d0f65ed17e3c578f0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someVariable&lt;/code&gt; is nil, then you'll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you're guaranteeing to the compiler that you'll never have nil values there. And guess what it happens if somehow a nil value ends in in &lt;code&gt;someVariable&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;someVariable&lt;/code&gt; 이 nil이면 충돌이 발생합니다. 강제 랩 해제를 수행하면 기본적으로 강제 랩 해제를 수행하여 컴파일러에서 nil check 책임을 사용자에게 옮길 수 있습니다. 어떻게 든 nil 값이 &lt;code&gt;someVariable&lt;/code&gt; 로 끝나는 경우 어떻게 될지 추측 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c01ad95af312c93699d0f265e3b3b0b10e9f23a1" translate="yes" xml:space="preserve">
          <source>If we wanted to call a method on &lt;code&gt;foo&lt;/code&gt; that doesn&amp;rsquo;t return anything, we can simply do:</source>
          <target state="translated">아무것도 반환하지 않는 &lt;code&gt;foo&lt;/code&gt; 에서 메소드를 호출하려면 간단히 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="78da2ff6a4b5799b4addacf92cf6d2b26fb23cc8" translate="yes" xml:space="preserve">
          <source>If you get this error in CollectionView try to create CustomCell file and Custom xib also.</source>
          <target state="translated">CollectionView에서이 오류가 발생하면 CustomCell 파일 및 Custom xib도 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0127a3535a0583ab1a79af7eea2befd762a366e7" translate="yes" xml:space="preserve">
          <source>Implicitly Unwrapped Optionals</source>
          <target state="translated">암시 적으로 래핑되지 않은 옵션</target>
        </trans-unit>
        <trans-unit id="051898db5718d1ca1229f4edae90fa5baa7e3071" translate="yes" xml:space="preserve">
          <source>Implicitly unwrapped optionals. Let's assume you have the following class definition:</source>
          <target state="translated">암시 적으로 랩핑되지 않은 옵션. 다음과 같은 클래스 정의가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="484536419577c05bc013ad78ac088dd3099a07ed" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;generic type&lt;/a&gt; that can contain a value (of any kind), or no value at all.</source>
          <target state="translated">Swift에서 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; 은 임의의 값을 포함하거나 전혀 값을 포함 할 수없는 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;일반 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79a7dee40b7721bf417ab75a0b14f771e29d4b3d" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;strong&gt;&lt;em&gt;any type&lt;/em&gt; can be made optional&lt;/strong&gt;. An optional value can take on any value from the original type, &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;or&lt;/em&gt;&lt;/a&gt; the special value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Swift에서는 &lt;strong&gt;&lt;em&gt;모든 유형&lt;/em&gt; 을 선택적으로 만들 수 있습니다&lt;/strong&gt; . 선택적 값은 원래 유형의 값 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;또는&lt;/em&gt;&lt;/a&gt; 특수 값 &lt;code&gt;nil&lt;/code&gt; 을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04774461a3612ca563f0e36ff0dbf0f0ec4fa74c" translate="yes" xml:space="preserve">
          <source>In many other programming languages, a particular &quot;sentinel&quot; value is often used to indicate a &lt;em&gt;lack of a value&lt;/em&gt;. In Objective-C, for example, &lt;code&gt;nil&lt;/code&gt; (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;null pointer&lt;/a&gt;) indicates the lack of an object. But this gets more tricky when working with primitive types &amp;mdash; should &lt;code&gt;-1&lt;/code&gt; be used to indicate the absence of an integer, or perhaps &lt;code&gt;INT_MIN&lt;/code&gt;, or some other integer? If any particular value is chosen to mean &quot;no integer&quot;, that means it can no longer be treated as a &lt;em&gt;valid&lt;/em&gt; value.</source>
          <target state="translated">다른 많은 프로그래밍 언어에서 특정 &quot;센티넬&quot;값은 종종 값 &lt;em&gt;부족&lt;/em&gt; 을 나타내는 데 사용됩니다. 예를 들어 Objective-C에서 &lt;code&gt;nil&lt;/code&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;null 포인터&lt;/a&gt; )은 객체가 없음을 나타냅니다. 그러나 이것은 프리미티브 유형으로 작업 할 때 더 까다로워집니다. 정수 또는 &lt;code&gt;INT_MIN&lt;/code&gt; 또는 다른 정수가 없음을 나타내는 데 &lt;code&gt;-1&lt;/code&gt; 을 사용해야합니까? &quot;정수 없음&quot;을 의미하도록 특정 값을 선택하면 더 이상 &lt;em&gt;유효한&lt;/em&gt; 값으로 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="46b85b18ba2133633a4afcab43ae7743b50be6e2" translate="yes" xml:space="preserve">
          <source>In order to access an optional&amp;rsquo;s value (if it has one at all), you need to &lt;strong&gt;unwrap&lt;/strong&gt; it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it &lt;em&gt;didn't&lt;/em&gt; have a value, your program will crash with the above message.</source>
          <target state="translated">옵션의 값에 액세스하려면 (옵션이있는 경우) &lt;strong&gt;랩핑&lt;/strong&gt; 을 &lt;strong&gt;해제&lt;/strong&gt; 해야합니다. 선택적인 값은 안전하거나 강제로 풀 수 있습니다. 옵션을 강제로 풀고 값 &lt;em&gt;이 없으면&lt;/em&gt; 위의 메시지와 함께 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="2870a2cd345396e3c49f99168c09a7038d33fa6f" translate="yes" xml:space="preserve">
          <source>In order to work out which variable caused the crash, you can hold</source>
          <target state="translated">충돌을 일으킨 변수를 파악하기 위해</target>
        </trans-unit>
        <trans-unit id="ee021373ae2b52768be006a0a1a52dc063c5b011" translate="yes" xml:space="preserve">
          <source>In other words, rather use:</source>
          <target state="translated">즉, 오히려 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c40e8f1772cb4a16417b4c1962c3c56e76be0301" translate="yes" xml:space="preserve">
          <source>In that case foo is still an optional, but you don't have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it's nil.</source>
          <target state="translated">이 경우 foo는 여전히 선택 사항이지만 참조하기 위해 랩을 풀 필요는 없습니다. 즉, foo를 참조하려고 할 때마다 nil이면 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="8bedbb9a541d4d033efb3e04645647ad1c32d4d3" translate="yes" xml:space="preserve">
          <source>It essentially lets you say &amp;ldquo;If &lt;code&gt;a&lt;/code&gt; contains a value, unwrap it. If it doesn&amp;rsquo;t then return &lt;code&gt;b&lt;/code&gt; instead&amp;rdquo;. For example, you could use it like this:</source>
          <target state="translated">본질적으로&amp;ldquo;값에 포함 된 값은 포장을 풉니 다. 그렇지 않으면 대신 &lt;code&gt;b&lt;/code&gt; 를 반환하십시오.&amp;rdquo; 예를 들어 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0ef45d1f8d084087d25064193cc17d964245ca" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s just shorthand for:</source>
          <target state="translated">다음과 같은 속기입니다.</target>
        </trans-unit>
        <trans-unit id="459fe8274d538afa06b4cd892cfc12fa3846a208" translate="yes" xml:space="preserve">
          <source>Learn how to debug an iOS app crash</source>
          <target state="translated">iOS 앱 충돌을 디버깅하는 방법 알아보기</target>
        </trans-unit>
        <trans-unit id="aaee9b9adb35ca322a119d776bbbe533b4d1fb20" translate="yes" xml:space="preserve">
          <source>Long story short by using &lt;code&gt;var address : Address!&lt;/code&gt; you're &lt;strong&gt;hiding&lt;/strong&gt; the possibility that a variable can be &lt;code&gt;nil&lt;/code&gt; from other readers. And when it crashes you're like &quot;what the hell?! my &lt;code&gt;address&lt;/code&gt; isn't an optional, so why am I crashing?!.</source>
          <target state="translated">&lt;code&gt;var address : Address!&lt;/code&gt; 를 사용하여 간단히 이야기하십시오 ! 다른 독자에게는 변수가 없을 가능성을 &lt;strong&gt;숨기고&lt;/strong&gt; 있습니다. 그리고 그것이 충돌 할 때 당신은 &quot;도대체 무엇입니까?! 내 &lt;code&gt;address&lt;/code&gt; 는 선택 사항이 아니므로 왜 충돌합니까?!.&quot;</target>
        </trans-unit>
        <trans-unit id="78cef24b9706680cc584904b5e88b79801d759b5" translate="yes" xml:space="preserve">
          <source>Most of the time you will use the complete Do-Try-Catch system - and the optional one, &lt;code&gt;try?&lt;/code&gt;, in the rare cases where handling the error is not important.</source>
          <target state="translated">대부분의 경우 완전한 Do-Try-Catch 시스템을 사용하고 선택적인 시스템을 &lt;code&gt;try?&lt;/code&gt; 드문 경우이지만 오류 처리가 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35e9fc497ab02ab074e552f7be54dc7f776c210a" translate="yes" xml:space="preserve">
          <source>My Swift program is crashing with &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and one of the following similar errors. What does this error mean, and how do I fix it?</source>
          <target state="translated">내 Swift 프로그램이 &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; 및 다음과 유사한 오류 중 하나로 충돌합니다. 이 오류는 무엇을 의미하며 어떻게 수정합니까?</target>
        </trans-unit>
        <trans-unit id="56a078777cdf9213e116547d03f394624b748e2b" translate="yes" xml:space="preserve">
          <source>Nil Coalescing Operator</source>
          <target state="translated">무 응집 연산자</target>
        </trans-unit>
        <trans-unit id="9b06cd01bf313f728f850e8f6dfbc9e6120741e5" translate="yes" xml:space="preserve">
          <source>Note that the variable you define when you use optional biding only exists (is only &quot;in scope&quot;) in the body of the if statement.</source>
          <target state="translated">선택적 입찰을 사용할 때 정의한 변수는 if 문의 본문에만 존재합니다 ( &quot;범위&quot;에만 있음).</target>
        </trans-unit>
        <trans-unit id="4c10eb68d56cba105bdf477429d00aea854d4ccd" translate="yes" xml:space="preserve">
          <source>Now if no nullability annotations are specified (either explicitly or via &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt;/&lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;), then the &lt;code&gt;name&lt;/code&gt; property will be imported in Swift as &lt;code&gt;String!&lt;/code&gt; (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if &lt;code&gt;name&lt;/code&gt; is nil.</source>
          <target state="translated">이제 명시 적으로 또는 &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; / &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt; 를 통해 Null 허용 주석을 지정하지 않으면 &lt;code&gt;name&lt;/code&gt; 속성을 Swift에서 &lt;code&gt;String!&lt;/code&gt; 으로 가져옵니다 ! (IUO-암시 적으로 래핑되지 않은 옵션). 일부 신속한 코드가 값을 사용하려는 즉시 &lt;code&gt;name&lt;/code&gt; 이 nil이면 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="16ffd92502b92b7dab0de459501aee70aad84527" translate="yes" xml:space="preserve">
          <source>Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you'll want to use the outlet.
Solution? Make sure all outlets are connected. Or use the &lt;code&gt;?&lt;/code&gt; operator on them: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.</source>
          <target state="translated">이제 XIB 편집기에서 콘센트 연결을 놓치면 콘센트를 사용하려는 즉시 앱이 중단됩니다. 해결책? 모든 콘센트가 연결되어 있는지 확인하십시오. 또는 &lt;code&gt;?&lt;/code&gt; 그들에 연산자 : &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt; . 또는 콘센트를 선택 사항으로 선언하지만이 경우 컴파일러는 코드 전체에서 코드를 풀어야합니다.</target>
        </trans-unit>
        <trans-unit id="f75a096d58dde4b74701e26c90ea72ae64747b35" translate="yes" xml:space="preserve">
          <source>Now, if no-one messes up with the &lt;code&gt;name&lt;/code&gt; property by setting it to &lt;code&gt;nil&lt;/code&gt;, then it works as expected, however if &lt;code&gt;User&lt;/code&gt; is initialized from a JSON that lacks the &lt;code&gt;name&lt;/code&gt; key, then you get the fatal error when trying to use the property.</source>
          <target state="translated">이제 아무도 &lt;code&gt;name&lt;/code&gt; 속성을 &lt;code&gt;nil&lt;/code&gt; 로 설정하여 엉망으로 만들지 않으면 예상대로 작동하지만 &lt;code&gt;User&lt;/code&gt; 가 &lt;code&gt;name&lt;/code&gt; 키가없는 JSON에서 초기화되면 속성을 사용하려고 할 때 치명적인 오류가 발생합니다. .</target>
        </trans-unit>
        <trans-unit id="936cf8bab3f747e065f42e3415906001fcaec17a" translate="yes" xml:space="preserve">
          <source>One other way, if you don't want to check the variable state before your implementation, you can also use &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; instead.</source>
          <target state="translated">다른 방법으로, 구현 전에 변수 상태를 확인하지 않으려면 &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; 대신 &quot;buildingName&quot; .</target>
        </trans-unit>
        <trans-unit id="4a3f188326fc444bc42e44fa25a0acf6b3ccac81" translate="yes" xml:space="preserve">
          <source>Optional Binding</source>
          <target state="translated">선택적 바인딩</target>
        </trans-unit>
        <trans-unit id="7a826a948d8f9ecc960c32ca6f545004bbd4247e" translate="yes" xml:space="preserve">
          <source>Optional Binding allows you to check if an optional contains a value &amp;ndash; and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; or &lt;code&gt;if var x = anOptional {...}&lt;/code&gt;, depending if you need to modify the value of the new variable after binding it.</source>
          <target state="translated">선택적 바인딩을 사용하면 옵션에 값이 포함되어 있는지 확인할 수 있으며 래핑되지 않은 값을 새 변수 또는 상수에 할당 할 수 있습니다. 바인딩 후 새 변수의 값을 수정 &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; 또는 &lt;code&gt;if var x = anOptional {...}&lt;/code&gt; 인 경우 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">옵션 체인</target>
        </trans-unit>
        <trans-unit id="1661a949efe8ce7e832a8022541343bb817a5148" translate="yes" xml:space="preserve">
          <source>Optionals are defined with a &lt;code&gt;?&lt;/code&gt; suffix on the type:</source>
          <target state="translated">옵션은 &lt;code&gt;?&lt;/code&gt; 로 정의됩니다 . 유형의 접미사 :</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">또는 이렇게 :</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="54833e81302d6311cef1a28ed09adc3690301a62" translate="yes" xml:space="preserve">
          <source>Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.</source>
          <target state="translated">둘째, 선택적 값에는 두 가지 상태가 있습니다. 하나는 전체 값이고 다른 하나는 nil 값입니다. 따라서 선택적 값을 구현하기 전에 어떤 상태인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="03c6c8c8bdb83cd4b0856641a961cecbc0c85b85" translate="yes" xml:space="preserve">
          <source>Since the above answers clearly explains how to play safely with Optionals.
I will try explain what Optionals are really in swift.</source>
          <target state="translated">위의 답변은 옵션으로 안전하게 연주하는 방법을 명확하게 설명하기 때문에. 나는 선택 사항이 실제로 신속하다는 것을 설명하려고 노력할 것입니다.</target>
        </trans-unit>
        <trans-unit id="dad624a90b7df3a23e5bb578feeeabdd12ee8888" translate="yes" xml:space="preserve">
          <source>So I solved it this way:</source>
          <target state="translated">그래서 나는 이것을 이렇게 해결했다.</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">따라서이 코드 :</target>
        </trans-unit>
        <trans-unit id="afb1b762e29712aa3b112a22ea2e06690f91025a" translate="yes" xml:space="preserve">
          <source>So to assign a nil to our variable 'i'. We can do 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt;
or to assign a value, we will pass some value 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</source>
          <target state="translated">변수 'i'에 nil을 할당합니다. &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt; 하거나 값을 할당 할 수 있습니다. var i = Optional &amp;lt;Int&amp;gt; .some &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a43ac01380800da0acd970a8b899fd1a1eb60e8" translate="yes" xml:space="preserve">
          <source>So you could use code like this:</source>
          <target state="translated">따라서 다음과 같은 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b04e4285f916f64b8ec1d071584592d993d42c35" translate="yes" xml:space="preserve">
          <source>So, to use them with an optional binding, you can do this:</source>
          <target state="translated">따라서 선택적 바인딩과 함께 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7547ba07041dcef70d621cc40b5c4a45b8ce5e45" translate="yes" xml:space="preserve">
          <source>Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as &lt;code&gt;nonnull&lt;/code&gt;.</source>
          <target state="translated">해결책? Objective-C 코드에 널 입력 가능 주석을 추가하십시오. 그러나 Objective-C 컴파일러는 널 (null) 가능성에있어 약간 허용하기 때문에 명시 적으로 &lt;code&gt;nonnull&lt;/code&gt; 것으로 표시하더라도 nil 값으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e5455e8973ef67576894c1d0ab773692ab9e50" translate="yes" xml:space="preserve">
          <source>Solution? Don't use them :) Unless you're 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property</source>
          <target state="translated">해결책? 사용하지 마십시오 :) 102 %가 속성을 사용해야 할 때까지 항상 0이 아닌 값을 가질 것이라고 확신하지 않는 한. 대부분의 경우 선택적 또는 비 선택적으로 변환하면 작동합니다. 선택 사항이 아닌 옵션을 만들면 누락 된 코드 경로에 해당 속성에 값을 제공하여 알려주는 컴파일러가 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dbbb73b74bb82fd31f9eda3643a242450fdeebf5" translate="yes" xml:space="preserve">
          <source>Solution? Use optional binding (aka if-let), do the variable processing there:</source>
          <target state="translated">해결책? 선택적 바인딩 (일명 if-let)을 사용하여 변수 처리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f6514760b09d36bf6238bb6b2eecdafcf283abf2" translate="yes" xml:space="preserve">
          <source>Something simple that is worth checking if all else looks ok</source>
          <target state="translated">다른 모든 것이 괜찮아 보이는지 확인할 가치가있는 간단한 것</target>
        </trans-unit>
        <trans-unit id="d9bf36cacd5682e9de59257e72eab5c7866cf9e7" translate="yes" xml:space="preserve">
          <source>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake.</source>
          <target state="translated">Swift는 형식에 안전한 언어이므로 코드를 사용하여 코드를 사용할 수있는 값의 유형을 명확하게 알 수 있습니다. 코드의 일부에 문자열이 필요한 경우 형식 안전으로 인해 실수로 Int를 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0191ce146a46db014aa0959a5ad6aab2ad0a906a" translate="yes" xml:space="preserve">
          <source>Swift optionals let you set up a variable of any type to contain either a valid value, or no value.</source>
          <target state="translated">Swift 옵션을 사용하면 유효한 값을 포함하거나 값을 포함하지 않는 모든 유형의 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f50948ddb6a9405af006b565688093e07e7df89" translate="yes" xml:space="preserve">
          <source>Swift uses the concept of &quot;Optionals&quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.</source>
          <target state="translated">Swift는 &quot;옵션&quot;개념을 사용하여 값을 포함하거나 포함하지 않을 수있는 값을 처리합니다. C와 같은 다른 언어에서는 값이 0임을 나타내는 변수에 값 0을 저장할 수 있습니다. 그러나 0이 유효한 값이면 어떻게됩니까? 그런 다음 -1을 사용할 수 있습니다. -1이 유효한 값이면 어떻게됩니까? 등등.</target>
        </trans-unit>
        <trans-unit id="8733a9d6eaaff2ad81a4c469105c4f2aa8f27191" translate="yes" xml:space="preserve">
          <source>Swift's error handling system can be safely used with &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;:</source>
          <target state="translated">Swift의 오류 처리 시스템은 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt; 와 함께 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab6e4d9938362d2634e37c6d271130b036be9f7" translate="yes" xml:space="preserve">
          <source>TL;DR answer</source>
          <target state="translated">TL; DR 답변</target>
        </trans-unit>
        <trans-unit id="5910011e369d233145df2614ffbb9258f70e2bc9" translate="yes" xml:space="preserve">
          <source>The &quot;!&quot; operator is a &quot;force unwrap&quot; operator. It says &quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.&quot; If you are wrong, you crash.</source>
          <target state="translated">&quot;!&quot; 연산자는 &quot;포스 랩 해제&quot;연산자입니다. &quot;나를 믿어 라. 내가하고있는 일을 안다.이 코드가 실행될 때 변수에 nil이 포함되지 않는다&quot;고 말한다. 당신이 틀리면 추락합니다.</target>
        </trans-unit>
        <trans-unit id="cc8497513f48b57bcdbd220d3e716cb1d4a6b09b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; is a nifty shorthand version of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;ternary conditional operator&lt;/a&gt;, primarily designed to convert optionals to non-optionals. It has the syntax &lt;code&gt;a ?? b&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an optional type and &lt;code&gt;b&lt;/code&gt; is the same type as &lt;code&gt;a&lt;/code&gt; (although usually non-optional).</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; 는 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;삼항 조건 연산자&lt;/a&gt; 의 간결한 단축 버전으로, 선택 사항을 선택 사항이 아닌 옵션으로 변환하도록 설계되었습니다. 그것은 구문을 &lt;code&gt;a ?? b&lt;/code&gt; b 는 여기서 선택적 유형이고 &lt;code&gt;b&lt;/code&gt; 는 a 와 동일한 유형입니다 (보통 비 선택적임).</target>
        </trans-unit>
        <trans-unit id="4f39a8383e521eac4930320b3f781463d412042a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; constant you see in the &lt;code&gt;catch&lt;/code&gt; block has not been declared by us - it's automatically generated by &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 블록에 표시되는 &lt;code&gt;error&lt;/code&gt; 상수는 우리에 의해 선언되지 않았습니다. &lt;code&gt;catch&lt;/code&gt; 에 의해 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cd0c0cb00ef66003262f22de70ce81e5de3dbebd" translate="yes" xml:space="preserve">
          <source>The concepts explained in this post also apply here: if an error is thrown, the application will crash.</source>
          <target state="translated">이 게시물에 설명 된 개념도 여기에 적용됩니다. 오류가 발생하면 응용 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4353dc8328b849dd5eee0ba9343f34b63353af" translate="yes" xml:space="preserve">
          <source>The errors &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; appears the most when you have declared an &lt;code&gt;@IBOutlet&lt;/code&gt;, but not connected to the &lt;strong&gt;storyboard&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; 오류와 &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; 은 &lt;code&gt;@IBOutlet&lt;/code&gt; 을 선언했지만 &lt;strong&gt;스토리 보드에&lt;/strong&gt; 연결되지 않은 경우에 가장 많이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f944bc0d51db4c42e0ab501ffaf2c9361c58f7c9" translate="yes" xml:space="preserve">
          <source>The full code would be :</source>
          <target state="translated">전체 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39947ad748876c5ade4da078e8c8623048e5ffc6" translate="yes" xml:space="preserve">
          <source>The full code would be:</source>
          <target state="translated">전체 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49a1afbffea19fea31c8bef0f4563791d58a8dc2" translate="yes" xml:space="preserve">
          <source>The lack of a value in an optional is indicated by &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">선택 사항에 값이 없음은 &lt;code&gt;nil&lt;/code&gt; 로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="37d4ab0d4c249a69f4593634c7af51c35f6f73fc" translate="yes" xml:space="preserve">
          <source>The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a &lt;em&gt;guard statement&lt;/em&gt;.</source>
          <target state="translated">if 문 내에서 선택적 바인딩을 사용하는 유일한 방법은 명령문 범위 내에서 래핑되지 않은 값에만 액세스 할 수 있다는 것입니다. 명령문 범위 밖에서 값에 액세스해야하는 경우 &lt;em&gt;guard 문을&lt;/em&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77a167b0cfc56774bff7d7b752b55f5f670e549d" translate="yes" xml:space="preserve">
          <source>The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can &lt;em&gt;only&lt;/em&gt; execute if the optional has a value). This is a great for eliminating &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;&amp;lsquo;pyramids of doom&amp;rsquo;&lt;/a&gt; created by nesting multiple if statements.</source>
          <target state="translated">가드 명령문에 대한 실제 깔끔한 점은 언 래핑 된 값을 명령문 다음에 오는 코드에서 사용할 수 있다는 것입니다. 이것은 여러 if 문을 중첩하여 생성 된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;'피라미드의 운명'&lt;/a&gt; 을 제거하는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f70e19cc299904e989d46111669248e2d6297b5a" translate="yes" xml:space="preserve">
          <source>The simplest way to check whether an optional contains a value, is to compare it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">선택 사항에 값이 포함되어 있는지 확인하는 가장 간단한 방법은 &lt;code&gt;nil&lt;/code&gt; 과 비교하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ad7c64f5b093e808ba67d8a73670ba71bd4ebd5" translate="yes" xml:space="preserve">
          <source>Then I found out that I can't set the values of the destination controller outlets because the controller hasn't been loaded or initialized yet.</source>
          <target state="translated">그런 다음 컨트롤러가 아직로드되거나 초기화되지 않았기 때문에 대상 컨트롤러 콘센트의 값을 설정할 수 없다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="1ec67f9dd2cfab174b6b515c3d0d4747bf7293ec" translate="yes" xml:space="preserve">
          <source>There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)</source>
          <target state="translated">더 안전한 옵션을 처리하는 다른 많은 방법이 있습니다. 다음은 일부 목록입니다 (전체 목록이 아님).</target>
        </trans-unit>
        <trans-unit id="0d60f2d11c0f746729eec725020f1feabe53897f" translate="yes" xml:space="preserve">
          <source>There are several scenarios that lead to this kind of fatal error:</source>
          <target state="translated">이러한 종류의 치명적인 오류로 이어지는 몇 가지 시나리오가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc4935148dd3d0a4d88768551d67d938c2ebaf2" translate="yes" xml:space="preserve">
          <source>There is also a construct called the &quot;nil coalescing operator&quot;. It takes the form &quot;optional_var ?? replacement_val&quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the &quot;??&quot; symbol.</source>
          <target state="translated">&quot;무 연합 연산자&quot;라는 구조도 있습니다. &quot;optional_var ?? replacement_val&quot;형식입니다. 선택 사항에 포함 된 데이터와 동일한 유형의 선택 사항이 아닌 변수를 리턴합니다. 선택 사항에 nil이 포함 된 경우 &quot;??&quot;뒤에있는 표현식의 값을 리턴합니다. 상징.</target>
        </trans-unit>
        <trans-unit id="b6b6bf923d0fa956d7f5415f78e183319a28b7b6" translate="yes" xml:space="preserve">
          <source>There's also &lt;code&gt;try?&lt;/code&gt; which absorbs the error:</source>
          <target state="translated">&lt;code&gt;try?&lt;/code&gt; 오류를 흡수합니다.</target>
        </trans-unit>
        <trans-unit id="051cef13b0cd111883df939c5644ba59bbe86947" translate="yes" xml:space="preserve">
          <source>These are defined with  a &lt;code&gt;!&lt;/code&gt;, rather than a &lt;code&gt;?&lt;/code&gt; after the type.</source>
          <target state="translated">이것들은 &lt;code&gt;!&lt;/code&gt; 대신에 &lt;code&gt;?&lt;/code&gt; 유형 후에.</target>
        </trans-unit>
        <trans-unit id="228d647e0bd3a874c5246256241ffafbe0dae63f" translate="yes" xml:space="preserve">
          <source>These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesn&amp;rsquo;t contain a value, it will crash.</source>
          <target state="translated">이러한 옵션은 값을 포함한다고 가정합니다. 따라서 암시 적으로 랩핑되지 않은 옵션에 액세스 할 때마다 자동으로 랩핑 해제됩니다. 값을 포함하지 않으면 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03d3193f66062a0894aa6946a0e2b6f22b829634" translate="yes" xml:space="preserve">
          <source>These variables are designed so that you can defer their assignment until later in your code. It is &lt;em&gt;your&lt;/em&gt; responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe &amp;ndash; as they &lt;em&gt;assume&lt;/em&gt; your value is non-nil, even though assigning nil is valid.</source>
          <target state="translated">이 변수는 나중에 코드에서 할당을 연기 할 수 있도록 설계되었습니다. 액세스하기 전에 가치가 있는지 확인하는 것은 &lt;em&gt;귀하의&lt;/em&gt; 책임입니다. 그러나 강제 래핑 해제와 관련되어 있기 때문에 nil을 할당하는 것이 유효하더라도 값이 nil이 아닌 &lt;em&gt;것으로 가정&lt;/em&gt; 하기 때문에 여전히 본질적으로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2a9aff700fd23b1fa64684c86c11f3e64379b3e" translate="yes" xml:space="preserve">
          <source>Think of the following code: 
It compiles with no errors/warnings:</source>
          <target state="translated">다음 코드를 생각해보십시오. 오류 / 경고없이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="09d8ef10eee293feb35c82626771fa027ffe930b" translate="yes" xml:space="preserve">
          <source>This answer was intended to be concise, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;for full comprehension read accepted answer&lt;/a&gt;</source>
          <target state="translated">이 답변은 &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;전체 이해를&lt;/a&gt; 돕기 위해 간결하게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="518b372f5b167794f9cb85ed9cffe42f1420058a" translate="yes" xml:space="preserve">
          <source>This can therefore also be used to set properties as well as call methods. For example:</source>
          <target state="translated">따라서 이것은 호출 메소드뿐만 아니라 특성을 설정하는 데에도 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a756f40b006c215a6765390c6966fd17d773cb9" translate="yes" xml:space="preserve">
          <source>This crash can occur with two different kinds of force-unwrap:</source>
          <target state="translated">이 충돌은 두 가지 다른 종류의 강제 전개 해제에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0250df27448e385747e9a13ccb5651fe27b21d" translate="yes" xml:space="preserve">
          <source>This is done with the &lt;code&gt;!&lt;/code&gt; operator on an optional. For example:</source>
          <target state="translated">이것은 &lt;code&gt;!&lt;/code&gt; 옵션에 연산자. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e414f3b50562e4d895870d8df98dbad24cb92fae" translate="yes" xml:space="preserve">
          <source>This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">이것은 더 중요한 주석이며 암시 적으로 래핑되지 않은 옵션이 &lt;code&gt;nil&lt;/code&gt; 값을 디버깅 할 때 기만적 일 수있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="0cb38c500378f3659b7d36d8d3cb7a2ed2377409" translate="yes" xml:space="preserve">
          <source>This question comes up &lt;strong&gt;ALL THE TIME&lt;/strong&gt; on SO. It's one of the first things that new Swift developers struggle with.</source>
          <target state="translated">이 질문은 항상 그렇습니다. 새로운 Swift 개발자가 어려움을 겪는 첫 번째 것 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="fe5ac8dc15cee70308d149380af17fd09b2dcd0b" translate="yes" xml:space="preserve">
          <source>This time the code has been made more clear to you. You can rationalize and think that likely it's the &lt;code&gt;address&lt;/code&gt; parameter that was forcefully unwrapped.</source>
          <target state="translated">이번에는 코드가 더 명확 해졌습니다. 합리화하고 강제로 래핑되지 않은 &lt;code&gt;address&lt;/code&gt; 매개 변수 일 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f93b94e3333c14bc5a8e2daea487de2fd080c3a5" translate="yes" xml:space="preserve">
          <source>This will define a &lt;code&gt;number&lt;/code&gt; constant of &lt;code&gt;Int&lt;/code&gt; type, that will either contain the value of &lt;code&gt;anOptionalInt&lt;/code&gt;, if it contains a value, or &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">이것은 &lt;code&gt;Int&lt;/code&gt; 유형의 &lt;code&gt;number&lt;/code&gt; 상수를 정의하며, 값이 포함 된 경우 &lt;code&gt;anOptionalInt&lt;/code&gt; 값을 포함하고, 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="36079ad7315babb9e3cfd31e04a6700ff9a65fd1" translate="yes" xml:space="preserve">
          <source>Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)</source>
          <target state="translated">따라서 암시 적으로 래핑되지 않은 옵션에주의해야합니다. (선택 사항에 대한 확실한 이해가있을 때까지는 완전히 피하십시오.)</target>
        </trans-unit>
        <trans-unit id="bf4f5d672e4353189b2590d59428129d4a05faa6" translate="yes" xml:space="preserve">
          <source>Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.</source>
          <target state="translated">콘센트가 연결되지 않았거나 아직 연결되지 않았습니다. 이것은 시나리오 # 3의 특별한 경우입니다. 기본적으로 사용하려는 XIB로드 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fbb993222752244a9f031c8c1d545ed152b2357" translate="yes" xml:space="preserve">
          <source>Unless you really &lt;strong&gt;do&lt;/strong&gt; know what you are doing, avoid the &quot;!&quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.</source>
          <target state="translated">실제로하고있는 &lt;strong&gt;일을&lt;/strong&gt; 모르는 경우 &quot;!&quot; 강제 랩 해제 연산자. Swift 프로그래머를 시작하는 데 가장 큰 충돌 원인 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af66b528b3a5e4db51aa7414b4854d62642ea64a" translate="yes" xml:space="preserve">
          <source>Unwrap optional variable using &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;guard let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 또는 &lt;code&gt;guard let&lt;/code&gt; 을 사용하여 선택적 변수 풀기</target>
        </trans-unit>
        <trans-unit id="bd4b5387dfce9931cda3017dc45ec2e24c2238c6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try&lt;/code&gt; this way is the proper way to try, catch and handle errors coming from throwing functions.</source>
          <target state="translated">이 방법으로 &lt;code&gt;try&lt;/code&gt; 를 사용하면 던지는 함수에서 발생하는 오류를 시도, 포착 및 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="da6d8e9893a791f4319490b2d723d4806a84568f" translate="yes" xml:space="preserve">
          <source>Values coming from Objective-C, and that don't have nullability annotations. Let's assume we have the following Objective-C class:</source>
          <target state="translated">Objective-C에서 가져오고 Null 허용 주석이없는 값입니다. 다음 Objective-C 클래스가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="9d11739af047f16216d738c322733a87037f743f" translate="yes" xml:space="preserve">
          <source>What does “Fatal error: Unexpectedly found nil while unwrapping an Optional value” mean</source>
          <target state="translated">&amp;ldquo;치명적 오류 : 선택적 값을 래핑하는 동안 예기치 않게 nil이 발견되었습니다&amp;rdquo;는 의미</target>
        </trans-unit>
        <trans-unit id="5e6a210b7a4319c69606343ec4904762d1eff5e8" translate="yes" xml:space="preserve">
          <source>What this does is first check that the optional contains a value. If it &lt;em&gt;does&lt;/em&gt;, then the &amp;lsquo;unwrapped&amp;rsquo; value is assigned to  a new variable (&lt;code&gt;number&lt;/code&gt;) &amp;ndash; which you can then freely use as if it were non-optional. If the optional &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; contain a value, then the else clause will be invoked, as you would expect.</source>
          <target state="translated">이것이하는 일은 먼저 옵션에 값이 포함되어 있는지 확인하는 것입니다. 이 경우 'unwrapped'값이 새 변수 ( &lt;code&gt;number&lt;/code&gt; )에 지정됩니다.이 옵션은 선택 사항이 아닌 것처럼 자유롭게 사용할 수 있습니다. 옵션에 값 &lt;em&gt;이 없으면&lt;/em&gt; else 절이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="10db728e68ab2e61caf6c0b29942fb92bfcc5927" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.</source>
          <target state="translated">선택적 바인딩의 장점은 여러 옵션을 동시에 풀 수 있다는 것입니다. 문장을 쉼표로 구분하면됩니다. 모든 선택 사항이 랩핑 해제되면 명령문이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="1373ba269d2cc3b83a01653ae7e2e71286d08529" translate="yes" xml:space="preserve">
          <source>When should I ever force unwrap an Optional?</source>
          <target state="translated">언제 옵션을 풀어야합니까?</target>
        </trans-unit>
        <trans-unit id="317e17e5c488981811996349a91cb8951d0d1759" translate="yes" xml:space="preserve">
          <source>When to use and when not to use implicitly unwrapped optionals</source>
          <target state="translated">암시 적으로 랩핑되지 않은 옵션을 사용하고 사용하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1f3a4ea673b0a5e8dc1d2d64df7cf20d096e7fe0" translate="yes" xml:space="preserve">
          <source>Whether you use an if or guard statement completely depends on whether any future code &lt;em&gt;requires&lt;/em&gt; the optional to contain a value.</source>
          <target state="translated">if 또는 guard 문을 완전히 사용할지 여부는 향후 코드에서 선택적 값이 값을 포함해야하는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c54b591d9a12bd724553adb14722d899feefcb1f" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;may&lt;/em&gt; be an occasion where you can use force unwrapping, as you know for a &lt;em&gt;fact&lt;/em&gt; that an optional contains a value &amp;ndash; there is not a &lt;em&gt;single&lt;/em&gt; place where you cannot safely unwrap that optional instead.</source>
          <target state="translated">선택적 옵션에 값이 포함되어 &lt;em&gt;있다는 사실&lt;/em&gt; 을 알고 있듯이 강제 언 랩핑을 사용할 수있는 경우가 있습니다. 대신 해당 옵션을 안전하게 래핑 할 수없는 &lt;em&gt;단일&lt;/em&gt; 지점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="87bd0f61bb6e6865c8ad7d95e74d3227791bcb36" translate="yes" xml:space="preserve">
          <source>Why did I get &amp;ldquo;&lt;em&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;&amp;rdquo;?</source>
          <target state="translated">왜 &quot; &lt;em&gt;치명적 오류 : 선택적 값을 풀 때 예기치 않게 nil이 발견되었습니다&lt;/em&gt; &quot;가 &lt;em&gt;발생하는&lt;/em&gt; 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4ed62fc8759885174a5e1c44082b865686115a7c" translate="yes" xml:space="preserve">
          <source>Will crash on reference to foo's capitalizedString property even though we're not force-unwrapping foo. the print looks fine, but it's not.</source>
          <target state="translated">foo를 강제로 풀지 않더라도 foo의 capitalizedString 속성을 참조하면 충돌이 발생합니다. 인쇄가 잘 보이지만 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e425b6ac11a3cf5713fb75b070bc494a5c64679e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;very few exceptions&lt;/a&gt;, this rule is golden:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;예외&lt;/a&gt; 는 거의 없지만 이 규칙은 황금색입니다.</target>
        </trans-unit>
        <trans-unit id="c496ef8337514f41cb37fdccdcb7d50ad577dff9" translate="yes" xml:space="preserve">
          <source>Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.</source>
          <target state="translated">Xcode는 코드 줄을 강조 표시하여 충돌을 보여줍니다. 이 줄에서 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="839c55483e3111c1ca07f84d7891a2c9b7b1beae" translate="yes" xml:space="preserve">
          <source>Yet at runtime it gives the following error: &lt;em&gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;</source>
          <target state="translated">그러나 런타임시 다음과 같은 오류가 발생합니다. &lt;em&gt;치명적인 오류 : 선택적 값을 래핑 해제하는 동안 예기치 않게 nil이 발견되었습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e9ce0757b971a4c196d317850c0dbdf450d7e30" translate="yes" xml:space="preserve">
          <source>You can also declare &lt;code&gt;error&lt;/code&gt; yourself, it has the advantage of being able to cast it to a useful format, for example:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 직접 선언 할 수도 있습니다. 예를 들어 다음과 같이 유용한 형식으로 캐스트 할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1350d18d0403c656c2c06ac9d6b05eba79938d9b" translate="yes" xml:space="preserve">
          <source>You can use &quot;optional binding&quot; or &quot;if let&quot; to say &quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement&quot;.</source>
          <target state="translated">&quot;선택적 바인딩&quot;또는 &quot;if let&quot;을 사용하여 &quot;이 선택 사항에 값이 포함 된 경우 해당 값을 선택 사항이 아닌 새 변수에 저장하십시오. 선택 사항에 값이 포함되지 않은 경우이 if 문의 본문을 건너 뛰십시오. &quot;.</target>
        </trans-unit>
        <trans-unit id="5d1b249ef279beb59a5d567f45b0c019278cedef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;Optional Chaining&lt;/a&gt; in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a &lt;code&gt;?&lt;/code&gt; when using it.</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;옵션 체인&lt;/a&gt; 을 사용하여 메서드를 호출하거나 옵션의 속성에 액세스 할 수 있습니다. 변수 이름에 &lt;code&gt;?&lt;/code&gt; 를 붙이면됩니다 . 그것을 사용할 때.</target>
        </trans-unit>
        <trans-unit id="aaff60ab9a0fe1d4638638d4410b990a62bde2cf" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;if let ...&lt;/code&gt; or &lt;code&gt;guard let ... else&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;code&gt;if let ...&lt;/code&gt; 또는 &lt;code&gt;guard let ... else&lt;/code&gt; 등을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9ba10c8d2d8d6b1b597f11d55cc435237669ae" translate="yes" xml:space="preserve">
          <source>You can't!</source>
          <target state="translated">당신은 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="6ec1cc83396860fe0f710055f9d7e89e1c8bc165" translate="yes" xml:space="preserve">
          <source>You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.</source>
          <target state="translated">try / catch 또는 guard error handling을 사용할 수도 있지만 일반적으로 위의 다른 기술 중 하나가 더 깔끔합니다.</target>
        </trans-unit>
        <trans-unit id="c4dc5e8cd9f1e69573167fc61cd53e581b19c500" translate="yes" xml:space="preserve">
          <source>You put a question mark after the type when you declare a variable to mean (type x, or no value).</source>
          <target state="translated">변수를 의미로 선언 할 때 (유형 x 또는 값 없음) 유형 뒤에 물음표를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="bf8513637bc93a619e697f6a9595807f32954dc5" translate="yes" xml:space="preserve">
          <source>You should also learn about how &lt;strong&gt;Optionals&lt;/strong&gt; work, mentioned in other answers, but this is the only time that mostly appears to me.</source>
          <target state="translated">다른 답변에서 언급 한 &lt;strong&gt;선택 사항의&lt;/strong&gt; 작동 방식에 대해서도 배워야하지만 지금은 대부분 나에게 나타나는 유일한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="af1087f6530251ae6d010a9f21750da1ea79e979" translate="yes" xml:space="preserve">
          <source>You should only be using implicitly unwrapped optionals as a &lt;em&gt;last resort&lt;/em&gt;. If you can use a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;lazy variable&lt;/a&gt;, or provide a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;default value&lt;/a&gt; for a variable &amp;ndash; you should do so instead of using an implicitly unwrapped optional.</source>
          <target state="translated">&lt;em&gt;최후의 수단&lt;/em&gt; 으로 암시 적으로 래핑되지 않은 옵션 만 사용해야합니다. &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;지연 변수&lt;/a&gt; 를 사용하거나 변수 의 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;기본값을&lt;/a&gt; 제공 할 수있는 경우 암시 적으로 랩핑되지 않은 옵션을 사용하는 대신 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="94f331b5b5c0ba72a4cfb9cf99bdd31fd6ae82d0" translate="yes" xml:space="preserve">
          <source>add this code in ViewDidLoad() at mainVC.</source>
          <target state="translated">mainVC의 ViewDidLoad ()에이 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7f66728a6d981314d1e4ec43c0a4f6c970120d38" translate="yes" xml:space="preserve">
          <source>forced (down)casts:</source>
          <target state="translated">강제 (다운) 캐스트 :</target>
        </trans-unit>
        <trans-unit id="fad23c2241f2181a2dba20635bf0879e56728e33" translate="yes" xml:space="preserve">
          <source>forced unwraps:</source>
          <target state="translated">강제 랩핑 해제 :</target>
        </trans-unit>
        <trans-unit id="958603fb1a0a0dac8fad299a6be3fb83ef2ce3f9" translate="yes" xml:space="preserve">
          <source>while clicking to show the definition, where you might find the optional type.</source>
          <target state="translated">을 클릭하여 정의를 표시하면 선택적 유형을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e8e6ff2989841893307b09e3c62d4b5ade13d31" translate="yes" xml:space="preserve">
          <source>⌥</source>
          <target state="translated">⌥</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
