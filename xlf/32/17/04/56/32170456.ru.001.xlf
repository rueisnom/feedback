<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/32170456">
    <body>
      <group id="32170456">
        <trans-unit id="d3a244fb54042f2dbf42e3fe5fb600311a47bd44" translate="yes" xml:space="preserve">
          <source>1. Explicit Force Unwrapping</source>
          <target state="translated">1.Явная сила Раскручивание</target>
        </trans-unit>
        <trans-unit id="635c6e54ef549bf1619585c9acdb06d314adaf23" translate="yes" xml:space="preserve">
          <source>2. Implicitly Unwrapped Optionals</source>
          <target state="translated">2.Неявно неупакованные опционалы</target>
        </trans-unit>
        <trans-unit id="18d21910bcbc1da8e1aa11e251dedd0b06352cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; has a single method called &lt;code&gt;init(nilLiteral:)&lt;/code&gt; which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with &lt;code&gt;nil&lt;/code&gt; literal.</source>
          <target state="translated">&lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; имеет единственный метод, называемый &lt;code&gt;init(nilLiteral:)&lt;/code&gt; который инициализирует instace с помощью nil. Вы обычно не вызываете этот метод, и согласно быстрой документации не рекомендуется вызывать этот инициализатор напрямую, так как компилятор вызывает его всякий раз, когда вы инициализируете необязательный тип литералом &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9772727897bd3ca247cb46b7f9cb451241ee24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works similarly to &lt;code&gt;map&lt;/code&gt;, except it allows you to return &lt;em&gt;another&lt;/em&gt; optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; работает аналогично &lt;code&gt;map&lt;/code&gt; , за исключением того, что позволяет вам возвращать &lt;em&gt;еще один&lt;/em&gt; необязательный элемент из тела замыкания. Это означает, что вы можете вводить необязательный в процесс, который требует не необязательного ввода, но может сам выводить необязательный.</target>
        </trans-unit>
        <trans-unit id="25b1070a11e663243cc897c90af46f99c6df445c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; и &lt;code&gt;flatMap&lt;/code&gt; карта</target>
        </trans-unit>
        <trans-unit id="c46dee75d89e56932987294e4ff7e4232b363930" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You should only ever use &lt;code&gt;try!&lt;/code&gt; if you can prove that its result will never fail in your context - and this is very rare.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Вы должны использовать только &lt;code&gt;try!&lt;/code&gt; &lt;/em&gt; &lt;em&gt;если вы можете доказать, что его результат никогда не потерпит неудачу в вашем контексте - и это очень редко.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b7730d90c9b2349ff66ee31e8785e67ba52fb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you now tell me which object it is that was &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Можете ли вы сказать мне, что это за &lt;code&gt;nil&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37a5bcf391e8ccb209c28d5fceb142b218d5b019" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can you tell me which object is &lt;code&gt;nil&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Можете ли вы сказать мне, какой объект &lt;code&gt;nil&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f283be4efc0664716ddd69d9cdc7df0c17dbd693" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that this &lt;code&gt;nil&lt;/code&gt; is not the same as the &lt;code&gt;nil&lt;/code&gt; in Objective-C. In Objective-C, &lt;code&gt;nil&lt;/code&gt; is the absence of a valid &lt;em&gt;object pointer&lt;/em&gt;; in Swift, Optionals are not restricted to objects/reference types. Optional behaves similarly to Haskell's &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Maybe&lt;/a&gt;.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Обратите внимание, что это &lt;code&gt;nil&lt;/code&gt; не совпадает с &lt;code&gt;nil&lt;/code&gt; в Objective-C. В Objective-C &lt;code&gt;nil&lt;/code&gt; - это отсутствие действительного &lt;em&gt;указателя объекта&lt;/em&gt; ; в Swift, Optional не ограничиваются объектами / ссылочными типами. Optional ведет себя аналогично Haskell &lt;a href=&quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html&quot;&gt;Может быть&lt;/a&gt; .)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d516eb97f8385312f77ef9000f049aeddc35663f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Note that within the guard body, you &lt;strong&gt;must&lt;/strong&gt; use one of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;control transfer statements&lt;/a&gt; in order to exit the scope of the currently executing code).&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Обратите внимание, что в теле защиты вы &lt;strong&gt;должны&lt;/strong&gt; использовать одну из &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135&quot;&gt;инструкций передачи управления&lt;/a&gt; , чтобы выйти из области текущего выполняемого кода).&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5b87ee6fe147c52e17815abd3b0ac225686bc372" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is because an optional value will return &lt;code&gt;Void?&lt;/code&gt; rather than &lt;code&gt;Void&lt;/code&gt; on a method that doesn&amp;rsquo;t return anything)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Это потому, что необязательное значение будет возвращать &lt;code&gt;Void?&lt;/code&gt; а не &lt;code&gt;Void&lt;/code&gt; для метода, который ничего не возвращает)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8d73db717d8e4390f76c6acdf864843b513507e2" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(This is similar behaviour to sending messages to &lt;code&gt;nil&lt;/code&gt; in Objective-C)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(Это похоже на отправку сообщений на &lt;code&gt;nil&lt;/code&gt; в Objective-C)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8404a61e69301e260a8bda1a58f0ce7110e7cc50" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This answer is &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;community wiki&lt;/a&gt;. If you feel it could be made better, feel free to &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit it&lt;/a&gt;!&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Этот ответ &lt;a href=&quot;https://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts&quot;&gt;вики сообщества&lt;/a&gt; .&lt;/sup&gt; &lt;sup&gt;Если вы чувствуете, что это может быть сделано лучше, не стесняйтесь &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;редактировать это&lt;/a&gt; !&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d92a649ecca38db770e2ea85dae9072443b3c79f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;edit&lt;/a&gt; the existing wiki answer.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Этот пост предназначен для сбора ответов на &amp;laquo;неожиданно найденные ноль&amp;raquo; проблемы, чтобы они не были разбросаны и их было трудно найти.&lt;/sup&gt; &lt;sup&gt;Не стесняйтесь добавлять свой собственный ответ или &lt;a href=&quot;https://stackoverflow.com/posts/32170457/edit&quot;&gt;редактировать&lt;/a&gt; существующий вики-ответ.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eae132614e41cb087afb2d1c01f40480f4698746" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;guard statement&lt;/a&gt; allows you to define a condition for success &amp;ndash; and the current scope will only continue executing if that condition is met. They are defined with the syntax &lt;code&gt;guard condition else {...}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement&quot;&gt;Защитный оператор&lt;/a&gt; позволяет вам определить условие успеха - и текущая область будет продолжать выполняться, только если это условие будет выполнено. Они определены с &lt;code&gt;guard condition else {...}&lt;/code&gt; синтаксиса else {...} .</target>
        </trans-unit>
        <trans-unit id="8dd03209df27cf5183ea0c4aad3e184b5a067c77" translate="yes" xml:space="preserve">
          <source>According to swift, 'nil' is the absence of value.
And to create an instance initialized with &lt;code&gt;nil&lt;/code&gt; We have to conform to a protocol called &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and great if you guessed it, only &lt;code&gt;Optionals&lt;/code&gt; conform to &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; and conforming to other types is discouraged.</source>
          <target state="translated">Согласно Свифту, &amp;laquo;ноль&amp;raquo; - это отсутствие стоимости. И для создания экземпляра, инициализированного с помощью &lt;code&gt;nil&lt;/code&gt; . Мы должны соответствовать протоколу под названием &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; и прекрасно, если вы догадались, только &lt;code&gt;Optionals&lt;/code&gt; ы соответствуют &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt; , и соответствие другим типам не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="45073dbf8f3ef81afe07094beb4f6608a541d353" translate="yes" xml:space="preserve">
          <source>Again, because &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are optional, the value returned from &lt;code&gt;qux&lt;/code&gt; will always be an optional regardless of whether &lt;code&gt;qux&lt;/code&gt; itself is optional.</source>
          <target state="translated">Опять же, поскольку &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; являются необязательными, значение, возвращаемое из &lt;code&gt;qux&lt;/code&gt; , всегда будет необязательным независимо от того, является ли сам &lt;code&gt;qux&lt;/code&gt; необязательным.</target>
        </trans-unit>
        <trans-unit id="04b74eddaac2e0ff122721a98735cd4f4241cab6" translate="yes" xml:space="preserve">
          <source>Again, nothing bad will happen here if &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Your code will simply continue executing.</source>
          <target state="translated">Опять же, ничего плохого здесь не произойдет, если &lt;code&gt;foo&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; . Ваш код просто продолжит выполнение.</target>
        </trans-unit>
        <trans-unit id="9e19419202a958c9e2c652dec63d96656df38091" translate="yes" xml:space="preserve">
          <source>Also, as the name suggests, you can &amp;lsquo;chain&amp;rsquo; these statements together. This means that if &lt;code&gt;foo&lt;/code&gt; has an optional property &lt;code&gt;baz&lt;/code&gt;, which has a property &lt;code&gt;qux&lt;/code&gt; &amp;ndash; you could write the following:</source>
          <target state="translated">Кроме того, как следует из названия, вы можете &amp;laquo;связать&amp;raquo; эти утверждения вместе. Это означает, что если &lt;code&gt;foo&lt;/code&gt; имеет необязательное свойство &lt;code&gt;baz&lt;/code&gt; , которое имеет свойство &lt;code&gt;qux&lt;/code&gt; - вы можете написать следующее:</target>
        </trans-unit>
        <trans-unit id="3231de44e5b6f036b78301686d6ee18d12703f6b" translate="yes" xml:space="preserve">
          <source>Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:</source>
          <target state="translated">В качестве альтернативы можно использовать оператор защиты,который позволяет выйти из функции,если переменная равна нулю:</target>
        </trans-unit>
        <trans-unit id="5df38dfc408955dbdd3d7167930749d99834f562" translate="yes" xml:space="preserve">
          <source>An often underused feature with optionals is the ability to use the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesn&amp;rsquo;t have a value, it will remain &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Часто недоиспользуемая функция с дополнительными функциями - это возможность использовать функции &lt;code&gt;map&lt;/code&gt; и &lt;code&gt;flatMap&lt;/code&gt; . Это позволяет вам применять необязательные преобразования к необязательным переменным. Если необязательный параметр имеет значение, вы можете применить к нему данное преобразование. Если оно не имеет значения, оно останется &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7475dbf59ea659fe38624a59d7089f9c937ce515" translate="yes" xml:space="preserve">
          <source>An optional is actually a container than contains either a variable of a given type, or nothing.</source>
          <target state="translated">Необязательным на самом деле является контейнер,чем содержит либо переменную заданного типа,либо ничего.</target>
        </trans-unit>
        <trans-unit id="3c0e7f41650898afdecfa4b26246b1d90eee328c" translate="yes" xml:space="preserve">
          <source>An optional needs to be &quot;unwrapped&quot; in order to fetch the value inside.</source>
          <target state="translated">Опция должна быть &quot;развернута&quot;,чтобы получить значение внутри.</target>
        </trans-unit>
        <trans-unit id="d26f01d2167b0ccd73f5ca8a245ba70fa537337b" translate="yes" xml:space="preserve">
          <source>And Optional type is nothing but an enumeration with two cases, i.e</source>
          <target state="translated">А опциональный тип-это не что иное,как перечисление с двумя случаями,т.е.</target>
        </trans-unit>
        <trans-unit id="0c9267177db8f82598d60f708a0d70d575d72d06" translate="yes" xml:space="preserve">
          <source>Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.</source>
          <target state="translated">Другой изящный трюк заключается в том,что вы также можете использовать запятые,чтобы проверить определенное условие на величину,после распаковки.</target>
        </trans-unit>
        <trans-unit id="6ddb885b2b01e4ba63f81165812deb39af75a71c" translate="yes" xml:space="preserve">
          <source>Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Еще одна хитрость, которую позволяет делать необязательное связывание, - это проверка успешности установки свойства или вызова метода. Вы можете сделать это, сравнивая возвращаемое значение с &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32470d176ca6dd8f034dc5807b14e045ee20d3c6" translate="yes" xml:space="preserve">
          <source>Another way to declare an optional variable is</source>
          <target state="translated">Другой способ объявить необязательную переменную</target>
        </trans-unit>
        <trans-unit id="443f7eb7f273a4e9c8d9c7fa2251a9bd082d81a0" translate="yes" xml:space="preserve">
          <source>Another, slightly more subtle gotcha with optionals is &quot;implicitly unwrapped optionals. When we declare foo, we could say:</source>
          <target state="translated">Другая,чуть более тонкая,но с опционалами-это &quot;неявно разворачивающиеся опционалы&quot;.Когда мы объявляем фу,можно сказать:</target>
        </trans-unit>
        <trans-unit id="52474acee09818b60266e64bb250148f3409b9d7" translate="yes" xml:space="preserve">
          <source>Apple documentation on Swift Optionals</source>
          <target state="translated">Документация Apple по опционам Swift</target>
        </trans-unit>
        <trans-unit id="515515b53e442d6c0ac9c382069d83edc146839b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;anOptionalString&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; here, you will get a crash on the line where you force unwrap it.</source>
          <target state="translated">Поскольку &lt;code&gt;anOptionalString&lt;/code&gt; здесь равен &lt;code&gt;nil&lt;/code&gt; , вы получите сбой на линии, где вы принудительно разверните его.</target>
        </trans-unit>
        <trans-unit id="6401b89cf6e7b504f6a51a78043447e304db2acc" translate="yes" xml:space="preserve">
          <source>As a general rule, you should never explicitly force unwrap an optional with the &lt;code&gt;!&lt;/code&gt; operator. There may be cases where using &lt;code&gt;!&lt;/code&gt; is acceptable &amp;ndash; but you should only ever be using it if you are 100% sure that the optional contains a value.</source>
          <target state="translated">Как правило, вы никогда не должны явно распаковывать опцию с помощью &lt;code&gt;!&lt;/code&gt; оператор. Могут быть случаи, когда с помощью &lt;code&gt;!&lt;/code&gt; допустимо, но вы должны использовать его только в том случае, если вы на 100% уверены, что необязательный параметр содержит значение.</target>
        </trans-unit>
        <trans-unit id="e63c2b6a3158f2d5901a2d116e700ecadd6e8ac7" translate="yes" xml:space="preserve">
          <source>Avoid use of &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">Избегайте использования &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="48ec3975808ef63d21f693479b688b665f317562" translate="yes" xml:space="preserve">
          <source>Background: What&amp;rsquo;s an Optional?</source>
          <target state="translated">Фон: что необязательно?</target>
        </trans-unit>
        <trans-unit id="000712677e846810968631694b8782eea505d28e" translate="yes" xml:space="preserve">
          <source>Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.</source>
          <target state="translated">В основном вы пытались использовать нулевое значение в тех местах,где Swift разрешает только нулевое,говоря компилятору,чтобы он доверял вам,что там никогда не будет нулевого значения,тем самым позволяя вашему приложению компилироваться.</target>
        </trans-unit>
        <trans-unit id="6510cebf85c73b91f042a999279b8ecb4a6cfde5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;stringByAppendingString&lt;/code&gt; takes a non-optional string argument, we cannot input our optional string directly. However, by using &lt;code&gt;map&lt;/code&gt;, we can use allow &lt;code&gt;stringByAppendingString&lt;/code&gt; to be used if &lt;code&gt;anOptionalString&lt;/code&gt; has a value.</source>
          <target state="translated">Поскольку &lt;code&gt;stringByAppendingString&lt;/code&gt; принимает необязательный строковый аргумент, мы не можем напрямую ввести нашу необязательную строку. Однако, используя &lt;code&gt;map&lt;/code&gt; , мы можем разрешить использование &lt;code&gt;stringByAppendingString&lt;/code&gt; , если &lt;code&gt;anOptionalString&lt;/code&gt; имеет значение.</target>
        </trans-unit>
        <trans-unit id="3981488e6abb1cb399b600a4e20bcc5f6c58686a" translate="yes" xml:space="preserve">
          <source>Bottom line: When you are first learning Swift, pretend the &quot;!&quot; character is not part of the language. It's likely to get you into trouble.</source>
          <target state="translated">Итог:Когда вы в первый раз изучаете Swift,притворитесь,что символ &quot;!&quot; не является частью языка.Скорее всего,это доставит вам неприятности.</target>
        </trans-unit>
        <trans-unit id="270c4892a016f64b1f29e7cd37c444a555dc7d7d" translate="yes" xml:space="preserve">
          <source>But Swift's error handling system also provides a way to &quot;force try&quot; with &lt;code&gt;try!&lt;/code&gt;:</source>
          <target state="translated">Но система обработки ошибок Swift также предоставляет способ &amp;laquo;принудительной попытки&amp;raquo; с помощью &lt;code&gt;try!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e2f129952b7df6d9c9137de5fc26c084032ef61" translate="yes" xml:space="preserve">
          <source>By applying the &lt;code&gt;map&lt;/code&gt; function to it &amp;ndash; we can use the &lt;code&gt;stringByAppendingString&lt;/code&gt; function in order to concatenate it to another string.</source>
          <target state="translated">Применяя к ней функцию &lt;code&gt;map&lt;/code&gt; - мы можем использовать функцию &lt;code&gt;stringByAppendingString&lt;/code&gt; , чтобы объединить ее с другой строкой.</target>
        </trans-unit>
        <trans-unit id="890392cd814cb51a3ec19620be5a911041086aa9" translate="yes" xml:space="preserve">
          <source>Declare variable optional (&lt;code&gt;?&lt;/code&gt;), not implicitly unwrapped optionals (IUO) (&lt;code&gt;!&lt;/code&gt;)</source>
          <target state="translated">Объявить переменную необязательной ( &lt;code&gt;?&lt;/code&gt; ), А не неявно развернутой опцией (IUO) ( &lt;code&gt;!&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2259c1bef40d9a2d2466c01f96f672a698d0443" translate="yes" xml:space="preserve">
          <source>Destination Controller:</source>
          <target state="translated">Контроллер пункта назначения:</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="202b26ba321fbfe7f81ed7bbc6b02aef082dc6be" translate="yes" xml:space="preserve">
          <source>Either unwrap variable like this:</source>
          <target state="translated">Либо разворачивай переменную вот так:</target>
        </trans-unit>
        <trans-unit id="ca0a491616073f375fc6c16bc6cdb928b2718880" translate="yes" xml:space="preserve">
          <source>Even myself has to wrap (no pun intended) my head around Optionals :D
&lt;em&gt;Happy Swfting All&lt;/em&gt;.</source>
          <target state="translated">Даже я должен обернуть (не каламбур) голову вокруг Факультативного</target>
        </trans-unit>
        <trans-unit id="d5e49c1f7f49b51d3c469b5d6175ea1c5c2c0403" translate="yes" xml:space="preserve">
          <source>Explicit Force Unwrapping</source>
          <target state="translated">Явная сила Раскручивание</target>
        </trans-unit>
        <trans-unit id="7e9c689c33f3c0bb551be00e08e8e196af6dd530" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while &lt;strong&gt;implicitly&lt;/strong&gt; unwrapping an Optional value</source>
          <target state="translated">Неустранимая ошибка: неожиданно обнаружен ноль при &lt;strong&gt;неявном&lt;/strong&gt; развертывании необязательного значения</target>
        </trans-unit>
        <trans-unit id="63b2f6bd19b28c7b1987bcb9dd32336331c79410" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</source>
          <target state="translated">Фатальная ошибка:Неожиданно найден ноль при неявном разворачивании опционального значения.</target>
        </trans-unit>
        <trans-unit id="5ee449f8148453a77ee10bc85af161a2bf6904d0" translate="yes" xml:space="preserve">
          <source>Fatal error: Unexpectedly found nil while unwrapping an Optional value</source>
          <target state="translated">Фатальная ошибка:Неожиданно найден ноль при разворачивании опционального значения.</target>
        </trans-unit>
        <trans-unit id="5c2c4179c8fff9ca83b586e12a580e908e386c5c" translate="yes" xml:space="preserve">
          <source>First, you should know what an Optional value is.
You can step to &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;The Swift Programming Language&lt;/a&gt; for detail.</source>
          <target state="translated">Во-первых, вы должны знать, что такое необязательное значение. Вы можете перейти к &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;языку программирования Swift&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="fe3fb55243316c9dc924d99b807f5717582eeb12" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have an optional string:</source>
          <target state="translated">Например, допустим, у вас есть необязательная строка:</target>
        </trans-unit>
        <trans-unit id="8bd561982c688335d8305fd365ca075aba1100cc" translate="yes" xml:space="preserve">
          <source>For example, say we have a variable &lt;code&gt;foo&lt;/code&gt;, of type an optional &lt;code&gt;Foo&lt;/code&gt; instance.</source>
          <target state="translated">Например, допустим, у нас есть переменная &lt;code&gt;foo&lt;/code&gt; типа необязательного экземпляра &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="4fe78f7c529115814a0589403fb98c66ea73e508" translate="yes" xml:space="preserve">
          <source>Guard statements were added in Swift 2. Guard lets you preserve the &quot;golden path&quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using &quot;if let&quot; optional binding.</source>
          <target state="translated">Заявления охранников были добавлены в Свифт 2.Guard позволяет сохранить &quot;золотой путь&quot; через ваш код,и избежать постоянно растущих уровней вложенности ifs,которые иногда возникают в результате использования опциональной привязки &quot;if let&quot;.</target>
        </trans-unit>
        <trans-unit id="93edce2bfc57c7c54e7fd4b314121e6beb589d57" translate="yes" xml:space="preserve">
          <source>Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">Охрана также поддерживает те же хитрые приемы, которые поддерживаются в операторе if, такие как одновременное развертывание нескольких дополнительных опций и использование предложения &lt;code&gt;where&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad08562b159908e3b05f037b3e013647aba536b4" translate="yes" xml:space="preserve">
          <source>Hence it's better to write as such:</source>
          <target state="translated">Следовательно,лучше писать как таковой:</target>
        </trans-unit>
        <trans-unit id="fd4007c3ff26895e5bb5fb48507590600d2502eb" translate="yes" xml:space="preserve">
          <source>Here by force casting you tell the compiler to no longer worry, as you'll always have a &lt;code&gt;Rectangle&lt;/code&gt; instance there. And as long as that holds, you don't have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.</source>
          <target state="translated">Здесь путем принудительного приведения вы говорите компилятору больше не беспокоиться, так как у вас всегда будет экземпляр &lt;code&gt;Rectangle&lt;/code&gt; . И пока это действительно так, вам не о чем беспокоиться. Проблемы начинаются, когда вы или ваши коллеги из проекта начинаете распространять не прямоугольные значения.</target>
        </trans-unit>
        <trans-unit id="a10432c3dfc4ac875e419233a429110d852331d9" translate="yes" xml:space="preserve">
          <source>Here is an example of optional binding with our &lt;code&gt;foo&lt;/code&gt; optional:</source>
          <target state="translated">Вот пример необязательного связывания с нашим необязательным &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f1995e5026962d6c02dca7e583fc61ef9cd31d6c" translate="yes" xml:space="preserve">
          <source>How can I safely deal with Optionals?</source>
          <target state="translated">Как я могу безопасно работать с опционами?</target>
        </trans-unit>
        <trans-unit id="e484fea1c47d9e20459264fe14e22be925d72d1b" translate="yes" xml:space="preserve">
          <source>How to deal with optionals:</source>
          <target state="translated">Как справляться с опционами:</target>
        </trans-unit>
        <trans-unit id="8633d1988d44234fa26b09689d230a24a81c00ff" translate="yes" xml:space="preserve">
          <source>However, 99.9% of the time when working with optionals, you&amp;rsquo;ll actually want to access the value it contains, if it contains one at all. To do this, you can use &lt;em&gt;Optional Binding&lt;/em&gt;.</source>
          <target state="translated">Тем не менее, в 99,9% случаев при работе с дополнительными компонентами вы фактически захотите получить доступ к содержащемуся в нем значению, если оно вообще содержится. Для этого вы можете использовать &lt;em&gt;Optional Binding&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9bcd13ba1c830e1eb8ee339d08e57ceccdcf9a16" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;anOptionalString&lt;/code&gt; doesn&amp;rsquo;t have a value, &lt;code&gt;map&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">Однако, если &lt;code&gt;anOptionalString&lt;/code&gt; не имеет значения, &lt;code&gt;map&lt;/code&gt; вернет &lt;code&gt;nil&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="a00cf22dac7a818231c0ff4ab31cff56b029afeb" translate="yes" xml:space="preserve">
          <source>However, there are a &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;few scenarios where implicitly unwrapped optionals are beneficial&lt;/a&gt;, and you are still able to use various ways of safely unwrapping them as listed below &amp;ndash; but you should &lt;em&gt;always&lt;/em&gt; use them with due caution.</source>
          <target state="translated">Тем не менее, есть &lt;a href=&quot;https://stackoverflow.com/a/24583157/2976878&quot;&gt;несколько сценариев, в которых неявно распакованные опции являются полезными&lt;/a&gt; , и вы по-прежнему можете использовать различные способы их безопасного развертывания, как указано ниже - но вы &lt;em&gt;всегда&lt;/em&gt; должны использовать их с должной осторожностью.</target>
        </trans-unit>
        <trans-unit id="045cfcd48cc9a7581c9554c6d0db82a58d3a86d5" translate="yes" xml:space="preserve">
          <source>However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because &lt;code&gt;foo&lt;/code&gt; is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods &amp;ndash; or unwrap &lt;code&gt;foo&lt;/code&gt; itself before accessing methods or calling methods that return values.</source>
          <target state="translated">Тем не менее, все становится немного сложнее при попытке получить доступ к свойствам или вызвать методы, которые возвращают значение. Поскольку &lt;code&gt;foo&lt;/code&gt; является необязательным, все, что возвращается из него, также будет необязательным. Чтобы справиться с этим, вы можете либо развернуть дополнительные параметры, возвращаемые с помощью одного из перечисленных выше методов, либо развернуть саму &lt;code&gt;foo&lt;/code&gt; перед доступом к методам или вызову методов, возвращающих значения.</target>
        </trans-unit>
        <trans-unit id="8925a8490bf5fd57f3e11be4c68ec114afe4face" translate="yes" xml:space="preserve">
          <source>I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.</source>
          <target state="translated">Я наткнулся на эту ошибку при переходе от контроллера представления таблицы к контроллеру представления,потому что забыл указать имя пользовательского класса для контроллера представления в основной раскадровке.</target>
        </trans-unit>
        <trans-unit id="961d19ccc70f1d74e0009e3c081c86736529fa59" translate="yes" xml:space="preserve">
          <source>I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:</source>
          <target state="translated">Однажды у меня была эта ошибка,когда я пытался установить значения Outlets из метода подготовки к сегменту следующим образом:</target>
        </trans-unit>
        <trans-unit id="c9821ba4ff1ad0757f5f86a478e8819368f2e4a1" translate="yes" xml:space="preserve">
          <source>I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn't addressed the issue itself directly.</source>
          <target state="translated">Я надеюсь,что этот ответ поможет любому,у кого есть такая же проблема,как я обнаружил,что отмеченный ответ является отличным ресурсом для понимания опционов и того,как они работают,но не обратился непосредственно к самому вопросу.</target>
        </trans-unit>
        <trans-unit id="687e27bcc1f747e004946e97f14c1a09937a1708" translate="yes" xml:space="preserve">
          <source>IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, &lt;em&gt;after&lt;/em&gt; initialization. You should therefore ensure that you&amp;rsquo;re not accessing outlets before they're loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be &lt;code&gt;nil&lt;/code&gt; at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.</source>
          <target state="translated">В частности, IBOutlets обычно являются неявно развернутыми опциями. Это потому, что ваш xib или раскадровка будут связывать выходы во время выполнения &lt;em&gt;после&lt;/em&gt; инициализации. Поэтому вы должны убедиться, что у вас нет доступа к розеткам до того, как они будут загружены. Вы также должны проверить правильность соединений в вашем файле раскадровки / xib, иначе значения будут &lt;code&gt;nil&lt;/code&gt; во время выполнения, и, следовательно, сбой, когда они неявно развернутый. При исправлении соединений попробуйте удалить строки кода, которые определяют ваши розетки, а затем снова подключить их.</target>
        </trans-unit>
        <trans-unit id="cbf8b026a781fcaf4a77cedd0a311b396615b39b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;anOptionalInt&lt;/code&gt; contains a value, it will be unwrapped and assigned to the new &lt;code&gt;number&lt;/code&gt; constant. The code &lt;em&gt;after&lt;/em&gt; the guard will then continue executing. If it doesn&amp;rsquo;t contain a value &amp;ndash; the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.</source>
          <target state="translated">Если &lt;code&gt;anOptionalInt&lt;/code&gt; содержит значение, оно будет развернуто и назначено новой постоянной &lt;code&gt;number&lt;/code&gt; . Код &lt;em&gt;после&lt;/em&gt; охраны продолжит выполнение. Если оно не содержит значения - охранник выполнит код в скобках, что приведет к передаче управления, так что код сразу после этого не будет выполнен.</target>
        </trans-unit>
        <trans-unit id="555b9e1b03e3ef819963d13f4ad1e9cd6291d3bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;foo&lt;/code&gt; contains a value, this method will be called on it. If it doesn&amp;rsquo;t, nothing bad will happen &amp;ndash; the code will simply continue executing.</source>
          <target state="translated">Если &lt;code&gt;foo&lt;/code&gt; содержит значение, этот метод будет вызван для него. Если этого не произойдет, ничего плохого не произойдет - код просто продолжит выполнение.</target>
        </trans-unit>
        <trans-unit id="bfd5e74dcdb489bc0ac5f2ed761961f64038c09a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someThrowingFunc()&lt;/code&gt; throws an error, the error will be safely caught in the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">Если &lt;code&gt;someThrowingFunc()&lt;/code&gt; выдает ошибку, ошибка будет безопасно перехвачена в блоке &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d952b11c89cd854be27de0d0f65ed17e3c578f0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;someVariable&lt;/code&gt; is nil, then you'll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you're guaranteeing to the compiler that you'll never have nil values there. And guess what it happens if somehow a nil value ends in in &lt;code&gt;someVariable&lt;/code&gt;?</source>
          <target state="translated">Если &lt;code&gt;someVariable&lt;/code&gt; равен нулю, вы получите сбой. Делая принудительную развёртку, вы перекладывали ответственность за проверку на ноль от компилятора к вам, в основном, выполняя принудительную развёртку, вы гарантируете компилятору, что там никогда не будет значений nil. И угадайте, что произойдет, если каким-то образом значение nil заканчивается в &lt;code&gt;someVariable&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c01ad95af312c93699d0f265e3b3b0b10e9f23a1" translate="yes" xml:space="preserve">
          <source>If we wanted to call a method on &lt;code&gt;foo&lt;/code&gt; that doesn&amp;rsquo;t return anything, we can simply do:</source>
          <target state="translated">Если мы хотим вызвать метод для &lt;code&gt;foo&lt;/code&gt; , который ничего не возвращает, мы можем просто сделать:</target>
        </trans-unit>
        <trans-unit id="78da2ff6a4b5799b4addacf92cf6d2b26fb23cc8" translate="yes" xml:space="preserve">
          <source>If you get this error in CollectionView try to create CustomCell file and Custom xib also.</source>
          <target state="translated">Если вы получите эту ошибку в CollectionView,попробуйте создать файл CustomCell и Custom xib тоже.</target>
        </trans-unit>
        <trans-unit id="0127a3535a0583ab1a79af7eea2befd762a366e7" translate="yes" xml:space="preserve">
          <source>Implicitly Unwrapped Optionals</source>
          <target state="translated">Неявно неупакованные опционалы</target>
        </trans-unit>
        <trans-unit id="051898db5718d1ca1229f4edae90fa5baa7e3071" translate="yes" xml:space="preserve">
          <source>Implicitly unwrapped optionals. Let's assume you have the following class definition:</source>
          <target state="translated">Неявно распакованные опционалы.Предположим,что у вас есть следующее определение класса:</target>
        </trans-unit>
        <trans-unit id="484536419577c05bc013ad78ac088dd3099a07ed" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;generic type&lt;/a&gt; that can contain a value (of any kind), or no value at all.</source>
          <target state="translated">В Swift &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; - это &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;универсальный тип,&lt;/a&gt; который может содержать значение (любого типа) или вообще не иметь значения.</target>
        </trans-unit>
        <trans-unit id="79a7dee40b7721bf417ab75a0b14f771e29d4b3d" translate="yes" xml:space="preserve">
          <source>In Swift, &lt;strong&gt;&lt;em&gt;any type&lt;/em&gt; can be made optional&lt;/strong&gt;. An optional value can take on any value from the original type, &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;or&lt;/em&gt;&lt;/a&gt; the special value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В Swift &lt;strong&gt;&lt;em&gt;любой тип&lt;/em&gt; можно сделать необязательным&lt;/strong&gt; . Необязательное значение может принимать любое значение из исходного типа &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;&lt;em&gt;или&lt;/em&gt;&lt;/a&gt; специальное значение &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04774461a3612ca563f0e36ff0dbf0f0ec4fa74c" translate="yes" xml:space="preserve">
          <source>In many other programming languages, a particular &quot;sentinel&quot; value is often used to indicate a &lt;em&gt;lack of a value&lt;/em&gt;. In Objective-C, for example, &lt;code&gt;nil&lt;/code&gt; (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;null pointer&lt;/a&gt;) indicates the lack of an object. But this gets more tricky when working with primitive types &amp;mdash; should &lt;code&gt;-1&lt;/code&gt; be used to indicate the absence of an integer, or perhaps &lt;code&gt;INT_MIN&lt;/code&gt;, or some other integer? If any particular value is chosen to mean &quot;no integer&quot;, that means it can no longer be treated as a &lt;em&gt;valid&lt;/em&gt; value.</source>
          <target state="translated">Во многих других языках программирования определенное значение &amp;laquo;страж&amp;raquo; часто используется для указания на &lt;em&gt;отсутствие значения&lt;/em&gt; . Например, в Objective-C &lt;code&gt;nil&lt;/code&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer&quot;&gt;нулевой указатель&lt;/a&gt; ) указывает на отсутствие объекта. Но это становится более сложным при работе с примитивными типами - следует ли использовать &lt;code&gt;-1&lt;/code&gt; , чтобы указать на отсутствие целого числа, или, возможно, &lt;code&gt;INT_MIN&lt;/code&gt; , или какого-то другого целого числа? Если какое-либо конкретное значение выбрано для обозначения &amp;laquo;нет целого числа&amp;raquo;, это означает, что оно больше не может рассматриваться как &lt;em&gt;допустимое&lt;/em&gt; значение.</target>
        </trans-unit>
        <trans-unit id="46b85b18ba2133633a4afcab43ae7743b50be6e2" translate="yes" xml:space="preserve">
          <source>In order to access an optional&amp;rsquo;s value (if it has one at all), you need to &lt;strong&gt;unwrap&lt;/strong&gt; it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it &lt;em&gt;didn't&lt;/em&gt; have a value, your program will crash with the above message.</source>
          <target state="translated">Чтобы получить доступ к необязательному значению (если оно вообще есть), вам необходимо &lt;strong&gt;развернуть&lt;/strong&gt; его. Необязательное значение может быть развернуто безопасно или принудительно. Если вы принудительно разверните необязательный файл, у &lt;em&gt;которого не&lt;/em&gt; было значения, ваша программа вылетит с сообщением выше.</target>
        </trans-unit>
        <trans-unit id="2870a2cd345396e3c49f99168c09a7038d33fa6f" translate="yes" xml:space="preserve">
          <source>In order to work out which variable caused the crash, you can hold</source>
          <target state="translated">Для того,чтобы выяснить,какая переменная вызвала сбой,можно удерживать</target>
        </trans-unit>
        <trans-unit id="ee021373ae2b52768be006a0a1a52dc063c5b011" translate="yes" xml:space="preserve">
          <source>In other words, rather use:</source>
          <target state="translated">Другими словами,скорее используйте:</target>
        </trans-unit>
        <trans-unit id="c40e8f1772cb4a16417b4c1962c3c56e76be0301" translate="yes" xml:space="preserve">
          <source>In that case foo is still an optional, but you don't have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it's nil.</source>
          <target state="translated">В таком случае,foo все еще является необязательным,но вы не должны развернуть его,чтобы ссылаться на него.Это значит,что каждый раз,когда ты пытаешься сослаться на Фу,ты разбиваешься,если она нулевая.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="8bedbb9a541d4d033efb3e04645647ad1c32d4d3" translate="yes" xml:space="preserve">
          <source>It essentially lets you say &amp;ldquo;If &lt;code&gt;a&lt;/code&gt; contains a value, unwrap it. If it doesn&amp;rsquo;t then return &lt;code&gt;b&lt;/code&gt; instead&amp;rdquo;. For example, you could use it like this:</source>
          <target state="translated">По сути, он позволяет вам сказать: &amp;laquo;Если &lt;code&gt;a&lt;/code&gt; содержит значение, разверните его. Если это не так, тогда верните &lt;code&gt;b&lt;/code&gt; &amp;raquo;. Например, вы можете использовать это так:</target>
        </trans-unit>
        <trans-unit id="ad0ef45d1f8d084087d25064193cc17d964245ca" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s just shorthand for:</source>
          <target state="translated">Это просто сокращение для:</target>
        </trans-unit>
        <trans-unit id="459fe8274d538afa06b4cd892cfc12fa3846a208" translate="yes" xml:space="preserve">
          <source>Learn how to debug an iOS app crash</source>
          <target state="translated">Узнайте,как отладить падение iOS-приложения.</target>
        </trans-unit>
        <trans-unit id="aaee9b9adb35ca322a119d776bbbe533b4d1fb20" translate="yes" xml:space="preserve">
          <source>Long story short by using &lt;code&gt;var address : Address!&lt;/code&gt; you're &lt;strong&gt;hiding&lt;/strong&gt; the possibility that a variable can be &lt;code&gt;nil&lt;/code&gt; from other readers. And when it crashes you're like &quot;what the hell?! my &lt;code&gt;address&lt;/code&gt; isn't an optional, so why am I crashing?!.</source>
          <target state="translated">Короче говоря, используя &lt;code&gt;var address : Address!&lt;/code&gt; вы &lt;strong&gt;скрываете&lt;/strong&gt; возможность того, что переменная может быть &lt;code&gt;nil&lt;/code&gt; от других читателей. И когда он выходит из строя, вы говорите: &amp;laquo;Какого черта ?! Мой &lt;code&gt;address&lt;/code&gt; не является обязательным, так почему я рушаюсь ?!&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="78cef24b9706680cc584904b5e88b79801d759b5" translate="yes" xml:space="preserve">
          <source>Most of the time you will use the complete Do-Try-Catch system - and the optional one, &lt;code&gt;try?&lt;/code&gt;, in the rare cases where handling the error is not important.</source>
          <target state="translated">Большую часть времени вы будете использовать полную систему Do-Try-Catch, а дополнительную - &lt;code&gt;try?&lt;/code&gt; В редких случаях, когда обработка ошибки не важна.</target>
        </trans-unit>
        <trans-unit id="35e9fc497ab02ab074e552f7be54dc7f776c210a" translate="yes" xml:space="preserve">
          <source>My Swift program is crashing with &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and one of the following similar errors. What does this error mean, and how do I fix it?</source>
          <target state="translated">Моя программа Swift аварийно &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; с EXC_BAD_INSTRUCTION и одной из следующих похожих ошибок. Что означает эта ошибка и как ее исправить?</target>
        </trans-unit>
        <trans-unit id="56a078777cdf9213e116547d03f394624b748e2b" translate="yes" xml:space="preserve">
          <source>Nil Coalescing Operator</source>
          <target state="translated">Нил Коалесцирующий Оператор</target>
        </trans-unit>
        <trans-unit id="9b06cd01bf313f728f850e8f6dfbc9e6120741e5" translate="yes" xml:space="preserve">
          <source>Note that the variable you define when you use optional biding only exists (is only &quot;in scope&quot;) in the body of the if statement.</source>
          <target state="translated">Обратите внимание,что переменная,которую вы определяете,когда используете необязательное бидинговое предложение,существует только в теле оператора if (только &quot;в области видимости&quot;).</target>
        </trans-unit>
        <trans-unit id="4c10eb68d56cba105bdf477429d00aea854d4ccd" translate="yes" xml:space="preserve">
          <source>Now if no nullability annotations are specified (either explicitly or via &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt;/&lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;), then the &lt;code&gt;name&lt;/code&gt; property will be imported in Swift as &lt;code&gt;String!&lt;/code&gt; (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if &lt;code&gt;name&lt;/code&gt; is nil.</source>
          <target state="translated">Теперь, если аннотации обнуляемости не указаны (явно или через &lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; / &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt; ), то свойство &lt;code&gt;name&lt;/code&gt; будет импортировано в Swift как &lt;code&gt;String!&lt;/code&gt; (IUO - неявно развернутый необязательный). Как только какой-то swift-код захочет использовать значение, он потерпит крах, если &lt;code&gt;name&lt;/code&gt; равно nil.</target>
        </trans-unit>
        <trans-unit id="16ffd92502b92b7dab0de459501aee70aad84527" translate="yes" xml:space="preserve">
          <source>Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you'll want to use the outlet.
Solution? Make sure all outlets are connected. Or use the &lt;code&gt;?&lt;/code&gt; operator on them: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.</source>
          <target state="translated">Теперь, если вы пропустили подключение к розетке из редактора XIB, приложение завершит работу, как только вы захотите использовать розетку. Решение? Убедитесь, что все розетки подключены. Или использовать &lt;code&gt;?&lt;/code&gt; оператор на них: &lt;code&gt;emailTextField?.text = &quot;my@email.com&quot;&lt;/code&gt; . Или объявите выход как опциональный, хотя в этом случае компилятор заставит вас развернуть его по всему коду.</target>
        </trans-unit>
        <trans-unit id="f75a096d58dde4b74701e26c90ea72ae64747b35" translate="yes" xml:space="preserve">
          <source>Now, if no-one messes up with the &lt;code&gt;name&lt;/code&gt; property by setting it to &lt;code&gt;nil&lt;/code&gt;, then it works as expected, however if &lt;code&gt;User&lt;/code&gt; is initialized from a JSON that lacks the &lt;code&gt;name&lt;/code&gt; key, then you get the fatal error when trying to use the property.</source>
          <target state="translated">Теперь, если никто не напутает со свойством &lt;code&gt;name&lt;/code&gt; , установив для него значение &lt;code&gt;nil&lt;/code&gt; , тогда оно будет работать, как и ожидалось, однако, если &lt;code&gt;User&lt;/code&gt; инициализируется из JSON, в котором отсутствует ключ &lt;code&gt;name&lt;/code&gt; , вы получаете фатальную ошибку при попытке использовать свойство ,</target>
        </trans-unit>
        <trans-unit id="936cf8bab3f747e065f42e3415906001fcaec17a" translate="yes" xml:space="preserve">
          <source>One other way, if you don't want to check the variable state before your implementation, you can also use &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; instead.</source>
          <target state="translated">Еще один способ, если вы не хотите проверять состояние переменной перед реализацией, вы также можете использовать &lt;code&gt;var buildingName = buildingName ?? &quot;buildingName&quot;&lt;/code&gt; вместо этого &quot;buildingName&quot; .</target>
        </trans-unit>
        <trans-unit id="4a3f188326fc444bc42e44fa25a0acf6b3ccac81" translate="yes" xml:space="preserve">
          <source>Optional Binding</source>
          <target state="translated">Дополнительный переплёт</target>
        </trans-unit>
        <trans-unit id="7a826a948d8f9ecc960c32ca6f545004bbd4247e" translate="yes" xml:space="preserve">
          <source>Optional Binding allows you to check if an optional contains a value &amp;ndash; and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; or &lt;code&gt;if var x = anOptional {...}&lt;/code&gt;, depending if you need to modify the value of the new variable after binding it.</source>
          <target state="translated">Опциональное связывание позволяет проверить, содержит ли необязательное значение значение, и позволяет назначить развернутое значение новой переменной или константе. Он использует синтаксис, &lt;code&gt;if let x = anOptional {...}&lt;/code&gt; или &lt;code&gt;if var x = anOptional {...}&lt;/code&gt; , в зависимости от того, нужно ли вам изменить значение новой переменной после ее связывания.</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">Дополнительная цепочка</target>
        </trans-unit>
        <trans-unit id="1661a949efe8ce7e832a8022541343bb817a5148" translate="yes" xml:space="preserve">
          <source>Optionals are defined with a &lt;code&gt;?&lt;/code&gt; suffix on the type:</source>
          <target state="translated">Необязательные значения определяются с помощью &lt;code&gt;?&lt;/code&gt; суффикс по типу:</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">Или вот так:</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="54833e81302d6311cef1a28ed09adc3690301a62" translate="yes" xml:space="preserve">
          <source>Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.</source>
          <target state="translated">Во-вторых,вы должны знать,что необязательное значение имеет два статуса.Один-полное значение,а другой-нулевое.Поэтому,прежде чем реализовывать необязательное значение,вы должны проверить,в каком состоянии оно находится.</target>
        </trans-unit>
        <trans-unit id="03c6c8c8bdb83cd4b0856641a961cecbc0c85b85" translate="yes" xml:space="preserve">
          <source>Since the above answers clearly explains how to play safely with Optionals.
I will try explain what Optionals are really in swift.</source>
          <target state="translated">Так как вышеприведенные ответы ясно объясняют,как безопасно играть с опционами.Я постараюсь объяснить,что такое опционалы на самом деле быстро.</target>
        </trans-unit>
        <trans-unit id="dad624a90b7df3a23e5bb578feeeabdd12ee8888" translate="yes" xml:space="preserve">
          <source>So I solved it this way:</source>
          <target state="translated">Так что я решил это так:</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">Итак,этот код:</target>
        </trans-unit>
        <trans-unit id="afb1b762e29712aa3b112a22ea2e06690f91025a" translate="yes" xml:space="preserve">
          <source>So to assign a nil to our variable 'i'. We can do 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt;
or to assign a value, we will pass some value 
&lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</source>
          <target state="translated">Таким образом, чтобы присвоить ноль нашей переменной &amp;laquo;я&amp;raquo;. Мы можем сделать &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.none&lt;/code&gt; или присвоить значение, мы передадим некоторое значение &lt;code&gt;var i = Optional&amp;lt;Int&amp;gt;.some(28)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a43ac01380800da0acd970a8b899fd1a1eb60e8" translate="yes" xml:space="preserve">
          <source>So you could use code like this:</source>
          <target state="translated">Так что ты можешь использовать такой код:</target>
        </trans-unit>
        <trans-unit id="b04e4285f916f64b8ec1d071584592d993d42c35" translate="yes" xml:space="preserve">
          <source>So, to use them with an optional binding, you can do this:</source>
          <target state="translated">Так что,чтобы использовать их с необязательным переплётом,вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="7547ba07041dcef70d621cc40b5c4a45b8ce5e45" translate="yes" xml:space="preserve">
          <source>Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as &lt;code&gt;nonnull&lt;/code&gt;.</source>
          <target state="translated">Решение? Добавьте аннулируемые аннотации к вашему коду Objective-C. Однако остерегайтесь, когда компилятор Objective-C немного допустим, когда дело доходит до обнуляемости, вы можете получить нулевые значения, даже если вы явно пометили их как &lt;code&gt;nonnull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52e5455e8973ef67576894c1d0ab773692ab9e50" translate="yes" xml:space="preserve">
          <source>Solution? Don't use them :) Unless you're 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property</source>
          <target state="translated">Решение? Не используйте их :)Если только вы не уверены на 102%,что к моменту использования собственность всегда будет иметь нулевое значение.В большинстве случаев будет работать преобразование в необязательное или неопциональное.Сделав его неопциональным,компилятор также поможет вам,сообщив пути кода,которые вы пропустили,давая значение этому свойству</target>
        </trans-unit>
        <trans-unit id="dbbb73b74bb82fd31f9eda3643a242450fdeebf5" translate="yes" xml:space="preserve">
          <source>Solution? Use optional binding (aka if-let), do the variable processing there:</source>
          <target state="translated">Решение? Используйте опциональную привязку (так же известную как if-let),выполняйте обработку переменных там:</target>
        </trans-unit>
        <trans-unit id="f6514760b09d36bf6238bb6b2eecdafcf283abf2" translate="yes" xml:space="preserve">
          <source>Something simple that is worth checking if all else looks ok</source>
          <target state="translated">Что-нибудь простое,что стоит проверить,все ли остальное выглядит нормально.</target>
        </trans-unit>
        <trans-unit id="d9bf36cacd5682e9de59257e72eab5c7866cf9e7" translate="yes" xml:space="preserve">
          <source>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake.</source>
          <target state="translated">Swift-это безопасный для типов язык,что означает,что язык помогает вам четко понимать,с какими типами значений может работать ваш код.Если часть вашего кода ожидает строку,то безопасность типов предотвращает ошибочную передачу ей Int.</target>
        </trans-unit>
        <trans-unit id="0191ce146a46db014aa0959a5ad6aab2ad0a906a" translate="yes" xml:space="preserve">
          <source>Swift optionals let you set up a variable of any type to contain either a valid value, or no value.</source>
          <target state="translated">Опции Swift позволяют настроить переменную любого типа,чтобы она содержала либо действительное значение,либо его отсутствие.</target>
        </trans-unit>
        <trans-unit id="9f50948ddb6a9405af006b565688093e07e7df89" translate="yes" xml:space="preserve">
          <source>Swift uses the concept of &quot;Optionals&quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.</source>
          <target state="translated">Swift использует концепцию &quot;Вариантов&quot; для работы со значениями,которые могут содержать или не содержать значение.В других языках,таких как C,вы можете хранить значение 0 в переменной,чтобы показать,что она не содержит значения.Однако,что если 0 является действительным значением? Тогда вы можете использовать -1.Что если -1 является действительным значением? И так далее.</target>
        </trans-unit>
        <trans-unit id="8733a9d6eaaff2ad81a4c469105c4f2aa8f27191" translate="yes" xml:space="preserve">
          <source>Swift's error handling system can be safely used with &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt;:</source>
          <target state="translated">Система обработки ошибок Swift может безопасно использоваться с &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508&quot;&gt;Do-Try-Catch&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="aab6e4d9938362d2634e37c6d271130b036be9f7" translate="yes" xml:space="preserve">
          <source>TL;DR answer</source>
          <target state="translated">TL;DR ответ</target>
        </trans-unit>
        <trans-unit id="5910011e369d233145df2614ffbb9258f70e2bc9" translate="yes" xml:space="preserve">
          <source>The &quot;!&quot; operator is a &quot;force unwrap&quot; operator. It says &quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.&quot; If you are wrong, you crash.</source>
          <target state="translated">Оператор &quot;!&quot;-это оператор &quot;принудительного разворачивания&quot;.Там написано &quot;поверь мне.Я знаю,что я делаю.Я гарантирую,что когда этот код запустится,переменная не будет содержать нуля&quot;.Если ты ошибаешься,ты разобьешься.</target>
        </trans-unit>
        <trans-unit id="cc8497513f48b57bcdbd220d3e716cb1d4a6b09b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; is a nifty shorthand version of the &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;ternary conditional operator&lt;/a&gt;, primarily designed to convert optionals to non-optionals. It has the syntax &lt;code&gt;a ?? b&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an optional type and &lt;code&gt;b&lt;/code&gt; is the same type as &lt;code&gt;a&lt;/code&gt; (although usually non-optional).</source>
          <target state="translated">&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72&quot;&gt;Nil Coalescing Operator&lt;/a&gt; - изящная сокращенная версия &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71&quot;&gt;троичного условного оператора&lt;/a&gt; , в первую очередь предназначенная для преобразования необязательных необязательных операторов . Имеет синтаксис &lt;code&gt;a ?? b&lt;/code&gt; , где &lt;code&gt;a&lt;/code&gt; - необязательный тип, а &lt;code&gt;b&lt;/code&gt; - тот же тип, что и &lt;code&gt;a&lt;/code&gt; (хотя обычно это необязательный тип).</target>
        </trans-unit>
        <trans-unit id="4f39a8383e521eac4930320b3f781463d412042a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; constant you see in the &lt;code&gt;catch&lt;/code&gt; block has not been declared by us - it's automatically generated by &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">Константа &lt;code&gt;error&lt;/code&gt; вы видите в блоке &lt;code&gt;catch&lt;/code&gt; , нами не объявлена ​​- она ​​автоматически генерируется &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0c0cb00ef66003262f22de70ce81e5de3dbebd" translate="yes" xml:space="preserve">
          <source>The concepts explained in this post also apply here: if an error is thrown, the application will crash.</source>
          <target state="translated">Понятия,описанные в этой заметке,также применимы и здесь:если бросить ошибку,приложение аварийно завершает свою работу.</target>
        </trans-unit>
        <trans-unit id="cc4353dc8328b849dd5eee0ba9343f34b63353af" translate="yes" xml:space="preserve">
          <source>The errors &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; and &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; appears the most when you have declared an &lt;code&gt;@IBOutlet&lt;/code&gt;, but not connected to the &lt;strong&gt;storyboard&lt;/strong&gt;.</source>
          <target state="translated">Ошибки &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; и &lt;code&gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value&lt;/code&gt; появляется чаще всего, когда вы объявили &lt;code&gt;@IBOutlet&lt;/code&gt; , но не подключены к &lt;strong&gt;раскадровке&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f944bc0d51db4c42e0ab501ffaf2c9361c58f7c9" translate="yes" xml:space="preserve">
          <source>The full code would be :</source>
          <target state="translated">Полный код будет :</target>
        </trans-unit>
        <trans-unit id="39947ad748876c5ade4da078e8c8623048e5ffc6" translate="yes" xml:space="preserve">
          <source>The full code would be:</source>
          <target state="translated">Полный код будет:</target>
        </trans-unit>
        <trans-unit id="49a1afbffea19fea31c8bef0f4563791d58a8dc2" translate="yes" xml:space="preserve">
          <source>The lack of a value in an optional is indicated by &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">Отсутствие значения в необязательном порядке указывается как &lt;code&gt;nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37d4ab0d4c249a69f4593634c7af51c35f6f73fc" translate="yes" xml:space="preserve">
          <source>The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a &lt;em&gt;guard statement&lt;/em&gt;.</source>
          <target state="translated">Единственная особенность использования необязательного связывания в операторе if состоит в том, что вы можете получить доступ только к развернутому значению в пределах оператора. Если вам нужен доступ к значению вне области действия оператора, вы можете использовать &lt;em&gt;защитный оператор&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="77a167b0cfc56774bff7d7b752b55f5f670e549d" translate="yes" xml:space="preserve">
          <source>The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can &lt;em&gt;only&lt;/em&gt; execute if the optional has a value). This is a great for eliminating &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;&amp;lsquo;pyramids of doom&amp;rsquo;&lt;/a&gt; created by nesting multiple if statements.</source>
          <target state="translated">Настоящая изящная вещь в операторах защиты - это то, что теперь развернутое значение доступно для использования в коде, который следует за оператором (поскольку мы знаем, что будущий код может выполняться &lt;em&gt;только в том&lt;/em&gt; случае, если необязательное значение имеет значение). Это отлично подходит для устранения &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)&quot;&gt;&amp;laquo;пирамид гибели&amp;raquo;,&lt;/a&gt; созданных вложением нескольких операторов if.</target>
        </trans-unit>
        <trans-unit id="f70e19cc299904e989d46111669248e2d6297b5a" translate="yes" xml:space="preserve">
          <source>The simplest way to check whether an optional contains a value, is to compare it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Самый простой способ проверить, содержит ли необязательное значение значение, - сравнить его с &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad7c64f5b093e808ba67d8a73670ba71bd4ebd5" translate="yes" xml:space="preserve">
          <source>Then I found out that I can't set the values of the destination controller outlets because the controller hasn't been loaded or initialized yet.</source>
          <target state="translated">Затем я обнаружил,что не могу установить значения выходов контроллера назначения,потому что контроллер еще не был загружен или инициализирован.</target>
        </trans-unit>
        <trans-unit id="1ec67f9dd2cfab174b6b515c3d0d4747bf7293ec" translate="yes" xml:space="preserve">
          <source>There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)</source>
          <target state="translated">Есть много других способов справиться с опционалами,которые более безопасны.Вот некоторые из них (не полный список).</target>
        </trans-unit>
        <trans-unit id="0d60f2d11c0f746729eec725020f1feabe53897f" translate="yes" xml:space="preserve">
          <source>There are several scenarios that lead to this kind of fatal error:</source>
          <target state="translated">Существует несколько сценариев,которые приводят к подобной фатальной ошибке:</target>
        </trans-unit>
        <trans-unit id="3cc4935148dd3d0a4d88768551d67d938c2ebaf2" translate="yes" xml:space="preserve">
          <source>There is also a construct called the &quot;nil coalescing operator&quot;. It takes the form &quot;optional_var ?? replacement_val&quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the &quot;??&quot; symbol.</source>
          <target state="translated">Существует также конструкция,называемая &quot;ноль коалесцирующий оператор&quot;.Она принимает форму &quot;optional_var ??replace_val&quot;.Она возвращает неопциональную переменную с тем же типом,что и данные,содержащиеся в необязательном.Если необязательная переменная содержит nil,она возвращает значение выражения после символа &quot;??&quot;.</target>
        </trans-unit>
        <trans-unit id="b6b6bf923d0fa956d7f5415f78e183319a28b7b6" translate="yes" xml:space="preserve">
          <source>There's also &lt;code&gt;try?&lt;/code&gt; which absorbs the error:</source>
          <target state="translated">Там тоже &lt;code&gt;try?&lt;/code&gt; которая поглощает ошибку:</target>
        </trans-unit>
        <trans-unit id="051cef13b0cd111883df939c5644ba59bbe86947" translate="yes" xml:space="preserve">
          <source>These are defined with  a &lt;code&gt;!&lt;/code&gt;, rather than a &lt;code&gt;?&lt;/code&gt; after the type.</source>
          <target state="translated">Они определены с &lt;code&gt;!&lt;/code&gt; , а не &lt;code&gt;?&lt;/code&gt; после типа.</target>
        </trans-unit>
        <trans-unit id="228d647e0bd3a874c5246256241ffafbe0dae63f" translate="yes" xml:space="preserve">
          <source>These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesn&amp;rsquo;t contain a value, it will crash.</source>
          <target state="translated">Предполагается, что эти опции содержат значение. Поэтому всякий раз, когда вы получаете доступ к неявно развернутому необязательному файлу, он будет автоматически развернут для вас. Если он не содержит значения, он потерпит крах.</target>
        </trans-unit>
        <trans-unit id="03d3193f66062a0894aa6946a0e2b6f22b829634" translate="yes" xml:space="preserve">
          <source>These variables are designed so that you can defer their assignment until later in your code. It is &lt;em&gt;your&lt;/em&gt; responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe &amp;ndash; as they &lt;em&gt;assume&lt;/em&gt; your value is non-nil, even though assigning nil is valid.</source>
          <target state="translated">Эти переменные разработаны таким образом, что вы можете отложить их назначение до следующего момента в вашем коде. Вы несете ответственность за обеспечение их ценности, прежде чем вы получите к ним доступ. Однако, поскольку они включают принудительное развертывание, они по-прежнему небезопасны - поскольку они &lt;em&gt;предполагают, что&lt;/em&gt; ваше значение не равно нулю, даже если присвоение nil допустимо.</target>
        </trans-unit>
        <trans-unit id="e2a9aff700fd23b1fa64684c86c11f3e64379b3e" translate="yes" xml:space="preserve">
          <source>Think of the following code: 
It compiles with no errors/warnings:</source>
          <target state="translated">Подумай о следующем коде:Он компилируется без предупреждений об ошибках:</target>
        </trans-unit>
        <trans-unit id="09d8ef10eee293feb35c82626771fa027ffe930b" translate="yes" xml:space="preserve">
          <source>This answer was intended to be concise, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;for full comprehension read accepted answer&lt;/a&gt;</source>
          <target state="translated">Этот ответ должен был быть кратким, &lt;a href=&quot;https://stackoverflow.com/a/32170457/1311272&quot;&gt;для полного понимания прочитайте принятый ответ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="518b372f5b167794f9cb85ed9cffe42f1420058a" translate="yes" xml:space="preserve">
          <source>This can therefore also be used to set properties as well as call methods. For example:</source>
          <target state="translated">Таким образом,это также может быть использовано для установки свойств,а также для вызова методов.Например:</target>
        </trans-unit>
        <trans-unit id="8a756f40b006c215a6765390c6966fd17d773cb9" translate="yes" xml:space="preserve">
          <source>This crash can occur with two different kinds of force-unwrap:</source>
          <target state="translated">Эта авария может произойти при двух различных видах принудительного разворачивания:</target>
        </trans-unit>
        <trans-unit id="8f0250df27448e385747e9a13ccb5651fe27b21d" translate="yes" xml:space="preserve">
          <source>This is done with the &lt;code&gt;!&lt;/code&gt; operator on an optional. For example:</source>
          <target state="translated">Это сделано с &lt;code&gt;!&lt;/code&gt; оператор по желанию. Например:</target>
        </trans-unit>
        <trans-unit id="e414f3b50562e4d895870d8df98dbad24cb92fae" translate="yes" xml:space="preserve">
          <source>This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">Это более важный комментарий, и поэтому неявно развернутые дополнительные параметры могут быть обманчивы, когда дело доходит до отладки &lt;code&gt;nil&lt;/code&gt; значений.</target>
        </trans-unit>
        <trans-unit id="0cb38c500378f3659b7d36d8d3cb7a2ed2377409" translate="yes" xml:space="preserve">
          <source>This question comes up &lt;strong&gt;ALL THE TIME&lt;/strong&gt; on SO. It's one of the first things that new Swift developers struggle with.</source>
          <target state="translated">Этот вопрос возникает &lt;strong&gt;все время&lt;/strong&gt; на SO. Это одна из первых вещей, с которыми борются новые разработчики Swift.</target>
        </trans-unit>
        <trans-unit id="fe5ac8dc15cee70308d149380af17fd09b2dcd0b" translate="yes" xml:space="preserve">
          <source>This time the code has been made more clear to you. You can rationalize and think that likely it's the &lt;code&gt;address&lt;/code&gt; parameter that was forcefully unwrapped.</source>
          <target state="translated">На этот раз код стал более понятным для вас. Вы можете рационализировать и думать, что, скорее всего, это параметр &lt;code&gt;address&lt;/code&gt; который был принудительно развернут.</target>
        </trans-unit>
        <trans-unit id="f93b94e3333c14bc5a8e2daea487de2fd080c3a5" translate="yes" xml:space="preserve">
          <source>This will define a &lt;code&gt;number&lt;/code&gt; constant of &lt;code&gt;Int&lt;/code&gt; type, that will either contain the value of &lt;code&gt;anOptionalInt&lt;/code&gt;, if it contains a value, or &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">Это определит &lt;code&gt;anOptionalInt&lt;/code&gt; константу типа &lt;code&gt;Int&lt;/code&gt; , которая будет содержать значение anOptionalInt , если оно содержит значение, или &lt;code&gt;0&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="36079ad7315babb9e3cfd31e04a6700ff9a65fd1" translate="yes" xml:space="preserve">
          <source>Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)</source>
          <target state="translated">Таким образом,вы хотите быть действительно осторожными с неявно распакованными опционалами.(и,возможно,даже избегать их полностью до тех пор,пока вы не поймете,что такое опционалы).</target>
        </trans-unit>
        <trans-unit id="bf4f5d672e4353189b2590d59428129d4a05faa6" translate="yes" xml:space="preserve">
          <source>Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.</source>
          <target state="translated">Неподключенные или еще не подключенные розетки.Это конкретный случай сценария №3.В основном,у вас есть какой-то класс,загруженный XIB,который вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="7fbb993222752244a9f031c8c1d545ed152b2357" translate="yes" xml:space="preserve">
          <source>Unless you really &lt;strong&gt;do&lt;/strong&gt; know what you are doing, avoid the &quot;!&quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.</source>
          <target state="translated">Если вы действительно &lt;strong&gt;не&lt;/strong&gt; знаете, что делаете, избегайте &quot;!&quot; Принудительно развернуть оператор. Вероятно, это самый большой источник сбоев для начинающих программистов Swift.</target>
        </trans-unit>
        <trans-unit id="af66b528b3a5e4db51aa7414b4854d62642ea64a" translate="yes" xml:space="preserve">
          <source>Unwrap optional variable using &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;guard let&lt;/code&gt;</source>
          <target state="translated">Разверните необязательную переменную, используя &lt;code&gt;if let&lt;/code&gt; или &lt;code&gt;guard let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd4b5387dfce9931cda3017dc45ec2e24c2238c6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try&lt;/code&gt; this way is the proper way to try, catch and handle errors coming from throwing functions.</source>
          <target state="translated">Использование &lt;code&gt;try&lt;/code&gt; this way - это правильный способ попытаться поймать и обработать ошибки, возникающие при вызове функций.</target>
        </trans-unit>
        <trans-unit id="da6d8e9893a791f4319490b2d723d4806a84568f" translate="yes" xml:space="preserve">
          <source>Values coming from Objective-C, and that don't have nullability annotations. Let's assume we have the following Objective-C class:</source>
          <target state="translated">Значения,исходящие из Цели-С,и не имеющие примечаний об аннулировании.Предположим,что у нас есть следующий класс Objective-C:</target>
        </trans-unit>
        <trans-unit id="9d11739af047f16216d738c322733a87037f743f" translate="yes" xml:space="preserve">
          <source>What does “Fatal error: Unexpectedly found nil while unwrapping an Optional value” mean</source>
          <target state="translated">Что такое &quot;Фатальная ошибка:Неожиданно найденный ноль при разворачивании опционального значения&quot; означает.</target>
        </trans-unit>
        <trans-unit id="5e6a210b7a4319c69606343ec4904762d1eff5e8" translate="yes" xml:space="preserve">
          <source>What this does is first check that the optional contains a value. If it &lt;em&gt;does&lt;/em&gt;, then the &amp;lsquo;unwrapped&amp;rsquo; value is assigned to  a new variable (&lt;code&gt;number&lt;/code&gt;) &amp;ndash; which you can then freely use as if it were non-optional. If the optional &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; contain a value, then the else clause will be invoked, as you would expect.</source>
          <target state="translated">Это сначала проверяет, что необязательное содержит значение. Если это &lt;em&gt;так&lt;/em&gt; , то значение unwrapped присваивается новой переменной ( &lt;code&gt;number&lt;/code&gt; ), которую вы затем можете свободно использовать, как если бы она была необязательной. Если необязательный параметр &lt;em&gt;не&lt;/em&gt; содержит значения, то будет вызвано предложение else, как и следовало ожидать.</target>
        </trans-unit>
        <trans-unit id="10db728e68ab2e61caf6c0b29942fb92bfcc5927" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.</source>
          <target state="translated">Преимущество необязательного связывания заключается в том, что вы можете развернуть несколько необязательных элементов одновременно. Вы можете просто отделить утверждения запятой. Оператор будет успешным, если все дополнительные параметры были развернуты.</target>
        </trans-unit>
        <trans-unit id="1373ba269d2cc3b83a01653ae7e2e71286d08529" translate="yes" xml:space="preserve">
          <source>When should I ever force unwrap an Optional?</source>
          <target state="translated">Когда я должен когда-нибудь заставить разворачивать факультатив?</target>
        </trans-unit>
        <trans-unit id="317e17e5c488981811996349a91cb8951d0d1759" translate="yes" xml:space="preserve">
          <source>When to use and when not to use implicitly unwrapped optionals</source>
          <target state="translated">Когда использовать и когда не использовать неявно распакованные опционалы</target>
        </trans-unit>
        <trans-unit id="1f3a4ea673b0a5e8dc1d2d64df7cf20d096e7fe0" translate="yes" xml:space="preserve">
          <source>Whether you use an if or guard statement completely depends on whether any future code &lt;em&gt;requires&lt;/em&gt; the optional to contain a value.</source>
          <target state="translated">Используете ли вы оператор if или guard, полностью зависит от того, &lt;em&gt;требует&lt;/em&gt; ли какой-либо будущий код необязательного значения.</target>
        </trans-unit>
        <trans-unit id="c54b591d9a12bd724553adb14722d899feefcb1f" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;may&lt;/em&gt; be an occasion where you can use force unwrapping, as you know for a &lt;em&gt;fact&lt;/em&gt; that an optional contains a value &amp;ndash; there is not a &lt;em&gt;single&lt;/em&gt; place where you cannot safely unwrap that optional instead.</source>
          <target state="translated">Хотя &lt;em&gt;может&lt;/em&gt; быть случай, когда вы можете использовать принудительное развертывание, как вы знаете для &lt;em&gt;факта,&lt;/em&gt; что необязательный параметр содержит значение - нет ни &lt;em&gt;одного&lt;/em&gt; места, где вы не можете безопасно развернуть это необязательное.</target>
        </trans-unit>
        <trans-unit id="87bd0f61bb6e6865c8ad7d95e74d3227791bcb36" translate="yes" xml:space="preserve">
          <source>Why did I get &amp;ldquo;&lt;em&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;&amp;rdquo;?</source>
          <target state="translated">Почему я получил &amp;laquo; &lt;em&gt;фатальную ошибку: неожиданно обнаружил ноль при развертывании необязательного значения&lt;/em&gt; &amp;raquo;?</target>
        </trans-unit>
        <trans-unit id="4ed62fc8759885174a5e1c44082b865686115a7c" translate="yes" xml:space="preserve">
          <source>Will crash on reference to foo's capitalizedString property even though we're not force-unwrapping foo. the print looks fine, but it's not.</source>
          <target state="translated">Разобьется по ссылке на капитализированную собственность Фу,хотя мы не насильно разворачиваем Фу.Отпечаток выглядит нормально,но это не так.</target>
        </trans-unit>
        <trans-unit id="e425b6ac11a3cf5713fb75b070bc494a5c64679e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;very few exceptions&lt;/a&gt;, this rule is golden:</source>
          <target state="translated">За &lt;a href=&quot;https://stackoverflow.com/a/24583157/1311272&quot;&gt;очень немногими исключениями&lt;/a&gt; это правило является золотым:</target>
        </trans-unit>
        <trans-unit id="c496ef8337514f41cb37fdccdcb7d50ad577dff9" translate="yes" xml:space="preserve">
          <source>Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.</source>
          <target state="translated">Xcode покажет падение,выделив строку кода.Проблема возникает на этой строке.</target>
        </trans-unit>
        <trans-unit id="839c55483e3111c1ca07f84d7891a2c9b7b1beae" translate="yes" xml:space="preserve">
          <source>Yet at runtime it gives the following error: &lt;em&gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value&lt;/em&gt;</source>
          <target state="translated">Тем не менее, во время выполнения он выдает следующую ошибку: &lt;em&gt;Неустранимая ошибка: неожиданно обнаружен ноль при развертывании необязательного значения&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e9ce0757b971a4c196d317850c0dbdf450d7e30" translate="yes" xml:space="preserve">
          <source>You can also declare &lt;code&gt;error&lt;/code&gt; yourself, it has the advantage of being able to cast it to a useful format, for example:</source>
          <target state="translated">Вы также можете объявить &lt;code&gt;error&lt;/code&gt; самостоятельно, она имеет то преимущество, что может привести ее к полезному формату, например:</target>
        </trans-unit>
        <trans-unit id="1350d18d0403c656c2c06ac9d6b05eba79938d9b" translate="yes" xml:space="preserve">
          <source>You can use &quot;optional binding&quot; or &quot;if let&quot; to say &quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement&quot;.</source>
          <target state="translated">Вы можете использовать &quot;необязательную привязку&quot; или &quot;if let&quot;,чтобы сказать &quot;если эта опция содержит значение,сохраните это значение в новой,неопциональной переменной&quot;.Если опция не содержит значения,пропустите тело оператора if&quot;.</target>
        </trans-unit>
        <trans-unit id="5d1b249ef279beb59a5d567f45b0c019278cedef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;Optional Chaining&lt;/a&gt; in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a &lt;code&gt;?&lt;/code&gt; when using it.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245&quot;&gt;Optional Chaining&lt;/a&gt; , чтобы вызвать метод или получить доступ к свойству по желанию. Это просто делается путем добавления суффикса к имени переменной &lt;code&gt;?&lt;/code&gt; при его использовании.</target>
        </trans-unit>
        <trans-unit id="aaff60ab9a0fe1d4638638d4410b990a62bde2cf" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;if let ...&lt;/code&gt; or &lt;code&gt;guard let ... else&lt;/code&gt; and so on.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;if let ...&lt;/code&gt; или &lt;code&gt;guard let ... else&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="5d9ba10c8d2d8d6b1b597f11d55cc435237669ae" translate="yes" xml:space="preserve">
          <source>You can't!</source>
          <target state="translated">Ты не можешь!</target>
        </trans-unit>
        <trans-unit id="6ec1cc83396860fe0f710055f9d7e89e1c8bc165" translate="yes" xml:space="preserve">
          <source>You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.</source>
          <target state="translated">Можно также использовать метод пробной ловли или защиту от ошибок,но,как правило,один из вышеперечисленных методов более чистый.</target>
        </trans-unit>
        <trans-unit id="c4dc5e8cd9f1e69573167fc61cd53e581b19c500" translate="yes" xml:space="preserve">
          <source>You put a question mark after the type when you declare a variable to mean (type x, or no value).</source>
          <target state="translated">Вы ставите вопросительный знак после типа,когда объявляете переменную средней (тип x,или нет значения).</target>
        </trans-unit>
        <trans-unit id="bf8513637bc93a619e697f6a9595807f32954dc5" translate="yes" xml:space="preserve">
          <source>You should also learn about how &lt;strong&gt;Optionals&lt;/strong&gt; work, mentioned in other answers, but this is the only time that mostly appears to me.</source>
          <target state="translated">Вы также должны узнать о том, как работают &lt;strong&gt;дополнительные устройства&lt;/strong&gt; , упомянутые в других ответах, но это единственный случай, который мне больше всего кажется.</target>
        </trans-unit>
        <trans-unit id="af1087f6530251ae6d010a9f21750da1ea79e979" translate="yes" xml:space="preserve">
          <source>You should only be using implicitly unwrapped optionals as a &lt;em&gt;last resort&lt;/em&gt;. If you can use a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;lazy variable&lt;/a&gt;, or provide a &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;default value&lt;/a&gt; for a variable &amp;ndash; you should do so instead of using an implicitly unwrapped optional.</source>
          <target state="translated">Вы должны использовать только неявно развернутые опции как &lt;em&gt;последнее средство&lt;/em&gt; . Если вы можете использовать &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255&quot;&gt;переменную lazy&lt;/a&gt; или предоставить &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206&quot;&gt;значение&lt;/a&gt; по умолчанию для переменной - вы должны сделать это вместо использования неявно развернутого необязательного параметра.</target>
        </trans-unit>
        <trans-unit id="94f331b5b5c0ba72a4cfb9cf99bdd31fd6ae82d0" translate="yes" xml:space="preserve">
          <source>add this code in ViewDidLoad() at mainVC.</source>
          <target state="translated">добавьте этот код в ViewDidLoad()в mainVC.</target>
        </trans-unit>
        <trans-unit id="7f66728a6d981314d1e4ec43c0a4f6c970120d38" translate="yes" xml:space="preserve">
          <source>forced (down)casts:</source>
          <target state="translated">принудительные (вниз)слепки:</target>
        </trans-unit>
        <trans-unit id="fad23c2241f2181a2dba20635bf0879e56728e33" translate="yes" xml:space="preserve">
          <source>forced unwraps:</source>
          <target state="translated">принудительные развороты:</target>
        </trans-unit>
        <trans-unit id="958603fb1a0a0dac8fad299a6be3fb83ef2ce3f9" translate="yes" xml:space="preserve">
          <source>while clicking to show the definition, where you might find the optional type.</source>
          <target state="translated">при щелчке,чтобы показать определение,где вы можете найти необязательный тип.</target>
        </trans-unit>
        <trans-unit id="4e8e6ff2989841893307b09e3c62d4b5ade13d31" translate="yes" xml:space="preserve">
          <source>⌥</source>
          <target state="translated">⌥</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
