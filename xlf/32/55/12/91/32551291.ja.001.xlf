<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/32551291">
    <body>
      <group id="32551291">
        <trans-unit id="d0adf8710d72374b7667ab0b0ec90f9a4e48e191" translate="yes" xml:space="preserve">
          <source>(I'm ignoring &lt;code&gt;*-items&lt;/code&gt; properties here, since they simply establish defaults for &lt;code&gt;*-self&lt;/code&gt;.)</source>
          <target state="translated">（ここでは &lt;code&gt;*-items&lt;/code&gt; プロパティは無視しています。なぜなら、それらは &lt;code&gt;*-self&lt;/code&gt; のデフォルトを確立するだけだからです。）</target>
        </trans-unit>
        <trans-unit id="87f44007e0c815b4418a046627d1c32a32292bdd" translate="yes" xml:space="preserve">
          <source>(The cross axis is always perpendicular to the main axis.)</source>
          <target state="translated">(クロス軸は常に主軸に対して垂直である)</target>
        </trans-unit>
        <trans-unit id="23ff138b6483809599bab773f7cf16cba70ada2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/mz1ft6jx/8/&quot;&gt;&lt;strong&gt;PLAYGROUND&lt;/strong&gt;&lt;/a&gt; (includes code for all examples above)</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/mz1ft6jx/8/&quot;&gt;&lt;strong&gt;PLAYGROUND&lt;/strong&gt;&lt;/a&gt; （上記のすべての例のコードを含む）</target>
        </trans-unit>
        <trans-unit id="01ec125c39da5b23d7e2d92c7b80dc423d821ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; margins</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; マージン</target>
        </trans-unit>
        <trans-unit id="bf6f2b80d2774c1c9055de59bd2c0b7ab6bdfecf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;margin: auto&lt;/code&gt; is an alternative to &lt;code&gt;justify-content: center&lt;/code&gt; and &lt;code&gt;align-items: center&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;margin: auto&lt;/code&gt; は &lt;code&gt;justify-content: center&lt;/code&gt; と &lt;code&gt;align-items: center&lt;/code&gt; 代替です。</target>
        </trans-unit>
        <trans-unit id="d7277d83bd852798cc69ffcc70408410927d8cf3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;sup&gt;(credit: &lt;a href=&quot;https://stackoverflow.com/a/34455480/3597276&quot;&gt;@oriol&lt;/a&gt; for the code, and &lt;a href=&quot;https://stackoverflow.com/users/3183756/crl&quot;&gt;@crl&lt;/a&gt; for the label)&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;sup&gt;（クレジット：コードには&lt;a href=&quot;https://stackoverflow.com/users/3183756/crl&quot;&gt;@oriol&lt;/a&gt; 、ラベルには@crl ）&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0cce71c8c02b6a9dfa63a3360c0d0a442c55f44" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Consider a header section with a group of nav items and a logo. With
  &lt;code&gt;justify-self&lt;/code&gt; the logo could be aligned left while the nav items stay
  far right, and the whole thing adjusts smoothly (&quot;flexes&quot;) to
  different screen sizes.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ナビゲーションアイテムのグループとロゴを含むヘッダーセクションを考えます。&lt;/em&gt; &lt;em&gt; &lt;code&gt;justify-self&lt;/code&gt; を使用すると 、ナビゲーション項目が右端のままでロゴを左揃えにすることができ、全体がさまざまな画面サイズにスムーズに（「フレックス」）調整されます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be71f263cc2ee0b7eb52faa42e6acc4fdaae9f36" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Here are two methods for solving this problem:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この問題を解決する2つの方法を次に示します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec2382f679f227d6cab98ad865aea3a472870754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE: The examples above will only work &amp;ndash; in terms of true centering &amp;ndash; when the outermost items are equal height/width. When flex items are different lengths, see next example.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注：上記の例は、真のセンタリングに関して、最も外側のアイテムの高さ/幅が等しい場合にのみ機能します。&lt;/em&gt; &lt;em&gt;フレックスアイテムの長さが異なる場合は、次の例を参照してください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f15dcd3afeab936c96401715c5c7d8aca003f4c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that values &lt;code&gt;space-around&lt;/code&gt; and &lt;code&gt;space-between&lt;/code&gt; on
&lt;code&gt;justify-content&lt;/code&gt; property  will not keep the middle item centered about the container if the adjacent items have different widths.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;justify-content&lt;/code&gt; プロパティの &lt;code&gt;space-around&lt;/code&gt; と &lt;code&gt;space-between&lt;/code&gt; の値は、隣接するアイテムの幅が異なる場合、中央のアイテムがコンテナの中央に配置されないことに注意してください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="882bd2c7008ff6fda20938096df7a74eb5ce7f64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that values &lt;code&gt;space-around&lt;/code&gt; and &lt;code&gt;space-between&lt;/code&gt; on &lt;code&gt;justify-content&lt;/code&gt; property  will not keep the middle item centered in relation to the container if the adjacent items have different widths (&lt;a href=&quot;http://jsfiddle.net/7an37m20/12/&quot;&gt;see demo&lt;/a&gt;).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;justify-content&lt;/code&gt; プロパティの &lt;code&gt;space-around&lt;/code&gt; と &lt;code&gt;space-between&lt;/code&gt; の値は、隣接するアイテムの幅が異なる場合、コンテナーに対して中央のアイテムが中央に配置されないことに注意して&lt;a href=&quot;http://jsfiddle.net/7an37m20/12/&quot;&gt;ください&lt;/a&gt; （ デモを参照 ）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f39d73046dae365c47c26aea8030a3b148d4ba9e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;So why does the cross axis get two additional alignment properties?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;では、なぜ交差軸は2つの追加の配置プロパティを取得するのですか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f669d2478c3a72ae54c55d4256ce22f4f80f5ac6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why are &lt;code&gt;align-content&lt;/code&gt; and &lt;code&gt;align-items&lt;/code&gt; consolidated into one property for the main axis?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;align-content&lt;/code&gt; と &lt;code&gt;align-items&lt;/code&gt; が主軸の1つのプロパティに統合されるのはなぜですか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12baa504b3e88c4c76e9e4caa3a8b114033e2866" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why does the main axis not get a &lt;code&gt;justify-self&lt;/code&gt; property?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;主軸が &lt;code&gt;justify-self&lt;/code&gt; プロパティを取得しないのはなぜですか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461e4bc45b9f5e12231e7d42da971d35faff0de8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;justify-content: space-same (concept)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;justify-content：space-same（概念）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd02a2f174e726f39147cdb7cbd9ac440bfb0857" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;justify-content&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;justify-content&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f77a30776f4c98ba46fdb9d415f2e0ba01c3e7cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;8.1. Aligning with &lt;code&gt;auto&lt;/code&gt;
  margins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;8.1。&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;auto&lt;/code&gt; マージンに合わせる&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f138ca6590be12cdc56693b70c0e8e7e968ac51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;center&lt;/code&gt;&lt;/strong&gt; ~ Flex items are packed toward the center of the line.</source>
          <target state="translated">center〜フレックスアイテムはラインの中心に向かって詰められます。</target>
        </trans-unit>
        <trans-unit id="590f1c6746050d55f9d2eeceabfc5fbc813bf871" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;flex-end&lt;/code&gt;&lt;/strong&gt; ~ Flex items are packed toward the end of the line.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;flex-end&lt;/code&gt; &lt;/strong&gt; end〜Flexアイテムはラインの終わりに向かってパックされます。</target>
        </trans-unit>
        <trans-unit id="afd0a6e592253ffa96beac902846fdea380d66f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;flex-start&lt;/code&gt;&lt;/strong&gt; ~ Flex items are packed toward the start of the line.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;flex-start&lt;/code&gt; &lt;/strong&gt; start〜Flexアイテムはラインの最初に向かってパックされます。</target>
        </trans-unit>
        <trans-unit id="6fe1ac83eea7a36e61c908cbd8ab024c6744f6d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;space-around&lt;/code&gt;&lt;/strong&gt; ~ Same as &lt;code&gt;space-between&lt;/code&gt; except with half-size spaces on both ends.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;space-around&lt;/code&gt; &lt;/strong&gt; around〜両端に半角スペース &lt;code&gt;space-between&lt;/code&gt; を除いて、 space-betweenと同じです。</target>
        </trans-unit>
        <trans-unit id="300ff42df0ec34f15bb04bcc34f1942d1076cf44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;space-between&lt;/code&gt;&lt;/strong&gt; ~ Flex items are evenly spaced, with the first item aligned to one edge of the container and the last item aligned to the opposite edge. The edges used by the first and last items depends on &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#flex-direction-property&quot;&gt;&lt;code&gt;flex-direction&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/direction&quot;&gt;writing mode&lt;/a&gt; (&lt;code&gt;ltr&lt;/code&gt; or &lt;code&gt;rtl&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;space-between&lt;/code&gt; &lt;/strong&gt; between〜Flexアイテムは等間隔で配置され、最初のアイテムはコンテナの一方の端に揃えられ、最後のアイテムは反対側の端に揃えられます。 最初と最後のアイテムで使用されるエッジは、 &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#flex-direction-property&quot;&gt; &lt;code&gt;flex-direction&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/direction&quot;&gt;書き込みモード&lt;/a&gt; （ &lt;code&gt;ltr&lt;/code&gt; または &lt;code&gt;rtl&lt;/code&gt; ）によって異なります 。</target>
        </trans-unit>
        <trans-unit id="c656b8c80c57bdd37e9f1b5842dccf22070d4b31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;space-same&lt;/code&gt;&lt;/strong&gt; ~ A hybrid of &lt;code&gt;space-between&lt;/code&gt; and &lt;code&gt;space-around&lt;/code&gt;. Flex items are evenly spaced (like &lt;code&gt;space-between&lt;/code&gt;), except instead of half-size spaces on both ends (like &lt;code&gt;space-around&lt;/code&gt;), there are full-size spaces on both ends.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;space-same&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;space-between&lt;/code&gt; と &lt;code&gt;space-around&lt;/code&gt; のハイブリッド。 Flexアイテムは等間隔に配置されます（ &lt;code&gt;space-between&lt;/code&gt; のように）。両端に（ &lt;code&gt;space-around&lt;/code&gt; のように ）ハーフサイズのスペースの代わりに、両端にフルサイズのスペースがあります。</target>
        </trans-unit>
        <trans-unit id="54c2a9814326d208f935d58fa02b0bfb8618a3cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Other useful scenarios:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;その他の便利なシナリオ：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b68e7de4fe74f71d019433154fc1ff12bfa140b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Solution #1: Absolute Positioning&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ソリューション＃1：絶対配置&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4163701fb94c71954d44f831535baf6cb37492c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Solution #2: Nested Flex Containers (no absolute positioning)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ソリューション＃2：ネストされたフレックスコンテナー（絶対配置なし）&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65223fc2b2ea2fecc09cb0a919751b63c4943ec2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Browsers have begun implementing &lt;strong&gt;&lt;code&gt;space-evenly&lt;/code&gt;&lt;/strong&gt;, which accomplishes the above. See this post for details: &lt;a href=&quot;https://stackoverflow.com/q/45134400/3597276&quot;&gt;Equal space between flex items&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;ブラウザーは、上記のことを実現する&lt;strong&gt; &lt;code&gt;space-evenly&lt;/code&gt; の&lt;/strong&gt;実装を開始しました。 詳細については、この投稿を参照してください： &lt;a href=&quot;https://stackoverflow.com/q/45134400/3597276&quot;&gt;フレックスアイテム間の等間隔&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3924dea0368a791fb7b629d595519a14c09076b8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Source: &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#box-model&quot;&gt;W3C&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;出典： &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#box-model&quot;&gt;W3C&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="80d3f8d3a2a082029bbb4f99f06686098122c9c4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Source: &lt;a href=&quot;https://www.w3.org/TR/css3-align/#overview&quot;&gt;W3C&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;出典： &lt;a href=&quot;https://www.w3.org/TR/css3-align/#overview&quot;&gt;W3C&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c804b45240ab70358497d5c9caeab39f740e477f" translate="yes" xml:space="preserve">
          <source>A flex container aligns flex items by distributing free space.</source>
          <target state="translated">フレックスコンテナは、フリースペースを分散させてフレックスアイテムを配置します。</target>
        </trans-unit>
        <trans-unit id="4da17d366ecff36ea1cac650ca65d2a664eb1bf3" translate="yes" xml:space="preserve">
          <source>Align group of flex items to the right, but first item to the left</source>
          <target state="translated">フレックスアイテムのグループを右に揃え、最初のアイテムを左に揃える</target>
        </trans-unit>
        <trans-unit id="05a6a86948426358ea3c21352c7d614a295156da" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use a pseudo-element instead of an actual DOM element. Or you can use absolute positioning. All three methods are covered here: &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/q/36191516/3597276&quot;&gt;Center and bottom-align flex items&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">または、実際のDOM要素の代わりに疑似要素を使用することもできます。 または、絶対配置を使用できます。 ここでは、3つの方法すべてについて説明します。 &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/q/36191516/3597276&quot;&gt;中央揃えと下揃えのフレックスアイテム&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dc847a0e79131fa0bfb366be6971fb13b498afe" translate="yes" xml:space="preserve">
          <source>As noted, unless all flex items are of equal width or height (depending on &lt;code&gt;flex-direction&lt;/code&gt;), the middle item cannot be truly centered. This problem makes a strong case for a &lt;code&gt;justify-self&lt;/code&gt; property (designed to handle the task, of course).</source>
          <target state="translated">前述のように、すべてのflexアイテムが同じ幅または高さ（ &lt;code&gt;flex-direction&lt;/code&gt; に依存）でない限り、真ん中のアイテムを真ん中に配置することはできません。 この問題は、（もちろん、タスクを処理するように設計された） &lt;code&gt;justify-self&lt;/code&gt; プロパティを強く主張します。</target>
        </trans-unit>
        <trans-unit id="bde7c681e1cb191f24cc2edaf366944fc849dff7" translate="yes" xml:space="preserve">
          <source>As of this writing, there is no mention of &lt;code&gt;justify-self&lt;/code&gt; or &lt;code&gt;justify-items&lt;/code&gt; in the &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot;&gt;flexbox spec&lt;/a&gt;.</source>
          <target state="translated">この記事の執筆時点では、 &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot;&gt;フレックスボックスの仕様&lt;/a&gt;に &lt;code&gt;justify-self&lt;/code&gt; または &lt;code&gt;justify-items&lt;/code&gt; に関する記述はありません。</target>
        </trans-unit>
        <trans-unit id="063a6280a86b3f4718bce159521da1a8d22a803c" translate="yes" xml:space="preserve">
          <source>As stated in the question:</source>
          <target state="translated">質問に書いてある通りです。</target>
        </trans-unit>
        <trans-unit id="747ecb298c88b20b47b314aebf90221a9bdf11be" translate="yes" xml:space="preserve">
          <source>Auto Margins</source>
          <target state="translated">オートマージン</target>
        </trans-unit>
        <trans-unit id="01c572750bfa0d79795b6b6d7954908c1889529f" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;justify-content&lt;/code&gt; can work here because &lt;code&gt;auto&lt;/code&gt; margins always have priority. From the spec:</source>
          <target state="translated">ただし、 &lt;code&gt;auto&lt;/code&gt; マージンが常に優先されるため、 &lt;code&gt;justify-content&lt;/code&gt; はここで機能します。 スペックから：</target>
        </trans-unit>
        <trans-unit id="8d4213b36744da1b265e0303472bb103783c22cc" translate="yes" xml:space="preserve">
          <source>Center a flex item vertically and horizontally</source>
          <target state="translated">フレックスアイテムを縦と横にセンタリングする</target>
        </trans-unit>
        <trans-unit id="7500d336c8ddc6598c8ae48c4bf50410c73ec5b7" translate="yes" xml:space="preserve">
          <source>Center a flex item when adjacent items vary in size</source>
          <target state="translated">隣接するアイテムのサイズが異なる場合にフレックスアイテムを中央に配置する</target>
        </trans-unit>
        <trans-unit id="fc2900f83a97eb5a8a7c8cd243c8f3d85f8e5a7f" translate="yes" xml:space="preserve">
          <source>Center a flex item, and center a second flex item between the first and the edge</source>
          <target state="translated">フレックスアイテムをセンタリングし、第1のフレックスアイテムと端部との間に第2のフレックスアイテムをセンタリングする</target>
        </trans-unit>
        <trans-unit id="5b90c37faf74a9a2d30dae7e3a8d4388130e1cfb" translate="yes" xml:space="preserve">
          <source>Consider the main axis and cross axis of a flex container:</source>
          <target state="translated">フレックスコンテナの主軸とクロス軸を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3d2ca01355425326b5db1b89e25dae4411947c07" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;.box&lt;/code&gt; item is given &lt;code&gt;flex: 1&lt;/code&gt; in order to distribute container space equally.</source>
          <target state="translated">コンテナのスペースを均等に配分するために、各 &lt;code&gt;.box&lt;/code&gt; アイテムには &lt;code&gt;flex: 1&lt;/code&gt; が与えられます。</target>
        </trans-unit>
        <trans-unit id="7308075d5eb7c52d10886f82aceb093fa28acdc7" translate="yes" xml:space="preserve">
          <source>Each child div (&lt;code&gt;.box&lt;/code&gt;) is now a flex item.</source>
          <target state="translated">各子div（ &lt;code&gt;.box&lt;/code&gt; ）はflexアイテムになりました。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="9b9c7185b10cff50c07d31dc8c67f387d7383041" translate="yes" xml:space="preserve">
          <source>For multi-line flexbox, the same logic applies to each &quot;flex line&quot;. In a given line, items are aligned individually in the cross axis (since there's only one item per line, in the cross axis), vs. collectively in the main axis.</source>
          <target state="translated">複数行のフレックスボックスの場合、各「フレックスライン」にも同じロジックが適用されます。与えられた行では、アイテムは、主軸にまとめて配置されるのに対して、横軸に個別に配置されます(行ごとに1つのアイテムしかないので、横軸に配置されます)。</target>
        </trans-unit>
        <trans-unit id="0e261cb61c15e7524a3f5f73edaf2997f6a48b7c" translate="yes" xml:space="preserve">
          <source>Going back to &lt;a href=&quot;https://stackoverflow.com/a/33856609/3597276&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt; for a minute, here's an idea for one more option.</source>
          <target state="translated">1分間&lt;a href=&quot;https://stackoverflow.com/a/33856609/3597276&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; &lt;/a&gt;戻って、もう1つのオプションのアイデアを示します。</target>
        </trans-unit>
        <trans-unit id="3076a1145a934d87ac14292707679e111176b2ef" translate="yes" xml:space="preserve">
          <source>Hence, in order to create &lt;em&gt;equal balance&lt;/em&gt;, so that a middle item can be centered in the container with a single item alongside, a counterbalance must be introduced.</source>
          <target state="translated">したがって、 &lt;em&gt;均等なバランス&lt;/em&gt;を作成して、中央のアイテムを1つのアイテムを並べてコンテナーの中央に配置できるようにするには、カウンターバランスを導入する必要があります。</target>
        </trans-unit>
        <trans-unit id="ef7f4acde5c6414199299ee93519f61d4b7a719f" translate="yes" xml:space="preserve">
          <source>Here's another way of phrasing it: so, &lt;em&gt;all&lt;/em&gt; of the &lt;code&gt;*-self&lt;/code&gt; and &lt;code&gt;*-content&lt;/code&gt; properties are about how to distribute extra space around things.  But the key difference is that the &lt;code&gt;*-self&lt;/code&gt; versions are for cases where there's &lt;em&gt;only a single thing in that axis&lt;/em&gt;, and the &lt;code&gt;*-content&lt;/code&gt; versions are for when there are potentially &lt;em&gt;many things in that axis&lt;/em&gt;. The one-thing vs. many-things scenarios are different types of problems, and so they have different types of options available -- for example, the &lt;code&gt;space-around&lt;/code&gt; / &lt;code&gt;space-between&lt;/code&gt; values make sense for &lt;code&gt;*-content&lt;/code&gt;, but not for &lt;code&gt;*-self&lt;/code&gt;.</source>
          <target state="translated">これは別の言い方です。つまり、 &lt;code&gt;*-content&lt;/code&gt; プロパティと* -contentプロパティは&lt;em&gt;すべて&lt;/em&gt; 、周囲に余分なスペースを配置する方法です。 ただし、主な違いは、 &lt;code&gt;*-content&lt;/code&gt; バージョンは&lt;em&gt;その軸に1つしか&lt;/em&gt;存在し&lt;em&gt;ない&lt;/em&gt;場合の&lt;em&gt;もので&lt;/em&gt;あり、 *-contentバージョンは&lt;em&gt;その軸に&lt;/em&gt;潜在的に&lt;em&gt;多くのもの&lt;/em&gt;が存在する場合の&lt;em&gt;ものであること&lt;/em&gt;です。 1対多のシナリオはさまざまなタイプの問題であるため、使用できるオプションのタイプはさまざまです。たとえば、 &lt;code&gt;space-around&lt;/code&gt; / &lt;code&gt;space-between&lt;/code&gt; の値は &lt;code&gt;*-content&lt;/code&gt; では意味がありますが、 *では意味がありません。 &lt;code&gt;*-self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcae16de665cdab304c88fb675786b95de0fc2e3" translate="yes" xml:space="preserve">
          <source>Here's how it works:</source>
          <target state="translated">その仕組みをご紹介します。</target>
        </trans-unit>
        <trans-unit id="a0e3a2a19ce1000cf191188a9fee46e9d189c657" translate="yes" xml:space="preserve">
          <source>However, in the &lt;a href=&quot;http://www.w3.org/TR/css-align-3/&quot;&gt;CSS Box Alignment Module&lt;/a&gt;, which is the W3C's unfinished proposal to establish a common set of alignment properties for use across all box models, there is this:</source>
          <target state="translated">ただし、 &lt;a href=&quot;http://www.w3.org/TR/css-align-3/&quot;&gt;CSS Box Alignment Module&lt;/a&gt;には、すべてのボックスモデルで使用するための共通の配置プロパティセットを確立するというW3Cの未完成の提案があります。これは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="875275a668cdf2393513313f9d2b0faee4082721" translate="yes" xml:space="preserve">
          <source>However, these directions can be easily interchanged with the &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#propdef-flex-direction&quot;&gt;&lt;code&gt;flex-direction&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">ただし、これらの方向は&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/#propdef-flex-direction&quot;&gt; &lt;code&gt;flex-direction&lt;/code&gt; &lt;/a&gt;プロパティと簡単に交換できます。</target>
        </trans-unit>
        <trans-unit id="c548970d6aa13a373f3147e2a073121aba64c29b" translate="yes" xml:space="preserve">
          <source>I know this doesn't use flexbox, but for the simple use-case of three items (one at left, one at center, one at right), this can be accomplished easily using &lt;code&gt;display: grid&lt;/code&gt; on the parent, &lt;code&gt;grid-area: 1/1/1/1;&lt;/code&gt; on the children, and &lt;code&gt;justify-self&lt;/code&gt; for positioning of those children.</source>
          <target state="translated">これはフレックスボックスを使用しないことを知っていますが、3つの項目（左に1つ、中央に1つ、右に1つ）の単純なユースケースの場合、これは &lt;code&gt;display: grid&lt;/code&gt; 親の &lt;code&gt;grid-area: 1/1/1/1;&lt;/code&gt; 、 grid-area： 1/1/1/1; 子供たちに、そしてそれらの子供たちのポジショニングのために &lt;code&gt;justify-self&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="65b83508d4321b99493ef685e4b8a62cde229d84" translate="yes" xml:space="preserve">
          <source>I know this is not an answer, but I'd like to contribute to this matter for what it's worth. It would be great if they could release &lt;code&gt;justify-self&lt;/code&gt; for flexbox to make it truly flexible.</source>
          <target state="translated">私はこれが答えではないことを知っていますが、私はそれが価値があるもののためにこの問題に貢献したいと思います。 flexboxを本当に柔軟にするためにジャスティファイ &lt;code&gt;justify-self&lt;/code&gt; をリリースできれば素晴らしいと思います。</target>
        </trans-unit>
        <trans-unit id="0a3f6838d89bc36a8fc2e9bf9922fa739f6a4fcc" translate="yes" xml:space="preserve">
          <source>I truly hope, W3C takes notice of this and will at least consider it. =)</source>
          <target state="translated">W3Cがこれに注目して、少なくとも検討してくれることを心から願っています。)</target>
        </trans-unit>
        <trans-unit id="efbdf21baf4e7c29ed8d162c92dc1cd17b814e14" translate="yes" xml:space="preserve">
          <source>I'll end by reiterating the main question:</source>
          <target state="translated">最後に本題の再掲をして終わります。</target>
        </trans-unit>
        <trans-unit id="4772a3830eb86f10627970d7479b8e5311e2eddc" translate="yes" xml:space="preserve">
          <source>In CSS Flexbox, why are there no “justify-items” and “justify-self” properties</source>
          <target state="translated">CSS Flexboxでは、なぜ &quot;justify-items &quot;と &quot;justify-self &quot;のプロパティがないのか?</target>
        </trans-unit>
        <trans-unit id="8b7804282eb657aa81012de0a9d0f54bfee34e05" translate="yes" xml:space="preserve">
          <source>In contrast, in the cross axis, we have both a &lt;code&gt;*-self&lt;/code&gt; and a &lt;code&gt;*-content&lt;/code&gt; property.  One determines how we'll distribute space around the &lt;em&gt;many&lt;/em&gt; flex lines (&lt;code&gt;align-content&lt;/code&gt;), whereas the other (&lt;code&gt;align-self&lt;/code&gt;) determines how to distribute space around &lt;em&gt;individual&lt;/em&gt; flex items in the cross axis, within a given flex line.</source>
          <target state="translated">対照的に、横軸には、 &lt;code&gt;*-content&lt;/code&gt; プロパティと* -contentプロパティの両方があります。 1つは&lt;em&gt;多くの&lt;/em&gt;フレックスラインの周りにスペースをどのように配置するかを決定し（ &lt;code&gt;align-content&lt;/code&gt; ）、もう1つは（ &lt;code&gt;align-self&lt;/code&gt; ）所定のフレックスライン内のクロス軸の&lt;em&gt;個々の&lt;/em&gt;フレックスアイテムの周りにスペースを配置する方法を決定します。</target>
        </trans-unit>
        <trans-unit id="37756e40491f2fb1119ce1774bafce1cc6c05ab9" translate="yes" xml:space="preserve">
          <source>In the examples below, invisible third flex items (boxes 61 &amp;amp; 68) are introduced to balance out the &quot;real&quot; items (box 63 &amp;amp; 66).</source>
          <target state="translated">以下の例では、「実際の」アイテム（ボックス63および66）のバランスをとるために、非表示の3番目のフレックスアイテム（ボックス61および68）が導入されています。</target>
        </trans-unit>
        <trans-unit id="c88fa0fcc5de0d0213083a8fd4d15ad3e8bcb814" translate="yes" xml:space="preserve">
          <source>In the examples below, the middle item is centered with absolute positioning and the outer items remain in-flow. But the same layout can be achieved in reverse fashion: Center the middle item with &lt;code&gt;justify-content: center&lt;/code&gt; and absolutely position the outer items.</source>
          <target state="translated">以下の例では、中央のアイテムは絶対配置で中央に配置され、外側のアイテムはインフローのままです。 ただし、同じレイアウトを逆の方法で実現できます。中央のアイテムを &lt;code&gt;justify-content: center&lt;/code&gt; 揃えにします。外側のアイテムを中央に配置し、絶対的に配置します。</target>
        </trans-unit>
        <trans-unit id="272fbf104af5738686712062b783431cc9f3df64" translate="yes" xml:space="preserve">
          <source>In the image above, the main axis is horizontal and the cross axis is vertical. These are the default directions of a flex container.</source>
          <target state="translated">上の画像では、主軸が横軸、十字軸が縦軸になっています。これらはフレックスコンテナのデフォルトの方向です。</target>
        </trans-unit>
        <trans-unit id="3c79e4b5dfb2911d012af76d845c3abf8b9e5c44" translate="yes" xml:space="preserve">
          <source>Instead of this code on the flex container:</source>
          <target state="translated">フレックスコンテナ上のこのコードの代わりに</target>
        </trans-unit>
        <trans-unit id="93ca92e0b3437e59e32e28886010a3656e244fba" translate="yes" xml:space="preserve">
          <source>It is applied to the flex container but only affects flex items.</source>
          <target state="translated">フレックスコンテナに適用されますが、フレックスアイテムにのみ影響します。</target>
        </trans-unit>
        <trans-unit id="c3da8523bbd051218b3552fe613194443a5c3afb" translate="yes" xml:space="preserve">
          <source>It's my belief that when there are multiple items on the axis, the most logical way for &lt;code&gt;justify-self&lt;/code&gt; to behave is to align itself to its nearest neighbours (or edge) as demonstrated below.</source>
          <target state="translated">軸上に複数のアイテムがある場合、 &lt;code&gt;justify-self&lt;/code&gt; が動作する最も論理的な方法は、以下に示すように、自身を最も近い近傍（またはエッジ）に位置合わせすることであると私の信念です。</target>
        </trans-unit>
        <trans-unit id="739dad22c33408410ac37ca0ce40fb18c410b8ad" translate="yes" xml:space="preserve">
          <source>Just keep in mind that, like all absolutely positioned elements, the items are removed from the &lt;a href=&quot;https://www.w3.org/TR/CSS22/visuren.html#normal-flow&quot;&gt;document flow&lt;/a&gt;. This means they don't take up space in the container and can overlap their siblings.</source>
          <target state="translated">すべての絶対配置要素と同様に、アイテムは&lt;a href=&quot;https://www.w3.org/TR/CSS22/visuren.html#normal-flow&quot;&gt;ドキュメントフロー&lt;/a&gt;から削除されることに注意してください。 つまり、コンテナ内のスペースを占有せず、兄弟を重ねることができます。</target>
        </trans-unit>
        <trans-unit id="e0b9968c18ab550e495d78526b744718b77addff" translate="yes" xml:space="preserve">
          <source>Make each item a (nested) flex container and add &lt;code&gt;justify-content: center&lt;/code&gt;.</source>
          <target state="translated">各アイテムを（ネストされた）フレックスコンテナーにして、 &lt;code&gt;justify-content: center&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="5d8066cc9b03e98c675abe23de2883c00ac31e5c" translate="yes" xml:space="preserve">
          <source>Methods for Aligning Flex Items along the Main Axis</source>
          <target state="translated">主軸に沿ったフレックスアイテムの配置方法</target>
        </trans-unit>
        <trans-unit id="82eb4eef826aa6c8bc9837418f29eeb1724ca7b9" translate="yes" xml:space="preserve">
          <source>My point in describing how the axes' work is that there doesn't seem to be anything special about either direction. Main axis, cross axis, they're both equal in terms of importance and &lt;code&gt;flex-direction&lt;/code&gt; makes it easy to switch back and forth.</source>
          <target state="translated">軸の動作を説明する上での私のポイントは、どちらの方向にも特別なものは何もないように見えることです。 主軸、交差軸、重要性の点で同じであり、 &lt;code&gt;flex-direction&lt;/code&gt; により、簡単に前後に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="ac82ff486a34d57698d149ec732b71604850ca58" translate="yes" xml:space="preserve">
          <source>Now each &lt;code&gt;span&lt;/code&gt; element is a centered flex item.</source>
          <target state="translated">これで、各 &lt;code&gt;span&lt;/code&gt; 要素は中央揃えのフレックスアイテムになります。</target>
        </trans-unit>
        <trans-unit id="1180c7b4f540ed903856a89607ed3a67f6435121" translate="yes" xml:space="preserve">
          <source>Now the items are consuming all space in the row and are equal width.</source>
          <target state="translated">これで、項目は行内のすべてのスペースを消費し、幅が同じになりました。</target>
        </trans-unit>
        <trans-unit id="1db5cdc44ae81cdbeac3876f61dd7aefe29a1c96" translate="yes" xml:space="preserve">
          <source>Of course, this method is nothing great in terms of semantics.</source>
          <target state="translated">もちろん、この方法は意味論的には何も素晴らしいことはありません。</target>
        </trans-unit>
        <trans-unit id="98a3075ac072c5bbe8f097c8a62fbf167a8ee772" translate="yes" xml:space="preserve">
          <source>One answer may be: &lt;em&gt;Because they're not necessary.&lt;/em&gt;</source>
          <target state="translated">1つの答えは次のとおり&lt;em&gt;です。それらは必要ないためです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eab3d81600a0e6948e5a5f7275850f42b98b134" translate="yes" xml:space="preserve">
          <source>Place a flex item in the corner</source>
          <target state="translated">フレックスアイテムをコーナーに配置</target>
        </trans-unit>
        <trans-unit id="e4568d5a3c303e6f9130f5fb032f2a720cca858d" translate="yes" xml:space="preserve">
          <source>Prior to alignment via &lt;code&gt;justify-content&lt;/code&gt; and &lt;code&gt;align-self&lt;/code&gt;, any
  positive free space is distributed to auto margins in that dimension.</source>
          <target state="translated">&lt;code&gt;justify-content&lt;/code&gt; と &lt;code&gt;align-self&lt;/code&gt; による位置合わせの前に、正の空き領域がその次元の自動マージンに分散されます。</target>
        </trans-unit>
        <trans-unit id="709adcb6169a5ae72c065c5951d469b1e50f4cc0" translate="yes" xml:space="preserve">
          <source>SO: In a flexbox's main axis, there are many things to distribute space around. So a &lt;code&gt;*-content&lt;/code&gt; property makes sense there, but not a &lt;code&gt;*-self&lt;/code&gt; property.</source>
          <target state="translated">SO：フレックスボックスの主軸では、周りにスペースを分散させるために多くのものがあります。 したがって、 &lt;code&gt;*-content&lt;/code&gt; プロパティは、 *-selfプロパティでは意味がありません。</target>
        </trans-unit>
        <trans-unit id="e85344f152be9d004898c21033ba7739575a8d96" translate="yes" xml:space="preserve">
          <source>Scenario from the question:</source>
          <target state="translated">質問からのシナリオ。</target>
        </trans-unit>
        <trans-unit id="2bd0fa47144f1af128f63f96fad41e10b3e1a782" translate="yes" xml:space="preserve">
          <source>Scenarios where these properties would be useful:</source>
          <target state="translated">これらのプロパティが有用であると思われるシナリオ。</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="17f2e34a5076d813ccb0945e905e65d131e7aa4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/&quot;&gt;flexbox specification&lt;/a&gt; provides &lt;em&gt;two&lt;/em&gt; methods for aligning flex items along the main axis:</source>
          <target state="translated">フレックス&lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/&quot;&gt;ボックス仕様で&lt;/a&gt;は、主軸に沿ってフレックスアイテムを配置するための&lt;em&gt;2つの&lt;/em&gt;方法が提供されています。</target>
        </trans-unit>
        <trans-unit id="87124f1fc4db00f03ba205517bc85ee8a255d676" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#justify-content-property&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt; property aligns flex items along the main axis of the flex container.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#justify-content-property&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; &lt;/a&gt;プロパティは、フレックスコンテナーの主軸に沿ってフレックスアイテムを配置します。</target>
        </trans-unit>
        <trans-unit id="13119a843f7925f48797e13473d61b03728af02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;justify-content&lt;/code&gt; keyword property, and</source>
          <target state="translated">&lt;code&gt;justify-content&lt;/code&gt; キーワードプロパティ、および</target>
        </trans-unit>
        <trans-unit id="8054d659d6f2f90a878d8e06a1b4b0c0148b410c" translate="yes" xml:space="preserve">
          <source>The ease of making awesome layouts are endless, take a look at this &quot;complex&quot; example.</source>
          <target state="translated">素晴らしいレイアウトを作ることの容易さは無限であり、この &quot;複雑な &quot;例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b7b02bea92259be41b1d4b835a2206d212647cd9" translate="yes" xml:space="preserve">
          <source>The flexbox spec allows for &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#abspos-items&quot;&gt;absolute positioning of flex items&lt;/a&gt;. This allows for the middle item to be perfectly centered regardless of the size of its siblings.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#abspos-items&quot;&gt;フレックス&lt;/a&gt;ボックス仕様では、フレックスアイテムの絶対配置が可能です。 これにより、兄弟のサイズに関係なく、真ん中のアイテムを完全に中央に配置できます。</target>
        </trans-unit>
        <trans-unit id="c46a20385e49898949f3110263211ac2909b7b6c" translate="yes" xml:space="preserve">
          <source>The question then asks:</source>
          <target state="translated">続いて質問が出ます。</target>
        </trans-unit>
        <trans-unit id="fb11d4bae6d47595c09a7e9509244c4ad5bac98b" translate="yes" xml:space="preserve">
          <source>The top-level div (&lt;code&gt;.container&lt;/code&gt;) is a flex container.</source>
          <target state="translated">トップレベルのdiv（ &lt;code&gt;.container&lt;/code&gt; ）はフレックスコンテナーです。</target>
        </trans-unit>
        <trans-unit id="b0caf8999f687ab71c7b3cbfc376d1e250a46f84" translate="yes" xml:space="preserve">
          <source>There are five alignment options:</source>
          <target state="translated">アライメントは5つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="5d8c86150c16391a3211d601ba175d8cc5a83be4" translate="yes" xml:space="preserve">
          <source>They work by consuming all free space in the specified direction.</source>
          <target state="translated">指定された方向にあるすべての空きスペースを消費することで動作します。</target>
        </trans-unit>
        <trans-unit id="efce2f6e1f2e99d89b2b8840eeb7ed650872d949" translate="yes" xml:space="preserve">
          <source>This alternative is useful when &lt;a href=&quot;https://stackoverflow.com/q/33454533/3597276&quot;&gt;&lt;strong&gt;centering a flex item that overflows the container&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">この方法は&lt;a href=&quot;https://stackoverflow.com/q/33454533/3597276&quot;&gt;&lt;strong&gt;、コンテナーからオーバーフローするフレックスアイテムを中央&lt;/strong&gt;&lt;/a&gt;に配置するときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="04d36d1bd9bba3a7f54efd6b51574c0dd5f2ea6a" translate="yes" xml:space="preserve">
          <source>This layout can be achieved with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/%3A%3Abefore&quot;&gt;&lt;code&gt;::before&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/%3A%3Aafter&quot;&gt;&lt;code&gt;::after&lt;/code&gt;&lt;/a&gt; pseudo-elements on the flex container.</source>
          <target state="translated">このレイアウトは、フレックスコンテナーの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/%3A%3Abefore&quot;&gt; &lt;code&gt;::before&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/%3A%3Aafter&quot;&gt; &lt;code&gt;::after&lt;/code&gt; &lt;/a&gt;疑似要素で実現できます。</target>
        </trans-unit>
        <trans-unit id="78815cd68ed41c7001f10d2c4364833392e8238d" translate="yes" xml:space="preserve">
          <source>This was asked on the www-style list, and Tab Atkins (spec editor) &lt;a href=&quot;https://lists.w3.org/Archives/Public/www-style/2015Apr/0114.html&quot;&gt;provided an answer explaining why&lt;/a&gt;. I'll elaborate on that a bit here.</source>
          <target state="translated">これはwwwスタイルのリストで尋ねられ、Tab Atkins（スペックエディター） &lt;a href=&quot;https://lists.w3.org/Archives/Public/www-style/2015Apr/0114.html&quot;&gt;がその理由を説明する回答を提供しました&lt;/a&gt; 。 ここで少し詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="0e8b933e14def2e3c880d17941aeaae871a6d270" translate="yes" xml:space="preserve">
          <source>This way you can have an item that is truly centered regardless of the size of the left and right box. When one of the boxes reaches the point of the center box it will simply push it until there is no more space to distribute.</source>
          <target state="translated">このようにすることで、左右のボックスの大きさに関係なく、真に中央に位置するアイテムを持つことができます。どちらかのボックスが中央のボックスのポイントに達すると、それは単にそれを配布するためのそれ以上のスペースがなくなるまでそれをプッシュします。</target>
        </trans-unit>
        <trans-unit id="5b46f4c9a033791982fdfe2bab73fabcafeb9c29" translate="yes" xml:space="preserve">
          <source>To align flex items along the cross axis there are three properties:</source>
          <target state="translated">フレックスアイテムを十字軸に沿って配置するには、3つのプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="e74e96c38351b2baa08ed57895153bb2db0648ef" translate="yes" xml:space="preserve">
          <source>To align flex items along the cross axis there are three properties: &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#align-content-property&quot;&gt;&lt;code&gt;align-content&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#align-items-property&quot;&gt;&lt;code&gt;align-items&lt;/code&gt; and &lt;code&gt;align-self&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クロス軸に沿ってflexアイテムを整列させるために、3つのプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="a4c93f3931932e07dd086729073d59b602536745" translate="yes" xml:space="preserve">
          <source>To align flex items along the main axis there is one property:</source>
          <target state="translated">主軸に沿ってフレックスアイテムを配置するには、1つのプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="441039ac4d86a52dda68662f244f7a7843735b4c" translate="yes" xml:space="preserve">
          <source>To align flex items along the main axis there is one property: &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#justify-content-property&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">主軸に沿ってフレックスアイテムを配置するには、1つのプロパティがあります： &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#justify-content-property&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="926349ca375edf7159b92b90c752bb45edac6c06" translate="yes" xml:space="preserve">
          <source>To start out, let's initially assume our flex container is single-line (&lt;code&gt;flex-wrap: nowrap&lt;/code&gt;). In this case, there's clearly an alignment difference between the main axis and the cross axis -- there are multiple items stacked in the main axis, but only one item stacked in the cross axis. So it makes sense to have a customizeable-per-item &quot;align-self&quot; in the cross axis (since each item is aligned separately, on its own), whereas it doesn't make sense in the main axis (since there, the items are aligned collectively).</source>
          <target state="translated">まず、フレックスコンテナーが単一行（ &lt;code&gt;flex-wrap: nowrap&lt;/code&gt; ）であると仮定します。 この場合、主軸と交差軸の配置に明らかに違いがあります。主軸には複数のアイテムが積み重ねられていますが、交差軸には1つのアイテムしか積み上げられていません。 したがって、クロス軸にアイテムごとにカスタマイズ可能な「align-self」を配置することは理にかなっています（各アイテムは個別に個別に配置されるため）。一方、メイン軸（それがないため、アイテムはまとめて配置されます）。</target>
        </trans-unit>
        <trans-unit id="a4b79ce2ed9ff853a57d406c94901c306bd02037" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;justify-content&lt;/code&gt;, which is applied to the flex container, &lt;code&gt;auto&lt;/code&gt; margins go on flex items.</source>
          <target state="translated">flexコンテナーに適用される &lt;code&gt;justify-content&lt;/code&gt; とは異なり、 &lt;code&gt;auto&lt;/code&gt; マージンはflexアイテムに適用されます。</target>
        </trans-unit>
        <trans-unit id="2f1c388f2373313235bd362d7e15ff7b90bd84fb" translate="yes" xml:space="preserve">
          <source>Use flex &lt;code&gt;auto&lt;/code&gt; margins to shift the outer &lt;code&gt;span&lt;/code&gt;s left and right.</source>
          <target state="translated">フレックス &lt;code&gt;auto&lt;/code&gt; マージンを使用して、外側の &lt;code&gt;span&lt;/code&gt; を左右にシフトします 。</target>
        </trans-unit>
        <trans-unit id="12c1d2b1cd4b64830c17d3e48423acd0022cc632" translate="yes" xml:space="preserve">
          <source>Why are there no &quot;justify-items&quot; and &quot;justify-self&quot; properties?</source>
          <target state="translated">なぜ「justify-items」と「justify-self」のプロパティがないのか?</target>
        </trans-unit>
        <trans-unit id="0a97f40220d48afbe93d21d9acbefb01332789fa" translate="yes" xml:space="preserve">
          <source>Why are there no &lt;code&gt;justify-items&lt;/code&gt; and &lt;code&gt;justify-self&lt;/code&gt; properties?</source>
          <target state="translated">&lt;code&gt;justify-items&lt;/code&gt; と &lt;code&gt;justify-self&lt;/code&gt; プロパティがないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="2bc6837c057f2cbf487e67e38795156c781a92c3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#auto-margins&quot;&gt;&lt;code&gt;auto&lt;/code&gt; margins&lt;/a&gt;, flex items can be centered, spaced away or packed into sub-groups.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/css-flexbox-1/#auto-margins&quot;&gt; &lt;code&gt;auto&lt;/code&gt; マージンを使用すると&lt;/a&gt; 、フレックスアイテムを中央に配置したり、間隔を空けたり、サブグループにパックしたりできます。</target>
        </trans-unit>
        <trans-unit id="84c7988b483f93b21c0019ff4cf1937bbab47d9d" translate="yes" xml:space="preserve">
          <source>You can use this on the flex item:</source>
          <target state="translated">フレックスアイテムにも使えます。</target>
        </trans-unit>
        <trans-unit id="61c1d569c686ec4bbde2e3747c4364ad79778251" translate="yes" xml:space="preserve">
          <source>You could also forgo &lt;code&gt;justify-content&lt;/code&gt; and use &lt;code&gt;auto&lt;/code&gt; margins exclusively.</source>
          <target state="translated">また &lt;code&gt;justify-content&lt;/code&gt; を忘れて、 &lt;code&gt;auto&lt;/code&gt; マージンを排他的に使用することもできます。</target>
        </trans-unit>
        <trans-unit id="6bf7bcac703b01728bcc0b903373750a57e0446e" translate="yes" xml:space="preserve">
          <source>You'll notice that &lt;code&gt;justify-self&lt;/code&gt; and &lt;code&gt;justify-items&lt;/code&gt; are being considered... &lt;em&gt;but not for flexbox&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;justify-self&lt;/code&gt; と &lt;code&gt;justify-items&lt;/code&gt; が検討されていることに気付くでしょう... &lt;em&gt;しかしflexboxについてはそうではありません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="29dafa2f2041145636463ea3de38f5ab6cc203c9" translate="yes" xml:space="preserve">
          <source>in a row of three flex items, affix the middle item to the center of the container  (&lt;code&gt;justify-content: center&lt;/code&gt;) and align the adjacent
  items to the container edges (&lt;code&gt;justify-self: flex-start&lt;/code&gt; and
  &lt;code&gt;justify-self: flex-end&lt;/code&gt;).</source>
          <target state="translated">3つのフレックスアイテムの行で、中央のアイテムをコンテナーの中央に貼り付け（ &lt;code&gt;justify-content: center&lt;/code&gt; ）、隣接するアイテムをコンテナーの端に揃えます（ &lt;code&gt;justify-self: flex-start&lt;/code&gt; および &lt;code&gt;justify-self: flex-end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dc9a190f4d4ce52f1b859b2aa8f88fc216c314ff" translate="yes" xml:space="preserve">
          <source>jsFiddle version</source>
          <target state="translated">jsFiddleバージョン</target>
        </trans-unit>
        <trans-unit id="9eee0a92017fd47aad364b5ad123b08e1ab3ce15" translate="yes" xml:space="preserve">
          <source>making a group of flex items align-right (&lt;code&gt;justify-content: flex-end&lt;/code&gt;)
  but have the first item align left (&lt;code&gt;justify-self: flex-start&lt;/code&gt;)</source>
          <target state="translated">フレックスアイテムのグループを &lt;code&gt;justify-content: flex-end&lt;/code&gt; （ justify-content：flex-end ）が、最初のアイテムを左揃えにします（ &lt;code&gt;justify-self: flex-start&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7f7b8a182e3a8e4c8d707973a7fee69e035ee791" translate="yes" xml:space="preserve">
          <source>placing a flex item in a corner &lt;code&gt;.box { align-self: flex-end; justify-self: flex-end; }&lt;/code&gt;</source>
          <target state="translated">コーナー &lt;code&gt;.box { align-self: flex-end; justify-self: flex-end; }&lt;/code&gt; フレックスアイテムを配置する{align-self：flex-end; justify-self：flex-end; }</target>
        </trans-unit>
        <trans-unit id="7f54afe70e6bf663d8ae52f6ac3e4e40b400d526" translate="yes" xml:space="preserve">
          <source>placing a flex item in the corner of the flex container</source>
          <target state="translated">フレックスコンテナの隅にフレックスアイテムを置く</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
