<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/495021">
    <body>
      <group id="495021">
        <trans-unit id="b035bf2cc167fd9eb1fa6ad4f75e65902c071b59" translate="yes" xml:space="preserve">
          <source>&quot;Instantiation-style polymorphism&quot; means that the template &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt; isn't really a generic class that can be compiled to code that can work for any value of &lt;code&gt;T&lt;/code&gt;. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical &lt;code&gt;class MyClass_int&lt;/code&gt;, &lt;code&gt;class MyClass_float&lt;/code&gt;, etc, but to still be able to end up with compiled code that is mostly as if we &lt;em&gt;had&lt;/em&gt; written each version separately. So a template is &lt;em&gt;literally&lt;/em&gt; a template; a class template is &lt;em&gt;not&lt;/em&gt; a class, it's a recipe for creating a new class for each &lt;code&gt;T&lt;/code&gt; we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.</source>
          <target state="translated">&quot;Polimorfismo de estilo de instanciaci&amp;oacute;n&quot; significa que la plantilla &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt; no es realmente una clase gen&amp;eacute;rica que pueda compilarse en un c&amp;oacute;digo que pueda funcionar para cualquier valor de &lt;code&gt;T&lt;/code&gt; . Eso agregar&amp;iacute;a gastos generales como el boxeo, la necesidad de pasar punteros de funci&amp;oacute;n a asignadores y constructores, etc. La intenci&amp;oacute;n de las plantillas de C ++ es evitar tener que escribir &lt;code&gt;class MyClass_int&lt;/code&gt; casi id&amp;eacute;nticas MyClass_int , &lt;code&gt;class MyClass_float&lt;/code&gt; , etc., pero a&amp;uacute;n as&amp;iacute; poder terminar con c&amp;oacute;digo compilado que es principalmente como si hubi&amp;eacute;ramos escrito cada versi&amp;oacute;n por separado. Entonces una plantilla es &lt;em&gt;literalmente&lt;/em&gt; una plantilla; una plantilla de clase &lt;em&gt;no&lt;/em&gt; es una clase, es una receta para crear una nueva clase para cada &lt;code&gt;T&lt;/code&gt; que encontremos. Una plantilla no se puede compilar en c&amp;oacute;digo, solo se puede compilar el resultado de instanciar la plantilla.</target>
        </trans-unit>
        <trans-unit id="e9f8648e64f859e7cabf474d36d8473d6277cf09" translate="yes" xml:space="preserve">
          <source>(Clarification: header files are not the &lt;em&gt;only&lt;/em&gt; portable solution. But they are the most convenient portable solution.)</source>
          <target state="translated">(Aclaraci&amp;oacute;n: los archivos de encabezado no son la &lt;em&gt;&amp;uacute;nica&lt;/em&gt; soluci&amp;oacute;n port&amp;aacute;til. Pero son la soluci&amp;oacute;n port&amp;aacute;til m&amp;aacute;s conveniente).</target>
        </trans-unit>
        <trans-unit id="5eea08821de446b9d5a28f7b7ec97da98d199f9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bar.cpp&lt;/strong&gt; doesn't even need to exist when I compile &lt;strong&gt;foo.cpp&lt;/strong&gt;, but I should still be able to link the &lt;strong&gt;foo.o&lt;/strong&gt; I already had together with the &lt;strong&gt;bar.o&lt;/strong&gt; I've only just produced, without needing to recompile &lt;strong&gt;foo.cpp&lt;/strong&gt;. &lt;strong&gt;foo.cpp&lt;/strong&gt; could even be compiled into a dynamic library, distributed somewhere else without &lt;strong&gt;foo.cpp&lt;/strong&gt;, and linked with code they write years after I wrote &lt;strong&gt;foo.cpp&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;bar.cpp&lt;/strong&gt; ni siquiera necesita existir cuando compilo &lt;strong&gt;foo.cpp&lt;/strong&gt; , pero a&amp;uacute;n as&amp;iacute; deber&amp;iacute;a poder vincular el &lt;strong&gt;foo.o&lt;/strong&gt; Ya lo ten&amp;iacute;a junto con el &lt;strong&gt;bar.o&lt;/strong&gt; Acabo de producir, sin necesidad de recompilar &lt;strong&gt;foo .cpp&lt;/strong&gt; . &lt;strong&gt;foo.cpp&lt;/strong&gt; incluso podr&amp;iacute;a compilarse en una biblioteca din&amp;aacute;mica, distribuirse en otro lugar sin &lt;strong&gt;foo.cpp&lt;/strong&gt; y vincularse con el c&amp;oacute;digo que escriben a&amp;ntilde;os despu&amp;eacute;s de que escrib&amp;iacute; &lt;strong&gt;foo.cpp&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2fc371f446c0acfde57bd7659ead23b9112f8278" translate="yes" xml:space="preserve">
          <source>A common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.</source>
          <target state="translated">Una solución común a esto es escribir la declaración de la plantilla en un archivo de encabezamiento,luego implementar la clase en un archivo de implementación (por ejemplo .tpp),e incluir este archivo de implementación al final del encabezamiento.</target>
        </trans-unit>
        <trans-unit id="e57d0314403f00ceaaaa8428eba3e1aef96c93ae" translate="yes" xml:space="preserve">
          <source>A schematic example:</source>
          <target state="translated">Un ejemplo esquemático:</target>
        </trans-unit>
        <trans-unit id="196609edf5fcabd3de77dfd3d5b00786d86be944" translate="yes" xml:space="preserve">
          <source>A way to have separate implementation is as follows.</source>
          <target state="translated">Una forma de tener una aplicación separada es la siguiente.</target>
        </trans-unit>
        <trans-unit id="be5dd547c840410475dd23e56ea45e18c434e2ab" translate="yes" xml:space="preserve">
          <source>Actually, prior to C++11 the standard defined the &lt;code&gt;export&lt;/code&gt; keyword that &lt;em&gt;would&lt;/em&gt; make it possible to declare templates in a header file and implement them elsewhere.</source>
          <target state="translated">En realidad, antes de C ++ 11, el est&amp;aacute;ndar defin&amp;iacute;a la palabra clave de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n que &lt;em&gt;permitir&amp;iacute;a&lt;/em&gt; declarar plantillas en un archivo de encabezado e implementarlas en otro lugar.</target>
        </trans-unit>
        <trans-unit id="3268f427c74032de655fa4e01528f44190c37aec" translate="yes" xml:space="preserve">
          <source>Alternative solution</source>
          <target state="translated">Solución alternativa</target>
        </trans-unit>
        <trans-unit id="443f50703b7217e59b314d8938c59b61b0d3db20" translate="yes" xml:space="preserve">
          <source>Although standard C++ has no such requirement, some compilers require that all function and class templates need to be made available in every translation unit they are used. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won't allow them to be defined in non-header files such as .cpp files</source>
          <target state="translated">Aunque el estándar C++no tiene ese requisito,algunos compiladores exigen que todas las plantillas de funciones y clases estén disponibles en cada unidad de traducción que se utilice.En efecto,para esos compiladores,los cuerpos de las funciones de las plantillas deben estar disponibles en un archivo de cabecera.Repito:eso significa que esos compiladores no permitirán que se definan en archivos que no sean de cabecera,como los archivos .cpp</target>
        </trans-unit>
        <trans-unit id="06fa10dc30994a0c1e4738b1af8fe281fe0f2079" translate="yes" xml:space="preserve">
          <source>And in the Utility.cpp:</source>
          <target state="translated">Y en el Utility.cpp:</target>
        </trans-unit>
        <trans-unit id="cdab4bd0267850a1f73e501206add84b1278204d" translate="yes" xml:space="preserve">
          <source>Another reason that it's a good idea to write both declarations and definitions in header files is for readability. Suppose there's such a template function in Utility.h:</source>
          <target state="translated">Otra razón por la que es una buena idea escribir tanto declaraciones como definiciones en los archivos de encabezamiento es por la legibilidad.Supongamos que existe una función de plantilla de este tipo en Utility.h:</target>
        </trans-unit>
        <trans-unit id="295b12e50623177c4327236e29b6ef8235275a3a" translate="yes" xml:space="preserve">
          <source>Another solution is to keep the implementation separated, and explicitly instantiate all the template instances you'll need:</source>
          <target state="translated">Otra solución es mantener la implementación separada,e instanciar explícitamente todas las instancias de plantillas que se necesiten:</target>
        </trans-unit>
        <trans-unit id="c3fdc10777f128f761e03c874819811a55f60399" translate="yes" xml:space="preserve">
          <source>Anyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:</source>
          <target state="translated">De todos modos,la razón por la que tu código está fallando es que,al instanciar una plantilla,el compilador crea una nueva clase con el argumento de la plantilla dada.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e4384f393f9a314fc52cf6be36242df62df17b5e" translate="yes" xml:space="preserve">
          <source>As a result, the ISO C++ standard committee decided to remove the &lt;code&gt;export&lt;/code&gt; feature of templates with C++11.</source>
          <target state="translated">Como resultado, el comit&amp;eacute; est&amp;aacute;ndar ISO C ++ decidi&amp;oacute; eliminar la funci&amp;oacute;n de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n de plantillas con C ++ 11.</target>
        </trans-unit>
        <trans-unit id="cc12f0b11ceb91fcc52e35983342499dacc9520a" translate="yes" xml:space="preserve">
          <source>Caveat: It is &lt;em&gt;not&lt;/em&gt; necessary to put the implementation in the header file, see the alternative solution at the end of this answer.</source>
          <target state="translated">Advertencia: &lt;em&gt;no&lt;/em&gt; es necesario poner la implementaci&amp;oacute;n en el archivo de encabezado; consulte la soluci&amp;oacute;n alternativa al final de esta respuesta.</target>
        </trans-unit>
        <trans-unit id="714c7edcf9a6dfde043d41d403275de85af64e20" translate="yes" xml:space="preserve">
          <source>Consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case &lt;code&gt;int&lt;/code&gt;). If these implementations were not in the header, they wouldn't be accessible, and therefore the compiler wouldn't be able to instantiate the template.</source>
          <target state="translated">En consecuencia, el compilador necesita tener acceso a la implementaci&amp;oacute;n de los m&amp;eacute;todos, para instanciarlos con el argumento de la plantilla (en este caso &lt;code&gt;int&lt;/code&gt; ). Si estas implementaciones no estuvieran en el encabezado, no ser&amp;iacute;an accesibles y, por lo tanto, el compilador no podr&amp;iacute;a crear una instancia de la plantilla.</target>
        </trans-unit>
        <trans-unit id="66705bb389b50ec573981426b267ee96ef11ce15" translate="yes" xml:space="preserve">
          <source>Don't forget to have your compiler treat your .template file as a c++ file to keep the intelli sense.</source>
          <target state="translated">No olvides que tu compilador trate tu archivo .template como un archivo c++para mantener el sentido de la inteligencia.</target>
        </trans-unit>
        <trans-unit id="80ff8bad077219e5eb6d2824ef614f47f5e13f01" translate="yes" xml:space="preserve">
          <source>Each user of the template includes that header file and uses the typedef.</source>
          <target state="translated">Cada usuario de la plantilla incluye ese archivo de encabezamiento y utiliza el tipedef.</target>
        </trans-unit>
        <trans-unit id="cc94c8862d7b92a03b6b8a599fe014178a50d393" translate="yes" xml:space="preserve">
          <source>Edit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.</source>
          <target state="translated">Editar:Añadir ejemplo de instanciación de plantilla explícita.Se utiliza después de que se haya definido la plantilla y se hayan definido todas las funciones de los miembros.</target>
        </trans-unit>
        <trans-unit id="f95b23255b3aa50ef9fc041109ba878b6c2aa2b1" translate="yes" xml:space="preserve">
          <source>Even though there are plenty of good explanations above, I'm missing a practical way to separate templates into header and body.</source>
          <target state="translated">Aunque hay muchas buenas explicaciones arriba,me falta una forma práctica de separar las plantillas en la cabecera y el cuerpo.</target>
        </trans-unit>
        <trans-unit id="6cc307ede2a377f65c8c1c69348f06afd6a2e8c7" translate="yes" xml:space="preserve">
          <source>Foo.cpp</source>
          <target state="translated">Foo.cpp</target>
        </trans-unit>
        <trans-unit id="908239a07d276301afb988b50e7f6bb2d18d784d" translate="yes" xml:space="preserve">
          <source>Foo.h</source>
          <target state="translated">Foo.h</target>
        </trans-unit>
        <trans-unit id="4a7d5666a48d825ce85c0580fe4cc84bc378d8f3" translate="yes" xml:space="preserve">
          <source>Foo.tpp</source>
          <target state="translated">Foo.tpp</target>
        </trans-unit>
        <trans-unit id="82a77bbbd6668cf9c08fdbe5e3587d003efcd33a" translate="yes" xml:space="preserve">
          <source>For each template usage there's a typedef in its own header file (generated from the UML model). Its body contains the instantiation (which ends up in a library which is linked in at the end).</source>
          <target state="translated">Para cada uso de la plantilla hay un tipedef en su propio archivo de cabecera (generado a partir del modelo UML).Su cuerpo contiene la instanciación (que termina en una biblioteca que está enlazada al final).</target>
        </trans-unit>
        <trans-unit id="5b5fed325d16bdec5cc8b43d0474e826e2cf9b46" translate="yes" xml:space="preserve">
          <source>For separate compilation to be achieved, separate template body checking must be possible. It seems that a solution is possible with concepts. Take a look at this &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3629.pdf&quot;&gt;paper&lt;/a&gt; recently presented at the 
standards commitee meeting. I think this is not the only requirement, since you still need to instantiate code for the template code in user code.</source>
          <target state="translated">Para lograr una compilaci&amp;oacute;n por separado, debe ser posible la verificaci&amp;oacute;n del cuerpo de la plantilla por separado. Parece que una soluci&amp;oacute;n es posible con conceptos. Eche un vistazo a este &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3629.pdf&quot;&gt;documento&lt;/a&gt; presentado recientemente en la reuni&amp;oacute;n del comit&amp;eacute; de normas. Creo que este no es el &amp;uacute;nico requisito, ya que a&amp;uacute;n necesita crear instancias de c&amp;oacute;digo para el c&amp;oacute;digo de plantilla en el c&amp;oacute;digo de usuario.</target>
        </trans-unit>
        <trans-unit id="64df38475feba828e0989613927f71a856e989b4" translate="yes" xml:space="preserve">
          <source>Have to recompile &lt;strong&gt;foo.cpp&lt;/strong&gt; every time we change &lt;em&gt;any other file in the program&lt;/em&gt;, in case it added a new novel instantiation of &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Debe volver&lt;/strong&gt; a compilar &lt;strong&gt;foo.cpp&lt;/strong&gt; cada vez que cambiemos &lt;em&gt;cualquier otro archivo en el programa&lt;/em&gt; , en caso de que agregue una nueva instancia de &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9125e5f2cc07fe769d4b37e603b64292d0aba7b" translate="yes" xml:space="preserve">
          <source>Having all template instantiations in the template body is not a viable solution for me, since the template author may not know all if its usage and the template user may not have the right to modify it.</source>
          <target state="translated">Tener todas las instancias de la plantilla en el cuerpo de la plantilla no es una solución viable para mí,ya que el autor de la plantilla puede no saberlo todo si su uso y el usuario de la plantilla puede no tener derecho a modificarla.</target>
        </trans-unit>
        <trans-unit id="2fc1605804c6bc9c61485c59f3cb5aed20c0e151" translate="yes" xml:space="preserve">
          <source>Here is an example of this for a dynamic array class.</source>
          <target state="translated">Aquí hay un ejemplo de esto para una clase de arreglo dinámico.</target>
        </trans-unit>
        <trans-unit id="facd6b7aac26f9ee87b6abf6cea13139dac87079" translate="yes" xml:space="preserve">
          <source>However since templates need to be processed in the compilation step in order to generate code for each template instantiation that you define, so simply compiling a template separate from it's header file won't work because they always go hand and hand, for the very reason that each template instantiation is a whole new class literally. In a regular class you can separate .h and .cpp because .h is a blueprint of that class and the .cpp is the raw implementation so any implementation files can be compiled and linked regularly, however using templates .h is a blueprint of how the class should look not how the object should look meaning a template .cpp file isn't a raw regular implementation of a class, it's simply a blueprint for a class, so any implementation of a .h template file can't be compiled because you need something concrete to compile, templates are abstract in that sense.</source>
          <target state="translated">Sin embargo,como las plantillas necesitan ser procesadas en el paso de compilación para generar código para cada instanciación de plantilla que definas,así que simplemente compilar una plantilla separada de su archivo de cabecera no funcionará porque siempre van de la mano,por la misma razón que cada instanciación de plantilla es una clase completamente nueva literalmente.En una clase normal se pueden separar los archivos .h y .cpp porque el .h es un plano de esa clase y el .cpp es la implementación en bruto,por lo que cualquier archivo de implementación puede ser compilado y enlazado regularmente,sin embargo,el uso de plantillas .h es un plano de cómo debe ser la clase y no de cómo debe ser el objeto,lo que significa que un archivo de plantilla .cpp no es una implementación regular en bruto de una clase,es simplemente un plano de una clase,por lo que cualquier implementación de un archivo de plantilla .h no puede ser compilada porque se necesita algo concreto para compilar,las plantillas son abstractas en ese sentido.</target>
        </trans-unit>
        <trans-unit id="87f174db2809957fd6b6e355c08819c42e926f22" translate="yes" xml:space="preserve">
          <source>I do this because static analyzers for the code break when it does not see the forward declarations of class in *.tpp. This is annoying when writing code in any IDE or using YouCompleteMe or others.</source>
          <target state="translated">Hago esto porque los analizadores estáticos para la ruptura de código cuando no ve las declaraciones de clase en *.tpp.Esto es molesto cuando se escribe código en cualquier IDE o se utiliza YouCompleteMe u otros.</target>
        </trans-unit>
        <trans-unit id="a00573411f305b4648ab694f0a3f5eb5f85894a3" translate="yes" xml:space="preserve">
          <source>I suggest looking at this gcc page which discusses the tradeoffs between the &quot;cfront&quot; and &quot;borland&quot; model for template instantiations.</source>
          <target state="translated">Sugiero que mire esta página de GCC que discute los intercambios entre el modelo &quot;cfront&quot; y &quot;borland&quot; para las instancias de la plantilla.</target>
        </trans-unit>
        <trans-unit id="fd41fb7a1caa2b78e5d1a3e75ebe40ef63a19fc5" translate="yes" xml:space="preserve">
          <source>I took the following approach, which works also for older compilers (gcc 4.3.4, aCC A.03.13).</source>
          <target state="translated">Tomé el siguiente enfoque,que funciona también para los compiladores más antiguos (gcc 4.3.4,aCC A.03.13).</target>
        </trans-unit>
        <trans-unit id="3333e71f7edcca169894e1df3c21ed777965c2b5" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;foo.cpp&lt;/strong&gt; itself uses &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt;, then code for that will be generated while compiling &lt;strong&gt;foo.cpp&lt;/strong&gt;, so when &lt;strong&gt;bar.o&lt;/strong&gt; is linked to &lt;strong&gt;foo.o&lt;/strong&gt; they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there's no way for &lt;strong&gt;bar.cpp&lt;/strong&gt; to use the template &lt;em&gt;as a template&lt;/em&gt; and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of &lt;strong&gt;foo.cpp&lt;/strong&gt; thought to provide.</source>
          <target state="translated">Si &lt;strong&gt;foo.cpp&lt;/strong&gt; usa &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt; , entonces el c&amp;oacute;digo para eso se generar&amp;aacute; al compilar &lt;strong&gt;foo.cpp&lt;/strong&gt; , de modo que cuando &lt;strong&gt;bar.o&lt;/strong&gt; est&amp;eacute; vinculado a &lt;strong&gt;foo.o&lt;/strong&gt; se puedan conectar y funcionar&amp;aacute;n. Podemos usar ese hecho para permitir que se implemente un conjunto finito de instancias de plantilla en un archivo .cpp escribiendo una sola plantilla. Pero no hay forma de que &lt;strong&gt;bar.cpp&lt;/strong&gt; use la plantilla &lt;em&gt;como plantilla&lt;/em&gt; y la instancia en los tipos que le gusten; solo puede usar versiones preexistentes de la clase con plantilla que el autor de &lt;strong&gt;foo.cpp&lt;/strong&gt; pens&amp;oacute; proporcionar.</target>
        </trans-unit>
        <trans-unit id="011a72a7f3dc5627b578590bd02a88adde7b305a" translate="yes" xml:space="preserve">
          <source>If I was really worried about speed, I suppose I would explore using Precompiled Headers 
&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html&quot;&gt;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html&lt;/a&gt;</source>
          <target state="translated">Si realmente me preocupara la velocidad, supongo que explorar&amp;iacute;a el uso de encabezados precompilados &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html&quot;&gt;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b87ff4c31fa3b95028236c600a2a6c3ac3da1e5" translate="yes" xml:space="preserve">
          <source>If my explanation isn't clear enough, you can have a look at the &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl&quot;&gt;C++ Super-FAQ on this subject&lt;/a&gt;.</source>
          <target state="translated">Si mi explicaci&amp;oacute;n no es lo suficientemente clara, puede echar un vistazo a las &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl&quot;&gt;preguntas frecuentes de C ++ Super sobre este tema&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bf8cdd8be4fa175a80b68f8957e30eb7bb988c2" translate="yes" xml:space="preserve">
          <source>If the concern is the extra compilation time and binary size bloat produced by compiling the .h as part of all the .cpp modules using it, in many cases what you can do is make the template class descend from a non-templatized base class for non type-dependent parts of the interface, and that base class can have its implementation in the .cpp file.</source>
          <target state="translated">Si lo que preocupa es el tiempo extra de compilación y la hinchazón de tamaño binario que se produce al compilar el .h como parte de todos los módulos .cpp que lo utilizan,en muchos casos lo que se puede hacer es hacer que la clase de plantilla descienda de una clase base no templada para las partes no dependientes del tipo de la interfaz,y esa clase base puede tener su implementación en el archivo .cpp.</target>
        </trans-unit>
        <trans-unit id="b9aeaa7ae46fee59a9175d2ea5a67ecb336c12cb" translate="yes" xml:space="preserve">
          <source>If you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.</source>
          <target state="translated">Si usted,en la parte inferior del archivo cpp de implementación,hace una instanciación explícita de todos los tipos con los que se utilizará la plantilla,el enlazador podrá encontrarlos como de costumbre.</target>
        </trans-unit>
        <trans-unit id="17b3a73d1735316997e49303704cf1f9e4bcf528" translate="yes" xml:space="preserve">
          <source>In my experience, I rely on the C++ Standard Library and Boost templates being instantiated for each compilation unit (using a template library).  For my large template classes, I do manual template instantiation, once, for the types I need.</source>
          <target state="translated">En mi experiencia,confío en que las plantillas de la Biblioteca Estándar de C++y de Boost sean instanciadas para cada unidad de compilación (usando una biblioteca de plantillas).Para mis clases de plantillas grandes,hago la instanciación manual de plantillas,una vez,para los tipos que necesito.</target>
        </trans-unit>
        <trans-unit id="8c31ab53c2aa0f343fe425ec5ac5df36ee59ff73" translate="yes" xml:space="preserve">
          <source>It contains explicit recommendations concerning using manual and automatic template instantiation.  For example, the &quot;-repo&quot; option can be used to collect templates which need to be instantiated.  Or another option is to disable automatic template instantiations using &quot;-fno-implicit-templates&quot; to force manual template instantiation.</source>
          <target state="translated">Contiene recomendaciones explícitas sobre el uso de la instanciación manual y automática de plantillas.Por ejemplo,la opción &quot;-repo&quot; puede utilizarse para recoger las plantillas que deben ser instanciadas.Otra opción es desactivar la instanciación automática de plantillas usando &quot;-fno-implicit-templates&quot; para forzar la instanciación manual de plantillas.</target>
        </trans-unit>
        <trans-unit id="d7fcfe322279aaaf6ecb382779c5e98a8fbcbd54" translate="yes" xml:space="preserve">
          <source>It is technically possible to create some sort of functionality that will save the template.cpp file and switch out the types when it finds them in other sources, I think that the standard does have a keyword &lt;code&gt;export&lt;/code&gt; that will allow you to put templates in a separate cpp file but not that many compilers actually implement this.</source>
          <target state="translated">Es t&amp;eacute;cnicamente posible crear alg&amp;uacute;n tipo de funcionalidad que guardar&amp;aacute; el archivo template.cpp y cambiar&amp;aacute; los tipos cuando los encuentre en otras fuentes, creo que el est&amp;aacute;ndar tiene una &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n de palabras clave que le permitir&amp;aacute; colocar plantillas en un archivo cpp separado pero no muchos compiladores realmente implementan esto.</target>
        </trans-unit>
        <trans-unit id="c4587d4599976fa42e1045afc20e1c648a79bff6" translate="yes" xml:space="preserve">
          <source>It means that the most portable way to define method implementations of template classes is to define them inside the template class definition.</source>
          <target state="translated">Significa que la forma más portátil de definir implementaciones de métodos de clases de plantillas es definirlas dentro de la definición de la clase de plantillas.</target>
        </trans-unit>
        <trans-unit id="465d68aca886e2ba0f6bc7c8e105292f938fcb0d" translate="yes" xml:space="preserve">
          <source>It's because of the requirement for separate compilation and because templates are instantiation-style polymorphism.</source>
          <target state="translated">Es por el requisito de la compilación por separado y porque las plantillas son un polimorfismo de tipo instanciación.</target>
        </trans-unit>
        <trans-unit id="25dec0fc6c89b691f8f9a3e994c3ef5b0abc0fe8" translate="yes" xml:space="preserve">
          <source>Just a side note, when making specializations for a template class, you can separate the header from the implementation because a specialization by definition means that I am specializing for a concrete type that can be compiled and linked individually.</source>
          <target state="translated">Sólo una nota al margen,cuando se hacen especializaciones para una clase de plantilla,se puede separar el encabezamiento de la implementación porque una especialización por definición significa que me estoy especializando para un tipo concreto que puede ser compilado y vinculado individualmente.</target>
        </trans-unit>
        <trans-unit id="90c0f03268a72533d3715fb1c3f04f17010fd4e8" translate="yes" xml:space="preserve">
          <source>Just to add something noteworthy here. One can define methods of a templated class just fine in the implementation file when they are not function templates.</source>
          <target state="translated">Sólo para añadir algo digno de mención aquí.Uno puede definir los métodos de una clase planificada muy bien en el archivo de implementación cuando no son plantillas de funciones.</target>
        </trans-unit>
        <trans-unit id="888d48c5f6045b8a8e83ebd7c050f1a0853a2ae6" translate="yes" xml:space="preserve">
          <source>Lets get a little closer to concrete for an explanation. Say I've got the following files:</source>
          <target state="translated">Acerquémonos un poco más al concreto para una explicación.Digamos que tengo los siguientes archivos:</target>
        </trans-unit>
        <trans-unit id="874b2d856f83dc17aed9827ccbaf2c655bd10aef" translate="yes" xml:space="preserve">
          <source>Meaning &lt;code&gt;typename T&lt;/code&gt; get's replaced during the compilation step not the linking step so if I try to compile a template without &lt;code&gt;T&lt;/code&gt; being replaced as a concrete value type that is completely meaningless to the compiler and as a result object code can't be created because it doesn't know what &lt;code&gt;T&lt;/code&gt; is.</source>
          <target state="translated">Lo que significa que el &lt;code&gt;typename T&lt;/code&gt; se reemplaza durante el paso de compilaci&amp;oacute;n, no el paso de vinculaci&amp;oacute;n, por lo que si intento compilar una plantilla sin que &lt;code&gt;T&lt;/code&gt; sea ​​reemplazado como un tipo de valor concreto que no tiene ning&amp;uacute;n significado para el compilador y, como resultado, el c&amp;oacute;digo objeto no se puede crear porque No sabe qu&amp;eacute; es &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc9acfdc804197b314d8a24ba75469bacf7cd44" translate="yes" xml:space="preserve">
          <source>My main concern is avoiding recompilation of all template users, when I change its definition.</source>
          <target state="translated">Mi principal preocupación es evitar la recompilación de todos los usuarios de la plantilla,cuando cambio su definición.</target>
        </trans-unit>
        <trans-unit id="19e735f0ba4f7fedbf86a4d8db05ec2168dae756" translate="yes" xml:space="preserve">
          <source>MyInstantiatedTemplate.cpp:</source>
          <target state="translated">MyInstantiatedTemplate.cpp:</target>
        </trans-unit>
        <trans-unit id="fa356b6c6efa2ea6ff88305f59851d0e6a2e480e" translate="yes" xml:space="preserve">
          <source>MyInstantiatedTemplate.h:</source>
          <target state="translated">MyInstantiatedTemplate.h:</target>
        </trans-unit>
        <trans-unit id="8e34d8a24c57d38d429bde7fc7eceb8c00a41285" translate="yes" xml:space="preserve">
          <source>MyTemplate.cpp:</source>
          <target state="translated">MyTemplate.cpp:</target>
        </trans-unit>
        <trans-unit id="9dd5eb3e28a84b69814aa5d8085079ec0abf9aae" translate="yes" xml:space="preserve">
          <source>MyTemplate.h:</source>
          <target state="translated">MyTemplate.h:</target>
        </trans-unit>
        <trans-unit id="779855889bb02228386e15de72062da5af7cdbf1" translate="yes" xml:space="preserve">
          <source>Nobody likes (1), because whole-program-analysis compilation systems take &lt;em&gt;forever&lt;/em&gt; to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.</source>
          <target state="translated">A nadie le gusta (1), porque los sistemas de compilaci&amp;oacute;n de an&amp;aacute;lisis de todo el programa tardan una &lt;em&gt;eternidad&lt;/em&gt; en compilarse, y porque hace que sea imposible distribuir bibliotecas compiladas sin el c&amp;oacute;digo fuente. Entonces tenemos (2) en su lugar.</target>
        </trans-unit>
        <trans-unit id="8600908363c5763340849b73a07750b2fc8781dc" translate="yes" xml:space="preserve">
          <source>None of the popular compilers implemented this keyword. The only one I know about is the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already).</source>
          <target state="translated">Ninguno de los compiladores populares implementó esta palabra clave.El único que conozco es el frontend escrito por el Edison Design Group,que es usado por el compilador Comeau C++.Todos los demás requerían que se escribieran plantillas en los archivos de cabecera,porque el compilador necesita la definición de la plantilla para la correcta instanciación (como ya han señalado otros).</target>
        </trans-unit>
        <trans-unit id="d369389a12d35315051d668fcdde49164cea6c93" translate="yes" xml:space="preserve">
          <source>Now inside you .template file you define your functions just how you normally would.</source>
          <target state="translated">Ahora dentro de tu archivo .template defines tus funciones como lo harías normalmente.</target>
        </trans-unit>
        <trans-unit id="a4d3b6b3a919caaa1d049a3a1514e4b1e2c7dae8" translate="yes" xml:space="preserve">
          <source>On compile time, contents of foo.h are copied to foo.tpp and then the whole file is copied to foo.h after which it compiles. This way, there is no limitations, and the naming is consistent, in exchange for one extra file.</source>
          <target state="translated">En tiempo de compilación,el contenido de foo.h se copia a foo.tpp y luego todo el archivo se copia a foo.h después de lo cual se compila.De esta manera,no hay limitaciones,y la denominación es consistente,a cambio de un archivo extra.</target>
        </trans-unit>
        <trans-unit id="17bbed3b3378d62cae5186ee6b302a66b4c7e881" translate="yes" xml:space="preserve">
          <source>One can argue that compilers can be made smarter to &quot;look ahead&quot; for all uses of the template, but I'm sure that it wouldn't be difficult to create recursive or otherwise complicated scenarios. AFAIK, compilers don't do such look aheads.  As Anton pointed out, some compilers support explicit export declarations of template instantiations, but not all compilers support it (yet?).</source>
          <target state="translated">Se puede argumentar que se puede hacer que los compiladores sean más inteligentes para &quot;mirar hacia adelante&quot; para todos los usos de la plantilla,pero estoy seguro de que no sería difícil crear escenarios recursivos o de otro modo complicados.AFAIK,los compiladores no hacen tales miradas hacia adelante.Como señaló Anton,algunos compiladores apoyan las declaraciones explícitas de exportación de las instancias de la plantilla,pero no todos los compiladores lo apoyan (¿todavía?).</target>
        </trans-unit>
        <trans-unit id="027b97136fa29f83fd726f6a8f31ab5c63fb0ccc" translate="yes" xml:space="preserve">
          <source>Plenty correct answers here, but I wanted to add this (for completeness):</source>
          <target state="translated">Hay muchas respuestas correctas aquí,pero quería añadir esto (para completar):</target>
        </trans-unit>
        <trans-unit id="1e3ccd72561a2cf529bc2692dc40f14a6b2e4173" translate="yes" xml:space="preserve">
          <source>Quote from &lt;a href=&quot;http://books.google.com/books?id=n9VEG2Gp5pkC&amp;amp;pg=PA10&amp;amp;lpg=PA10&amp;amp;dq=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;amp;source=bl&amp;amp;ots=Ref8pl8dPX&amp;amp;sig=t4K5gvxtBblpcujNxodpwMfei8I&amp;amp;hl=en&amp;amp;ei=qkR6TvbiGojE0AHq4IzqAg&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;ct=result&amp;amp;resnum=3&amp;amp;ved=0CC8Q6AEwAg#v=onepage&amp;amp;q=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;amp;f=false&quot;&gt;The C++ standard library: a tutorial and handbook&lt;/a&gt;:</source>
          <target state="translated">Cita de &lt;a href=&quot;http://books.google.com/books?id=n9VEG2Gp5pkC&amp;amp;pg=PA10&amp;amp;lpg=PA10&amp;amp;dq=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;amp;source=bl&amp;amp;ots=Ref8pl8dPX&amp;amp;sig=t4K5gvxtBblpcujNxodpwMfei8I&amp;amp;hl=en&amp;amp;ei=qkR6TvbiGojE0AHq4IzqAg&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;ct=result&amp;amp;resnum=3&amp;amp;ved=0CC8Q6AEwAg#v=onepage&amp;amp;q=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;amp;f=false&quot;&gt;la biblioteca est&amp;aacute;ndar de C ++: un tutorial y un manual&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f41f7caecccc6ad203c01fef0e084e8b1d92a5ec" translate="yes" xml:space="preserve">
          <source>Require that &lt;strong&gt;baz.cpp&lt;/strong&gt; contains (possibly via header includes) the full template of &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt;, so that the compiler can generate &lt;code&gt;MyClass&amp;lt;BazPrivate&amp;gt;&lt;/code&gt; during compilation of &lt;strong&gt;baz.cpp&lt;/strong&gt;.</source>
          <target state="translated">Requerir que &lt;strong&gt;baz.cpp&lt;/strong&gt; contenga (posiblemente mediante el encabezado incluye) la plantilla completa de &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt; , para que el compilador pueda generar &lt;code&gt;MyClass&amp;lt;BazPrivate&amp;gt;&lt;/code&gt; durante la compilaci&amp;oacute;n de &lt;strong&gt;baz.cpp&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="60a978398e64164bca212555aaa064c2a8b0b5ed" translate="yes" xml:space="preserve">
          <source>Separate compilation means I should be able to compile &lt;strong&gt;foo.cpp&lt;/strong&gt; independently from &lt;strong&gt;bar.cpp&lt;/strong&gt;. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don't need to do whole-program analysis. It's only the linker that needs to handle the entire program at once, and the linker's job is substantially easier.</source>
          <target state="translated">La compilaci&amp;oacute;n separada significa que deber&amp;iacute;a poder compilar &lt;strong&gt;foo.cpp&lt;/strong&gt; independientemente de &lt;strong&gt;bar.cpp&lt;/strong&gt; . El compilador realiza todo el trabajo duro de an&amp;aacute;lisis, optimizaci&amp;oacute;n y generaci&amp;oacute;n de c&amp;oacute;digo en cada unidad de compilaci&amp;oacute;n de forma completamente independiente; No necesitamos hacer un an&amp;aacute;lisis completo del programa. Es solo el enlazador que necesita manejar todo el programa a la vez, y el trabajo del enlazador es sustancialmente m&amp;aacute;s f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="cf96ef776af92be9a3da407eefb0092aa784a378" translate="yes" xml:space="preserve">
          <source>So when &lt;strong&gt;foo.cpp&lt;/strong&gt; is compiled, the compiler can't see &lt;strong&gt;bar.cpp&lt;/strong&gt; to know that &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt; is needed. It can see the template &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt;, but it can't emit code for that (it's a template, not a class). And when &lt;strong&gt;bar.cpp&lt;/strong&gt; is compiled, the compiler can see that it needs to create a &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt;, but it can't see the template &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt; (only its interface in &lt;strong&gt;foo.h&lt;/strong&gt;) so it can't create it.</source>
          <target state="translated">Entonces, cuando se compila &lt;strong&gt;foo.cpp&lt;/strong&gt; , el compilador no puede ver &lt;strong&gt;bar.cpp&lt;/strong&gt; para saber que se necesita &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt; . Puede ver la plantilla &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt; , pero no puede emitir c&amp;oacute;digo para eso (es una plantilla, no una clase). Y cuando se compila &lt;strong&gt;bar.cpp&lt;/strong&gt; , el compilador puede ver que necesita crear &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt; , pero no puede ver la plantilla &lt;code&gt;MyClass&amp;lt;T&amp;gt;&lt;/code&gt; (solo su interfaz en &lt;strong&gt;foo.h&lt;/strong&gt; ), por lo que no puede crear eso.</target>
        </trans-unit>
        <trans-unit id="e7892a8d20de035b9b6701d9b3ebc8381493ee59" translate="yes" xml:space="preserve">
          <source>Templates must be used in headers because the compiler needs to instantiate different versions of the code, depending on the parameters given/deduced for template parameters. Remember that a template doesn't represent code directly, but a template for several versions of that code. 
When you compile a non-template function in a &lt;code&gt;.cpp&lt;/code&gt; file, you are compiling a concrete function/class. This is not the case for templates, which can be instantiated with different types, namely, concrete code must be emitted when replacing template parameters with concrete types.</source>
          <target state="translated">Las plantillas deben usarse en los encabezados porque el compilador necesita crear instancias de diferentes versiones del c&amp;oacute;digo, dependiendo de los par&amp;aacute;metros dados / deducidos para los par&amp;aacute;metros de la plantilla. Recuerde que una plantilla no representa el c&amp;oacute;digo directamente, sino una plantilla para varias versiones de ese c&amp;oacute;digo. Cuando compila una funci&amp;oacute;n que no es de plantilla en un archivo &lt;code&gt;.cpp&lt;/code&gt; , est&amp;aacute; compilando una funci&amp;oacute;n / clase concreta. Este no es el caso de las plantillas, que se pueden instanciar con diferentes tipos, a saber, se debe emitir un c&amp;oacute;digo concreto al reemplazar los par&amp;aacute;metros de la plantilla con tipos concretos.</target>
        </trans-unit>
        <trans-unit id="07055fec01ec5ac6275859a7a311bf06f2c99470" translate="yes" xml:space="preserve">
          <source>Templates need to be &lt;em&gt;instantiated&lt;/em&gt; by the compiler before actually compiling them into object code.  This instantiation can only be achieved if the template arguments are known. Now imagine a scenario where a template function is declared in &lt;code&gt;a.h&lt;/code&gt;, defined in &lt;code&gt;a.cpp&lt;/code&gt; and used in &lt;code&gt;b.cpp&lt;/code&gt;. When &lt;code&gt;a.cpp&lt;/code&gt; is compiled, it is not necessarily known that the upcoming compilation &lt;code&gt;b.cpp&lt;/code&gt; will require an instance of the template, let alone which specific instance would that be. For more header and source files, the situation can quickly get more complicated.</source>
          <target state="translated">El compilador debe &lt;em&gt;crear instancias&lt;/em&gt; de las plantillas antes de compilarlas en el c&amp;oacute;digo objeto. Esta instanciaci&amp;oacute;n solo se puede lograr si se conocen los argumentos de la plantilla. Ahora imagine un escenario donde una funci&amp;oacute;n de plantilla se declara en &lt;code&gt;a.h&lt;/code&gt; , se define en &lt;code&gt;a.cpp&lt;/code&gt; y se usa en &lt;code&gt;b.cpp&lt;/code&gt; . Cuando se compila &lt;code&gt;a.cpp&lt;/code&gt; , no se sabe necesariamente que la pr&amp;oacute;xima compilaci&amp;oacute;n &lt;code&gt;b.cpp&lt;/code&gt; requerir&amp;aacute; una instancia de la plantilla, y mucho menos qu&amp;eacute; instancia espec&amp;iacute;fica ser&amp;iacute;a esa. Para m&amp;aacute;s archivos de cabecera y fuente, la situaci&amp;oacute;n puede volverse m&amp;aacute;s complicada r&amp;aacute;pidamente.</target>
        </trans-unit>
        <trans-unit id="573267f5fdff7a38869f846560058a7991782d2f" translate="yes" xml:space="preserve">
          <source>That is exactly correct because the compiler has to know what type it is for allocation. So template classes, functions, enums,etc.. must be implemented as well in the header file if it is to be made public or part of a library (static or dynamic) because header files are NOT compiled unlike the c/cpp files which are. If the compiler doesn't know the type is can't compile it. In .Net it can because all objects derive from the Object class. This is not .Net.</source>
          <target state="translated">Eso es exactamente correcto porque el compilador tiene que saber de qué tipo es para la asignación.Por lo tanto,las clases de plantillas,las funciones,los enums,etc.,deben implementarse también en el archivo de cabecera si se va a hacer público o formar parte de una biblioteca (estática o dinámica)porque los archivos de cabecera NO se compilan como los archivos ccpp que sí lo hacen.Si el compilador no conoce el tipo es no puede compilarlo.En .Net puede porque todos los objetos derivan de la clase Object.Esto no es .Net.</target>
        </trans-unit>
        <trans-unit id="9e58a81b20c16d22062ebf223f9ad4f4d3b4f677" translate="yes" xml:space="preserve">
          <source>The &quot;borland&quot; model corresponds to what the author suggests, providing the full template definition, and having things compiled multiple times.</source>
          <target state="translated">El modelo &quot;borland&quot; corresponde a lo que el autor sugiere,proporcionando la definición completa de la plantilla,y teniendo las cosas compiladas varias veces.</target>
        </trans-unit>
        <trans-unit id="58e8c1052ab3a21074d7cb8bccc45c2a6626437e" translate="yes" xml:space="preserve">
          <source>The above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses &lt;code&gt;extern template class vector&amp;lt;int&amp;gt;&lt;/code&gt; so as to keep it from instantiating it in all the &lt;em&gt;other&lt;/em&gt; (1000?) files that use vector.</source>
          <target state="translated">El ejemplo anterior es bastante in&amp;uacute;til ya que el vector est&amp;aacute; completamente definido en los encabezados, excepto cuando un archivo de inclusi&amp;oacute;n com&amp;uacute;n (encabezado precompilado?) Usa el &lt;code&gt;extern template class vector&amp;lt;int&amp;gt;&lt;/code&gt; para evitar que lo instancia en todos los &lt;em&gt;otros&lt;/em&gt; archivos (1000?) que usan el vector</target>
        </trans-unit>
        <trans-unit id="751e836bc3075952f979fef87738701137f3a956" translate="yes" xml:space="preserve">
          <source>The compiler will generate code for each template instantiation when you use a template during the compilation step. 
In the compilation and linking process .cpp files are converted to pure object or machine code which in them contains references or undefined symbols because the .h files that are included in your main.cpp have no implementation YET. These are ready to be linked with another object file that defines an implementation for your template and thus you have a full a.out executable.</source>
          <target state="translated">El compilador generará código para cada instanciamiento de plantilla cuando use una plantilla durante el paso de compilación.En el proceso de compilación y enlace,los archivos .cpp se convierten en puro código de objeto o máquina que en ellos contiene referencias o símbolos indefinidos porque los archivos .h que se incluyen en su main.cpp no tienen implementación TAMBIÉN.Estos están listos para ser enlazados con otro archivo objeto que define una implementación para su plantilla y así usted tiene un ejecutable a.out completo.</target>
        </trans-unit>
        <trans-unit id="70e1a76050b751aa87f42fb2a3667367780128f9" translate="yes" xml:space="preserve">
          <source>The only portable way of using templates at the moment is to implement them in header files by using inline functions.</source>
          <target state="translated">La única forma portátil de utilizar plantillas por el momento es implementarlas en los archivos de cabecera mediante el uso de funciones en línea.</target>
        </trans-unit>
        <trans-unit id="5a0f95b8ca2d9538f3bebbd2e52eab17be41473f" translate="yes" xml:space="preserve">
          <source>The separate compilation problem for templates I guess it's also a problem that is arising with the migration to modules, which is currently being worked.</source>
          <target state="translated">El problema de la compilación separada de las plantillas supongo que también es un problema que está surgiendo con la migración a los módulos,que se está trabajando actualmente.</target>
        </trans-unit>
        <trans-unit id="c898a850ca6d8f4fa0a444f7353ad2e51c50f8b6" translate="yes" xml:space="preserve">
          <source>There is an &lt;em&gt;export&lt;/em&gt; keyword which is supposed to mitigate this problem, but it's nowhere close to being portable.</source>
          <target state="translated">Hay una palabra clave de &lt;em&gt;exportaci&amp;oacute;n&lt;/em&gt; que se supone que mitiga este problema, pero no est&amp;aacute; cerca de ser port&amp;aacute;til.</target>
        </trans-unit>
        <trans-unit id="2392d1fe804bd11c9c1e2fe664277a9cea150dc6" translate="yes" xml:space="preserve">
          <source>There is no possible way that this could work unless we either</source>
          <target state="translated">No hay forma posible de que esto pueda funcionar a menos que nosotros</target>
        </trans-unit>
        <trans-unit id="9f0f3cb27a80c18b9106602e69afe581b1d5d1ac" translate="yes" xml:space="preserve">
          <source>There was a feature with the &lt;code&gt;export&lt;/code&gt; keyword that was meant to be used for separate compilation.
The &lt;code&gt;export&lt;/code&gt; feature is deprecated in &lt;code&gt;C++11&lt;/code&gt; and, AFAIK, only one compiler implemented it. You shouldn't make use of &lt;code&gt;export&lt;/code&gt;. Separate compilation is not possible in &lt;code&gt;C++&lt;/code&gt; or &lt;code&gt;C++11&lt;/code&gt; but maybe in &lt;code&gt;C++17&lt;/code&gt;, if concepts make it in, we could have some way of separate compilation.</source>
          <target state="translated">Hab&amp;iacute;a una funci&amp;oacute;n con la palabra clave de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n que deb&amp;iacute;a usarse para una compilaci&amp;oacute;n separada. La funci&amp;oacute;n de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n est&amp;aacute; en desuso en &lt;code&gt;C++11&lt;/code&gt; y, AFAIK, solo un compilador la implement&amp;oacute;. No debe hacer uso de la &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n . La compilaci&amp;oacute;n separada no es posible en &lt;code&gt;C++&lt;/code&gt; o &lt;code&gt;C++11&lt;/code&gt; pero tal vez en &lt;code&gt;C++17&lt;/code&gt; , si los conceptos lo logran, podr&amp;iacute;amos tener alguna forma de compilaci&amp;oacute;n separada.</target>
        </trans-unit>
        <trans-unit id="ca26dec36ce34dee761b07dff18f299e91237c3d" translate="yes" xml:space="preserve">
          <source>Therefore if you separate the template declaration and definition, you won't be able to only read the header file to see the ins and outs of this template in order to use this API on your own classes, though the compiler will tell you in this case about which operator needs to be overridden.</source>
          <target state="translated">Por lo tanto,si separa la declaración y la definición de la plantilla,no podrá leer únicamente el archivo de cabecera para ver los detalles de esta plantilla con el fin de utilizar esta API en sus propias clases,aunque el compilador le dirá en este caso sobre qué operador debe ser anulado.</target>
        </trans-unit>
        <trans-unit id="a88a22ac4bcba82eae4ad56a83eb507a4312a8a0" translate="yes" xml:space="preserve">
          <source>Therefore templates are never separately compiled and are only compiled wherever you have a concrete instantiation in some other source file. However, the concrete instantiation needs to know the implementation of the template file, because simply modifying the &lt;code&gt;typename T&lt;/code&gt; using a concrete type in the .h file is not going to do the job because what .cpp is there to link, I can't find it later on because remember templates are abstract and can't be compiled, so I'm forced to give the implementation right now so I know what to compile and link, and now that I have the implementation it gets linked into the enclosing source file. Basically, the moment I instantiate a template I need to create a whole new class, and I can't do that if I don't know how that class should look like when using the type I provide unless I make notice to the compiler of the template implementation, so now the compiler can replace &lt;code&gt;T&lt;/code&gt; with my type and create a concrete class that's ready to be compiled and linked.</source>
          <target state="translated">Por lo tanto, las plantillas nunca se compilan por separado y solo se compilan donde sea que tenga una instanciaci&amp;oacute;n concreta en alg&amp;uacute;n otro archivo fuente. Sin embargo, la instanciaci&amp;oacute;n concreta necesita conocer la implementaci&amp;oacute;n del archivo de plantilla, porque simplemente modificar el &lt;code&gt;typename T&lt;/code&gt; usando un tipo concreto en el archivo .h no va a hacer el trabajo porque lo que .cpp est&amp;aacute; all&amp;iacute; para vincular, no puedo lo encuentro m&amp;aacute;s tarde porque las plantillas de recuerdo son abstractas y no se pueden compilar, por lo que me veo obligado a dar la implementaci&amp;oacute;n en este momento, as&amp;iacute; que s&amp;eacute; qu&amp;eacute; compilar y vincular, y ahora que tengo la implementaci&amp;oacute;n, se vincula a la fuente adjunta expediente. B&amp;aacute;sicamente, en el momento en que instancia una plantilla, necesito crear una clase completamente nueva, y no puedo hacerlo si no s&amp;eacute; c&amp;oacute;mo deber&amp;iacute;a ser esa clase cuando uso el tipo que proporciono, a menos que notifique al compilador de la implementaci&amp;oacute;n de la plantilla, por lo que ahora el compilador puede reemplazar &lt;code&gt;T&lt;/code&gt; con mi tipo y crear una clase concreta que est&amp;eacute; lista para ser compilada y vinculada.</target>
        </trans-unit>
        <trans-unit id="23a63b54ada9895386ea62c48cd3d7b7c294f6fe" translate="yes" xml:space="preserve">
          <source>This is my approach because I am providing a working program, not a template library for use in other programs.  The author of the book, Josuttis, works a lot on template libraries.</source>
          <target state="translated">Este es mi enfoque porque estoy proporcionando un programa de trabajo,no una biblioteca de plantillas para su uso en otros programas.El autor del libro,Josuttis,trabaja mucho en bibliotecas de plantillas.</target>
        </trans-unit>
        <trans-unit id="1994e35f7ee1b0488b7ab2d83998104be1a5a533" translate="yes" xml:space="preserve">
          <source>This requires every T class here to implement the less than operator (&amp;lt;). It will throw a compiler error when you compare two class instances that haven't implemented the &quot;&amp;lt;&quot;.</source>
          <target state="translated">Esto requiere que cada clase T aqu&amp;iacute; implemente el operador menor que (&amp;lt;). Lanzar&amp;aacute; un error de compilaci&amp;oacute;n cuando compare dos instancias de clase que no hayan implementado el &quot;&amp;lt;&quot;.</target>
        </trans-unit>
        <trans-unit id="9c31f99a4d4893f55a1fc379d541ff802eb19e98" translate="yes" xml:space="preserve">
          <source>This way only the template instantiations will need to be recompiled, not all template users (and dependencies).</source>
          <target state="translated">De esta manera sólo las instancias de la plantilla deberán ser recompiladas,no todos los usuarios de la plantilla (y las dependencias).</target>
        </trans-unit>
        <trans-unit id="5e7797397a628b0cc37c602183b6487c56a7909b" translate="yes" xml:space="preserve">
          <source>This way, implementation is still separated from declaration, but is accessible to the compiler.</source>
          <target state="translated">De esta manera,la aplicación sigue estando separada de la declaración,pero es accesible para el compilador.</target>
        </trans-unit>
        <trans-unit id="64b32d3878b4d863ed08ff59292c12d3efc96524" translate="yes" xml:space="preserve">
          <source>This will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for template functions, so if you have non-member operator overloads you may need to do the same for those.</source>
          <target state="translated">Esto instanciará (y por lo tanto pondrá a disposición del enlazador)la clase y todas sus funciones de miembro (solamente).Una sintaxis similar funciona para las funciones de plantilla,por lo que si tiene sobrecargas de operadores no miembros puede que tenga que hacer lo mismo para aquellos.</target>
        </trans-unit>
        <trans-unit id="a2e4febc84235aa3945c67bda91b8350e52c0816" translate="yes" xml:space="preserve">
          <source>To sum up, templates are blueprints for how classes should look, classes are blueprints for how an object should look.
I can't compile templates separate from their concrete instantiation because the compiler only compiles concrete types, in other words, templates at least in C++, is pure language abstraction. We have to de-abstract templates so to speak, and we do so by giving them a concrete type to deal with so that our template abstraction can transform into a regular class file and in turn, it can be compiled normally. Separating the template .h file and the template .cpp file is meaningless. It is nonsensical because the separation of .cpp and .h only is only where the .cpp can be compiled individually and linked individually, with templates since we can't compile them separately, because templates are an abstraction, therefore we are always forced to put the abstraction always together with the concrete instantiation where the concrete instantiation always has to know about the type being used.</source>
          <target state="translated">En resumen,las plantillas son planos de cómo deben verse las clases,las clases son planos de cómo debe verse un objeto.No puedo compilar plantillas por separado de su instanciación concreta porque el compilador sólo compila tipos concretos,en otras palabras,las plantillas al menos en C++,es pura abstracción del lenguaje.Tenemos que des-abstruir plantillas por así decirlo,y lo hacemos dándoles un tipo concreto con el que lidiar para que nuestra abstracción de plantillas se transforme en un archivo de clase regular y a su vez,pueda ser compilado normalmente.Separar el archivo de plantilla .h y el archivo de plantilla .cpp no tiene sentido.No tiene sentido porque la separación del archivo .cpp y del archivo .h sólo es posible cuando el .cpp puede ser compilado individualmente y enlazado individualmente,con plantillas ya que no podemos compilarlas por separado,porque las plantillas son una abstracción,por lo que siempre estamos obligados a poner la abstracción siempre junto con la instanciación concreta donde la instanciación concreta siempre tiene que saber sobre el tipo que se está utilizando.</target>
        </trans-unit>
        <trans-unit id="8babc0d4da66cbd7109fa8d9a726d718a76ecfc1" translate="yes" xml:space="preserve">
          <source>When reading this line, the compiler will create a new class (let's call it &lt;code&gt;FooInt&lt;/code&gt;), which is equivalent to the following:</source>
          <target state="translated">Al leer esta l&amp;iacute;nea, el compilador crear&amp;aacute; una nueva clase (llam&amp;eacute;mosla &lt;code&gt;FooInt&lt;/code&gt; ), que es equivalente a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b476e94c03f06628448dd244ac53118aacb69996" translate="yes" xml:space="preserve">
          <source>Why can templates only be implemented in the header file</source>
          <target state="translated">¿Por qué las plantillas sólo pueden ser implementadas en el archivo de cabecera</target>
        </trans-unit>
        <trans-unit id="9d863fbd4a4b35d1abc87eb5fac9e58af686e66b" translate="yes" xml:space="preserve">
          <source>Why is this?</source>
          <target state="translated">¿Por qué?</target>
        </trans-unit>
        <trans-unit id="93a9a1e27d6f5ea86d321335fd4bdffa983cbc3e" translate="yes" xml:space="preserve">
          <source>You can actually define your template class inside a .template file rather than a .cpp file. Whoever is saying you can only define it inside a header file is wrong. This is something that works all the way back to c++ 98.</source>
          <target state="translated">En realidad puedes definir tu clase de plantilla dentro de un archivo .template en lugar de un archivo .cpp.Quienquiera que diga que sólo puedes definirla dentro de un archivo de encabezado está equivocado.Esto es algo que funciona hasta el c++98.</target>
        </trans-unit>
        <trans-unit id="a823daba893b149e44607d98fae24dda1422529b" translate="yes" xml:space="preserve">
          <source>You might think that when compiling a template the compiler should &quot;generate all versions&quot;, with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because &quot;type modifier&quot; features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:</source>
          <target state="translated">Se podría pensar que al compilar una plantilla el compilador debería &quot;generar todas las versiones&quot;,filtrando las que nunca se utilizan durante el enlace.Aparte de la enorme sobrecarga y las extremas dificultades que tal enfoque enfrentaría porque las características del &quot;modificador de tipos&quot; como punteros y matrices permiten que incluso sólo los tipos incorporados den lugar a un número infinito de tipos,lo que sucede cuando ahora extiendo mi programa añadiendo:</target>
        </trans-unit>
        <trans-unit id="1750a1b4ec7b68120fb74bc6447975a220440d61" translate="yes" xml:space="preserve">
          <source>bar.cpp</source>
          <target state="translated">bar.cpp</target>
        </trans-unit>
        <trans-unit id="782314c016bd8917ce979dc818a4fd7ac7ab7c91" translate="yes" xml:space="preserve">
          <source>baz.cpp</source>
          <target state="translated">baz.cpp</target>
        </trans-unit>
        <trans-unit id="10cb3d1898ec0f9b461c034465b3a25a5a0ce364" translate="yes" xml:space="preserve">
          <source>declares and implements &lt;code&gt;class BazPrivate&lt;/code&gt;, and uses &lt;code&gt;MyClass&amp;lt;BazPrivate&amp;gt;&lt;/code&gt;</source>
          <target state="translated">declara e implementa la &lt;code&gt;class BazPrivate&lt;/code&gt; , y usa &lt;code&gt;MyClass&amp;lt;BazPrivate&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8483342ec553e84a688884d513d4b7cc9f37f84" translate="yes" xml:space="preserve">
          <source>declares the interface of &lt;code&gt;class MyClass&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">declara la interfaz de la &lt;code&gt;class MyClass&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb4fdc80a04ae99261e64f95fee1e452c9f18025" translate="yes" xml:space="preserve">
          <source>defines the implementation of &lt;code&gt;class MyClass&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">define la implementaci&amp;oacute;n de la &lt;code&gt;class MyClass&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b3f4243ca82300fbaf70a60588d086a1fc4d8cc" translate="yes" xml:space="preserve">
          <source>foo.cpp</source>
          <target state="translated">foo.cpp</target>
        </trans-unit>
        <trans-unit id="dde724ad19815ae98cc695bb8a67aae7d2faa5e5" translate="yes" xml:space="preserve">
          <source>foo.h</source>
          <target state="translated">foo.h</target>
        </trans-unit>
        <trans-unit id="02637a26f8881bbb4079d37a0a539bc980568f9a" translate="yes" xml:space="preserve">
          <source>inner_foo has the forward declarations. foo.tpp has the implementation and include inner_foo.h; and foo.h will have just one line, to include foo.tpp.</source>
          <target state="translated">inner_foo tiene las declaraciones delanteras.foo.tpp tiene la implementación e incluye inner_foo.h;y foo.h tendrá una sola línea,para incluir foo.tpp.</target>
        </trans-unit>
        <trans-unit id="b9ae663c6f99d0b5550468e0f718e2d689b19354" translate="yes" xml:space="preserve">
          <source>main.cpp:</source>
          <target state="translated">main.cpp:</target>
        </trans-unit>
        <trans-unit id="e4665c0718899ccbac4e58743355fb37a56287f0" translate="yes" xml:space="preserve">
          <source>myQueue.cpp:</source>
          <target state="translated">myQueue.cpp:</target>
        </trans-unit>
        <trans-unit id="561d0ea5d0c750aef414c6ce0bbefbc2c915c486" translate="yes" xml:space="preserve">
          <source>myQueue.hpp:</source>
          <target state="translated">myQueue.hpp:</target>
        </trans-unit>
        <trans-unit id="920571f4eeae7c8e9c9d5838050e2eb652c3bd9c" translate="yes" xml:space="preserve">
          <source>uses &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt;</source>
          <target state="translated">utiliza &lt;code&gt;MyClass&amp;lt;int&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93374352e9e105c91716fa4d811f0fe7be51fe7b" translate="yes" xml:space="preserve">
          <source>which is gaining support in many compilers.  However, I think precompiled headers would be difficult with template header files.</source>
          <target state="translated">que está ganando apoyo en muchos compiladores.Sin embargo,creo que los encabezados precompilados serían difíciles con archivos de encabezados de plantillas.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
