<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/49002">
    <body>
      <group id="49002">
        <trans-unit id="19e4a51166cdfb3ff9a0baa3e1422bffe26ed5b1" translate="yes" xml:space="preserve">
          <source>(a fragment from: &lt;a href=&quot;http://www.copypasteisforword.com/notes/use-inheritance-properly&quot;&gt;use inheritance properly&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（来自：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.copypasteisforword.com/notes/use-inheritance-properly&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正确使用继承&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的片段&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3cf3c58c0ff1ab151c796159d9fba6934da34ccd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Wikipedia&lt;/a&gt; offers a nice overview of the topic being discussed in this question.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很好地概述了此问题中讨论的主题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84d22270db5c3c635539d2d8ae442c8752d70e66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Car is a Vehicle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;汽车是车辆&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc60060a7f66a3c1423f56735ed1401baf4fbfea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Classes get heavier&lt;/em&gt; - you don't necessarily know what work your superclass is doing in its constructor, or how much memory it's going
  to use. So constructing some innocent would-be lightweight object can
  be far more expensive than you think, and this may change over time if
  the superclass evolves</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类变得更重&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -您不一定知道您的超类在其构造函数中正在做什么，也不知道它将使用多少内存。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，构造一些无辜的轻量级对象可能比您想象的要昂贵得多，而且如果超类不断发展，这种情况可能会随着时间而改变。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd3b79af469cff75a228b80ca85b2a0c9d81150b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Innocent acts can have unexpected results&lt;/em&gt; - The classic example of this is calls to overridable methods from the superclass
  constructor, before the subclasses instance fields have been
  initialized. In a perfect world, nobody would ever do that. This is
  not a perfect world.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无辜的行为会产生意想不到的结果&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -典型的例子是在初始化子类实例字段之前，从超类构造函数调用可重写方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在理想世界中，没有人会这样做。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这不是一个完美的世界。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d09d2c9a3f2c14f6cb59dcf58a0f00d467588cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It encourages an explosion of subclasses&lt;/em&gt;. Classloading costs time, more classes costs memory. This may be a non-issue until you're
  dealing with an app on the scale of NetBeans, but there, we had real
  issues with, for example, menus being slow because the first display
  of a menu triggered massive class loading. We fixed this by moving to
  more declarative syntax and other techniques, but that cost time to
  fix as well.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它鼓励子类的爆炸式增长&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类加载会花费时间，更多类会消耗内存。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在您处理NetBeans规模的应用程序之前，这可能不是问题，但是在那儿，我们遇到了一些实际问题，例如菜单速度慢，因为菜单的首次显示会触发大量的类加载。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们通过使用更具声明性的语法和其他技术来解决此问题，但这也需要花费时间来解决。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="99b00c9cf8e683fccb25eac102b209f855086a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It makes it harder to change things later&lt;/em&gt; - if you've made a class public, swapping the superclass is going to break subclasses -
  it's a choice which, once you've made the code public, you're married
  to. So if you're not altering the real functionality to your
  superclass, you get much more freedom to change things later if you
  use, rather than extend the thing you need. Take, for example,
  subclassing JPanel - this is usually wrong; and if the subclass is
  public somewhere, you never get a chance to revisit that decision. If
  it's accessed as JComponent getThePanel() , you can still do it (hint:
  expose models for the components within as your API).</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这使以后更改内容变得更加困难&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -如果您将一个类公开，则交换超类将破坏子类-这是一个选择，一旦您将代码公开，便成为您的选择。因此，如果您不更改超类的实际功能，则可以在以后使用时有更大的自由来进行更改，而不必扩展所需的内容。以子类化JPanel为例-这通常是错误的。如果子类在某个地方是公共的，则您将永远没有机会重新审视该决定。如果以JComponent getThePanel（）的形式访问它，则仍然可以执行此操作（提示：以您的API公开内部组件的模型）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9fea8abbd67148f9aaad86c2cc91e5b50984e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It offers perverse temptations for subclassers to make assumptions about order of method calls and such&lt;/em&gt; - such assumptions tend not to
  be stable if the superclass may evolve over time. See also &lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;amp;messageID=91819530#91819530&quot;&gt;my toaster
  and coffee pot analogy&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它为子类提供了不正确的诱惑，使&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们无法对&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法调用的顺序进行假设，并且&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种假设-如果超类可能随时间演变，则这种假设可能会变得不稳定。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;amp;messageID=91819530#91819530&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的烤面包机和咖啡壶类比&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f2d1a02f1330761039247ff2ac486fa4bcd2963" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Object hierarchies don't scale (or making them scale later is much harder than planning ahead)&lt;/em&gt; - this is the classic &quot;too many layers&quot;
  problem. I'll go into this below, and how the AskTheOracle pattern can
  solve it (though it may offend OOP purists).</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象层次结构无法扩展（或使它们在以后扩展比预先计划要困难得多）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -这是经典的&amp;ldquo;层数过多&amp;rdquo;问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将在下面进行介绍，以及AskTheOracle模式如何解决它（尽管它可能会冒犯OOP纯粹主义者）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de6ccea047149366a9dda9ed695b699d688314a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.&lt;/em&gt; With composition, it's easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优先考虑组成而不是继承，因为它在以后更容易延展/更容易修改，但不要使用总是组合的方法。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过组合，可以轻松地通过&amp;ldquo;依赖注入/设置器&amp;rdquo;即时更改行为。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承更加严格，因为大多数语言不允许您从一种以上的类型派生。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，一旦从TypeA派生，鹅或多或少就会被煮熟。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4308a41a321f00f54f99cdd2884e9094023fd662" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Truck is a Vehicle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;卡车是一辆车&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f587fb9140a968f772a8162968129fa88e330b59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cons of Composition:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组成的缺点：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="790ced1c5a0bbe20b15223aa6a4e22337bfcd462" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Pros of Inheritance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承的优点：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a69a0cc249ebb716c5b801c19b32afb8a98697dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because inheritance is a poor way of moving information&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为继承是传递信息的不良方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="642f86d54fa53fe530b7fceb3af4325e550ae72b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages of Inheritance:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承的缺点：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30e3ffdd81cf85d5a9b7fbf8f2b5ed8777d2cb4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1: Dog --&amp;gt; Animal&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例1：狗-&amp;gt;动物&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08d6fcd73932e2db1e487ea9c038b47cd04b4f4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2: Circle -/-&amp;gt; Ellipse&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例2：圆形-/-&amp;gt;椭圆&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22d74f86d3cbdef89198b5678344bd3b330b51a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REFERENCE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REFERENCE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01e62217f11659bf6313a453455a96ddfecb964" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subclassing&lt;/strong&gt; means implicit reuse of method implementations.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子类化&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着方法实现的隐式重用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46f346af11e821ee7e1ce39993d2a8fb3fd69a7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subtyping&lt;/strong&gt; means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型化意味着符合类型（接口）签名，即一组API，并且可以覆盖部分签名以实现子类型多态性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="133fbefb42fa53f06d9d810164f60ab910ebfa77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov's &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; as a test for 'Should I be inheriting from this type?'</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更新：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;刚刚回到我的答案，现在似乎没有完整提及Barbara Liskov的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Liskov替代原则&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是不完整的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以检验&amp;ldquo;我是否应该继承这种类型？&amp;rdquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5fe3b54cb63f0b09fd4abeb10b7c42f52993fc0c" translate="yes" xml:space="preserve">
          <source>@MatthieuM. says in &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&quot;&gt;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@MatthieuM。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448中&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;说&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1d66bf495a38f7905720f390dbf27d3cd5934bd" translate="yes" xml:space="preserve">
          <source>A circle is an ellipse BUT circles can't do everything that ellipses can do. For example, circles can't stretch, while ellipses can. Therefore, the class &lt;code&gt;Circle&lt;/code&gt;&lt;strong&gt;cannot&lt;/strong&gt; inherit the class &lt;code&gt;Ellipse&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;圆是椭圆，但是圆不能做椭圆所能做的所有事情。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，圆圈不能伸展，而椭圆可以伸展。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Circle&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Ellipse&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed02723917385f91dd310ca5a8a52e74215144aa" translate="yes" xml:space="preserve">
          <source>A dog is an animal AND dogs can do everything that animals can do (such as breathing, dying, etc.). Therefore, the class &lt;code&gt;Dog&lt;/code&gt;&lt;strong&gt;can&lt;/strong&gt; inherit the class &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;狗是动物，而狗可以做动物可以做的所有事情（例如呼吸，死亡等）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Dog&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Animal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01287059a41e22e70d573f7784b74fea385c7a85" translate="yes" xml:space="preserve">
          <source>A much more complete and concrete &lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;amp;threadID=16487#91822172&quot;&gt;answer from Tim Boudreau&lt;/a&gt; of Sun:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sun的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;amp;threadID=16487#91822172&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tim Boudreau&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给出&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了更为完整和具体的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ecfbd413e3b64a89620f4a0c3113ea12be77cd9" translate="yes" xml:space="preserve">
          <source>A rule of thumb I have heard is inheritance should be used when its a &quot;is-a&quot; relationship and composition when its a &quot;has-a&quot;. Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.</source>
          <target state="translated">我听说的一个经验法则是,当它是 &quot;is-a &quot;关系时,应该使用继承,而当它是 &quot;has-a &quot;关系时,应该使用组合。即使是这样,我觉得你应该总是倾向于使用组成关系,因为它可以消除很多的复杂性。</target>
        </trans-unit>
        <trans-unit id="7ba0c4f8f2f7998fd84e1b2e18671bab5f8dbd05" translate="yes" xml:space="preserve">
          <source>A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same &lt;em&gt;interface&lt;/em&gt; as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level &lt;em&gt;implementation&lt;/em&gt; differs, the high-level &lt;em&gt;interface&lt;/em&gt; remains the same).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一种简单的理解方法是，当您需要类的对象具有与&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其父类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接口&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，应使用继承&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以便可以将其视为父类的对象（向上投射）。 。此外，对派生类对象的函数调用在代码中的每个地方都将保持不变，但具体的调用方法将在运行时确定（即，低级&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不同，高级&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接口&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保持不变）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf4a40229fa15c4916233897eb3cd85732b5ca8" translate="yes" xml:space="preserve">
          <source>Also, I support @anon answer in &lt;a href=&quot;https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1&quot;&gt;Why use inheritance at all?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，我支持@anon回答&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么要完全使用继承？&amp;rdquo;中的内容。&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fcf41a9237c1dac7d08f4bbf45ff16fef75d4e1" translate="yes" xml:space="preserve">
          <source>An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering more object oriented design.</source>
          <target state="translated">这方面的一个例子是没有使用类的PHP(尤其是在PHP5之前)。所有的逻辑都编码在一组函数中。你可以包含其他包含辅助函数等的文件,通过在函数中传递数据来进行业务逻辑。随着应用程序的发展,这可能是很难管理的。PHP5试图通过提供更多的面向对象设计来弥补这个问题。</target>
        </trans-unit>
        <trans-unit id="003b46e7955af669ca0d0b1ccab8ff624590d7d7" translate="yes" xml:space="preserve">
          <source>Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It's really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren't always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.</source>
          <target state="translated">另一个非常实用的理由是,宁愿使用组合而不是继承,这与你的域模型,以及将其映射到关系型数据库有关。要把继承映射到SQL模型上真的很难(你最终会遇到各种黑客的变通方法,比如创建不经常使用的列,使用视图等)。一些ORML试图处理这个问题,但总是很快就变得复杂了。组成可以通过两个表之间的外键关系轻松建模,但继承就难多了。</target>
        </trans-unit>
        <trans-unit id="b3ead00c7eaee34c442057dee94f69e62fca38dd" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class &lt;code&gt;Widget&lt;/code&gt; in GUI frameworks, or a polymorphic class &lt;code&gt;Node&lt;/code&gt; in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据经验，当预期多态使用非常普遍时，我倾向于选择继承而不是合成，在这种情况下，动态分派的功能可以使API更具可读性和优雅性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在GUI框架中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有多态类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在XML库中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有多态类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Node&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使API具有比纯粹基于组成的解决方案更易读和直观的使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="19790e17c44a9b95a38b06493bf40dd98fb49535" translate="yes" xml:space="preserve">
          <source>As many people told, I will first start with the check - whether there exists an &quot;is-a&quot; relationship. If it exists I usually check the following:</source>
          <target state="translated">正如很多人说的那样,我先从检查开始--是否存在 &quot;is-a &quot;关系。如果存在,我通常会从以下几个方面进行检查。</target>
        </trans-unit>
        <trans-unit id="fda1192189400839b8b95f4e3718dccf23de4a71" translate="yes" xml:space="preserve">
          <source>As soon as someone explained &quot;favor composition over inheritance&quot; to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn't really work well.</source>
          <target state="translated">当有人向我解释 &quot;偏向于继承 &quot;的时候,我回想了一下每次尝试使用继承在类之间共享功能的时候,发现大多数时候并没有很好地实现。</target>
        </trans-unit>
        <trans-unit id="dd869ae1d27b49cf539b23ec39ba981088b4ec6a" translate="yes" xml:space="preserve">
          <source>Aside from is a/has a considerations, one must also consider the &quot;depth&quot; of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.</source>
          <target state="translated">除了是啊是的考虑,还必须考虑你的对象所要经历的继承的 &quot;深度&quot;。任何超过五、六级继承深度的东西都可能会引起意想不到的铸造和boxingunboxing的问题,在这种情况下,也许明智的做法是将你的对象改成编译对象。</target>
        </trans-unit>
        <trans-unit id="382e62ec5112339ce9d05227c6fa3d942c472f7a" translate="yes" xml:space="preserve">
          <source>At the risk of oversimplifying, that's composition - composing multiple classes to work together. And once we form that habit we find that it's much more flexible, maintainable, and testable than using inheritance.</source>
          <target state="translated">冒着过度简化的风险,这就是组成--将多个类组成在一起工作。而一旦我们形成了这个习惯,我们会发现它比使用继承的方式更灵活、更可维护、更可测试。</target>
        </trans-unit>
        <trans-unit id="400d0992f15edf3eca262b5209a73094f8d6e110" translate="yes" xml:space="preserve">
          <source>Base class defines structure of the algorithm  and sub-class will override a part of algorithm =&amp;gt; &lt;strong&gt;&lt;em&gt;You can implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;Template_method&lt;/a&gt; without change in base class skeleton&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基类定义算法的结构，子类将覆盖算法的一部分=&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在不更改基类骨架的情况下&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Template_method&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c024738e730ecac1df27b0bab86fd28a7f5eab0" translate="yes" xml:space="preserve">
          <source>Base class provides default implementation and sub-class can change the behaviour =&amp;gt; &lt;strong&gt;&lt;em&gt;You can re-define contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基类提供默认实现，子类可以更改行为=&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以重新定义合同&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec79a6576dd1a829ef1be9035eab29495e4a39ac" translate="yes" xml:space="preserve">
          <source>Base class provides no implementation and sub-class has to override complete method (abstract) =&amp;gt; &lt;strong&gt;&lt;em&gt;You can implement a contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基类不提供任何实现，子类必须重写complete方法（抽象）=&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以实现合同&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5071aef9005443060d06d71c91df8e638ed8f5f" translate="yes" xml:space="preserve">
          <source>Call no methods from the superclass constructor</source>
          <target state="translated">从超级类构造函数中不调用任何方法</target>
        </trans-unit>
        <trans-unit id="4b96cc03f1983251e435c5372fac4d177913e2d5" translate="yes" xml:space="preserve">
          <source>Common problems to the use of inheritance as I see it are:</source>
          <target state="translated">在我看来,继承权的使用存在的共同问题是:</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="81f2d2c7a8be16bc594e920e17d27d214e445279" translate="yes" xml:space="preserve">
          <source>Composition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in &lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java&quot;&gt;decorator pattern&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java&quot;&gt;proxy pattern&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;合成具有控制反转的功能，并且它的依赖项可以动态注入，如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;装饰器模式&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代理模式所示&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58f3246a619006b9498ebf3dce3fe08d69bb09f" translate="yes" xml:space="preserve">
          <source>Composition has the benefit of &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators&quot;&gt;combinator-oriented&lt;/a&gt; programming, i.e. working in a way like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern#Java&quot;&gt;composite pattern&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组合的好处是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;面向组合&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;程序的编程，即以类似于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复合模式&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的方式工作&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b61664eea08164f2bdbcf4e14aaae6423d48a24e" translate="yes" xml:space="preserve">
          <source>Composition has the benefit of easy &lt;a href=&quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance&quot;&gt;multiple inheritance&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组合具有易于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多重继承&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的优点&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0686522d6dc64a26474dd45526ab7c5d6f2976fd" translate="yes" xml:space="preserve">
          <source>Composition immediately follows &lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;programming to an interface&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写之后&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;立即&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写接口&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46ef1a92cd606125c6540b7b2b01afd6a3c39af1" translate="yes" xml:space="preserve">
          <source>Composition is favoured over inheritance. To put it very simply you would have:</source>
          <target state="translated">组成是偏向于继承的。说得很简单,你会有:</target>
        </trans-unit>
        <trans-unit id="5a48c284575bc59295e94ae273beff875be00b0e" translate="yes" xml:space="preserve">
          <source>Composition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it's quite safe and easy to use composition. There are so many possibilites here.</source>
          <target state="translated">组成只是发挥它的模块化:你创建类似于父类的接口,创建新的对象,并对其进行委托调用。如果这些对象不需要互相不知道,那么使用Composition是相当安全和容易的。这里有很多的可能性。</target>
        </trans-unit>
        <trans-unit id="ae3589f9e16ef3d74aae74f9cc0e37a51e1e1c2f" translate="yes" xml:space="preserve">
          <source>Composition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the &quot;&lt;em&gt;Single Responsibility Principle&lt;/em&gt;&quot;, which is often summarized as &quot;&lt;em&gt;There should never be more than one reason for a class to change.&lt;/em&gt;&quot;, and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our &lt;em&gt;real world&lt;/em&gt; pretty well, but that isn't the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组合通常更合乎逻辑，它提供了更好的抽象，更好的封装，更好的代码重用（尤其是在非常大的项目中），并且几乎不会因为在代码中的任何地方进行孤立的更改而在远处破坏任何东西。这也使坚持&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单一责任原则&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变得更加容易，该&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原则&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常被总结为&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个类别发生变化的原因绝不应该有一个以上。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;，这意味着每个类别都出于特定的目的而存在，并且应该仅具有与其目的直接相关的方法。另外，由于继承树很浅，即使您的项目开始变得很大，也更容易保留概述。许多人认为继承代表了我们的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现实世界&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很好，但这不是事实。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现实世界中使用的构成多于继承。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;几乎可以握在手中的每个现实对象都是由其他较小的现实对象组成的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10f3a58f627a1c06a673bba20f0d87bcfa973635" translate="yes" xml:space="preserve">
          <source>Composition is typically &quot;has a&quot; or &quot;uses a&quot; relationship. Here the Employee class has a Person. It does not inherit from Person but instead gets the Person object passed to it, which is why it &quot;has a&quot; Person.</source>
          <target state="translated">构成一般是 &quot;有一个 &quot;或 &quot;使用一个 &quot;的关系。这里的Employee类有一个Person。它不从Person继承,而是获得传递给它的Person对象,这就是它 &quot;有一个 &quot;Person的原因。</target>
        </trans-unit>
        <trans-unit id="3fd117ba0aac29cf18bbb9d63f44b9e57ef72792" translate="yes" xml:space="preserve">
          <source>Composition over Inheritance</source>
          <target state="translated">继承权的组成</target>
        </trans-unit>
        <trans-unit id="f95b761f5013500506669ddde5d332b7d2698e3f" translate="yes" xml:space="preserve">
          <source>Composition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class' implementation which the user of that class need not know about. So composition is more in the way of supporting &lt;em&gt;encapsulation&lt;/em&gt; (i.e. concealing the implementation) while inheritance is meant to support &lt;em&gt;abstraction&lt;/em&gt; (i.e. providing a simplified representation of something, in this case the &lt;strong&gt;same&lt;/strong&gt; interface for a range of types with different internals).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您不需要新的类具有相同的接口时，即应该隐藏该类的用户不需要知道的类实现的某些方面时，应使用组合。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，组合更多地是通过支持&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;封装&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即隐藏实现）的方式，而继承是为了支持&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;抽象&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即提供某种事物的简化表示，在这种情况下，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于具有不同内部结构的各种类型，使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接口）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2a8235eed4685d8113375b89cd8a8e3d9bd3e3a" translate="yes" xml:space="preserve">
          <source>Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.</source>
          <target state="translated">组成vs继承是一个很广泛的话题。至于什么是更好的,我认为这完全取决于系统的设计,所以没有真正的答案。</target>
        </trans-unit>
        <trans-unit id="92716f2ee6cb1310c9dda41d91fd87785b6876c1" translate="yes" xml:space="preserve">
          <source>Creating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass &quot;is-a&quot; super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.</source>
          <target state="translated">创建子类的意义不应该仅仅是为了方便调用超类的方法。当子类在结构上和功能上都是 &quot;是-a &quot;超类的时候,当它可以作为超类的时候,你就应该使用继承,而且你要用这个继承。如果不是这样--那就不是继承,而是其他的东西。构成是当你的对象由另一个,或者说与之有一定关系的对象组成时。</target>
        </trans-unit>
        <trans-unit id="3fe61a6e3e340af7a148250fe18c7fe220180a40" translate="yes" xml:space="preserve">
          <source>Didn't find a satisfactory answer here, so I wrote a new one.</source>
          <target state="translated">在这里没有找到一个满意的答案,所以我写了一个新的。</target>
        </trans-unit>
        <trans-unit id="2134be01d96196149dd1553096fb7d21f63f453f" translate="yes" xml:space="preserve">
          <source>Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for &lt;strong&gt;Composition.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TypeB是否只希望TypeA公开某些/部分行为？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示需要&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组成。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="12ab02cfb9dcddf234cbcb5daadc6acbbc33faab" translate="yes" xml:space="preserve">
          <source>Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates &lt;strong&gt;Inheritance&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TypeB是否要公开TypeA的完整接口（所有公共方法都不少），以便可以在需要TypeA的地方使用TypeB？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777d4fc8b7f76029a5967bc0b0912719f3a1a9b1" translate="yes" xml:space="preserve">
          <source>Does your class need to re-use any high level interactions defined in another class ? The &lt;a href=&quot;http://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;template method&lt;/a&gt; design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的班级是否需要重用另一个班级中定义的任何高级交互？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;模板方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设计模式就不可能不继承来实现。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我相信所有可扩展的框架都使用这种模式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ce219366653ef3fc59ddc3a55f02fcdb049f3e4" translate="yes" xml:space="preserve">
          <source>E.g 1. Accountant &lt;strong&gt;is an&lt;/strong&gt; Employee. But I will &lt;strong&gt;not&lt;/strong&gt; use inheritance because a Employee object can be instantiated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如1.会计师&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;雇员。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是我&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用继承，因为可以实例化Employee对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd394dfc4783e4030e370145dbe0cbed4e04b2f6" translate="yes" xml:space="preserve">
          <source>E.g 2. Book &lt;strong&gt;is a&lt;/strong&gt; SellingItem. A SellingItem cannot be instantiated - it is abstract concept. Hence I will use inheritacne. The SellingItem is an &lt;strong&gt;abstract base class (or interface&lt;/strong&gt; in C#)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如2.书&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; SellingItem。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SellingItem无法实例化-这是抽象概念。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我将使用Inheritacne。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SellingItem是一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;抽象基类（或&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C＃中的&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接口&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e63cd64448d1fa4bd7208eeb5d3146984a4c565d" translate="yes" xml:space="preserve">
          <source>Either the base class &lt;code&gt;Engine&lt;/code&gt; exposes a mutator to change its</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Engine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;公开了一个更改器以更改其&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b189d69566897b8878d77a4a677fe65f855dc737" translate="yes" xml:space="preserve">
          <source>Essentially, this means that inheritance is possible if the base class can be used polymorphically, which I believe is equivalent to our test &quot;a bar is a foo and bars can do everything that foos can do&quot;.</source>
          <target state="translated">本质上,这意味着如果基类可以多态化使用,那么继承是可以的,我认为这就相当于我们的测试 &quot;a bar是foo,而bar可以做foos能做的一切事情&quot;。</target>
        </trans-unit>
        <trans-unit id="f2051d9830558331ddb82ea3d448072dd2bb9c36" translate="yes" xml:space="preserve">
          <source>Even if you &lt;em&gt;can&lt;/em&gt; use inheritance doesn't mean you &lt;em&gt;should&lt;/em&gt;: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren't obvious, and in my opinion are best explained in &lt;a href=&quot;https://stackoverflow.com/a/32557773/1951907&quot;&gt;lcn's answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使您&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用继承也不意味着您&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：使用组合始终是一种选择。继承是一个强大的工具，允许隐式代码重用和动态分配，但是它确实有一些缺点，这就是为什么通常首选组合的原因。继承与组合之间的权衡并不明显，我认为最好在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/32557773/1951907&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lcn的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解释&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f8acd85ea01ba780aab8bff6a6da0a022821ecd" translate="yes" xml:space="preserve">
          <source>Even though Composition is preferred, I would like to highlight pros of &lt;em&gt;Inheritance&lt;/em&gt; and cons of &lt;em&gt;Composition&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使首选Composition，我还是要强调&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优点&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Composition的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缺点&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31031c9aad8cde85b2091023e88715df8ab33039" translate="yes" xml:space="preserve">
          <source>Excessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.</source>
          <target state="translated">通过子类的过度重用会使继承堆栈变得很深,也很混乱。</target>
        </trans-unit>
        <trans-unit id="89a3623ed6c1f4cf17b888e7b9aea97aa69741d0" translate="yes" xml:space="preserve">
          <source>Expose no fields, ever, except constants</source>
          <target state="translated">除了常数之外,不暴露任何字段。</target>
        </trans-unit>
        <trans-unit id="043fff222c570925fe52a25442b655b888e4778a" translate="yes" xml:space="preserve">
          <source>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it</source>
          <target state="translated">使用指针或引用基类的函数必须能够在不知道的情况下使用派生类的对象。</target>
        </trans-unit>
        <trans-unit id="3bb1334620acce14a757514719a368811078eacb" translate="yes" xml:space="preserve">
          <source>Generally type of relationship between object provide better information to choose one of them.</source>
          <target state="translated">一般来说,对象之间的关系类型提供了较好的信息,可以选择其中的一个。</target>
        </trans-unit>
        <trans-unit id="4f12a4d9f8c6da07d46b0a2b46004b726e7c45ee" translate="yes" xml:space="preserve">
          <source>However, if the parent class for some reason needs to access functions provided by the &quot;child class&quot; for inexperienced programmer it may look like it's a great place to use  inheritance. The parent class can just call it's own abstract &quot;foo()&quot; which is overwritten by the subclass and then it can give the value to the abstract base.</source>
          <target state="translated">但是,如果父类因为某种原因需要访问 &quot;子类 &quot;提供的函数,对于没有经验的程序员来说,可能看起来是使用继承的好地方。父类只需要调用自己的抽象 &quot;foo()&quot;就可以了,而这个子类就可以把这个值交给抽象的基类。</target>
        </trans-unit>
        <trans-unit id="97f925aaef0269b5644be480512ea4709622251e" translate="yes" xml:space="preserve">
          <source>However, if you want to use the private variables, the case 3, then you may be in trouble. &lt;strong&gt;If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe&lt;/strong&gt;. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it's quite fine.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果要使用私有变量（情况3），则可能会遇到麻烦。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您认为全局变量不安全，则应考虑使用继承来访问也不安全的私有变量&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。提醒您，全局变量并不全是坏事-数据库本质上是一大组全局变量。但是，如果您可以处理，那就很好。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4d685219579566f4df07511cc885fbfa342cbce" translate="yes" xml:space="preserve">
          <source>However, if your intention is purely that of code re-use, then composition most likely is a better design choice.</source>
          <target state="translated">但是,如果你的目的纯粹是为了代码的重用,那么构图很可能是一个更好的设计选择。</target>
        </trans-unit>
        <trans-unit id="79722dd4bf505b50db03d2d8689bea00b8a0de1d" translate="yes" xml:space="preserve">
          <source>I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.</source>
          <target state="translated">我同意@Pavel的说法,当他说的时候,我同意他说的,作文有地方,继承也有地方。</target>
        </trans-unit>
        <trans-unit id="9da4978d60ea2b750a44d4c39e654ed0899f255e" translate="yes" xml:space="preserve">
          <source>I can think of three real reasons for using inheritance:</source>
          <target state="translated">我能想到三个真正使用继承的理由。</target>
        </trans-unit>
        <trans-unit id="92415e061dde1a77f1cbf96f5a396e5e3f625e79" translate="yes" xml:space="preserve">
          <source>I have three classes that all need some common functionality. So if I
  write a base class and have them all inherit from it, then they will
  all have that functionality and I'll only need to maintain it in once
  place.</source>
          <target state="translated">我有三个类,它们都需要一些共同的功能。所以,如果我写一个基类,让它们都继承到这个基类,那么它们都会有这个功能,而且我只需要在一个地方维护它。</target>
        </trans-unit>
        <trans-unit id="94322ac0b828540a1a09d955fde0930579fb6eef" translate="yes" xml:space="preserve">
          <source>I see no one mentioned the &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&quot;&gt;&lt;strong&gt;diamond problem&lt;/strong&gt;&lt;/a&gt;, which might arise with inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我看不到有人提到&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;钻石问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这可能是继承带来的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66bbabb97fcd47e383202e2d023a33046ffde71d" translate="yes" xml:space="preserve">
          <source>I take no credit for this approach. I took it straight from the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735619670&quot;&gt;Second Edition of Code Complete&lt;/a&gt; by &lt;a href=&quot;http://blogs.construx.com/blogs/stevemcc/default.aspx&quot;&gt;Steve McConnell&lt;/a&gt;, &lt;em&gt;Section 6.3&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不相信这种方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我把它直接从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735619670&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码的第二版完全&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.construx.com/blogs/stevemcc/default.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;史蒂夫&amp;middot;麦康奈尔&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第6.3节&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa2bbecf277f1f24d2f1347150c527e7e0547d68" translate="yes" xml:space="preserve">
          <source>I think inheritance should be used if your answer is an affirmative to any of these questions.</source>
          <target state="translated">我认为,如果你的答案是肯定的,就应该使用继承权。</target>
        </trans-unit>
        <trans-unit id="9a218d45daf46b325069807128916cf22840ea70" translate="yes" xml:space="preserve">
          <source>I would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it's easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).</source>
          <target state="translated">我建议使用composing作为默认设置。它更模块化,而且有后期绑定的好处(你可以动态改变组件)。另外,它更容易分别测试的东西。而且,如果你需要使用类中的方法,也不会被强制要求一定形式(Liskov Substitution Principle)。</target>
        </trans-unit>
        <trans-unit id="b4b8830d61628daddd8e304299af6cded09fa350" translate="yes" xml:space="preserve">
          <source>If code reuse is the &lt;em&gt;sole&lt;/em&gt; purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don't make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is &lt;em&gt;demanded&lt;/em&gt;. This is also where the &quot;is-a&quot; vs. &quot;has-a&quot; notion comes from.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果代码重用是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;目的，则子类提供的功能可能比他所需要的多，即子类的某些公共方法对子类没有多大意义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，代替偏袒继承组合物，组合物被&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要求&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这也是&amp;ldquo; is-a&amp;rdquo;与&amp;ldquo; has-a&amp;rdquo;概念的来源。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f377d45b989acafd55d82af80725c12e6b22ad84" translate="yes" xml:space="preserve">
          <source>If relation type is  &quot;IS-A&quot; relation then Inheritance is better approach.
otherwise relation type is  &quot;HAS-A&quot; relation then composition will better approach.</source>
          <target state="translated">如果关系类型是 &quot;IS-A &quot;关系,那么继承是比较好的方法。</target>
        </trans-unit>
        <trans-unit id="31255e40d0434216cba8c8688fd5f4dadb2d4bce" translate="yes" xml:space="preserve">
          <source>If the object need to be of the same type, then use &lt;strong&gt;Inheritance&lt;/strong&gt; or implement interfaces.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果对象必须是同一类型，则使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或实现接口。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03ea0bf4e382df082ffa1f260eb4aff741e92ef5" translate="yes" xml:space="preserve">
          <source>If the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.</source>
          <target state="translated">如果原因是2号,那就有点麻烦了。你真的只需要使用相同的基类吗?一般来说,仅仅使用相同的基类是不够好的,但这可能是你的框架的要求,这是一个设计上无法避免的考虑。</target>
        </trans-unit>
        <trans-unit id="50913e0cbdc9a4f53879607cd8217f727ee11c8d" translate="yes" xml:space="preserve">
          <source>If these are true, then it is probably necessary to use inheritance.</source>
          <target state="translated">如果这些都是真的,那么可能就需要使用继承。</target>
        </trans-unit>
        <trans-unit id="8b1c2b77c49e48b7fd23f6be825d3e74aa05cdb1" translate="yes" xml:space="preserve">
          <source>If you understand the difference, it's easier to explain.</source>
          <target state="translated">如果你能明白其中的区别,解释起来就比较容易了。</target>
        </trans-unit>
        <trans-unit id="0744b5b95abf4fe22c4bb86def64e0a6bd18cab0" translate="yes" xml:space="preserve">
          <source>In Java or C#, an object cannot change its type once it has been instantiated.</source>
          <target state="translated">在Java或C#中,对象一旦被实例化,就不能改变其类型。</target>
        </trans-unit>
        <trans-unit id="048c5d31bb5c132e0c74cc2184a24b79baadf241" translate="yes" xml:space="preserve">
          <source>In a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?</source>
          <target state="translated">一目了然,如果B类和C类继承了A类,并且都覆盖了方法X,而第四个类D,继承了B类和C类,并且不覆盖X,那么X D应该使用哪个实现?</target>
        </trans-unit>
        <trans-unit id="328ab1e48844e9cef1794c68df9d6ef8b3d470f0" translate="yes" xml:space="preserve">
          <source>In inheritance, subclass can directly invoke base class method even though it's not implementing base class method because of &lt;strong&gt;&lt;em&gt;IS A&lt;/em&gt;&lt;/strong&gt; relation. If you use composition, you have to add methods in container class to expose contained class API</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在继承中，子类可以直接调用基类方法，即使由于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IS A&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关系&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而没有实现基类方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果使用组合，则必须在容器类中添加方法以公开包含的类API&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0237d418d5cba034a69d0e770a4c52723e47e4d3" translate="yes" xml:space="preserve">
          <source>In the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, &quot;Cool, I learned about inheritance and now I used it.&quot; That's not meant to be condescending because we've all done it. But we all did it because no one told us not to.</source>
          <target state="translated">到最后,我们把自己的代码打上了一些难解的结,除了可以说 &quot;酷,我学会了继承,现在我用上了 &quot;之外,并没有得到任何好处。这不是居高临下的意思,因为我们都做过。但我们都做过,因为没有人告诉我们不要做。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="8acfc927b768458de4cace8265888459e774da8a" translate="yes" xml:space="preserve">
          <source>Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class'es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally.</source>
          <target state="translated">继承在子类和超级类之间建立了一个强大的关系,子类必须知道超级类的实现细节。创建超级类就难多了,这时你必须考虑如何扩展超级类。你必须仔细记录类的 invariants,并说明其他可覆盖的方法在内部使用什么方法。</target>
        </trans-unit>
        <trans-unit id="b7060930ac5a536fbe2aad05ec9ec8d02db42c83" translate="yes" xml:space="preserve">
          <source>Inheritance exposes &lt;em&gt;protected&lt;/em&gt; members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承公开&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;受保护的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成员。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这破坏了父类的封装，并且如果由子类使用，则会在子代及其父代之间引入另一个依赖关系。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1ded82669ac9037f30aed69f3e1289af7838c6f" translate="yes" xml:space="preserve">
          <source>Inheritance exposes a subclass to details of its parent class implementation, that's why it's often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).</source>
          <target state="translated">继承将一个子类暴露在其父类实现的细节中,这就是为什么人们常说的继承打破了封装(从某种意义上说,你真正需要关注的只是接口而不是实现,所以通过子类化重用不一定是首选)。</target>
        </trans-unit>
        <trans-unit id="6b2f20d3e798733bc6014d967772e1dd274bc317" translate="yes" xml:space="preserve">
          <source>Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here.</source>
          <target state="translated">继承是一种非常强大的代码重用机制。但是需要正确的使用。我想说的是,如果子类也是父类的子类型,那么继承的使用是正确的。如上所述,Liskov替代原则是这里的关键点。</target>
        </trans-unit>
        <trans-unit id="4d4a2058f753bb6fa776187437c532819ce7c9eb" translate="yes" xml:space="preserve">
          <source>Inheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.</source>
          <target state="translated">不过,继承很容易被过度使用,而且会产生额外的复杂性,类之间存在着硬性的依赖关系。同时,由于层和方法调用的动态选择,理解程序执行过程中发生的事情也变得相当困难。</target>
        </trans-unit>
        <trans-unit id="246a008dc7a1185d80da575bb9971db7f90056e2" translate="yes" xml:space="preserve">
          <source>Inheritance is often taught early when we learn object-oriented programming, so it's seen as an easy solution to a common problem.</source>
          <target state="translated">在我们学习面向对象编程的时候,往往会很早就教给我们继承,所以大家都把它看成是一个很容易解决的常见问题。</target>
        </trans-unit>
        <trans-unit id="644a9a7de65c713edc98cce558794f4f5d61fd4c" translate="yes" xml:space="preserve">
          <source>Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that</source>
          <target state="translated">继承是非常诱人的,尤其是来自于程序化领域的继承,而且它通常看起来很优雅。我的意思是,我只需要把这个功能添加到其他类中就可以了,对吧?好吧,问题之一是</target>
        </trans-unit>
        <trans-unit id="62e87b6a71b6557527e58c600d3ce6921f9bf0e3" translate="yes" xml:space="preserve">
          <source>Inheritance is really a cool feature, but I'm afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.</source>
          <target state="translated">继承确实是一个很酷的功能,但恐怕在过去几年里,它已经被过度使用了。人们把继承视为一锤定音,不管实际上是钉子、螺丝钉,或许是完全不同的东西,都能把它当成是一锤定音。</target>
        </trans-unit>
        <trans-unit id="6876956ee9e8f2967733c679847a166bd622f332" translate="yes" xml:space="preserve">
          <source>Inheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).</source>
          <target state="translated">继承有时是有用的,如果层次结构真的代表了一个is-a-relationship的话。它与开放封闭原则(Open-Closed Principle)有关,该原则规定,类应该是封闭的,可以修改,但也可以扩展。这样,你可以有多态性;有一个处理超级类型及其方法的通用方法,但通过动态调度调用子类的方法。这样做很灵活,而且有助于建立隐蔽性,这在软件中是必不可少的(对实现细节了解较少)。</target>
        </trans-unit>
        <trans-unit id="bced79113df2d8dc04636edbfd4c770f3793b989" translate="yes" xml:space="preserve">
          <source>Inheritance is very powerful, but you can't force it (see: the &lt;a href=&quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;circle-ellipse problem&lt;/a&gt;). If you really can't be completely sure of a true &quot;is-a&quot; subtype relationship, then it's best to go with composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承非常强大，但是您不能强制继承（请参阅：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;圆椭圆问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不能完全确定真正的&amp;ldquo;是&amp;rdquo;子类型关系，那么最好使用组合。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c9e4c9ebc2c06779a4efa98017c411df12f9203" translate="yes" xml:space="preserve">
          <source>Inheritance provides straightforward &lt;a href=&quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion&quot;&gt;open recursion&lt;/a&gt; via the internal polymorphic site &lt;code&gt;this&lt;/code&gt;, i.e. invoking overriding method (or even &lt;a href=&quot;http://www.scala-lang.org/old/node/1637.html#comment-5489&quot;&gt;type&lt;/a&gt;) in another member function, either public or private (though &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one&quot;&gt;discouraged&lt;/a&gt;). Open recursion can be &lt;a href=&quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java&quot;&gt;simulated via composition&lt;/a&gt;, but it requires extra effort and may not always viable(?). This &lt;a href=&quot;https://stackoverflow.com/a/2238735/2073130&quot;&gt;answer&lt;/a&gt; to a duplicated question talks something similar.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承提供简单的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;开递归&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;经由内部多态性位点&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，即调用重写方法（或者甚至&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.scala-lang.org/old/node/1637.html#comment-5489&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中另一个成员函数），可以是公共或私有的（虽然&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;泄气&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过composition&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;模拟&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;开放递归&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是这需要额外的精力，并且可能并不总是可行的（？）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重复问题的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/2238735/2073130&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案讲&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类似的话。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476dda4bfbf5d4cce097cb5b1043e190f23872ad" translate="yes" xml:space="preserve">
          <source>Inheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it's just a simple job of delegation.</source>
          <target state="translated">继承提供了直截了当的代码重用,如果不被覆盖的话,而组成则需要对每一个API进行重新编码,哪怕只是简单的委托工作。</target>
        </trans-unit>
        <trans-unit id="58f31260c50c06295c28ea7e8151785985ab907c" translate="yes" xml:space="preserve">
          <source>Inheritance vs. Aggregation</source>
          <target state="translated">继承与聚合的关系</target>
        </trans-unit>
        <trans-unit id="e4add19dff6bf1f83b08edd6c883185779e798ed" translate="yes" xml:space="preserve">
          <source>Is your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.</source>
          <target state="translated">你的类是否属于多态性结构的一部分?例如,如果你有一个Shape类,它声明了一个叫做draw()的方法,那么我们显然需要Circle和Square类是Shape的子类,这样它们的客户端类就会依赖于Shape而不是特定的子类。</target>
        </trans-unit>
        <trans-unit id="bfe3497c44aa76555ec280d12b36758df5b4f30f" translate="yes" xml:space="preserve">
          <source>It establishes a logical &quot;&lt;strong&gt;IS A&quot;&lt;/strong&gt; relation. If &lt;em&gt;Car&lt;/em&gt; and &lt;em&gt;Truck&lt;/em&gt; are two types of &lt;em&gt;Vehicle&lt;/em&gt; ( base class), child class &lt;strong&gt;IS A&lt;/strong&gt; base class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它建立逻辑&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IS A&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关系。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;汽车&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;卡车&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;车辆的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（基本类），则子类为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IS A&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本类。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="896d22608075a950c42470104324b7925c60561d" translate="yes" xml:space="preserve">
          <source>It is often said that a class &lt;code&gt;Bar&lt;/code&gt; can inherit a class &lt;code&gt;Foo&lt;/code&gt; when the following sentence is true:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;人们常说，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当以下句子为真时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以继承类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34e84b66db1164cc20f4c06d7a6b4d4b98054d53" translate="yes" xml:space="preserve">
          <source>It looks like a nice idea, but in many cases it's better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.</source>
          <target state="translated">这看起来是个不错的想法,但在很多情况下,仅仅给类一个实现了foo()的对象(甚至可以手动设置提供的值foo())比从一些需要指定函数foo()的基类中继承新类要好。</target>
        </trans-unit>
        <trans-unit id="0325327f4aa9142c3fd02e3a934a008c92e7171d" translate="yes" xml:space="preserve">
          <source>It sounds great, but in practice it almost never, ever works, for one of several reasons:</source>
          <target state="translated">这听起来很好,但在实际操作中,它几乎从来没有,永远也不会起作用,原因有以下几个。</target>
        </trans-unit>
        <trans-unit id="f8a7ea6e944d4c6b1135e3b5b710351923f2b191" translate="yes" xml:space="preserve">
          <source>Its totally depend on entity relationship.</source>
          <target state="translated">其完全取决于实体关系。</target>
        </trans-unit>
        <trans-unit id="9aa3aeed06309616a463e707f18bc9934bea552e" translate="yes" xml:space="preserve">
          <source>Just so you know, another method used to determine whether inheritance is possible  is called the &lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;Liskov Substitution Principle&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;众所周知，另一种用于确定继承是否可能的方法称为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Liskov替代原理&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5197c78c69bc09836bc35c15c3eef5138da931c2" translate="yes" xml:space="preserve">
          <source>Liskov Substitution Principle</source>
          <target state="translated">利斯科夫替代原理</target>
        </trans-unit>
        <trans-unit id="d422e9f26503f80de1cff472c1db2f215fa1702a" translate="yes" xml:space="preserve">
          <source>Methods shall be either abstract or final</source>
          <target state="translated">方法应是抽象的或最终的</target>
        </trans-unit>
        <trans-unit id="ac55c0bd23a1f1346ee8d2c06328fa87ad445ad8" translate="yes" xml:space="preserve">
          <source>My acid test for the above is:</source>
          <target state="translated">我对上述的酸度测试是:</target>
        </trans-unit>
        <trans-unit id="9981ec34a9c592b0920bf23bf8fac06054f08043" translate="yes" xml:space="preserve">
          <source>My general rule of thumb: &lt;em&gt;Before using inheritance, consider if composition makes more sense.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的一般经验法则：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在使用继承之前，请考虑组合是否更有意义。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db3f86242cf06a42d0939d0152ef62fe2f01bab2" translate="yes" xml:space="preserve">
          <source>My take on what to do, if you do allow for inheritance, which you may
  take with a grain of salt is:</source>
          <target state="translated">我的看法是,如果你真的允许继承,你可以带着一粒盐去继承,那该怎么做。</target>
        </trans-unit>
        <trans-unit id="fdcdd0dea9447d0f926949cde5bf20294722ed01" translate="yes" xml:space="preserve">
          <source>Now say you want to create a Manager type so you end up with:</source>
          <target state="translated">现在说你想创建一个经理类型,所以你最终会有。</target>
        </trans-unit>
        <trans-unit id="f67f8e82998175522142525ba912b4ae6be97e09" translate="yes" xml:space="preserve">
          <source>Now your aircraft can start with having fixed wings</source>
          <target state="translated">现在你的飞机可以开始拥有固定翼了</target>
        </trans-unit>
        <trans-unit id="3fdddf6d088be0ec0a4568052a16a437fcc42087" translate="yes" xml:space="preserve">
          <source>Now, I can replace my engine on the fly as well.</source>
          <target state="translated">现在,我也可以把发动机换成飞的了。</target>
        </trans-unit>
        <trans-unit id="832d28133a55725f1ed6e5888b63068210a2853f" translate="yes" xml:space="preserve">
          <source>On the other hand &lt;b&gt;Object composition&lt;/b&gt; is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other's protected data (no encapsulation break) and will be forced to respect each other's interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象组成&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是在运行时通过对象获取对其他对象的引用来定义的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，这些对象将永远无法访问彼此的受保护数据（没有封装中断），并且将被迫尊重彼此的接口。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，在这种情况下，实现依赖将比继承的情况少很多。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c7b128050c901c022cde5fd0d94700144c01c7a" translate="yes" xml:space="preserve">
          <source>On the other hand when you have &lt;strong&gt;has-a&lt;/strong&gt; or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，当您&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在两个班级（学生开设课程）或（老师学习课程）之间&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有某种&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或某种形容词关系时，您选择了作文。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5aa7d08c0a1cf9428cca33805b546bb71b9e85d3" translate="yes" xml:space="preserve">
          <source>One example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn't use inheritance given that you don't want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.</source>
          <target state="translated">这方面的一个例子。你想从List中创建一个Stack。Stack只有pop、push和peek功能。你不应该使用继承,因为你不希望在一个Stack里有push_back、push_front、removeAt等功能。</target>
        </trans-unit>
        <trans-unit id="c15fc0f907136cf0672eb8daba99647310e8c8f3" translate="yes" xml:space="preserve">
          <source>Our Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!</source>
          <target state="translated">我们的Set of integers类是List of Integers的一个子类,但不是一个子类型,由于它不满足List类的所有特征。值,以及方法的签名都满足,但属性却不满足。add(Integer)方法的行为已经明显改变了,没有保留父类型的属性。站在你的类的客户端的角度思考一下。他们可能会接收到一个Set of integers,而在这里期望的是一个List of integers。客户端可能希望添加一个值,并得到这个值被添加到List中,即使这个值已经存在于List中。但是,如果这个值存在,她就不会得到这个行为。这让她大吃一惊!</target>
        </trans-unit>
        <trans-unit id="c1ba9f43aacc5af4e732994e2cf99330626de110" translate="yes" xml:space="preserve">
          <source>Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn't know any such thing, you'll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.</source>
          <target state="translated">就我个人而言,我学会了永远喜欢使用组成式而不是继承式。没有什么程序性的问题是你用继承可以解决的,而你不能用组成解决的;尽管在某些情况下你可能不得不使用Interfaces(Java)或Protocols(Obj-C)。因为C++不知道这些东西,所以你必须使用抽象基类,这意味着你不能在C++中完全摆脱继承。</target>
        </trans-unit>
        <trans-unit id="09ac00419cae691f7272de0fcf67b357fbda9a77" translate="yes" xml:space="preserve">
          <source>Prefer composition over inheritance</source>
          <target state="translated">继承权优先于继承权</target>
        </trans-unit>
        <trans-unit id="ee0347cbc9ba866cc7d164011ffab0691b350235" translate="yes" xml:space="preserve">
          <source>Procedural Code</source>
          <target state="translated">程序性法规</target>
        </trans-unit>
        <trans-unit id="e723b4eaeeb9a79c6611a9a222aeb92911a3f411" translate="yes" xml:space="preserve">
          <source>Reason: &lt;em&gt;Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原因：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子类化通常意味着更多的复杂性和联系性，即更容易更改，维护和扩展而不犯错误。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b27176c7cd1d943a977fdce1ee934c4c1feeb14" translate="yes" xml:space="preserve">
          <source>See other answers.</source>
          <target state="translated">查看其他答案。</target>
        </trans-unit>
        <trans-unit id="8719dca4ec3565d3812b57bd3de8cc2af492bfeb" translate="yes" xml:space="preserve">
          <source>So for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.</source>
          <target state="translated">所以在我看来,如果有人不知道自己是需要继承还是需要构成,真正的问题是不知道自己是要喝酒还是要吃饭。多想想你的问题域,多理解一下你的问题域。</target>
        </trans-unit>
        <trans-unit id="5e46fa089d47708f97cac794ca257e6960b4ed16" translate="yes" xml:space="preserve">
          <source>So only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.</source>
          <target state="translated">因此,只有当子类型的目的是为了以后使用新类的多态性时,我们才会面临选择继承还是组成的问题。这就是我们讨论中的短语中被省略的假设。</target>
        </trans-unit>
        <trans-unit id="38f67df16186ea732f8e64c3dc6f62ebcca5e137" translate="yes" xml:space="preserve">
          <source>So, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use &lt;strong&gt;Composition&lt;/strong&gt;: Refer to &lt;a href=&quot;http://www.dofactory.com/Patterns/PatternState.aspx&quot;&gt;State&lt;/a&gt; and &lt;a href=&quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx&quot;&gt;Strategy&lt;/a&gt; Design Patterns.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果您的对象需要显示为不同的对象或根据对象的状态或行为而有所不同，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组成&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.dofactory.com/Patterns/PatternState.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;状态&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;策略&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设计模式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="549f8d9bac9806f318f15d88f433b6bc397447c1" translate="yes" xml:space="preserve">
          <source>Sub-class adds extension to base class implementation by calling super.methodName() as first statement =&amp;gt; &lt;strong&gt;&lt;em&gt;You can extend a contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子类通过调用super.methodName（）作为第一条语句为基础类实现添加扩展，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以扩展合同&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2edf57dc395184ef34315b418a2b088ba9c59312" translate="yes" xml:space="preserve">
          <source>Subclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.</source>
          <target state="translated">子类和子类型不一样。你可能会创建不是子类型的子类(这时你应该使用composition)。为了理解什么是子类型,我们先来解释一下什么是类型。</target>
        </trans-unit>
        <trans-unit id="6280068eb73b4991a7ab571fc93fcf217f265813" translate="yes" xml:space="preserve">
          <source>Subtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Let&amp;rsquo;s go to see some code to exemplify what I&amp;rsquo;m saying. Suppose I write a List of integers (in some sort of pseudo language):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子类型也是一种类型，它与另一个类型有关系，称为父类型（或超类型）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子类型必须满足父类型的特征（值，方法和属性）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该关系意味着在期望超类型的任何上下文中，它都可以被子类型替代，而不会影响执行的行为。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我们来看一些代码来举例说明我的意思。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设我写了一个整数列表（用某种伪语言）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6887946e4c5b4415b62320ae3947b236c9c5c713" translate="yes" xml:space="preserve">
          <source>Subtyping is appropriate and more powerful where the &lt;a href=&quot;https://stackoverflow.com/a/8352969&quot;&gt;invariants can be enumerated&lt;/a&gt;, else use function composition for extensibility.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/8352969&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以枚举不变量的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;地方，子类型化是适当的并且功能更强大&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，否则，使用函数组合来实现可扩展性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e98d1b95929689559f3d4c93532fcfbd040d69e9" translate="yes" xml:space="preserve">
          <source>Suppose an aircraft has only two parts: an engine and wings.</source>
          <target state="translated">假设一架飞机只有两部分:发动机和机翼。</target>
        </trans-unit>
        <trans-unit id="748d9e332cb80d932e28118f49b5638ba8eaee06" translate="yes" xml:space="preserve">
          <source>The Manager object is composed as an Employee and a Person. The Title behaviour is taken from employee. This explicit composition removes ambiguity among other things and you'll encounter fewer bugs.</source>
          <target state="translated">管理者对象由雇员和个人组成。Title行为取自于雇员。这种明确的构成,消除了其他方面的模糊性,你会遇到更少的BUG。</target>
        </trans-unit>
        <trans-unit id="81ed2eb88eaa37fdff388424251ce97e077ced4c" translate="yes" xml:space="preserve">
          <source>The antidote is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;Single Responsibility Principle&lt;/a&gt;. Think of it as a constraint. My class &lt;em&gt;must&lt;/em&gt; do one thing. I &lt;em&gt;must&lt;/em&gt; be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we're learning.) It follows that I cannot write a base class called &lt;code&gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses&lt;/code&gt;. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, &lt;em&gt;not&lt;/em&gt; inherit from it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解毒剂是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单一责任原则&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。将其视为约束。我班上&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做一件事。我&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;能够给班级一个名称，以某种方式描述它所做的一件事情。 （所有情况都有例外，但是当我们学习时，绝对规则有时会更好。）因此，我无法编写名为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的基类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。无论我需要什么独特的功能，都必须在其自己的类中，然后其他需要该功能的类可以依赖于该类，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="756c9ed98907d3961cd495c08dfc9ecbac6456d9" translate="yes" xml:space="preserve">
          <source>The article, &lt;a href=&quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/&quot;&gt;Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder&lt;/a&gt;, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文章&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Inheritance is Evil：DataAnnotationsModelBinder的史诗失败，逐步介绍&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了C＃中的一个示例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它显示了应在使用合成时使用继承的方式以及如何对其进行重构。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f0cb63e7db6c559e277c0e6f5e0b14d3af0a76f" translate="yes" xml:space="preserve">
          <source>The composition has a real edge here: the relationship can be reversed: the &quot;parent class&quot; or &quot;abstract worker&quot; can aggregate any specific &quot;child&quot; objects implementing certain interface + &lt;strong&gt;any child can be set inside any other type of parent, which accepts it's type&lt;/strong&gt;. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement &quot;foo()&quot; and other group of objects which can make use of objects having &quot;foo()&quot; can play together.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种组合在这里具有真正的优势：这种关系可以颠倒：&amp;ldquo;父类&amp;rdquo;或&amp;ldquo;抽象工作者&amp;rdquo;可以聚合实现特定接口的任何特定&amp;ldquo;子&amp;rdquo;对象+ &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以在任何其他类型的父内部设置任何子，它是type&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且可以有任意数量的对象，例如MergeSort或QuickSort可以对实现抽象Compare接口的对象列表进行排序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;换句话说，实现&amp;ldquo; foo（）&amp;rdquo;的任何对象组和可以利用具有&amp;ldquo; foo（）&amp;rdquo;的对象的其他对象组都可以一起玩。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="33595de1c584d88b32800d1fcaf74682bd919860" translate="yes" xml:space="preserve">
          <source>The first test ensures that all &lt;em&gt;getters&lt;/em&gt; of &lt;code&gt;Foo&lt;/code&gt; make sense in &lt;code&gt;Bar&lt;/code&gt; (= shared properties), while the second test makes sure that all &lt;em&gt;setters&lt;/em&gt; of &lt;code&gt;Foo&lt;/code&gt; make sense in &lt;code&gt;Bar&lt;/code&gt; (= shared functionality).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一测试确保了所有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的吸气剂&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中有意义&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（=共享属性），而在第二测试确保所有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设置器&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中有意义&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（=共享的功能）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3af0b301854a243ae48ec4eb1b17706b1a405f" translate="yes" xml:space="preserve">
          <source>The issue with inheritance is that it can be used for two orthogonal purposes:</source>
          <target state="translated">继承的问题在于,它可以用于两个正交的目的。</target>
        </trans-unit>
        <trans-unit id="fef004bb30a4e0c238ab2b8425780e54d9f658d4" translate="yes" xml:space="preserve">
          <source>The main reason for using inheritance is not as a form of composition - it is so you can get polymorphic behaviour. If you don't need polymorphism, you probably should not be using inheritance.</source>
          <target state="translated">使用继承的主要原因不是作为一种组成形式,而是为了让你可以获得多态性。如果你不需要多态性,你可能不应该使用继承。</target>
        </trans-unit>
        <trans-unit id="eb4e58f56ade41db120e0e321541a267008d9df9" translate="yes" xml:space="preserve">
          <source>The tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.</source>
          <target state="translated">继承所提供的紧密耦合性使得子类的实现与超类的实现非常绑定,父类实现的任何改变都会迫使子类改变。</target>
        </trans-unit>
        <trans-unit id="c6e1071aed30be94da0e2cdf87f2e045c58cf0cd" translate="yes" xml:space="preserve">
          <source>Then there are two ways to design an aircraft class.</source>
          <target state="translated">那么,设计一个飞机级别有两种方法。</target>
        </trans-unit>
        <trans-unit id="1377e93559cb9cad4550161694e59ceef28236fd" translate="yes" xml:space="preserve">
          <source>Then, I write the Set of integers as a subclass of the List of integers:</source>
          <target state="translated">那么,我把整数集写成了整数列表的子类。</target>
        </trans-unit>
        <trans-unit id="ba41722cdbc379b118c4e701663ebf832365813b" translate="yes" xml:space="preserve">
          <source>There are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren't necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the &lt;em&gt;DRY Principle&lt;/em&gt; (DRY = Don't Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such &quot;double method calls&quot; (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，在组合方面也有缺点。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您完全跳过继承而只关注合成，您会发现您经常不得不编写一些额外的代码行，如果您使用了继承，则这些代码行是不必要的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您有时还被迫重复自己，这违反了&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DRY原则&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（干=不要重复自己）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，合成通常需要委托，而一个方法只是调用另一个对象的另一个方法，而此调用周围没有其他代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样的&amp;ldquo;双重方法调用&amp;rdquo;（可能会很容易地扩展到三重或四重方法调用，甚至更远），其性能比继承要差得多，在继承中，您仅继承父方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用继承的方法可能与调用非继承的方法一样快，或者可能稍慢一些，但通常仍比两个连续的方法调用快。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88dbe40d0ed3ede68edda71ef3030a4c38686ece" translate="yes" xml:space="preserve">
          <source>There are two benefits of inheritance: &lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html&quot;&gt;subtyping and subclassing&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承有两个好处：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子类型化和子类化&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9613a336cd64521f866d933e120f5f900e231b8" translate="yes" xml:space="preserve">
          <source>There is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.</source>
          <target state="translated">使用理由1并没有什么不好,在你的对象上有一个稳固的接口是非常好的事情。这可以通过使用组成或继承来实现,没有问题--如果这个接口很简单,而且不会改变的话。通常情况下,继承在这里是相当有效的。</target>
        </trans-unit>
        <trans-unit id="2ff1e38501fc05dc5ab2089683a417fc9d8ae800" translate="yes" xml:space="preserve">
          <source>These two ways can live together just fine and actually support each other.</source>
          <target state="translated">这两种方式在一起生活就好,实际上是可以互相扶持的。</target>
        </trans-unit>
        <trans-unit id="96a0b8fbc97ccd7232afaf128e1f72ba9c64d8fe" translate="yes" xml:space="preserve">
          <source>Think of containment as a &lt;strong&gt;has a&lt;/strong&gt; relationship. A car &quot;has an&quot; engine, a person &quot;has a&quot; name, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将遏制视为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关系。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;汽车&amp;ldquo;具有&amp;rdquo;引擎，人&amp;ldquo;具有&amp;rdquo;名称，等等。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b6ec4f6260ad4a41e813b5819357d4fdd59cd6e" translate="yes" xml:space="preserve">
          <source>Think of inheritance as an &lt;strong&gt;is a&lt;/strong&gt; relationship. A car &quot;is a&quot; vehicle, a person &quot;is a&quot; mammal, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;想继承的作为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关系。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;汽车&amp;ldquo;是&amp;rdquo;车辆，人&amp;ldquo;是&amp;rdquo;哺乳动物，等等。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66d70c1014e5da803fb71e6a40877d96f60ee637" translate="yes" xml:space="preserve">
          <source>This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).</source>
          <target state="translated">这就鼓励了类的使用。继承是OO设计的三大原则(继承、多态、封装)之一。</target>
        </trans-unit>
        <trans-unit id="02d27b966f445c927c12a951352c5a2ee16cc24d" translate="yes" xml:space="preserve">
          <source>This example will work fine, however, what if Person and Employee both declared &lt;code&gt;Title&lt;/code&gt;? Should Manager.Title return &quot;Manager of Operations&quot; or &quot;Mr.&quot;? Under composition this ambiguity is better handled:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此示例可以正常工作，但是，如果Person和Employee都声明&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Title&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;怎么办？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Manager.Title是否应返回&amp;ldquo;运营经理&amp;rdquo;或&amp;ldquo;先生&amp;rdquo;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在组成下，这种歧义可以更好地解决：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bdb26a327b7e7a1f89230942d7086df40a2044bb" translate="yes" xml:space="preserve">
          <source>This is a classic example of an improper use of inheritance. Use composition in this case.</source>
          <target state="translated">这是一个典型的继承使用不当的例子。在这种情况下,使用组成。</target>
        </trans-unit>
        <trans-unit id="892eb23b0e64d101eac60b59156102e0dc8377de" translate="yes" xml:space="preserve">
          <source>This is called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;Circle-Ellipse problem&lt;/a&gt;, which really isn't a problem, just a clear proof that the first test alone isn't enough to conclude that inheritance is possible. In particular, this example highlights that derived classes should &lt;em&gt;extend&lt;/em&gt; the functionality of base classes, never &lt;em&gt;restrict&lt;/em&gt; it. Otherwise, the base class couldn't be used polymorphically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这被称为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Circle-Ellipse问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这实际上不是问题，只是一个明确的证明，仅第一个测试不足以得出继承是可能的结论。特别是，该示例强调了派生类应&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;扩展&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基类的功能，而从不对其进行&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;限制&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。否则，基类不能被多态使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c1a3f007444e788c520debfe97ad582556ee1e" translate="yes" xml:space="preserve">
          <source>This is inheritance at work. The Employee &quot;is a&quot; Person or inherits from Person. All inheritance relationships are &quot;is-a&quot; relationships. Employee also shadows the Title property from Person, meaning Employee.Title will return the Title for the Employee not the Person.</source>
          <target state="translated">这就是工作中的继承。雇员 &quot;是一个 &quot;Person或从Person继承。所有的继承关系都是 &quot;是-a &quot;关系。Employee也会从Person继承Title属性,也就是说Employee.Title会返回Employee的Title而不是Person。</target>
        </trans-unit>
        <trans-unit id="4bfff73a25d5d08232eb54847cfc587269729bfb" translate="yes" xml:space="preserve">
          <source>To address this question from a different perspective for newer programmers:</source>
          <target state="translated">为了解决这个问题,从不同的角度为新入行的程序员解决这个问题。</target>
        </trans-unit>
        <trans-unit id="948c2e5682be0db8695bdb1c215662f9b744cd72" translate="yes" xml:space="preserve">
          <source>To give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).</source>
          <target state="translated">再举一个例子,想想看抽象的数据类型,Set of integers和List of integers,它们能持有的值都是限制在整数的。它们都支持一组方法,比如add(newValue)和size()。而且它们都有不同的属性(类不变性),Sets不允许重复,而List允许重复(当然还有其他属性,它们都满足)。</target>
        </trans-unit>
        <trans-unit id="8dfe69d77cbdafc2b0a714261fbe7a897520f08c" translate="yes" xml:space="preserve">
          <source>To subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:</source>
          <target state="translated">子类型就是要符合一个类型签名,这就意味着组成必须暴露出不低于类型API的数量。现在,交易开始了。</target>
        </trans-unit>
        <trans-unit id="d54b82edafd720a780f59eaceb3e260ef8e20abd" translate="yes" xml:space="preserve">
          <source>To understand why &quot;&lt;em&gt;prefer&lt;/em&gt; composition over inheritance&quot;, we need first get back the assumption omitted in this shortened idiom.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要了解为什么&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;宁愿&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继承而不愿继承&amp;rdquo;，我们需要首先找回在这个简短成语中省略的假设。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30b841e646c940730a92f3a6fde8ddbb4fa7b8a7" translate="yes" xml:space="preserve">
          <source>Unfortunately, the above test alone is not reliable. Use the following instead:</source>
          <target state="translated">遗憾的是,仅靠上述测试并不可靠。请用下面的方法来代替。</target>
        </trans-unit>
        <trans-unit id="902e9220c7e8e78a1688a9c75dc574c63e2d44d9" translate="yes" xml:space="preserve">
          <source>We discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, &quot;If I'm inherited type A, do this, but if I'm inherited type B, do that.&quot; That's bad for lots of reasons. One is that every time we change the base class, we're effectively changing every inherited class. So we're really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.</source>
          <target state="translated">我们发现,仅仅对于继承自基类的其中一个类,我们希望基类的行为有点不一样。所以现在我们回去修改我们的基类,也许会增加一些虚拟方法,或者更糟糕的是,一些代码说:&quot;如果我是继承类型A,就做这个,但如果我是继承类型B,就做那个。&quot; 这是很糟糕的,原因有很多。其中一个原因是,每当我们改变基类时,我们实际上就是在改变每一个继承类。所以,我们实际上是在改变A类、B类、C类和D类,因为我们需要A类中的行为略有不同。</target>
        </trans-unit>
        <trans-unit id="6227a652268bd11d1b6cbf24ac145873c6174ca7" translate="yes" xml:space="preserve">
          <source>We discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?</source>
          <target state="translated">我们发现,还有一些其他的功能是我们希望我们的类能够拥有的。如果我们给类添加功能的方式是通过继承的方式,那么我们必须决定----即使不是每个继承的类都需要这个功能,我们是否要把它添加到现有的基类中?我们要不要再创建一个基类?但对于已经从另一个基类中继承的类呢?</target>
        </trans-unit>
        <trans-unit id="e2615b408bdb1e0ba98c485bf5cdf2441399a639" translate="yes" xml:space="preserve">
          <source>We might know why we decided to make all of these classes inherit from each other, but it might not (probably won't) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.</source>
          <target state="translated">我们可能知道为什么我们决定让所有这些类相互继承,但对于必须维护我们的代码的其他人来说,这可能并不(可能不会)有意义。我们可能会迫使他们陷入一个艰难的选择--我是做一些非常丑陋和混乱的事情来实现我所需要的改变(见前面的弹出点),还是直接重写一堆这样的东西。</target>
        </trans-unit>
        <trans-unit id="0e5823e905840f2d1a0b16c41e23924b6b4651bd" translate="yes" xml:space="preserve">
          <source>What do you think about this approach?</source>
          <target state="translated">对于这种做法,你怎么看?</target>
        </trans-unit>
        <trans-unit id="c1756bd1b9efd32a1d214b99f06d2f7a4f7d669c" translate="yes" xml:space="preserve">
          <source>When can you use inheritance?</source>
          <target state="translated">什么时候可以使用继承?</target>
        </trans-unit>
        <trans-unit id="d970be0b61d6aad200582d59cc11f107fad3f0af" translate="yes" xml:space="preserve">
          <source>When should you use inheritance?</source>
          <target state="translated">什么时候应该使用继承?</target>
        </trans-unit>
        <trans-unit id="428208f05c644812526e760213d893a9e0d85b4f" translate="yes" xml:space="preserve">
          <source>When we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.</source>
          <target state="translated">当我们说数字5是整数类型时,我们是在说明5属于一个可能的值集(作为一个例子,请看Java基元类型的可能值)。我们也是在说明有一组有效的方法可以对这个值执行加法和减法等方法。最后我们声明有一组属性总是满足的,例如,如果我把值3和5相加,就会得到8作为结果。</target>
        </trans-unit>
        <trans-unit id="09af7bb65f1be8d511ca24f115a8de295966a370" translate="yes" xml:space="preserve">
          <source>When you have an &lt;strong&gt;is-a&lt;/strong&gt; relation between two classes (example dog is a canine), you go for inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当你有一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是，一个&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两个类（例如狗是犬科动物）之间的关系，你去继承。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0055b1a10a69cdf90f2c9f52386c2e6f796966" translate="yes" xml:space="preserve">
          <source>When you want to &quot;copy&quot;/Expose the base class' API, you use inheritance. When you only want to &quot;copy&quot; functionality, use delegation.</source>
          <target state="translated">当你想 &quot;复制 &quot;暴露基类的API时,就使用继承。当你只想 &quot;复制 &quot;功能的时候,就使用授权。</target>
        </trans-unit>
        <trans-unit id="68d2706b23183a0d7d52371d8dfbf231a40a8ff7" translate="yes" xml:space="preserve">
          <source>Whether the base class can be instantiated. That is, whether the base class can be non-abstract.  If it can be non-abstract I usually prefer composition</source>
          <target state="translated">基类是否可以被实例化。也就是说,基类是否可以非抽象。如果可以是非抽象的,我通常更喜欢用component</target>
        </trans-unit>
        <trans-unit id="a606c7a3b25e33c0493da4afddb01b3c57747671" translate="yes" xml:space="preserve">
          <source>Which class design is better?</source>
          <target state="translated">哪种班级设计比较好?</target>
        </trans-unit>
        <trans-unit id="b1791d8464070d229c878a59d0498e929cd34625" translate="yes" xml:space="preserve">
          <source>While in short words I would agree with &quot;Prefer composition over inheritance&quot;, very often for me it sounds like &quot;prefer potatoes over coca-cola&quot;. There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is &quot;if you are going to use inheritance - think again, chances are you need composition&quot;.</source>
          <target state="translated">虽然简而言之,我会同意 &quot;宁可作文,也不要继承 &quot;的说法,但很多时候对我来说,这听起来就像 &quot;宁可吃土豆,也不要喝可乐&quot;。继承有继承的地方,构成也有构成的地方。你需要理解区别,那么这个问题就会消失。对我来说,它真正的意思是 &quot;如果你要用继承--再想一想,很可能你需要作曲&quot;。</target>
        </trans-unit>
        <trans-unit id="027a582c02cb725a52172159b5c1aa8f207673db" translate="yes" xml:space="preserve">
          <source>Why prefer composition over inheritance?</source>
          <target state="translated">为什么偏重于继承的成分,而不是继承?</target>
        </trans-unit>
        <trans-unit id="28ebe126ef18993fcdc302fb140fe416bf4b44bd" translate="yes" xml:space="preserve">
          <source>Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?</source>
          <target state="translated">为什么偏向于组成法而不是继承法?每种方法都有哪些权衡?什么时候应该选择继承而不是组成式?</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="8a5494e3346ea1f03b16a7e69409337675dba6a2" translate="yes" xml:space="preserve">
          <source>With all the undeniable benefits provided by inheritance, here's some of its disadvantages.</source>
          <target state="translated">不可否认的是,继承的好处有很多,下面是它的一些弊端。</target>
        </trans-unit>
        <trans-unit id="187b043aa54e89394b8d77a7ea3e521335e23aa7" translate="yes" xml:space="preserve">
          <source>With inheritance, you can define/modify/extend a capability</source>
          <target state="translated">有了继承,你可以定义一个能力的定义、修改和扩展。</target>
        </trans-unit>
        <trans-unit id="c909e0bb35edebdb81f6b7167ac08348fb47388c" translate="yes" xml:space="preserve">
          <source>With the above trade offs in mind, we hence &lt;em&gt;prefer&lt;/em&gt; composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑到上述折衷因素，因此我们&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更倾向于使用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组合而不是继承。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是对于紧密相关的类，即当隐式代码重用确实能带来好处，或者需要开放递归的神奇力量时，继承将是选择。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca54eb74c9e8cc45b664e45d5cd2d030838c910b" translate="yes" xml:space="preserve">
          <source>With the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.</source>
          <target state="translated">有了这两个好处,就带来了做继承的两个不同目的:面向子类型和面向代码重用的代码。</target>
        </trans-unit>
        <trans-unit id="c6f46fcaef29ad747c9c053a5250628a59ec8937" translate="yes" xml:space="preserve">
          <source>You can't change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).</source>
          <target state="translated">你不能在运行时改变从超级类继承的实现(显然是因为继承是在编译时定义的)。</target>
        </trans-unit>
        <trans-unit id="c841ca97d91f3a90e4a981be8a8e3eaf9eca4bee" translate="yes" xml:space="preserve">
          <source>You have many classes with &lt;strong&gt;same interface&lt;/strong&gt; and you want to save time writing them</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您有许多具有&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同接口的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且您想节省编写它们的时间&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f7027c12ff7351a14aec7ceaf153b91f1cd5a76" translate="yes" xml:space="preserve">
          <source>You have to use same Base Class for each object</source>
          <target state="translated">你必须对每个对象使用相同的基类。</target>
        </trans-unit>
        <trans-unit id="db9d5b717fd3a0428e874979b657d64399fb0932" translate="yes" xml:space="preserve">
          <source>You may have noticed that most OO languages don't allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think &quot;multiple inheritance would be a really cool feature to solve this problem&quot;, you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.</source>
          <target state="translated">你可能已经注意到,大多数OO语言不允许多重继承。虽然有一些情况下,多重继承确实可以为你买到一些东西,但这些都是特例而不是规则。每当你遇到这样的情况时,你会认为 &quot;多重继承将是一个非常酷的功能来解决这个问题&quot;,你通常都应该重新考虑一下继承的问题,因为即使它可能需要额外增加几行代码,但基于组合的解决方案通常会更优雅、更灵活、更有未来感。</target>
        </trans-unit>
        <trans-unit id="6461c7d3d8ea98d44e07224509d8188c5fd65616" translate="yes" xml:space="preserve">
          <source>You need to have a look at &lt;strong&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;The Liskov Substitution Principle&lt;/a&gt;&lt;/strong&gt; in Uncle Bob's &lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;SOLID&lt;/a&gt; principles of class design. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要查看&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bob叔叔的&lt;/font&gt;&lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SOLID&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类设计&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原则&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的Liskov替代原则&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:)&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="365fd5a8c9d353531398ff13dddbb1a9cd04bd1f" translate="yes" xml:space="preserve">
          <source>You need to modify the private variables, which can not be public in any case</source>
          <target state="translated">你需要修改私有变量,在任何情况下都不能是公共变量</target>
        </trans-unit>
        <trans-unit id="debc0fa37d0f792340965981a5a035cc009e22ae" translate="yes" xml:space="preserve">
          <source>You should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.</source>
          <target state="translated">想吃东西的时候,应该选择土豆而不是可乐,想喝东西的时候,应该选择可乐而不是土豆。</target>
        </trans-unit>
        <trans-unit id="70a3f516785b8d2c0cef4b9bfa90e997156cdb0e" translate="yes" xml:space="preserve">
          <source>Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.</source>
          <target state="translated">你的基类通过将实现细节以protected members的形式暴露给子类来打破封装。这使得你的系统变得僵化和脆弱。然而更悲剧的缺陷是,新的子类带来了继承链的所有包袱和意见。</target>
        </trans-unit>
        <trans-unit id="a7b6ec9ba3ba6cb389d0be77dde1a3a2b1b3c784" translate="yes" xml:space="preserve">
          <source>a bar is a foo</source>
          <target state="translated">杠杠是一个Foo</target>
        </trans-unit>
        <trans-unit id="321619efe153470d82ced208ab3b5924f96e157d" translate="yes" xml:space="preserve">
          <source>a bar is a foo, &lt;strong&gt;AND&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;酒吧是foo，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e151551bf5c2dbfb47e6ba04d1cb6d6f9881994" translate="yes" xml:space="preserve">
          <source>all of this applies less to small projects than large ones, and less
  to private classes than public ones</source>
          <target state="translated">这一切对小项目不如大项目,对私人班不如公班</target>
        </trans-unit>
        <trans-unit id="7704fccffa58783a84da4eb8c0166fdf191a3fdd" translate="yes" xml:space="preserve">
          <source>an engine with wings. But what if I wanted to change</source>
          <target state="translated">一个有翅膀的发动机。但是,如果我想改变</target>
        </trans-unit>
        <trans-unit id="8dde7711f9ea3766728a62f96c6515f11ba48445" translate="yes" xml:space="preserve">
          <source>and change them to rotary wings on the fly. It's essentially</source>
          <target state="translated">并在飞行时将其改成旋转翼。它的本质是</target>
        </trans-unit>
        <trans-unit id="729852eb34a3e850ade763665925935482786102" translate="yes" xml:space="preserve">
          <source>bars can do everything that foos can do.</source>
          <target state="translated">吧台可以做所有Foos能做的事情。</target>
        </trans-unit>
        <trans-unit id="6b17efef870e73ac5a6927dfab46f89a43147e20" translate="yes" xml:space="preserve">
          <source>e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.</source>
          <target state="translated">例如:A Bird可能只需要Airplane的飞行行为。在这种情况下,将其作为接口类提取出来,并使其成为这两个类的成员是有意义的。</target>
        </trans-unit>
        <trans-unit id="886bf306e5453e891f922ec6a0c0d688fc89e7b2" translate="yes" xml:space="preserve">
          <source>e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane.</source>
          <target state="translated">如:塞斯纳双翼飞机将暴露出飞机的完整接口,如果不是更多的话。所以,这使得它适合从Airplane派生。</target>
        </trans-unit>
        <trans-unit id="696ad70d6976b57faf133b6ee5ef5b78578b56f1" translate="yes" xml:space="preserve">
          <source>e.g. If  &lt;em&gt;Car&lt;/em&gt; contains &lt;em&gt;Vehicle&lt;/em&gt; and if you have to get price of the &lt;em&gt;Car&lt;/em&gt;, which has been defined in &lt;em&gt;Vehicle&lt;/em&gt;, your code will be like this</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，如果 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Car&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Vehicle&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且您必须获取&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Vehicle中&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Car的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;价格，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的代码将如下所示&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="1fc4018d629a16d759e998a6c95e3a4757b18a87" translate="yes" xml:space="preserve">
          <source>implementation (for code reuse)</source>
          <target state="translated">实现</target>
        </trans-unit>
        <trans-unit id="8242e2b420f05d62490ce28c67966e458a29c56a" translate="yes" xml:space="preserve">
          <source>inheritance is probably the worst form of coupling you can have</source>
          <target state="translated">继承可能是你可以有的最糟糕的耦合形式。</target>
        </trans-unit>
        <trans-unit id="f2804e2e271f82c68b66f986da5df262ee4cb967" translate="yes" xml:space="preserve">
          <source>interface (for polymorphism)</source>
          <target state="translated">多态性界面</target>
        </trans-unit>
        <trans-unit id="13ac262839d95d773d2a3d28f3999d812e21769b" translate="yes" xml:space="preserve">
          <source>properties, or I redesign &lt;code&gt;Aircraft&lt;/code&gt; as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;属性，或者我将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Aircraft&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重新设计&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8823f52bf571c1ac1f5e036a349bdba206f867f6" translate="yes" xml:space="preserve">
          <source>the engine on the fly as well?</source>
          <target state="translated">发动机也在飞的时候?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
