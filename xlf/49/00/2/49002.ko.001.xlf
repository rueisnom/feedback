<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/49002">
    <body>
      <group id="49002">
        <trans-unit id="19e4a51166cdfb3ff9a0baa3e1422bffe26ed5b1" translate="yes" xml:space="preserve">
          <source>(a fragment from: &lt;a href=&quot;http://www.copypasteisforword.com/notes/use-inheritance-properly&quot;&gt;use inheritance properly&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(의 조각 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.copypasteisforword.com/notes/use-inheritance-properly&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 올바르게 사용하십시오&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3cf3c58c0ff1ab151c796159d9fba6934da34ccd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Wikipedia&lt;/a&gt; offers a nice overview of the topic being discussed in this question.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는이 질문에서 다루고있는 주제에 대한 훌륭한 개요를 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84d22270db5c3c635539d2d8ae442c8752d70e66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Car is a Vehicle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동차는 차량입니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc60060a7f66a3c1423f56735ed1401baf4fbfea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Classes get heavier&lt;/em&gt; - you don't necessarily know what work your superclass is doing in its constructor, or how much memory it's going
  to use. So constructing some innocent would-be lightweight object can
  be far more expensive than you think, and this may change over time if
  the superclass evolves</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스가 더 무겁습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 수퍼 클래스가 생성자에서 어떤 작업을 수행하는지 또는 얼마나 많은 메모리를 사용할지 반드시 알 필요는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 무고한 가벼운 객체를 만드는 것은 생각보다 훨씬 비쌀 수 있으며 수퍼 클래스가 진화하면 시간이 지남에 따라 변경 될 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd3b79af469cff75a228b80ca85b2a0c9d81150b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Innocent acts can have unexpected results&lt;/em&gt; - The classic example of this is calls to overridable methods from the superclass
  constructor, before the subclasses instance fields have been
  initialized. In a perfect world, nobody would ever do that. This is
  not a perfect world.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무고한 행위는 예기치 않은 결과를 초래할 수 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이것의 전형적인 예는 서브 클래스 인스턴스 필드가 초기화되기 전에 수퍼 클래스 생성자에서 재정의 가능한 메소드를 호출하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완벽한 세상에서는 아무도 그렇게하지 않을 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 완벽한 세상이 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d09d2c9a3f2c14f6cb59dcf58a0f00d467588cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It encourages an explosion of subclasses&lt;/em&gt;. Classloading costs time, more classes costs memory. This may be a non-issue until you're
  dealing with an app on the scale of NetBeans, but there, we had real
  issues with, for example, menus being slow because the first display
  of a menu triggered massive class loading. We fixed this by moving to
  more declarative syntax and other techniques, but that cost time to
  fix as well.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 서브 클래스의 폭발을 장려합니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 클래스 로딩에는 시간이 걸리고 더 많은 클래스에는 메모리가 필요합니다. NetBeans 규모의 앱을 처리 할 때까지 이것은 문제가되지 않을 수 있지만 메뉴의 첫 번째 표시가 대규모 클래스로드를 트리거했기 때문에 메뉴가 느려지는 등 실제 문제가있었습니다. 우리는보다 선언적인 구문과 다른 기술로 이동하여이 문제를 해결했지만 수정하는 데 시간이 걸렸습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="99b00c9cf8e683fccb25eac102b209f855086a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It makes it harder to change things later&lt;/em&gt; - if you've made a class public, swapping the superclass is going to break subclasses -
  it's a choice which, once you've made the code public, you're married
  to. So if you're not altering the real functionality to your
  superclass, you get much more freedom to change things later if you
  use, rather than extend the thing you need. Take, for example,
  subclassing JPanel - this is usually wrong; and if the subclass is
  public somewhere, you never get a chance to revisit that decision. If
  it's accessed as JComponent getThePanel() , you can still do it (hint:
  expose models for the components within as your API).</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 나중에 변경 일을 어렵게 만든다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - 당신이 코드 공개 한 후, 당신이 결혼하고, 선택 - 당신은 슈퍼 클래스는 서브 클래스를 깰 것입니다 스와핑, 클래스 공개 한 경우. 따라서 실제 기능을 수퍼 클래스로 변경하지 않으면 나중에 필요한 것을 확장하지 않고 나중에 사용할 경우 훨씬 더 자유롭게 변경할 수 있습니다. 예를 들어 JPanel을 서브 클래 싱하는 경우를 생각해보십시오. 일반적으로 잘못되었습니다. 서브 클래스가 어딘가에 공개되어 있으면 그 결정을 다시 방문 할 기회가 없습니다. JComponent getThePanel ()으로 액세스하면 여전히 할 수 있습니다 (힌트 : API로 구성 요소의 모델을 노출하십시오).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9fea8abbd67148f9aaad86c2cc91e5b50984e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It offers perverse temptations for subclassers to make assumptions about order of method calls and such&lt;/em&gt; - such assumptions tend not to
  be stable if the superclass may evolve over time. See also &lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;amp;messageID=91819530#91819530&quot;&gt;my toaster
  and coffee pot analogy&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래스가 메소드 호출 순서에 대한&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가정을하는 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;등의 유혹을 제공합니다.&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이러한 가정은 수퍼 클래스가 시간이 지남에 따라 진화 할 경우 안정적이지 않은 경향이 있습니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;amp;messageID=91819530#91819530&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 토스터와 커피 포트 비유&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 도 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f2d1a02f1330761039247ff2ac486fa4bcd2963" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Object hierarchies don't scale (or making them scale later is much harder than planning ahead)&lt;/em&gt; - this is the classic &quot;too many layers&quot;
  problem. I'll go into this below, and how the AskTheOracle pattern can
  solve it (though it may offend OOP purists).</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개체 계층 구조는 확장되지 않습니다 (또는 나중에 확장하는 것이 미리 계획하는 것보다 훨씬 어렵습니다)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 이것은 고전적인 &quot;너무 많은 레이어&quot;문제입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래에서이 문제에 대해 살펴보고 AskTheOracle 패턴이이를 해결하는 방법 (OOP 순수 주의자들을 불쾌하게 할 수 있음).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de6ccea047149366a9dda9ed695b699d688314a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.&lt;/em&gt; With composition, it's easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 가능성이 높고 나중에 수정하기가 쉽지만 작성 항상 접근 방식을 사용하지 않으므로 상속보다 구성을 선호하십시오. &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션을 사용하면 Dependency Injection / Setter를 사용하여 동작을 쉽게 변경할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 언어에서는 여러 유형에서 파생 할 수 없으므로 상속이 더 엄격합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 TypeA에서 파생되면 거위는 다소 요리됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4308a41a321f00f54f99cdd2884e9094023fd662" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Truck is a Vehicle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;트럭은 차량입니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f587fb9140a968f772a8162968129fa88e330b59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cons of Composition:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성의 단점 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="790ced1c5a0bbe20b15223aa6a4e22337bfcd462" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Pros of Inheritance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속의 장점 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a69a0cc249ebb716c5b801c19b32afb8a98697dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because inheritance is a poor way of moving information&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 정보를 옮기는 데 나쁜 방법이기 때문&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="642f86d54fa53fe530b7fceb3af4325e550ae72b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages of Inheritance:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속의 단점 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30e3ffdd81cf85d5a9b7fbf8f2b5ed8777d2cb4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1: Dog --&amp;gt; Animal&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 1 : 개-&amp;gt; 동물&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08d6fcd73932e2db1e487ea9c038b47cd04b4f4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2: Circle -/-&amp;gt; Ellipse&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 2 : 원-/-&amp;gt; 타원&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22d74f86d3cbdef89198b5678344bd3b330b51a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REFERENCE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REFERENCE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01e62217f11659bf6313a453455a96ddfecb964" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subclassing&lt;/strong&gt; means implicit reuse of method implementations.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 싱은 메서드 구현의 암묵적인 재사용을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46f346af11e821ee7e1ce39993d2a8fb3fd69a7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subtyping&lt;/strong&gt; means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 타이핑&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 유형 (인터페이스) 서명, 즉 API 세트를 따르는 것을 의미하며 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 타이핑&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다형성을 달성하기 위해 서명의 일부를 무시할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="133fbefb42fa53f06d9d810164f60ab910ebfa77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov's &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; as a test for 'Should I be inheriting from this type?'</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;업데이트 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 방금 내 대답으로 돌아 왔으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'이 유형에서 상속해야합니까?'에 대한 테스트로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Barbara Liskov의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Liskov 대체 원칙에&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 언급이 없으면 불완전한 것으로 보입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5fe3b54cb63f0b09fd4abeb10b7c42f52993fc0c" translate="yes" xml:space="preserve">
          <source>@MatthieuM. says in &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&quot;&gt;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@MatthieuM. &lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 나와 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1d66bf495a38f7905720f390dbf27d3cd5934bd" translate="yes" xml:space="preserve">
          <source>A circle is an ellipse BUT circles can't do everything that ellipses can do. For example, circles can't stretch, while ellipses can. Therefore, the class &lt;code&gt;Circle&lt;/code&gt;&lt;strong&gt;cannot&lt;/strong&gt; inherit the class &lt;code&gt;Ellipse&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원은 타원이지만 원은 타원으로 할 수있는 모든 것을 할 수는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 타원은 뻗을 수 있지만 원은 늘릴 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Circle&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스는 &lt;/font&gt; &lt;code&gt;Ellipse&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스를 상속 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 수 없습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed02723917385f91dd310ca5a8a52e74215144aa" translate="yes" xml:space="preserve">
          <source>A dog is an animal AND dogs can do everything that animals can do (such as breathing, dying, etc.). Therefore, the class &lt;code&gt;Dog&lt;/code&gt;&lt;strong&gt;can&lt;/strong&gt; inherit the class &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개는 동물이며 개는 동물이 할 수있는 모든 일 (호흡, 죽기 등)을 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Dog&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스는 &lt;/font&gt; &lt;code&gt;Animal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스를 상속 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01287059a41e22e70d573f7784b74fea385c7a85" translate="yes" xml:space="preserve">
          <source>A much more complete and concrete &lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;amp;threadID=16487#91822172&quot;&gt;answer from Tim Boudreau&lt;/a&gt; of Sun:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sun의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;amp;threadID=16487#91822172&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tim Boudreau&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 제공 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 훨씬 더 완전하고 구체적인 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;답변&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ecfbd413e3b64a89620f4a0c3113ea12be77cd9" translate="yes" xml:space="preserve">
          <source>A rule of thumb I have heard is inheritance should be used when its a &quot;is-a&quot; relationship and composition when its a &quot;has-a&quot;. Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 들었던 경험은 상속은 &quot;is-a&quot;관계 일 때 사용되어야하고 &quot;has-a&quot;일 때 구성을 사용해야한다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그럼에도 불구하고 나는 많은 복잡성을 제거하기 때문에 항상 구성에 의존해야한다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ba0c4f8f2f7998fd84e1b2e18671bab5f8dbd05" translate="yes" xml:space="preserve">
          <source>A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same &lt;em&gt;interface&lt;/em&gt; as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level &lt;em&gt;implementation&lt;/em&gt; differs, the high-level &lt;em&gt;interface&lt;/em&gt; remains the same).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 이해하는 간단한 방법은 클래스의 객체가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부모 클래스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 동일한 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 갖기 위해 상속을 사용해야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부모 클래스의 객체로 취급 될 수 있다는 것입니다 (업 캐스팅) . 또한 파생 클래스 객체의 함수 호출은 코드의 모든 곳에서 동일하게 유지되지만 호출 할 특정 메서드는 런타임에 결정됩니다 (즉, 저수준 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현이&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다르면 고수준 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 동일하게 유지됨).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf4a40229fa15c4916233897eb3cd85732b5ca8" translate="yes" xml:space="preserve">
          <source>Also, I support @anon answer in &lt;a href=&quot;https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1&quot;&gt;Why use inheritance at all?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 상속을 사용합니까?에서&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; @anon 답변을 지원 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fcf41a9237c1dac7d08f4bbf45ff16fef75d4e1" translate="yes" xml:space="preserve">
          <source>An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering more object oriented design.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 클래스를 사용하지 않는 PHP (특히 PHP5 이전)가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 논리는 일련의 기능으로 인코딩됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;헬퍼 함수 등을 포함하는 다른 파일을 포함하고 함수에서 데이터를 전달하여 비즈니스 로직을 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;애플리케이션이 커질수록 관리하기가 매우 어려울 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PHP5는 더 많은 객체 지향 디자인을 제공함으로써이를 해결하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="003b46e7955af669ca0d0b1ccab8ff624590d7d7" translate="yes" xml:space="preserve">
          <source>Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It's really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren't always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 구성을 선호하는 또 다른 매우 실용적인 이유는 도메인 모델과 관련이 있으며 관계형 데이터베이스에 매핑해야합니다. 상속을 SQL 모델에 매핑하는 것은 실제로 어렵습니다 (항상 사용되지 않는 열 만들기, 뷰 사용 등)와 같은 모든 종류의 해킹 방법으로 끝납니다. 일부 ORML은이를 처리하려고하지만 항상 빠르게 복잡해집니다. 두 테이블 간의 외래 키 관계를 통해 컴포지션을 쉽게 모델링 할 수 있지만 상속은 훨씬 어렵습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3ead00c7eaee34c442057dee94f69e62fca38dd" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class &lt;code&gt;Widget&lt;/code&gt; in GUI frameworks, or a polymorphic class &lt;code&gt;Node&lt;/code&gt; in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 다형성 사용이 매우 일반적 일 것으로 예상되는 경우 컴포지션보다 상속을 선택하는 경향이 있습니다.이 경우 동적 디스패치의 힘이 훨씬 더 읽기 쉽고 우아한 API로 이어질 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GUI 프레임 워크에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다형성 클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;XML 라이브러리에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다형성 클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Node&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하면 구성을 기반으로하는 솔루션을 사용하는 것보다 훨씬 읽기 쉽고 직관적 인 API를 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="19790e17c44a9b95a38b06493bf40dd98fb49535" translate="yes" xml:space="preserve">
          <source>As many people told, I will first start with the check - whether there exists an &quot;is-a&quot; relationship. If it exists I usually check the following:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 사람들이 말했듯이, 나는 &quot;is-a&quot;관계가 존재하는지 여부를 먼저 검사로 시작할 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;존재하는 경우 일반적으로 다음을 확인하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fda1192189400839b8b95f4e3718dccf23de4a71" translate="yes" xml:space="preserve">
          <source>As soon as someone explained &quot;favor composition over inheritance&quot; to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn't really work well.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;누군가가 &quot;상속보다 선호하는 구성&quot;을 설명하자마자, 상속을 사용하여 클래스간에 기능을 공유하려고 할 때마다 다시 생각하고 대부분의 시간이 실제로 제대로 작동하지 않는다는 것을 깨달았습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd869ae1d27b49cf539b23ec39ba981088b4ec6a" translate="yes" xml:space="preserve">
          <source>Aside from is a/has a considerations, one must also consider the &quot;depth&quot; of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고려해야 할 사항 외에도 고려해야 할 사항은 객체가 거쳐야하는 상속의 &quot;깊이&quot;도 고려해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 수준이 5-6 단계를 초과하면 예상치 못한 캐스팅 및 박싱 / 언 박싱 문제가 발생할 수 있으며,이 경우 대신 객체를 작성하는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="382e62ec5112339ce9d05227c6fa3d942c472f7a" translate="yes" xml:space="preserve">
          <source>At the risk of oversimplifying, that's composition - composing multiple classes to work together. And once we form that habit we find that it's much more flexible, maintainable, and testable than using inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지나치게 단순화 할 위험이있는 경우, 여러 개의 클래스를 구성하여 함께 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 일단 습관을 형성하면 상속을 사용하는 것보다 훨씬 유연하고 유지 보수가 가능하며 테스트가 가능하다는 것을 알게됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="400d0992f15edf3eca262b5209a73094f8d6e110" translate="yes" xml:space="preserve">
          <source>Base class defines structure of the algorithm  and sub-class will override a part of algorithm =&amp;gt; &lt;strong&gt;&lt;em&gt;You can implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;Template_method&lt;/a&gt; without change in base class skeleton&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스는 알고리즘의 구조를 정의하고 하위 클래스는 알고리즘의 일부를 대체합니다. =&amp;gt; &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스 스켈레톤을 변경하지 않고 &lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Template_method&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현할 수 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c024738e730ecac1df27b0bab86fd28a7f5eab0" translate="yes" xml:space="preserve">
          <source>Base class provides default implementation and sub-class can change the behaviour =&amp;gt; &lt;strong&gt;&lt;em&gt;You can re-define contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스는 기본 구현을 제공하고 하위 클래스는 동작을 변경할 &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수 있습니다&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계약을 다시 정의 할 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec79a6576dd1a829ef1be9035eab29495e4a39ac" translate="yes" xml:space="preserve">
          <source>Base class provides no implementation and sub-class has to override complete method (abstract) =&amp;gt; &lt;strong&gt;&lt;em&gt;You can implement a contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스는 구현을 제공하지 않으며 하위 클래스는 전체 메소드를 대체해야합니다 (추상) =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계약을 구현할 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5071aef9005443060d06d71c91df8e638ed8f5f" translate="yes" xml:space="preserve">
          <source>Call no methods from the superclass constructor</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수퍼 클래스 생성자로부터 메소드를 호출하지 않습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4b96cc03f1983251e435c5372fac4d177913e2d5" translate="yes" xml:space="preserve">
          <source>Common problems to the use of inheritance as I see it are:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 볼 때 상속 사용에 대한 일반적인 문제는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="81f2d2c7a8be16bc594e920e17d27d214e445279" translate="yes" xml:space="preserve">
          <source>Composition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in &lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java&quot;&gt;decorator pattern&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java&quot;&gt;proxy pattern&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션은 반전 제어에 적합하며 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데코레이터 패턴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프록시 패턴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같이 종속성을 동적으로 주입 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58f3246a619006b9498ebf3dce3fe08d69bb09f" translate="yes" xml:space="preserve">
          <source>Composition has the benefit of &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators&quot;&gt;combinator-oriented&lt;/a&gt; programming, i.e. working in a way like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern#Java&quot;&gt;composite pattern&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션은 컴비 네이터 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지향&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 프로그래밍, 즉 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복합 패턴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 같은 방식으로 작업 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 이점이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b61664eea08164f2bdbcf4e14aaae6423d48a24e" translate="yes" xml:space="preserve">
          <source>Composition has the benefit of easy &lt;a href=&quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance&quot;&gt;multiple inheritance&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다중 상속&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 용이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하다는&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이점이 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0686522d6dc64a26474dd45526ab7c5d6f2976fd" translate="yes" xml:space="preserve">
          <source>Composition immediately follows &lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;programming to an interface&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 인터페이스에 대한 프로그래밍을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 즉시 따릅니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46ef1a92cd606125c6540b7b2b01afd6a3c39af1" translate="yes" xml:space="preserve">
          <source>Composition is favoured over inheritance. To put it very simply you would have:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 구성이 선호됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단히 말하면 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a48c284575bc59295e94ae273beff875be00b0e" translate="yes" xml:space="preserve">
          <source>Composition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it's quite safe and easy to use composition. There are so many possibilites here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션은 모듈 식으로 재생됩니다. 부모 클래스와 유사한 인터페이스를 만들고 새 객체를 만들고 호출을 위임합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 객체가 서로를 알 필요가 없다면 구성이 매우 안전하고 사용하기 쉽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에는 많은 가능성이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae3589f9e16ef3d74aae74f9cc0e37a51e1e1c2f" translate="yes" xml:space="preserve">
          <source>Composition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the &quot;&lt;em&gt;Single Responsibility Principle&lt;/em&gt;&quot;, which is often summarized as &quot;&lt;em&gt;There should never be more than one reason for a class to change.&lt;/em&gt;&quot;, and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our &lt;em&gt;real world&lt;/em&gt; pretty well, but that isn't the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션은 종종보다 논리적이며, 더 나은 추상화, 더 나은 캡슐화, 더 나은 코드 재사용 (특히 대규모 프로젝트에서)을 제공하며 코드의 어느 곳에서든 고립 된 변경을 수행했기 때문에 멀리서도 문제가 발생하지 않습니다. 또한 &quot; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 책임 원칙&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보다 쉽게지지 할 수 있습니다. &quot; &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 책임 원칙&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;은 종종 &quot; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;교실이 바뀌어야 할 이유가 두 개 이상 있어야합니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;로 요약됩니다 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이는 모든 학급이 특정 목적을 위해 존재하며 목적과 직접 관련된 방법 만 있습니다. 또한 매우 얕은 상속 트리를 사용하면 프로젝트가 실제로 커지기 시작할 때에도 개요를 훨씬 쉽게 유지할 수 있습니다. 많은 사람들은 상속이 우리의 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제 세계를&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대표한다고 생각합니다&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;꽤 잘하지만 그것은 사실이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제 세계는 상속보다 훨씬 더 많은 구성을 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 손에 쥐고있을 수있는 거의 모든 실제 물체는 다른 작은 실제 물체로 구성되어 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10f3a58f627a1c06a673bba20f0d87bcfa973635" translate="yes" xml:space="preserve">
          <source>Composition is typically &quot;has a&quot; or &quot;uses a&quot; relationship. Here the Employee class has a Person. It does not inherit from Person but instead gets the Person object passed to it, which is why it &quot;has a&quot; Person.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성은 일반적으로 &quot;있다&quot;또는 &quot;사용&quot;관계입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기 Employee 클래스에는 Person이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Person으로부터 상속받지 않고 대신 Person 오브젝트를 전달받습니다. 이것이 &quot;Person&quot;을 갖는 이유입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fd117ba0aac29cf18bbb9d63f44b9e57ef72792" translate="yes" xml:space="preserve">
          <source>Composition over Inheritance</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속에 대한 구성&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f95b761f5013500506669ddde5d332b7d2698e3f" translate="yes" xml:space="preserve">
          <source>Composition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class' implementation which the user of that class need not know about. So composition is more in the way of supporting &lt;em&gt;encapsulation&lt;/em&gt; (i.e. concealing the implementation) while inheritance is meant to support &lt;em&gt;abstraction&lt;/em&gt; (i.e. providing a simplified representation of something, in this case the &lt;strong&gt;same&lt;/strong&gt; interface for a range of types with different internals).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 클래스가 동일한 인터페이스를 가질 필요가없는 경우 구성을 사용해야합니다. 즉, 해당 클래스의 사용자가 알 필요가없는 클래스 구현의 특정 측면을 숨기려고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 컴포지션은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캡슐화&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (즉, 구현 은폐)를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지원하는 방법이 더 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많으며 상속은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추상화&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 지원하기위한 것입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(즉, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부가 다른 유형의 범위에 대해 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인터페이스를 제공합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2a8235eed4685d8113375b89cd8a8e3d9bd3e3a" translate="yes" xml:space="preserve">
          <source>Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성 대 상속은 광범위한 주제입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 것이 시스템의 디자인에 달려 있다고 생각하기 때문에 더 나은 것에 대한 진정한 대답은 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92716f2ee6cb1310c9dda41d91fd87785b6876c1" translate="yes" xml:space="preserve">
          <source>Creating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass &quot;is-a&quot; super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래스를 생성한다는 것은 수퍼 클래스 메소드를 호출하는 편리한 방법 이상을 의미해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래스 &quot;is-a&quot;수퍼 클래스가 구조적으로나 기능적으로 모두 수퍼 클래스로 사용될 수 있고 상속 할 때는 상속을 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않은 경우-상속이 아니라 다른 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성은 개체가 다른 개체로 구성되거나 관계가있는 경우입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fe61a6e3e340af7a148250fe18c7fe220180a40" translate="yes" xml:space="preserve">
          <source>Didn't find a satisfactory answer here, so I wrote a new one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 만족스러운 답변을 찾지 못하여 새로운 답변을 썼습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2134be01d96196149dd1553096fb7d21f63f453f" translate="yes" xml:space="preserve">
          <source>Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for &lt;strong&gt;Composition.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TypeB는 TypeA에 의해 노출되는 동작의 일부 / 일부만 원합니까? &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성이&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필요함을 나타냅니다 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="12ab02cfb9dcddf234cbcb5daadc6acbbc33faab" translate="yes" xml:space="preserve">
          <source>Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates &lt;strong&gt;Inheritance&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TypeB는 TypeA가 예상되는 곳에서 TypeB를 사용할 수 있도록 TypeA의 완전한 인터페이스 (모든 공용 메소드)를 공개하려고합니까? &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 나타냅니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777d4fc8b7f76029a5967bc0b0912719f3a1a9b1" translate="yes" xml:space="preserve">
          <source>Does your class need to re-use any high level interactions defined in another class ? The &lt;a href=&quot;http://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;template method&lt;/a&gt; design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수업에서 다른 수업에 정의 된 높은 수준의 상호 작용을 재사용해야합니까? &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;템플릿 메소드&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 디자인 패턴은 상속없이 구현하기가 불가능하다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 확장 가능한 프레임 워크 가이 패턴을 사용한다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ce219366653ef3fc59ddc3a55f02fcdb049f3e4" translate="yes" xml:space="preserve">
          <source>E.g 1. Accountant &lt;strong&gt;is an&lt;/strong&gt; Employee. But I will &lt;strong&gt;not&lt;/strong&gt; use inheritance because a Employee object can be instantiated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 1. 회계사 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 직원입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Employee 객체를 인스턴스화 할 수 있기 때문에 상속을 사용 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd394dfc4783e4030e370145dbe0cbed4e04b2f6" translate="yes" xml:space="preserve">
          <source>E.g 2. Book &lt;strong&gt;is a&lt;/strong&gt; SellingItem. A SellingItem cannot be instantiated - it is abstract concept. Hence I will use inheritacne. The SellingItem is an &lt;strong&gt;abstract base class (or interface&lt;/strong&gt; in C#)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 2. Book &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; SellingItem입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SellingItem은 인스턴스화 할 수 없으며 추상적 개념입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 나는 상속을 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SellingItem은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추상 기본 클래스 (또는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C #의 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e63cd64448d1fa4bd7208eeb5d3146984a4c565d" translate="yes" xml:space="preserve">
          <source>Either the base class &lt;code&gt;Engine&lt;/code&gt; exposes a mutator to change its</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Engine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 변경자를 변경하기 위해 뮤 테이터를 노출시킵니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b189d69566897b8878d77a4a677fe65f855dc737" translate="yes" xml:space="preserve">
          <source>Essentially, this means that inheritance is possible if the base class can be used polymorphically, which I believe is equivalent to our test &quot;a bar is a foo and bars can do everything that foos can do&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 이것은 기본 클래스를 다형성으로 사용할 수있는 경우 상속이 가능하다는 것을 의미합니다. 이는 &quot;바는 foo이고 바는 foo가 할 수있는 모든 작업을 수행 할 수 있습니다&quot;라고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2051d9830558331ddb82ea3d448072dd2bb9c36" translate="yes" xml:space="preserve">
          <source>Even if you &lt;em&gt;can&lt;/em&gt; use inheritance doesn't mean you &lt;em&gt;should&lt;/em&gt;: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren't obvious, and in my opinion are best explained in &lt;a href=&quot;https://stackoverflow.com/a/32557773/1951907&quot;&gt;lcn's answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용할 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있다고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반드시 컴포지션 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용해야&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 것은 아닙니다. 상속은 암시 적 코드 재사용 및 동적 디스패치를 ​​허용하는 강력한 도구이지만 몇 가지 단점이 있으므로 구성이 종종 선호됩니다. 상속과 구성 간의 상충 관계는 분명하지 않으며 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/32557773/1951907&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lcn의 답변&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 가장 잘 설명되어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f8acd85ea01ba780aab8bff6a6da0a022821ecd" translate="yes" xml:space="preserve">
          <source>Even though Composition is preferred, I would like to highlight pros of &lt;em&gt;Inheritance&lt;/em&gt; and cons of &lt;em&gt;Composition&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성이 바람직하더라도, 나는의 장점 강조하고 싶은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 양론 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;조성&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31031c9aad8cde85b2091023e88715df8ab33039" translate="yes" xml:space="preserve">
          <source>Excessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래 싱에 의한 과도한 재사용은 상속 스택을 매우 깊고 혼란스럽게 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89a3623ed6c1f4cf17b888e7b9aea97aa69741d0" translate="yes" xml:space="preserve">
          <source>Expose no fields, ever, except constants</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상수를 제외하고 필드를 노출하지 마십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="043fff222c570925fe52a25442b655b888e4778a" translate="yes" xml:space="preserve">
          <source>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스에 대한 포인터 또는 참조를 사용하는 함수는 몰래 파생 클래스의 객체를 사용할 수 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3bb1334620acce14a757514719a368811078eacb" translate="yes" xml:space="preserve">
          <source>Generally type of relationship between object provide better information to choose one of them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 객체 간의 관계 유형은 더 나은 정보를 제공하여 객체 중 하나를 선택할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f12a4d9f8c6da07d46b0a2b46004b726e7c45ee" translate="yes" xml:space="preserve">
          <source>However, if the parent class for some reason needs to access functions provided by the &quot;child class&quot; for inexperienced programmer it may look like it's a great place to use  inheritance. The parent class can just call it's own abstract &quot;foo()&quot; which is overwritten by the subclass and then it can give the value to the abstract base.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 어떤 이유로 부모 클래스가 경험이없는 프로그래머를 위해 &quot;자식 클래스&quot;에서 제공하는 함수에 액세스해야하는 경우 상속을 사용하기에 좋은 장소 인 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부모 클래스는 서브 클래스로 덮어 쓰는 자체 추상 &quot;foo ()&quot;를 호출 한 다음 추상베이스에 값을 제공 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97f925aaef0269b5644be480512ea4709622251e" translate="yes" xml:space="preserve">
          <source>However, if you want to use the private variables, the case 3, then you may be in trouble. &lt;strong&gt;If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe&lt;/strong&gt;. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it's quite fine.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 개인 변수, 사례 3을 사용하려면 문제가있을 수 있습니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전역 변수를 안전하지 않은 것으로 간주하면 상속을 사용하여 개인 변수에 대한 액세스도 안전하지 않은 것으로 고려해야&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전역 변수가 모두 나쁜 것은 아닙니다. 데이터베이스는 본질적으로 큰 전역 변수 세트입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 당신이 그것을 처리 할 수 ​​있다면, 그것은 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4d685219579566f4df07511cc885fbfa342cbce" translate="yes" xml:space="preserve">
          <source>However, if your intention is purely that of code re-use, then composition most likely is a better design choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 의도가 코드 재사용의 의도라면 컴포지션이 더 나은 디자인 선택입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79722dd4bf505b50db03d2d8689bea00b8a0de1d" translate="yes" xml:space="preserve">
          <source>I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그가 @Pavel에 동의하면 작곡 장소와 상속 장소가 있다고 말합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da4978d60ea2b750a44d4c39e654ed0899f255e" translate="yes" xml:space="preserve">
          <source>I can think of three real reasons for using inheritance:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 사용하는 세 가지 실제 이유를 생각할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92415e061dde1a77f1cbf96f5a396e5e3f625e79" translate="yes" xml:space="preserve">
          <source>I have three classes that all need some common functionality. So if I
  write a base class and have them all inherit from it, then they will
  all have that functionality and I'll only need to maintain it in once
  place.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공통적 인 기능이 필요한 세 가지 클래스가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 기본 클래스를 작성하고 모든 클래스를 상속 받으면 모두 해당 기능을 갖게되므로 한 번만 유지하면됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94322ac0b828540a1a09d955fde0930579fb6eef" translate="yes" xml:space="preserve">
          <source>I see no one mentioned the &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&quot;&gt;&lt;strong&gt;diamond problem&lt;/strong&gt;&lt;/a&gt;, which might arise with inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속과 관련하여 발생할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다이아몬드 문제에&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대해서는 아무도 언급하지 않았습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66bbabb97fcd47e383202e2d023a33046ffde71d" translate="yes" xml:space="preserve">
          <source>I take no credit for this approach. I took it straight from the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735619670&quot;&gt;Second Edition of Code Complete&lt;/a&gt; by &lt;a href=&quot;http://blogs.construx.com/blogs/stevemcc/default.aspx&quot;&gt;Steve McConnell&lt;/a&gt;, &lt;em&gt;Section 6.3&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는이 접근법에 대해 아무런 신용도받지 않는다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는에서 똑바로했다 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735619670&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 코드의 두 번째 판&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 의해 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.construx.com/blogs/stevemcc/default.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스티브 맥코넬&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.3 절&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa2bbecf277f1f24d2f1347150c527e7e0547d68" translate="yes" xml:space="preserve">
          <source>I think inheritance should be used if your answer is an affirmative to any of these questions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;귀하의 답변이 위의 질문 중 하나라도 긍정적이라면 상속을 사용해야한다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a218d45daf46b325069807128916cf22840ea70" translate="yes" xml:space="preserve">
          <source>I would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it's easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성을 기본값으로 사용하는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 모듈화되어 있으며 후기 바인딩의 이점을 제공합니다 (구성 요소를 동적으로 변경할 수 있음). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 사물을 별도로 테스트하는 것이 더 쉽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 클래스의 메소드를 사용해야하는 경우 특정 형식 (Liskov 대체 원칙)이 아니어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4b8830d61628daddd8e304299af6cded09fa350" translate="yes" xml:space="preserve">
          <source>If code reuse is the &lt;em&gt;sole&lt;/em&gt; purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don't make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is &lt;em&gt;demanded&lt;/em&gt;. This is also where the &quot;is-a&quot; vs. &quot;has-a&quot; notion comes from.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드 재사용이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유일한&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 목적 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이라면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, 서브 클래 싱은 필요한 것 이상을 제공 할 수 있습니다. 즉, 부모 클래스의 일부 공용 메소드는 자식 클래스에 대해 의미가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우, 대신에 상속 위에 조성물을 선호에, 조성은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요구&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 &quot;is-a&quot;대 &quot;has-a&quot;개념의 유래이기도합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f377d45b989acafd55d82af80725c12e6b22ad84" translate="yes" xml:space="preserve">
          <source>If relation type is  &quot;IS-A&quot; relation then Inheritance is better approach.
otherwise relation type is  &quot;HAS-A&quot; relation then composition will better approach.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;관계 유형이 &quot;IS-A&quot;관계이면 상속이 더 나은 방법입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않으면 관계 유형이 &quot;HAS-A&quot;관계이면 컴포지션이 더 잘 접근합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31255e40d0434216cba8c8688fd5f4dadb2d4bce" translate="yes" xml:space="preserve">
          <source>If the object need to be of the same type, then use &lt;strong&gt;Inheritance&lt;/strong&gt; or implement interfaces.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체의 유형이 동일해야하는 경우 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하거나 인터페이스를 구현하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03ea0bf4e382df082ffa1f260eb4aff741e92ef5" translate="yes" xml:space="preserve">
          <source>If the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유가 2 번이면 조금 까다 롭습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 동일한 기본 클래스 만 사용해야합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 동일한 기본 클래스를 사용하는 것만으로는 충분하지 않지만 프레임 워크의 요구 사항이 될 수 있으며 피할 수없는 디자인 고려 사항 일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50913e0cbdc9a4f53879607cd8217f727ee11c8d" translate="yes" xml:space="preserve">
          <source>If these are true, then it is probably necessary to use inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 사실이라면 상속을 사용해야 할 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b1c2b77c49e48b7fd23f6be825d3e74aa05cdb1" translate="yes" xml:space="preserve">
          <source>If you understand the difference, it's easier to explain.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차이점을 이해하면 설명하기가 더 쉽습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0744b5b95abf4fe22c4bb86def64e0a6bd18cab0" translate="yes" xml:space="preserve">
          <source>In Java or C#, an object cannot change its type once it has been instantiated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 또는 C #에서 인스턴스화되면 객체의 유형을 변경할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="048c5d31bb5c132e0c74cc2184a24b79baadf241" translate="yes" xml:space="preserve">
          <source>In a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B와 C 클래스가 A를 상속하고 메소드 X를 대체하고 네 번째 클래스 D를 B와 C에서 모두 상속하고 X를 대체하지 않으면 XD의 어떤 구현을 사용해야합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="328ab1e48844e9cef1794c68df9d6ef8b3d470f0" translate="yes" xml:space="preserve">
          <source>In inheritance, subclass can directly invoke base class method even though it's not implementing base class method because of &lt;strong&gt;&lt;em&gt;IS A&lt;/em&gt;&lt;/strong&gt; relation. If you use composition, you have to add methods in container class to expose contained class API</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속에서 하위 클래스는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IS A&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관계로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인해 기본 클래스 메서드를 구현하지 않더라도 기본 클래스 메서드를 직접 호출 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션을 사용하는 경우 컨테이너 클래스에 메소드를 추가하여 포함 된 클래스 API를 노출해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0237d418d5cba034a69d0e770a4c52723e47e4d3" translate="yes" xml:space="preserve">
          <source>In the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, &quot;Cool, I learned about inheritance and now I used it.&quot; That's not meant to be condescending because we've all done it. But we all did it because no one told us not to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결국, 우리는 코드를 어려운 매듭으로 묶고 &quot;쿨, 나는 상속에 대해 배웠고 이제는 그것을 사용했다&quot;는 말을 제외하고는 그로부터 이익을 얻지 못합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리 모두가 해냈 기 때문에 그것은 하찮은 것이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 아무도 우리에게하지 말라고했기 때문에 우리 모두는 그렇게했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="8acfc927b768458de4cace8265888459e774da8a" translate="yes" xml:space="preserve">
          <source>Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class'es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 서브 클래스와 수퍼 클래스 사이에 강한 관계를 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래스는 수퍼 클래스의 구현 세부 사항을 알고 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떻게 수퍼 클래스를 만들 수 있는지 생각해야 할 때 슈퍼 클래스를 만드는 것이 훨씬 어렵습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 불변량을주의 깊게 문서화하고 재정의 가능한 다른 메소드가 내부적으로 사용하는 것을 명시해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7060930ac5a536fbe2aad05ec9ec8d02db42c83" translate="yes" xml:space="preserve">
          <source>Inheritance exposes &lt;em&gt;protected&lt;/em&gt; members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보호 된&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구성원을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;노출시킵니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이로 인해 부모 클래스의 캡슐화가 중단되고 하위 클래스에서 사용하는 경우 자식과 부모 간의 다른 종속성이 도입됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1ded82669ac9037f30aed69f3e1289af7838c6f" translate="yes" xml:space="preserve">
          <source>Inheritance exposes a subclass to details of its parent class implementation, that's why it's often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 서브 클래스를 부모 클래스 구현의 세부 사항에 노출 시키므로 상속이 캡슐화를 깨뜨리는 경우가 종종 있습니다 (구현이 아닌 인터페이스에만 집중해야한다는 의미에서 서브 클래 싱으로 재사용하는 것이 항상 바람직하지는 않습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b2f20d3e798733bc6014d967772e1dd274bc317" translate="yes" xml:space="preserve">
          <source>Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 코드 재사용을위한 매우 강력한 메커니즘입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 올바르게 사용되어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 클래스가 부모 클래스의 하위 유형 인 경우 상속이 올바르게 사용된다고 말하고 싶습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위에서 언급했듯이 Liskov 대체 원칙이 핵심입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d4a2058f753bb6fa776187437c532819ce7c9eb" translate="yes" xml:space="preserve">
          <source>Inheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 상속은 쉽게 과도하게 사용되며 클래스 사이의 어려운 종속성으로 인해 추가 복잡성이 발생합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 프로그램 실행 중 발생하는 상황을 이해하는 것은 계층과 메소드 호출의 동적 선택으로 인해 매우 어려워집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="246a008dc7a1185d80da575bb9971db7f90056e2" translate="yes" xml:space="preserve">
          <source>Inheritance is often taught early when we learn object-oriented programming, so it's seen as an easy solution to a common problem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 종종 객체 지향 프로그래밍을 배울 때 일찍 가르치므로 일반적인 문제에 대한 쉬운 해결책으로 간주됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="644a9a7de65c713edc98cce558794f4f5d61fd4c" translate="yes" xml:space="preserve">
          <source>Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 특히 절차 적 국가에서 오는 매우 유혹적이며 종종 기만적으로 우아해 보입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가해야 할 일은이 클래스의 기능을 다른 클래스에 추가하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 문제 중 하나는&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62e87b6a71b6557527e58c600d3ce6921f9bf0e3" translate="yes" xml:space="preserve">
          <source>Inheritance is really a cool feature, but I'm afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 정말 멋진 기능이지만 지난 몇 년 동안 과도하게 사용 된 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사람들은 상속이 실제로 못, 나사 또는 완전히 다른 무엇이든 관계없이 모든 것을 못 박는 망치로 취급했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6876956ee9e8f2967733c679847a166bd622f332" translate="yes" xml:space="preserve">
          <source>Inheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계층 구조가 실제로 관계를 나타내는 경우 상속이 유용 할 때가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 공개 폐쇄 원칙과 관련이 있으며,이 클래스는 수정을 위해 클래스를 닫아야하지만 확장 가능합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇게하면 다형성을 가질 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수퍼 유형과 해당 메소드를 처리하는 일반 메소드를 갖지만 동적 디스패치를 ​​통해 서브 클래스의 메소드가 호출됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 유연성이 뛰어나고 소프트웨어에 필수적인 간접 구현을 만드는 데 도움이됩니다 (구현 세부 사항에 대해 덜 알고 있음).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bced79113df2d8dc04636edbfd4c770f3793b989" translate="yes" xml:space="preserve">
          <source>Inheritance is very powerful, but you can't force it (see: the &lt;a href=&quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;circle-ellipse problem&lt;/a&gt;). If you really can't be completely sure of a true &quot;is-a&quot; subtype relationship, then it's best to go with composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 매우 강력하지만 강제로 할 수는 없습니다 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원-타원 문제 참조&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;진정한 &quot;is-a&quot;하위 유형 관계를 완전히 확신 할 수 없으면 컴포지션을 사용하는 것이 가장 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c9e4c9ebc2c06779a4efa98017c411df12f9203" translate="yes" xml:space="preserve">
          <source>Inheritance provides straightforward &lt;a href=&quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion&quot;&gt;open recursion&lt;/a&gt; via the internal polymorphic site &lt;code&gt;this&lt;/code&gt;, i.e. invoking overriding method (or even &lt;a href=&quot;http://www.scala-lang.org/old/node/1637.html#comment-5489&quot;&gt;type&lt;/a&gt;) in another member function, either public or private (though &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one&quot;&gt;discouraged&lt;/a&gt;). Open recursion can be &lt;a href=&quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java&quot;&gt;simulated via composition&lt;/a&gt;, but it requires extra effort and may not always viable(?). This &lt;a href=&quot;https://stackoverflow.com/a/2238735/2073130&quot;&gt;answer&lt;/a&gt; to a duplicated question talks something similar.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 간단 제공 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오픈 재귀&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내부 다형성 부위를 통해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 즉 재정 방법 (또는 호출 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.scala-lang.org/old/node/1637.html#comment-5489&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유형&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다른 멤버 함수)를 하나 (비록 공개 또는 비공개 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;낙담&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오픈 재귀는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;composition을 통해 시뮬레이션&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 추가 노력이 필요하며 항상 실행 가능한 것은 아닙니다 (?). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중복 질문에 대한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/2238735/2073130&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;답변&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 비슷한 것을 말합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476dda4bfbf5d4cce097cb5b1043e190f23872ad" translate="yes" xml:space="preserve">
          <source>Inheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it's just a simple job of delegation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 재정의되지 않은 경우 간단한 코드 재사용을 제공하는 반면 컴포지션은 단순한 위임 작업 인 경우에도 모든 API를 다시 코딩해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="58f31260c50c06295c28ea7e8151785985ab907c" translate="yes" xml:space="preserve">
          <source>Inheritance vs. Aggregation</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 vs. 집계&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4add19dff6bf1f83b08edd6c883185779e798ed" translate="yes" xml:space="preserve">
          <source>Is your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신의 클래스는 다형성으로부터 이익을 얻는 구조의 일부입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, draw ()라는 메서드를 선언하는 Shape 클래스가있는 경우 Circle 및 Square 클래스가 Shape의 하위 클래스가되어야 클라이언트 클래스가 특정 하위 클래스가 아닌 Shape에 종속 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bfe3497c44aa76555ec280d12b36758df5b4f30f" translate="yes" xml:space="preserve">
          <source>It establishes a logical &quot;&lt;strong&gt;IS A&quot;&lt;/strong&gt; relation. If &lt;em&gt;Car&lt;/em&gt; and &lt;em&gt;Truck&lt;/em&gt; are two types of &lt;em&gt;Vehicle&lt;/em&gt; ( base class), child class &lt;strong&gt;IS A&lt;/strong&gt; base class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;논리적 &quot; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IS A&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관계를 설정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동차&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;트럭&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 두 종류가 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차량&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (기본 클래스), 하위 클래스 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기본 클래스.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="896d22608075a950c42470104324b7925c60561d" translate="yes" xml:space="preserve">
          <source>It is often said that a class &lt;code&gt;Bar&lt;/code&gt; can inherit a class &lt;code&gt;Foo&lt;/code&gt; when the following sentence is true:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 문장이 참일 때 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 상속받을 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있다고 종종 말합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34e84b66db1164cc20f4c06d7a6b4d4b98054d53" translate="yes" xml:space="preserve">
          <source>It looks like a nice idea, but in many cases it's better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좋은 생각처럼 보이지만 많은 경우에 필요한 클래스 클래스에서 새 클래스를 상속하는 것보다 foo ()를 구현하는 객체를 클래스에 제공하는 것이 좋습니다 (또는 foo ()를 수동으로 제공된 값으로 설정). 지정할 foo () 함수&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0325327f4aa9142c3fd02e3a934a008c92e7171d" translate="yes" xml:space="preserve">
          <source>It sounds great, but in practice it almost never, ever works, for one of several reasons:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 훌륭하게 들리지만 실제로 여러 가지 이유 중 하나 때문에 거의 작동하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8a7ea6e944d4c6b1135e3b5b710351923f2b191" translate="yes" xml:space="preserve">
          <source>Its totally depend on entity relationship.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 엔티티 관계에 전적으로 의존합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9aa3aeed06309616a463e707f18bc9934bea552e" translate="yes" xml:space="preserve">
          <source>Just so you know, another method used to determine whether inheritance is possible  is called the &lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;Liskov Substitution Principle&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아시다시피 상속 가능 여부를 결정하는 데 사용되는 또 다른 방법을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Liskov 대체 원칙&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이라고합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5197c78c69bc09836bc35c15c3eef5138da931c2" translate="yes" xml:space="preserve">
          <source>Liskov Substitution Principle</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리스 코프 대체 원리&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d422e9f26503f80de1cff472c1db2f215fa1702a" translate="yes" xml:space="preserve">
          <source>Methods shall be either abstract or final</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방법은 추상적이거나 최종적이어야한다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac55c0bd23a1f1346ee8d2c06328fa87ad445ad8" translate="yes" xml:space="preserve">
          <source>My acid test for the above is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 내 산 테스트는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9981ec34a9c592b0920bf23bf8fac06054f08043" translate="yes" xml:space="preserve">
          <source>My general rule of thumb: &lt;em&gt;Before using inheritance, consider if composition makes more sense.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나의 일반적인 경험 법칙 : &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 사용하기 전에 구성이 더 합리적인지 고려하십시오.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db3f86242cf06a42d0939d0152ef62fe2f01bab2" translate="yes" xml:space="preserve">
          <source>My take on what to do, if you do allow for inheritance, which you may
  take with a grain of salt is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 허용하면 소금 한 알을 가지고 할 수있는 일에 대한 나의 취지는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdcdd0dea9447d0f926949cde5bf20294722ed01" translate="yes" xml:space="preserve">
          <source>Now say you want to create a Manager type so you end up with:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 관리자 유형을 만들고 싶다고 가정 해 봅시다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f67f8e82998175522142525ba912b4ae6be97e09" translate="yes" xml:space="preserve">
          <source>Now your aircraft can start with having fixed wings</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 항공기는 고정 날개로 시작할 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fdddf6d088be0ec0a4568052a16a437fcc42087" translate="yes" xml:space="preserve">
          <source>Now, I can replace my engine on the fly as well.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 엔진을 즉시 교체 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="832d28133a55725f1ed6e5888b63068210a2853f" translate="yes" xml:space="preserve">
          <source>On the other hand &lt;b&gt;Object composition&lt;/b&gt; is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other's protected data (no encapsulation break) and will be forced to respect each other's interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 구성&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 런타임에 다른 객체에 대한 참조를 얻는 객체를 통해 정의됩니다. 이러한 경우 이러한 개체는 서로의 보호 된 데이터에 도달 할 수 없으며 (캡슐화 중단 없음) 서로의 인터페이스를 강제해야합니다. 이 경우에도 구현 종속성은 상속의 경우보다 훨씬 적습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c7b128050c901c022cde5fd0d94700144c01c7a" translate="yes" xml:space="preserve">
          <source>On the other hand when you have &lt;strong&gt;has-a&lt;/strong&gt; or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 당신이 가지고있는 경우 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가-A&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 일부 두 클래스 사이의 형용사 관계 (학생이 교육 과정을 가지고) 또는 (교사 연구 과정), 당신은 구성을 선택했다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5aa7d08c0a1cf9428cca33805b546bb71b9e85d3" translate="yes" xml:space="preserve">
          <source>One example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn't use inheritance given that you don't want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이에 대한 예 : 목록에서 스택을 생성하려고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스택에는 팝, 푸시 및 픽만 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;push_back, push_front, removeAt 등의 기능이 스택에 필요하지 않다면 상속을 사용해서는 안됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c15fc0f907136cf0672eb8daba99647310e8c8f3" translate="yes" xml:space="preserve">
          <source>Our Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정수 세트 클래스는 List of Integers의 서브 클래스이지만 List 클래스의 모든 기능을 만족하지 않기 때문에 서브 타입이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드의 값 및 서명은 만족되지만 특성은 만족되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;add (Integer) 메소드의 동작은 상위 유형의 특성을 유지하지 않고 명확하게 변경되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수업의 클라이언트의 관점에서 생각하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정수 목록이 필요한 정수 세트를 수신 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클라이언트는 값이 목록에 이미있는 경우에도 값을 추가하고 해당 값을 목록에 추가 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 그녀는 그 가치가 존재한다면 그 행동을 얻지 못할 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그녀를위한 큰 놀라움!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1ba9f43aacc5af4e732994e2cf99330626de110" translate="yes" xml:space="preserve">
          <source>Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn't know any such thing, you'll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인적으로 저는 항상 상속보다 구성을 선호하는 법을 배웠습니다. 컴포지션으로는 해결할 수없는 상속으로 해결할 수있는 프로그래밍 문제는 없습니다. 경우에 따라 Interfaces (Java) 또는 Protocols (Obj-C)를 사용해야 할 수도 있습니다. C ++은 그러한 것을 알지 못하므로 추상 기본 클래스를 사용해야하므로 C ++에서 상속을 완전히 제거 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="09ac00419cae691f7272de0fcf67b357fbda9a77" translate="yes" xml:space="preserve">
          <source>Prefer composition over inheritance</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 컴포지션 선호&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee0347cbc9ba866cc7d164011ffab0691b350235" translate="yes" xml:space="preserve">
          <source>Procedural Code</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;절차 코드&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e723b4eaeeb9a79c6611a9a222aeb92911a3f411" translate="yes" xml:space="preserve">
          <source>Reason: &lt;em&gt;Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유 : &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 클래 싱은 일반적으로 더 복잡하고 연결성을 의미합니다. 즉 실수없이 변경, 유지 관리 및 확장하기가 어렵습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b27176c7cd1d943a977fdce1ee934c4c1feeb14" translate="yes" xml:space="preserve">
          <source>See other answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 답변을 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8719dca4ec3565d3812b57bd3de8cc2af492bfeb" translate="yes" xml:space="preserve">
          <source>So for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 누군가가 상속이나 구성이 필요한지 알지 못하는 경우 실제 문제는 그가 마시거나 먹고 싶어하는지 모른다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제 영역에 대해 더 많이 생각하고 더 잘 이해하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e46fa089d47708f97cac794ca257e6960b4ed16" translate="yes" xml:space="preserve">
          <source>So only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 서브 타이핑이 목적 일 때, 즉 새로운 클래스를 나중에 다형성 방식으로 사용하려는 경우에만 상속 또는 구성을 선택하는 문제에 직면하게됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 논의중인 단축 관용구에서 생략되는 가정입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38f67df16186ea732f8e64c3dc6f62ebcca5e137" translate="yes" xml:space="preserve">
          <source>So, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use &lt;strong&gt;Composition&lt;/strong&gt;: Refer to &lt;a href=&quot;http://www.dofactory.com/Patterns/PatternState.aspx&quot;&gt;State&lt;/a&gt; and &lt;a href=&quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx&quot;&gt;Strategy&lt;/a&gt; Design Patterns.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 객체가 다른 객체로 나타나거나 객체 상태 또는 조건에 따라 다르게 동작해야하는 경우 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.dofactory.com/Patterns/PatternState.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상태&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전략&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 디자인 패턴 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="549f8d9bac9806f318f15d88f433b6bc397447c1" translate="yes" xml:space="preserve">
          <source>Sub-class adds extension to base class implementation by calling super.methodName() as first statement =&amp;gt; &lt;strong&gt;&lt;em&gt;You can extend a contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 클래스는 super.methodName ()을 첫 번째 명령문으로 호출하여 기본 클래스 구현에 확장을 추가합니다. =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계약을 연장 할 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2edf57dc395184ef34315b418a2b088ba9c59312" translate="yes" xml:space="preserve">
          <source>Subclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 클래스는 하위 유형과 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 타입이 아닌 서브 클래스를 작성할 수 있습니다 (이는 컴포지션을 사용해야하는 경우입니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 유형이 무엇인지 이해하려면 유형이 무엇인지 설명하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6280068eb73b4991a7ab571fc93fcf217f265813" translate="yes" xml:space="preserve">
          <source>Subtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Let&amp;rsquo;s go to see some code to exemplify what I&amp;rsquo;m saying. Suppose I write a List of integers (in some sort of pseudo language):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 유형은 또한 상위 유형 (또는 상위 유형)이라고하는 다른 유형과 관계가있는 유형입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 유형은 상위 유형의 기능 (값, 메소드 및 특성)을 충족해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;관계는 상위 유형이 예상되는 모든 컨텍스트에서 실행 동작에 영향을주지 않고 하위 유형으로 대체 할 수 있음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 말하는 것을 예시하는 코드를 보도록하겠습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 어떤 종류의 의사 언어로 정수 목록을 작성한다고 가정 해보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6887946e4c5b4415b62320ae3947b236c9c5c713" translate="yes" xml:space="preserve">
          <source>Subtyping is appropriate and more powerful where the &lt;a href=&quot;https://stackoverflow.com/a/8352969&quot;&gt;invariants can be enumerated&lt;/a&gt;, else use function composition for extensibility.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 타이핑은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/8352969&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불변이 열거 될 수있는&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 경우 적절하고 강력하며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, 그렇지 않으면 확장 성을 위해 함수 구성을 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e98d1b95929689559f3d4c93532fcfbd040d69e9" translate="yes" xml:space="preserve">
          <source>Suppose an aircraft has only two parts: an engine and wings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항공기에 엔진과 날개의 두 부분 만 있다고 가정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="748d9e332cb80d932e28118f49b5638ba8eaee06" translate="yes" xml:space="preserve">
          <source>The Manager object is composed as an Employee and a Person. The Title behaviour is taken from employee. This explicit composition removes ambiguity among other things and you'll encounter fewer bugs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Manager 개체는 직원과 사람으로 구성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직함 행동은 직원으로부터 가져옵니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 명시적인 구성은 무엇보다도 애매 모호함을 없애고 버그가 줄어 듭니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81ed2eb88eaa37fdff388424251ce97e077ced4c" translate="yes" xml:space="preserve">
          <source>The antidote is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;Single Responsibility Principle&lt;/a&gt;. Think of it as a constraint. My class &lt;em&gt;must&lt;/em&gt; do one thing. I &lt;em&gt;must&lt;/em&gt; be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we're learning.) It follows that I cannot write a base class called &lt;code&gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses&lt;/code&gt;. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, &lt;em&gt;not&lt;/em&gt; inherit from it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해독제는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 책임 원칙&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. 그것을 제약 조건으로 생각하십시오. 수업 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 한 가지만 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해야합니다&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 나는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수업에 그 일을 묘사하는 이름을 수업에 줄 수 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있어야&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 한다. (모든 것에 예외가 있지만 우리가 배우면 절대 규칙이 더 나은 경우가 있습니다.) &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라는 기본 클래스를 작성할 수 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 필요한 기능이 무엇이든 자체 클래스에 있어야하며 해당 기능이 필요한 다른 클래스는 클래스에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되지 않고&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해당 클래스에 의존 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="756c9ed98907d3961cd495c08dfc9ecbac6456d9" translate="yes" xml:space="preserve">
          <source>The article, &lt;a href=&quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/&quot;&gt;Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder&lt;/a&gt;, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Inheritance is Evil : DataAnnotationsModelBinder의 Epic Fail&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기사 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 C #에서 이에 대한 예제를 설명합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션을 사용해야 할 때 상속을 사용하고 리팩토링하는 방법을 보여줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f0cb63e7db6c559e277c0e6f5e0b14d3af0a76f" translate="yes" xml:space="preserve">
          <source>The composition has a real edge here: the relationship can be reversed: the &quot;parent class&quot; or &quot;abstract worker&quot; can aggregate any specific &quot;child&quot; objects implementing certain interface + &lt;strong&gt;any child can be set inside any other type of parent, which accepts it's type&lt;/strong&gt;. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement &quot;foo()&quot; and other group of objects which can make use of objects having &quot;foo()&quot; can play together.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴포지션의 실제 장점은 다음과 같습니다. &quot;상위 클래스&quot;또는 &quot;추상 작업자&quot;는 특정 인터페이스를 구현하는 특정 &quot;하위&quot;개체를 집계 할 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수 있습니다. 유형&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 MergeSort 또는 QuickSort는 추상 비교 인터페이스를 구현하는 모든 객체 목록을 정렬 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 &quot;foo ()&quot;를 구현하는 모든 객체 그룹과 &quot;foo ()&quot;를 가진 객체를 사용할 수있는 다른 객체 그룹은 함께 재생할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="33595de1c584d88b32800d1fcaf74682bd919860" translate="yes" xml:space="preserve">
          <source>The first test ensures that all &lt;em&gt;getters&lt;/em&gt; of &lt;code&gt;Foo&lt;/code&gt; make sense in &lt;code&gt;Bar&lt;/code&gt; (= shared properties), while the second test makes sure that all &lt;em&gt;setters&lt;/em&gt; of &lt;code&gt;Foo&lt;/code&gt; make sense in &lt;code&gt;Bar&lt;/code&gt; (= shared functionality).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 테스트는 &lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 모든 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 &lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; (= 공유 속성) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 있는지 확인하고, 두 번째 테스트는 &lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 모든 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;setter&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 &lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; (= 공유 기능) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 있는지 확인합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3af0b301854a243ae48ec4eb1b17706b1a405f" translate="yes" xml:space="preserve">
          <source>The issue with inheritance is that it can be used for two orthogonal purposes:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 문제는 두 가지 직교 목적으로 사용할 수 있다는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fef004bb30a4e0c238ab2b8425780e54d9f658d4" translate="yes" xml:space="preserve">
          <source>The main reason for using inheritance is not as a form of composition - it is so you can get polymorphic behaviour. If you don't need polymorphism, you probably should not be using inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 사용하는 주된 이유는 구성의 형태가 아니기 때문에 다형성 동작을 얻을 수 있기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다형성이 필요하지 않으면 상속을 사용하지 않아야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb4e58f56ade41db120e0e321541a267008d9df9" translate="yes" xml:space="preserve">
          <source>The tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속에 의해 제공되는 긴밀한 결합은 서브 클래스의 구현이 상위 클래스의 구현과 매우 밀접한 관계가되므로 상위 구현의 변경으로 인해 서브 클래스가 변경됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6e1071aed30be94da0e2cdf87f2e045c58cf0cd" translate="yes" xml:space="preserve">
          <source>Then there are two ways to design an aircraft class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 항공기 클래스를 설계하는 두 가지 방법이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1377e93559cb9cad4550161694e59ceef28236fd" translate="yes" xml:space="preserve">
          <source>Then, I write the Set of integers as a subclass of the List of integers:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 정수 목록을 정수 목록의 하위 클래스로 작성합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba41722cdbc379b118c4e701663ebf832365813b" translate="yes" xml:space="preserve">
          <source>There are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren't necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the &lt;em&gt;DRY Principle&lt;/em&gt; (DRY = Don't Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such &quot;double method calls&quot; (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 구성에는 단점이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 완전히 건너 뛰고 컴포지션에만 중점을두면 상속을 사용하는 경우 필요하지 않은 몇 가지 추가 코드 줄을 작성해야하는 경우가 종종 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 또한 때때로 자신을 반복하도록 강요받으며 이것은 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;건조 원리를&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 위반합니다&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(건조 = 자신을 반복하지 마십시오). 또한 컴포지션에는 종종 위임이 필요하며 메서드는이 호출을 둘러싼 다른 코드없이 다른 객체의 다른 메서드를 호출합니다. 이러한 &quot;이중 메서드 호출&quot;(트리플 또는 쿼드 러플 메서드 호출로 쉽게 확장 될 수 있으며 그보다 훨씬 큼)은 상속하는 것보다 성능이 훨씬 나빠 부모의 메서드를 상속합니다. 상속 된 메소드를 호출하는 것은 상속되지 않은 메소드를 호출하는 것과 똑같이 빠르거나 약간 느릴 수 있지만 일반적으로 두 번의 연속 메소드 호출보다 여전히 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88dbe40d0ed3ede68edda71ef3030a4c38686ece" translate="yes" xml:space="preserve">
          <source>There are two benefits of inheritance: &lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html&quot;&gt;subtyping and subclassing&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속의 두 가지 이점이 있습니다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 타이핑 및 서브 클래 싱&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9613a336cd64521f866d933e120f5f900e231b8" translate="yes" xml:space="preserve">
          <source>There is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유 1을 사용하는 것은 나쁘지 않습니다. 객체에 견고한 인터페이스를 갖는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 인터페이스가 단순하고 변경되지 않는 경우 구성을 사용하거나 상속없이 문제없이 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 상속은 여기서 매우 효과적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ff1e38501fc05dc5ab2089683a417fc9d8ae800" translate="yes" xml:space="preserve">
          <source>These two ways can live together just fine and actually support each other.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 두 가지 방법은 함께 잘 살 수 있고 실제로 서로를 지원할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="96a0b8fbc97ccd7232afaf128e1f72ba9c64d8fe" translate="yes" xml:space="preserve">
          <source>Think of containment as a &lt;strong&gt;has a&lt;/strong&gt; relationship. A car &quot;has an&quot; engine, a person &quot;has a&quot; name, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;격리 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관계 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있다고 생각하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동차에는 &quot;엔진&quot;, 사람에는 &quot;이름&quot;등이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b6ec4f6260ad4a41e813b5819357d4fdd59cd6e" translate="yes" xml:space="preserve">
          <source>Think of inheritance as an &lt;strong&gt;is a&lt;/strong&gt; relationship. A car &quot;is a&quot; vehicle, a person &quot;is a&quot; mammal, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관계 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라고 생각하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동차는 &quot;차량&quot;, 사람은 &quot;동물&quot;등&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66d70c1014e5da803fb71e6a40877d96f60ee637" translate="yes" xml:space="preserve">
          <source>This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 클래스 사용을 권장합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 OO 디자인의 세 가지 신조 중 하나입니다 (상속, 다형성, 캡슐화).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02d27b966f445c927c12a951352c5a2ee16cc24d" translate="yes" xml:space="preserve">
          <source>This example will work fine, however, what if Person and Employee both declared &lt;code&gt;Title&lt;/code&gt;? Should Manager.Title return &quot;Manager of Operations&quot; or &quot;Mr.&quot;? Under composition this ambiguity is better handled:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나이 예제는 제대로 작동하지만 Person과 Employee가 모두 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Title&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 선언하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떻게됩니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Manager.Title이 &quot;Manager of Operations&quot;또는 &quot;Mr.&quot;를 반환해야합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성에서이 모호성은 더 잘 처리됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bdb26a327b7e7a1f89230942d7086df40a2044bb" translate="yes" xml:space="preserve">
          <source>This is a classic example of an improper use of inheritance. Use composition in this case.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 상속의 부적절한 사용에 대한 전형적인 예입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 컴포지션을 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="892eb23b0e64d101eac60b59156102e0dc8377de" translate="yes" xml:space="preserve">
          <source>This is called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;Circle-Ellipse problem&lt;/a&gt;, which really isn't a problem, just a clear proof that the first test alone isn't enough to conclude that inheritance is possible. In particular, this example highlights that derived classes should &lt;em&gt;extend&lt;/em&gt; the functionality of base classes, never &lt;em&gt;restrict&lt;/em&gt; it. Otherwise, the base class couldn't be used polymorphically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원형 타원 문제&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라고합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이것은 실제로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 아니며, 첫 번째 테스트만으로는 상속이 가능하다는 결론을 내리기에 충분하지 않다는 명백한 증거입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히,이 예제는 파생 클래스가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스의 기능을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;확장&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하고 절대로 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제한&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하지 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않아야 함을 강조 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않으면 기본 클래스를 다형성으로 사용할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c1a3f007444e788c520debfe97ad582556ee1e" translate="yes" xml:space="preserve">
          <source>This is inheritance at work. The Employee &quot;is a&quot; Person or inherits from Person. All inheritance relationships are &quot;is-a&quot; relationships. Employee also shadows the Title property from Person, meaning Employee.Title will return the Title for the Employee not the Person.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 직장에서의 상속입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직원은 &quot;개인&quot;이거나 개인으로부터 상속받습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 상속 관계는 &quot;is-a&quot;관계입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 Employee는 Person의 Title 속성을 숨 깁니다. 이는 Employee를 의미합니다. Title은 Person이 아닌 Employee의 제목을 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bfff73a25d5d08232eb54847cfc587269729bfb" translate="yes" xml:space="preserve">
          <source>To address this question from a different perspective for newer programmers:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 프로그래머를위한 다른 관점에서이 질문을 해결하려면 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="948c2e5682be0db8695bdb1c215662f9b744cd72" translate="yes" xml:space="preserve">
          <source>To give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 예제를 제공하기 위해 추상 데이터 유형, 정수 세트 및 정수 목록에 대해 생각해보십시오. 보유 할 수있는 값은 정수로 제한됩니다. 둘 다 add (newValue) 및 size ()와 같은 일련의 메소드를 지원합니다. 그리고 둘 다 다른 속성을 가지고 있습니다 (클래스 불변) .Sets는 중복을 허용하지 않지만 List는 중복을 허용합니다 (물론 둘 다 만족하는 다른 속성이 있습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8dfe69d77cbdafc2b0a714261fbe7a897520f08c" translate="yes" xml:space="preserve">
          <source>To subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서브 타입은 타입 시그니처를 따르는 것인데, 이는 컴포지션이 항상 타입의 API를 최소한으로 노출시켜야한다는 것을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 트레이드 오프가 시작됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d54b82edafd720a780f59eaceb3e260ef8e20abd" translate="yes" xml:space="preserve">
          <source>To understand why &quot;&lt;em&gt;prefer&lt;/em&gt; composition over inheritance&quot;, we need first get back the assumption omitted in this shortened idiom.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 구성을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;선호&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는지 이해하려면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저이 단축 된 관용구에서 생략 된 가정을 되 찾아야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30b841e646c940730a92f3a6fde8ddbb4fa7b8a7" translate="yes" xml:space="preserve">
          <source>Unfortunately, the above test alone is not reliable. Use the following instead:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행히도, 위의 테스트만으로는 신뢰할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신 다음을 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="902e9220c7e8e78a1688a9c75dc574c63e2d44d9" translate="yes" xml:space="preserve">
          <source>We discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, &quot;If I'm inherited type A, do this, but if I'm inherited type B, do that.&quot; That's bad for lots of reasons. One is that every time we change the base class, we're effectively changing every inherited class. So we're really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 기본 클래스에서 상속받은 클래스 중 하나에 대해서만 기본 클래스가 약간 다르게 동작하기를 원한다는 것을 발견했습니다. 이제 기본 클래스로 돌아가서 약간의 가상 메소드를 추가하거나 더 나쁜 경우, &quot;유형 A를 상속받은 경우, 이렇게하십시오. 그러나 B를 상속받은 경우에는 그렇게하십시오. &quot; 여러 가지 이유로 나쁘다. 하나는 기본 클래스를 변경할 때마다 상속 된 모든 클래스를 효과적으로 변경한다는 것입니다. 우리는 클래스 A에서 약간 다른 행동이 필요하기 때문에 클래스 A, B, C 및 D를 실제로 변경하고 있습니다. 우리가 생각하는대로 조심스럽게 생각하면 클래스와 관련이없는 이유로 클래스 중 하나를 중단 할 수 있습니다 클래스.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6227a652268bd11d1b6cbf24ac145873c6174ca7" translate="yes" xml:space="preserve">
          <source>We discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 클래스가 갖고 싶은 다른 함수가 있다는 것을 발견했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스에 기능을 추가하는 방법이 상속을 통해 이루어지면 결정해야합니다. 상속을받는 모든 클래스가 해당 기능을 필요로하지 않더라도 기존 기본 클래스에 추가해야합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 기본 클래스를 작성합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 다른 기본 클래스에서 이미 상속받은 클래스는 어떻습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2615b408bdb1e0ba98c485bf5cdf2441399a639" translate="yes" xml:space="preserve">
          <source>We might know why we decided to make all of these classes inherit from each other, but it might not (probably won't) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 왜 이러한 클래스를 모두 서로 상속하기로 결정했는지 알 수 있지만 코드를 유지 관리해야하는 다른 사람에게는 의미가 없을 수도 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 그것들을 어려운 선택으로 강요 할 수 있습니다. 내가 필요한 변화를 만들기 위해 정말 못 생겼고 지저분한 일을합니까 (이전 글 머리표 참조).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e5823e905840f2d1a0b16c41e23924b6b4651bd" translate="yes" xml:space="preserve">
          <source>What do you think about this approach?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 접근법에 대해 어떻게 생각하십니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1756bd1b9efd32a1d214b99f06d2f7a4f7d669c" translate="yes" xml:space="preserve">
          <source>When can you use inheritance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 언제 사용할 수 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d970be0b61d6aad200582d59cc11f107fad3f0af" translate="yes" xml:space="preserve">
          <source>When should you use inheritance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 언제 사용해야합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="428208f05c644812526e760213d893a9e0d85b4f" translate="yes" xml:space="preserve">
          <source>When we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;숫자 5가 정수 유형이라고 할 때 5는 가능한 값 세트에 속한다고합니다 (예를 들어, Java 기본 유형의 가능한 값 참조). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 덧셈과 뺄셈과 같은 값으로 수행 할 수있는 유효한 방법이 있다고 말하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 우리는 항상 만족하는 속성 세트가 있다고 말하고 있습니다. 예를 들어 값 3과 5를 추가하면 결과적으로 8이됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="09af7bb65f1be8d511ca24f115a8de295966a370" translate="yes" xml:space="preserve">
          <source>When you have an &lt;strong&gt;is-a&lt;/strong&gt; relation between two classes (example dog is a canine), you go for inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 클래스 사이에 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;is-a&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관계 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 있으면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(예 : 개는 개), 상속을받습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0055b1a10a69cdf90f2c9f52386c2e6f796966" translate="yes" xml:space="preserve">
          <source>When you want to &quot;copy&quot;/Expose the base class' API, you use inheritance. When you only want to &quot;copy&quot; functionality, use delegation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스의 API를 &quot;복사&quot;/ 노출하려면 상속을 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기능 만 &quot;복사&quot;하려면 위임을 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68d2706b23183a0d7d52371d8dfbf231a40a8ff7" translate="yes" xml:space="preserve">
          <source>Whether the base class can be instantiated. That is, whether the base class can be non-abstract.  If it can be non-abstract I usually prefer composition</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스를 인스턴스화 할 수 있는지 여부 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 기본 클래스가 비 추상적 일 수 있는지 여부입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 비 추상적 일 수 있다면 나는 보통 구성을 선호한다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a606c7a3b25e33c0493da4afddb01b3c57747671" translate="yes" xml:space="preserve">
          <source>Which class design is better?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어느 클래스 디자인이 더 낫습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1791d8464070d229c878a59d0498e929cd34625" translate="yes" xml:space="preserve">
          <source>While in short words I would agree with &quot;Prefer composition over inheritance&quot;, very often for me it sounds like &quot;prefer potatoes over coca-cola&quot;. There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is &quot;if you are going to use inheritance - think again, chances are you need composition&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단히 말해서 나는 &quot;상속보다 구성을 선호한다&quot;에 동의하지만, 종종 &quot;코카콜라보다 감자를 선호한다&quot;고 들린다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속 장소와 구성 장소가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차이점을 이해해야합니다. 그러면이 질문은 사라집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 저에게 실제로 의미하는 것은 &quot;상속을 사용하려는 경우 다시 생각하면 구성이 필요할 것입니다&quot;입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="027a582c02cb725a52172159b5c1aa8f207673db" translate="yes" xml:space="preserve">
          <source>Why prefer composition over inheritance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 구성을 선호하는 이유는 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28ebe126ef18993fcdc302fb140fe416bf4b44bd" translate="yes" xml:space="preserve">
          <source>Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 구성을 선호하는 이유는 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 접근법마다 어떤 절충점이 있습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성보다 상속을 언제 선택해야합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="8a5494e3346ea1f03b16a7e69409337675dba6a2" translate="yes" xml:space="preserve">
          <source>With all the undeniable benefits provided by inheritance, here's some of its disadvantages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 통해 부인할 수없는 모든 혜택을 누리면 다음과 같은 단점이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="187b043aa54e89394b8d77a7ea3e521335e23aa7" translate="yes" xml:space="preserve">
          <source>With inheritance, you can define/modify/extend a capability</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 통해 기능을 정의 / 수정 / 확장 할 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c909e0bb35edebdb81f6b7167ac08348fb47388c" translate="yes" xml:space="preserve">
          <source>With the above trade offs in mind, we hence &lt;em&gt;prefer&lt;/em&gt; composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 장단점을 염두에두고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속보다 구성을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;선호합니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 밀접하게 관련된 클래스, 즉 암시 적 코드 재사용이 실제로 이익을 얻거나 개방형 재귀의 마법의 힘이 필요한 경우 상속이 선택됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca54eb74c9e8cc45b664e45d5cd2d030838c910b" translate="yes" xml:space="preserve">
          <source>With the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속을 수행하는 두 가지 목적, 즉 서브 타이핑 지향과 코드 재사용 지향의 두 가지 이점이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6f46fcaef29ad747c9c053a5250628a59ec8937" translate="yes" xml:space="preserve">
          <source>You can't change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임에 수퍼 클래스에서 상속 된 구현을 변경할 수 없습니다 (물론 상속은 컴파일 타임에 정의되므로).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c841ca97d91f3a90e4a981be8a8e3eaf9eca4bee" translate="yes" xml:space="preserve">
          <source>You have many classes with &lt;strong&gt;same interface&lt;/strong&gt; and you want to save time writing them</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한 인터페이스를&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가진 많은 클래스가 있으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성 시간을 절약하고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f7027c12ff7351a14aec7ceaf153b91f1cd5a76" translate="yes" xml:space="preserve">
          <source>You have to use same Base Class for each object</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 객체에 대해 동일한 기본 클래스를 사용해야합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db9d5b717fd3a0428e874979b657d64399fb0932" translate="yes" xml:space="preserve">
          <source>You may have noticed that most OO languages don't allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think &quot;multiple inheritance would be a really cool feature to solve this problem&quot;, you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 OO 언어는 다중 상속을 허용하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다중 상속이 실제로 무언가를 구입할 수있는 몇 가지 경우가 있지만 규칙보다는 예외입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;여러 상속이이 문제를 해결하는 정말 멋진 기능&quot;이라고 생각하는 상황에 처할 때마다 대개 몇 가지 추가 코드 줄이 필요할 수 있으므로 상속을 다시 생각해야하는 시점에 있습니다. 구성에 기반한 솔루션은 일반적으로 훨씬 더 우아하고 유연하며 미래의 증거로 판명됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6461c7d3d8ea98d44e07224509d8188c5fd65616" translate="yes" xml:space="preserve">
          <source>You need to have a look at &lt;strong&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;The Liskov Substitution Principle&lt;/a&gt;&lt;/strong&gt; in Uncle Bob's &lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;SOLID&lt;/a&gt; principles of class design. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bob 삼촌의 &lt;/font&gt;&lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SOLID&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스 설계 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원칙&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있는 Liskov 대체 원리&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;살펴 봐야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:)&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="365fd5a8c9d353531398ff13dddbb1a9cd04bd1f" translate="yes" xml:space="preserve">
          <source>You need to modify the private variables, which can not be public in any case</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떤 경우에도 공개 될 수없는 개인 변수를 수정해야합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="debc0fa37d0f792340965981a5a035cc009e22ae" translate="yes" xml:space="preserve">
          <source>You should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먹고 싶을 때는 코카콜라보다 감자를, 마시고 싶을 때는 감자보다 코카콜라를 선호해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70a3f516785b8d2c0cef4b9bfa90e997156cdb0e" translate="yes" xml:space="preserve">
          <source>Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 클래스는 구현 된 세부 정보를 보호 된 멤버 형태로 하위 클래스에 노출시켜 캡슐화를 중단합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 시스템을 단단하고 취약하게 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 더 비극적 인 결함은 새로운 하위 클래스가 상속 체인의 모든 수하물과 의견을 가져 오는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7b6ec9ba3ba6cb389d0be77dde1a3a2b1b3c784" translate="yes" xml:space="preserve">
          <source>a bar is a foo</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바는 foo입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="321619efe153470d82ced208ab3b5924f96e157d" translate="yes" xml:space="preserve">
          <source>a bar is a foo, &lt;strong&gt;AND&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바는 foo, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AND&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e151551bf5c2dbfb47e6ba04d1cb6d6f9881994" translate="yes" xml:space="preserve">
          <source>all of this applies less to small projects than large ones, and less
  to private classes than public ones</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 모든 것은 큰 프로젝트보다 작은 프로젝트에 덜 적용되고 공개 프로젝트보다 작은 프로젝트에 덜 적용됩니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7704fccffa58783a84da4eb8c0166fdf191a3fdd" translate="yes" xml:space="preserve">
          <source>an engine with wings. But what if I wanted to change</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;날개가 달린 엔진. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지만 내가 바꾸고 싶다면&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8dde7711f9ea3766728a62f96c6515f11ba48445" translate="yes" xml:space="preserve">
          <source>and change them to rotary wings on the fly. It's essentially</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;회전 날개로 즉시 변경하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;본질적으로&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="729852eb34a3e850ade763665925935482786102" translate="yes" xml:space="preserve">
          <source>bars can do everything that foos can do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바는 푸가 할 수있는 모든 것을 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b17efef870e73ac5a6927dfab46f89a43147e20" translate="yes" xml:space="preserve">
          <source>e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 조류는 비행기의 비행 행동 만 필요할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 인터페이스 / 클래스 / 둘 다로 추출하여 두 클래스의 멤버로 만드는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="886bf306e5453e891f922ec6a0c0d688fc89e7b2" translate="yes" xml:space="preserve">
          <source>e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 Cessna 복엽 비행기는 비행기의 전체 인터페이스를 보여줍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 비행기에서 파생되는 것이 적합합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="696ad70d6976b57faf133b6ee5ef5b78578b56f1" translate="yes" xml:space="preserve">
          <source>e.g. If  &lt;em&gt;Car&lt;/em&gt; contains &lt;em&gt;Vehicle&lt;/em&gt; and if you have to get price of the &lt;em&gt;Car&lt;/em&gt;, which has been defined in &lt;em&gt;Vehicle&lt;/em&gt;, your code will be like this</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 만약 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동차가&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 포함 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차량을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하고 가격 얻을 수있는 경우 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동차&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 정의 된, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차량을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 코드는 다음과 같이 될 것입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="1fc4018d629a16d759e998a6c95e3a4757b18a87" translate="yes" xml:space="preserve">
          <source>implementation (for code reuse)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현 (코드 재사용)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8242e2b420f05d62490ce28c67966e458a29c56a" translate="yes" xml:space="preserve">
          <source>inheritance is probably the worst form of coupling you can have</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속은 아마도 최악의 결합 형태 일 것입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2804e2e271f82c68b66f986da5df262ee4cb967" translate="yes" xml:space="preserve">
          <source>interface (for polymorphism)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스 (다형성)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13ac262839d95d773d2a3d28f3999d812e21769b" translate="yes" xml:space="preserve">
          <source>properties, or I redesign &lt;code&gt;Aircraft&lt;/code&gt; as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Aircraft&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 다음과 같이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재 설계 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8823f52bf571c1ac1f5e036a349bdba206f867f6" translate="yes" xml:space="preserve">
          <source>the engine on the fly as well?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;엔진도 즉시?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
