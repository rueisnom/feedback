<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/49002">
    <body>
      <group id="49002">
        <trans-unit id="19e4a51166cdfb3ff9a0baa3e1422bffe26ed5b1" translate="yes" xml:space="preserve">
          <source>(a fragment from: &lt;a href=&quot;http://www.copypasteisforword.com/notes/use-inheritance-properly&quot;&gt;use inheritance properly&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(фрагмент из: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.copypasteisforword.com/notes/use-inheritance-properly&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;правильно использовать наследование&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3cf3c58c0ff1ab151c796159d9fba6934da34ccd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Wikipedia&lt;/a&gt; offers a nice overview of the topic being discussed in this question.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Википедия&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предлагает хороший обзор темы, обсуждаемой в этом вопросе.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84d22270db5c3c635539d2d8ae442c8752d70e66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Car is a Vehicle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Автомобиль - это Автомобиль&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc60060a7f66a3c1423f56735ed1401baf4fbfea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Classes get heavier&lt;/em&gt; - you don't necessarily know what work your superclass is doing in its constructor, or how much memory it's going
  to use. So constructing some innocent would-be lightweight object can
  be far more expensive than you think, and this may change over time if
  the superclass evolves</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Классы становятся тяжелее&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - вы не обязательно знаете, что делает ваш суперкласс в своем конструкторе, или сколько памяти он собирается использовать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому создание какого-то невинного потенциального легковесного объекта может оказаться намного дороже, чем вы думаете, и со временем это может измениться, если суперкласс развивается&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd3b79af469cff75a228b80ca85b2a0c9d81150b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Innocent acts can have unexpected results&lt;/em&gt; - The classic example of this is calls to overridable methods from the superclass
  constructor, before the subclasses instance fields have been
  initialized. In a perfect world, nobody would ever do that. This is
  not a perfect world.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Невинные действия могут привести к неожиданным результатам&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Классическим примером этого являются вызовы переопределяемых методов из конструктора суперкласса до инициализации полей экземпляра подкласса. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В идеальном мире никто никогда бы не сделал это. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не идеальный мир.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d09d2c9a3f2c14f6cb59dcf58a0f00d467588cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It encourages an explosion of subclasses&lt;/em&gt;. Classloading costs time, more classes costs memory. This may be a non-issue until you're
  dealing with an app on the scale of NetBeans, but there, we had real
  issues with, for example, menus being slow because the first display
  of a menu triggered massive class loading. We fixed this by moving to
  more declarative syntax and other techniques, but that cost time to
  fix as well.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это поощряет взрыв подклассов&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Загрузка классов стоит времени, больше классов - памяти. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это может быть не проблема, пока вы не имеете дело с приложением в масштабе NetBeans, но там у нас были реальные проблемы, например, с медленным меню, потому что первое отображение меню вызвало массовую загрузку классов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы исправили это, перейдя к более декларативному синтаксису и другим методам, но это также потребовало времени на исправление.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="99b00c9cf8e683fccb25eac102b209f855086a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It makes it harder to change things later&lt;/em&gt; - if you've made a class public, swapping the superclass is going to break subclasses -
  it's a choice which, once you've made the code public, you're married
  to. So if you're not altering the real functionality to your
  superclass, you get much more freedom to change things later if you
  use, rather than extend the thing you need. Take, for example,
  subclassing JPanel - this is usually wrong; and if the subclass is
  public somewhere, you never get a chance to revisit that decision. If
  it's accessed as JComponent getThePanel() , you can still do it (hint:
  expose models for the components within as your API).</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Позже становится сложнее что-то менять&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - если вы сделали класс общедоступным, замена суперкласса приведет к поломке подклассов - это выбор, на котором после того, как вы сделали код общедоступным, вы будете женаты. Поэтому, если вы не изменяете реальную функциональность своего суперкласса, вы получаете гораздо больше свободы, чтобы изменить вещи позже, если вы используете, а не расширять то, что вам нужно. Взять, к примеру, создание подклассов JPanel - это обычно неправильно; и если подкласс где-то публичный, у вас никогда не будет возможности пересмотреть это решение. Если к нему обращаются как JComponent getThePanel (), вы все равно можете это сделать (подсказка: показать модели для компонентов в качестве вашего API).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9fea8abbd67148f9aaad86c2cc91e5b50984e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It offers perverse temptations for subclassers to make assumptions about order of method calls and such&lt;/em&gt; - such assumptions tend not to
  be stable if the superclass may evolve over time. See also &lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;amp;messageID=91819530#91819530&quot;&gt;my toaster
  and coffee pot analogy&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он предлагает извращенные соблазны для субклассеров делать предположения о порядке вызовов методов и тому подобное&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - такие предположения, как правило, не являются стабильными, если суперкласс может развиваться со временем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смотрите также &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;amp;messageID=91819530#91819530&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;мою аналогию с тостером и кофейником&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f2d1a02f1330761039247ff2ac486fa4bcd2963" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Object hierarchies don't scale (or making them scale later is much harder than planning ahead)&lt;/em&gt; - this is the classic &quot;too many layers&quot;
  problem. I'll go into this below, and how the AskTheOracle pattern can
  solve it (though it may offend OOP purists).</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Иерархии объектов не масштабируются (или сделать их масштабирование позже гораздо сложнее, чем планировать заранее)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это классическая проблема &amp;laquo;слишком много слоев&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я расскажу об этом ниже и о том, как шаблон AskTheOracle может решить эту проблему (хотя он может оскорблять пуристов ООП).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de6ccea047149366a9dda9ed695b699d688314a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.&lt;/em&gt; With composition, it's easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предпочитайте композицию наследованию, так как она более гибкая / ее легко изменить позже, но не используйте подход, всегда составляемый. &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С составом, легко изменить поведение на лету с помощью инъекций / сеттеров зависимостей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наследование более жесткое, так как большинство языков не позволяют вам наследовать от более чем одного типа. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, гусь более или менее готовится, как только вы получаете от TypeA.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4308a41a321f00f54f99cdd2884e9094023fd662" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Truck is a Vehicle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Грузовик - это транспортное средство&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f587fb9140a968f772a8162968129fa88e330b59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cons of Composition:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Минусы композиции:&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="790ced1c5a0bbe20b15223aa6a4e22337bfcd462" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Pros of Inheritance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Плюсы наследования:&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a69a0cc249ebb716c5b801c19b32afb8a98697dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Because inheritance is a poor way of moving information&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Потому что наследование - плохой способ передачи информации&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="642f86d54fa53fe530b7fceb3af4325e550ae72b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages of Inheritance:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Недостатки наследования:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30e3ffdd81cf85d5a9b7fbf8f2b5ed8777d2cb4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1: Dog --&amp;gt; Animal&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пример 1: Собака -&amp;gt; Животное&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08d6fcd73932e2db1e487ea9c038b47cd04b4f4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2: Circle -/-&amp;gt; Ellipse&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пример 2: Круг - / -&amp;gt; Эллипс&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22d74f86d3cbdef89198b5678344bd3b330b51a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REFERENCE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REFERENCE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01e62217f11659bf6313a453455a96ddfecb964" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subclassing&lt;/strong&gt; means implicit reuse of method implementations.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подклассирование&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает неявное повторное использование реализаций метода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46f346af11e821ee7e1ce39993d2a8fb3fd69a7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subtyping&lt;/strong&gt; means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подтипирование&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает соответствие сигнатуре типа (интерфейса), то есть набора API, и можно переопределить часть сигнатуры для достижения полиморфизма подтипа.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="133fbefb42fa53f06d9d810164f60ab910ebfa77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov's &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; as a test for 'Should I be inheriting from this type?'</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обновление:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; только что вернулся к моему ответу, и теперь кажется, что он неполон без конкретного упоминания &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;принципа подстановки Лискова&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Барбары &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в качестве теста для &amp;laquo;Должен ли я наследовать от этого типа?&amp;raquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5fe3b54cb63f0b09fd4abeb10b7c42f52993fc0c" translate="yes" xml:space="preserve">
          <source>@MatthieuM. says in &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&quot;&gt;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@MatthieuM. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;говорит в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d66bf495a38f7905720f390dbf27d3cd5934bd" translate="yes" xml:space="preserve">
          <source>A circle is an ellipse BUT circles can't do everything that ellipses can do. For example, circles can't stretch, while ellipses can. Therefore, the class &lt;code&gt;Circle&lt;/code&gt;&lt;strong&gt;cannot&lt;/strong&gt; inherit the class &lt;code&gt;Ellipse&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Круг - это эллипс, НО круги не могут делать все, что могут делать эллипсы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, круги не могут растягиваться, а эллипсы могут. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Следовательно, класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Circle&lt;/code&gt; &lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не может&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; наследовать класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Ellipse&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed02723917385f91dd310ca5a8a52e74215144aa" translate="yes" xml:space="preserve">
          <source>A dog is an animal AND dogs can do everything that animals can do (such as breathing, dying, etc.). Therefore, the class &lt;code&gt;Dog&lt;/code&gt;&lt;strong&gt;can&lt;/strong&gt; inherit the class &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Собака - это животное, и собаки могут делать все, что могут делать животные (например, дышать, умирать и т. Д.). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Следовательно, класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Dog&lt;/code&gt; &lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;может&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; наследовать класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Animal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01287059a41e22e70d573f7784b74fea385c7a85" translate="yes" xml:space="preserve">
          <source>A much more complete and concrete &lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;amp;threadID=16487#91822172&quot;&gt;answer from Tim Boudreau&lt;/a&gt; of Sun:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Гораздо более полный и конкретный &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;amp;threadID=16487#91822172&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответ Тима Будро&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из Sun:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ecfbd413e3b64a89620f4a0c3113ea12be77cd9" translate="yes" xml:space="preserve">
          <source>A rule of thumb I have heard is inheritance should be used when its a &quot;is-a&quot; relationship and composition when its a &quot;has-a&quot;. Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.</source>
          <target state="translated">Я слышал правило,что наследство должно использоваться,когда оно имеет отношение &quot;is-a&quot;,а композиция,когда оно имеет отношение &quot;has-a&quot;.Даже при этом я считаю,что всегда следует склоняться к композиции,потому что это устраняет много сложностей.</target>
        </trans-unit>
        <trans-unit id="7ba0c4f8f2f7998fd84e1b2e18671bab5f8dbd05" translate="yes" xml:space="preserve">
          <source>A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same &lt;em&gt;interface&lt;/em&gt; as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level &lt;em&gt;implementation&lt;/em&gt; differs, the high-level &lt;em&gt;interface&lt;/em&gt; remains the same).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Простой способ разобраться в этом состоит в том, что наследование следует использовать, когда вам нужно, чтобы объект вашего класса имел тот же &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интерфейс,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что и его родительский класс, чтобы его можно было таким образом рассматривать как объект родительского класса (апкастинг) , Более того, вызовы функций для объекта производного класса в коде будут оставаться одинаковыми везде, но конкретный вызываемый метод будет определен во время выполнения (т. Е. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реализация&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; низкого уровня &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отличается, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интерфейс&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; высокого уровня &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;остается тем же).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf4a40229fa15c4916233897eb3cd85732b5ca8" translate="yes" xml:space="preserve">
          <source>Also, I support @anon answer in &lt;a href=&quot;https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1&quot;&gt;Why use inheritance at all?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, я поддерживаю ответ @anon в разделе &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Почему вообще используется наследование?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fcf41a9237c1dac7d08f4bbf45ff16fef75d4e1" translate="yes" xml:space="preserve">
          <source>An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering more object oriented design.</source>
          <target state="translated">Примером может служить PHP без использования классов (особенно до PHP5).Вся логика закодирована в наборе функций.Вы можете включать другие файлы,содержащие вспомогательные функции и т.д.и вести свою бизнес-логику,передавая данные в функциях.С этим может быть очень сложно справиться по мере роста приложения.PHP5 пытается исправить это,предлагая более объектно-ориентированный дизайн.</target>
        </trans-unit>
        <trans-unit id="003b46e7955af669ca0d0b1ccab8ff624590d7d7" translate="yes" xml:space="preserve">
          <source>Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It's really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren't always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.</source>
          <target state="translated">Другая,очень прагматичная причина,предпочитать композицию,а не наследование,связана с вашей моделью домена и сопоставлением ее с реляционной базой данных.Очень сложно сопоставить наследование с SQL моделью (в итоге вы получаете всевозможные хакерские обходные пути,например,создание колонок,которые не всегда используются,использование представлений и т.д.).Некоторые ORML пытаются справиться с этим,но это всегда быстро усложняется.Состав можно легко смоделировать с помощью внешних связей между двумя таблицами,но наследование намного сложнее.</target>
        </trans-unit>
        <trans-unit id="b3ead00c7eaee34c442057dee94f69e62fca38dd" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class &lt;code&gt;Widget&lt;/code&gt; in GUI frameworks, or a polymorphic class &lt;code&gt;Node&lt;/code&gt; in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как правило, я склонен выбирать наследование вместо композиции, когда ожидается, что полиморфное использование будет очень распространенным, и в этом случае мощь динамической диспетчеризации может привести к гораздо более читаемому и элегантному API. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, наличие полиморфного класса &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в платформах GUI или полиморфного класса &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Node&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в библиотеках XML позволяет иметь API, который гораздо более читабелен и интуитивно понятен, чем тот, который вы имели бы с решением, основанным исключительно на композиции.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="19790e17c44a9b95a38b06493bf40dd98fb49535" translate="yes" xml:space="preserve">
          <source>As many people told, I will first start with the check - whether there exists an &quot;is-a&quot; relationship. If it exists I usually check the following:</source>
          <target state="translated">Как многие говорили,я начну с проверки-существуют ли отношения &quot;есть-а&quot;.Если они существуют,я обычно проверяю следующее:</target>
        </trans-unit>
        <trans-unit id="fda1192189400839b8b95f4e3718dccf23de4a71" translate="yes" xml:space="preserve">
          <source>As soon as someone explained &quot;favor composition over inheritance&quot; to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn't really work well.</source>
          <target state="translated">Как только кто-то объяснил мне &quot;предпочтение композиции перед наследством&quot;,я вспоминал каждый раз,когда пытался поделиться функциональностью между классами,использующими наследование,и понимал,что в большинстве случаев это работало не очень хорошо.</target>
        </trans-unit>
        <trans-unit id="dd869ae1d27b49cf539b23ec39ba981088b4ec6a" translate="yes" xml:space="preserve">
          <source>Aside from is a/has a considerations, one must also consider the &quot;depth&quot; of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.</source>
          <target state="translated">Помимо соображений,необходимо также учитывать &quot;глубину&quot; наследования,через которую должен пройти ваш объект.Все,что выходит за рамки пяти или шести уровней глубины наследования,может вызвать неожиданные проблемы с кастингом и боксом,и в этих случаях,возможно,было бы разумно составить свой объект вместо этого.</target>
        </trans-unit>
        <trans-unit id="382e62ec5112339ce9d05227c6fa3d942c472f7a" translate="yes" xml:space="preserve">
          <source>At the risk of oversimplifying, that's composition - composing multiple classes to work together. And once we form that habit we find that it's much more flexible, maintainable, and testable than using inheritance.</source>
          <target state="translated">Рискуя чрезмерно упростить,это и есть композиция-сочинять несколько классов для совместной работы.И как только мы формируем эту привычку,мы обнаруживаем,что она гораздо более гибкая,поддерживаемая и контролепригодная,чем использование наследования.</target>
        </trans-unit>
        <trans-unit id="400d0992f15edf3eca262b5209a73094f8d6e110" translate="yes" xml:space="preserve">
          <source>Base class defines structure of the algorithm  and sub-class will override a part of algorithm =&amp;gt; &lt;strong&gt;&lt;em&gt;You can implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;Template_method&lt;/a&gt; without change in base class skeleton&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Базовый класс определяет структуру алгоритма, а подкласс переопределит часть алгоритма =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете реализовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Template_method&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; без изменений в скелете базового класса&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c024738e730ecac1df27b0bab86fd28a7f5eab0" translate="yes" xml:space="preserve">
          <source>Base class provides default implementation and sub-class can change the behaviour =&amp;gt; &lt;strong&gt;&lt;em&gt;You can re-define contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Базовый класс обеспечивает реализацию по умолчанию, а подкласс может изменить поведение =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете переопределить контракт&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec79a6576dd1a829ef1be9035eab29495e4a39ac" translate="yes" xml:space="preserve">
          <source>Base class provides no implementation and sub-class has to override complete method (abstract) =&amp;gt; &lt;strong&gt;&lt;em&gt;You can implement a contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Базовый класс не обеспечивает реализацию, а подкласс должен переопределять полный метод (аннотация) =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете реализовать контракт&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5071aef9005443060d06d71c91df8e638ed8f5f" translate="yes" xml:space="preserve">
          <source>Call no methods from the superclass constructor</source>
          <target state="translated">Не вызывать методы из конструктора суперкласса</target>
        </trans-unit>
        <trans-unit id="4b96cc03f1983251e435c5372fac4d177913e2d5" translate="yes" xml:space="preserve">
          <source>Common problems to the use of inheritance as I see it are:</source>
          <target state="translated">Общие проблемы с использованием наследства,как я вижу:</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="81f2d2c7a8be16bc594e920e17d27d214e445279" translate="yes" xml:space="preserve">
          <source>Composition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in &lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java&quot;&gt;decorator pattern&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java&quot;&gt;proxy pattern&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Композиция имеет Подходят инверсии управления, и его зависимость может быть введен динамически, как показано на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;декоратор&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;прокси - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;шаблона&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58f3246a619006b9498ebf3dce3fe08d69bb09f" translate="yes" xml:space="preserve">
          <source>Composition has the benefit of &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators&quot;&gt;combinator-oriented&lt;/a&gt; programming, i.e. working in a way like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern#Java&quot;&gt;composite pattern&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Композиция имеет преимущество &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;комбинаторно-ориентированного&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; программирования, то есть работает как &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern#Java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;составной шаблон&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b61664eea08164f2bdbcf4e14aaae6423d48a24e" translate="yes" xml:space="preserve">
          <source>Composition has the benefit of easy &lt;a href=&quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance&quot;&gt;multiple inheritance&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Преимущество композиции заключается в легком &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;множественном наследовании&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0686522d6dc64a26474dd45526ab7c5d6f2976fd" translate="yes" xml:space="preserve">
          <source>Composition immediately follows &lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;programming to an interface&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Композиция сразу следует за &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;программированием интерфейса&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46ef1a92cd606125c6540b7b2b01afd6a3c39af1" translate="yes" xml:space="preserve">
          <source>Composition is favoured over inheritance. To put it very simply you would have:</source>
          <target state="translated">Составу отдается предпочтение перед наследством.Проще говоря,вы бы так и сделали:</target>
        </trans-unit>
        <trans-unit id="5a48c284575bc59295e94ae273beff875be00b0e" translate="yes" xml:space="preserve">
          <source>Composition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it's quite safe and easy to use composition. There are so many possibilites here.</source>
          <target state="translated">Композиция просто играет на модульной основе:вы создаете интерфейс,похожий на родительский класс,создаете новый объект и делегируете ему вызовы.Если этим объектам не нужно знать друг о друге,то композиция достаточно безопасна и проста в использовании.Здесь так много возможностей.</target>
        </trans-unit>
        <trans-unit id="ae3589f9e16ef3d74aae74f9cc0e37a51e1e1c2f" translate="yes" xml:space="preserve">
          <source>Composition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the &quot;&lt;em&gt;Single Responsibility Principle&lt;/em&gt;&quot;, which is often summarized as &quot;&lt;em&gt;There should never be more than one reason for a class to change.&lt;/em&gt;&quot;, and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our &lt;em&gt;real world&lt;/em&gt; pretty well, but that isn't the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Композиция часто более логична, она обеспечивает лучшую абстракцию, лучшую инкапсуляцию, лучшее повторное использование кода (особенно в очень больших проектах) и с меньшей вероятностью что-либо сломает на расстоянии только потому, что вы сделали изолированное изменение в любом месте вашего кода. Это также облегчает соблюдение &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Принципа единой ответственности&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;, который часто резюмируется как &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У класса никогда не должно быть более одной причины для изменения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;. Это означает, что каждый класс существует для определенной цели, и он должен есть только методы, которые напрямую связаны с его целью. Кроме того, наличие очень мелкого дерева наследования значительно упрощает обзор, даже когда ваш проект начинает становиться действительно большим. Многие люди думают, что наследство представляет наш &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реальный мир&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;довольно хорошо, но это не правда. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реальный мир использует гораздо больше композиции, чем наследования. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Практически каждый объект реального мира, который вы можете держать в руке, был составлен из других, меньших объектов реального мира.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10f3a58f627a1c06a673bba20f0d87bcfa973635" translate="yes" xml:space="preserve">
          <source>Composition is typically &quot;has a&quot; or &quot;uses a&quot; relationship. Here the Employee class has a Person. It does not inherit from Person but instead gets the Person object passed to it, which is why it &quot;has a&quot; Person.</source>
          <target state="translated">Композиция,как правило,&quot;имеет&quot; или &quot;использует&quot; отношения.Здесь у класса &quot;Сотрудник&quot; есть Человек.Он не наследует от Человека,а вместо этого получает переданный ему объект Человек,вот почему он &quot;имеет&quot; Человек.</target>
        </trans-unit>
        <trans-unit id="3fd117ba0aac29cf18bbb9d63f44b9e57ef72792" translate="yes" xml:space="preserve">
          <source>Composition over Inheritance</source>
          <target state="translated">Состав по наследству</target>
        </trans-unit>
        <trans-unit id="f95b761f5013500506669ddde5d332b7d2698e3f" translate="yes" xml:space="preserve">
          <source>Composition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class' implementation which the user of that class need not know about. So composition is more in the way of supporting &lt;em&gt;encapsulation&lt;/em&gt; (i.e. concealing the implementation) while inheritance is meant to support &lt;em&gt;abstraction&lt;/em&gt; (i.e. providing a simplified representation of something, in this case the &lt;strong&gt;same&lt;/strong&gt; interface for a range of types with different internals).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Композиция должна использоваться, когда вам не нужно, чтобы новый класс имел такой же интерфейс, т.е. вы хотите скрыть определенные аспекты реализации класса, о которых пользователь этого класса не должен знать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, композиция в большей степени поддерживает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;инкапсуляцию&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (т. Е. Скрывает реализацию), а наследование предназначено для поддержки &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;абстракции&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (т. Е. Обеспечивает упрощенное представление чего-либо, в данном случае один и тот &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;же&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; интерфейс для ряда типов с различными внутренними компонентами).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2a8235eed4685d8113375b89cd8a8e3d9bd3e3a" translate="yes" xml:space="preserve">
          <source>Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.</source>
          <target state="translated">Композиция против наследования является широкой темой.Нет реального ответа на вопрос,что лучше,так как я думаю,что все зависит от дизайна системы.</target>
        </trans-unit>
        <trans-unit id="92716f2ee6cb1310c9dda41d91fd87785b6876c1" translate="yes" xml:space="preserve">
          <source>Creating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass &quot;is-a&quot; super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.</source>
          <target state="translated">Создание подкласса должно означать больше,чем просто удобный способ вызова методов суперкласса.Наследование следует использовать,когда подкласс &quot;is-a&quot; супер-класс как структурно,так и функционально,когда его можно использовать в качестве супер-класса,и вы собираетесь его использовать.Если это не так-это не наследование,а что-то другое.Состав-это когда ваши объекты состоят из другого,или имеют к ним какое-то отношение.</target>
        </trans-unit>
        <trans-unit id="3fe61a6e3e340af7a148250fe18c7fe220180a40" translate="yes" xml:space="preserve">
          <source>Didn't find a satisfactory answer here, so I wrote a new one.</source>
          <target state="translated">Не нашел здесь удовлетворительного ответа,поэтому написал новый.</target>
        </trans-unit>
        <trans-unit id="2134be01d96196149dd1553096fb7d21f63f453f" translate="yes" xml:space="preserve">
          <source>Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for &lt;strong&gt;Composition.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Разве TypeB хочет только часть / часть поведения, раскрываемого TypeA? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Указывает на необходимость в &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;композиции.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="12ab02cfb9dcddf234cbcb5daadc6acbbc33faab" translate="yes" xml:space="preserve">
          <source>Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates &lt;strong&gt;Inheritance&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Желает ли TypeB предоставить полный интерфейс (не все общедоступные методы) TypeA так, чтобы TypeB можно было использовать там, где ожидается TypeA? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Указывает на &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;наследование&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777d4fc8b7f76029a5967bc0b0912719f3a1a9b1" translate="yes" xml:space="preserve">
          <source>Does your class need to re-use any high level interactions defined in another class ? The &lt;a href=&quot;http://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;template method&lt;/a&gt; design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Нужно ли вашему классу повторно использовать взаимодействия высокого уровня, определенные в другом классе? &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Метод шаблона&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; шаблон дизайна будет невозможно реализовать без наследования. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я считаю, что все расширяемые рамки используют этот шаблон.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ce219366653ef3fc59ddc3a55f02fcdb049f3e4" translate="yes" xml:space="preserve">
          <source>E.g 1. Accountant &lt;strong&gt;is an&lt;/strong&gt; Employee. But I will &lt;strong&gt;not&lt;/strong&gt; use inheritance because a Employee object can be instantiated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, 1. Бухгалтер &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;является&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Сотрудником. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но я &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; буду &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использовать наследование, потому что объект Employee может быть создан.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd394dfc4783e4030e370145dbe0cbed4e04b2f6" translate="yes" xml:space="preserve">
          <source>E.g 2. Book &lt;strong&gt;is a&lt;/strong&gt; SellingItem. A SellingItem cannot be instantiated - it is abstract concept. Hence I will use inheritacne. The SellingItem is an &lt;strong&gt;abstract base class (or interface&lt;/strong&gt; in C#)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, 2. Книга &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;является&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предметом продажи. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SellingItem не может быть создан - это абстрактное понятие. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Следовательно, я буду использовать наследство. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SellingItem - это &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;абстрактный базовый класс (или интерфейс&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в C #)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e63cd64448d1fa4bd7208eeb5d3146984a4c565d" translate="yes" xml:space="preserve">
          <source>Either the base class &lt;code&gt;Engine&lt;/code&gt; exposes a mutator to change its</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Либо базовый класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Engine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выставляет мутатор для изменения его&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b189d69566897b8878d77a4a677fe65f855dc737" translate="yes" xml:space="preserve">
          <source>Essentially, this means that inheritance is possible if the base class can be used polymorphically, which I believe is equivalent to our test &quot;a bar is a foo and bars can do everything that foos can do&quot;.</source>
          <target state="translated">По сути,это означает,что наследование возможно,если базовый класс можно использовать полиморфно,что,на мой взгляд,эквивалентно нашему тесту &quot;бар-это фу,а бары могут делать все,что могут делать фу&quot;.</target>
        </trans-unit>
        <trans-unit id="f2051d9830558331ddb82ea3d448072dd2bb9c36" translate="yes" xml:space="preserve">
          <source>Even if you &lt;em&gt;can&lt;/em&gt; use inheritance doesn't mean you &lt;em&gt;should&lt;/em&gt;: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren't obvious, and in my opinion are best explained in &lt;a href=&quot;https://stackoverflow.com/a/32557773/1951907&quot;&gt;lcn's answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Даже если вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;можете&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; использовать наследование, это не значит, что вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должны&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; использовать композицию всегда. Наследование - это мощный инструмент, позволяющий неявное повторное использование кода и динамическую диспетчеризацию, но у него есть несколько недостатков, поэтому составление часто предпочтительнее. Компромиссы между наследованием и составом не очевидны, и, на мой взгляд, лучше всего объяснить в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/32557773/1951907&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответе lcn&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f8acd85ea01ba780aab8bff6a6da0a022821ecd" translate="yes" xml:space="preserve">
          <source>Even though Composition is preferred, I would like to highlight pros of &lt;em&gt;Inheritance&lt;/em&gt; and cons of &lt;em&gt;Composition&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Несмотря на то, что композиция является предпочтительной, я хотел бы выделить плюсы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;наследования&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и минусы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;композиции&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31031c9aad8cde85b2091023e88715df8ab33039" translate="yes" xml:space="preserve">
          <source>Excessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.</source>
          <target state="translated">Чрезмерное повторное использование с помощью подклассов может сделать стек наследства очень глубоким и очень запутанным.</target>
        </trans-unit>
        <trans-unit id="89a3623ed6c1f4cf17b888e7b9aea97aa69741d0" translate="yes" xml:space="preserve">
          <source>Expose no fields, ever, except constants</source>
          <target state="translated">Никогда не открывайте никаких полей,кроме констант.</target>
        </trans-unit>
        <trans-unit id="043fff222c570925fe52a25442b655b888e4778a" translate="yes" xml:space="preserve">
          <source>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it</source>
          <target state="translated">Функции,использующие указатели или ссылки на базовые классы,должны уметь использовать объекты производных классов,не зная об этом.</target>
        </trans-unit>
        <trans-unit id="3bb1334620acce14a757514719a368811078eacb" translate="yes" xml:space="preserve">
          <source>Generally type of relationship between object provide better information to choose one of them.</source>
          <target state="translated">Как правило,тип отношений между объектами предоставляет лучшую информацию для выбора одного из них.</target>
        </trans-unit>
        <trans-unit id="4f12a4d9f8c6da07d46b0a2b46004b726e7c45ee" translate="yes" xml:space="preserve">
          <source>However, if the parent class for some reason needs to access functions provided by the &quot;child class&quot; for inexperienced programmer it may look like it's a great place to use  inheritance. The parent class can just call it's own abstract &quot;foo()&quot; which is overwritten by the subclass and then it can give the value to the abstract base.</source>
          <target state="translated">Однако,если родительскому классу по каким-то причинам понадобится доступ к функциям,предоставляемым &quot;дочерним классом&quot; для неопытного программиста,то это может показаться отличным местом для использования наследования.Родительский класс может просто назвать свой собственный абстрактный &quot;foo()&quot;,который перезаписывается подклассом,а затем передать значение в абстрактную базу.</target>
        </trans-unit>
        <trans-unit id="97f925aaef0269b5644be480512ea4709622251e" translate="yes" xml:space="preserve">
          <source>However, if you want to use the private variables, the case 3, then you may be in trouble. &lt;strong&gt;If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe&lt;/strong&gt;. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it's quite fine.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако, если вы хотите использовать закрытые переменные, случай 3, то у вас могут быть проблемы. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы считаете глобальные переменные небезопасными, то вам следует рассмотреть возможность использования наследования для получения доступа к закрытым переменным, также небезопасным&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Имейте в виду, что глобальные переменные - это еще не все, что Плохо - базы данных представляют собой большой набор глобальных переменных. Но если вы можете справиться с этим, то это вполне нормально.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4d685219579566f4df07511cc885fbfa342cbce" translate="yes" xml:space="preserve">
          <source>However, if your intention is purely that of code re-use, then composition most likely is a better design choice.</source>
          <target state="translated">Однако,если вы намерены использовать код исключительно повторно,то композиция,скорее всего,является лучшим выбором дизайна.</target>
        </trans-unit>
        <trans-unit id="79722dd4bf505b50db03d2d8689bea00b8a0de1d" translate="yes" xml:space="preserve">
          <source>I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.</source>
          <target state="translated">Я согласен с @Павелем,когда он говорит,что есть места для композиции и есть места для наследования.</target>
        </trans-unit>
        <trans-unit id="9da4978d60ea2b750a44d4c39e654ed0899f255e" translate="yes" xml:space="preserve">
          <source>I can think of three real reasons for using inheritance:</source>
          <target state="translated">Я могу придумать три реальные причины для использования наследства:</target>
        </trans-unit>
        <trans-unit id="92415e061dde1a77f1cbf96f5a396e5e3f625e79" translate="yes" xml:space="preserve">
          <source>I have three classes that all need some common functionality. So if I
  write a base class and have them all inherit from it, then they will
  all have that functionality and I'll only need to maintain it in once
  place.</source>
          <target state="translated">У меня есть три класса,которые все нуждаются в общей функциональности.Так что если я напишу базовый класс и все они унаследуют от него,то все они будут иметь такую функциональность,и мне нужно будет поддерживать его только один раз.</target>
        </trans-unit>
        <trans-unit id="94322ac0b828540a1a09d955fde0930579fb6eef" translate="yes" xml:space="preserve">
          <source>I see no one mentioned the &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&quot;&gt;&lt;strong&gt;diamond problem&lt;/strong&gt;&lt;/a&gt;, which might arise with inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я вижу, что никто не упомянул &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;проблему алмазов&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которая может возникнуть при наследовании.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66bbabb97fcd47e383202e2d023a33046ffde71d" translate="yes" xml:space="preserve">
          <source>I take no credit for this approach. I took it straight from the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735619670&quot;&gt;Second Edition of Code Complete&lt;/a&gt; by &lt;a href=&quot;http://blogs.construx.com/blogs/stevemcc/default.aspx&quot;&gt;Steve McConnell&lt;/a&gt;, &lt;em&gt;Section 6.3&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я не принимаю кредит на этот подход. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я взял это прямо из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735619670&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;второго издания Code Complete,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выполненного &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.construx.com/blogs/stevemcc/default.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Стивом Макконнеллом&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;раздел 6.3&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa2bbecf277f1f24d2f1347150c527e7e0547d68" translate="yes" xml:space="preserve">
          <source>I think inheritance should be used if your answer is an affirmative to any of these questions.</source>
          <target state="translated">Я думаю,что наследство следует использовать,если ваш ответ утвердительный на любой из этих вопросов.</target>
        </trans-unit>
        <trans-unit id="9a218d45daf46b325069807128916cf22840ea70" translate="yes" xml:space="preserve">
          <source>I would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it's easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).</source>
          <target state="translated">Я бы предложил использовать композицию по умолчанию.Она более модульная,и дает преимущество позднего связывания (можно изменять компонент динамически).Также проще тестировать вещи по отдельности.И если вам нужно использовать метод из класса,вы не обязаны быть в определенной форме (Liskov Substitution Principle).</target>
        </trans-unit>
        <trans-unit id="b4b8830d61628daddd8e304299af6cded09fa350" translate="yes" xml:space="preserve">
          <source>If code reuse is the &lt;em&gt;sole&lt;/em&gt; purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don't make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is &lt;em&gt;demanded&lt;/em&gt;. This is also where the &quot;is-a&quot; vs. &quot;has-a&quot; notion comes from.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если повторное использование кода является &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;единственной&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; целью, создание подклассов может дать больше, чем ему нужно, то есть некоторые открытые методы родительского класса не имеют особого смысла для дочернего класса. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае, вместо того, чтобы отдавать предпочтение композиции над наследованием, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;требуется&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; композиция &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это также то, откуда приходит понятие &amp;laquo;есть&amp;raquo; против &amp;laquo;имеет&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f377d45b989acafd55d82af80725c12e6b22ad84" translate="yes" xml:space="preserve">
          <source>If relation type is  &quot;IS-A&quot; relation then Inheritance is better approach.
otherwise relation type is  &quot;HAS-A&quot; relation then composition will better approach.</source>
          <target state="translated">Если тип отношения-отношение &quot;IS-A&quot;,то наследование-лучший подход.В противном случае тип отношения-отношение &quot;HAS-A&quot;,то состав будет лучше приближаться.</target>
        </trans-unit>
        <trans-unit id="31255e40d0434216cba8c8688fd5f4dadb2d4bce" translate="yes" xml:space="preserve">
          <source>If the object need to be of the same type, then use &lt;strong&gt;Inheritance&lt;/strong&gt; or implement interfaces.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если объект должен быть того же типа, тогда используйте &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наследование&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или реализуйте интерфейсы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03ea0bf4e382df082ffa1f260eb4aff741e92ef5" translate="yes" xml:space="preserve">
          <source>If the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.</source>
          <target state="translated">Если причина-номер 2,то она становится немного хитрой.Вам действительно нужно использовать только тот же базовый класс? В общем,просто использовать один и тот же базовый класс не достаточно хорошо,но это может быть требованием вашего каркаса,проектным соображением,которого нельзя избежать.</target>
        </trans-unit>
        <trans-unit id="50913e0cbdc9a4f53879607cd8217f727ee11c8d" translate="yes" xml:space="preserve">
          <source>If these are true, then it is probably necessary to use inheritance.</source>
          <target state="translated">Если это правда,то,вероятно,необходимо использовать наследование.</target>
        </trans-unit>
        <trans-unit id="8b1c2b77c49e48b7fd23f6be825d3e74aa05cdb1" translate="yes" xml:space="preserve">
          <source>If you understand the difference, it's easier to explain.</source>
          <target state="translated">Если ты понимаешь разницу,это легче объяснить.</target>
        </trans-unit>
        <trans-unit id="0744b5b95abf4fe22c4bb86def64e0a6bd18cab0" translate="yes" xml:space="preserve">
          <source>In Java or C#, an object cannot change its type once it has been instantiated.</source>
          <target state="translated">В Java или C#объект не может изменить свой тип после его инстанцирования.</target>
        </trans-unit>
        <trans-unit id="048c5d31bb5c132e0c74cc2184a24b79baadf241" translate="yes" xml:space="preserve">
          <source>In a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?</source>
          <target state="translated">С первого взгляда,если классы B и C наследуют A и оба переопределяют метод X,а четвертый класс D наследует и от B и от C,и не переопределяет X,какую реализацию X D предполагается использовать?</target>
        </trans-unit>
        <trans-unit id="328ab1e48844e9cef1794c68df9d6ef8b3d470f0" translate="yes" xml:space="preserve">
          <source>In inheritance, subclass can directly invoke base class method even though it's not implementing base class method because of &lt;strong&gt;&lt;em&gt;IS A&lt;/em&gt;&lt;/strong&gt; relation. If you use composition, you have to add methods in container class to expose contained class API</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В наследовании подкласс может напрямую вызывать метод базового класса, даже если он не реализует метод базового класса из-за &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отношения &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IS A. &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы используете композицию, вы должны добавить методы в контейнерный класс, чтобы предоставить доступ к API класса.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0237d418d5cba034a69d0e770a4c52723e47e4d3" translate="yes" xml:space="preserve">
          <source>In the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, &quot;Cool, I learned about inheritance and now I used it.&quot; That's not meant to be condescending because we've all done it. But we all did it because no one told us not to.</source>
          <target state="translated">В конце концов,мы завязываем наш код в какие-то сложные узлы и не получаем от этого никакой выгоды,кроме того,что можем сказать:&quot;Круто,я узнал о наследовании и теперь использовал его&quot;.Это не должно быть снисходительным,потому что мы все это сделали.Но мы все делали это,потому что никто не говорил нам не делать этого.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="8acfc927b768458de4cace8265888459e774da8a" translate="yes" xml:space="preserve">
          <source>Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class'es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally.</source>
          <target state="translated">Наследование создает сильную связь между подклассом и суперклассом;подкласс должен знать детали реализации суперкласса.Создание супер-класса намного сложнее,когда нужно подумать о том,как его можно расширить.Вы должны внимательно документировать инварианты класса и указать,какие другие методы,которые можно переопределить,используют внутри класса.</target>
        </trans-unit>
        <trans-unit id="b7060930ac5a536fbe2aad05ec9ec8d02db42c83" translate="yes" xml:space="preserve">
          <source>Inheritance exposes &lt;em&gt;protected&lt;/em&gt; members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наследование подвергает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;защищенных&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; членов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это нарушает инкапсуляцию родительского класса, и, если используется подклассом, вводится другая зависимость между дочерним и его родительским классом.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1ded82669ac9037f30aed69f3e1289af7838c6f" translate="yes" xml:space="preserve">
          <source>Inheritance exposes a subclass to details of its parent class implementation, that's why it's often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).</source>
          <target state="translated">Наследование подвергает подкласс подробностям реализации его родительского класса,поэтому часто говорят,что наследование нарушает инкапсуляцию (в том смысле,что вам действительно нужно сосредоточиться только на интерфейсах,а не на реализации,поэтому повторное использование подкласса не всегда предпочтительнее).</target>
        </trans-unit>
        <trans-unit id="6b2f20d3e798733bc6014d967772e1dd274bc317" translate="yes" xml:space="preserve">
          <source>Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here.</source>
          <target state="translated">Наследование-это очень мощный механизм повторного использования кода.Но его нужно использовать правильно.Я бы сказал,что наследование используется правильно,если подкласс также является подтипом родительского класса.Как упоминалось выше,ключевым моментом здесь является принцип подстановки Лискова.</target>
        </trans-unit>
        <trans-unit id="4d4a2058f753bb6fa776187437c532819ce7c9eb" translate="yes" xml:space="preserve">
          <source>Inheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.</source>
          <target state="translated">Наследование,однако,легко переусердствуется и создает дополнительные сложности,с жесткими зависимостями между классами.Также понимание того,что происходит во время выполнения программы,становится довольно сложным из-за наслоений и динамического выбора вызова методов.</target>
        </trans-unit>
        <trans-unit id="246a008dc7a1185d80da575bb9971db7f90056e2" translate="yes" xml:space="preserve">
          <source>Inheritance is often taught early when we learn object-oriented programming, so it's seen as an easy solution to a common problem.</source>
          <target state="translated">Наследование часто преподается рано,когда мы учимся объектно-ориентированному программированию,поэтому оно рассматривается как простое решение общей проблемы.</target>
        </trans-unit>
        <trans-unit id="644a9a7de65c713edc98cce558794f4f5d61fd4c" translate="yes" xml:space="preserve">
          <source>Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that</source>
          <target state="translated">Наследство довольно заманчиво,особенно происходящее из процедурных земель,и часто выглядит обманчиво элегантно.Я имею в виду,что все,что мне нужно сделать,это добавить этот бит функциональности в какой-нибудь другой класс,не так ли? Ну,одна из проблем в том,что</target>
        </trans-unit>
        <trans-unit id="62e87b6a71b6557527e58c600d3ce6921f9bf0e3" translate="yes" xml:space="preserve">
          <source>Inheritance is really a cool feature, but I'm afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.</source>
          <target state="translated">Наследство-это действительно крутая особенность,но,боюсь,она была чрезмерно использована в последние пару лет.Люди относились к наследству как к единственному молотку,который может прибить все это,независимо от того,был ли это на самом деле гвоздь,винт,или,может быть,что-то совершенно другое.</target>
        </trans-unit>
        <trans-unit id="6876956ee9e8f2967733c679847a166bd622f332" translate="yes" xml:space="preserve">
          <source>Inheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).</source>
          <target state="translated">Наследование иногда полезно,если иерархия действительно представляет собой отношение &quot;is-a&quot;.Это относится к принципу Open-Closed,который гласит,что классы должны быть закрыты для модификации,но открыты для расширения.Таким образом,можно иметь полиморфизм;иметь общий метод,который имеет дело с супертипом и его методами,но через динамическую диспетчеризацию вызывается метод подкласса.Это гибко,и помогает создать индирекцию,что очень важно в программном обеспечении (меньше знать о деталях реализации).</target>
        </trans-unit>
        <trans-unit id="bced79113df2d8dc04636edbfd4c770f3793b989" translate="yes" xml:space="preserve">
          <source>Inheritance is very powerful, but you can't force it (see: the &lt;a href=&quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;circle-ellipse problem&lt;/a&gt;). If you really can't be completely sure of a true &quot;is-a&quot; subtype relationship, then it's best to go with composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наследование очень мощное, но вы не можете его форсировать (см .: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;проблема круга-эллипса&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы действительно не можете быть полностью уверены в истинных отношениях типа &amp;laquo;есть&amp;raquo;, то лучше пойти с композицией.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c9e4c9ebc2c06779a4efa98017c411df12f9203" translate="yes" xml:space="preserve">
          <source>Inheritance provides straightforward &lt;a href=&quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion&quot;&gt;open recursion&lt;/a&gt; via the internal polymorphic site &lt;code&gt;this&lt;/code&gt;, i.e. invoking overriding method (or even &lt;a href=&quot;http://www.scala-lang.org/old/node/1637.html#comment-5489&quot;&gt;type&lt;/a&gt;) in another member function, either public or private (though &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one&quot;&gt;discouraged&lt;/a&gt;). Open recursion can be &lt;a href=&quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java&quot;&gt;simulated via composition&lt;/a&gt;, but it requires extra effort and may not always viable(?). This &lt;a href=&quot;https://stackoverflow.com/a/2238735/2073130&quot;&gt;answer&lt;/a&gt; to a duplicated question talks something similar.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наследование обеспечивает прямую &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;открытую рекурсию&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; через внутренний полиморфный сайт &lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , то есть вызов метода переопределения (или даже &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.scala-lang.org/old/node/1637.html#comment-5489&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;типа&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) в другой функции-члене, публичной или закрытой (хотя и не &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;рекомендуется&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Открытая рекурсия может быть &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;смоделирована с помощью композиции&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но она требует дополнительных усилий и не всегда жизнеспособна (?). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/2238735/2073130&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на дублированный вопрос говорит о чем-то похожем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476dda4bfbf5d4cce097cb5b1043e190f23872ad" translate="yes" xml:space="preserve">
          <source>Inheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it's just a simple job of delegation.</source>
          <target state="translated">Наследование обеспечивает простое повторное использование кода,если его не переопределить,в то время как композиция должна перекодировать каждый API,даже если это простая работа по делегированию.</target>
        </trans-unit>
        <trans-unit id="58f31260c50c06295c28ea7e8151785985ab907c" translate="yes" xml:space="preserve">
          <source>Inheritance vs. Aggregation</source>
          <target state="translated">Наследство против агрегации</target>
        </trans-unit>
        <trans-unit id="e4add19dff6bf1f83b08edd6c883185779e798ed" translate="yes" xml:space="preserve">
          <source>Is your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.</source>
          <target state="translated">Является ли ваш класс частью структуры,которая выигрывает от полиморфизма? Например,если у вас был класс Shape,который объявляет метод,называемый draw(),то нам явно нужны классы Circle и Square,чтобы быть подклассами Shape,так чтобы их клиентские классы зависели от Shape,а не от конкретных подклассов.</target>
        </trans-unit>
        <trans-unit id="bfe3497c44aa76555ec280d12b36758df5b4f30f" translate="yes" xml:space="preserve">
          <source>It establishes a logical &quot;&lt;strong&gt;IS A&quot;&lt;/strong&gt; relation. If &lt;em&gt;Car&lt;/em&gt; and &lt;em&gt;Truck&lt;/em&gt; are two types of &lt;em&gt;Vehicle&lt;/em&gt; ( base class), child class &lt;strong&gt;IS A&lt;/strong&gt; base class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он устанавливает логическое отношение &amp;laquo;есть &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;автомобиль&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;грузовик&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; два типа &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;транспортного средства&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (базовый класс), дочерний класс &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ЯВЛЯЕТСЯ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; базовый класс.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="896d22608075a950c42470104324b7925c60561d" translate="yes" xml:space="preserve">
          <source>It is often said that a class &lt;code&gt;Bar&lt;/code&gt; can inherit a class &lt;code&gt;Foo&lt;/code&gt; when the following sentence is true:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Часто говорят, что класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может наследовать класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда верно следующее предложение:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34e84b66db1164cc20f4c06d7a6b4d4b98054d53" translate="yes" xml:space="preserve">
          <source>It looks like a nice idea, but in many cases it's better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.</source>
          <target state="translated">Выглядит неплохой идеей,но во многих случаях лучше просто дать классу объект,который реализует foo()(или даже установить значение,предоставленное foo()вручную),чем унаследовать новый класс от какого-то базового класса,который требует указания функции foo().</target>
        </trans-unit>
        <trans-unit id="0325327f4aa9142c3fd02e3a934a008c92e7171d" translate="yes" xml:space="preserve">
          <source>It sounds great, but in practice it almost never, ever works, for one of several reasons:</source>
          <target state="translated">Звучит здорово,но на практике это почти никогда,никогда не работает,по одной из нескольких причин:</target>
        </trans-unit>
        <trans-unit id="f8a7ea6e944d4c6b1135e3b5b710351923f2b191" translate="yes" xml:space="preserve">
          <source>Its totally depend on entity relationship.</source>
          <target state="translated">Это полностью зависит от отношений между организациями.</target>
        </trans-unit>
        <trans-unit id="9aa3aeed06309616a463e707f18bc9934bea552e" translate="yes" xml:space="preserve">
          <source>Just so you know, another method used to determine whether inheritance is possible  is called the &lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;Liskov Substitution Principle&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как вы знаете, другой метод, используемый для определения возможности наследования, называется &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;принципом подстановки Лискова&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5197c78c69bc09836bc35c15c3eef5138da931c2" translate="yes" xml:space="preserve">
          <source>Liskov Substitution Principle</source>
          <target state="translated">принцип замещения Лискова</target>
        </trans-unit>
        <trans-unit id="d422e9f26503f80de1cff472c1db2f215fa1702a" translate="yes" xml:space="preserve">
          <source>Methods shall be either abstract or final</source>
          <target state="translated">Методы должны быть абстрактными или окончательными</target>
        </trans-unit>
        <trans-unit id="ac55c0bd23a1f1346ee8d2c06328fa87ad445ad8" translate="yes" xml:space="preserve">
          <source>My acid test for the above is:</source>
          <target state="translated">Мой тест на кислоту для вышеперечисленного:</target>
        </trans-unit>
        <trans-unit id="9981ec34a9c592b0920bf23bf8fac06054f08043" translate="yes" xml:space="preserve">
          <source>My general rule of thumb: &lt;em&gt;Before using inheritance, consider if composition makes more sense.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мое общее правило: &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перед использованием наследования подумайте, имеет ли смысл смысл композиции.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db3f86242cf06a42d0939d0152ef62fe2f01bab2" translate="yes" xml:space="preserve">
          <source>My take on what to do, if you do allow for inheritance, which you may
  take with a grain of salt is:</source>
          <target state="translated">Мое мнение о том,что делать,если вы позволите наследство,которое вы можете взять с зерном соли:</target>
        </trans-unit>
        <trans-unit id="fdcdd0dea9447d0f926949cde5bf20294722ed01" translate="yes" xml:space="preserve">
          <source>Now say you want to create a Manager type so you end up with:</source>
          <target state="translated">Теперь скажите,что вы хотите создать тип Менеджера,и вы закончите:</target>
        </trans-unit>
        <trans-unit id="f67f8e82998175522142525ba912b4ae6be97e09" translate="yes" xml:space="preserve">
          <source>Now your aircraft can start with having fixed wings</source>
          <target state="translated">Теперь ваш самолет может начать с неподвижных крыльев.</target>
        </trans-unit>
        <trans-unit id="3fdddf6d088be0ec0a4568052a16a437fcc42087" translate="yes" xml:space="preserve">
          <source>Now, I can replace my engine on the fly as well.</source>
          <target state="translated">Теперь я могу заменить свой двигатель и на лету.</target>
        </trans-unit>
        <trans-unit id="832d28133a55725f1ed6e5888b63068210a2853f" translate="yes" xml:space="preserve">
          <source>On the other hand &lt;b&gt;Object composition&lt;/b&gt; is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other's protected data (no encapsulation break) and will be forced to respect each other's interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С другой стороны, &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;композиция объектов&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; определяется во время выполнения посредством объектов, получающих ссылки на другие объекты. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В таком случае эти объекты никогда не смогут получить доступ к защищенным данным друг друга (без нарушения инкапсуляции) и будут вынуждены соблюдать интерфейс друг друга. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И в этом случае зависимости реализации также будут намного меньше, чем в случае наследования.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c7b128050c901c022cde5fd0d94700144c01c7a" translate="yes" xml:space="preserve">
          <source>On the other hand when you have &lt;strong&gt;has-a&lt;/strong&gt; or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С другой стороны , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если у &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вас есть &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;есть-а&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или какое - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то отношение прилагательного между двумя классами (студент курсов) или (исследования учителей курсы), вы выбрали композицию.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5aa7d08c0a1cf9428cca33805b546bb71b9e85d3" translate="yes" xml:space="preserve">
          <source>One example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn't use inheritance given that you don't want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.</source>
          <target state="translated">Один пример:Ты хочешь создать Стек из списка.В стеке есть только pop,push и peek.Вы не должны использовать наследование,если не хотите,чтобы в стеке была функциональность push_back,push_front,removeAt и др.</target>
        </trans-unit>
        <trans-unit id="c15fc0f907136cf0672eb8daba99647310e8c8f3" translate="yes" xml:space="preserve">
          <source>Our Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!</source>
          <target state="translated">Наш класс Set of integers является подклассом List of Integers,но не является подтипом,в связи с тем,что не удовлетворяет всем возможностям класса List.Значения и сигнатуры методов удовлетворяют,а свойства-нет.Поведение метода add(Integer)явно изменилось,не сохранив свойств родительского типа.Подумайте с точки зрения клиента своих классов.Они могут получить набор целых чисел,где ожидается список целых чисел.Клиент может захотеть добавить значение и получить это значение,добавленное в Список,даже если это значение уже существует в Списке.Но она не получит такого поведения,если значение уже существует.Большой сюрприз для нее!</target>
        </trans-unit>
        <trans-unit id="c1ba9f43aacc5af4e732994e2cf99330626de110" translate="yes" xml:space="preserve">
          <source>Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn't know any such thing, you'll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.</source>
          <target state="translated">Лично я научился всегда отдавать предпочтение композиции,а не наследованию.Нет программной проблемы,которую вы можете решить с помощью наследования,которую вы не можете решить с помощью композиции;хотя в некоторых случаях вам может понадобиться использовать Interfaces(Java)или Protocols(Obj-C).Так как С++не знает ничего подобного,вам придется использовать абстрактные базовые классы,что означает,что вы не можете полностью избавиться от наследования на С++.</target>
        </trans-unit>
        <trans-unit id="09ac00419cae691f7272de0fcf67b357fbda9a77" translate="yes" xml:space="preserve">
          <source>Prefer composition over inheritance</source>
          <target state="translated">Предпочитает состав,а не наследование</target>
        </trans-unit>
        <trans-unit id="ee0347cbc9ba866cc7d164011ffab0691b350235" translate="yes" xml:space="preserve">
          <source>Procedural Code</source>
          <target state="translated">процессуальный кодекс</target>
        </trans-unit>
        <trans-unit id="e723b4eaeeb9a79c6611a9a222aeb92911a3f411" translate="yes" xml:space="preserve">
          <source>Reason: &lt;em&gt;Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Причина: &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;подклассы обычно означают большую сложность и связанность, то есть сложнее изменять, поддерживать и масштабировать без ошибок.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b27176c7cd1d943a977fdce1ee934c4c1feeb14" translate="yes" xml:space="preserve">
          <source>See other answers.</source>
          <target state="translated">См.другие ответы.</target>
        </trans-unit>
        <trans-unit id="8719dca4ec3565d3812b57bd3de8cc2af492bfeb" translate="yes" xml:space="preserve">
          <source>So for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.</source>
          <target state="translated">Поэтому для меня это выглядит так,будто если кто-то не знает,нужно ли ему наследство или композиция,то реальная проблема в том,что он не знает,хочет ли он выпить или поесть.Подумайте о своей проблемной области больше,поймите ее лучше.</target>
        </trans-unit>
        <trans-unit id="5e46fa089d47708f97cac794ca257e6960b4ed16" translate="yes" xml:space="preserve">
          <source>So only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.</source>
          <target state="translated">Таким образом,только в случае,когда подтипирование предназначено,т.е.использование нового класса в дальнейшем полиморфным способом,мы сталкиваемся с проблемой выбора наследования или состава.Это предположение опускается в обсуждаемой сокращенной идиоме.</target>
        </trans-unit>
        <trans-unit id="38f67df16186ea732f8e64c3dc6f62ebcca5e137" translate="yes" xml:space="preserve">
          <source>So, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use &lt;strong&gt;Composition&lt;/strong&gt;: Refer to &lt;a href=&quot;http://www.dofactory.com/Patterns/PatternState.aspx&quot;&gt;State&lt;/a&gt; and &lt;a href=&quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx&quot;&gt;Strategy&lt;/a&gt; Design Patterns.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, если ваш объект должен выглядеть как другой объект или вести себя по-разному в зависимости от состояния или условий объекта, используйте &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Composition&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : см. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Шаблоны проектирования &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.dofactory.com/Patterns/PatternState.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;состояний&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;стратегий&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="549f8d9bac9806f318f15d88f433b6bc397447c1" translate="yes" xml:space="preserve">
          <source>Sub-class adds extension to base class implementation by calling super.methodName() as first statement =&amp;gt; &lt;strong&gt;&lt;em&gt;You can extend a contract&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подкласс добавляет расширение к реализации базового класса, вызывая super.methodName () в качестве первого оператора =&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете продлить контракт&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2edf57dc395184ef34315b418a2b088ba9c59312" translate="yes" xml:space="preserve">
          <source>Subclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.</source>
          <target state="translated">Подкласс-это не то же самое,что подтип.Можно создавать подклассы,которые не являются подтипами (и именно в этом случае следует использовать композицию).Чтобы понять,что такое подтип,давайте начнем объяснять,что такое тип.</target>
        </trans-unit>
        <trans-unit id="6280068eb73b4991a7ab571fc93fcf217f265813" translate="yes" xml:space="preserve">
          <source>Subtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Let&amp;rsquo;s go to see some code to exemplify what I&amp;rsquo;m saying. Suppose I write a List of integers (in some sort of pseudo language):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подтип также является типом, который имеет отношение к другому типу, называемому родительским типом (или супертипом). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подтип должен удовлетворять признакам (значениям, методам и свойствам) родительского типа. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отношение означает, что в любом контексте, где ожидается использование супертипа, его можно заменить на подтип, не влияя на поведение выполнения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Давайте посмотрим код, чтобы проиллюстрировать то, что я говорю. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, я пишу список целых чисел (на каком-то псевдо-языке):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6887946e4c5b4415b62320ae3947b236c9c5c713" translate="yes" xml:space="preserve">
          <source>Subtyping is appropriate and more powerful where the &lt;a href=&quot;https://stackoverflow.com/a/8352969&quot;&gt;invariants can be enumerated&lt;/a&gt;, else use function composition for extensibility.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подтипирование является подходящим и более мощным, когда &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/8352969&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;можно перечислить инварианты&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , иначе используйте композицию функций для расширяемости.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e98d1b95929689559f3d4c93532fcfbd040d69e9" translate="yes" xml:space="preserve">
          <source>Suppose an aircraft has only two parts: an engine and wings.</source>
          <target state="translated">Предположим,что самолет состоит только из двух частей:двигателя и крыльев.</target>
        </trans-unit>
        <trans-unit id="748d9e332cb80d932e28118f49b5638ba8eaee06" translate="yes" xml:space="preserve">
          <source>The Manager object is composed as an Employee and a Person. The Title behaviour is taken from employee. This explicit composition removes ambiguity among other things and you'll encounter fewer bugs.</source>
          <target state="translated">Объект Менеджер состоит из Сотрудника и Человека.Поведение Титула берётся у сотрудника.Эта явная композиция устраняет двусмысленность среди прочего,и вы столкнетесь с меньшим количеством ошибок.</target>
        </trans-unit>
        <trans-unit id="81ed2eb88eaa37fdff388424251ce97e077ced4c" translate="yes" xml:space="preserve">
          <source>The antidote is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;Single Responsibility Principle&lt;/a&gt;. Think of it as a constraint. My class &lt;em&gt;must&lt;/em&gt; do one thing. I &lt;em&gt;must&lt;/em&gt; be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we're learning.) It follows that I cannot write a base class called &lt;code&gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses&lt;/code&gt;. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, &lt;em&gt;not&lt;/em&gt; inherit from it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Противоядием является &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;принцип единой ответственности&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Думайте об этом как об ограничении. Мой класс &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должен&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сделать одну вещь. Я &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должен&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; быть в состоянии дать своему классу имя, которое каким-то образом описывает ту вещь, которую он делает. (Есть исключения для всего, но абсолютные правила иногда лучше, когда мы учимся.) Из этого следует, что я не могу написать базовый класс с именем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Независимо от того, какая отдельная функциональность мне нужна, она должна принадлежать своему классу, и тогда другие классы, которым эта функциональность нужна, могут зависеть от этого класса, а &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; наследоваться от него.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="756c9ed98907d3961cd495c08dfc9ecbac6456d9" translate="yes" xml:space="preserve">
          <source>The article, &lt;a href=&quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/&quot;&gt;Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder&lt;/a&gt;, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В статье &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наследование есть зло: эпическая ошибка DataAnnotationsModelBinder&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; приведен пример этого в C #. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это показывает использование наследования, когда состав должен был использоваться и как это могло быть реорганизовано.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f0cb63e7db6c559e277c0e6f5e0b14d3af0a76f" translate="yes" xml:space="preserve">
          <source>The composition has a real edge here: the relationship can be reversed: the &quot;parent class&quot; or &quot;abstract worker&quot; can aggregate any specific &quot;child&quot; objects implementing certain interface + &lt;strong&gt;any child can be set inside any other type of parent, which accepts it's type&lt;/strong&gt;. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement &quot;foo()&quot; and other group of objects which can make use of objects having &quot;foo()&quot; can play together.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Здесь у композиции есть реальное преимущество: связь может быть обратной: &amp;laquo;родительский класс&amp;raquo; или &amp;laquo;абстрактный работник&amp;raquo; могут агрегировать любые конкретные &amp;laquo;дочерние&amp;raquo; объекты, реализующие определенный интерфейс + &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;любой дочерний&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; объект &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;может быть установлен внутри любого другого типа родителя, который принимает это тип&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И может быть любое количество объектов, например, MergeSort или QuickSort могут отсортировать любой список объектов, реализующих абстрактный интерфейс Compare. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Или, говоря иначе: любая группа объектов, которые реализуют &quot;foo ()&quot;, и другая группа объектов, которые могут использовать объекты, имеющие &quot;foo ()&quot;, могут играть вместе.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="33595de1c584d88b32800d1fcaf74682bd919860" translate="yes" xml:space="preserve">
          <source>The first test ensures that all &lt;em&gt;getters&lt;/em&gt; of &lt;code&gt;Foo&lt;/code&gt; make sense in &lt;code&gt;Bar&lt;/code&gt; (= shared properties), while the second test makes sure that all &lt;em&gt;setters&lt;/em&gt; of &lt;code&gt;Foo&lt;/code&gt; make sense in &lt;code&gt;Bar&lt;/code&gt; (= shared functionality).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Первые испытания гарантируют , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что все &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;добытчики&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеет смысла в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (= общие свойства), в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то время как второй тест гарантирует , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что все &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сеттер&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеет смысла, в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (= общие функциональные возможности &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3af0b301854a243ae48ec4eb1b17706b1a405f" translate="yes" xml:space="preserve">
          <source>The issue with inheritance is that it can be used for two orthogonal purposes:</source>
          <target state="translated">Проблема с наследованием заключается в том,что его можно использовать для двух ортогональных целей:</target>
        </trans-unit>
        <trans-unit id="fef004bb30a4e0c238ab2b8425780e54d9f658d4" translate="yes" xml:space="preserve">
          <source>The main reason for using inheritance is not as a form of composition - it is so you can get polymorphic behaviour. If you don't need polymorphism, you probably should not be using inheritance.</source>
          <target state="translated">Основная причина использования наследования не в форме композиции,а в том,чтобы получить полиморфное поведение.Если вам не нужен полиморфизм,то,скорее всего,вам не стоит использовать наследование.</target>
        </trans-unit>
        <trans-unit id="eb4e58f56ade41db120e0e321541a267008d9df9" translate="yes" xml:space="preserve">
          <source>The tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.</source>
          <target state="translated">Тесная связь,обеспечиваемая наследованием,делает реализацию подкласса очень тесно связанной с реализацией суперкласса,что любое изменение в родительской реализации заставит подкласс измениться.</target>
        </trans-unit>
        <trans-unit id="c6e1071aed30be94da0e2cdf87f2e045c58cf0cd" translate="yes" xml:space="preserve">
          <source>Then there are two ways to design an aircraft class.</source>
          <target state="translated">Тогда есть два способа спроектировать класс самолета.</target>
        </trans-unit>
        <trans-unit id="1377e93559cb9cad4550161694e59ceef28236fd" translate="yes" xml:space="preserve">
          <source>Then, I write the Set of integers as a subclass of the List of integers:</source>
          <target state="translated">Затем я пишу Множество целых чисел как подкласс Списка целых чисел:</target>
        </trans-unit>
        <trans-unit id="ba41722cdbc379b118c4e701663ebf832365813b" translate="yes" xml:space="preserve">
          <source>There are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren't necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the &lt;em&gt;DRY Principle&lt;/em&gt; (DRY = Don't Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such &quot;double method calls&quot; (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя есть и недостатки в композиции. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы вообще пропустите наследование и сконцентрируетесь только на композиции, вы заметите, что вам часто приходится писать пару дополнительных строк кода, в которых не было необходимости, если вы использовали наследование. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы также иногда вынуждены повторяться, и это нарушает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;принцип СУХОГО&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(СУХОЙ = Не повторяйся). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Также состав часто требует делегирования, и метод просто вызывает другой метод другого объекта без какого-либо другого кода, окружающего этот вызов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Такие &amp;laquo;двойные вызовы методов&amp;raquo; (которые могут легко распространяться на тройные или четырехкратные вызовы методов и даже дальше) имеют гораздо худшую производительность, чем наследование, когда вы просто наследуете метод своего родителя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вызов унаследованного метода может быть таким же быстрым, как и вызов не унаследованного, или немного медленнее, но обычно все же быстрее, чем два последовательных вызова метода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88dbe40d0ed3ede68edda71ef3030a4c38686ece" translate="yes" xml:space="preserve">
          <source>There are two benefits of inheritance: &lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html&quot;&gt;subtyping and subclassing&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть два преимущества наследования: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;подтип и подклассы&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9613a336cd64521f866d933e120f5f900e231b8" translate="yes" xml:space="preserve">
          <source>There is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.</source>
          <target state="translated">Нет ничего плохого в использовании причины 1,очень хорошо иметь надежный интерфейс на ваших объектах.Это можно сделать с помощью композиции или с помощью наследования,без проблем-если этот интерфейс прост и не меняется.Обычно здесь наследование достаточно эффективно.</target>
        </trans-unit>
        <trans-unit id="2ff1e38501fc05dc5ab2089683a417fc9d8ae800" translate="yes" xml:space="preserve">
          <source>These two ways can live together just fine and actually support each other.</source>
          <target state="translated">Эти два способа могут прекрасно жить вместе и фактически поддерживать друг друга.</target>
        </trans-unit>
        <trans-unit id="96a0b8fbc97ccd7232afaf128e1f72ba9c64d8fe" translate="yes" xml:space="preserve">
          <source>Think of containment as a &lt;strong&gt;has a&lt;/strong&gt; relationship. A car &quot;has an&quot; engine, a person &quot;has a&quot; name, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Думайте о сдерживании как &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;об&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; отношениях. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У автомобиля &quot;есть&quot; двигатель, у человека &quot;есть&quot; имя и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b6ec4f6260ad4a41e813b5819357d4fdd59cd6e" translate="yes" xml:space="preserve">
          <source>Think of inheritance as an &lt;strong&gt;is a&lt;/strong&gt; relationship. A car &quot;is a&quot; vehicle, a person &quot;is a&quot; mammal, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подумайте о наследовании как &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; взаимоотношения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Автомобиль &amp;raquo;- это&amp;laquo; транспортное средство, человек &amp;raquo;- это&amp;laquo; млекопитающее &amp;raquo;и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66d70c1014e5da803fb71e6a40877d96f60ee637" translate="yes" xml:space="preserve">
          <source>This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).</source>
          <target state="translated">Это поощряет использование классов.Наследование является одним из трех принципов проектирования ОО (наследование,полиморфизм,капсулирование).</target>
        </trans-unit>
        <trans-unit id="02d27b966f445c927c12a951352c5a2ee16cc24d" translate="yes" xml:space="preserve">
          <source>This example will work fine, however, what if Person and Employee both declared &lt;code&gt;Title&lt;/code&gt;? Should Manager.Title return &quot;Manager of Operations&quot; or &quot;Mr.&quot;? Under composition this ambiguity is better handled:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот пример будет работать нормально, однако, что, если Person и Employee оба объявили &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Title&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Должен ли Manager.Title вернуть &amp;laquo;Менеджер операций&amp;raquo; или &amp;laquo;Мистер&amp;raquo;? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По составу эта двусмысленность лучше решается:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bdb26a327b7e7a1f89230942d7086df40a2044bb" translate="yes" xml:space="preserve">
          <source>This is a classic example of an improper use of inheritance. Use composition in this case.</source>
          <target state="translated">Это классический пример неправильного использования наследства.В данном случае используйте состав.</target>
        </trans-unit>
        <trans-unit id="892eb23b0e64d101eac60b59156102e0dc8377de" translate="yes" xml:space="preserve">
          <source>This is called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;Circle-Ellipse problem&lt;/a&gt;, which really isn't a problem, just a clear proof that the first test alone isn't enough to conclude that inheritance is possible. In particular, this example highlights that derived classes should &lt;em&gt;extend&lt;/em&gt; the functionality of base classes, never &lt;em&gt;restrict&lt;/em&gt; it. Otherwise, the base class couldn't be used polymorphically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это называется &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;проблемой Circle-Ellipse&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которая на самом деле не является проблемой, просто явным доказательством того, что одного первого теста недостаточно для заключения о том, что наследование возможно. В частности, этот пример подчеркивает, что производные классы должны &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;расширять&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; функциональность базовых классов, а не &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ограничивать&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; их. В противном случае базовый класс не может быть использован полиморфно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c1a3f007444e788c520debfe97ad582556ee1e" translate="yes" xml:space="preserve">
          <source>This is inheritance at work. The Employee &quot;is a&quot; Person or inherits from Person. All inheritance relationships are &quot;is-a&quot; relationships. Employee also shadows the Title property from Person, meaning Employee.Title will return the Title for the Employee not the Person.</source>
          <target state="translated">Это наследство на работе.Сотрудник &quot;является&quot; Человеком или наследует от Человека.Все отношения наследования являются отношениями &quot;есть-а&quot;.Сотрудник также затеняет свойство Title от Личности,имея в виду Employee.Title (Сотрудник)возвращает свойство для Сотрудника,а не для Личности.</target>
        </trans-unit>
        <trans-unit id="4bfff73a25d5d08232eb54847cfc587269729bfb" translate="yes" xml:space="preserve">
          <source>To address this question from a different perspective for newer programmers:</source>
          <target state="translated">Рассмотреть этот вопрос с другой точки зрения для начинающих программистов:</target>
        </trans-unit>
        <trans-unit id="948c2e5682be0db8695bdb1c215662f9b744cd72" translate="yes" xml:space="preserve">
          <source>To give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).</source>
          <target state="translated">Чтобы привести другой пример,подумайте об абстрактных типах данных,множестве целых чисел и списке целых чисел,значения,которые они могут держать,ограничены целыми числами.Оба они поддерживают набор методов,таких как add(newValue)и size().И оба они имеют различные свойства (класс инвариант),Множества не допускают дубликатов,в то время как Список допускает дубликаты (конечно,есть и другие свойства,которым они оба удовлетворяют).</target>
        </trans-unit>
        <trans-unit id="8dfe69d77cbdafc2b0a714261fbe7a897520f08c" translate="yes" xml:space="preserve">
          <source>To subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:</source>
          <target state="translated">Подтип должен соответствовать сигнатуре типа,это означает,что состав всегда должен раскрывать не меньшее количество API типа.Теперь начинаются компромиссы:</target>
        </trans-unit>
        <trans-unit id="d54b82edafd720a780f59eaceb3e260ef8e20abd" translate="yes" xml:space="preserve">
          <source>To understand why &quot;&lt;em&gt;prefer&lt;/em&gt; composition over inheritance&quot;, we need first get back the assumption omitted in this shortened idiom.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы понять, почему &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;предпочесть&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; композицию наследованию&amp;raquo;, нам нужно сначала вернуться к предположению, опущенному в этой сокращенной идиоме.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30b841e646c940730a92f3a6fde8ddbb4fa7b8a7" translate="yes" xml:space="preserve">
          <source>Unfortunately, the above test alone is not reliable. Use the following instead:</source>
          <target state="translated">К сожалению,вышеупомянутый тест сам по себе не является надежным.Вместо этого используйте следующее:</target>
        </trans-unit>
        <trans-unit id="902e9220c7e8e78a1688a9c75dc574c63e2d44d9" translate="yes" xml:space="preserve">
          <source>We discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, &quot;If I'm inherited type A, do this, but if I'm inherited type B, do that.&quot; That's bad for lots of reasons. One is that every time we change the base class, we're effectively changing every inherited class. So we're really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.</source>
          <target state="translated">Мы обнаружили,что только для одного из классов,который наследуется от нашего базового класса,мы хотим,чтобы базовый класс вел себя немного по-другому.Итак,теперь мы возвращаемся и работаем с нашим базовым классом,может быть,добавляем какие-нибудь виртуальные методы,или,что еще хуже,какой-нибудь код,который говорит:&quot;Если я наследую тип A,сделайте это,но если я наследую тип B,то сделайте это&quot;.Это плохо по многим причинам.Одна из них заключается в том,что каждый раз,когда мы меняем базовый класс,мы эффективно меняем каждый наследуемый класс.Так что мы действительно меняем классы A,B,C и D,потому что нам нужно немного другое поведение в классе A.Как бы осторожно мы ни думали,мы можем сломать один из этих классов по причинам,которые не имеют никакого отношения к этим классам.</target>
        </trans-unit>
        <trans-unit id="6227a652268bd11d1b6cbf24ac145873c6174ca7" translate="yes" xml:space="preserve">
          <source>We discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?</source>
          <target state="translated">Мы обнаружили,что есть и другие функции,которые мы хотим,чтобы наши классы имели.Если способ,которым мы добавляем функциональность в классы,заключается в наследовании,то мы должны решить-добавляем ли мы ее в существующий базовый класс,хотя не каждый класс,который наследует от него,нуждается в такой функциональности? Создадим ли мы еще один базовый класс? Но как быть с классами,которые уже наследуются от другого базового класса?</target>
        </trans-unit>
        <trans-unit id="e2615b408bdb1e0ba98c485bf5cdf2441399a639" translate="yes" xml:space="preserve">
          <source>We might know why we decided to make all of these classes inherit from each other, but it might not (probably won't) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.</source>
          <target state="translated">Возможно,мы знаем,почему решили сделать все эти классы наследственными друг от друга,но это может не иметь смысла (вероятно,не будет)для кого-то другого,кто должен поддерживать наш код.Мы можем заставить их сделать трудный выбор-сделать что-то действительно уродливое и грязное,чтобы внести необходимые изменения (см.предыдущий пункт)или просто переписать кучу всего этого.</target>
        </trans-unit>
        <trans-unit id="0e5823e905840f2d1a0b16c41e23924b6b4651bd" translate="yes" xml:space="preserve">
          <source>What do you think about this approach?</source>
          <target state="translated">Что ты думаешь об этом подходе?</target>
        </trans-unit>
        <trans-unit id="c1756bd1b9efd32a1d214b99f06d2f7a4f7d669c" translate="yes" xml:space="preserve">
          <source>When can you use inheritance?</source>
          <target state="translated">Когда вы можете использовать наследство?</target>
        </trans-unit>
        <trans-unit id="d970be0b61d6aad200582d59cc11f107fad3f0af" translate="yes" xml:space="preserve">
          <source>When should you use inheritance?</source>
          <target state="translated">Когда вы должны использовать наследство?</target>
        </trans-unit>
        <trans-unit id="428208f05c644812526e760213d893a9e0d85b4f" translate="yes" xml:space="preserve">
          <source>When we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.</source>
          <target state="translated">Когда мы говорим,что число 5-целое число,мы утверждаем,что 5 принадлежит к набору возможных значений (в качестве примера см.возможные значения для Java-примитивных типов).Мы также заявляем,что существует допустимый набор методов,которые я могу выполнить для таких значений,как сложение и вычитание.И,наконец,мы утверждаем,что существует набор свойств,которые всегда удовлетворяют меня,например,если я добавлю значения 3 и 5,то в результате получу 8.</target>
        </trans-unit>
        <trans-unit id="09af7bb65f1be8d511ca24f115a8de295966a370" translate="yes" xml:space="preserve">
          <source>When you have an &lt;strong&gt;is-a&lt;/strong&gt; relation between two classes (example dog is a canine), you go for inheritance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда у вас есть отношение &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;is-&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; между двумя классами (например, собака - собака), вы переходите на наследство.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0055b1a10a69cdf90f2c9f52386c2e6f796966" translate="yes" xml:space="preserve">
          <source>When you want to &quot;copy&quot;/Expose the base class' API, you use inheritance. When you only want to &quot;copy&quot; functionality, use delegation.</source>
          <target state="translated">Когда вы хотите &quot;скопировать&quot; Разоблачить API базового класса,вы используете наследование.Когда вы хотите только &quot;скопировать&quot; функциональность,используйте делегирование.</target>
        </trans-unit>
        <trans-unit id="68d2706b23183a0d7d52371d8dfbf231a40a8ff7" translate="yes" xml:space="preserve">
          <source>Whether the base class can be instantiated. That is, whether the base class can be non-abstract.  If it can be non-abstract I usually prefer composition</source>
          <target state="translated">Может ли базовый класс быть инстанцирован.То есть,может ли базовый класс быть не абстрактным.Если он может быть неабстрактным,я обычно предпочитаю состав.</target>
        </trans-unit>
        <trans-unit id="a606c7a3b25e33c0493da4afddb01b3c57747671" translate="yes" xml:space="preserve">
          <source>Which class design is better?</source>
          <target state="translated">Какой классовый дизайн лучше?</target>
        </trans-unit>
        <trans-unit id="b1791d8464070d229c878a59d0498e929cd34625" translate="yes" xml:space="preserve">
          <source>While in short words I would agree with &quot;Prefer composition over inheritance&quot;, very often for me it sounds like &quot;prefer potatoes over coca-cola&quot;. There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is &quot;if you are going to use inheritance - think again, chances are you need composition&quot;.</source>
          <target state="translated">Хотя в коротких словах я бы согласился с &quot;Предпочитаю композицию,а не наследство&quot;,очень часто для меня это звучит как &quot;предпочитаю картофель,а не кока-колу&quot;.Есть места для наследования и места для композиции.Нужно понять разницу,тогда этот вопрос исчезнет.На самом деле для меня это означает:&quot;если Вы собираетесь использовать наследование-подумайте еще раз,есть шанс,что Вам нужна композиция&quot;.</target>
        </trans-unit>
        <trans-unit id="027a582c02cb725a52172159b5c1aa8f207673db" translate="yes" xml:space="preserve">
          <source>Why prefer composition over inheritance?</source>
          <target state="translated">Почему предпочитают композицию,а не наследование?</target>
        </trans-unit>
        <trans-unit id="28ebe126ef18993fcdc302fb140fe416bf4b44bd" translate="yes" xml:space="preserve">
          <source>Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?</source>
          <target state="translated">Почему предпочитают композицию,а не наследование? Какие компромиссы существуют для каждого подхода? Когда следует выбирать наследование,а не состав?</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="8a5494e3346ea1f03b16a7e69409337675dba6a2" translate="yes" xml:space="preserve">
          <source>With all the undeniable benefits provided by inheritance, here's some of its disadvantages.</source>
          <target state="translated">Со всеми неоспоримыми преимуществами,предоставляемыми наследством,вот некоторые из его недостатков.</target>
        </trans-unit>
        <trans-unit id="187b043aa54e89394b8d77a7ea3e521335e23aa7" translate="yes" xml:space="preserve">
          <source>With inheritance, you can define/modify/extend a capability</source>
          <target state="translated">С помощью наследования,вы можете дефинемодифицировать расширение возможности</target>
        </trans-unit>
        <trans-unit id="c909e0bb35edebdb81f6b7167ac08348fb47388c" translate="yes" xml:space="preserve">
          <source>With the above trade offs in mind, we hence &lt;em&gt;prefer&lt;/em&gt; composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Имея в виду вышеупомянутые компромиссы, мы, следовательно, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;предпочитаем&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; композицию наследованию. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, для тесно связанных классов, т. Е. Когда неявное повторное использование кода действительно приносит пользу, или желательна волшебная сила открытой рекурсии, наследование должно быть выбором.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca54eb74c9e8cc45b664e45d5cd2d030838c910b" translate="yes" xml:space="preserve">
          <source>With the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.</source>
          <target state="translated">С двумя преимуществами приходят две разные цели для осуществления наследования:ориентация на подтипирование и ориентация на повторное использование кода.</target>
        </trans-unit>
        <trans-unit id="c6f46fcaef29ad747c9c053a5250628a59ec8937" translate="yes" xml:space="preserve">
          <source>You can't change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).</source>
          <target state="translated">Вы не можете изменить реализацию,унаследованную от суперклассов во время исполнения (очевидно,потому что наследование определяется во время компиляции).</target>
        </trans-unit>
        <trans-unit id="c841ca97d91f3a90e4a981be8a8e3eaf9eca4bee" translate="yes" xml:space="preserve">
          <source>You have many classes with &lt;strong&gt;same interface&lt;/strong&gt; and you want to save time writing them</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У вас много классов с &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;одинаковым интерфейсом,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и вы хотите сэкономить время на их написание&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f7027c12ff7351a14aec7ceaf153b91f1cd5a76" translate="yes" xml:space="preserve">
          <source>You have to use same Base Class for each object</source>
          <target state="translated">Вы должны использовать один и тот же базовый класс для каждого объекта.</target>
        </trans-unit>
        <trans-unit id="db9d5b717fd3a0428e874979b657d64399fb0932" translate="yes" xml:space="preserve">
          <source>You may have noticed that most OO languages don't allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think &quot;multiple inheritance would be a really cool feature to solve this problem&quot;, you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.</source>
          <target state="translated">Вы,возможно,заметили,что большинство языков OO не допускают множественного наследования.Хотя есть пара случаев,когда множественное наследование может действительно что-то купить,но это скорее исключения,чем правило.Всякий раз,когда вы сталкиваетесь с ситуацией,когда считаете,что &quot;многократное наследование было бы действительно крутой возможностью для решения этой проблемы&quot;,вы,как правило,находитесь в такой ситуации,когда вам следует заново подумать о многократном наследовании,поскольку даже оно может потребовать пары дополнительных строк кода,решение,основанное на композиции,обычно оказывается гораздо более элегантным,гибким и перспективным.</target>
        </trans-unit>
        <trans-unit id="6461c7d3d8ea98d44e07224509d8188c5fd65616" translate="yes" xml:space="preserve">
          <source>You need to have a look at &lt;strong&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;The Liskov Substitution Principle&lt;/a&gt;&lt;/strong&gt; in Uncle Bob's &lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;SOLID&lt;/a&gt; principles of class design. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам нужно взглянуть на &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Принцип подстановки Лискова&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SOLID&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; принципах проектирования классов &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Дядей Бобом &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="365fd5a8c9d353531398ff13dddbb1a9cd04bd1f" translate="yes" xml:space="preserve">
          <source>You need to modify the private variables, which can not be public in any case</source>
          <target state="translated">Вам необходимо изменить приватные переменные,которые в любом случае не могут быть публичными</target>
        </trans-unit>
        <trans-unit id="debc0fa37d0f792340965981a5a035cc009e22ae" translate="yes" xml:space="preserve">
          <source>You should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.</source>
          <target state="translated">Вы должны предпочитать картофель,а не кока-колу,когда хотите есть,и кока-колу,когда хотите пить.</target>
        </trans-unit>
        <trans-unit id="70a3f516785b8d2c0cef4b9bfa90e997156cdb0e" translate="yes" xml:space="preserve">
          <source>Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.</source>
          <target state="translated">Базовый класс нарушает инкапсуляцию,подвергая детали реализации подклассам в виде защищенных членов.Это делает вашу систему жесткой и хрупкой.Тем не менее,более трагичным недостатком является то,что новый подкласс приносит с собой весь багаж и мнение цепочки наследования.</target>
        </trans-unit>
        <trans-unit id="a7b6ec9ba3ba6cb389d0be77dde1a3a2b1b3c784" translate="yes" xml:space="preserve">
          <source>a bar is a foo</source>
          <target state="translated">бар-это чушь</target>
        </trans-unit>
        <trans-unit id="321619efe153470d82ced208ab3b5924f96e157d" translate="yes" xml:space="preserve">
          <source>a bar is a foo, &lt;strong&gt;AND&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;бар является Foo, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e151551bf5c2dbfb47e6ba04d1cb6d6f9881994" translate="yes" xml:space="preserve">
          <source>all of this applies less to small projects than large ones, and less
  to private classes than public ones</source>
          <target state="translated">все это относится в меньшей степени к малым проектам,чем к крупным,и в меньшей степени к частным занятиям,чем к государственным.</target>
        </trans-unit>
        <trans-unit id="7704fccffa58783a84da4eb8c0166fdf191a3fdd" translate="yes" xml:space="preserve">
          <source>an engine with wings. But what if I wanted to change</source>
          <target state="translated">двигатель с крыльями.Но что если я захочу изменить</target>
        </trans-unit>
        <trans-unit id="8dde7711f9ea3766728a62f96c6515f11ba48445" translate="yes" xml:space="preserve">
          <source>and change them to rotary wings on the fly. It's essentially</source>
          <target state="translated">и поменять их на вращающиеся крылья на лету.По сути</target>
        </trans-unit>
        <trans-unit id="729852eb34a3e850ade763665925935482786102" translate="yes" xml:space="preserve">
          <source>bars can do everything that foos can do.</source>
          <target state="translated">бары могут делать все,что могут ноги.</target>
        </trans-unit>
        <trans-unit id="6b17efef870e73ac5a6927dfab46f89a43147e20" translate="yes" xml:space="preserve">
          <source>e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.</source>
          <target state="translated">Например,Птице может понадобиться только поведение полета на самолете.В этом случае имеет смысл извлечь его как интерфейсный класс и сделать членом обоих классов.</target>
        </trans-unit>
        <trans-unit id="886bf306e5453e891f922ec6a0c0d688fc89e7b2" translate="yes" xml:space="preserve">
          <source>e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane.</source>
          <target state="translated">Например,биплан &quot;Цессна&quot; выставит полный интерфейс самолета,если не больше.Так что это делает его пригодным для получения из самолета.</target>
        </trans-unit>
        <trans-unit id="696ad70d6976b57faf133b6ee5ef5b78578b56f1" translate="yes" xml:space="preserve">
          <source>e.g. If  &lt;em&gt;Car&lt;/em&gt; contains &lt;em&gt;Vehicle&lt;/em&gt; and if you have to get price of the &lt;em&gt;Car&lt;/em&gt;, which has been defined in &lt;em&gt;Vehicle&lt;/em&gt;, your code will be like this</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, если &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Автомобиль&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; содержит &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Автомобиль,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и если вам нужно получить цену на &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Автомобиль&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которая была определена в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Транспортном средстве&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ваш код будет таким&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="1fc4018d629a16d759e998a6c95e3a4757b18a87" translate="yes" xml:space="preserve">
          <source>implementation (for code reuse)</source>
          <target state="translated">реализация (для повторного использования кода)</target>
        </trans-unit>
        <trans-unit id="8242e2b420f05d62490ce28c67966e458a29c56a" translate="yes" xml:space="preserve">
          <source>inheritance is probably the worst form of coupling you can have</source>
          <target state="translated">Наследование,вероятно,самая худшая форма связи,которую вы можете иметь.</target>
        </trans-unit>
        <trans-unit id="f2804e2e271f82c68b66f986da5df262ee4cb967" translate="yes" xml:space="preserve">
          <source>interface (for polymorphism)</source>
          <target state="translated">интерфейс (для полиморфизма)</target>
        </trans-unit>
        <trans-unit id="13ac262839d95d773d2a3d28f3999d812e21769b" translate="yes" xml:space="preserve">
          <source>properties, or I redesign &lt;code&gt;Aircraft&lt;/code&gt; as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;свойства, или я изменяю дизайн &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Aircraft&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8823f52bf571c1ac1f5e036a349bdba206f867f6" translate="yes" xml:space="preserve">
          <source>the engine on the fly as well?</source>
          <target state="translated">и двигатель на ходу?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
