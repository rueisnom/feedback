<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1335851">
    <body>
      <group id="1335851">
        <trans-unit id="59655149a5150c3ca8c39faa908f2d6163ff8a16" translate="yes" xml:space="preserve">
          <source>&quot;Use Strict&quot;; is an insurance that programmer will not use the loose or the bad properties of JavaScript. It is a guide, just like a ruler will help you make straight lines. &quot;Use Strict&quot; will help you do &quot;Straight coding&quot;.</source>
          <target state="translated">&quot;엄격한 사용&quot;; 프로그래머가 JavaScript의 느슨하거나 나쁜 속성을 사용하지 않는 보험입니다. 통치자가 직선을 만드는 데 도움이되는 것처럼 가이드입니다. &quot;엄격한 사용&quot;은 &quot;직선 코딩&quot;에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3004d681862814bd492c00f298f79de8546a16e3" translate="yes" xml:space="preserve">
          <source>&quot;use strict&quot;; is the ECMA effort to make JavaScript a little bit more robust. It brings in JS an attempt to make it at least a little &quot;strict&quot; (other languages implement strict rules since the 90s). It actually &quot;forces&quot; JavaScript developers to follow some sort of coding best practices.
Still, JavaScript is very fragile. There is no such thing as typed variables, typed methods, etc.
I strongly recommend JavaScript developers to learn a more robust language such as Java or ActionScript3, and implement the same best practices in your JavaScript code, it will work better and be easier to debug.</source>
          <target state="translated">&quot;엄격한 사용&quot;; JavaScript를 좀 더 강력하게 만드는 ECMA의 노력입니다. JS는 최소한 &quot;엄격한&quot;(다른 언어는 90 년대 이후 엄격한 규칙을 구현)하려고 시도했다. 실제로 JavaScript 개발자는 일종의 코딩 모범 사례를 따르도록 강요합니다. 여전히 JavaScript는 매우 취약합니다. 유형 변수, 유형 메소드 등은 없습니다. JavaScript 개발자는 Java 또는 ActionScript3와 같은 더 강력한 언어를 배우고 JavaScript 코드에서 동일한 모범 사례를 구현하는 것이 좋습니다. 디버그.</target>
        </trans-unit>
        <trans-unit id="a890ef5e6862668a8f388386b332421857c3174b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20170707015027/http://cjihrig.com/blog/javascripts-strict-mode-and-why-you-should-use-it/&quot;&gt;JavaScript&amp;rsquo;s Strict Mode and Why You Should Use It&lt;/a&gt; on Colin J. Ihrig's blog (archived version)</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20170707015027/http://cjihrig.com/blog/javascripts-strict-mode-and-why-you-should-use-it/&quot;&gt;JavaScript의 엄격한 모드와&lt;/a&gt; Colin J. Ihrig의 블로그 (아카이브 버전)에서 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="d3d3727e7b6567159e7a102fb614c67f67805b58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.jslint.com/&quot;&gt;JSLint&lt;/a&gt; is a debugger written by Douglas Crockford. Simply paste in your script, and it&amp;rsquo;ll quickly scan for any noticeable issues and errors in your code.</source>
          <target state="translated">&lt;a href=&quot;http://www.jslint.com/&quot;&gt;JSLint&lt;/a&gt; 는 Douglas Crockford가 작성한 디버거입니다. 스크립트에 붙여 넣기 만하면 코드에서 눈에 띄는 문제와 오류가 있는지 신속하게 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="78bf625f7b5e03664c59d7ee51dc7af02310b85e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.w3schools.com/js/js_strict.asp&quot;&gt;Quoting from w3schools&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3schools.com/js/js_strict.asp&quot;&gt;w3schools에서 인용&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b5af4e0174180b8a2c7208d7edf82d109f9cd5e9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;Strict mode&lt;/a&gt; on MDN</source>
          <target state="translated">MDN의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;엄격한 모드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5bcc7d75cb8e736baf64db945995c8b9a3a60be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode&quot;&gt;Transitioning to strict mode&lt;/a&gt; on MDN</source>
          <target state="translated">MDN &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode&quot;&gt;에서 엄격 모드로 전환&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e939affa70685384b45a4a4e094772a28124974" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;use strict&quot;&lt;/code&gt; a directive introduced in ECMAScript 5.</source>
          <target state="translated">ECMAScript 5에 도입 된 지시문을 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="643a6e9cb02c410968fee48edd499efb7b160711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;use strict&quot;&lt;/code&gt; is widely needed to be used in ECMA5, &lt;strong&gt;in ECMA6 it's part of JavaScript by default&lt;/strong&gt;, so it doesn't need to be added if you're using ES6.</source>
          <target state="translated">ECMA5에서 사용하려면 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 이 널리 필요합니다. ECMA6에서는 &lt;strong&gt;기본적으로 JavaScript의 일부&lt;/strong&gt; 이므로 ES6을 사용하는 경우 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="42f94653c815af9a0a66db63daf88a106628f565" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;use strict&quot;&lt;/code&gt; makes JavaScript code to run in &lt;em&gt;strict mode&lt;/em&gt;, which basically means everything needs to be defined before use. The main reason for using strict mode is to avoid accidental global uses of undefined methods.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 은 JavaScript 코드를 &lt;em&gt;엄격 모드&lt;/em&gt; 에서 실행하도록 &lt;em&gt;합니다&lt;/em&gt; . 이는 기본적으로 사용하기 전에 모든 것을 정의해야 함을 의미합니다. 엄격 모드를 사용하는 주된 이유는 정의되지 않은 메소드가 실수로 전역 적으로 사용되는 것을 피하기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="b2700ddb133085373ac38f09a3f5d0bf79811178" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arguments.callee&lt;/code&gt; is not supported</source>
          <target state="translated">&lt;code&gt;arguments.callee&lt;/code&gt; 는 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="f8d48d4465392e0aa08ee8ea840aa1b3f23996fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt; in strict mode does not introduce new variables</source>
          <target state="translated">엄격 모드의 &lt;code&gt;eval&lt;/code&gt; 은 새로운 변수를 도입하지 않습니다</target>
        </trans-unit>
        <trans-unit id="3ab7533dde427ea5d6492eae8a3125e8afc3cfaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;implements&lt;/code&gt;, &lt;code&gt;interface&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;implements&lt;/code&gt; , &lt;code&gt;interface&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;package&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec53e46b9a64ec466cbf3b9f2ea170c32991ddb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; point to the global object.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 점은 전역 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="ff636551fe7d26c196cc6753f1ecb44215346d16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use strict&lt;/code&gt; also works inside of individual functions. It is always a better practice to include &lt;code&gt;use strict&lt;/code&gt; in your code.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 은 개별 기능 내에서도 작동합니다. 항상 코드에 &lt;code&gt;use strict&lt;/code&gt; 을 포함시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="189bf0e21b07dc936d1f4023bde32e80cf254249" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use strict&lt;/code&gt; can be used only at the beginning of a script or of a function, i.e. it must precede every other (real) statement. It does not have to be the first instruction in a script of function: it can be preceded by other statement expressions that consist of string literals ( and JavaScript implementations can treat them as implementation specific directives). String literals statements, which follow a first real statement (in a script or function) are simple expression statements. Interpreters must not interpret them as directives and they have no effect.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 는 스크립트 나 함수의 시작 부분에서만 사용할 수 있습니다. 즉, 다른 모든 실제 명령문 앞에 와야합니다. 함수 스크립트에서 첫 번째 명령 일 필요는 없습니다. 문자열 리터럴로 구성된 다른 명령문 표현식이 앞에 올 수 있습니다 (JavaScript 구현에서는이를 구현 특정 지시문으로 취급 할 수 있음). 스크립트 또는 함수에서 첫 번째 실제 명령문을 따르는 문자열 리터럴 명령문은 간단한 표현식 명령문입니다. 통역사는 지시어로 해석해서는 안되며 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8a24ea46f8167baca5ea7c30a696dde06bff8b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use strict&lt;/code&gt; does not contain key words: The directive is a simple expression statement, which consists of a special string literal (in single or double quotes). JavaScript engines, that do not implement ECMAScript 5, merely see an expression statement without side effects. It is expected that future versions of ECMAScript standards introduce &lt;code&gt;use&lt;/code&gt; as a real key word; the quotes would thereby become obsolete.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 에는 키워드가 포함되지 않습니다. 지시문은 간단한 표현식 문으로, 특수 문자열 리터럴 (작은 따옴표 나 큰 따옴표)로 구성됩니다. ECMAScript 5를 구현하지 않는 JavaScript 엔진은 부작용없이 표현식 문만 보게됩니다. 향후 버전의 ECMAScript 표준은 실제 키워드로 &lt;code&gt;use&lt;/code&gt; 되기를 기대합니다. 따라서 인용문은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93d83abef028d4a348358ca66f7d7b8d130ab13f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use strict&lt;/code&gt; is a way to make your code safer, because you can't use dangerous features that can work not as you expect. And, as was written before, it makes code more strict.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 은 코드를 더 안전하게 만드는 방법입니다. 예상대로 작동하지 않는 위험한 기능을 사용할 수 없기 때문입니다. 그리고 이전에 작성된 것처럼 코드를보다 엄격하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="02f9e1a9c89babe3794e548d1c031c3a106b1dc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with&lt;/code&gt; statements can't be minified using tools like &lt;a href=&quot;http://marijnhaverbeke.nl/uglifyjs&quot;&gt;uglify-js&lt;/a&gt;. They're also &lt;a href=&quot;http://www.2ality.com/2011/06/with-statement.html&quot;&gt;deprecated&lt;/a&gt; and removed from future JavaScript versions.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문은 &lt;a href=&quot;http://marijnhaverbeke.nl/uglifyjs&quot;&gt;uglify-js&lt;/a&gt; 와 같은 도구를 사용하여 축소 할 수 없습니다. 또한 향후 JavaScript 버전에서 &lt;a href=&quot;http://www.2ality.com/2011/06/with-statement.html&quot;&gt;더 이상 사용되지 않으며&lt;/a&gt; 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="0f478c9cf6e945f9f4d68899a9b247c36f3d43c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;My two cents:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;내 두 센트 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6ab9835d91deb98705b1f3c514957269bbf6e08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NovoGeek.com - Krishna's weblog&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;NovoGeek.com-Krishna의 웹 로그&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8816eb841c341fc968650270e2dd8daff581dcd3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Paving the way for future ECMAScript versions&lt;/em&gt;, using one of the newly reserved keywords (in prevision for &lt;em&gt;ECMAScript 6&lt;/em&gt;): &lt;code&gt;implements&lt;/code&gt;, &lt;code&gt;interface&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;ECMAScript 6에&lt;/em&gt; 대해 사전 예약 된 새로 예약 된 키워드 중 하나를 사용하여 &lt;em&gt;향후 ECMAScript 버전을위한 방법을&lt;/em&gt; &lt;code&gt;implements&lt;/code&gt; : 구현 , &lt;code&gt;interface&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;package&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52f29c68d91653f44d8533c880c63c94e3e9dcf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;use strict&quot;; Defines that JavaScript code should be executed in
   &quot;strict mode&quot;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;엄격한 사용&quot;;&lt;/strong&gt; &lt;strong&gt;JavaScript 코드가 &quot;엄격 모드&quot;에서 실행되도록 정의합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09cd3a0fa55f56bac5040bfc18287c80994ace0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) strict mode in functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 기능의 엄격 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e089472c5ade8f427379cbfba941de4da55d3013" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) whole-script strict mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) 전체 스크립트 엄격 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b57044be78a581d58d23dca3de27afea5b94cd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Assignment to a non-writable global&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) 쓰기 불가능한 글로벌에 할당&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52c10b26b568d358a2c9ff43b75af0bbd5a03c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Eliminates &lt;code&gt;with&lt;/code&gt; statement :&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;진술로 제거 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b530f16cb2cdcb16e6f7fae19819d91e97699f28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Prevents Duplicates :&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;중복 방지 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="006313eaf6ed1ef228bc9756401cadce71d77bf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Prevents Global Variable Declaration:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;전역 변수 선언 방지 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44a2e98717969ad732e7c5e16b7d1aae416b7dda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Disadvantage&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccc562ed44c4f818dcfeca5bfa62cf8a988e432f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of using &quot;use strict&quot;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;엄격한 사용&quot;의 예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32305f493625f6db39745d253e553217cacc1727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For basic example and for reference go through :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 예와 참조를 위해 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d1cedec098132288882de2701536c454db45920" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modern JavaScript practice should always evoke the &quot;Use Strict&quot;; pragma.&lt;/strong&gt; The only reason that the ECMA Group has made the &quot;Strict&quot; mode optional &lt;em&gt;is to permit less experienced coders access to JavaScript and give then time to adapt to the new and safer coding practices.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;현대의 JavaScript 실습은 항상 &quot;엄격한 사용&quot;을 불러 와야합니다.&lt;/strong&gt; &lt;strong&gt;프라 그마.&lt;/strong&gt; ECMA 그룹이 &quot;엄격한&quot;모드를 선택적 &lt;em&gt;으로&lt;/em&gt; 설정 한 유일한 이유는 &lt;em&gt;경험이 적은 코더가 JavaScript에 액세스 할 수 있도록 허용 한 다음 새롭고 안전한 코딩 방법에 적응할 시간을주기 위해서입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6733430d33b7d3b1398536a80cb90975b34194ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strict mode can prevent memory leaks.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;엄격 모드는 메모리 누수를 방지 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f944ee70b14fb3dd9fca1ed2e2bdaf3550fc90e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &quot;use strict&quot; Directive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;엄격한 사용&quot;지침&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="606ab5905d1c2d5a8327c6d7ed46db7c3e80503c" translate="yes" xml:space="preserve">
          <source>A word of caution, all you hard-charging programmers:  applying &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; to existing code can be hazardous!  This thing is not some feel-good, happy-face sticker that you can slap on the code to make it 'better'.  With the &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; pragma, the browser will suddenly THROW exceptions in random places that it never threw before just because at that spot you are doing something that default/loose JavaScript happily allows but strict JavaScript abhors!  You may have strictness violations hiding in seldom used calls in your code that will only throw an exception when they do eventually get run - say, in the production environment that your paying customers use!</source>
          <target state="translated">주의해야 할 것은 하드 충전 프로그래머 모두입니다. 기존 코드에 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 을 적용하는 것은 위험 할 수 있습니다! 이 것은 기분이 좋고 행복한 얼굴 스티커가 아니므로 코드를 더 잘 찍을 수 있습니다. &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; pragma를 사용하면 브라우저가 갑자기 발생하지 않은 임의의 위치에서 예외를 갑자기 발생시킵니다. 그 자리에서 기본 / 느슨한 JavaScript가 행복하게 허용하지만 엄격한 JavaScript는 혐오스러운 일을하고 있기 때문입니다! 엄격하게 위반하면 코드에서 거의 사용되지 않는 호출에 숨겨져있어 결국 유료 고객이 사용하는 프로덕션 환경에서 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93bdd3af6ffad7ab4f106dd14cd1a4e23ee208e6" translate="yes" xml:space="preserve">
          <source>All modern browsers support &quot;use strict&quot; except &lt;em&gt;Internet Explorer 9 and lower&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Internet Explorer 9 이하를&lt;/em&gt; 제외한 모든 최신 브라우저는 &quot;엄격한 사용&quot;을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2343885cdd0e3c22f513cc0ca57ce37cc20a84a5" translate="yes" xml:space="preserve">
          <source>All parts of a &lt;em&gt;ClassDeclaration&lt;/em&gt; or a &lt;em&gt;ClassExpression&lt;/em&gt; are strict mode    code.</source>
          <target state="translated">&lt;em&gt;ClassDeclaration&lt;/em&gt; 또는 &lt;em&gt;ClassExpression&lt;/em&gt; 의 모든 부분은 엄격 모드 코드입니다.</target>
        </trans-unit>
        <trans-unit id="289ffdbd1f800570bced2d458ea2e61545122c4a" translate="yes" xml:space="preserve">
          <source>Also in strict mode, things run faster, some warnings or silent warnings throw fatal errors, it's better to always use it to make a neater code.</source>
          <target state="translated">또한 엄격 모드에서는 상황이 더 빨리 실행되고 일부 경고 또는 자동 경고는 치명적인 오류를 발생시키기 때문에 항상 더 깔끔한 코드를 만드는 데 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="da06e553d0eb67ac4244ee6f5298f173e41be07e" translate="yes" xml:space="preserve">
          <source>Also note you can apply &quot;strict mode&quot; to the whole file... Or you can use it only for a specific function &lt;em&gt;(still quoting from John Resig's article)&lt;/em&gt;:</source>
          <target state="translated">또한 전체 파일에 &quot;엄격 모드&quot;를 적용 할 수 있습니다. 또는 &lt;em&gt;John Resig의 기사에서 인용&lt;/em&gt; 한 특정 기능에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73300c7892262287c245360c5af86d15a6a13f4" translate="yes" xml:space="preserve">
          <source>Also when a function is invoked with &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; in strict mode, then &lt;code&gt;this&lt;/code&gt; is exactly the value of the first argument of the &lt;code&gt;call()&lt;/code&gt;or &lt;code&gt;apply()&lt;/code&gt; invocation. (In normal mode &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are replaced by the global &lt;code&gt;Object&lt;/code&gt; and values, which are not objects, are cast into objects.)</source>
          <target state="translated">또한 &lt;code&gt;call()&lt;/code&gt; 사용하여 함수를 호출하거나 엄격 모드로 &lt;code&gt;apply&lt;/code&gt; 하는 경우 이는 &lt;code&gt;call()&lt;/code&gt; 또는 &lt;code&gt;apply()&lt;/code&gt; 호출의 첫 번째 인수의 값입니다. (정상 모드에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 전역 &lt;code&gt;Object&lt;/code&gt; 로 바뀌고 객체가 아닌 값은 객체로 캐스트됩니다.)</target>
        </trans-unit>
        <trans-unit id="b93fcc8b812303345005a85b6a1b344c558d79a2" translate="yes" xml:space="preserve">
          <source>Also, as listed above, strict mode stops you from doing certain things.</source>
          <target state="translated">또한 위에 나열된 것처럼 엄격 모드는 특정 작업을 수행하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="f29a859de34d8206276e4fbe86c78577ef463680" translate="yes" xml:space="preserve">
          <source>And:</source>
          <target state="translated">And:</target>
        </trans-unit>
        <trans-unit id="e2abd0d44e964816aa501cf23404b343505b9d60" translate="yes" xml:space="preserve">
          <source>Another scenario is that, say, the variable is declared in a child function. In that case, the compiler checks the validity of that variable in the outer scope, i.e., the parent function. Only then it will check in the global space and create a variable for us there.
That means additional checks need to be done. This will affect the performance of the application.</source>
          <target state="translated">또 다른 시나리오는 변수가 자식 함수에서 선언되는 것입니다. 이 경우 컴파일러는 외부 범위, 즉 상위 함수에서 해당 변수의 유효성을 확인합니다. 그래야만 글로벌 공간을 체크인하고 거기에 변수를 만들 수 있습니다. 즉, 추가 점검이 필요합니다. 이것은 응용 프로그램의 성능에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="0ce5379811a96887a1d3f16ab89d89d7711a7375" translate="yes" xml:space="preserve">
          <source>Apparently, at the initial stage there will be errors we have never encountered before. To get the full benefit, we need to do proper testing after switching to strict mode to make sure we have caught everything. Definitely we don&amp;rsquo;t just throw &lt;code&gt;use strict&lt;/code&gt; in our code and assume there are no errors. So the churn is that it&amp;rsquo;s time to start using this incredibly useful language feature to write better code.</source>
          <target state="translated">분명히, 초기 단계에서 우리가 전에는 본 적이없는 오류가있을 것입니다. 모든 이점을 얻으려면 엄격한 모드로 전환 한 후 모든 것을 포착했는지 확인하기 위해 적절한 테스트를 수행해야합니다. 확실히 우리는 코드에서 &lt;code&gt;use strict&lt;/code&gt; 하지 않고 오류가 없다고 가정합니다. 따라서 더 좋은 코드를 작성하기 위해이 매우 유용한 언어 기능을 사용하기 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="23c13738c7207b9f6d81bccd86fb3f5f24fbc321" translate="yes" xml:space="preserve">
          <source>As an example, in normal JavaScript, mistyping a variable name creates
  a new global variable. In strict mode, this will throw an error,
  making it impossible to accidentally create a global variable.</source>
          <target state="translated">예를 들어, 일반적인 JavaScript에서 변수 이름을 잘못 입력하면 새로운 전역 변수가 만들어집니다. 엄격 모드에서는 실수로 전역 변수를 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c40cd067423f60a47c31129f8f11cc9df0347a6" translate="yes" xml:space="preserve">
          <source>Attempts to delete undeletable properties will throw (&lt;code&gt;delete Object.prototype&lt;/code&gt;)</source>
          <target state="translated">삭제 불가능한 속성을 삭제하려고하면 ( &lt;code&gt;delete Object.prototype&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9b6df8c6d28fca843574fe8424266b77eefb28e0" translate="yes" xml:space="preserve">
          <source>Believe me. The overhead is negligible compared to poorly designed code. &lt;a href=&quot;http://www.yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/&quot;&gt;Doug Crockford, who has been a senior JavaScript developer for several years, has a very interesting post here&lt;/a&gt;. Personally, I like to return to his site all the time to make sure I don't forget my good practice.</source>
          <target state="translated">나를 믿어. 잘못 설계된 코드와 비교할 때 오버 헤드는 무시할 수 있습니다. &lt;a href=&quot;http://www.yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/&quot;&gt;수년간 수석 JavaScript 개발자였던 Doug Crockford는 여기에 매우 흥미로운 게시물을 가지고 있습니다&lt;/a&gt; . 개인적으로, 나는 항상 좋은 습관을 잊지 않도록 자신의 사이트를 방문하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="a1ddd7f39e440d9be6e057065c68fec0776269ba" translate="yes" xml:space="preserve">
          <source>Below are the conditions to trigger strict mode in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-code&quot;&gt;ES6&lt;/a&gt; and &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-strict-mode-code&quot;&gt;ES7&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-code&quot;&gt;ES6&lt;/a&gt; 및 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-strict-mode-code&quot;&gt;ES7&lt;/a&gt; 에서 엄격 모드를 트리거하는 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1928a98ad81a0a2fb8810d43513549e8510e1221" translate="yes" xml:space="preserve">
          <source>Browser compatibility issue: 
The &quot;use&quot; directives are meant to be backwards-compatible. Browsers that do not support them will just see a string literal that isn't referenced further. So, they will pass over it and move on.</source>
          <target state="translated">브라우저 호환성 문제 : &quot;use&quot;지시문은 이전 버전과 호환됩니다. 이를 지원하지 않는 브라우저는 더 이상 참조되지 않는 문자열 리터럴 만 보게됩니다. 그래서 그들은 그것을 넘겨 나갈 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a7fb1b9a52cbb2e017378cb1f11854e33a814a7" translate="yes" xml:space="preserve">
          <source>Browser support for strict mode</source>
          <target state="translated">엄격 모드에 대한 브라우저 지원</target>
        </trans-unit>
        <trans-unit id="565e25b1be863570aa48357d4e37a3cb9b1014a4" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="translated">이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="baa2c64bbbada534ed6075e89a55128be8090417" translate="yes" xml:space="preserve">
          <source>Declaring function in blocks</source>
          <target state="translated">블록에서 함수 선언</target>
        </trans-unit>
        <trans-unit id="38996e986e93e308076d27bc04e168330b4535b3" translate="yes" xml:space="preserve">
          <source>Declaring twice the same name for a property name in an object literal</source>
          <target state="translated">객체 리터럴에서 속성 이름에 대해 동일한 이름을 두 번 선언</target>
        </trans-unit>
        <trans-unit id="29ac6062865d40d043be78b3c36ccdeeec441106" translate="yes" xml:space="preserve">
          <source>Declaring two function arguments with the same name function</source>
          <target state="translated">이름 함수가 동일한 두 개의 함수 인수 선언</target>
        </trans-unit>
        <trans-unit id="5c4d6e11f66aa0a3fdd7d4a8816581873a8955ae" translate="yes" xml:space="preserve">
          <source>Directives are similar to statements, yet different.</source>
          <target state="translated">지시문은 문장과 비슷하지만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b8f87df5829d8a168c7e799e5c216af27378f943" translate="yes" xml:space="preserve">
          <source>Disallows global variables. (Catches missing &lt;code&gt;var&lt;/code&gt; declarations and typos in variable names)</source>
          <target state="translated">전역 변수를 허용하지 않습니다. (변수 이름에 누락 된 &lt;code&gt;var&lt;/code&gt; 선언 및 오타가 있음)</target>
        </trans-unit>
        <trans-unit id="273671e9ae03a9235fcaa5ba2170f1974218b666" translate="yes" xml:space="preserve">
          <source>Do any of the current browsers respond to the &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; string or is it for future use?</source>
          <target state="translated">현재 브라우저 중 하나라도 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 응답하십시오 . 문자열 또는 나중에 사용하기위한 것입니까?</target>
        </trans-unit>
        <trans-unit id="e4d1d77242da906971270be245172a570ee8b0fb" translate="yes" xml:space="preserve">
          <source>Doing some searching, I realized that some people add &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; into their JavaScript code. Once I added the statement, the error stopped appearing. Unfortunately, Google did not reveal much of the history behind this string statement. Certainly it must have something to do with how the JavaScript is interpreted by the browser, but I have no idea what the effect would be.</source>
          <target state="translated">몇 가지 검색을 수행하면서 일부 사람들은 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 추가한다는 것을 깨달았습니다 . 그들의 JavaScript 코드로. 문을 추가하면 오류가 더 이상 나타나지 않습니다. 불행히도 구글은이 문자열 진술의 역사를 많이 밝히지 않았다. 확실히 브라우저가 JavaScript를 해석하는 방법과 관련이 있어야하지만 그 효과가 무엇인지 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="48af85fc915d01a4202f28354202609ebabc9352" translate="yes" xml:space="preserve">
          <source>ECMAScript 5 'Strict mode' support in browsers. What does this mean?</source>
          <target state="translated">브라우저에서 ECMAScript 5 '엄격한 모드'지원. 이것은 무엇을 의미 하는가?</target>
        </trans-unit>
        <trans-unit id="9fc854e7ec3ef2a462edaa98d116548946d2673f" translate="yes" xml:space="preserve">
          <source>ECMAScript 5 adds a list of reserved words. If you use them as variables or arguments, strict mode will throw an error. The reserved words are:</source>
          <target state="translated">ECMAScript 5는 예약어 목록을 추가합니다. 변수 또는 인수로 사용하면 엄격 모드에서 오류가 발생합니다. 예약어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebcaa1421d2e09e7ea9eec47fe05b48861d7705e" translate="yes" xml:space="preserve">
          <source>Eliminates this coercion</source>
          <target state="translated">이 강요를 제거합니다</target>
        </trans-unit>
        <trans-unit id="ed326f039ef104d9ba966135c56dac8bf600657a" translate="yes" xml:space="preserve">
          <source>Eliminates with</source>
          <target state="translated">와 함께 제거</target>
        </trans-unit>
        <trans-unit id="0c26b81d89bbb54118dbce8cd05504fa17f8b5c2" translate="yes" xml:space="preserve">
          <source>Errors for immutables</source>
          <target state="translated">불변의 에러</target>
        </trans-unit>
        <trans-unit id="efa60700d7b2ed517f9d3d0229490278c5d94c97" translate="yes" xml:space="preserve">
          <source>Et cetera</source>
          <target state="translated">등등</target>
        </trans-unit>
        <trans-unit id="e5356a0a78fcc2f6a59293d5076e50a82279173b" translate="yes" xml:space="preserve">
          <source>Eval code is strict mode code if it begins with a Directive Prologue    that contains a Use Strict Directive or if the call to eval is a direct eval (see 12.3.4.1) that is contained in strict mode code.</source>
          <target state="translated">Eval 코드는 Use Strict Directive가 포함 된 Directive Prologue로 시작하거나 eval에 대한 호출이 엄격 모드 코드에 포함 된 직접 eval (12.3.4.1 참조) 인 경우 엄격한 모드 코드입니다.</target>
        </trans-unit>
        <trans-unit id="89ce572ad2c6a69c00995dd23c773545b3d69731" translate="yes" xml:space="preserve">
          <source>Everything in the &lt;em&gt;lexical scope&lt;/em&gt; of function &lt;code&gt;doSomething&lt;/code&gt; will be interpreted in strict mode. The word &lt;em&gt;lexical scope&lt;/em&gt; is important here. For example, if your &lt;em&gt;strict&lt;/em&gt; code calls a function of a library that is &lt;em&gt;not strict&lt;/em&gt;, only your code is executed in strict mode, and not the called function. See &lt;a href=&quot;https://stackoverflow.com/a/6039163/1461424&quot;&gt;this answer&lt;/a&gt; for a better explanation.</source>
          <target state="translated">&lt;em&gt;어휘 범위&lt;/em&gt; 의 함수 &lt;code&gt;doSomething&lt;/code&gt; 에있는 모든 것은 엄격 모드에서 해석됩니다. &lt;em&gt;어휘 범위&lt;/em&gt; 라는 단어가 여기서 중요합니다. 예를 들어, &lt;em&gt;엄격한&lt;/em&gt; 코드가 &lt;em&gt;엄격&lt;/em&gt; &lt;em&gt;하지 않은&lt;/em&gt; 라이브러리의 함수를 호출하면 코드 만 호출 된 함수가 &lt;em&gt;아닌&lt;/em&gt; 엄격 모드로 실행됩니다. 자세한 설명은 &lt;a href=&quot;https://stackoverflow.com/a/6039163/1461424&quot;&gt;이 답변&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="4daa46b47ce88ea7b35fb3d45a4029cb54de2f47" translate="yes" xml:space="preserve">
          <source>Few important things which I have learned after using &lt;code&gt;use strict&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 사용을 사용한 후에 배운 몇 가지 중요한 사항 :</target>
        </trans-unit>
        <trans-unit id="b80e966415fec4b14584eef46091cc1f5fed8c7a" translate="yes" xml:space="preserve">
          <source>For a non-exhaustive list of specialties in strict mode, see &lt;a href=&quot;https://stackoverflow.com/a/27114400/1461424&quot;&gt;this answer&lt;/a&gt;.</source>
          <target state="translated">엄격 모드의 비전문가 목록은 &lt;a href=&quot;https://stackoverflow.com/a/27114400/1461424&quot;&gt;이 답변을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="59a44288386a492ebd014862dd175b15ca71076a" translate="yes" xml:space="preserve">
          <source>Forbids binding or assignment of the names &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; in any form</source>
          <target state="translated">모든 형식의 이름 &lt;code&gt;eval&lt;/code&gt; 및 &lt;code&gt;arguments&lt;/code&gt; 의 바인딩 또는 할당을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="85882ed43f947d20ab023a241c16a0839507bff1" translate="yes" xml:space="preserve">
          <source>Forbids deleting plain names (&lt;code&gt;delete x;&lt;/code&gt;)</source>
          <target state="translated">일반 이름 삭제 금지 ( &lt;code&gt;delete x;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="932069b68ebf7d6e48537be78e32212e3699abcd" translate="yes" xml:space="preserve">
          <source>Forbids octal syntax (&lt;code&gt;var x = 023;&lt;/code&gt; some devs assume wrongly that a preceding zero does nothing to change the number.)</source>
          <target state="translated">8 진수 구문을 금지합니다 ( &lt;code&gt;var x = 023;&lt;/code&gt; 일부 개발자는 앞의 0이 숫자를 변경하는 데 아무 것도 없다고 잘못 가정합니다.)</target>
        </trans-unit>
        <trans-unit id="3799c98240f4cdb7b40c5e3fdcb7c5e4f2f10c8b" translate="yes" xml:space="preserve">
          <source>Forbids the &lt;code&gt;with&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 키워드를 금지합니다</target>
        </trans-unit>
        <trans-unit id="b458948cb359c5a3bdb7d06c0c0102f9e79964a1" translate="yes" xml:space="preserve">
          <source>Function code is strict mode code if the associated &lt;em&gt;FunctionDeclaration, FunctionExpression, GeneratorDeclaration, GeneratorExpression, MethodDefinition, or ArrowFunction&lt;/em&gt; is contained in strict mode code or if the code that produces the value of the function&amp;rsquo;s [[ECMAScriptCode]] internal slot begins with a Directive Prologue that contains a Use Strict Directive.</source>
          <target state="translated">연관된 &lt;em&gt;FunctionDeclaration, FunctionExpression, GeneratorDeclaration, GeneratorExpression, MethodDefinition 또는 ArrowFunction&lt;/em&gt; 이 엄격한 모드 코드에 포함되어 있거나 함수의 [[ECMAScriptCode]] 내부 슬롯의 값을 생성하는 코드가 Directive Prologue로 시작하는 경우 함수 코드는 엄격한 모드 코드입니다. 엄격한 사용 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c282a4f93e31f632be83929715796e01490e87f" translate="yes" xml:space="preserve">
          <source>Function code that is supplied as the arguments to the built-in    Function and Generator constructors is strict mode code if the last argument is a String that when processed is a &lt;em&gt;FunctionBody&lt;/em&gt; that begins with a Directive Prologue that contains a Use Strict Directive.</source>
          <target state="translated">마지막 인수가 처리 될 때 엄격한 지시문이 포함 된 지시문 프롤로그로 시작하는 &lt;em&gt;FunctionBody 인&lt;/em&gt; 문자열 인 경우 내장 함수 및 생성자 생성자에 인수로 제공되는 함수 코드는 엄격한 모드 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1847e9a8ccc9abd72f714eab1618108a4c8cbe08" translate="yes" xml:space="preserve">
          <source>Function parameter names must be unique (&lt;code&gt;function sum (x, x) {...}&lt;/code&gt;)</source>
          <target state="translated">함수 매개 변수 이름은 고유해야합니다 ( &lt;code&gt;function sum (x, x) {...}&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="e311ed625506e39cf4918abdd75a8aaa56e4dfc8" translate="yes" xml:space="preserve">
          <source>Global Leakage</source>
          <target state="translated">글로벌 누출</target>
        </trans-unit>
        <trans-unit id="eead7b84869b7d6893ff5ea59fd12d29fc73671a" translate="yes" xml:space="preserve">
          <source>Global code is strict mode code if it begins with a Directive    Prologue that contains a Use Strict Directive (see 14.1.1).</source>
          <target state="translated">전역 코드는 엄격한 사용 지침 (14.1.1 참조)이 포함 된 Directive Prologue로 시작하는 경우 엄격한 모드 코드입니다.</target>
        </trans-unit>
        <trans-unit id="6304fe8539e56d461068a240f624db35fe5dca0a" translate="yes" xml:space="preserve">
          <source>Here, the compiler throws the reference error. In strict mode, the compiler does not allow us to use the variable without declaring it. So memory leaks can be prevented. In addition, we can write more optimized code.</source>
          <target state="translated">여기서 컴파일러는 참조 오류를 발생시킵니다. 엄격 모드에서는 컴파일러가 변수를 선언하지 않고 사용할 수 없습니다. 따라서 메모리 누수를 방지 할 수 있습니다. 또한 더 최적화 된 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d2172dcc5510adbb4b052a53b0f1eaf23d08d5" translate="yes" xml:space="preserve">
          <source>Historically, JavaScript has been confused about how functions
  are scoped. Sometimes they seem to be statically scoped, but some
  features make them behave like they are dynamically scoped. This is
  confusing, making programs difficult to read and understand.
  Misunderstanding causes bugs. It also is a problem for performance.
  Static scoping would permit variable binding to happen at compile
  time, but the requirement for dynamic scope means the binding must be
  deferred to runtime, which comes with a significant performance
  penalty.</source>
          <target state="translated">역사적으로 JavaScript는 함수의 범위를 지정하는 방법에 대해 혼란 스러웠습니다. 때로는 정적으로 범위가 지정된 것처럼 보이지만 일부 기능은 동적으로 범위가 지정된 것처럼 동작합니다. 혼란 스럽기 때문에 프로그램을 읽고 이해하기가 어렵습니다. 오해로 인해 버그가 발생합니다. 성능 문제이기도합니다. 정적 범위 지정은 컴파일 타임에 변수 바인딩이 발생하도록 허용하지만 동적 범위의 요구 사항은 바인딩이 런타임으로 지연되어야한다는 것을 의미하며, 이는 상당한 성능 저하가 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ff46ea9bef3c6d32c8a1ad7bb317595dd80cf361" translate="yes" xml:space="preserve">
          <source>How do I use strict mode?</source>
          <target state="translated">엄격 모드는 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="cc9be850e0a7084a9595e60ae16f023125baaa52" translate="yes" xml:space="preserve">
          <source>I found a &lt;a href=&quot;http://yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/&quot;&gt;nice article&lt;/a&gt; describing several things that are prohibited in strict mode (note that this is not an exclusive list):</source>
          <target state="translated">엄격한 모드에서 금지 된 몇 가지 사항을 설명하는 &lt;a href=&quot;http://yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/&quot;&gt;멋진 기사&lt;/a&gt; 를 찾았습니다 (이 목록은 독점 목록이 아닙니다).</target>
        </trans-unit>
        <trans-unit id="dc8952723c45fe0a5695d3b38a7da82ec0f08130" translate="yes" xml:space="preserve">
          <source>I strongly recommend every developer to start using strict mode now. There are enough browsers supporting it that strict mode will legitimately help save us from errors we didn&amp;rsquo;t even know were in your code.</source>
          <target state="translated">모든 개발자가 지금 엄격 모드를 사용하는 것이 좋습니다. 엄격한 모드는 코드에서 알지 못했던 오류로부터 우리를 구하는 데 합법적으로 도움을 줄 수있는 충분한 브라우저가 있습니다.</target>
        </trans-unit>
        <trans-unit id="469b8c44f76024a66385d6b7d25b2e82c43551eb" translate="yes" xml:space="preserve">
          <source>I think even though it is a deadly caged animal, &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; can be good stuff, but you have to do it right.  The best time to go strict is when your project is greenfield and you are starting from scratch. Configure &lt;code&gt;JSHint/JSLint&lt;/code&gt; with all the warnings and options cranked up as tight as your team can stomach, get a good build/test/assert system du jour rigged like &lt;code&gt;Grunt+Karma+Chai&lt;/code&gt;, and only THEN start marking all your new modules as &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;.  Be prepared to cure lots of niggly errors and warnings.  Make sure everyone understands the gravity by configuring the build to FAIL if &lt;code&gt;JSHint/JSLint&lt;/code&gt; produces any violations.</source>
          <target state="translated">나는 그것이 갇힌 동물이지만 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 은 좋은 일이 될 수 있다고 생각하지만 제대로해야합니다. 엄격하게 가기 가장 좋은시기는 프로젝트가 그린 필드이고 처음부터 시작할 때입니다. &lt;code&gt;JSHint/JSLint&lt;/code&gt; 를 모든 경고 및 옵션을 사용하여 팀이 위장 할 수있을 정도로 단단히 구성하고 &lt;code&gt;Grunt+Karma+Chai&lt;/code&gt; 와 같은 좋은 빌드 / 테스트 / 어설 션 시스템을 확보 한 다음 새 모듈을 모두 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 많은 오류와 경고를 치료할 수 있도록 준비하십시오. &lt;code&gt;JSHint/JSLint&lt;/code&gt; 에서 위반이 발생하면 빌드를 FAIL로 구성하여 모든 사람이 중력을 이해하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="fe9be0949ff68bb7e46ceee0fc5d7b1234fe99fe" translate="yes" xml:space="preserve">
          <source>I would like to offer a somewhat more founded answer complementing the other answers. I was hoping to edit the most popular answer, but failed. I tried to make it as comprehensive and complete as I could.</source>
          <target state="translated">다른 답변을 보완하는 다소 더 설립 된 답변을 제공하고 싶습니다. 가장 인기있는 답변을 수정하고 싶었지만 실패했습니다. 나는 그것을 가능한 한 포괄적이고 완전하게 만들려고 노력했다.</target>
        </trans-unit>
        <trans-unit id="412701d63b5068562cc4090f3741aedcbe4b4488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; is used, the code should be written by following a strict set of rules, hence decreasing the chances of errors and ambiguities.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 규칙 집합을 따라 코드를 작성해야하므로 오류 및 모호성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="becf61a07fb9b6bce75ee86403b6a44cc4230a2d" translate="yes" xml:space="preserve">
          <source>If a developer used a library that was in strict mode, but the developer was used to working in normal mode, they might call some actions on the library that wouldn&amp;rsquo;t work as expected.</source>
          <target state="translated">개발자가 엄격 모드 인 라이브러리를 사용했지만 개발자가 일반 모드에서 작업하는 데 익숙한 경우 라이브러리에서 예상대로 작동하지 않는 일부 조치를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73b348a017ce42f08ddfcc1a55aa16726529e7db" translate="yes" xml:space="preserve">
          <source>If people are worried about using &lt;code&gt;use strict&lt;/code&gt; it might be worth checking out this article:</source>
          <target state="translated">사람들이 &lt;code&gt;use strict&lt;/code&gt; 에 대해 걱정한다면이 기사를 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fa6ab3ff8e0221431d8c26a934a3e66ae5341150" translate="yes" xml:space="preserve">
          <source>If you are going to take the plunge, it is a good idea to apply &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; alongside comprehensive unit tests and a strictly configured JSHint build task that will give you some confidence that there is no dark corner of your module that will blow up horribly just because you've turned on Strict Mode.  Or, hey, here's another option:  just don't add &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; to any of your legacy code, it's probably safer that way, honestly.  &lt;strong&gt;DEFINITELY DO NOT&lt;/strong&gt; add &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; to any modules you do not own or maintain, like third party modules.</source>
          <target state="translated">급락을하려는 경우, 포괄적 인 단위 테스트와 함께 엄격하게 사용하고 엄격하게 구성된 JSHint 빌드 태스크를 적용하여 모듈의 어두운 구석이 없다는 것을 확신하는 것이 좋습니다. 엄밀히 말해 엄격 모드를 설정했기 때문입니다. 또는, 또 다른 옵션이 있습니다. 기존 코드에 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 을 추가하지 마십시오. 정직하게 안전 할 것입니다. 타사 모듈과 같이 소유하거나 유지 관리하지 않는 모듈에는 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 을 추가 &lt;strong&gt;하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf2b000cc3982bb988fd19b404d2df442c39ee61" translate="yes" xml:space="preserve">
          <source>If you use a browser released in the last year or so then it most likely supports JavaScript Strict mode. Only older browsers around before ECMAScript 5 became the current standard don't support it.</source>
          <target state="translated">작년에 출시 된 브라우저를 사용하는 경우 JavaScript 엄격 모드를 지원할 가능성이 높습니다. ECMAScript 5가 현재 표준이되기 전에는 이전 버전의 브라우저 만 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a61d4fd4d403e4d13959975f3c5f54da73790ed8" translate="yes" xml:space="preserve">
          <source>Implied Global Variables</source>
          <target state="translated">내재 된 글로벌 변수</target>
        </trans-unit>
        <trans-unit id="d3431d0f279fa8fa3e8a6d6d9667d24dcf95f4a3" translate="yes" xml:space="preserve">
          <source>In C, an extremely unfortunate representation of octalness was
  selected: Leading zero. So in C, &lt;code&gt;0100&lt;/code&gt; means 64, not 100, and &lt;code&gt;08&lt;/code&gt; is an
  error, not 8. Even more unfortunately, this anachronism has been
  copied into nearly all modern languages, including JavaScript, where
  it is only used to create errors. It has no other purpose. So in
  strict mode, octal forms are no longer allowed.</source>
          <target state="translated">C에서는 매우 불행한 8 진 표현이 선택되었습니다 : 선행 0. 따라서 C에서 &lt;code&gt;0100&lt;/code&gt; 은 100이 아니라 64를 의미하고 &lt;code&gt;08&lt;/code&gt; 은 8 이 아닌 오류를 의미합니다. 불행히도이 구식은 JavaScript를 포함한 거의 모든 현대 언어로 복사되어 오류를 만드는 데만 사용됩니다. 다른 목적은 없습니다. 따라서 엄격 모드에서는 8 진 양식이 더 이상 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16b4064635890ddd67afa5ee74230310465108e6" translate="yes" xml:space="preserve">
          <source>In my &lt;em&gt;existing&lt;/em&gt; JavaScript code: &lt;strong&gt;Probably not!&lt;/strong&gt; If your existing JavaScript code has statements that are prohibited in strict-mode, the application will simply break. If you want strict mode, you should be prepared to debug and correct your existing code. This is why &lt;em&gt;using &lt;code&gt;'use strict';&lt;/code&gt; does not suddenly make your code better&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;기존&lt;/em&gt; JavaScript 코드에서 : &lt;strong&gt;아마도 아닙니다!&lt;/strong&gt; 기존 JavaScript 코드에 엄격 모드에서 금지 된 명령문이있는 경우 애플리케이션이 중단됩니다. 엄격 모드를 원하면 기존 코드를 디버그하고 수정할 준비가되어 있어야합니다. 이것이 &lt;em&gt; &lt;code&gt;'use strict';&lt;/code&gt; &lt;/em&gt; 이유입니다 &lt;em&gt;.&lt;/em&gt; &lt;em&gt;갑자기 코드가 더 나아지지는 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0c29f3552537c30fb2098c4a96f0030e9e96ee78" translate="yes" xml:space="preserve">
          <source>In my &lt;em&gt;new&lt;/em&gt; JavaScript application: &lt;strong&gt;Absolutely!&lt;/strong&gt; Strict mode can be used as a whistleblower when you are doing something stupid with your code.</source>
          <target state="translated">내 &lt;em&gt;새&lt;/em&gt; JavaScript 응용 프로그램에서 : &lt;strong&gt;절대적으로!&lt;/strong&gt; 엄격한 모드는 코드로 바보 같은 일을 할 때 내부 고발자로서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3634f14a41df1f551fd64c581da9a12e76201cd6" translate="yes" xml:space="preserve">
          <source>In normal JavaScript, a developer will not receive any error feedback
  assigning values to non-writable properties.</source>
          <target state="translated">일반적인 JavaScript에서 개발자는 쓰기 불가능한 속성에 값을 할당하는 오류 피드백을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1c4997af91ea1824f16708d431766bae6358c7a" translate="yes" xml:space="preserve">
          <source>In short will make your code less error prone and in turn will make you write good code.</source>
          <target state="translated">간단히 말해서 코드 오류가 덜 발생하게되고 좋은 코드를 작성하게됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a158933baae4e76b4d77171e82fba2ab4d99d9" translate="yes" xml:space="preserve">
          <source>In strict mode all variables have to be declared: if you assign a value to an identifier that has not been declared as variable, function, function parameter, catch-clause parameter or property of the global &lt;code&gt;Object&lt;/code&gt;, then you will get a &lt;code&gt;ReferenceError&lt;/code&gt;. In normal mode the identifier is implicitly declared as a global variable (as a property of the global &lt;code&gt;Object&lt;/code&gt;)</source>
          <target state="translated">엄격 모드에서는 모든 변수를 선언해야합니다. 변수, 함수, 함수 매개 변수, catch-clause 매개 변수 또는 전역 &lt;code&gt;Object&lt;/code&gt; 의 특성으로 선언되지 않은 식별자에 값을 지정하면 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생 합니다. 일반 모드에서 식별자는 전역 변수 (전역 &lt;code&gt;Object&lt;/code&gt; 의 속성)로 암시 적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="f9069656fdcbb8041857c4d722a72e7658151a0c" translate="yes" xml:space="preserve">
          <source>In strict mode are more restrictions on the possibilities to examine the call stack. &lt;code&gt;arguments.caller&lt;/code&gt; and &lt;code&gt;arguments.callee&lt;/code&gt; cause a &lt;code&gt;TypeError&lt;/code&gt; in a function in strict mode. Furthermore, some caller- and arguments properties of functions in strict mode cause a &lt;code&gt;TypeError&lt;/code&gt; when you try to read them.</source>
          <target state="translated">엄격 모드에서는 호출 스택을 검사 할 가능성에 대한 추가 제한 사항이 있습니다. &lt;code&gt;arguments.caller&lt;/code&gt; 및 &lt;code&gt;arguments.callee&lt;/code&gt; 는 엄격 모드의 함수에서 &lt;code&gt;TypeError&lt;/code&gt; 를 발생시킵니다. 또한 엄격한 모드에서 함수의 일부 호출자 및 인수 속성을 읽으려고하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b5c0423fd33ef61899aaaab9c15cc303390184f6" translate="yes" xml:space="preserve">
          <source>In strict mode it is considered a syntactical error when a function declaration has multiple parameters with the same name. (In normal mode there is no error.)</source>
          <target state="translated">엄격 모드에서는 함수 선언에 동일한 이름을 가진 여러 개의 매개 변수가있는 경우 구문 오류로 간주됩니다. (일반 모드에서는 오류가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="ad8a374a0ecffbb86ab61cd3fbd81734ca7e9123" translate="yes" xml:space="preserve">
          <source>In strict mode it is considered a syntactical error when you try to define several properties with the same name for an object literal. (In normal mode there is no error.)</source>
          <target state="translated">엄격 모드에서는 객체 리터럴에 대해 동일한 이름으로 여러 속성을 정의하려고 할 때 구문 오류로 간주됩니다. (일반 모드에서는 오류가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="6e88e83d9825a17cda0546c6144bf263c3be4fd7" translate="yes" xml:space="preserve">
          <source>In strict mode octal literals are not allowed (these are literals that start with &lt;code&gt;0x&lt;/code&gt;. (In normal mode some implementations do allow octal literals.)</source>
          <target state="translated">엄격 모드에서는 8 진 리터럴이 허용되지 않습니다 (이것은 &lt;code&gt;0x&lt;/code&gt; 로 시작하는 리터럴입니다. 일반 모드에서는 8 진 리터럴을 허용하는 구현이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ada7b6efb898cb90db8476a67881c7168d01d3c2" translate="yes" xml:space="preserve">
          <source>In strict mode the arguments-object of a function contains a static copy of the values, which are passed to that function. In normal mode the arguments-object has a somewhat &quot;magical&quot; behaviour: The elements of the array and the named function parameters reference both the same value.</source>
          <target state="translated">엄격 모드에서 함수의 arguments-object는 해당 함수에 전달되는 값의 정적 사본을 포함합니다. 일반 모드에서 arguments-object는 다소 &quot;마법적인&quot;동작을합니다. 배열의 요소와 명명 된 함수 매개 변수는 모두 동일한 값을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="7045fbdd229530fd0f1b40aa6038b589b411e771" translate="yes" xml:space="preserve">
          <source>In strict mode the identifiers &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; are treated like keywords. You cannot change their value, cannot assign a value to them, and you cannot use them as names for variables, functions, function parameters or identifiers of a catch block.</source>
          <target state="translated">엄격 모드에서는 식별자 &lt;code&gt;eval&lt;/code&gt; 및 &lt;code&gt;arguments&lt;/code&gt; 가 키워드처럼 취급됩니다. 값을 변경하거나 값을 지정할 수 없으며 변수, 함수, 함수 매개 변수 또는 catch 블록의 식별자 이름으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84f9e027f80dc82cfbcc02dc7ceec363aaaa0369" translate="yes" xml:space="preserve">
          <source>In strict mode the keyword &lt;code&gt;this&lt;/code&gt; has the value &lt;code&gt;undefined&lt;/code&gt; in functions that were invoked as functions (not as methods). (In normal mode &lt;code&gt;this&lt;/code&gt; always points to the global &lt;code&gt;Object&lt;/code&gt;). This difference can be used to test if an implementation supports the strict mode:</source>
          <target state="translated">엄격 모드에서 키워드는 메소드가 아닌 함수로 호출 된 함수에서 &lt;code&gt;undefined&lt;/code&gt; 값을 갖습니다. (정상 모드 &lt;code&gt;this&lt;/code&gt; 항상 전역 &lt;code&gt;Object&lt;/code&gt; 가리 킵니다). 이 차이는 구현이 엄격 모드를 지원하는지 테스트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="590bf1e232e9ab23ec1128befcc7fba6b47df466" translate="yes" xml:space="preserve">
          <source>In strict mode you will get a &lt;code&gt;SyntaxError&lt;/code&gt; when the &lt;code&gt;delete&lt;/code&gt; operator is followed by a non qualified identifier (a variable, function or function parameter). In normal mode the &lt;code&gt;delete&lt;/code&gt; expression would do nothing and is evaluated to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">엄격 모드에서는 &lt;code&gt;delete&lt;/code&gt; 연산자 뒤에 규정되지 않은 식별자 (변수, 함수 또는 함수 매개 변수)가 올 때 &lt;code&gt;SyntaxError&lt;/code&gt; 가 발생합니다. 일반 모드에서 &lt;code&gt;delete&lt;/code&gt; 표현식은 아무 작업도 수행하지 않으며 &lt;code&gt;false&lt;/code&gt; 로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="85d415079a470edeb131eb3614bacfeeedb08d6e" translate="yes" xml:space="preserve">
          <source>In strict mode you will get a &lt;code&gt;TypeError&lt;/code&gt; when you try to delete a non configurable property. (In normal mode the attempt simply fails and the &lt;code&gt;delete&lt;/code&gt; expression is evaluated to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">엄격 모드에서는 구성 할 수없는 속성을 삭제하려고하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다. 일반 모드에서는 시도가 실패하고 &lt;code&gt;delete&lt;/code&gt; 표현식이 &lt;code&gt;false&lt;/code&gt; 로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b36659c0c4c3212e959b1c3409c8e84af48a58ca" translate="yes" xml:space="preserve">
          <source>In strict mode you will get a &lt;code&gt;TypeError&lt;/code&gt;, when you try to assign to readonly properties or to define new properties for a non extensible object. (In normal mode both simply fail without error message.)</source>
          <target state="translated">엄격 모드에서는 읽기 전용 속성을 할당하거나 확장 할 수없는 객체에 대한 새 속성을 정의하려고하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다. (정상 모드에서는 단순히 오류 메시지없이 실패합니다.)</target>
        </trans-unit>
        <trans-unit id="779a188a15eeeb75cd33dabaef5f5607b5e7df04" translate="yes" xml:space="preserve">
          <source>In strict mode, any assignment to a non-writable property, a
  getter-only property, a non-existing property, a non-existing
  variable, or a non-existing object, will throw an error.</source>
          <target state="translated">엄격 모드에서는 쓸 수없는 속성, 게터 전용 속성, 존재하지 않는 속성, 존재하지 않는 변수 또는 존재하지 않는 개체에 할당하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="34660b8b97e8c589b1780bcb0a3ad7df23ae6ebe" translate="yes" xml:space="preserve">
          <source>In strict mode, duplicate keys in a function literal will produce a
  syntax error. A function can&amp;rsquo;t have two parameters with the same name.
  A function can&amp;rsquo;t have a variable with the same name as one of its
  parameters. A function can&amp;rsquo;t &lt;code&gt;delete&lt;/code&gt; its own variables. An attempt to
  &lt;code&gt;delete&lt;/code&gt; a non-configurable property now throws an exception. Primitive
  values are not implicitly wrapped.</source>
          <target state="translated">엄격 모드에서 함수 리터럴의 중복 키는 구문 오류를 생성합니다. 함수는 같은 이름을 가진 두 개의 매개 변수를 가질 수 없습니다. 함수는 매개 변수 중 하나와 이름이 같은 변수를 가질 수 없습니다. 함수는 자체 변수를 &lt;code&gt;delete&lt;/code&gt; 수 없습니다. 구성 할 수없는 속성을 &lt;code&gt;delete&lt;/code&gt; 하려고하면 예외가 발생합니다. 기본 값은 암시 적으로 랩핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1277d69296a283f503d1a6c94d74f75f1d3e36bd" translate="yes" xml:space="preserve">
          <source>In strict mode, when passing code to &lt;code&gt;eval()&lt;/code&gt;, you cannot declare or define variables or functions in the scope of the caller (as you can do it in normal mode). Instead, a new scope is created for &lt;code&gt;eval()&lt;/code&gt; and the variables and functions are within that scope. That scope is destroyed after &lt;code&gt;eval()&lt;/code&gt; finishes execution.</source>
          <target state="translated">엄격 모드에서는 코드를 &lt;code&gt;eval()&lt;/code&gt; 전달할 때 호출자의 범위에서 변수 또는 함수를 선언하거나 정의 할 수 없습니다 (정상 모드에서와 같이). 대신 &lt;code&gt;eval()&lt;/code&gt; 대한 새 범위가 작성되고 변수 및 함수가 해당 범위 내에 있습니다. 해당 범위는 &lt;code&gt;eval()&lt;/code&gt; 이 실행을 마친 후에 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="3b9445116c4c7387170dcadef8c31c50c662cba8" translate="yes" xml:space="preserve">
          <source>In their obsession to line up the numeric literals, the developer has inadvertently initialized variable &lt;code&gt;b&lt;/code&gt; with an octal literal. Non-strict mode will interpret this as a numeric literal with value &lt;code&gt;24&lt;/code&gt; (in base 10). However, strict mode will throw an error.</source>
          <target state="translated">숫자 리터럴을 정렬하는 데 강박 적으로 개발자는 실수로 변수 &lt;code&gt;b&lt;/code&gt; 를 8 진 리터럴로 초기화했습니다. 엄격하지 않은 모드는이 값을 &lt;code&gt;24&lt;/code&gt; (기본 10)의 숫자 리터럴로 해석합니다. 그러나 엄격 모드에서는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9831e3ee257b8570017d5e3cbd952bf7d9110f05" translate="yes" xml:space="preserve">
          <source>In this function, we are using a variable called &lt;code&gt;name&lt;/code&gt; inside the function. Internally, the compiler will first check if there is any variable declared with that particular name in that particular function scope. Since the compiler understood that there is no such variable, it will check in the outer scope. In our case, it is the global scope. Again, the compiler understood that there is also no variable declared in the global space with that name, so it creates such a variable for us in the global space. Conceptually, this variable will be created in the global scope and will be available in the entire application.</source>
          <target state="translated">이 함수에서는 함수 안에 &lt;code&gt;name&lt;/code&gt; 이라는 변수를 사용하고 있습니다. 내부적으로 컴파일러는 먼저 특정 함수 범위에 해당 특정 이름으로 선언 된 변수가 있는지 확인합니다. 컴파일러는 그러한 변수가 없다는 것을 이해했기 때문에 외부 범위를 검사합니다. 우리의 경우, 그것은 세계적인 범위입니다. 다시 말하지만 컴파일러는 해당 이름을 가진 전역 공간에 선언 된 변수도 없다는 것을 이해했기 때문에 전역 공간에서 이러한 변수를 만듭니다. 개념적으로이 변수는 전역 범위에서 만들어지며 전체 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29d176e51afc8cfe92995728f708273a3dba6e2b" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;use strict&lt;/code&gt; in the beginning of your all sensitive JavaScript files from this point is a small way to be a better JavaScript programmer and avoid random variables becoming global and things change silently.</source>
          <target state="translated">이 시점부터 모든 민감한 JavaScript 파일의 시작 부분에 &lt;code&gt;use strict&lt;/code&gt; 포함시키는 것은 더 나은 JavaScript 프로그래머가되고 무작위 변수가 전역으로 변하지 않고 사물이 바뀌는 것을 피할 수있는 작은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="025fb56c42e573032fb397fd3868bcc2c6bb5ce7" translate="yes" xml:space="preserve">
          <source>Insert a &lt;code&gt;'use strict';&lt;/code&gt; statement on top of your script:</source>
          <target state="translated">&lt;code&gt;'use strict';&lt;/code&gt; 삽입하십시오 . 스크립트 위에 진술 :</target>
        </trans-unit>
        <trans-unit id="9c8d780490a36100dba6e751d2b2cef05a32cfe4" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;native ECMAScript modules&lt;/a&gt; (with &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 classes&lt;/a&gt;, strict mode is always enabled and cannot be disabled.</source>
          <target state="translated">&lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;기본 ECMAScript 모듈&lt;/a&gt; ( &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 문 포함) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 클래스 내&lt;/a&gt; 에서 엄격 모드는 항상 활성화되어 있으며 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e171a04a4eeaf5a9849e77b87c64e070643b7ba" translate="yes" xml:space="preserve">
          <source>It catches some common coding bloopers, throwing exceptions.</source>
          <target state="translated">일반적인 코딩 블로커를 잡아 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="9dcb0c3ef0d34afe87dadacc330eb172ee25f066" translate="yes" xml:space="preserve">
          <source>It disables features that are confusing or poorly thought out.</source>
          <target state="translated">혼란 스럽거나 잘못 생각한 기능을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="49b8baaa6a095c3eb48ab5966d9e83454f6ec304" translate="yes" xml:space="preserve">
          <source>It is not a statement, but a literal expression, ignored by earlier
versions of JavaScript.</source>
          <target state="translated">이전 버전의 JavaScript에서는 무시 된 문이 아니라 리터럴 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f332558e8f07c24532551cb466729913fd5cd0e9" translate="yes" xml:space="preserve">
          <source>It prevents, or throws errors, when relatively &quot;unsafe&quot; actions are taken (such as gaining access to the global object).</source>
          <target state="translated">상대적으로 &quot;안전하지 않은&quot;조치가 수행 될 때 (예 : 글로벌 오브젝트에 대한 액세스 권한 확보) 오류를 방지하거나 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8cba967f49d817c496f0e2267da26d8c35639e1d" translate="yes" xml:space="preserve">
          <source>It talks about browser support, but more importantly how to deal with it safely:</source>
          <target state="translated">브라우저 지원에 대해 이야기하지만 더 중요하게는 안전하게 처리하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a7db968114d988709a73f4b2145447f7be94164f" translate="yes" xml:space="preserve">
          <source>It's a new feature of ECMAScript 5. John Resig wrote up &lt;a href=&quot;http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/&quot;&gt;a nice summary&lt;/a&gt; of it.</source>
          <target state="translated">ECMAScript 5의 새로운 기능입니다. John Resig는 이에 &lt;a href=&quot;http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/&quot;&gt;대한 훌륭한 요약&lt;/a&gt; 을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="e32f416964e370d5e5ee36f3cd35416da4dbe41b" translate="yes" xml:space="preserve">
          <source>It's just a string you put in your JavaScript files (either at the top of your file or inside of a function) that looks like this:</source>
          <target state="translated">JavaScript 파일 (파일 상단 또는 함수 내부)에 다음과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="817c8652ad34e116e5811fa2935033d7b0db3d3f" translate="yes" xml:space="preserve">
          <source>JavaScript &amp;ldquo;strict&amp;rdquo; mode was introduced in ECMAScript 5.</source>
          <target state="translated">ECMAScript 5에 JavaScript &quot;strict&quot;모드가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2b940df5bba00944ecb478eabe69d76ab720b74a" translate="yes" xml:space="preserve">
          <source>JavaScript has always had read-only properties, but you
  could not create them yourself until ES5&amp;rsquo;s &lt;code&gt;Object.createProperty&lt;/code&gt;
  function exposed that capability. If you attempted to assign a value
  to a read-only property, it would fail silently. The assignment would
  not change the property&amp;rsquo;s value, but your program would proceed as
  though it had. This is an integrity hazard that can cause programs to
  go into an inconsistent state. In strict mode, attempting to change a
  read-only property will throw an exception.</source>
          <target state="translated">JavaScript에는 항상 읽기 전용 속성이 있었지만 ES5의 &lt;code&gt;Object.createProperty&lt;/code&gt; 함수가 해당 기능을 노출 할 때까지 직접 만들 수 없었습니다. 읽기 전용 속성에 값을 할당하려고하면 자동으로 실패합니다. 할당은 속성 값을 변경하지 않지만 프로그램은 마치 그대로 진행됩니다. 이는 프로그램이 일관성이없는 상태가 될 수있는 무결성 위험입니다. 엄격 모드에서는 읽기 전용 속성을 변경하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ddb6e2a5aa8c17476d0875f1a887b8d5ae8365ff" translate="yes" xml:space="preserve">
          <source>JavaScript has implied global variables. If
  you do not explicitly declare a variable, a global variable is
  implicitly declared for you. This makes programming easier for
  beginners because they can neglect some of their basic housekeeping
  chores. But it makes the management of larger programs much more
  difficult and it significantly degrades reliability. So in strict
  mode, implied global variables are no longer created. You should
  explicitly declare all of your variables.</source>
          <target state="translated">JavaScript는 전역 변수를 암시했습니다. 변수를 명시 적으로 선언하지 않으면 전역 변수가 암시 적으로 선언됩니다. 이를 통해 초보자는 기본 하우스 키핑 작업을 무시할 수 있으므로 프로그래밍이 쉬워집니다. 그러나 큰 프로그램을 관리하기가 훨씬 어려워지고 안정성이 크게 저하됩니다. 따라서 엄격 모드에서는 내재 된 전역 변수가 더 이상 생성되지 않습니다. 모든 변수를 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2d7eb3c95183e015ef939a2a91a64f282eb81f9" translate="yes" xml:space="preserve">
          <source>List of features (non-exhaustive)</source>
          <target state="translated">기능 목록 (완전하지 않음)</target>
        </trans-unit>
        <trans-unit id="9c7b40e6928a432a1ec3f4bfbac791071ab83c89" translate="yes" xml:space="preserve">
          <source>Look at these statements and examples from MDN:</source>
          <target state="translated">MDN의 다음 진술과 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="5469b8b61ffe448f41a3cf81a23966ddb0f980b6" translate="yes" xml:space="preserve">
          <source>Module code is always strict mode code.</source>
          <target state="translated">모듈 코드는 항상 엄격 모드 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c5e07b85564bd88aae754a962908532c8c0e4b6d" translate="yes" xml:space="preserve">
          <source>My project was not a greenfield project when I adopted &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;.  As a result, my IDE is full of red marks because I don't have &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; on half my modules, and JSHint complains about that.  It's a reminder to me about what refactoring I should do in the future.  My goal is to be red mark free due to all of my missing &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; statements, but that is years away now.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 채택했을 때 프로젝트는 그린 필드 프로젝트가 아니 었습니다. 결과적으로 내 모듈의 절반에 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 이 없기 때문에 IDE에 빨간색 표시가 생겨 JSHint가 이에 대해 불평합니다. 앞으로 리팩토링을 어떻게해야하는지 알려줍니다. 나의 목표는 내가 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 하지 않은 &quot;엄격한 사용&quot; 진술로 인해 빨간색으로 표시되지 않는 것이지만 지금은 몇 년이 지났습니다.</target>
        </trans-unit>
        <trans-unit id="44085a42d6cb5c69ac3619d4793a1d1371ccfcfa" translate="yes" xml:space="preserve">
          <source>N.B: The &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directive is only recognized at the beginning of a script or a function.</source>
          <target state="translated">주의 : &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 지시문은 스크립트 나 함수의 시작 부분에서만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="ae74c50e67b3cccd367e03333a64b86a6bddcf67" translate="yes" xml:space="preserve">
          <source>No duplicates</source>
          <target state="translated">중복 없음</target>
        </trans-unit>
        <trans-unit id="10b58a0a8940ea2e58dbffa20044c150b681b579" translate="yes" xml:space="preserve">
          <source>Noisy Failure</source>
          <target state="translated">시끄러운 실패</target>
        </trans-unit>
        <trans-unit id="5de14d9134cba90071dacb30ddfcb3e147447382" translate="yes" xml:space="preserve">
          <source>Non-strict mode:</source>
          <target state="translated">엄격하지 않은 모드 :</target>
        </trans-unit>
        <trans-unit id="8d36800f9bf0d59a3c2d2c533771cdf6c89406de" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript does not follow strict rules, hence increasing chances of errors. After using &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;, the JavaScript code should follow strict set of rules as in other programming languages such as use of terminators, declaration before initialization, etc.</source>
          <target state="translated">일반적으로 JavaScript는 엄격한 규칙을 따르지 않으므로 오류 가능성이 높아집니다. &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 를 사용한 후 JavaScript 코드는 종료 기 사용, 초기화 전 선언 등과 같은 다른 프로그래밍 언어에서와 같이 엄격한 규칙을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="19034d503e754b80c9af82f89e91b77bf8089b78" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;use strict&lt;/code&gt; was introduced in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;EcmaScript 5&lt;/a&gt; and was kept since then.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;EcmaScript 5&lt;/a&gt; 에서 도입되었으며 그 이후로 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="f92b62c5cd55600499e3b2fcbabc790595cffe51" translate="yes" xml:space="preserve">
          <source>Note that everything in the file &lt;code&gt;myscript.js&lt;/code&gt; will be interpreted in strict mode.</source>
          <target state="translated">&lt;code&gt;myscript.js&lt;/code&gt; 파일의 모든 내용은 엄격 모드로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0498bcc5326f24110adbf8018626105327647e5c" translate="yes" xml:space="preserve">
          <source>Now let's write the same function in strict mode.</source>
          <target state="translated">이제 엄격 모드에서 동일한 함수를 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="7ca0bcad832ba95a89c297b2ceac7cc9fc126660" translate="yes" xml:space="preserve">
          <source>Now,this code creates &lt;code&gt;nameoftree&lt;/code&gt; in global scope which could be accessed using &lt;code&gt;window.nameoftree&lt;/code&gt;. When we implement &lt;code&gt;use strict&lt;/code&gt; the code would throw error.</source>
          <target state="translated">이제이 코드는 &lt;code&gt;window.nameoftree&lt;/code&gt; 를 사용하여 액세스 할 수있는 전역 범위에서 &lt;code&gt;nameoftree&lt;/code&gt; 를 만듭니다. &lt;code&gt;use strict&lt;/code&gt; 을 구현하면 코드에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="fc48827db54649898f715056ea3b1540dc1d9231" translate="yes" xml:space="preserve">
          <source>Octal syntax</source>
          <target state="translated">8 진법</target>
        </trans-unit>
        <trans-unit id="dc4532f060ff3aae00b84dcf89567e87053d969d" translate="yes" xml:space="preserve">
          <source>Of course it also talks about just what a lot of those misfeatures are (were) and how ECMAScript 5 fixes them.</source>
          <target state="translated">물론 이러한 많은 기능이 무엇인지와 ECMAScript 5가 어떻게이를 고치는 지에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="a9c8e2b60591d63bee27d639f4a20c27d766869f" translate="yes" xml:space="preserve">
          <source>One of the benefits of strict code is that tools like &lt;a href=&quot;http://developer.yahoo.com/yui/compressor/&quot;&gt;YUI Compressor&lt;/a&gt;
  can do a better job when processing it.</source>
          <target state="translated">엄격한 코드의 장점 중 하나는 &lt;a href=&quot;http://developer.yahoo.com/yui/compressor/&quot;&gt;YUI Compressor&lt;/a&gt; 와 같은 도구가 처리 할 때 더 나은 작업을 수행 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6441d22a368af55c21ee62c9b9e951bc296104eb" translate="yes" xml:space="preserve">
          <source>One of the goals of strict mode is to allow for faster debugging of issues. It helps the developers by throwing exception when certain wrong things occur that can cause silent &amp;amp; strange behaviour of your webpage. The moment we use &lt;code&gt;use strict&lt;/code&gt;, the code will throw out errors which helps developer to fix it in advance.</source>
          <target state="translated">엄격 모드의 목표 중 하나는 문제를 더 빨리 디버깅 할 수 있도록하는 것입니다. 그것은 당신의 웹 페이지의 조용하고 이상한 행동을 유발할 수있는 특정한 잘못된 것들이 발생했을 때 개발자들에게 예외를 던지도록 도와줍니다. 우리가 &lt;code&gt;use strict&lt;/code&gt; 사용 하는 순간, 코드는 오류를 발생시켜 개발자가 미리 수정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a0456e473032cec369aace45ac22933c75e5b022" translate="yes" xml:space="preserve">
          <source>Or, insert a &lt;code&gt;'use strict';&lt;/code&gt; statement on top of your function body:</source>
          <target state="translated">또는 &lt;code&gt;'use strict';&lt;/code&gt; 삽입하십시오 . 함수 본문에 대한 설명 :</target>
        </trans-unit>
        <trans-unit id="5bfc0f97dcb02767913e44123d36722a2485178e" translate="yes" xml:space="preserve">
          <source>People generally think that you shouldn&amp;rsquo;t use those things in the first place, but some developers don&amp;rsquo;t like the constraint and want to use all the features of the language.</source>
          <target state="translated">사람들은 일반적으로 처음부터 그런 것들을 사용해서는 안된다고 생각하지만 일부 개발자는 제약 조건을 좋아하지 않으며 언어의 모든 기능을 사용하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="f73ad56101ddb20a046ef96d3b285d9ee896e394" translate="yes" xml:space="preserve">
          <source>Please check the function below written in non-strict mode:</source>
          <target state="translated">엄격하지 않은 모드로 작성된 아래 기능을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ea0e96af85e42105da55a87738dffc05d9c4b8aa" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;http://www.w3schools.com/js/js_strict.asp&quot;&gt;http://www.w3schools.com/js/js_strict.asp&lt;/a&gt; to know more</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.w3schools.com/js/js_strict.asp&quot;&gt;http://www.w3schools.com/js/js_strict.asp&lt;/a&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="73834459f6254152ddd4773c32f68818b0dbafff" translate="yes" xml:space="preserve">
          <source>Prevents accidental declaration of global variables.Using &lt;code&gt;&quot;use strict()&quot;&lt;/code&gt; will make sure that variables are declared with &lt;code&gt;var&lt;/code&gt; before use. 
Eg:</source>
          <target state="translated">실수로 전역 변수를 선언하는 것을 방지합니다. &lt;code&gt;&quot;use strict()&quot;&lt;/code&gt; 를 사용하면 변수를 사용하기 전에 &lt;code&gt;var&lt;/code&gt; 로 선언해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d19ef64a263f6819272bad8f55d25e26eaca089d" translate="yes" xml:space="preserve">
          <source>Prevents accidental globals</source>
          <target state="translated">우발적 인 글로벌을 방지</target>
        </trans-unit>
        <trans-unit id="74d06b24393fc0bc828f7990084cc04f0d92db56" translate="yes" xml:space="preserve">
          <source>Problem at line 1 character 1: Missing &quot;use strict&quot; statement.</source>
          <target state="translated">1 행의 문제점 문자 1 : &quot;엄격한 사용&quot;명령문이 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="313048df06e5e26643dc1670c345e8164e9763eb" translate="yes" xml:space="preserve">
          <source>Putting it in your code now shouldn't cause any problems with current browsers as it's just a string. It may cause problems with your code in the future if your code violates the pragma.  For instance, if you currently have &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; without defining &lt;code&gt;foo&lt;/code&gt; first, your code will start failing...which is a good thing in my opinion.</source>
          <target state="translated">코드에 넣는 것은 문자열 일뿐이므로 현재 브라우저에서 문제를 일으키지 않아야합니다. 코드가 pragma를 위반하면 나중에 코드에 문제가 발생할 수 있습니다. 예를 들어, 현재 &lt;code&gt;foo&lt;/code&gt; 를 먼저 정의하지 않고 &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; 를 가지고 있다면 코드가 실패하기 시작합니다 ... 제 생각에는 좋은 것입니다.</target>
        </trans-unit>
        <trans-unit id="136f357105c51a569118fd5e9a4b2d1dc183c426" translate="yes" xml:space="preserve">
          <source>Recently, I ran some of my JavaScript code through Crockford's &lt;a href=&quot;http://www.jslint.com/&quot;&gt;JSLint&lt;/a&gt;, and it gave the following error:</source>
          <target state="translated">최근에 Crockford의 &lt;a href=&quot;http://www.jslint.com/&quot;&gt;JSLint를&lt;/a&gt; 통해 일부 JavaScript 코드를 실행했으며 다음 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="86a7a25b3cd35a1d2197e94d964ad1f2752ed5ee" translate="yes" xml:space="preserve">
          <source>Requires all property names in an object literal to be unique (&lt;code&gt;var x = {x1: &quot;1&quot;, x1: &quot;2&quot;}&lt;/code&gt;)</source>
          <target state="translated">객체 리터럴의 모든 속성 이름이 고유해야합니다 ( &lt;code&gt;var x = {x1: &quot;1&quot;, x1: &quot;2&quot;}&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b82277b8027feee64c843902b18fa2f0eaf9f6f9" translate="yes" xml:space="preserve">
          <source>Reserved words for future JavaScript versions</source>
          <target state="translated">향후 JavaScript 버전을위한 예약어</target>
        </trans-unit>
        <trans-unit id="00fe32fa055c05b65cba3aa264fdbb5e9ec51640" translate="yes" xml:space="preserve">
          <source>Safer eval()</source>
          <target state="translated">보다 안전한 평가 ()</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="c5ed7ad12df1fb5c64372abffb2e9c638c2000fd" translate="yes" xml:space="preserve">
          <source>Setting a value to an undeclared variable</source>
          <target state="translated">선언되지 않은 변수에 값 설정</target>
        </trans-unit>
        <trans-unit id="158a5623a22ae074fb939328027da4313300684f" translate="yes" xml:space="preserve">
          <source>Silent failing assignments will throw error in strict mode (assigning &lt;code&gt;NaN = 5;&lt;/code&gt;)</source>
          <target state="translated">자동 실패 할당은 엄격 모드 ( &lt;code&gt;NaN = 5;&lt;/code&gt; 할당)에서 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a249bbd654c1ea670a1ce21638e02e4758f365f8" translate="yes" xml:space="preserve">
          <source>Small examples to compare:</source>
          <target state="translated">비교할 작은 예 :</target>
        </trans-unit>
        <trans-unit id="4a4f135a79bb2ffe4e6528781a0caca54f5e9001" translate="yes" xml:space="preserve">
          <source>So what is &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; all about, what does it imply, and is it still relevant?</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 이란 무엇입니까 ? 모든 것이 무엇을 의미하며 여전히 관련이 있습니까?</target>
        </trans-unit>
        <trans-unit id="efdeaaeb5cef631181f2b0b6615ca443336cee21" translate="yes" xml:space="preserve">
          <source>So, I suppose it's a bit like the &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; you can use in Perl &lt;em&gt;(hence the name?)&lt;/em&gt;: it helps you make fewer errors, by detecting more things that could lead to breakages.</source>
          <target state="translated">그래서 나는 그것이 당신이 Perl에서 사용할 수있는 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 과 비슷하다고 생각합니다 &lt;em&gt;(따라서 이름은?)&lt;/em&gt; : 그것은 더 많은 것들을 감지하여 파손을 일으킬 수있는 오류를 줄이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="56888f9c90a484f01fdab9bff41f2251fdd72944" translate="yes" xml:space="preserve">
          <source>Strict Mode - JavaScript | MDN</source>
          <target state="translated">엄격한 모드-JavaScript | MDN</target>
        </trans-unit>
        <trans-unit id="4c97b7a3fcb78ad7a4d70823a936a41e3b32a18f" translate="yes" xml:space="preserve">
          <source>Strict Mode is a new feature in ECMAScript 5 that allows you to place a program, or a function, in a &quot;strict&quot; operating context. This strict context prevents certain actions from being taken and throws more exceptions.</source>
          <target state="translated">엄격 모드는 ECMAScript 5의 새로운 기능으로 &quot;엄격한&quot;운영 컨텍스트에 프로그램 또는 기능을 배치 할 수 있습니다. 이 엄격한 컨텍스트는 특정 조치가 수행되지 않도록하고 더 많은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0925c525a403588f0be5f281195e7ab1228e41ce" translate="yes" xml:space="preserve">
          <source>Strict mode changes previously accepted &quot;bad syntax&quot; into real errors.</source>
          <target state="translated">엄격한 모드는 이전에 허용 된 &quot;잘못된 구문&quot;을 실제 오류로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="dfa23d0a0c1ade7fa039058260fbdf2a088763e0" translate="yes" xml:space="preserve">
          <source>Strict mode does not alias properties of the &lt;code&gt;arguments&lt;/code&gt; object with the formal parameters. (i.e. in &lt;code&gt;function sum (a,b) { return arguments[0] + b;}&lt;/code&gt; This works because &lt;code&gt;arguments[0]&lt;/code&gt; is bound to &lt;code&gt;a&lt;/code&gt; and so on. )</source>
          <target state="translated">엄격 모드는 형식 매개 변수를 사용하여 &lt;code&gt;arguments&lt;/code&gt; 오브젝트의 특성에 별명을 지정하지 않습니다. (즉, &lt;code&gt;function sum (a,b) { return arguments[0] + b;}&lt;/code&gt; &lt;code&gt;arguments[0]&lt;/code&gt; 이 &lt;code&gt;a&lt;/code&gt; 등에 바인딩되어 있기 때문에 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="1e7b5b22d16bdb8a5476e2e6c1fdc04bffef1ee0" translate="yes" xml:space="preserve">
          <source>Strict mode for functions: Likewise, to invoke strict mode for a
  function, put the exact statement &quot;use strict&quot;; (or 'use strict';) in
  the function's body before any other statements.</source>
          <target state="translated">함수의 엄격한 모드 : 마찬가지로 함수의 엄격한 모드를 호출하려면 &quot;엄격한 사용&quot;이라는 정확한 문장을 입력하십시오. (또는 'use strict';)는 다른 문장보다 먼저 함수 본문에 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba1aed4e7b22cf2830dc704dbcbc7728a024ed8" translate="yes" xml:space="preserve">
          <source>Strict mode helps out in a couple ways:</source>
          <target state="translated">엄격한 모드는 몇 가지 방법으로 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a1071c6d144e305f80fc9cb060b9efe833597dc7" translate="yes" xml:space="preserve">
          <source>Strict mode is now &lt;a href=&quot;http://caniuse.com/#use-strict&quot;&gt;supported by all major browsers&lt;/a&gt;.</source>
          <target state="translated">엄격한 모드는 이제 &lt;a href=&quot;http://caniuse.com/#use-strict&quot;&gt;모든 주요 브라우저에서 지원됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fecd3bae551b0fe9196f1a9e57dd72fde9f330a3" translate="yes" xml:space="preserve">
          <source>Strict mode makes it easier to write &quot;secure&quot; JavaScript.</source>
          <target state="translated">엄격한 모드를 사용하면 &quot;보안&quot;JavaScript를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd44cb0172afba4c6ad8d00101e96f6c2f1ced4" translate="yes" xml:space="preserve">
          <source>Strict mode makes several changes to normal JavaScript semantics:</source>
          <target state="translated">엄격 모드는 일반적인 JavaScript 의미를 몇 가지 변경합니다.</target>
        </trans-unit>
        <trans-unit id="42aae285b68e8a7fe6a0256e8acb1b55fb12a44f" translate="yes" xml:space="preserve">
          <source>Strict mode requires that all variable binding be done statically.
  That means that the features that previously required dynamic binding
  must be eliminated or modified. Specifically, the with statement is
  eliminated, and the eval function&amp;rsquo;s ability to tamper with the
  environment of its caller is severely restricted.</source>
          <target state="translated">엄격 모드에서는 모든 변수 바인딩을 정적으로 수행해야합니다. 즉, 이전에 동적 바인딩이 필요한 기능을 제거하거나 수정해야합니다. 특히 with 문이 제거되고 호출자의 환경을 변경하는 eval 함수의 기능이 심각하게 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="981037f259f5ec994dd978355da84261730db94d" translate="yes" xml:space="preserve">
          <source>Strict mode:</source>
          <target state="translated">엄격한 모드 :</target>
        </trans-unit>
        <trans-unit id="73600aa2e4bc7bac1a44ca2049803b7ae131c09a" translate="yes" xml:space="preserve">
          <source>The &quot;use strict&quot; directive is new in
  JavaScript 1.8.5 (ECMAScript version 5). It is not a statement, but a
  literal expression, ignored by earlier versions of JavaScript. The
  purpose of &quot;use strict&quot; is to indicate that the code should be
  executed in &quot;strict mode&quot;. With strict mode, you can not, for example,
  use undeclared variables.</source>
          <target state="translated">&quot;엄격한 사용&quot;지시문은 JavaScript 1.8.5 (ECMAScript 버전 5)의 새로운 기능입니다. 이전 버전의 JavaScript에서는 무시 된 문이 아니라 리터럴 표현식입니다. &quot;엄격한 사용&quot;의 목적은 코드가 &quot;엄격 모드&quot;에서 실행되어야 함을 나타냅니다. 엄격 모드를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da414cbc8191e02ce23dc8839e8f655afd89e64c" translate="yes" xml:space="preserve">
          <source>The &quot;use strict&quot; directive is new in JavaScript 1.8.5 (ECMAScript
  version 5).</source>
          <target state="translated">&quot;엄격한 사용&quot;지시문은 JavaScript 1.8.5 (ECMAScript 버전 5)의 새로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="871bf0916612bf268e233d62d36329c75cb6843d" translate="yes" xml:space="preserve">
          <source>The &quot;use strict&quot; directive was new in ECMAScript version 5.</source>
          <target state="translated">&quot;엄격한 사용&quot;지시문은 ECMAScript 버전 5에서 새로 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc3dd2b1ab543df882ca1a48ca20880937f9ee29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;JavaScript strict mode&lt;/a&gt; is a feature in &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;ECMAScript 5&lt;/a&gt;. You can enable the strict mode by declaring this in the top of your script/function.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;JavaScript 엄격 모드&lt;/a&gt; 는 &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;ECMAScript 5&lt;/a&gt; 의 기능입니다. 스크립트 / 함수 맨 위에 이것을 선언하여 엄격 모드를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ab9d9f8d23f7bf773bc9224e29ab32c41301a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use strict&lt;/code&gt; directive indicates that the following code (in a script or a function) is strict code.
The code in the highest level of a script (code that is not in a function) is considered strict code when the script contains a &lt;code&gt;use strict&lt;/code&gt; directive.
The content of a function is considered strict code when the function itself is defined in a strict code or when the function contains a &lt;code&gt;use strict&lt;/code&gt; directive.
Code that is passed to an &lt;code&gt;eval()&lt;/code&gt; method is considered strict code when &lt;code&gt;eval()&lt;/code&gt; was called from a strict code or contains the &lt;code&gt;use strict&lt;/code&gt; directive itself.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 지시문은 다음 코드 (스크립트 또는 함수)가 엄격한 코드임을 나타냅니다. 스크립트에 &lt;code&gt;use strict&lt;/code&gt; 지시문이 포함 된 경우 최상위 레벨의 스크립트 (함수에없는 코드)의 코드는 엄격한 코드로 간주됩니다. 함수 자체가 엄격한 코드로 정의되거나 함수에 &lt;code&gt;use strict&lt;/code&gt; 지시문이 포함 된 경우 함수의 내용은 엄격한 코드로 간주됩니다. &lt;code&gt;eval()&lt;/code&gt; 메소드에 전달 된 코드는 엄격한 코드에서 &lt;code&gt;eval()&lt;/code&gt; 을 호출했거나 &lt;code&gt;use strict&lt;/code&gt; 지시문 자체를 포함하는 경우 엄격한 코드로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e02035bfd1451179fb6fa7438f433460a260f654" translate="yes" xml:space="preserve">
          <source>The arguments pseudo array becomes a little bit more
  array-like in ES5. In strict mode, it loses its &lt;code&gt;callee&lt;/code&gt; and &lt;code&gt;caller&lt;/code&gt;
  properties. This makes it possible to pass your &lt;code&gt;arguments&lt;/code&gt; to untrusted
  code without giving up a lot of confidential context. Also, the
  &lt;code&gt;arguments&lt;/code&gt; property of functions is eliminated.</source>
          <target state="translated">인수 의사 배열은 ES5에서 조금 더 배열과 비슷해집니다. 엄격 모드에서는 &lt;code&gt;callee&lt;/code&gt; 및 &lt;code&gt;caller&lt;/code&gt; 속성이 손실됩니다. 이를 통해 많은 기밀 컨텍스트를 포기하지 않고 신뢰할 수없는 코드에 &lt;code&gt;arguments&lt;/code&gt; 를 전달할 수 있습니다. 또한 함수의 &lt;code&gt;arguments&lt;/code&gt; 속성이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a01550b956584e50c573534903412b194d39ea38" translate="yes" xml:space="preserve">
          <source>The main reasons why developers should use &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; are:</source>
          <target state="translated">개발자가 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 사용 &quot;을 사용해야 하는 주요 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e11cb88feedf1f50b774d7918351ac724492485e" translate="yes" xml:space="preserve">
          <source>The octal (or base 8) representation of numbers was extremely
  useful when doing machine-level programming on machines whose word
  sizes were a multiple of 3. You needed octal when working with the CDC
  6600 mainframe, which had a word size of 60 bits. If you could read
  octal, you could look at a word as 20 digits. Two digits represented
  the op code, and one digit identified one of 8 registers. During the
  slow transition from machine codes to high level languages, it was
  thought to be useful to provide octal forms in programming languages.</source>
          <target state="translated">숫자의 8 진법 (또는 8 진법)은 단어 크기가 3의 배수 인 기계에서 기계 수준 프로그래밍을 수행 할 때 매우 유용했습니다. 단어 크기가 60 비트 인 CDC 6600 메인 프레임으로 작업 할 때는 8 진법이 필요했습니다. 8 진수를 읽을 수 있다면 단어를 20 자리로 볼 수 있습니다. 2 자리 숫자는 op 코드를 나타내고 1 자리 숫자는 8 개의 레지스터 중 하나를 나타냅니다. 기계어 코드에서 고급 언어로 느리게 전환하는 동안 프로그래밍 언어로 8 진 형식을 제공하는 것이 유용한 것으로 생각되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b9d97e5a3c8f84f9eca85dd8d59d37bf769eaf4" translate="yes" xml:space="preserve">
          <source>The purpose of &quot;use strict&quot; is to indicate that the code should be
executed in &quot;strict mode&quot;.</source>
          <target state="translated">&quot;엄격한 사용&quot;의 목적은 코드가 &quot;엄격 모드&quot;에서 실행되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50e416e7691b94ac73a19329e3d0d84aa7766f77" translate="yes" xml:space="preserve">
          <source>The quotes around the command make sure that the code will still work in older browsers as well (although the things that generate a syntax error in strict mode will generally just cause the script to malfunction in some hard to detect way in those older browsers).</source>
          <target state="translated">명령 주위의 따옴표는 코드가 이전 브라우저에서도 계속 작동하는지 확인합니다 (엄격한 모드에서 구문 오류를 생성하는 것은 일반적으로 스크립트가 이전 브라우저에서 감지하기 어려운 방식으로 오작동을 일으킬 수 있음).</target>
        </trans-unit>
        <trans-unit id="fef18bab467b7c8273c3132a626d92c3771e553a" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; instructs the browser to use the Strict mode, which is a reduced and safer feature set of JavaScript.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 진술 ; 브라우저가 엄격하고 안전한 JavaScript 기능 세트 인 엄격한 모드를 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="092a4db52edff1b55719897e8c31aebfe3163802" translate="yes" xml:space="preserve">
          <source>The strict mode of ECMAScript 5 is a restricted subset of the JavaScript language, which eliminates relevant deficits of the language and features more stringent error checking and higher security. The following lists the differences between strict mode and normal mode (of which the first three are particularly important):</source>
          <target state="translated">ECMAScript 5의 엄격한 모드는 JavaScript 언어의 제한된 하위 집합으로, 언어의 관련 결함을 제거하고보다 엄격한 오류 검사 및 높은 보안 기능을 제공합니다. 다음은 엄격 모드와 일반 모드의 차이점을 나열합니다 (처음 세 가지가 특히 중요 함).</target>
        </trans-unit>
        <trans-unit id="35a411c4b982908019ab5ca4beff69a7f8222678" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;arguments&quot;&lt;/code&gt; cannot be used as a variable:</source>
          <target state="translated">문자열 &lt;code&gt;&quot;arguments&quot;&lt;/code&gt; 는 변수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ceeec8e70875ba0392801d9dae48808cf2b43044" translate="yes" xml:space="preserve">
          <source>There are a number of situations that could cause &lt;code&gt;this&lt;/code&gt;
  to be bound to the global object. For example, if you forget to
  provide the &lt;code&gt;new&lt;/code&gt; prefix when calling a constructor function, the
  constructor's &lt;code&gt;this&lt;/code&gt; will be bound unexpectedly to the global object, so
  instead of initializing a new object, it will instead be silently
  tampering with global variables. In these situations, strict mode will
  instead bind &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt;, which will cause the constructor to
  throw an exception instead, allowing the error to be detected much
  sooner.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 전역 객체에 바인딩시킬 수있는 상황이 많이 있습니다. 예를 들어, 생성자 함수를 호출 할 때 &lt;code&gt;new&lt;/code&gt; 접두사를 제공하는 것을 잊어 버린 경우 생성자의 전역 객체에 예기치 않게 바인딩되므로 새 객체를 초기화하는 대신 전역 변수를 자동으로 변경합니다. 이러한 상황에서 엄격 모드는 &lt;code&gt;this&lt;/code&gt; 를 대신 &lt;code&gt;undefined&lt;/code&gt; 에 바인딩하여 생성자가 대신 예외를 발생시켜 오류를 훨씬 빨리 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b08b8743bda54c101d135ee7a32c07df9257bf6" translate="yes" xml:space="preserve">
          <source>There are few more but I need to gain more knowledge on that.</source>
          <target state="translated">더는 없지만 더 많은 지식을 얻을 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="048399442f3a5673fb36ae4b92a85ca20458e560" translate="yes" xml:space="preserve">
          <source>There's a good talk by some people who were on the ECMAScript committee: &lt;a href=&quot;http://www.youtube.com/watch?v=Kq4FpMe6cRs&quot;&gt;Changes to JavaScript, Part 1: ECMAScript 5&quot;&lt;/a&gt; about how incremental use of the &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; switch allows JavaScript implementers to clean up a lot of the dangerous features of JavaScript without suddenly breaking every website in the world.</source>
          <target state="translated">ECMAScript위원회에 참여한 일부 사람들은 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 스위치를 점진적으로 사용하여 JavaScript 구현자가 JavaScript의 많은 위험한 기능을 정리할 수있게하는 방법에 대한 &lt;a href=&quot;http://www.youtube.com/watch?v=Kq4FpMe6cRs&quot;&gt;JavaScript 변경 사항, 제 1 부 : ECMAScript 5 &quot;&lt;/a&gt; 세상의 모든 웹 사이트를 갑자기 깨뜨 렸습니다.</target>
        </trans-unit>
        <trans-unit id="3e37513efc84c83ee98db8c100f7f728f1063cb3" translate="yes" xml:space="preserve">
          <source>This article about Javascript Strict Mode might interest you: &lt;a href=&quot;http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/&quot;&gt;John Resig - ECMAScript 5 Strict Mode, JSON, and More&lt;/a&gt;</source>
          <target state="translated">Javascript Strict Mode에 대한이 기사는 다음과 같습니다. &lt;a href=&quot;http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/&quot;&gt;John Resig-ECMAScript 5 Strict Mode, JSON 등&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d9da1eab3a2754c07bf853818048cf86ef9a8bc1" translate="yes" xml:space="preserve">
          <source>This is no longer the case in ECMAScript 6 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1041128&quot;&gt;bug 1041128&lt;/a&gt;).</source>
          <target state="translated">ECMAScript 6에서는 더 이상 해당되지 않습니다 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1041128&quot;&gt;버그 1041128&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd413d88ab98b532770fd5f2fc9d3f7ef62c23ce" translate="yes" xml:space="preserve">
          <source>Those that prefer not to use rulers to do their lines straight usually end up in those pages asking for others to debug their code.</source>
          <target state="translated">눈금자를 사용하여 직선을 직접 사용하지 않으려는 사람들은 대개 다른 사람들이 코드를 디버깅하도록 요청하는 해당 페이지에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="a7fd2f79041e08e0c8925669b484de4ed27bacfa" translate="yes" xml:space="preserve">
          <source>To quote some interesting parts:</source>
          <target state="translated">흥미로운 부분을 인용하려면 :</target>
        </trans-unit>
        <trans-unit id="18959bdb468277df6861dc45265096e4e03b934c" translate="yes" xml:space="preserve">
          <source>To read more about it you can refer &lt;a href=&quot;http://www.w3schools.com/js/js_strict.asp&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;http://www.w3schools.com/js/js_strict.asp&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="42a3bb278c71efefd64c79603bbd7e4b085a3e13" translate="yes" xml:space="preserve">
          <source>Transitioning to strict mode</source>
          <target state="translated">엄격 모드로 전환</target>
        </trans-unit>
        <trans-unit id="a036c9d3bcde8686731beb5eb26de106ef7784ed" translate="yes" xml:space="preserve">
          <source>Uncaught ReferenceError: nameoftree is not defined</source>
          <target state="translated">잡히지 않은 ReferenceError : nameoftree가 정의되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="4c156a916f8a6f9574955750b2a1451326982d3f" translate="yes" xml:space="preserve">
          <source>Uncaught SyntaxError: Duplicate data property in object literal not
  allowed in strict mode</source>
          <target state="translated">Uncaught SyntaxError : 엄격 모드에서는 객체 리터럴의 중복 데이터 속성이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="7aaa011136ee898447ada0c1377720eb7677dcbb" translate="yes" xml:space="preserve">
          <source>Use Strict is used to show common and repeated errors so that it is handled differently , and changes the way java script runs , such changes are :</source>
          <target state="translated">Use Strict는 일반적으로 반복되는 오류를 표시하여 다르게 처리되고 Java 스크립트 실행 방식을 변경하는 데 사용됩니다. 이러한 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6a2b8c9600130299cd64c46f5748d992d100d46" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;'use strict';&lt;/code&gt; does not suddenly make your code better.</source>
          <target state="translated">&lt;code&gt;'use strict';&lt;/code&gt; 사용 '사용; 갑자기 코드가 나아지지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d6e1571c87c5715f5b1379bfd5792f9c941414" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;delete&lt;/code&gt; on a variable name &lt;code&gt;delete myVariable;&lt;/code&gt;</source>
          <target state="translated">변수 이름에 &lt;code&gt;delete myVariable;&lt;/code&gt; 사용하면 &lt;code&gt;delete&lt;/code&gt; myVariable;</target>
        </trans-unit>
        <trans-unit id="21daefad12ef11f96031aa365048e01337e377ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt; as variable or function argument name</source>
          <target state="translated">변수 또는 함수 인수 이름으로 &lt;code&gt;eval&lt;/code&gt; 또는 &lt;code&gt;arguments&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="e4d9563de300edd23fd7c3850db04036a25d79ee" translate="yes" xml:space="preserve">
          <source>We will get the following error.</source>
          <target state="translated">다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4dbef12467da7f5817c1305f1e396998d11eafa3" translate="yes" xml:space="preserve">
          <source>What does “use strict” do in JavaScript, and what is the reasoning behind it</source>
          <target state="translated">JavaScript에서 &quot;엄격한 사용&quot;은 무엇이며 그 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4c18ac01741b6780a43048c77a24b5e2c0540bae" translate="yes" xml:space="preserve">
          <source>What things are prohibited in strict mode?</source>
          <target state="translated">엄격 모드에서 금지 된 사항은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a48ab950c2dd3afad682dd72baa410b63bc6e0a1" translate="yes" xml:space="preserve">
          <source>When a JavaScript engine sees this &lt;em&gt;directive&lt;/em&gt;, it will start to interpret the code in a special mode. In this mode, errors are thrown up when certain coding practices that could end up being potential bugs are detected (which is the reasoning behind the strict mode).</source>
          <target state="translated">JavaScript 엔진이이 &lt;em&gt;지시문을&lt;/em&gt; 보면 특수 모드에서 코드를 해석하기 시작합니다. 이 모드에서는 잠재적 인 버그가 될 수있는 특정 코딩 방법이 감지 될 때 오류가 발생합니다 (엄격한 모드의 원인).</target>
        </trans-unit>
        <trans-unit id="c300272a821d8e78995c84df72b42286f65185e1" translate="yes" xml:space="preserve">
          <source>When adding &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt;, the following cases will throw a &lt;strong&gt;SyntaxError&lt;/strong&gt; before the script is executing:</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 추가 할 때 ; 스크립트가 실행되기 전에 다음과 같은 경우 &lt;strong&gt;SyntaxError가&lt;/strong&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1027ddb2af687a000e1f43ee83be4b6c15b8e572" translate="yes" xml:space="preserve">
          <source>When we have duplicate property, it throws an exception</source>
          <target state="translated">중복 속성이 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9786db102e0c8271479dae448d90367999358652" translate="yes" xml:space="preserve">
          <source>Where should I use &lt;code&gt;'use strict';&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;'use strict';&lt;/code&gt; 사용 '을 어디에서 사용해야합니까 ? ?</target>
        </trans-unit>
        <trans-unit id="f5501718d21e44942c25ce38f65fbb4d2ea2d9e5" translate="yes" xml:space="preserve">
          <source>Which might be helpful if you have to mix old and new code ;-)</source>
          <target state="translated">이전 코드와 새 코드를 혼합 해야하는 경우 도움이 될 수 있습니다 ;-)</target>
        </trans-unit>
        <trans-unit id="184e2f1b60c365bdbd0ab8e43df510d15bccc6c0" translate="yes" xml:space="preserve">
          <source>Why Strict Mode?</source>
          <target state="translated">왜 엄격한 모드입니까?</target>
        </trans-unit>
        <trans-unit id="2e23b3df3a20138c20d2c8e491ee2570ddf50bfb" translate="yes" xml:space="preserve">
          <source>Will restrict uses of keywords as variables. Trying to use them will throw errors.</source>
          <target state="translated">키워드 사용을 변수로 제한합니다. 그것들을 사용하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a71ea5c1e3ada42c1b0d204b7398947c063f4a74" translate="yes" xml:space="preserve">
          <source>With strict mode, you can not, for example, use undeclared variables.</source>
          <target state="translated">엄격 모드를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="161190f164917a24616c94f2e53483ba35c86211" translate="yes" xml:space="preserve">
          <source>Worse, since the developer is in normal mode, they don&amp;rsquo;t have the advantages of extra errors being thrown, so the error might fail silently.</source>
          <target state="translated">더 나쁜 것은 개발자가 일반 모드이기 때문에 추가 오류가 발생한다는 이점이 없으므로 오류가 자동으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20bd93de5e3a15e93016dccea88cc98f2d1f95ed" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; at the very top of your JS file turns on strict
syntax checking. It does the following tasks for us:</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 작성 ; JS 파일 맨 위에는 엄격한 구문 검사가 사용됩니다. 우리를 위해 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="290c3178ac3f676c45b24cb8690955d39c8b4d14" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;read more on MDN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN에 대한 자세한 내용을 읽을&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7487ef619ee058617d220fbdcb1ff71b70d7e8" translate="yes" xml:space="preserve">
          <source>You can refer to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN documentation&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b84b03d930a95b32ff7fff301afe23652a22474" translate="yes" xml:space="preserve">
          <source>You cannot use the &lt;code&gt;with&lt;/code&gt;-statement in strict mode.</source>
          <target state="translated">엄격 모드에서는 &lt;code&gt;with&lt;/code&gt; -statement를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd707966b9d71560d8d3c73a2fd4a8e76a284eb2" translate="yes" xml:space="preserve">
          <source>[Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;Strict mode&lt;/a&gt;, &lt;em&gt;Mozilla Developer Network&lt;/em&gt;]</source>
          <target state="translated">[참고 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;엄격 모드&lt;/a&gt; , &lt;em&gt;Mozilla 개발자 네트워크&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="5640892492b3a140a15198eb7f173e54896999fc" translate="yes" xml:space="preserve">
          <source>eliminates some JavaScript silent errors by changing them
to throw errors.</source>
          <target state="translated">오류를 발생 시키도록 일부 JavaScript 자동 오류를 변경하여 제거합니다.</target>
        </trans-unit>
        <trans-unit id="16de3f2d338913f29c8f9f128d32ba48cbb95641" translate="yes" xml:space="preserve">
          <source>fixes mistakes that make it difficult for JavaScript
engines to perform optimizations.</source>
          <target state="translated">JavaScript 엔진이 최적화를 수행하기 어려운 오류를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0364811af40b95fa72a60403bfe331e1a6c30201" translate="yes" xml:space="preserve">
          <source>for more information vistit &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode&quot;&gt;Strict Mode- Javascript&lt;/a&gt;</source>
          <target state="translated">자세한 정보를 보려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode&quot;&gt;엄격한 모드&lt;/a&gt; -Javascript</target>
        </trans-unit>
        <trans-unit id="db0b8b9b231300c663125ba290de7d8ad030cebe" translate="yes" xml:space="preserve">
          <source>forbids some unsafe or error-prone language features</source>
          <target state="translated">안전하지 않거나 오류가 발생하기 쉬운 언어 기능을 금지합니다</target>
        </trans-unit>
        <trans-unit id="01f927911ed04f070c42384b5acdb1eaa080798c" translate="yes" xml:space="preserve">
          <source>prohibits some syntax likely to be defined in future
versions of ECMAScript.</source>
          <target state="translated">향후 버전의 ECMAScript에서 정의 될 수있는 일부 구문을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="fee36c7820652167ca4505a5dcd195808ce9cfe0" translate="yes" xml:space="preserve">
          <source>shows an error if you try to assign to an undeclared variable</source>
          <target state="translated">선언되지 않은 변수에 할당하려고하면 오류가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="65b524cf6d7ace1ef4955efb2c2c0f3cea4f4878" translate="yes" xml:space="preserve">
          <source>stops you from overwriting key JS system libraries</source>
          <target state="translated">주요 JS 시스템 라이브러리를 덮어 쓰지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="118ad7cd18fd1f4ce16961837b121bd93511a087" translate="yes" xml:space="preserve">
          <source>you can also read this &lt;a href=&quot;https://www.nczonline.net/blog/2012/03/13/its-time-to-start-using-javascript-strict-mode/&quot;&gt;article&lt;/a&gt; for the details</source>
          <target state="translated">자세한 내용은이 &lt;a href=&quot;https://www.nczonline.net/blog/2012/03/13/its-time-to-start-using-javascript-strict-mode/&quot;&gt;기사&lt;/a&gt; 를 읽을 수도 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
