<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1394797">
    <body>
      <group id="1394797">
        <trans-unit id="ba486396875db8ae9ec14bf5a1239c6e235f52be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;!&lt;/strong&gt;   If the repo has more than one stash, see which one to apply to the new-branch:</source>
          <target state="translated">&lt;strong&gt;!&lt;/strong&gt; 저장소에 둘 이상의 숨김이있는 경우 새 분기에 적용 할 저장소를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2bf695ac2647c1533249c9022a8f96def0a7b1b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; There is also a danger if you rebase after branching, which is &lt;a href=&quot;https://stackoverflow.com/a/36463546/99777&quot;&gt;described here&lt;/a&gt;.  The only way to avoid that is to create a new history using cherry-pick.  That link describes &lt;strong&gt;the safest fool-proof method&lt;/strong&gt;.  If you have uncommitted changes, you may want to &lt;code&gt;git stash&lt;/code&gt; at the start and &lt;code&gt;git stash pop&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;경고 :&lt;/em&gt;&lt;/strong&gt; 분기 후 리베이스하면 &lt;a href=&quot;https://stackoverflow.com/a/36463546/99777&quot;&gt;여기&lt;/a&gt; 에 설명 된 위험이 있습니다 . 이를 피할 수있는 유일한 방법은 cherry-pick을 사용하여 새 기록을 만드는 것입니다. 이 링크 &lt;strong&gt;는 가장 안전한 방법을&lt;/strong&gt; 설명 &lt;strong&gt;합니다&lt;/strong&gt; . 커밋되지 않은 변경 사항이 있으면 시작 부분에 &lt;code&gt;git stash pop&lt;/code&gt; 끝 부분에 git stash pop 을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc09849dcad3761871d9ee917e048cf9c22dde7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;git branch -f master origin/master&lt;/code&gt; will &lt;em&gt;reset the tracking information&lt;/em&gt; for that branch.  So if you have configured your &lt;code&gt;master&lt;/code&gt; branch to push to somewhere other than &lt;code&gt;origin/master&lt;/code&gt; then that configuration will be lost.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;경고 :&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;git branch -f master origin/master&lt;/code&gt; 는 해당 분기에 대한 &lt;em&gt;추적 정보&lt;/em&gt; 를 &lt;em&gt;재설정합니다&lt;/em&gt; . 따라서 &lt;code&gt;origin/master&lt;/code&gt; 이외의 곳으로 푸시하도록 &lt;code&gt;master&lt;/code&gt; 브랜치를 구성한 경우 해당 구성이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="7f9ad6c0ec2a73b8d713e3d81a49de29bff79dc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Command&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2477858102f7652389b875f96a2e140e6fd64b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have been making commits&lt;/strong&gt; on your main branch while you coded, but you now want to move those commits to a different branch, this is a quick way:</source>
          <target state="translated">코딩하는 동안 메인 브랜치에서 &lt;strong&gt;커밋&lt;/strong&gt; 을 수행했지만 이제 해당 커밋을 다른 브랜치로 이동하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="1c6238087e049f3d0691d7bd7a1ccbf11bdc4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SourceTree&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SourceTree&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364298da3e6538acf42867a5ddd243b1de71dc7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TortoiseGIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TortoiseGIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e34b3b0ea3d7be25a4e72b4749dea317e42a1f26" translate="yes" xml:space="preserve">
          <source>All you need to do is switch to the new branch in GitHub Desktop, and it will prompt you to leave your changes on the current branch (which will be stashed), or to bring your changes with you to the new branch. Just choose the second option, to bring the changes to the new branch. You can then commit as usual.</source>
          <target state="translated">GitHub Desktop에서 새 브랜치로 전환하기 만하면 현재 브랜치에 변경 사항을 그대로 두거나 (지속될) 새 브랜치로 변경 사항을 가져 오라는 메시지가 표시됩니다. 두 번째 옵션을 선택하면 새 지점으로 변경 사항이 적용됩니다. 그런 다음 평소처럼 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85c58dec99e5ab948d510b95570ff7548c7b434" translate="yes" xml:space="preserve">
          <source>Alternatively:</source>
          <target state="translated">Alternatively:</target>
        </trans-unit>
        <trans-unit id="af6fe2dfd2b702ee9c4634a1fbec1f0ba87607ff" translate="yes" xml:space="preserve">
          <source>Copy your current history onto a new branch, bringing along any uncommitted changes too:</source>
          <target state="translated">커밋되지 않은 변경 사항을 모두 가져 와서 현재 기록을 새 브랜치에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="d74e937433f4ec11a53b474659c010b78ec26526" translate="yes" xml:space="preserve">
          <source>Create a new branch based on this stash, and switch to the new branch:</source>
          <target state="translated">이 숨김을 기반으로 새 분기를 작성하고 새 분기로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d2961b41291ba5b61f065ca5a9ade88738ccef9" translate="yes" xml:space="preserve">
          <source>Git 2.23 adds the new &lt;code&gt;switch&lt;/code&gt; subcommand in an attempt to clear some of the confusion that comes from the overloaded usage of &lt;code&gt;checkout&lt;/code&gt; (switching branches, restoring files, detaching HEAD, etc.)</source>
          <target state="translated">Git 2.23은 오버로드 된 &lt;code&gt;checkout&lt;/code&gt; 사용법 (브랜치 전환, 파일 복원, HEAD 분리 등)으로 인한 혼란을 없애기 위해 새로운 &lt;code&gt;switch&lt;/code&gt; 부속 명령을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="25d2c2b1aca053db2279c5abae2f58f2560f39a3" translate="yes" xml:space="preserve">
          <source>How do I move the existing uncommitted changes to a new branch and reset my current one?</source>
          <target state="translated">커밋되지 않은 기존 변경 사항을 새 브랜치로 옮기고 현재 브랜치를 재설정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="561541131dd59d2b4ea14dd7f7521dec21ced931" translate="yes" xml:space="preserve">
          <source>I started some work on a new feature and after coding for a bit, I decided this feature should be on its own branch.</source>
          <target state="translated">나는 새로운 기능에 대한 연구를 시작했으며 약간의 코딩을 한 후에이 기능이 자체 분기에 있어야한다고 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="ce000e487cc15cdd599c5e7a39dafbd95a412e0b" translate="yes" xml:space="preserve">
          <source>I used &lt;a href=&quot;https://stackoverflow.com/a/30927991/4149861&quot;&gt;@Robin&lt;/a&gt; answer &amp;amp; listing all that I did,</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/30927991/4149861&quot;&gt;@Robin&lt;/a&gt; 답변을 사용하고 내가 한 모든 것을 나열했습니다.</target>
        </trans-unit>
        <trans-unit id="c7391ed2637e644368f0521e7e43e7864e5a4630" translate="yes" xml:space="preserve">
          <source>I want to reset my current branch while preserving existing work on the new feature.</source>
          <target state="translated">새 기능에 대한 기존 작업을 유지하면서 현재 지점을 재설정하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="6aa389b1da3f6f442903cb6820a91cb3c0e17d71" translate="yes" xml:space="preserve">
          <source>If you commit it, you could also cherry-pick the single commit ID.  I do this often when I start work in master, and then want to create a local branch before I push up to my origin/.</source>
          <target state="translated">커밋하면 단일 커밋 ID를 체리 픽으로 선택할 수도 있습니다. 나는 마스터에서 일을 시작할 때 종종이 작업을 수행 한 다음 내 원산지 /에 도달하기 전에 로컬 지점을 만들고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="b298f57ebc4077b762c6a1ce2866654050fdb7ab" translate="yes" xml:space="preserve">
          <source>Move existing, uncommitted work to a new branch in Git</source>
          <target state="translated">커밋되지 않은 기존 작업을 Git의 새 지점으로 이동</target>
        </trans-unit>
        <trans-unit id="5a1270962cf994901a5b46427b97c33d06a12e26" translate="yes" xml:space="preserve">
          <source>Now force the original &quot;messy&quot; branch to roll back: (without switching to it)</source>
          <target state="translated">이제 원래 &quot;지저분한&quot;브랜치를 강제로 롤백하십시오 (전환하지 않고).</target>
        </trans-unit>
        <trans-unit id="c224788c05df4ff1d1d8812f96b7dd74d158b5a8" translate="yes" xml:space="preserve">
          <source>Or inspect all stashes at once:</source>
          <target state="translated">또는 모든 숨김을 한 번에 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="ac1b7836245be583a0314602f255f394611b0b12" translate="yes" xml:space="preserve">
          <source>Right-click on your repository and then use TortoiseGit-&amp;gt;Switch/Checkout</source>
          <target state="translated">저장소를 마우스 오른쪽 버튼으로 클릭하고 TortoiseGit-&amp;gt; 스위치 / 체크 아웃을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4cb2473d1a9663dbfcce1afa77b723f19484009f" translate="yes" xml:space="preserve">
          <source>Save current changes to a temp stash:</source>
          <target state="translated">임시 변경 사항에 현재 변경 사항을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="a402f9933183f964ca68793227503e860d765bd4" translate="yes" xml:space="preserve">
          <source>Starting with this version of Git, replace above's command with:</source>
          <target state="translated">이 버전의 Git부터는 위의 명령을 다음과 같이 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="ba9131ec417c9a8ab0e8d4f31502a4f4fed17c56" translate="yes" xml:space="preserve">
          <source>Switch branch - it will move your changes to new-branch. Then you can commit changes.</source>
          <target state="translated">스위치 브랜치-변경 사항을 새 브랜치로 이동합니다. 그런 다음 변경 사항을 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c9d3dda07e1c3a8f3955036e6e9b7455a661f5" translate="yes" xml:space="preserve">
          <source>The behavior is identical and remains unchanged.</source>
          <target state="translated">동작은 동일하며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ec2ca34cf5f8ab05811622d65ba6f5de8d8e208" translate="yes" xml:space="preserve">
          <source>The changes in the working directory and changes staged in index &lt;em&gt;do not belong to any branch&lt;/em&gt; yet. This changes the branch where those modifications would end in.</source>
          <target state="translated">작업 디렉토리의 변경 사항과 인덱스에서 준비된 변경 사항은 아직 &lt;em&gt;어떤 브랜치에도 속하지&lt;/em&gt; 않습니다. 그러면 수정이 끝나는 지점이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="81c2a72e26eb6d3af7267ab7e4bddd00421a2cb4" translate="yes" xml:space="preserve">
          <source>The common scenario is the following: I forgot to create the new branch for the new feature, and was doing all the work in the old feature branch. I have commited all the &quot;old&quot; work to the master branch, and I want my new branch to grow from the &quot;master&quot;. I have not made a single commit of my new work.
Here is the branch structure:
&quot;master&quot;-&amp;gt;&quot;Old_feature&quot;</source>
          <target state="translated">일반적인 시나리오는 다음과 같습니다. 새 기능에 대한 새 분기를 만드는 것을 잊었으며 이전 기능 분기에서 모든 작업을 수행하고있었습니다. 나는 모든 &quot;오래된&quot;작업을 마스터 브랜치에 맡기고 새 브랜치가 &quot;마스터&quot;에서 성장하기를 원합니다. 나는 새로운 일을 한 번도하지 않았습니다. 분기 구조는 다음과 같습니다. &quot;master&quot;-&amp;gt; &quot;Old_feature&quot;</target>
        </trans-unit>
        <trans-unit id="d6bfe534338f93bba2f16566e3b76e30c418a379" translate="yes" xml:space="preserve">
          <source>There is actually a really easy way to do this with GitHub Desktop now that I don't believe was a feature before.</source>
          <target state="translated">실제로 GitHub Desktop 으로이 작업을 수행하는 정말 쉬운 방법이 있습니다. 이전에는 기능이라고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c0653175c372182c14b05b1fd0df72ef1681996" translate="yes" xml:space="preserve">
          <source>There is alot you can do with cherry-pick, as described &lt;a href=&quot;https://git-scm.com/docs/git-cherry-pick&quot;&gt;here&lt;/a&gt;, but this could be a use-case for you.</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/docs/git-cherry-pick&quot;&gt;여기&lt;/a&gt; 에 설명 된 것처럼 체리 피킹으로 할 수있는 많은 것이 있지만 이것은 유스 케이스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd7ed0fafb9ce8b6d4a8a896071624ec143d1d56" translate="yes" xml:space="preserve">
          <source>This may be helpful for all using tools for GIT</source>
          <target state="translated">이것은 GIT 도구를 사용하는 모든 사람에게 도움이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="da077db9b311b66042457479300697ab669d5d01" translate="yes" xml:space="preserve">
          <source>This will leave your current branch as it is, create and checkout a new branch and keep all your changes. You can then stage changes in files to commit with:</source>
          <target state="translated">현재 지점을 그대로두고 새 지점을 생성 및 체크 아웃하고 모든 변경 사항을 유지합니다. 그런 다음 커밋 할 파일의 변경 사항을 준비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4a215ebaea7d82ec9461232c8095db4ee383b5f" translate="yes" xml:space="preserve">
          <source>Tip: use tab key to reduce typing the stash name.</source>
          <target state="translated">팁 : 숨김 키 입력을 줄이려면 Tab 키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="becde14ef41bbf13dfecef5d85c8bfcb751caeb9" translate="yes" xml:space="preserve">
          <source>Update 2020 / Git 2.23</source>
          <target state="translated">2020 업데이트 / 힘내 2.23</target>
        </trans-unit>
        <trans-unit id="85ebfb4fe55a1ee0f5b07ae2dd384843a6e72cfb" translate="yes" xml:space="preserve">
          <source>Use the &quot;Checkout&quot; button to switch branch. You will see the &quot;checkout&quot; button at the top after clicking on a branch. Changes from the current branch will be applied automatically.  Then you can commit them.</source>
          <target state="translated">&quot;체크 아웃&quot;버튼을 사용하여 분기를 전환하십시오. 지점을 클릭하면 상단에 &quot;체크 아웃&quot;버튼이 표시됩니다. 현재 지점의 변경 사항이 자동으로 적용됩니다. 그런 다음 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f8a1626b883c2f3276b89ccbee6f458981b3c6b" translate="yes" xml:space="preserve">
          <source>Use the following:</source>
          <target state="translated">다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98e4ff14af1895227f442b3b0d38996c483e9fa3" translate="yes" xml:space="preserve">
          <source>You don't &lt;em&gt;reset&lt;/em&gt; your original branch, it stays as it is. The last commit on &lt;code&gt;&amp;lt;old-branch&amp;gt;&lt;/code&gt; will still be the same. Therefore you &lt;code&gt;checkout -b&lt;/code&gt; and then commit.</source>
          <target state="translated">원래 브랜치를 &lt;em&gt;재설정&lt;/em&gt; 하지 않고 그대로 유지합니다. &lt;code&gt;&amp;lt;old-branch&amp;gt;&lt;/code&gt; 의 마지막 커밋은 여전히 ​​동일합니다. 따라서 &lt;code&gt;checkout -b&lt;/code&gt; 를 체크 아웃 한 다음 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="4501ad41b9c25e2ac0a25cb11c60f77c18080098" translate="yes" xml:space="preserve">
          <source>and commit to your &lt;em&gt;new branch&lt;/em&gt; with:</source>
          <target state="translated">다음과 같이 &lt;em&gt;새 지점에&lt;/em&gt; 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="3a87edc1a77b3ef1079647eaea86b842bb2e2c5a" translate="yes" xml:space="preserve">
          <source>and inspect the individual stash by,</source>
          <target state="translated">개별 숨김을 검사하여</target>
        </trans-unit>
        <trans-unit id="89023c029834bb950e9973e068dc6f1315c10e5e" translate="yes" xml:space="preserve">
          <source>or if you had made 4 commits:</source>
          <target state="translated">또는 4 번 커밋 한 경우 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
