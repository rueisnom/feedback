<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1394797">
    <body>
      <group id="1394797">
        <trans-unit id="ba486396875db8ae9ec14bf5a1239c6e235f52be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;!&lt;/strong&gt;   If the repo has more than one stash, see which one to apply to the new-branch:</source>
          <target state="translated">&lt;strong&gt;！&lt;/strong&gt; 如果存储库有多个存储库，请查看将哪个存储库应用于新分支：</target>
        </trans-unit>
        <trans-unit id="2bf695ac2647c1533249c9022a8f96def0a7b1b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; There is also a danger if you rebase after branching, which is &lt;a href=&quot;https://stackoverflow.com/a/36463546/99777&quot;&gt;described here&lt;/a&gt;.  The only way to avoid that is to create a new history using cherry-pick.  That link describes &lt;strong&gt;the safest fool-proof method&lt;/strong&gt;.  If you have uncommitted changes, you may want to &lt;code&gt;git stash&lt;/code&gt; at the start and &lt;code&gt;git stash pop&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;如果在分支后重新设置基准，也存在危险，如此处&lt;a href=&quot;https://stackoverflow.com/a/36463546/99777&quot;&gt;所述&lt;/a&gt; 。 避免这种情况的唯一方法是使用Cherry-Pick创建新的历史记录。 该链接描述&lt;strong&gt;了最安全的防呆方法&lt;/strong&gt; 。 如果您有未提交的更改，则可能要在开始时使用 &lt;code&gt;git stash pop&lt;/code&gt; ，在结束时使用git stash pop 。</target>
        </trans-unit>
        <trans-unit id="1dc09849dcad3761871d9ee917e048cf9c22dde7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;git branch -f master origin/master&lt;/code&gt; will &lt;em&gt;reset the tracking information&lt;/em&gt; for that branch.  So if you have configured your &lt;code&gt;master&lt;/code&gt; branch to push to somewhere other than &lt;code&gt;origin/master&lt;/code&gt; then that configuration will be lost.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;git branch -f master origin/master&lt;/code&gt; 将&lt;em&gt;重置该&lt;/em&gt;分支&lt;em&gt;的跟踪信息&lt;/em&gt; 。 因此，如果您已将 &lt;code&gt;master&lt;/code&gt; 分支配置为推送到 &lt;code&gt;origin/master&lt;/code&gt; 以外的其他位置，则该配置将丢失。</target>
        </trans-unit>
        <trans-unit id="7f9ad6c0ec2a73b8d713e3d81a49de29bff79dc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Command&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2477858102f7652389b875f96a2e140e6fd64b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have been making commits&lt;/strong&gt; on your main branch while you coded, but you now want to move those commits to a different branch, this is a quick way:</source>
          <target state="translated">&lt;strong&gt;如果您&lt;/strong&gt;在编码时&lt;strong&gt;一直&lt;/strong&gt;在主分支上&lt;strong&gt;进行提交&lt;/strong&gt; ，但是现在您想将这些提交移动到另一个分支，这是一种快速的方法：</target>
        </trans-unit>
        <trans-unit id="1c6238087e049f3d0691d7bd7a1ccbf11bdc4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SourceTree&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SourceTree&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364298da3e6538acf42867a5ddd243b1de71dc7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TortoiseGIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TortoiseGIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e34b3b0ea3d7be25a4e72b4749dea317e42a1f26" translate="yes" xml:space="preserve">
          <source>All you need to do is switch to the new branch in GitHub Desktop, and it will prompt you to leave your changes on the current branch (which will be stashed), or to bring your changes with you to the new branch. Just choose the second option, to bring the changes to the new branch. You can then commit as usual.</source>
          <target state="translated">你只需要在GitHub桌面上切换到新的分支,它会提示你把你的修改留在当前的分支上(会被隐藏),或者把你的修改带到新的分支上。只需选择第二个选项,将修改带到新的分支中。然后你可以像往常一样提交。</target>
        </trans-unit>
        <trans-unit id="c85c58dec99e5ab948d510b95570ff7548c7b434" translate="yes" xml:space="preserve">
          <source>Alternatively:</source>
          <target state="translated">Alternatively:</target>
        </trans-unit>
        <trans-unit id="af6fe2dfd2b702ee9c4634a1fbec1f0ba87607ff" translate="yes" xml:space="preserve">
          <source>Copy your current history onto a new branch, bringing along any uncommitted changes too:</source>
          <target state="translated">将你当前的历史记录复制到一个新的分支上,同时也要带着任何未约定的修改。</target>
        </trans-unit>
        <trans-unit id="d74e937433f4ec11a53b474659c010b78ec26526" translate="yes" xml:space="preserve">
          <source>Create a new branch based on this stash, and switch to the new branch:</source>
          <target state="translated">在此基础上创建一个新的分支,并切换到新的分支。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="8d2961b41291ba5b61f065ca5a9ade88738ccef9" translate="yes" xml:space="preserve">
          <source>Git 2.23 adds the new &lt;code&gt;switch&lt;/code&gt; subcommand in an attempt to clear some of the confusion that comes from the overloaded usage of &lt;code&gt;checkout&lt;/code&gt; (switching branches, restoring files, detaching HEAD, etc.)</source>
          <target state="translated">Git 2.23添加了新的 &lt;code&gt;switch&lt;/code&gt; 子命令，以试图消除由于 &lt;code&gt;checkout&lt;/code&gt; 的过多使用而引起的一些混乱（切换分支，还原文件，分离HEAD等）。</target>
        </trans-unit>
        <trans-unit id="25d2c2b1aca053db2279c5abae2f58f2560f39a3" translate="yes" xml:space="preserve">
          <source>How do I move the existing uncommitted changes to a new branch and reset my current one?</source>
          <target state="translated">如何将现有的未承诺的变更转移到新的分支,并重置当前的分支?</target>
        </trans-unit>
        <trans-unit id="561541131dd59d2b4ea14dd7f7521dec21ced931" translate="yes" xml:space="preserve">
          <source>I started some work on a new feature and after coding for a bit, I decided this feature should be on its own branch.</source>
          <target state="translated">我开始了一些关于新功能的工作,经过一段时间的编码,我决定这个功能应该放在自己的分支上。</target>
        </trans-unit>
        <trans-unit id="ce000e487cc15cdd599c5e7a39dafbd95a412e0b" translate="yes" xml:space="preserve">
          <source>I used &lt;a href=&quot;https://stackoverflow.com/a/30927991/4149861&quot;&gt;@Robin&lt;/a&gt; answer &amp;amp; listing all that I did,</source>
          <target state="translated">我用&lt;a href=&quot;https://stackoverflow.com/a/30927991/4149861&quot;&gt;@Robin&lt;/a&gt;回答并列出了我所做的所有事情，</target>
        </trans-unit>
        <trans-unit id="c7391ed2637e644368f0521e7e43e7864e5a4630" translate="yes" xml:space="preserve">
          <source>I want to reset my current branch while preserving existing work on the new feature.</source>
          <target state="translated">我想在保留现有的新功能上的工作的同时,重新设置当前的分支。</target>
        </trans-unit>
        <trans-unit id="6aa389b1da3f6f442903cb6820a91cb3c0e17d71" translate="yes" xml:space="preserve">
          <source>If you commit it, you could also cherry-pick the single commit ID.  I do this often when I start work in master, and then want to create a local branch before I push up to my origin/.</source>
          <target state="translated">如果你提交的话,也可以偷工减料的单次提交ID。我经常这样做,当我在master中开始工作的时候,然后想在推送到我的原点之前创建一个本地分支。</target>
        </trans-unit>
        <trans-unit id="b298f57ebc4077b762c6a1ce2866654050fdb7ab" translate="yes" xml:space="preserve">
          <source>Move existing, uncommitted work to a new branch in Git</source>
          <target state="translated">将现有的、未提交的工作转移到Git中的新分支中</target>
        </trans-unit>
        <trans-unit id="5a1270962cf994901a5b46427b97c33d06a12e26" translate="yes" xml:space="preserve">
          <source>Now force the original &quot;messy&quot; branch to roll back: (without switching to it)</source>
          <target state="translated">现在强行将原来 &quot;乱七八糟 &quot;的分支回滚。(没有切换到它)</target>
        </trans-unit>
        <trans-unit id="c224788c05df4ff1d1d8812f96b7dd74d158b5a8" translate="yes" xml:space="preserve">
          <source>Or inspect all stashes at once:</source>
          <target state="translated">或者一次性检查所有的藏品。</target>
        </trans-unit>
        <trans-unit id="ac1b7836245be583a0314602f255f394611b0b12" translate="yes" xml:space="preserve">
          <source>Right-click on your repository and then use TortoiseGit-&amp;gt;Switch/Checkout</source>
          <target state="translated">右键单击您的存储库，然后使用TortoiseGit-&amp;gt; Switch / Checkout</target>
        </trans-unit>
        <trans-unit id="4cb2473d1a9663dbfcce1afa77b723f19484009f" translate="yes" xml:space="preserve">
          <source>Save current changes to a temp stash:</source>
          <target state="translated">将当前的更改保存到一个临时储存库中。</target>
        </trans-unit>
        <trans-unit id="a402f9933183f964ca68793227503e860d765bd4" translate="yes" xml:space="preserve">
          <source>Starting with this version of Git, replace above's command with:</source>
          <target state="translated">从这个版本的Git开始,将上面的命令替换成。</target>
        </trans-unit>
        <trans-unit id="ba9131ec417c9a8ab0e8d4f31502a4f4fed17c56" translate="yes" xml:space="preserve">
          <source>Switch branch - it will move your changes to new-branch. Then you can commit changes.</source>
          <target state="translated">切换分支--它会将你的修改转移到新分支。然后你就可以提交修改了。</target>
        </trans-unit>
        <trans-unit id="79c9d3dda07e1c3a8f3955036e6e9b7455a661f5" translate="yes" xml:space="preserve">
          <source>The behavior is identical and remains unchanged.</source>
          <target state="translated">行为完全相同,没有变化。</target>
        </trans-unit>
        <trans-unit id="4ec2ca34cf5f8ab05811622d65ba6f5de8d8e208" translate="yes" xml:space="preserve">
          <source>The changes in the working directory and changes staged in index &lt;em&gt;do not belong to any branch&lt;/em&gt; yet. This changes the branch where those modifications would end in.</source>
          <target state="translated">工作目录中的更改和索引中暂存的更改&lt;em&gt;尚不属于任何分支&lt;/em&gt; 。 这将更改这些修改的终止分支。</target>
        </trans-unit>
        <trans-unit id="81c2a72e26eb6d3af7267ab7e4bddd00421a2cb4" translate="yes" xml:space="preserve">
          <source>The common scenario is the following: I forgot to create the new branch for the new feature, and was doing all the work in the old feature branch. I have commited all the &quot;old&quot; work to the master branch, and I want my new branch to grow from the &quot;master&quot;. I have not made a single commit of my new work.
Here is the branch structure:
&quot;master&quot;-&amp;gt;&quot;Old_feature&quot;</source>
          <target state="translated">常见的情况如下：我忘记为新功能创建新分支，并且在旧功能分支中进行了所有工作。 我已经将所有&amp;ldquo;旧&amp;rdquo;工作都提交给master分支，并且我希望我的新分支可以从&amp;ldquo; master&amp;rdquo;中成长。 我还没有提交新工作。 这是分支结构：&amp;ldquo; master&amp;rdquo;-&amp;gt;&amp;ldquo; Old_feature&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d6bfe534338f93bba2f16566e3b76e30c418a379" translate="yes" xml:space="preserve">
          <source>There is actually a really easy way to do this with GitHub Desktop now that I don't believe was a feature before.</source>
          <target state="translated">事实上,现在有一个非常简单的方法可以在GitHub桌面上实现这个功能,我不相信这在以前是没有的。</target>
        </trans-unit>
        <trans-unit id="1c0653175c372182c14b05b1fd0df72ef1681996" translate="yes" xml:space="preserve">
          <source>There is alot you can do with cherry-pick, as described &lt;a href=&quot;https://git-scm.com/docs/git-cherry-pick&quot;&gt;here&lt;/a&gt;, but this could be a use-case for you.</source>
          <target state="translated">如此处所述，您可以使用Cherry-pick进行很多操作，但这可能是您的用例。</target>
        </trans-unit>
        <trans-unit id="bd7ed0fafb9ce8b6d4a8a896071624ec143d1d56" translate="yes" xml:space="preserve">
          <source>This may be helpful for all using tools for GIT</source>
          <target state="translated">这可能对所有使用GIT工具的人都有帮助。</target>
        </trans-unit>
        <trans-unit id="da077db9b311b66042457479300697ab669d5d01" translate="yes" xml:space="preserve">
          <source>This will leave your current branch as it is, create and checkout a new branch and keep all your changes. You can then stage changes in files to commit with:</source>
          <target state="translated">这将使您的当前分支保持原样,创建并签出一个新的分支并保留所有的修改。然后,你可以在文件中进行阶段性的修改,并将其提交。</target>
        </trans-unit>
        <trans-unit id="b4a215ebaea7d82ec9461232c8095db4ee383b5f" translate="yes" xml:space="preserve">
          <source>Tip: use tab key to reduce typing the stash name.</source>
          <target state="translated">提示:使用tab键减少键入储物箱名称。</target>
        </trans-unit>
        <trans-unit id="becde14ef41bbf13dfecef5d85c8bfcb751caeb9" translate="yes" xml:space="preserve">
          <source>Update 2020 / Git 2.23</source>
          <target state="translated">更新2020年Git 2.23</target>
        </trans-unit>
        <trans-unit id="85ebfb4fe55a1ee0f5b07ae2dd384843a6e72cfb" translate="yes" xml:space="preserve">
          <source>Use the &quot;Checkout&quot; button to switch branch. You will see the &quot;checkout&quot; button at the top after clicking on a branch. Changes from the current branch will be applied automatically.  Then you can commit them.</source>
          <target state="translated">使用 &quot;结账 &quot;按钮切换分支。点击一个分支后,你会看到顶部的 &quot;结账 &quot;按钮。当前分支中的更改将自动应用。然后你就可以提交了。</target>
        </trans-unit>
        <trans-unit id="9f8a1626b883c2f3276b89ccbee6f458981b3c6b" translate="yes" xml:space="preserve">
          <source>Use the following:</source>
          <target state="translated">采用以下方法:</target>
        </trans-unit>
        <trans-unit id="98e4ff14af1895227f442b3b0d38996c483e9fa3" translate="yes" xml:space="preserve">
          <source>You don't &lt;em&gt;reset&lt;/em&gt; your original branch, it stays as it is. The last commit on &lt;code&gt;&amp;lt;old-branch&amp;gt;&lt;/code&gt; will still be the same. Therefore you &lt;code&gt;checkout -b&lt;/code&gt; and then commit.</source>
          <target state="translated">您无需&lt;em&gt;重置&lt;/em&gt;原始分支，它会保持原样。 &lt;code&gt;&amp;lt;old-branch&amp;gt;&lt;/code&gt; 上的最后一次提交将保持不变。 因此，您 &lt;code&gt;checkout -b&lt;/code&gt; 然后提交。</target>
        </trans-unit>
        <trans-unit id="4501ad41b9c25e2ac0a25cb11c60f77c18080098" translate="yes" xml:space="preserve">
          <source>and commit to your &lt;em&gt;new branch&lt;/em&gt; with:</source>
          <target state="translated">并使用以下命令提交到您的&lt;em&gt;新分支&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a87edc1a77b3ef1079647eaea86b842bb2e2c5a" translate="yes" xml:space="preserve">
          <source>and inspect the individual stash by,</source>
          <target state="translated">并检查个人藏匿处。</target>
        </trans-unit>
        <trans-unit id="89023c029834bb950e9973e068dc6f1315c10e5e" translate="yes" xml:space="preserve">
          <source>or if you had made 4 commits:</source>
          <target state="translated">或如果你有4个承诺,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
