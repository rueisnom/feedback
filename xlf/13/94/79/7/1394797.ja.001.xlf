<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1394797">
    <body>
      <group id="1394797">
        <trans-unit id="ba486396875db8ae9ec14bf5a1239c6e235f52be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;!&lt;/strong&gt;   If the repo has more than one stash, see which one to apply to the new-branch:</source>
          <target state="translated">&lt;strong&gt;！&lt;/strong&gt; リポジトリに複数のスタッシュがある場合は、新しいブランチに適用するスタッシュを確認します。</target>
        </trans-unit>
        <trans-unit id="2bf695ac2647c1533249c9022a8f96def0a7b1b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; There is also a danger if you rebase after branching, which is &lt;a href=&quot;https://stackoverflow.com/a/36463546/99777&quot;&gt;described here&lt;/a&gt;.  The only way to avoid that is to create a new history using cherry-pick.  That link describes &lt;strong&gt;the safest fool-proof method&lt;/strong&gt;.  If you have uncommitted changes, you may want to &lt;code&gt;git stash&lt;/code&gt; at the start and &lt;code&gt;git stash pop&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt; &lt;a href=&quot;https://stackoverflow.com/a/36463546/99777&quot;&gt;ここ&lt;/a&gt;で説明されているように 、分岐後にリベースする場合にも危険があります 。 これを回避する唯一の方法は、チェリーピックを使用して新しい履歴を作成することです。 そのリンクは&lt;strong&gt;、最も安全で簡単な方法を説明してい&lt;/strong&gt;ます。 コミットされていない変更がある場合は、最初に &lt;code&gt;git stash pop&lt;/code&gt; を、最後にgit stash popを使用できます。</target>
        </trans-unit>
        <trans-unit id="1dc09849dcad3761871d9ee917e048cf9c22dde7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;git branch -f master origin/master&lt;/code&gt; will &lt;em&gt;reset the tracking information&lt;/em&gt; for that branch.  So if you have configured your &lt;code&gt;master&lt;/code&gt; branch to push to somewhere other than &lt;code&gt;origin/master&lt;/code&gt; then that configuration will be lost.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;git branch -f master origin/master&lt;/code&gt; は、そのブランチの&lt;em&gt;追跡情報&lt;/em&gt;を&lt;em&gt;リセットし&lt;/em&gt;ます。 したがって、 &lt;code&gt;master&lt;/code&gt; ブランチを &lt;code&gt;origin/master&lt;/code&gt; 以外の場所にプッシュするように構成した場合、その構成は失われます。</target>
        </trans-unit>
        <trans-unit id="7f9ad6c0ec2a73b8d713e3d81a49de29bff79dc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Command&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2477858102f7652389b875f96a2e140e6fd64b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have been making commits&lt;/strong&gt; on your main branch while you coded, but you now want to move those commits to a different branch, this is a quick way:</source>
          <target state="translated">コーディング中にメインブランチで&lt;strong&gt;コミット&lt;/strong&gt;を&lt;strong&gt;行っていたが&lt;/strong&gt; 、それらのコミットを別のブランチに移動したい場合、これは簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="1c6238087e049f3d0691d7bd7a1ccbf11bdc4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SourceTree&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SourceTree&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364298da3e6538acf42867a5ddd243b1de71dc7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TortoiseGIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TortoiseGIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e34b3b0ea3d7be25a4e72b4749dea317e42a1f26" translate="yes" xml:space="preserve">
          <source>All you need to do is switch to the new branch in GitHub Desktop, and it will prompt you to leave your changes on the current branch (which will be stashed), or to bring your changes with you to the new branch. Just choose the second option, to bring the changes to the new branch. You can then commit as usual.</source>
          <target state="translated">GitHub Desktop で新しいブランチに切り替えると、変更内容を現在のブランチに残すか (隠したままにするか)、変更内容を新しいブランチに持っていくかの選択画面が表示されます。2 番目のオプションを選択すると、変更を新しいブランチに持っていくことができます。これで、通常通りコミットすることができます。</target>
        </trans-unit>
        <trans-unit id="c85c58dec99e5ab948d510b95570ff7548c7b434" translate="yes" xml:space="preserve">
          <source>Alternatively:</source>
          <target state="translated">Alternatively:</target>
        </trans-unit>
        <trans-unit id="af6fe2dfd2b702ee9c4634a1fbec1f0ba87607ff" translate="yes" xml:space="preserve">
          <source>Copy your current history onto a new branch, bringing along any uncommitted changes too:</source>
          <target state="translated">現在の履歴を新しいブランチにコピーし、コミットされていない変更も一緒に持っていきます。</target>
        </trans-unit>
        <trans-unit id="d74e937433f4ec11a53b474659c010b78ec26526" translate="yes" xml:space="preserve">
          <source>Create a new branch based on this stash, and switch to the new branch:</source>
          <target state="translated">このスタッシュを元に新しいブランチを作成し、新しいブランチに切り替えます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="8d2961b41291ba5b61f065ca5a9ade88738ccef9" translate="yes" xml:space="preserve">
          <source>Git 2.23 adds the new &lt;code&gt;switch&lt;/code&gt; subcommand in an attempt to clear some of the confusion that comes from the overloaded usage of &lt;code&gt;checkout&lt;/code&gt; (switching branches, restoring files, detaching HEAD, etc.)</source>
          <target state="translated">Git 2.23は、 &lt;code&gt;checkout&lt;/code&gt; の過負荷使用によるブランチの切り替え、ファイルの復元、HEADの切り離しなどの混乱を解消するために、新しい &lt;code&gt;switch&lt;/code&gt; サブコマンドを追加しています。</target>
        </trans-unit>
        <trans-unit id="25d2c2b1aca053db2279c5abae2f58f2560f39a3" translate="yes" xml:space="preserve">
          <source>How do I move the existing uncommitted changes to a new branch and reset my current one?</source>
          <target state="translated">既存のコミットされていない変更を新しいブランチに移動して、現在のブランチをリセットするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="561541131dd59d2b4ea14dd7f7521dec21ced931" translate="yes" xml:space="preserve">
          <source>I started some work on a new feature and after coding for a bit, I decided this feature should be on its own branch.</source>
          <target state="translated">私は新しい機能についていくつかの作業を開始し、少しの間コーディングをした後、この機能は独自のブランチにするべきだと決めました。</target>
        </trans-unit>
        <trans-unit id="ce000e487cc15cdd599c5e7a39dafbd95a412e0b" translate="yes" xml:space="preserve">
          <source>I used &lt;a href=&quot;https://stackoverflow.com/a/30927991/4149861&quot;&gt;@Robin&lt;/a&gt; answer &amp;amp; listing all that I did,</source>
          <target state="translated">私は&lt;a href=&quot;https://stackoverflow.com/a/30927991/4149861&quot;&gt;@Robinの&lt;/a&gt;回答を使用し、自分がしたことをすべてリストしました。</target>
        </trans-unit>
        <trans-unit id="c7391ed2637e644368f0521e7e43e7864e5a4630" translate="yes" xml:space="preserve">
          <source>I want to reset my current branch while preserving existing work on the new feature.</source>
          <target state="translated">新機能の既存の作業を残しつつ、現在のブランチをリセットしたい。</target>
        </trans-unit>
        <trans-unit id="6aa389b1da3f6f442903cb6820a91cb3c0e17d71" translate="yes" xml:space="preserve">
          <source>If you commit it, you could also cherry-pick the single commit ID.  I do this often when I start work in master, and then want to create a local branch before I push up to my origin/.</source>
          <target state="translated">コミットするならシングルコミットIDをチェリーピックするのもありだと思います。私は master で作業を開始して、自分のオリジンにプッシュする前にローカルブランチを作成したいときによくやります。</target>
        </trans-unit>
        <trans-unit id="b298f57ebc4077b762c6a1ce2866654050fdb7ab" translate="yes" xml:space="preserve">
          <source>Move existing, uncommitted work to a new branch in Git</source>
          <target state="translated">既存のコミットされていない作業を Git の新しいブランチに移動します。</target>
        </trans-unit>
        <trans-unit id="5a1270962cf994901a5b46427b97c33d06a12e26" translate="yes" xml:space="preserve">
          <source>Now force the original &quot;messy&quot; branch to roll back: (without switching to it)</source>
          <target state="translated">今度は元の「ごちゃごちゃした」ブランチを強制的にロールバックさせます。(切り替えずに)</target>
        </trans-unit>
        <trans-unit id="c224788c05df4ff1d1d8812f96b7dd74d158b5a8" translate="yes" xml:space="preserve">
          <source>Or inspect all stashes at once:</source>
          <target state="translated">または、一度にすべての隠し場所を検査します。</target>
        </trans-unit>
        <trans-unit id="ac1b7836245be583a0314602f255f394611b0b12" translate="yes" xml:space="preserve">
          <source>Right-click on your repository and then use TortoiseGit-&amp;gt;Switch/Checkout</source>
          <target state="translated">リポジトリを右クリックして、TortoiseGit-&amp;gt; Switch / Checkoutを使用します</target>
        </trans-unit>
        <trans-unit id="4cb2473d1a9663dbfcce1afa77b723f19484009f" translate="yes" xml:space="preserve">
          <source>Save current changes to a temp stash:</source>
          <target state="translated">現在の変更点を一時的な隠し場所に保存します。</target>
        </trans-unit>
        <trans-unit id="a402f9933183f964ca68793227503e860d765bd4" translate="yes" xml:space="preserve">
          <source>Starting with this version of Git, replace above's command with:</source>
          <target state="translated">このバージョンのGitからは、上記のコマンドを次のように置き換えてください。</target>
        </trans-unit>
        <trans-unit id="ba9131ec417c9a8ab0e8d4f31502a4f4fed17c56" translate="yes" xml:space="preserve">
          <source>Switch branch - it will move your changes to new-branch. Then you can commit changes.</source>
          <target state="translated">ブランチを切り替える-変更内容を new-branch に移動します。その後、変更をコミットすることができます。</target>
        </trans-unit>
        <trans-unit id="79c9d3dda07e1c3a8f3955036e6e9b7455a661f5" translate="yes" xml:space="preserve">
          <source>The behavior is identical and remains unchanged.</source>
          <target state="translated">挙動は全く同じで、そのままです。</target>
        </trans-unit>
        <trans-unit id="4ec2ca34cf5f8ab05811622d65ba6f5de8d8e208" translate="yes" xml:space="preserve">
          <source>The changes in the working directory and changes staged in index &lt;em&gt;do not belong to any branch&lt;/em&gt; yet. This changes the branch where those modifications would end in.</source>
          <target state="translated">作業ディレクトリでの変更とインデックスでステージングされた変更は、まだ&lt;em&gt;どのブランチにも属して&lt;/em&gt;いません。 これにより、変更が終了するブランチが変更されます。</target>
        </trans-unit>
        <trans-unit id="81c2a72e26eb6d3af7267ab7e4bddd00421a2cb4" translate="yes" xml:space="preserve">
          <source>The common scenario is the following: I forgot to create the new branch for the new feature, and was doing all the work in the old feature branch. I have commited all the &quot;old&quot; work to the master branch, and I want my new branch to grow from the &quot;master&quot;. I have not made a single commit of my new work.
Here is the branch structure:
&quot;master&quot;-&amp;gt;&quot;Old_feature&quot;</source>
          <target state="translated">一般的なシナリオは次のとおりです。新しい機能の新しいブランチを作成するのを忘れて、すべての作業を古い機能のブランチで行っていました。 私はすべての「古い」作業をマスターブランチにコミットしましたが、新しいブランチを「マスター」から成長させたいと思っています。 私は新しい仕事を1回もコミットしていません。 これがブランチ構造です： &quot;master&quot;-&amp;gt; &quot;Old_feature&quot;</target>
        </trans-unit>
        <trans-unit id="d6bfe534338f93bba2f16566e3b76e30c418a379" translate="yes" xml:space="preserve">
          <source>There is actually a really easy way to do this with GitHub Desktop now that I don't believe was a feature before.</source>
          <target state="translated">以前の機能とは思えないほど、今のGitHub Desktopには本当に簡単にできる方法があります。</target>
        </trans-unit>
        <trans-unit id="1c0653175c372182c14b05b1fd0df72ef1681996" translate="yes" xml:space="preserve">
          <source>There is alot you can do with cherry-pick, as described &lt;a href=&quot;https://git-scm.com/docs/git-cherry-pick&quot;&gt;here&lt;/a&gt;, but this could be a use-case for you.</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/docs/git-cherry-pick&quot;&gt;ここ&lt;/a&gt;で説明するように、チェリーピックでできることはたくさんありますが、これはユースケースになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd7ed0fafb9ce8b6d4a8a896071624ec143d1d56" translate="yes" xml:space="preserve">
          <source>This may be helpful for all using tools for GIT</source>
          <target state="translated">GIT用のツールを使っている方には参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="da077db9b311b66042457479300697ab669d5d01" translate="yes" xml:space="preserve">
          <source>This will leave your current branch as it is, create and checkout a new branch and keep all your changes. You can then stage changes in files to commit with:</source>
          <target state="translated">これにより、現在のブランチはそのままにして、新しいブランチを作成してチェックアウトし、すべての変更を保持します。そして、変更をファイルにまとめてコミットすることができます。</target>
        </trans-unit>
        <trans-unit id="b4a215ebaea7d82ec9461232c8095db4ee383b5f" translate="yes" xml:space="preserve">
          <source>Tip: use tab key to reduce typing the stash name.</source>
          <target state="translated">ヒント:タブキーを使用すると、隠し場所の名前の入力を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="becde14ef41bbf13dfecef5d85c8bfcb751caeb9" translate="yes" xml:space="preserve">
          <source>Update 2020 / Git 2.23</source>
          <target state="translated">アップデート2020 Git 2.23</target>
        </trans-unit>
        <trans-unit id="85ebfb4fe55a1ee0f5b07ae2dd384843a6e72cfb" translate="yes" xml:space="preserve">
          <source>Use the &quot;Checkout&quot; button to switch branch. You will see the &quot;checkout&quot; button at the top after clicking on a branch. Changes from the current branch will be applied automatically.  Then you can commit them.</source>
          <target state="translated">ブランチの切り替えは「チェックアウト」ボタンで行います。ブランチをクリックすると、上部に「チェックアウト」ボタンが表示されます。現在のブランチからの変更が自動的に適用されます。あとはコミットするだけです。</target>
        </trans-unit>
        <trans-unit id="9f8a1626b883c2f3276b89ccbee6f458981b3c6b" translate="yes" xml:space="preserve">
          <source>Use the following:</source>
          <target state="translated">以下のような使い方をしてください。</target>
        </trans-unit>
        <trans-unit id="98e4ff14af1895227f442b3b0d38996c483e9fa3" translate="yes" xml:space="preserve">
          <source>You don't &lt;em&gt;reset&lt;/em&gt; your original branch, it stays as it is. The last commit on &lt;code&gt;&amp;lt;old-branch&amp;gt;&lt;/code&gt; will still be the same. Therefore you &lt;code&gt;checkout -b&lt;/code&gt; and then commit.</source>
          <target state="translated">元のブランチは&lt;em&gt;リセット&lt;/em&gt;せず、そのままです。 &lt;code&gt;&amp;lt;old-branch&amp;gt;&lt;/code&gt; の最後のコミットは同じままです。 したがって、 &lt;code&gt;checkout -b&lt;/code&gt; をチェックアウトしてからコミットします。</target>
        </trans-unit>
        <trans-unit id="4501ad41b9c25e2ac0a25cb11c60f77c18080098" translate="yes" xml:space="preserve">
          <source>and commit to your &lt;em&gt;new branch&lt;/em&gt; with:</source>
          <target state="translated">そしてあなたの&lt;em&gt;新しいブランチに&lt;/em&gt;コミットします：</target>
        </trans-unit>
        <trans-unit id="3a87edc1a77b3ef1079647eaea86b842bb2e2c5a" translate="yes" xml:space="preserve">
          <source>and inspect the individual stash by,</source>
          <target state="translated">で個々の隠し場所を検査します。</target>
        </trans-unit>
        <trans-unit id="89023c029834bb950e9973e068dc6f1315c10e5e" translate="yes" xml:space="preserve">
          <source>or if you had made 4 commits:</source>
          <target state="translated">または4回のコミットをしていたとします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
