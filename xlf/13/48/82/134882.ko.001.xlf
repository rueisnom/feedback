<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/134882">
    <body>
      <group id="134882">
        <trans-unit id="485e988a7f1dbb69ea5f0a679447c4c9a7dab699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@{1}&lt;/code&gt; is simply a &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;shortcut for the current branch&lt;/a&gt;, so it's equal to &lt;code&gt;master@{1}&lt;/code&gt; if you are on &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{1}&lt;/code&gt; 은 &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;현재 브랜치에 대한 바로 가기&lt;/a&gt; 이므로 &lt;code&gt;master@{1}&lt;/code&gt; 있으면 master @ {1} 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9bc4014689fa4baa39e8b87d2468282def86529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # rename current branch</source>
          <target state="translated">&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # 현재 브랜치 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="bfda7d77b5b972fdf20ec53e82b252d4ad0fe27f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout to latest state that is known to origin</source>
          <target state="translated">&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout to origin으로 알려진 최신 상태로</target>
        </trans-unit>
        <trans-unit id="07207ed049130625fe302e9ca3beb10a46d2beb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; for every commit in &lt;code&gt;your-branch-rebased&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;your-branch-rebased&lt;/code&gt; 모든 커밋마다 &lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe994780fc748e95d0b566c8e6c574877a427d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; will usually change HEAD multiple times but the current branch will be updated only once.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 는 일반적으로 HEAD를 여러 번 변경하지만 현재 분기는 한 번만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="44b38faa03fcfeccb3dc48f166670c5094ecba30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will not work if you used &lt;code&gt;git reset&lt;/code&gt; during an interactive &lt;code&gt;rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; 대화식 &lt;code&gt;rebase&lt;/code&gt; 중에 &lt;code&gt;git reset&lt;/code&gt; 을 사용하면 ORIG_HEAD 가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60962f1f2e2fdc168c467a84e483c028bd28cb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In Windows, you may need to quote the reference:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Windows에서는 참조를 인용해야 할 수도 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdd0bc10d78fa9ec9a62228639ed3f30908302a3" translate="yes" xml:space="preserve">
          <source>Actually, rebase saves your starting point to &lt;code&gt;ORIG_HEAD&lt;/code&gt; so this is usually as simple as:</source>
          <target state="translated">실제로 rebase는 시작점을 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 에 저장하므로 일반적으로 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">어떤 아이디어?</target>
        </trans-unit>
        <trans-unit id="ff2182d3089c835305e268ddfc313a98127a2259" translate="yes" xml:space="preserve">
          <source>Charles's answer works, but you may want to do this:</source>
          <target state="translated">Charles의 답변은 효과가 있지만 이렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478fb09c52d9ac30db65cd8c129f2a00fa60873b" translate="yes" xml:space="preserve">
          <source>Checkout the second commit listed on the line.</source>
          <target state="translated">행에 나열된 두 번째 커밋을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="11f4b89f046872d1ad2bff120040541a670f7216" translate="yes" xml:space="preserve">
          <source>Clarification: I'm talking about a rebase during which a bunch of commits were replayed. Not only one.</source>
          <target state="translated">설명 : 나는 많은 커밋이 재생되는 rebase에 대해 이야기하고 있습니다. 하나만이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1aef15ad9f09a5d5283aabf0de4f3b326001bfea" translate="yes" xml:space="preserve">
          <source>Does anybody know how to easily undo a git rebase?</source>
          <target state="translated">누구나 git rebase를 쉽게 취소하는 방법을 알고 있습니까?</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1fa2937366e4ec50dff43ed7af243ae0b3eda8f4" translate="yes" xml:space="preserve">
          <source>Find the commit just before you started rebasing. You may need to scroll further down to find it (press Enter or PageDown). Take note of the HEAD number and replace 57:</source>
          <target state="translated">리베이스를 시작하기 직전에 커밋을 찾으십시오. 찾을 때까지 더 아래로 스크롤해야 할 수도 있습니다 (Enter 또는 PageDown 누르기). HEAD 번호를 기록하고 57을 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="7d9eba55b102479dd959077a7e1efc9adcfa2ea3" translate="yes" xml:space="preserve">
          <source>Following the solution of @Allan and @Zearin, I wish I could simply do a comment though but I don't enough reputation, so I have used the following command:</source>
          <target state="translated">@Allan과 @Zearin의 해결책에 따라 간단히 의견을 말할 수는 있지만 평판이 충분하지 않기 때문에 다음 명령을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="1702f3d4d1fec2cfc4791658c3c4bb50b0a1e0b5" translate="yes" xml:space="preserve">
          <source>For multiple commits, remember that any commit references all the history leading up to that commit. So in Charles' answer, read &quot;the old commit&quot; as &quot;the newest of the old commits&quot;. If you reset to that commit, then all the history leading up to that commit will reappear. This should do what you want.</source>
          <target state="translated">여러 커밋의 경우 커밋은 해당 커밋으로 이어지는 모든 기록을 참조합니다. 찰스의 대답에서 &quot;오래된 커밋&quot;을 &quot;가장 오래된 커밋&quot;으로 읽습니다. 해당 커밋으로 재설정하면 해당 커밋으로 이어지는 모든 기록이 다시 나타납니다. 이것은 당신이 원하는 것을해야합니다.</target>
        </trans-unit>
        <trans-unit id="b88844d33be1d8a23479b050c6cbe28dc3c37b7b" translate="yes" xml:space="preserve">
          <source>For newbies/anyone too scared of doing a hard reset, you could checkout the commit from the reflog, and then save it as a new branch.</source>
          <target state="translated">초보자 / 하드 재설정을 너무 두려워하는 사람은 reflog에서 커밋을 확인한 다음 새 분기로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe0323780eb76243a143dd02dc0455e8d2c9790a" translate="yes" xml:space="preserve">
          <source>Have fun. :-)</source>
          <target state="translated">즐기세요 :-)</target>
        </trans-unit>
        <trans-unit id="a3f9b2b97c3087b8e02f0c8af588c75399a4d9ef" translate="yes" xml:space="preserve">
          <source>However my approach strikes me as suboptimal and error-prone (let's say I had just rebased with 2 of my own branches).</source>
          <target state="translated">그러나 내 접근 방식은 차선책이고 오류가 발생하기 쉬운 것으로 나타났습니다 (방금 자신의 지점 중 2 개로 리베이스했다고 가정 해 봅시다).</target>
        </trans-unit>
        <trans-unit id="6bbeb0619c90fd9dedceca7cfea9e5bd8e41631b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; all save your original &lt;code&gt;HEAD&lt;/code&gt; pointer into &lt;code&gt;ORIG_HEAD&lt;/code&gt; so, if you've done any of those commands since the rebase you're trying to undo then you'll have to use the reflog.</source>
          <target state="translated">그러나 &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 및 &lt;code&gt;merge&lt;/code&gt; 모두 원래 &lt;code&gt;HEAD&lt;/code&gt; 포인터를 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 에 저장하므로 rebase 후 실행 취소하려는 명령을 수행 한 경우 reflog를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f86c80285262a7e2615dadf8914a3f7dec17b1ee" translate="yes" xml:space="preserve">
          <source>I actually put a backup tag on the branch before I do any nontrivial operation (most rebases are trivial, but I'd do that if it looks anywhere complex).</source>
          <target state="translated">나는 사소한 작업을 수행하기 전에 실제로 지점에 백업 태그를 넣었습니다 (대부분의 리베이스는 사소한 것이지만 복잡한 곳이면 그렇게 할 것입니다).</target>
        </trans-unit>
        <trans-unit id="27c5ea5934dfb8ad56b285a9b5d966723626d0a0" translate="yes" xml:space="preserve">
          <source>I tried all suggestions with reset and reflog without any success. Restoring local history of IntelliJ resolved the problem of lost files</source>
          <target state="translated">나는 아무런 제안없이 재설정과 reflog로 모든 제안을 시도했다. IntelliJ의 로컬 기록을 복원하면 파일 손실 문제가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="db202ee368843d004ea2dbe47e16f8b0cb7d7e2e" translate="yes" xml:space="preserve">
          <source>If you are on a branch you can use:</source>
          <target state="translated">지점에 있다면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c90536428df878e6543665a6e580136a874480" translate="yes" xml:space="preserve">
          <source>If you mess something up within a git rebase, e.g. &lt;code&gt;git rebase --abort&lt;/code&gt;, while you have uncommitted files, they will be lost and &lt;code&gt;git reflog&lt;/code&gt; will not help. This happened to me and you will need to think outside the box here. If you are lucky like me and use IntelliJ Webstorm then you can &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; and can revert to a previous state of your file/folders no matter what mistakes you have done with versioning software. It is always good to have another failsafe running.</source>
          <target state="translated">커밋되지 않은 파일이있는 동안 &lt;code&gt;git rebase --abort&lt;/code&gt; 와 같이 git rebase 내에서 무언가를 엉망으로 만들면 파일이 손실되고 &lt;code&gt;git reflog&lt;/code&gt; 가 도움이되지 않습니다. 이것은 나에게 일어 났고 당신은 상자 밖에서 생각해야합니다. 운이 좋으며 IntelliJ Webstorm을 사용하는 경우 &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; 하고 버전 관리 소프트웨어로 어떤 실수를했는지와 상관없이 파일 / 폴더의 이전 상태로 되돌릴 수 있습니다. 다른 안전 장치를 항상 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="013c48e280d48f19d4cad21390fd46a9596cb653" translate="yes" xml:space="preserve">
          <source>If you successfully rebased against remote branch and can not &lt;code&gt;git rebase --abort&lt;/code&gt; you still can do some tricks to save your work and don't have forced pushes.
Suppose your current branch that was rebased by mistake is called &lt;code&gt;your-branch&lt;/code&gt; and is tracking &lt;code&gt;origin/your-branch&lt;/code&gt;</source>
          <target state="translated">원격 브랜치를 성공적으로 리베이스하고 &lt;code&gt;git rebase --abort&lt;/code&gt; 를 수행 할 수없는 경우 여전히 작업을 저장하고 강제로 푸시하지 않는 몇 가지 트릭을 수행 할 수 있습니다. 실수로 리베이스 된 현재 지점을 지점이라고 &lt;code&gt;your-branch&lt;/code&gt; &lt;code&gt;origin/your-branch&lt;/code&gt; 지점 을 추적한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="83cc381547f8a030cf071119f534556596dbfab9" translate="yes" xml:space="preserve">
          <source>If you've not disabled per branch reflogs you should be able to simply do &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; as a rebase detaches the branch head before reattaching to the final head. I would double check this, though as I haven't verified this recently.</source>
          <target state="translated">브랜치 리플 로그 당 비활성화하지 않은 경우 리베이스가 브랜치 헤드를 분리하기 전에 &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; 을 수행하여 최종 헤드에 다시 부착 할 수 있습니다. 최근에 확인하지 않았지만 이것을 다시 확인하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6041cef935b0edda7b431f1ff958efaab1330162" translate="yes" xml:space="preserve">
          <source>In case &lt;strong&gt;you had pushed your branch to remote repository&lt;/strong&gt; (usually it's origin) and then you've done a succesfull rebase (without merge) (&lt;code&gt;git rebase --abort&lt;/code&gt; gives &quot;No rebase in progress&quot;) you can easily &lt;strong&gt;reset branch&lt;/strong&gt; using 
command:</source>
          <target state="translated">&lt;strong&gt;브랜치를 원격 저장소&lt;/strong&gt; (일반적으로 원점)로 &lt;strong&gt;푸시&lt;/strong&gt; 한 다음 성공적으로 리베이스 (병합하지 않고)를 수행 한 경우 ( &lt;code&gt;git rebase --abort&lt;/code&gt; 는 &quot;No rebase in progress 진행 중&quot;) 다음 명령을 사용하여 &lt;strong&gt;분기&lt;/strong&gt; 를 쉽게 &lt;strong&gt;재설정&lt;/strong&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e4fc2fc1d41ffbe6668cc611516884a3bff28a" translate="yes" xml:space="preserve">
          <source>In my current situation this is gonna work because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff).</source>
          <target state="translated">현재 상황에서 이것은 두 가지에서 커밋을 쉽게 찾을 수 있기 때문에 작동합니다 (하나는 내 물건이고 다른 하나는 동료의 물건이었습니다).</target>
        </trans-unit>
        <trans-unit id="6beaf2457746442d44badde4d6709cfd081329c8" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;git rebase -i --abort&lt;/code&gt;  (note the &lt;strong&gt;-i&lt;/strong&gt;) I had to simply do &lt;code&gt;git rebase --abort&lt;/code&gt; (&lt;strong&gt;without&lt;/strong&gt; the &lt;strong&gt;-i&lt;/strong&gt;).</source>
          <target state="translated">&lt;code&gt;git rebase -i --abort&lt;/code&gt; ( -i 참고) 대신 &lt;code&gt;git rebase --abort&lt;/code&gt; ( &lt;strong&gt;-i&lt;/strong&gt; &lt;strong&gt;없이&lt;/strong&gt; )를 수행해야했습니다.</target>
        </trans-unit>
        <trans-unit id="8154864319f08fa3f967d82b49989b78f65702e5" translate="yes" xml:space="preserve">
          <source>Interactive rebase for the last 31 commits (it doesn't hurt if you pick way too many).</source>
          <target state="translated">지난 31 개의 커밋에 대한 대화식 리베이스 (너무 많이 선택해도 아프지 않음).</target>
        </trans-unit>
        <trans-unit id="ce46e1e45654f64aeca93b5f6355c5284e0cbaec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you had a topic branch imaginatively called &lt;code&gt;topic&lt;/code&gt;, that you branched off &lt;code&gt;master&lt;/code&gt; when the tip of &lt;code&gt;master&lt;/code&gt; was the &lt;code&gt;0deadbeef&lt;/code&gt; commit. At some point while on the &lt;code&gt;topic&lt;/code&gt; branch, you did &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt;. Now you want to undo this. Here&amp;rsquo;s how:</source>
          <target state="translated">상상할 수있는 topic이라는 주제 브랜치를 가지고 있다고 가정 해 봅시다. &lt;code&gt;master&lt;/code&gt; 의 끝이 &lt;code&gt;0deadbeef&lt;/code&gt; commit 일 때 master에서 분기했습니다. &lt;code&gt;topic&lt;/code&gt; 지점에있는 동안 어느 시점에서 &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt; . 이제이 작업을 취소하고 싶습니다. 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64623897cf0f36a57fa3993d119f0422c2e95a5a" translate="yes" xml:space="preserve">
          <source>Let's say I rebase master to my feature branch and I get 30 new commits which break something. I've found that often it's easiest to just remove the bad commits.</source>
          <target state="translated">마스터를 기능 지점으로 리베이스하고 30 개의 새로운 커밋을 가져 와서 무언가를 깨뜨렸다 고 가정 해 봅시다. 나는 종종 나쁜 커밋을 제거하는 것이 가장 쉬운 것을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="00be5546f3e050b00b83cd1e291c22ae03377949" translate="yes" xml:space="preserve">
          <source>Now one can just cherry-pick the commits on this branch.</source>
          <target state="translated">이제이 지점에서 커밋을 체리 픽으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f290fc5ab229ace776403a7adbbcb2c5b482a03a" translate="yes" xml:space="preserve">
          <source>Now your branch should match exactly like master and rebased commits should not be in it.</source>
          <target state="translated">이제 브랜치는 마스터와 정확히 일치해야하며 리베이스 된 커밋은 그 안에 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="4c5f62df5d76cab8927c8dd3d9979cf194b289ad" translate="yes" xml:space="preserve">
          <source>Once confirmed this contained my lost changes I branched and let out a sigh of relief.</source>
          <target state="translated">이것이 내가 잃어버린 변화를 포함하고 있음을 확인하면 나는 분기하고 안도의 한숨을 내 쉬었다.</target>
        </trans-unit>
        <trans-unit id="17ac578638a77119b22a0ef0fd582d06ff78fb70" translate="yes" xml:space="preserve">
          <source>Otherwise, you may get the message &amp;ldquo;&lt;code&gt;Interactive rebase already started&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">그렇지 않으면 &quot; &lt;code&gt;Interactive rebase already started&lt;/code&gt; &quot;라는 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3edd20a694a67af267bbe0f00e744393ed23d4" translate="yes" xml:space="preserve">
          <source>Per default, all reflogs are activated for non-bare repositories:</source>
          <target state="translated">기본적으로 모든 reflog는 베어 리포지토리에 대해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="acd49b96d3638c606ba5bf332f0134bbf9f5ee3a" translate="yes" xml:space="preserve">
          <source>Resetting the branch to the dangling commit object of its old tip is of course the best solution, because it restores the previous state without expending any effort. But if you happen to have lost those commits (f.ex. because you garbage-collected your repository in the meantime, or this is a fresh clone), you can always rebase the branch again. The key to this is the &lt;code&gt;--onto&lt;/code&gt; switch.</source>
          <target state="translated">이전 팁의 댕글 링 커밋 객체로 분기를 재설정하는 것은 노력을 기울이지 않고 이전 상태를 복원하기 때문에 물론 최상의 솔루션입니다. 그러나 커밋을 잃어 버린 경우 (f.ex. 저장소를 가비지 수집했거나 새로운 복제본이기 때문에) 언제든지 브랜치를 다시 리베이스 할 수 있습니다. 이것의 핵심은 &lt;code&gt;--onto&lt;/code&gt; 스위치입니다.</target>
        </trans-unit>
        <trans-unit id="3ece396da0628e57454c25fe2253e1aa83303ce1" translate="yes" xml:space="preserve">
          <source>Review the branch/commits, if it looks good create a new branch using this HEAD:</source>
          <target state="translated">이 HEAD를 사용하여 새 분기를 작성하는 것이 좋으면 분기 / 커밋을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="879255296f2058bf0b6d20d8d4430f6c18e39c63" translate="yes" xml:space="preserve">
          <source>Simply take the commits that you want to get rid of and mark them with &quot;d&quot; instead of &quot;pick&quot;. Now the commits are deleted effectively undoing the rebase (if you remove only the commits you just got when rebasing).</source>
          <target state="translated">제거하려는 커밋을 &quot;pick&quot;대신 &quot;d&quot;로 표시하면됩니다. 이제 커밋이 효과적으로 rebase를 취소하여 삭제됩니다 (리베이스 할 때 얻은 커밋 만 제거하면).</target>
        </trans-unit>
        <trans-unit id="b4c0abfc095433426f93517b32d1d4bee8b05f36" translate="yes" xml:space="preserve">
          <source>So my previous and current branch status with this solution is:</source>
          <target state="translated">따라서이 솔루션의 이전 및 현재 지점 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="932bec474a6c74dd0900945896962bce5275e11e" translate="yes" xml:space="preserve">
          <source>Suppose the old commit was &lt;code&gt;HEAD@{5}&lt;/code&gt; in the ref log:</source>
          <target state="translated">이전 커밋이 참조 로그에 &lt;code&gt;HEAD@{5}&lt;/code&gt; 라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="98965671388f946c895ba0055c01a28612d3d89d" translate="yes" xml:space="preserve">
          <source>The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt;...</source>
          <target state="translated">가장 쉬운 방법은 &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt; 에서 rebase가 시작되기 직전의 지점의 헤드 커밋을 찾는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="ca2f30514675f9e637a20918d8d8d0f512c6f9f3" translate="yes" xml:space="preserve">
          <source>The only way that comes to mind is to go at it manually:</source>
          <target state="translated">마음에 드는 유일한 방법은 수동으로 진행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d787aca5cf568872bda4063d540b0c0046567061" translate="yes" xml:space="preserve">
          <source>Then, restoring is as easy as &lt;code&gt;git reset --hard BACKUP&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;git reset --hard BACKUP&lt;/code&gt; 만큼 쉽게 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3a988e7a60f0da5c4f9def7dee1850461b8f3b" translate="yes" xml:space="preserve">
          <source>There is not only a reference log for HEAD (obtained by &lt;code&gt;git reflog&lt;/code&gt;), there are also reflogs for each branch (obtained by &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt;). So, if you are on &lt;code&gt;master&lt;/code&gt; then &lt;code&gt;git reflog master&lt;/code&gt; will list all changes to that branch. You can refer to that changes by &lt;code&gt;master@{1}&lt;/code&gt;, &lt;code&gt;master@{2}&lt;/code&gt;, etc.</source>
          <target state="translated">HEAD에 대한 참조 로그 ( &lt;code&gt;git reflog&lt;/code&gt; 로 획득)뿐만 아니라 각 분기 ( &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt; 로 획득)에 대한 reflog도 있습니다. 따라서 &lt;code&gt;master&lt;/code&gt; 에 있으면 &lt;code&gt;git reflog master&lt;/code&gt; 는 해당 분기에 대한 모든 변경 사항을 나열합니다. &lt;code&gt;master@{1}&lt;/code&gt; , &lt;code&gt;master@{2}&lt;/code&gt; 등으로 변경 사항을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d7296e9b8d972eff9aa7a6fe60b532e90cc2b8" translate="yes" xml:space="preserve">
          <source>This will take all commits on &lt;code&gt;topic&lt;/code&gt; that aren&amp;rsquo;t on &lt;code&gt;master&lt;/code&gt; and replay them on top of &lt;code&gt;0deadbeef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 가 아닌 &lt;code&gt;topic&lt;/code&gt; 에 대한 모든 커밋을 수행하고 &lt;code&gt;0deadbeef&lt;/code&gt; 위에서 재생합니다.</target>
        </trans-unit>
        <trans-unit id="8ed4fb7ac2cf6e91b1b5e291f349f37aa053fd3f" translate="yes" xml:space="preserve">
          <source>Undoing a git rebase</source>
          <target state="translated">git rebase 실행 취소</target>
        </trans-unit>
        <trans-unit id="14cdb2f516e22d708d894150192bf04045183e7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reflog&lt;/code&gt; didn't work for me.</source>
          <target state="translated">&lt;code&gt;reflog&lt;/code&gt; 를 사용하면 효과가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="30f016f0b32997e11d4d48e324e9e27272d432f7" translate="yes" xml:space="preserve">
          <source>Using both &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;--abort&lt;/code&gt; at the same time causes Git to show me a list of usage/options.</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; 와 &lt;code&gt;--abort&lt;/code&gt; 를 동시에 사용하면 Git에서 사용법 / 옵션 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bcc55cab10be3e7ca760fd150f0ed4879593a38f" translate="yes" xml:space="preserve">
          <source>What I usually do is 
&lt;code&gt;git reset #commit_hash&lt;/code&gt;</source>
          <target state="translated">내가 보통하는 일은 &lt;code&gt;git reset #commit_hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37bf6d37f7aae92346c5eebf1b3d26301f952981" translate="yes" xml:space="preserve">
          <source>What worked for me was similar to as described &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;here&lt;/a&gt;. Open the file in .git/logs/refs named after the branch that was rebased and find the line that contains &quot;rebase finsihed&quot;, something like:</source>
          <target state="translated">나를 위해 일한 것은 &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;여기에&lt;/a&gt; 설명 된 것과 유사합니다. 리베이스 된 브랜치의 이름을 딴 .git / logs / refs에서 파일을 열고 &quot;rebase finsihed&quot;를 포함하는 라인을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4b85c64df08e0aef374566cf3e7615298c2ef6fa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--onto&lt;/code&gt;, you can rearrange your history into pretty much &lt;em&gt;any shape whatsoever&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;--onto&lt;/code&gt; 를 사용하면 역사를 거의 &lt;em&gt;모든 형태&lt;/em&gt; 로 재 배열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d6b017b1ba5cebf6c2f857689fd624eb352a14" translate="yes" xml:space="preserve">
          <source>You can check the history of the candidate old head by just doing a &lt;code&gt;git log HEAD@{5}&lt;/code&gt; (&lt;em&gt;Windows:&lt;/em&gt;&lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git log HEAD@{5}&lt;/code&gt; ( &lt;em&gt;Windows :&lt;/em&gt; &lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt; )를 수행하여 후보 이전 헤드의 히스토리를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc966eeda60ebe0e15568e6cd359e59315182be0" translate="yes" xml:space="preserve">
          <source>and to reset the current branch to it (with the usual caveats about being absolutely sure before reseting with the &lt;code&gt;--hard&lt;/code&gt; option).</source>
          <target state="translated">그리고 현재 브랜치를 그것으로 재설정합니다 ( &lt;code&gt;--hard&lt;/code&gt; 옵션으로 재설정하기 전에 절대적으로 확신하는 일반적인주의 사항).</target>
        </trans-unit>
        <trans-unit id="dc45ecc7d390f3dd103fcc1ff125d23a8f41bd83" translate="yes" xml:space="preserve">
          <source>check &lt;code&gt;git log your-branch-rebased&lt;/code&gt;, compare to &lt;code&gt;git log your-branch&lt;/code&gt; and define commits that are missing from &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git log your-branch-rebased&lt;/code&gt; 를 확인하고 git log your-branch 와 비교하고 &lt;code&gt;git log your-branch&lt;/code&gt; 에서 누락 된 커밋을 정의 &lt;code&gt;your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dffd8d007aaffc16e1e7fa638c3e9fc5a504ed5b" translate="yes" xml:space="preserve">
          <source>cherry-pick all commits by hand</source>
          <target state="translated">손으로 모든 커밋을 체리 픽</target>
        </trans-unit>
        <trans-unit id="7e9253f7b4d71c53bbd4a3bb0becbfd929dbcbfc" translate="yes" xml:space="preserve">
          <source>git checkout the commit parent to both of the branches</source>
          <target state="translated">커밋 부모를 두 가지 모두에 대해 git checkout</target>
        </trans-unit>
        <trans-unit id="7cafc9208dd98f19bb025eeb64873b839c518b8b" translate="yes" xml:space="preserve">
          <source>git reset --hard origin/{branchName}</source>
          <target state="translated">git reset --hard origin / {branchName}</target>
        </trans-unit>
        <trans-unit id="c88469e42270704f6e193e24b6da03b1cc8dae70" translate="yes" xml:space="preserve">
          <source>is the correct solution to reset all your local changes done by rebase.</source>
          <target state="translated">rebase에 의해 수행 된 모든 로컬 변경 사항을 재설정하는 올바른 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="0351ad7008e72dc467df900fc25e191599e5e545" translate="yes" xml:space="preserve">
          <source>push your changes. Please aware that two local branches are associated with &lt;code&gt;remote/your-branch&lt;/code&gt; and you should push only &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">변경 사항을 푸시하십시오. 두 지역 지점은 &lt;code&gt;remote/your-branch&lt;/code&gt; 지점과 연결되어 있으며 지점 만 밀어야합니다.</target>
        </trans-unit>
        <trans-unit id="ca128547c7a36343c630bbb370466ed768244ffb" translate="yes" xml:space="preserve">
          <source>replace the branch in which I rebased by the manually-created branch</source>
          <target state="translated">수동으로 만든 브랜치로 리베이스 한 브랜치를 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="822cc616c222af42f76cbd4f1565eabd22f79a3d" translate="yes" xml:space="preserve">
          <source>then     &lt;code&gt;git pull&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b3f96980463884649a33fec1ce240daf9b01bf" translate="yes" xml:space="preserve">
          <source>then create a temp branch from there</source>
          <target state="translated">그런 다음 거기에서 임시 지점을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="14aaf576055048f03411baac8b376b98fef14261" translate="yes" xml:space="preserve">
          <source>to clean up after the &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 후 정리합니다.</target>
        </trans-unit>
        <trans-unit id="d17835a4913bee2ba3d371cdbd9f5b9f00a7e874" translate="yes" xml:space="preserve">
          <source>to the last commit where I think rebase had no effect.</source>
          <target state="translated">rebase가 효과가 없다고 생각하는 마지막 커밋에.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
