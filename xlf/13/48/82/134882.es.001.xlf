<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/134882">
    <body>
      <group id="134882">
        <trans-unit id="485e988a7f1dbb69ea5f0a679447c4c9a7dab699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@{1}&lt;/code&gt; is simply a &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;shortcut for the current branch&lt;/a&gt;, so it's equal to &lt;code&gt;master@{1}&lt;/code&gt; if you are on &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{1}&lt;/code&gt; es simplemente un &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;acceso directo para la rama actual&lt;/a&gt; , por lo que es igual a &lt;code&gt;master@{1}&lt;/code&gt; si est&amp;aacute; en &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9bc4014689fa4baa39e8b87d2468282def86529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # rename current branch</source>
          <target state="translated">&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # renombrar rama actual</target>
        </trans-unit>
        <trans-unit id="bfda7d77b5b972fdf20ec53e82b252d4ad0fe27f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout to latest state that is known to origin</source>
          <target state="translated">&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout al &amp;uacute;ltimo estado que se conoce como origen</target>
        </trans-unit>
        <trans-unit id="07207ed049130625fe302e9ca3beb10a46d2beb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; for every commit in &lt;code&gt;your-branch-rebased&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; para cada confirmaci&amp;oacute;n en &lt;code&gt;your-branch-rebased&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe994780fc748e95d0b566c8e6c574877a427d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; will usually change HEAD multiple times but the current branch will be updated only once.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; generalmente cambiar&amp;aacute; HEAD varias veces, pero la rama actual se actualizar&amp;aacute; solo una vez.</target>
        </trans-unit>
        <trans-unit id="44b38faa03fcfeccb3dc48f166670c5094ecba30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will not work if you used &lt;code&gt;git reset&lt;/code&gt; during an interactive &lt;code&gt;rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; no funcionar&amp;aacute; si &lt;code&gt;rebase&lt;/code&gt; &lt;code&gt;git reset&lt;/code&gt; durante un rebase interactivo.</target>
        </trans-unit>
        <trans-unit id="60962f1f2e2fdc168c467a84e483c028bd28cb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In Windows, you may need to quote the reference:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;En Windows, puede que necesite citar la referencia:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdd0bc10d78fa9ec9a62228639ed3f30908302a3" translate="yes" xml:space="preserve">
          <source>Actually, rebase saves your starting point to &lt;code&gt;ORIG_HEAD&lt;/code&gt; so this is usually as simple as:</source>
          <target state="translated">En realidad, rebase guarda su punto de partida en &lt;code&gt;ORIG_HEAD&lt;/code&gt; , por lo que esto suele ser tan simple como:</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">¿Alguna idea?</target>
        </trans-unit>
        <trans-unit id="ff2182d3089c835305e268ddfc313a98127a2259" translate="yes" xml:space="preserve">
          <source>Charles's answer works, but you may want to do this:</source>
          <target state="translated">La respuesta de Charles funciona,pero tal vez quieras hacer esto:</target>
        </trans-unit>
        <trans-unit id="478fb09c52d9ac30db65cd8c129f2a00fa60873b" translate="yes" xml:space="preserve">
          <source>Checkout the second commit listed on the line.</source>
          <target state="translated">Revise el segundo compromiso que aparece en la línea.</target>
        </trans-unit>
        <trans-unit id="11f4b89f046872d1ad2bff120040541a670f7216" translate="yes" xml:space="preserve">
          <source>Clarification: I'm talking about a rebase during which a bunch of commits were replayed. Not only one.</source>
          <target state="translated">Aclaración:Hablo de un rebase durante el cual se repitieron un montón de compromisos.No sólo uno.</target>
        </trans-unit>
        <trans-unit id="1aef15ad9f09a5d5283aabf0de4f3b326001bfea" translate="yes" xml:space="preserve">
          <source>Does anybody know how to easily undo a git rebase?</source>
          <target state="translated">¿Alguien sabe cómo deshacer fácilmente una base de git?</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1fa2937366e4ec50dff43ed7af243ae0b3eda8f4" translate="yes" xml:space="preserve">
          <source>Find the commit just before you started rebasing. You may need to scroll further down to find it (press Enter or PageDown). Take note of the HEAD number and replace 57:</source>
          <target state="translated">Encuentra el compromiso justo antes de empezar a rebasar.Es posible que tenga que desplazarse más hacia abajo para encontrarlo (pulse Intro o Avance).Tome nota del número de HEAD y reemplace el 57:</target>
        </trans-unit>
        <trans-unit id="7d9eba55b102479dd959077a7e1efc9adcfa2ea3" translate="yes" xml:space="preserve">
          <source>Following the solution of @Allan and @Zearin, I wish I could simply do a comment though but I don't enough reputation, so I have used the following command:</source>
          <target state="translated">Siguiendo la solución de @Allan y @Zearin,me gustaría poder hacer simplemente un comentario,pero no tengo suficiente reputación,así que he usado el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="1702f3d4d1fec2cfc4791658c3c4bb50b0a1e0b5" translate="yes" xml:space="preserve">
          <source>For multiple commits, remember that any commit references all the history leading up to that commit. So in Charles' answer, read &quot;the old commit&quot; as &quot;the newest of the old commits&quot;. If you reset to that commit, then all the history leading up to that commit will reappear. This should do what you want.</source>
          <target state="translated">En el caso de múltiples compromisos,recuerde que cualquier compromiso hace referencia a toda la historia que ha llevado a ese compromiso.Así que en la respuesta de Charles,lee &quot;la antigua comisión&quot; como &quot;la más reciente de las antiguas comisiones&quot;.Si se reinicia esa confirmación,entonces toda la historia que condujo a esa confirmación reaparecerá.Esto debería hacer lo que quieres.</target>
        </trans-unit>
        <trans-unit id="b88844d33be1d8a23479b050c6cbe28dc3c37b7b" translate="yes" xml:space="preserve">
          <source>For newbies/anyone too scared of doing a hard reset, you could checkout the commit from the reflog, and then save it as a new branch.</source>
          <target state="translated">Para los novatos que tengan miedo de hacer un hard reset,pueden revisar el commit del reflog,y luego guardarlo como una nueva rama.</target>
        </trans-unit>
        <trans-unit id="fe0323780eb76243a143dd02dc0455e8d2c9790a" translate="yes" xml:space="preserve">
          <source>Have fun. :-)</source>
          <target state="translated">Diviértete.:-)</target>
        </trans-unit>
        <trans-unit id="a3f9b2b97c3087b8e02f0c8af588c75399a4d9ef" translate="yes" xml:space="preserve">
          <source>However my approach strikes me as suboptimal and error-prone (let's say I had just rebased with 2 of my own branches).</source>
          <target state="translated">Sin embargo,mi enfoque me parece subóptimo y propenso a errores (digamos que acababa de rebasar con 2 de mis propias ramas).</target>
        </trans-unit>
        <trans-unit id="6bbeb0619c90fd9dedceca7cfea9e5bd8e41631b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; all save your original &lt;code&gt;HEAD&lt;/code&gt; pointer into &lt;code&gt;ORIG_HEAD&lt;/code&gt; so, if you've done any of those commands since the rebase you're trying to undo then you'll have to use the reflog.</source>
          <target state="translated">Sin embargo, el &lt;code&gt;reset&lt;/code&gt; , el &lt;code&gt;rebase&lt;/code&gt; y la &lt;code&gt;merge&lt;/code&gt; guardan su puntero &lt;code&gt;HEAD&lt;/code&gt; original en &lt;code&gt;ORIG_HEAD&lt;/code&gt; , por lo tanto, si ha ejecutado alguno de esos comandos desde el rebase que intenta deshacer, deber&amp;aacute; usar el registro.</target>
        </trans-unit>
        <trans-unit id="f86c80285262a7e2615dadf8914a3f7dec17b1ee" translate="yes" xml:space="preserve">
          <source>I actually put a backup tag on the branch before I do any nontrivial operation (most rebases are trivial, but I'd do that if it looks anywhere complex).</source>
          <target state="translated">De hecho puse una etiqueta de respaldo en la rama antes de hacer cualquier operación no trivial (la mayoría de las rebases son triviales,pero lo haría si se ve en cualquier lugar complejo).</target>
        </trans-unit>
        <trans-unit id="27c5ea5934dfb8ad56b285a9b5d966723626d0a0" translate="yes" xml:space="preserve">
          <source>I tried all suggestions with reset and reflog without any success. Restoring local history of IntelliJ resolved the problem of lost files</source>
          <target state="translated">Intenté todas las sugerencias con reset y reflog sin éxito.Restaurar la historia local del IntelliJ resolvió el problema de los archivos perdidos</target>
        </trans-unit>
        <trans-unit id="db202ee368843d004ea2dbe47e16f8b0cb7d7e2e" translate="yes" xml:space="preserve">
          <source>If you are on a branch you can use:</source>
          <target state="translated">Si estás en una sucursal,puedes usarla:</target>
        </trans-unit>
        <trans-unit id="51c90536428df878e6543665a6e580136a874480" translate="yes" xml:space="preserve">
          <source>If you mess something up within a git rebase, e.g. &lt;code&gt;git rebase --abort&lt;/code&gt;, while you have uncommitted files, they will be lost and &lt;code&gt;git reflog&lt;/code&gt; will not help. This happened to me and you will need to think outside the box here. If you are lucky like me and use IntelliJ Webstorm then you can &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; and can revert to a previous state of your file/folders no matter what mistakes you have done with versioning software. It is always good to have another failsafe running.</source>
          <target state="translated">Si estropea algo dentro de un git rebase, por ejemplo, &lt;code&gt;git rebase --abort&lt;/code&gt; , mientras tenga archivos no confirmados, se perder&amp;aacute;n y &lt;code&gt;git reflog&lt;/code&gt; no ayudar&amp;aacute;. Esto me sucedi&amp;oacute; y tendr&amp;aacute;s que pensar fuera de la caja aqu&amp;iacute;. Si tiene suerte como yo y usa IntelliJ Webstorm, puede hacer &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; y puede volver al estado anterior de sus archivos / carpetas sin importar los errores que haya cometido con el software de control de versiones. Siempre es bueno tener otro funcionamiento a prueba de fallos.</target>
        </trans-unit>
        <trans-unit id="013c48e280d48f19d4cad21390fd46a9596cb653" translate="yes" xml:space="preserve">
          <source>If you successfully rebased against remote branch and can not &lt;code&gt;git rebase --abort&lt;/code&gt; you still can do some tricks to save your work and don't have forced pushes.
Suppose your current branch that was rebased by mistake is called &lt;code&gt;your-branch&lt;/code&gt; and is tracking &lt;code&gt;origin/your-branch&lt;/code&gt;</source>
          <target state="translated">Si realiz&amp;oacute; un rebase exitosamente contra una rama remota y no puede &lt;code&gt;git rebase --abort&lt;/code&gt; , a&amp;uacute;n puede hacer algunos trucos para salvar su trabajo y no tener empujes forzados. Supongamos que su rama actual que fue modificada por error se llama &lt;code&gt;your-branch&lt;/code&gt; y est&amp;aacute; rastreando &lt;code&gt;origin/your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83cc381547f8a030cf071119f534556596dbfab9" translate="yes" xml:space="preserve">
          <source>If you've not disabled per branch reflogs you should be able to simply do &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; as a rebase detaches the branch head before reattaching to the final head. I would double check this, though as I haven't verified this recently.</source>
          <target state="translated">Si no ha deshabilitado los registros de registro por rama, deber&amp;iacute;a poder simplemente hacer &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; medida que una nueva base separa el encabezado de la rama antes de volver a colocarlo en el encabezado final. Verificar&amp;iacute;a esto dos veces, aunque no lo he verificado recientemente.</target>
        </trans-unit>
        <trans-unit id="6041cef935b0edda7b431f1ff958efaab1330162" translate="yes" xml:space="preserve">
          <source>In case &lt;strong&gt;you had pushed your branch to remote repository&lt;/strong&gt; (usually it's origin) and then you've done a succesfull rebase (without merge) (&lt;code&gt;git rebase --abort&lt;/code&gt; gives &quot;No rebase in progress&quot;) you can easily &lt;strong&gt;reset branch&lt;/strong&gt; using 
command:</source>
          <target state="translated">En caso de &lt;strong&gt;que haya empujado su bifurcaci&amp;oacute;n al repositorio remoto&lt;/strong&gt; (generalmente es el origen) y luego haya realizado un rebase exitoso (sin fusi&amp;oacute;n) ( &lt;code&gt;git rebase --abort&lt;/code&gt; da &quot;No rebase en progreso&quot;), puede &lt;strong&gt;restablecer&lt;/strong&gt; f&amp;aacute;cilmente la &lt;strong&gt;bifurcaci&amp;oacute;n&lt;/strong&gt; usando el comando:</target>
        </trans-unit>
        <trans-unit id="42e4fc2fc1d41ffbe6668cc611516884a3bff28a" translate="yes" xml:space="preserve">
          <source>In my current situation this is gonna work because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff).</source>
          <target state="translated">En mi situación actual esto va a funcionar porque puedo detectar fácilmente a los commits de ambas ramas (uno era mi material,el otro era el material de mi colega).</target>
        </trans-unit>
        <trans-unit id="6beaf2457746442d44badde4d6709cfd081329c8" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;git rebase -i --abort&lt;/code&gt;  (note the &lt;strong&gt;-i&lt;/strong&gt;) I had to simply do &lt;code&gt;git rebase --abort&lt;/code&gt; (&lt;strong&gt;without&lt;/strong&gt; the &lt;strong&gt;-i&lt;/strong&gt;).</source>
          <target state="translated">En lugar de hacer &lt;code&gt;git rebase -i --abort&lt;/code&gt; (tenga en cuenta el &lt;strong&gt;-i&lt;/strong&gt; ) tuve que simplemente hacer &lt;code&gt;git rebase --abort&lt;/code&gt; ( &lt;strong&gt;sin&lt;/strong&gt; el &lt;strong&gt;-i&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="8154864319f08fa3f967d82b49989b78f65702e5" translate="yes" xml:space="preserve">
          <source>Interactive rebase for the last 31 commits (it doesn't hurt if you pick way too many).</source>
          <target state="translated">Rebase interactivo para los últimos 31 compromisos (no duele si eliges demasiados).</target>
        </trans-unit>
        <trans-unit id="ce46e1e45654f64aeca93b5f6355c5284e0cbaec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you had a topic branch imaginatively called &lt;code&gt;topic&lt;/code&gt;, that you branched off &lt;code&gt;master&lt;/code&gt; when the tip of &lt;code&gt;master&lt;/code&gt; was the &lt;code&gt;0deadbeef&lt;/code&gt; commit. At some point while on the &lt;code&gt;topic&lt;/code&gt; branch, you did &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt;. Now you want to undo this. Here&amp;rsquo;s how:</source>
          <target state="translated">Digamos que ten&amp;iacute;as una rama de tema llamada imaginariamente &lt;code&gt;topic&lt;/code&gt; , que ramificaste &lt;code&gt;master&lt;/code&gt; cuando la punta del &lt;code&gt;master&lt;/code&gt; era el commit &lt;code&gt;0deadbeef&lt;/code&gt; . En alg&amp;uacute;n momento, mientras estaba en la rama de &lt;code&gt;topic&lt;/code&gt; , &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt; . Ahora quieres deshacer esto. As&amp;iacute; es c&amp;oacute;mo:</target>
        </trans-unit>
        <trans-unit id="64623897cf0f36a57fa3993d119f0422c2e95a5a" translate="yes" xml:space="preserve">
          <source>Let's say I rebase master to my feature branch and I get 30 new commits which break something. I've found that often it's easiest to just remove the bad commits.</source>
          <target state="translated">Digamos que rebase el maestro a mi rama de características y consiga 30 nuevos compromisos que rompan algo.He descubierto que a menudo es más fácil eliminar los commits malos.</target>
        </trans-unit>
        <trans-unit id="00be5546f3e050b00b83cd1e291c22ae03377949" translate="yes" xml:space="preserve">
          <source>Now one can just cherry-pick the commits on this branch.</source>
          <target state="translated">Ahora uno puede elegir los compromisos de esta rama.</target>
        </trans-unit>
        <trans-unit id="f290fc5ab229ace776403a7adbbcb2c5b482a03a" translate="yes" xml:space="preserve">
          <source>Now your branch should match exactly like master and rebased commits should not be in it.</source>
          <target state="translated">Ahora tu rama debe coincidir exactamente con la del maestro y no debe haber commits de nuevo en ella.</target>
        </trans-unit>
        <trans-unit id="4c5f62df5d76cab8927c8dd3d9979cf194b289ad" translate="yes" xml:space="preserve">
          <source>Once confirmed this contained my lost changes I branched and let out a sigh of relief.</source>
          <target state="translated">Una vez confirmado que esto contenía mis cambios perdidos me ramifiqué y dejé escapar un suspiro de alivio.</target>
        </trans-unit>
        <trans-unit id="17ac578638a77119b22a0ef0fd582d06ff78fb70" translate="yes" xml:space="preserve">
          <source>Otherwise, you may get the message &amp;ldquo;&lt;code&gt;Interactive rebase already started&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">De lo contrario, puede recibir el mensaje &quot; &lt;code&gt;Interactive rebase already started&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="7b3edd20a694a67af267bbe0f00e744393ed23d4" translate="yes" xml:space="preserve">
          <source>Per default, all reflogs are activated for non-bare repositories:</source>
          <target state="translated">Por defecto,todos los reflogs se activan para los repositorios no desnudos:</target>
        </trans-unit>
        <trans-unit id="acd49b96d3638c606ba5bf332f0134bbf9f5ee3a" translate="yes" xml:space="preserve">
          <source>Resetting the branch to the dangling commit object of its old tip is of course the best solution, because it restores the previous state without expending any effort. But if you happen to have lost those commits (f.ex. because you garbage-collected your repository in the meantime, or this is a fresh clone), you can always rebase the branch again. The key to this is the &lt;code&gt;--onto&lt;/code&gt; switch.</source>
          <target state="translated">Restablecer la rama al objeto de confirmaci&amp;oacute;n colgante de su punta anterior es, por supuesto, la mejor soluci&amp;oacute;n, ya que restaura el estado anterior sin gastar ning&amp;uacute;n esfuerzo. Pero si por casualidad ha perdido esas confirmaciones (por ejemplo, porque recolect&amp;oacute; basura su repositorio mientras tanto, o este es un clon nuevo), siempre puede volver a cambiar la rama. La clave para esto es el interruptor &lt;code&gt;--onto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ece396da0628e57454c25fe2253e1aa83303ce1" translate="yes" xml:space="preserve">
          <source>Review the branch/commits, if it looks good create a new branch using this HEAD:</source>
          <target state="translated">Revisa los compromisos de la rama,si se ve bien crea una nueva rama usando este CABEZAL:</target>
        </trans-unit>
        <trans-unit id="879255296f2058bf0b6d20d8d4430f6c18e39c63" translate="yes" xml:space="preserve">
          <source>Simply take the commits that you want to get rid of and mark them with &quot;d&quot; instead of &quot;pick&quot;. Now the commits are deleted effectively undoing the rebase (if you remove only the commits you just got when rebasing).</source>
          <target state="translated">Simplemente toma los compromisos de los que quieres deshacerte y márcalos con una &quot;d&quot; en lugar de &quot;pick&quot;.Ahora las confirmaciones se borran efectivamente deshaciendo la base (si sólo eliminas las confirmaciones que acabas de obtener al rebasar).</target>
        </trans-unit>
        <trans-unit id="b4c0abfc095433426f93517b32d1d4bee8b05f36" translate="yes" xml:space="preserve">
          <source>So my previous and current branch status with this solution is:</source>
          <target state="translated">Así que mi estado anterior y actual de la rama con esta solución es:</target>
        </trans-unit>
        <trans-unit id="932bec474a6c74dd0900945896962bce5275e11e" translate="yes" xml:space="preserve">
          <source>Suppose the old commit was &lt;code&gt;HEAD@{5}&lt;/code&gt; in the ref log:</source>
          <target state="translated">Supongamos que la confirmaci&amp;oacute;n anterior era &lt;code&gt;HEAD@{5}&lt;/code&gt; en el registro de referencia:</target>
        </trans-unit>
        <trans-unit id="98965671388f946c895ba0055c01a28612d3d89d" translate="yes" xml:space="preserve">
          <source>The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt;...</source>
          <target state="translated">La manera m&amp;aacute;s f&amp;aacute;cil ser&amp;iacute;a encontrar el commit principal de la sucursal tal como estaba inmediatamente antes de que comenzara el &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;rebase&lt;/a&gt; en el reflog ...</target>
        </trans-unit>
        <trans-unit id="ca2f30514675f9e637a20918d8d8d0f512c6f9f3" translate="yes" xml:space="preserve">
          <source>The only way that comes to mind is to go at it manually:</source>
          <target state="translated">La única forma que se me ocurre es hacerlo manualmente:</target>
        </trans-unit>
        <trans-unit id="d787aca5cf568872bda4063d540b0c0046567061" translate="yes" xml:space="preserve">
          <source>Then, restoring is as easy as &lt;code&gt;git reset --hard BACKUP&lt;/code&gt;.</source>
          <target state="translated">Luego, la restauraci&amp;oacute;n es tan f&amp;aacute;cil como &lt;code&gt;git reset --hard BACKUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c3a988e7a60f0da5c4f9def7dee1850461b8f3b" translate="yes" xml:space="preserve">
          <source>There is not only a reference log for HEAD (obtained by &lt;code&gt;git reflog&lt;/code&gt;), there are also reflogs for each branch (obtained by &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt;). So, if you are on &lt;code&gt;master&lt;/code&gt; then &lt;code&gt;git reflog master&lt;/code&gt; will list all changes to that branch. You can refer to that changes by &lt;code&gt;master@{1}&lt;/code&gt;, &lt;code&gt;master@{2}&lt;/code&gt;, etc.</source>
          <target state="translated">No solo hay un registro de referencia para HEAD (obtenido por &lt;code&gt;git reflog&lt;/code&gt; ), tambi&amp;eacute;n hay registros de registro para cada rama (obtenido por &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt; ). Entonces, si est&amp;aacute; en el &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;git reflog master&lt;/code&gt; enumerar&amp;aacute; todos los cambios en esa rama. Puede referirse a los cambios por &lt;code&gt;master@{1}&lt;/code&gt; , &lt;code&gt;master@{2}&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="87d7296e9b8d972eff9aa7a6fe60b532e90cc2b8" translate="yes" xml:space="preserve">
          <source>This will take all commits on &lt;code&gt;topic&lt;/code&gt; that aren&amp;rsquo;t on &lt;code&gt;master&lt;/code&gt; and replay them on top of &lt;code&gt;0deadbeef&lt;/code&gt;.</source>
          <target state="translated">Esto tomar&amp;aacute; todas las confirmaciones sobre el &lt;code&gt;topic&lt;/code&gt; que no est&amp;aacute;n en el &lt;code&gt;master&lt;/code&gt; y las reproducir&amp;aacute; sobre &lt;code&gt;0deadbeef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ed4fb7ac2cf6e91b1b5e291f349f37aa053fd3f" translate="yes" xml:space="preserve">
          <source>Undoing a git rebase</source>
          <target state="translated">Deshacer una base de git</target>
        </trans-unit>
        <trans-unit id="14cdb2f516e22d708d894150192bf04045183e7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reflog&lt;/code&gt; didn't work for me.</source>
          <target state="translated">Usar &lt;code&gt;reflog&lt;/code&gt; no funcion&amp;oacute; para m&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="30f016f0b32997e11d4d48e324e9e27272d432f7" translate="yes" xml:space="preserve">
          <source>Using both &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;--abort&lt;/code&gt; at the same time causes Git to show me a list of usage/options.</source>
          <target state="translated">El uso de &lt;code&gt;-i&lt;/code&gt; y &lt;code&gt;--abort&lt;/code&gt; al mismo tiempo hace que Git me muestre una lista de uso / opciones.</target>
        </trans-unit>
        <trans-unit id="bcc55cab10be3e7ca760fd150f0ed4879593a38f" translate="yes" xml:space="preserve">
          <source>What I usually do is 
&lt;code&gt;git reset #commit_hash&lt;/code&gt;</source>
          <target state="translated">Lo que suelo hacer es &lt;code&gt;git reset #commit_hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37bf6d37f7aae92346c5eebf1b3d26301f952981" translate="yes" xml:space="preserve">
          <source>What worked for me was similar to as described &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;here&lt;/a&gt;. Open the file in .git/logs/refs named after the branch that was rebased and find the line that contains &quot;rebase finsihed&quot;, something like:</source>
          <target state="translated">Lo que funcion&amp;oacute; para m&amp;iacute; fue similar a lo que se describe &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Abra el archivo en .git / logs / refs con el nombre de la rama que se ha modificado y busque la l&amp;iacute;nea que contiene &quot;rebase finsihed&quot;, algo as&amp;iacute; como:</target>
        </trans-unit>
        <trans-unit id="4b85c64df08e0aef374566cf3e7615298c2ef6fa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--onto&lt;/code&gt;, you can rearrange your history into pretty much &lt;em&gt;any shape whatsoever&lt;/em&gt;.</source>
          <target state="translated">Con &lt;code&gt;--onto&lt;/code&gt; , puedes reorganizar tu historia en casi &lt;em&gt;cualquier forma&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="99d6b017b1ba5cebf6c2f857689fd624eb352a14" translate="yes" xml:space="preserve">
          <source>You can check the history of the candidate old head by just doing a &lt;code&gt;git log HEAD@{5}&lt;/code&gt; (&lt;em&gt;Windows:&lt;/em&gt;&lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt;).</source>
          <target state="translated">Puede verificar el historial del antiguo jefe candidato simplemente haciendo un &lt;code&gt;git log HEAD@{5}&lt;/code&gt; ( &lt;em&gt;Windows:&lt;/em&gt; &lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc966eeda60ebe0e15568e6cd359e59315182be0" translate="yes" xml:space="preserve">
          <source>and to reset the current branch to it (with the usual caveats about being absolutely sure before reseting with the &lt;code&gt;--hard&lt;/code&gt; option).</source>
          <target state="translated">y para restablecer la rama actual (con las advertencias habituales sobre estar absolutamente seguro antes de restablecer con la opci&amp;oacute;n &lt;code&gt;--hard&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc45ecc7d390f3dd103fcc1ff125d23a8f41bd83" translate="yes" xml:space="preserve">
          <source>check &lt;code&gt;git log your-branch-rebased&lt;/code&gt;, compare to &lt;code&gt;git log your-branch&lt;/code&gt; and define commits that are missing from &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">compruebe &lt;code&gt;git log your-branch-rebased&lt;/code&gt; , comp&amp;aacute;relo con &lt;code&gt;git log your-branch&lt;/code&gt; y defina los commits que faltan en &lt;code&gt;your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dffd8d007aaffc16e1e7fa638c3e9fc5a504ed5b" translate="yes" xml:space="preserve">
          <source>cherry-pick all commits by hand</source>
          <target state="translated">cherry-pick todo se compromete a mano</target>
        </trans-unit>
        <trans-unit id="7e9253f7b4d71c53bbd4a3bb0becbfd929dbcbfc" translate="yes" xml:space="preserve">
          <source>git checkout the commit parent to both of the branches</source>
          <target state="translated">git checkout the commit parent to both of the branches</target>
        </trans-unit>
        <trans-unit id="7cafc9208dd98f19bb025eeb64873b839c518b8b" translate="yes" xml:space="preserve">
          <source>git reset --hard origin/{branchName}</source>
          <target state="translated">git reset-hard origin{branchName}</target>
        </trans-unit>
        <trans-unit id="c88469e42270704f6e193e24b6da03b1cc8dae70" translate="yes" xml:space="preserve">
          <source>is the correct solution to reset all your local changes done by rebase.</source>
          <target state="translated">es la solución correcta para reajustar todos los cambios locales hechos por la base.</target>
        </trans-unit>
        <trans-unit id="0351ad7008e72dc467df900fc25e191599e5e545" translate="yes" xml:space="preserve">
          <source>push your changes. Please aware that two local branches are associated with &lt;code&gt;remote/your-branch&lt;/code&gt; and you should push only &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">empuja tus cambios. Tenga en cuenta que dos sucursales locales est&amp;aacute;n asociadas con &lt;code&gt;remote/your-branch&lt;/code&gt; y debe presionar solo &lt;code&gt;your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca128547c7a36343c630bbb370466ed768244ffb" translate="yes" xml:space="preserve">
          <source>replace the branch in which I rebased by the manually-created branch</source>
          <target state="translated">reemplazar la rama en la que me basé por la rama creada manualmente</target>
        </trans-unit>
        <trans-unit id="822cc616c222af42f76cbd4f1565eabd22f79a3d" translate="yes" xml:space="preserve">
          <source>then     &lt;code&gt;git pull&lt;/code&gt;</source>
          <target state="translated">entonces &lt;code&gt;git pull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b3f96980463884649a33fec1ce240daf9b01bf" translate="yes" xml:space="preserve">
          <source>then create a temp branch from there</source>
          <target state="translated">y luego crear una rama temporal desde allí</target>
        </trans-unit>
        <trans-unit id="14aaf576055048f03411baac8b376b98fef14261" translate="yes" xml:space="preserve">
          <source>to clean up after the &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">para limpiar despu&amp;eacute;s del &lt;code&gt;reset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d17835a4913bee2ba3d371cdbd9f5b9f00a7e874" translate="yes" xml:space="preserve">
          <source>to the last commit where I think rebase had no effect.</source>
          <target state="translated">hasta el último compromiso donde creo que la rebase no tuvo efecto.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
