<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/134882">
    <body>
      <group id="134882">
        <trans-unit id="485e988a7f1dbb69ea5f0a679447c4c9a7dab699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@{1}&lt;/code&gt; is simply a &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;shortcut for the current branch&lt;/a&gt;, so it's equal to &lt;code&gt;master@{1}&lt;/code&gt; if you are on &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{1}&lt;/code&gt; - это просто &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;ярлык для текущей ветви&lt;/a&gt; , поэтому он равен &lt;code&gt;master@{1}&lt;/code&gt; если вы используете &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9bc4014689fa4baa39e8b87d2468282def86529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # rename current branch</source>
          <target state="translated">&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # переименовать текущую ветку</target>
        </trans-unit>
        <trans-unit id="bfda7d77b5b972fdf20ec53e82b252d4ad0fe27f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout to latest state that is known to origin</source>
          <target state="translated">&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout до последнего состояния, известного как источник</target>
        </trans-unit>
        <trans-unit id="07207ed049130625fe302e9ca3beb10a46d2beb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; for every commit in &lt;code&gt;your-branch-rebased&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; для каждого коммита в &lt;code&gt;your-branch-rebased&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe994780fc748e95d0b566c8e6c574877a427d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; will usually change HEAD multiple times but the current branch will be updated only once.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; обычно меняет HEAD несколько раз, но текущая ветка будет обновляться только один раз.</target>
        </trans-unit>
        <trans-unit id="44b38faa03fcfeccb3dc48f166670c5094ecba30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will not work if you used &lt;code&gt;git reset&lt;/code&gt; during an interactive &lt;code&gt;rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; не будет работать, если вы использовали &lt;code&gt;git reset&lt;/code&gt; во время интерактивной &lt;code&gt;rebase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60962f1f2e2fdc168c467a84e483c028bd28cb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In Windows, you may need to quote the reference:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;В Windows вам может понадобиться процитировать ссылку:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdd0bc10d78fa9ec9a62228639ed3f30908302a3" translate="yes" xml:space="preserve">
          <source>Actually, rebase saves your starting point to &lt;code&gt;ORIG_HEAD&lt;/code&gt; so this is usually as simple as:</source>
          <target state="translated">На самом деле, rebase сохраняет вашу отправную точку в &lt;code&gt;ORIG_HEAD&lt;/code&gt; , поэтому обычно это так просто:</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">Есть идеи?</target>
        </trans-unit>
        <trans-unit id="ff2182d3089c835305e268ddfc313a98127a2259" translate="yes" xml:space="preserve">
          <source>Charles's answer works, but you may want to do this:</source>
          <target state="translated">Ответ Чарльза работает,но ты можешь захотеть сделать это:</target>
        </trans-unit>
        <trans-unit id="478fb09c52d9ac30db65cd8c129f2a00fa60873b" translate="yes" xml:space="preserve">
          <source>Checkout the second commit listed on the line.</source>
          <target state="translated">Проверьте второй коммит,указанный в строке.</target>
        </trans-unit>
        <trans-unit id="11f4b89f046872d1ad2bff120040541a670f7216" translate="yes" xml:space="preserve">
          <source>Clarification: I'm talking about a rebase during which a bunch of commits were replayed. Not only one.</source>
          <target state="translated">Уточнение:Я говорю о перезагрузке,во время которой была перезагружена куча коммитов.Не только один.</target>
        </trans-unit>
        <trans-unit id="1aef15ad9f09a5d5283aabf0de4f3b326001bfea" translate="yes" xml:space="preserve">
          <source>Does anybody know how to easily undo a git rebase?</source>
          <target state="translated">Кто-нибудь знает,как с легкостью отменить git-ребейз?</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1fa2937366e4ec50dff43ed7af243ae0b3eda8f4" translate="yes" xml:space="preserve">
          <source>Find the commit just before you started rebasing. You may need to scroll further down to find it (press Enter or PageDown). Take note of the HEAD number and replace 57:</source>
          <target state="translated">Найди коммит как раз перед тем,как начать перезагрузку.Возможно,вам понадобится прокрутить вниз,чтобы найти его (нажмите Enter или PageDown).Запишите номер HEAD и замените 57:</target>
        </trans-unit>
        <trans-unit id="7d9eba55b102479dd959077a7e1efc9adcfa2ea3" translate="yes" xml:space="preserve">
          <source>Following the solution of @Allan and @Zearin, I wish I could simply do a comment though but I don't enough reputation, so I have used the following command:</source>
          <target state="translated">Следуя решению @Allan и @Zearin,я хотел бы просто сделать комментарий,но мне не хватает репутации,поэтому я использовал следующую команду:</target>
        </trans-unit>
        <trans-unit id="1702f3d4d1fec2cfc4791658c3c4bb50b0a1e0b5" translate="yes" xml:space="preserve">
          <source>For multiple commits, remember that any commit references all the history leading up to that commit. So in Charles' answer, read &quot;the old commit&quot; as &quot;the newest of the old commits&quot;. If you reset to that commit, then all the history leading up to that commit will reappear. This should do what you want.</source>
          <target state="translated">Для нескольких коммитов помните,что любой коммит ссылается на всю историю,ведущую к этому коммиту.Поэтому в ответе Чарльза прочитайте &quot;старый коммит&quot; как &quot;самый новый из старых коммитов&quot;.Если вы сброситесь на этот коммит,то вся история,ведущая к этому коммиту,появится снова.Это должно делать то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="b88844d33be1d8a23479b050c6cbe28dc3c37b7b" translate="yes" xml:space="preserve">
          <source>For newbies/anyone too scared of doing a hard reset, you could checkout the commit from the reflog, and then save it as a new branch.</source>
          <target state="translated">Для новичков,которые слишком боятся делать жёсткий сброс,вы можете извлечь коммит из рефлога,а затем сохранить его как новую ветку.</target>
        </trans-unit>
        <trans-unit id="fe0323780eb76243a143dd02dc0455e8d2c9790a" translate="yes" xml:space="preserve">
          <source>Have fun. :-)</source>
          <target state="translated">Развлекайся.:-)</target>
        </trans-unit>
        <trans-unit id="a3f9b2b97c3087b8e02f0c8af588c75399a4d9ef" translate="yes" xml:space="preserve">
          <source>However my approach strikes me as suboptimal and error-prone (let's say I had just rebased with 2 of my own branches).</source>
          <target state="translated">Однако мой подход кажется мне неоптимальным и предрасположенным к ошибкам (допустим,я только что отскочил с 2 своими ветками).</target>
        </trans-unit>
        <trans-unit id="6bbeb0619c90fd9dedceca7cfea9e5bd8e41631b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; all save your original &lt;code&gt;HEAD&lt;/code&gt; pointer into &lt;code&gt;ORIG_HEAD&lt;/code&gt; so, if you've done any of those commands since the rebase you're trying to undo then you'll have to use the reflog.</source>
          <target state="translated">Тем не менее, &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; и &lt;code&gt;merge&lt;/code&gt; всех сохраняют ваш исходный указатель &lt;code&gt;HEAD&lt;/code&gt; в &lt;code&gt;ORIG_HEAD&lt;/code&gt; , поэтому, если вы выполнили какую-либо из этих команд после перебазировки, которую вы пытаетесь отменить, вам придется использовать reflog.</target>
        </trans-unit>
        <trans-unit id="f86c80285262a7e2615dadf8914a3f7dec17b1ee" translate="yes" xml:space="preserve">
          <source>I actually put a backup tag on the branch before I do any nontrivial operation (most rebases are trivial, but I'd do that if it looks anywhere complex).</source>
          <target state="translated">На самом деле я ставлю резервный тег на ветку перед тем,как делать какую-либо нетривиальную операцию (большинство отказов тривиально,но я бы сделал это,если бы это выглядело в каком-нибудь сложном месте).</target>
        </trans-unit>
        <trans-unit id="27c5ea5934dfb8ad56b285a9b5d966723626d0a0" translate="yes" xml:space="preserve">
          <source>I tried all suggestions with reset and reflog without any success. Restoring local history of IntelliJ resolved the problem of lost files</source>
          <target state="translated">Я перепробовал все предложения со сбросом и рефлогом безуспешно.Восстановление локальной истории IntelliJ решило проблему потерянных файлов.</target>
        </trans-unit>
        <trans-unit id="db202ee368843d004ea2dbe47e16f8b0cb7d7e2e" translate="yes" xml:space="preserve">
          <source>If you are on a branch you can use:</source>
          <target state="translated">Если вы находитесь на ветке,вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="51c90536428df878e6543665a6e580136a874480" translate="yes" xml:space="preserve">
          <source>If you mess something up within a git rebase, e.g. &lt;code&gt;git rebase --abort&lt;/code&gt;, while you have uncommitted files, they will be lost and &lt;code&gt;git reflog&lt;/code&gt; will not help. This happened to me and you will need to think outside the box here. If you are lucky like me and use IntelliJ Webstorm then you can &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; and can revert to a previous state of your file/folders no matter what mistakes you have done with versioning software. It is always good to have another failsafe running.</source>
          <target state="translated">Если вы что-то &lt;code&gt;git rebase --abort&lt;/code&gt; , например, git rebase --abort , пока у вас есть незафиксированные файлы, они будут потеряны, и &lt;code&gt;git reflog&lt;/code&gt; не поможет. Это случилось со мной, и вам нужно будет думать нестандартно здесь. Если вам повезло, как и мне, и вы используете IntelliJ Webstorm, то вы можете щелкнуть &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; кнопкой мыши -&amp;gt; локальную историю и вернуться к предыдущему состоянию вашего файла / папки, независимо от того, какие ошибки вы допустили при работе с версионным программным обеспечением. Всегда хорошо иметь другой отказоустойчивый запуск.</target>
        </trans-unit>
        <trans-unit id="013c48e280d48f19d4cad21390fd46a9596cb653" translate="yes" xml:space="preserve">
          <source>If you successfully rebased against remote branch and can not &lt;code&gt;git rebase --abort&lt;/code&gt; you still can do some tricks to save your work and don't have forced pushes.
Suppose your current branch that was rebased by mistake is called &lt;code&gt;your-branch&lt;/code&gt; and is tracking &lt;code&gt;origin/your-branch&lt;/code&gt;</source>
          <target state="translated">Если вы успешно &lt;code&gt;git rebase --abort&lt;/code&gt; на удаленную ветку и не можете выполнить git rebase --abort, вы все равно можете сделать некоторые трюки, чтобы сохранить свою работу и не делать принудительных нажатий. Предположим, что ваша текущая ветка, которая была перебазирована по ошибке, называется &lt;code&gt;your-branch&lt;/code&gt; и отслеживает &lt;code&gt;origin/your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83cc381547f8a030cf071119f534556596dbfab9" translate="yes" xml:space="preserve">
          <source>If you've not disabled per branch reflogs you should be able to simply do &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; as a rebase detaches the branch head before reattaching to the final head. I would double check this, though as I haven't verified this recently.</source>
          <target state="translated">Если вы не отключили повторные журналы для каждой ветви, вы можете просто выполнить &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; как ребаз отсоединяет головку ветви перед повторным подключением к конечной головке. Я бы дважды проверил это, хотя я не проверял это недавно.</target>
        </trans-unit>
        <trans-unit id="6041cef935b0edda7b431f1ff958efaab1330162" translate="yes" xml:space="preserve">
          <source>In case &lt;strong&gt;you had pushed your branch to remote repository&lt;/strong&gt; (usually it's origin) and then you've done a succesfull rebase (without merge) (&lt;code&gt;git rebase --abort&lt;/code&gt; gives &quot;No rebase in progress&quot;) you can easily &lt;strong&gt;reset branch&lt;/strong&gt; using 
command:</source>
          <target state="translated">Если &lt;strong&gt;вы перенесли ветку в удаленный репозиторий&lt;/strong&gt; (обычно это источник), а затем выполнили успешную перебазировку (без слияния) ( &lt;code&gt;git rebase --abort&lt;/code&gt; выдает &amp;laquo;Нет выполнения в процессе&amp;raquo;), вы можете легко &lt;strong&gt;сбросить ветку&lt;/strong&gt; с помощью команды:</target>
        </trans-unit>
        <trans-unit id="42e4fc2fc1d41ffbe6668cc611516884a3bff28a" translate="yes" xml:space="preserve">
          <source>In my current situation this is gonna work because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff).</source>
          <target state="translated">В моей нынешней ситуации это сработает,потому что я могу легко обнаружить коммиты из обеих ветвей (одна из них-мои вещи,другая-вещи моего коллеги).</target>
        </trans-unit>
        <trans-unit id="6beaf2457746442d44badde4d6709cfd081329c8" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;git rebase -i --abort&lt;/code&gt;  (note the &lt;strong&gt;-i&lt;/strong&gt;) I had to simply do &lt;code&gt;git rebase --abort&lt;/code&gt; (&lt;strong&gt;without&lt;/strong&gt; the &lt;strong&gt;-i&lt;/strong&gt;).</source>
          <target state="translated">Вместо того, чтобы делать &lt;code&gt;git rebase -i --abort&lt;/code&gt; (обратите внимание на &lt;strong&gt;-i&lt;/strong&gt; ), я должен был просто сделать &lt;code&gt;git rebase --abort&lt;/code&gt; ( &lt;strong&gt;без&lt;/strong&gt; &lt;strong&gt;-i&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="8154864319f08fa3f967d82b49989b78f65702e5" translate="yes" xml:space="preserve">
          <source>Interactive rebase for the last 31 commits (it doesn't hurt if you pick way too many).</source>
          <target state="translated">Интерактивный rebase для последних 31 коммитов (не повредит,если вы выберете слишком много).</target>
        </trans-unit>
        <trans-unit id="ce46e1e45654f64aeca93b5f6355c5284e0cbaec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you had a topic branch imaginatively called &lt;code&gt;topic&lt;/code&gt;, that you branched off &lt;code&gt;master&lt;/code&gt; when the tip of &lt;code&gt;master&lt;/code&gt; was the &lt;code&gt;0deadbeef&lt;/code&gt; commit. At some point while on the &lt;code&gt;topic&lt;/code&gt; branch, you did &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt;. Now you want to undo this. Here&amp;rsquo;s how:</source>
          <target state="translated">Допустим, у вас была ветвь темы с воображаемым названием &lt;code&gt;topic&lt;/code&gt; , которую вы разветвляли от &lt;code&gt;master&lt;/code&gt; , когда tip of &lt;code&gt;master&lt;/code&gt; был коммит &lt;code&gt;0deadbeef&lt;/code&gt; . В какой-то момент в ветке &lt;code&gt;topic&lt;/code&gt; вы сделали &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt; . Теперь вы хотите отменить это. Вот как:</target>
        </trans-unit>
        <trans-unit id="64623897cf0f36a57fa3993d119f0422c2e95a5a" translate="yes" xml:space="preserve">
          <source>Let's say I rebase master to my feature branch and I get 30 new commits which break something. I've found that often it's easiest to just remove the bad commits.</source>
          <target state="translated">Допустим,я возвращаю мастера в свою ветку возможностей и получаю 30 новых коммитов,которые что-то ломают.Я обнаружил,что часто проще всего просто удалить плохие коммиты.</target>
        </trans-unit>
        <trans-unit id="00be5546f3e050b00b83cd1e291c22ae03377949" translate="yes" xml:space="preserve">
          <source>Now one can just cherry-pick the commits on this branch.</source>
          <target state="translated">Теперь можно просто выбирать коммиты в этой ветке.</target>
        </trans-unit>
        <trans-unit id="f290fc5ab229ace776403a7adbbcb2c5b482a03a" translate="yes" xml:space="preserve">
          <source>Now your branch should match exactly like master and rebased commits should not be in it.</source>
          <target state="translated">Теперь ваша ветка должна совпадать точно так же,как и master,а коммиты rebased не должны быть в ней.</target>
        </trans-unit>
        <trans-unit id="4c5f62df5d76cab8927c8dd3d9979cf194b289ad" translate="yes" xml:space="preserve">
          <source>Once confirmed this contained my lost changes I branched and let out a sigh of relief.</source>
          <target state="translated">Однажды подтвердив,что это содержит мои потерянные изменения,я разветвился и вздохнул с облегчением.</target>
        </trans-unit>
        <trans-unit id="17ac578638a77119b22a0ef0fd582d06ff78fb70" translate="yes" xml:space="preserve">
          <source>Otherwise, you may get the message &amp;ldquo;&lt;code&gt;Interactive rebase already started&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">В противном случае вы можете получить сообщение &amp;laquo; &lt;code&gt;Interactive rebase already started&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7b3edd20a694a67af267bbe0f00e744393ed23d4" translate="yes" xml:space="preserve">
          <source>Per default, all reflogs are activated for non-bare repositories:</source>
          <target state="translated">По умолчанию все рефлоги активированы для небогатых репозиториев:</target>
        </trans-unit>
        <trans-unit id="acd49b96d3638c606ba5bf332f0134bbf9f5ee3a" translate="yes" xml:space="preserve">
          <source>Resetting the branch to the dangling commit object of its old tip is of course the best solution, because it restores the previous state without expending any effort. But if you happen to have lost those commits (f.ex. because you garbage-collected your repository in the meantime, or this is a fresh clone), you can always rebase the branch again. The key to this is the &lt;code&gt;--onto&lt;/code&gt; switch.</source>
          <target state="translated">Сброс ветвления к висячему объекту фиксации его старого наконечника, конечно же, является лучшим решением, поскольку он восстанавливает предыдущее состояние, не затрачивая усилий. Но если вы потеряли эти коммиты (например, потому что тем временем вы собрали мусор в своем хранилище или это новый клон), вы всегда можете перебазировать ветку снова. Ключом к этому является ключ &lt;code&gt;--onto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ece396da0628e57454c25fe2253e1aa83303ce1" translate="yes" xml:space="preserve">
          <source>Review the branch/commits, if it looks good create a new branch using this HEAD:</source>
          <target state="translated">Просмотрите ветки,если они хорошо выглядят,создайте новое ответвление,используя этот HEAD:</target>
        </trans-unit>
        <trans-unit id="879255296f2058bf0b6d20d8d4430f6c18e39c63" translate="yes" xml:space="preserve">
          <source>Simply take the commits that you want to get rid of and mark them with &quot;d&quot; instead of &quot;pick&quot;. Now the commits are deleted effectively undoing the rebase (if you remove only the commits you just got when rebasing).</source>
          <target state="translated">Просто возьмите коммиты,от которых вы хотите избавиться,и отметьте их буквой &quot;d&quot; вместо &quot;выбрать&quot;.Теперь коммиты удаляются,эффективно отменяя перебазирование (если вы удаляете только те коммиты,которые вы только что получили при перебазировании).</target>
        </trans-unit>
        <trans-unit id="b4c0abfc095433426f93517b32d1d4bee8b05f36" translate="yes" xml:space="preserve">
          <source>So my previous and current branch status with this solution is:</source>
          <target state="translated">Итак,мой предыдущий и текущий статус ветки с этим решением:</target>
        </trans-unit>
        <trans-unit id="932bec474a6c74dd0900945896962bce5275e11e" translate="yes" xml:space="preserve">
          <source>Suppose the old commit was &lt;code&gt;HEAD@{5}&lt;/code&gt; in the ref log:</source>
          <target state="translated">Предположим, что старая фиксация была &lt;code&gt;HEAD@{5}&lt;/code&gt; в журнале ссылок:</target>
        </trans-unit>
        <trans-unit id="98965671388f946c895ba0055c01a28612d3d89d" translate="yes" xml:space="preserve">
          <source>The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt;...</source>
          <target state="translated">Самым простым способом было бы найти главный коммит ветви, как это было непосредственно перед тем, как в &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt; начался ребаз ...</target>
        </trans-unit>
        <trans-unit id="ca2f30514675f9e637a20918d8d8d0f512c6f9f3" translate="yes" xml:space="preserve">
          <source>The only way that comes to mind is to go at it manually:</source>
          <target state="translated">Единственный способ,который приходит в голову-идти на это вручную:</target>
        </trans-unit>
        <trans-unit id="d787aca5cf568872bda4063d540b0c0046567061" translate="yes" xml:space="preserve">
          <source>Then, restoring is as easy as &lt;code&gt;git reset --hard BACKUP&lt;/code&gt;.</source>
          <target state="translated">Затем восстановление так же просто, как &lt;code&gt;git reset --hard BACKUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c3a988e7a60f0da5c4f9def7dee1850461b8f3b" translate="yes" xml:space="preserve">
          <source>There is not only a reference log for HEAD (obtained by &lt;code&gt;git reflog&lt;/code&gt;), there are also reflogs for each branch (obtained by &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt;). So, if you are on &lt;code&gt;master&lt;/code&gt; then &lt;code&gt;git reflog master&lt;/code&gt; will list all changes to that branch. You can refer to that changes by &lt;code&gt;master@{1}&lt;/code&gt;, &lt;code&gt;master@{2}&lt;/code&gt;, etc.</source>
          <target state="translated">Существует не только справочный журнал для HEAD (полученный с помощью &lt;code&gt;git reflog&lt;/code&gt; ), но также есть и журналы для каждой ветки (полученные с помощью &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt; ). Таким образом, если вы используете &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;git reflog master&lt;/code&gt; выведет список всех изменений в этой ветке. Вы можете ссылаться на эти изменения по &lt;code&gt;master@{1}&lt;/code&gt; , &lt;code&gt;master@{2}&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="87d7296e9b8d972eff9aa7a6fe60b532e90cc2b8" translate="yes" xml:space="preserve">
          <source>This will take all commits on &lt;code&gt;topic&lt;/code&gt; that aren&amp;rsquo;t on &lt;code&gt;master&lt;/code&gt; and replay them on top of &lt;code&gt;0deadbeef&lt;/code&gt;.</source>
          <target state="translated">Это возьмет все коммиты по &lt;code&gt;topic&lt;/code&gt; , которые не находятся на &lt;code&gt;master&lt;/code&gt; и воспроизведет их поверх &lt;code&gt;0deadbeef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ed4fb7ac2cf6e91b1b5e291f349f37aa053fd3f" translate="yes" xml:space="preserve">
          <source>Undoing a git rebase</source>
          <target state="translated">Отмена git-ребейза</target>
        </trans-unit>
        <trans-unit id="14cdb2f516e22d708d894150192bf04045183e7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reflog&lt;/code&gt; didn't work for me.</source>
          <target state="translated">Использование &lt;code&gt;reflog&lt;/code&gt; не работает для меня.</target>
        </trans-unit>
        <trans-unit id="30f016f0b32997e11d4d48e324e9e27272d432f7" translate="yes" xml:space="preserve">
          <source>Using both &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;--abort&lt;/code&gt; at the same time causes Git to show me a list of usage/options.</source>
          <target state="translated">Использование одновременно &lt;code&gt;-i&lt;/code&gt; и &lt;code&gt;--abort&lt;/code&gt; приводит к тому, что Git показывает мне список использования / опций.</target>
        </trans-unit>
        <trans-unit id="bcc55cab10be3e7ca760fd150f0ed4879593a38f" translate="yes" xml:space="preserve">
          <source>What I usually do is 
&lt;code&gt;git reset #commit_hash&lt;/code&gt;</source>
          <target state="translated">Что я обычно делаю, так это &lt;code&gt;git reset #commit_hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37bf6d37f7aae92346c5eebf1b3d26301f952981" translate="yes" xml:space="preserve">
          <source>What worked for me was similar to as described &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;here&lt;/a&gt;. Open the file in .git/logs/refs named after the branch that was rebased and find the line that contains &quot;rebase finsihed&quot;, something like:</source>
          <target state="translated">То, что работало для меня, было похоже на описанное &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;здесь&lt;/a&gt; . Откройте файл в .git / logs / refs, названном в честь перебазированной ветви, и найдите строку, содержащую &amp;laquo;rebase finsihed&amp;raquo;, что-то вроде:</target>
        </trans-unit>
        <trans-unit id="4b85c64df08e0aef374566cf3e7615298c2ef6fa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--onto&lt;/code&gt;, you can rearrange your history into pretty much &lt;em&gt;any shape whatsoever&lt;/em&gt;.</source>
          <target state="translated">С &lt;code&gt;--onto&lt;/code&gt; вы можете изменить свою историю практически в &lt;em&gt;любой форме&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="99d6b017b1ba5cebf6c2f857689fd624eb352a14" translate="yes" xml:space="preserve">
          <source>You can check the history of the candidate old head by just doing a &lt;code&gt;git log HEAD@{5}&lt;/code&gt; (&lt;em&gt;Windows:&lt;/em&gt;&lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt;).</source>
          <target state="translated">Вы можете проверить историю старого руководителя-кандидата, просто выполнив &lt;code&gt;git log HEAD@{5}&lt;/code&gt; ( &lt;em&gt;Windows:&lt;/em&gt; &lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc966eeda60ebe0e15568e6cd359e59315182be0" translate="yes" xml:space="preserve">
          <source>and to reset the current branch to it (with the usual caveats about being absolutely sure before reseting with the &lt;code&gt;--hard&lt;/code&gt; option).</source>
          <target state="translated">и сбросить текущую ветвь к нему (с обычными предостережениями о полной уверенности перед сбросом с опцией &lt;code&gt;--hard&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc45ecc7d390f3dd103fcc1ff125d23a8f41bd83" translate="yes" xml:space="preserve">
          <source>check &lt;code&gt;git log your-branch-rebased&lt;/code&gt;, compare to &lt;code&gt;git log your-branch&lt;/code&gt; and define commits that are missing from &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">проверьте &lt;code&gt;git log your-branch-rebased&lt;/code&gt; , сравните с &lt;code&gt;git log your-branch&lt;/code&gt; и определите коммиты, которые отсутствуют в &lt;code&gt;your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dffd8d007aaffc16e1e7fa638c3e9fc5a504ed5b" translate="yes" xml:space="preserve">
          <source>cherry-pick all commits by hand</source>
          <target state="translated">вишнёвый выбор всех коммитов от руки</target>
        </trans-unit>
        <trans-unit id="7e9253f7b4d71c53bbd4a3bb0becbfd929dbcbfc" translate="yes" xml:space="preserve">
          <source>git checkout the commit parent to both of the branches</source>
          <target state="translated">git извлечение родителя коммита в обеих ветках</target>
        </trans-unit>
        <trans-unit id="7cafc9208dd98f19bb025eeb64873b839c518b8b" translate="yes" xml:space="preserve">
          <source>git reset --hard origin/{branchName}</source>
          <target state="translated">сброс гита-жёсткое происхождение{название}</target>
        </trans-unit>
        <trans-unit id="c88469e42270704f6e193e24b6da03b1cc8dae70" translate="yes" xml:space="preserve">
          <source>is the correct solution to reset all your local changes done by rebase.</source>
          <target state="translated">это правильное решение для сброса всех ваших локальных изменений,сделанных с помощью rebase.</target>
        </trans-unit>
        <trans-unit id="0351ad7008e72dc467df900fc25e191599e5e545" translate="yes" xml:space="preserve">
          <source>push your changes. Please aware that two local branches are associated with &lt;code&gt;remote/your-branch&lt;/code&gt; and you should push only &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">подтолкнуть ваши изменения. Имейте в виду, что с &lt;code&gt;remote/your-branch&lt;/code&gt; связаны две локальные ветви, и вы должны использовать только &lt;code&gt;your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca128547c7a36343c630bbb370466ed768244ffb" translate="yes" xml:space="preserve">
          <source>replace the branch in which I rebased by the manually-created branch</source>
          <target state="translated">замените ветку,в которой я делал ребрендинг,на ветку,созданную вручную.</target>
        </trans-unit>
        <trans-unit id="822cc616c222af42f76cbd4f1565eabd22f79a3d" translate="yes" xml:space="preserve">
          <source>then     &lt;code&gt;git pull&lt;/code&gt;</source>
          <target state="translated">тогда &lt;code&gt;git pull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b3f96980463884649a33fec1ce240daf9b01bf" translate="yes" xml:space="preserve">
          <source>then create a temp branch from there</source>
          <target state="translated">затем создать оттуда временную ветку</target>
        </trans-unit>
        <trans-unit id="14aaf576055048f03411baac8b376b98fef14261" translate="yes" xml:space="preserve">
          <source>to clean up after the &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">очистить после &lt;code&gt;reset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d17835a4913bee2ba3d371cdbd9f5b9f00a7e874" translate="yes" xml:space="preserve">
          <source>to the last commit where I think rebase had no effect.</source>
          <target state="translated">к последнему совершению,где,я думаю,ребейз не оказал никакого эффекта.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
