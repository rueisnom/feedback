<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/134882">
    <body>
      <group id="134882">
        <trans-unit id="485e988a7f1dbb69ea5f0a679447c4c9a7dab699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@{1}&lt;/code&gt; is simply a &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;shortcut for the current branch&lt;/a&gt;, so it's equal to &lt;code&gt;master@{1}&lt;/code&gt; if you are on &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{1}&lt;/code&gt; は単に&lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;現在のブランチのショートカットであるため、&lt;/a&gt; &lt;code&gt;master@{1}&lt;/code&gt; 使用している場合はmaster @ {1}と同じです。</target>
        </trans-unit>
        <trans-unit id="e9bc4014689fa4baa39e8b87d2468282def86529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # rename current branch</source>
          <target state="translated">&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; ＃現在のブランチの名前を変更</target>
        </trans-unit>
        <trans-unit id="bfda7d77b5b972fdf20ec53e82b252d4ad0fe27f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout to latest state that is known to origin</source>
          <target state="translated">&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; ＃起点として知られている最新の状態へのチェックアウト</target>
        </trans-unit>
        <trans-unit id="07207ed049130625fe302e9ca3beb10a46d2beb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; for every commit in &lt;code&gt;your-branch-rebased&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;your-branch-rebased&lt;/code&gt; コミットごとに &lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; COMMIT_HASH</target>
        </trans-unit>
        <trans-unit id="fe994780fc748e95d0b566c8e6c574877a427d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; will usually change HEAD multiple times but the current branch will be updated only once.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; は通常HEADを複数回変更しますが、現在のブランチは一度だけ更新されます。</target>
        </trans-unit>
        <trans-unit id="44b38faa03fcfeccb3dc48f166670c5094ecba30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will not work if you used &lt;code&gt;git reset&lt;/code&gt; during an interactive &lt;code&gt;rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; は、インタラクティブな &lt;code&gt;rebase&lt;/code&gt; 中に &lt;code&gt;git reset&lt;/code&gt; を使用した場合は機能しません。</target>
        </trans-unit>
        <trans-unit id="60962f1f2e2fdc168c467a84e483c028bd28cb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In Windows, you may need to quote the reference:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Windowsでは、参照を引用する必要がある場合があります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdd0bc10d78fa9ec9a62228639ed3f30908302a3" translate="yes" xml:space="preserve">
          <source>Actually, rebase saves your starting point to &lt;code&gt;ORIG_HEAD&lt;/code&gt; so this is usually as simple as:</source>
          <target state="translated">実際、リベースは開始点を &lt;code&gt;ORIG_HEAD&lt;/code&gt; に保存するため、これは通常次のように簡単です。</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">何かアイデアは?</target>
        </trans-unit>
        <trans-unit id="ff2182d3089c835305e268ddfc313a98127a2259" translate="yes" xml:space="preserve">
          <source>Charles's answer works, but you may want to do this:</source>
          <target state="translated">シャルルの答えは効きますが、これはやっておいた方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="478fb09c52d9ac30db65cd8c129f2a00fa60873b" translate="yes" xml:space="preserve">
          <source>Checkout the second commit listed on the line.</source>
          <target state="translated">ラインに記載されているセカンドコミットをチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="11f4b89f046872d1ad2bff120040541a670f7216" translate="yes" xml:space="preserve">
          <source>Clarification: I'm talking about a rebase during which a bunch of commits were replayed. Not only one.</source>
          <target state="translated">明確にしておきます。私が話しているのは リベースのことで、その間に多くのコミットがリプレイされた。1つだけじゃない</target>
        </trans-unit>
        <trans-unit id="1aef15ad9f09a5d5283aabf0de4f3b326001bfea" translate="yes" xml:space="preserve">
          <source>Does anybody know how to easily undo a git rebase?</source>
          <target state="translated">git rebase を簡単に元に戻す方法を知っている人はいますか?</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1fa2937366e4ec50dff43ed7af243ae0b3eda8f4" translate="yes" xml:space="preserve">
          <source>Find the commit just before you started rebasing. You may need to scroll further down to find it (press Enter or PageDown). Take note of the HEAD number and replace 57:</source>
          <target state="translated">リベースを開始する直前のコミットを探してください。見つけるには、さらに下にスクロールする必要があるかもしれません (Enter キーを押すか PageDown キーを押してください)。HEAD 番号をメモして、57 に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="7d9eba55b102479dd959077a7e1efc9adcfa2ea3" translate="yes" xml:space="preserve">
          <source>Following the solution of @Allan and @Zearin, I wish I could simply do a comment though but I don't enough reputation, so I have used the following command:</source>
          <target state="translated">Allanさん、@Zearinさんの解決策に続いて、単純にコメントができればいいのですが、評価が足りないので、以下のコマンドを使っています。</target>
        </trans-unit>
        <trans-unit id="1702f3d4d1fec2cfc4791658c3c4bb50b0a1e0b5" translate="yes" xml:space="preserve">
          <source>For multiple commits, remember that any commit references all the history leading up to that commit. So in Charles' answer, read &quot;the old commit&quot; as &quot;the newest of the old commits&quot;. If you reset to that commit, then all the history leading up to that commit will reappear. This should do what you want.</source>
          <target state="translated">複数のコミットについては、どのコミットもそのコミットに至るまでのすべての履歴を参照することを覚えておいてください。ですから、Charlesさんの回答では、&quot;the old commit &quot;を &quot;the new of the old commitits &quot;と読みます。そのコミットにリセットすると、そのコミットに至るまでのすべての履歴が再表示されます。これで望み通りになるはずです。</target>
        </trans-unit>
        <trans-unit id="b88844d33be1d8a23479b050c6cbe28dc3c37b7b" translate="yes" xml:space="preserve">
          <source>For newbies/anyone too scared of doing a hard reset, you could checkout the commit from the reflog, and then save it as a new branch.</source>
          <target state="translated">ハードリセットをするのが怖くてできない初心者のために、reflogからコミットをチェックアウトして、新しいブランチとして保存しておくといいでしょう。</target>
        </trans-unit>
        <trans-unit id="fe0323780eb76243a143dd02dc0455e8d2c9790a" translate="yes" xml:space="preserve">
          <source>Have fun. :-)</source>
          <target state="translated">楽しんできてください。)</target>
        </trans-unit>
        <trans-unit id="a3f9b2b97c3087b8e02f0c8af588c75399a4d9ef" translate="yes" xml:space="preserve">
          <source>However my approach strikes me as suboptimal and error-prone (let's say I had just rebased with 2 of my own branches).</source>
          <target state="translated">しかし、私のアプローチは最適ではなく、エラーを起こしやすいものでした(自分のブランチのうち2つをリベースしただけだとしましょう)。</target>
        </trans-unit>
        <trans-unit id="6bbeb0619c90fd9dedceca7cfea9e5bd8e41631b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; all save your original &lt;code&gt;HEAD&lt;/code&gt; pointer into &lt;code&gt;ORIG_HEAD&lt;/code&gt; so, if you've done any of those commands since the rebase you're trying to undo then you'll have to use the reflog.</source>
          <target state="translated">ただし、 &lt;code&gt;reset&lt;/code&gt; 、 &lt;code&gt;rebase&lt;/code&gt; 、 &lt;code&gt;merge&lt;/code&gt; を実行すると、元の &lt;code&gt;HEAD&lt;/code&gt; ポインターが &lt;code&gt;ORIG_HEAD&lt;/code&gt; に保存されるため、元に戻そうとしているリベース以降にこれらのコマンドを実行した場合は、reflogを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f86c80285262a7e2615dadf8914a3f7dec17b1ee" translate="yes" xml:space="preserve">
          <source>I actually put a backup tag on the branch before I do any nontrivial operation (most rebases are trivial, but I'd do that if it looks anywhere complex).</source>
          <target state="translated">私は実際に、トリビアルでない操作をする前にブランチにバックアップタグを付けています(ほとんどのリベースはトリビアルですが、どこか複雑に見える場合はそうしています)。</target>
        </trans-unit>
        <trans-unit id="27c5ea5934dfb8ad56b285a9b5d966723626d0a0" translate="yes" xml:space="preserve">
          <source>I tried all suggestions with reset and reflog without any success. Restoring local history of IntelliJ resolved the problem of lost files</source>
          <target state="translated">リセットと reflog ですべての提案を試してみたが、成功しなかった。IntelliJのローカル履歴を復元すると、ファイルが失われる問題が解決しました。</target>
        </trans-unit>
        <trans-unit id="db202ee368843d004ea2dbe47e16f8b0cb7d7e2e" translate="yes" xml:space="preserve">
          <source>If you are on a branch you can use:</source>
          <target state="translated">支店にいる場合は利用できます。</target>
        </trans-unit>
        <trans-unit id="51c90536428df878e6543665a6e580136a874480" translate="yes" xml:space="preserve">
          <source>If you mess something up within a git rebase, e.g. &lt;code&gt;git rebase --abort&lt;/code&gt;, while you have uncommitted files, they will be lost and &lt;code&gt;git reflog&lt;/code&gt; will not help. This happened to me and you will need to think outside the box here. If you are lucky like me and use IntelliJ Webstorm then you can &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; and can revert to a previous state of your file/folders no matter what mistakes you have done with versioning software. It is always good to have another failsafe running.</source>
          <target state="translated">コミットされていないファイルがある間に &lt;code&gt;git rebase --abort&lt;/code&gt; などのgit rebase内で何かを台無しにすると、それらは失われ、 &lt;code&gt;git reflog&lt;/code&gt; は役に立ちません。 これは私に起こりました、そしてあなたはここで箱の外で考える必要があります。 私のように幸運でIntelliJ Webstormを使用している場合は、 &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; を使用して、バージョン管理ソフトウェアでどんなミスをしても、ファイル/フォルダーの以前の状態に戻すことができます。 別のフェイルセーフを実行することは常に良いことです。</target>
        </trans-unit>
        <trans-unit id="013c48e280d48f19d4cad21390fd46a9596cb653" translate="yes" xml:space="preserve">
          <source>If you successfully rebased against remote branch and can not &lt;code&gt;git rebase --abort&lt;/code&gt; you still can do some tricks to save your work and don't have forced pushes.
Suppose your current branch that was rebased by mistake is called &lt;code&gt;your-branch&lt;/code&gt; and is tracking &lt;code&gt;origin/your-branch&lt;/code&gt;</source>
          <target state="translated">リモートブランチに対して正常に &lt;code&gt;git rebase --abort&lt;/code&gt; 実行できない場合でも、作業を保存するためのいくつかのトリックを実行でき、強制プッシュはありません。 誤ってリベースされた現在のブランチが &lt;code&gt;your-branch&lt;/code&gt; と呼ばれ、 &lt;code&gt;origin/your-branch&lt;/code&gt; を追跡しているとします。</target>
        </trans-unit>
        <trans-unit id="83cc381547f8a030cf071119f534556596dbfab9" translate="yes" xml:space="preserve">
          <source>If you've not disabled per branch reflogs you should be able to simply do &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; as a rebase detaches the branch head before reattaching to the final head. I would double check this, though as I haven't verified this recently.</source>
          <target state="translated">ブランチごとのreflogを無効にしていない場合は、リベースが最終的なヘッドに再接続する前にブランチのヘッドを切り離すので、単に &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; を実行できるはずです。 私はこれを最近確認していないので、これを再確認します。</target>
        </trans-unit>
        <trans-unit id="6041cef935b0edda7b431f1ff958efaab1330162" translate="yes" xml:space="preserve">
          <source>In case &lt;strong&gt;you had pushed your branch to remote repository&lt;/strong&gt; (usually it's origin) and then you've done a succesfull rebase (without merge) (&lt;code&gt;git rebase --abort&lt;/code&gt; gives &quot;No rebase in progress&quot;) you can easily &lt;strong&gt;reset branch&lt;/strong&gt; using 
command:</source>
          <target state="translated">&lt;strong&gt;ブランチをリモートリポジトリ&lt;/strong&gt; （通常はオリジン）に&lt;strong&gt;プッシュし、&lt;/strong&gt;その後、成功したリベース（マージなし）を実行した場合（ &lt;code&gt;git rebase --abort&lt;/code&gt; は「No rebase in progress」を提供します）、コマンドを使用して簡単に&lt;strong&gt;ブランチ&lt;/strong&gt;を&lt;strong&gt;リセット&lt;/strong&gt;できます。</target>
        </trans-unit>
        <trans-unit id="42e4fc2fc1d41ffbe6668cc611516884a3bff28a" translate="yes" xml:space="preserve">
          <source>In my current situation this is gonna work because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff).</source>
          <target state="translated">私の現在の状況では、両方のブランチからのコミットを簡単に見つけることができるので、これはうまくいきそうです (片方は私のもの、もう片方は同僚のもの)。</target>
        </trans-unit>
        <trans-unit id="6beaf2457746442d44badde4d6709cfd081329c8" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;git rebase -i --abort&lt;/code&gt;  (note the &lt;strong&gt;-i&lt;/strong&gt;) I had to simply do &lt;code&gt;git rebase --abort&lt;/code&gt; (&lt;strong&gt;without&lt;/strong&gt; the &lt;strong&gt;-i&lt;/strong&gt;).</source>
          <target state="translated">&lt;code&gt;git rebase -i --abort&lt;/code&gt; （ -iに注意）を実行する代わりに、単に &lt;code&gt;git rebase --abort&lt;/code&gt; （ &lt;strong&gt;-i&lt;/strong&gt; &lt;strong&gt;なし&lt;/strong&gt; ）を実行する必要がありました。</target>
        </trans-unit>
        <trans-unit id="8154864319f08fa3f967d82b49989b78f65702e5" translate="yes" xml:space="preserve">
          <source>Interactive rebase for the last 31 commits (it doesn't hurt if you pick way too many).</source>
          <target state="translated">最後の31回のコミットのためのインタラクティブなリベース(それはあなたがあまりにも多くの方法を選択する場合は、それが痛いことはありません)。</target>
        </trans-unit>
        <trans-unit id="ce46e1e45654f64aeca93b5f6355c5284e0cbaec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you had a topic branch imaginatively called &lt;code&gt;topic&lt;/code&gt;, that you branched off &lt;code&gt;master&lt;/code&gt; when the tip of &lt;code&gt;master&lt;/code&gt; was the &lt;code&gt;0deadbeef&lt;/code&gt; commit. At some point while on the &lt;code&gt;topic&lt;/code&gt; branch, you did &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt;. Now you want to undo this. Here&amp;rsquo;s how:</source>
          <target state="translated">想像上の &lt;code&gt;topic&lt;/code&gt; と呼ばれるトピックブランチがあり、 &lt;code&gt;master&lt;/code&gt; の先端が &lt;code&gt;0deadbeef&lt;/code&gt; コミットであるときに &lt;code&gt;master&lt;/code&gt; から分岐したとしましょう。 &lt;code&gt;topic&lt;/code&gt; ブランチのある時点で、 &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt; 。 これを元に戻します。 方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="64623897cf0f36a57fa3993d119f0422c2e95a5a" translate="yes" xml:space="preserve">
          <source>Let's say I rebase master to my feature branch and I get 30 new commits which break something. I've found that often it's easiest to just remove the bad commits.</source>
          <target state="translated">master を自分の機能ブランチにリベースすると、何かを壊すような新しいコミットが 30 件出てきます。悪いコミットを削除するのが一番簡単だということがよくわかりました。</target>
        </trans-unit>
        <trans-unit id="00be5546f3e050b00b83cd1e291c22ae03377949" translate="yes" xml:space="preserve">
          <source>Now one can just cherry-pick the commits on this branch.</source>
          <target state="translated">これで、このブランチのコミットをさくらんぼで選ぶことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f290fc5ab229ace776403a7adbbcb2c5b482a03a" translate="yes" xml:space="preserve">
          <source>Now your branch should match exactly like master and rebased commits should not be in it.</source>
          <target state="translated">これであなたのブランチはマスターブランチと完全に一致するようになり、リベースされたコミットはその中に入れないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="4c5f62df5d76cab8927c8dd3d9979cf194b289ad" translate="yes" xml:space="preserve">
          <source>Once confirmed this contained my lost changes I branched and let out a sigh of relief.</source>
          <target state="translated">一度これが私の失われた変更が含まれていることを確認したら、私は分岐し、安堵のため息を吐き出しました。</target>
        </trans-unit>
        <trans-unit id="17ac578638a77119b22a0ef0fd582d06ff78fb70" translate="yes" xml:space="preserve">
          <source>Otherwise, you may get the message &amp;ldquo;&lt;code&gt;Interactive rebase already started&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">そうしないと、「 &lt;code&gt;Interactive rebase already started&lt;/code&gt; ます」というメッセージが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="7b3edd20a694a67af267bbe0f00e744393ed23d4" translate="yes" xml:space="preserve">
          <source>Per default, all reflogs are activated for non-bare repositories:</source>
          <target state="translated">デフォルトでは、ベアではないリポジトリに対してすべてのリフローが有効になります。</target>
        </trans-unit>
        <trans-unit id="acd49b96d3638c606ba5bf332f0134bbf9f5ee3a" translate="yes" xml:space="preserve">
          <source>Resetting the branch to the dangling commit object of its old tip is of course the best solution, because it restores the previous state without expending any effort. But if you happen to have lost those commits (f.ex. because you garbage-collected your repository in the meantime, or this is a fresh clone), you can always rebase the branch again. The key to this is the &lt;code&gt;--onto&lt;/code&gt; switch.</source>
          <target state="translated">ブランチを古いヒントのダングリングコミットオブジェクトにリセットすることは、最善の解決策です。これは、努力を費やすことなく以前の状態を復元するためです。 しかし、これらのコミットを失った場合（たとえば、リポジトリをガベージコレクションしたか、これが新しいクローンである場合など）は、いつでもブランチを再度リベースできます。 これの鍵は &lt;code&gt;--onto&lt;/code&gt; スイッチです。</target>
        </trans-unit>
        <trans-unit id="3ece396da0628e57454c25fe2253e1aa83303ce1" translate="yes" xml:space="preserve">
          <source>Review the branch/commits, if it looks good create a new branch using this HEAD:</source>
          <target state="translated">branchcommits をレビューして、良さそうならこの HEAD を使って新しいブランチを作成してください。</target>
        </trans-unit>
        <trans-unit id="879255296f2058bf0b6d20d8d4430f6c18e39c63" translate="yes" xml:space="preserve">
          <source>Simply take the commits that you want to get rid of and mark them with &quot;d&quot; instead of &quot;pick&quot;. Now the commits are deleted effectively undoing the rebase (if you remove only the commits you just got when rebasing).</source>
          <target state="translated">削除したいコミットを取り出し、&quot;pick&quot; の代わりに &quot;d&quot; でマークします。これでコミットが削除され、リベースは効果的に元に戻されます (リベース時に取得したコミットだけを削除した場合)。</target>
        </trans-unit>
        <trans-unit id="b4c0abfc095433426f93517b32d1d4bee8b05f36" translate="yes" xml:space="preserve">
          <source>So my previous and current branch status with this solution is:</source>
          <target state="translated">この解決策での私の以前の、そして現在のブランチの状況は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="932bec474a6c74dd0900945896962bce5275e11e" translate="yes" xml:space="preserve">
          <source>Suppose the old commit was &lt;code&gt;HEAD@{5}&lt;/code&gt; in the ref log:</source>
          <target state="translated">refログの古いコミットが &lt;code&gt;HEAD@{5}&lt;/code&gt; だったとします。</target>
        </trans-unit>
        <trans-unit id="98965671388f946c895ba0055c01a28612d3d89d" translate="yes" xml:space="preserve">
          <source>The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt;...</source>
          <target state="translated">最も簡単な方法は、 &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;リログがreflogで&lt;/a&gt;開始される直前だったので、ブランチのヘッドコミットを見つけることです...</target>
        </trans-unit>
        <trans-unit id="ca2f30514675f9e637a20918d8d8d0f512c6f9f3" translate="yes" xml:space="preserve">
          <source>The only way that comes to mind is to go at it manually:</source>
          <target state="translated">思いつくのは手動でやるしかない。</target>
        </trans-unit>
        <trans-unit id="d787aca5cf568872bda4063d540b0c0046567061" translate="yes" xml:space="preserve">
          <source>Then, restoring is as easy as &lt;code&gt;git reset --hard BACKUP&lt;/code&gt;.</source>
          <target state="translated">その後、復元は &lt;code&gt;git reset --hard BACKUP&lt;/code&gt; と同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="3c3a988e7a60f0da5c4f9def7dee1850461b8f3b" translate="yes" xml:space="preserve">
          <source>There is not only a reference log for HEAD (obtained by &lt;code&gt;git reflog&lt;/code&gt;), there are also reflogs for each branch (obtained by &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt;). So, if you are on &lt;code&gt;master&lt;/code&gt; then &lt;code&gt;git reflog master&lt;/code&gt; will list all changes to that branch. You can refer to that changes by &lt;code&gt;master@{1}&lt;/code&gt;, &lt;code&gt;master@{2}&lt;/code&gt;, etc.</source>
          <target state="translated">HEADの参照ログ（ &lt;code&gt;git reflog&lt;/code&gt; で取得 ）だけでなく、各ブランチのreflog（ &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt; で取得）もあります。 したがって、 &lt;code&gt;master&lt;/code&gt; を使用している場合、 &lt;code&gt;git reflog master&lt;/code&gt; はそのブランチに対するすべての変更をリストします。 その変更は &lt;code&gt;master@{1}&lt;/code&gt; 、 &lt;code&gt;master@{2}&lt;/code&gt; などで参照できます。</target>
        </trans-unit>
        <trans-unit id="87d7296e9b8d972eff9aa7a6fe60b532e90cc2b8" translate="yes" xml:space="preserve">
          <source>This will take all commits on &lt;code&gt;topic&lt;/code&gt; that aren&amp;rsquo;t on &lt;code&gt;master&lt;/code&gt; and replay them on top of &lt;code&gt;0deadbeef&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;master&lt;/code&gt; ない &lt;code&gt;topic&lt;/code&gt; すべてのコミットが取得され、 &lt;code&gt;0deadbeef&lt;/code&gt; の上で再生されます。</target>
        </trans-unit>
        <trans-unit id="8ed4fb7ac2cf6e91b1b5e291f349f37aa053fd3f" translate="yes" xml:space="preserve">
          <source>Undoing a git rebase</source>
          <target state="translated">git のリベースを元に戻す</target>
        </trans-unit>
        <trans-unit id="14cdb2f516e22d708d894150192bf04045183e7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reflog&lt;/code&gt; didn't work for me.</source>
          <target state="translated">&lt;code&gt;reflog&lt;/code&gt; を使用してもうまくいきませんでした。</target>
        </trans-unit>
        <trans-unit id="30f016f0b32997e11d4d48e324e9e27272d432f7" translate="yes" xml:space="preserve">
          <source>Using both &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;--abort&lt;/code&gt; at the same time causes Git to show me a list of usage/options.</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; と &lt;code&gt;--abort&lt;/code&gt; の両方を同時に使用すると、Gitは使用法/オプションのリストを表示します。</target>
        </trans-unit>
        <trans-unit id="bcc55cab10be3e7ca760fd150f0ed4879593a38f" translate="yes" xml:space="preserve">
          <source>What I usually do is 
&lt;code&gt;git reset #commit_hash&lt;/code&gt;</source>
          <target state="translated">私が通常やっていることは &lt;code&gt;git reset #commit_hash&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="37bf6d37f7aae92346c5eebf1b3d26301f952981" translate="yes" xml:space="preserve">
          <source>What worked for me was similar to as described &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;here&lt;/a&gt;. Open the file in .git/logs/refs named after the branch that was rebased and find the line that contains &quot;rebase finsihed&quot;, something like:</source>
          <target state="translated">私にとってうまくいったことは、 &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;ここで&lt;/a&gt;説明したものと似ていました 。 リベースされたブランチにちなんで名付けられた.git / logs / refsのファイルを開き、次のような「rebase finsihed」を含む行を見つけます。</target>
        </trans-unit>
        <trans-unit id="4b85c64df08e0aef374566cf3e7615298c2ef6fa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--onto&lt;/code&gt;, you can rearrange your history into pretty much &lt;em&gt;any shape whatsoever&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;--onto&lt;/code&gt; を使用すると、履歴をほとんど&lt;em&gt;すべての形に&lt;/em&gt;再配置できます。</target>
        </trans-unit>
        <trans-unit id="99d6b017b1ba5cebf6c2f857689fd624eb352a14" translate="yes" xml:space="preserve">
          <source>You can check the history of the candidate old head by just doing a &lt;code&gt;git log HEAD@{5}&lt;/code&gt; (&lt;em&gt;Windows:&lt;/em&gt;&lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git log HEAD@{5}&lt;/code&gt; （ &lt;em&gt;Windows：&lt;/em&gt; &lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt; ）を実行するだけで、候補の古いヘッドの履歴を確認できます 。</target>
        </trans-unit>
        <trans-unit id="fc966eeda60ebe0e15568e6cd359e59315182be0" translate="yes" xml:space="preserve">
          <source>and to reset the current branch to it (with the usual caveats about being absolutely sure before reseting with the &lt;code&gt;--hard&lt;/code&gt; option).</source>
          <target state="translated">そして、現在のブランチをそれにリセットします（ &lt;code&gt;--hard&lt;/code&gt; オプションでリセットする前に絶対的に確実であるという通常の警告があります）。</target>
        </trans-unit>
        <trans-unit id="dc45ecc7d390f3dd103fcc1ff125d23a8f41bd83" translate="yes" xml:space="preserve">
          <source>check &lt;code&gt;git log your-branch-rebased&lt;/code&gt;, compare to &lt;code&gt;git log your-branch&lt;/code&gt; and define commits that are missing from &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git log your-branch-rebased&lt;/code&gt; を確認し、 git log your-branchと比較して、 &lt;code&gt;your-branch&lt;/code&gt; にないコミットを定義してください</target>
        </trans-unit>
        <trans-unit id="dffd8d007aaffc16e1e7fa638c3e9fc5a504ed5b" translate="yes" xml:space="preserve">
          <source>cherry-pick all commits by hand</source>
          <target state="translated">手で摘み取る</target>
        </trans-unit>
        <trans-unit id="7e9253f7b4d71c53bbd4a3bb0becbfd929dbcbfc" translate="yes" xml:space="preserve">
          <source>git checkout the commit parent to both of the branches</source>
          <target state="translated">git は両方のブランチのコミットの親をチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="7cafc9208dd98f19bb025eeb64873b839c518b8b" translate="yes" xml:space="preserve">
          <source>git reset --hard origin/{branchName}</source>
          <target state="translated">git reset --hard origin{branchName}。</target>
        </trans-unit>
        <trans-unit id="c88469e42270704f6e193e24b6da03b1cc8dae70" translate="yes" xml:space="preserve">
          <source>is the correct solution to reset all your local changes done by rebase.</source>
          <target state="translated">は、リベースによって行われたローカルの変更をすべてリセットするための正しいソリューションです。</target>
        </trans-unit>
        <trans-unit id="0351ad7008e72dc467df900fc25e191599e5e545" translate="yes" xml:space="preserve">
          <source>push your changes. Please aware that two local branches are associated with &lt;code&gt;remote/your-branch&lt;/code&gt; and you should push only &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">変更をプッシュします。 2つのローカルブランチは &lt;code&gt;remote/your-branch&lt;/code&gt; ブランチに関連付けられているため &lt;code&gt;your-branch&lt;/code&gt; のみをプッシュする必要があることに注意してください</target>
        </trans-unit>
        <trans-unit id="ca128547c7a36343c630bbb370466ed768244ffb" translate="yes" xml:space="preserve">
          <source>replace the branch in which I rebased by the manually-created branch</source>
          <target state="translated">リベースしたブランチを手動で作成したブランチに置き換えます。</target>
        </trans-unit>
        <trans-unit id="822cc616c222af42f76cbd4f1565eabd22f79a3d" translate="yes" xml:space="preserve">
          <source>then     &lt;code&gt;git pull&lt;/code&gt;</source>
          <target state="translated">次に &lt;code&gt;git pull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b3f96980463884649a33fec1ce240daf9b01bf" translate="yes" xml:space="preserve">
          <source>then create a temp branch from there</source>
          <target state="translated">そして、そこから一時的なブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="14aaf576055048f03411baac8b376b98fef14261" translate="yes" xml:space="preserve">
          <source>to clean up after the &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 後にクリーンアップする。</target>
        </trans-unit>
        <trans-unit id="d17835a4913bee2ba3d371cdbd9f5b9f00a7e874" translate="yes" xml:space="preserve">
          <source>to the last commit where I think rebase had no effect.</source>
          <target state="translated">を、リベースが効かなかったと思われる最後のコミットに変更しました。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
