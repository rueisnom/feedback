<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/134882">
    <body>
      <group id="134882">
        <trans-unit id="485e988a7f1dbb69ea5f0a679447c4c9a7dab699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@{1}&lt;/code&gt; is simply a &lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;shortcut for the current branch&lt;/a&gt;, so it's equal to &lt;code&gt;master@{1}&lt;/code&gt; if you are on &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{1}&lt;/code&gt; 只是&lt;a href=&quot;https://git-scm.com/docs/gitrevisions#gitrevisions-emltngtemegem1em&quot;&gt;当前分支&lt;/a&gt;的快捷方式 ，因此，如果您在 &lt;code&gt;master&lt;/code&gt; 上，它就等于 &lt;code&gt;master@{1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9bc4014689fa4baa39e8b87d2468282def86529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; # rename current branch</source>
          <target state="translated">&lt;code&gt;git branch -m your-branch-rebased&lt;/code&gt; ＃重命名当前分支</target>
        </trans-unit>
        <trans-unit id="bfda7d77b5b972fdf20ec53e82b252d4ad0fe27f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; # checkout to latest state that is known to origin</source>
          <target state="translated">&lt;code&gt;git checkout origin/your-branch&lt;/code&gt; ＃结帐到已知的最新状态</target>
        </trans-unit>
        <trans-unit id="07207ed049130625fe302e9ca3beb10a46d2beb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; for every commit in &lt;code&gt;your-branch-rebased&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git cherry-pick COMMIT_HASH&lt;/code&gt; ,用于 &lt;code&gt;your-branch-rebased&lt;/code&gt; 每次提交</target>
        </trans-unit>
        <trans-unit id="fe994780fc748e95d0b566c8e6c574877a427d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; will usually change HEAD multiple times but the current branch will be updated only once.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 通常会多次更改HEAD，但当前分支只会更新一次。</target>
        </trans-unit>
        <trans-unit id="44b38faa03fcfeccb3dc48f166670c5094ecba30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will not work if you used &lt;code&gt;git reset&lt;/code&gt; during an interactive &lt;code&gt;rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; 如果您在交互式 &lt;code&gt;rebase&lt;/code&gt; 期间使用 &lt;code&gt;git reset&lt;/code&gt; ，将无法使用。</target>
        </trans-unit>
        <trans-unit id="60962f1f2e2fdc168c467a84e483c028bd28cb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In Windows, you may need to quote the reference:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;在Windows中，您可能需要引用以下引用：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdd0bc10d78fa9ec9a62228639ed3f30908302a3" translate="yes" xml:space="preserve">
          <source>Actually, rebase saves your starting point to &lt;code&gt;ORIG_HEAD&lt;/code&gt; so this is usually as simple as:</source>
          <target state="translated">实际上，重新设置基准会将您的起点保存到 &lt;code&gt;ORIG_HEAD&lt;/code&gt; ,因此通常很简单：</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">有什么想法吗?</target>
        </trans-unit>
        <trans-unit id="ff2182d3089c835305e268ddfc313a98127a2259" translate="yes" xml:space="preserve">
          <source>Charles's answer works, but you may want to do this:</source>
          <target state="translated">查尔斯的答案有效,但你可能想这样做。</target>
        </trans-unit>
        <trans-unit id="478fb09c52d9ac30db65cd8c129f2a00fa60873b" translate="yes" xml:space="preserve">
          <source>Checkout the second commit listed on the line.</source>
          <target state="translated">看一下第二条线上列出的承诺。</target>
        </trans-unit>
        <trans-unit id="11f4b89f046872d1ad2bff120040541a670f7216" translate="yes" xml:space="preserve">
          <source>Clarification: I'm talking about a rebase during which a bunch of commits were replayed. Not only one.</source>
          <target state="translated">澄清一下。我说的是重播期间的一次重播,期间重播了一堆投入。不仅仅是一个。</target>
        </trans-unit>
        <trans-unit id="1aef15ad9f09a5d5283aabf0de4f3b326001bfea" translate="yes" xml:space="preserve">
          <source>Does anybody know how to easily undo a git rebase?</source>
          <target state="translated">有没有人知道如何轻松解开git rebase?</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1fa2937366e4ec50dff43ed7af243ae0b3eda8f4" translate="yes" xml:space="preserve">
          <source>Find the commit just before you started rebasing. You may need to scroll further down to find it (press Enter or PageDown). Take note of the HEAD number and replace 57:</source>
          <target state="translated">在你开始rebasing之前找到提交。你可能需要再往下滚动找到它(按回车键或PageDown)。记下head号并替换成57。</target>
        </trans-unit>
        <trans-unit id="7d9eba55b102479dd959077a7e1efc9adcfa2ea3" translate="yes" xml:space="preserve">
          <source>Following the solution of @Allan and @Zearin, I wish I could simply do a comment though but I don't enough reputation, so I have used the following command:</source>
          <target state="translated">按照@Allan和@Zearin的解决方案,我希望可以简单地做一个评论,但我没有足够的声誉,所以我使用了以下命令。</target>
        </trans-unit>
        <trans-unit id="1702f3d4d1fec2cfc4791658c3c4bb50b0a1e0b5" translate="yes" xml:space="preserve">
          <source>For multiple commits, remember that any commit references all the history leading up to that commit. So in Charles' answer, read &quot;the old commit&quot; as &quot;the newest of the old commits&quot;. If you reset to that commit, then all the history leading up to that commit will reappear. This should do what you want.</source>
          <target state="translated">对于多个提交,请记住,任何提交都会引用该提交之前的所有历史记录。所以在 Charles 的回答中,将 &quot;旧提交&quot; 读作 &quot;旧提交中的最新提交&quot;。如果你重置到那个提交,那么所有的历史记录都会重新出现。这应该会达到你想要的效果。</target>
        </trans-unit>
        <trans-unit id="b88844d33be1d8a23479b050c6cbe28dc3c37b7b" translate="yes" xml:space="preserve">
          <source>For newbies/anyone too scared of doing a hard reset, you could checkout the commit from the reflog, and then save it as a new branch.</source>
          <target state="translated">对于新手来说,太害怕做一个硬重置,你可以从 reflog 中查看提交,然后将其保存为一个新的分支。</target>
        </trans-unit>
        <trans-unit id="fe0323780eb76243a143dd02dc0455e8d2c9790a" translate="yes" xml:space="preserve">
          <source>Have fun. :-)</source>
          <target state="translated">玩得开心。)</target>
        </trans-unit>
        <trans-unit id="a3f9b2b97c3087b8e02f0c8af588c75399a4d9ef" translate="yes" xml:space="preserve">
          <source>However my approach strikes me as suboptimal and error-prone (let's say I had just rebased with 2 of my own branches).</source>
          <target state="translated">然而我的方法让我觉得是次优的,而且容易出错(假设我刚刚用自己的2个分支重新建立了基础)。</target>
        </trans-unit>
        <trans-unit id="6bbeb0619c90fd9dedceca7cfea9e5bd8e41631b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; all save your original &lt;code&gt;HEAD&lt;/code&gt; pointer into &lt;code&gt;ORIG_HEAD&lt;/code&gt; so, if you've done any of those commands since the rebase you're trying to undo then you'll have to use the reflog.</source>
          <target state="translated">但是， &lt;code&gt;reset&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 和 &lt;code&gt;merge&lt;/code&gt; 都将原始 &lt;code&gt;HEAD&lt;/code&gt; 指针保存到 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 中,因此，如果自从rebase开始以来您已经执行了其中的任何命令，则必须撤消引用操作。</target>
        </trans-unit>
        <trans-unit id="f86c80285262a7e2615dadf8914a3f7dec17b1ee" translate="yes" xml:space="preserve">
          <source>I actually put a backup tag on the branch before I do any nontrivial operation (most rebases are trivial, but I'd do that if it looks anywhere complex).</source>
          <target state="translated">实际上,我在做任何非琐碎的操作之前,我都会在分支上贴上备份标签(大多数rebases都是琐碎的,但如果看起来很复杂的地方我都会这么做)。</target>
        </trans-unit>
        <trans-unit id="27c5ea5934dfb8ad56b285a9b5d966723626d0a0" translate="yes" xml:space="preserve">
          <source>I tried all suggestions with reset and reflog without any success. Restoring local history of IntelliJ resolved the problem of lost files</source>
          <target state="translated">我尝试了所有的建议,重置和重新登录都没有成功。恢复 IntelliJ的本地历史记录,解决了文件丢失的问题。</target>
        </trans-unit>
        <trans-unit id="db202ee368843d004ea2dbe47e16f8b0cb7d7e2e" translate="yes" xml:space="preserve">
          <source>If you are on a branch you can use:</source>
          <target state="translated">如果你在一个分支上,你可以使用。</target>
        </trans-unit>
        <trans-unit id="51c90536428df878e6543665a6e580136a874480" translate="yes" xml:space="preserve">
          <source>If you mess something up within a git rebase, e.g. &lt;code&gt;git rebase --abort&lt;/code&gt;, while you have uncommitted files, they will be lost and &lt;code&gt;git reflog&lt;/code&gt; will not help. This happened to me and you will need to think outside the box here. If you are lucky like me and use IntelliJ Webstorm then you can &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; and can revert to a previous state of your file/folders no matter what mistakes you have done with versioning software. It is always good to have another failsafe running.</source>
          <target state="translated">如果您在git rebase中弄乱了某些内容，例如 &lt;code&gt;git rebase --abort&lt;/code&gt; ，而您尚未提交的文件将丢失，并且 &lt;code&gt;git reflog&lt;/code&gt; 将无济于事。 这发生在我身上，您需要在这里跳出框框。 如果像我一样幸运并使用IntelliJ Webstorm，那么无论您使用版本控制软件犯了什么错误，都可以 &lt;code&gt;right-click-&amp;gt;local history&lt;/code&gt; 并可以恢复到文件/文件夹的先前状态。 再次运行故障保护总是好的。</target>
        </trans-unit>
        <trans-unit id="013c48e280d48f19d4cad21390fd46a9596cb653" translate="yes" xml:space="preserve">
          <source>If you successfully rebased against remote branch and can not &lt;code&gt;git rebase --abort&lt;/code&gt; you still can do some tricks to save your work and don't have forced pushes.
Suppose your current branch that was rebased by mistake is called &lt;code&gt;your-branch&lt;/code&gt; and is tracking &lt;code&gt;origin/your-branch&lt;/code&gt;</source>
          <target state="translated">如果您成功地针对远程分支重新建立了基础，并且无法 &lt;code&gt;git rebase --abort&lt;/code&gt; ,您仍然可以做一些技巧来保存您的工作，而不必强制执行。 假设您当前被错误地重新设置了基础 &lt;code&gt;your-branch&lt;/code&gt; 称为您的分支，并且正在跟踪 &lt;code&gt;origin/your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83cc381547f8a030cf071119f534556596dbfab9" translate="yes" xml:space="preserve">
          <source>If you've not disabled per branch reflogs you should be able to simply do &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; as a rebase detaches the branch head before reattaching to the final head. I would double check this, though as I haven't verified this recently.</source>
          <target state="translated">如果尚未对每个分支引用禁用禁用，则应该可以简单地执行 &lt;code&gt;git reflog branchname@{1}&lt;/code&gt; 因为在重新连接到最终头之前，rebase会分离分支头。 我会仔细检查，尽管最近我还没有验证。</target>
        </trans-unit>
        <trans-unit id="6041cef935b0edda7b431f1ff958efaab1330162" translate="yes" xml:space="preserve">
          <source>In case &lt;strong&gt;you had pushed your branch to remote repository&lt;/strong&gt; (usually it's origin) and then you've done a succesfull rebase (without merge) (&lt;code&gt;git rebase --abort&lt;/code&gt; gives &quot;No rebase in progress&quot;) you can easily &lt;strong&gt;reset branch&lt;/strong&gt; using 
command:</source>
          <target state="translated">如果&lt;strong&gt;您已将分支推送到远程存储库&lt;/strong&gt; （通常是它的原点），然后完成了一次成功的完全重新设置（没有合并）（ &lt;code&gt;git rebase --abort&lt;/code&gt; 给出&amp;ldquo; No rebase in progress&amp;rdquo;），则可以使用以下命令轻松&lt;strong&gt;重置分支&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="42e4fc2fc1d41ffbe6668cc611516884a3bff28a" translate="yes" xml:space="preserve">
          <source>In my current situation this is gonna work because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff).</source>
          <target state="translated">在我目前的情况下,这个方法会很管用,因为我可以很容易地从两个分支(一个是我的东西,另一个是我同事的东西)中发现提交人。</target>
        </trans-unit>
        <trans-unit id="6beaf2457746442d44badde4d6709cfd081329c8" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;git rebase -i --abort&lt;/code&gt;  (note the &lt;strong&gt;-i&lt;/strong&gt;) I had to simply do &lt;code&gt;git rebase --abort&lt;/code&gt; (&lt;strong&gt;without&lt;/strong&gt; the &lt;strong&gt;-i&lt;/strong&gt;).</source>
          <target state="translated">与其做 &lt;code&gt;git rebase -i --abort&lt;/code&gt; （注意&lt;strong&gt;-i&lt;/strong&gt; ）， &lt;code&gt;git rebase --abort&lt;/code&gt; 做git rebase --abort （ &lt;strong&gt;不&lt;/strong&gt;使用&lt;strong&gt;-i&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8154864319f08fa3f967d82b49989b78f65702e5" translate="yes" xml:space="preserve">
          <source>Interactive rebase for the last 31 commits (it doesn't hurt if you pick way too many).</source>
          <target state="translated">最近31次提交的交互式回扣(如果你选的太多也无妨)。</target>
        </trans-unit>
        <trans-unit id="ce46e1e45654f64aeca93b5f6355c5284e0cbaec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you had a topic branch imaginatively called &lt;code&gt;topic&lt;/code&gt;, that you branched off &lt;code&gt;master&lt;/code&gt; when the tip of &lt;code&gt;master&lt;/code&gt; was the &lt;code&gt;0deadbeef&lt;/code&gt; commit. At some point while on the &lt;code&gt;topic&lt;/code&gt; branch, you did &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt;. Now you want to undo this. Here&amp;rsquo;s how:</source>
          <target state="translated">假设您有一个主题分支，想象中的 &lt;code&gt;topic&lt;/code&gt; ，当 &lt;code&gt;master&lt;/code&gt; 的尖端是 &lt;code&gt;0deadbeef&lt;/code&gt; commit时，您从master分支出来。 在 &lt;code&gt;topic&lt;/code&gt; 分支上的某个时刻，您做了 &lt;code&gt;git&amp;nbsp;rebase&amp;nbsp;master&lt;/code&gt; 。 现在您要撤消此操作。 这是如何做：</target>
        </trans-unit>
        <trans-unit id="64623897cf0f36a57fa3993d119f0422c2e95a5a" translate="yes" xml:space="preserve">
          <source>Let's say I rebase master to my feature branch and I get 30 new commits which break something. I've found that often it's easiest to just remove the bad commits.</source>
          <target state="translated">假设我把 master 重启到我的功能分支中,我得到了 30 个新的提交,而这些新的提交破坏了一些东西。我发现通常情况下,最简单的方法就是删除坏的提交。</target>
        </trans-unit>
        <trans-unit id="00be5546f3e050b00b83cd1e291c22ae03377949" translate="yes" xml:space="preserve">
          <source>Now one can just cherry-pick the commits on this branch.</source>
          <target state="translated">现在,人们可以直接在这个分支上樱桃小菜一碟。</target>
        </trans-unit>
        <trans-unit id="f290fc5ab229ace776403a7adbbcb2c5b482a03a" translate="yes" xml:space="preserve">
          <source>Now your branch should match exactly like master and rebased commits should not be in it.</source>
          <target state="translated">现在你的分支应该和master完全匹配,而基于重构的提交不应该在其中。</target>
        </trans-unit>
        <trans-unit id="4c5f62df5d76cab8927c8dd3d9979cf194b289ad" translate="yes" xml:space="preserve">
          <source>Once confirmed this contained my lost changes I branched and let out a sigh of relief.</source>
          <target state="translated">一旦确认这其中包含了我失去的变化,我支支吾吾吾地发出了一声叹息。</target>
        </trans-unit>
        <trans-unit id="17ac578638a77119b22a0ef0fd582d06ff78fb70" translate="yes" xml:space="preserve">
          <source>Otherwise, you may get the message &amp;ldquo;&lt;code&gt;Interactive rebase already started&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">否则，您可能会收到消息&amp;ldquo; &lt;code&gt;Interactive rebase already started&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7b3edd20a694a67af267bbe0f00e744393ed23d4" translate="yes" xml:space="preserve">
          <source>Per default, all reflogs are activated for non-bare repositories:</source>
          <target state="translated">根据默认情况,所有的回填都会被激活,用于非备用资源库。</target>
        </trans-unit>
        <trans-unit id="acd49b96d3638c606ba5bf332f0134bbf9f5ee3a" translate="yes" xml:space="preserve">
          <source>Resetting the branch to the dangling commit object of its old tip is of course the best solution, because it restores the previous state without expending any effort. But if you happen to have lost those commits (f.ex. because you garbage-collected your repository in the meantime, or this is a fresh clone), you can always rebase the branch again. The key to this is the &lt;code&gt;--onto&lt;/code&gt; switch.</source>
          <target state="translated">将分支重置为其旧提示的悬挂提交对象当然是最好的解决方案，因为它无需花费任何精力即可恢复先前的状态。 但是，如果您恰巧丢失了这些提交（例如，因为在此期间您对存储库进行了垃圾回收，或者这是一个新的克隆），则始终可以再次为分支建立基础。 关键是 &lt;code&gt;--onto&lt;/code&gt; 开关。</target>
        </trans-unit>
        <trans-unit id="3ece396da0628e57454c25fe2253e1aa83303ce1" translate="yes" xml:space="preserve">
          <source>Review the branch/commits, if it looks good create a new branch using this HEAD:</source>
          <target state="translated">查看分支commits,如果看起来不错的话,用这个head创建一个新的分支。</target>
        </trans-unit>
        <trans-unit id="879255296f2058bf0b6d20d8d4430f6c18e39c63" translate="yes" xml:space="preserve">
          <source>Simply take the commits that you want to get rid of and mark them with &quot;d&quot; instead of &quot;pick&quot;. Now the commits are deleted effectively undoing the rebase (if you remove only the commits you just got when rebasing).</source>
          <target state="translated">只需把你想删除的提交,用 &quot;d &quot;标记,而不是 &quot;pick&quot;。现在,这些提交被删除了,可以有效地撤销重新建立的提交(如果你只删除了刚才重新建立时得到的提交)。</target>
        </trans-unit>
        <trans-unit id="b4c0abfc095433426f93517b32d1d4bee8b05f36" translate="yes" xml:space="preserve">
          <source>So my previous and current branch status with this solution is:</source>
          <target state="translated">所以,我以前和现在这个方案的分支状态是:。</target>
        </trans-unit>
        <trans-unit id="932bec474a6c74dd0900945896962bce5275e11e" translate="yes" xml:space="preserve">
          <source>Suppose the old commit was &lt;code&gt;HEAD@{5}&lt;/code&gt; in the ref log:</source>
          <target state="translated">假设参考日志中的旧提交为 &lt;code&gt;HEAD@{5}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="98965671388f946c895ba0055c01a28612d3d89d" translate="yes" xml:space="preserve">
          <source>The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the &lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt;...</source>
          <target state="translated">最简单的方法是找到分支的头提交，就像在&lt;a href=&quot;https://git-scm.com/docs/git-reflog&quot;&gt;reflog中重新&lt;/a&gt;启动基础之前一样。</target>
        </trans-unit>
        <trans-unit id="ca2f30514675f9e637a20918d8d8d0f512c6f9f3" translate="yes" xml:space="preserve">
          <source>The only way that comes to mind is to go at it manually:</source>
          <target state="translated">唯一能想到的办法,就是手动去做。</target>
        </trans-unit>
        <trans-unit id="d787aca5cf568872bda4063d540b0c0046567061" translate="yes" xml:space="preserve">
          <source>Then, restoring is as easy as &lt;code&gt;git reset --hard BACKUP&lt;/code&gt;.</source>
          <target state="translated">然后，还原就像 &lt;code&gt;git reset --hard BACKUP&lt;/code&gt; 一样容易。</target>
        </trans-unit>
        <trans-unit id="3c3a988e7a60f0da5c4f9def7dee1850461b8f3b" translate="yes" xml:space="preserve">
          <source>There is not only a reference log for HEAD (obtained by &lt;code&gt;git reflog&lt;/code&gt;), there are also reflogs for each branch (obtained by &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt;). So, if you are on &lt;code&gt;master&lt;/code&gt; then &lt;code&gt;git reflog master&lt;/code&gt; will list all changes to that branch. You can refer to that changes by &lt;code&gt;master@{1}&lt;/code&gt;, &lt;code&gt;master@{2}&lt;/code&gt;, etc.</source>
          <target state="translated">不仅有HEAD的参考日志（由 &lt;code&gt;git reflog&lt;/code&gt; 获得），而且每个分支都有 &lt;code&gt;git reflog &amp;lt;branch&amp;gt;&lt;/code&gt; （由git reflog &amp;lt;branch&amp;gt;获得 ）。 因此，如果您在 &lt;code&gt;master&lt;/code&gt; 上,则 &lt;code&gt;git reflog master&lt;/code&gt; 将列出对该分支的所有更改。 您可以通过 &lt;code&gt;master@{1}&lt;/code&gt; ， &lt;code&gt;master@{2}&lt;/code&gt; 等引用这些更改。</target>
        </trans-unit>
        <trans-unit id="87d7296e9b8d972eff9aa7a6fe60b532e90cc2b8" translate="yes" xml:space="preserve">
          <source>This will take all commits on &lt;code&gt;topic&lt;/code&gt; that aren&amp;rsquo;t on &lt;code&gt;master&lt;/code&gt; and replay them on top of &lt;code&gt;0deadbeef&lt;/code&gt;.</source>
          <target state="translated">这将接受不在 &lt;code&gt;master&lt;/code&gt; 上的所有 &lt;code&gt;topic&lt;/code&gt; 提交，并在 &lt;code&gt;0deadbeef&lt;/code&gt; 之上重播它们。</target>
        </trans-unit>
        <trans-unit id="8ed4fb7ac2cf6e91b1b5e291f349f37aa053fd3f" translate="yes" xml:space="preserve">
          <source>Undoing a git rebase</source>
          <target state="translated">撤销git rebbase</target>
        </trans-unit>
        <trans-unit id="14cdb2f516e22d708d894150192bf04045183e7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reflog&lt;/code&gt; didn't work for me.</source>
          <target state="translated">使用 &lt;code&gt;reflog&lt;/code&gt; 对我不起作用。</target>
        </trans-unit>
        <trans-unit id="30f016f0b32997e11d4d48e324e9e27272d432f7" translate="yes" xml:space="preserve">
          <source>Using both &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;--abort&lt;/code&gt; at the same time causes Git to show me a list of usage/options.</source>
          <target state="translated">同时使用 &lt;code&gt;-i&lt;/code&gt; 和 &lt;code&gt;--abort&lt;/code&gt; 会使Git向我显示使用/选项列表。</target>
        </trans-unit>
        <trans-unit id="bcc55cab10be3e7ca760fd150f0ed4879593a38f" translate="yes" xml:space="preserve">
          <source>What I usually do is 
&lt;code&gt;git reset #commit_hash&lt;/code&gt;</source>
          <target state="translated">我通常要做的是 &lt;code&gt;git reset #commit_hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37bf6d37f7aae92346c5eebf1b3d26301f952981" translate="yes" xml:space="preserve">
          <source>What worked for me was similar to as described &lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;here&lt;/a&gt;. Open the file in .git/logs/refs named after the branch that was rebased and find the line that contains &quot;rebase finsihed&quot;, something like:</source>
          <target state="translated">对我有用的类似于&lt;a href=&quot;http://www.bluemangolearning.com/blog/2009/03/recovering-from-a-disastrous-git-rebase-mistake/&quot;&gt;此处&lt;/a&gt;所述。 在.git / logs / refs中打开文件，该文件以已重新建立分支的名称命名，然后找到包含&amp;ldquo; rebase finsihed&amp;rdquo;的行，如下所示：</target>
        </trans-unit>
        <trans-unit id="4b85c64df08e0aef374566cf3e7615298c2ef6fa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--onto&lt;/code&gt;, you can rearrange your history into pretty much &lt;em&gt;any shape whatsoever&lt;/em&gt;.</source>
          <target state="translated">使用 &lt;code&gt;--onto&lt;/code&gt; ，您可以将历史记录重新排列成几乎&lt;em&gt;任何形状&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="99d6b017b1ba5cebf6c2f857689fd624eb352a14" translate="yes" xml:space="preserve">
          <source>You can check the history of the candidate old head by just doing a &lt;code&gt;git log HEAD@{5}&lt;/code&gt; (&lt;em&gt;Windows:&lt;/em&gt;&lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt;).</source>
          <target state="translated">您可以通过执行 &lt;code&gt;git log HEAD@{5}&lt;/code&gt; （ &lt;em&gt;Windows：&lt;/em&gt; &lt;code&gt;git log &quot;HEAD@{5}&quot;&lt;/code&gt; ）来检查候选旧头的历史。</target>
        </trans-unit>
        <trans-unit id="fc966eeda60ebe0e15568e6cd359e59315182be0" translate="yes" xml:space="preserve">
          <source>and to reset the current branch to it (with the usual caveats about being absolutely sure before reseting with the &lt;code&gt;--hard&lt;/code&gt; option).</source>
          <target state="translated">并将其重置为当前分支（通常的警告是在使用 &lt;code&gt;--hard&lt;/code&gt; 选项进行重置之前必须绝对确定）。</target>
        </trans-unit>
        <trans-unit id="dc45ecc7d390f3dd103fcc1ff125d23a8f41bd83" translate="yes" xml:space="preserve">
          <source>check &lt;code&gt;git log your-branch-rebased&lt;/code&gt;, compare to &lt;code&gt;git log your-branch&lt;/code&gt; and define commits that are missing from &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">检查 &lt;code&gt;git log your-branch-rebased&lt;/code&gt; ，与 &lt;code&gt;git log your-branch&lt;/code&gt; 进行比较，并定义分支中缺少的提交</target>
        </trans-unit>
        <trans-unit id="dffd8d007aaffc16e1e7fa638c3e9fc5a504ed5b" translate="yes" xml:space="preserve">
          <source>cherry-pick all commits by hand</source>
          <target state="translated">偷工减料</target>
        </trans-unit>
        <trans-unit id="7e9253f7b4d71c53bbd4a3bb0becbfd929dbcbfc" translate="yes" xml:space="preserve">
          <source>git checkout the commit parent to both of the branches</source>
          <target state="translated">git检查出这两个分支的提交父分支</target>
        </trans-unit>
        <trans-unit id="7cafc9208dd98f19bb025eeb64873b839c518b8b" translate="yes" xml:space="preserve">
          <source>git reset --hard origin/{branchName}</source>
          <target state="translated">git reset --hard origin{branchName}</target>
        </trans-unit>
        <trans-unit id="c88469e42270704f6e193e24b6da03b1cc8dae70" translate="yes" xml:space="preserve">
          <source>is the correct solution to reset all your local changes done by rebase.</source>
          <target state="translated">是重置所有本地更改的正确解决方案。</target>
        </trans-unit>
        <trans-unit id="0351ad7008e72dc467df900fc25e191599e5e545" translate="yes" xml:space="preserve">
          <source>push your changes. Please aware that two local branches are associated with &lt;code&gt;remote/your-branch&lt;/code&gt; and you should push only &lt;code&gt;your-branch&lt;/code&gt;</source>
          <target state="translated">推动您的更改。 请注意，两个本地分支与 &lt;code&gt;remote/your-branch&lt;/code&gt; 相关联，您应该只推送 &lt;code&gt;your-branch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca128547c7a36343c630bbb370466ed768244ffb" translate="yes" xml:space="preserve">
          <source>replace the branch in which I rebased by the manually-created branch</source>
          <target state="translated">替换为手动创建的分支,并将其中的分支替换为手动创建的分支。</target>
        </trans-unit>
        <trans-unit id="822cc616c222af42f76cbd4f1565eabd22f79a3d" translate="yes" xml:space="preserve">
          <source>then     &lt;code&gt;git pull&lt;/code&gt;</source>
          <target state="translated">然后 &lt;code&gt;git pull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b3f96980463884649a33fec1ce240daf9b01bf" translate="yes" xml:space="preserve">
          <source>then create a temp branch from there</source>
          <target state="translated">然后从那里创建一个临时分支</target>
        </trans-unit>
        <trans-unit id="14aaf576055048f03411baac8b376b98fef14261" translate="yes" xml:space="preserve">
          <source>to clean up after the &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 后清理。</target>
        </trans-unit>
        <trans-unit id="d17835a4913bee2ba3d371cdbd9f5b9f00a7e874" translate="yes" xml:space="preserve">
          <source>to the last commit where I think rebase had no effect.</source>
          <target state="translated">到最后一次提交,我认为rebase没有任何影响。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
