<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1313120">
    <body>
      <group id="1313120">
        <trans-unit id="bc2f74c22f98f7b6ffbc2f67453dbfa99bce9a32" translate="yes" xml:space="preserve">
          <source>**</source>
          <target state="translated">**</target>
        </trans-unit>
        <trans-unit id="8f645513ffa73d44a4fa5de5330055f3be40b1c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.mysqlperformanceblog.com/2009/09/12/3-ways-mysql-uses-indexes&quot;&gt;3 ways MySQL uses indexes&lt;/a&gt; is a great article to understand some details.</source>
          <target state="translated">&lt;a href=&quot;http://www.mysqlperformanceblog.com/2009/09/12/3-ways-mysql-uses-indexes&quot;&gt;MySQLがインデックスを使用する3つの方法&lt;/a&gt;は、詳細を理解するための優れた記事です。</target>
        </trans-unit>
        <trans-unit id="6b5f5c3163b44cfb577f7102eba674dc7dead525" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This should work both on MySQL and SQL Server.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;これはMySQLとSQL Serverの両方で機能するはずです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ef7cf3995e5d790678b807a725ee0318ff9bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UPD: 2017-03-31, the version &lt;a href=&quot;https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html#mysqld-5-7-5-sql-mode&quot;&gt;5.7.5&lt;/a&gt; of MySQL made the ONLY_FULL_GROUP_BY switch enabled by default (hence, non-deterministic GROUP BY queries became disabled). Moreover, they updated the GROUP BY implementation and the solution might not work as expected anymore even with the disabled switch. One needs to check.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UPD：2017-03-31、MySQLのバージョン&lt;a href=&quot;https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html#mysqld-5-7-5-sql-mode&quot;&gt;5.7.5&lt;/a&gt;によりONLY_FULL_GROUP_BYスイッチがデフォルトで有効になりました（そのため、非決定的なGROUP BYクエリは無効になりました）。&lt;/em&gt; &lt;em&gt;さらに、彼らはGROUP BY実装を更新し、無効化されたスイッチを使用しても、ソリューションが期待どおりに機能しない可能性があります。&lt;/em&gt; &lt;em&gt;確認する必要があります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4aeaa617d0d40556e2ebfbac11a9c7b612cae76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Hi, this query might help :&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;こんにちは、このクエリは役立つかもしれません：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cba4951ffd2b51c76d331e5a3fa3e6ec9193fef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実施例4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c36ab90a22beaab321d017be889526e748936ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e534f76560839fac49d71827900280961455f692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実施例6&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4417dba7c1c0db0f0da450df72fc6aaf8bffcf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実施例7&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ebec6ad107992984e17ccecc97ed3cab85a50b7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FIRST SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最初のソリューション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="096e3dd5b45fc3fbad6172ee5bcf27f1ee5f8f15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First using the technique &lt;a href=&quot;https://stackoverflow.com/questions/1313120/sql-retrieving-the-last-record-in-each-group/1313140#1313140&quot;&gt;shown&lt;/a&gt; by @Eric with the &lt;code&gt;GROUP BY&lt;/code&gt; in a subquery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;まず、サブクエリで &lt;code&gt;GROUP BY&lt;/code&gt; を使用して@Ericが&lt;a href=&quot;https://stackoverflow.com/questions/1313120/sql-retrieving-the-last-record-in-each-group/1313140#1313140&quot;&gt;示す&lt;/a&gt;手法を使用します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d66c96ef877ff9a09a1b6092e2d693638bc51369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now produce the same query result using &lt;a href=&quot;https://stackoverflow.com/questions/121387/fetch-the-row-which-has-the-max-value-for-a-column/123481#123481&quot;&gt;my technique&lt;/a&gt; with &lt;code&gt;LEFT JOIN&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;LEFT JOIN&lt;/code&gt; を使用した&lt;a href=&quot;https://stackoverflow.com/questions/121387/fetch-the-row-which-has-the-max-value-for-a-column/123481#123481&quot;&gt;私のテクニック&lt;/a&gt;を使用して 、同じクエリ結果を生成します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba65d8c19571d88f28ec5b5c980e23acc73041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;QUERY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;QUERY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7f8a11139f03cf3b0c8e2a9df85a2ae32908607" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SECOND SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2番目のソリューション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21aa429fd1f960433948c85037e5c8a8b7b989ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;解決策1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="386b462eb4b8c11b6ed2f186c1638cabe4ee6309" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;解決策2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff9929d19b9080a8ccd6f1a2254225e9d9fbe50e" translate="yes" xml:space="preserve">
          <source>Above query will group the all the &lt;code&gt;Other_Columns&lt;/code&gt; that are in same &lt;code&gt;Name&lt;/code&gt; group  and using &lt;code&gt;ORDER BY id DESC&lt;/code&gt; will join all the &lt;code&gt;Other_Columns&lt;/code&gt; in a specific group in descending order  with the provided separator in my case i have used &lt;code&gt;||&lt;/code&gt; ,using &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; over this list will pick the first one</source>
          <target state="translated">上記のクエリは、同じ &lt;code&gt;Name&lt;/code&gt; グループにあるすべての &lt;code&gt;Other_Columns&lt;/code&gt; をグループ化し、 &lt;code&gt;ORDER BY id DESC&lt;/code&gt; を使用すると、特定のグループ内のすべての &lt;code&gt;Other_Columns&lt;/code&gt; が降順で結合されます。 、このリストで &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; を使用すると、最初のリストが選択されます</target>
        </trans-unit>
        <trans-unit id="f4f69c12f5f097c3bc85d1c305639e5e3bd817e5" translate="yes" xml:space="preserve">
          <source>An approach with considerable speed is as follows.</source>
          <target state="translated">かなりのスピードでのアプローチは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6ffa51cbbf5cad2672d34a40acf2a210fc73291d" translate="yes" xml:space="preserve">
          <source>Another approach :</source>
          <target state="translated">別のアプローチ。</target>
        </trans-unit>
        <trans-unit id="5895da138d7bad5c473af20dabff9e769de91aee" translate="yes" xml:space="preserve">
          <source>As this data is random it means that multiple rows can have the same recordedTimestamps. What we want is to get a list of all of the selected groups in order of groupID with the last recordedTimestamp for each group, and if the same group has more than one matching row like that then the last matching id of those rows.</source>
          <target state="translated">このデータはランダムなので、複数の行が同じRecordedTimestampを持つことができることを意味します。選択されたグループのリストをgroupIDの順に取得し、各グループの最後の記録されたTimestampを取得し、同じグループに複数の行がある場合は、それらの行の最後のIDを取得します。</target>
        </trans-unit>
        <trans-unit id="fa9ea7afc562036e3828d246e9208813dd89e863" translate="yes" xml:space="preserve">
          <source>At present, this is the query that I use:</source>
          <target state="translated">今のところ、私が使っているクエリはこれです。</target>
        </trans-unit>
        <trans-unit id="52af234919e0864d5be789ce9e9966fa719f0fdf" translate="yes" xml:space="preserve">
          <source>Below is the original answer I wrote for this question in 2009:</source>
          <target state="translated">以下は、2009年にこの質問に対して私が書いたオリジナルの回答です。</target>
        </trans-unit>
        <trans-unit id="dfa20b2c64f084967f88e2b30b428496e758d2ce" translate="yes" xml:space="preserve">
          <source>Bill Karwin's solution above works fine when item count within groups is rather small, but the performance of the query becomes bad when the groups are rather large, since the solution requires about &lt;code&gt;n*n/2 + n/2&lt;/code&gt; of only &lt;code&gt;IS NULL&lt;/code&gt; comparisons.</source>
          <target state="translated">上記のビルカーウィンのソリューションは、グループ内のアイテム数がかなり少ない場合は問題なく機能しますが、グループがかなり大きい場合は、ソリューションが約 &lt;code&gt;n*n/2 + n/2&lt;/code&gt; の &lt;code&gt;IS NULL&lt;/code&gt; 比較しか必要としないため、クエリのパフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="bd4c066734a8ad4492b0a6e00d4fd47414089358" translate="yes" xml:space="preserve">
          <source>Bill's solution has already been running for several hours on my dell e4310 and I do not know when it is going to finish even though it operates on a coverage index (hence &lt;code&gt;using index&lt;/code&gt; in EXPLAIN).</source>
          <target state="translated">ビルのソリューションはすでにデルe4310で数時間実行されており、カバレッジインデックス（したがってEXPLAINの &lt;code&gt;using index&lt;/code&gt; を使用）で動作しているのに、いつ終了するかわかりません。</target>
        </trans-unit>
        <trans-unit id="a540b9b8692c7398481e1d0a45488fe1cb97fc95" translate="yes" xml:space="preserve">
          <source>But the results we get back from this query is.</source>
          <target state="translated">しかし、このクエリから得られる結果は</target>
        </trans-unit>
        <trans-unit id="409b3a6cc20c0128a69a6b5836d7b3c4dd161adb" translate="yes" xml:space="preserve">
          <source>But this looks highly inefficient. Any other ways to achieve the same result?</source>
          <target state="translated">しかし、これは非常に効率が悪そうです。他にも同じ結果になる方法はありますか?</target>
        </trans-unit>
        <trans-unit id="dfa6620c99e58e7436201c6184ee2ca49c84b834" translate="yes" xml:space="preserve">
          <source>Clearly there are lots of different ways of getting the same results, your question seems to be what is an efficient way of getting the last results in each group in MySQL. If you are working with huge amounts of data and assuming you are using InnoDB with even the latest versions of MySQL (such as 5.7.21 and 8.0.4-rc) then there might not be an efficient way of doing this.</source>
          <target state="translated">同じ結果を得る方法はたくさんありますが、あなたの質問は、MySQLの各グループの最後の結果を得る効率的な方法は何かということのようです。膨大な量のデータを扱う場合や、MySQLの最新バージョン(5.7.21や8.0.4-rcなど)でもInnoDBを使用していることを想定している場合は、効率的な方法はないかもしれません。</target>
        </trans-unit>
        <trans-unit id="0e6166e0885a4e9c3b9b6dc26f6c33ee9c6b158c" translate="yes" xml:space="preserve">
          <source>EDIT: Think i found the solution:</source>
          <target state="translated">EDIT:解決策を見つけました。</target>
        </trans-unit>
        <trans-unit id="da752519d3c02bfcbee192fe71cb5d1c2afba9fc" translate="yes" xml:space="preserve">
          <source>Even the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&quot;&gt;&lt;code&gt;EXPLAIN&lt;/code&gt; analysis&lt;/a&gt; takes over 16 seconds:</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&quot;&gt; &lt;code&gt;EXPLAIN&lt;/code&gt; 分析で&lt;/a&gt;さえ16秒以上かかります：</target>
        </trans-unit>
        <trans-unit id="9ab63eeb4d0745316d2eee1767dd903b98520f3c" translate="yes" xml:space="preserve">
          <source>Fiddle Demo</source>
          <target state="translated">フィドルデモ</target>
        </trans-unit>
        <trans-unit id="b7e5708f1f87ff99a200942c6f52c205533b087c" translate="yes" xml:space="preserve">
          <source>Find the propertie with the max m2_price withing each program (n properties in 1 program) :</source>
          <target state="translated">各プログラムの中で最大 m2_price を持つ物件を探します (1 つのプログラムの中で n 個の物件)。</target>
        </trans-unit>
        <trans-unit id="159d4ff95f68b8d2bd154edd020461cb5caf121d" translate="yes" xml:space="preserve">
          <source>For example, I have a copy of the &lt;a href=&quot;https://archive.org/details/stackexchange&quot;&gt;StackOverflow August data dump&lt;/a&gt;.  I'll use that for benchmarking.  There are 1,114,357 rows in the &lt;code&gt;Posts&lt;/code&gt; table.  This is running on &lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt; 5.0.75 on my Macbook Pro 2.40GHz.</source>
          <target state="translated">たとえば、 &lt;a href=&quot;https://archive.org/details/stackexchange&quot;&gt;StackOverflowのAugustデータダンプの&lt;/a&gt;コピーがあります。 これをベンチマークに使用します。 &lt;code&gt;Posts&lt;/code&gt; テーブルには1,114,357行あります。 これは、Macbook Pro 2.40GHzの&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt; 5.0.75で実行されています 。</target>
        </trans-unit>
        <trans-unit id="b17d6e4ca90fd7b884da8ccc58edeeefcae86e04" translate="yes" xml:space="preserve">
          <source>For these examples I will use data with only about 1.5 million rows where the queries would need to find results for all groups in the data. In our actual cases we would often need to return back data from about 2,000 groups (which hypothetically would not require examining very much of the data).</source>
          <target state="translated">これらの例では、約150万行のデータを使用し、クエリはデータ内のすべてのグループの結果を検索する必要があります。実際のケースでは、多くの場合、約2,000グループのデータを返す必要があります(これは仮説上、あまり多くのデータを調べる必要はありません)。</target>
        </trans-unit>
        <trans-unit id="87d03384f44b47a879deeda44b7ac84af6c50aec" translate="yes" xml:space="preserve">
          <source>Here are two suggestions.  First, if mysql supports ROW_NUMBER(), it's very simple:</source>
          <target state="translated">ここで2つの提案があります。まず、mysqlがROW_NUMBER()をサポートしている場合、それは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="6c7b5efaecd6bf9fd8ebaf569dd613771dfd1d37" translate="yes" xml:space="preserve">
          <source>Here is another solution that takes about 19 seconds for my table:</source>
          <target state="translated">ここに、私のテーブルに約19秒かかる別のソリューションがあります。</target>
        </trans-unit>
        <trans-unit id="91f7e27f60625062718026b18b9e89832af53376" translate="yes" xml:space="preserve">
          <source>Here is another way to get the last related record using &lt;code&gt;GROUP_CONCAT&lt;/code&gt; with order by and &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; to pick one of the record from the list</source>
          <target state="translated">以下は、 &lt;code&gt;GROUP_CONCAT&lt;/code&gt; を使用して最後の関連レコードを取得する別の方法です。ORDERBYおよび &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; を使用して、リストからレコードの1つを選択します。</target>
        </trans-unit>
        <trans-unit id="6a0ac753b84f68190035e002ff7c3d92847813ee" translate="yes" xml:space="preserve">
          <source>Here is my solution:</source>
          <target state="translated">これが私の解決策です。</target>
        </trans-unit>
        <trans-unit id="b93bfb210dc14c88784f9e875260957b2d19e337" translate="yes" xml:space="preserve">
          <source>Here's the DDL for my &lt;code&gt;Posts&lt;/code&gt; table:</source>
          <target state="translated">これが私の &lt;code&gt;Posts&lt;/code&gt; テーブルのDDLです。</target>
        </trans-unit>
        <trans-unit id="6b43694db01032ca975a3ee122be4c0ac567c042" translate="yes" xml:space="preserve">
          <source>Hi @Vijay Dev if your table &lt;strong&gt;messages&lt;/strong&gt; contains &lt;strong&gt;Id&lt;/strong&gt; which is auto increment primary key then to fetch the latest record basis on the primary key your query should read as below:</source>
          <target state="translated">こんにちは@Vijay Devテーブル&lt;strong&gt;メッセージ&lt;/strong&gt;に主キーの自動インクリメントである&lt;strong&gt;Id&lt;/strong&gt;が含まれている場合、主キーに基づいて最新のレコードを取得するには、クエリは次のように読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="7b7402d87ff4654cdcf49d6ce05c1a115c8ccdc7" translate="yes" xml:space="preserve">
          <source>Hope below Oracle query can help:</source>
          <target state="translated">以下のOracleクエリは助けることができる希望。</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">これはどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="056165c6f3e12f6a33964cf8f0af752642c0aab9" translate="yes" xml:space="preserve">
          <source>However MySQL does not have this so let's look at different ideas of what it does have and prove that none of these are efficient.</source>
          <target state="translated">しかし、MySQLにはこのような機能はありませんので、MySQLが持っている機能についていろいろな考えを見て、どれも効率的ではないことを証明してみましょう。</target>
        </trans-unit>
        <trans-unit id="d85b71d6929ce27f94649bf0418056833e4ab04f" translate="yes" xml:space="preserve">
          <source>I arrived at a different solution, which is to get the IDs for the last post within each group, then select from the messages table using the result from the first query as the argument for a &lt;code&gt;WHERE x IN&lt;/code&gt; construct:</source>
          <target state="translated">各グループ内の最後の投稿のIDを取得し、最初のクエリの結果を &lt;code&gt;WHERE x IN&lt;/code&gt; 構成の引数として使用してメッセージテーブルから選択するという、別のソリューションに到達しました。</target>
        </trans-unit>
        <trans-unit id="2f758943b374e2de01a29386e7186bc2832d669e" translate="yes" xml:space="preserve">
          <source>I don't know how this performs compared to some of the other solutions, but it worked spectacularly for my table with 3+ million rows. (4 second execution with 1200+ results)</source>
          <target state="translated">他のソリューションと比較してどのように実行されるかわかりませんが、300万行以上のテーブルでは目を見張るような働きをしてくれました。(4秒間の実行で1200以上の結果)</target>
        </trans-unit>
        <trans-unit id="c79f4514092c5c57c78efdc4efc2c4a179d86a7b" translate="yes" xml:space="preserve">
          <source>I had similar issue (on postgresql tough) and on a 1M records table. This solution takes 1.7s vs 44s produced by the one with LEFT JOIN.
In my case I had to filter the corrispondant of your &lt;em&gt;name&lt;/em&gt; field against NULL values, resulting in even better performances by 0.2 secs</source>
          <target state="translated">私は（postgresqlでタフな）と1Mレコードテーブルで同様の問題を抱えていました。 このソリューションでは、1.7秒とLEFT JOINを使用した44秒で生成された時間がかかります。 私の場合、私はあなたの&lt;em&gt;名前&lt;/em&gt;フィールドの対応するものをNULL値に対してフィルタリングしなければならなかったので、0.2秒でさらに優れたパフォーマンスが得られました</target>
        </trans-unit>
        <trans-unit id="da167e102b3d5e635c7f55d996d67d693a53f36a" translate="yes" xml:space="preserve">
          <source>I have a couple of other solutions that are based on the same ideas:</source>
          <target state="translated">同じ考えに基づいた他の解決策をいくつか持っています。</target>
        </trans-unit>
        <trans-unit id="4f0df4d19dabab6b773646d8e917b78cf2345072" translate="yes" xml:space="preserve">
          <source>I made my tests on a InnoDB table of &lt;code&gt;18684446&lt;/code&gt; rows with &lt;code&gt;1182&lt;/code&gt; groups. The table contains testresults for functional tests and has the &lt;code&gt;(test_id, request_id)&lt;/code&gt; as the primary key. Thus, &lt;code&gt;test_id&lt;/code&gt; is a group and I was searching for the last &lt;code&gt;request_id&lt;/code&gt; for each &lt;code&gt;test_id&lt;/code&gt;.</source>
          <target state="translated">私は &lt;code&gt;1182&lt;/code&gt; グループの &lt;code&gt;18684446&lt;/code&gt; 行のInnoDBテーブルでテストを行いました。 テーブルには機能テストのテスト結果が含まれており、主キーとして &lt;code&gt;(test_id, request_id)&lt;/code&gt; があります。 したがって、 &lt;code&gt;test_id&lt;/code&gt; はグループであり、各 &lt;code&gt;test_id&lt;/code&gt; の最後の &lt;code&gt;request_id&lt;/code&gt; を検索していました。</target>
        </trans-unit>
        <trans-unit id="d996176f5905df1624f8116497fa1de72077529d" translate="yes" xml:space="preserve">
          <source>I want to be able to get the last post in each category which are Title 3, Title 5 and Title 6. To get the posts by the category you will use the MySQL Group By keyboard.</source>
          <target state="translated">タイトル3、タイトル5、タイトル6の各カテゴリの最後の投稿を取得できるようにしたいです。カテゴリー別の投稿を取得するには、MySQLのGroup Byキーボードを使用します。</target>
        </trans-unit>
        <trans-unit id="73e045cc5161636dbe8249df55b0e0d0eac97f41" translate="yes" xml:space="preserve">
          <source>I will use the following tables:</source>
          <target state="translated">私は以下の表を使用します。</target>
        </trans-unit>
        <trans-unit id="b11b882165cd4c620e269037c730139ff813cde5" translate="yes" xml:space="preserve">
          <source>I write the solution this way:</source>
          <target state="translated">解答はこのように書いています。</target>
        </trans-unit>
        <trans-unit id="2cb7e3a389d31699c10dcaf352f8221c5b08befe" translate="yes" xml:space="preserve">
          <source>I'll write a query to find the most recent post for a given user ID (mine).</source>
          <target state="translated">指定されたユーザーID(私のもの)の最新の投稿を見つけるためのクエリを書いてみます。</target>
        </trans-unit>
        <trans-unit id="0441db57073c36c9dcbad5725d9a159517c98628" translate="yes" xml:space="preserve">
          <source>I'm assuming by &quot;last&quot; you mean last in Id order. If not, change the ORDER BY clause of the ROW_NUMBER() window accordingly. If ROW_NUMBER() isn't available, this is another solution:</source>
          <target state="translated">私は、&quot;last &quot;というのはId順の最後という意味だと思っています。そうでない場合は、ROW_NUMBER()ウィンドウの ORDER BY 節をそれに応じて変更してください。ROW_NUMBER()が利用できない場合は、これが別の解決策です。</target>
        </trans-unit>
        <trans-unit id="cc052c86860a135a6f085fd44a8a1f24e217e3a7" translate="yes" xml:space="preserve">
          <source>I've not yet tested with large DB but I think this could be faster than joining tables:</source>
          <target state="translated">まだ大規模DBでのテストはしていませんが、テーブルの結合よりも高速にできるのではないかと思います。</target>
        </trans-unit>
        <trans-unit id="f314ae9a99438bf63c3f0b555c9e065aab4b46ea" translate="yes" xml:space="preserve">
          <source>If I run a query &lt;code&gt;select * from messages group by name&lt;/code&gt;, I will get the result as:</source>
          <target state="translated">クエリ &lt;code&gt;select * from messages group by name&lt;/code&gt; を実行すると、結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="797a6d4eef68c1f394a200a217d61880cd5ed2d7" translate="yes" xml:space="preserve">
          <source>If hypothetically MySQL had a last() function which returned values from the last row in a special ORDER BY clause then we could simply do:</source>
          <target state="translated">仮にMySQLが特別なORDER BY句の最後の行から値を返すlast()関数を持っていたとしたら、それを単純に実行することができます。</target>
        </trans-unit>
        <trans-unit id="397ad59e8dc6fb0f10b2f5d37063b39999ddda56" translate="yes" xml:space="preserve">
          <source>If it's not &lt;code&gt;id&lt;/code&gt; you want the max of:</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; でない場合は、次の最大値が必要です。</target>
        </trans-unit>
        <trans-unit id="fdc44790d10a344d9c45e8557b1f1784a0892c6d" translate="yes" xml:space="preserve">
          <source>If performance is really your concern you can introduce a new column on the table called &lt;code&gt;IsLastInGroup&lt;/code&gt; of type BIT.</source>
          <target state="translated">パフォーマンスが本当に懸念される場合は、BITタイプの &lt;code&gt;IsLastInGroup&lt;/code&gt; と呼ばれるテーブルに新しい列を導入できます。</target>
        </trans-unit>
        <trans-unit id="596781a5f726b6c0fe295b2e871cab00ef658a31" translate="yes" xml:space="preserve">
          <source>If you want the last row for each &lt;code&gt;Name&lt;/code&gt;, then you can give a row number to each row group by the &lt;code&gt;Name&lt;/code&gt; and order by &lt;code&gt;Id&lt;/code&gt; in descending order.</source>
          <target state="translated">各 &lt;code&gt;Name&lt;/code&gt; の最後の行が必要な場合は、各行グループに &lt;code&gt;Name&lt;/code&gt; で行番号を付け、 &lt;code&gt;Id&lt;/code&gt; で降順で並べることができます。</target>
        </trans-unit>
        <trans-unit id="f2f007ea893d6f3c6e118ffeb2a9bed4e6acd781" translate="yes" xml:space="preserve">
          <source>If you want to change the order to ASC, put it in a subquery, return the ids only and use that as the subquery to join to the rest of the columns:</source>
          <target state="translated">順番をASCに変更したい場合は、サブクエリに入れて、idのみを返し、それをサブクエリとして使用して残りのカラムに結合します。</target>
        </trans-unit>
        <trans-unit id="17aca632dd9cf57e5ef672ea1e653cdeb1c6449c" translate="yes" xml:space="preserve">
          <source>In other words, select messages where there is no later-Id message with the same Name.</source>
          <target state="translated">つまり、同じ名前の later-Id メッセージが存在しないメッセージを選択します。</target>
        </trans-unit>
        <trans-unit id="831a9fcccb916e910885880847357e0eea51c908" translate="yes" xml:space="preserve">
          <source>Is there a way to maybe save the output to a temp variable then delete from  NOT IN (temp variable)? @Bill thanks for a very useful solution.</source>
          <target state="translated">出力をテンポラリ変数に保存して、NOT IN (テンポラリ変数)から削除する方法はありますか?Billさん、非常に有用な解決策をありがとうございます。</target>
        </trans-unit>
        <trans-unit id="ada0cba277b001b725563b9d65b32b187fa0ae2b" translate="yes" xml:space="preserve">
          <source>Is there any way we could use this method to delete duplicates in a table? The result set is basically a collection of unique records, so if we could delete all records not in the result set, we would effectively have no duplicates? I tried this but mySQL gave a 1093 error.</source>
          <target state="translated">この方法を使ってテーブル内の重複を削除する方法はありますか?結果セットは基本的に一意のレコードの集合体なので、結果セットに含まれていないレコードをすべて削除することができれば、実質的に重複はないのでしょうか?私はこれを試してみましたが、mySQLは1093エラーを出しました。</target>
        </trans-unit>
        <trans-unit id="2e9abaca41125759bfd9e5d67d812105d729c63d" translate="yes" xml:space="preserve">
          <source>It returns tests in descending order as well. It is much slower since it does a full index scan but it is here to give you an idea how to output N max rows for each group.</source>
          <target state="translated">これは降順にテストを返します。これは完全なインデックススキャンを行うのでかなり遅くなりますが、グループごとに最大N個の行を出力する方法についてのアイデアを提供しています。</target>
        </trans-unit>
        <trans-unit id="8c11361b17e7c01dbfb348627e33f2ea917dbaa0" translate="yes" xml:space="preserve">
          <source>MySQL 8.0 now supports windowing functions, like almost all popular SQL implementations. With this standard syntax, we can write greatest-n-per-group queries:</source>
          <target state="translated">MySQL 8.0では、ほとんどの一般的なSQL実装と同様にウィンドウ関数をサポートするようになりました。この標準構文を使用することで、グループごとに最大のn個のクエリを書くことができます。</target>
        </trans-unit>
        <trans-unit id="7498655159a7c6a1db086cfbb567bf671cdb7903" translate="yes" xml:space="preserve">
          <source>Reason for this post is to give fiddle link only.
Same SQL is already provided in other answers.</source>
          <target state="translated">この投稿の理由は、フィドルリンクのみを提供するためです。同じSQLは他の回答で既に提供されています。</target>
        </trans-unit>
        <trans-unit id="c8ccfe4e25d21448dd15fe21c154c0902f66df2f" translate="yes" xml:space="preserve">
          <source>Reference Click Here</source>
          <target state="translated">参考文献はこちら</target>
        </trans-unit>
        <trans-unit id="4dbd14c8aebe37e42d2468dbe2ca220c3dd24a16" translate="yes" xml:space="preserve">
          <source>Regarding performance, one solution or the other can be better, depending on the nature of your data. So you should test both queries and use the one that is better at performance given your database.</source>
          <target state="translated">パフォーマンスに関しては、データの性質に応じて、どちらか一方のソリューションの方が優れている場合があります。そのため、両方のクエリをテストして、データベースを考慮してパフォーマンスの良い方を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea2eb0c5738bc8cf0364f734acf68aa67e48e394" translate="yes" xml:space="preserve">
          <source>Retrieving the last record in each group - MySQL</source>
          <target state="translated">各グループの最後のレコードを取得する-MySQL</target>
        </trans-unit>
        <trans-unit id="36a563f27a865c596b19c7761ec4e2b026984fa2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle</source>
          <target state="translated">エスエルフィドル</target>
        </trans-unit>
        <trans-unit id="2e164b5bceb0a464ce80e56aff6823f1858c33ba" translate="yes" xml:space="preserve">
          <source>Second, if it doesn't, this is often a good way to proceed:</source>
          <target state="translated">次に、そうでない場合は、この方法で進めることが多いです。</target>
        </trans-unit>
        <trans-unit id="75ebe02529363af8ac2cb81968008f69e5a68b18" translate="yes" xml:space="preserve">
          <source>Set it to true on the columns which are last and maintain it with every row insert/update/delete. Writes will be slower, but you'll benefit on reads. It depends on your use case and I recommend it only if you're read-focused.</source>
          <target state="translated">最後のカラムでtrueに設定し、行ごとにinsertupdatedeleteで維持します。書き込みは遅くなりますが、読み込みではメリットがあります。これはあなたのユースケースに依存しますが、私はリードを重視する場合にのみお勧めします。</target>
        </trans-unit>
        <trans-unit id="1306934731570ec8e798cf5b4cd03e78daa17a10" translate="yes" xml:space="preserve">
          <source>So your query will look like:</source>
          <target state="translated">そのため、あなたのクエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="479af75d9051b37626a807b3177da597d19796c0" translate="yes" xml:space="preserve">
          <source>Solution By join condition &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/18&quot;&gt;fiddle link&lt;/a&gt;</source>
          <target state="translated">結合条件&lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/18&quot;&gt;フィドルリンクによる&lt;/a&gt;ソリューション</target>
        </trans-unit>
        <trans-unit id="d3b27c248bca752dbaba1f5b514eb99b1bcdc96f" translate="yes" xml:space="preserve">
          <source>Solution by sub query &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/1&quot;&gt;fiddle Link&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/1&quot;&gt;サブクエリフィドルリンク&lt;/a&gt;による解決策</target>
        </trans-unit>
        <trans-unit id="29cb8ee63e4c8270e106385d8e5c11ee5799bfeb" translate="yes" xml:space="preserve">
          <source>That is, the last record in each group should be returned.</source>
          <target state="translated">つまり、各グループの最後のレコードを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="2bb0de9f8da9dd7162532db1473209ed5825a10b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPLAIN&lt;/code&gt; analysis shows that both tables are able to use their indexes:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 分析は、両方のテーブルがインデックスを使用できることを示しています。</target>
        </trans-unit>
        <trans-unit id="e920682d80f71e871fb5071381e58689d878c2cb" translate="yes" xml:space="preserve">
          <source>The below query will work fine as per your question.</source>
          <target state="translated">以下のクエリは、ご質問の通りに正常に動作します。</target>
        </trans-unit>
        <trans-unit id="fbb5af9150f5c7e0fd44650e727dd0f46a838bd6" translate="yes" xml:space="preserve">
          <source>The disadvantage of the query is that its result cannot be cached by the query cache.</source>
          <target state="translated">クエリの欠点は、その結果がクエリキャッシュにキャッシュされないことです。</target>
        </trans-unit>
        <trans-unit id="5220d6e37a53ba1055afaff9daacc47717d2d61f" translate="yes" xml:space="preserve">
          <source>The group by will always return the first record in the group on the result set.</source>
          <target state="translated">group by は常に結果セットのグループ内の最初のレコードを返します。</target>
        </trans-unit>
        <trans-unit id="7dd52bfaec335c59b803de78dc6380ac948b3229" translate="yes" xml:space="preserve">
          <source>The temperature table is populated with about 1.5 million random records, and with 100 different groups.
The selected_group is populated with those 100 groups (in our cases this would normally be less than 20% for all of the groups).</source>
          <target state="translated">温度テーブルには、約150万のランダムレコードと100の異なるグループが登録されています。selected_groupには、これらの100のグループが登録されています(我々の場合、通常はすべてのグループの20%以下になります)。</target>
        </trans-unit>
        <trans-unit id="ec4e7f239a53c42502c3d2c45c9642be417399a8" translate="yes" xml:space="preserve">
          <source>There is a table &lt;code&gt;messages&lt;/code&gt; that contains data as shown below:</source>
          <target state="translated">以下に示すようなデータを含むテーブル &lt;code&gt;messages&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="9c5c5e44410797cfb80e0b55cb8140f14b46c58d" translate="yes" xml:space="preserve">
          <source>This examined 1,505,331 rows and took ~1.25 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">1,505,331行を調べ、5.7.21で1.25秒、8.0.4-rcで少し長くかかりました。</target>
        </trans-unit>
        <trans-unit id="81b6914c1559bc587f6326f1599b365c83c12191" translate="yes" xml:space="preserve">
          <source>This examined 3,009,254 rows and took ~0.859 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">3,009,254行を検査し、5.7.21で0.859秒、8.0.4-rcでわずかに長くかかりました。</target>
        </trans-unit>
        <trans-unit id="68ee38cc43cdcf53c46ba3c759220581e6045302" translate="yes" xml:space="preserve">
          <source>This examined 3,009,685 rows and took ~1.95 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">3,009,685行を検査し、5.7.21で1.95秒、8.0.4-rcでわずかに長くかかりました。</target>
        </trans-unit>
        <trans-unit id="9d63c8255231bfb5a1e6b95fc961911c48243edb" translate="yes" xml:space="preserve">
          <source>This examined 6,017,808 rows and took ~4.2 seconds on 8.0.4-rc</source>
          <target state="translated">6,017,808行を調べ、8.0.4-rcで4.2秒ほどかかりました。</target>
        </trans-unit>
        <trans-unit id="fc109de8d773a09cf6788ca55e814373baa27457" translate="yes" xml:space="preserve">
          <source>This examined 6,017,908 rows and took ~17.5 seconds on 8.0.4-rc</source>
          <target state="translated">6,017,908行を検査し、8.0.4-rcで17.5秒かかりました。</target>
        </trans-unit>
        <trans-unit id="72ec9773fda740bb1bf37b3e30dfc1ce6ad25cf5" translate="yes" xml:space="preserve">
          <source>This examined 6,137,810 rows and took ~2.2 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">これは6,137,810行を検査し、5.7.21で2.2秒、8.0.4-rcでわずかに長くかかりました。</target>
        </trans-unit>
        <trans-unit id="27f603924db5fd8fddbe9a57eb559c6a96ccc965" translate="yes" xml:space="preserve">
          <source>This one is incredibly fast, it takes about 0,8 secs on my 18M+ rows:</source>
          <target state="translated">これは信じられないほど高速で、私の18M以上の列では約0.8秒かかります。</target>
        </trans-unit>
        <trans-unit id="d56054ecf34d32d8faa73a9cb4c977ff7cfc9ca8" translate="yes" xml:space="preserve">
          <source>This one takes about 1,2 secs on my data.</source>
          <target state="translated">これは私のデータで約1,2秒かかります。</target>
        </trans-unit>
        <trans-unit id="2d1a634cf82106f06d5f961a9c42270a2cf578cc" translate="yes" xml:space="preserve">
          <source>This one was taking forever so I had to kill it.</source>
          <target state="translated">これは時間がかかっていたので、殺すしかなかった。</target>
        </trans-unit>
        <trans-unit id="755305d457fac753eeacf1f66314a371e7fea104" translate="yes" xml:space="preserve">
          <source>This way, you avoid correlated subqueries and/or ordering in your subqueries, which tend to be very slow/inefficient.</source>
          <target state="translated">この方法では、相関のある副問い合わせや、非常に遅く効率的になりがちな副問い合わせの順序付けを避けることができます。</target>
        </trans-unit>
        <trans-unit id="249758b42b9acb20fe5738ab609f7e27cf7b0fbb" translate="yes" xml:space="preserve">
          <source>This will return the posts with the highest IDs in each group.</source>
          <target state="translated">これは、各グループの中で最も高いIDを持つ投稿を返します。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">これを試してみてください。</target>
        </trans-unit>
        <trans-unit id="df80017da6bdb06ae1c099a4d4f79dcdcedede04" translate="yes" xml:space="preserve">
          <source>Use your &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/subqueries.html&quot;&gt;subquery&lt;/a&gt; to return the correct grouping, because you're halfway there.</source>
          <target state="translated">途中なので、 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/subqueries.html&quot;&gt;サブクエリ&lt;/a&gt;を使用して正しいグループを返します。</target>
        </trans-unit>
        <trans-unit id="343378ebb4e422d7ee308714179fb8a50ab2941c" translate="yes" xml:space="preserve">
          <source>We sometimes need to do this with tables with even more than 60 million rows.</source>
          <target state="translated">6,000万行以上のテーブルでは、これを行う必要があることもあります。</target>
        </trans-unit>
        <trans-unit id="34ab847fb665a4a7425fb456ca2ccb8df1de44b7" translate="yes" xml:space="preserve">
          <source>What query will return the following result?</source>
          <target state="translated">どのようなクエリが次のような結果を返しますか?</target>
        </trans-unit>
        <trans-unit id="35e155c7e23b04728d125cca110a23de7aab004d" translate="yes" xml:space="preserve">
          <source>You can group by counting and also get the last item of group like:</source>
          <target state="translated">数を数えてグループ化したり、グループの最後の項目を取得したりすることができます。</target>
        </trans-unit>
        <trans-unit id="99d6b48b4fe1053f56f03f22891e1a03ea6f47c8" translate="yes" xml:space="preserve">
          <source>You can take view from here as well.</source>
          <target state="translated">ここからも景色を眺めることができます。</target>
        </trans-unit>
        <trans-unit id="bb064e50508085f145c1589d4249bb5c9a7172dc" translate="yes" xml:space="preserve">
          <source>each index implicitly contains primary key columns appended to that (that is the primary key is in the coverage index). In solutions below I operate directly on the primary key, in you case, you will just need to add primary key columns in the result.</source>
          <target state="translated">各インデックスには暗黙のうちに主キーカラムが追加されています (つまり、主キーはカバレッジインデックスにあります)。以下のソリューションでは、私は主キーを直接操作していますが、あなたの場合は結果に主キーカラムを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="9544b09ea42d2c0e18032bc4cecd486c9b87360e" translate="yes" xml:space="preserve">
          <source>if the underlying index is BTREE index (which is usually the case), the largest &lt;code&gt;(group_id, item_value)&lt;/code&gt; pair is the last value within each &lt;code&gt;group_id&lt;/code&gt;, that is the first for each &lt;code&gt;group_id&lt;/code&gt; if we walk through the index in descending order;</source>
          <target state="translated">基礎となるインデックスがBTREEインデックス（通常の場合）である場合、最大の &lt;code&gt;(group_id, item_value)&lt;/code&gt; ペアは、各 &lt;code&gt;group_id&lt;/code&gt; 内の最後の値です。これは、降順でインデックスをウォークスルーした場合の各 &lt;code&gt;group_id&lt;/code&gt; の最初の値です。</target>
        </trans-unit>
        <trans-unit id="874be9484ee4451489e054a270b056560700e9e7" translate="yes" xml:space="preserve">
          <source>if we read the values which are covered by an index, the values are read in the order of the index;</source>
          <target state="translated">インデックスに覆われている値を読み込むと、インデックスの順に値が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="d7e92e6ab44616f5629fd1eb078c11805d79e266" translate="yes" xml:space="preserve">
          <source>in many cases it is much cheaper to collect the required row ids in the required order in a subquery and join the result of the subquery on the id. Since for each row in the subquery result MySQL will need a single fetch based on primary key, the subquery will be put first in the join and the rows will be output in the order of the ids in the subquery (if we omit explicit ORDER BY for the join)</source>
          <target state="translated">多くの場合、サブクエリで必要な順序で必要な行のIDを収集し、そのIDでサブクエリの結果を結合する方がはるかに安いです。サブクエリの結果の各行に対して、MySQLは主キーに基づいた単一のフェッチを必要とするので、サブクエリは結合の最初に置かれ、行はサブクエリのidの順番で出力されます(結合のための明示的なORDER BYを省略した場合)。</target>
        </trans-unit>
        <trans-unit id="1b14ebfb6f316da8b1c0d2fe564a472eedf03091" translate="yes" xml:space="preserve">
          <source>we will look at how you can use MySQL at getting the last record in a Group By of records. For example if you have this result set of posts.</source>
          <target state="translated">ここでは、レコードのGroup Byで最後のレコードを取得する際にMySQLを使用する方法を見ていきます。例えば、次のような結果があったとします。</target>
        </trans-unit>
        <trans-unit id="34299c5c85340cd7ddedf639ab202e2e2e8a2761" translate="yes" xml:space="preserve">
          <source>which would only need to examine a few 100 rows in this case as it doesn't use any of the normal GROUP BY functions. This would execute in 0 seconds and hence be highly efficient.
Note that normally in MySQL we would see an ORDER BY clause following the GROUP BY clause however this ORDER BY clause is used to determine the ORDER for the last() function, if it was after the GROUP BY then it would be ordering the GROUPS. If no GROUP BY clause is present then the last values will be the same in all of the returned rows.</source>
          <target state="translated">これは通常のGROUP BY関数を使用しないので、この場合は数100行を検査する必要があります。これは0秒で実行され、非常に効率的です。通常、MySQLではGROUP BY句の後にORDER BY句が表示されますが、このORDER BY句はlast()関数のORDERを決定するために使用されます。GROUP BY 句が存在しない場合、最後の値は、返されたすべての行で同じになります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
