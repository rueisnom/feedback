<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1313120">
    <body>
      <group id="1313120">
        <trans-unit id="bc2f74c22f98f7b6ffbc2f67453dbfa99bce9a32" translate="yes" xml:space="preserve">
          <source>**</source>
          <target state="translated">**</target>
        </trans-unit>
        <trans-unit id="8f645513ffa73d44a4fa5de5330055f3be40b1c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.mysqlperformanceblog.com/2009/09/12/3-ways-mysql-uses-indexes&quot;&gt;3 ways MySQL uses indexes&lt;/a&gt; is a great article to understand some details.</source>
          <target state="translated">&lt;a href=&quot;http://www.mysqlperformanceblog.com/2009/09/12/3-ways-mysql-uses-indexes&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL使用索引的3种方式&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一篇了解某些细节的好文章。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b5f5c3163b44cfb577f7102eba674dc7dead525" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This should work both on MySQL and SQL Server.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这在MySQL和SQL Server上均应起作用。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ef7cf3995e5d790678b807a725ee0318ff9bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UPD: 2017-03-31, the version &lt;a href=&quot;https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html#mysqld-5-7-5-sql-mode&quot;&gt;5.7.5&lt;/a&gt; of MySQL made the ONLY_FULL_GROUP_BY switch enabled by default (hence, non-deterministic GROUP BY queries became disabled). Moreover, they updated the GROUP BY implementation and the solution might not work as expected anymore even with the disabled switch. One needs to check.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UPD：2017-03-31，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html#mysqld-5-7-5-sql-mode&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.7.5&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;版&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;默认情况下启用了ONLY_FULL_GROUP_BY开关（因此，不确定的GROUP BY查询被禁用）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此外，他们更新了GROUP BY实施，即使禁用了开关，该解决方案也可能无法按预期工作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个需要检查。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4aeaa617d0d40556e2ebfbac11a9c7b612cae76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Hi, this query might help :&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;嗨，此查询可能会有所帮助：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cba4951ffd2b51c76d331e5a3fa3e6ec9193fef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例子4&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c36ab90a22beaab321d017be889526e748936ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例子5&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e534f76560839fac49d71827900280961455f692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例子6&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4417dba7c1c0db0f0da450df72fc6aaf8bffcf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例子7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ebec6ad107992984e17ccecc97ed3cab85a50b7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FIRST SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一个解决方案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="096e3dd5b45fc3fbad6172ee5bcf27f1ee5f8f15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First using the technique &lt;a href=&quot;https://stackoverflow.com/questions/1313120/sql-retrieving-the-last-record-in-each-group/1313140#1313140&quot;&gt;shown&lt;/a&gt; by @Eric with the &lt;code&gt;GROUP BY&lt;/code&gt; in a subquery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在子查询&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中将@Eric &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1313120/sql-retrieving-the-last-record-in-each-group/1313140#1313140&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显示&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的技术&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 结合&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d66c96ef877ff9a09a1b6092e2d693638bc51369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now produce the same query result using &lt;a href=&quot;https://stackoverflow.com/questions/121387/fetch-the-row-which-has-the-max-value-for-a-column/123481#123481&quot;&gt;my technique&lt;/a&gt; with &lt;code&gt;LEFT JOIN&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/121387/fetch-the-row-which-has-the-max-value-for-a-column/123481#123481&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的技术&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;LEFT JOIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;产生相同的查询结果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba65d8c19571d88f28ec5b5c980e23acc73041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;QUERY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;QUERY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7f8a11139f03cf3b0c8e2a9df85a2ae32908607" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SECOND SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第二解决方案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21aa429fd1f960433948c85037e5c8a8b7b989ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方案1&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="386b462eb4b8c11b6ed2f186c1638cabe4ee6309" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方案2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff9929d19b9080a8ccd6f1a2254225e9d9fbe50e" translate="yes" xml:space="preserve">
          <source>Above query will group the all the &lt;code&gt;Other_Columns&lt;/code&gt; that are in same &lt;code&gt;Name&lt;/code&gt; group  and using &lt;code&gt;ORDER BY id DESC&lt;/code&gt; will join all the &lt;code&gt;Other_Columns&lt;/code&gt; in a specific group in descending order  with the provided separator in my case i have used &lt;code&gt;||&lt;/code&gt; ,using &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; over this list will pick the first one</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的查询将所有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在同一个&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;组中的所有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Other_Columns&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分组，并使用&lt;/font&gt; &lt;code&gt;ORDER BY id DESC&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用提供的分隔符以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;降序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定组中的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt; &lt;code&gt;Other_Columns&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;连接&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;起来&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在我的情况下，我已经使用了&lt;/font&gt; &lt;code&gt;||&lt;/code&gt; 。&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在此列表上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;将选择第一个&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4f69c12f5f097c3bc85d1c305639e5e3bd817e5" translate="yes" xml:space="preserve">
          <source>An approach with considerable speed is as follows.</source>
          <target state="translated">具有相当速度的方法如下:</target>
        </trans-unit>
        <trans-unit id="6ffa51cbbf5cad2672d34a40acf2a210fc73291d" translate="yes" xml:space="preserve">
          <source>Another approach :</source>
          <target state="translated">另一种方法是:</target>
        </trans-unit>
        <trans-unit id="5895da138d7bad5c473af20dabff9e769de91aee" translate="yes" xml:space="preserve">
          <source>As this data is random it means that multiple rows can have the same recordedTimestamps. What we want is to get a list of all of the selected groups in order of groupID with the last recordedTimestamp for each group, and if the same group has more than one matching row like that then the last matching id of those rows.</source>
          <target state="translated">因为这个数据是随机的,这意味着多行可能有相同的记录Timestamps。我们要做的是得到一个列表,按照groupID的顺序列出所有被选中的组,每个组的最后一次记录的Timestamp,如果同一个组有一个以上的匹配行,那么就是这些行的最后一次匹配ID。</target>
        </trans-unit>
        <trans-unit id="fa9ea7afc562036e3828d246e9208813dd89e863" translate="yes" xml:space="preserve">
          <source>At present, this is the query that I use:</source>
          <target state="translated">目前,我用的就是这个查询方式。</target>
        </trans-unit>
        <trans-unit id="52af234919e0864d5be789ce9e9966fa719f0fdf" translate="yes" xml:space="preserve">
          <source>Below is the original answer I wrote for this question in 2009:</source>
          <target state="translated">下面是我2009年为这个问题写的原始答案。</target>
        </trans-unit>
        <trans-unit id="dfa20b2c64f084967f88e2b30b428496e758d2ce" translate="yes" xml:space="preserve">
          <source>Bill Karwin's solution above works fine when item count within groups is rather small, but the performance of the query becomes bad when the groups are rather large, since the solution requires about &lt;code&gt;n*n/2 + n/2&lt;/code&gt; of only &lt;code&gt;IS NULL&lt;/code&gt; comparisons.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当组中的项目数很小时，Bill Karwin的上述解决方案可以很好地工作，但是当组中的项数量很大时，查询性能就会变差，因为该解决方案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅需要&lt;/font&gt; &lt;code&gt;IS NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;比较的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n*n/2 + n/2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd4c066734a8ad4492b0a6e00d4fd47414089358" translate="yes" xml:space="preserve">
          <source>Bill's solution has already been running for several hours on my dell e4310 and I do not know when it is going to finish even though it operates on a coverage index (hence &lt;code&gt;using index&lt;/code&gt; in EXPLAIN).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bill的解决方案已经在我的Dell e4310上运行了几个小时，即使它在coverage索引上运行（因此&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在EXPLAIN中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;using index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我也不知道它何时会完成&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a540b9b8692c7398481e1d0a45488fe1cb97fc95" translate="yes" xml:space="preserve">
          <source>But the results we get back from this query is.</source>
          <target state="translated">但我们从这个查询中得到的结果是。</target>
        </trans-unit>
        <trans-unit id="409b3a6cc20c0128a69a6b5836d7b3c4dd161adb" translate="yes" xml:space="preserve">
          <source>But this looks highly inefficient. Any other ways to achieve the same result?</source>
          <target state="translated">但是,这看起来效率很低下。还有其他方法可以达到同样的效果吗?</target>
        </trans-unit>
        <trans-unit id="dfa6620c99e58e7436201c6184ee2ca49c84b834" translate="yes" xml:space="preserve">
          <source>Clearly there are lots of different ways of getting the same results, your question seems to be what is an efficient way of getting the last results in each group in MySQL. If you are working with huge amounts of data and assuming you are using InnoDB with even the latest versions of MySQL (such as 5.7.21 and 8.0.4-rc) then there might not be an efficient way of doing this.</source>
          <target state="translated">显然,有很多不同的方法可以得到相同的结果,你的问题似乎是,在MySQL中,什么是得到每个组中最后一个结果的有效方法。如果你是在处理大量的数据,并且假设你使用的是最新版本的MySQL(如5.7.21和8.0.4-rc)的InnoDB,那么可能没有一个有效的方法。</target>
        </trans-unit>
        <trans-unit id="0e6166e0885a4e9c3b9b6dc26f6c33ee9c6b158c" translate="yes" xml:space="preserve">
          <source>EDIT: Think i found the solution:</source>
          <target state="translated">EDIT:我想我找到了解决方案。</target>
        </trans-unit>
        <trans-unit id="da752519d3c02bfcbee192fe71cb5d1c2afba9fc" translate="yes" xml:space="preserve">
          <source>Even the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&quot;&gt;&lt;code&gt;EXPLAIN&lt;/code&gt; analysis&lt;/a&gt; takes over 16 seconds:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;甚至&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&quot;&gt; &lt;code&gt;EXPLAIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分析&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也要&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;花费16秒以上的时间：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ab63eeb4d0745316d2eee1767dd903b98520f3c" translate="yes" xml:space="preserve">
          <source>Fiddle Demo</source>
          <target state="translated">琴键演示</target>
        </trans-unit>
        <trans-unit id="b7e5708f1f87ff99a200942c6f52c205533b087c" translate="yes" xml:space="preserve">
          <source>Find the propertie with the max m2_price withing each program (n properties in 1 program) :</source>
          <target state="translated">找到每个程序中最大m2_价格的属性(1个程序中有n个属性)。</target>
        </trans-unit>
        <trans-unit id="159d4ff95f68b8d2bd154edd020461cb5caf121d" translate="yes" xml:space="preserve">
          <source>For example, I have a copy of the &lt;a href=&quot;https://archive.org/details/stackexchange&quot;&gt;StackOverflow August data dump&lt;/a&gt;.  I'll use that for benchmarking.  There are 1,114,357 rows in the &lt;code&gt;Posts&lt;/code&gt; table.  This is running on &lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt; 5.0.75 on my Macbook Pro 2.40GHz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，我有一个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://archive.org/details/stackexchange&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;StackOverflow August数据转储&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的副本&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将其用于基准测试。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Posts&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有1,114,357行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Macbook Pro 2.40GHz的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 5.0.75上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b17d6e4ca90fd7b884da8ccc58edeeefcae86e04" translate="yes" xml:space="preserve">
          <source>For these examples I will use data with only about 1.5 million rows where the queries would need to find results for all groups in the data. In our actual cases we would often need to return back data from about 2,000 groups (which hypothetically would not require examining very much of the data).</source>
          <target state="translated">在这些例子中,我将使用只有150万行左右的数据,查询需要找到数据中所有组的结果。在我们的实际案例中,我们通常需要返回大约2,000个组的数据(假设情况下,不需要对数据中的大部分数据进行检查)。</target>
        </trans-unit>
        <trans-unit id="87d03384f44b47a879deeda44b7ac84af6c50aec" translate="yes" xml:space="preserve">
          <source>Here are two suggestions.  First, if mysql supports ROW_NUMBER(), it's very simple:</source>
          <target state="translated">这里有两个建议。第一,如果mysql支持ROW_NUMBER(),那就很简单了。</target>
        </trans-unit>
        <trans-unit id="6c7b5efaecd6bf9fd8ebaf569dd613771dfd1d37" translate="yes" xml:space="preserve">
          <source>Here is another solution that takes about 19 seconds for my table:</source>
          <target state="translated">这里是另一个解决方案,我的桌子需要19秒左右的时间。</target>
        </trans-unit>
        <trans-unit id="91f7e27f60625062718026b18b9e89832af53376" translate="yes" xml:space="preserve">
          <source>Here is another way to get the last related record using &lt;code&gt;GROUP_CONCAT&lt;/code&gt; with order by and &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; to pick one of the record from the list</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GROUP_CONCAT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并按&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的最后一条相关记录的另一种方法，可&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从列表中选择一条记录&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6a0ac753b84f68190035e002ff7c3d92847813ee" translate="yes" xml:space="preserve">
          <source>Here is my solution:</source>
          <target state="translated">这是我的解决方案。</target>
        </trans-unit>
        <trans-unit id="b93bfb210dc14c88784f9e875260957b2d19e337" translate="yes" xml:space="preserve">
          <source>Here's the DDL for my &lt;code&gt;Posts&lt;/code&gt; table:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Posts&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的DDL &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b43694db01032ca975a3ee122be4c0ac567c042" translate="yes" xml:space="preserve">
          <source>Hi @Vijay Dev if your table &lt;strong&gt;messages&lt;/strong&gt; contains &lt;strong&gt;Id&lt;/strong&gt; which is auto increment primary key then to fetch the latest record basis on the primary key your query should read as below:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@Vijay Dev，您好，如果您的表&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;消息&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ID（&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它是自动递增主键），&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则要根据&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;主键获取最新记录，您的查询应如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7b7402d87ff4654cdcf49d6ce05c1a115c8ccdc7" translate="yes" xml:space="preserve">
          <source>Hope below Oracle query can help:</source>
          <target state="translated">希望下面的Oracle查询可以帮助到你。</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">这个怎么样?</target>
        </trans-unit>
        <trans-unit id="056165c6f3e12f6a33964cf8f0af752642c0aab9" translate="yes" xml:space="preserve">
          <source>However MySQL does not have this so let's look at different ideas of what it does have and prove that none of these are efficient.</source>
          <target state="translated">然而MySQL并不具备这些,所以我们来看看它所具备的不同想法,证明这些都不是有效的。</target>
        </trans-unit>
        <trans-unit id="d85b71d6929ce27f94649bf0418056833e4ab04f" translate="yes" xml:space="preserve">
          <source>I arrived at a different solution, which is to get the IDs for the last post within each group, then select from the messages table using the result from the first query as the argument for a &lt;code&gt;WHERE x IN&lt;/code&gt; construct:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我得出了一个不同的解决方案，即获取每个组中最后一个帖子的ID，然后使用第一个查询的结果作为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;WHERE x IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的参数从message表中进行选择&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2f758943b374e2de01a29386e7186bc2832d669e" translate="yes" xml:space="preserve">
          <source>I don't know how this performs compared to some of the other solutions, but it worked spectacularly for my table with 3+ million rows. (4 second execution with 1200+ results)</source>
          <target state="translated">我不知道与其他的一些解决方案相比,这个方案的表现如何,但它对我的表有300多万行的表非常有效。(4秒执行1200+的结果)</target>
        </trans-unit>
        <trans-unit id="c79f4514092c5c57c78efdc4efc2c4a179d86a7b" translate="yes" xml:space="preserve">
          <source>I had similar issue (on postgresql tough) and on a 1M records table. This solution takes 1.7s vs 44s produced by the one with LEFT JOIN.
In my case I had to filter the corrispondant of your &lt;em&gt;name&lt;/em&gt; field against NULL values, resulting in even better performances by 0.2 secs</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我有类似的问题（在postgresql上）和1M记录表上。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与LEFT JOIN相比，此解决方案花费的时间为1.7s与44s。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以我为例，我必须&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据NULL值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;过滤您的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;name&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字段的对应内容，从而使性能提高了0.2秒&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da167e102b3d5e635c7f55d996d67d693a53f36a" translate="yes" xml:space="preserve">
          <source>I have a couple of other solutions that are based on the same ideas:</source>
          <target state="translated">我有几个其他的解决方案,都是基于同样的想法。</target>
        </trans-unit>
        <trans-unit id="4f0df4d19dabab6b773646d8e917b78cf2345072" translate="yes" xml:space="preserve">
          <source>I made my tests on a InnoDB table of &lt;code&gt;18684446&lt;/code&gt; rows with &lt;code&gt;1182&lt;/code&gt; groups. The table contains testresults for functional tests and has the &lt;code&gt;(test_id, request_id)&lt;/code&gt; as the primary key. Thus, &lt;code&gt;test_id&lt;/code&gt; is a group and I was searching for the last &lt;code&gt;request_id&lt;/code&gt; for each &lt;code&gt;test_id&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有&lt;/font&gt; &lt;code&gt;1182&lt;/code&gt; 个&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;18684446&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的InnoDB表上进行了测试&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该表包含功能测试的测试结果，并具有&lt;/font&gt; &lt;code&gt;(test_id, request_id)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为主键。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt; &lt;code&gt;test_id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个组，我正在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为每个&lt;/font&gt; &lt;code&gt;test_id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;搜索最后一个&lt;/font&gt; &lt;code&gt;request_id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d996176f5905df1624f8116497fa1de72077529d" translate="yes" xml:space="preserve">
          <source>I want to be able to get the last post in each category which are Title 3, Title 5 and Title 6. To get the posts by the category you will use the MySQL Group By keyboard.</source>
          <target state="translated">我希望能够得到每个类别中的最后一篇文章,即标题3,标题5和标题6。要获得帖子的类别,你将使用MySQL分组键盘。</target>
        </trans-unit>
        <trans-unit id="73e045cc5161636dbe8249df55b0e0d0eac97f41" translate="yes" xml:space="preserve">
          <source>I will use the following tables:</source>
          <target state="translated">我将使用以下表格:</target>
        </trans-unit>
        <trans-unit id="b11b882165cd4c620e269037c730139ff813cde5" translate="yes" xml:space="preserve">
          <source>I write the solution this way:</source>
          <target state="translated">我把解决方案写成这样。</target>
        </trans-unit>
        <trans-unit id="2cb7e3a389d31699c10dcaf352f8221c5b08befe" translate="yes" xml:space="preserve">
          <source>I'll write a query to find the most recent post for a given user ID (mine).</source>
          <target state="translated">我会写一个查询,找到给定用户ID(我的)的最新帖子。</target>
        </trans-unit>
        <trans-unit id="0441db57073c36c9dcbad5725d9a159517c98628" translate="yes" xml:space="preserve">
          <source>I'm assuming by &quot;last&quot; you mean last in Id order. If not, change the ORDER BY clause of the ROW_NUMBER() window accordingly. If ROW_NUMBER() isn't available, this is another solution:</source>
          <target state="translated">我假设你说的 &quot;最后一个 &quot;是指按Id顺序的最后一个。如果不是,请相应地改变ROW_NUMBER()窗口的ORDER BY子句。如果ROW_NUMBER()不可用,这是另一个解决方案。</target>
        </trans-unit>
        <trans-unit id="cc052c86860a135a6f085fd44a8a1f24e217e3a7" translate="yes" xml:space="preserve">
          <source>I've not yet tested with large DB but I think this could be faster than joining tables:</source>
          <target state="translated">我还没有用大DB测试过,但我认为这可能比加入表更快。</target>
        </trans-unit>
        <trans-unit id="f314ae9a99438bf63c3f0b555c9e065aab4b46ea" translate="yes" xml:space="preserve">
          <source>If I run a query &lt;code&gt;select * from messages group by name&lt;/code&gt;, I will get the result as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我运行查询，请&lt;/font&gt;&lt;/font&gt; &lt;code&gt;select * from messages group by name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我将得到的结果为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="797a6d4eef68c1f394a200a217d61880cd5ed2d7" translate="yes" xml:space="preserve">
          <source>If hypothetically MySQL had a last() function which returned values from the last row in a special ORDER BY clause then we could simply do:</source>
          <target state="translated">如果假设MySQL有一个last()函数,在一个特殊的ORDER BY子句中返回最后一行的值,那么我们可以简单地这样做。</target>
        </trans-unit>
        <trans-unit id="397ad59e8dc6fb0f10b2f5d37063b39999ddda56" translate="yes" xml:space="preserve">
          <source>If it's not &lt;code&gt;id&lt;/code&gt; you want the max of:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则需要最大值：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdc44790d10a344d9c45e8557b1f1784a0892c6d" translate="yes" xml:space="preserve">
          <source>If performance is really your concern you can introduce a new column on the table called &lt;code&gt;IsLastInGroup&lt;/code&gt; of type BIT.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您确实关心性能，则可以在表上引入一个称为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BIT类型的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;名为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;IsLastInGroup&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新列&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="596781a5f726b6c0fe295b2e871cab00ef658a31" translate="yes" xml:space="preserve">
          <source>If you want the last row for each &lt;code&gt;Name&lt;/code&gt;, then you can give a row number to each row group by the &lt;code&gt;Name&lt;/code&gt; and order by &lt;code&gt;Id&lt;/code&gt; in descending order.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要每个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的最后一行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则可以按&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为每个行组指定行号&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并按&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;降序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ID&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行排序。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2f007ea893d6f3c6e118ffeb2a9bed4e6acd781" translate="yes" xml:space="preserve">
          <source>If you want to change the order to ASC, put it in a subquery, return the ids only and use that as the subquery to join to the rest of the columns:</source>
          <target state="translated">如果你想把订单改成ASC,就把它放在一个子查询中,只返回id,然后用它作为子查询连接到其他列中。</target>
        </trans-unit>
        <trans-unit id="17aca632dd9cf57e5ef672ea1e653cdeb1c6449c" translate="yes" xml:space="preserve">
          <source>In other words, select messages where there is no later-Id message with the same Name.</source>
          <target state="translated">换句话说,选择没有同名的后来者ID消息的消息。</target>
        </trans-unit>
        <trans-unit id="831a9fcccb916e910885880847357e0eea51c908" translate="yes" xml:space="preserve">
          <source>Is there a way to maybe save the output to a temp variable then delete from  NOT IN (temp variable)? @Bill thanks for a very useful solution.</source>
          <target state="translated">有什么方法可以把输出保存到一个临时变量,然后从NOT IN(临时变量)中删除吗?@Bill 谢谢你提供了一个非常有用的解决方案。</target>
        </trans-unit>
        <trans-unit id="ada0cba277b001b725563b9d65b32b187fa0ae2b" translate="yes" xml:space="preserve">
          <source>Is there any way we could use this method to delete duplicates in a table? The result set is basically a collection of unique records, so if we could delete all records not in the result set, we would effectively have no duplicates? I tried this but mySQL gave a 1093 error.</source>
          <target state="translated">有没有什么方法可以用这种方法来删除表中的重复记录?结果集基本上是一个唯一记录的集合,所以如果我们可以删除所有不在结果集中的记录,那么我们实际上就没有重复记录了?我试了一下,但是mySQL给了一个1093的错误。</target>
        </trans-unit>
        <trans-unit id="2e9abaca41125759bfd9e5d67d812105d729c63d" translate="yes" xml:space="preserve">
          <source>It returns tests in descending order as well. It is much slower since it does a full index scan but it is here to give you an idea how to output N max rows for each group.</source>
          <target state="translated">它也是按降序返回测试。它的速度要慢得多,因为它做了一个完整的索引扫描,但它在这里给你提供了一个如何为每个组输出N个最大行的想法。</target>
        </trans-unit>
        <trans-unit id="8c11361b17e7c01dbfb348627e33f2ea917dbaa0" translate="yes" xml:space="preserve">
          <source>MySQL 8.0 now supports windowing functions, like almost all popular SQL implementations. With this standard syntax, we can write greatest-n-per-group queries:</source>
          <target state="translated">MySQL 8.0现在支持窗口化函数,就像几乎所有流行的SQL实现一样。使用这个标准的语法,我们可以编写最大的-n个组查询。</target>
        </trans-unit>
        <trans-unit id="7498655159a7c6a1db086cfbb567bf671cdb7903" translate="yes" xml:space="preserve">
          <source>Reason for this post is to give fiddle link only.
Same SQL is already provided in other answers.</source>
          <target state="translated">发这个帖子的原因是为了给fiddle链接。同样的SQL已经在其他答案中提供了。</target>
        </trans-unit>
        <trans-unit id="c8ccfe4e25d21448dd15fe21c154c0902f66df2f" translate="yes" xml:space="preserve">
          <source>Reference Click Here</source>
          <target state="translated">参考资料 点击这里</target>
        </trans-unit>
        <trans-unit id="4dbd14c8aebe37e42d2468dbe2ca220c3dd24a16" translate="yes" xml:space="preserve">
          <source>Regarding performance, one solution or the other can be better, depending on the nature of your data. So you should test both queries and use the one that is better at performance given your database.</source>
          <target state="translated">关于性能,根据你的数据性质,一个方案或另一个方案可能更好,这取决于你的数据性质。因此,你应该测试这两种查询,并根据你的数据库,使用性能更好的那一种。</target>
        </trans-unit>
        <trans-unit id="ea2eb0c5738bc8cf0364f734acf68aa67e48e394" translate="yes" xml:space="preserve">
          <source>Retrieving the last record in each group - MySQL</source>
          <target state="translated">检索每个组中的最后一条记录-MySQL</target>
        </trans-unit>
        <trans-unit id="36a563f27a865c596b19c7761ec4e2b026984fa2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle</source>
          <target state="translated">SQL Fiddle</target>
        </trans-unit>
        <trans-unit id="2e164b5bceb0a464ce80e56aff6823f1858c33ba" translate="yes" xml:space="preserve">
          <source>Second, if it doesn't, this is often a good way to proceed:</source>
          <target state="translated">第二,如果没有的话,这往往是一个很好的方法。</target>
        </trans-unit>
        <trans-unit id="75ebe02529363af8ac2cb81968008f69e5a68b18" translate="yes" xml:space="preserve">
          <source>Set it to true on the columns which are last and maintain it with every row insert/update/delete. Writes will be slower, but you'll benefit on reads. It depends on your use case and I recommend it only if you're read-focused.</source>
          <target state="translated">在最后的列上设置为true,并在每一行insertupdatedelete时保持它。写会比较慢,但你会在读取时受益。这取决于你的用例,我建议只有当你以读取为中心时才会使用。</target>
        </trans-unit>
        <trans-unit id="1306934731570ec8e798cf5b4cd03e78daa17a10" translate="yes" xml:space="preserve">
          <source>So your query will look like:</source>
          <target state="translated">所以你的查询结果是这样的:</target>
        </trans-unit>
        <trans-unit id="479af75d9051b37626a807b3177da597d19796c0" translate="yes" xml:space="preserve">
          <source>Solution By join condition &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/18&quot;&gt;fiddle link&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方案：通过加入条件&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/18&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小提琴链接&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b27c248bca752dbaba1f5b514eb99b1bcdc96f" translate="yes" xml:space="preserve">
          <source>Solution by sub query &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/1&quot;&gt;fiddle Link&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过子查询&lt;/font&gt;&lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小提琴链接&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29cb8ee63e4c8270e106385d8e5c11ee5799bfeb" translate="yes" xml:space="preserve">
          <source>That is, the last record in each group should be returned.</source>
          <target state="translated">也就是说,每组中的最后一条记录都应该返回。</target>
        </trans-unit>
        <trans-unit id="2bb0de9f8da9dd7162532db1473209ed5825a10b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPLAIN&lt;/code&gt; analysis shows that both tables are able to use their indexes:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;EXPLAIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分析表明，这两个表都能够使用他们的指标：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e920682d80f71e871fb5071381e58689d878c2cb" translate="yes" xml:space="preserve">
          <source>The below query will work fine as per your question.</source>
          <target state="translated">根据你的问题,下面的查询可以正常工作。</target>
        </trans-unit>
        <trans-unit id="fbb5af9150f5c7e0fd44650e727dd0f46a838bd6" translate="yes" xml:space="preserve">
          <source>The disadvantage of the query is that its result cannot be cached by the query cache.</source>
          <target state="translated">其缺点是查询的结果不能被查询缓存缓存。</target>
        </trans-unit>
        <trans-unit id="5220d6e37a53ba1055afaff9daacc47717d2d61f" translate="yes" xml:space="preserve">
          <source>The group by will always return the first record in the group on the result set.</source>
          <target state="translated">在结果集上,组由总是会返回组中的第一个记录。</target>
        </trans-unit>
        <trans-unit id="7dd52bfaec335c59b803de78dc6380ac948b3229" translate="yes" xml:space="preserve">
          <source>The temperature table is populated with about 1.5 million random records, and with 100 different groups.
The selected_group is populated with those 100 groups (in our cases this would normally be less than 20% for all of the groups).</source>
          <target state="translated">温度表中填充了大约150万条随机记录,并填充了100个不同的组。selected_group是用这100个组来填充的(在我们的案例中,通常情况下,这将是所有组的20%以下)。</target>
        </trans-unit>
        <trans-unit id="ec4e7f239a53c42502c3d2c45c9642be417399a8" translate="yes" xml:space="preserve">
          <source>There is a table &lt;code&gt;messages&lt;/code&gt; that contains data as shown below:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一个表&lt;/font&gt;&lt;/font&gt; &lt;code&gt;messages&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其中包含数据，如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c5c5e44410797cfb80e0b55cb8140f14b46c58d" translate="yes" xml:space="preserve">
          <source>This examined 1,505,331 rows and took ~1.25 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">在5.7.21上检查了1,505,331行,用时约1.25秒,在8.0.4-rc上用时稍长。</target>
        </trans-unit>
        <trans-unit id="81b6914c1559bc587f6326f1599b365c83c12191" translate="yes" xml:space="preserve">
          <source>This examined 3,009,254 rows and took ~0.859 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">这检查了3,009,254行,在5.7.21上用时约0.859秒,在8.0.4-rc上用时稍长。</target>
        </trans-unit>
        <trans-unit id="68ee38cc43cdcf53c46ba3c759220581e6045302" translate="yes" xml:space="preserve">
          <source>This examined 3,009,685 rows and took ~1.95 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">该方法检查了3,009,685行,在5.7.21上用时约1.95秒,在8.0.4-rc上用时稍长。</target>
        </trans-unit>
        <trans-unit id="9d63c8255231bfb5a1e6b95fc961911c48243edb" translate="yes" xml:space="preserve">
          <source>This examined 6,017,808 rows and took ~4.2 seconds on 8.0.4-rc</source>
          <target state="translated">在8.0.4RC上检查了6,017,808行,用时约4.2秒。</target>
        </trans-unit>
        <trans-unit id="fc109de8d773a09cf6788ca55e814373baa27457" translate="yes" xml:space="preserve">
          <source>This examined 6,017,908 rows and took ~17.5 seconds on 8.0.4-rc</source>
          <target state="translated">检查了6,017,908行,在8.0.4RC上用时约17.5秒。</target>
        </trans-unit>
        <trans-unit id="72ec9773fda740bb1bf37b3e30dfc1ce6ad25cf5" translate="yes" xml:space="preserve">
          <source>This examined 6,137,810 rows and took ~2.2 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">在5.7.21上检查了6,137,810行,用时约2.2秒,在8.0.4-rc上用时稍长。</target>
        </trans-unit>
        <trans-unit id="27f603924db5fd8fddbe9a57eb559c6a96ccc965" translate="yes" xml:space="preserve">
          <source>This one is incredibly fast, it takes about 0,8 secs on my 18M+ rows:</source>
          <target state="translated">这个速度非常快,在我的18M+行上大约需要0.8秒。</target>
        </trans-unit>
        <trans-unit id="d56054ecf34d32d8faa73a9cb4c977ff7cfc9ca8" translate="yes" xml:space="preserve">
          <source>This one takes about 1,2 secs on my data.</source>
          <target state="translated">这个在我的数据上大约需要1,2秒。</target>
        </trans-unit>
        <trans-unit id="2d1a634cf82106f06d5f961a9c42270a2cf578cc" translate="yes" xml:space="preserve">
          <source>This one was taking forever so I had to kill it.</source>
          <target state="translated">这个要花很长时间,所以我不得不杀了它。</target>
        </trans-unit>
        <trans-unit id="755305d457fac753eeacf1f66314a371e7fea104" translate="yes" xml:space="preserve">
          <source>This way, you avoid correlated subqueries and/or ordering in your subqueries, which tend to be very slow/inefficient.</source>
          <target state="translated">这样一来,你可以避免相关的子查询和子查询中的排序,这往往会使你的子查询的效率很慢。</target>
        </trans-unit>
        <trans-unit id="249758b42b9acb20fe5738ab609f7e27cf7b0fbb" translate="yes" xml:space="preserve">
          <source>This will return the posts with the highest IDs in each group.</source>
          <target state="translated">这将返回每个组中ID最高的职位。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
        <trans-unit id="df80017da6bdb06ae1c099a4d4f79dcdcedede04" translate="yes" xml:space="preserve">
          <source>Use your &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/subqueries.html&quot;&gt;subquery&lt;/a&gt; to return the correct grouping, because you're halfway there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/subqueries.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子查询&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回正确的分组，因为您已经到了一半。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="343378ebb4e422d7ee308714179fb8a50ab2941c" translate="yes" xml:space="preserve">
          <source>We sometimes need to do this with tables with even more than 60 million rows.</source>
          <target state="translated">我们有时需要对有6000万行以上的表进行这样的操作。</target>
        </trans-unit>
        <trans-unit id="34ab847fb665a4a7425fb456ca2ccb8df1de44b7" translate="yes" xml:space="preserve">
          <source>What query will return the following result?</source>
          <target state="translated">什么查询会返回以下结果?</target>
        </trans-unit>
        <trans-unit id="35e155c7e23b04728d125cca110a23de7aab004d" translate="yes" xml:space="preserve">
          <source>You can group by counting and also get the last item of group like:</source>
          <target state="translated">你可以通过计数进行分组,也可以得到组的最后一项,如。</target>
        </trans-unit>
        <trans-unit id="99d6b48b4fe1053f56f03f22891e1a03ea6f47c8" translate="yes" xml:space="preserve">
          <source>You can take view from here as well.</source>
          <target state="translated">你也可以在这里取景。</target>
        </trans-unit>
        <trans-unit id="bb064e50508085f145c1589d4249bb5c9a7172dc" translate="yes" xml:space="preserve">
          <source>each index implicitly contains primary key columns appended to that (that is the primary key is in the coverage index). In solutions below I operate directly on the primary key, in you case, you will just need to add primary key columns in the result.</source>
          <target state="translated">每个索引都隐含了主键列(即主键在覆盖索引中)。在下面的解决方案中我直接对主键进行操作,在你的情况下,你只需要在结果中添加主键列即可。</target>
        </trans-unit>
        <trans-unit id="9544b09ea42d2c0e18032bc4cecd486c9b87360e" translate="yes" xml:space="preserve">
          <source>if the underlying index is BTREE index (which is usually the case), the largest &lt;code&gt;(group_id, item_value)&lt;/code&gt; pair is the last value within each &lt;code&gt;group_id&lt;/code&gt;, that is the first for each &lt;code&gt;group_id&lt;/code&gt; if we walk through the index in descending order;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果底层索引是BTREE指数（其通常是这种情况），最大&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(group_id, item_value)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对是每个内的最后值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;group_id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，即第一个为每一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;group_id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们通过以降序的索引行走;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="874be9484ee4451489e054a270b056560700e9e7" translate="yes" xml:space="preserve">
          <source>if we read the values which are covered by an index, the values are read in the order of the index;</source>
          <target state="translated">如果我们读取一个索引所覆盖的值,那么这些值是按照索引的顺序读取的。</target>
        </trans-unit>
        <trans-unit id="d7e92e6ab44616f5629fd1eb078c11805d79e266" translate="yes" xml:space="preserve">
          <source>in many cases it is much cheaper to collect the required row ids in the required order in a subquery and join the result of the subquery on the id. Since for each row in the subquery result MySQL will need a single fetch based on primary key, the subquery will be put first in the join and the rows will be output in the order of the ids in the subquery (if we omit explicit ORDER BY for the join)</source>
          <target state="translated">在很多情况下,在子查询中按照所需的顺序收集所需的行id,然后将子查询的结果加入到id上,会便宜很多。因为对于子查询结果中的每一条记录,MySQL将需要基于主键进行单次取值,所以子查询将被放在join中,而记录将按照子查询中的id的顺序输出(如果我们省略了join中的显式ORDER BY)。</target>
        </trans-unit>
        <trans-unit id="1b14ebfb6f316da8b1c0d2fe564a472eedf03091" translate="yes" xml:space="preserve">
          <source>we will look at how you can use MySQL at getting the last record in a Group By of records. For example if you have this result set of posts.</source>
          <target state="translated">我们将看看如何使用MySQL在获取记录的Group By中的最后一条记录。例如,如果你有这样一组结果的帖子。</target>
        </trans-unit>
        <trans-unit id="34299c5c85340cd7ddedf639ab202e2e2e8a2761" translate="yes" xml:space="preserve">
          <source>which would only need to examine a few 100 rows in this case as it doesn't use any of the normal GROUP BY functions. This would execute in 0 seconds and hence be highly efficient.
Note that normally in MySQL we would see an ORDER BY clause following the GROUP BY clause however this ORDER BY clause is used to determine the ORDER for the last() function, if it was after the GROUP BY then it would be ordering the GROUPS. If no GROUP BY clause is present then the last values will be the same in all of the returned rows.</source>
          <target state="translated">在这种情况下,它只需要检查几条100行,因为它不使用任何正常的GROUP BY函数。这将在0秒内执行,因此效率很高。请注意,通常在MySQL中,我们会在GROUP BY子句之后看到一个ORDER BY子句,但是这个ORDER BY子句是用来确定last()函数的ORDER,如果它在GROUP BY之后,那么它就会对GROUPS进行排序。如果没有GROUP BY子句,那么最后的值在所有返回的行中都是一样的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
