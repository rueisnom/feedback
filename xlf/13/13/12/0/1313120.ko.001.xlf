<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1313120">
    <body>
      <group id="1313120">
        <trans-unit id="bc2f74c22f98f7b6ffbc2f67453dbfa99bce9a32" translate="yes" xml:space="preserve">
          <source>**</source>
          <target state="translated">**</target>
        </trans-unit>
        <trans-unit id="8f645513ffa73d44a4fa5de5330055f3be40b1c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.mysqlperformanceblog.com/2009/09/12/3-ways-mysql-uses-indexes&quot;&gt;3 ways MySQL uses indexes&lt;/a&gt; is a great article to understand some details.</source>
          <target state="translated">&lt;a href=&quot;http://www.mysqlperformanceblog.com/2009/09/12/3-ways-mysql-uses-indexes&quot;&gt;MySQL이 인덱스를 사용하는 3 가지 방법&lt;/a&gt; 은 몇 가지 세부 사항을 이해하기위한 훌륭한 기사입니다.</target>
        </trans-unit>
        <trans-unit id="6b5f5c3163b44cfb577f7102eba674dc7dead525" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This should work both on MySQL and SQL Server.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이것은 MySQL과 SQL Server 모두에서 작동합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ef7cf3995e5d790678b807a725ee0318ff9bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UPD: 2017-03-31, the version &lt;a href=&quot;https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html#mysqld-5-7-5-sql-mode&quot;&gt;5.7.5&lt;/a&gt; of MySQL made the ONLY_FULL_GROUP_BY switch enabled by default (hence, non-deterministic GROUP BY queries became disabled). Moreover, they updated the GROUP BY implementation and the solution might not work as expected anymore even with the disabled switch. One needs to check.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UPD : 2017-03-31, MySQL 버전 &lt;a href=&quot;https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html#mysqld-5-7-5-sql-mode&quot;&gt;5.7.5&lt;/a&gt; 에서는 ONLY_FULL_GROUP_BY 스위치를 기본적으로 활성화했습니다 (따라서 비 결정적 GROUP BY 쿼리는 비활성화 됨).&lt;/em&gt; &lt;em&gt;또한 GROUP BY 구현을 업데이트했으며 비활성화 된 스위치로도 솔루션이 더 이상 예상대로 작동하지 않을 수 있습니다.&lt;/em&gt; &lt;em&gt;확인해야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4aeaa617d0d40556e2ebfbac11a9c7b612cae76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Hi, this query might help :&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;안녕하세요,이 쿼리가 도움이 될 수 있습니다 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cba4951ffd2b51c76d331e5a3fa3e6ec9193fef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c36ab90a22beaab321d017be889526e748936ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e534f76560839fac49d71827900280961455f692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 6&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4417dba7c1c0db0f0da450df72fc6aaf8bffcf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 7&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ebec6ad107992984e17ccecc97ed3cab85a50b7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FIRST SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;첫 번째 솔루션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="096e3dd5b45fc3fbad6172ee5bcf27f1ee5f8f15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First using the technique &lt;a href=&quot;https://stackoverflow.com/questions/1313120/sql-retrieving-the-last-record-in-each-group/1313140#1313140&quot;&gt;shown&lt;/a&gt; by @Eric with the &lt;code&gt;GROUP BY&lt;/code&gt; in a subquery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;먼저 하위 쿼리에서 &lt;code&gt;GROUP BY&lt;/code&gt; 와 함께 @Eric으로 &lt;a href=&quot;https://stackoverflow.com/questions/1313120/sql-retrieving-the-last-record-in-each-group/1313140#1313140&quot;&gt;표시된&lt;/a&gt; 기술을 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d66c96ef877ff9a09a1b6092e2d693638bc51369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now produce the same query result using &lt;a href=&quot;https://stackoverflow.com/questions/121387/fetch-the-row-which-has-the-max-value-for-a-column/123481#123481&quot;&gt;my technique&lt;/a&gt; with &lt;code&gt;LEFT JOIN&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 &lt;code&gt;LEFT JOIN&lt;/code&gt; 과 함께 &lt;a href=&quot;https://stackoverflow.com/questions/121387/fetch-the-row-which-has-the-max-value-for-a-column/123481#123481&quot;&gt;내 기술&lt;/a&gt; 을 사용하여 동일한 쿼리 결과를 생성하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba65d8c19571d88f28ec5b5c980e23acc73041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;QUERY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;QUERY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7f8a11139f03cf3b0c8e2a9df85a2ae32908607" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SECOND SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;두 번째 솔루션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21aa429fd1f960433948c85037e5c8a8b7b989ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;해결책 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="386b462eb4b8c11b6ed2f186c1638cabe4ee6309" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;해결책 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff9929d19b9080a8ccd6f1a2254225e9d9fbe50e" translate="yes" xml:space="preserve">
          <source>Above query will group the all the &lt;code&gt;Other_Columns&lt;/code&gt; that are in same &lt;code&gt;Name&lt;/code&gt; group  and using &lt;code&gt;ORDER BY id DESC&lt;/code&gt; will join all the &lt;code&gt;Other_Columns&lt;/code&gt; in a specific group in descending order  with the provided separator in my case i have used &lt;code&gt;||&lt;/code&gt; ,using &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; over this list will pick the first one</source>
          <target state="translated">위의 쿼리는 동일한 &lt;code&gt;Name&lt;/code&gt; 그룹에있는 모든 &lt;code&gt;Other_Columns&lt;/code&gt; 를 그룹화하고 &lt;code&gt;ORDER BY id DESC&lt;/code&gt; 사용하면 DESC 는 특정 그룹의 모든 &lt;code&gt;Other_Columns&lt;/code&gt; 를 내림차순으로 내림차순으로 내 경우에 사용했습니다. ,이 목록에서 &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; 를 사용하면 첫 번째 목록을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f4f69c12f5f097c3bc85d1c305639e5e3bd817e5" translate="yes" xml:space="preserve">
          <source>An approach with considerable speed is as follows.</source>
          <target state="translated">상당한 속도의 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ffa51cbbf5cad2672d34a40acf2a210fc73291d" translate="yes" xml:space="preserve">
          <source>Another approach :</source>
          <target state="translated">다른 접근법 :</target>
        </trans-unit>
        <trans-unit id="5895da138d7bad5c473af20dabff9e769de91aee" translate="yes" xml:space="preserve">
          <source>As this data is random it means that multiple rows can have the same recordedTimestamps. What we want is to get a list of all of the selected groups in order of groupID with the last recordedTimestamp for each group, and if the same group has more than one matching row like that then the last matching id of those rows.</source>
          <target state="translated">이 데이터는 임의이므로 여러 행에 동일한 recordedTimestamp가있을 수 있습니다. 우리가 원하는 것은 각 그룹에 대해 마지막으로 기록 된 타임 스탬프를 가진 groupID 순서대로 선택한 모든 그룹의 목록을 가져 오는 것입니다. 같은 그룹에 일치하는 행이 둘 이상 있으면 해당 행의 마지막 일치하는 ID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa9ea7afc562036e3828d246e9208813dd89e863" translate="yes" xml:space="preserve">
          <source>At present, this is the query that I use:</source>
          <target state="translated">현재 이것은 내가 사용하는 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="52af234919e0864d5be789ce9e9966fa719f0fdf" translate="yes" xml:space="preserve">
          <source>Below is the original answer I wrote for this question in 2009:</source>
          <target state="translated">아래는 2009 년에이 질문에 대해 작성한 최초의 답변입니다.</target>
        </trans-unit>
        <trans-unit id="dfa20b2c64f084967f88e2b30b428496e758d2ce" translate="yes" xml:space="preserve">
          <source>Bill Karwin's solution above works fine when item count within groups is rather small, but the performance of the query becomes bad when the groups are rather large, since the solution requires about &lt;code&gt;n*n/2 + n/2&lt;/code&gt; of only &lt;code&gt;IS NULL&lt;/code&gt; comparisons.</source>
          <target state="translated">위의 Bill Karwin의 솔루션은 그룹 내 항목 수가 적을 때 잘 작동하지만 그룹이 다소 많으면 쿼리 성능이 나빠집니다. 솔루션에는 &lt;code&gt;IS NULL&lt;/code&gt; 비교의 약 &lt;code&gt;n*n/2 + n/2&lt;/code&gt; 가 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bd4c066734a8ad4492b0a6e00d4fd47414089358" translate="yes" xml:space="preserve">
          <source>Bill's solution has already been running for several hours on my dell e4310 and I do not know when it is going to finish even though it operates on a coverage index (hence &lt;code&gt;using index&lt;/code&gt; in EXPLAIN).</source>
          <target state="translated">Bill의 솔루션은 이미 Dell e4310에서 몇 시간 동안 실행되어 왔으며 커버리지 인덱스에서 작동하더라도 종료 시점을 알 수 없습니다 (따라서 EXPLAIN의 &lt;code&gt;using index&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a540b9b8692c7398481e1d0a45488fe1cb97fc95" translate="yes" xml:space="preserve">
          <source>But the results we get back from this query is.</source>
          <target state="translated">그러나이 쿼리에서 얻은 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="409b3a6cc20c0128a69a6b5836d7b3c4dd161adb" translate="yes" xml:space="preserve">
          <source>But this looks highly inefficient. Any other ways to achieve the same result?</source>
          <target state="translated">그러나 이것은 매우 비효율적입니다. 동일한 결과를 얻는 다른 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="dfa6620c99e58e7436201c6184ee2ca49c84b834" translate="yes" xml:space="preserve">
          <source>Clearly there are lots of different ways of getting the same results, your question seems to be what is an efficient way of getting the last results in each group in MySQL. If you are working with huge amounts of data and assuming you are using InnoDB with even the latest versions of MySQL (such as 5.7.21 and 8.0.4-rc) then there might not be an efficient way of doing this.</source>
          <target state="translated">분명히 동일한 결과를 얻는 데는 여러 가지 방법이 있습니다. 귀하의 질문은 MySQL의 각 그룹에서 마지막 결과를 얻는 효율적인 방법 인 것 같습니다. 방대한 양의 데이터로 작업하고 있고 최신 버전의 MySQL (예 : 5.7.21 및 8.0.4-rc)에서도 InnoDB를 사용한다고 가정하면이를 수행하는 효율적인 방법이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6166e0885a4e9c3b9b6dc26f6c33ee9c6b158c" translate="yes" xml:space="preserve">
          <source>EDIT: Think i found the solution:</source>
          <target state="translated">편집 : 해결책을 찾았습니다 생각 :</target>
        </trans-unit>
        <trans-unit id="da752519d3c02bfcbee192fe71cb5d1c2afba9fc" translate="yes" xml:space="preserve">
          <source>Even the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&quot;&gt;&lt;code&gt;EXPLAIN&lt;/code&gt; analysis&lt;/a&gt; takes over 16 seconds:</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&quot;&gt; &lt;code&gt;EXPLAIN&lt;/code&gt; 분석&lt;/a&gt; 조차도 16 초 이상이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9ab63eeb4d0745316d2eee1767dd903b98520f3c" translate="yes" xml:space="preserve">
          <source>Fiddle Demo</source>
          <target state="translated">바이올린 데모</target>
        </trans-unit>
        <trans-unit id="b7e5708f1f87ff99a200942c6f52c205533b087c" translate="yes" xml:space="preserve">
          <source>Find the propertie with the max m2_price withing each program (n properties in 1 program) :</source>
          <target state="translated">각 프로그램과 함께 최대 m2_price로 속성을 찾으십시오 (1 개의 프로그램에서 n 개의 속성).</target>
        </trans-unit>
        <trans-unit id="159d4ff95f68b8d2bd154edd020461cb5caf121d" translate="yes" xml:space="preserve">
          <source>For example, I have a copy of the &lt;a href=&quot;https://archive.org/details/stackexchange&quot;&gt;StackOverflow August data dump&lt;/a&gt;.  I'll use that for benchmarking.  There are 1,114,357 rows in the &lt;code&gt;Posts&lt;/code&gt; table.  This is running on &lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt; 5.0.75 on my Macbook Pro 2.40GHz.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://archive.org/details/stackexchange&quot;&gt;StackOverflow August 데이터 덤프&lt;/a&gt; 복사본이 있습니다. 벤치마킹에 사용하겠습니다. &lt;code&gt;Posts&lt;/code&gt; 테이블에 1,114,357 개의 행이 있습니다. Macbook Pro 2.40GHz의 &lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt; 5.0.75에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b17d6e4ca90fd7b884da8ccc58edeeefcae86e04" translate="yes" xml:space="preserve">
          <source>For these examples I will use data with only about 1.5 million rows where the queries would need to find results for all groups in the data. In our actual cases we would often need to return back data from about 2,000 groups (which hypothetically would not require examining very much of the data).</source>
          <target state="translated">이 예제에서는 쿼리에서 데이터의 모든 그룹에 대한 결과를 찾아야하는 행이 약 150 만 행인 데이터를 사용합니다. 실제 사례에서 우리는 종종 약 2,000 개의 그룹에서 데이터를 반환해야합니다 (가설 ​​적으로 많은 데이터를 검사 할 필요가 없음).</target>
        </trans-unit>
        <trans-unit id="87d03384f44b47a879deeda44b7ac84af6c50aec" translate="yes" xml:space="preserve">
          <source>Here are two suggestions.  First, if mysql supports ROW_NUMBER(), it's very simple:</source>
          <target state="translated">다음은 두 가지 제안입니다. 먼저, mysql이 ROW_NUMBER ()를 지원하면 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="6c7b5efaecd6bf9fd8ebaf569dd613771dfd1d37" translate="yes" xml:space="preserve">
          <source>Here is another solution that takes about 19 seconds for my table:</source>
          <target state="translated">내 테이블에 약 19 초가 걸리는 다른 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f7e27f60625062718026b18b9e89832af53376" translate="yes" xml:space="preserve">
          <source>Here is another way to get the last related record using &lt;code&gt;GROUP_CONCAT&lt;/code&gt; with order by and &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; to pick one of the record from the list</source>
          <target state="translated">다음은 order by 및 &lt;code&gt;SUBSTRING_INDEX&lt;/code&gt; 와 함께 &lt;code&gt;GROUP_CONCAT&lt;/code&gt; 를 사용하여 마지막 관련 레코드를 가져 와서 목록에서 레코드 중 하나를 선택하는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6a0ac753b84f68190035e002ff7c3d92847813ee" translate="yes" xml:space="preserve">
          <source>Here is my solution:</source>
          <target state="translated">내 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b93bfb210dc14c88784f9e875260957b2d19e337" translate="yes" xml:space="preserve">
          <source>Here's the DDL for my &lt;code&gt;Posts&lt;/code&gt; table:</source>
          <target state="translated">내 &lt;code&gt;Posts&lt;/code&gt; 표에 대한 DDL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b43694db01032ca975a3ee122be4c0ac567c042" translate="yes" xml:space="preserve">
          <source>Hi @Vijay Dev if your table &lt;strong&gt;messages&lt;/strong&gt; contains &lt;strong&gt;Id&lt;/strong&gt; which is auto increment primary key then to fetch the latest record basis on the primary key your query should read as below:</source>
          <target state="translated">테이블 &lt;strong&gt;메시지&lt;/strong&gt; 에 자동 증분 기본 키인 &lt;strong&gt;Id&lt;/strong&gt; 가 포함 된 경우 @Vijay Dev에서 안녕하세요. 그러면 기본 키를 기준으로 최신 레코드 기반을 가져와 쿼리에서 다음과 같이 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="7b7402d87ff4654cdcf49d6ce05c1a115c8ccdc7" translate="yes" xml:space="preserve">
          <source>Hope below Oracle query can help:</source>
          <target state="translated">오라클 쿼리 아래에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">이것은 어떤가요:</target>
        </trans-unit>
        <trans-unit id="056165c6f3e12f6a33964cf8f0af752642c0aab9" translate="yes" xml:space="preserve">
          <source>However MySQL does not have this so let's look at different ideas of what it does have and prove that none of these are efficient.</source>
          <target state="translated">그러나 MySQL에는 이것이 없기 때문에 그것이 가지고있는 것에 대한 다른 아이디어를 살펴보고 이것들 중 어느 것도 효율적이지 않다는 것을 증명합시다.</target>
        </trans-unit>
        <trans-unit id="d85b71d6929ce27f94649bf0418056833e4ab04f" translate="yes" xml:space="preserve">
          <source>I arrived at a different solution, which is to get the IDs for the last post within each group, then select from the messages table using the result from the first query as the argument for a &lt;code&gt;WHERE x IN&lt;/code&gt; construct:</source>
          <target state="translated">다른 솔루션에 도달했습니다. 각 그룹의 마지막 게시물에 대한 ID를 얻은 다음 첫 번째 쿼리의 결과를 &lt;code&gt;WHERE x IN&lt;/code&gt; 구문의 인수로 사용하여 메시지 테이블에서 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2f758943b374e2de01a29386e7186bc2832d669e" translate="yes" xml:space="preserve">
          <source>I don't know how this performs compared to some of the other solutions, but it worked spectacularly for my table with 3+ million rows. (4 second execution with 1200+ results)</source>
          <target state="translated">다른 솔루션과 비교하여 이것이 어떻게 수행되는지는 모르지만 3 백만 행 이상의 테이블에서 훌륭하게 작동했습니다. (1200+ 결과로 4 초 실행)</target>
        </trans-unit>
        <trans-unit id="c79f4514092c5c57c78efdc4efc2c4a179d86a7b" translate="yes" xml:space="preserve">
          <source>I had similar issue (on postgresql tough) and on a 1M records table. This solution takes 1.7s vs 44s produced by the one with LEFT JOIN.
In my case I had to filter the corrispondant of your &lt;em&gt;name&lt;/em&gt; field against NULL values, resulting in even better performances by 0.2 secs</source>
          <target state="translated">비슷한 문제 (postgresql tough)와 1M 레코드 테이블에 있습니다. 이 솔루션은 LEFT JOIN을 사용하여 1.7 초 대 44 초가 걸립니다. 필자의 경우 &lt;em&gt;이름&lt;/em&gt; 필드의 해당 값을 NULL 값으로 필터링하여 0.2 초 더 나은 성능을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="da167e102b3d5e635c7f55d996d67d693a53f36a" translate="yes" xml:space="preserve">
          <source>I have a couple of other solutions that are based on the same ideas:</source>
          <target state="translated">동일한 아이디어를 기반으로하는 다른 솔루션이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f0df4d19dabab6b773646d8e917b78cf2345072" translate="yes" xml:space="preserve">
          <source>I made my tests on a InnoDB table of &lt;code&gt;18684446&lt;/code&gt; rows with &lt;code&gt;1182&lt;/code&gt; groups. The table contains testresults for functional tests and has the &lt;code&gt;(test_id, request_id)&lt;/code&gt; as the primary key. Thus, &lt;code&gt;test_id&lt;/code&gt; is a group and I was searching for the last &lt;code&gt;request_id&lt;/code&gt; for each &lt;code&gt;test_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1182&lt;/code&gt; 그룹의 &lt;code&gt;18684446&lt;/code&gt; 행의 InnoDB 테이블에서 테스트를 수행했습니다. 이 테이블에는 기능 테스트에 대한 테스트 결과가 포함되며 기본 키는 &lt;code&gt;(test_id, request_id)&lt;/code&gt; 입니다. 따라서 &lt;code&gt;test_id&lt;/code&gt; 는 그룹이며 각 &lt;code&gt;test_id&lt;/code&gt; 의 마지막 &lt;code&gt;request_id&lt;/code&gt; 를 검색했습니다.</target>
        </trans-unit>
        <trans-unit id="d996176f5905df1624f8116497fa1de72077529d" translate="yes" xml:space="preserve">
          <source>I want to be able to get the last post in each category which are Title 3, Title 5 and Title 6. To get the posts by the category you will use the MySQL Group By keyboard.</source>
          <target state="translated">제목 3, 제목 5 및 제목 6 인 각 범주에서 마지막 게시물을 얻을 수 있기를 원합니다. 범주별로 게시물을 가져 오려면 MySQL Group By 키보드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="73e045cc5161636dbe8249df55b0e0d0eac97f41" translate="yes" xml:space="preserve">
          <source>I will use the following tables:</source>
          <target state="translated">다음 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b11b882165cd4c620e269037c730139ff813cde5" translate="yes" xml:space="preserve">
          <source>I write the solution this way:</source>
          <target state="translated">나는 이런 식으로 해결책을 씁니다.</target>
        </trans-unit>
        <trans-unit id="2cb7e3a389d31699c10dcaf352f8221c5b08befe" translate="yes" xml:space="preserve">
          <source>I'll write a query to find the most recent post for a given user ID (mine).</source>
          <target state="translated">주어진 사용자 ID (광산)에 대한 최신 게시물을 찾기 위해 쿼리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0441db57073c36c9dcbad5725d9a159517c98628" translate="yes" xml:space="preserve">
          <source>I'm assuming by &quot;last&quot; you mean last in Id order. If not, change the ORDER BY clause of the ROW_NUMBER() window accordingly. If ROW_NUMBER() isn't available, this is another solution:</source>
          <target state="translated">나는 &quot;마지막&quot;으로 가정하고 마지막으로 ID 순서를 의미합니다. 그렇지 않으면 ROW_NUMBER () 창의 ORDER BY 절을 적절히 변경하십시오. ROW_NUMBER ()를 사용할 수 없으면 다른 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="cc052c86860a135a6f085fd44a8a1f24e217e3a7" translate="yes" xml:space="preserve">
          <source>I've not yet tested with large DB but I think this could be faster than joining tables:</source>
          <target state="translated">아직 큰 DB로 테스트하지는 않았지만 테이블을 조인하는 것보다 빠를 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="f314ae9a99438bf63c3f0b555c9e065aab4b46ea" translate="yes" xml:space="preserve">
          <source>If I run a query &lt;code&gt;select * from messages group by name&lt;/code&gt;, I will get the result as:</source>
          <target state="translated">query &lt;code&gt;select * from messages group by name&lt;/code&gt; 실행하면 결과가 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="797a6d4eef68c1f394a200a217d61880cd5ed2d7" translate="yes" xml:space="preserve">
          <source>If hypothetically MySQL had a last() function which returned values from the last row in a special ORDER BY clause then we could simply do:</source>
          <target state="translated">가상의 MySQL에 특별한 ORDER BY 절의 마지막 행에서 값을 반환하는 last () 함수가 있다면 간단히 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="397ad59e8dc6fb0f10b2f5d37063b39999ddda56" translate="yes" xml:space="preserve">
          <source>If it's not &lt;code&gt;id&lt;/code&gt; you want the max of:</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 가 아닌 경우 최대 값을 원합니다.</target>
        </trans-unit>
        <trans-unit id="fdc44790d10a344d9c45e8557b1f1784a0892c6d" translate="yes" xml:space="preserve">
          <source>If performance is really your concern you can introduce a new column on the table called &lt;code&gt;IsLastInGroup&lt;/code&gt; of type BIT.</source>
          <target state="translated">성능이 실제로 우려되는 경우 BIT 유형의 &lt;code&gt;IsLastInGroup&lt;/code&gt; 이라는 테이블에 새 열을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="596781a5f726b6c0fe295b2e871cab00ef658a31" translate="yes" xml:space="preserve">
          <source>If you want the last row for each &lt;code&gt;Name&lt;/code&gt;, then you can give a row number to each row group by the &lt;code&gt;Name&lt;/code&gt; and order by &lt;code&gt;Id&lt;/code&gt; in descending order.</source>
          <target state="translated">각 &lt;code&gt;Name&lt;/code&gt; 의 마지막 행을 원하는 경우 &lt;code&gt;Name&lt;/code&gt; 별로 &lt;code&gt;Id&lt;/code&gt; 를 기준으로 내림차순으로 각 행 그룹에 행 번호를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2f007ea893d6f3c6e118ffeb2a9bed4e6acd781" translate="yes" xml:space="preserve">
          <source>If you want to change the order to ASC, put it in a subquery, return the ids only and use that as the subquery to join to the rest of the columns:</source>
          <target state="translated">순서를 ASC로 변경하려면 하위 쿼리에 넣고 ID 만 반환하고 하위 쿼리로 사용하여 나머지 열에 조인하십시오.</target>
        </trans-unit>
        <trans-unit id="17aca632dd9cf57e5ef672ea1e653cdeb1c6449c" translate="yes" xml:space="preserve">
          <source>In other words, select messages where there is no later-Id message with the same Name.</source>
          <target state="translated">즉, 같은 이름을 가진 나중의 ID 메시지가없는 메시지를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="831a9fcccb916e910885880847357e0eea51c908" translate="yes" xml:space="preserve">
          <source>Is there a way to maybe save the output to a temp variable then delete from  NOT IN (temp variable)? @Bill thanks for a very useful solution.</source>
          <target state="translated">출력을 임시 변수에 저장 한 다음 NOT IN (임시 변수)에서 삭제하는 방법이 있습니까? @Bill은 매우 유용한 솔루션에 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="ada0cba277b001b725563b9d65b32b187fa0ae2b" translate="yes" xml:space="preserve">
          <source>Is there any way we could use this method to delete duplicates in a table? The result set is basically a collection of unique records, so if we could delete all records not in the result set, we would effectively have no duplicates? I tried this but mySQL gave a 1093 error.</source>
          <target state="translated">이 방법을 사용하여 테이블에서 중복을 삭제할 수있는 방법이 있습니까? 결과 집합은 기본적으로 고유 한 레코드 모음이므로 결과 집합에없는 모든 레코드를 삭제할 수 있다면 사실상 중복이 없습니까? 나는 이것을 시도했지만 mySQL은 1093 오류를 주었다.</target>
        </trans-unit>
        <trans-unit id="2e9abaca41125759bfd9e5d67d812105d729c63d" translate="yes" xml:space="preserve">
          <source>It returns tests in descending order as well. It is much slower since it does a full index scan but it is here to give you an idea how to output N max rows for each group.</source>
          <target state="translated">내림차순으로 테스트를 반환합니다. 전체 인덱스 스캔을 수행하기 때문에 속도가 훨씬 느리지 만 각 그룹에 대해 N 개의 최대 행을 출력하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8c11361b17e7c01dbfb348627e33f2ea917dbaa0" translate="yes" xml:space="preserve">
          <source>MySQL 8.0 now supports windowing functions, like almost all popular SQL implementations. With this standard syntax, we can write greatest-n-per-group queries:</source>
          <target state="translated">MySQL 8.0은 이제 거의 모든 인기있는 SQL 구현과 같은 윈도우 기능을 지원합니다. 이 표준 구문을 사용하면 그룹당 최대 n 개의 쿼리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7498655159a7c6a1db086cfbb567bf671cdb7903" translate="yes" xml:space="preserve">
          <source>Reason for this post is to give fiddle link only.
Same SQL is already provided in other answers.</source>
          <target state="translated">이 게시물의 이유는 바이올린 링크 만 제공하는 것입니다. 다른 답변에 동일한 SQL이 이미 제공되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ccfe4e25d21448dd15fe21c154c0902f66df2f" translate="yes" xml:space="preserve">
          <source>Reference Click Here</source>
          <target state="translated">참조 여기를 클릭하십시오</target>
        </trans-unit>
        <trans-unit id="4dbd14c8aebe37e42d2468dbe2ca220c3dd24a16" translate="yes" xml:space="preserve">
          <source>Regarding performance, one solution or the other can be better, depending on the nature of your data. So you should test both queries and use the one that is better at performance given your database.</source>
          <target state="translated">성능과 관련하여 데이터의 특성에 따라 하나의 솔루션 또는 다른 솔루션이 더 나을 수 있습니다. 따라서 두 쿼리를 모두 테스트하고 데이터베이스에 비해 성능이 좋은 쿼리를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea2eb0c5738bc8cf0364f734acf68aa67e48e394" translate="yes" xml:space="preserve">
          <source>Retrieving the last record in each group - MySQL</source>
          <target state="translated">각 그룹에서 마지막 레코드 검색-MySQL</target>
        </trans-unit>
        <trans-unit id="36a563f27a865c596b19c7761ec4e2b026984fa2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle</source>
          <target state="translated">SQL 바이올린</target>
        </trans-unit>
        <trans-unit id="2e164b5bceb0a464ce80e56aff6823f1858c33ba" translate="yes" xml:space="preserve">
          <source>Second, if it doesn't, this is often a good way to proceed:</source>
          <target state="translated">둘째, 그렇지 않은 경우 다음과 같이 진행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="75ebe02529363af8ac2cb81968008f69e5a68b18" translate="yes" xml:space="preserve">
          <source>Set it to true on the columns which are last and maintain it with every row insert/update/delete. Writes will be slower, but you'll benefit on reads. It depends on your use case and I recommend it only if you're read-focused.</source>
          <target state="translated">마지막 열에서는 true로 설정하고 모든 행 삽입 / 업데이트 / 삭제마다 유지하십시오. 쓰기 속도는 느리지 만 읽기에 도움이됩니다. 사용 사례에 따라 다르며 읽기 중심 인 경우에만 권장합니다.</target>
        </trans-unit>
        <trans-unit id="1306934731570ec8e798cf5b4cd03e78daa17a10" translate="yes" xml:space="preserve">
          <source>So your query will look like:</source>
          <target state="translated">따라서 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="479af75d9051b37626a807b3177da597d19796c0" translate="yes" xml:space="preserve">
          <source>Solution By join condition &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/18&quot;&gt;fiddle link&lt;/a&gt;</source>
          <target state="translated">솔루션 결합 조건 &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/18&quot;&gt;바이올린 링크&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b27c248bca752dbaba1f5b514eb99b1bcdc96f" translate="yes" xml:space="preserve">
          <source>Solution by sub query &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/1&quot;&gt;fiddle Link&lt;/a&gt;</source>
          <target state="translated">하위 쿼리 &lt;a href=&quot;http://sqlfiddle.com/#!2/76f31/1&quot;&gt;바이올린 링크에&lt;/a&gt; 의한 솔루션</target>
        </trans-unit>
        <trans-unit id="29cb8ee63e4c8270e106385d8e5c11ee5799bfeb" translate="yes" xml:space="preserve">
          <source>That is, the last record in each group should be returned.</source>
          <target state="translated">즉, 각 그룹의 마지막 레코드가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2bb0de9f8da9dd7162532db1473209ed5825a10b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPLAIN&lt;/code&gt; analysis shows that both tables are able to use their indexes:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 분석에 따르면 두 테이블 모두 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e920682d80f71e871fb5071381e58689d878c2cb" translate="yes" xml:space="preserve">
          <source>The below query will work fine as per your question.</source>
          <target state="translated">아래 쿼리는 귀하의 질문에 따라 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fbb5af9150f5c7e0fd44650e727dd0f46a838bd6" translate="yes" xml:space="preserve">
          <source>The disadvantage of the query is that its result cannot be cached by the query cache.</source>
          <target state="translated">쿼리의 단점은 쿼리 캐시로 결과를 캐시 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5220d6e37a53ba1055afaff9daacc47717d2d61f" translate="yes" xml:space="preserve">
          <source>The group by will always return the first record in the group on the result set.</source>
          <target state="translated">그룹 기준은 항상 결과 집합에서 그룹의 첫 번째 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7dd52bfaec335c59b803de78dc6380ac948b3229" translate="yes" xml:space="preserve">
          <source>The temperature table is populated with about 1.5 million random records, and with 100 different groups.
The selected_group is populated with those 100 groups (in our cases this would normally be less than 20% for all of the groups).</source>
          <target state="translated">온도 표는 약 150 만 개의 무작위 레코드와 100 개의 다른 그룹으로 채워져 있습니다. selected_group은 100 개의 그룹으로 채워집니다 (이 경우 일반적으로 모든 그룹에서 20 % 미만입니다).</target>
        </trans-unit>
        <trans-unit id="ec4e7f239a53c42502c3d2c45c9642be417399a8" translate="yes" xml:space="preserve">
          <source>There is a table &lt;code&gt;messages&lt;/code&gt; that contains data as shown below:</source>
          <target state="translated">아래와 같이 데이터가 포함 된 테이블 &lt;code&gt;messages&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5c5e44410797cfb80e0b55cb8140f14b46c58d" translate="yes" xml:space="preserve">
          <source>This examined 1,505,331 rows and took ~1.25 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">이것은 1,505,331 행을 검사하고 5.7.21에서 ~ 1.25 초가 걸리고 8.0.4-rc에서 약간 더 길었습니다.</target>
        </trans-unit>
        <trans-unit id="81b6914c1559bc587f6326f1599b365c83c12191" translate="yes" xml:space="preserve">
          <source>This examined 3,009,254 rows and took ~0.859 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">이것은 3,009,254 행을 검사하고 5.7.21에서 ~ 0.859 초가 걸리고 8.0.4-rc에서 약간 더 길었습니다.</target>
        </trans-unit>
        <trans-unit id="68ee38cc43cdcf53c46ba3c759220581e6045302" translate="yes" xml:space="preserve">
          <source>This examined 3,009,685 rows and took ~1.95 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">이것은 3,009,685 행을 검사하고 5.7.21에서 ~ 1.95 초가 걸리고 8.0.4-rc에서 약간 더 길었습니다.</target>
        </trans-unit>
        <trans-unit id="9d63c8255231bfb5a1e6b95fc961911c48243edb" translate="yes" xml:space="preserve">
          <source>This examined 6,017,808 rows and took ~4.2 seconds on 8.0.4-rc</source>
          <target state="translated">이것은 6,017,808 행을 검사하고 8.0.4-rc에서 ~ 4.2 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="fc109de8d773a09cf6788ca55e814373baa27457" translate="yes" xml:space="preserve">
          <source>This examined 6,017,908 rows and took ~17.5 seconds on 8.0.4-rc</source>
          <target state="translated">이것은 6,017,908 행을 검사하고 8.0.4-rc에서 ~ 17.5 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="72ec9773fda740bb1bf37b3e30dfc1ce6ad25cf5" translate="yes" xml:space="preserve">
          <source>This examined 6,137,810 rows and took ~2.2 seconds on 5.7.21 and slightly longer on 8.0.4-rc</source>
          <target state="translated">이것은 6,137,810 행을 검사하고 5.7.21에서 ~ 2.2 초가 걸리고 8.0.4-rc에서 약간 더 길었습니다.</target>
        </trans-unit>
        <trans-unit id="27f603924db5fd8fddbe9a57eb559c6a96ccc965" translate="yes" xml:space="preserve">
          <source>This one is incredibly fast, it takes about 0,8 secs on my 18M+ rows:</source>
          <target state="translated">이것은 엄청나게 빠르며 18M + 행에서 약 0.8 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="d56054ecf34d32d8faa73a9cb4c977ff7cfc9ca8" translate="yes" xml:space="preserve">
          <source>This one takes about 1,2 secs on my data.</source>
          <target state="translated">이것은 내 데이터에 약 1.2 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="2d1a634cf82106f06d5f961a9c42270a2cf578cc" translate="yes" xml:space="preserve">
          <source>This one was taking forever so I had to kill it.</source>
          <target state="translated">이건 영원히 복용해서 죽여야 했어요</target>
        </trans-unit>
        <trans-unit id="755305d457fac753eeacf1f66314a371e7fea104" translate="yes" xml:space="preserve">
          <source>This way, you avoid correlated subqueries and/or ordering in your subqueries, which tend to be very slow/inefficient.</source>
          <target state="translated">이렇게하면 매우 느리거나 비효율적 인 하위 쿼리의 상관 된 하위 쿼리 및 / 또는 순서를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="249758b42b9acb20fe5738ab609f7e27cf7b0fbb" translate="yes" xml:space="preserve">
          <source>This will return the posts with the highest IDs in each group.</source>
          <target state="translated">각 그룹에서 ID가 가장 높은 게시물을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">이 시도:</target>
        </trans-unit>
        <trans-unit id="df80017da6bdb06ae1c099a4d4f79dcdcedede04" translate="yes" xml:space="preserve">
          <source>Use your &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/subqueries.html&quot;&gt;subquery&lt;/a&gt; to return the correct grouping, because you're halfway there.</source>
          <target state="translated">중간에 있으므로 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/subqueries.html&quot;&gt;하위 쿼리&lt;/a&gt; 를 사용하여 올바른 그룹화를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="343378ebb4e422d7ee308714179fb8a50ab2941c" translate="yes" xml:space="preserve">
          <source>We sometimes need to do this with tables with even more than 60 million rows.</source>
          <target state="translated">때로는 6000 만 개가 넘는 행이있는 테이블을 사용하여이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="34ab847fb665a4a7425fb456ca2ccb8df1de44b7" translate="yes" xml:space="preserve">
          <source>What query will return the following result?</source>
          <target state="translated">어떤 쿼리가 다음 결과를 반환합니까?</target>
        </trans-unit>
        <trans-unit id="35e155c7e23b04728d125cca110a23de7aab004d" translate="yes" xml:space="preserve">
          <source>You can group by counting and also get the last item of group like:</source>
          <target state="translated">계산하여 그룹화하고 다음과 같이 그룹의 마지막 항목을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d6b48b4fe1053f56f03f22891e1a03ea6f47c8" translate="yes" xml:space="preserve">
          <source>You can take view from here as well.</source>
          <target state="translated">여기서도 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb064e50508085f145c1589d4249bb5c9a7172dc" translate="yes" xml:space="preserve">
          <source>each index implicitly contains primary key columns appended to that (that is the primary key is in the coverage index). In solutions below I operate directly on the primary key, in you case, you will just need to add primary key columns in the result.</source>
          <target state="translated">각 인덱스에는 암시 적으로 추가 된 기본 키 열이 포함됩니다 (즉, 기본 키는 적용 범위 인덱스에 있음). 아래 솔루션에서 기본 키에서 직접 작동하므로 결과에 기본 키 열을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9544b09ea42d2c0e18032bc4cecd486c9b87360e" translate="yes" xml:space="preserve">
          <source>if the underlying index is BTREE index (which is usually the case), the largest &lt;code&gt;(group_id, item_value)&lt;/code&gt; pair is the last value within each &lt;code&gt;group_id&lt;/code&gt;, that is the first for each &lt;code&gt;group_id&lt;/code&gt; if we walk through the index in descending order;</source>
          <target state="translated">기본 인덱스가 BTREE 인덱스 (보통 경우)이면 가장 큰 &lt;code&gt;(group_id, item_value)&lt;/code&gt; 쌍은 각 &lt;code&gt;group_id&lt;/code&gt; 내에서 마지막 값이며, 인덱스를 내림차순으로 걸면 각 group_id 의 첫 번째 값입니다.</target>
        </trans-unit>
        <trans-unit id="874be9484ee4451489e054a270b056560700e9e7" translate="yes" xml:space="preserve">
          <source>if we read the values which are covered by an index, the values are read in the order of the index;</source>
          <target state="translated">인덱스로 커버되는 값을 읽으면 인덱스 순서대로 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="d7e92e6ab44616f5629fd1eb078c11805d79e266" translate="yes" xml:space="preserve">
          <source>in many cases it is much cheaper to collect the required row ids in the required order in a subquery and join the result of the subquery on the id. Since for each row in the subquery result MySQL will need a single fetch based on primary key, the subquery will be put first in the join and the rows will be output in the order of the ids in the subquery (if we omit explicit ORDER BY for the join)</source>
          <target state="translated">많은 경우 하위 쿼리에서 필요한 행 ID를 필요한 순서로 수집하고 하위 쿼리의 결과를 ID에서 결합하는 것이 훨씬 저렴합니다. 하위 쿼리 결과의 각 행에 대해 MySQL은 기본 키를 기반으로 한 단일 가져 오기가 필요하므로 하위 쿼리가 결합에 먼저 들어가고 하위 쿼리의 ID 순서대로 행이 출력됩니다 (명시 적 ORDER BY를 생략 한 경우) 가입)</target>
        </trans-unit>
        <trans-unit id="1b14ebfb6f316da8b1c0d2fe564a472eedf03091" translate="yes" xml:space="preserve">
          <source>we will look at how you can use MySQL at getting the last record in a Group By of records. For example if you have this result set of posts.</source>
          <target state="translated">Group By of 레코드에서 마지막 레코드를 가져올 때 MySQL을 사용하는 방법을 살펴 보겠습니다. 예를 들어이 결과 게시물 세트가있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="34299c5c85340cd7ddedf639ab202e2e2e8a2761" translate="yes" xml:space="preserve">
          <source>which would only need to examine a few 100 rows in this case as it doesn't use any of the normal GROUP BY functions. This would execute in 0 seconds and hence be highly efficient.
Note that normally in MySQL we would see an ORDER BY clause following the GROUP BY clause however this ORDER BY clause is used to determine the ORDER for the last() function, if it was after the GROUP BY then it would be ordering the GROUPS. If no GROUP BY clause is present then the last values will be the same in all of the returned rows.</source>
          <target state="translated">이 경우 일반적인 GROUP BY 함수를 사용하지 않으므로이 경우 몇 개의 100 개 행만 검사하면됩니다. 이것은 0 초 안에 실행되므로 매우 효율적입니다. 일반적으로 MySQL에서는 GROUP BY 절 뒤에 ORDER BY 절이 표시되지만,이 ORDER BY 절은 last () 함수의 ORDER를 결정하는 데 사용됩니다. GROUP BY 이후 인 경우 GROUPS를 주문합니다. GROUP BY 절이 없으면 마지막 값은 반환 된 모든 행에서 동일합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
