<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/13102045">
    <body>
      <group id="13102045">
        <trans-unit id="710a2db5b66ac26e1478825da4ef8408d1069ec9" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;input.nextInt()&lt;/code&gt; consumes only the number, not the &quot;end of line&quot;. When &lt;code&gt;input.nextLine()&lt;/code&gt; executes, it consumes the &quot;end of line&quot; still in the buffer from the first input.</source>
          <target state="translated">、 &lt;code&gt;input.nextInt()&lt;/code&gt; は「行末」ではなく、数値のみを消費します。 &lt;code&gt;input.nextLine()&lt;/code&gt; が実行されると、最初の入力からまだバッファー内にある「行の終わり」が消費されます。</target>
        </trans-unit>
        <trans-unit id="b886918d5042bbbfc958525b15f82c6c7d2e2c84" translate="yes" xml:space="preserve">
          <source>54 234</source>
          <target state="translated">54 234</target>
        </trans-unit>
        <trans-unit id="75fe10c33ab541c3ff9a2dec9478850dc828c24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScanReader sc = new ScanReader(System.in);
&lt;/code&gt;
3. Import necessary Classes :</source>
          <target state="translated">&lt;code&gt;ScanReader sc = new ScanReader(System.in); &lt;/code&gt; 3.必要なクラスをインポートします。</target>
        </trans-unit>
        <trans-unit id="366a4c8a89e72813c933b40b16a4ea31bed9b47f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scanner#nextInt&lt;/code&gt; (and other &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods) doesn't allow Scanner to &lt;em&gt;consume&lt;/em&gt; these line separators. It will read them from &lt;code&gt;System.in&lt;/code&gt; (how else Scanner would know that there are no more digits from the user which represent &lt;code&gt;age&lt;/code&gt; value than facing whitespace?) which will remove them from standard input, but &lt;strong&gt;it will also &lt;em&gt;cache&lt;/em&gt; those line separators internally&lt;/strong&gt;. What we need to remember, is that all of the Scanner methods are always scanning starting from the cached text.</source>
          <target state="translated">&lt;code&gt;Scanner#nextInt&lt;/code&gt; （およびその他の &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; メソッド）は、Scannerがこれらの行セパレーターを使用&lt;em&gt;する&lt;/em&gt;ことを許可しません。 &lt;code&gt;System.in&lt;/code&gt; からそれらを読み取り（標準で入力された空白よりも &lt;code&gt;age&lt;/code&gt; 値を表す桁がユーザーからないことをスキャナーがどのように認識するか）、これらを標準入力から削除しますが、 &lt;strong&gt;これらの行区切り文字を内部的に&lt;em&gt;キャッシュし&lt;/em&gt;&lt;/strong&gt;ます。 私たちが覚えておく必要があるのは、すべてのScannerメソッドが常にキャッシュされたテキストからスキャンを開始していることです。</target>
        </trans-unit>
        <trans-unit id="56b4dfc8432afa4fa111e34e26cc3f44eb402f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
&lt;/code&gt; 
4. Throw IOException from your main method to handle Exception
5. Use Provided Methods.
6. Enjoy</source>
          <target state="translated">&lt;code&gt;import java.io.BufferedInputStream; import java.io.IOException; import java.io.InputStream; &lt;/code&gt; import java.io.IOException; import java.io.InputStream; 4.メインメソッドからIOExceptionをスローして、例外を処理します。5.提供されたメソッドを使用します。 6.楽しむ</target>
        </trans-unit>
        <trans-unit id="373f1750feea9fb203e722a6c277aad2739d5096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sc.nextLine()&lt;/code&gt; is better as compared to parsing the input.
Because performance wise it will be good.</source>
          <target state="translated">&lt;code&gt;sc.nextLine()&lt;/code&gt; は、入力を解析するよりも優れています。 パフォーマンスが賢明だからです。</target>
        </trans-unit>
        <trans-unit id="b35e887c8e2cf9f2d2e03c3bddb48a8a829d7780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; メソッド。</target>
        </trans-unit>
        <trans-unit id="70f588a817efac382b9515d6deb996668f23df8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;if I expect a non-empty input&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;空でない入力を期待する場合&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0d666e158289b5045c42686e3b906f172a349da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;: &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods can &lt;em&gt;skip&lt;/em&gt; delimiters (by default all whitespaces like tabs, line separators) including those cached by scanner, until they will find next non-delimiter value (token). Thanks to that for input like &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; code</source>
          <target state="translated">&lt;strong&gt;BTW&lt;/strong&gt; ： &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; メソッドは、次の非区切り値（トークン）が見つかるまで、スキャナーによってキャッシュされたものを含む区切り文字（デフォルトでは、タブ、行区切り記号などのすべての空白）を&lt;em&gt;スキップ&lt;/em&gt;できます。 &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; コードのような入力をありがとう</target>
        </trans-unit>
        <trans-unit id="0d2adef1f69f8dff2d1dcc4d1bd9850708850158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use 2 scanner objects instead of one&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1つではなく2つのスキャナーオブジェクトを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef28c560bd67f0e0f4953b7c23f5c2507be1533" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Workaround:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Workaround:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61ac0246f79c4b57695a1547128e8b7cded82bb8" translate="yes" xml:space="preserve">
          <source>Advantages :</source>
          <target state="translated">利点 .</target>
        </trans-unit>
        <trans-unit id="fb62cdea39d977351a6037cf5625c21cd1fc59a4" translate="yes" xml:space="preserve">
          <source>Alternatively you can do it C# style and parse a nextLine to an integer like so:</source>
          <target state="translated">あるいは、C#スタイルで nextLine をパースして、次のように整数にすることもできます。</target>
        </trans-unit>
        <trans-unit id="2b1cba757b139aa52180f923668b1674db554ca3" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;nextXXX()&lt;/code&gt; methods don't read &lt;code&gt;newline&lt;/code&gt;, except &lt;code&gt;nextLine()&lt;/code&gt;. We can skip the &lt;code&gt;newline&lt;/code&gt; after reading any &lt;code&gt;non-string&lt;/code&gt; value (&lt;code&gt;int&lt;/code&gt; in this case) by using &lt;code&gt;scanner.skip()&lt;/code&gt; as below:</source>
          <target state="translated">&lt;code&gt;nextXXX()&lt;/code&gt; メソッドは、 &lt;code&gt;nextLine()&lt;/code&gt; を除き、 &lt;code&gt;newline&lt;/code&gt; 読み取らないため。 以下のように &lt;code&gt;scanner.skip()&lt;/code&gt; を使用して、 &lt;code&gt;non-string&lt;/code&gt; 値（この場合は &lt;code&gt;int&lt;/code&gt; ）を読み取った後、 &lt;code&gt;newline&lt;/code&gt; をスキップできます。</target>
        </trans-unit>
        <trans-unit id="0fd82344fa304c1dd4055b949995baf438f7846f" translate="yes" xml:space="preserve">
          <source>As previously stated, calling &lt;code&gt;input.nextLine()&lt;/code&gt; after getting your int value will solve your problem. The reason why your code didn't work was because there was nothing else to store from your input (where you inputted the int) into &lt;code&gt;string1&lt;/code&gt;. I'll just shed a little more light to the entire topic.</source>
          <target state="translated">前述のように、int値を取得した後に &lt;code&gt;input.nextLine()&lt;/code&gt; を呼び出すと問題が解決します。 コードが機能しなかった理由は、入力（intを入力した場所）から &lt;code&gt;string1&lt;/code&gt; に格納するものが他にないためです。 トピック全体に少しだけ光を当てます。</target>
        </trans-unit>
        <trans-unit id="2f31b23750226d934737a24b3f09c090104f16c2" translate="yes" xml:space="preserve">
          <source>BTW &lt;code&gt;nextLine&lt;/code&gt; also &lt;em&gt;consumes&lt;/em&gt; those line separators.</source>
          <target state="translated">BTW &lt;code&gt;nextLine&lt;/code&gt; もこれらの行セパレーターを使用します。</target>
        </trans-unit>
        <trans-unit id="19095fe2701b8ec2bf4d7a6be7459653c80841cb" translate="yes" xml:space="preserve">
          <source>Code :</source>
          <target state="translated">コード .</target>
        </trans-unit>
        <trans-unit id="635fc6fa5a8e88c6c6559e092853eaf5e388aeef" translate="yes" xml:space="preserve">
          <source>Consider &lt;em&gt;nextLine()&lt;/em&gt; as the odd one out among the &lt;em&gt;nextFoo()&lt;/em&gt; methods in the Scanner class. Let's take a quick example.. Let's say we have two lines of code like the ones below:</source>
          <target state="translated">Scannerクラスの&lt;em&gt;nextFoo（）&lt;/em&gt;メソッドの中で奇妙なものとして&lt;em&gt;nextLine（）&lt;/em&gt;を検討してください。 簡単な例を見てみましょう。次のような2行のコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="002e9982d256050d883ef1699f718354b3cc3337" translate="yes" xml:space="preserve">
          <source>Copy the Given Code below your java code.</source>
          <target state="translated">以下の与えられたコードをコピーしてください。</target>
        </trans-unit>
        <trans-unit id="7663ac04f8dea414c68a9376e483611c239cbf2b" translate="yes" xml:space="preserve">
          <source>Doing this works just as well, and it saves you a line of code.</source>
          <target state="translated">これを行うことで、コードの一行分を節約することができます。</target>
        </trans-unit>
        <trans-unit id="13ae67b14ee7a023f7ff33b63de3b4c801273e5c" translate="yes" xml:space="preserve">
          <source>EDIT: as @PatrickParker noted below, this will cause an infinite loop if user inputs any whitespace after the number. See their answer for a better pattern to use with skip: &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https://stackoverflow.com/a/42471816/143585&lt;/a&gt;</source>
          <target state="translated">編集：@PatrickParkerが以下に示すように、ユーザーが数値の後に空白を入力すると、無限ループが発生します。 スキップで使用するより良いパターンについては、回答を参照して&lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;ください&lt;/a&gt; ： https : //stackoverflow.com/a/42471816/143585</target>
        </trans-unit>
        <trans-unit id="a00740e62f881fb4b637adb2a149d6d4dda30c90" translate="yes" xml:space="preserve">
          <source>Either put a &lt;code&gt;Scanner.nextLine&lt;/code&gt; call after each &lt;code&gt;Scanner.nextInt&lt;/code&gt; or &lt;code&gt;Scanner.nextFoo&lt;/code&gt; to consume rest of that line including &lt;em&gt;newline&lt;/em&gt;</source>
          <target state="translated">各 &lt;code&gt;Scanner.nextInt&lt;/code&gt; または &lt;code&gt;Scanner.nextFoo&lt;/code&gt; の後に &lt;code&gt;Scanner.nextLine&lt;/code&gt; 呼び出しを配置し​​て、 &lt;em&gt;改行&lt;/em&gt;を含むその行の残りを消費し&lt;em&gt;ます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="0483beb1135269908e7a45fb455b6f6963675242" translate="yes" xml:space="preserve">
          <source>Example :</source>
          <target state="translated">例.</target>
        </trans-unit>
        <trans-unit id="1ea6c561d0d39b2a9b43c6ee0183e3b4518033f4" translate="yes" xml:space="preserve">
          <source>Flushes Buffer for every next input</source>
          <target state="translated">次の入力のたびにバッファをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="7e06811cbd4c56a0f5d613919cbfee5e88f0a9cf" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;Scanner&lt;/code&gt; methods &lt;code&gt;nextInt()&lt;/code&gt; and &lt;code&gt;nextLine()&lt;/code&gt; for reading input.</source>
          <target state="translated">入力の読み取りに &lt;code&gt;Scanner&lt;/code&gt; メソッド &lt;code&gt;nextInt()&lt;/code&gt; および &lt;code&gt;nextLine()&lt;/code&gt; を使用しています。</target>
        </trans-unit>
        <trans-unit id="696ce6127beeba3523dbb29590922581f35141b0" translate="yes" xml:space="preserve">
          <source>I guess I'm pretty late to the party..</source>
          <target state="translated">かなり遅刻してしまったようですが...。</target>
        </trans-unit>
        <trans-unit id="d349f68c15e01a087fd9a0d658f3db417be916d7" translate="yes" xml:space="preserve">
          <source>I hope this helps.. Merry coding!</source>
          <target state="translated">これが役に立つといいんだけど...。メリーコーデ!</target>
        </trans-unit>
        <trans-unit id="2d556e4c136e883374af9aa52727bd3818d1dd05" translate="yes" xml:space="preserve">
          <source>I tested my application and it looks like the problem lies in using &lt;code&gt;input.nextInt()&lt;/code&gt;. If I delete it, then both &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; and &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; are executed as I want them to be.</source>
          <target state="translated">アプリケーションをテストしましたが、問題は &lt;code&gt;input.nextInt()&lt;/code&gt; の使用にあるようです。 削除すると、 &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; と &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; 両方が希望どおりに実行されます。</target>
        </trans-unit>
        <trans-unit id="77960121ea1555cb0df4ff3bde8191c00116f793" translate="yes" xml:space="preserve">
          <source>If we input the value below (as a single line of input)</source>
          <target state="translated">以下の値を入力すると(1行で入力した場合</target>
        </trans-unit>
        <trans-unit id="a38e67c54c42a5512691e8e1b9804287ebb56652" translate="yes" xml:space="preserve">
          <source>If you want to read both strings and ints, a solution is to use two Scanners:</source>
          <target state="translated">文字列とイントの両方を読みたい場合は、2つのスキャナを使うのが解決策です。</target>
        </trans-unit>
        <trans-unit id="4ded73408781de19fbe45a6dddd399e16827e4cc" translate="yes" xml:space="preserve">
          <source>If you want to scan input fast without getting confused into Scanner class nextLine() method , Use Custom Input Scanner for it .</source>
          <target state="translated">あなたは、スキャナクラスnextLine()メソッドに混乱を得ることなく、高速に入力をスキャンしたい場合,それのためにカスタム入力スキャナを使用してください .</target>
        </trans-unit>
        <trans-unit id="2bf7e3910af2c708c663efffc860e3a0530af49b" translate="yes" xml:space="preserve">
          <source>In one of my usecase, I had the scenario of reading a &lt;strong&gt;string value preceded by a couple of integer values&lt;/strong&gt;. I had to use a &quot;&lt;strong&gt;for / while loop&lt;/strong&gt;&quot; to read the values. And none of the above suggestions worked in this case.</source>
          <target state="translated">私のユースケースの1つで&lt;strong&gt;、いくつかの整数値が前に付い&lt;/strong&gt;た&lt;strong&gt;文字列値&lt;/strong&gt;を読み取るシナリオが&lt;strong&gt;ありました&lt;/strong&gt; 。 値を読み取るには、「 &lt;strong&gt;for / whileループ&lt;/strong&gt; 」を使用する必要がありました。 この場合、上記の提案はどれも機能しませんでした。</target>
        </trans-unit>
        <trans-unit id="10d3c730a99e74d5a24dd317d4db4a694e228ad9" translate="yes" xml:space="preserve">
          <source>In order to avoid the issue, use &lt;code&gt;nextLine();&lt;/code&gt; immediately after &lt;code&gt;nextInt();&lt;/code&gt; as it helps in clearing out the buffer. When you press &lt;code&gt;ENTER&lt;/code&gt; the &lt;code&gt;nextInt();&lt;/code&gt; does not capture the new line and hence, skips the &lt;code&gt;Scanner&lt;/code&gt; code later.</source>
          <target state="translated">この問題を回避するには、 &lt;code&gt;nextLine();&lt;/code&gt; を使用します。 &lt;code&gt;nextInt();&lt;/code&gt; の直後 バッファをクリアするのに役立ちます。 &lt;code&gt;ENTER&lt;/code&gt; を押すと、 &lt;code&gt;nextInt();&lt;/code&gt; 新しい行をキャプチャしないため、後で &lt;code&gt;Scanner&lt;/code&gt; コードをスキップします 。</target>
        </trans-unit>
        <trans-unit id="1edb3ce39c21cf9587795abbe3311a18bf0c8903" translate="yes" xml:space="preserve">
          <source>Initialise Object for Given Class</source>
          <target state="translated">与えられたクラスのオブジェクトを初期化する</target>
        </trans-unit>
        <trans-unit id="b1b2eea9a00239d91a7c93b3f68769f6bc79e8ce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;input.nextLine()&lt;/code&gt; use &lt;code&gt;input.next()&lt;/code&gt;, that should solve the problem.</source>
          <target state="translated">&lt;code&gt;input.nextLine()&lt;/code&gt; の代わりにinput.next（）を使用すると、問題が解決します。</target>
        </trans-unit>
        <trans-unit id="5a9a73068cabea22a1e6fe0fc9bd5ef7971141e4" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;input.nextLine()&lt;/code&gt; immediately after &lt;code&gt;input.nextInt()&lt;/code&gt;</source>
          <target state="translated">代わりに、 &lt;code&gt;input.nextLine()&lt;/code&gt; 直後に &lt;code&gt;input.nextInt()&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="dc65d994a35abffd8df4ed8ea137588c33ec9b15" translate="yes" xml:space="preserve">
          <source>It does that because &lt;code&gt;input.nextInt();&lt;/code&gt; doesn't capture the newline. you could do like the others proposed by adding an &lt;code&gt;input.nextLine();&lt;/code&gt; underneath.</source>
          <target state="translated">それは &lt;code&gt;input.nextInt();&lt;/code&gt; だからです。 改行をキャプチャしません。 &lt;code&gt;input.nextLine();&lt;/code&gt; を追加することで提案された他の方法と同じようにすることができます。 下に。</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">こんな感じです。</target>
        </trans-unit>
        <trans-unit id="3c95406d44cb825b56c4dfe09670a16f7805a269" translate="yes" xml:space="preserve">
          <source>It's because when you enter a number then press</source>
          <target state="translated">それは、数字を入力してから</target>
        </trans-unit>
        <trans-unit id="75d4d0fa84b2616f2559145a9e543dcf04362e6e" translate="yes" xml:space="preserve">
          <source>Lastly, the next() method simply takes the nearest String &lt;strong&gt;without&lt;/strong&gt; generating a new line; this makes this the preferential method for taking separate Strings within the same single line.</source>
          <target state="translated">最後に、next（）メソッドは、新しい行&lt;strong&gt;を&lt;/strong&gt;生成&lt;strong&gt;せずに&lt;/strong&gt;最も近い文字列を取得するだけです。 これにより、これは、同じ単一行内で個別の文字列を取得するための優先的な方法になります。</target>
        </trans-unit>
        <trans-unit id="d1d9319457390e1dead075b888d4ff571e51eac8" translate="yes" xml:space="preserve">
          <source>Methods :</source>
          <target state="translated">方法 .</target>
        </trans-unit>
        <trans-unit id="963f50210de73d6adb4e4a4d700c1acde79d6293" translate="yes" xml:space="preserve">
          <source>Modified code:</source>
          <target state="translated">コードを変更しました。</target>
        </trans-unit>
        <trans-unit id="66848aec0d0dab5e4aa6db56c612529606000bb0" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;Scanner#nextLine()&lt;/code&gt; simply collects and returns all characters &lt;em&gt;until it finds line separators&lt;/em&gt; (or end of stream). But since line separators after reading the number from the console are found immediately in Scanner's cache, it returns empty String, meaning that Scanner was not able to find any character before those line separators (or end of stream).</source>
          <target state="translated">&lt;code&gt;Scanner#nextLine()&lt;/code&gt; は、 &lt;em&gt;行セパレーター&lt;/em&gt; （またはストリームの終わり） &lt;em&gt;が見つかるまで、&lt;/em&gt;すべての文字を収集して返します。 ただし、コンソールから数値を読み取った後の行区切り文字はスキャナーのキャッシュですぐに検出されるため、空の文字列が返されます。つまり、スキャナーはこれらの行区切り文字（またはストリームの終わり）の前に文字を見つけることができませんでした。</target>
        </trans-unit>
        <trans-unit id="6bd03a7d475e74af9f88c473ad6e73bd6b8b77bc" translate="yes" xml:space="preserve">
          <source>Or, even better, read the input through &lt;code&gt;Scanner.nextLine&lt;/code&gt; and convert your input to the proper format you need. For example, you may convert to an integer using &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt;&lt;code&gt;Integer.parseInt(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">または、さらに良いことに、 &lt;code&gt;Scanner.nextLine&lt;/code&gt; を介して入力を読み取り、入力を必要な適切な形式に変換します。 たとえば、 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt; &lt;code&gt;Integer.parseInt(String)&lt;/code&gt; &lt;/a&gt;メソッドを使用して整数に変換できます。</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="35821505e2e6e8e20b4075e0e2fe7993e4ab1ae9" translate="yes" xml:space="preserve">
          <source>Reduces Time Complexity</source>
          <target state="translated">時間的な複雑さを軽減</target>
        </trans-unit>
        <trans-unit id="b3611377a8ddae98b3fd5ae8e68a0494c2318114" translate="yes" xml:space="preserve">
          <source>Scanner is skipping nextLine() after using next() or nextFoo()</source>
          <target state="translated">スキャナが next()または nextFoo()を使用した後に nextLine()をスキップする。</target>
        </trans-unit>
        <trans-unit id="2ba3201f9253fe49326935b9547594c936b32423" translate="yes" xml:space="preserve">
          <source>Scans Input faster than BufferReader</source>
          <target state="translated">BufferReaderよりも高速に入力をスキャン</target>
        </trans-unit>
        <trans-unit id="61f6f5d26bd0fa6841d6a278283463ffb2e7b424" translate="yes" xml:space="preserve">
          <source>So when you are asking the user for value like &lt;code&gt;age&lt;/code&gt;, and user types 42 and presses enter, standard input will contain &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">したがって、ユーザーに &lt;code&gt;age&lt;/code&gt; などの値を要求し、ユーザーが42と入力してEnterキーを押すと、標準入力には &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="915380b2025e2ea32e6d63ecbe5ca0d105e28889" translate="yes" xml:space="preserve">
          <source>So when you want to ask for number and then for entire line while avoiding that empty string as result of &lt;code&gt;nextLine&lt;/code&gt;, either</source>
          <target state="translated">したがって、 &lt;code&gt;nextLine&lt;/code&gt; の結果としての空の文字列を回避しながら、番号を要求してから行全体を要求する場合は、</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="81b083adda697bdb56a20d1790d8681abb807f3b" translate="yes" xml:space="preserve">
          <source>TL;DR Use &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; before each &lt;code&gt;scanner.newLine()&lt;/code&gt; call, which is executed after:</source>
          <target state="translated">TL; DR次の後に実行される &lt;code&gt;scanner.newLine()&lt;/code&gt; 呼び出しの前に、 &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="b9a0dd757f8afd33badbe9990f296a1aafeb6947" translate="yes" xml:space="preserve">
          <source>That's because the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt;&lt;code&gt;Scanner.nextInt&lt;/code&gt;&lt;/a&gt; method does not read the &lt;em&gt;newline&lt;/em&gt; character in your input created by hitting &quot;Enter,&quot; and so the call to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt;&lt;code&gt;Scanner.nextLine&lt;/code&gt;&lt;/a&gt; returns after reading that &lt;em&gt;newline&lt;/em&gt;.</source>
          <target state="translated">これは、 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt; &lt;code&gt;Scanner.nextInt&lt;/code&gt; &lt;/a&gt;メソッドが「Enter」を&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt; &lt;code&gt;Scanner.nextLine&lt;/code&gt; &lt;/a&gt;作成された入力の&lt;em&gt;改行&lt;/em&gt;文字を読み取らないため、その&lt;em&gt;改行を&lt;/em&gt;読み取った後にScanner.nextLineの呼び出しが返されるためです。</target>
        </trans-unit>
        <trans-unit id="6cfe61b93b23a99a69d941bc9eac99b8f483fd93" translate="yes" xml:space="preserve">
          <source>The problem is that after entering the numerical value, the first &lt;code&gt;input.nextLine()&lt;/code&gt; is skipped and the second &lt;code&gt;input.nextLine()&lt;/code&gt; is executed, so that my output looks like this:</source>
          <target state="translated">問題は、数値を入力した後、最初の &lt;code&gt;input.nextLine()&lt;/code&gt; がスキップされ、2番目の &lt;code&gt;input.nextLine()&lt;/code&gt; が実行されるため、出力が次のようになることです。</target>
        </trans-unit>
        <trans-unit id="ddde142a96e23eda3603161b1436db7d86c53024" translate="yes" xml:space="preserve">
          <source>The problem is with the &lt;strong&gt;input.nextInt()&lt;/strong&gt; method - it only reads the int value. So when you continue reading with input.nextLine() you receive the &quot;\n&quot; Enter key. So to skip this you have to add the &lt;strong&gt;input.nextLine()&lt;/strong&gt;. Hope this should be clear now.</source>
          <target state="translated">問題は&lt;strong&gt;input.nextInt（）&lt;/strong&gt;メソッドにあります-これはint値のみを読み取ります。 したがって、input.nextLine（）で読み続けると、「\ n」Enterキーを受け取ります。 したがって、これをスキップするには、 &lt;strong&gt;input.nextLine（）&lt;/strong&gt;を追加する必要があります。 これが今明らかになることを願っています。</target>
        </trans-unit>
        <trans-unit id="3f31e7321f597a2b4fae45f4c1cd3a445c0c7c27" translate="yes" xml:space="preserve">
          <source>The value of our &lt;code&gt;firstNumber&lt;/code&gt; and &lt;code&gt;secondNumber&lt;/code&gt; variable become 54 and 234 respectively. The reason why this works this way is because a new line feed (&lt;em&gt;i.e \n&lt;/em&gt;)  &lt;strong&gt;&lt;em&gt;IS NOT&lt;/em&gt;&lt;/strong&gt; automatically generated when the nextInt() method takes in the values. It simply takes the &lt;em&gt;&quot;next int&quot;&lt;/em&gt; and moves on. This is the same for the rest of the nextFoo() methods except nextLine().</source>
          <target state="translated">&lt;code&gt;secondNumber&lt;/code&gt; 変数とsecondNumber変数の値は、それぞれ54と234になります。 これがこのように機能する理由は、nextInt（）メソッドが値を受け取ったときに、新しいラインフィード（ &lt;em&gt;つまり\ n&lt;/em&gt; ）が自動的に生成されないためです。 それは単に&lt;em&gt;「次の整数」&lt;/em&gt;を取り、 &lt;em&gt;次に&lt;/em&gt;進みます。 これは、nextLine（）を除いて、残りのnextFoo（）メソッドでも同じです。</target>
        </trans-unit>
        <trans-unit id="af8e7ea64187803595eadb5f2b017a3cad5d4a9a" translate="yes" xml:space="preserve">
          <source>There seem to be many questions about this issue with &lt;code&gt;java.util.Scanner&lt;/code&gt;. I think a more readable/idiomatic solution would be to call &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; to drop any newline characters after calling &lt;code&gt;nextInt()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;java.util.Scanner&lt;/code&gt; には 、この問題に関する多くの質問があるようです。 もっと読みやすく、慣用的な解決策は、 &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; を呼び出して、 &lt;code&gt;nextInt()&lt;/code&gt; を呼び出した後に改行文字を削除することです。</target>
        </trans-unit>
        <trans-unit id="452c4ddb10a28ec2d90555e81046ff458fa71020" translate="yes" xml:space="preserve">
          <source>Things you need to know:</source>
          <target state="translated">知っておくべきこと</target>
        </trans-unit>
        <trans-unit id="d3179f988755b5bb60be9c863f7cebddd9b574c9" translate="yes" xml:space="preserve">
          <source>Try it like that:</source>
          <target state="translated">そんな感じでやってみてください。</target>
        </trans-unit>
        <trans-unit id="57407da8b23d181fa23db3253e9d0f4a5430604b" translate="yes" xml:space="preserve">
          <source>Usage :</source>
          <target state="translated">使用法 .</target>
        </trans-unit>
        <trans-unit id="66566971990e9567bbe4356e1d7b83f65d85a803" translate="yes" xml:space="preserve">
          <source>Use this code it will fix your problem.</source>
          <target state="translated">このコードを使用すると問題が解決します。</target>
        </trans-unit>
        <trans-unit id="da071d271d89a4bba999d81fadfe3918d9372bc9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;input.next()&lt;/code&gt; instead of &lt;code&gt;input.nextLine()&lt;/code&gt; fixed the issue. Hope this might be helpful for those dealing with similar scenario.</source>
          <target state="translated">&lt;code&gt;input.next()&lt;/code&gt; 代わりに &lt;code&gt;input.nextLine()&lt;/code&gt; を使用すると、問題が修正されました。 これが同様のシナリオを扱う人々に役立つことを願っています。</target>
        </trans-unit>
        <trans-unit id="7226d641baa8ae41de06bb475758de53fed8eae0" translate="yes" xml:space="preserve">
          <source>What is important is that this key beside ensuring placing user data to &lt;em&gt;standard input&lt;/em&gt; (represented by &lt;code&gt;System.in&lt;/code&gt; which is read by &lt;code&gt;Scanner&lt;/code&gt;) also sends OS dependant line separators (like for Windows &lt;code&gt;\r\n&lt;/code&gt;) after it.</source>
          <target state="translated">重要なのは、ユーザーデータを&lt;em&gt;標準入力&lt;/em&gt; （ &lt;code&gt;System.in&lt;/code&gt; によって表され、 &lt;code&gt;Scanner&lt;/code&gt; によって読み取られる）に配置することを保証するほかに、このキーがOS依存の行区切り文字（Windowsの場合と同様に &lt;code&gt;\r\n&lt;/code&gt; ）も送信することです。</target>
        </trans-unit>
        <trans-unit id="5f74999b3e95cf6f71b9f27aae94da4b0a057762" translate="yes" xml:space="preserve">
          <source>Why not use a new Scanner for every reading? Like below. With this approach you will not confront your problem.</source>
          <target state="translated">読むたびに新しいスキャナを使ってみてはいかがでしょうか?以下のように。このアプローチでは、問題に直面することはありません。</target>
        </trans-unit>
        <trans-unit id="5c4a63babaeaeb0c49e6c1ad33b7739c3722c9c8" translate="yes" xml:space="preserve">
          <source>You will encounter the similar behaviour when you use &lt;code&gt;Scanner.nextLine&lt;/code&gt; after &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt;&lt;code&gt;Scanner.next()&lt;/code&gt;&lt;/a&gt; or any &lt;code&gt;Scanner.nextFoo&lt;/code&gt; method (except &lt;code&gt;nextLine&lt;/code&gt; itself).</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt; &lt;code&gt;Scanner.next()&lt;/code&gt; &lt;/a&gt;または任意の &lt;code&gt;Scanner.nextFoo&lt;/code&gt; メソッド（ &lt;code&gt;nextLine&lt;/code&gt; 自体を除く）の後にScanner.nextLineを使用すると、同様の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="9fea7758b88440c7c56014d785e74b79822df1b6" translate="yes" xml:space="preserve">
          <source>calling &lt;code&gt;nextLine&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;nextLine&lt;/code&gt; を呼び出す</target>
        </trans-unit>
        <trans-unit id="5bff49825d310d45ca3198277065d394e5a1403e" translate="yes" xml:space="preserve">
          <source>carriage return (CR - in String literals represented as &lt;code&gt;&quot;\r&quot;&lt;/code&gt;)</source>
          <target state="translated">復帰（CR- &lt;code&gt;&quot;\r&quot;&lt;/code&gt; として表される文字列リテラル）</target>
        </trans-unit>
        <trans-unit id="d71a472719c217d1cbb03b0100ec6f4d7963af45" translate="yes" xml:space="preserve">
          <source>consume line separator left by &lt;code&gt;nextInt&lt;/code&gt; from Scanners cache by</source>
          <target state="translated">スキャナーのキャッシュから &lt;code&gt;nextInt&lt;/code&gt; によって残された行セパレーターを使用</target>
        </trans-unit>
        <trans-unit id="906919592563b8ceb86995b2350c1f3d4e41ab40" translate="yes" xml:space="preserve">
          <source>don't use &lt;code&gt;nextInt&lt;/code&gt; (nor &lt;code&gt;next&lt;/code&gt;, or any &lt;code&gt;nextTYPE&lt;/code&gt; methods) at all. Instead read entire data line-by-line using &lt;code&gt;nextLine&lt;/code&gt; and parse numbers from each line (assuming one line contains only one number) to proper type like &lt;code&gt;int&lt;/code&gt; via &lt;code&gt;Integer.parseInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nextInt&lt;/code&gt; （または &lt;code&gt;next&lt;/code&gt; 、または &lt;code&gt;nextTYPE&lt;/code&gt; メソッド）をまったく使用しないでください。 代わりに、 &lt;code&gt;nextLine&lt;/code&gt; を使用してデータ全体を1行ずつ読み取り 、 各行の数値を解析して（1行に1つの数値しかないと想定）、 &lt;code&gt;Integer.parseInt&lt;/code&gt; を介して &lt;code&gt;int&lt;/code&gt; のような適切なタイプに変換します 。</target>
        </trans-unit>
        <trans-unit id="777254e6cdb58468ee14265cac12172de470597b" translate="yes" xml:space="preserve">
          <source>line feed (LF - in String literals represented as &lt;code&gt;&quot;\n&quot;&lt;/code&gt;)</source>
          <target state="translated">改行（LF- &lt;code&gt;&quot;\n&quot;&lt;/code&gt; として表される文字列リテラル）</target>
        </trans-unit>
        <trans-unit id="8da85052008fcd09092d1cdda4d021c77716afa0" translate="yes" xml:space="preserve">
          <source>nextLine() generates a new line feed immediately after taking a value; this is what @RohitJain means by saying the new line feed is &quot;consumed&quot;.</source>
          <target state="translated">nextLine()は値を取得した直後に改行を生成します。</target>
        </trans-unit>
        <trans-unit id="2adabff3d49bda2a937fc4b067e7987b56a2272d" translate="yes" xml:space="preserve">
          <source>or IMO &lt;strong&gt;&lt;em&gt;more readable&lt;/em&gt;&lt;/strong&gt; way would be by calling &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; or &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; to let Scanner skip part matched by line separator (more info about &lt;code&gt;\R&lt;/code&gt;: &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https://stackoverflow.com/a/31060125&lt;/a&gt;)</source>
          <target state="translated">またはIMO &lt;strong&gt;&lt;em&gt;より読みやすい&lt;/em&gt;&lt;/strong&gt;方法は、 &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; または &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; を呼び出して、スキャナーが行区切り文字によって一致する部分をスキップできるようにすることです（ &lt;code&gt;\R&lt;/code&gt; 詳細： &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https）。 ：//stackoverflow.com/a/31060125&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="1f6110eaae5d5a0ecdc62ad5c92021701b7e35bc" translate="yes" xml:space="preserve">
          <source>scanChar() - scan single character</source>
          <target state="translated">scanChar()-一文字をスキャンする</target>
        </trans-unit>
        <trans-unit id="cd026e2048c739cc97f92689f612919ef5c6f357" translate="yes" xml:space="preserve">
          <source>scanDouble() - scan Double value</source>
          <target state="translated">scanDouble()-ダブル値をスキャンする</target>
        </trans-unit>
        <trans-unit id="f9f73c1f34ff7aacd07be55f18ef5aa637930aab" translate="yes" xml:space="preserve">
          <source>scanInt() - scan Integer value</source>
          <target state="translated">scanInt()-整数値をスキャンする</target>
        </trans-unit>
        <trans-unit id="ef1eda467483f01eb3b62158743bad7b3d0cae6b" translate="yes" xml:space="preserve">
          <source>scanInt(int[] array) - scans complete Array(Integer)</source>
          <target state="translated">scanInt(int[]配列)-完全な配列(整数)をスキャンします。</target>
        </trans-unit>
        <trans-unit id="2465b71fb96ee91597729b6326b210dde7b49bf2" translate="yes" xml:space="preserve">
          <source>scanLong() - scan Long value</source>
          <target state="translated">scanLong()-ロング値をスキャンします。</target>
        </trans-unit>
        <trans-unit id="b51f0a30704bc4d31354bd7ed09956e546786886" translate="yes" xml:space="preserve">
          <source>scanLong(long[] array) - scans complete Array(Long)</source>
          <target state="translated">scanLong(long[]配列)-完全な配列(Long)をスキャンします。</target>
        </trans-unit>
        <trans-unit id="5573ccf4ef9b0ea26f56581c29410ab374bbbaef" translate="yes" xml:space="preserve">
          <source>scanString() - scan String value</source>
          <target state="translated">scanString()-文字列の値をスキャンする</target>
        </trans-unit>
        <trans-unit id="6bbab5d9b19a578d0536edf4fdcfc1a8f42cbf35" translate="yes" xml:space="preserve">
          <source>text which represents few lines also contains non-printable characters between lines (we call them line separators) like</source>
          <target state="translated">のように行間には印刷不可能な文字が含まれています(これを行区切り文字と呼んでいます)。</target>
        </trans-unit>
        <trans-unit id="2f36c69e8c8276a72aa79a95117c23454c420b24" translate="yes" xml:space="preserve">
          <source>used in above example:</source>
          <target state="translated">を使用しています。</target>
        </trans-unit>
        <trans-unit id="78bcf988e9009f9c4b7a945f5289e06addc0b65f" translate="yes" xml:space="preserve">
          <source>when you are reading data from the console, it allows the user to type his response and when he is done he needs to &lt;em&gt;somehow&lt;/em&gt; confirm that fact. To do so, the user is required to press &quot;enter&quot;/&quot;return&quot; key on the keyboard.</source>
          <target state="translated">コンソールからデータを読み取っているときに、ユーザーは応答を入力できます。完了したら、 &lt;em&gt;何らかの形で&lt;/em&gt;その事実を確認する必要があります。 これを行うには、ユーザーはキーボードの「Enter」/「Return」キーを押す必要があります。</target>
        </trans-unit>
        <trans-unit id="9fb12221c0f1d15ac31091e556227d379cefd286" translate="yes" xml:space="preserve">
          <source>will be able to properly assign &lt;code&gt;num1=42&lt;/code&gt;&lt;code&gt;num2=321&lt;/code&gt;&lt;code&gt;name=foobar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;num1=42&lt;/code&gt; &lt;code&gt;num2=321&lt;/code&gt; &lt;code&gt;name=foobar&lt;/code&gt; を適切に割り当てることができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
