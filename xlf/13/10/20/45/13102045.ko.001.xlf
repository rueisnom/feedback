<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/13102045">
    <body>
      <group id="13102045">
        <trans-unit id="710a2db5b66ac26e1478825da4ef8408d1069ec9" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;input.nextInt()&lt;/code&gt; consumes only the number, not the &quot;end of line&quot;. When &lt;code&gt;input.nextLine()&lt;/code&gt; executes, it consumes the &quot;end of line&quot; still in the buffer from the first input.</source>
          <target state="translated">&lt;code&gt;input.nextInt()&lt;/code&gt; 는 &quot;줄 끝&quot;이 아닌 숫자 만 사용합니다. &lt;code&gt;input.nextLine()&lt;/code&gt; 실행될 때 첫 번째 입력에서 여전히 버퍼에있는 &quot;end of line&quot;을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b886918d5042bbbfc958525b15f82c6c7d2e2c84" translate="yes" xml:space="preserve">
          <source>54 234</source>
          <target state="translated">54234</target>
        </trans-unit>
        <trans-unit id="75fe10c33ab541c3ff9a2dec9478850dc828c24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScanReader sc = new ScanReader(System.in);
&lt;/code&gt;
3. Import necessary Classes :</source>
          <target state="translated">&lt;code&gt;ScanReader sc = new ScanReader(System.in); &lt;/code&gt; 3. 필요한 수업 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="366a4c8a89e72813c933b40b16a4ea31bed9b47f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scanner#nextInt&lt;/code&gt; (and other &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods) doesn't allow Scanner to &lt;em&gt;consume&lt;/em&gt; these line separators. It will read them from &lt;code&gt;System.in&lt;/code&gt; (how else Scanner would know that there are no more digits from the user which represent &lt;code&gt;age&lt;/code&gt; value than facing whitespace?) which will remove them from standard input, but &lt;strong&gt;it will also &lt;em&gt;cache&lt;/em&gt; those line separators internally&lt;/strong&gt;. What we need to remember, is that all of the Scanner methods are always scanning starting from the cached text.</source>
          <target state="translated">&lt;code&gt;Scanner#nextInt&lt;/code&gt; (및 기타 &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; 메서드)에서는 스캐너가 이러한 줄 구분 기호를 &lt;em&gt;사용할&lt;/em&gt; 수 없습니다. &lt;code&gt;System.in&lt;/code&gt; 에서 읽습니다 (다른 방법으로 스캐너는 공백을 입력하는 것보다 &lt;code&gt;age&lt;/code&gt; 값을 나타내는 숫자가 사용자에게 더 이상 없다는 것을 알 수 있습니까?). 표준 입력에서 제거하지만 &lt;strong&gt;내부적으로 해당 행 구분 기호를 &lt;em&gt;캐시&lt;/em&gt; 합니다&lt;/strong&gt; . 우리가 기억해야 할 것은 모든 스캐너 메소드가 항상 캐시 된 텍스트부터 스캔한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="56b4dfc8432afa4fa111e34e26cc3f44eb402f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
&lt;/code&gt; 
4. Throw IOException from your main method to handle Exception
5. Use Provided Methods.
6. Enjoy</source>
          <target state="translated">&lt;code&gt;import java.io.BufferedInputStream; import java.io.IOException; import java.io.InputStream; &lt;/code&gt; import java.io.IOException; import java.io.InputStream; 4. 메인 메소드에서 IOException을 발생시켜 예외를 처리합니다. 5. 제공된 메소드를 사용하십시오. 6. 즐기십시오</target>
        </trans-unit>
        <trans-unit id="373f1750feea9fb203e722a6c277aad2739d5096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sc.nextLine()&lt;/code&gt; is better as compared to parsing the input.
Because performance wise it will be good.</source>
          <target state="translated">입력 구문 분석에 비해 &lt;code&gt;sc.nextLine()&lt;/code&gt; 이 더 좋습니다. 성능이 현명하기 때문에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b35e887c8e2cf9f2d2e03c3bddb48a8a829d7780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="70f588a817efac382b9515d6deb996668f23df8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;if I expect a non-empty input&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;비어 있지 않은 입력이 예상되는 경우&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0d666e158289b5045c42686e3b906f172a349da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;: &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods can &lt;em&gt;skip&lt;/em&gt; delimiters (by default all whitespaces like tabs, line separators) including those cached by scanner, until they will find next non-delimiter value (token). Thanks to that for input like &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; code</source>
          <target state="translated">&lt;strong&gt;BTW&lt;/strong&gt; : &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; 방법은 스캐너가 캐싱 한 것을 포함하여 구분 기호 (기본적으로 탭, 줄 구분 기호와 같은 모든 공백)를 &lt;em&gt;건너 뛸&lt;/em&gt; 수 있습니다. &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; 코드와 같은 입력 덕분입니다.</target>
        </trans-unit>
        <trans-unit id="0d2adef1f69f8dff2d1dcc4d1bd9850708850158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use 2 scanner objects instead of one&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;하나 대신 2 개의 스캐너 개체를 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef28c560bd67f0e0f4953b7c23f5c2507be1533" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Workaround:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Workaround:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61ac0246f79c4b57695a1547128e8b7cded82bb8" translate="yes" xml:space="preserve">
          <source>Advantages :</source>
          <target state="translated">장점 :</target>
        </trans-unit>
        <trans-unit id="fb62cdea39d977351a6037cf5625c21cd1fc59a4" translate="yes" xml:space="preserve">
          <source>Alternatively you can do it C# style and parse a nextLine to an integer like so:</source>
          <target state="translated">또는 C # 스타일로 nextLine을 정수로 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b1cba757b139aa52180f923668b1674db554ca3" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;nextXXX()&lt;/code&gt; methods don't read &lt;code&gt;newline&lt;/code&gt;, except &lt;code&gt;nextLine()&lt;/code&gt;. We can skip the &lt;code&gt;newline&lt;/code&gt; after reading any &lt;code&gt;non-string&lt;/code&gt; value (&lt;code&gt;int&lt;/code&gt; in this case) by using &lt;code&gt;scanner.skip()&lt;/code&gt; as below:</source>
          <target state="translated">&lt;code&gt;nextXXX()&lt;/code&gt; 메소드는 &lt;code&gt;nextLine()&lt;/code&gt; 제외하고 &lt;code&gt;newline&lt;/code&gt; 을 읽지 않습니다. 다음과 같이 &lt;code&gt;scanner.skip()&lt;/code&gt; 를 사용하여 &lt;code&gt;non-string&lt;/code&gt; 값 (이 경우 &lt;code&gt;int&lt;/code&gt; ) 을 읽은 후 &lt;code&gt;newline&lt;/code&gt; 을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd82344fa304c1dd4055b949995baf438f7846f" translate="yes" xml:space="preserve">
          <source>As previously stated, calling &lt;code&gt;input.nextLine()&lt;/code&gt; after getting your int value will solve your problem. The reason why your code didn't work was because there was nothing else to store from your input (where you inputted the int) into &lt;code&gt;string1&lt;/code&gt;. I'll just shed a little more light to the entire topic.</source>
          <target state="translated">앞에서 언급했듯이 int 값을 얻은 후 &lt;code&gt;input.nextLine()&lt;/code&gt; 을 호출 하면 문제가 해결됩니다. 코드가 작동하지 않는 이유는 입력 (int를 입력 한 곳)에서 &lt;code&gt;string1&lt;/code&gt; 로 저장할 다른 것이 없기 때문입니다. 나는 전체 주제에 대해 조금 더 밝힐 것이다.</target>
        </trans-unit>
        <trans-unit id="2f31b23750226d934737a24b3f09c090104f16c2" translate="yes" xml:space="preserve">
          <source>BTW &lt;code&gt;nextLine&lt;/code&gt; also &lt;em&gt;consumes&lt;/em&gt; those line separators.</source>
          <target state="translated">BTW &lt;code&gt;nextLine&lt;/code&gt; 은 또한 이러한 라인 구분 기호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="19095fe2701b8ec2bf4d7a6be7459653c80841cb" translate="yes" xml:space="preserve">
          <source>Code :</source>
          <target state="translated">코드 :</target>
        </trans-unit>
        <trans-unit id="635fc6fa5a8e88c6c6559e092853eaf5e388aeef" translate="yes" xml:space="preserve">
          <source>Consider &lt;em&gt;nextLine()&lt;/em&gt; as the odd one out among the &lt;em&gt;nextFoo()&lt;/em&gt; methods in the Scanner class. Let's take a quick example.. Let's say we have two lines of code like the ones below:</source>
          <target state="translated">스캐너 클래스의 &lt;em&gt;nextFoo ()&lt;/em&gt; 메소드 중에서 &lt;em&gt;nextLine ()&lt;/em&gt; 을 홀수로 고려하십시오. 간단한 예를 들어 보자. 아래 코드와 같이 두 줄의 코드가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="002e9982d256050d883ef1699f718354b3cc3337" translate="yes" xml:space="preserve">
          <source>Copy the Given Code below your java code.</source>
          <target state="translated">자바 코드 아래에 주어진 코드를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="7663ac04f8dea414c68a9376e483611c239cbf2b" translate="yes" xml:space="preserve">
          <source>Doing this works just as well, and it saves you a line of code.</source>
          <target state="translated">이 작업도 마찬가지로 작동하므로 코드를 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ae67b14ee7a023f7ff33b63de3b4c801273e5c" translate="yes" xml:space="preserve">
          <source>EDIT: as @PatrickParker noted below, this will cause an infinite loop if user inputs any whitespace after the number. See their answer for a better pattern to use with skip: &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https://stackoverflow.com/a/42471816/143585&lt;/a&gt;</source>
          <target state="translated">편집 : 아래의 @PatrickParker와 같이 사용자가 숫자 뒤에 공백을 입력하면 무한 루프가 발생합니다. skip과 함께 사용하기에 더 나은 패턴에 대한 답변은 &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https://stackoverflow.com/a/42471816/143585에서 확인하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a00740e62f881fb4b637adb2a149d6d4dda30c90" translate="yes" xml:space="preserve">
          <source>Either put a &lt;code&gt;Scanner.nextLine&lt;/code&gt; call after each &lt;code&gt;Scanner.nextInt&lt;/code&gt; or &lt;code&gt;Scanner.nextFoo&lt;/code&gt; to consume rest of that line including &lt;em&gt;newline&lt;/em&gt;</source>
          <target state="translated">각 &lt;code&gt;Scanner.nextInt&lt;/code&gt; 또는 &lt;code&gt;Scanner.nextFoo&lt;/code&gt; 뒤에 &lt;code&gt;Scanner.nextLine&lt;/code&gt; 호출을 넣어 &lt;em&gt;개행을&lt;/em&gt; 포함한 나머지 행을 소비하십시오.</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="0483beb1135269908e7a45fb455b6f6963675242" translate="yes" xml:space="preserve">
          <source>Example :</source>
          <target state="translated">예 :</target>
        </trans-unit>
        <trans-unit id="1ea6c561d0d39b2a9b43c6ee0183e3b4518033f4" translate="yes" xml:space="preserve">
          <source>Flushes Buffer for every next input</source>
          <target state="translated">다음 입력마다 플러시 버퍼</target>
        </trans-unit>
        <trans-unit id="7e06811cbd4c56a0f5d613919cbfee5e88f0a9cf" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;Scanner&lt;/code&gt; methods &lt;code&gt;nextInt()&lt;/code&gt; and &lt;code&gt;nextLine()&lt;/code&gt; for reading input.</source>
          <target state="translated">입력을 읽는 데 &lt;code&gt;Scanner&lt;/code&gt; 메소드 &lt;code&gt;nextInt()&lt;/code&gt; 및 &lt;code&gt;nextLine()&lt;/code&gt; 을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="696ce6127beeba3523dbb29590922581f35141b0" translate="yes" xml:space="preserve">
          <source>I guess I'm pretty late to the party..</source>
          <target state="translated">파티에 늦었을 것 같아 ..</target>
        </trans-unit>
        <trans-unit id="d349f68c15e01a087fd9a0d658f3db417be916d7" translate="yes" xml:space="preserve">
          <source>I hope this helps.. Merry coding!</source>
          <target state="translated">도움이 되길 바랍니다 .. 즐거운 코딩!</target>
        </trans-unit>
        <trans-unit id="2d556e4c136e883374af9aa52727bd3818d1dd05" translate="yes" xml:space="preserve">
          <source>I tested my application and it looks like the problem lies in using &lt;code&gt;input.nextInt()&lt;/code&gt;. If I delete it, then both &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; and &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; are executed as I want them to be.</source>
          <target state="translated">내 응용 프로그램을 테스트 &lt;code&gt;input.nextInt()&lt;/code&gt; 사용하는 데 문제가있는 것 같습니다. 삭제하면 &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; 및 &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; 모두 원하는대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="77960121ea1555cb0df4ff3bde8191c00116f793" translate="yes" xml:space="preserve">
          <source>If we input the value below (as a single line of input)</source>
          <target state="translated">아래의 값을 입력하면 (한 줄의 입력으로)</target>
        </trans-unit>
        <trans-unit id="a38e67c54c42a5512691e8e1b9804287ebb56652" translate="yes" xml:space="preserve">
          <source>If you want to read both strings and ints, a solution is to use two Scanners:</source>
          <target state="translated">문자열과 정수를 모두 읽으려면 두 개의 스캐너를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4ded73408781de19fbe45a6dddd399e16827e4cc" translate="yes" xml:space="preserve">
          <source>If you want to scan input fast without getting confused into Scanner class nextLine() method , Use Custom Input Scanner for it .</source>
          <target state="translated">스캐너 클래스 nextLine () 메소드에 혼동하지 않고 입력을 빠르게 스캔하려면 사용자 정의 입력 스캐너를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2bf7e3910af2c708c663efffc860e3a0530af49b" translate="yes" xml:space="preserve">
          <source>In one of my usecase, I had the scenario of reading a &lt;strong&gt;string value preceded by a couple of integer values&lt;/strong&gt;. I had to use a &quot;&lt;strong&gt;for / while loop&lt;/strong&gt;&quot; to read the values. And none of the above suggestions worked in this case.</source>
          <target state="translated">유스 케이스 중 하나에서 &lt;strong&gt;문자열 값&lt;/strong&gt; 을 읽고 &lt;strong&gt;두 개의 정수 값&lt;/strong&gt; 을 읽는 시나리오가있었습니다. 값을 읽으려면 &quot; &lt;strong&gt;for / while loop&lt;/strong&gt; &quot;를 사용해야했습니다. 그리고이 경우 위의 제안 중 어느 것도 효과가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="10d3c730a99e74d5a24dd317d4db4a694e228ad9" translate="yes" xml:space="preserve">
          <source>In order to avoid the issue, use &lt;code&gt;nextLine();&lt;/code&gt; immediately after &lt;code&gt;nextInt();&lt;/code&gt; as it helps in clearing out the buffer. When you press &lt;code&gt;ENTER&lt;/code&gt; the &lt;code&gt;nextInt();&lt;/code&gt; does not capture the new line and hence, skips the &lt;code&gt;Scanner&lt;/code&gt; code later.</source>
          <target state="translated">이 문제를 피하려면 &lt;code&gt;nextLine();&lt;/code&gt; &lt;code&gt;nextInt();&lt;/code&gt; 직후 버퍼를 지우는 데 도움이됩니다. &lt;code&gt;ENTER&lt;/code&gt; 를 누르면 &lt;code&gt;nextInt();&lt;/code&gt; 새 줄을 캡처하지 않으므로 나중에 &lt;code&gt;Scanner&lt;/code&gt; 코드를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="1edb3ce39c21cf9587795abbe3311a18bf0c8903" translate="yes" xml:space="preserve">
          <source>Initialise Object for Given Class</source>
          <target state="translated">주어진 클래스에 대한 객체 초기화</target>
        </trans-unit>
        <trans-unit id="b1b2eea9a00239d91a7c93b3f68769f6bc79e8ce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;input.nextLine()&lt;/code&gt; use &lt;code&gt;input.next()&lt;/code&gt;, that should solve the problem.</source>
          <target state="translated">&lt;code&gt;input.nextLine()&lt;/code&gt; 대신 input.next ()를 사용하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="5a9a73068cabea22a1e6fe0fc9bd5ef7971141e4" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;input.nextLine()&lt;/code&gt; immediately after &lt;code&gt;input.nextInt()&lt;/code&gt;</source>
          <target state="translated">대신 &lt;code&gt;input.nextLine()&lt;/code&gt; 바로 다음에 &lt;code&gt;input.nextInt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc65d994a35abffd8df4ed8ea137588c33ec9b15" translate="yes" xml:space="preserve">
          <source>It does that because &lt;code&gt;input.nextInt();&lt;/code&gt; doesn't capture the newline. you could do like the others proposed by adding an &lt;code&gt;input.nextLine();&lt;/code&gt; underneath.</source>
          <target state="translated">&lt;code&gt;input.nextInt();&lt;/code&gt; 때문에 그렇게합니다. 개행을 캡처하지 않습니다. &lt;code&gt;input.nextLine();&lt;/code&gt; 을 추가하여 제안 된 다른 것들처럼 할 수 있습니다 . 아래에.</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="3c95406d44cb825b56c4dfe09670a16f7805a269" translate="yes" xml:space="preserve">
          <source>It's because when you enter a number then press</source>
          <target state="translated">숫자를 입력 한 다음</target>
        </trans-unit>
        <trans-unit id="75d4d0fa84b2616f2559145a9e543dcf04362e6e" translate="yes" xml:space="preserve">
          <source>Lastly, the next() method simply takes the nearest String &lt;strong&gt;without&lt;/strong&gt; generating a new line; this makes this the preferential method for taking separate Strings within the same single line.</source>
          <target state="translated">마지막으로 next () 메소드는 새로운 줄 &lt;strong&gt;을&lt;/strong&gt; 생성 &lt;strong&gt;하지 않고&lt;/strong&gt; 가장 가까운 String &lt;strong&gt;을&lt;/strong&gt; 가져옵니다. 이것은 동일한 단일 행 내에서 별도의 문자열을 취하는 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d1d9319457390e1dead075b888d4ff571e51eac8" translate="yes" xml:space="preserve">
          <source>Methods :</source>
          <target state="translated">방법 :</target>
        </trans-unit>
        <trans-unit id="963f50210de73d6adb4e4a4d700c1acde79d6293" translate="yes" xml:space="preserve">
          <source>Modified code:</source>
          <target state="translated">수정 된 코드 :</target>
        </trans-unit>
        <trans-unit id="66848aec0d0dab5e4aa6db56c612529606000bb0" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;Scanner#nextLine()&lt;/code&gt; simply collects and returns all characters &lt;em&gt;until it finds line separators&lt;/em&gt; (or end of stream). But since line separators after reading the number from the console are found immediately in Scanner's cache, it returns empty String, meaning that Scanner was not able to find any character before those line separators (or end of stream).</source>
          <target state="translated">이제 &lt;code&gt;Scanner#nextLine()&lt;/code&gt; 단순히 &lt;em&gt;줄 구분 기호&lt;/em&gt; (또는 스트림 끝)를 &lt;em&gt;찾을 때까지&lt;/em&gt; 모든 문자를 수집하고 반환합니다. 그러나 콘솔에서 숫자를 읽은 후 줄 구분 기호는 스캐너의 캐시에서 즉시 발견되므로 빈 문자열을 반환합니다. 즉, 줄 구분 기호 (또는 스트림 끝) 앞에 스캐너가 문자를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6bd03a7d475e74af9f88c473ad6e73bd6b8b77bc" translate="yes" xml:space="preserve">
          <source>Or, even better, read the input through &lt;code&gt;Scanner.nextLine&lt;/code&gt; and convert your input to the proper format you need. For example, you may convert to an integer using &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt;&lt;code&gt;Integer.parseInt(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">또는 &lt;code&gt;Scanner.nextLine&lt;/code&gt; 을 통해 입력을 읽고 입력을 필요한 형식으로 변환하십시오. 예를 들어 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt; &lt;code&gt;Integer.parseInt(String)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="35821505e2e6e8e20b4075e0e2fe7993e4ab1ae9" translate="yes" xml:space="preserve">
          <source>Reduces Time Complexity</source>
          <target state="translated">시간 복잡성을 줄입니다</target>
        </trans-unit>
        <trans-unit id="b3611377a8ddae98b3fd5ae8e68a0494c2318114" translate="yes" xml:space="preserve">
          <source>Scanner is skipping nextLine() after using next() or nextFoo()</source>
          <target state="translated">next () 또는 nextFoo ()를 사용한 후 스캐너가 nextLine ()을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="2ba3201f9253fe49326935b9547594c936b32423" translate="yes" xml:space="preserve">
          <source>Scans Input faster than BufferReader</source>
          <target state="translated">BufferReader보다 빠른 입력 검색</target>
        </trans-unit>
        <trans-unit id="61f6f5d26bd0fa6841d6a278283463ffb2e7b424" translate="yes" xml:space="preserve">
          <source>So when you are asking the user for value like &lt;code&gt;age&lt;/code&gt;, and user types 42 and presses enter, standard input will contain &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">따라서 사용자에게 &lt;code&gt;age&lt;/code&gt; 와 같은 값을 요구할 때 사용자 유형 42와 Enter 키를 누르면 표준 입력에 &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="915380b2025e2ea32e6d63ecbe5ca0d105e28889" translate="yes" xml:space="preserve">
          <source>So when you want to ask for number and then for entire line while avoiding that empty string as result of &lt;code&gt;nextLine&lt;/code&gt;, either</source>
          <target state="translated">따라서 &lt;code&gt;nextLine&lt;/code&gt; 의 결과로 빈 문자열을 피하면서 숫자를 요청한 다음 전체 줄을 요청하려는 경우,</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="81b083adda697bdb56a20d1790d8681abb807f3b" translate="yes" xml:space="preserve">
          <source>TL;DR Use &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; before each &lt;code&gt;scanner.newLine()&lt;/code&gt; call, which is executed after:</source>
          <target state="translated">TL; DR 각 &lt;code&gt;scanner.newLine()&lt;/code&gt; 호출 전에 &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b9a0dd757f8afd33badbe9990f296a1aafeb6947" translate="yes" xml:space="preserve">
          <source>That's because the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt;&lt;code&gt;Scanner.nextInt&lt;/code&gt;&lt;/a&gt; method does not read the &lt;em&gt;newline&lt;/em&gt; character in your input created by hitting &quot;Enter,&quot; and so the call to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt;&lt;code&gt;Scanner.nextLine&lt;/code&gt;&lt;/a&gt; returns after reading that &lt;em&gt;newline&lt;/em&gt;.</source>
          <target state="translated">&quot;Enter&quot;를 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt; &lt;code&gt;Scanner.nextLine&lt;/code&gt; &lt;/a&gt; 때 작성된 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt; &lt;code&gt;Scanner.nextInt&lt;/code&gt; &lt;/a&gt; 메소드가 입력에서 &lt;em&gt;개행&lt;/em&gt; 문자를 읽지 않기 때문에 해당 &lt;em&gt;개행&lt;/em&gt; 을 읽은 후 Scanner.nextLine에 대한 호출이 리턴되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6cfe61b93b23a99a69d941bc9eac99b8f483fd93" translate="yes" xml:space="preserve">
          <source>The problem is that after entering the numerical value, the first &lt;code&gt;input.nextLine()&lt;/code&gt; is skipped and the second &lt;code&gt;input.nextLine()&lt;/code&gt; is executed, so that my output looks like this:</source>
          <target state="translated">문제는 숫자 값을 입력 한 후 첫 번째 &lt;code&gt;input.nextLine()&lt;/code&gt; 을 건너 뛰고 두 번째 &lt;code&gt;input.nextLine()&lt;/code&gt; 을 실행하여 내 출력이 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="ddde142a96e23eda3603161b1436db7d86c53024" translate="yes" xml:space="preserve">
          <source>The problem is with the &lt;strong&gt;input.nextInt()&lt;/strong&gt; method - it only reads the int value. So when you continue reading with input.nextLine() you receive the &quot;\n&quot; Enter key. So to skip this you have to add the &lt;strong&gt;input.nextLine()&lt;/strong&gt;. Hope this should be clear now.</source>
          <target state="translated">문제는 &lt;strong&gt;input.nextInt ()&lt;/strong&gt; 메소드에 있습니다. int 값만 읽습니다. 따라서 input.nextLine ()을 계속 사용하면 &quot;\ n&quot;Enter 키가 나타납니다. 따라서 이것을 건너 뛰려면 &lt;strong&gt;input.nextLine ()&lt;/strong&gt; 을 추가해야합니다. 이것이 분명해지기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="3f31e7321f597a2b4fae45f4c1cd3a445c0c7c27" translate="yes" xml:space="preserve">
          <source>The value of our &lt;code&gt;firstNumber&lt;/code&gt; and &lt;code&gt;secondNumber&lt;/code&gt; variable become 54 and 234 respectively. The reason why this works this way is because a new line feed (&lt;em&gt;i.e \n&lt;/em&gt;)  &lt;strong&gt;&lt;em&gt;IS NOT&lt;/em&gt;&lt;/strong&gt; automatically generated when the nextInt() method takes in the values. It simply takes the &lt;em&gt;&quot;next int&quot;&lt;/em&gt; and moves on. This is the same for the rest of the nextFoo() methods except nextLine().</source>
          <target state="translated">&lt;code&gt;firstNumber&lt;/code&gt; 및 &lt;code&gt;secondNumber&lt;/code&gt; 변수의 값은 각각 54와 234가됩니다. 이 방법이 작동하는 이유는 nextInt () 메소드가 값을 취할 때 새 줄 바꿈 ( &lt;em&gt;예 : \ n&lt;/em&gt; )이 자동으로 생성 &lt;strong&gt;&lt;em&gt;되지&lt;/em&gt;&lt;/strong&gt; 않기 때문입니다. 단순히 &lt;em&gt;&quot;다음 int&quot;&lt;/em&gt; 를 가져 와서 계속 진행합니다. 이것은 nextLine ()을 제외한 나머지 nextFoo () 메소드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="af8e7ea64187803595eadb5f2b017a3cad5d4a9a" translate="yes" xml:space="preserve">
          <source>There seem to be many questions about this issue with &lt;code&gt;java.util.Scanner&lt;/code&gt;. I think a more readable/idiomatic solution would be to call &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; to drop any newline characters after calling &lt;code&gt;nextInt()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;java.util.Scanner&lt;/code&gt; 에서이 문제에 대해 많은 질문이있는 것 같습니다. 더 읽기 쉽고 관용적 인 해결책은 &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; 을 호출하여 &lt;code&gt;nextInt()&lt;/code&gt; 호출 한 후 줄 바꿈 문자를 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="452c4ddb10a28ec2d90555e81046ff458fa71020" translate="yes" xml:space="preserve">
          <source>Things you need to know:</source>
          <target state="translated">알아야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="d3179f988755b5bb60be9c863f7cebddd9b574c9" translate="yes" xml:space="preserve">
          <source>Try it like that:</source>
          <target state="translated">그렇게 해보십시오.</target>
        </trans-unit>
        <trans-unit id="57407da8b23d181fa23db3253e9d0f4a5430604b" translate="yes" xml:space="preserve">
          <source>Usage :</source>
          <target state="translated">사용법 :</target>
        </trans-unit>
        <trans-unit id="66566971990e9567bbe4356e1d7b83f65d85a803" translate="yes" xml:space="preserve">
          <source>Use this code it will fix your problem.</source>
          <target state="translated">이 코드를 사용하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="da071d271d89a4bba999d81fadfe3918d9372bc9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;input.next()&lt;/code&gt; instead of &lt;code&gt;input.nextLine()&lt;/code&gt; fixed the issue. Hope this might be helpful for those dealing with similar scenario.</source>
          <target state="translated">&lt;code&gt;input.next()&lt;/code&gt; 대신 input.next () 를 사용하면 문제가 해결되었습니다. 이것이 비슷한 시나리오를 다루는 사람들에게 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="7226d641baa8ae41de06bb475758de53fed8eae0" translate="yes" xml:space="preserve">
          <source>What is important is that this key beside ensuring placing user data to &lt;em&gt;standard input&lt;/em&gt; (represented by &lt;code&gt;System.in&lt;/code&gt; which is read by &lt;code&gt;Scanner&lt;/code&gt;) also sends OS dependant line separators (like for Windows &lt;code&gt;\r\n&lt;/code&gt;) after it.</source>
          <target state="translated">중요한 것은 사용자 데이터를 &lt;em&gt;표준 입력에&lt;/em&gt; 배치하는 것 ( &lt;code&gt;Scanner&lt;/code&gt; 가 읽는 &lt;code&gt;System.in&lt;/code&gt; 으로 표시) 외에이 키가 그 후에 OS 종속 행 구분 기호 (예 : Windows &lt;code&gt;\r\n&lt;/code&gt; )도 전송한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f74999b3e95cf6f71b9f27aae94da4b0a057762" translate="yes" xml:space="preserve">
          <source>Why not use a new Scanner for every reading? Like below. With this approach you will not confront your problem.</source>
          <target state="translated">독서 할 때마다 새 스캐너를 사용하지 않습니까? 아래처럼. 이 방법을 사용하면 문제에 직면하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c4a63babaeaeb0c49e6c1ad33b7739c3722c9c8" translate="yes" xml:space="preserve">
          <source>You will encounter the similar behaviour when you use &lt;code&gt;Scanner.nextLine&lt;/code&gt; after &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt;&lt;code&gt;Scanner.next()&lt;/code&gt;&lt;/a&gt; or any &lt;code&gt;Scanner.nextFoo&lt;/code&gt; method (except &lt;code&gt;nextLine&lt;/code&gt; itself).</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt; &lt;code&gt;Scanner.next()&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;Scanner.nextFoo&lt;/code&gt; 메서드 ( &lt;code&gt;nextLine&lt;/code&gt; 자체 제외 ) 다음에 Scanner.nextLine 을 사용할 때 비슷한 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9fea7758b88440c7c56014d785e74b79822df1b6" translate="yes" xml:space="preserve">
          <source>calling &lt;code&gt;nextLine&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;nextLine&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="5bff49825d310d45ca3198277065d394e5a1403e" translate="yes" xml:space="preserve">
          <source>carriage return (CR - in String literals represented as &lt;code&gt;&quot;\r&quot;&lt;/code&gt;)</source>
          <target state="translated">캐리지 리턴 (CR-문자열 리터럴에서 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 표시됨)</target>
        </trans-unit>
        <trans-unit id="d71a472719c217d1cbb03b0100ec6f4d7963af45" translate="yes" xml:space="preserve">
          <source>consume line separator left by &lt;code&gt;nextInt&lt;/code&gt; from Scanners cache by</source>
          <target state="translated">스캐너 캐시에서 &lt;code&gt;nextInt&lt;/code&gt; 로 남은 줄 구분 기호를</target>
        </trans-unit>
        <trans-unit id="906919592563b8ceb86995b2350c1f3d4e41ab40" translate="yes" xml:space="preserve">
          <source>don't use &lt;code&gt;nextInt&lt;/code&gt; (nor &lt;code&gt;next&lt;/code&gt;, or any &lt;code&gt;nextTYPE&lt;/code&gt; methods) at all. Instead read entire data line-by-line using &lt;code&gt;nextLine&lt;/code&gt; and parse numbers from each line (assuming one line contains only one number) to proper type like &lt;code&gt;int&lt;/code&gt; via &lt;code&gt;Integer.parseInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nextInt&lt;/code&gt; (또는 &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;nextTYPE&lt;/code&gt; 메소드)를 전혀 사용하지 마십시오. 대신 &lt;code&gt;nextLine&lt;/code&gt; 을 사용하여 전체 데이터를 한 줄씩 읽고 &lt;code&gt;Integer.parseInt&lt;/code&gt; 를 통해 &lt;code&gt;int&lt;/code&gt; 와 같은 적절한 유형으로 각 줄의 숫자를 구문 분석하십시오 (한 줄에 하나의 숫자 만 있다고 가정).</target>
        </trans-unit>
        <trans-unit id="777254e6cdb58468ee14265cac12172de470597b" translate="yes" xml:space="preserve">
          <source>line feed (LF - in String literals represented as &lt;code&gt;&quot;\n&quot;&lt;/code&gt;)</source>
          <target state="translated">줄 바꿈 (LF-문자열 리터럴에서 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8da85052008fcd09092d1cdda4d021c77716afa0" translate="yes" xml:space="preserve">
          <source>nextLine() generates a new line feed immediately after taking a value; this is what @RohitJain means by saying the new line feed is &quot;consumed&quot;.</source>
          <target state="translated">nextLine ()은 값을 얻은 직후 새 줄 바꿈을 생성합니다. 이것은 @RohitJain이 새로운 줄 바꿈이 &quot;소비되었다&quot;는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2adabff3d49bda2a937fc4b067e7987b56a2272d" translate="yes" xml:space="preserve">
          <source>or IMO &lt;strong&gt;&lt;em&gt;more readable&lt;/em&gt;&lt;/strong&gt; way would be by calling &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; or &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; to let Scanner skip part matched by line separator (more info about &lt;code&gt;\R&lt;/code&gt;: &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https://stackoverflow.com/a/31060125&lt;/a&gt;)</source>
          <target state="translated">또는 IMO &lt;strong&gt;&lt;em&gt;보다 읽기 쉬운&lt;/em&gt;&lt;/strong&gt; 방법은 &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; 또는 &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; 을 호출하여 스캐너가 줄 구분 기호와 일치하는 부분을 건너 뛸 수 있습니다 ( &lt;code&gt;\R&lt;/code&gt; 에 대한 자세한 정보 : &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https : //stackoverflow.com/a/31060125&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1f6110eaae5d5a0ecdc62ad5c92021701b7e35bc" translate="yes" xml:space="preserve">
          <source>scanChar() - scan single character</source>
          <target state="translated">scanChar ()-단일 문자 스캔</target>
        </trans-unit>
        <trans-unit id="cd026e2048c739cc97f92689f612919ef5c6f357" translate="yes" xml:space="preserve">
          <source>scanDouble() - scan Double value</source>
          <target state="translated">scanDouble ()-스캔 더블 값</target>
        </trans-unit>
        <trans-unit id="f9f73c1f34ff7aacd07be55f18ef5aa637930aab" translate="yes" xml:space="preserve">
          <source>scanInt() - scan Integer value</source>
          <target state="translated">scanInt ()-스캔 정수 값</target>
        </trans-unit>
        <trans-unit id="ef1eda467483f01eb3b62158743bad7b3d0cae6b" translate="yes" xml:space="preserve">
          <source>scanInt(int[] array) - scans complete Array(Integer)</source>
          <target state="translated">scanInt (int [] array)-완전한 Array (Integer)를 스캔합니다</target>
        </trans-unit>
        <trans-unit id="2465b71fb96ee91597729b6326b210dde7b49bf2" translate="yes" xml:space="preserve">
          <source>scanLong() - scan Long value</source>
          <target state="translated">scanLong ()-긴 값 스캔</target>
        </trans-unit>
        <trans-unit id="b51f0a30704bc4d31354bd7ed09956e546786886" translate="yes" xml:space="preserve">
          <source>scanLong(long[] array) - scans complete Array(Long)</source>
          <target state="translated">scanLong (long [] array)-완전한 Array (Long)을 스캔합니다</target>
        </trans-unit>
        <trans-unit id="5573ccf4ef9b0ea26f56581c29410ab374bbbaef" translate="yes" xml:space="preserve">
          <source>scanString() - scan String value</source>
          <target state="translated">scanString ()-스캔 문자열 값</target>
        </trans-unit>
        <trans-unit id="6bbab5d9b19a578d0536edf4fdcfc1a8f42cbf35" translate="yes" xml:space="preserve">
          <source>text which represents few lines also contains non-printable characters between lines (we call them line separators) like</source>
          <target state="translated">몇 줄을 나타내는 텍스트에는 줄 사이에 인쇄 할 수없는 문자도 포함됩니다 (우리는 줄 구분 기호라고 부릅니다)</target>
        </trans-unit>
        <trans-unit id="2f36c69e8c8276a72aa79a95117c23454c420b24" translate="yes" xml:space="preserve">
          <source>used in above example:</source>
          <target state="translated">위 예제에서 사용 된</target>
        </trans-unit>
        <trans-unit id="78bcf988e9009f9c4b7a945f5289e06addc0b65f" translate="yes" xml:space="preserve">
          <source>when you are reading data from the console, it allows the user to type his response and when he is done he needs to &lt;em&gt;somehow&lt;/em&gt; confirm that fact. To do so, the user is required to press &quot;enter&quot;/&quot;return&quot; key on the keyboard.</source>
          <target state="translated">콘솔에서 데이터를 읽을 때 사용자는 자신의 응답을 입력 할 수 있으며 완료되면 그 사실을 확인해야합니다. 그렇게하려면, 사용자는 키보드에서 &quot;enter&quot;/ &quot;return&quot;키를 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="9fb12221c0f1d15ac31091e556227d379cefd286" translate="yes" xml:space="preserve">
          <source>will be able to properly assign &lt;code&gt;num1=42&lt;/code&gt;&lt;code&gt;num2=321&lt;/code&gt;&lt;code&gt;name=foobar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;num1=42&lt;/code&gt; &lt;code&gt;num2=321&lt;/code&gt; &lt;code&gt;name=foobar&lt;/code&gt; 를 올바르게 할당 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
