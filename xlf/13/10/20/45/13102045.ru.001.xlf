<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/13102045">
    <body>
      <group id="13102045">
        <trans-unit id="710a2db5b66ac26e1478825da4ef8408d1069ec9" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;input.nextInt()&lt;/code&gt; consumes only the number, not the &quot;end of line&quot;. When &lt;code&gt;input.nextLine()&lt;/code&gt; executes, it consumes the &quot;end of line&quot; still in the buffer from the first input.</source>
          <target state="translated">, &lt;code&gt;input.nextInt()&lt;/code&gt; только число, а не &amp;laquo;конец строки&amp;raquo;. Когда &lt;code&gt;input.nextLine()&lt;/code&gt; выполняется, он использует &amp;laquo;конец строки&amp;raquo;, все еще находящийся в буфере от первого ввода.</target>
        </trans-unit>
        <trans-unit id="b886918d5042bbbfc958525b15f82c6c7d2e2c84" translate="yes" xml:space="preserve">
          <source>54 234</source>
          <target state="translated">54 234</target>
        </trans-unit>
        <trans-unit id="75fe10c33ab541c3ff9a2dec9478850dc828c24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScanReader sc = new ScanReader(System.in);
&lt;/code&gt;
3. Import necessary Classes :</source>
          <target state="translated">&lt;code&gt;ScanReader sc = new ScanReader(System.in); &lt;/code&gt; 3. Импортируйте необходимые классы:</target>
        </trans-unit>
        <trans-unit id="366a4c8a89e72813c933b40b16a4ea31bed9b47f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scanner#nextInt&lt;/code&gt; (and other &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods) doesn't allow Scanner to &lt;em&gt;consume&lt;/em&gt; these line separators. It will read them from &lt;code&gt;System.in&lt;/code&gt; (how else Scanner would know that there are no more digits from the user which represent &lt;code&gt;age&lt;/code&gt; value than facing whitespace?) which will remove them from standard input, but &lt;strong&gt;it will also &lt;em&gt;cache&lt;/em&gt; those line separators internally&lt;/strong&gt;. What we need to remember, is that all of the Scanner methods are always scanning starting from the cached text.</source>
          <target state="translated">&lt;code&gt;Scanner#nextInt&lt;/code&gt; (и другие методы &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; ) не позволяет Scanner &lt;em&gt;использовать&lt;/em&gt; эти разделители строк. Он будет читать их из &lt;code&gt;System.in&lt;/code&gt; (как иначе Сканер узнает, что от пользователя больше нет цифр, представляющих значение &lt;code&gt;age&lt;/code&gt; не с пробелами?), &lt;strong&gt;Что&lt;/strong&gt; удалит их из стандартного ввода, но &lt;strong&gt;он также &lt;em&gt;кеширует&lt;/em&gt; эти разделители строк внутри&lt;/strong&gt; . Нам нужно помнить, что все методы Scanner всегда сканируют, начиная с кэшированного текста.</target>
        </trans-unit>
        <trans-unit id="56b4dfc8432afa4fa111e34e26cc3f44eb402f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
&lt;/code&gt; 
4. Throw IOException from your main method to handle Exception
5. Use Provided Methods.
6. Enjoy</source>
          <target state="translated">&lt;code&gt;import java.io.BufferedInputStream; import java.io.IOException; import java.io.InputStream; &lt;/code&gt; импорт java.io.IOException; import java.io.InputStream; 4. Бросьте IOException из вашего основного метода для обработки Exception 5. Используйте предоставленные методы. 6. Наслаждайтесь</target>
        </trans-unit>
        <trans-unit id="373f1750feea9fb203e722a6c277aad2739d5096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sc.nextLine()&lt;/code&gt; is better as compared to parsing the input.
Because performance wise it will be good.</source>
          <target state="translated">&lt;code&gt;sc.nextLine()&lt;/code&gt; лучше по сравнению с анализом ввода. Потому что по производительности это будет хорошо.</target>
        </trans-unit>
        <trans-unit id="b35e887c8e2cf9f2d2e03c3bddb48a8a829d7780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; метод.</target>
        </trans-unit>
        <trans-unit id="70f588a817efac382b9515d6deb996668f23df8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;if I expect a non-empty input&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;если я ожидаю непустой ввод&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0d666e158289b5045c42686e3b906f172a349da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;: &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods can &lt;em&gt;skip&lt;/em&gt; delimiters (by default all whitespaces like tabs, line separators) including those cached by scanner, until they will find next non-delimiter value (token). Thanks to that for input like &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; code</source>
          <target state="translated">&lt;strong&gt;КСТАТИ&lt;/strong&gt; : &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; Методы &lt;b&gt;&lt;i&gt;типа&lt;/i&gt;&lt;/b&gt; могут &lt;em&gt;пропускать&lt;/em&gt; разделители (по умолчанию все пробелы, такие как вкладки, разделители строк), включая те, которые кэшируются сканером, пока они не найдут следующее значение без разделителя (токен). Благодаря этому для ввода типа &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; код</target>
        </trans-unit>
        <trans-unit id="0d2adef1f69f8dff2d1dcc4d1bd9850708850158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use 2 scanner objects instead of one&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Используйте 2 объекта сканера вместо одного&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef28c560bd67f0e0f4953b7c23f5c2507be1533" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Workaround:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Workaround:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61ac0246f79c4b57695a1547128e8b7cded82bb8" translate="yes" xml:space="preserve">
          <source>Advantages :</source>
          <target state="translated">Преимущества :</target>
        </trans-unit>
        <trans-unit id="fb62cdea39d977351a6037cf5625c21cd1fc59a4" translate="yes" xml:space="preserve">
          <source>Alternatively you can do it C# style and parse a nextLine to an integer like so:</source>
          <target state="translated">Или же вы можете сделать это в стиле C#и разобрать следующую строку на целое число:</target>
        </trans-unit>
        <trans-unit id="2b1cba757b139aa52180f923668b1674db554ca3" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;nextXXX()&lt;/code&gt; methods don't read &lt;code&gt;newline&lt;/code&gt;, except &lt;code&gt;nextLine()&lt;/code&gt;. We can skip the &lt;code&gt;newline&lt;/code&gt; after reading any &lt;code&gt;non-string&lt;/code&gt; value (&lt;code&gt;int&lt;/code&gt; in this case) by using &lt;code&gt;scanner.skip()&lt;/code&gt; as below:</source>
          <target state="translated">Так &lt;code&gt;nextXXX()&lt;/code&gt; методы nextXXX () не читают &lt;code&gt;nextLine()&lt;/code&gt; &lt;code&gt;newline&lt;/code&gt; , кроме nextLine () . Мы можем пропустить &lt;code&gt;newline&lt;/code&gt; после прочтения любого &lt;code&gt;non-string&lt;/code&gt; значения (в данном случае &lt;code&gt;int&lt;/code&gt; ) с помощью &lt;code&gt;scanner.skip()&lt;/code&gt; как показано ниже:</target>
        </trans-unit>
        <trans-unit id="0fd82344fa304c1dd4055b949995baf438f7846f" translate="yes" xml:space="preserve">
          <source>As previously stated, calling &lt;code&gt;input.nextLine()&lt;/code&gt; after getting your int value will solve your problem. The reason why your code didn't work was because there was nothing else to store from your input (where you inputted the int) into &lt;code&gt;string1&lt;/code&gt;. I'll just shed a little more light to the entire topic.</source>
          <target state="translated">Как уже говорилось ранее, вызов &lt;code&gt;input.nextLine()&lt;/code&gt; после получения значения int решит вашу проблему. Причина, по которой ваш код не работал, заключалась в том, что больше нечего было сохранить из вашего ввода (где вы вводили int) в &lt;code&gt;string1&lt;/code&gt; . Я просто пролью немного света на всю тему.</target>
        </trans-unit>
        <trans-unit id="2f31b23750226d934737a24b3f09c090104f16c2" translate="yes" xml:space="preserve">
          <source>BTW &lt;code&gt;nextLine&lt;/code&gt; also &lt;em&gt;consumes&lt;/em&gt; those line separators.</source>
          <target state="translated">Кстати, &lt;code&gt;nextLine&lt;/code&gt; также использует эти разделители строк.</target>
        </trans-unit>
        <trans-unit id="19095fe2701b8ec2bf4d7a6be7459653c80841cb" translate="yes" xml:space="preserve">
          <source>Code :</source>
          <target state="translated">Кодекс :</target>
        </trans-unit>
        <trans-unit id="635fc6fa5a8e88c6c6559e092853eaf5e388aeef" translate="yes" xml:space="preserve">
          <source>Consider &lt;em&gt;nextLine()&lt;/em&gt; as the odd one out among the &lt;em&gt;nextFoo()&lt;/em&gt; methods in the Scanner class. Let's take a quick example.. Let's say we have two lines of code like the ones below:</source>
          <target state="translated">Рассмотрим &lt;em&gt;nextLine ()&lt;/em&gt; как нечетный среди методов &lt;em&gt;nextFoo ()&lt;/em&gt; в классе Scanner. Давайте рассмотрим небольшой пример. Допустим, у нас есть две строки кода, подобные приведенным ниже:</target>
        </trans-unit>
        <trans-unit id="002e9982d256050d883ef1699f718354b3cc3337" translate="yes" xml:space="preserve">
          <source>Copy the Given Code below your java code.</source>
          <target state="translated">Скопируйте данный код под вашим java-кодом.</target>
        </trans-unit>
        <trans-unit id="7663ac04f8dea414c68a9376e483611c239cbf2b" translate="yes" xml:space="preserve">
          <source>Doing this works just as well, and it saves you a line of code.</source>
          <target state="translated">Это работает так же хорошо,и это экономит вам строку кода.</target>
        </trans-unit>
        <trans-unit id="13ae67b14ee7a023f7ff33b63de3b4c801273e5c" translate="yes" xml:space="preserve">
          <source>EDIT: as @PatrickParker noted below, this will cause an infinite loop if user inputs any whitespace after the number. See their answer for a better pattern to use with skip: &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https://stackoverflow.com/a/42471816/143585&lt;/a&gt;</source>
          <target state="translated">РЕДАКТИРОВАТЬ: как @PatrickParker отметил ниже, это приведет к бесконечному циклу, если пользователь вводит любой пробел после числа. Смотрите их ответ для лучшего шаблона для использования с пропустить: &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https://stackoverflow.com/a/42471816/143585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a00740e62f881fb4b637adb2a149d6d4dda30c90" translate="yes" xml:space="preserve">
          <source>Either put a &lt;code&gt;Scanner.nextLine&lt;/code&gt; call after each &lt;code&gt;Scanner.nextInt&lt;/code&gt; or &lt;code&gt;Scanner.nextFoo&lt;/code&gt; to consume rest of that line including &lt;em&gt;newline&lt;/em&gt;</source>
          <target state="translated">Либо поместите вызов &lt;code&gt;Scanner.nextLine&lt;/code&gt; после каждого &lt;code&gt;Scanner.nextInt&lt;/code&gt; , либо &lt;code&gt;Scanner.nextFoo&lt;/code&gt; , чтобы использовать оставшуюся часть этой строки, включая символ &lt;em&gt;новой строки.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="0483beb1135269908e7a45fb455b6f6963675242" translate="yes" xml:space="preserve">
          <source>Example :</source>
          <target state="translated">Пример :</target>
        </trans-unit>
        <trans-unit id="1ea6c561d0d39b2a9b43c6ee0183e3b4518033f4" translate="yes" xml:space="preserve">
          <source>Flushes Buffer for every next input</source>
          <target state="translated">Промывает буфер для каждого следующего входа</target>
        </trans-unit>
        <trans-unit id="7e06811cbd4c56a0f5d613919cbfee5e88f0a9cf" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;Scanner&lt;/code&gt; methods &lt;code&gt;nextInt()&lt;/code&gt; and &lt;code&gt;nextLine()&lt;/code&gt; for reading input.</source>
          <target state="translated">Я использую методы &lt;code&gt;Scanner&lt;/code&gt; &lt;code&gt;nextInt()&lt;/code&gt; и &lt;code&gt;nextLine()&lt;/code&gt; для чтения ввода.</target>
        </trans-unit>
        <trans-unit id="696ce6127beeba3523dbb29590922581f35141b0" translate="yes" xml:space="preserve">
          <source>I guess I'm pretty late to the party..</source>
          <target state="translated">Наверное,я опоздал на вечеринку...</target>
        </trans-unit>
        <trans-unit id="d349f68c15e01a087fd9a0d658f3db417be916d7" translate="yes" xml:space="preserve">
          <source>I hope this helps.. Merry coding!</source>
          <target state="translated">Надеюсь,это поможет...Счастливого кодирования!</target>
        </trans-unit>
        <trans-unit id="2d556e4c136e883374af9aa52727bd3818d1dd05" translate="yes" xml:space="preserve">
          <source>I tested my application and it looks like the problem lies in using &lt;code&gt;input.nextInt()&lt;/code&gt;. If I delete it, then both &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; and &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; are executed as I want them to be.</source>
          <target state="translated">Я протестировал свое приложение, и похоже, что проблема заключается в использовании &lt;code&gt;input.nextInt()&lt;/code&gt; . Если я его удаляю, то и &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; и &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; выполняются так, как я хочу.</target>
        </trans-unit>
        <trans-unit id="77960121ea1555cb0df4ff3bde8191c00116f793" translate="yes" xml:space="preserve">
          <source>If we input the value below (as a single line of input)</source>
          <target state="translated">Если мы введем значение ниже (в виде одной строки ввода)</target>
        </trans-unit>
        <trans-unit id="a38e67c54c42a5512691e8e1b9804287ebb56652" translate="yes" xml:space="preserve">
          <source>If you want to read both strings and ints, a solution is to use two Scanners:</source>
          <target state="translated">Если вы хотите прочитать обе строки и буквы,решение заключается в использовании двух сканеров:</target>
        </trans-unit>
        <trans-unit id="4ded73408781de19fbe45a6dddd399e16827e4cc" translate="yes" xml:space="preserve">
          <source>If you want to scan input fast without getting confused into Scanner class nextLine() method , Use Custom Input Scanner for it .</source>
          <target state="translated">Если вы хотите быстро отсканировать ввод,не запутываясь в методе класса Scanner nextLine(),используйте для этого специальный сканер ввода.</target>
        </trans-unit>
        <trans-unit id="2bf7e3910af2c708c663efffc860e3a0530af49b" translate="yes" xml:space="preserve">
          <source>In one of my usecase, I had the scenario of reading a &lt;strong&gt;string value preceded by a couple of integer values&lt;/strong&gt;. I had to use a &quot;&lt;strong&gt;for / while loop&lt;/strong&gt;&quot; to read the values. And none of the above suggestions worked in this case.</source>
          <target state="translated">В одном из моих вариантов использования у меня был сценарий чтения &lt;strong&gt;строкового значения, которому предшествовала пара целочисленных значений&lt;/strong&gt; . Мне пришлось использовать &lt;strong&gt;цикл for / while&lt;/strong&gt; для чтения значений. И ни одно из вышеперечисленных предложений не сработало в этом случае.</target>
        </trans-unit>
        <trans-unit id="10d3c730a99e74d5a24dd317d4db4a694e228ad9" translate="yes" xml:space="preserve">
          <source>In order to avoid the issue, use &lt;code&gt;nextLine();&lt;/code&gt; immediately after &lt;code&gt;nextInt();&lt;/code&gt; as it helps in clearing out the buffer. When you press &lt;code&gt;ENTER&lt;/code&gt; the &lt;code&gt;nextInt();&lt;/code&gt; does not capture the new line and hence, skips the &lt;code&gt;Scanner&lt;/code&gt; code later.</source>
          <target state="translated">Чтобы избежать проблемы, используйте &lt;code&gt;nextLine();&lt;/code&gt; сразу после &lt;code&gt;nextInt();&lt;/code&gt; как это помогает в очистке буфера. Когда вы нажимаете &lt;code&gt;ENTER&lt;/code&gt; , &lt;code&gt;nextInt();&lt;/code&gt; не захватывает новую строку и, следовательно, пропускает код &lt;code&gt;Scanner&lt;/code&gt; позже.</target>
        </trans-unit>
        <trans-unit id="1edb3ce39c21cf9587795abbe3311a18bf0c8903" translate="yes" xml:space="preserve">
          <source>Initialise Object for Given Class</source>
          <target state="translated">Инициализировать объект для данного класса</target>
        </trans-unit>
        <trans-unit id="b1b2eea9a00239d91a7c93b3f68769f6bc79e8ce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;input.nextLine()&lt;/code&gt; use &lt;code&gt;input.next()&lt;/code&gt;, that should solve the problem.</source>
          <target state="translated">Вместо &lt;code&gt;input.nextLine()&lt;/code&gt; используйте &lt;code&gt;input.next()&lt;/code&gt; , это должно решить проблему.</target>
        </trans-unit>
        <trans-unit id="5a9a73068cabea22a1e6fe0fc9bd5ef7971141e4" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;input.nextLine()&lt;/code&gt; immediately after &lt;code&gt;input.nextInt()&lt;/code&gt;</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;input.nextLine()&lt;/code&gt; сразу после &lt;code&gt;input.nextInt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc65d994a35abffd8df4ed8ea137588c33ec9b15" translate="yes" xml:space="preserve">
          <source>It does that because &lt;code&gt;input.nextInt();&lt;/code&gt; doesn't capture the newline. you could do like the others proposed by adding an &lt;code&gt;input.nextLine();&lt;/code&gt; underneath.</source>
          <target state="translated">Это происходит потому, что &lt;code&gt;input.nextInt();&lt;/code&gt; не захватывает новую строку. вы можете сделать то же самое, что предложили другие, добавив &lt;code&gt;input.nextLine();&lt;/code&gt; под.</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">Похоже на то:</target>
        </trans-unit>
        <trans-unit id="3c95406d44cb825b56c4dfe09670a16f7805a269" translate="yes" xml:space="preserve">
          <source>It's because when you enter a number then press</source>
          <target state="translated">Это потому,что когда вы вводите число,то нажимаете</target>
        </trans-unit>
        <trans-unit id="75d4d0fa84b2616f2559145a9e543dcf04362e6e" translate="yes" xml:space="preserve">
          <source>Lastly, the next() method simply takes the nearest String &lt;strong&gt;without&lt;/strong&gt; generating a new line; this makes this the preferential method for taking separate Strings within the same single line.</source>
          <target state="translated">Наконец, метод next () просто берет ближайшую строку &lt;strong&gt;без&lt;/strong&gt; генерации новой строки; это делает этот метод предпочтительным для получения отдельных строк в одной строке.</target>
        </trans-unit>
        <trans-unit id="d1d9319457390e1dead075b888d4ff571e51eac8" translate="yes" xml:space="preserve">
          <source>Methods :</source>
          <target state="translated">Методы :</target>
        </trans-unit>
        <trans-unit id="963f50210de73d6adb4e4a4d700c1acde79d6293" translate="yes" xml:space="preserve">
          <source>Modified code:</source>
          <target state="translated">Модифицированный код:</target>
        </trans-unit>
        <trans-unit id="66848aec0d0dab5e4aa6db56c612529606000bb0" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;Scanner#nextLine()&lt;/code&gt; simply collects and returns all characters &lt;em&gt;until it finds line separators&lt;/em&gt; (or end of stream). But since line separators after reading the number from the console are found immediately in Scanner's cache, it returns empty String, meaning that Scanner was not able to find any character before those line separators (or end of stream).</source>
          <target state="translated">Теперь &lt;code&gt;Scanner#nextLine()&lt;/code&gt; просто собирает и возвращает все символы, &lt;em&gt;пока не найдет разделители строк&lt;/em&gt; (или конец потока). Но поскольку разделители строк после чтения номера из консоли сразу же обнаруживаются в кэше сканера, он возвращает пустую строку, то есть сканер не смог найти ни одного символа перед этими разделителями строк (или концом потока).</target>
        </trans-unit>
        <trans-unit id="6bd03a7d475e74af9f88c473ad6e73bd6b8b77bc" translate="yes" xml:space="preserve">
          <source>Or, even better, read the input through &lt;code&gt;Scanner.nextLine&lt;/code&gt; and convert your input to the proper format you need. For example, you may convert to an integer using &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt;&lt;code&gt;Integer.parseInt(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Или, что еще лучше, прочитайте ввод через &lt;code&gt;Scanner.nextLine&lt;/code&gt; и преобразуйте его в нужный вам формат. Например, вы можете преобразовать в целое число, используя &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt; &lt;code&gt;Integer.parseInt(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="35821505e2e6e8e20b4075e0e2fe7993e4ab1ae9" translate="yes" xml:space="preserve">
          <source>Reduces Time Complexity</source>
          <target state="translated">Снижает временную сложность</target>
        </trans-unit>
        <trans-unit id="b3611377a8ddae98b3fd5ae8e68a0494c2318114" translate="yes" xml:space="preserve">
          <source>Scanner is skipping nextLine() after using next() or nextFoo()</source>
          <target state="translated">Сканер пропускает nextLine()после использования next()или nextFoo().</target>
        </trans-unit>
        <trans-unit id="2ba3201f9253fe49326935b9547594c936b32423" translate="yes" xml:space="preserve">
          <source>Scans Input faster than BufferReader</source>
          <target state="translated">Сканирует Вход быстрее,чем BufferReader.</target>
        </trans-unit>
        <trans-unit id="61f6f5d26bd0fa6841d6a278283463ffb2e7b424" translate="yes" xml:space="preserve">
          <source>So when you are asking the user for value like &lt;code&gt;age&lt;/code&gt;, and user types 42 and presses enter, standard input will contain &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">Поэтому, когда вы запрашиваете у пользователя значение типа &lt;code&gt;age&lt;/code&gt; , а пользователь вводит 42 и нажимает ввод, стандартный ввод будет содержать &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="915380b2025e2ea32e6d63ecbe5ca0d105e28889" translate="yes" xml:space="preserve">
          <source>So when you want to ask for number and then for entire line while avoiding that empty string as result of &lt;code&gt;nextLine&lt;/code&gt;, either</source>
          <target state="translated">Поэтому, когда вы хотите запросить номер, а затем всю строку, избегая этой пустой строки в результате &lt;code&gt;nextLine&lt;/code&gt; , либо</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="81b083adda697bdb56a20d1790d8681abb807f3b" translate="yes" xml:space="preserve">
          <source>TL;DR Use &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; before each &lt;code&gt;scanner.newLine()&lt;/code&gt; call, which is executed after:</source>
          <target state="translated">TL; DR Использовать &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; перед каждым вызовом &lt;code&gt;scanner.newLine()&lt;/code&gt; , который выполняется после:</target>
        </trans-unit>
        <trans-unit id="b9a0dd757f8afd33badbe9990f296a1aafeb6947" translate="yes" xml:space="preserve">
          <source>That's because the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt;&lt;code&gt;Scanner.nextInt&lt;/code&gt;&lt;/a&gt; method does not read the &lt;em&gt;newline&lt;/em&gt; character in your input created by hitting &quot;Enter,&quot; and so the call to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt;&lt;code&gt;Scanner.nextLine&lt;/code&gt;&lt;/a&gt; returns after reading that &lt;em&gt;newline&lt;/em&gt;.</source>
          <target state="translated">Это связано с &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt; &lt;code&gt;Scanner.nextInt&lt;/code&gt; &lt;/a&gt; метод Scanner.nextInt не читает символ &lt;em&gt;новой строки&lt;/em&gt; в вводе, созданном нажатием &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt; &lt;code&gt;Scanner.nextLine&lt;/code&gt; &lt;/a&gt; &amp;laquo;Ввод&amp;raquo;, и поэтому вызов Scanner.nextLine возвращается после чтения этой &lt;em&gt;новой строки&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6cfe61b93b23a99a69d941bc9eac99b8f483fd93" translate="yes" xml:space="preserve">
          <source>The problem is that after entering the numerical value, the first &lt;code&gt;input.nextLine()&lt;/code&gt; is skipped and the second &lt;code&gt;input.nextLine()&lt;/code&gt; is executed, so that my output looks like this:</source>
          <target state="translated">Проблема заключается в том, что после ввода числового значения первый &lt;code&gt;input.nextLine()&lt;/code&gt; пропускается, а второй &lt;code&gt;input.nextLine()&lt;/code&gt; выполняется, так что мой вывод выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="ddde142a96e23eda3603161b1436db7d86c53024" translate="yes" xml:space="preserve">
          <source>The problem is with the &lt;strong&gt;input.nextInt()&lt;/strong&gt; method - it only reads the int value. So when you continue reading with input.nextLine() you receive the &quot;\n&quot; Enter key. So to skip this you have to add the &lt;strong&gt;input.nextLine()&lt;/strong&gt;. Hope this should be clear now.</source>
          <target state="translated">Проблема в &lt;strong&gt;методе input.nextInt ()&lt;/strong&gt; - он только читает значение int. Поэтому, когда вы продолжаете чтение с помощью input.nextLine (), вы получаете клавишу ввода &amp;laquo;\ n&amp;raquo;. Поэтому, чтобы пропустить это, вы должны добавить &lt;strong&gt;input.nextLine ()&lt;/strong&gt; . Надеюсь, это должно быть ясно сейчас.</target>
        </trans-unit>
        <trans-unit id="3f31e7321f597a2b4fae45f4c1cd3a445c0c7c27" translate="yes" xml:space="preserve">
          <source>The value of our &lt;code&gt;firstNumber&lt;/code&gt; and &lt;code&gt;secondNumber&lt;/code&gt; variable become 54 and 234 respectively. The reason why this works this way is because a new line feed (&lt;em&gt;i.e \n&lt;/em&gt;)  &lt;strong&gt;&lt;em&gt;IS NOT&lt;/em&gt;&lt;/strong&gt; automatically generated when the nextInt() method takes in the values. It simply takes the &lt;em&gt;&quot;next int&quot;&lt;/em&gt; and moves on. This is the same for the rest of the nextFoo() methods except nextLine().</source>
          <target state="translated">Значения наших переменных &lt;code&gt;firstNumber&lt;/code&gt; и &lt;code&gt;secondNumber&lt;/code&gt; становятся 54 и 234 соответственно. Причина, по которой это работает таким образом, заключается в том, что новый перевод строки ( &lt;em&gt;т.е. \ n&lt;/em&gt; ) &lt;strong&gt;&lt;em&gt;НЕ&lt;/em&gt;&lt;/strong&gt; генерируется автоматически, когда метод nextInt () принимает значения. Он просто берет &lt;em&gt;&amp;laquo;следующий int&amp;raquo;&lt;/em&gt; и движется дальше. То же самое относится и к остальным методам nextFoo (), за исключением nextLine ().</target>
        </trans-unit>
        <trans-unit id="af8e7ea64187803595eadb5f2b017a3cad5d4a9a" translate="yes" xml:space="preserve">
          <source>There seem to be many questions about this issue with &lt;code&gt;java.util.Scanner&lt;/code&gt;. I think a more readable/idiomatic solution would be to call &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; to drop any newline characters after calling &lt;code&gt;nextInt()&lt;/code&gt;.</source>
          <target state="translated">Кажется, есть много вопросов по этой проблеме с &lt;code&gt;java.util.Scanner&lt;/code&gt; . Я думаю, что более читаемым / идиоматическим решением было бы вызвать &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; чтобы удалить любые символы новой строки после вызова &lt;code&gt;nextInt()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452c4ddb10a28ec2d90555e81046ff458fa71020" translate="yes" xml:space="preserve">
          <source>Things you need to know:</source>
          <target state="translated">Вещи,которые тебе нужно знать:</target>
        </trans-unit>
        <trans-unit id="d3179f988755b5bb60be9c863f7cebddd9b574c9" translate="yes" xml:space="preserve">
          <source>Try it like that:</source>
          <target state="translated">Попробуй вот так:</target>
        </trans-unit>
        <trans-unit id="57407da8b23d181fa23db3253e9d0f4a5430604b" translate="yes" xml:space="preserve">
          <source>Usage :</source>
          <target state="translated">Использование :</target>
        </trans-unit>
        <trans-unit id="66566971990e9567bbe4356e1d7b83f65d85a803" translate="yes" xml:space="preserve">
          <source>Use this code it will fix your problem.</source>
          <target state="translated">Используйте этот код,он исправит вашу проблему.</target>
        </trans-unit>
        <trans-unit id="da071d271d89a4bba999d81fadfe3918d9372bc9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;input.next()&lt;/code&gt; instead of &lt;code&gt;input.nextLine()&lt;/code&gt; fixed the issue. Hope this might be helpful for those dealing with similar scenario.</source>
          <target state="translated">Использование &lt;code&gt;input.next()&lt;/code&gt; вместо &lt;code&gt;input.nextLine()&lt;/code&gt; проблему. Надеюсь, что это может быть полезно для тех, кто имеет дело с подобным сценарием.</target>
        </trans-unit>
        <trans-unit id="7226d641baa8ae41de06bb475758de53fed8eae0" translate="yes" xml:space="preserve">
          <source>What is important is that this key beside ensuring placing user data to &lt;em&gt;standard input&lt;/em&gt; (represented by &lt;code&gt;System.in&lt;/code&gt; which is read by &lt;code&gt;Scanner&lt;/code&gt;) also sends OS dependant line separators (like for Windows &lt;code&gt;\r\n&lt;/code&gt;) after it.</source>
          <target state="translated">Важно то, что этот ключ помимо обеспечения помещения пользовательских данных на &lt;em&gt;стандартный ввод&lt;/em&gt; (представленный &lt;code&gt;System.in&lt;/code&gt; , который читается &lt;code&gt;Scanner&lt;/code&gt; ) также отправляет зависимые от ОС разделители строк (как для Windows &lt;code&gt;\r\n&lt;/code&gt; ) после него.</target>
        </trans-unit>
        <trans-unit id="5f74999b3e95cf6f71b9f27aae94da4b0a057762" translate="yes" xml:space="preserve">
          <source>Why not use a new Scanner for every reading? Like below. With this approach you will not confront your problem.</source>
          <target state="translated">Почему бы не использовать новый сканер для каждого чтения? Как внизу.При таком подходе вы не столкнетесь со своей проблемой.</target>
        </trans-unit>
        <trans-unit id="5c4a63babaeaeb0c49e6c1ad33b7739c3722c9c8" translate="yes" xml:space="preserve">
          <source>You will encounter the similar behaviour when you use &lt;code&gt;Scanner.nextLine&lt;/code&gt; after &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt;&lt;code&gt;Scanner.next()&lt;/code&gt;&lt;/a&gt; or any &lt;code&gt;Scanner.nextFoo&lt;/code&gt; method (except &lt;code&gt;nextLine&lt;/code&gt; itself).</source>
          <target state="translated">С подобным поведением вы &lt;code&gt;Scanner.nextLine&lt;/code&gt; при использовании Scanner.nextLine после &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt; &lt;code&gt;Scanner.next()&lt;/code&gt; &lt;/a&gt; или любого метода &lt;code&gt;Scanner.nextFoo&lt;/code&gt; (кроме самого &lt;code&gt;nextLine&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9fea7758b88440c7c56014d785e74b79822df1b6" translate="yes" xml:space="preserve">
          <source>calling &lt;code&gt;nextLine&lt;/code&gt;,</source>
          <target state="translated">вызывая &lt;code&gt;nextLine&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="5bff49825d310d45ca3198277065d394e5a1403e" translate="yes" xml:space="preserve">
          <source>carriage return (CR - in String literals represented as &lt;code&gt;&quot;\r&quot;&lt;/code&gt;)</source>
          <target state="translated">возврат каретки (CR - в строковых литералах, представленных как &lt;code&gt;&quot;\r&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d71a472719c217d1cbb03b0100ec6f4d7963af45" translate="yes" xml:space="preserve">
          <source>consume line separator left by &lt;code&gt;nextInt&lt;/code&gt; from Scanners cache by</source>
          <target state="translated">использовать разделитель строк, оставленный &lt;code&gt;nextInt&lt;/code&gt; из кэша сканеров</target>
        </trans-unit>
        <trans-unit id="906919592563b8ceb86995b2350c1f3d4e41ab40" translate="yes" xml:space="preserve">
          <source>don't use &lt;code&gt;nextInt&lt;/code&gt; (nor &lt;code&gt;next&lt;/code&gt;, or any &lt;code&gt;nextTYPE&lt;/code&gt; methods) at all. Instead read entire data line-by-line using &lt;code&gt;nextLine&lt;/code&gt; and parse numbers from each line (assuming one line contains only one number) to proper type like &lt;code&gt;int&lt;/code&gt; via &lt;code&gt;Integer.parseInt&lt;/code&gt;.</source>
          <target state="translated">вообще не используйте &lt;code&gt;nextInt&lt;/code&gt; (ни &lt;code&gt;next&lt;/code&gt; , ни любые методы &lt;code&gt;nextTYPE&lt;/code&gt; ). Вместо этого читайте все данные построчно, используя &lt;code&gt;nextLine&lt;/code&gt; , и анализируйте номера из каждой строки (предполагая, что в одной строке содержится только одно число), чтобы получить правильный тип, например &lt;code&gt;int&lt;/code&gt; , через &lt;code&gt;Integer.parseInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="777254e6cdb58468ee14265cac12172de470597b" translate="yes" xml:space="preserve">
          <source>line feed (LF - in String literals represented as &lt;code&gt;&quot;\n&quot;&lt;/code&gt;)</source>
          <target state="translated">перевод строки (LF - в строковых литералах, представленных как &lt;code&gt;&quot;\n&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8da85052008fcd09092d1cdda4d021c77716afa0" translate="yes" xml:space="preserve">
          <source>nextLine() generates a new line feed immediately after taking a value; this is what @RohitJain means by saying the new line feed is &quot;consumed&quot;.</source>
          <target state="translated">nextLine()генерирует новый поток строк сразу после получения значения;вот что означает @RohitJain,говоря,что новый поток строк &quot;расходуется&quot;.</target>
        </trans-unit>
        <trans-unit id="2adabff3d49bda2a937fc4b067e7987b56a2272d" translate="yes" xml:space="preserve">
          <source>or IMO &lt;strong&gt;&lt;em&gt;more readable&lt;/em&gt;&lt;/strong&gt; way would be by calling &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; or &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; to let Scanner skip part matched by line separator (more info about &lt;code&gt;\R&lt;/code&gt;: &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https://stackoverflow.com/a/31060125&lt;/a&gt;)</source>
          <target state="translated">или IMO &lt;strong&gt;&lt;em&gt;более удобочитаемым&lt;/em&gt;&lt;/strong&gt; способом было бы вызвать &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; или &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; чтобы позволить сканеру пропустить часть, совпадающую с разделителем строк (больше информации о &lt;code&gt;\R&lt;/code&gt; : &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https : //stackoverflow.com/a/31060125&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1f6110eaae5d5a0ecdc62ad5c92021701b7e35bc" translate="yes" xml:space="preserve">
          <source>scanChar() - scan single character</source>
          <target state="translated">scanChar()-сканирование одного символа</target>
        </trans-unit>
        <trans-unit id="cd026e2048c739cc97f92689f612919ef5c6f357" translate="yes" xml:space="preserve">
          <source>scanDouble() - scan Double value</source>
          <target state="translated">scanDouble()-сканирование Двойное значение</target>
        </trans-unit>
        <trans-unit id="f9f73c1f34ff7aacd07be55f18ef5aa637930aab" translate="yes" xml:space="preserve">
          <source>scanInt() - scan Integer value</source>
          <target state="translated">scanInt()-сканирование Целое значение</target>
        </trans-unit>
        <trans-unit id="ef1eda467483f01eb3b62158743bad7b3d0cae6b" translate="yes" xml:space="preserve">
          <source>scanInt(int[] array) - scans complete Array(Integer)</source>
          <target state="translated">scanInt(int[]array)-сканирует полный массив array(Integer)</target>
        </trans-unit>
        <trans-unit id="2465b71fb96ee91597729b6326b210dde7b49bf2" translate="yes" xml:space="preserve">
          <source>scanLong() - scan Long value</source>
          <target state="translated">scanLong()-сканировать значение Long</target>
        </trans-unit>
        <trans-unit id="b51f0a30704bc4d31354bd7ed09956e546786886" translate="yes" xml:space="preserve">
          <source>scanLong(long[] array) - scans complete Array(Long)</source>
          <target state="translated">scanLong(long[]array)-сканирует полный массив (long).</target>
        </trans-unit>
        <trans-unit id="5573ccf4ef9b0ea26f56581c29410ab374bbbaef" translate="yes" xml:space="preserve">
          <source>scanString() - scan String value</source>
          <target state="translated">scanString()-сканирование Значение строки</target>
        </trans-unit>
        <trans-unit id="6bbab5d9b19a578d0536edf4fdcfc1a8f42cbf35" translate="yes" xml:space="preserve">
          <source>text which represents few lines also contains non-printable characters between lines (we call them line separators) like</source>
          <target state="translated">текст,который представляет собой несколько строк,также содержит непечатаемые символы между строками (мы называем их разделителями строк),такие как</target>
        </trans-unit>
        <trans-unit id="2f36c69e8c8276a72aa79a95117c23454c420b24" translate="yes" xml:space="preserve">
          <source>used in above example:</source>
          <target state="translated">использованный в вышеприведенном примере:</target>
        </trans-unit>
        <trans-unit id="78bcf988e9009f9c4b7a945f5289e06addc0b65f" translate="yes" xml:space="preserve">
          <source>when you are reading data from the console, it allows the user to type his response and when he is done he needs to &lt;em&gt;somehow&lt;/em&gt; confirm that fact. To do so, the user is required to press &quot;enter&quot;/&quot;return&quot; key on the keyboard.</source>
          <target state="translated">когда вы читаете данные с консоли, это позволяет пользователю вводить свой ответ, а когда он это делает, ему необходимо &lt;em&gt;каким-то образом&lt;/em&gt; подтвердить этот факт. Для этого пользователю необходимо нажать клавишу &amp;laquo;ввод&amp;raquo; / &amp;laquo;возврат&amp;raquo; на клавиатуре.</target>
        </trans-unit>
        <trans-unit id="9fb12221c0f1d15ac31091e556227d379cefd286" translate="yes" xml:space="preserve">
          <source>will be able to properly assign &lt;code&gt;num1=42&lt;/code&gt;&lt;code&gt;num2=321&lt;/code&gt;&lt;code&gt;name=foobar&lt;/code&gt;.</source>
          <target state="translated">сможет правильно назначить &lt;code&gt;num1=42&lt;/code&gt; &lt;code&gt;num2=321&lt;/code&gt; &lt;code&gt;name=foobar&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
