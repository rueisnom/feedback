<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/13102045">
    <body>
      <group id="13102045">
        <trans-unit id="710a2db5b66ac26e1478825da4ef8408d1069ec9" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;input.nextInt()&lt;/code&gt; consumes only the number, not the &quot;end of line&quot;. When &lt;code&gt;input.nextLine()&lt;/code&gt; executes, it consumes the &quot;end of line&quot; still in the buffer from the first input.</source>
          <target state="translated">， &lt;code&gt;input.nextInt()&lt;/code&gt; 仅消耗数字，而不消耗&amp;ldquo;行尾&amp;rdquo;。 执行 &lt;code&gt;input.nextLine()&lt;/code&gt; 时 ，它会消耗掉第一个输入中缓冲区中的&amp;ldquo;行尾&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b886918d5042bbbfc958525b15f82c6c7d2e2c84" translate="yes" xml:space="preserve">
          <source>54 234</source>
          <target state="translated">54 234</target>
        </trans-unit>
        <trans-unit id="75fe10c33ab541c3ff9a2dec9478850dc828c24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScanReader sc = new ScanReader(System.in);
&lt;/code&gt;
3. Import necessary Classes :</source>
          <target state="translated">&lt;code&gt;ScanReader sc = new ScanReader(System.in); &lt;/code&gt; 3.导入必要的类：</target>
        </trans-unit>
        <trans-unit id="366a4c8a89e72813c933b40b16a4ea31bed9b47f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scanner#nextInt&lt;/code&gt; (and other &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods) doesn't allow Scanner to &lt;em&gt;consume&lt;/em&gt; these line separators. It will read them from &lt;code&gt;System.in&lt;/code&gt; (how else Scanner would know that there are no more digits from the user which represent &lt;code&gt;age&lt;/code&gt; value than facing whitespace?) which will remove them from standard input, but &lt;strong&gt;it will also &lt;em&gt;cache&lt;/em&gt; those line separators internally&lt;/strong&gt;. What we need to remember, is that all of the Scanner methods are always scanning starting from the cached text.</source>
          <target state="translated">&lt;code&gt;Scanner#nextInt&lt;/code&gt; （和其他 &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; 方法）不允许Scanner &lt;em&gt;使用&lt;/em&gt;这些行分隔符。 它将从 &lt;code&gt;System.in&lt;/code&gt; 中读取它们（否则Scanner怎么会知道用户表示 &lt;code&gt;age&lt;/code&gt; 值的数字不多于面对空格？），这会将它们从标准输入中删除，但&lt;strong&gt;还将在内部&lt;em&gt;缓存&lt;/em&gt;这些行分隔符&lt;/strong&gt; 。 我们需要记住的是，所有Scanner方法始终从缓存的文本开始进行扫描。</target>
        </trans-unit>
        <trans-unit id="56b4dfc8432afa4fa111e34e26cc3f44eb402f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
&lt;/code&gt; 
4. Throw IOException from your main method to handle Exception
5. Use Provided Methods.
6. Enjoy</source>
          <target state="translated">&lt;code&gt;import java.io.BufferedInputStream; import java.io.IOException; import java.io.InputStream; &lt;/code&gt; 导入java.io.IOException; 导入java.io.InputStream; 4.从您的主要方法中抛出IOException以处理异常5.使用提供的方法。 6.享受</target>
        </trans-unit>
        <trans-unit id="373f1750feea9fb203e722a6c277aad2739d5096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sc.nextLine()&lt;/code&gt; is better as compared to parsing the input.
Because performance wise it will be good.</source>
          <target state="translated">与解析输入相比， &lt;code&gt;sc.nextLine()&lt;/code&gt; 更好。 因为明智的表现会很好。</target>
        </trans-unit>
        <trans-unit id="b35e887c8e2cf9f2d2e03c3bddb48a8a829d7780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;scanner.next*TYPE*()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="70f588a817efac382b9515d6deb996668f23df8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;if I expect a non-empty input&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果我希望输入非空&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0d666e158289b5045c42686e3b906f172a349da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;: &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; methods can &lt;em&gt;skip&lt;/em&gt; delimiters (by default all whitespaces like tabs, line separators) including those cached by scanner, until they will find next non-delimiter value (token). Thanks to that for input like &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; code</source>
          <target state="translated">&lt;strong&gt;顺便说一句&lt;/strong&gt; ： &lt;code&gt;Scanner#next&lt;b&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/b&gt;&lt;/code&gt; 方法可以&lt;em&gt;跳过&lt;/em&gt;定界符（默认情况下，所有空白，如制表符，行分隔符），包括由扫描程序缓存的定界符，直到找到下一个非定界符值（令牌）为止。 感谢输入类似 &lt;code&gt;&quot;42\r\n\r\n321\r\n\r\n\r\nfoobar&quot;&lt;/code&gt; 代码</target>
        </trans-unit>
        <trans-unit id="0d2adef1f69f8dff2d1dcc4d1bd9850708850158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use 2 scanner objects instead of one&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用2个扫描仪对象而不是一个&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef28c560bd67f0e0f4953b7c23f5c2507be1533" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Workaround:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Workaround:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61ac0246f79c4b57695a1547128e8b7cded82bb8" translate="yes" xml:space="preserve">
          <source>Advantages :</source>
          <target state="translated">优点 :</target>
        </trans-unit>
        <trans-unit id="fb62cdea39d977351a6037cf5625c21cd1fc59a4" translate="yes" xml:space="preserve">
          <source>Alternatively you can do it C# style and parse a nextLine to an integer like so:</source>
          <target state="translated">另外,你也可以用C#的风格,把nextLine解析成一个整数,就像这样。</target>
        </trans-unit>
        <trans-unit id="2b1cba757b139aa52180f923668b1674db554ca3" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;nextXXX()&lt;/code&gt; methods don't read &lt;code&gt;newline&lt;/code&gt;, except &lt;code&gt;nextLine()&lt;/code&gt;. We can skip the &lt;code&gt;newline&lt;/code&gt; after reading any &lt;code&gt;non-string&lt;/code&gt; value (&lt;code&gt;int&lt;/code&gt; in this case) by using &lt;code&gt;scanner.skip()&lt;/code&gt; as below:</source>
          <target state="translated">由于 &lt;code&gt;nextXXX()&lt;/code&gt; 方法不读取 &lt;code&gt;newline&lt;/code&gt; ，除了 &lt;code&gt;nextLine()&lt;/code&gt; 。 在读取任何 &lt;code&gt;non-string&lt;/code&gt; 值（在这种情况下为 &lt;code&gt;int&lt;/code&gt; ）之后，我们可以通过使用如下 &lt;code&gt;scanner.skip()&lt;/code&gt; 来跳过 &lt;code&gt;newline&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0fd82344fa304c1dd4055b949995baf438f7846f" translate="yes" xml:space="preserve">
          <source>As previously stated, calling &lt;code&gt;input.nextLine()&lt;/code&gt; after getting your int value will solve your problem. The reason why your code didn't work was because there was nothing else to store from your input (where you inputted the int) into &lt;code&gt;string1&lt;/code&gt;. I'll just shed a little more light to the entire topic.</source>
          <target state="translated">如前所述，在获取int值之后调用 &lt;code&gt;input.nextLine()&lt;/code&gt; 将解决您的问题。 您的代码无法正常工作的原因是，您的输入（您在其中输入int的内容）中没有其他要存储到 &lt;code&gt;string1&lt;/code&gt; 的内容 。 我将为整个主题提供更多信息。</target>
        </trans-unit>
        <trans-unit id="2f31b23750226d934737a24b3f09c090104f16c2" translate="yes" xml:space="preserve">
          <source>BTW &lt;code&gt;nextLine&lt;/code&gt; also &lt;em&gt;consumes&lt;/em&gt; those line separators.</source>
          <target state="translated">BTW &lt;code&gt;nextLine&lt;/code&gt; 也使用那些行分隔符。</target>
        </trans-unit>
        <trans-unit id="19095fe2701b8ec2bf4d7a6be7459653c80841cb" translate="yes" xml:space="preserve">
          <source>Code :</source>
          <target state="translated">代码 :</target>
        </trans-unit>
        <trans-unit id="635fc6fa5a8e88c6c6559e092853eaf5e388aeef" translate="yes" xml:space="preserve">
          <source>Consider &lt;em&gt;nextLine()&lt;/em&gt; as the odd one out among the &lt;em&gt;nextFoo()&lt;/em&gt; methods in the Scanner class. Let's take a quick example.. Let's say we have two lines of code like the ones below:</source>
          <target state="translated">将&lt;em&gt;nextLine（）&lt;/em&gt;视为Scanner类中&lt;em&gt;nextFoo（）&lt;/em&gt;方法中的奇数。 让我们举个简单的例子。假设我们有两行代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="002e9982d256050d883ef1699f718354b3cc3337" translate="yes" xml:space="preserve">
          <source>Copy the Given Code below your java code.</source>
          <target state="translated">将Given代码复制到你的java代码下面。</target>
        </trans-unit>
        <trans-unit id="7663ac04f8dea414c68a9376e483611c239cbf2b" translate="yes" xml:space="preserve">
          <source>Doing this works just as well, and it saves you a line of code.</source>
          <target state="translated">这样做就好用了,还能为你节省一行代码。</target>
        </trans-unit>
        <trans-unit id="13ae67b14ee7a023f7ff33b63de3b4c801273e5c" translate="yes" xml:space="preserve">
          <source>EDIT: as @PatrickParker noted below, this will cause an infinite loop if user inputs any whitespace after the number. See their answer for a better pattern to use with skip: &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https://stackoverflow.com/a/42471816/143585&lt;/a&gt;</source>
          <target state="translated">编辑：如下@PatrickParker所述，如果用户在数字后输入任何空格，这将导致无限循环。 请参阅他们的答案以获取与跳过一起使用的更好模式： &lt;a href=&quot;https://stackoverflow.com/a/42471816/143585&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/42471816/143585</target>
        </trans-unit>
        <trans-unit id="a00740e62f881fb4b637adb2a149d6d4dda30c90" translate="yes" xml:space="preserve">
          <source>Either put a &lt;code&gt;Scanner.nextLine&lt;/code&gt; call after each &lt;code&gt;Scanner.nextInt&lt;/code&gt; or &lt;code&gt;Scanner.nextFoo&lt;/code&gt; to consume rest of that line including &lt;em&gt;newline&lt;/em&gt;</source>
          <target state="translated">在每个 &lt;code&gt;Scanner.nextInt&lt;/code&gt; 或 &lt;code&gt;Scanner.nextFoo&lt;/code&gt; 之后放置 &lt;code&gt;Scanner.nextLine&lt;/code&gt; 调用，以消耗该行的其余部分，包括&lt;em&gt;换行符&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="0483beb1135269908e7a45fb455b6f6963675242" translate="yes" xml:space="preserve">
          <source>Example :</source>
          <target state="translated">例子 :</target>
        </trans-unit>
        <trans-unit id="1ea6c561d0d39b2a9b43c6ee0183e3b4518033f4" translate="yes" xml:space="preserve">
          <source>Flushes Buffer for every next input</source>
          <target state="translated">每下一次输入都要冲洗缓冲区</target>
        </trans-unit>
        <trans-unit id="7e06811cbd4c56a0f5d613919cbfee5e88f0a9cf" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;Scanner&lt;/code&gt; methods &lt;code&gt;nextInt()&lt;/code&gt; and &lt;code&gt;nextLine()&lt;/code&gt; for reading input.</source>
          <target state="translated">我正在使用 &lt;code&gt;Scanner&lt;/code&gt; 方法 &lt;code&gt;nextInt()&lt;/code&gt; 和 &lt;code&gt;nextLine()&lt;/code&gt; 读取输入。</target>
        </trans-unit>
        <trans-unit id="696ce6127beeba3523dbb29590922581f35141b0" translate="yes" xml:space="preserve">
          <source>I guess I'm pretty late to the party..</source>
          <target state="translated">我想我是来晚了......</target>
        </trans-unit>
        <trans-unit id="d349f68c15e01a087fd9a0d658f3db417be916d7" translate="yes" xml:space="preserve">
          <source>I hope this helps.. Merry coding!</source>
          <target state="translated">我希望这对你有帮助.....编码快乐!</target>
        </trans-unit>
        <trans-unit id="2d556e4c136e883374af9aa52727bd3818d1dd05" translate="yes" xml:space="preserve">
          <source>I tested my application and it looks like the problem lies in using &lt;code&gt;input.nextInt()&lt;/code&gt;. If I delete it, then both &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; and &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; are executed as I want them to be.</source>
          <target state="translated">我测试了我的应用程序，看起来问题出在使用 &lt;code&gt;input.nextInt()&lt;/code&gt; 。 如果我删除它，那么 &lt;code&gt;string1 = input.nextLine()&lt;/code&gt; 和 &lt;code&gt;string2 = input.nextLine()&lt;/code&gt; 都按照我希望的方式执行。</target>
        </trans-unit>
        <trans-unit id="77960121ea1555cb0df4ff3bde8191c00116f793" translate="yes" xml:space="preserve">
          <source>If we input the value below (as a single line of input)</source>
          <target state="translated">如果我们输入下面的值(作为单行输入)</target>
        </trans-unit>
        <trans-unit id="a38e67c54c42a5512691e8e1b9804287ebb56652" translate="yes" xml:space="preserve">
          <source>If you want to read both strings and ints, a solution is to use two Scanners:</source>
          <target state="translated">如果你想同时读取字符串和ints,一个解决方案是使用两个扫描仪。</target>
        </trans-unit>
        <trans-unit id="4ded73408781de19fbe45a6dddd399e16827e4cc" translate="yes" xml:space="preserve">
          <source>If you want to scan input fast without getting confused into Scanner class nextLine() method , Use Custom Input Scanner for it .</source>
          <target state="translated">如果你想快速扫描输入,而不迷惑于Scanner类的nextLine()方法,使用自定义输入法扫描器进行扫描。</target>
        </trans-unit>
        <trans-unit id="2bf7e3910af2c708c663efffc860e3a0530af49b" translate="yes" xml:space="preserve">
          <source>In one of my usecase, I had the scenario of reading a &lt;strong&gt;string value preceded by a couple of integer values&lt;/strong&gt;. I had to use a &quot;&lt;strong&gt;for / while loop&lt;/strong&gt;&quot; to read the values. And none of the above suggestions worked in this case.</source>
          <target state="translated">在我的一个用例中，有一种方案是读取一个&lt;strong&gt;字符串值，然后是几个整数值&lt;/strong&gt; 。 我必须使用&amp;ldquo; &lt;strong&gt;for / while循环&lt;/strong&gt; &amp;rdquo;来读取值。 在这种情况下，以上建议均无效。</target>
        </trans-unit>
        <trans-unit id="10d3c730a99e74d5a24dd317d4db4a694e228ad9" translate="yes" xml:space="preserve">
          <source>In order to avoid the issue, use &lt;code&gt;nextLine();&lt;/code&gt; immediately after &lt;code&gt;nextInt();&lt;/code&gt; as it helps in clearing out the buffer. When you press &lt;code&gt;ENTER&lt;/code&gt; the &lt;code&gt;nextInt();&lt;/code&gt; does not capture the new line and hence, skips the &lt;code&gt;Scanner&lt;/code&gt; code later.</source>
          <target state="translated">为了避免该问题，请使用 &lt;code&gt;nextLine();&lt;/code&gt; 。 在 &lt;code&gt;nextInt();&lt;/code&gt; 因为它有助于清除缓冲区。 当您按 &lt;code&gt;ENTER&lt;/code&gt; 时 ， &lt;code&gt;nextInt();&lt;/code&gt; 不会捕获新行，因此稍后会跳过 &lt;code&gt;Scanner&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="1edb3ce39c21cf9587795abbe3311a18bf0c8903" translate="yes" xml:space="preserve">
          <source>Initialise Object for Given Class</source>
          <target state="translated">为给定类初始化对象</target>
        </trans-unit>
        <trans-unit id="b1b2eea9a00239d91a7c93b3f68769f6bc79e8ce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;input.nextLine()&lt;/code&gt; use &lt;code&gt;input.next()&lt;/code&gt;, that should solve the problem.</source>
          <target state="translated">代替 &lt;code&gt;input.nextLine()&lt;/code&gt; 使用 &lt;code&gt;input.next()&lt;/code&gt; ，应该可以解决问题。</target>
        </trans-unit>
        <trans-unit id="5a9a73068cabea22a1e6fe0fc9bd5ef7971141e4" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;input.nextLine()&lt;/code&gt; immediately after &lt;code&gt;input.nextInt()&lt;/code&gt;</source>
          <target state="translated">相反，请在 &lt;code&gt;input.nextInt()&lt;/code&gt; 之后立即使用input.nextLine（）</target>
        </trans-unit>
        <trans-unit id="dc65d994a35abffd8df4ed8ea137588c33ec9b15" translate="yes" xml:space="preserve">
          <source>It does that because &lt;code&gt;input.nextInt();&lt;/code&gt; doesn't capture the newline. you could do like the others proposed by adding an &lt;code&gt;input.nextLine();&lt;/code&gt; underneath.</source>
          <target state="translated">这样做是因为 &lt;code&gt;input.nextInt();&lt;/code&gt; 不捕获换行符。 您可以通过添加 &lt;code&gt;input.nextLine();&lt;/code&gt; 来完成其他建议的操作。 下。</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">它看起来是这样的</target>
        </trans-unit>
        <trans-unit id="3c95406d44cb825b56c4dfe09670a16f7805a269" translate="yes" xml:space="preserve">
          <source>It's because when you enter a number then press</source>
          <target state="translated">这是因为当你输入一个数字,然后按下</target>
        </trans-unit>
        <trans-unit id="75d4d0fa84b2616f2559145a9e543dcf04362e6e" translate="yes" xml:space="preserve">
          <source>Lastly, the next() method simply takes the nearest String &lt;strong&gt;without&lt;/strong&gt; generating a new line; this makes this the preferential method for taking separate Strings within the same single line.</source>
          <target state="translated">最后，next（）方法仅采用最接近的String &lt;strong&gt;而不&lt;/strong&gt;生成新行； 这使它成为在同一行中采用单独的字符串的首选方法。</target>
        </trans-unit>
        <trans-unit id="d1d9319457390e1dead075b888d4ff571e51eac8" translate="yes" xml:space="preserve">
          <source>Methods :</source>
          <target state="translated">方法</target>
        </trans-unit>
        <trans-unit id="963f50210de73d6adb4e4a4d700c1acde79d6293" translate="yes" xml:space="preserve">
          <source>Modified code:</source>
          <target state="translated">修改后的代码:</target>
        </trans-unit>
        <trans-unit id="66848aec0d0dab5e4aa6db56c612529606000bb0" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;Scanner#nextLine()&lt;/code&gt; simply collects and returns all characters &lt;em&gt;until it finds line separators&lt;/em&gt; (or end of stream). But since line separators after reading the number from the console are found immediately in Scanner's cache, it returns empty String, meaning that Scanner was not able to find any character before those line separators (or end of stream).</source>
          <target state="translated">现在， &lt;code&gt;Scanner#nextLine()&lt;/code&gt; 只是收集并返回所有字符， &lt;em&gt;直到找到行分隔符&lt;/em&gt; （或流的末尾） &lt;em&gt;为止&lt;/em&gt; 。 但是，由于从控制台读取数字后的行分隔符会立即在Scanner的缓存中找到，因此它返回空字符串，这意味着Scanner在这些行分隔符（或流的末尾）之前找不到任何字符。</target>
        </trans-unit>
        <trans-unit id="6bd03a7d475e74af9f88c473ad6e73bd6b8b77bc" translate="yes" xml:space="preserve">
          <source>Or, even better, read the input through &lt;code&gt;Scanner.nextLine&lt;/code&gt; and convert your input to the proper format you need. For example, you may convert to an integer using &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt;&lt;code&gt;Integer.parseInt(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">或者，甚至更好的是，通过 &lt;code&gt;Scanner.nextLine&lt;/code&gt; 读取输入，并将输入转换为所需的正确格式。 例如，您可以使用&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)&quot;&gt; &lt;code&gt;Integer.parseInt(String)&lt;/code&gt; &lt;/a&gt;方法转换为整数。</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="35821505e2e6e8e20b4075e0e2fe7993e4ab1ae9" translate="yes" xml:space="preserve">
          <source>Reduces Time Complexity</source>
          <target state="translated">减少了时间的复杂性</target>
        </trans-unit>
        <trans-unit id="b3611377a8ddae98b3fd5ae8e68a0494c2318114" translate="yes" xml:space="preserve">
          <source>Scanner is skipping nextLine() after using next() or nextFoo()</source>
          <target state="translated">Scanner在使用next()或nextFoo()后跳过nextLine()</target>
        </trans-unit>
        <trans-unit id="2ba3201f9253fe49326935b9547594c936b32423" translate="yes" xml:space="preserve">
          <source>Scans Input faster than BufferReader</source>
          <target state="translated">比BufferReader更快的扫描输入</target>
        </trans-unit>
        <trans-unit id="61f6f5d26bd0fa6841d6a278283463ffb2e7b424" translate="yes" xml:space="preserve">
          <source>So when you are asking the user for value like &lt;code&gt;age&lt;/code&gt;, and user types 42 and presses enter, standard input will contain &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">因此，当您询问用户 &lt;code&gt;age&lt;/code&gt; 等值，并且用户键入42并按Enter键时，标准输入将包含 &lt;code&gt;&quot;42\r\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="915380b2025e2ea32e6d63ecbe5ca0d105e28889" translate="yes" xml:space="preserve">
          <source>So when you want to ask for number and then for entire line while avoiding that empty string as result of &lt;code&gt;nextLine&lt;/code&gt;, either</source>
          <target state="translated">因此，当您 &lt;code&gt;nextLine&lt;/code&gt; 输入数字然后再查询整行，同时又要避免由于nextLine导致该空字符串时，要么</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="81b083adda697bdb56a20d1790d8681abb807f3b" translate="yes" xml:space="preserve">
          <source>TL;DR Use &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; before each &lt;code&gt;scanner.newLine()&lt;/code&gt; call, which is executed after:</source>
          <target state="translated">TL; DR在每次调用 &lt;code&gt;scanner.newLine()&lt;/code&gt; 之前使用 &lt;code&gt;scanner.skip(&quot;\\R&quot;)&lt;/code&gt; ，该调用在以下时间执行：</target>
        </trans-unit>
        <trans-unit id="b9a0dd757f8afd33badbe9990f296a1aafeb6947" translate="yes" xml:space="preserve">
          <source>That's because the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt;&lt;code&gt;Scanner.nextInt&lt;/code&gt;&lt;/a&gt; method does not read the &lt;em&gt;newline&lt;/em&gt; character in your input created by hitting &quot;Enter,&quot; and so the call to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt;&lt;code&gt;Scanner.nextLine&lt;/code&gt;&lt;/a&gt; returns after reading that &lt;em&gt;newline&lt;/em&gt;.</source>
          <target state="translated">这是因为&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29&quot;&gt; &lt;code&gt;Scanner.nextInt&lt;/code&gt; &lt;/a&gt;方法不会在通过按&amp;ldquo; Enter&amp;rdquo;键创建的输入中读取&lt;em&gt;换行符&lt;/em&gt; ，因此对&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine%28%29&quot;&gt; &lt;code&gt;Scanner.nextLine&lt;/code&gt; &lt;/a&gt;的调用在读取该&lt;em&gt;换行符&lt;/em&gt;后返回。</target>
        </trans-unit>
        <trans-unit id="6cfe61b93b23a99a69d941bc9eac99b8f483fd93" translate="yes" xml:space="preserve">
          <source>The problem is that after entering the numerical value, the first &lt;code&gt;input.nextLine()&lt;/code&gt; is skipped and the second &lt;code&gt;input.nextLine()&lt;/code&gt; is executed, so that my output looks like this:</source>
          <target state="translated">问题是输入数值后，第一个 &lt;code&gt;input.nextLine()&lt;/code&gt; 被跳过，第二个 &lt;code&gt;input.nextLine()&lt;/code&gt; 被执行，所以我的输出看起来像这样：</target>
        </trans-unit>
        <trans-unit id="ddde142a96e23eda3603161b1436db7d86c53024" translate="yes" xml:space="preserve">
          <source>The problem is with the &lt;strong&gt;input.nextInt()&lt;/strong&gt; method - it only reads the int value. So when you continue reading with input.nextLine() you receive the &quot;\n&quot; Enter key. So to skip this you have to add the &lt;strong&gt;input.nextLine()&lt;/strong&gt;. Hope this should be clear now.</source>
          <target state="translated">问题出在&lt;strong&gt;input.nextInt（）&lt;/strong&gt;方法上-它只读取int值。 因此，当您继续阅读input.nextLine（）时，您会收到&amp;ldquo; \ n&amp;rdquo;回车键。 因此，要跳过此步骤，您必须添加&lt;strong&gt;input.nextLine（）&lt;/strong&gt; 。 希望现在应该弄清楚。</target>
        </trans-unit>
        <trans-unit id="3f31e7321f597a2b4fae45f4c1cd3a445c0c7c27" translate="yes" xml:space="preserve">
          <source>The value of our &lt;code&gt;firstNumber&lt;/code&gt; and &lt;code&gt;secondNumber&lt;/code&gt; variable become 54 and 234 respectively. The reason why this works this way is because a new line feed (&lt;em&gt;i.e \n&lt;/em&gt;)  &lt;strong&gt;&lt;em&gt;IS NOT&lt;/em&gt;&lt;/strong&gt; automatically generated when the nextInt() method takes in the values. It simply takes the &lt;em&gt;&quot;next int&quot;&lt;/em&gt; and moves on. This is the same for the rest of the nextFoo() methods except nextLine().</source>
          <target state="translated">我们的 &lt;code&gt;firstNumber&lt;/code&gt; 和 &lt;code&gt;secondNumber&lt;/code&gt; 变量的值分别变为54和234。 之所以如此工作，是因为当nextInt（）方法接受值时， &lt;strong&gt;&lt;em&gt;不会&lt;/em&gt;&lt;/strong&gt;自动生成新的换行符（ &lt;em&gt;即\ n&lt;/em&gt; ）。 它只是采用&lt;em&gt;&amp;ldquo;下一个int&amp;rdquo;&lt;/em&gt;并继续前进。 除nextLine（）之外，其余其余nextFoo（）方法都是相同的。</target>
        </trans-unit>
        <trans-unit id="af8e7ea64187803595eadb5f2b017a3cad5d4a9a" translate="yes" xml:space="preserve">
          <source>There seem to be many questions about this issue with &lt;code&gt;java.util.Scanner&lt;/code&gt;. I think a more readable/idiomatic solution would be to call &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; to drop any newline characters after calling &lt;code&gt;nextInt()&lt;/code&gt;.</source>
          <target state="translated">关于 &lt;code&gt;java.util.Scanner&lt;/code&gt; 的问题似乎有很多问题。 我认为一种更具可读性/惯用性的解决方案是在调用 &lt;code&gt;nextInt()&lt;/code&gt; 之后，调用scanner.skip（ &lt;code&gt;scanner.skip(&quot;[\r\n]+&quot;)&lt;/code&gt; 删除所有换行符。</target>
        </trans-unit>
        <trans-unit id="452c4ddb10a28ec2d90555e81046ff458fa71020" translate="yes" xml:space="preserve">
          <source>Things you need to know:</source>
          <target state="translated">你需要知道的事情。</target>
        </trans-unit>
        <trans-unit id="d3179f988755b5bb60be9c863f7cebddd9b574c9" translate="yes" xml:space="preserve">
          <source>Try it like that:</source>
          <target state="translated">试试这样做。</target>
        </trans-unit>
        <trans-unit id="57407da8b23d181fa23db3253e9d0f4a5430604b" translate="yes" xml:space="preserve">
          <source>Usage :</source>
          <target state="translated">使用方法 :</target>
        </trans-unit>
        <trans-unit id="66566971990e9567bbe4356e1d7b83f65d85a803" translate="yes" xml:space="preserve">
          <source>Use this code it will fix your problem.</source>
          <target state="translated">使用这个代码,它将解决你的问题。</target>
        </trans-unit>
        <trans-unit id="da071d271d89a4bba999d81fadfe3918d9372bc9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;input.next()&lt;/code&gt; instead of &lt;code&gt;input.nextLine()&lt;/code&gt; fixed the issue. Hope this might be helpful for those dealing with similar scenario.</source>
          <target state="translated">使用 &lt;code&gt;input.next()&lt;/code&gt; 而不是 &lt;code&gt;input.nextLine()&lt;/code&gt; 解决了该问题。 希望这对处理类似情况的人可能有所帮助。</target>
        </trans-unit>
        <trans-unit id="7226d641baa8ae41de06bb475758de53fed8eae0" translate="yes" xml:space="preserve">
          <source>What is important is that this key beside ensuring placing user data to &lt;em&gt;standard input&lt;/em&gt; (represented by &lt;code&gt;System.in&lt;/code&gt; which is read by &lt;code&gt;Scanner&lt;/code&gt;) also sends OS dependant line separators (like for Windows &lt;code&gt;\r\n&lt;/code&gt;) after it.</source>
          <target state="translated">重要的是，此键除了确保将用户数据放入&lt;em&gt;标准输入&lt;/em&gt; （由 &lt;code&gt;System.in&lt;/code&gt; 表示，由 &lt;code&gt;Scanner&lt;/code&gt; 读取）之外，还向其发送依赖于操作系统的行分隔符（例如Windows &lt;code&gt;\r\n&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5f74999b3e95cf6f71b9f27aae94da4b0a057762" translate="yes" xml:space="preserve">
          <source>Why not use a new Scanner for every reading? Like below. With this approach you will not confront your problem.</source>
          <target state="translated">为什么不用新的扫描仪,每次阅读都要用新的扫描仪呢?就像下面这样。有了这个方法,你就不会再去面对你的问题了。</target>
        </trans-unit>
        <trans-unit id="5c4a63babaeaeb0c49e6c1ad33b7739c3722c9c8" translate="yes" xml:space="preserve">
          <source>You will encounter the similar behaviour when you use &lt;code&gt;Scanner.nextLine&lt;/code&gt; after &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt;&lt;code&gt;Scanner.next()&lt;/code&gt;&lt;/a&gt; or any &lt;code&gt;Scanner.nextFoo&lt;/code&gt; method (except &lt;code&gt;nextLine&lt;/code&gt; itself).</source>
          <target state="translated">在&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#next%28%29&quot;&gt; &lt;code&gt;Scanner.next()&lt;/code&gt; &lt;/a&gt;或任何 &lt;code&gt;Scanner.nextFoo&lt;/code&gt; 方法（ &lt;code&gt;nextLine&lt;/code&gt; 本身除外）之后使用 &lt;code&gt;Scanner.nextLine&lt;/code&gt; 时，会遇到类似的行为。</target>
        </trans-unit>
        <trans-unit id="9fea7758b88440c7c56014d785e74b79822df1b6" translate="yes" xml:space="preserve">
          <source>calling &lt;code&gt;nextLine&lt;/code&gt;,</source>
          <target state="translated">调用 &lt;code&gt;nextLine&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="5bff49825d310d45ca3198277065d394e5a1403e" translate="yes" xml:space="preserve">
          <source>carriage return (CR - in String literals represented as &lt;code&gt;&quot;\r&quot;&lt;/code&gt;)</source>
          <target state="translated">回车（CR-以字符串文字形式表示为 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d71a472719c217d1cbb03b0100ec6f4d7963af45" translate="yes" xml:space="preserve">
          <source>consume line separator left by &lt;code&gt;nextInt&lt;/code&gt; from Scanners cache by</source>
          <target state="translated">消耗Scanners缓存中 &lt;code&gt;nextInt&lt;/code&gt; 留下的行分隔符</target>
        </trans-unit>
        <trans-unit id="906919592563b8ceb86995b2350c1f3d4e41ab40" translate="yes" xml:space="preserve">
          <source>don't use &lt;code&gt;nextInt&lt;/code&gt; (nor &lt;code&gt;next&lt;/code&gt;, or any &lt;code&gt;nextTYPE&lt;/code&gt; methods) at all. Instead read entire data line-by-line using &lt;code&gt;nextLine&lt;/code&gt; and parse numbers from each line (assuming one line contains only one number) to proper type like &lt;code&gt;int&lt;/code&gt; via &lt;code&gt;Integer.parseInt&lt;/code&gt;.</source>
          <target state="translated">根本不使用 &lt;code&gt;nextInt&lt;/code&gt; （也不使用 &lt;code&gt;next&lt;/code&gt; 或任何 &lt;code&gt;nextTYPE&lt;/code&gt; 方法）。 而是使用 &lt;code&gt;nextLine&lt;/code&gt; 逐行读取整个数据，并通过 &lt;code&gt;Integer.parseInt&lt;/code&gt; 将每行中的数字（假设一行仅包含一个数字）解析为适当的类型，例如 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="777254e6cdb58468ee14265cac12172de470597b" translate="yes" xml:space="preserve">
          <source>line feed (LF - in String literals represented as &lt;code&gt;&quot;\n&quot;&lt;/code&gt;)</source>
          <target state="translated">换行符（LF-以字符串文字形式表示为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8da85052008fcd09092d1cdda4d021c77716afa0" translate="yes" xml:space="preserve">
          <source>nextLine() generates a new line feed immediately after taking a value; this is what @RohitJain means by saying the new line feed is &quot;consumed&quot;.</source>
          <target state="translated">nextLine()在取值后立即生成一个新的换行符;这就是@RohitJain所说的新换行符 &quot;被消耗 &quot;的意思。</target>
        </trans-unit>
        <trans-unit id="2adabff3d49bda2a937fc4b067e7987b56a2272d" translate="yes" xml:space="preserve">
          <source>or IMO &lt;strong&gt;&lt;em&gt;more readable&lt;/em&gt;&lt;/strong&gt; way would be by calling &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; or &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; to let Scanner skip part matched by line separator (more info about &lt;code&gt;\R&lt;/code&gt;: &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https://stackoverflow.com/a/31060125&lt;/a&gt;)</source>
          <target state="translated">或IMO &lt;strong&gt;&lt;em&gt;更具可读性的&lt;/em&gt;&lt;/strong&gt;方式是调用 &lt;code&gt;skip(&quot;\\R&quot;)&lt;/code&gt; 或 &lt;code&gt;skip(&quot;\r\n|\r|\n&quot;)&lt;/code&gt; 来让Scanner跳过由行分隔符匹配的部分（有关 &lt;code&gt;\R&lt;/code&gt; 更多信息： &lt;a href=&quot;https://stackoverflow.com/a/31060125&quot;&gt;https ：//stackoverflow.com/a/31060125&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="1f6110eaae5d5a0ecdc62ad5c92021701b7e35bc" translate="yes" xml:space="preserve">
          <source>scanChar() - scan single character</source>
          <target state="translated">scanChar()-扫描单个字符</target>
        </trans-unit>
        <trans-unit id="cd026e2048c739cc97f92689f612919ef5c6f357" translate="yes" xml:space="preserve">
          <source>scanDouble() - scan Double value</source>
          <target state="translated">scanDouble()-扫描双倍值</target>
        </trans-unit>
        <trans-unit id="f9f73c1f34ff7aacd07be55f18ef5aa637930aab" translate="yes" xml:space="preserve">
          <source>scanInt() - scan Integer value</source>
          <target state="translated">scanInt()-扫描整数值</target>
        </trans-unit>
        <trans-unit id="ef1eda467483f01eb3b62158743bad7b3d0cae6b" translate="yes" xml:space="preserve">
          <source>scanInt(int[] array) - scans complete Array(Integer)</source>
          <target state="translated">scanInt(int[]array)-扫描完成 Array(Integer)</target>
        </trans-unit>
        <trans-unit id="2465b71fb96ee91597729b6326b210dde7b49bf2" translate="yes" xml:space="preserve">
          <source>scanLong() - scan Long value</source>
          <target state="translated">scanLong()-scan Long值</target>
        </trans-unit>
        <trans-unit id="b51f0a30704bc4d31354bd7ed09956e546786886" translate="yes" xml:space="preserve">
          <source>scanLong(long[] array) - scans complete Array(Long)</source>
          <target state="translated">scanLong(long[]array)-扫描完整的Array(Long)</target>
        </trans-unit>
        <trans-unit id="5573ccf4ef9b0ea26f56581c29410ab374bbbaef" translate="yes" xml:space="preserve">
          <source>scanString() - scan String value</source>
          <target state="translated">scanString()-扫描字符串值</target>
        </trans-unit>
        <trans-unit id="6bbab5d9b19a578d0536edf4fdcfc1a8f42cbf35" translate="yes" xml:space="preserve">
          <source>text which represents few lines also contains non-printable characters between lines (we call them line separators) like</source>
          <target state="translated">代表少数行的文本也包含行与行之间的不可打印字符(我们称之为行分隔符),如</target>
        </trans-unit>
        <trans-unit id="2f36c69e8c8276a72aa79a95117c23454c420b24" translate="yes" xml:space="preserve">
          <source>used in above example:</source>
          <target state="translated">上例中使用的。</target>
        </trans-unit>
        <trans-unit id="78bcf988e9009f9c4b7a945f5289e06addc0b65f" translate="yes" xml:space="preserve">
          <source>when you are reading data from the console, it allows the user to type his response and when he is done he needs to &lt;em&gt;somehow&lt;/em&gt; confirm that fact. To do so, the user is required to press &quot;enter&quot;/&quot;return&quot; key on the keyboard.</source>
          <target state="translated">当您从控制台读取数据时，它允许用户键入其响应，完成后，他需要以&lt;em&gt;某种方式&lt;/em&gt;确认该事实。 为此，要求用户按下键盘上的&amp;ldquo;输入&amp;rdquo; /&amp;ldquo;返回&amp;rdquo;键。</target>
        </trans-unit>
        <trans-unit id="9fb12221c0f1d15ac31091e556227d379cefd286" translate="yes" xml:space="preserve">
          <source>will be able to properly assign &lt;code&gt;num1=42&lt;/code&gt;&lt;code&gt;num2=321&lt;/code&gt;&lt;code&gt;name=foobar&lt;/code&gt;.</source>
          <target state="translated">将能够正确分配 &lt;code&gt;num1=42&lt;/code&gt; &lt;code&gt;num2=321&lt;/code&gt; &lt;code&gt;name=foobar&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
