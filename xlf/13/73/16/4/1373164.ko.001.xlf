<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1373164">
    <body>
      <group id="1373164">
        <trans-unit id="6039cc72c2e501d8b803f4d0f359b7d216beea93" translate="yes" xml:space="preserve">
          <source>&quot;initial_variable&quot;</source>
          <target state="translated">&quot;initial_variable&quot;</target>
        </trans-unit>
        <trans-unit id="5fb6200f31dcb03426f181dfa778a4e44d0588c8" translate="yes" xml:space="preserve">
          <source>&quot;is actually not initial&quot;</source>
          <target state="translated">&quot;실제로 초기가 아니다&quot;</target>
        </trans-unit>
        <trans-unit id="c89219926b58206de9588d41605f62d4b2588d17" translate="yes" xml:space="preserve">
          <source>... choose to implement const variables</source>
          <target state="translated">... const 변수를 구현하도록 선택</target>
        </trans-unit>
        <trans-unit id="e5030f237ca24e2f400d411ec8781c9f8cfeeb12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A better solution&lt;/strong&gt; is to use &lt;code&gt;getattr&lt;/code&gt; or store your variables in a dictionary and then access them by name.</source>
          <target state="translated">&lt;strong&gt;더 나은 해결책&lt;/strong&gt; 은 &lt;code&gt;getattr&lt;/code&gt; 을 사용하거나 사전에 변수를 저장 한 다음 이름으로 변수에 액세스하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="920b598082fb6e89e9b9d2744d7bf0c328bdb5a6" translate="yes" xml:space="preserve">
          <source>Any set of variables can also be wrapped up in a class. 
&quot;Variable&quot; variables may be added to the class instance during runtime by directly accessing the built-in dictionary through __dict__ attribute.</source>
          <target state="translated">모든 변수 집합을 클래스로 래핑 할 수도 있습니다. __dict__ 속성을 통해 내장 사전에 직접 액세스하여 런타임 동안 &quot;가변&quot;변수를 클래스 인스턴스에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b993d4814e701a4900badf1ceb8b6302066b50" translate="yes" xml:space="preserve">
          <source>Finally, don't forget other data structures, such as the &lt;code&gt;set&lt;/code&gt; - this is similar to a dictionary, except that each &quot;name&quot; doesn't have a value attached to it. If you simply need a &quot;bag&quot; of objects, this can be a great choice. Instead of something like this:</source>
          <target state="translated">마지막으로, &lt;code&gt;set&lt;/code&gt; 와 같은 다른 데이터 구조를 잊지 마십시오. 이것은 각 &quot;name&quot;에 값이 첨부되어 있지 않다는 점을 제외하고는 사전과 유사합니다. 단순히 물건의 &quot;가방&quot;이 필요하다면, 이것은 훌륭한 선택이 될 수 있습니다. 이와 같은 대신 :</target>
        </trans-unit>
        <trans-unit id="62b78176387af05976e3c36610897ce9ccbfa774" translate="yes" xml:space="preserve">
          <source>For cases where you're thinking of doing something like</source>
          <target state="translated">다음과 같은 일을 생각하는 경우</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52b22ef05e7a7c371ee7038acef57378bc06dece" translate="yes" xml:space="preserve">
          <source>For ordered sequences, lists are more convenient than dicts with integer keys, because lists support iteration in index order, &lt;a href=&quot;https://stackoverflow.com/questions/509211/understanding-pythons-slice-notation&quot;&gt;slicing&lt;/a&gt;, &lt;code&gt;append&lt;/code&gt;, and other operations that would require awkward key management with a dict.</source>
          <target state="translated">순서가 지정된 시퀀스의 경우 목록은 인덱스 키, &lt;a href=&quot;https://stackoverflow.com/questions/509211/understanding-pythons-slice-notation&quot;&gt;슬라이싱&lt;/a&gt; , &lt;code&gt;append&lt;/code&gt; 및 기타 dict를 사용하여 어색한 키 관리가 필요한 기타 작업의 반복을 지원하므로 정수 키를 사용하는 dict보다 편리합니다.</target>
        </trans-unit>
        <trans-unit id="23aec67b01c0b0bdfacb1ae1afd2813f1c643b24" translate="yes" xml:space="preserve">
          <source>Here is an elaborative manual entry, for instance: &lt;em&gt;&lt;a href=&quot;http://us3.php.net/manual/en/language.variables.variable.php&quot;&gt;Variable variables&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">다음은 정교한 수동 항목입니다. &lt;em&gt;&lt;a href=&quot;http://us3.php.net/manual/en/language.variables.variable.php&quot;&gt;변수 변수&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="849a7a6472a8054e5a032a4226d61b4d0a0b08c7" translate="yes" xml:space="preserve">
          <source>How do I accomplish variable variables in Python?</source>
          <target state="translated">파이썬에서 변수 변수를 어떻게 달성합니까?</target>
        </trans-unit>
        <trans-unit id="ae6552a5bb87a5c1ce1fccd21112be3815f25f8e" translate="yes" xml:space="preserve">
          <source>How do I create a variable number of variables</source>
          <target state="translated">변수 수의 변수를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="8f801a60c8bbd44e6c8e803dd9f5695ec52dec81" translate="yes" xml:space="preserve">
          <source>I have heard this is a bad idea in general though, and it is a security hole in Python. Is that true?</source>
          <target state="translated">나는 이것이 일반적으로 나쁜 생각이라고 들었고, 그것은 파이썬의 보안 구멍입니다. 그게 사실입니까?</target>
        </trans-unit>
        <trans-unit id="d07d315c22fa66a5b4d8a0fde4357d7133883329" translate="yes" xml:space="preserve">
          <source>I have tried both in python 3.7.3, you can use either globals() or vars()</source>
          <target state="translated">파이썬 3.7.3에서 두 가지를 모두 시도했지만 globals () 또는 vars ()</target>
        </trans-unit>
        <trans-unit id="2d30a1844a115b32955e1639993f89ad3a09db05" translate="yes" xml:space="preserve">
          <source>I'm am answering the question: &lt;a href=&quot;https://stackoverflow.com/questions/9437726/how-to-get-the-value-of-a-variable-given-its-name-in-a-string&quot;&gt;How to get the value of a variable given its name in a string?&lt;/a&gt;
which is closed as a duplicate with a link to this question.</source>
          <target state="translated">나는 질문에 대답하고있다 : &lt;a href=&quot;https://stackoverflow.com/questions/9437726/how-to-get-the-value-of-a-variable-given-its-name-in-a-string&quot;&gt;문자열에 이름이 주어진 변수의 값을 얻는 방법?&lt;/a&gt; 이 질문에 대한 링크와 함께 중복으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="18a5f35bd371c48bcc67f192eed772ec90306d1c" translate="yes" xml:space="preserve">
          <source>If the program requires arbitrary variable &quot;names,&quot; a dictionary is the best choice, as explained in other answers. However, if you're simply trying to create many variables and you don't mind referring to them with a sequence of integers, you're probably looking for a &lt;code&gt;list&lt;/code&gt;. This is particularly true if your data are homogeneous, such as daily temperature readings, weekly quiz scores, or a grid of graphical widgets.</source>
          <target state="translated">프로그램에 임의의 변수 &quot;이름&quot;이 필요한 경우 다른 답변에서 설명한대로 사전이 최선의 선택입니다. 그러나 단순히 많은 변수를 만들려고하고 정수 시퀀스로 변수를 참조하는 것이 마음에 들지 않으면 &lt;code&gt;list&lt;/code&gt; 찾고있을 것입니다. 일일 온도 측정 값, 주별 퀴즈 점수 또는 그래픽 위젯 그리드와 같이 데이터가 균일 한 경우 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="64358dd2d48fdd4cd1bc1a000b89807dc3a13b24" translate="yes" xml:space="preserve">
          <source>If the variables in question are part of an object (part of a class for example) then some useful functions to achieve exactly that are &lt;code&gt;hasattr&lt;/code&gt;, &lt;code&gt;getattr&lt;/code&gt;, and &lt;code&gt;setattr&lt;/code&gt;.</source>
          <target state="translated">해당 변수가 객체의 일부 (예 : 클래스의 일부) 인 경우 &lt;code&gt;hasattr&lt;/code&gt; , &lt;code&gt;getattr&lt;/code&gt; 및 &lt;code&gt;setattr&lt;/code&gt; 을 정확하게 달성하는 유용한 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f86c76f8e3155e9eaa5ba6e1caff290311c8717" translate="yes" xml:space="preserve">
          <source>If you don't want to use any object, you can still use &lt;code&gt;setattr()&lt;/code&gt; inside your current module:</source>
          <target state="translated">객체를 사용하지 않으려면 현재 모듈 내에서 &lt;code&gt;setattr()&lt;/code&gt; 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f48f6db9abd28854a569ecf3accb6e0016b254c" translate="yes" xml:space="preserve">
          <source>If you want to access a variable in the local scope you can use &lt;a href=&quot;http://docs.python.org/library/functions.html#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt;, but you cannot assign values to the returned dict.</source>
          <target state="translated">로컬 범위의 변수에 액세스하려면 &lt;a href=&quot;http://docs.python.org/library/functions.html#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있지만 반환 된 dict에 값을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7faf2553f8415046471d7a59c6b718da3ebe659a" translate="yes" xml:space="preserve">
          <source>If you wish to allow overwriting of variables with the same type only:</source>
          <target state="translated">동일한 유형의 변수 만 덮어 쓰려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4e0c3b044bf2ead2176cad648113a8d373dfa0e4" translate="yes" xml:space="preserve">
          <source>Instead of a dictionary you can also use &lt;a href=&quot;https://docs.python.org/library/collections.html#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt; from the collections module, which makes access easier.</source>
          <target state="translated">사전 대신 collections 모듈에서 &lt;a href=&quot;https://docs.python.org/library/collections.html#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt; 을 사용하여 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fab19888db5a67123e5839ab084c0aea1b19536" translate="yes" xml:space="preserve">
          <source>It's not a good idea. If you are accessing a global variable you can use &lt;a href=&quot;http://docs.python.org/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">좋은 생각이 아닙니다. 전역 변수에 액세스하는 경우 &lt;a href=&quot;http://docs.python.org/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f7ac61350f8d755965920838d3ba902791eca0" translate="yes" xml:space="preserve">
          <source>New coders sometimes write code like this:</source>
          <target state="translated">새로운 코더는 때때로 다음과 같은 코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="a892b74a4ac755e4764b0e3e0b4ecbd48f6d9566" translate="yes" xml:space="preserve">
          <source>So for example you can have:</source>
          <target state="translated">예를 들어 다음을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30cf33051ddd11a560ceb2f00189926144ceb761" translate="yes" xml:space="preserve">
          <source>That said, I've implemented a &lt;a href=&quot;https://sourceforge.net/projects/python-vvm/&quot;&gt;variable variables manager&lt;/a&gt;-class which provides some of the above ideas. It works for python 2 and 3.</source>
          <target state="translated">즉, 위의 아이디어 중 일부를 제공하는 &lt;a href=&quot;https://sourceforge.net/projects/python-vvm/&quot;&gt;변수 변수 관리자&lt;/a&gt; 클래스를 구현했습니다. 파이썬 2와 3에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5920ba62da6b3fc96c778d9ff6ddb4b1b25e1823" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/library/types.html#types.SimpleNamespace&quot;&gt;&lt;code&gt;SimpleNamespace&lt;/code&gt;&lt;/a&gt; class could be used to create new attributes with &lt;code&gt;setattr&lt;/code&gt;, or subclass &lt;code&gt;SimpleNamespace&lt;/code&gt; and create your own function to add new attribute names (variables).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/types.html#types.SimpleNamespace&quot;&gt; &lt;code&gt;SimpleNamespace&lt;/code&gt; &lt;/a&gt; 클래스는 &lt;code&gt;setattr&lt;/code&gt; 을 사용하여 새 속성을 작성하거나 &lt;code&gt;SimpleNamespace&lt;/code&gt; 서브 클래스를 작성 하고 새 속성 이름 (변수)을 추가하는 고유 한 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="441ab396ac9de093879ddabaadbb3fab730a2cd3" translate="yes" xml:space="preserve">
          <source>The coder is then left with a pile of named variables, with a coding effort of O(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;), where &lt;em&gt;m&lt;/em&gt; is the number of named variables and &lt;em&gt;n&lt;/em&gt; is the number of times that group of variables needs to be accessed (including creation). The more astute beginner observes that the only difference in each of those lines is a number that changes based on a rule, and decides to use a loop. However, they get stuck on how to dynamically create those variable names, and may try something like this:</source>
          <target state="translated">그런 다음 코더에는 O ( &lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; )의 코딩 노력으로 명명 된 변수 더미가 남습니다. 여기서 &lt;em&gt;m&lt;/em&gt; 은 명명 된 변수 수이고 &lt;em&gt;n&lt;/em&gt; 은 변수 그룹에 액세스해야하는 횟수입니다 (생성 포함). ). 좀 더 초보자는 각 라인의 유일한 차이점은 규칙에 따라 변경되는 숫자이며 루프를 사용하기로 결정한다는 것을 알 수 있습니다. 그러나 변수 이름을 동적으로 만드는 방법을 고수하고 다음과 같이 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cc4f6975b74fc18e12ef2a5b28bb88dc6368a2d" translate="yes" xml:space="preserve">
          <source>The consensus is to use a dictionary for this - see the other answers. This is a good idea for most cases, however, there are many aspects arising from this:</source>
          <target state="translated">합의는이를 위해 사전을 사용하는 것입니다. 다른 답변을보십시오. 이것은 대부분의 경우 좋은 생각이지만 이로 인해 여러 가지 측면이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5732d6a71cc900cd8992693021cb55e36f1df364" translate="yes" xml:space="preserve">
          <source>The following code defines Variables class, which adds variables (in this case attributes) to its instance during the construction. Variable names are taken from a specified list (which, for example, could have been generated by program code):</source>
          <target state="translated">다음 코드는 구성하는 동안 인스턴스에 변수 (이 경우 속성)를 추가하는 Variables 클래스를 정의합니다. 변수 이름은 지정된 목록에서 가져옵니다 (예 : 프로그램 코드로 생성 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3c4500bc627597f72b477bf78ae14689fefc0f0a" translate="yes" xml:space="preserve">
          <source>The result in either case is a populated &lt;code&gt;list&lt;/code&gt;, with the first element accessed with &lt;code&gt;my_calculator.buttons[0]&lt;/code&gt;, the next with &lt;code&gt;my_calculator.buttons[1]&lt;/code&gt;, and so on. The &quot;base&quot; variable name becomes the name of the &lt;code&gt;list&lt;/code&gt; and the varying identifier is used to access it.</source>
          <target state="translated">두 경우 모두 결과는 채워진 &lt;code&gt;list&lt;/code&gt; 이며, 첫 번째 요소는 &lt;code&gt;my_calculator.buttons[0]&lt;/code&gt; 액세스되고 다음 요소는 &lt;code&gt;my_calculator.buttons[1]&lt;/code&gt; 으로 액세스 됩니다. &quot;기본&quot;변수 이름은 &lt;code&gt;list&lt;/code&gt; 의 이름이되며 가변 식별자를 사용하여 해당 이름에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="eeae1384b2f94311d0148155d4105806167ce513" translate="yes" xml:space="preserve">
          <source>Then you can do:</source>
          <target state="translated">그럼 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3faa232d4f5186099e424ea2820d4a021fb7a7f8" translate="yes" xml:space="preserve">
          <source>They soon find that this does not work.</source>
          <target state="translated">그들은 곧 이것이 효과가 없다는 것을 알게되었습니다.</target>
        </trans-unit>
        <trans-unit id="290d56ed9b233f779d04a7b929c7bc7fa6dfb2df" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;list&lt;/code&gt; can also be created in one line with a comprehension:</source>
          <target state="translated">이 &lt;code&gt;list&lt;/code&gt; 은 다음과 같이 한 줄로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff57f7c33f548283912e68a98d7cf258ead89a5" translate="yes" xml:space="preserve">
          <source>This can be assembled as follows:</source>
          <target state="translated">다음과 같이 조립할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7213a70d2034e473881e812faf32408d6512ac9c" translate="yes" xml:space="preserve">
          <source>This way you won't accidentally overwrite previously existing variables (which is the security aspect) and you can have different &quot;namespaces&quot;.</source>
          <target state="translated">이렇게하면 실수로 기존 변수 (보안 측면)를 덮어 쓰지 않으며 다른 &quot;네임 스페이스&quot;를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="409561cf2b160a1c36717f3a6949ebae680daf2d" translate="yes" xml:space="preserve">
          <source>This will assign 'a' to all of these 10 variables, of course you can change the value dynamically as well. All of these variables can be accessed now like other globally declared variable:</source>
          <target state="translated">이렇게하면 10 개의 변수 모두에 'a'가 할당되며 물론 값을 동적으로 변경할 수도 있습니다. 이러한 전역 변수는 모두 전역 적으로 선언 된 다른 변수처럼 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e5295fa48a75da11bc0d9f16c465452c0fc49d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;globals()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;globals()&lt;/code&gt; 사용 ()</target>
        </trans-unit>
        <trans-unit id="e331c614da5d177a4fc6ac78a5fb120a626e96e8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;list&lt;/code&gt; for a sequence of similar objects, a &lt;code&gt;set&lt;/code&gt; for an arbitrarily-ordered bag of objects, or a &lt;code&gt;dict&lt;/code&gt; for a bag of names with associated values.</source>
          <target state="translated">유사한 객체 시퀀스, 임의로 정렬 된 객체 백 &lt;code&gt;set&lt;/code&gt; 또는 관련 값을 가진 이름 백에 대한 &lt;code&gt;list&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="edc0b7560962bcbf6f4322fa4e87eb0b37234292" translate="yes" xml:space="preserve">
          <source>Use the built-in &lt;a href=&quot;http://docs.python.org/library/functions.html#getattr&quot;&gt;&lt;code&gt;getattr&lt;/code&gt;&lt;/a&gt; function to get an attribute on an object by name.  Modify the name as needed.</source>
          <target state="translated">내장 &lt;a href=&quot;http://docs.python.org/library/functions.html#getattr&quot;&gt; &lt;code&gt;getattr&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이름으로 객체의 속성을 가져옵니다. 필요에 따라 이름을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6d13e412e862067defbbb2d6504aee2f2ddbd9" translate="yes" xml:space="preserve">
          <source>Whenever you want to use variable variables, it's probably better to use a dictionary. So instead of writing</source>
          <target state="translated">변수 변수를 사용할 때마다 사전을 사용하는 것이 좋습니다. 글을 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="2eebade0a74f50ac8f0f010afce8443b505c25b9" translate="yes" xml:space="preserve">
          <source>You can actually assign variables to global scope dynamically, for instance, if you want 10 variables that can be accessed on a global scope &lt;code&gt;i_1&lt;/code&gt;, &lt;code&gt;i_2&lt;/code&gt; ... &lt;code&gt;i_10&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 전역 범위 &lt;code&gt;i_1&lt;/code&gt; , &lt;code&gt;i_2&lt;/code&gt; ... &lt;code&gt;i_10&lt;/code&gt; 에서 액세스 할 수있는 10 개의 변수를 원할 경우 실제로 변수를 전역 범위에 동적으로 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b81497c97d5403c47b7179fa6b3fe89dfa1591" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/tutorial/datastructures.html#dictionaries&quot;&gt;dictionaries&lt;/a&gt; to accomplish this. Dictionaries are stores of keys and values.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/tutorial/datastructures.html#dictionaries&quot;&gt;사전&lt;/a&gt; 을 사용하여이를 수행 할 수 있습니다. 사전은 키와 값의 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="7d9bd4cc0b29bc2c2db7ecf717765fd1ce1a3e4d" translate="yes" xml:space="preserve">
          <source>You can use variable key names to achieve the effect of variable variables without the security risk.</source>
          <target state="translated">변수 키 이름을 사용하여 보안 위험없이 변수 변수의 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcf7295d6344e469700691e25ae0c18f64b983ec" translate="yes" xml:space="preserve">
          <source>You have to use &lt;a href=&quot;https://docs.python.org/2/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt; built in method&lt;/a&gt;  to achieve that behaviour:</source>
          <target state="translated">해당 동작을 달성하려면 &lt;a href=&quot;https://docs.python.org/2/library/functions.html#globals&quot;&gt;내장 된 &lt;code&gt;globals()&lt;/code&gt; 메소드&lt;/a&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fdc9257befef940b959102b0145be8ce9eb50604" translate="yes" xml:space="preserve">
          <source>You will have this:</source>
          <target state="translated">당신은 이것을 가질 것입니다 :</target>
        </trans-unit>
        <trans-unit id="428aa556b84407dd42722850e5ec94cb8472df75" translate="yes" xml:space="preserve">
          <source>You'd use &lt;a href=&quot;https://sourceforge.net/p/python-vvm/code/ci/master/tree/variableVariablesManager.py&quot;&gt;the class&lt;/a&gt; like this:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;https://sourceforge.net/p/python-vvm/code/ci/master/tree/variableVariablesManager.py&quot;&gt;클래스를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9df9e6504db50770c7dec41c0e41bebfd97c019" translate="yes" xml:space="preserve">
          <source>a list may be more appropriate than a dict. A list represents an ordered sequence of objects, with integer indices:</source>
          <target state="translated">dict보다 목록이 더 적합 할 수 있습니다. 목록은 정수 인덱스를 사용하여 순서가 지정된 객체 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="1cd4904effad73686c1ae71e998a90fb306559c0" translate="yes" xml:space="preserve">
          <source>however, you are much more flexible, e.g.</source>
          <target state="translated">그러나 훨씬 유연합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="99befabf4533023d4103df2842ce7d736d4c4095" translate="yes" xml:space="preserve">
          <source>if you want to rename a variable name, you'll have to do it manually</source>
          <target state="translated">변수 이름을 바꾸려면 수동으로 변경해야합니다</target>
        </trans-unit>
        <trans-unit id="2ad25a3ab907d0517e675911828c60750b4252e0" translate="yes" xml:space="preserve">
          <source>there's either no locality or globality for variable variables, it depends on the globality of the dictionary</source>
          <target state="translated">변수 변수에 대한 지역성 또는 전역 성이 없으며 사전의 전역성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="630e51783416953ffc715ff70b006a8cccf423e0" translate="yes" xml:space="preserve">
          <source>to raise an exception on overwriting for different types</source>
          <target state="translated">다른 유형의 덮어 쓰기에 대한 예외를 제기</target>
        </trans-unit>
        <trans-unit id="fe9f4907df588254f3f758e18069e1407ae365e1" translate="yes" xml:space="preserve">
          <source>you can decide to overwrite existing variables or  ...</source>
          <target state="translated">기존 변수를 덮어 쓰거나 ...</target>
        </trans-unit>
        <trans-unit id="304747224cc19794b15e3d40426989c941348c0c" translate="yes" xml:space="preserve">
          <source>you write</source>
          <target state="translated">당신은 쓰기</target>
        </trans-unit>
        <trans-unit id="afca87b48d68ef853ce2576d4755bf1bf7a01246" translate="yes" xml:space="preserve">
          <source>you'll yourself be responsible for this dictionary, including garbage collection (of in-dict variables) etc.</source>
          <target state="translated">가비지 수집 (예측 변수) 등을 포함하여이 사전에 대한 책임은 사용자에게 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
