<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/136097">
    <body>
      <group id="136097">
        <trans-unit id="aa144f0df0c14097f3b8e4a435d288dd748a60f2" translate="yes" xml:space="preserve">
          <source>1 - we can directly call static and classmethods without initializing</source>
          <target state="translated">1-初期化せずにスタティックメソッドやクラスメソッドを直接呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0a9d3e4d0a97cf241ef520fe2f9fed00affd565a" translate="yes" xml:space="preserve">
          <source>2- Static method cannot call self method but can call other static and classmethod</source>
          <target state="translated">2-静的メソッドはselfメソッドを呼び出すことはできないが、他の静的メソッドやクラスメソッドを呼び出すことはできる</target>
        </trans-unit>
        <trans-unit id="ba80ec9d2d639befa7d404721881b5c7d98cdae9" translate="yes" xml:space="preserve">
          <source>3- Static method belong to class and will not use object at all.</source>
          <target state="translated">3-静的メソッドはクラスに属し、オブジェクトを一切使用しません。</target>
        </trans-unit>
        <trans-unit id="e8c0b69e76c3b6c611154e992cff7ec6523a7c8d" translate="yes" xml:space="preserve">
          <source>4- Class method are not bound to an object but to a class.</source>
          <target state="translated">4-クラスメソッドはオブジェクトに縛られるのではなく、クラスに縛られる。</target>
        </trans-unit>
        <trans-unit id="2c410662ef68a73ded71a185123e3a9bdd483a53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://rapd.wordpress.com/2008/07/02/python-staticmethod-vs-classmethod/&quot;&gt;Here&lt;/a&gt; is a short article on this question</source>
          <target state="translated">これはこの質問に関する短い記事です</target>
        </trans-unit>
        <trans-unit id="ecef4db1810048a106a04d647a7cecab4f8eae51" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods&quot;&gt;The definitive guide on how to use static, class or abstract methods in Python&lt;/a&gt; is one good link for this topic, and summary it as following.</source>
          <target state="translated">&lt;a href=&quot;https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods&quot;&gt;Pythonで静的メソッド、クラスメソッド、または抽象メソッドを使用する方法に関する決定的なガイド&lt;/a&gt;は、このトピックへの良いリンクの1つであり、次のように要約します。</target>
        </trans-unit>
        <trans-unit id="666e477109d5e8dbab875d1af9b39529b55a2804" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@staticmethod&lt;/code&gt; just disables the default function as method descriptor.  classmethod wraps your function in a container callable that passes a reference to the owning class as first argument:</source>
          <target state="translated">&lt;code&gt;@staticmethod&lt;/code&gt; は、メソッド記述子としてのデフォルト関数を無効にするだけです。 classmethodは、所有するクラスへの参照を最初の引数として渡すコンテナ呼び出し可能オブジェクトで関数をラップします。</target>
        </trans-unit>
        <trans-unit id="9f1da008aee7e1bacb91f2808d9ff3a6fe24d3c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; is bound to &lt;code&gt;foo&lt;/code&gt;. That is what is meant by the term &quot;bound&quot; below:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は &lt;code&gt;foo&lt;/code&gt; にバインドされています。 これが、以下の「バインド」という用語の意味するところです。</target>
        </trans-unit>
        <trans-unit id="63e351f5e858a7fd0d48a6e4d6759d19a111bf63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;classmethod&lt;/code&gt; is mostly used for alternative constructors.</source>
          <target state="translated">&lt;code&gt;classmethod&lt;/code&gt; は、主に代替コンストラクタに使用されます。</target>
        </trans-unit>
        <trans-unit id="7f77acaab87e00fe6a0a1c10f99432922bf13570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; is just a function, but when you call &lt;code&gt;a.foo&lt;/code&gt; you don't just get the function,
you get a &quot;partially applied&quot; version of the function with the object instance &lt;code&gt;a&lt;/code&gt; bound as the first argument to the function. &lt;code&gt;foo&lt;/code&gt; expects 2 arguments, while &lt;code&gt;a.foo&lt;/code&gt; only expects 1 argument.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; は単なる関数ですが、 &lt;code&gt;a.foo&lt;/code&gt; を呼び出すと、関数を取得するだけでなく、関数の最初の引数としてバインドされたオブジェクトインスタンスを持つ「部分的に適用された」バージョンの関数を取得します。 &lt;code&gt;foo&lt;/code&gt; には2つの引数が必要ですが、 &lt;code&gt;a.foo&lt;/code&gt; には1つの引数しか必要ありません。</target>
        </trans-unit>
        <trans-unit id="4c7321399c70f406d6b983cba08f69f8710b39a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;staticmethod&lt;/code&gt; does not use the state of the object. It could be a function external to a class. It only put inside the class for grouping functions with similar functionality (for example, like Java's &lt;code&gt;Math&lt;/code&gt; class static methods)</source>
          <target state="translated">&lt;code&gt;staticmethod&lt;/code&gt; はオブジェクトの状態を使用しません。 これは、クラスの外部の関数である可能性があります。 同様の機能を持つ関数をグループ化するためにクラス内にのみ配置します（たとえば、Javaの &lt;code&gt;Math&lt;/code&gt; クラスの静的メソッドなど）。</target>
        </trans-unit>
        <trans-unit id="70ebfa84e6baeaba89a1999620a95d79a3a014c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Factory methods&lt;/em&gt;, that are used to create an instance for a class using for example some sort of pre-processing.</source>
          <target state="translated">たとえば、ある種の前処理を使用してクラスのインスタンスを作成するために使用される&lt;em&gt;ファクトリメソッド&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="19768dccc2b9e420935daf19e8803203ed16eed2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static methods calling static methods&lt;/em&gt;: if you split a static methods in several static methods, you shouldn't hard-code the class name but use class methods</source>
          <target state="translated">&lt;em&gt;静的メソッドが静的メソッドを呼び出す&lt;/em&gt; ：静的メソッドをいくつかの静的メソッドに分割する場合、クラス名をハードコーディングするのではなく、クラスメソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3d87acdab3eddbb193a6102f1a2534880a4189a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;@classmethod&lt;/code&gt;&lt;/strong&gt; function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That&amp;rsquo;s because the first argument for &lt;code&gt;@classmethod&lt;/code&gt; function must always be &lt;em&gt;cls&lt;/em&gt; (class).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;@classmethod&lt;/code&gt; &lt;/strong&gt;関数もクラスをインスタンス化せずに呼び出すことができますが、その定義は継承を介して、親クラスではなくサブクラスに従いますが、サブクラスによってオーバーライドできます。 &lt;code&gt;@classmethod&lt;/code&gt; 関数の最初の引数は常に&lt;em&gt;cls&lt;/em&gt; （クラス）でなければならないためです 。</target>
        </trans-unit>
        <trans-unit id="07183b14ce2b254988723cad943c35fde62379ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;@staticmethod&lt;/code&gt;&lt;/strong&gt; function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It&amp;rsquo;s definition is immutable via inheritance.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;@staticmethod&lt;/code&gt; &lt;/strong&gt;関数は、クラス内で定義された関数にすぎません。 最初にクラスをインスタンス化せずに呼び出すことができます。 その定義は継承によって不変です。</target>
        </trans-unit>
        <trans-unit id="2b6a30c8a4feebc05c4e9619c9402923e2918c46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benefits of Static Methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;静的メソッドの利点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4541e7106f30501f486b234e7f532b33217c8233" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class Method:&lt;/strong&gt; Python unlike Java and C++ doesn't have constructor overloading.  And so to achieve this you could use &lt;code&gt;classmethod&lt;/code&gt;. Following example will explain this</source>
          <target state="translated">&lt;strong&gt;クラスメソッド：&lt;/strong&gt; JavaやC ++とは異なり、Pythonにはコンストラクタのオーバーロードがありません。 そして、これを実現するには、 &lt;code&gt;classmethod&lt;/code&gt; を使用できます。 次の例はこれを説明します</target>
        </trans-unit>
        <trans-unit id="477db5eb89c8f164a4c2adb5b5140970f46c9422" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class Methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クラスメソッド：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a3084a5494570dbc2dcf3a00d2e16eaa9ab0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Difference:&lt;/strong&gt; A classmethod will receive the class itself as the first argument, while a staticmethod does not.</source>
          <target state="translated">&lt;strong&gt;違い：&lt;/strong&gt;クラスメソッドはクラス自体を最初の引数として受け取りますが、静的メソッドは受け取りません。</target>
        </trans-unit>
        <trans-unit id="cb38e8b8db4a863b4a43406d1c1edbe185ca4988" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Official python docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;公式のPythonドキュメント：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8000d9e43119e78c3dc28894c99b6e45fdf6129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only the first argument differs&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;最初の引数のみが異なります&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f9f5eb385e646bdeefe41d0134d9298e151d0ad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Similarity:&lt;/strong&gt; Both of them can be called on the &lt;em&gt;Class&lt;/em&gt; itself, rather than just the &lt;em&gt;instance&lt;/em&gt; of the class. So, both of them in a sense are &lt;em&gt;Class's methods&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;類似性：&lt;/strong&gt;どちらも、 &lt;em&gt;クラス&lt;/em&gt;の&lt;em&gt;インスタンス&lt;/em&gt;だけでなく、 &lt;em&gt;クラス&lt;/em&gt;自体で呼び出すことができます。 したがって、ある意味では両方とも&lt;em&gt;Classのメソッド&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="13b294aa2a66fd79cfa2fa74b88dff29e3a58028" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static Method:&lt;/strong&gt; This is rather simple, it's not bound to instance or class and you can simply call that using class name.</source>
          <target state="translated">&lt;strong&gt;静的メソッド：&lt;/strong&gt;これはかなりシンプルで、インスタンスやクラスにバインドされておらず、クラス名を使用して呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="e01b6d5fbe10be46aaf391a840622400eeaba30e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static Methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;静的メソッド：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e7552d839770842e4bdc41f92fe9f44d288df33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With classmethods&lt;/strong&gt;, the class of the object instance is implicitly passed as the first argument instead of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;classmethods&lt;/strong&gt;では、オブジェクトインスタンスのクラスが &lt;code&gt;self&lt;/code&gt; ではなく暗黙的に最初の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="a432d953e1017402a8688be133f46b1f6662056f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With staticmethods&lt;/strong&gt;, neither &lt;code&gt;self&lt;/code&gt; (the object instance) nor  &lt;code&gt;cls&lt;/code&gt; (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:</source>
          <target state="translated">&lt;strong&gt;staticmethods&lt;/strong&gt;では、 &lt;code&gt;self&lt;/code&gt; （オブジェクトインスタンス）も &lt;code&gt;cls&lt;/code&gt; （クラス）も最初の引数として暗黙的に渡されません。 これらは、インスタンスまたはクラスから呼び出すことができることを除いて、単純な関数のように動作します。</target>
        </trans-unit>
        <trans-unit id="90bbd0ef7a61c3f762a030a3fabe6121f8aa5f09" translate="yes" xml:space="preserve">
          <source>@classmethod</source>
          <target state="translated">@classmethod</target>
        </trans-unit>
        <trans-unit id="1b87c7f5dd2ac6a4b5c6f0928185ece8eefb7bfa" translate="yes" xml:space="preserve">
          <source>@classmethod : can be used to create a shared global access to all the instances created of that class..... like updating a record by multiple users....
I particulary found it use ful when creating singletons as well..:)</source>
          <target state="translated">classmethod:そのクラスで作成されたすべてのインスタンスへの共有グローバルアクセスを作成するために使うことができます......複数のユーザによるレコードの更新のように。私は特にシングルトンを作成するときに便利だと感じました。)</target>
        </trans-unit>
        <trans-unit id="44ef4b40d79513b33f7f9ae604039ccb1774d51f" translate="yes" xml:space="preserve">
          <source>@classmethod allows you easy access to private members that are associated to the class definition. this is a great way to do singletons, or factory classes that control the number of instances of the created objects exist.</source>
          <target state="translated">これは、シングルトンや、作成されたオブジェクトのインスタンス数を制御するファクトリクラスを行うのに最適な方法です。</target>
        </trans-unit>
        <trans-unit id="cd8d342a5b4d72e4e7a0daeb849290be2f41e7e1" translate="yes" xml:space="preserve">
          <source>@classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance. That&amp;rsquo;s because the first argument for @classmethod function must always be cls (class).</source>
          <target state="translated">@classmethod関数もクラスをインスタンス化せずに呼び出すことができますが、その定義は継承によって、親クラスではなくサブクラスに従います。 @classmethod関数の最初の引数は常にcls（クラス）でなければならないためです。</target>
        </trans-unit>
        <trans-unit id="1800b3976c1e687a9ed79d2d3b2072083ebcd591" translate="yes" xml:space="preserve">
          <source>@decorators were added in python 2.4 If you're using python &amp;lt; 2.4 you can use the classmethod() and staticmethod() function.</source>
          <target state="translated">@decoratorsはpython 2.4で追加されました。Python&amp;lt;2.4を使用している場合は、classmethod（）およびstaticmethod（）関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="f7625edc6b9228ed3988e14a71b1981c5ed03102" translate="yes" xml:space="preserve">
          <source>@static method:  has nothing to do with the class or instance being associated with ...but for readability can use static method</source>
          <target state="translated">staticメソッド:クラスやインスタンスには何の関係もありませんが、可読性のためにスタティックメソッドを使用することができます。</target>
        </trans-unit>
        <trans-unit id="a7e9e685ffa9bc2ea7a32b2ca97495fffb98da72" translate="yes" xml:space="preserve">
          <source>@staticmethod</source>
          <target state="translated">@staticmethod</target>
        </trans-unit>
        <trans-unit id="316937114375aa711e02d313c11e07624f951988" translate="yes" xml:space="preserve">
          <source>@staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It&amp;rsquo;s definition is immutable via inheritance.</source>
          <target state="translated">@staticmethod関数は、クラス内で定義された関数にすぎません。 最初にクラスをインスタンス化せずに呼び出すことができます。 その定義は継承によって不変です。</target>
        </trans-unit>
        <trans-unit id="07d2b2c31d4856ae66f1901996734386b80a1c1e" translate="yes" xml:space="preserve">
          <source>@staticmethod provides marginal performance gains, but I have yet to see a productive use of a static method within a class that couldn't be achieved as a standalone function outside the class.</source>
          <target state="translated">staticmethod はわずかなパフォーマンスの向上をもたらしますが、クラス外のスタンドアロン関数として実現できなかったクラス内のスタティックメソッドを生産的に使用しているのをまだ見たことがありません。</target>
        </trans-unit>
        <trans-unit id="43b64154609a96d68266675199015630093e6d25" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;classmethod&lt;/strong&gt;, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how &lt;code&gt;dict.fromkeys()&lt;/code&gt;, a classmethod, returns an instance of the subclass when called on a subclass:</source>
          <target state="translated">一方、 &lt;strong&gt;classmethod&lt;/strong&gt;は、呼び出されたクラス、または呼び出されたインスタンスのクラスを最初の引数として渡されるメソッドです。 これは、メソッドをクラスのファクトリーにする場合に便利です。最初の引数として呼び出された実際のクラスを取得するため、サブクラスが関係する場合でも、常に適切なクラスをインスタンス化できます。 たとえば、クラスメソッドである &lt;code&gt;dict.fromkeys()&lt;/code&gt; がサブクラスで呼び出されたときにサブクラスのインスタンスを返す方法を確認します。</target>
        </trans-unit>
        <trans-unit id="ea9ca6bfe7447631d34a67f0f001a61c11f0d90e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;staticmethod&lt;/strong&gt; is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument. It is basically useless in Python -- you can just use a module function instead of a staticmethod.</source>
          <target state="translated">&lt;strong&gt;staticmethod&lt;/strong&gt;は、呼び出されたクラスまたはインスタンスについて何も知らないメソッドです。 渡された引数を取得するだけで、暗黙の最初の引数はありません。 これは基本的にPythonでは役に立たない-静的メソッドの代わりにモジュール関数を使用するだけでよい。</target>
        </trans-unit>
        <trans-unit id="fdf2945b9c4df3d30c98cd6d026d7f48f4cc3d83" translate="yes" xml:space="preserve">
          <source>A class method is a similar to an instance method in that it takes an implicit first argument, but instead of taking the instance, it takes the class. Frequently these are used as alternative constructors for better semantic usage and it will support inheritance.</source>
          <target state="translated">クラスメソッドは暗黙の第一引数を取りますが、インスタンスを取る代わりにクラスを取ります。セマンティックな使い方をするために代替のコンストラクタとして使用されることが多く、継承をサポートしています。</target>
        </trans-unit>
        <trans-unit id="7bcf63323ea71d67fbe14ff17405e56e9914d012" translate="yes" xml:space="preserve">
          <source>A class method receives the class as
  implicit first argument, just like an
  instance method receives the instance.
  To declare a class method, use this
  idiom:</source>
          <target state="translated">クラスメソッドは、インスタンスメソッドがインスタンスを受け取るように、クラスを暗黙の第一引数として受け取ります。クラスメソッドを宣言するには、この慣用句を使います。</target>
        </trans-unit>
        <trans-unit id="3d92730dcf5e8db0d25f10bd3fd12e7e4523c413" translate="yes" xml:space="preserve">
          <source>A class method receives the class as implicit first argument, just like an instance method receives the instance. It is a method which is bound to the class and not the object of the class.It has access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances.</source>
          <target state="translated">クラスメソッドは、インスタンスメソッドがインスタンスを受け取るように、クラスを暗黙の第一引数として受け取ります。クラスメソッドは、クラスのオブジェクトではなくクラスにバインドされたメソッドで、オブジェクトのインスタンスではなくクラスを指すクラスパラメータを取るので、クラスの状態にアクセスすることができます。クラスのすべてのインスタンスに適用されるクラスの状態を変更することができます。例えば、すべてのインスタンスに適用されるクラス変数を変更することができます。</target>
        </trans-unit>
        <trans-unit id="4f544cf2ef41a072f58086b28f8ecb1cc39d4746" translate="yes" xml:space="preserve">
          <source>A normal method of a class is an implicit &lt;strong&gt;dynamic&lt;/strong&gt; method which takes the instance as first argument.</source>
          <target state="translated">クラスの通常のメソッドは、最初の引数としてインスタンスを取る暗黙の&lt;strong&gt;動的&lt;/strong&gt;メソッドです。</target>
        </trans-unit>
        <trans-unit id="2b07004d7733b00054b2d72c8854d6ba07c831e3" translate="yes" xml:space="preserve">
          <source>A quick hack-up ofotherwise identical methods in iPython reveals that &lt;code&gt;@staticmethod&lt;/code&gt; yields marginal performance gains (in the nanoseconds), but otherwise it seems to serve no function. Also, any performance gains will probably be wiped out by the additional work of processing the method through &lt;code&gt;staticmethod()&lt;/code&gt; during compilation (which happens prior to any code execution when you run a script).</source>
          <target state="translated">それ以外の点ではiPythonの同じメソッドをすばやくハックアップすると、@ staticmethodによってパフォーマンスが（ナノ秒単位で）わずかに向上することが &lt;code&gt;@staticmethod&lt;/code&gt; ますが、それ以外の場合は機能しないようです。 また、パフォーマンスの向上は、コンパイル中に &lt;code&gt;staticmethod()&lt;/code&gt; を介してメソッドを処理するという追加の作業（スクリプトを実行するときのコード実行の前に行われます）によっておそらくなくなるでしょう。</target>
        </trans-unit>
        <trans-unit id="174b86cd307a93d7ede9985e59dfb55608a534c0" translate="yes" xml:space="preserve">
          <source>A static method does not receive an
  implicit first argument. To declare a
  static method, use this idiom:</source>
          <target state="translated">静的メソッドは暗黙の第一引数を受け取りません。静的メソッドを宣言するには、このイディオムを使用します。</target>
        </trans-unit>
        <trans-unit id="d1a64bfff8220829f5366f3b2a593cfff2896ad2" translate="yes" xml:space="preserve">
          <source>A staticmethod is indeed such a normal function the same as those outside a class definition.</source>
          <target state="translated">staticmethodは確かにクラス定義外のものと同じような普通の関数です。</target>
        </trans-unit>
        <trans-unit id="d402c4c27f3621c9392d6c31422a842c2a7bd1bf" translate="yes" xml:space="preserve">
          <source>Also observe that this is a good example for using a classmethod and a static method,
The static method clearly belongs to the class, since it uses the class Cluster internally.
The classmethod only needs information about the class, and no instance of the object.</source>
          <target state="translated">また、これは classmethod と static メソッドを使用するための良い例であることにも注目してください。classmethod はクラスに関する情報だけを必要とし、オブジェクトのインスタンスは必要ありません。</target>
        </trans-unit>
        <trans-unit id="caa569c9ae472a87f325f4b599c69c6baca55fad" translate="yes" xml:space="preserve">
          <source>An example of a static method is &lt;code&gt;str.maketrans&lt;/code&gt;, moved from the &lt;code&gt;string&lt;/code&gt; module in Python 3.  It makes a translation table suitable for consumption by &lt;code&gt;str.translate&lt;/code&gt;. It does seem rather silly when used from an instance of a string, as demonstrated below, but importing the function from the &lt;code&gt;string&lt;/code&gt; module is rather clumsy, and it's nice to be able to call it from the class, as in &lt;code&gt;str.maketrans&lt;/code&gt;</source>
          <target state="translated">静的メソッドの例は、Python 3の &lt;code&gt;string&lt;/code&gt; モジュールから移動された &lt;code&gt;str.maketrans&lt;/code&gt; です。これにより、変換テーブルが &lt;code&gt;str.translate&lt;/code&gt; による使用に適したものになります。 以下に示すように、文字列のインスタンスから使用すると、かなりばかげているように見えますが、文字 &lt;code&gt;string&lt;/code&gt; モジュールからの関数のインポートはかなり &lt;code&gt;str.maketrans&lt;/code&gt; 、 str.maketransのように、クラスから呼び出すことができるのは良いことです。</target>
        </trans-unit>
        <trans-unit id="4016333d9516bf49e82568ddb25694c7dab41ec1" translate="yes" xml:space="preserve">
          <source>Analyze @staticmethod &lt;strong&gt;literally&lt;/strong&gt; providing different insights.</source>
          <target state="translated">&lt;strong&gt;文字通り&lt;/strong&gt;さまざまな洞察を提供する@staticmethod &lt;strong&gt;を&lt;/strong&gt;分析します。</target>
        </trans-unit>
        <trans-unit id="46dc7b6eec81baff58dad68305e781177e5e36b4" translate="yes" xml:space="preserve">
          <source>And later we can use this as a function that already has the first argument bound to it. In this way, it works like a partial function on the instance:</source>
          <target state="translated">そして、後でこれを、すでに第一引数にバインドされている関数として使うことができます。このようにして、インスタンス上の部分関数のように動作します。</target>
        </trans-unit>
        <trans-unit id="8de9d2abf5cd59c945e75988adc6ab4ac9e4ae20" translate="yes" xml:space="preserve">
          <source>And of course the same thing happens when you call &lt;code&gt;static_foo&lt;/code&gt; with the class &lt;code&gt;A&lt;/code&gt; instead.</source>
          <target state="translated">そしてもちろん、代わりにクラス &lt;code&gt;A&lt;/code&gt; で &lt;code&gt;static_foo&lt;/code&gt; を呼び出すと、同じことが起こります。</target>
        </trans-unit>
        <trans-unit id="0f24da3f406bdcbf3cbb1052ac539ab58118e8b9" translate="yes" xml:space="preserve">
          <source>And you then want to override &lt;code&gt;bar()&lt;/code&gt; in a child class:</source>
          <target state="translated">次に、子クラスの &lt;code&gt;bar()&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="1e36acde21e68ba316af8bc3e870c4b88751f9d9" translate="yes" xml:space="preserve">
          <source>Another benefit of making the &lt;code&gt;_is_cluster_for&lt;/code&gt; method a classmethod is so a subclass can decide to change it's implementation, maybe because it is pretty generic and can handle more than one type of cluster, so just checking the name of the class would not be enough.</source>
          <target state="translated">&lt;code&gt;_is_cluster_for&lt;/code&gt; メソッドをクラスメソッドにするもう1つの利点は、サブクラスが実装を変更することを決定できることです。これは、かなり汎用的であり、複数のタイプのクラスターを処理できるため、クラスの名前を確認するだけでは不十分です。</target>
        </trans-unit>
        <trans-unit id="7dab70172b4929776efda7b5da9421027c390a28" translate="yes" xml:space="preserve">
          <source>Another consideration with respect to staticmethod vs classmethod comes up with inheritance.  Say you have the following class:</source>
          <target state="translated">staticmethodとclassmethodに関してもう一つ考えなければならないのは、継承の問題です。以下のようなクラスがあるとします。</target>
        </trans-unit>
        <trans-unit id="5e28a0e57c66449c767e62be787a89c79b95f964" translate="yes" xml:space="preserve">
          <source>As a matter of fact, &lt;code&gt;classmethod&lt;/code&gt; has a runtime overhead but makes it possible to access the owning class.  Alternatively I recommend using a metaclass and putting the class methods on that metaclass:</source>
          <target state="translated">実際、 &lt;code&gt;classmethod&lt;/code&gt; には実行時のオーバーヘッドがありますが、所有するクラスにアクセスすることができます。 または、メタクラスを使用して、クラスメソッドをそのメタクラスに配置することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0d849f64698b3cf225429211c021d253be4d70d2" translate="yes" xml:space="preserve">
          <source>Basically &lt;code&gt;@classmethod&lt;/code&gt; makes a method whose first argument is the class it's called from (rather than the class instance), &lt;code&gt;@staticmethod&lt;/code&gt; does not have any implicit arguments.</source>
          <target state="translated">基本的に &lt;code&gt;@classmethod&lt;/code&gt; は、最初の引数が（クラスインスタンスではなく） &lt;code&gt;@staticmethod&lt;/code&gt; クラスであるメソッドを作成します。 @ staticmethodには暗黙の引数はありません。</target>
        </trans-unit>
        <trans-unit id="7a9e8fbf97ca31874aa69d63a389a951865d7274" translate="yes" xml:space="preserve">
          <source>Below is the usual way an object instance calls a method. The object instance, &lt;code&gt;a&lt;/code&gt;, is implicitly passed as the first argument.</source>
          <target state="translated">以下は、オブジェクトインスタンスがメソッドを呼び出す通常の方法です。 オブジェクトインスタンス &lt;code&gt;a&lt;/code&gt; は、最初の引数として暗黙的に渡されます。</target>
        </trans-unit>
        <trans-unit id="558943de44a405cf7f92076e794bfab4df9297b3" translate="yes" xml:space="preserve">
          <source>Both of them are non-data descriptors (It would be easier to understand them if you are familiar with &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#implementing-descriptors&quot;&gt;descriptors&lt;/a&gt; first).</source>
          <target state="translated">どちらもデータ記述子ではありません（最初に&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#implementing-descriptors&quot;&gt;記述子について&lt;/a&gt;理解していると、理解しやすくなります）。</target>
        </trans-unit>
        <trans-unit id="96cb4b862bfd721769fe8f3891a2750e3f0d62bb" translate="yes" xml:space="preserve">
          <source>Bound methods</source>
          <target state="translated">バウンド法</target>
        </trans-unit>
        <trans-unit id="485f0584baedc52a76dddcbdc5a384a621979991" translate="yes" xml:space="preserve">
          <source>Can be called through both class and instance.</source>
          <target state="translated">クラスとインスタンスの両方から呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="267824910c5cace5b6b1cc20f56a51bf416793ea" translate="yes" xml:space="preserve">
          <source>Class Method</source>
          <target state="translated">クラスメソッド</target>
        </trans-unit>
        <trans-unit id="96aa2b8b1142697d7bff0fdb46efcf730f9fcac9" translate="yes" xml:space="preserve">
          <source>Class methods are different than C++
  or Java static methods. If you want
  those, see &lt;a href=&quot;http://docs.python.org/2/library/functions.html#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt; in this
  section.</source>
          <target state="translated">クラスメソッドは、C ++またはJavaの静的メソッドとは異なります。 それらが必要な場合は、このセクションの&lt;a href=&quot;http://docs.python.org/2/library/functions.html#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="80672eaa5ba6013d2c0fa4f9eca5fccf474819ff" translate="yes" xml:space="preserve">
          <source>Class methods, as the name suggests, are used to make changes to classes and not the objects. To make changes to classes, they will modify the class attributes(not object attributes), since that is how you update classes.
This is the reason that class methods take the class(conventionally denoted by 'cls') as the first argument.</source>
          <target state="translated">クラスメソッドはその名の通り、オブジェクトではなくクラスに変更を加えるために使用されます。クラスに変更を加えるには、クラスの属性を変更します(オブジェクトの属性ではなく)。これがクラスメソッドが最初の引数としてクラス(従来は'cls')を取る理由です。</target>
        </trans-unit>
        <trans-unit id="b35b086653d69dfdfe1042ce78c4bcdb48c3d279" translate="yes" xml:space="preserve">
          <source>Difference between staticmethod and classmethod</source>
          <target state="translated">staticmethodとclassmethodの違い</target>
        </trans-unit>
        <trans-unit id="164607916d6ea823ef7c78eb0833afe38bf3630f" translate="yes" xml:space="preserve">
          <source>First I'll explain &lt;code&gt;a_normal_instance_method&lt;/code&gt;. This is precisely called an &quot;&lt;strong&gt;instance method&lt;/strong&gt;&quot;. When an instance method is used, it is used as a partial function (as opposed to a total function, defined for all values when viewed in source code) that is, when used, the first of the arguments is predefined as the instance of the object, with all of its given attributes. It has the instance of the object bound to it, and it must be called from an instance of the object. Typically, it will access various attributes of the instance.</source>
          <target state="translated">まず、 &lt;code&gt;a_normal_instance_method&lt;/code&gt; について説明します 。 これは、正確に「 &lt;strong&gt;インスタンスメソッド&lt;/strong&gt; 」と呼ばれ&lt;strong&gt;ます&lt;/strong&gt; 。 インスタンスメソッドが使用される場合、それは（ソースコードで表示されるときにすべての値に対して定義される合計関数ではなく）部分関数として使用されます。つまり、使用される場合、最初の引数はインスタンスのインスタンスとして事前定義されます。指定されたすべての属性を持つオブジェクト。 バインドされているオブジェクトのインスタンスがあり、オブジェクトのインスタンスから呼び出す必要があります。 通常、インスタンスのさまざまな属性にアクセスします。</target>
        </trans-unit>
        <trans-unit id="0f7fb90238ae76c6afb80f76159dd7556d88d38f" translate="yes" xml:space="preserve">
          <source>For example, if you want to create a factory method (A function returning an instance of a different implementation of a class depending on what argument it gets) you can do something like:</source>
          <target state="translated">例えば、ファクトリーメソッド(取得する引数に応じてクラスの異なる実装のインスタンスを返す関数)を作成したい場合は、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="06ec4552ced78aea82f7ba25beef8c69e6f4a32a" translate="yes" xml:space="preserve">
          <source>For example, this binds the &lt;code&gt;str.join&lt;/code&gt; method to the &lt;code&gt;':'&lt;/code&gt; instance:</source>
          <target state="translated">たとえば、これは &lt;code&gt;str.join&lt;/code&gt; メソッドを &lt;code&gt;':'&lt;/code&gt; インスタンスにバインドします。</target>
        </trans-unit>
        <trans-unit id="e14341dc4aa4a22660bb62e64b2a9ec3f3217718" translate="yes" xml:space="preserve">
          <source>For example, this is an instance of a string:</source>
          <target state="translated">例えば、これは文字列のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="90faa00926d9e27636891da919e5733d1122d8b2" translate="yes" xml:space="preserve">
          <source>For the sake of code readability I'd avoid &lt;code&gt;@staticmethod&lt;/code&gt; unless your method will be used for loads of work, where the nanoseconds count.</source>
          <target state="translated">コードを読みやすくするため、ナノ秒がカウントされる作業負荷にメソッドが使用されない限り、 &lt;code&gt;@staticmethod&lt;/code&gt; は避けます。</target>
        </trans-unit>
        <trans-unit id="9a2b129313b892462b40ddd6c79d0af830dea9c8" translate="yes" xml:space="preserve">
          <source>Functions that have first argument as classname.</source>
          <target state="translated">第一引数にクラス名を持つ関数。</target>
        </trans-unit>
        <trans-unit id="807d50dce55b514a4fba42b13f8002d515f8a71b" translate="yes" xml:space="preserve">
          <source>Gives: &lt;code&gt;In Foo2 MAGIC&lt;/code&gt;</source>
          <target state="translated">Gives： &lt;code&gt;In Foo2 MAGIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2860e65bbc0758e8d4d475d85f1680dabe52e6a1" translate="yes" xml:space="preserve">
          <source>Here, with a staticmethod, even though it is a method, &lt;code&gt;a.static_foo&lt;/code&gt; just returns
a good 'ole function with no arguments bound. &lt;code&gt;static_foo&lt;/code&gt; expects 1 argument, and
&lt;code&gt;a.static_foo&lt;/code&gt; expects 1 argument too.</source>
          <target state="translated">ここで、 &lt;code&gt;a.static_foo&lt;/code&gt; メソッドでは、それがメソッドであっても、 a.static_fooは引数がバインドされていない適切な 'ole関数を返すだけです。 &lt;code&gt;static_foo&lt;/code&gt; は1つの引数を期待し、 &lt;code&gt;a.static_foo&lt;/code&gt; も1つの引数を期待します。</target>
        </trans-unit>
        <trans-unit id="ce0274e0663be4ad665ddb61fc313fc1346d7b03" translate="yes" xml:space="preserve">
          <source>Hope I was clear !</source>
          <target state="translated">私がはっきりしていたことを願っています!</target>
        </trans-unit>
        <trans-unit id="536783112e18b97571f614392a4dc28b80515954" translate="yes" xml:space="preserve">
          <source>However, a module level function must live in the module and be specially imported to other places where it is used.</source>
          <target state="translated">しかし、モジュールレベルの関数はモジュール内に住み、それが使用される他の場所に特別にインポートされなければなりません。</target>
        </trans-unit>
        <trans-unit id="8f6343acac6bb042a0e1759058bfdad64fdb5e56" translate="yes" xml:space="preserve">
          <source>However, you could achieve the same thing using &lt;code&gt;@classmethod&lt;/code&gt; as mentioned below</source>
          <target state="translated">ただし、以下のように &lt;code&gt;@classmethod&lt;/code&gt; を使用して同じことを達成できます</target>
        </trans-unit>
        <trans-unit id="fe663cfec4745cf0ea4c84d7a734da467f0e2ce4" translate="yes" xml:space="preserve">
          <source>I started learning programming language with C++ and then Java and then Python and so this question bothered me a lot as well, until I understood the simple usage of each.</source>
          <target state="translated">私はC++でプログラミング言語を学び始めて、次にJava、そしてPythonと学んでいたので、この質問もそれぞれの簡単な使い方を理解するまではかなり頭を悩ませていたのですが、今回の質問では、それぞれの簡単な使い方を理解することができました。</target>
        </trans-unit>
        <trans-unit id="5ab2de0b5f9aebcc8092bd625d4e80db8214b56e" translate="yes" xml:space="preserve">
          <source>I think a better question is &quot;When would you use @classmethod vs @staticmethod?&quot;</source>
          <target state="translated">より良い質問は &quot;@classmethod vs @staticmethodをいつ使うか?&quot; だと思います。</target>
        </trans-unit>
        <trans-unit id="e03cea799789ab3a8ab2445c8c76ff25537711d7" translate="yes" xml:space="preserve">
          <source>I think giving a purely Python version of &lt;code&gt;staticmethod&lt;/code&gt; and &lt;code&gt;classmethod&lt;/code&gt; would help to understand the difference between them at language level.</source>
          <target state="translated">純粋なPythonバージョンの &lt;code&gt;staticmethod&lt;/code&gt; と &lt;code&gt;classmethod&lt;/code&gt; を与えると、言語レベルでの違いを理解するのに役立つと思います。</target>
        </trans-unit>
        <trans-unit id="69a1c0771c12086dd4b452a55dc59cc30ff19aca" translate="yes" xml:space="preserve">
          <source>I will try to explain the basic difference using an example.</source>
          <target state="translated">基本的な違いを例に挙げて説明してみたいと思います。</target>
        </trans-unit>
        <trans-unit id="1bf6e736cb87adbab8ee43c998f8352378eb5f99" translate="yes" xml:space="preserve">
          <source>If it is attached to the object, however, it will follow the object conveniently through importing and inheritance as well.</source>
          <target state="translated">ただし、オブジェクトにくっついている場合は、インポートや継承でも便利にオブジェクトについてきます。</target>
        </trans-unit>
        <trans-unit id="b6064776a38f8588bf3204f57e4defc4d6b48090" translate="yes" xml:space="preserve">
          <source>In contrast, a staticmethod does not take the instance as first argument, so is called &lt;strong&gt;'static'&lt;/strong&gt;.</source>
          <target state="translated">対照的に、 &lt;strong&gt;静的&lt;/strong&gt;メソッドはインスタンスを最初の引数として取らないため、 &lt;strong&gt;「静的」&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="418e1f592595199710930f400b12c6648ac41d0d" translate="yes" xml:space="preserve">
          <source>In more detail...</source>
          <target state="translated">詳しくは...</target>
        </trans-unit>
        <trans-unit id="ce1dc58e2832295d9371005f7e0507920675bea9" translate="yes" xml:space="preserve">
          <source>In python 2, you have to import this function from the increasingly less useful string module:</source>
          <target state="translated">python 2 では、ますます便利ではなくなってきた string モジュールからこの関数をインポートしなければなりません。</target>
        </trans-unit>
        <trans-unit id="f6b415ed12f65f9bbf40b9142a369fba8072e05c" translate="yes" xml:space="preserve">
          <source>Instance methods can be bound via a dotted lookup for use later.</source>
          <target state="translated">インスタンス・メソッドは、後で使用するために点線のルックアップを介してバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="fe77d4b7f35bb53ca43fe505597fa8fc7799f6f4" translate="yes" xml:space="preserve">
          <source>It can be called either on the class
  (such as &lt;code&gt;C.f()&lt;/code&gt;) or on an instance
  (such as &lt;code&gt;C().f()&lt;/code&gt;). The instance is
  ignored except for its class.</source>
          <target state="translated">クラス（ &lt;code&gt;C.f()&lt;/code&gt; ）またはインスタンス（ &lt;code&gt;C().f()&lt;/code&gt; など）で呼び出すことができます。 クラス以外のインスタンスは無視されます。</target>
        </trans-unit>
        <trans-unit id="c2c132e491d3b48b18fe928903a3b9627a4b7db6" translate="yes" xml:space="preserve">
          <source>It can be called either on the class
  (such as &lt;code&gt;C.f()&lt;/code&gt;) or on an instance
  (such as &lt;code&gt;C().f()&lt;/code&gt;). The instance is
  ignored except for its class. If a
  class method is called for a derived
  class, the derived class object is
  passed as the implied first argument.</source>
          <target state="translated">クラス（ &lt;code&gt;C.f()&lt;/code&gt; ）またはインスタンス（ &lt;code&gt;C().f()&lt;/code&gt; など）で呼び出すことができます。 クラス以外のインスタンスは無視されます。 派生クラスに対してクラスメソッドが呼び出された場合、派生クラスオブジェクトは暗黙の最初の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="bab5a5442633b80e598ccbf398e186dbd8ee95fb" translate="yes" xml:space="preserve">
          <source>It eases the readability of the code, and it does not depend on the state of object itself;</source>
          <target state="translated">コードの可読性を容易にし、オブジェクト自体の状態に依存しない。</target>
        </trans-unit>
        <trans-unit id="939616480d0a5694951a8e24ef3733c4dcbedd3d" translate="yes" xml:space="preserve">
          <source>It is luckily grouped into the class just in order to stand closer where it is applied, or you might scroll around to find it.</source>
          <target state="translated">それは幸いにも、それが適用される場所の近くに立つためだけにクラスにグループ化されているか、またはそれを見つけるためにスクロールしているかもしれません。</target>
        </trans-unit>
        <trans-unit id="230b0bc30ac33392bc5367bb425ea96b284d2e75" translate="yes" xml:space="preserve">
          <source>It is very similar to a module level function.</source>
          <target state="translated">モジュールレベルの関数に非常に似ています。</target>
        </trans-unit>
        <trans-unit id="bdaab6a3bf7746bf4181f9f1669e8524b277ed65" translate="yes" xml:space="preserve">
          <source>It localizes the function name in the classscope</source>
          <target state="translated">クラススコープ内の関数名をローカライズします。</target>
        </trans-unit>
        <trans-unit id="f21f6aa25b5c058c5e292d885804e6cf2b2ef443" translate="yes" xml:space="preserve">
          <source>It moves the function code closer to where it is used</source>
          <target state="translated">関数コードを使用する場所に近づけます。</target>
        </trans-unit>
        <trans-unit id="faebdc4b4a231fbaedbee2f66d2684f878485f0d" translate="yes" xml:space="preserve">
          <source>Let me tell the similarity between a method decorated with @classmethod vs @staticmethod first.</source>
          <target state="translated">まず、@classmethodと@staticmethodでデコレーションされたメソッドの類似性を教えてください。</target>
        </trans-unit>
        <trans-unit id="2b2aa4f3e36c9530575f19c9f0598e540f26891d" translate="yes" xml:space="preserve">
          <source>Let's consider we have a &lt;code&gt;Person&lt;/code&gt; class which takes two arguments &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt; and creates the instance of &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">2つの引数 &lt;code&gt;first_name&lt;/code&gt; と &lt;code&gt;last_name&lt;/code&gt; を取り、 &lt;code&gt;Person&lt;/code&gt; のインスタンスを作成するPersonクラスがあるとしましょう。</target>
        </trans-unit>
        <trans-unit id="a9b10a40e3f747fcf229fa77c0fa98a6c253c3a2" translate="yes" xml:space="preserve">
          <source>Maybe a bit of example code will help: Notice the difference in the call signatures of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;class_foo&lt;/code&gt; and &lt;code&gt;static_foo&lt;/code&gt;:</source>
          <target state="translated">多分少しのコード例が役立つでしょう： &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;class_foo&lt;/code&gt; 、 &lt;code&gt;static_foo&lt;/code&gt; の呼び出しシグネチャの違いに注意してください ：</target>
        </trans-unit>
        <trans-unit id="7122abd306cee02d99048842c405d1b59faf3176" translate="yes" xml:space="preserve">
          <source>More convenient to import versus module-level functions since each method does not have to be specially imported</source>
          <target state="translated">各メソッドを特別にインポートする必要がないため、モジュールレベルの関数と比較してインポートがより便利になります。</target>
        </trans-unit>
        <trans-unit id="baee456d57820da13b11bc2426c66fd95bd49685" translate="yes" xml:space="preserve">
          <source>My contribution demonstrates the difference amongst &lt;code&gt;@classmethod&lt;/code&gt;, &lt;code&gt;@staticmethod&lt;/code&gt;, and instance methods, including how an instance can indirectly call a &lt;code&gt;@staticmethod&lt;/code&gt;. But instead of indirectly calling a &lt;code&gt;@staticmethod&lt;/code&gt; from an instance, making it private may be more &quot;pythonic.&quot; Getting something from a private method isn't demonstrated here but it's basically the same concept.</source>
          <target state="translated">私の貢献は、インスタンスがどのように間接的に &lt;code&gt;@staticmethod&lt;/code&gt; を呼び出すことができるかなど、 &lt;code&gt;@staticmethod&lt;/code&gt; &lt;code&gt;@classmethod&lt;/code&gt; 、 @staticmethod 、およびインスタンスメソッドの違いを示しています。 ただし、インスタンスから &lt;code&gt;@staticmethod&lt;/code&gt; を間接的に呼び出す代わりに、インスタンスをプライベートにすることは、より「Python的」になる可能性があります。 ここではプライベートメソッドから何かを取得する方法は示していませんが、基本的には同じ概念です。</target>
        </trans-unit>
        <trans-unit id="06bdb3d7b2f194e09ab0a51f0107d3fa31a0f2c6" translate="yes" xml:space="preserve">
          <source>Now, if the requirement comes where you need to create a class using a single name only, just a &lt;code&gt;first_name&lt;/code&gt;, you &lt;strong&gt;can't&lt;/strong&gt; do something like this in Python.</source>
          <target state="translated">さて、 &lt;code&gt;first_name&lt;/code&gt; だけの単一の名前のみを使用してクラスを作成する必要がある場合、Pythonではこのような&lt;strong&gt;ことはできませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="c446d44cb0d9ce8db33e3b393ea1f71b690bad22" translate="yes" xml:space="preserve">
          <source>On the other hand, a static method does not receive an implicit first argument, compared to class methods or instance methods. And can&amp;rsquo;t access or modify class state. It only belongs to the class because from design point of view that is the correct way. But in terms of functionality is not bound, at runtime, to the class.</source>
          <target state="translated">一方、静的メソッドは、クラスメソッドやインスタンスメソッドと比較して、暗黙的な最初の引数を受け取りません。 また、クラスの状態にアクセスしたり変更したりすることはできません。 これは、設計の観点からは正しい方法であるため、クラスにのみ属します。 ただし、機能に関しては、実行時にクラスにバインドされません。</target>
        </trans-unit>
        <trans-unit id="0601259c1a596a32a613d81d7b9416a72f1706e5" translate="yes" xml:space="preserve">
          <source>One use people have found for class methods is to create &lt;a href=&quot;https://stackoverflow.com/a/1950927/190597&quot;&gt;inheritable alternative constructors&lt;/a&gt;.</source>
          <target state="translated">人々がクラスメソッドに使用した1つの用途は、 &lt;a href=&quot;https://stackoverflow.com/a/1950927/190597&quot;&gt;継承可能な代替コンストラクタ&lt;/a&gt;を作成することです。</target>
        </trans-unit>
        <trans-unit id="3e6e99fe2ce49b8e8aed43869178d41b3d185e3f" translate="yes" xml:space="preserve">
          <source>Python does not have to instantiate a bound-method for object.</source>
          <target state="translated">Pythonはオブジェクトに対してバウンドメソッドをインスタンス化する必要はありません。</target>
        </trans-unit>
        <trans-unit id="f24b1de7ff195e42428cd5db28a36a5b118842b9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/pydata/pandas/blob/master/pandas/core/frame.py&quot;&gt;pandas source code&lt;/a&gt; for other similar examples of alternative constructors, and see also the official Python documentation on &lt;a href=&quot;https://docs.python.org/library/functions.html#classmethod&quot;&gt;&lt;code&gt;classmethod&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/library/functions.html#staticmethod&quot;&gt;&lt;code&gt;staticmethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">代替コンストラクタの他の同様の例については、 &lt;a href=&quot;https://github.com/pydata/pandas/blob/master/pandas/core/frame.py&quot;&gt;pandasソースコード&lt;/a&gt;を参照してください。また、 &lt;a href=&quot;https://docs.python.org/library/functions.html#classmethod&quot;&gt; &lt;code&gt;classmethod&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://docs.python.org/library/functions.html#staticmethod&quot;&gt; &lt;code&gt;staticmethod&lt;/code&gt; &lt;/a&gt;に関する公式のPythonドキュメントも参照してください。</target>
        </trans-unit>
        <trans-unit id="f01d0a8ab6576c208384ec02c477895fb03fdd00" translate="yes" xml:space="preserve">
          <source>Simple functions with no self argument.</source>
          <target state="translated">自己引数を持たないシンプルな関数。</target>
        </trans-unit>
        <trans-unit id="94dd432a314d7dfb9142b28cff141918df0ee440" translate="yes" xml:space="preserve">
          <source>So a static method is, in a sense, not bound to the Class itself and is just hanging in there just because it may have a related functionality.</source>
          <target state="translated">つまり、静的メソッドはある意味ではクラス自体に縛られておらず、関連する機能を持っているかもしれないという理由だけでそこにぶら下がっているだけなのです。</target>
        </trans-unit>
        <trans-unit id="65363de032aba81ff598ab4d63be7b2e577f8cb9" translate="yes" xml:space="preserve">
          <source>So let's say in above example you need a validation that &lt;code&gt;first_name&lt;/code&gt; should not exceed 20 characters, you can simply do this.</source>
          <target state="translated">したがって、上記の例で、 &lt;code&gt;first_name&lt;/code&gt; が20文字を超えてはならないという検証が必要だとしましょう。これは簡単に行うことができます。</target>
        </trans-unit>
        <trans-unit id="182c8c616107a2457bad4250829c2d737ac45ed3" translate="yes" xml:space="preserve">
          <source>So using  &lt;code&gt;@staticmethod&lt;/code&gt; for methods only called directly from the class has become optional in python3. If you want to call them from both class and instance, you still need to use the &lt;code&gt;@staticmethod&lt;/code&gt; decorator.</source>
          <target state="translated">したがって、クラスから直接呼び出されるだけのメソッドに &lt;code&gt;@staticmethod&lt;/code&gt; を使用することは、 python3ではオプションになりました。 クラスとインスタンスの両方からそれらを呼び出す場合でも、 &lt;code&gt;@staticmethod&lt;/code&gt; デコレーターを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9e7b56ba099663ac3dac80d5ad3bbee9b28e3d48" translate="yes" xml:space="preserve">
          <source>Static Method</source>
          <target state="translated">静的メソッド</target>
        </trans-unit>
        <trans-unit id="f4eea620f6c60864e8c46d16abb4c687e8c6331d" translate="yes" xml:space="preserve">
          <source>Static methods in Python are similar
  to those found in Java or C++. For a
  more advanced concept, see
  &lt;a href=&quot;http://docs.python.org/2/library/functions.html#classmethod&quot;&gt;&lt;code&gt;classmethod()&lt;/code&gt;&lt;/a&gt; in this section.</source>
          <target state="translated">Pythonの静的メソッドは、JavaまたはC ++にあるものと似ています。 より高度な概念については、このセクションの&lt;a href=&quot;http://docs.python.org/2/library/functions.html#classmethod&quot;&gt; &lt;code&gt;classmethod()&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e562c390a784edf0b3feb04ea00ba8e2392d8d34" translate="yes" xml:space="preserve">
          <source>Static methods on the other hand, are used to perform functionalities that are not bound to the class i.e. they will not read or write class variables. Hence, static methods do not take classes as arguments. They are used so that classes can perform functionalities that are not directly related to the purpose of the class.</source>
          <target state="translated">一方、静的メソッドは、クラスに縛られない機能を実行するために使用されます。したがって、静的メソッドはクラスを引数として取りません。これらのメソッドは、クラスがクラスの目的とは直接関係のない機能を実行するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5ffe8a646ab05acaf25f6688924681394d7f4b50" translate="yes" xml:space="preserve">
          <source>Staticmethods are used to group functions which have some logical connection with a class to the class.</source>
          <target state="translated">Staticmethodsは、クラスと何らかの論理的な接続を持つ関数をクラスにグループ化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ce6f2467322be66f2c66550f026cdbdd30261e17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@classmethod&lt;/code&gt; form is a function
  &lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;decorator&lt;/em&gt;&lt;/a&gt; &amp;ndash; see the description of
  function definitions in &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;Function
  definitions&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;@classmethod&lt;/code&gt; フォームは関数&lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;デコレーター&lt;/em&gt;&lt;/a&gt;です。詳細については、 &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;関数定義の&lt;/em&gt;&lt;/a&gt;関数定義の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="9055ab2b4172076d48e20f45dc0229a7e5605442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@staticmethod&lt;/code&gt; form is a function
  &lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;decorator&lt;/em&gt;&lt;/a&gt; &amp;ndash; see the description of
  function definitions in &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;Function
  definitions&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;@staticmethod&lt;/code&gt; フォームは関数&lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;デコレーター&lt;/em&gt;&lt;/a&gt;です。詳細については、 &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;関数定義の&lt;/em&gt;&lt;/a&gt;関数定義の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="8f0986b5efbab0453d76f7f6ca9ae170f03a69d9" translate="yes" xml:space="preserve">
          <source>The Normal Instance Method</source>
          <target state="translated">通常のインスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="bd04489a697867005e789fddc84ebc4dd500b1ba" translate="yes" xml:space="preserve">
          <source>The built-in function staticmethod()is used to create them.</source>
          <target state="translated">作成には組み込み関数staticmethod()を使用します。</target>
        </trans-unit>
        <trans-unit id="6421f9367c3ff555773546cfcde71ec15b8c1b25" translate="yes" xml:space="preserve">
          <source>The most canonical example of a builtin classmethod is &lt;code&gt;dict.fromkeys&lt;/code&gt;. It is used as an alternative constructor of dict, (well suited for when you know what your keys are and want a default value for them.)</source>
          <target state="translated">組み込みクラスメソッドの最も標準的な例は &lt;code&gt;dict.fromkeys&lt;/code&gt; です。 これは、dictの代替コンストラクターとして使用されます（キーが何であるかを知っていて、それらのデフォルト値が必要な場合に適しています）。</target>
        </trans-unit>
        <trans-unit id="5944b31af7aa8a97f6f73cdc54e88234802fe3f1" translate="yes" xml:space="preserve">
          <source>The other cases have been well covered by unutbus answer.</source>
          <target state="translated">その他のケースは、unutbusの回答で十分にカバーされています。</target>
        </trans-unit>
        <trans-unit id="d9dcfa9ec5bb063d28e1a65b69d5c1996c83cf8c" translate="yes" xml:space="preserve">
          <source>The static method does &lt;em&gt;not&lt;/em&gt; take the instance as an argument.</source>
          <target state="translated">静的メソッドは、インスタンスを引数として取りませ&lt;em&gt;ん&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="af7cb13e62642ee499a113906d710325fb97372a" translate="yes" xml:space="preserve">
          <source>The workaround here would be to call &lt;code&gt;Foo2.magic()&lt;/code&gt; in &lt;code&gt;bar()&lt;/code&gt;, but then you're repeating yourself (if the name of &lt;code&gt;Foo2&lt;/code&gt; changes, you'll have to remember to update that &lt;code&gt;bar()&lt;/code&gt; method).</source>
          <target state="translated">ここでの回避策は &lt;code&gt;bar()&lt;/code&gt; &lt;code&gt;Foo2.magic()&lt;/code&gt; でFoo2.magic（）を呼び出すことですが、その後、繰り返します（ &lt;code&gt;Foo2&lt;/code&gt; の名前が​​変更された場合、その &lt;code&gt;bar()&lt;/code&gt; メソッドを更新することを忘れないでください）。</target>
        </trans-unit>
        <trans-unit id="d75be3892212a0b3d72aa89d5805947b4703d4c3" translate="yes" xml:space="preserve">
          <source>These are created with classmethod in-built function.</source>
          <target state="translated">これらは classmethod に組み込まれた関数で作成されています。</target>
        </trans-unit>
        <trans-unit id="f15cd3ae0b92af773354fba252df6a2f9c169e4b" translate="yes" xml:space="preserve">
          <source>Think we have a class with &lt;code&gt;b=2&lt;/code&gt;, we will create an object and re-set this to &lt;code&gt;b=4&lt;/code&gt; in it.
Staticmethod cannot access nothing from previous.
Classmethod can access &lt;code&gt;.b==2&lt;/code&gt; only, via &lt;code&gt;cls.b&lt;/code&gt;.
Normal method can access both: &lt;code&gt;.b==4&lt;/code&gt; via &lt;code&gt;self.b&lt;/code&gt; and &lt;code&gt;.b==2&lt;/code&gt; via &lt;code&gt;self.__class__.b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b=2&lt;/code&gt; のクラスがあると考えてください。オブジェクトを作成し、これを &lt;code&gt;b=4&lt;/code&gt; に再設定します。 Staticmethodは以前のものから何もアクセスできません。 Classmethodは、 &lt;code&gt;cls.b&lt;/code&gt; を介して.b &lt;code&gt;.b==2&lt;/code&gt; のみアクセスできます。 通常のメソッドは両方にアクセスできます： &lt;code&gt;.b==4&lt;/code&gt; を介して.b == 4と &lt;code&gt;self.__class__.b&lt;/code&gt; 介して &lt;code&gt;.b==2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80280e49a1f8353c5b3bba30201343e829087168" translate="yes" xml:space="preserve">
          <source>This has changed between python2 and python3:</source>
          <target state="translated">python2とpython3で変更されました。</target>
        </trans-unit>
        <trans-unit id="258f0cf75229fbcab6f2fd1285ff5938bf4aeca7" translate="yes" xml:space="preserve">
          <source>This will give you an error when you will try to create an object (instance).</source>
          <target state="translated">これは、オブジェクト(インスタンス)を作成しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="4adbdfc052a06d13f49928019797c091206b0882" translate="yes" xml:space="preserve">
          <source>This works, but note that now the &lt;code&gt;bar()&lt;/code&gt; implementation in the child class (&lt;code&gt;Foo2&lt;/code&gt;) can no longer take advantage of anything specific to that class.  For example, say &lt;code&gt;Foo2&lt;/code&gt; had a method called &lt;code&gt;magic()&lt;/code&gt; that you want to use in the &lt;code&gt;Foo2&lt;/code&gt; implementation of &lt;code&gt;bar()&lt;/code&gt;:</source>
          <target state="translated">これは機能し &lt;code&gt;bar()&lt;/code&gt; が、子クラス（ &lt;code&gt;Foo2&lt;/code&gt; ）のbar（）実装は、そのクラスに固有の何かを利用できなくなりました。 たとえば、 &lt;code&gt;Foo2&lt;/code&gt; に &lt;code&gt;bar()&lt;/code&gt; の Foo2実装で使用したい &lt;code&gt;magic()&lt;/code&gt; というメソッドがあるとします。</target>
        </trans-unit>
        <trans-unit id="79477ed5dad94d6833e83e3a8699a0463de9de85" translate="yes" xml:space="preserve">
          <source>To decide whether to use &lt;a href=&quot;https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod&quot;&gt;@staticmethod&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.5/library/functions.html?highlight=classmethod#classmethod&quot;&gt;@classmethod&lt;/a&gt; you have to look inside your method. &lt;strong&gt;If your method accesses other variables/methods in your class then use @classmethod&lt;/strong&gt;. On the other hand, if your method does not touches any other parts of the class then use @staticmethod.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod&quot;&gt;@staticmethodと@classmethodの&lt;/a&gt;どちらを使用するかを決定するには、メソッド内を調べる必要があります。 &lt;strong&gt;メソッドがクラス内の他の変数/メソッドにアクセスする場合は、@classmethodを使用します&lt;/strong&gt; 。 一方、メソッドがクラスの他の部分に触れない場合は、@ staticmethodを使用します。</target>
        </trans-unit>
        <trans-unit id="41c4939ed15126e325624c1d7f0ae8e61154e275" translate="yes" xml:space="preserve">
          <source>To me, this is a slight violation of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;open/closed principle&lt;/a&gt;, since a decision made in &lt;code&gt;Foo&lt;/code&gt; is impacting your ability to refactor common code in a derived class (ie it's less open to extension).  If &lt;code&gt;bar()&lt;/code&gt; were a &lt;code&gt;classmethod&lt;/code&gt; we'd be fine:</source>
          <target state="translated">私にとって、これは&lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;オープン/クローズの原則&lt;/a&gt;に対するわずかな違反です。Fooで行われた決定が、派生クラスの共通コードをリファクタリングする機能に影響を与えているためです（つまり、拡張に対してあまりオープンではありません）。 &lt;code&gt;bar()&lt;/code&gt; が &lt;code&gt;classmethod&lt;/code&gt; である場合、問題はありません。</target>
        </trans-unit>
        <trans-unit id="8a5223e4291f77ecc334b5a5bbcbdaa187282c18" translate="yes" xml:space="preserve">
          <source>We could follow the KISS style (keep it simple, stupid): Don't use staticmethods and classmethods, don't use classes without instantiating them, access only the object's attributes &lt;code&gt;self.attribute(s)&lt;/code&gt;. There are languages where the OOP is implemented that way and I think it is not bad idea. :)</source>
          <target state="translated">KISSスタイルに従うことができます（シンプルで愚かにしてください）：staticmethodsとclassmethodsを使用せず、インスタンス化せずにクラスを使用せず、オブジェクトの属性 &lt;code&gt;self.attribute(s)&lt;/code&gt; にのみアクセスします。 OOPがそのように実装されている言語がありますが、それは悪い考えではないと思います。 :)</target>
        </trans-unit>
        <trans-unit id="fcbb519e378d850b1b68ca11bf02470e1595d064" translate="yes" xml:space="preserve">
          <source>What is the difference between @staticmethod and @classmethod in Python?</source>
          <target state="translated">Pythonの@staticmethodと@classmethodの違いは?</target>
        </trans-unit>
        <trans-unit id="eb4e5926c4dc5d5f3bc9f05359bd22b70d529258" translate="yes" xml:space="preserve">
          <source>What is the difference between a function decorated with &lt;a href=&quot;http://docs.python.org/library/functions.html#staticmethod&quot;&gt;&lt;code&gt;@staticmethod&lt;/code&gt;&lt;/a&gt; and one decorated with &lt;a href=&quot;http://docs.python.org/library/functions.html#classmethod&quot;&gt;&lt;code&gt;@classmethod&lt;/code&gt;&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/library/functions.html#staticmethod&quot;&gt; &lt;code&gt;@staticmethod&lt;/code&gt; &lt;/a&gt;で装飾された関数と@classmethodで装飾された関数の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="2e5c6569bb706d28e402587b1466ff95d88243e1" translate="yes" xml:space="preserve">
          <source>When an object's method is called, it is automatically given an extra argument &lt;code&gt;self&lt;/code&gt; as its first argument. That is, method</source>
          <target state="translated">オブジェクトのメソッドが呼び出されると、最初の引数として自動的に追加の引数 &lt;code&gt;self&lt;/code&gt; が与えられます。 つまり、方法</target>
        </trans-unit>
        <trans-unit id="829e8b693aed55e8328e8d5d8439f95ac3af86b9" translate="yes" xml:space="preserve">
          <source>When the method is decorated</source>
          <target state="translated">メソッドが装飾されている場合</target>
        </trans-unit>
        <trans-unit id="341319811e49792c2c672aa7a5e85c27a7f50380" translate="yes" xml:space="preserve">
          <source>When we subclass dict, we can use the same constructor, which creates an instance of the subclass.</source>
          <target state="translated">dictをサブクラス化する際には、同じコンストラクタを使用することで、サブクラスのインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="68ae0e89977a649bad665ad27c89cbedc3a29ee1" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;a.class_foo&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is not bound to &lt;code&gt;class_foo&lt;/code&gt;, rather the class &lt;code&gt;A&lt;/code&gt; is bound to &lt;code&gt;class_foo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.class_foo&lt;/code&gt; では、 &lt;code&gt;a&lt;/code&gt; はclass_fooにバインドされず、クラス &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;class_foo&lt;/code&gt; にバインドされます 。</target>
        </trans-unit>
        <trans-unit id="e91195e59505ea892019be8785a88af1bd3c3f6f" translate="yes" xml:space="preserve">
          <source>Work on class attributes; not on instance attributes.</source>
          <target state="translated">インスタンス属性ではなく、クラス属性で作業します。</target>
        </trans-unit>
        <trans-unit id="adebd78a8dd903e227a396616541192276725be4" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;class_foo&lt;/code&gt; using the class. In fact, if you define something to be
a classmethod, it is probably because you intend to call it from the class rather than from a class instance. &lt;code&gt;A.foo(1)&lt;/code&gt; would have raised a TypeError, but &lt;code&gt;A.class_foo(1)&lt;/code&gt; works just fine:</source>
          <target state="translated">クラスを使用して &lt;code&gt;class_foo&lt;/code&gt; を呼び出すこともできます。 実際、何かをクラスメソッドとして定義する場合、それはおそらく、クラスインスタンスからではなくクラスから呼び出すことを意図しているためです。 &lt;code&gt;A.foo(1)&lt;/code&gt; はTypeErrorを発生させますが、 &lt;code&gt;A.class_foo(1)&lt;/code&gt; は問題なく機能します。</target>
        </trans-unit>
        <trans-unit id="3ffe0412197d5a8f4286d21ec5576d1cbd38ecf0" translate="yes" xml:space="preserve">
          <source>You may have seen Python code like this pseudocode, which demonstrates the signatures of the various method types and provides a docstring to explain each:</source>
          <target state="translated">この擬似コードのようなPythonのコードを見たことがあるかもしれませんが、これは様々なメソッドタイプのシグネチャを示し、それぞれを説明するためのdocstringを提供しています。</target>
        </trans-unit>
        <trans-unit id="aa25ff3c9b231e9b99c6cece2313f1a161111d45" translate="yes" xml:space="preserve">
          <source>You might want to consider the difference between:</source>
          <target state="translated">の違いを考えてみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9d508031d4e84b7cc27af600bec98b3141da798e" translate="yes" xml:space="preserve">
          <source>and you could simply call using &lt;code&gt;class name&lt;/code&gt;</source>
          <target state="translated">そしてあなたは単に &lt;code&gt;class name&lt;/code&gt; を使って呼び出すことができます</target>
        </trans-unit>
        <trans-unit id="d49b88615309e95621c35de40da5fe92499b533d" translate="yes" xml:space="preserve">
          <source>as a guideline, use static methods as utilities, use class methods for example as factory . Or maybe to define a singleton. And use instance methods to model the state and behavior of instances.</source>
          <target state="translated">ガイドラインとしては、静的メソッドをユーティリティとして使い、クラスメソッドをファクトリとして使うなどの方法があります。あるいはシングルトンを定義することもできます。また、インスタンスの状態や振る舞いをモデル化するためにインスタンスメソッドを使うこともできます。</target>
        </trans-unit>
        <trans-unit id="d52a33eead97a71117a46cf4e95a8a4ce30467f3" translate="yes" xml:space="preserve">
          <source>class method</source>
          <target state="translated">クラスメソッド</target>
        </trans-unit>
        <trans-unit id="52f372dd7e7596da7a6a95d387e97222b81d84c7" translate="yes" xml:space="preserve">
          <source>classmethod has no access to attributes of the object. It however can access attributes of the class and of parent classes in the inheritance hierarchy.
It can be called at the class directly (without creating an object). If called at the object then it is the same as normal method which doesn't access &lt;code&gt;self.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; and accesses &lt;code&gt;self.__class__.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; only.</source>
          <target state="translated">classmethodはオブジェクトの属性にアクセスできません。 ただし、継承階層のクラスおよび親クラスの属性にはアクセスできます。 クラスで直接（オブジェクトを作成せずに）呼び出すことができます。 オブジェクトで呼び出された場合、それは &lt;code&gt;self.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; にアクセスせず、 &lt;code&gt;self.__class__.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; のみにアクセスする通常のメソッドと同じです。</target>
        </trans-unit>
        <trans-unit id="7948ad16ed2603a6348a81efc5083231e6e99599" translate="yes" xml:space="preserve">
          <source>classmethod: &lt;strong&gt;the class of the current object&lt;/strong&gt; is automatically passed as an (additional) fist argument</source>
          <target state="translated">classmethod： &lt;strong&gt;現在のオブジェクトのクラスは&lt;/strong&gt; （追加の）第1引数として自動的に渡されます</target>
        </trans-unit>
        <trans-unit id="040092959b9872d342ec8835eaf66a5912667aab" translate="yes" xml:space="preserve">
          <source>if we use the instance method, &lt;code&gt;join&lt;/code&gt; on this string, to join another iterable,
it quite obviously is a function of the instance, in addition to being a function of the iterable list, &lt;code&gt;['a', 'b', 'c']&lt;/code&gt;:</source>
          <target state="translated">インスタンスメソッドを使用して、この文字列に結合し、別の反復可能オブジェクトを結合する場合、それは明らかに、反復可能リストの関数であることに加えて、インスタンスの関数です &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="458d61efa24b172ec0fd06ca32a179e50bd11ce5" translate="yes" xml:space="preserve">
          <source>must be called with 2 arguments. &lt;code&gt;self&lt;/code&gt; is automatically passed, and it is &lt;em&gt;the object itself&lt;/em&gt;.</source>
          <target state="translated">2つの引数を指定して呼び出す必要があります。 &lt;code&gt;self&lt;/code&gt; は自動的に渡され、それは&lt;em&gt;オブジェクトそのもの&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="708f8989ac21092a5c5d8c983540d9bb44c48d11" translate="yes" xml:space="preserve">
          <source>normal method</source>
          <target state="translated">ノーマルメソッド</target>
        </trans-unit>
        <trans-unit id="feaabadfa899129cb55b2beee5ee0ea7aabdd795" translate="yes" xml:space="preserve">
          <source>normal method: &lt;strong&gt;the current object&lt;/strong&gt; if automatically passed as an (additional) first argument</source>
          <target state="translated">通常のメソッド：（追加の）最初の引数として自動的に渡された場合&lt;strong&gt;の現在のオブジェクト&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bced6a1cd17696e1d77254556ccfcc9c6ad98d6a" translate="yes" xml:space="preserve">
          <source>python2:</source>
          <target state="translated">python2:</target>
        </trans-unit>
        <trans-unit id="e174fa5929995f67b31815ee0e9bd6d2d9fd8564" translate="yes" xml:space="preserve">
          <source>python3:</source>
          <target state="translated">python3:</target>
        </trans-unit>
        <trans-unit id="75d198e754da69d735666ee31a24c9846f114435" translate="yes" xml:space="preserve">
          <source>static method</source>
          <target state="translated">スタティックメソッド</target>
        </trans-unit>
        <trans-unit id="6acd42d6636986fd7c20f9eddf725cc1b2a99a5e" translate="yes" xml:space="preserve">
          <source>staticmethod has no access to attibutes of the object, of the class, or of parent classes in the inheritance hierarchy.
It can be called at the class directly (without creating an object).</source>
          <target state="translated">staticmethod は、オブジェクトの属性、クラスの属性、継承階層の親クラスの属性にはアクセスできません。クラスで直接呼び出すことができます (オブジェクトを作成せずに)。</target>
        </trans-unit>
        <trans-unit id="7ac95df276e52f37bfcb52496e9992dd99c61d05" translate="yes" xml:space="preserve">
          <source>staticmethod: &lt;strong&gt;no extra arguments&lt;/strong&gt; are automatically passed. What you passed to the function is what you get.</source>
          <target state="translated">staticmethod： &lt;strong&gt;追加の引数&lt;/strong&gt;は自動的に渡され&lt;strong&gt;ません&lt;/strong&gt; 。 関数に渡したのは、取得したものです。</target>
        </trans-unit>
        <trans-unit id="2fa2da2994698860ee444ff57aadffe1813adf65" translate="yes" xml:space="preserve">
          <source>the automatically provided argument &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;self&lt;/code&gt;, but &lt;em&gt;the class of&lt;/em&gt;&lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">自動的に提供される引数&lt;em&gt;は&lt;/em&gt; &lt;code&gt;self&lt;/code&gt; ではなく&lt;em&gt;、&lt;/em&gt; &lt;code&gt;self&lt;/code&gt; &lt;em&gt;のクラスです&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fbfad97aa3528afd3e7b36e34de780b77e439c1" translate="yes" xml:space="preserve">
          <source>the method &lt;em&gt;is not given&lt;/em&gt; any automatic argument at all. It is only given the parameters that it is called with.</source>
          <target state="translated">メソッドに&lt;em&gt;は&lt;/em&gt; 、自動引数&lt;em&gt;はまったく与えられ&lt;/em&gt;ませ&lt;em&gt;ん&lt;/em&gt; 。 呼び出されたパラメーターのみが指定されます。</target>
        </trans-unit>
        <trans-unit id="2e0f976fbe142678d71e6f50a7587ee622db8c82" translate="yes" xml:space="preserve">
          <source>usages</source>
          <target state="translated">usages</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
