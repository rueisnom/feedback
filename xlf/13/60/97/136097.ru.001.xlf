<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/136097">
    <body>
      <group id="136097">
        <trans-unit id="aa144f0df0c14097f3b8e4a435d288dd748a60f2" translate="yes" xml:space="preserve">
          <source>1 - we can directly call static and classmethods without initializing</source>
          <target state="translated">1-мы можем напрямую вызывать статические и одноклассные методы без инициализации</target>
        </trans-unit>
        <trans-unit id="0a9d3e4d0a97cf241ef520fe2f9fed00affd565a" translate="yes" xml:space="preserve">
          <source>2- Static method cannot call self method but can call other static and classmethod</source>
          <target state="translated">2-Статический метод не может вызвать метод self,но может вызвать другой статический и одноклассный метод.</target>
        </trans-unit>
        <trans-unit id="ba80ec9d2d639befa7d404721881b5c7d98cdae9" translate="yes" xml:space="preserve">
          <source>3- Static method belong to class and will not use object at all.</source>
          <target state="translated">3-Статический метод принадлежит классу и не будет использовать объект вообще.</target>
        </trans-unit>
        <trans-unit id="e8c0b69e76c3b6c611154e992cff7ec6523a7c8d" translate="yes" xml:space="preserve">
          <source>4- Class method are not bound to an object but to a class.</source>
          <target state="translated">4-Метод класса привязан не к объекту,а к классу.</target>
        </trans-unit>
        <trans-unit id="2c410662ef68a73ded71a185123e3a9bdd483a53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://rapd.wordpress.com/2008/07/02/python-staticmethod-vs-classmethod/&quot;&gt;Here&lt;/a&gt; is a short article on this question</source>
          <target state="translated">&lt;a href=&quot;http://rapd.wordpress.com/2008/07/02/python-staticmethod-vs-classmethod/&quot;&gt;Вот&lt;/a&gt; небольшая статья по этому вопросу</target>
        </trans-unit>
        <trans-unit id="ecef4db1810048a106a04d647a7cecab4f8eae51" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods&quot;&gt;The definitive guide on how to use static, class or abstract methods in Python&lt;/a&gt; is one good link for this topic, and summary it as following.</source>
          <target state="translated">&lt;a href=&quot;https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods&quot;&gt;Полное руководство по использованию статических, классовых или абстрактных методов в Python&lt;/a&gt; - одна из хороших ссылок на эту тему, и подытожьте ее следующим образом.</target>
        </trans-unit>
        <trans-unit id="666e477109d5e8dbab875d1af9b39529b55a2804" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@staticmethod&lt;/code&gt; just disables the default function as method descriptor.  classmethod wraps your function in a container callable that passes a reference to the owning class as first argument:</source>
          <target state="translated">&lt;code&gt;@staticmethod&lt;/code&gt; просто отключает функцию по умолчанию как дескриптор метода. classmethod оборачивает вашу функцию в вызываемый контейнер, который передает ссылку на собственный класс в качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="9f1da008aee7e1bacb91f2808d9ff3a6fe24d3c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; is bound to &lt;code&gt;foo&lt;/code&gt;. That is what is meant by the term &quot;bound&quot; below:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; обязан &lt;code&gt;foo&lt;/code&gt; . Вот что подразумевается под термином &amp;laquo;связанный&amp;raquo; ниже:</target>
        </trans-unit>
        <trans-unit id="63e351f5e858a7fd0d48a6e4d6759d19a111bf63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;classmethod&lt;/code&gt; is mostly used for alternative constructors.</source>
          <target state="translated">&lt;code&gt;classmethod&lt;/code&gt; в основном используется для альтернативных конструкторов.</target>
        </trans-unit>
        <trans-unit id="7f77acaab87e00fe6a0a1c10f99432922bf13570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; is just a function, but when you call &lt;code&gt;a.foo&lt;/code&gt; you don't just get the function,
you get a &quot;partially applied&quot; version of the function with the object instance &lt;code&gt;a&lt;/code&gt; bound as the first argument to the function. &lt;code&gt;foo&lt;/code&gt; expects 2 arguments, while &lt;code&gt;a.foo&lt;/code&gt; only expects 1 argument.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; - это просто функция, но когда вы вызываете &lt;code&gt;a.foo&lt;/code&gt; , вы не просто получаете функцию, вы получаете &amp;laquo;частично примененную&amp;raquo; версию функции с экземпляром объекта, связанным в качестве первого аргумента функции. &lt;code&gt;foo&lt;/code&gt; ожидает 2 аргумента, а &lt;code&gt;a.foo&lt;/code&gt; ожидает только 1 аргумент.</target>
        </trans-unit>
        <trans-unit id="4c7321399c70f406d6b983cba08f69f8710b39a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;staticmethod&lt;/code&gt; does not use the state of the object. It could be a function external to a class. It only put inside the class for grouping functions with similar functionality (for example, like Java's &lt;code&gt;Math&lt;/code&gt; class static methods)</source>
          <target state="translated">&lt;code&gt;staticmethod&lt;/code&gt; не использует состояние объекта. Это может быть функция, внешняя по отношению к классу. Он помещается только внутри класса для группировки функций со схожей функциональностью (например, как статические методы класса &lt;code&gt;Math&lt;/code&gt; Java)</target>
        </trans-unit>
        <trans-unit id="70ebfa84e6baeaba89a1999620a95d79a3a014c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Factory methods&lt;/em&gt;, that are used to create an instance for a class using for example some sort of pre-processing.</source>
          <target state="translated">&lt;em&gt;Методы фабрики&lt;/em&gt; , которые используются для создания экземпляра для класса, используя, например, некоторую предварительную обработку.</target>
        </trans-unit>
        <trans-unit id="19768dccc2b9e420935daf19e8803203ed16eed2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static methods calling static methods&lt;/em&gt;: if you split a static methods in several static methods, you shouldn't hard-code the class name but use class methods</source>
          <target state="translated">&lt;em&gt;Статические методы, вызывающие статические методы&lt;/em&gt; : если вы разделяете статические методы на несколько статических методов, вам не нужно жестко кодировать имя класса, а использовать методы класса</target>
        </trans-unit>
        <trans-unit id="3d87acdab3eddbb193a6102f1a2534880a4189a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;@classmethod&lt;/code&gt;&lt;/strong&gt; function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That&amp;rsquo;s because the first argument for &lt;code&gt;@classmethod&lt;/code&gt; function must always be &lt;em&gt;cls&lt;/em&gt; (class).</source>
          <target state="translated">Функция &lt;strong&gt; &lt;code&gt;@classmethod&lt;/code&gt; &lt;/strong&gt; также может &lt;strong&gt;вызываться&lt;/strong&gt; без создания экземпляра класса, но ее определение следует за подклассом, а не родительский класс посредством наследования может быть переопределен подклассом. Это потому, что первым аргументом для функции &lt;code&gt;@classmethod&lt;/code&gt; всегда должен быть &lt;em&gt;cls&lt;/em&gt; (class).</target>
        </trans-unit>
        <trans-unit id="07183b14ce2b254988723cad943c35fde62379ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;@staticmethod&lt;/code&gt;&lt;/strong&gt; function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It&amp;rsquo;s definition is immutable via inheritance.</source>
          <target state="translated">Функция &lt;strong&gt; &lt;code&gt;@staticmethod&lt;/code&gt; &lt;/strong&gt; - это не что иное, как функция, определенная внутри класса. Он вызывается без создания экземпляра класса первым. Это определение является неизменным через наследование.</target>
        </trans-unit>
        <trans-unit id="2b6a30c8a4feebc05c4e9619c9402923e2918c46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benefits of Static Methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Преимущества статических методов:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4541e7106f30501f486b234e7f532b33217c8233" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class Method:&lt;/strong&gt; Python unlike Java and C++ doesn't have constructor overloading.  And so to achieve this you could use &lt;code&gt;classmethod&lt;/code&gt;. Following example will explain this</source>
          <target state="translated">&lt;strong&gt;Метод класса:&lt;/strong&gt; Python в отличие от Java и C ++ не имеет перегрузки конструктора. И поэтому, чтобы достичь этого, вы можете использовать &lt;code&gt;classmethod&lt;/code&gt; . Следующий пример объяснит это</target>
        </trans-unit>
        <trans-unit id="477db5eb89c8f164a4c2adb5b5140970f46c9422" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class Methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Методы класса:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a3084a5494570dbc2dcf3a00d2e16eaa9ab0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Difference:&lt;/strong&gt; A classmethod will receive the class itself as the first argument, while a staticmethod does not.</source>
          <target state="translated">&lt;strong&gt;Разница:&lt;/strong&gt; метод класса получит сам класс в качестве первого аргумента, а метод static - нет.</target>
        </trans-unit>
        <trans-unit id="cb38e8b8db4a863b4a43406d1c1edbe185ca4988" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Official python docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Официальные документы по питону:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8000d9e43119e78c3dc28894c99b6e45fdf6129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only the first argument differs&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Отличается только первый аргумент&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f9f5eb385e646bdeefe41d0134d9298e151d0ad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Similarity:&lt;/strong&gt; Both of them can be called on the &lt;em&gt;Class&lt;/em&gt; itself, rather than just the &lt;em&gt;instance&lt;/em&gt; of the class. So, both of them in a sense are &lt;em&gt;Class's methods&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Сходство:&lt;/strong&gt; оба они могут быть вызваны на самом &lt;em&gt;Классе&lt;/em&gt; , а не только на &lt;em&gt;экземпляре&lt;/em&gt; класса. Итак, оба они в некотором смысле являются &lt;em&gt;методами класса&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="13b294aa2a66fd79cfa2fa74b88dff29e3a58028" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static Method:&lt;/strong&gt; This is rather simple, it's not bound to instance or class and you can simply call that using class name.</source>
          <target state="translated">&lt;strong&gt;Статический метод:&lt;/strong&gt; это довольно просто, он не привязан к экземпляру или классу, и вы можете просто вызвать его, используя имя класса.</target>
        </trans-unit>
        <trans-unit id="e01b6d5fbe10be46aaf391a840622400eeaba30e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static Methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Статические методы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e7552d839770842e4bdc41f92fe9f44d288df33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With classmethods&lt;/strong&gt;, the class of the object instance is implicitly passed as the first argument instead of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;При использовании методов&lt;/strong&gt; класса класс экземпляра объекта неявно передается в качестве первого аргумента, а не в &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a432d953e1017402a8688be133f46b1f6662056f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With staticmethods&lt;/strong&gt;, neither &lt;code&gt;self&lt;/code&gt; (the object instance) nor  &lt;code&gt;cls&lt;/code&gt; (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:</source>
          <target state="translated">&lt;strong&gt;При использовании статических методов&lt;/strong&gt; ни &lt;code&gt;self&lt;/code&gt; (экземпляр объекта), ни &lt;code&gt;cls&lt;/code&gt; (класс) неявно передаются в качестве первого аргумента. Они ведут себя как простые функции, за исключением того, что вы можете вызывать их из экземпляра или класса:</target>
        </trans-unit>
        <trans-unit id="90bbd0ef7a61c3f762a030a3fabe6121f8aa5f09" translate="yes" xml:space="preserve">
          <source>@classmethod</source>
          <target state="translated">@classmethod</target>
        </trans-unit>
        <trans-unit id="1b87c7f5dd2ac6a4b5c6f0928185ece8eefb7bfa" translate="yes" xml:space="preserve">
          <source>@classmethod : can be used to create a shared global access to all the instances created of that class..... like updating a record by multiple users....
I particulary found it use ful when creating singletons as well..:)</source>
          <target state="translated">Я,в частности,обнаружил,что он используется ful и при создании синглетов...:)</target>
        </trans-unit>
        <trans-unit id="44ef4b40d79513b33f7f9ae604039ccb1774d51f" translate="yes" xml:space="preserve">
          <source>@classmethod allows you easy access to private members that are associated to the class definition. this is a great way to do singletons, or factory classes that control the number of instances of the created objects exist.</source>
          <target state="translated">@classmethod позволяет легко получить доступ к приватным членам,которые связаны с определением класса.это отличный способ делать синглоны,или заводские классы,которые контролируют количество экземпляров создаваемых объектов.</target>
        </trans-unit>
        <trans-unit id="cd8d342a5b4d72e4e7a0daeb849290be2f41e7e1" translate="yes" xml:space="preserve">
          <source>@classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance. That&amp;rsquo;s because the first argument for @classmethod function must always be cls (class).</source>
          <target state="translated">Функция @classmethod также может вызываться без создания экземпляра класса, но ее определение следует через Sub class, а не Parent, посредством наследования. Это потому, что первым аргументом для функции @classmethod всегда должен быть cls (class).</target>
        </trans-unit>
        <trans-unit id="1800b3976c1e687a9ed79d2d3b2072083ebcd591" translate="yes" xml:space="preserve">
          <source>@decorators were added in python 2.4 If you're using python &amp;lt; 2.4 you can use the classmethod() and staticmethod() function.</source>
          <target state="translated">@decorators были добавлены в python 2.4. Если вы используете python &amp;lt;2.4, вы можете использовать функции classmethod () и staticmethod ().</target>
        </trans-unit>
        <trans-unit id="f7625edc6b9228ed3988e14a71b1981c5ed03102" translate="yes" xml:space="preserve">
          <source>@static method:  has nothing to do with the class or instance being associated with ...but for readability can use static method</source>
          <target state="translated">@static метод:не имеет никакого отношения к тому,что класс или экземпляр ассоциируется с ...но для удобочитаемости может использовать статический метод</target>
        </trans-unit>
        <trans-unit id="a7e9e685ffa9bc2ea7a32b2ca97495fffb98da72" translate="yes" xml:space="preserve">
          <source>@staticmethod</source>
          <target state="translated">@staticmethod</target>
        </trans-unit>
        <trans-unit id="316937114375aa711e02d313c11e07624f951988" translate="yes" xml:space="preserve">
          <source>@staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It&amp;rsquo;s definition is immutable via inheritance.</source>
          <target state="translated">Функция @staticmethod - это не что иное, как функция, определенная внутри класса. Он вызывается без создания экземпляра класса первым. Это определение является неизменным через наследование.</target>
        </trans-unit>
        <trans-unit id="07d2b2c31d4856ae66f1901996734386b80a1c1e" translate="yes" xml:space="preserve">
          <source>@staticmethod provides marginal performance gains, but I have yet to see a productive use of a static method within a class that couldn't be achieved as a standalone function outside the class.</source>
          <target state="translated">@staticmethod обеспечивает незначительный прирост производительности,но мне еще предстоит увидеть продуктивное использование статического метода внутри класса,который не может быть достигнут как отдельная функция вне класса.</target>
        </trans-unit>
        <trans-unit id="43b64154609a96d68266675199015630093e6d25" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;classmethod&lt;/strong&gt;, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how &lt;code&gt;dict.fromkeys()&lt;/code&gt;, a classmethod, returns an instance of the subclass when called on a subclass:</source>
          <target state="translated">&lt;strong&gt;Метод класса&lt;/strong&gt; , с другой стороны, - это метод, которому передают класс, к которому он был вызван, или класс экземпляра, к которому он был вызван, в качестве первого аргумента. Это полезно, когда вы хотите, чтобы метод был фабрикой для класса: поскольку он получает фактический класс, для которого он был вызван в качестве первого аргумента, вы всегда можете создать экземпляр нужного класса, даже если задействованы подклассы. Посмотрите, например, как &lt;code&gt;dict.fromkeys()&lt;/code&gt; , метод класса, возвращает экземпляр подкласса при вызове в подклассе:</target>
        </trans-unit>
        <trans-unit id="ea9ca6bfe7447631d34a67f0f001a61c11f0d90e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;staticmethod&lt;/strong&gt; is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument. It is basically useless in Python -- you can just use a module function instead of a staticmethod.</source>
          <target state="translated">&lt;strong&gt;Статический&lt;/strong&gt; метод - это метод, который ничего не знает о классе или экземпляре, к которому он был вызван. Он просто получает переданные аргументы, без первого неявного аргумента. Это в основном бесполезно в Python - вы можете просто использовать функцию модуля вместо статического метода.</target>
        </trans-unit>
        <trans-unit id="fdf2945b9c4df3d30c98cd6d026d7f48f4cc3d83" translate="yes" xml:space="preserve">
          <source>A class method is a similar to an instance method in that it takes an implicit first argument, but instead of taking the instance, it takes the class. Frequently these are used as alternative constructors for better semantic usage and it will support inheritance.</source>
          <target state="translated">Метод класса аналогичен методу экземпляра в том,что он принимает неявный первый аргумент,но вместо того,чтобы взять экземпляр,он берет класс.Часто они используются в качестве альтернативных конструкторов для лучшего семантического использования и будут поддерживать наследование.</target>
        </trans-unit>
        <trans-unit id="7bcf63323ea71d67fbe14ff17405e56e9914d012" translate="yes" xml:space="preserve">
          <source>A class method receives the class as
  implicit first argument, just like an
  instance method receives the instance.
  To declare a class method, use this
  idiom:</source>
          <target state="translated">Метод класса получает класс в качестве неявного первого аргумента,точно так же,как и метод экземпляра получает экземпляр.Чтобы объявить метод класса,используйте эту идиому:</target>
        </trans-unit>
        <trans-unit id="3d92730dcf5e8db0d25f10bd3fd12e7e4523c413" translate="yes" xml:space="preserve">
          <source>A class method receives the class as implicit first argument, just like an instance method receives the instance. It is a method which is bound to the class and not the object of the class.It has access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances.</source>
          <target state="translated">Метод класса получает класс в качестве неявного первого аргумента,точно так же,как и метод экземпляра получает экземпляр.Это метод,который привязан к классу,а не к объекту класса,и имеет доступ к состоянию класса,так как принимает параметр класса,который указывает на класс,а не на экземпляр объекта.Он может изменить состояние класса,которое будет применяться ко всем экземплярам класса.Например,он может изменить переменную класса,которая будет применима ко всем экземплярам.</target>
        </trans-unit>
        <trans-unit id="4f544cf2ef41a072f58086b28f8ecb1cc39d4746" translate="yes" xml:space="preserve">
          <source>A normal method of a class is an implicit &lt;strong&gt;dynamic&lt;/strong&gt; method which takes the instance as first argument.</source>
          <target state="translated">Обычный метод класса - это неявный &lt;strong&gt;динамический&lt;/strong&gt; метод, который принимает экземпляр в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="2b07004d7733b00054b2d72c8854d6ba07c831e3" translate="yes" xml:space="preserve">
          <source>A quick hack-up ofotherwise identical methods in iPython reveals that &lt;code&gt;@staticmethod&lt;/code&gt; yields marginal performance gains (in the nanoseconds), but otherwise it seems to serve no function. Also, any performance gains will probably be wiped out by the additional work of processing the method through &lt;code&gt;staticmethod()&lt;/code&gt; during compilation (which happens prior to any code execution when you run a script).</source>
          <target state="translated">Быстрый взлом других идентичных методов в iPython показывает, что &lt;code&gt;@staticmethod&lt;/code&gt; дает незначительный прирост производительности (в наносекундах), но в остальном он, похоже, не работает. Кроме того, любое повышение производительности, вероятно, будет &lt;code&gt;staticmethod()&lt;/code&gt; дополнительной работой по обработке метода с помощью staticmethod () во время компиляции (что происходит до выполнения любого кода при запуске сценария).</target>
        </trans-unit>
        <trans-unit id="174b86cd307a93d7ede9985e59dfb55608a534c0" translate="yes" xml:space="preserve">
          <source>A static method does not receive an
  implicit first argument. To declare a
  static method, use this idiom:</source>
          <target state="translated">Статический метод не получает неявного первого аргумента.Чтобы объявить статический метод,используйте эту идиому:</target>
        </trans-unit>
        <trans-unit id="d1a64bfff8220829f5366f3b2a593cfff2896ad2" translate="yes" xml:space="preserve">
          <source>A staticmethod is indeed such a normal function the same as those outside a class definition.</source>
          <target state="translated">Статический метод действительно является такой же нормальной функцией,как и те,которые находятся вне определения класса.</target>
        </trans-unit>
        <trans-unit id="d402c4c27f3621c9392d6c31422a842c2a7bd1bf" translate="yes" xml:space="preserve">
          <source>Also observe that this is a good example for using a classmethod and a static method,
The static method clearly belongs to the class, since it uses the class Cluster internally.
The classmethod only needs information about the class, and no instance of the object.</source>
          <target state="translated">Также заметьте,что это хороший пример использования метода класса и статического метода,Статический метод явно принадлежит классу,так как он использует класс Кластер внутренне.Классметоду нужна только информация о классе,и нет экземпляра объекта.</target>
        </trans-unit>
        <trans-unit id="caa569c9ae472a87f325f4b599c69c6baca55fad" translate="yes" xml:space="preserve">
          <source>An example of a static method is &lt;code&gt;str.maketrans&lt;/code&gt;, moved from the &lt;code&gt;string&lt;/code&gt; module in Python 3.  It makes a translation table suitable for consumption by &lt;code&gt;str.translate&lt;/code&gt;. It does seem rather silly when used from an instance of a string, as demonstrated below, but importing the function from the &lt;code&gt;string&lt;/code&gt; module is rather clumsy, and it's nice to be able to call it from the class, as in &lt;code&gt;str.maketrans&lt;/code&gt;</source>
          <target state="translated">Пример статического метода - &lt;code&gt;str.maketrans&lt;/code&gt; , перенесенный из &lt;code&gt;string&lt;/code&gt; модуля в Python 3. Он делает таблицу перевода пригодной для использования &lt;code&gt;str.translate&lt;/code&gt; . Это выглядит довольно глупо при использовании из экземпляра строки, как показано ниже, но импорт функции из &lt;code&gt;string&lt;/code&gt; модуля довольно неуклюжий, и приятно иметь возможность вызывать его из класса, как в &lt;code&gt;str.maketrans&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4016333d9516bf49e82568ddb25694c7dab41ec1" translate="yes" xml:space="preserve">
          <source>Analyze @staticmethod &lt;strong&gt;literally&lt;/strong&gt; providing different insights.</source>
          <target state="translated">Анализируйте @staticmethod &lt;strong&gt;буквально,&lt;/strong&gt; предоставляя различные идеи.</target>
        </trans-unit>
        <trans-unit id="46dc7b6eec81baff58dad68305e781177e5e36b4" translate="yes" xml:space="preserve">
          <source>And later we can use this as a function that already has the first argument bound to it. In this way, it works like a partial function on the instance:</source>
          <target state="translated">А позже мы сможем использовать его как функцию,к которой уже привязан первый аргумент.Таким образом,она работает как частичная функция на экземпляре:</target>
        </trans-unit>
        <trans-unit id="8de9d2abf5cd59c945e75988adc6ab4ac9e4ae20" translate="yes" xml:space="preserve">
          <source>And of course the same thing happens when you call &lt;code&gt;static_foo&lt;/code&gt; with the class &lt;code&gt;A&lt;/code&gt; instead.</source>
          <target state="translated">И, конечно, то же самое происходит, когда вы вызываете &lt;code&gt;static_foo&lt;/code&gt; с классом &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f24da3f406bdcbf3cbb1052ac539ab58118e8b9" translate="yes" xml:space="preserve">
          <source>And you then want to override &lt;code&gt;bar()&lt;/code&gt; in a child class:</source>
          <target state="translated">И затем вы хотите переопределить &lt;code&gt;bar()&lt;/code&gt; в дочернем классе:</target>
        </trans-unit>
        <trans-unit id="1e36acde21e68ba316af8bc3e870c4b88751f9d9" translate="yes" xml:space="preserve">
          <source>Another benefit of making the &lt;code&gt;_is_cluster_for&lt;/code&gt; method a classmethod is so a subclass can decide to change it's implementation, maybe because it is pretty generic and can handle more than one type of cluster, so just checking the name of the class would not be enough.</source>
          <target state="translated">Еще одно преимущество превращения метода &lt;code&gt;_is_cluster_for&lt;/code&gt; в метод класса заключается в том, что подкласс может принять решение об изменении своей реализации, возможно, потому, что он довольно универсален и может обрабатывать более одного типа кластера, поэтому простой проверки имени класса будет недостаточно.</target>
        </trans-unit>
        <trans-unit id="7dab70172b4929776efda7b5da9421027c390a28" translate="yes" xml:space="preserve">
          <source>Another consideration with respect to staticmethod vs classmethod comes up with inheritance.  Say you have the following class:</source>
          <target state="translated">Другое соображение в отношении статического метода в сравнении с одноклассным методом связано с наследованием.Скажем,у вас есть следующий класс:</target>
        </trans-unit>
        <trans-unit id="5e28a0e57c66449c767e62be787a89c79b95f964" translate="yes" xml:space="preserve">
          <source>As a matter of fact, &lt;code&gt;classmethod&lt;/code&gt; has a runtime overhead but makes it possible to access the owning class.  Alternatively I recommend using a metaclass and putting the class methods on that metaclass:</source>
          <target state="translated">На самом деле, &lt;code&gt;classmethod&lt;/code&gt; имеет накладные расходы времени выполнения, но позволяет получить доступ к классу-владельцу. В качестве альтернативы я рекомендую использовать метакласс и поместить методы класса в этот метакласс:</target>
        </trans-unit>
        <trans-unit id="0d849f64698b3cf225429211c021d253be4d70d2" translate="yes" xml:space="preserve">
          <source>Basically &lt;code&gt;@classmethod&lt;/code&gt; makes a method whose first argument is the class it's called from (rather than the class instance), &lt;code&gt;@staticmethod&lt;/code&gt; does not have any implicit arguments.</source>
          <target state="translated">По сути, &lt;code&gt;@classmethod&lt;/code&gt; создает метод, первым аргументом которого является класс, из которого он вызывается (а не экземпляр класса), &lt;code&gt;@staticmethod&lt;/code&gt; не имеет никаких неявных аргументов.</target>
        </trans-unit>
        <trans-unit id="7a9e8fbf97ca31874aa69d63a389a951865d7274" translate="yes" xml:space="preserve">
          <source>Below is the usual way an object instance calls a method. The object instance, &lt;code&gt;a&lt;/code&gt;, is implicitly passed as the first argument.</source>
          <target state="translated">Ниже приведен обычный способ вызова экземпляра объекта методом. Экземпляр объекта &lt;code&gt;a&lt;/code&gt; неявно передается в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="558943de44a405cf7f92076e794bfab4df9297b3" translate="yes" xml:space="preserve">
          <source>Both of them are non-data descriptors (It would be easier to understand them if you are familiar with &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#implementing-descriptors&quot;&gt;descriptors&lt;/a&gt; first).</source>
          <target state="translated">Оба они являются дескрипторами, не относящимися к данным (их было бы легче понять, если вы сначала знакомы с &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#implementing-descriptors&quot;&gt;дескрипторами&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="96cb4b862bfd721769fe8f3891a2750e3f0d62bb" translate="yes" xml:space="preserve">
          <source>Bound methods</source>
          <target state="translated">Связанные методы</target>
        </trans-unit>
        <trans-unit id="485f0584baedc52a76dddcbdc5a384a621979991" translate="yes" xml:space="preserve">
          <source>Can be called through both class and instance.</source>
          <target state="translated">Может вызываться как по классу,так и по экземпляру.</target>
        </trans-unit>
        <trans-unit id="267824910c5cace5b6b1cc20f56a51bf416793ea" translate="yes" xml:space="preserve">
          <source>Class Method</source>
          <target state="translated">классовый метод</target>
        </trans-unit>
        <trans-unit id="96aa2b8b1142697d7bff0fdb46efcf730f9fcac9" translate="yes" xml:space="preserve">
          <source>Class methods are different than C++
  or Java static methods. If you want
  those, see &lt;a href=&quot;http://docs.python.org/2/library/functions.html#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt; in this
  section.</source>
          <target state="translated">Методы класса отличаются от статических методов C ++ или Java. Если вам это нужно, смотрите &lt;a href=&quot;http://docs.python.org/2/library/functions.html#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt; в этом разделе.</target>
        </trans-unit>
        <trans-unit id="80672eaa5ba6013d2c0fa4f9eca5fccf474819ff" translate="yes" xml:space="preserve">
          <source>Class methods, as the name suggests, are used to make changes to classes and not the objects. To make changes to classes, they will modify the class attributes(not object attributes), since that is how you update classes.
This is the reason that class methods take the class(conventionally denoted by 'cls') as the first argument.</source>
          <target state="translated">Методы классов,как следует из названия,используются для внесения изменений в классы,а не в объекты.Для внесения изменений в классы они будут модифицировать атрибуты класса (а не атрибуты объекта),так как именно так происходит обновление классов.Это является причиной того,что методы классов принимают в качестве первого аргумента класс (условно обозначаемый 'cls').</target>
        </trans-unit>
        <trans-unit id="b35b086653d69dfdfe1042ce78c4bcdb48c3d279" translate="yes" xml:space="preserve">
          <source>Difference between staticmethod and classmethod</source>
          <target state="translated">Различие между статическим методом и одноклассным методом</target>
        </trans-unit>
        <trans-unit id="164607916d6ea823ef7c78eb0833afe38bf3630f" translate="yes" xml:space="preserve">
          <source>First I'll explain &lt;code&gt;a_normal_instance_method&lt;/code&gt;. This is precisely called an &quot;&lt;strong&gt;instance method&lt;/strong&gt;&quot;. When an instance method is used, it is used as a partial function (as opposed to a total function, defined for all values when viewed in source code) that is, when used, the first of the arguments is predefined as the instance of the object, with all of its given attributes. It has the instance of the object bound to it, and it must be called from an instance of the object. Typically, it will access various attributes of the instance.</source>
          <target state="translated">Сначала я объясню &lt;code&gt;a_normal_instance_method&lt;/code&gt; . Это точно называется &amp;laquo; &lt;strong&gt;метод экземпляра&lt;/strong&gt; &amp;raquo;. Когда используется метод экземпляра, он используется как частичная функция (в отличие от функции total, определенной для всех значений при просмотре в исходном коде), то есть при использовании первый из аргументов предопределен как экземпляр объект со всеми заданными атрибутами. Он имеет экземпляр объекта, связанный с ним, и его необходимо вызывать из экземпляра объекта. Как правило, он будет обращаться к различным атрибутам экземпляра.</target>
        </trans-unit>
        <trans-unit id="0f7fb90238ae76c6afb80f76159dd7556d88d38f" translate="yes" xml:space="preserve">
          <source>For example, if you want to create a factory method (A function returning an instance of a different implementation of a class depending on what argument it gets) you can do something like:</source>
          <target state="translated">Например,если вы хотите создать заводской метод (функция,возвращающая экземпляр другой реализации класса в зависимости от того,какой аргумент она получает),вы можете сделать что-то вроде:</target>
        </trans-unit>
        <trans-unit id="06ec4552ced78aea82f7ba25beef8c69e6f4a32a" translate="yes" xml:space="preserve">
          <source>For example, this binds the &lt;code&gt;str.join&lt;/code&gt; method to the &lt;code&gt;':'&lt;/code&gt; instance:</source>
          <target state="translated">Например, это связывает метод &lt;code&gt;str.join&lt;/code&gt; с экземпляром &lt;code&gt;':'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e14341dc4aa4a22660bb62e64b2a9ec3f3217718" translate="yes" xml:space="preserve">
          <source>For example, this is an instance of a string:</source>
          <target state="translated">Например,это экземпляр строки:</target>
        </trans-unit>
        <trans-unit id="90faa00926d9e27636891da919e5733d1122d8b2" translate="yes" xml:space="preserve">
          <source>For the sake of code readability I'd avoid &lt;code&gt;@staticmethod&lt;/code&gt; unless your method will be used for loads of work, where the nanoseconds count.</source>
          <target state="translated">Ради читабельности кода я бы избегал &lt;code&gt;@staticmethod&lt;/code&gt; , если только ваш метод не будет использоваться для больших нагрузок, где подсчитываются наносекунды.</target>
        </trans-unit>
        <trans-unit id="9a2b129313b892462b40ddd6c79d0af830dea9c8" translate="yes" xml:space="preserve">
          <source>Functions that have first argument as classname.</source>
          <target state="translated">Функции,которые имеют первый аргумент как classname.</target>
        </trans-unit>
        <trans-unit id="807d50dce55b514a4fba42b13f8002d515f8a71b" translate="yes" xml:space="preserve">
          <source>Gives: &lt;code&gt;In Foo2 MAGIC&lt;/code&gt;</source>
          <target state="translated">Дает: &lt;code&gt;In Foo2 MAGIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2860e65bbc0758e8d4d475d85f1680dabe52e6a1" translate="yes" xml:space="preserve">
          <source>Here, with a staticmethod, even though it is a method, &lt;code&gt;a.static_foo&lt;/code&gt; just returns
a good 'ole function with no arguments bound. &lt;code&gt;static_foo&lt;/code&gt; expects 1 argument, and
&lt;code&gt;a.static_foo&lt;/code&gt; expects 1 argument too.</source>
          <target state="translated">Здесь со статическим методом, даже если это метод, &lt;code&gt;a.static_foo&lt;/code&gt; просто возвращает хорошую функцию, без привязки аргументов. &lt;code&gt;static_foo&lt;/code&gt; ожидает 1 аргумент, &lt;code&gt;a.static_foo&lt;/code&gt; также ожидает 1 аргумент.</target>
        </trans-unit>
        <trans-unit id="ce0274e0663be4ad665ddb61fc313fc1346d7b03" translate="yes" xml:space="preserve">
          <source>Hope I was clear !</source>
          <target state="translated">Надеюсь,я ясно выразился!</target>
        </trans-unit>
        <trans-unit id="536783112e18b97571f614392a4dc28b80515954" translate="yes" xml:space="preserve">
          <source>However, a module level function must live in the module and be specially imported to other places where it is used.</source>
          <target state="translated">Тем не менее,функция уровня модуля должна жить в модуле и быть специально импортирована в другие места,где она используется.</target>
        </trans-unit>
        <trans-unit id="8f6343acac6bb042a0e1759058bfdad64fdb5e56" translate="yes" xml:space="preserve">
          <source>However, you could achieve the same thing using &lt;code&gt;@classmethod&lt;/code&gt; as mentioned below</source>
          <target state="translated">Тем не менее, вы можете добиться того же, используя &lt;code&gt;@classmethod&lt;/code&gt; , как указано ниже</target>
        </trans-unit>
        <trans-unit id="fe663cfec4745cf0ea4c84d7a734da467f0e2ce4" translate="yes" xml:space="preserve">
          <source>I started learning programming language with C++ and then Java and then Python and so this question bothered me a lot as well, until I understood the simple usage of each.</source>
          <target state="translated">Я начал учить язык программирования с C++,затем Java,затем Python,и этот вопрос меня тоже очень беспокоил,пока я не понял простоту использования каждого из них.</target>
        </trans-unit>
        <trans-unit id="5ab2de0b5f9aebcc8092bd625d4e80db8214b56e" translate="yes" xml:space="preserve">
          <source>I think a better question is &quot;When would you use @classmethod vs @staticmethod?&quot;</source>
          <target state="translated">Думаю,лучший вопрос-&quot;Когда бы вы использовали @classmethod против @staticmethod?&quot;.</target>
        </trans-unit>
        <trans-unit id="e03cea799789ab3a8ab2445c8c76ff25537711d7" translate="yes" xml:space="preserve">
          <source>I think giving a purely Python version of &lt;code&gt;staticmethod&lt;/code&gt; and &lt;code&gt;classmethod&lt;/code&gt; would help to understand the difference between them at language level.</source>
          <target state="translated">Я думаю, что предоставление чисто Python-версии &lt;code&gt;staticmethod&lt;/code&gt; и &lt;code&gt;classmethod&lt;/code&gt; поможет понять разницу между ними на уровне языка.</target>
        </trans-unit>
        <trans-unit id="69a1c0771c12086dd4b452a55dc59cc30ff19aca" translate="yes" xml:space="preserve">
          <source>I will try to explain the basic difference using an example.</source>
          <target state="translated">Я постараюсь объяснить основную разницу на примере.</target>
        </trans-unit>
        <trans-unit id="1bf6e736cb87adbab8ee43c998f8352378eb5f99" translate="yes" xml:space="preserve">
          <source>If it is attached to the object, however, it will follow the object conveniently through importing and inheritance as well.</source>
          <target state="translated">Если же он прикреплен к объекту,то он будет удобно следовать за объектом через импорт и наследование.</target>
        </trans-unit>
        <trans-unit id="b6064776a38f8588bf3204f57e4defc4d6b48090" translate="yes" xml:space="preserve">
          <source>In contrast, a staticmethod does not take the instance as first argument, so is called &lt;strong&gt;'static'&lt;/strong&gt;.</source>
          <target state="translated">Напротив, метод static не принимает экземпляр в качестве первого аргумента, поэтому он называется &lt;strong&gt;&amp;laquo;статическим&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="418e1f592595199710930f400b12c6648ac41d0d" translate="yes" xml:space="preserve">
          <source>In more detail...</source>
          <target state="translated">Более подробно...</target>
        </trans-unit>
        <trans-unit id="ce1dc58e2832295d9371005f7e0507920675bea9" translate="yes" xml:space="preserve">
          <source>In python 2, you have to import this function from the increasingly less useful string module:</source>
          <target state="translated">В питоне 2 эту функцию приходится импортировать из все менее полезного строкового модуля:</target>
        </trans-unit>
        <trans-unit id="f6b415ed12f65f9bbf40b9142a369fba8072e05c" translate="yes" xml:space="preserve">
          <source>Instance methods can be bound via a dotted lookup for use later.</source>
          <target state="translated">Экземплярские методы могут быть привязаны с помощью точечного поиска для использования в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="fe77d4b7f35bb53ca43fe505597fa8fc7799f6f4" translate="yes" xml:space="preserve">
          <source>It can be called either on the class
  (such as &lt;code&gt;C.f()&lt;/code&gt;) or on an instance
  (such as &lt;code&gt;C().f()&lt;/code&gt;). The instance is
  ignored except for its class.</source>
          <target state="translated">Его можно вызывать либо в классе (например, &lt;code&gt;C.f()&lt;/code&gt; ), либо в экземпляре (например, &lt;code&gt;C().f()&lt;/code&gt; ). Экземпляр игнорируется за исключением его класса.</target>
        </trans-unit>
        <trans-unit id="c2c132e491d3b48b18fe928903a3b9627a4b7db6" translate="yes" xml:space="preserve">
          <source>It can be called either on the class
  (such as &lt;code&gt;C.f()&lt;/code&gt;) or on an instance
  (such as &lt;code&gt;C().f()&lt;/code&gt;). The instance is
  ignored except for its class. If a
  class method is called for a derived
  class, the derived class object is
  passed as the implied first argument.</source>
          <target state="translated">Его можно вызывать либо в классе (например, &lt;code&gt;C.f()&lt;/code&gt; ), либо в экземпляре (например, &lt;code&gt;C().f()&lt;/code&gt; ). Экземпляр игнорируется за исключением его класса. Если метод класса вызывается для производного класса, объект производного класса передается как подразумеваемый первый аргумент.</target>
        </trans-unit>
        <trans-unit id="bab5a5442633b80e598ccbf398e186dbd8ee95fb" translate="yes" xml:space="preserve">
          <source>It eases the readability of the code, and it does not depend on the state of object itself;</source>
          <target state="translated">Это облегчает чтение кода и не зависит от состояния самого объекта;</target>
        </trans-unit>
        <trans-unit id="939616480d0a5694951a8e24ef3733c4dcbedd3d" translate="yes" xml:space="preserve">
          <source>It is luckily grouped into the class just in order to stand closer where it is applied, or you might scroll around to find it.</source>
          <target state="translated">Он,к счастью,сгруппирован в классе только для того,чтобы стоять ближе к тому месту,где он применяется,или вы можете прокрутить вокруг,чтобы найти его.</target>
        </trans-unit>
        <trans-unit id="230b0bc30ac33392bc5367bb425ea96b284d2e75" translate="yes" xml:space="preserve">
          <source>It is very similar to a module level function.</source>
          <target state="translated">Это очень похоже на функцию модульного уровня.</target>
        </trans-unit>
        <trans-unit id="bdaab6a3bf7746bf4181f9f1669e8524b277ed65" translate="yes" xml:space="preserve">
          <source>It localizes the function name in the classscope</source>
          <target state="translated">Локализует имя функции в классе.</target>
        </trans-unit>
        <trans-unit id="f21f6aa25b5c058c5e292d885804e6cf2b2ef443" translate="yes" xml:space="preserve">
          <source>It moves the function code closer to where it is used</source>
          <target state="translated">Он перемещает код функции ближе к тому месту,где она используется.</target>
        </trans-unit>
        <trans-unit id="faebdc4b4a231fbaedbee2f66d2684f878485f0d" translate="yes" xml:space="preserve">
          <source>Let me tell the similarity between a method decorated with @classmethod vs @staticmethod first.</source>
          <target state="translated">Расскажу сначала о сходстве метода,украшенного @classmethod и @staticmethod.</target>
        </trans-unit>
        <trans-unit id="2b2aa4f3e36c9530575f19c9f0598e540f26891d" translate="yes" xml:space="preserve">
          <source>Let's consider we have a &lt;code&gt;Person&lt;/code&gt; class which takes two arguments &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt; and creates the instance of &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">Давайте рассмотрим, у нас есть класс &lt;code&gt;Person&lt;/code&gt; , который принимает два аргумента &lt;code&gt;first_name&lt;/code&gt; и &lt;code&gt;last_name&lt;/code&gt; и создает экземпляр &lt;code&gt;Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b10a40e3f747fcf229fa77c0fa98a6c253c3a2" translate="yes" xml:space="preserve">
          <source>Maybe a bit of example code will help: Notice the difference in the call signatures of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;class_foo&lt;/code&gt; and &lt;code&gt;static_foo&lt;/code&gt;:</source>
          <target state="translated">Может быть, пример кода поможет: обратите внимание на разницу в сигнатурах вызовов &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;class_foo&lt;/code&gt; и &lt;code&gt;static_foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7122abd306cee02d99048842c405d1b59faf3176" translate="yes" xml:space="preserve">
          <source>More convenient to import versus module-level functions since each method does not have to be specially imported</source>
          <target state="translated">Удобнее импортировать по сравнению с функциями модульного уровня,так как нет необходимости специально импортировать каждый метод.</target>
        </trans-unit>
        <trans-unit id="baee456d57820da13b11bc2426c66fd95bd49685" translate="yes" xml:space="preserve">
          <source>My contribution demonstrates the difference amongst &lt;code&gt;@classmethod&lt;/code&gt;, &lt;code&gt;@staticmethod&lt;/code&gt;, and instance methods, including how an instance can indirectly call a &lt;code&gt;@staticmethod&lt;/code&gt;. But instead of indirectly calling a &lt;code&gt;@staticmethod&lt;/code&gt; from an instance, making it private may be more &quot;pythonic.&quot; Getting something from a private method isn't demonstrated here but it's basically the same concept.</source>
          <target state="translated">Мой вклад демонстрирует разницу между &lt;code&gt;@classmethod&lt;/code&gt; , &lt;code&gt;@staticmethod&lt;/code&gt; и методами экземпляра, в том числе в том, как экземпляр может косвенно вызывать &lt;code&gt;@staticmethod&lt;/code&gt; . Но вместо косвенного вызова &lt;code&gt;@staticmethod&lt;/code&gt; из экземпляра, сделать его частным может быть более &amp;laquo;питонным&amp;raquo;. Получение чего-то из закрытого метода здесь не демонстрируется, но в основном это та же концепция.</target>
        </trans-unit>
        <trans-unit id="06bdb3d7b2f194e09ab0a51f0107d3fa31a0f2c6" translate="yes" xml:space="preserve">
          <source>Now, if the requirement comes where you need to create a class using a single name only, just a &lt;code&gt;first_name&lt;/code&gt;, you &lt;strong&gt;can't&lt;/strong&gt; do something like this in Python.</source>
          <target state="translated">Теперь, если требование возникает там, где вам нужно создать класс, используя только одно имя, просто &lt;code&gt;first_name&lt;/code&gt; , вы &lt;strong&gt;не можете&lt;/strong&gt; сделать что-то подобное в Python.</target>
        </trans-unit>
        <trans-unit id="c446d44cb0d9ce8db33e3b393ea1f71b690bad22" translate="yes" xml:space="preserve">
          <source>On the other hand, a static method does not receive an implicit first argument, compared to class methods or instance methods. And can&amp;rsquo;t access or modify class state. It only belongs to the class because from design point of view that is the correct way. But in terms of functionality is not bound, at runtime, to the class.</source>
          <target state="translated">С другой стороны, статический метод не получает неявный первый аргумент по сравнению с методами класса или методами экземпляра. И не может получить доступ или изменить состояние класса. Он принадлежит только классу, потому что с точки зрения дизайна это правильный путь. Но с точки зрения функциональности не связан, во время выполнения, с классом.</target>
        </trans-unit>
        <trans-unit id="0601259c1a596a32a613d81d7b9416a72f1706e5" translate="yes" xml:space="preserve">
          <source>One use people have found for class methods is to create &lt;a href=&quot;https://stackoverflow.com/a/1950927/190597&quot;&gt;inheritable alternative constructors&lt;/a&gt;.</source>
          <target state="translated">Одно из применений, которые люди нашли для методов класса, - это создание &lt;a href=&quot;https://stackoverflow.com/a/1950927/190597&quot;&gt;наследуемых альтернативных конструкторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e6e99fe2ce49b8e8aed43869178d41b3d185e3f" translate="yes" xml:space="preserve">
          <source>Python does not have to instantiate a bound-method for object.</source>
          <target state="translated">Python не должен инстанцировать граничный метод для объекта.</target>
        </trans-unit>
        <trans-unit id="f24b1de7ff195e42428cd5db28a36a5b118842b9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/pydata/pandas/blob/master/pandas/core/frame.py&quot;&gt;pandas source code&lt;/a&gt; for other similar examples of alternative constructors, and see also the official Python documentation on &lt;a href=&quot;https://docs.python.org/library/functions.html#classmethod&quot;&gt;&lt;code&gt;classmethod&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/library/functions.html#staticmethod&quot;&gt;&lt;code&gt;staticmethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Посмотрите &lt;a href=&quot;https://github.com/pydata/pandas/blob/master/pandas/core/frame.py&quot;&gt;исходный код&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/library/functions.html#classmethod&quot;&gt; &lt;code&gt;classmethod&lt;/code&gt; &lt;/a&gt; для других подобных примеров альтернативных конструкторов, а также посмотрите официальную документацию Python по методам classmethod и &lt;a href=&quot;https://docs.python.org/library/functions.html#staticmethod&quot;&gt; &lt;code&gt;staticmethod&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f01d0a8ab6576c208384ec02c477895fb03fdd00" translate="yes" xml:space="preserve">
          <source>Simple functions with no self argument.</source>
          <target state="translated">Простые функции без аргументов.</target>
        </trans-unit>
        <trans-unit id="94dd432a314d7dfb9142b28cff141918df0ee440" translate="yes" xml:space="preserve">
          <source>So a static method is, in a sense, not bound to the Class itself and is just hanging in there just because it may have a related functionality.</source>
          <target state="translated">Так что статический метод в некотором смысле не привязан к самому классу и держится только потому,что у него может быть связанная с ним функциональность.</target>
        </trans-unit>
        <trans-unit id="65363de032aba81ff598ab4d63be7b2e577f8cb9" translate="yes" xml:space="preserve">
          <source>So let's say in above example you need a validation that &lt;code&gt;first_name&lt;/code&gt; should not exceed 20 characters, you can simply do this.</source>
          <target state="translated">Итак, скажем, в приведенном выше примере вам нужна проверка, что &lt;code&gt;first_name&lt;/code&gt; не должно превышать 20 символов, вы можете просто сделать это.</target>
        </trans-unit>
        <trans-unit id="182c8c616107a2457bad4250829c2d737ac45ed3" translate="yes" xml:space="preserve">
          <source>So using  &lt;code&gt;@staticmethod&lt;/code&gt; for methods only called directly from the class has become optional in python3. If you want to call them from both class and instance, you still need to use the &lt;code&gt;@staticmethod&lt;/code&gt; decorator.</source>
          <target state="translated">Поэтому использование &lt;code&gt;@staticmethod&lt;/code&gt; для методов, вызываемых только из класса, стало необязательным в python3. Если вы хотите вызывать их как из класса, так и из экземпляра, вам все равно нужно использовать декоратор &lt;code&gt;@staticmethod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7b56ba099663ac3dac80d5ad3bbee9b28e3d48" translate="yes" xml:space="preserve">
          <source>Static Method</source>
          <target state="translated">Статический метод</target>
        </trans-unit>
        <trans-unit id="f4eea620f6c60864e8c46d16abb4c687e8c6331d" translate="yes" xml:space="preserve">
          <source>Static methods in Python are similar
  to those found in Java or C++. For a
  more advanced concept, see
  &lt;a href=&quot;http://docs.python.org/2/library/functions.html#classmethod&quot;&gt;&lt;code&gt;classmethod()&lt;/code&gt;&lt;/a&gt; in this section.</source>
          <target state="translated">Статические методы в Python похожи на те, которые есть в Java или C ++. Для более продвинутой концепции см. &lt;a href=&quot;http://docs.python.org/2/library/functions.html#classmethod&quot;&gt; &lt;code&gt;classmethod()&lt;/code&gt; &lt;/a&gt; в этом разделе.</target>
        </trans-unit>
        <trans-unit id="e562c390a784edf0b3feb04ea00ba8e2392d8d34" translate="yes" xml:space="preserve">
          <source>Static methods on the other hand, are used to perform functionalities that are not bound to the class i.e. they will not read or write class variables. Hence, static methods do not take classes as arguments. They are used so that classes can perform functionalities that are not directly related to the purpose of the class.</source>
          <target state="translated">Статические методы,с другой стороны,используются для выполнения функций,которые не привязаны к классу,т.е.они не будут читать или записывать переменные класса.Следовательно,статические методы не принимают классы в качестве аргументов.Они используются для того,чтобы классы могли выполнять функции,не связанные напрямую с назначением класса.</target>
        </trans-unit>
        <trans-unit id="5ffe8a646ab05acaf25f6688924681394d7f4b50" translate="yes" xml:space="preserve">
          <source>Staticmethods are used to group functions which have some logical connection with a class to the class.</source>
          <target state="translated">Статические методы используются для группировки функций,которые имеют определенную логическую связь с классом к классу.</target>
        </trans-unit>
        <trans-unit id="ce6f2467322be66f2c66550f026cdbdd30261e17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@classmethod&lt;/code&gt; form is a function
  &lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;decorator&lt;/em&gt;&lt;/a&gt; &amp;ndash; see the description of
  function definitions in &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;Function
  definitions&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Форма &lt;code&gt;@classmethod&lt;/code&gt; является &lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;декоратором&lt;/em&gt;&lt;/a&gt; функции - подробности см. В описании определений функций в определениях &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;функций&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9055ab2b4172076d48e20f45dc0229a7e5605442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@staticmethod&lt;/code&gt; form is a function
  &lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;decorator&lt;/em&gt;&lt;/a&gt; &amp;ndash; see the description of
  function definitions in &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;Function
  definitions&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Форма &lt;code&gt;@staticmethod&lt;/code&gt; является &lt;a href=&quot;http://docs.python.org/2/glossary.html#term-decorator&quot;&gt;&lt;em&gt;декоратором&lt;/em&gt;&lt;/a&gt; функции - подробности см. В описании определений функций в определениях &lt;a href=&quot;http://docs.python.org/2/reference/compound_stmts.html#function&quot;&gt;&lt;em&gt;функций&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f0986b5efbab0453d76f7f6ca9ae170f03a69d9" translate="yes" xml:space="preserve">
          <source>The Normal Instance Method</source>
          <target state="translated">Нормальный метод</target>
        </trans-unit>
        <trans-unit id="bd04489a697867005e789fddc84ebc4dd500b1ba" translate="yes" xml:space="preserve">
          <source>The built-in function staticmethod()is used to create them.</source>
          <target state="translated">Для их создания используется встроенная функция staticmethod().</target>
        </trans-unit>
        <trans-unit id="6421f9367c3ff555773546cfcde71ec15b8c1b25" translate="yes" xml:space="preserve">
          <source>The most canonical example of a builtin classmethod is &lt;code&gt;dict.fromkeys&lt;/code&gt;. It is used as an alternative constructor of dict, (well suited for when you know what your keys are and want a default value for them.)</source>
          <target state="translated">Наиболее каноническим примером встроенного метода класса является &lt;code&gt;dict.fromkeys&lt;/code&gt; . Он используется в качестве альтернативного конструктора dict (хорошо подходит для случаев, когда вы знаете, какие у вас ключи, и хотите для них значение по умолчанию.)</target>
        </trans-unit>
        <trans-unit id="5944b31af7aa8a97f6f73cdc54e88234802fe3f1" translate="yes" xml:space="preserve">
          <source>The other cases have been well covered by unutbus answer.</source>
          <target state="translated">Остальные случаи были хорошо освещены ответом &quot;неавтобуса&quot;.</target>
        </trans-unit>
        <trans-unit id="d9dcfa9ec5bb063d28e1a65b69d5c1996c83cf8c" translate="yes" xml:space="preserve">
          <source>The static method does &lt;em&gt;not&lt;/em&gt; take the instance as an argument.</source>
          <target state="translated">Статический метод &lt;em&gt;не&lt;/em&gt; принимает экземпляр в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="af7cb13e62642ee499a113906d710325fb97372a" translate="yes" xml:space="preserve">
          <source>The workaround here would be to call &lt;code&gt;Foo2.magic()&lt;/code&gt; in &lt;code&gt;bar()&lt;/code&gt;, but then you're repeating yourself (if the name of &lt;code&gt;Foo2&lt;/code&gt; changes, you'll have to remember to update that &lt;code&gt;bar()&lt;/code&gt; method).</source>
          <target state="translated">Обходной путь здесь должен был бы вызвать &lt;code&gt;Foo2.magic()&lt;/code&gt; в &lt;code&gt;bar()&lt;/code&gt; , но затем вы повторяете себя (если имя &lt;code&gt;Foo2&lt;/code&gt; изменится, вы должны будете не забыть обновить этот метод &lt;code&gt;bar()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d75be3892212a0b3d72aa89d5805947b4703d4c3" translate="yes" xml:space="preserve">
          <source>These are created with classmethod in-built function.</source>
          <target state="translated">Они создаются со встроенной функцией метода одноклассников.</target>
        </trans-unit>
        <trans-unit id="f15cd3ae0b92af773354fba252df6a2f9c169e4b" translate="yes" xml:space="preserve">
          <source>Think we have a class with &lt;code&gt;b=2&lt;/code&gt;, we will create an object and re-set this to &lt;code&gt;b=4&lt;/code&gt; in it.
Staticmethod cannot access nothing from previous.
Classmethod can access &lt;code&gt;.b==2&lt;/code&gt; only, via &lt;code&gt;cls.b&lt;/code&gt;.
Normal method can access both: &lt;code&gt;.b==4&lt;/code&gt; via &lt;code&gt;self.b&lt;/code&gt; and &lt;code&gt;.b==2&lt;/code&gt; via &lt;code&gt;self.__class__.b&lt;/code&gt;.</source>
          <target state="translated">Представьте, что у нас есть класс с &lt;code&gt;b=2&lt;/code&gt; , мы создадим объект и заново установим в нем значение &lt;code&gt;b=4&lt;/code&gt; . Статический метод не может получить доступ ни к чему из предыдущего. Classmethod может получить доступ &lt;code&gt;.b==2&lt;/code&gt; к .b == 2 через &lt;code&gt;cls.b&lt;/code&gt; . Обычный метод может обращаться к обоим: &lt;code&gt;.b==4&lt;/code&gt; через &lt;code&gt;self.b&lt;/code&gt; и &lt;code&gt;.b==2&lt;/code&gt; через &lt;code&gt;self.__class__.b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80280e49a1f8353c5b3bba30201343e829087168" translate="yes" xml:space="preserve">
          <source>This has changed between python2 and python3:</source>
          <target state="translated">Это изменилось между питоном2 и питоном3:</target>
        </trans-unit>
        <trans-unit id="258f0cf75229fbcab6f2fd1285ff5938bf4aeca7" translate="yes" xml:space="preserve">
          <source>This will give you an error when you will try to create an object (instance).</source>
          <target state="translated">Это приведет к ошибке,когда вы попытаетесь создать объект (экземпляр).</target>
        </trans-unit>
        <trans-unit id="4adbdfc052a06d13f49928019797c091206b0882" translate="yes" xml:space="preserve">
          <source>This works, but note that now the &lt;code&gt;bar()&lt;/code&gt; implementation in the child class (&lt;code&gt;Foo2&lt;/code&gt;) can no longer take advantage of anything specific to that class.  For example, say &lt;code&gt;Foo2&lt;/code&gt; had a method called &lt;code&gt;magic()&lt;/code&gt; that you want to use in the &lt;code&gt;Foo2&lt;/code&gt; implementation of &lt;code&gt;bar()&lt;/code&gt;:</source>
          <target state="translated">Это работает, но обратите внимание, что теперь реализация &lt;code&gt;bar()&lt;/code&gt; в дочернем классе ( &lt;code&gt;Foo2&lt;/code&gt; ) больше не может использовать в своих интересах что-то специфическое для этого класса. Например, скажем, в &lt;code&gt;Foo2&lt;/code&gt; есть метод &lt;code&gt;magic()&lt;/code&gt; который вы хотите использовать в реализации &lt;code&gt;bar()&lt;/code&gt; в &lt;code&gt;Foo2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79477ed5dad94d6833e83e3a8699a0463de9de85" translate="yes" xml:space="preserve">
          <source>To decide whether to use &lt;a href=&quot;https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod&quot;&gt;@staticmethod&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.5/library/functions.html?highlight=classmethod#classmethod&quot;&gt;@classmethod&lt;/a&gt; you have to look inside your method. &lt;strong&gt;If your method accesses other variables/methods in your class then use @classmethod&lt;/strong&gt;. On the other hand, if your method does not touches any other parts of the class then use @staticmethod.</source>
          <target state="translated">Чтобы решить, использовать ли &lt;a href=&quot;https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod&quot;&gt;@staticmethod&lt;/a&gt; или &lt;a href=&quot;https://docs.python.org/3.5/library/functions.html?highlight=classmethod#classmethod&quot;&gt;@classmethod,&lt;/a&gt; вы должны заглянуть внутрь своего метода. &lt;strong&gt;Если ваш метод обращается к другим переменным / методам в вашем классе, тогда используйте @classmethod&lt;/strong&gt; . С другой стороны, если ваш метод не касается других частей класса, используйте @staticmethod.</target>
        </trans-unit>
        <trans-unit id="41c4939ed15126e325624c1d7f0ae8e61154e275" translate="yes" xml:space="preserve">
          <source>To me, this is a slight violation of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;open/closed principle&lt;/a&gt;, since a decision made in &lt;code&gt;Foo&lt;/code&gt; is impacting your ability to refactor common code in a derived class (ie it's less open to extension).  If &lt;code&gt;bar()&lt;/code&gt; were a &lt;code&gt;classmethod&lt;/code&gt; we'd be fine:</source>
          <target state="translated">Для меня это небольшое нарушение &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;принципа открытого / закрытого&lt;/a&gt; , поскольку решение, принятое в &lt;code&gt;Foo&lt;/code&gt; , влияет на вашу способность реорганизовывать общий код в производном классе (то есть он менее открыт для расширения). Если бы &lt;code&gt;bar()&lt;/code&gt; был &lt;code&gt;classmethod&lt;/code&gt; мы были бы в порядке:</target>
        </trans-unit>
        <trans-unit id="8a5223e4291f77ecc334b5a5bbcbdaa187282c18" translate="yes" xml:space="preserve">
          <source>We could follow the KISS style (keep it simple, stupid): Don't use staticmethods and classmethods, don't use classes without instantiating them, access only the object's attributes &lt;code&gt;self.attribute(s)&lt;/code&gt;. There are languages where the OOP is implemented that way and I think it is not bad idea. :)</source>
          <target state="translated">Мы могли бы следовать стилю KISS (пусть это будет просто, глупо): не используйте статические методы и методы классов, не используйте классы без их создания, &lt;code&gt;self.attribute(s)&lt;/code&gt; только к атрибутам объекта self.attribute (s) . Есть языки, в которых ООП реализован таким образом, и я думаю, что это неплохая идея. :)</target>
        </trans-unit>
        <trans-unit id="fcbb519e378d850b1b68ca11bf02470e1595d064" translate="yes" xml:space="preserve">
          <source>What is the difference between @staticmethod and @classmethod in Python?</source>
          <target state="translated">В чем разница между @статистическим методом и @классметодом на Питоне?</target>
        </trans-unit>
        <trans-unit id="eb4e5926c4dc5d5f3bc9f05359bd22b70d529258" translate="yes" xml:space="preserve">
          <source>What is the difference between a function decorated with &lt;a href=&quot;http://docs.python.org/library/functions.html#staticmethod&quot;&gt;&lt;code&gt;@staticmethod&lt;/code&gt;&lt;/a&gt; and one decorated with &lt;a href=&quot;http://docs.python.org/library/functions.html#classmethod&quot;&gt;&lt;code&gt;@classmethod&lt;/code&gt;&lt;/a&gt;?</source>
          <target state="translated">В чем разница между функцией, украшенной &lt;a href=&quot;http://docs.python.org/library/functions.html#staticmethod&quot;&gt; &lt;code&gt;@staticmethod&lt;/code&gt; ,&lt;/a&gt; и функцией, украшенной &lt;a href=&quot;http://docs.python.org/library/functions.html#classmethod&quot;&gt; &lt;code&gt;@classmethod&lt;/code&gt; &lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="2e5c6569bb706d28e402587b1466ff95d88243e1" translate="yes" xml:space="preserve">
          <source>When an object's method is called, it is automatically given an extra argument &lt;code&gt;self&lt;/code&gt; as its first argument. That is, method</source>
          <target state="translated">Когда вызывается метод объекта, ему автоматически присваивается дополнительный аргумент &lt;code&gt;self&lt;/code&gt; в качестве первого аргумента. То есть метод</target>
        </trans-unit>
        <trans-unit id="829e8b693aed55e8328e8d5d8439f95ac3af86b9" translate="yes" xml:space="preserve">
          <source>When the method is decorated</source>
          <target state="translated">Когда метод будет украшен</target>
        </trans-unit>
        <trans-unit id="341319811e49792c2c672aa7a5e85c27a7f50380" translate="yes" xml:space="preserve">
          <source>When we subclass dict, we can use the same constructor, which creates an instance of the subclass.</source>
          <target state="translated">Когда мы диктуем подкласс,мы можем использовать тот же конструктор,который создает экземпляр подкласса.</target>
        </trans-unit>
        <trans-unit id="68ae0e89977a649bad665ad27c89cbedc3a29ee1" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;a.class_foo&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is not bound to &lt;code&gt;class_foo&lt;/code&gt;, rather the class &lt;code&gt;A&lt;/code&gt; is bound to &lt;code&gt;class_foo&lt;/code&gt;.</source>
          <target state="translated">С &lt;code&gt;a.class_foo&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; не связан с &lt;code&gt;class_foo&lt;/code&gt; , скорее класс &lt;code&gt;A&lt;/code&gt; связан с &lt;code&gt;class_foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e91195e59505ea892019be8785a88af1bd3c3f6f" translate="yes" xml:space="preserve">
          <source>Work on class attributes; not on instance attributes.</source>
          <target state="translated">Работать с атрибутами класса,а не с атрибутами экземпляра.</target>
        </trans-unit>
        <trans-unit id="adebd78a8dd903e227a396616541192276725be4" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;class_foo&lt;/code&gt; using the class. In fact, if you define something to be
a classmethod, it is probably because you intend to call it from the class rather than from a class instance. &lt;code&gt;A.foo(1)&lt;/code&gt; would have raised a TypeError, but &lt;code&gt;A.class_foo(1)&lt;/code&gt; works just fine:</source>
          <target state="translated">Вы также можете вызвать &lt;code&gt;class_foo&lt;/code&gt; используя класс. На самом деле, если вы определяете что-то как метод класса, это, вероятно, потому, что вы намереваетесь вызывать это из класса, а не из экземпляра класса. &lt;code&gt;A.foo(1)&lt;/code&gt; вызовет &lt;code&gt;A.class_foo(1)&lt;/code&gt; , но A.class_foo (1) работает просто отлично:</target>
        </trans-unit>
        <trans-unit id="3ffe0412197d5a8f4286d21ec5576d1cbd38ecf0" translate="yes" xml:space="preserve">
          <source>You may have seen Python code like this pseudocode, which demonstrates the signatures of the various method types and provides a docstring to explain each:</source>
          <target state="translated">Возможно,вы видели код Python,подобный этому псевдокоду,который демонстрирует сигнатуры различных типов методов и предоставляет доктрину,объясняющую каждый из них:</target>
        </trans-unit>
        <trans-unit id="aa25ff3c9b231e9b99c6cece2313f1a161111d45" translate="yes" xml:space="preserve">
          <source>You might want to consider the difference between:</source>
          <target state="translated">Возможно,вы захотите рассмотреть разницу между ними:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9d508031d4e84b7cc27af600bec98b3141da798e" translate="yes" xml:space="preserve">
          <source>and you could simply call using &lt;code&gt;class name&lt;/code&gt;</source>
          <target state="translated">и вы можете просто позвонить, используя &lt;code&gt;class name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d49b88615309e95621c35de40da5fe92499b533d" translate="yes" xml:space="preserve">
          <source>as a guideline, use static methods as utilities, use class methods for example as factory . Or maybe to define a singleton. And use instance methods to model the state and behavior of instances.</source>
          <target state="translated">в качестве руководства используйте статические методы в качестве утилит,используйте методы классов,например,как заводские.Или,может быть,определить одиночку.И использовать методы экземпляров для моделирования состояния и поведения экземпляров.</target>
        </trans-unit>
        <trans-unit id="d52a33eead97a71117a46cf4e95a8a4ce30467f3" translate="yes" xml:space="preserve">
          <source>class method</source>
          <target state="translated">классовый метод</target>
        </trans-unit>
        <trans-unit id="52f372dd7e7596da7a6a95d387e97222b81d84c7" translate="yes" xml:space="preserve">
          <source>classmethod has no access to attributes of the object. It however can access attributes of the class and of parent classes in the inheritance hierarchy.
It can be called at the class directly (without creating an object). If called at the object then it is the same as normal method which doesn't access &lt;code&gt;self.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; and accesses &lt;code&gt;self.__class__.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; only.</source>
          <target state="translated">classmethod не имеет доступа к атрибутам объекта. Однако он может обращаться к атрибутам класса и родительских классов в иерархии наследования. Он может быть вызван непосредственно в классе (без создания объекта). Если вызывается в объекте, то он такой же, как обычный метод, который не обращается к &lt;code&gt;self.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; и обращается только к &lt;code&gt;self.__class__.&amp;lt;attribute(s)&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7948ad16ed2603a6348a81efc5083231e6e99599" translate="yes" xml:space="preserve">
          <source>classmethod: &lt;strong&gt;the class of the current object&lt;/strong&gt; is automatically passed as an (additional) fist argument</source>
          <target state="translated">classmethod: &lt;strong&gt;класс текущего объекта&lt;/strong&gt; автоматически передается как (дополнительный) первый аргумент</target>
        </trans-unit>
        <trans-unit id="040092959b9872d342ec8835eaf66a5912667aab" translate="yes" xml:space="preserve">
          <source>if we use the instance method, &lt;code&gt;join&lt;/code&gt; on this string, to join another iterable,
it quite obviously is a function of the instance, in addition to being a function of the iterable list, &lt;code&gt;['a', 'b', 'c']&lt;/code&gt;:</source>
          <target state="translated">если мы используем метод экземпляра, &lt;code&gt;join&lt;/code&gt; для этой строки, чтобы присоединиться к другой итерируемой, это, очевидно, является функцией экземпляра, в дополнение к функции итеративного списка, &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="458d61efa24b172ec0fd06ca32a179e50bd11ce5" translate="yes" xml:space="preserve">
          <source>must be called with 2 arguments. &lt;code&gt;self&lt;/code&gt; is automatically passed, and it is &lt;em&gt;the object itself&lt;/em&gt;.</source>
          <target state="translated">должен быть вызван с 2 аргументами. &lt;code&gt;self&lt;/code&gt; автоматически передается, и это &lt;em&gt;сам объект&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="708f8989ac21092a5c5d8c983540d9bb44c48d11" translate="yes" xml:space="preserve">
          <source>normal method</source>
          <target state="translated">обычный способ</target>
        </trans-unit>
        <trans-unit id="feaabadfa899129cb55b2beee5ee0ea7aabdd795" translate="yes" xml:space="preserve">
          <source>normal method: &lt;strong&gt;the current object&lt;/strong&gt; if automatically passed as an (additional) first argument</source>
          <target state="translated">обычный метод: &lt;strong&gt;текущий объект,&lt;/strong&gt; если автоматически передан как (дополнительный) первый аргумент</target>
        </trans-unit>
        <trans-unit id="bced6a1cd17696e1d77254556ccfcc9c6ad98d6a" translate="yes" xml:space="preserve">
          <source>python2:</source>
          <target state="translated">python2:</target>
        </trans-unit>
        <trans-unit id="e174fa5929995f67b31815ee0e9bd6d2d9fd8564" translate="yes" xml:space="preserve">
          <source>python3:</source>
          <target state="translated">python3:</target>
        </trans-unit>
        <trans-unit id="75d198e754da69d735666ee31a24c9846f114435" translate="yes" xml:space="preserve">
          <source>static method</source>
          <target state="translated">статический метод</target>
        </trans-unit>
        <trans-unit id="6acd42d6636986fd7c20f9eddf725cc1b2a99a5e" translate="yes" xml:space="preserve">
          <source>staticmethod has no access to attibutes of the object, of the class, or of parent classes in the inheritance hierarchy.
It can be called at the class directly (without creating an object).</source>
          <target state="translated">staticmethod не имеет доступа к атрибутам объекта,класса или родительских классов в иерархии наследования.Он может быть вызван непосредственно в классе (без создания объекта).</target>
        </trans-unit>
        <trans-unit id="7ac95df276e52f37bfcb52496e9992dd99c61d05" translate="yes" xml:space="preserve">
          <source>staticmethod: &lt;strong&gt;no extra arguments&lt;/strong&gt; are automatically passed. What you passed to the function is what you get.</source>
          <target state="translated">staticmethod: &lt;strong&gt;дополнительные аргументы не&lt;/strong&gt; передаются автоматически. То, что вы передали функции, это то, что вы получите.</target>
        </trans-unit>
        <trans-unit id="2fa2da2994698860ee444ff57aadffe1813adf65" translate="yes" xml:space="preserve">
          <source>the automatically provided argument &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;self&lt;/code&gt;, but &lt;em&gt;the class of&lt;/em&gt;&lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">автоматически предоставленный аргумент &lt;em&gt;- это не&lt;/em&gt; &lt;code&gt;self&lt;/code&gt; , а &lt;em&gt;класс&lt;/em&gt; &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fbfad97aa3528afd3e7b36e34de780b77e439c1" translate="yes" xml:space="preserve">
          <source>the method &lt;em&gt;is not given&lt;/em&gt; any automatic argument at all. It is only given the parameters that it is called with.</source>
          <target state="translated">метод &lt;em&gt;не имеет&lt;/em&gt; никакого автоматического аргумента вообще. Дается только параметры, с которыми он вызывается.</target>
        </trans-unit>
        <trans-unit id="2e0f976fbe142678d71e6f50a7587ee622db8c82" translate="yes" xml:space="preserve">
          <source>usages</source>
          <target state="translated">usages</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
