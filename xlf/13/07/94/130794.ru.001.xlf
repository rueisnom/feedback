<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/130794">
    <body>
      <group id="130794">
        <trans-unit id="075303a37c1db7777d673503bd42ea6517e55270" translate="yes" xml:space="preserve">
          <source>&quot;As our &lt;strong&gt;applications&lt;/strong&gt; grow and evolves, each one of our &lt;strong&gt;code entities&lt;/strong&gt; will internally require &lt;strong&gt;instances of other objects&lt;/strong&gt;, which are better known as &lt;strong&gt;dependencies&lt;/strong&gt; in the world of software engineering. The &lt;strong&gt;action&lt;/strong&gt; of passing such &lt;strong&gt;dependencies&lt;/strong&gt; to the dependent client is known as &lt;strong&gt;injection&lt;/strong&gt;, and it also entails the participation of another code entity, named the &lt;strong&gt;injector&lt;/strong&gt;. The &lt;strong&gt;injector&lt;/strong&gt; will take responsibility for &lt;strong&gt;instantiating&lt;/strong&gt; and &lt;strong&gt;bootstrapping&lt;/strong&gt; the required &lt;strong&gt;dependencies&lt;/strong&gt; so they are ready for use from the very moment they are successfully injected in the client. This is very important since the client knows nothing about how to &lt;strong&gt;instantiate&lt;/strong&gt; its own &lt;strong&gt;dependencies&lt;/strong&gt; and is only aware of the &lt;strong&gt;interface&lt;/strong&gt; they implement in order to use them.&quot;</source>
          <target state="translated">&amp;laquo;По мере роста и развития наших &lt;strong&gt;приложений&lt;/strong&gt; каждому из наших &lt;strong&gt;объектов кода&lt;/strong&gt; будут внутренне требовать &lt;strong&gt;экземпляры других объектов&lt;/strong&gt; , которые более известны как &lt;strong&gt;зависимости&lt;/strong&gt; в мире разработки программного обеспечения. &lt;strong&gt;Действие&lt;/strong&gt; передачи таких &lt;strong&gt;зависимостей&lt;/strong&gt; зависимому клиенту называется &lt;strong&gt;внедрением&lt;/strong&gt; , и это также влечет за собой участие другого объекта кода, называемого &lt;strong&gt;инжектором&lt;/strong&gt; . &lt;strong&gt;Инжектор&lt;/strong&gt; будет нести ответственность за &lt;strong&gt;создание&lt;/strong&gt; и &lt;strong&gt;загрузку&lt;/strong&gt; требуемых &lt;strong&gt;зависимостей,&lt;/strong&gt; чтобы они были готовы к использованию с того самого момента, как они успешно внедрены в клиенте. Это очень важно, поскольку клиент ничего не знает о том, как &lt;strong&gt;создавать&lt;/strong&gt; свои собственные &lt;strong&gt;зависимости,&lt;/strong&gt; и знает только &lt;strong&gt;интерфейс, который&lt;/strong&gt; они реализуют, чтобы использовать их &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="88ba72c68eb66f9403511df347aad31c0ffb36bb" translate="yes" xml:space="preserve">
          <source>&quot;Dependency Injection&quot; is a 25-dollar
  term for a 5-cent concept. [...]
  Dependency injection means giving an
  object its instance variables. [...].</source>
          <target state="translated">&quot;Укол зависимости&quot;-это 25-долларовый термин для 5-центовой концепции.[...]Инъекция зависимостей означает присвоение объекту переменных его экземпляра.[...].</target>
        </trans-unit>
        <trans-unit id="884583105d69da013b6572c7250c4e2a8f722ed6" translate="yes" xml:space="preserve">
          <source>&quot;Dependency injection&quot; is considered a type of &quot;inversion of control&quot;, which means that some logic is taken out of the caller. That isn't the case when the caller passes in parameters, so if that were DI, DI would not imply inversion of control.</source>
          <target state="translated">&quot;Инъекция зависимостей&quot; считается разновидностью &quot;инверсии управления&quot;,что означает,что некоторая логика выведена из вызывающего абонента.Это не тот случай,когда вызывающий абонент передает параметры,поэтому если бы это была DI,то DI не подразумевала бы инверсию управления.</target>
        </trans-unit>
        <trans-unit id="559316cc487d0d2d80076d1938d00fe314c1d36f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;In short, &lt;strong&gt;DI&lt;/strong&gt; helps you write code in a &lt;strong&gt;loosely coupled&lt;/strong&gt; way and makes your &lt;strong&gt;code&lt;/strong&gt; more &lt;strong&gt;testable&lt;/strong&gt; and &lt;strong&gt;reusable&lt;/strong&gt;.&amp;rdquo;</source>
          <target state="translated">&amp;laquo;Короче говоря, &lt;strong&gt;DI&lt;/strong&gt; помогает вам писать код в &lt;strong&gt;слабосвязанной&lt;/strong&gt; форме и делает ваш &lt;strong&gt;код&lt;/strong&gt; более &lt;strong&gt;тестируемым&lt;/strong&gt; и &lt;strong&gt;пригодным для&lt;/strong&gt; &lt;strong&gt;повторного использования&lt;/strong&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ec42628a9387e4101c1904f5ffcd31e7a85677db" translate="yes" xml:space="preserve">
          <source>(A concrete &lt;code&gt;Clock&lt;/code&gt; needs to be provided, which of course could revert to &lt;code&gt;DateTime.Now&lt;/code&gt;, and the two dependencies need to be provided by an IoC container via constructor injection)</source>
          <target state="translated">( &lt;code&gt;Clock&lt;/code&gt; быть предоставлены конкретные часы , которые, конечно, могут вернуться к &lt;code&gt;DateTime.Now&lt;/code&gt; , и две зависимости должны быть предоставлены контейнером IoC через внедрение конструктора)</target>
        </trans-unit>
        <trans-unit id="7c77d04844ca55b45c4e29a2ad4bd0663b614dc7" translate="yes" xml:space="preserve">
          <source>1) Simple manual &lt;code&gt;Injector&lt;/code&gt;</source>
          <target state="translated">1) Простой ручной &lt;code&gt;Injector&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b8c8a3c4e4de08de9d47e21c94fca818f3e508e" translate="yes" xml:space="preserve">
          <source>1.    Constructor-based dependency injection:</source>
          <target state="translated">1.Впрыск зависимости от конструктора:</target>
        </trans-unit>
        <trans-unit id="0fd3eb9210cba499046c01b805cb7de8b0581cf6" translate="yes" xml:space="preserve">
          <source>2) Use library: For Android &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;</source>
          <target state="translated">2) Использование библиотеки: для Android &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1dc2ccd951284c98a3bde560294a5c88093316a" translate="yes" xml:space="preserve">
          <source>2.    Setter-based dependency injection:</source>
          <target state="translated">2.Инъекция зависимости на основе сеттера:</target>
        </trans-unit>
        <trans-unit id="20d1910df8e94fb0fa91e3b643d5709d2d44f250" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://martinfowler.com/articles/injection.html#InterfaceInjection&quot;&gt;Martin Fowler&lt;/a&gt; documents a third alternative (h/t @MarcDix), where &lt;strong&gt;classes explicitly implement an interface&lt;/strong&gt; for the dependencies programmers wish injected.</source>
          <target state="translated">&lt;a href=&quot;http://martinfowler.com/articles/injection.html#InterfaceInjection&quot;&gt;Мартин Фаулер&lt;/a&gt; описывает третью альтернативу (h / t @MarcDix), где &lt;strong&gt;классы явно реализуют интерфейс&lt;/strong&gt; для зависимостей, которые программисты хотят &lt;strong&gt;внедрить&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="139cc1158c0803cacea84c6bb86ce8b3cd6a16e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php-di.org/doc/understanding-di.html&quot;&gt;This&lt;/a&gt; is the most simple explanation about &lt;strong&gt;Dependency Injection&lt;/strong&gt; and &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; I have ever seen:</source>
          <target state="translated">&lt;a href=&quot;http://php-di.org/doc/understanding-di.html&quot;&gt;Это&lt;/a&gt; самое простое объяснение &lt;strong&gt;контейнера&lt;/strong&gt; ввода &lt;strong&gt;зависимостей&lt;/strong&gt; и &lt;strong&gt;зависимостей, которое&lt;/strong&gt; я когда-либо видел:</target>
        </trans-unit>
        <trans-unit id="ea2f6774ac13f40817f28f4fc553b644d8059a9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James Shore's article shows the following examples for comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;Статья Джеймса Шора показывает следующие примеры для сравнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5dd4547c12b988e4cf971119a75e17e9ed5a4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency Injection&lt;/a&gt; means a way (actually &lt;strong&gt;any-way&lt;/strong&gt;) for one part of code (e.g a class) to have access to dependencies (other parts of code, e.g other classes, it depends upon) in a modular way without them being hardcoded (so they can change or be overriden freely, or even be loaded at another time, as needed)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Внедрение зависимостей&lt;/a&gt; означает способ (фактически &lt;strong&gt;любым способом&lt;/strong&gt; ) для одной части кода (например, класса) иметь доступ к зависимостям (другим частям кода, например, другим классам, от которых это зависит) модульным способом без их жесткого кодирования (поэтому они могут быть изменены или могут быть переопределены свободно, или даже могут быть загружены в другое время, если необходимо)</target>
        </trans-unit>
        <trans-unit id="489243935980044f46caf00a1da3950eb72480f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SomeClass()&lt;/code&gt; has its constructor as following:</source>
          <target state="translated">&lt;code&gt;SomeClass()&lt;/code&gt; имеет свой конструктор следующим образом:</target>
        </trans-unit>
        <trans-unit id="e7be66ff5c1f2bead4f99265aacf00180d5bd3fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myObject&lt;/code&gt; can be passed directly which makes testing easier.</source>
          <target state="translated">&lt;code&gt;myObject&lt;/code&gt; может быть передан напрямую, что облегчает тестирование.</target>
        </trans-unit>
        <trans-unit id="9bd7701ca83f91008241672a8066b98e80ce7fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and ps , yes it has become an overly-hyped 25$ name for a rather simple, concept)&lt;/em&gt;, my &lt;code&gt;.25&lt;/code&gt; cents</source>
          <target state="translated">&lt;em&gt;(и ps, да, это стало чрезмерно раскрученным названием за 25 $ для довольно простой, концепции)&lt;/em&gt; , мои &lt;code&gt;.25&lt;/code&gt; центов</target>
        </trans-unit>
        <trans-unit id="7c64642d978f251aeaa9e771fd6b2e4c8c2a0138" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DI increases cohesion by removing any need to determine the direction of dependency and write any glue code.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DI повышает сплоченность, устраняя необходимость определять направление зависимости и писать любой связующий код.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8cd65eebe518df31a3d3e8b816fd1032b277e646" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DI reduces coupling by making all of your components modular (i.e. replacable) and have well-defined interfaces to each other.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DI уменьшает связь, делая все ваши компоненты модульными (т.е. заменяемыми) и имеет четко определенные интерфейсы друг с другом.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2f6f530262aaa812ba33a2511d7964178350822" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I found this funny example in terms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot;&gt;loose coupling&lt;/a&gt;:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Я нашел этот забавный пример с точки зрения &lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot;&gt;слабой связи&lt;/a&gt; :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62fe0e1a78daa62d9061df07333b1c387f953b07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Using&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Using&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81d7f6f687485d5dc12f6f5268a195c72b70fee8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) 2) 3) Using&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 2) 3) Использование&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="134d462b40518572cfc8a34cb9179e98a9817f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Then what does the &lt;code&gt;Dependency Injection&lt;/code&gt; do for us...?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Тогда что делает &lt;code&gt;Dependency Injection&lt;/code&gt; для нас ...?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64e35a8a257eda0748b950b4efd25aebaab56d6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After using dependency injection:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;После использования зависимости зависимости:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e118dd44c7e67af1dc63de6f5672af7d0d76495d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the above answers are good, my aim is to explain the concept in a simple way so that anyone without a programming knowledge can also understand concept&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Все вышеприведенные ответы хороши, моя цель - объяснить концепцию простым способом, чтобы любой, кто не обладает знаниями в области программирования, также мог понять концепцию.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21f37caa4106b3b41630895455450baa84ccfb77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Alternative solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Альтернативное решение&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fe080fcf8cd21d9cdaa29a5c39e27707035ab956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DI, DIP and SOLID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DI, DIP и SOLID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e78d489aa9f4c7df98e18605184dfcf430472ba1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency Injection&lt;/strong&gt; and &lt;strong&gt;dependency Injection Containers&lt;/strong&gt; are different things:</source>
          <target state="translated">&lt;strong&gt;Инъекция&lt;/strong&gt; &lt;strong&gt;зависимости и Инъекция зависимости&lt;/strong&gt; - это разные вещи:</target>
        </trans-unit>
        <trans-unit id="4e7a19bc0d7c4175394cf98e210ddbeaca200985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency Injection&lt;/strong&gt; is passing dependency to other &lt;strong&gt;objects&lt;/strong&gt; or &lt;strong&gt;framework&lt;/strong&gt;( dependency injector).</source>
          <target state="translated">&lt;strong&gt;Внедрение зависимости&lt;/strong&gt; - это передача зависимости другим &lt;strong&gt;объектам&lt;/strong&gt; или &lt;strong&gt;каркасу&lt;/strong&gt; (инжектор зависимости).</target>
        </trans-unit>
        <trans-unit id="9050dff2d4e01dd22dab4a30a3b18b836dbca3a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Disadvantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="352fe1ffa66ad058937206892159aa0c751d3d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example for Dependency injection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример для внедрения зависимости&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89779a6f30decc7c58d031e6da0ce5e9759d2d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Next Steps&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Следующие шаги&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73b8706173c462cc0bdd6d2632616f2d7f4a120a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; : The creation / mapping / projection (via &lt;code&gt;new ..()&lt;/code&gt;) of POCO / POJO / Serialization DTOs / Entity Graphs / Anonymous JSON projections et al - i.e. &quot;Data only&quot; classes or records - used or returned from methods are &lt;em&gt;not&lt;/em&gt; regarded as Dependencies (in the UML sense) and not subject to DI. Using &lt;code&gt;new&lt;/code&gt; to project these is just fine.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : Создание / отображение / проекция (через &lt;code&gt;new ..()&lt;/code&gt; ) POCO / POJO / Сериализация DTO / Графы сущностей / Анонимные JSON-проекции и др., Т.е. классы или записи &amp;laquo;Только данные&amp;raquo; - используемые или возвращаемые из методов, &lt;em&gt;не&lt;/em&gt; рассматриваются как зависимости (в смысле UML) и не подлежат DI. Использование &lt;code&gt;new&lt;/code&gt; для проецирования это просто замечательно.</target>
        </trans-unit>
        <trans-unit id="d98f2b4bd341257a9dbd8120abd05530994fcf1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem&lt;/strong&gt;:
If &lt;code&gt;myObject&lt;/code&gt; involves complex tasks such as disk access or network access, it is &lt;strong&gt;hard&lt;/strong&gt; to do unit test on &lt;code&gt;SomeClass()&lt;/code&gt;. Programmers have to mock &lt;code&gt;myObject&lt;/code&gt; and might &lt;strong&gt;intercept&lt;/strong&gt; the factory call.</source>
          <target state="translated">&lt;strong&gt;Проблема&lt;/strong&gt; : если &lt;code&gt;myObject&lt;/code&gt; включает в себя сложные задачи, такие как доступ к диску или доступ к сети, &lt;strong&gt;трудно&lt;/strong&gt; выполнить модульное тестирование в &lt;code&gt;SomeClass()&lt;/code&gt; . Программисты должны издеваться над &lt;code&gt;myObject&lt;/code&gt; и могут &lt;strong&gt;перехватить&lt;/strong&gt; вызов фабрики.</target>
        </trans-unit>
        <trans-unit id="3caa217db0a9feb519ccfb83c5360a0fd9379499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Watched course about EF Core from Julie Lerman recently and also liked her short definition about DI.</source>
          <target state="translated">&lt;strong&gt;ОБНОВЛЕНИЕ:&lt;/strong&gt; Недавно посмотрел курс об EF Core от Джули Лерман, а также понравилось ее краткое определение о DI.</target>
        </trans-unit>
        <trans-unit id="bb8fdb2caf0495723a2bfa5cae2542c71d3df90c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Using&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fed09c4b3a548192ce23e86d0d3ac85024ca7184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 1)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 1)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5287e00dc55d1b18cf0490002f5097515ab0af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 1)&lt;/strong&gt; Constructor injection</source>
          <target state="translated">&lt;strong&gt;Способ 1)&lt;/strong&gt; Конструктор впрыска</target>
        </trans-unit>
        <trans-unit id="cffbc9253561d5f6c70f7781944f336db2c95227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 2)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 2)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfccbb774df62a67ec9d3bdc2292dd944115740" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 2)&lt;/strong&gt; Setter injection</source>
          <target state="translated">&lt;strong&gt;Способ 2)&lt;/strong&gt; Сеттер впрыска</target>
        </trans-unit>
        <trans-unit id="6b6b88724bc7d2fd56ed9b90ed70c1bf61d456de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 3)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 3)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7be335f5337bca5a01d1e24ed56b2f2d716bba6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 3)&lt;/strong&gt; Interface injection</source>
          <target state="translated">&lt;strong&gt;Способ 3)&lt;/strong&gt; Внедрение интерфейса</target>
        </trans-unit>
        <trans-unit id="e997684d5231d7a45924a857d44b5b8961d9a17d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Dependency Injection (DI)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое инъекция зависимостей (DI)?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a57f9d5d3eb174e62bab1bb6baa6ed97f6dfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is dependency injection and when/why should or shouldn't it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое внедрение зависимостей и когда / почему его следует или не следует использовать?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b431da6264f45e0d6035801527ad040d6ae12bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When to use DI?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Когда использовать DI?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd3cb919485762e2f7ae20824d2553c1b374d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why use DIP (and DI)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Зачем использовать DIP (и DI)?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e626bfdc41d8d0154fb13bbccc4a07c5bdea697f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without Dependency Injection (DI):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Без внедрения зависимостей (DI):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b41ad2ddaf8a9d9eee7a1bdd549ad0e74faf4d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;clean&lt;/strong&gt; of dependency initialization code</source>
          <target state="translated">&lt;strong&gt;очистить&lt;/strong&gt; от кода инициализации зависимости</target>
        </trans-unit>
        <trans-unit id="175b3654ce89f52bed835b1e1354adc55d5bff80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stable&lt;/strong&gt; regardless of dependency used</source>
          <target state="translated">&lt;strong&gt;стабильный&lt;/strong&gt; независимо от используемой зависимости</target>
        </trans-unit>
        <trans-unit id="b64cc2760536699c09c33fd0c38b16350e500872" translate="yes" xml:space="preserve">
          <source>===</source>
          <target state="translated">===</target>
        </trans-unit>
        <trans-unit id="6b0acc829dd60bf821accdbecbe0f34bcc950c1b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Car&lt;/code&gt; depends on wheels, engine, fuel, battery, etc. to run. Traditionally we define the brand of such dependent objects along with the definition of the &lt;code&gt;Car&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Car&lt;/code&gt; зависит от колес, двигателя, топлива, аккумулятора и т. Д. Для запуска. Традиционно мы определяем марку таких зависимых объектов вместе с определением объекта &lt;code&gt;Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76a8eb0e78cd5206cc6a627c1d56ea296a18f598" translate="yes" xml:space="preserve">
          <source>A dependency is an object that can be used (&lt;code&gt;Service&lt;/code&gt;)</source>
          <target state="translated">Зависимость - это объект, который можно использовать ( &lt;code&gt;Service&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d726743d668b3ba1c937402de85725ec11622168" translate="yes" xml:space="preserve">
          <source>A nice comment by Jose Maria Arranz on DI</source>
          <target state="translated">Приятный комментарий Jose Maria Arranz о компании DI</target>
        </trans-unit>
        <trans-unit id="55bbd203453572a1a2a8545b2a4e406f89f8d6bc" translate="yes" xml:space="preserve">
          <source>About replaceable: with a very simple .properties archive and Class.forName you can define wich classes can change. If ANY class of your code can be changed, Java is not for you, use an scripting language.  By the way: annotations cannot be changed without recompiling.</source>
          <target state="translated">О заменяемости:с помощью очень простого архива .properties и Class.forName вы можете определить,какие классы могут меняться.Если ЛЮБОЙ класс вашего кода может быть изменен,то Java не для вас,используйте скриптовый язык.Кстати:аннотации нельзя изменить без перекомпиляции.</target>
        </trans-unit>
        <trans-unit id="e431d362be915c2e12e2e8aec306dfb48350104c" translate="yes" xml:space="preserve">
          <source>Actually,Suppose in java you created two different classes as class A and class B, and whatever the function are available in class B you want to use in class A, So at that time dependency injection can be used.
where you can crate object of one class in other,in the same way you can inject an entire class in another class to make it accessible.
by this way dependency can be overcome.</source>
          <target state="translated">На самом деле,предположим,что в java вы создали два разных класса,как класс A и класс B,и что бы ни была доступна функция в классе B,которую вы хотите использовать в классе A,так что в это время можно использовать инъекцию зависимости.где вы можете создать объект одного класса в другом,таким же образом вы можете инъектировать целый класс в другом классе,чтобы сделать его доступным.таким образом зависимость можно преодолеть.</target>
        </trans-unit>
        <trans-unit id="b5e7a0d53d6a3064057c2db69d7bd1bb143ac3e8" translate="yes" xml:space="preserve">
          <source>All the three classes can be hidden for it's own implementation. Now we can use this code for DI:</source>
          <target state="translated">Все три класса могут быть скрыты для собственной реализации.Теперь мы можем использовать этот код для DI:</target>
        </trans-unit>
        <trans-unit id="9f4e112e7a703ff0642590623727505b80c743dd" translate="yes" xml:space="preserve">
          <source>Allowing expensive resources or services to be created as late as possible and only when needed.</source>
          <target state="translated">Позволяет создавать дорогие ресурсы или услуги как можно позже и только тогда,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="b73b678b4942a0f37f86394e629e8cffab4b632e" translate="yes" xml:space="preserve">
          <source>Also when we have many dependencies it is very good practice to use Inversion of Control(IoC) containers which we can tell which interfaces should be mapped to which concrete implementations for all our dependencies and we can have it resolve those dependencies for us when it constructs our object. For example, we could specify in the mapping for the IoC container that the &lt;strong&gt;IEngine&lt;/strong&gt; dependency should be mapped to the &lt;strong&gt;GasEngine&lt;/strong&gt; class and when we ask the IoC container for an instance of our &lt;strong&gt;Car&lt;/strong&gt; class, it will automatically construct our &lt;strong&gt;Car&lt;/strong&gt; class with a &lt;strong&gt;GasEngine&lt;/strong&gt; dependency passed in.</source>
          <target state="translated">Также, когда у нас много зависимостей, очень хорошая практика - использовать контейнеры Inversion of Control (IoC), которые мы можем сказать, какие интерфейсы должны быть отображены, какие конкретные реализации для всех наших зависимостей, и мы можем разрешить им разрешить эти зависимости для нас, когда он создаст наш объект. Например, мы могли бы указать в сопоставлении для контейнера IoC, что зависимость &lt;strong&gt;IEngine&lt;/strong&gt; должна быть сопоставлена ​​с классом &lt;strong&gt;GasEngine,&lt;/strong&gt; и когда мы запрашиваем у контейнера IoC экземпляр нашего класса &lt;strong&gt;Car&lt;/strong&gt; , он автоматически создаст наш класс &lt;strong&gt;Car&lt;/strong&gt; с зависимостью &lt;strong&gt;GasEngine.&lt;/strong&gt; прошло.</target>
        </trans-unit>
        <trans-unit id="992414fdd7e72886a072118a7f3b02c1d3b532c2" translate="yes" xml:space="preserve">
          <source>Although seemingly innocuous, it has two &lt;code&gt;static&lt;/code&gt; dependencies on two other classes, &lt;code&gt;System.DateTime&lt;/code&gt; and &lt;code&gt;System.Console&lt;/code&gt;, which not only limit the logging output options (logging to console will be worthless if no one is watching), but worse, it is difficult to automatically test given the dependency on a non-deterministic system clock.</source>
          <target state="translated">Несмотря на то, что он выглядит безобидным, он имеет две &lt;code&gt;static&lt;/code&gt; зависимости от двух других классов, &lt;code&gt;System.DateTime&lt;/code&gt; и &lt;code&gt;System.Console&lt;/code&gt; , которые не только ограничивают параметры вывода журналов (вход в консоль будет бесполезным, если никто не наблюдает), но, что еще хуже, это сложно автоматически проверять заданную зависимость от недетерминированных системных часов.</target>
        </trans-unit>
        <trans-unit id="608e86855b2a65e39ae912fd39a0fa1102aef2e4" translate="yes" xml:space="preserve">
          <source>An automated Unit Test can be built, which definitively proves that our logger is working correctly, as we now have control over the dependencies - the time, and we can spy on the written output:</source>
          <target state="translated">Может быть построен автоматизированный модульный тест,который окончательно доказывает,что наш регистратор работает правильно,так как теперь у нас есть контроль над зависимостями-временем,и мы можем шпионить за записанным выходом:</target>
        </trans-unit>
        <trans-unit id="70687f8f4f2b763df000dbed64d4fb27b23ff917" translate="yes" xml:space="preserve">
          <source>An injection is the passing of a dependency (&lt;code&gt;Service&lt;/code&gt;) to a dependent object (&lt;code&gt;Client&lt;/code&gt;) that would use it</source>
          <target state="translated">Инжекция - это передача зависимости ( &lt;code&gt;Service&lt;/code&gt; ) зависимому объекту ( &lt;code&gt;Client&lt;/code&gt; ), который будет его использовать.</target>
        </trans-unit>
        <trans-unit id="22de376201dcf4ad21e64690cf593a42ea12c2ce" translate="yes" xml:space="preserve">
          <source>And to instantiate the Car class we will use next code:</source>
          <target state="translated">А для конкретизации класса &quot;Автомобиль&quot; мы используем следующий код:</target>
        </trans-unit>
        <trans-unit id="5d989001b3ba666eebb2d9b73b1ed4f8b0f5b41d" translate="yes" xml:space="preserve">
          <source>Any application is composed of many objects that collaborate with each other to perform some useful stuff. Traditionally each object is responsible for obtaining its own references to the dependent objects (dependencies) it collaborate with. This leads to highly coupled classes and hard-to-test code.</source>
          <target state="translated">Любое приложение состоит из множества объектов,которые взаимодействуют друг с другом для выполнения некоторых полезных вещей.Традиционно каждый объект отвечает за получение собственных ссылок на зависимые объекты (зависимости),с которыми он сотрудничает.Это приводит к появлению классов с высокой связью и труднотестируемого кода.</target>
        </trans-unit>
        <trans-unit id="dcd3c9a7013d9400c6621023f7f9889b2d159708" translate="yes" xml:space="preserve">
          <source>Any time where you will need to unit test the methods of a class in isolation of its dependencies,</source>
          <target state="translated">В любое время,когда потребуется произвести единичное тестирование методов класса в отрыве от его зависимостей,</target>
        </trans-unit>
        <trans-unit id="8a5fc50e3ceaa03d10efa641f9932ed3164ec099" translate="yes" xml:space="preserve">
          <source>Application calls Foo</source>
          <target state="translated">Звонки в приложения Foo</target>
        </trans-unit>
        <trans-unit id="ac42390e19be354858b8262243637ee16d63efc2" translate="yes" xml:space="preserve">
          <source>Application creates Bar and gives it Bim</source>
          <target state="translated">Приложение создает Бар и дает ему Бим</target>
        </trans-unit>
        <trans-unit id="cc24fa2cfa1ade20a4b0568072650d805b3f7a37" translate="yes" xml:space="preserve">
          <source>Application creates Bim</source>
          <target state="translated">Приложение создает Bim</target>
        </trans-unit>
        <trans-unit id="70579284eb400d7297fa45f23e86008434a5dae7" translate="yes" xml:space="preserve">
          <source>Application creates Foo</source>
          <target state="translated">Приложение создает Foo</target>
        </trans-unit>
        <trans-unit id="c0f19361a5c397f8b9f7a8e3a097732fbca45296" translate="yes" xml:space="preserve">
          <source>Application creates Foo and gives it Bar</source>
          <target state="translated">Приложение создает Foo и дает ему Бар</target>
        </trans-unit>
        <trans-unit id="7f33a152d579b4e1ccdf69ca92b2a96ddcd2dca4" translate="yes" xml:space="preserve">
          <source>Application gets Foo from the Container, so:</source>
          <target state="translated">Приложение получает Фу из контейнера,так что..:</target>
        </trans-unit>
        <trans-unit id="1a435d46695a15e5ef97ebb4802372a00c982aa2" translate="yes" xml:space="preserve">
          <source>Application needs Foo (e.g. a controller), so:</source>
          <target state="translated">Для применения нужен Foo (например,контроллер):</target>
        </trans-unit>
        <trans-unit id="63f0eb90a103bbcdae0831a58efe78a5893f2f45" translate="yes" xml:space="preserve">
          <source>Application needs Foo so:</source>
          <target state="translated">Приложение должно Foo так:</target>
        </trans-unit>
        <trans-unit id="9be6e530a74dcafa45c7b24d7025184525c1bc10" translate="yes" xml:space="preserve">
          <source>Application needs Foo, which needs Bar, which needs Bim, so:</source>
          <target state="translated">Приложению нужен Фу,которому нужен Бар,которому нужен Бим,так что..:</target>
        </trans-unit>
        <trans-unit id="41f971b49b630ecc0dbd5fbc5a28c4f03ee52f5d" translate="yes" xml:space="preserve">
          <source>As others have said, &lt;em&gt;Dependency Injection(DI)&lt;/em&gt; removes the responsibility of direct creation, and management of the lifespan, of other object instances upon which our class of interest (consumer class) is dependent (in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency&quot;&gt;UML sense&lt;/a&gt;). These instances are instead passed to our consumer class, typically as constructor parameters or via property setters (the management of the dependency object instancing and passing to the consumer class is usually performed by an &lt;em&gt;Inversion of Control (IoC)&lt;/em&gt; container, but that's another topic).</source>
          <target state="translated">Как уже говорили другие, &lt;em&gt;внедрение зависимостей (DI)&lt;/em&gt; устраняет ответственность за непосредственное создание и управление продолжительностью жизни других экземпляров объектов, от которых зависит наш класс интересов (потребительский класс) (в &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency&quot;&gt;смысле UML&lt;/a&gt; ). Эти экземпляры вместо этого передаются в наш потребительский класс, обычно в качестве параметров конструктора или через установщики свойств (управление экземпляром объекта зависимости и передачей в потребительский класс обычно выполняется контейнером &lt;em&gt;Inversion of Control (IoC)&lt;/em&gt; , но это другая тема) ,</target>
        </trans-unit>
        <trans-unit id="08399bcb01b547cab14e44b28e00c30b6c0663f3" translate="yes" xml:space="preserve">
          <source>As per above example, decoupling of dependencies does require some design effort, and for the developer, there is a paradigm shift needed to break the habit of &lt;code&gt;new&lt;/code&gt;ing dependencies directly, and instead trusting the container to manage dependencies.</source>
          <target state="translated">Как в приведенном выше примере, разделение зависимостей требует определенных усилий по проектированию, и для разработчика существует смена парадигмы, необходимая для того, чтобы избавиться от привычки напрямую создавать &lt;code&gt;new&lt;/code&gt; зависимости и вместо этого доверять контейнеру управление зависимостями.</target>
        </trans-unit>
        <trans-unit id="fff41238dbef5b816e589fb9ecf3cbde7896731e" translate="yes" xml:space="preserve">
          <source>Bar creates Bim</source>
          <target state="translated">Бар создает Бим</target>
        </trans-unit>
        <trans-unit id="452099fc339bb9ab1a4137666deb3f1f3b017433" translate="yes" xml:space="preserve">
          <source>Bar does something</source>
          <target state="translated">Бар что-то делает</target>
        </trans-unit>
        <trans-unit id="2b2cfde5abc29f811788f8a477a12b0d271a2ada" translate="yes" xml:space="preserve">
          <source>Bar needs Bim (a service, a repository,
&amp;hellip;), so:</source>
          <target state="translated">Бар нужен Bim (сервис, репозиторий,&amp;hellip;), поэтому:</target>
        </trans-unit>
        <trans-unit id="ae219b96ca6e4a1b3a53e426dca90a803fe2da20" translate="yes" xml:space="preserve">
          <source>But consider the following example&amp;hellip; Suppose you have a class with ten methods that have no dependencies, but you&amp;rsquo;re adding a new method that does have a dependency on IDAO. You could change the constructor to use Constructor Injection, but this may force you to changes to all constructor calls all over the place. Alternatively, you could just add a new constructor that takes the dependency, but then how does a developer easily know when to use one constructor over the other. Finally, if the dependency is very expensive to create, why should it be created and passed to the constructor when it may only be used rarely? &amp;ldquo;Setter Injection&amp;rdquo; is another DI technique that can be used in situations such as this.</source>
          <target state="translated">Но рассмотрим следующий пример ... Предположим, у вас есть класс с десятью методами, которые не имеют зависимостей, но вы добавляете новый метод, который имеет зависимость от IDAO. Вы можете изменить конструктор, чтобы использовать конструктор Injection, но это может заставить вас вносить изменения во все вызовы конструктора повсюду. В качестве альтернативы, вы можете просто добавить новый конструктор, который получает зависимость, но тогда как разработчик легко узнает, когда использовать один конструктор над другим. Наконец, если создать зависимость очень дорого, зачем ее создавать и передавать конструктору, если ее можно использовать редко? &amp;laquo;Инъекция сеттера&amp;raquo; - это еще один метод DI, который можно использовать в таких ситуациях, как эта.</target>
        </trans-unit>
        <trans-unit id="1778648e0dd763c5f5a9c7958ded52526966ceb6" translate="yes" xml:space="preserve">
          <source>But it's a generic approach to split concerns of:</source>
          <target state="translated">Но это общий подход к разделению проблем:</target>
        </trans-unit>
        <trans-unit id="19a17a99cb30f6d4a5536c327bad501717385b19" translate="yes" xml:space="preserve">
          <source>But the benefits are many, especially in the ability to thoroughly test your class of interest.</source>
          <target state="translated">Но преимуществ много,особенно в возможности тщательно проверить свой класс.</target>
        </trans-unit>
        <trans-unit id="f690c20291f1b4d985514efeb98b89687022ac96" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;https://en.wikipedia.org/wiki/Dependency_injection&lt;/a&gt;</source>
          <target state="translated">Проверьте &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;https://en.wikipedia.org/wiki/Dependency_injection&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e531036736b85e446725e4e4e6164a78cdfb8c9c" translate="yes" xml:space="preserve">
          <source>Consider simple &lt;code&gt;dependent.sh&lt;/code&gt; script:</source>
          <target state="translated">Рассмотрим простой сценарий &lt;code&gt;dependent.sh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a938a98716a29fea8b403330f964cb8cf46392e9" translate="yes" xml:space="preserve">
          <source>Constructor Injection</source>
          <target state="translated">Инъекция конструктора</target>
        </trans-unit>
        <trans-unit id="b5773fd2800024a3f838fe7729940f9f8e15e065" translate="yes" xml:space="preserve">
          <source>Constructor injection</source>
          <target state="translated">Впрыск конструктора</target>
        </trans-unit>
        <trans-unit id="26032cadfd8928d408ef47b863c4b45733ef2d0d" translate="yes" xml:space="preserve">
          <source>Constructor with dependency injection:</source>
          <target state="translated">Конструктор с зависимым впрыском:</target>
        </trans-unit>
        <trans-unit id="3f2bf7f408c28388ad6bd617db22886b5fe56b26" translate="yes" xml:space="preserve">
          <source>Constructor without dependency injection:</source>
          <target state="translated">Конструктор без зависимого впрыска:</target>
        </trans-unit>
        <trans-unit id="b2146937a33bfcabf2430053c4204e88638eba30" translate="yes" xml:space="preserve">
          <source>Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on other class.</source>
          <target state="translated">DI,основанная на конструкторах,выполняется,когда контейнер вызывает конструктор класса с рядом аргументов,каждый из которых представляет собой зависимость от другого класса.</target>
        </trans-unit>
        <trans-unit id="faa2e023d8bf9a1b5e13e711551447a2e6bc4da2" translate="yes" xml:space="preserve">
          <source>Container creates Bar and gives it Bim</source>
          <target state="translated">Контейнер создает Бар и дает ему Бим.</target>
        </trans-unit>
        <trans-unit id="e72228b222f6d8727f4e55af720a28149a261110" translate="yes" xml:space="preserve">
          <source>Container creates Bim</source>
          <target state="translated">Контейнер создает Бим</target>
        </trans-unit>
        <trans-unit id="6653855bc3a85ec8d066669874a2916aaf0d2c9e" translate="yes" xml:space="preserve">
          <source>Container creates Foo and gives it Bar</source>
          <target state="translated">Контейнер создает Foo и дает ему Бар.</target>
        </trans-unit>
        <trans-unit id="8ac27f6a08ba25f489c38925c6e85a272db84091" translate="yes" xml:space="preserve">
          <source>DEPENDENCY INJECTION IS SIMPLY GLUING TWO CLASSES AND AT THE SAME TIME KEEPING THEM SEPARATE.</source>
          <target state="translated">ИНЪЕКЦИЯ ЗАВИСИМОСТИ ПРОСТО СКЛЕИВАЕТ ДВА КЛАССА И В ТО ЖЕ ВРЕМЯ ДЕРЖИТ ИХ ОТДЕЛЬНО ДРУГ ОТ ДРУГА.</target>
        </trans-unit>
        <trans-unit id="08ebf9ead9196a1af9ffc22cd9c1eeb51be76894" translate="yes" xml:space="preserve">
          <source>DI brings you closer to the Single Responsibility (SR) principle, like the &lt;code&gt;surgeon who can concentrate on surgery&lt;/code&gt;.</source>
          <target state="translated">DI приближает вас к принципу единой ответственности (SR), подобно &lt;code&gt;surgeon who can concentrate on surgery&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a43f9d298673ad95516fee4e62a2a823a586584a" translate="yes" xml:space="preserve">
          <source>DI for short, is a technique to remove a common additional responsibility (burden) on components to fetch the dependent components, by providing them to it.</source>
          <target state="translated">Короче говоря,DI-это методика,позволяющая снять общую дополнительную ответственность (нагрузку)на компоненты для извлечения зависимых компонентов,предоставляя их ему.</target>
        </trans-unit>
        <trans-unit id="4f5d36ed84699163eaf23e5a7fdfc103b0bbc15e" translate="yes" xml:space="preserve">
          <source>DI is a particular form of IoC, whereby the process of finding your dependencies is
  outside the direct control of your currently executing code.</source>
          <target state="translated">DI-это особая форма IoC,в которой процесс поиска ваших зависимостей находится вне непосредственного контроля выполняющегося в данный момент кода.</target>
        </trans-unit>
        <trans-unit id="feb00fd97973bff59f7d3245f637dd67debab5a4" translate="yes" xml:space="preserve">
          <source>DI is analogous to this in the world of Object Oriented programming.  The values there instead of constant literals are whole objects - but the reason to move the code creating them out from the class code is similar - the objects change more frequently then the code that uses them.  One important case where such a change is needed is tests.</source>
          <target state="translated">DI является аналогом в мире Объектно-ориентированного программирования.Значения там вместо константных литералов-это целые объекты-но причина переноса создающего их кода из кода класса похожа-объекты меняются чаще,чем код,который их использует.Одним из важных случаев,когда такое изменение необходимо,являются тесты.</target>
        </trans-unit>
        <trans-unit id="2e8b1223bba2170ce6128ed0e576d38e0241b406" translate="yes" xml:space="preserve">
          <source>DI is not as largely emphasized and popularized as in Java frameworks.</source>
          <target state="translated">DI не так акцентирован и популярен,как в Java-фреймворках.</target>
        </trans-unit>
        <trans-unit id="e75ded6d3588df205b0011e584a93bde9df27a8f" translate="yes" xml:space="preserve">
          <source>DI is the implementation of IOC principal of Spring which says &quot;Don't call us we will call you&quot;. Using dependency injection programmer doesn't need to create object using the new keyword.</source>
          <target state="translated">DI-это воплощение в жизнь принципа &quot;Весна&quot; МОК,который гласит:&quot;Не звоните нам,мы позвоним вам&quot;.Используя инъекцию зависимостей,программисту не нужно создавать объект по новому ключевому слову.</target>
        </trans-unit>
        <trans-unit id="88de733e17606a4266cbf096951b24a70dd9b893" translate="yes" xml:space="preserve">
          <source>DI means there is an intermediate level between the caller and the constructor which manages dependencies. A Makefile is a simple example of dependency injection. The &quot;caller&quot; is the person typing &quot;make bar&quot; on the command line, and the &quot;constructor&quot; is the compiler. The Makefile specifies that bar depends on foo, and it does a</source>
          <target state="translated">DI означает,что между вызывающим абонентом и конструктором существует промежуточный уровень,который управляет зависимостями.Makefile-простой пример внедрения зависимостей.Обратившийся&quot;-это человек,набравший в командной строке &quot;make bar&quot;,а &quot;конструктор&quot;-компилятор.Makefile указывает,что бар зависит от foo,и делает a</target>
        </trans-unit>
        <trans-unit id="007835874d333d08ff81faee651cdd6f320b4cd1" translate="yes" xml:space="preserve">
          <source>Decoupling dependencies between classes in this way allows for &lt;em&gt;easy substitution&lt;/em&gt; of these dependency classes with other implementations which also fulfil the prerequisites of the abstraction (e.g. the dependency can be switched with another implementation of the same interface). Moreover, as others have mentioned, possibly &lt;em&gt;the&lt;/em&gt; most common reason to decouple classes via the DIP is to allow a consuming class to be tested in isolation, as these same dependencies can now be stubbed and/or mocked.</source>
          <target state="translated">Разъединение зависимостей между классами таким способом позволяет &lt;em&gt;легко заменить&lt;/em&gt; эти классы зависимостей другими реализациями, которые также выполняют предварительные условия абстракции (например, зависимость может быть переключена с другой реализацией того же интерфейса). Более того, как уже упоминали другие, возможно, наиболее распространенная причина разъединения классов с помощью DIP состоит в том, чтобы позволить потребляющему классу тестироваться изолированно, так как эти же зависимости теперь могут быть заглушены и / или подвергнуты насмешкам.</target>
        </trans-unit>
        <trans-unit id="8373baaef22105a8574ebe7cace135c9de92ef3f" translate="yes" xml:space="preserve">
          <source>Dependencies can be injected into objects by many means (such as constructor injection or setter injection). One can even use specialized dependency injection frameworks (e.g. Spring) to do that, but they certainly aren't required. You don't need those frameworks to have dependency injection. Instantiating and passing objects (dependencies) explicitly is just as good an injection as injection by framework.</source>
          <target state="translated">Зависимости могут быть введены в объекты многими способами (например,впрыск конструктора или впрыск сеттера).Для этого можно даже использовать специализированные системы впрыска зависимостей (например,Spring),но они определённо не требуются.Вам не нужно,чтобы эти структуры имели инъекции зависимостей.Факторизация и передача объектов (зависимостей)явно так же хороша,как и инъекция с помощью фреймворка.</target>
        </trans-unit>
        <trans-unit id="805edc480d58383c8e5e2cdbb15c0f0b990469a8" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is one from Design Patterns, which uses the basic feature of OOP - the relationship in one object with another object. While inheritance inherits one object to do more complex and specific another object, relationship or association simply creates a pointer to another object from one object using attribute. The power of DI is in combination with other features of OOP as are interfaces and hiding code.
Suppose, we have a customer (subscriber) in the library, which can borrow only one book for simplicity.</source>
          <target state="translated">Инъекция зависимости (DI)-это инъекция из Design Patterns,использующая основную особенность ООП-связь в одном объекте с другим объектом.В то время как наследование наследует один объект,чтобы сделать более сложным и специфическим другой объект,связь или ассоциация просто создает указатель на другой объект из одного объекта с помощью атрибута.Сила DI в сочетании с другими особенностями ООП,так же как и интерфейсы и скрывающий код.Предположим,в библиотеке есть клиент (подписчик),который для простоты может позаимствовать только одну книгу.</target>
        </trans-unit>
        <trans-unit id="2eaf5885c756aab73a83e3523b8617e6e5448a02" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is part of Dependency Inversion Principle (DIP) practice, which is also called Inversion of Control (IoC). Basically you need to do DIP because you want to make your code more modular and unit testable, instead of just one monolithic system. So you start identifying parts of the code that can be separated from the class and abstracted away. Now the implementation of the abstraction need to be injected from outside of the class. Normally this can be done via constructor. So you create a constructor that accepts the abstraction as a parameter, and this is called dependency injection (via constructor). For more explanation about DIP, DI, and IoC container you can read &lt;a href=&quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">Инъекция зависимости (DI) является частью практики Принципа зависимости зависимости (DIP), которая также называется инверсией контроля (IoC). По сути, вам нужно выполнять DIP, потому что вы хотите сделать свой код более модульным и тестируемым на уровне модулей, а не только одной монолитной системой. Таким образом, вы начинаете определять части кода, которые можно отделить от класса и абстрагировать. Теперь реализацию абстракции нужно вводить извне класса. Обычно это можно сделать через конструктор. Таким образом, вы создаете конструктор, который принимает абстракцию в качестве параметра, и это называется внедрением зависимости (через конструктор). Более подробное описание контейнера DIP, DI и IoC вы можете прочитать &lt;a href=&quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html&quot;&gt;здесь.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec9e1e9a757b12d7ba7015b1965d7e8d66b82118" translate="yes" xml:space="preserve">
          <source>Dependency Injection definition</source>
          <target state="translated">Определение инъекции зависимости</target>
        </trans-unit>
        <trans-unit id="cb2cb0f05e812293b7ad0ba1d7be1914b8ecef4e" translate="yes" xml:space="preserve">
          <source>Dependency Injection is a method for writing better code</source>
          <target state="translated">Инъекция зависимостей-метод для написания лучшего кода</target>
        </trans-unit>
        <trans-unit id="cddf49311cde392103b798084c33da2a7ca7c60e" translate="yes" xml:space="preserve">
          <source>Dependency Injection is a practice where objects are designed in a manner where they receive instances of the objects from other pieces of code, instead of constructing them internally. This means that any object implementing the interface which is required by the object can be substituted in without changing the code, which simplifies testing, and improves decoupling.</source>
          <target state="translated">Dependency Injection-это практика,при которой объекты проектируются таким образом,что они получают экземпляры объектов из других частей кода,а не строят их внутренне.Это означает,что любой объект,реализующий интерфейс,который требуется объекту,может быть заменен без изменения кода,что упрощает тестирование и улучшает развязку.</target>
        </trans-unit>
        <trans-unit id="afcfc311b0f222c1476db1b255d403234af0b4db" translate="yes" xml:space="preserve">
          <source>Dependency Injection is the process of creating the static, stateless
  graph of service objects, where each service is parametrised by its
  dependencies.</source>
          <target state="translated">Инъекция зависимостей-это процесс создания статического графика объектов обслуживания,в котором каждый сервис параметризуется своими зависимостями.</target>
        </trans-unit>
        <trans-unit id="64a15438c3caa440c0a5dc9eb291180789196b8d" translate="yes" xml:space="preserve">
          <source>Dependency Injection(DI) means to decouple the objects which are dependent on each other. Say object A is dependent on Object B so the idea is to decouple these object from each other. We don&amp;rsquo;t need to hard code the object using new keyword rather sharing dependencies to objects at runtime in spite of compile time.
If we talk about</source>
          <target state="translated">Внедрение зависимостей (DI) означает разделение объектов, которые зависят друг от друга. Скажем, объект A зависит от объекта B, поэтому идея состоит в том, чтобы отделить эти объекты друг от друга. Нам не нужно жестко кодировать объект с использованием нового ключевого слова, а делиться зависимостями с объектами во время выполнения, несмотря на время компиляции. Если мы говорим о</target>
        </trans-unit>
        <trans-unit id="5ca81c175fbe0a8a94fd156ed8fda57771b7acaa" translate="yes" xml:space="preserve">
          <source>Dependency injection is a pattern to allow your application to inject
  objects on the fly to classes that need them, without forcing those
  classes to be responsible for those objects. It allows your code to be
  more loosely coupled, and Entity Framework Core plugs in to this same
  system of services.</source>
          <target state="translated">Инъекция зависимостей является шаблоном,позволяющим вашему приложению впрыскивать предметы на лету в классы,которые в них нуждаются,не заставляя эти классы нести ответственность за эти предметы.Это позволяет вашему коду быть более свободно связанным,и ядро Entity Framework Core подключается к этой же системе сервисов.</target>
        </trans-unit>
        <trans-unit id="f51897ce4672efc871df38ef9ec8a1e2a4f4a7a3" translate="yes" xml:space="preserve">
          <source>Dependency injection is a pattern used to create instances of objects that other objects rely upon without knowing at compile time which class will be used to provide that functionality or simply the way of injecting properties to an object is called dependency injection.</source>
          <target state="translated">Инъекция зависимостей-это шаблон,используемый для создания экземпляров объектов,на которые другие объекты полагаются,не зная во время компиляции,какой класс будет использоваться для обеспечения такой функциональности или просто способ инъекции свойств в объект называется инъекцией зависимостей.</target>
        </trans-unit>
        <trans-unit id="c8bcf420f928a840f91a5b1e5c82929829ba86a5" translate="yes" xml:space="preserve">
          <source>Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It's a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.</source>
          <target state="translated">Инъекция зависимостей-это,по сути,предоставление объектов,которые нужны объекту (его зависимостей),вместо того,чтобы создавать их самому.Это очень полезная методика для тестирования,так как она позволяет высмеивать или заглушать зависимости.</target>
        </trans-unit>
        <trans-unit id="eb5f2c3f9e29f385abcc1436959a966409e80529" translate="yes" xml:space="preserve">
          <source>Dependency injection is invariably associated with an &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Inversion of Control container(IoC)&lt;/a&gt;, to inject (provide) the concrete dependency instances, and to manage lifespan instances. During the configuration / bootstrapping process, &lt;code&gt;IoC&lt;/code&gt; containers allow the following to be defined:</source>
          <target state="translated">Внедрение зависимостей неизменно связано с &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;контейнером инверсии (IoC)&lt;/a&gt; для внедрения (предоставления) конкретных экземпляров зависимостей и управления экземплярами продолжительности жизни. В процессе конфигурирования / начальной загрузки контейнеры &lt;code&gt;IoC&lt;/code&gt; позволяют определить следующее:</target>
        </trans-unit>
        <trans-unit id="ca79292d85a27dbcae58c833ab50a3d5b3915751" translate="yes" xml:space="preserve">
          <source>Dependency injection is one of the design pattern that help us to create complex systems in a simpler manner.</source>
          <target state="translated">Впрыскивание зависимостей-один из шаблонов проектирования,который помогает нам создавать сложные системы более простым способом.</target>
        </trans-unit>
        <trans-unit id="69c4857065501ad52a336a3696b71d18e67bed61" translate="yes" xml:space="preserve">
          <source>Dependency injection is one possible solution to what could generally be termed the &quot;Dependency Obfuscation&quot; requirement. Dependency Obfuscation is a method of taking the 'obvious' nature out of the process of providing a dependency to a class that requires it and therefore obfuscating, in some way, the provision of said dependency to said class. This is not necessarily a bad thing. In fact, by obfuscating the manner by which a dependency is provided to a class then something outside the class is responsible for creating the dependency which means, in various scenarios, a different implementation of the dependency can be supplied to the class without making any changes to the class. This is great for switching between production and testing modes (eg., using a 'mock' service dependency).</source>
          <target state="translated">Инъекция зависимостей является одним из возможных решений того,что обычно можно назвать требованием &quot;Обмутнения зависимостей&quot;.Уточнение зависимости-это метод выведения &quot;очевидной&quot; природы из процесса предоставления зависимости классу,который ее требует,и,таким образом,каким-то образом сбивает с толку предоставление упомянутой зависимости упомянутому классу.Это не обязательно плохо.Фактически,запутывая способ,которым зависимость предоставляется классу,тогда что-то вне класса отвечает за создание зависимости,что означает,что в различных сценариях,различная реализация зависимости может быть поставлена в класс без внесения каких-либо изменений в класс.Это отлично подходит для переключения между производственным и тестовым режимами (например,использование &quot;имитационной&quot; зависимости от сервиса).</target>
        </trans-unit>
        <trans-unit id="0170849003cd6320060ea1c729c9aa49b34c7fd9" translate="yes" xml:space="preserve">
          <source>Dependency injection is the heart of the concept related with Spring Framework.While creating the framework of any project spring may perform a vital role,and here dependency injection come in pitcher.</source>
          <target state="translated">Инъекция зависимости-это сердцевина концепции,связанной с весной,в то время как создание структуры любой весны проекта может играть жизненно важную роль,и здесь инъекция зависимости приходит в кувшин.</target>
        </trans-unit>
        <trans-unit id="e58f7f11fd58e3edec005e7035583eb40983e40f" translate="yes" xml:space="preserve">
          <source>Dependency injection makes testing easier. The injection can be done through &lt;strong&gt;constructor&lt;/strong&gt;.</source>
          <target state="translated">Внедрение зависимостей облегчает тестирование. Внедрение может быть сделано через &lt;strong&gt;конструктор&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ff309b1b6291468565c4f9a9f51b36a3e04dd3" translate="yes" xml:space="preserve">
          <source>Dependency:</source>
          <target state="translated">Dependency:</target>
        </trans-unit>
        <trans-unit id="7ffc6ee12bdc72c1564366d1210f30e558da7c21" translate="yes" xml:space="preserve">
          <source>Difference between Inversion of Control &amp;amp; Dependency Injection</source>
          <target state="translated">Разница между инверсией контроля и инъекцией зависимостей</target>
        </trans-unit>
        <trans-unit id="be57f0e0c6c38a3c5499991aa97bdbb4642cde74" translate="yes" xml:space="preserve">
          <source>Doesn't &quot;dependency injection&quot; just mean using parameterized constructors and public setters?</source>
          <target state="translated">Разве &quot;инъекция зависимости&quot; не означает просто использование параметризованных конструкторов и публичных сеттеров?</target>
        </trans-unit>
        <trans-unit id="dce70f9dbaf63e1888206b128af00b53f6dd310d" translate="yes" xml:space="preserve">
          <source>Everytime I want to change what objects my AClass needs, I need to now look into two places - The class itself and the configuration file. How does that make life easier?</source>
          <target state="translated">Каждый раз,когда я хочу изменить,какие объекты нужны моему AClass,мне нужно посмотреть на два места-сам класс и файл конфигурации.Как это облегчает жизнь?</target>
        </trans-unit>
        <trans-unit id="624d5b857fe09b27ef0b52a651428cfe9bdeb229" translate="yes" xml:space="preserve">
          <source>Example, we have 2 class &lt;code&gt;Client&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt;. &lt;code&gt;Client&lt;/code&gt; will use &lt;code&gt;Service&lt;/code&gt;</source>
          <target state="translated">Например, у нас есть 2 класса &lt;code&gt;Client&lt;/code&gt; и &lt;code&gt;Service&lt;/code&gt; . &lt;code&gt;Client&lt;/code&gt; будет использовать &lt;code&gt;Service&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cc967eb9e93b5533d3da79d75ffcafa1c607fa2" translate="yes" xml:space="preserve">
          <source>Example: DI with shell script</source>
          <target state="translated">Пример:DI со скриптом оболочки</target>
        </trans-unit>
        <trans-unit id="2f74df37b1ea988409f33c42af68c3062f522296" translate="yes" xml:space="preserve">
          <source>Example: removing DI</source>
          <target state="translated">Пример:удаление DI</target>
        </trans-unit>
        <trans-unit id="4d32216898588a9d6769484729321b2a32005852" translate="yes" xml:space="preserve">
          <source>Externalizing dependency and looking only on responsibility.</source>
          <target state="translated">Экстернализация зависимости и взгляд только на ответственность.</target>
        </trans-unit>
        <trans-unit id="f94c5803a635417a4c63406b77fcbb7801e90db0" translate="yes" xml:space="preserve">
          <source>False. The direction of dependencies is in XML form or as annotations, your dependencies are written as XML code and annotations. XML and annotations ARE source code.</source>
          <target state="translated">Ложь.Направление зависимостей написано в виде XML или в виде аннотаций,ваши зависимости написаны в виде XML кода и аннотаций.XML и аннотации-это исходный код.</target>
        </trans-unit>
        <trans-unit id="c66a3755f7748dad912a8f295d8660519cb19da7" translate="yes" xml:space="preserve">
          <source>False. You do not need a DI framework to build a modular code based on interfaces.</source>
          <target state="translated">Ложь.Вам не нужен фреймворк DI для построения модульного кода на основе интерфейсов.</target>
        </trans-unit>
        <trans-unit id="e9044ac31a8995f5ad62b7e9f444f33bf9e08657" translate="yes" xml:space="preserve">
          <source>Foo calls Bar</source>
          <target state="translated">Фу звонит Бар</target>
        </trans-unit>
        <trans-unit id="36a8c8318b6369919a71996fd940aacf3965166d" translate="yes" xml:space="preserve">
          <source>Foo creates Bar</source>
          <target state="translated">Фу создает Бар</target>
        </trans-unit>
        <trans-unit id="c2cfcdd995da76d7e30b4bb8c5a58a247fe77380" translate="yes" xml:space="preserve">
          <source>Foo needs Bar (e.g. a service), so:</source>
          <target state="translated">Фу нуждается в баре (например,в услуге),так что..:</target>
        </trans-unit>
        <trans-unit id="b181ce4ed346bf93fb78e315f5b4e0fdc64a362e" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Car&lt;/code&gt; object.</source>
          <target state="translated">Например, рассмотрим объект &lt;code&gt;Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773f448aa74e9ddd91521dd1c2732d809239a14b" translate="yes" xml:space="preserve">
          <source>For example, consider these clases:</source>
          <target state="translated">Например,рассмотрим эти клэсы:</target>
        </trans-unit>
        <trans-unit id="6301c293c982fc83aecdf06eaf96df22050f4fa1" translate="yes" xml:space="preserve">
          <source>From Christoffer Noring, Pablo Deeleman's book &amp;ldquo;Learning Angular - Second Edition&amp;rdquo;:</source>
          <target state="translated">Из книги Кристоффера Норинга, книги Пабло Дилемана &amp;laquo;Углубленное изучение - второе издание&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="d2f6f2619a4fc19e9326d217edd2b9cb13d7536f" translate="yes" xml:space="preserve">
          <source>From the Book, '&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1617290068&quot;&gt;Well-Grounded Java Developer: Vital techniques of Java 7 and polyglot programming&lt;/a&gt;</source>
          <target state="translated">Из книги &amp;laquo; &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1617290068&quot;&gt;Обоснованный Java-разработчик: жизненно важные методы Java 7 и программирование полиглотов&amp;raquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="565b14720ba865ef973ba05f90a124c36bd9081e" translate="yes" xml:space="preserve">
          <source>From: Anton Moiseev. book &amp;ldquo;Angular Development with Typescript, Second Edition.&amp;rdquo;:</source>
          <target state="translated">От: Антон Моисеев. книга &amp;laquo;Угловое развитие с Typescript, второе издание&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7cc777757b505d7bbd1af628607007866c70d979" translate="yes" xml:space="preserve">
          <source>Going back to the first question. If using new object() is bad, how come we inject the implementation and not the interface? I think a lot of you are saying we're in fact injecting the interface but the configuration makes you specify the implementation of that interface ..not at runtime .. it is hardcoded during compile time.</source>
          <target state="translated">Возвращаясь к первому вопросу.Если использование новой функции object()плохо,то почему мы внедряем реализацию,а не интерфейс? Я думаю,что многие из вас говорят,что мы на самом деле внедряем интерфейс,но конфигурация заставляет вас указывать реализацию этого интерфейса ...не во время выполнения ...это жестко закодировано во время компиляции.</target>
        </trans-unit>
        <trans-unit id="28843d4be0ee34f253cca7cab2361c2a39ee4828" translate="yes" xml:space="preserve">
          <source>Hard for test &lt;code&gt;Client&lt;/code&gt; class</source>
          <target state="translated">Хард для тестирования &lt;code&gt;Client&lt;/code&gt; класса</target>
        </trans-unit>
        <trans-unit id="4aed8ebadb57ba9dd2776c20874fb02210f043c0" translate="yes" xml:space="preserve">
          <source>Here is the example of how the above code would look like:</source>
          <target state="translated">Приведем пример того,как будет выглядеть вышеприведенный код:</target>
        </trans-unit>
        <trans-unit id="43c80abc12795e6e4cb2a72b1e6d9012d550d4e0" translate="yes" xml:space="preserve">
          <source>Here we basically inject(pass) our dependency(Engine instance) to Car constructor. So now our classes have loose coupling between objects and their dependencies, and we can easily add new types of engines without changing the Car class.</source>
          <target state="translated">Здесь мы в основном впрыскиваем (передаем)нашу зависимость (экземпляр двигателя)в конструктор автомобиля.Так что теперь наши классы имеют свободную связь между объектами и их зависимостями,и мы можем легко добавлять новые типы двигателей без изменения класса Car.</target>
        </trans-unit>
        <trans-unit id="371a2ec52294658d0a3b4228a46b7d8f33efffe9" translate="yes" xml:space="preserve">
          <source>Here's a simple C# implementation. Given the below Consuming class:</source>
          <target state="translated">Вот простая реализация C#.Ниже приведен класс Consuming:</target>
        </trans-unit>
        <trans-unit id="922004128193bca294dd5fdb14c71cac1cae1545" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;Car&lt;/code&gt; object &lt;em&gt;is responsible for creating the dependent objects.&lt;/em&gt;</source>
          <target state="translated">Здесь объект &lt;code&gt;Car&lt;/code&gt; &lt;em&gt;отвечает за создание зависимых объектов.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0969f6c9b11047ca63ee874c7cf8c550f36eaef" translate="yes" xml:space="preserve">
          <source>Here, we are &lt;strong&gt;injecting&lt;/strong&gt; the &lt;strong&gt;dependencies&lt;/strong&gt; (Wheel and Battery) at runtime. Hence the term : &lt;em&gt;Dependency Injection.&lt;/em&gt;</source>
          <target state="translated">Здесь мы &lt;strong&gt;вводим&lt;/strong&gt; &lt;strong&gt;зависимости&lt;/strong&gt; (колесо и батарея) во время выполнения. Отсюда и термин: &lt;em&gt;введение зависимости.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="379dffc1a3970a2596b05e27d433878025eb9945" translate="yes" xml:space="preserve">
          <source>High cohesion and loose coupling.</source>
          <target state="translated">Высокая когезия и неплотное соединение.</target>
        </trans-unit>
        <trans-unit id="00bf8b24a1d88295bc7cfc6557e03947a6402c26" translate="yes" xml:space="preserve">
          <source>How Dependency Injection works in Spring:</source>
          <target state="translated">Как работает инъекция зависимостей весной:</target>
        </trans-unit>
        <trans-unit id="57367ae4f39a638d3dbf05ee497ca936efcff588" translate="yes" xml:space="preserve">
          <source>However, we still use &lt;code&gt;new Service()&lt;/code&gt; many time and it is not good when change &lt;code&gt;Service&lt;/code&gt; constructor. To prevent it, we can use DI injector like</source>
          <target state="translated">Тем не менее, мы все еще используем &lt;code&gt;new Service()&lt;/code&gt; много раз, и это не очень хорошо при изменении конструктора &lt;code&gt;Service&lt;/code&gt; . Чтобы предотвратить это, мы можем использовать инжектор DI, как</target>
        </trans-unit>
        <trans-unit id="f0d455ffdb1c3dbcd06e6b82c66932dc9c227efa" translate="yes" xml:space="preserve">
          <source>I know there are already many answers, but I found this very helpful: &lt;a href=&quot;http://tutorials.jenkov.com/dependency-injection/index.html&quot;&gt;http://tutorials.jenkov.com/dependency-injection/index.html&lt;/a&gt;</source>
          <target state="translated">Я знаю, что ответов уже много, но я нашел это очень полезным: &lt;a href=&quot;http://tutorials.jenkov.com/dependency-injection/index.html&quot;&gt;http://tutorials.jenkov.com/dependency-injection/index.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed04f29160674f83a072681c6eb371dd9cb26716" translate="yes" xml:space="preserve">
          <source>I think since everyone has written for DI, let me ask a few questions..</source>
          <target state="translated">Думаю,раз уж все написали для детектива,позвольте мне задать несколько вопросов...</target>
        </trans-unit>
        <trans-unit id="2e46bcee2ea4c8bc4943d46d73203933dc4b2714" translate="yes" xml:space="preserve">
          <source>I would propose a slightly different, short and precise definition of what Dependency Injection is, focusing on the primary goal, not on the technical means (following along from &lt;a href=&quot;https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f&quot;&gt;here&lt;/a&gt;):</source>
          <target state="translated">Я бы предложил несколько иное, краткое и точное определение понятия &amp;laquo;внедрение зависимостей&amp;raquo;, сосредоточив внимание на основной цели, а не на технических средствах (следуя далее):</target>
        </trans-unit>
        <trans-unit id="af50e26570dc36b5b468480dbae632233aa97929" translate="yes" xml:space="preserve">
          <source>IOC is a general concept and it can be expressed in many different ways and Dependency Injection is one concrete example of IOC.</source>
          <target state="translated">МОК-это общее понятие,которое может выражаться самыми разными способами,и одним из конкретных примеров МОК является &quot;инъекция зависимости&quot;.</target>
        </trans-unit>
        <trans-unit id="0718ee8859576506cf86f7bd25325cd7eca7c302" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dependent.sh&lt;/code&gt; script used dependencies directly, the approach would be called &lt;em&gt;dependency lookup&lt;/em&gt; (which is opposite to &lt;em&gt;dependency injection&lt;/em&gt;):</source>
          <target state="translated">Если сценарий &lt;code&gt;dependent.sh&lt;/code&gt; .sh использует зависимости напрямую, этот подход будет называться &lt;em&gt;поиском зависимостей&lt;/em&gt; (что противоположно &lt;em&gt;внедрению зависимостей&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="ed73d2934d77992080e551028a74bcbaafd9ce4d" translate="yes" xml:space="preserve">
          <source>If Aproperty of AClass is not injected, is it harder to mock it out?</source>
          <target state="translated">Если не впрыскивать Аппарат АК-класса,трудно ли его высмеять?</target>
        </trans-unit>
        <trans-unit id="327557f3bb6a180cff634bb5925c6178d29f71c3" translate="yes" xml:space="preserve">
          <source>If lifespan control of dependencies by the consuming class needs to be retained, control can be re-established by injecting an (abstract) factory for creating the dependency class instances, into the consumer class. The consumer will be able to obtain instances via a &lt;code&gt;Create&lt;/code&gt; on the factory as needed, and dispose of these instances once complete.</source>
          <target state="translated">Если необходимо сохранить контроль продолжительности жизни класса-потребителя, управление может быть восстановлено путем внедрения (абстрактной) фабрики для создания экземпляров класса зависимости в класс-потребитель. Потребитель сможет получать экземпляры через &lt;code&gt;Create&lt;/code&gt; на фабрике по мере необходимости и утилизировать эти экземпляры после завершения.</target>
        </trans-unit>
        <trans-unit id="17ad58325899b3161d70302101921cd886c5bcce" translate="yes" xml:space="preserve">
          <source>If we use the first one we need to open the machine to change the reel.
if we opt for the second one, that is placing a hook for reel, we are getting an added benefit of playing any music by changing the reel. and also reducing the function only to playing whatever in the reel.</source>
          <target state="translated">Если мы используем первый,нам нужно открыть машину для замены катушки.если мы выберем второй,то есть поставим крючок для катушки,мы получаем дополнительное преимущество от воспроизведения любой музыки,меняя катушку.а также уменьшая функцию только для того,чтобы играть все,что находится в катушке.</target>
        </trans-unit>
        <trans-unit id="8114d9a89619251a62658a6e49b95469bb138929" translate="yes" xml:space="preserve">
          <source>If you occasionally work outside of Java, recall how &lt;code&gt;source&lt;/code&gt; is often used in many scripting languages (Shell, Tcl, etc., or even &lt;code&gt;import&lt;/code&gt; in Python misused for this purpose).</source>
          <target state="translated">Если вы время от времени работаете вне Java, вспомните, как &lt;code&gt;source&lt;/code&gt; часто используется во многих языках сценариев (Shell, Tcl и т. Д., Или даже &lt;code&gt;import&lt;/code&gt; в Python, неправильно используемый для этой цели).</target>
        </trans-unit>
        <trans-unit id="b06602d95600aa4bf8101370b37215812a7573e0" translate="yes" xml:space="preserve">
          <source>If you use use &lt;code&gt;Constructor Injection&lt;/code&gt;, the &lt;code&gt;Service&lt;/code&gt; object is created when &lt;code&gt;Client&lt;/code&gt; created, sometime we use function in &lt;code&gt;Client&lt;/code&gt; class without use &lt;code&gt;Service&lt;/code&gt; so created &lt;code&gt;Service&lt;/code&gt; is wasted</source>
          <target state="translated">Если вы используете &lt;code&gt;Constructor Injection&lt;/code&gt; , объект &lt;code&gt;Service&lt;/code&gt; создается при создании &lt;code&gt;Client&lt;/code&gt; , иногда мы используем функцию в классе &lt;code&gt;Client&lt;/code&gt; без использования &lt;code&gt;Service&lt;/code&gt; , поэтому созданная &lt;code&gt;Service&lt;/code&gt; теряется</target>
        </trans-unit>
        <trans-unit id="0673d4f21f33e89f895b29060653f72b9912e5ee" translate="yes" xml:space="preserve">
          <source>If you use use &lt;code&gt;Constructor Injection&lt;/code&gt;, when you look at constructor of &lt;code&gt;Client&lt;/code&gt;, you will see how many dependency of &lt;code&gt;Client&lt;/code&gt; class</source>
          <target state="translated">Если вы используете &lt;code&gt;Constructor Injection&lt;/code&gt; , когда вы посмотрите на конструктор &lt;code&gt;Client&lt;/code&gt; , вы увидите, сколько зависит класс &lt;code&gt;Client&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe36ce97b13993591149a7d6ee89ed548e32abbb" translate="yes" xml:space="preserve">
          <source>In .Net, IoC containers are aware of protocols such as &lt;code&gt;IDisposable&lt;/code&gt; and will take on the responsibility of &lt;code&gt;Disposing&lt;/code&gt; dependencies in line with the configured lifespan management.</source>
          <target state="translated">В .Net контейнеры IoC знают о таких протоколах, как &lt;code&gt;IDisposable&lt;/code&gt; , и будут нести ответственность за &lt;code&gt;Disposing&lt;/code&gt; зависимостей в соответствии с настроенным управлением продолжительностью жизни.</target>
        </trans-unit>
        <trans-unit id="5874ec6c4d7578e3bf3f97834e478c385a3a81da" translate="yes" xml:space="preserve">
          <source>In 2013, when I wrote this answer, this was a major theme on the &lt;a href=&quot;http://googletesting.blogspot.com/&quot;&gt;Google Testing Blog&lt;/a&gt;. It remains the biggest advantage to me, as programmers not always need the extra flexibility in their run-time design (for instance, for service locator or similar patterns). Programmers often need to isolate the classes during testing.</source>
          <target state="translated">В 2013 году, когда я написал этот ответ, эта тема была основной в &lt;a href=&quot;http://googletesting.blogspot.com/&quot;&gt;блоге Google Testing&lt;/a&gt; . Это остается для меня самым большим преимуществом, так как программистам не всегда нужна дополнительная гибкость в их дизайне времени выполнения (например, для поиска служб или подобных шаблонов). Программисты часто должны изолировать классы во время тестирования.</target>
        </trans-unit>
        <trans-unit id="8dd39bee0cfeef6f907d686e8fca98428110580e" translate="yes" xml:space="preserve">
          <source>In my opinion there is one only reason for DI frameworks: boiler plate reduction. With a well done factory system you can do the same, more controlled and more predictable as your preferred DI framework, DI frameworks promise code reduction (XML and annotations are source code too). The problem is this boiler plate reduction is just real in very very simple cases (one instance-per class and similar), sometimes in the real world picking the appropriated service object is not as easy as mapping a class to a singleton object.</source>
          <target state="translated">На мой взгляд,есть одна единственная причина для каркасов DI:уменьшение пластин котла.С хорошо сделанной заводской системой вы можете делать то же самое,более контролируемое и более предсказуемое,что и предпочитаемая вами DI-фреймворка,DI-фреймворки обещают сокращение кода (XML и аннотации тоже являются исходным кодом).Проблема в том,что такое уменьшение котельной пластины является реальным в очень простых случаях (один экземпляр-класс и т.п.),иногда в реальном мире выбор подходящего объекта сервиса не так прост,как привязка класса к одноэлементному объекту.</target>
        </trans-unit>
        <trans-unit id="945ef8affad419ee07825f142d4a71064182f46f" translate="yes" xml:space="preserve">
          <source>In other words with this approach is that our high level Car class is dependent on the lower level GasEngine class which violate Dependency Inversion Principle(DIP) from SOLID. DIP suggests that we should depend on abstractions, not concrete classes. So to satisfy this we introduce IEngine interface and rewrite code like below:</source>
          <target state="translated">Другими словами,при таком подходе наш класс автомобилей высокого уровня зависит от класса газовых двигателей более низкого уровня,которые нарушают принцип зависимостной инверсии (DIP)от SOLID.DIP предполагает,что мы должны зависеть от абстракций,а не от конкретных классов.Поэтому,чтобы это удовлетворить,мы вводим интерфейс IEngine и переписываем код,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="bc6abe43c16188f9d3e1b34e8bf777645960925f" translate="yes" xml:space="preserve">
          <source>In simple words dependency injection (DI) is the way to remove dependencies or tight coupling between different object. Dependency Injection gives a cohesive behavior to each object.</source>
          <target state="translated">Простыми словами,инъекция зависимостей (DI)-это способ устранения зависимостей или тесной связи между различными объектами.Инъекция зависимостей дает связующее поведение для каждого объекта.</target>
        </trans-unit>
        <trans-unit id="2e58974612fd6fe0036631984f3609c239eab907" translate="yes" xml:space="preserve">
          <source>In this example, the implementation of &lt;code&gt;PersonService::addManager&lt;/code&gt; and &lt;code&gt;PersonService::removeManager&lt;/code&gt; would need an instance of the &lt;code&gt;GroupMembershipService&lt;/code&gt; in order to do its work. Without Dependency Injection, the traditional way of doing this would be to instantiate a new &lt;code&gt;GroupMembershipService&lt;/code&gt; in the constructor of &lt;code&gt;PersonService&lt;/code&gt; and use that instance attribute in both functions. However, if the constructor of &lt;code&gt;GroupMembershipService&lt;/code&gt; has multiple things it requires, or worse yet, there are some initialization &quot;setters&quot; that need to be called on the &lt;code&gt;GroupMembershipService&lt;/code&gt;, the code grows rather quickly, and the &lt;code&gt;PersonService&lt;/code&gt; now depends not only on the &lt;code&gt;GroupMembershipService&lt;/code&gt; but also everything else that &lt;code&gt;GroupMembershipService&lt;/code&gt; depends on. Furthermore, the linkage to &lt;code&gt;GroupMembershipService&lt;/code&gt; is hardcoded into the &lt;code&gt;PersonService&lt;/code&gt; which means that you can't &quot;dummy up&quot; a &lt;code&gt;GroupMembershipService&lt;/code&gt; for testing purposes, or to use a strategy pattern in different parts of your application.</source>
          <target state="translated">В этом примере реализации &lt;code&gt;PersonService::addManager&lt;/code&gt; и &lt;code&gt;PersonService::removeManager&lt;/code&gt; потребуется экземпляр GroupMembershipService для выполнения своей работы. Без внедрения зависимости традиционный способ сделать это - создать новый &lt;code&gt;GroupMembershipService&lt;/code&gt; в конструкторе &lt;code&gt;PersonService&lt;/code&gt; и использовать этот атрибут экземпляра в обеих функциях. Однако, если конструктор &lt;code&gt;GroupMembershipService&lt;/code&gt; имеет несколько вещей, которые ему требуются, или, что еще хуже, существуют некоторые &amp;laquo;установщики&amp;raquo; инициализации, которые необходимо вызывать в &lt;code&gt;GroupMembershipService&lt;/code&gt; , код растет довольно быстро, и &lt;code&gt;PersonService&lt;/code&gt; теперь зависит не только от &lt;code&gt;GroupMembershipService&lt;/code&gt; , но и также все остальное, от чего зависит &lt;code&gt;GroupMembershipService&lt;/code&gt; . Кроме того, связь с &lt;code&gt;GroupMembershipService&lt;/code&gt; жестко запрограммирована в &lt;code&gt;PersonService&lt;/code&gt; , что означает, что вы не можете &amp;laquo; подставить&amp;raquo; GroupMembershipService для целей тестирования или для использования шаблона стратегии в различных частях вашего приложения.</target>
        </trans-unit>
        <trans-unit id="3945063a7ab43002ea39d3d24e40ac75108803b6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;source&lt;/code&gt;-ing implementation script directly in the dependent one, you use an &lt;code&gt;injector.sh&lt;/code&gt; &quot;container&quot; which wraps both &quot;components&quot;:</source>
          <target state="translated">Вместо сценария реализации с &lt;code&gt;source&lt;/code&gt; непосредственно в зависимом, вы используете &amp;laquo;контейнер&amp;raquo; injector.sh, который оборачивает оба &amp;laquo;компонента&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="a32a54b9d71ad0ec3f835fab1768f5cabb2ce808" translate="yes" xml:space="preserve">
          <source>Interface of book:</source>
          <target state="translated">Интерфейс книги:</target>
        </trans-unit>
        <trans-unit id="87ce48016c0abd40898b021fa36510c98da3c3f6" translate="yes" xml:space="preserve">
          <source>Inversion of Control (IOC)</source>
          <target state="translated">Инверсия управления (МОК)</target>
        </trans-unit>
        <trans-unit id="c6f589e1a346ddca493c03b3d62843ee5c496a03" translate="yes" xml:space="preserve">
          <source>It helps to develop high quality components since they are independently developed they are properly tested.</source>
          <target state="translated">Это помогает разрабатывать высококачественные компоненты,так как они самостоятельно разрабатываются и тестируются должным образом.</target>
        </trans-unit>
        <trans-unit id="fe52190c660276a5234fd25313a1d7025785a9b1" translate="yes" xml:space="preserve">
          <source>It helps to replace the component with another if one fails.</source>
          <target state="translated">Помогает заменить компонент на другой,если один из них выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="12a6359f43afb8218185323269fc89edefe3a5f9" translate="yes" xml:space="preserve">
          <source>It is harder to isolate components in unit testing without dependency injection.</source>
          <target state="translated">Труднее выделить компоненты в модульном тестировании без впрыска зависимостей.</target>
        </trans-unit>
        <trans-unit id="5315cf7c004aa65a5379bfbf68f8aa368640746e" translate="yes" xml:space="preserve">
          <source>It means that objects should only have as many dependencies as is needed to do their job and the dependencies should be few. Furthermore, an object&amp;rsquo;s dependencies should be on interfaces and not on &amp;ldquo;concrete&amp;rdquo; objects, when possible. (A concrete object is any object created with the keyword new.) Loose coupling promotes greater reusability, easier maintainability, and allows you to easily provide &amp;ldquo;mock&amp;rdquo; objects in place of expensive services.</source>
          <target state="translated">Это означает, что у объектов должно быть только столько зависимостей, сколько необходимо для их работы, и зависимостей должно быть немного. Кроме того, зависимости объекта должны быть на интерфейсах, а не на &amp;laquo;конкретных&amp;raquo; объектах, когда это возможно. (Конкретный объект - это любой объект, созданный с помощью ключевого слова new.) Свободное связывание способствует большей возможности повторного использования, упрощает обслуживание и позволяет легко предоставлять &amp;laquo;фиктивные&amp;raquo; объекты вместо дорогих услуг.</target>
        </trans-unit>
        <trans-unit id="150a68e160c591532e3796e7a048e6a35a2b271c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s the technique of passing objects dependencies to its constructor.</source>
          <target state="translated">Это техника передачи зависимостей объекта его конструктору.</target>
        </trans-unit>
        <trans-unit id="aa27b9815cfca97bc09894174bbc5029fa7ea762" translate="yes" xml:space="preserve">
          <source>Last words</source>
          <target state="translated">Последние слова</target>
        </trans-unit>
        <trans-unit id="101f50890da169b761f4204e13794649557a2715" translate="yes" xml:space="preserve">
          <source>Let's imagine that you want to go fishing:</source>
          <target state="translated">Давай представим,что ты хочешь пойти на рыбалку:</target>
        </trans-unit>
        <trans-unit id="3fb3f6b5b730e2955d7fc11411b3be83f4438c60" translate="yes" xml:space="preserve">
          <source>Let's try simple example with &lt;strong&gt;Car&lt;/strong&gt; and &lt;strong&gt;Engine&lt;/strong&gt; classes, any car need an engine to go anywhere, at least for now. So below how code will look without dependency injection.</source>
          <target state="translated">Давайте попробуем простой пример с классами &lt;strong&gt;Car&lt;/strong&gt; и &lt;strong&gt;Engine&lt;/strong&gt; : любой автомобиль нуждается в двигателе, чтобы ехать куда угодно, по крайней мере, на данный момент. Ниже показано, как будет выглядеть код без внедрения зависимостей.</target>
        </trans-unit>
        <trans-unit id="0743bd397ad0bae662ab3527bca83ae55d5c97e6" translate="yes" xml:space="preserve">
          <source>Like wise dependency injection is the  process of externalizing the dependencies to focus only on the specific functionality of the component so that independent components can be coupled together to form a complex system.</source>
          <target state="translated">Подобно мудрому введению зависимостей-это процесс экстернализации зависимостей,чтобы сконцентрироваться только на специфической функциональности компонента,так что независимые компоненты могут быть соединены вместе,чтобы сформировать сложную систему.</target>
        </trans-unit>
        <trans-unit id="a77c6a3de980ebb5dc42a0edc1ee999977beda1e" translate="yes" xml:space="preserve">
          <source>Make test easier</source>
          <target state="translated">Сделать тест легче</target>
        </trans-unit>
        <trans-unit id="78928cbc17b1ac78636f5d533c2894682e0a6266" translate="yes" xml:space="preserve">
          <source>Making things as components and to combine to form a large systems with high capabilities.</source>
          <target state="translated">Делать вещи как компоненты и объединять их в большие системы с большими возможностями.</target>
        </trans-unit>
        <trans-unit id="04faf2b31cb2eb82166edebcf0b8fa045081749b" translate="yes" xml:space="preserve">
          <source>Modifying &lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James&lt;/a&gt; Example for Switch and Bulb:</source>
          <target state="translated">Модификация &lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;Джеймса&lt;/a&gt; для Switch и Bulb:</target>
        </trans-unit>
        <trans-unit id="38837e9f2c549ac0d1e7a54cf6258ccf4df0c3f2" translate="yes" xml:space="preserve">
          <source>NOTE:
It is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the if we use annotation based than @Required annotation on a setter can be used to make setters as a required dependencies.</source>
          <target state="translated">ЗАМЕЧАНИЕ:Хорошее эмпирическое правило-использовать аргументы конструктора для обязательных зависимостей и сеттеры для необязательных зависимостей.Обратите внимание,что если мы используем аннотацию,основанную на @Required annotation на сеттере,то она может быть использована для создания сеттеров в качестве обязательных зависимостей.</target>
        </trans-unit>
        <trans-unit id="8360dc1497a3895cbb0ae2365dd63cd62fb85433" translate="yes" xml:space="preserve">
          <source>Next we can have many kind of books; one of type is fiction:</source>
          <target state="translated">Далее у нас может быть много книг;одна из них-художественная:</target>
        </trans-unit>
        <trans-unit id="381bcfef8f062363621c6445f025fc1ec1ecb6e0" translate="yes" xml:space="preserve">
          <source>No Dependency:</source>
          <target state="translated">Никакой зависимости:</target>
        </trans-unit>
        <trans-unit id="148aedccb1c30aae863f891e9230b9918c3c26e5" translate="yes" xml:space="preserve">
          <source>Note that the constructor accepts an interface and not concrete object. Also, note that an exception is thrown if the orderDao parameter is null. This emphasizes the importance of receiving a valid dependency. Constructor Injection is, in my opinion, the preferred mechanism for giving an object its dependencies. It is clear to the developer while invoking the object which dependencies need to be given to the &amp;ldquo;Person&amp;rdquo; object for proper execution.</source>
          <target state="translated">Обратите внимание, что конструктор принимает интерфейс, а не конкретный объект. Также обратите внимание, что возникает исключение, если параметр orderDao имеет значение null. Это подчеркивает важность получения действительной зависимости. По моему мнению, Constructor Injection является предпочтительным механизмом для предоставления объекту его зависимостей. При вызове объекта для разработчика ясно, какие зависимости необходимо передать объекту &amp;laquo;Person&amp;raquo; для правильного выполнения.</target>
        </trans-unit>
        <trans-unit id="52a2afd82b94f21efe4003a5f77702e673692a03" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;DataSourceImpl&lt;/code&gt; instantiation is moved into a constructor. The constructor takes four parameters which are the four values needed by the &lt;code&gt;DataSourceImpl&lt;/code&gt;. Though the &lt;code&gt;MyDao&lt;/code&gt; class still depends on these four values, it no longer satisfies these dependencies itself. They are provided by whatever class creating a &lt;code&gt;MyDao&lt;/code&gt; instance.</source>
          <target state="translated">Обратите внимание, как экземпляр &lt;code&gt;DataSourceImpl&lt;/code&gt; перемещается в конструктор. Конструктор принимает четыре параметра, которые являются четырьмя значениями, необходимыми для &lt;code&gt;DataSourceImpl&lt;/code&gt; . Хотя класс &lt;code&gt;MyDao&lt;/code&gt; все еще зависит от этих четырех значений, он сам больше не удовлетворяет этим зависимостям. Они предоставляются любым классом, создающим экземпляр &lt;code&gt;MyDao&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9bf32a5cd289e031981b513bdc34931168fff08" translate="yes" xml:space="preserve">
          <source>Now a days these concept forms the basis of well known frameworks in programming world.
The Spring Angular etc are the well-known software frameworks built on the top of this concept</source>
          <target state="translated">Сейчас эта концепция лежит в основе хорошо известных фреймворков в мире программирования.The Spring Angular и т.д.-известные программные фреймворки,построенные на вершине этой концепции.</target>
        </trans-unit>
        <trans-unit id="3f568c10c487626292e158f1321b91077bbdfb85" translate="yes" xml:space="preserve">
          <source>Now our Car class is dependent on only the IEngine interface, not a specific implementation of engine. 
Now, the only trick is how do we create an instance of the Car and give it an actual concrete Engine class like GasEngine or ElectricityEngine. That's where &lt;strong&gt;Dependency Injection&lt;/strong&gt; comes in.</source>
          <target state="translated">Теперь наш класс Car зависит только от интерфейса IEngine, а не от конкретной реализации движка. Теперь единственная хитрость заключается в том, как нам создать экземпляр Car и присвоить ему конкретный класс Engine, такой как GasEngine или ElectricityEngine. Вот где &lt;strong&gt;вводится зависимость&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="294a5073bdc9a6339404dadb5c21756e099a6869" translate="yes" xml:space="preserve">
          <source>Now subscriber can have association to the book:</source>
          <target state="translated">Теперь абонент может иметь связь с книгой:</target>
        </trans-unit>
        <trans-unit id="3c4442a341c09f2a8337cd53e8c9d7b14c1f8d57" translate="yes" xml:space="preserve">
          <source>Now the problem is that dependent &quot;component&quot; has to perform initialization itself.</source>
          <target state="translated">Теперь проблема в том,что зависимый &quot;компонент&quot; должен сам выполнять инициализацию.</target>
        </trans-unit>
        <trans-unit id="244d7754a9d504a1f45d44ae1bdf5c41e24ccff1" translate="yes" xml:space="preserve">
          <source>Now, this code is already follow &lt;code&gt;Dependency Injection&lt;/code&gt; and it is easier for test &lt;code&gt;Client&lt;/code&gt; class.</source>
          <target state="translated">Теперь этот код уже соответствует &lt;code&gt;Dependency Injection&lt;/code&gt; , и его легче тестировать в классе &lt;code&gt;Client&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01cf15bf0efc21fae58f14423988c7d39bcbc525" translate="yes" xml:space="preserve">
          <source>Objects are once loaded in Spring container and then we reuse them whenever we need them by fetching those objects from Spring container using getBean(String beanName) method.</source>
          <target state="translated">Объекты один раз загружаются в контейнер Spring,а затем мы повторно используем их,когда они нам нужны,извлекая эти объекты из контейнера Spring с помощью метода getBean(String beanName).</target>
        </trans-unit>
        <trans-unit id="6cf40f56e8e4c0d23d55ca133079493612e29b47" translate="yes" xml:space="preserve">
          <source>One common alternative is defining a &lt;strong&gt;do-nothing constructor&lt;/strong&gt;. Dependency injection can be done through setters. (h/t @MikeVella).</source>
          <target state="translated">Одна из распространенных альтернатив - определение конструктора &lt;strong&gt;, который ничего не делает&lt;/strong&gt; . Внедрение зависимости может быть сделано через сеттеры. (h / t @MikeVella).</target>
        </trans-unit>
        <trans-unit id="e85085db2ea4a2409b650b063f440106471f7755" translate="yes" xml:space="preserve">
          <source>One consequence of DI is that the lifespan management of dependency object instances is no longer controlled by a consuming class, as the dependency object is now passed into the consuming class (via constructor or setter injection).</source>
          <target state="translated">Одним из последствий DI является то,что управление жизненным циклом экземпляров объектов зависимостей больше не контролируется классом-потребителем,так как объект зависимостей теперь передается в класс-потребитель (через инжектор конструктора или сеттера).</target>
        </trans-unit>
        <trans-unit id="0e87d7a02651091658f2b2651ada0186577a5e58" translate="yes" xml:space="preserve">
          <source>One requirement is that the services must be parametrised by their dependencies. What this means exactly depends on the language and approach taken in a given system. Usually, this takes the form of constructor parameters, but using setters is also an option. This also means that the dependencies of a service are hidden (when invoking a service method) from the users of the service.</source>
          <target state="translated">Одно из требований состоит в том,что услуги должны быть параметризованы их зависимостями.Что именно это означает,зависит от языка и подхода,принятого в данной системе.Обычно это принимает форму параметров конструктора,но использование сеттеров также является опцией.Это также означает,что зависимости сервиса скрыты (при вызове метода сервиса)от пользователей сервиса.</target>
        </trans-unit>
        <trans-unit id="159c3350bcfe189a7b428c479d9201ea48faf507" translate="yes" xml:space="preserve">
          <source>Or, lifespan control of dependency instances can be relinquished to an IoC container (more about this below).</source>
          <target state="translated">Или же,контроль срока службы экземпляров зависимостей может быть передан контейнеру IoC (подробнее об этом ниже).</target>
        </trans-unit>
        <trans-unit id="93d225da5e27eb45ee9a17d2a3dcf555280a505b" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;myObject&lt;/code&gt; in as an argument to the constructor</source>
          <target state="translated">Передача &lt;code&gt;myObject&lt;/code&gt; в качестве аргумента конструктору</target>
        </trans-unit>
        <trans-unit id="21b3ab899d3e7a2f72bd43dcfb14037ae113a442" translate="yes" xml:space="preserve">
          <source>Practically, every design pattern separates concerns to make future changes affect minimum files.</source>
          <target state="translated">Практически каждый шаблон проектирования разделяет опасения,чтобы будущие изменения повлияли на минимальное количество файлов.</target>
        </trans-unit>
        <trans-unit id="d9f5010baa893f9ad98e960248019e1ff603968f" translate="yes" xml:space="preserve">
          <source>Previously we are writing code like this</source>
          <target state="translated">Раньше мы так писали код.</target>
        </trans-unit>
        <trans-unit id="533e261383d8b2d3e59f53c2e9d59c559259294d" translate="yes" xml:space="preserve">
          <source>Programmers have understood the dependency obfuscation requirement for years and many alternative solutions have evolved both before and after dependency injection was conceived. There are Factory patterns but there are also many options using ThreadLocal where no injection to a particular instance is needed - the dependency is effectively injected into the thread which has the benefit of making the object available (via convenience static getter methods) to &lt;em&gt;any&lt;/em&gt; class that requires it without having to add annotations to the classes that require it and set up intricate XML 'glue' to make it happen. When your dependencies are required for persistence (JPA/JDO or whatever) it allows you to achieve 'tranaparent persistence' much easier and with domain model and business model classes made up purely of POJOs (i.e. no framework specific/locked in annotations).</source>
          <target state="translated">Программисты понимали требование запутывания зависимостей в течение многих лет, и многие альтернативные решения развивались как до, так и после зачатия внедрения зависимости. Существуют фабричные шаблоны, но есть также много опций, использующих ThreadLocal, где не требуется внедрение в конкретный экземпляр - зависимость эффективно внедряется в поток, что дает преимущество в том, что объект становится доступным (с помощью удобных статических методов получения) для &lt;em&gt;любого&lt;/em&gt; класса, который требует этого, не добавляя аннотации к классам, которые этого требуют, и настраивая сложный XML-клей, чтобы это произошло. Когда ваши зависимости требуются для персистентности (JPA / JDO и т. Д.), Это позволяет вам намного проще добиться &amp;laquo;прозрачной персистентности&amp;raquo;, а доменная модель и классы бизнес-моделей состоят исключительно из POJO (то есть, нет специфичной для фреймворка / заблокированной в аннотациях).</target>
        </trans-unit>
        <trans-unit id="6fbc5d43864c0ac8fa3636a03653618ac21757e7" translate="yes" xml:space="preserve">
          <source>Setter Injection</source>
          <target state="translated">Впрыск сеттера</target>
        </trans-unit>
        <trans-unit id="5a34561d27d0c82f9fb28bebbfcc20bc74ddc2a1" translate="yes" xml:space="preserve">
          <source>Setter Injection does not force dependencies to be passed to the constructor. Instead, the dependencies are set onto public properties exposed by the object in need. As implied previously, the primary motivators for doing this include:</source>
          <target state="translated">Инжекция сеттера не заставляет передавать конструктору зависимости.Вместо этого,зависимости устанавливаются на публичные свойства,выставляемые нужным объектом.Как подразумевалось ранее,первичные мотиваторы для этого включают в себя:</target>
        </trans-unit>
        <trans-unit id="3ba4002363cebe927c87f145292fe23279da4fc4" translate="yes" xml:space="preserve">
          <source>Setter injection</source>
          <target state="translated">Впрыск сеттера</target>
        </trans-unit>
        <trans-unit id="b8cb1079b38327369ec318ba6d8358b7e9c456ba" translate="yes" xml:space="preserve">
          <source>Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.</source>
          <target state="translated">DI на основе Setter выполняется контейнером,вызывающим методы Setter на бобах после вызова конструктора нулевого размера или статического метода фабрики нулевого размера для инстанцирования бобов.</target>
        </trans-unit>
        <trans-unit id="de72ea9e60d3b0389fb7873c1d21268b088fa6d4" translate="yes" xml:space="preserve">
          <source>Simple</source>
          <target state="translated">Simple</target>
        </trans-unit>
        <trans-unit id="53b5b8696132c7f14a83c7efaf53a8df90f22d0e" translate="yes" xml:space="preserve">
          <source>So in the end &lt;strong&gt;Dependency injection&lt;/strong&gt; is just a technique for
  achieving loose coupling between objects and their dependencies.
  Rather than directly instantiating dependencies that class needs in
  order to perform its actions, dependencies are provided to the class
  (most often) via constructor injection.</source>
          <target state="translated">Таким образом, в конечном итоге &lt;strong&gt;внедрение зависимостей&lt;/strong&gt; - это просто метод достижения слабой связи между объектами и их зависимостями. Вместо того, чтобы непосредственно создавать экземпляры зависимостей, которые нужны классу для выполнения его действий, зависимости предоставляются классу (чаще всего) посредством внедрения конструктора.</target>
        </trans-unit>
        <trans-unit id="7da9dbfe443ff7c3e18888265c12bc4c6d7027ed" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html&quot;&gt;Understanding dependency injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Источник: &lt;em&gt;&lt;a href=&quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html&quot;&gt;Понимание внедрения зависимости&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5974b915c67629f3fb291858490061a4113d7288" translate="yes" xml:space="preserve">
          <source>Specifically, in the paradigm of Robert C Martin's &lt;a href=&quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;SOLID principles of Object Oriented Design&lt;/a&gt;, &lt;code&gt;DI&lt;/code&gt; is one of the possible implementations of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;Dependency Inversion Principle (DIP)&lt;/a&gt;. The &lt;a href=&quot;https://stackoverflow.com/q/27978841/314291&quot;&gt;DIP is the &lt;code&gt;D&lt;/code&gt; of the &lt;code&gt;SOLID&lt;/code&gt; mantra&lt;/a&gt;  - other DIP implementations include the Service Locator, and Plugin patterns.</source>
          <target state="translated">В частности, в парадигме &lt;a href=&quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;SOLID принципов&lt;/a&gt; Роберта С. Мартина объектно-ориентированного проектирования , &lt;code&gt;DI&lt;/code&gt; является одной из возможных реализаций &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;принципа инверсии зависимости (DIP)&lt;/a&gt; . &lt;a href=&quot;https://stackoverflow.com/q/27978841/314291&quot;&gt;DIP - это &lt;code&gt;D&lt;/code&gt; &lt;code&gt;SOLID&lt;/code&gt; &lt;/a&gt; - другие реализации DIP включают в себя сервисный локатор и шаблоны плагинов.</target>
        </trans-unit>
        <trans-unit id="f4b86bb17c077dd81ce6f0d78a2ce285c974111f" translate="yes" xml:space="preserve">
          <source>Supporting dependency injection without having to modify the constructor of a legacy class.</source>
          <target state="translated">Поддержка инжекции зависимостей без необходимости изменения конструктора унаследованного класса.</target>
        </trans-unit>
        <trans-unit id="ad518a2bfe35a440dc057b8df89372141fdee4b1" translate="yes" xml:space="preserve">
          <source>Switch -&amp;gt; Bulb1 OR Bulb2 OR NightBulb (injected dependency)</source>
          <target state="translated">Переключатель -&amp;gt; Bulb1 ИЛИ Bulb2 ИЛИ NightBulb (введенная зависимость)</target>
        </trans-unit>
        <trans-unit id="1f8e6772695db9bb64683f23fba3fcc305250d9e" translate="yes" xml:space="preserve">
          <source>Switch -&amp;gt; PermanentBulb &lt;em&gt;//switch is directly connected to permanent bulb, testing not possible easily&lt;/em&gt;</source>
          <target state="translated">Switch -&amp;gt; PermanentBulb &lt;em&gt;// переключатель напрямую подключен к постоянной лампе, тестирование невозможно&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c4c8437fc5346d142f060317a5f268dabd0d961" translate="yes" xml:space="preserve">
          <source>Switch needs to know beforehand which bulb I am connected to (hard-coded dependency). So,</source>
          <target state="translated">Переключатель должен заранее знать,к какой лампе я подключен (жесткокодифференцированная зависимость).Итак,</target>
        </trans-unit>
        <trans-unit id="4d7495d3cc88447e63485a25f72ecf731763671c" translate="yes" xml:space="preserve">
          <source>Switch only knows I need to turn on/off whichever Bulb is passed to me. So,</source>
          <target state="translated">Выключатель только знает,что мне нужно включить ту лампочку,которая мне передается.Так что..,</target>
        </trans-unit>
        <trans-unit id="4c1913b877e14f9958c5e5bb105932590816f59f" translate="yes" xml:space="preserve">
          <source>The &quot;component&quot;'s source code is neither &lt;strong&gt;clean&lt;/strong&gt; nor &lt;strong&gt;stable&lt;/strong&gt; because every changes in initialization of dependencies requires new release for &quot;components&quot;'s source code file as well.</source>
          <target state="translated">Исходный код &amp;laquo;компонента&amp;raquo; не является ни &lt;strong&gt;чистым,&lt;/strong&gt; ни &lt;strong&gt;стабильным,&lt;/strong&gt; потому что каждое изменение в инициализации зависимостей требует новой версии и для файла исходного кода &amp;laquo;компонентов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="73264d2706ed99c7c3cf1d84437da53a400c9eb1" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Dependency Injection&amp;rdquo; (DI) is also known as &amp;ldquo;Inversion of Control&amp;rdquo; (IoC), can be used as a technique for encouraging this loose coupling.</source>
          <target state="translated">&amp;laquo;Инъекция зависимостей&amp;raquo; (DI) также известна как &amp;laquo;Инверсия контроля&amp;raquo; (IoC) и может использоваться в качестве метода для поощрения этой слабой связи.</target>
        </trans-unit>
        <trans-unit id="4ce8e8f58189f93cac9d7dcd25f82fad19ea42c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;archive_files&lt;/code&gt;&lt;em&gt;dependency&lt;/em&gt; has just been &lt;em&gt;injected&lt;/em&gt; into &lt;em&gt;dependent&lt;/em&gt; script.</source>
          <target state="translated">&lt;em&gt;Зависимость&lt;/em&gt; &lt;code&gt;archive_files&lt;/code&gt; была только что вставлена в &lt;em&gt;зависимый&lt;/em&gt; скрипт.</target>
        </trans-unit>
        <trans-unit id="57f5c2a4c3648bf44c57e0b10c21224b7534177d" translate="yes" xml:space="preserve">
          <source>The above image is an image of Reel-to-reel portable tape recorder, mid-20th century. &lt;a href=&quot;https://www.britannica.com/technology/tape-recorder&quot;&gt;Source&lt;/a&gt;.</source>
          <target state="translated">Это изображение представляет собой портативный магнитофон Reel-to-reel, середина 20-го века. &lt;a href=&quot;https://www.britannica.com/technology/tape-recorder&quot;&gt;Источник&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc174d974fc2630ad90c3952d5479067c5370ff0" translate="yes" xml:space="preserve">
          <source>The accepted answer is a good one - but I would like to add to this that DI is very much like the classic avoiding of hardcoded constants in the code.</source>
          <target state="translated">Принятый ответ хорош-но я хотел бы добавить к этому,что DI очень похож на классический отказ от жестко закодированных констант в коде.</target>
        </trans-unit>
        <trans-unit id="a38ac33b8fba8d81022fa8e5992560f5f98cbdc3" translate="yes" xml:space="preserve">
          <source>The best analogy I can think of is the surgeon and his assistant(s) in an operation theater, where the surgeon is the main person and his assistant who provides the various surgical components when he needs it so that the surgeon can concentrate on the one thing he does best (surgery). Without the assistant the surgeon has to get the components himself every time he needs one.</source>
          <target state="translated">Лучшая аналогия,которую я могу придумать,это хирург и его ассистент(ы)в операционном театре,где хирург является главным человеком и его ассистент,который предоставляет различные хирургические компоненты,когда он нуждается в этом,чтобы хирург мог сконцентрироваться на том,что он делает лучше всего (операция).Без ассистента хирург каждый раз,когда он нуждается в компонентах,должен получать их сам.</target>
        </trans-unit>
        <trans-unit id="a41ea95353f5d528dfa619f0e43f5976252872f7" translate="yes" xml:space="preserve">
          <source>The best definition I've found so far is &lt;a href=&quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;one by James Shore&lt;/a&gt;:</source>
          <target state="translated">Лучшее определение, которое я нашел до сих пор, - это определение &lt;a href=&quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;Джеймса Шора&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="888a31b520ca5d4997c6aa72d7a98329f15bff71" translate="yes" xml:space="preserve">
          <source>The issue with this code that we tightly coupled to GasEngine and if we decide to change it to ElectricityEngine then we will need to rewrite Car class. And the bigger the application the more issues and headache we will have to add and use new type of engine.</source>
          <target state="translated">Проблема с этим кодом в том,что мы тесно связаны с GasEngine,и если мы решим изменить его на ElectricityEngine,то нам придется переписать класс Car.И чем больше приложение,тем больше проблем и головной боли нам придется добавлять и использовать новый тип двигателя.</target>
        </trans-unit>
        <trans-unit id="55cafcb834ee14f42eff09928fdaf624281b81f7" translate="yes" xml:space="preserve">
          <source>The key to DI-friendly code is to avoid static coupling of classes, and not to use new() for the creation of Dependencies</source>
          <target state="translated">Ключ к DI-дружественному коду-избегать статического связывания классов,а не использовать new()для создания зависимостей.</target>
        </trans-unit>
        <trans-unit id="5ca5815f45aca9074db82cb4273a806d37ea2c5b" translate="yes" xml:space="preserve">
          <source>The main benefit of the &lt;strong&gt;Dependency Injection&lt;/strong&gt; that classes are more loosely coupled, because they do not have hard-coded dependencies. This follows the Dependency Inversion Principle, which was mentioned above. Instead of referencing specific implementations, classes request abstractions (usually &lt;strong&gt;interfaces&lt;/strong&gt;) which are provided to them when the class is constructed.</source>
          <target state="translated">Основное преимущество &lt;strong&gt;внедрения зависимостей заключается в&lt;/strong&gt; том, что классы более слабо связаны, поскольку у них нет жестко закодированных зависимостей. Это следует принципу инверсии зависимости, который был упомянут выше. Вместо того, чтобы ссылаться на конкретные реализации, классы запрашивают абстракции (обычно &lt;strong&gt;интерфейсы&lt;/strong&gt; ), которые предоставляются им при создании класса.</target>
        </trans-unit>
        <trans-unit id="473698f3e91170575e3a1dd7c3f14effd0d4dbdd" translate="yes" xml:space="preserve">
          <source>The main benefits we achieved by using dependency injection.</source>
          <target state="translated">Основные преимущества,которых мы добились с помощью инъекций с иждивенцами.</target>
        </trans-unit>
        <trans-unit id="3a01d41764fb9f4deb184c6238b397910d66d4e7" translate="yes" xml:space="preserve">
          <source>The main purpose of the intermediate level is not just to pass in the dependencies to the constructor, but to list all the dependencies in &lt;em&gt;just one place&lt;/em&gt;, and to hide them from the coder (not to make the coder provide them).</source>
          <target state="translated">Основная цель промежуточного уровня - не просто передать зависимости конструктору, но перечислить все зависимости в &lt;em&gt;одном месте&lt;/em&gt; и спрятать их от кодера (чтобы кодер не предоставлял их).</target>
        </trans-unit>
        <trans-unit id="675567e15eedcab72deecf5182fe51cdda38c6b1" translate="yes" xml:space="preserve">
          <source>The module graph - the graph of service objects - is typically created on application startup. This can be done using a container, such as Spring, but can also be done manually, by passing parameters to object constructors. Both ways have their pros and cons, but a framework definitely isn&amp;rsquo;t necessary to use DI in your application.</source>
          <target state="translated">Граф модуля - граф сервисных объектов - обычно создается при запуске приложения. Это можно сделать с помощью контейнера, такого как Spring, но также можно сделать вручную, передав параметры конструкторам объектов. Оба способа имеют свои плюсы и минусы, но для использования DI в вашем приложении определенно не требуется фреймворк.</target>
        </trans-unit>
        <trans-unit id="1345d93e55da0a02f0e73cb3294e155c0fcd0c41" translate="yes" xml:space="preserve">
          <source>The objective of the DIP is to decouple tight, concrete dependencies between classes, and instead, to loosen the coupling by means of an abstraction, which can be achieved via an &lt;code&gt;interface&lt;/code&gt;, &lt;code&gt;abstract class&lt;/code&gt; or &lt;code&gt;pure virtual class&lt;/code&gt;, depending on the language and approach used.</source>
          <target state="translated">Цель DIP состоит в том, чтобы отделить жесткие конкретные зависимости между классами и вместо этого ослабить связь с помощью абстракции, которая может быть достигнута через &lt;code&gt;interface&lt;/code&gt; , &lt;code&gt;abstract class&lt;/code&gt; или &lt;code&gt;pure virtual class&lt;/code&gt; , в зависимости от используемого языка и подхода ,</target>
        </trans-unit>
        <trans-unit id="13ddfae2bc42d77fabc17f4670bf62cf40aa3c4a" translate="yes" xml:space="preserve">
          <source>The objects that we create in our applications (regardless if we use Java, C# or other object-oriented language) usually fall into one of two categories: stateless, static and global &amp;ldquo;service objects&amp;rdquo; (modules), and stateful, dynamic and local &amp;ldquo;data objects&amp;rdquo;.</source>
          <target state="translated">Объекты, которые мы создаем в наших приложениях (независимо от того, используем ли мы Java, C # или другой объектно-ориентированный язык), обычно попадают в одну из двух категорий: не имеющие состояния, статические и глобальные &amp;laquo;сервисные объекты&amp;raquo; (модули), и с состоянием, динамические и локальные &amp;laquo;Объекты данных&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fccd88c774cbd85630c6ee5e8c38793343e3457d" translate="yes" xml:space="preserve">
          <source>The person typing &quot;make bar&quot; doesn't need to know that bar depends on foo. The dependency was injected between &quot;make bar&quot; and gcc.</source>
          <target state="translated">Человеку,печатающему &quot;make bar&quot;,не обязательно знать,что бар зависит от фу.Зависимость была введена между &quot;make bar&quot; и gcc.</target>
        </trans-unit>
        <trans-unit id="c8b03c2d69af0fb222af1edc1d1a6a786e0d51c4" translate="yes" xml:space="preserve">
          <source>The popular answers are unhelpful, because they define dependency injection in a way that isn't useful. Let's agree that by &quot;dependency&quot; we mean some pre-existing other object that our object X needs. But we don't say we're doing &quot;dependency injection&quot; when we say</source>
          <target state="translated">Популярные ответы бесполезны,потому что они определяют инъекцию зависимости таким образом,что это не приносит пользы.Давайте согласимся,что под &quot;зависимостью&quot; мы подразумеваем какой-то уже существующий другой объект,который нужен нашему объекту X.Но мы не говорим,что делаем &quot;инъекцию зависимости&quot;,когда говорим.</target>
        </trans-unit>
        <trans-unit id="bbadfee066654ad4aea424424e4eade208a93f88" translate="yes" xml:space="preserve">
          <source>The primary intention of a tape recorder machine is to record or playback sound.</source>
          <target state="translated">Основным назначением магнитофона является запись или воспроизведение звука.</target>
        </trans-unit>
        <trans-unit id="72621a62fc0916c8f0e046dcd1a82521dee3ad8a" translate="yes" xml:space="preserve">
          <source>The purpose of dependency injection is to decouple the work of
  resolving external software components from your application business
  logic.Without dependency injection, the details of how a component
  accesses required services can get muddled in with the component&amp;rsquo;s
  code. This not only increases the potential for errors, adds code
  bloat, and magnifies maintenance complexities; it couples components
  together more closely, making it difficult to modify dependencies when
  refactoring or testing.</source>
          <target state="translated">Цель внедрения зависимостей состоит в том, чтобы отделить работу по разрешению внешних программных компонентов от бизнес-логики вашего приложения. Без внедрения зависимостей сведения о том, как компонент обращается к требуемым службам, могут быть запутаны в коде компонента. Это не только увеличивает вероятность возникновения ошибок, добавляет вздутие кода и увеличивает сложности обслуживания; он более тесно связывает компоненты, что затрудняет изменение зависимостей при рефакторинге или тестировании.</target>
        </trans-unit>
        <trans-unit id="0597c45b3f09c949a793674e4746ee654b8e2e31" translate="yes" xml:space="preserve">
          <source>The script is dependent: it won't execute successfully on its own (&lt;code&gt;archive_files&lt;/code&gt; is not defined).</source>
          <target state="translated">Сценарий является зависимым: он не будет успешно выполнен сам по себе ( &lt;code&gt;archive_files&lt;/code&gt; не определен).</target>
        </trans-unit>
        <trans-unit id="1771cd5e467d2af2b6f2a767136b82451f592144" translate="yes" xml:space="preserve">
          <source>The specific domain of DI is delegation of dependency configuration and initialization.</source>
          <target state="translated">Специфической областью DI является делегирование конфигурации и инициализации зависимостей.</target>
        </trans-unit>
        <trans-unit id="cd6b99e6180e4829c33bd4547e92926e1044e126" translate="yes" xml:space="preserve">
          <source>The whole point of Dependency Injection (DI) is to keep application source code &lt;strong&gt;clean&lt;/strong&gt; and &lt;strong&gt;stable&lt;/strong&gt;:</source>
          <target state="translated">Смысл Dependency Injection (DI) в том, чтобы поддерживать исходный код приложения в &lt;strong&gt;чистоте&lt;/strong&gt; и &lt;strong&gt;стабильности&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="27e320b7600e5266bce3ce68ab1e42620f41d50b" translate="yes" xml:space="preserve">
          <source>There are many different ways how to use dependency injection. It is possible to combine it with Singleton, etc., but still in basic it is only association realized by creating attribute of object type inside another object.
The usefulness is only and only in feature, that code, which we should write again and again is always prepared and done for us forward. This is why DI so closely binded with Inversion of Control (IoC) which means, that our program passes control another running module, which does injections of beans to our code. (Each object, which can be injected can be signed or considered as a Bean.) For example in Spring it is done by creating and initialization &lt;em&gt;ApplicationContext&lt;/em&gt; container, which does this work for us. We simply in our code create the Context and invoke initialization the beans. In that moment injection has been done automatically.</source>
          <target state="translated">Существует много разных способов использования внедрения зависимостей. Можно комбинировать его с Singleton и т. Д., Но в основном это только ассоциация, реализованная путем создания атрибута типа объекта внутри другого объекта. Полезность только и только в том, что код, который мы должны писать снова и снова, всегда готов и сделан для нас вперед. Вот почему DI так тесно связан с Inversion of Control (IoC), что означает, что наша программа передает управление другому работающему модулю, который делает инъекции bean-компонентов в наш код. (Каждый объект, который может быть введен, может быть подписан или рассматриваться как Бин.) Например, в Spring это делается путем создания и инициализации контейнера &lt;em&gt;ApplicationContext&lt;/em&gt; , который выполняет эту работу за нас. Мы просто в нашем коде создаем Context и вызываем инициализацию bean-компонентов. В этот момент инъекция была сделана автоматически.</target>
        </trans-unit>
        <trans-unit id="4bbc78d6e852d2e63980ceadf582e6e2cde07680" translate="yes" xml:space="preserve">
          <source>There are two primary approaches to implementing DI:</source>
          <target state="translated">Существуют два основных подхода к реализации ИР:</target>
        </trans-unit>
        <trans-unit id="e94b174e1d5cc2e2152c883c5d77b0f60deea3d8" translate="yes" xml:space="preserve">
          <source>There have been several questions already posted with specific questions about &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, such as when to use it and what frameworks are there for it. However,</source>
          <target state="translated">Уже было опубликовано несколько вопросов с конкретными вопросами о &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;внедрении зависимостей&lt;/a&gt; , например, когда его использовать и какие существуют для него рамки. Однако,</target>
        </trans-unit>
        <trans-unit id="bc485497e5c277af6e8ba89ddeb765c26b3e96ea" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;an article by Martin Fowler&lt;/a&gt; that may prove useful, too.</source>
          <target state="translated">Есть &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;статья Мартина Фаулера,&lt;/a&gt; которая также может оказаться полезной.</target>
        </trans-unit>
        <trans-unit id="815c6163aa7ffe62c24c7f4421caa35a91b5752f" translate="yes" xml:space="preserve">
          <source>This can be viewed in different ways:</source>
          <target state="translated">Это можно рассматривать по-разному:</target>
        </trans-unit>
        <trans-unit id="252c2fc56bbf461770e127f5279e75e5c6e1a9ef" translate="yes" xml:space="preserve">
          <source>This is based on the answer @Adam N posted.</source>
          <target state="translated">Это основано на ответе @Adam N размещенном.</target>
        </trans-unit>
        <trans-unit id="3214625379bb5b7d1b275f45dbd054121808f8f3" translate="yes" xml:space="preserve">
          <source>To make Dependency Injection concept simple to understand. Let's take an example of switch button to toggle(on/off) a bulb.</source>
          <target state="translated">Сделать концепцию &quot;Впрыскивание зависимостей&quot; простой для понимания.Рассмотрим пример кнопки переключения для включения/выключения лампочки.</target>
        </trans-unit>
        <trans-unit id="5343d4544799a720118861acb1f47462973d60f8" translate="yes" xml:space="preserve">
          <source>Two types of Dependency Injection:</source>
          <target state="translated">Два типа впрыскивания в зависимости:</target>
        </trans-unit>
        <trans-unit id="63568b370a821de5c78ae9aa707bb16d7ed41fac" translate="yes" xml:space="preserve">
          <source>Typically, once IoC containers have been configured / bootstrapped, they operate seamlessly in the background allowing the coder to focus on the code at hand rather than worrying about dependencies.</source>
          <target state="translated">Обычно,после того,как контейнеры IoC настроены на загрузку,они работают в фоновом режиме,позволяя кодеру сконцентрироваться на рассматриваемом коде,а не беспокоиться о зависимостях.</target>
        </trans-unit>
        <trans-unit id="182c61d24602b96b1f93b9d02ddeddadb6b2993d" translate="yes" xml:space="preserve">
          <source>Unfortunately the bad part is that some people have assumed you need a specialized framework to do dependency obfuscation and that you are somehow a 'lesser' programmer if you choose not to use a particular framework to do it. Another, extremely disturbing myth, believed by many, is that dependency injection is the only way of achieving dependency obfuscation. This is demonstrably and historically and obviously 100% wrong but you will have trouble convincing some people that there are alternatives to dependency injection for your dependency obfuscation requirements.</source>
          <target state="translated">К сожалению,плохо то,что некоторые считают,что для обтупления зависимостей нужен специализированный фреймворк,и что вы каким-то образом являетесь &quot;меньшим&quot; программистом,если решите не использовать для этого конкретный фреймворк.Другой,крайне тревожный миф,по мнению многих,заключается в том,что инъекция зависимостей является единственным способом достижения обфускации зависимости.Это очевидно и исторически,и очевидно на 100% неправильно,но вам будет трудно убедить некоторых людей,что есть альтернативы инъекции зависимости для ваших требований обфускации зависимости.</target>
        </trans-unit>
        <trans-unit id="3848296892c89c589ff3cd256248c78c171b9a63" translate="yes" xml:space="preserve">
          <source>Use Dependency Injection</source>
          <target state="translated">Использовать инъекцию зависимостей</target>
        </trans-unit>
        <trans-unit id="b5b26b6f5a26c971914a39f28f7610b2ff42bb58" translate="yes" xml:space="preserve">
          <source>Using a Dependency Injection Container</source>
          <target state="translated">Использование контейнера для впрыскивания зависимостей</target>
        </trans-unit>
        <trans-unit id="38051c244ec62e5af7798f63213cc9da83353e86" translate="yes" xml:space="preserve">
          <source>Using configuration only with &lt;em&gt;dependency lookup&lt;/em&gt; does not help as number of configuration parameters may change per dependency (e.g. new authentication type) as well as number of supported types of dependencies (e.g. new database type).</source>
          <target state="translated">Использование конфигурации только с &lt;em&gt;поиском зависимостей&lt;/em&gt; не помогает, так как количество параметров конфигурации может изменяться для каждой зависимости (например, новый тип аутентификации), а также количество поддерживаемых типов зависимостей (например, новый тип базы данных).</target>
        </trans-unit>
        <trans-unit id="cd86d58fd77887709d26819ecdbbed88c3b2259e" translate="yes" xml:space="preserve">
          <source>Usually the intermediate level provides factories for the constructed objects, which must provide a role that each requested object type must satisfy. That's because by having an intermediate level that hides the details of construction, you've already incurred the abstraction penalty imposed by factories, so you might as well use factories.</source>
          <target state="translated">Обычно промежуточный уровень предоставляет фабрики для построенных объектов,которые должны обеспечивать роль,которой должен удовлетворять каждый запрашиваемый тип объекта.Это потому,что,имея промежуточный уровень,который скрывает детали конструкции,вы уже получили штраф за абстракцию,налагаемый фабриками,так что вы можете также использовать фабрики.</target>
        </trans-unit>
        <trans-unit id="f80646d8467ba758d39c4c0efe8023f67e2f3d51" translate="yes" xml:space="preserve">
          <source>We can also loosen the dependency on &lt;code&gt;Console&lt;/code&gt; to an abstraction, such as a &lt;code&gt;TextWriter&lt;/code&gt;. Dependency Injection is typically implemented as either &lt;code&gt;constructor&lt;/code&gt; injection (passing an abstraction to a dependency as a parameter to the constructor of a consuming class) or &lt;code&gt;Setter Injection&lt;/code&gt; (passing the dependency via a &lt;code&gt;setXyz()&lt;/code&gt; setter or a .Net Property with &lt;code&gt;{set;}&lt;/code&gt; defined). Constructor Injection is preferred, as this guarantees the class will be in a correct state after construction, and allows the internal dependency fields to be marked as &lt;code&gt;readonly&lt;/code&gt; (C#) or &lt;code&gt;final&lt;/code&gt; (Java). So using constructor injection on the above example, this leaves us with:</source>
          <target state="translated">Мы также можем ослабить зависимость от &lt;code&gt;Console&lt;/code&gt; до абстракции, такой как &lt;code&gt;TextWriter&lt;/code&gt; . Внедрение зависимостей обычно реализуется либо в виде инжектора &lt;code&gt;constructor&lt;/code&gt; (передача абстракции в зависимость в качестве параметра конструктору потребляющего класса), либо &lt;code&gt;Setter Injection&lt;/code&gt; (передача зависимости через &lt;code&gt;setXyz()&lt;/code&gt; или свойство .Net с &lt;code&gt;{set;}&lt;/code&gt; определены). Внедрение в конструктор является предпочтительным, так как это гарантирует, что класс будет в правильном состоянии после построения, и позволяет полям внутренней зависимости помечаться как только для &lt;code&gt;readonly&lt;/code&gt; (C #) или как &lt;code&gt;final&lt;/code&gt; (Java). Таким образом, используя инъекцию конструктора в приведенном выше примере, мы получаем:</target>
        </trans-unit>
        <trans-unit id="86284d96e43cd594072665725439a4504abe091b" translate="yes" xml:space="preserve">
          <source>We can however apply &lt;code&gt;DIP&lt;/code&gt; to this class, by abstracting out the the concern of timestamping as a dependency, and coupling &lt;code&gt;MyLogger&lt;/code&gt; only to a simple interface:</source>
          <target state="translated">Тем не менее, мы можем применить &lt;code&gt;DIP&lt;/code&gt; к этому классу, абстрагируясь от того, что метка времени является зависимостью, и &lt;code&gt;MyLogger&lt;/code&gt; только с простым интерфейсом:</target>
        </trans-unit>
        <trans-unit id="4d76ed5465c1e8ece422b3fde5fc9eac7b93e015" translate="yes" xml:space="preserve">
          <source>We can see a wide variety of application of this pattern in our day to day life.
Some of the examples are Tape recorder, VCD, CD Drive etc.</source>
          <target state="translated">Мы можем видеть широкий спектр применения этой схемы в нашей повседневной жизни.Некоторые из примеров-диктофон Tape Recorder,VCD,CD Drive и т.д.</target>
        </trans-unit>
        <trans-unit id="699f2807e416a1b822a3e5508ecc546ba1097cee" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to hard code the object using new keyword rather define the bean dependency in the configuration file. The spring container will be responsible for hooking up all.</source>
          <target state="translated">Нам не нужно жестко кодировать объект, используя ключевое слово new, а определить зависимость bean-компонента в файле конфигурации. Пружинный контейнер будет отвечать за подключение всех.</target>
        </trans-unit>
        <trans-unit id="e6a519ea1c63ceedd483bc62f122abf4b1705040" translate="yes" xml:space="preserve">
          <source>We just call that passing parameters into the constructor. We've been doing that regularly ever since constructors were invented.</source>
          <target state="translated">Мы просто называем это передачей параметров в конструктор.Мы делаем это регулярно с тех пор,как были изобретены конструкторы.</target>
        </trans-unit>
        <trans-unit id="4939eb99c093f041eb14a0ea96bcb8652ea8525e" translate="yes" xml:space="preserve">
          <source>What if I want to change the object at runtime? For example, my config already says when I instantiate MyController, inject for FileLogger as ILogger. But I might want to inject DatabaseLogger.</source>
          <target state="translated">Что,если я захочу поменять объект во время выполнения? Например,в моем конфигурационном файле уже сказано,когда я инстанцирую MyController,инжектируйте для FileLogger как ILogger.Но я,возможно,захочу внедрить DatabaseLogger.</target>
        </trans-unit>
        <trans-unit id="3e2750129099d2d658ea524bc22e6b383e10d747" translate="yes" xml:space="preserve">
          <source>What if we want to change the type of its dependent object - say &lt;code&gt;Wheel&lt;/code&gt; - after the initial &lt;code&gt;NepaliRubberWheel()&lt;/code&gt; punctures?
We need to recreate the Car object with its new dependency say &lt;code&gt;ChineseRubberWheel()&lt;/code&gt;, but only the &lt;code&gt;Car&lt;/code&gt; manufacturer can do that.</source>
          <target state="translated">Что если мы захотим изменить тип зависимого объекта - скажем, &lt;code&gt;Wheel&lt;/code&gt; - после начальных &lt;code&gt;NepaliRubberWheel()&lt;/code&gt; ? Нам нужно воссоздать объект Car с его новой зависимостью, скажем, &lt;code&gt;ChineseRubberWheel()&lt;/code&gt; , но это может сделать только производитель &lt;code&gt;Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d12d549f3851beb3cde5e7133f1816376aac4516" translate="yes" xml:space="preserve">
          <source>What is dependency Injection?</source>
          <target state="translated">Что такое ижекция?</target>
        </trans-unit>
        <trans-unit id="2a58e8a199dcdef3591f016058aadf67a10b6ea0" translate="yes" xml:space="preserve">
          <source>What is dependency injection</source>
          <target state="translated">Что такое иждивенческая инъекция</target>
        </trans-unit>
        <trans-unit id="96816fe77c474fe522ad8e991ee6edf78f7425c0" translate="yes" xml:space="preserve">
          <source>When to use DI : I would recommend using DI in almost all production projects ( small/big), particularly in ever changing business environments :)</source>
          <target state="translated">Когда использовать DI:Я бы порекомендовал использовать DI почти во всех производственных проектах (smallbig),особенно в постоянно меняющихся бизнес-средах :)</target>
        </trans-unit>
        <trans-unit id="f48ccb208f603d34093b9d2e0d7b264d9656e30f" translate="yes" xml:space="preserve">
          <source>When to use? I would say whenever the application is large enough that encapsulating logic into separate modules, with a dependency graph between the modules gives a gain in readability and explorability of the code.</source>
          <target state="translated">Когда использовать? Я бы сказал,когда приложение достаточно большое,что инкапсуляция логики в отдельные модули,с графом зависимости между модулями дает выигрыш в читабельности и изученности кода.</target>
        </trans-unit>
        <trans-unit id="eed4b47b27cb37bd0ec38f924963811f2806030d" translate="yes" xml:space="preserve">
          <source>When using dependency injection, objects are given their dependencies &lt;em&gt;at run time rather than compile time (car manufacturing time)&lt;/em&gt;.
So that we can now change the &lt;code&gt;Wheel&lt;/code&gt; whenever we want. Here, the &lt;code&gt;dependency&lt;/code&gt; (&lt;code&gt;wheel&lt;/code&gt;) can be injected into &lt;code&gt;Car&lt;/code&gt; at run time.</source>
          <target state="translated">При использовании внедрения зависимостей объектам присваиваются свои зависимости &lt;em&gt;во время выполнения, а не во время компиляции (время изготовления автомобиля)&lt;/em&gt; . Так что теперь мы можем менять &lt;code&gt;Wheel&lt;/code&gt; когда захотим. Здесь &lt;code&gt;dependency&lt;/code&gt; ( &lt;code&gt;wheel&lt;/code&gt; ) может быть введена в &lt;code&gt;Car&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="abc4d8921a46969ecc613e5055f52eca2c65ee07" translate="yes" xml:space="preserve">
          <source>When we change &lt;code&gt;Service&lt;/code&gt; constructor, we need to change code in all place create &lt;code&gt;Service&lt;/code&gt; object</source>
          <target state="translated">Когда мы меняем конструктор &lt;code&gt;Service&lt;/code&gt; , нам нужно изменить код во всем месте создания объекта &lt;code&gt;Service&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60a4437333ad60740280d7819cb15d4da2c92233" translate="yes" xml:space="preserve">
          <source>When you change the &lt;code&gt;Service&lt;/code&gt;, you only need to change it in Injector class</source>
          <target state="translated">Когда вы меняете &lt;code&gt;Service&lt;/code&gt; , вам нужно только изменить ее в классе инжекторов</target>
        </trans-unit>
        <trans-unit id="f19469b25d4ea3f9876fe4907b1de5c966b79296" translate="yes" xml:space="preserve">
          <source>When you have a configuration of DI where all the actual implementations(not interfaces) that are going to be injected into a class (for e.g services to a controller) why is that not some sort of hard-coding?</source>
          <target state="translated">Когда у вас есть конфигурация DI,где все реальные реализации (не интерфейсы),которые будут вставляться в класс (например,для сервисов к контроллеру),почему это не какое-то жесткое кодирование?</target>
        </trans-unit>
        <trans-unit id="e0e2e926020e782ca430259f6c4e7d67c44e4d4d" translate="yes" xml:space="preserve">
          <source>When you use some constant like a database name you'd quickly move it from the inside of the code to some config file and pass a variable containing that value to the place where it is needed.  The reason to do that is that these constants usually change more frequently than the rest of the code.  For example if you'd like to test the code in a test database.</source>
          <target state="translated">Когда вы используете какую-то константу вроде имени базы данных,вы быстро переносите ее изнутри кода в какой-нибудь конфигурационный файл и передаете переменную,содержащую это значение,туда,где она нужна.Причина этого заключается в том,что эти константы обычно меняются чаще,чем остальной код.Например,если вы хотите проверить код в тестовой базе данных.</target>
        </trans-unit>
        <trans-unit id="f13093462f2a85a2c0797285aa9864b8c2e8b0bb" translate="yes" xml:space="preserve">
          <source>Where there likely will be a need to substitute a dependency for an equivalent implementation,</source>
          <target state="translated">В тех случаях,когда существует вероятность того,что потребуется заменить иждивенцев эквивалентной реализацией,</target>
        </trans-unit>
        <trans-unit id="bd97b161d9e5c8373340c65f6128ec2d5bcf0fbe" translate="yes" xml:space="preserve">
          <source>Where uncertainty of the lifespan of a dependency may warrant experimentation (e.g. Hey, &lt;code&gt;MyDepClass&lt;/code&gt; is thread safe - what if we make it a singleton and inject the same instance into all consumers?)</source>
          <target state="translated">Там, где неопределенность продолжительности жизни зависимости может потребовать экспериментов (например, Эй, &lt;code&gt;MyDepClass&lt;/code&gt; является потокобезопасным - что, если мы сделаем его одиночным и добавим один и тот же экземпляр всем потребителям?)</target>
        </trans-unit>
        <trans-unit id="59a5dadbd1f1b46c880e4228a933e3575c4621e6" translate="yes" xml:space="preserve">
          <source>Whereas after application of the DIP, the requirement is loosened, and the concern of obtaining and managing the lifespan of the &lt;code&gt;Foo&lt;/code&gt; dependency has been removed:</source>
          <target state="translated">Принимая во внимание, что после применения DIP требование ослабляется, а проблема получения и управления продолжительностью жизни зависимости &lt;code&gt;Foo&lt;/code&gt; была удалена:</target>
        </trans-unit>
        <trans-unit id="2f8fd3870a84afb43d089851d3d66aefbefd8208" translate="yes" xml:space="preserve">
          <source>While designing a system it require a reel to record or playback sound or music. There are two possibilities for designing this system</source>
          <target state="translated">При проектировании системы для записи или воспроизведения звука или музыки требуется катушка.Есть две возможности для проектирования этой системы</target>
        </trans-unit>
        <trans-unit id="f24455302b22cf5f3be2af86011a77cc94c7bdb3" translate="yes" xml:space="preserve">
          <source>Why : Because you want your code to be easily testable, mockable etc so that you can quickly test your changes and push it to the market. Besides why would you not when you there are lots of awesome free tools/frameworks to support you in your journey to a codebase where you have more control.</source>
          <target state="translated">Почему:Потому что вы хотите,чтобы ваш код был легко тестируемым,высмеиваемым и т.д.,чтобы вы могли быстро протестировать ваши изменения и вывести его на рынок.Кроме того,почему бы и нет,когда у вас есть много потрясающих бесплатных инструментов,которые помогут вам в вашем путешествии к кодовой базе,где у вас больше контроля.</target>
        </trans-unit>
        <trans-unit id="155c0f309806e222f377eeb338deeddb4ac2035d" translate="yes" xml:space="preserve">
          <source>Why does PersonService no longer have to worry about GroupMembershipService? You just mentioned GroupMembership has multiple things(objects/properties) it depends on. If GMService was required in PService, you'd have it as a property. You can mock that out regardless of whether you injected it or not. The only time I'd like it to be injected is if GMService had more specific child classes, which you wouldn't know until runtime. Then you'd want to inject the subclass. Or if you wanted to use that as either singleton or prototype. To be honest, the configuration file has everything hardcoded as far as what subclass for a type (interface) it is going to inject during compile time.</source>
          <target state="translated">Почему PersonService больше не нужно беспокоиться о GroupMemberhipService? Вы только что упомянули,что членство в GroupM имеет множество вещей (объектов-свойств),от которых оно зависит.Если бы GMService был необходим в PService,у вас бы это было свойством.Вы можете высмеивать это независимо от того,вводили вы это или нет.Единственное время,когда я бы хотел,чтобы это было введено,это если бы GMService имел более специфические дочерние классы,которые вы не знали бы до выполнения.Тогда вы бы захотели ввести подкласс.Или если бы вы хотели использовать его как одиночку или как прототип.Честно говоря,в конфигурационном файле есть все жестко закодированное до того,какой подкласс для того или иного типа (интерфейса)он будет вводить во время компиляции.</target>
        </trans-unit>
        <trans-unit id="316cb2abaec2a090bd29421bce7b593838a6bd08" translate="yes" xml:space="preserve">
          <source>With Dependency Injection</source>
          <target state="translated">С инъекцией зависимостей</target>
        </trans-unit>
        <trans-unit id="1233c83a1bf8dee2cadec4b76cd3eec49f5d8602" translate="yes" xml:space="preserve">
          <source>With Dependency Injection, instead of instantiating the &lt;code&gt;GroupMembershipService&lt;/code&gt; within your &lt;code&gt;PersonService&lt;/code&gt;, you'd either pass it in to the &lt;code&gt;PersonService&lt;/code&gt; constructor, or else add a Property (getter and setter) to set a local instance of it. This means that your &lt;code&gt;PersonService&lt;/code&gt; no longer has to worry about how to create a &lt;code&gt;GroupMembershipService&lt;/code&gt;, it just accepts the ones it's given, and works with them.  This also means that anything which is a subclass of &lt;code&gt;GroupMembershipService&lt;/code&gt;, or implements the &lt;code&gt;GroupMembershipService&lt;/code&gt; interface can be &quot;injected&quot; into the &lt;code&gt;PersonService&lt;/code&gt;, and the &lt;code&gt;PersonService&lt;/code&gt; doesn't need to know about the change.</source>
          <target state="translated">С &lt;code&gt;PersonService&lt;/code&gt; Dependency Injection вместо создания экземпляра &lt;code&gt;GroupMembershipService&lt;/code&gt; в вашем PersonService вы либо передаете его конструктору &lt;code&gt;PersonService&lt;/code&gt; , либо добавляете свойство (getter и setter) для установки его локального экземпляра. Это означает, что вашему &lt;code&gt;PersonService&lt;/code&gt; больше не нужно беспокоиться о том, как создать &lt;code&gt;GroupMembershipService&lt;/code&gt; , он просто принимает предоставленные им и работает с ними. Это также означает, что все, что является подклассом &lt;code&gt;GroupMembershipService&lt;/code&gt; или реализует интерфейс &lt;code&gt;PersonService&lt;/code&gt; , может быть &amp;laquo; внедрено &amp;raquo; в PersonService , и &lt;code&gt;PersonService&lt;/code&gt; не нужно знать об изменении.</target>
        </trans-unit>
        <trans-unit id="0f0a3b5beff6045bb4f3fe845c538ad21014ce5e" translate="yes" xml:space="preserve">
          <source>With Dependency injection, the dependency injector will take off the instantiation for us</source>
          <target state="translated">С помощью инъекции зависимостей,инжектор зависимостей снимет для нас инстанцию.</target>
        </trans-unit>
        <trans-unit id="55cdf21af285a1570d5d341608f193842fd5a672" translate="yes" xml:space="preserve">
          <source>With dependency injection, someone else takes care of all the preparation and makes the required equipment available to you. You will receive (&quot;be injected&quot;) the boat, the fishing rod and the bait - all ready to use.</source>
          <target state="translated">При инъекции с иждивенцами кто-то другой берет на себя всю подготовку и предоставляет в ваше распоряжение необходимое оборудование.Вы получите (&quot;будут впрыснуты&quot;)лодку,удочку и наживку-все готово к использованию.</target>
        </trans-unit>
        <trans-unit id="f9f5cf6442cf84c858a561c2c1aa9e63fe5c3866" translate="yes" xml:space="preserve">
          <source>Without Dependency Injection</source>
          <target state="translated">Без впрыска в иждивенчество</target>
        </trans-unit>
        <trans-unit id="3b220ed590066bbf10e392ad2dd726fec3be4180" translate="yes" xml:space="preserve">
          <source>Without dependency injection, you need to take care of everything yourself. You need to find a boat, to buy a fishing rod, to look for bait, etc. It's possible, of course, but it puts a lot of responsibility on you. In software terms, it means that you have to perform a lookup for all these things.</source>
          <target state="translated">Без иждивенческих инъекций,вы должны позаботиться обо всем сами.Нужно найти лодку,купить удочку,поискать наживку и т.д.Это,конечно,возможно,но это накладывает на вас большую ответственность.С точки зрения программного обеспечения,это означает,что вы должны выполнить поиск всех этих вещей.</target>
        </trans-unit>
        <trans-unit id="49f49ef1de77737ae4e3ae770e87d4b807452cda" translate="yes" xml:space="preserve">
          <source>Without the DIP, our code (I've called this 'consuming class') is directly coupled to a concrete dependency and is also often burdened with the responsibility of knowing how to obtain, and manage, an instance of this dependency, i.e. conceptually:</source>
          <target state="translated">Без DIP наш код (я назвал этот &quot;класс-потребитель&quot;)напрямую связан с конкретной зависимостью,а также часто обременен ответственностью за знание того,как получить экземпляр этой зависимости и управлять им,т.е.концептуально:</target>
        </trans-unit>
        <trans-unit id="1b0617f8014f1a76dc7ba00100921c6326f40868" translate="yes" xml:space="preserve">
          <source>You can also read</source>
          <target state="translated">Вы также можете прочитать</target>
        </trans-unit>
        <trans-unit id="e84e5e5caa3f2b230be8ecf0ca3d63c1bcbc6707" translate="yes" xml:space="preserve">
          <source>You could have injected dependency which implements &lt;code&gt;archive_files&lt;/code&gt; using &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;.</source>
          <target state="translated">Вы могли бы внедрить зависимость, которая реализует &lt;code&gt;archive_files&lt;/code&gt; используя &lt;code&gt;tar&lt;/code&gt; или &lt;code&gt;xz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c14f594f01f1de9fd2aab048e30d8d2194a66f7" translate="yes" xml:space="preserve">
          <source>You define &lt;code&gt;archive_files&lt;/code&gt; in &lt;code&gt;archive_files_zip.sh&lt;/code&gt; implementation script (using &lt;code&gt;zip&lt;/code&gt; in this case):</source>
          <target state="translated">Вы определяете &lt;code&gt;archive_files&lt;/code&gt; в &lt;code&gt;archive_files_zip.sh&lt;/code&gt; реализации archive_files_zip.sh (в данном случае используя &lt;code&gt;zip&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="7444b1acde932a72f7dd1189c7b8bfd322ca3632" translate="yes" xml:space="preserve">
          <source>You don't need a container to do dependency injection. However a container can help you.</source>
          <target state="translated">Тебе не нужен контейнер,чтобы делать инъекции зависимостей.Однако контейнер может помочь вам.</target>
        </trans-unit>
        <trans-unit id="bbf99c4996fccfe9e7a0ac73dbccffb4a67c6cea" translate="yes" xml:space="preserve">
          <source>a DI Container is a tool to help injecting dependencies</source>
          <target state="translated">контейнер для инъекций-это инструмент для помощи в инъекционных зависимостях.</target>
        </trans-unit>
        <trans-unit id="4a4aad97c907cbb008e7b8b26d6f30985b32b8aa" translate="yes" xml:space="preserve">
          <source>application &lt;strong&gt;deployment&lt;/strong&gt; (&lt;strong&gt;multiple&lt;/strong&gt; target environments with independent lifecycles)</source>
          <target state="translated">&lt;strong&gt;развертывание&lt;/strong&gt; приложения ( &lt;strong&gt;несколько&lt;/strong&gt; целевых сред с независимыми жизненными циклами)</target>
        </trans-unit>
        <trans-unit id="a32ef176365fadc9778959691ce81fd982d81b42" translate="yes" xml:space="preserve">
          <source>application &lt;strong&gt;development&lt;/strong&gt; (&lt;strong&gt;single&lt;/strong&gt; source code release lifecycle)</source>
          <target state="translated">&lt;strong&gt;разработка&lt;/strong&gt; приложений (жизненный цикл выпуска &lt;strong&gt;одного&lt;/strong&gt; исходного кода)</target>
        </trans-unit>
        <trans-unit id="c2ae11a3ef2bc13a293ffe2bcc4ea4cf9c7088db" translate="yes" xml:space="preserve">
          <source>before doing a</source>
          <target state="translated">перед тем как сделать</target>
        </trans-unit>
        <trans-unit id="fb1802bd1e16e969815bc074b7285e09e6c78cfd" translate="yes" xml:space="preserve">
          <source>from Book &lt;strong&gt;Apress.Spring.Persistence.with.Hibernate.Oct.2010&lt;/strong&gt;</source>
          <target state="translated">из книги &lt;strong&gt;Apress.Spring.Persistence.with.Hibernate.Oct.2010&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="472f32380d47285104826da06f61443568994b00" translate="yes" xml:space="preserve">
          <source>mapping between each abstraction and the configured concrete implementation (e.g. &lt;em&gt;&quot;any time a consumer requests an &lt;code&gt;IBar&lt;/code&gt;, return a &lt;code&gt;ConcreteBar&lt;/code&gt; instance&quot;&lt;/em&gt;)</source>
          <target state="translated">отображение между каждой абстракцией и сконфигурированной конкретной реализацией (например, &lt;em&gt;&amp;laquo;каждый раз, когда потребитель запрашивает &lt;code&gt;IBar&lt;/code&gt; , возвращает экземпляр &lt;code&gt;ConcreteBar&lt;/code&gt; &amp;raquo;&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="a89dcdc02705c87126898e6ee6b1fbd5bdb0786f" translate="yes" xml:space="preserve">
          <source>policies can be set up for the lifespan management of each dependency, e.g. to create a new object for each consumer instance, to share a singleton dependency instance across all consumers, to share the same dependency instance only across the same thread, etc.</source>
          <target state="translated">Можно настроить политику управления жизненным циклом каждой зависимости,например,создать новый объект для каждого экземпляра-потребителя,совместно использовать один и тот же экземпляр зависимости для всех потребителей,совместно использовать один и тот же экземпляр зависимости только для одной и той же нити и т.д.</target>
        </trans-unit>
        <trans-unit id="036711eff2961f7a9eb870a48ad40790feff55dd" translate="yes" xml:space="preserve">
          <source>we can place the reel inside the machine</source>
          <target state="translated">мы можем поместить катушку внутри машины</target>
        </trans-unit>
        <trans-unit id="0a91593e00bce6f1bb48c8658c6f3c6f186cbbf2" translate="yes" xml:space="preserve">
          <source>we can provide a hook for the reel where it can be placed.</source>
          <target state="translated">мы можем предоставить крюк для катушки,где его можно разместить.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
