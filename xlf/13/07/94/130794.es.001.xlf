<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/130794">
    <body>
      <group id="130794">
        <trans-unit id="075303a37c1db7777d673503bd42ea6517e55270" translate="yes" xml:space="preserve">
          <source>&quot;As our &lt;strong&gt;applications&lt;/strong&gt; grow and evolves, each one of our &lt;strong&gt;code entities&lt;/strong&gt; will internally require &lt;strong&gt;instances of other objects&lt;/strong&gt;, which are better known as &lt;strong&gt;dependencies&lt;/strong&gt; in the world of software engineering. The &lt;strong&gt;action&lt;/strong&gt; of passing such &lt;strong&gt;dependencies&lt;/strong&gt; to the dependent client is known as &lt;strong&gt;injection&lt;/strong&gt;, and it also entails the participation of another code entity, named the &lt;strong&gt;injector&lt;/strong&gt;. The &lt;strong&gt;injector&lt;/strong&gt; will take responsibility for &lt;strong&gt;instantiating&lt;/strong&gt; and &lt;strong&gt;bootstrapping&lt;/strong&gt; the required &lt;strong&gt;dependencies&lt;/strong&gt; so they are ready for use from the very moment they are successfully injected in the client. This is very important since the client knows nothing about how to &lt;strong&gt;instantiate&lt;/strong&gt; its own &lt;strong&gt;dependencies&lt;/strong&gt; and is only aware of the &lt;strong&gt;interface&lt;/strong&gt; they implement in order to use them.&quot;</source>
          <target state="translated">&quot;A medida que nuestras &lt;strong&gt;aplicaciones&lt;/strong&gt; crecen y evolucionan, cada una de nuestras &lt;strong&gt;entidades de c&amp;oacute;digo&lt;/strong&gt; requerir&amp;aacute; internamente &lt;strong&gt;instancias de otros objetos&lt;/strong&gt; , que se conocen mejor como &lt;strong&gt;dependencias&lt;/strong&gt; en el mundo de la ingenier&amp;iacute;a de software. La &lt;strong&gt;acci&amp;oacute;n&lt;/strong&gt; de pasar tales &lt;strong&gt;dependencias&lt;/strong&gt; al cliente dependiente se conoce como &lt;strong&gt;inyecci&amp;oacute;n&lt;/strong&gt; , y tambi&amp;eacute;n implica la participaci&amp;oacute;n de otra entidad de c&amp;oacute;digo, llamada el &lt;strong&gt;inyector&lt;/strong&gt; . El &lt;strong&gt;inyector&lt;/strong&gt; se responsabilizar&amp;aacute; de &lt;strong&gt;crear instancias&lt;/strong&gt; y &lt;strong&gt;arrancar&lt;/strong&gt; las &lt;strong&gt;dependencias&lt;/strong&gt; necesarias para que est&amp;eacute;n listas para su uso desde el momento en que se inyectan con &amp;eacute;xito en el cliente. Esto es muy importante ya que el cliente no sabe nada sobre c&amp;oacute;mo &lt;strong&gt;crear instancias de&lt;/strong&gt; sus propias &lt;strong&gt;dependencias&lt;/strong&gt; y solo conoce la &lt;strong&gt;interfaz&lt;/strong&gt; que implementa para usarlas &quot;.</target>
        </trans-unit>
        <trans-unit id="88ba72c68eb66f9403511df347aad31c0ffb36bb" translate="yes" xml:space="preserve">
          <source>&quot;Dependency Injection&quot; is a 25-dollar
  term for a 5-cent concept. [...]
  Dependency injection means giving an
  object its instance variables. [...].</source>
          <target state="translated">&quot;Inyección de dependencia&quot; es un término de 25 dólares para un concepto de 5 centavos.[...]La inyección de dependencia significa dar a un objeto sus variables de instancia.[...].</target>
        </trans-unit>
        <trans-unit id="884583105d69da013b6572c7250c4e2a8f722ed6" translate="yes" xml:space="preserve">
          <source>&quot;Dependency injection&quot; is considered a type of &quot;inversion of control&quot;, which means that some logic is taken out of the caller. That isn't the case when the caller passes in parameters, so if that were DI, DI would not imply inversion of control.</source>
          <target state="translated">La &quot;inyección de dependencia&quot; se considera un tipo de &quot;inversión de control&quot;,lo que significa que se le quita algo de lógica a la persona que llama.Ese no es el caso cuando el llamante pasa los parámetros,así que si eso fuera DI,DI no implicaría inversión de control.</target>
        </trans-unit>
        <trans-unit id="559316cc487d0d2d80076d1938d00fe314c1d36f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;In short, &lt;strong&gt;DI&lt;/strong&gt; helps you write code in a &lt;strong&gt;loosely coupled&lt;/strong&gt; way and makes your &lt;strong&gt;code&lt;/strong&gt; more &lt;strong&gt;testable&lt;/strong&gt; and &lt;strong&gt;reusable&lt;/strong&gt;.&amp;rdquo;</source>
          <target state="translated">&quot;En resumen, &lt;strong&gt;DI lo&lt;/strong&gt; ayuda a escribir c&amp;oacute;digo de una manera &lt;strong&gt;poco acoplada&lt;/strong&gt; y hace que su &lt;strong&gt;c&amp;oacute;digo sea&lt;/strong&gt; m&amp;aacute;s &lt;strong&gt;verificable&lt;/strong&gt; y &lt;strong&gt;reutilizable&lt;/strong&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="ec42628a9387e4101c1904f5ffcd31e7a85677db" translate="yes" xml:space="preserve">
          <source>(A concrete &lt;code&gt;Clock&lt;/code&gt; needs to be provided, which of course could revert to &lt;code&gt;DateTime.Now&lt;/code&gt;, and the two dependencies need to be provided by an IoC container via constructor injection)</source>
          <target state="translated">(Se debe proporcionar un &lt;code&gt;Clock&lt;/code&gt; concreto, que por supuesto podr&amp;iacute;a volver a &lt;code&gt;DateTime.Now&lt;/code&gt; , y las dos dependencias deben ser proporcionadas por un contenedor IoC a trav&amp;eacute;s de la inyecci&amp;oacute;n del constructor)</target>
        </trans-unit>
        <trans-unit id="7c77d04844ca55b45c4e29a2ad4bd0663b614dc7" translate="yes" xml:space="preserve">
          <source>1) Simple manual &lt;code&gt;Injector&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;Injector&lt;/code&gt; manual simple</target>
        </trans-unit>
        <trans-unit id="2b8c8a3c4e4de08de9d47e21c94fca818f3e508e" translate="yes" xml:space="preserve">
          <source>1.    Constructor-based dependency injection:</source>
          <target state="translated">1.Inyección de dependencia basada en el constructor:</target>
        </trans-unit>
        <trans-unit id="0fd3eb9210cba499046c01b805cb7de8b0581cf6" translate="yes" xml:space="preserve">
          <source>2) Use library: For Android &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;</source>
          <target state="translated">2) Usar biblioteca: para Android &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1dc2ccd951284c98a3bde560294a5c88093316a" translate="yes" xml:space="preserve">
          <source>2.    Setter-based dependency injection:</source>
          <target state="translated">2.Inyección de dependencia a base de Setter:</target>
        </trans-unit>
        <trans-unit id="20d1910df8e94fb0fa91e3b643d5709d2d44f250" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://martinfowler.com/articles/injection.html#InterfaceInjection&quot;&gt;Martin Fowler&lt;/a&gt; documents a third alternative (h/t @MarcDix), where &lt;strong&gt;classes explicitly implement an interface&lt;/strong&gt; for the dependencies programmers wish injected.</source>
          <target state="translated">&lt;a href=&quot;http://martinfowler.com/articles/injection.html#InterfaceInjection&quot;&gt;Martin Fowler&lt;/a&gt; documenta una tercera alternativa (h / t @MarcDix), donde las &lt;strong&gt;clases implementan expl&amp;iacute;citamente una interfaz&lt;/strong&gt; para las dependencias que los programadores desean inyectar.</target>
        </trans-unit>
        <trans-unit id="139cc1158c0803cacea84c6bb86ce8b3cd6a16e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php-di.org/doc/understanding-di.html&quot;&gt;This&lt;/a&gt; is the most simple explanation about &lt;strong&gt;Dependency Injection&lt;/strong&gt; and &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; I have ever seen:</source>
          <target state="translated">&lt;a href=&quot;http://php-di.org/doc/understanding-di.html&quot;&gt;Esta&lt;/a&gt; es la explicaci&amp;oacute;n m&amp;aacute;s simple sobre la &lt;strong&gt;inyecci&amp;oacute;n de&lt;/strong&gt; &lt;strong&gt;dependencia&lt;/strong&gt; y el &lt;strong&gt;contenedor de inyecci&amp;oacute;n de dependencia&lt;/strong&gt; que he visto:</target>
        </trans-unit>
        <trans-unit id="ea2f6774ac13f40817f28f4fc553b644d8059a9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James Shore's article shows the following examples for comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;El art&amp;iacute;culo de James Shore muestra los siguientes ejemplos para comparaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5dd4547c12b988e4cf971119a75e17e9ed5a4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency Injection&lt;/a&gt; means a way (actually &lt;strong&gt;any-way&lt;/strong&gt;) for one part of code (e.g a class) to have access to dependencies (other parts of code, e.g other classes, it depends upon) in a modular way without them being hardcoded (so they can change or be overriden freely, or even be loaded at another time, as needed)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;La inyecci&amp;oacute;n de dependencias&lt;/a&gt; significa una forma (en realidad de &lt;strong&gt;cualquier manera&lt;/strong&gt; ) para que una parte del c&amp;oacute;digo (por ejemplo, una clase) tenga acceso a las dependencias (otras partes del c&amp;oacute;digo, por ejemplo, otras clases, de las que depende) de forma modular sin que est&amp;eacute;n codificadas (por lo tanto, pueden cambiar o anularse libremente, o incluso cargarse en otro momento, seg&amp;uacute;n sea necesario)</target>
        </trans-unit>
        <trans-unit id="489243935980044f46caf00a1da3950eb72480f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SomeClass()&lt;/code&gt; has its constructor as following:</source>
          <target state="translated">&lt;code&gt;SomeClass()&lt;/code&gt; tiene su constructor como sigue:</target>
        </trans-unit>
        <trans-unit id="e7be66ff5c1f2bead4f99265aacf00180d5bd3fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myObject&lt;/code&gt; can be passed directly which makes testing easier.</source>
          <target state="translated">&lt;code&gt;myObject&lt;/code&gt; se puede pasar directamente, lo que facilita las pruebas.</target>
        </trans-unit>
        <trans-unit id="9bd7701ca83f91008241672a8066b98e80ce7fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and ps , yes it has become an overly-hyped 25$ name for a rather simple, concept)&lt;/em&gt;, my &lt;code&gt;.25&lt;/code&gt; cents</source>
          <target state="translated">&lt;em&gt;(y ps, s&amp;iacute;, se ha convertido en un nombre exagerado de 25 $ para un concepto bastante simple)&lt;/em&gt; , mis &lt;code&gt;.25&lt;/code&gt; centavos</target>
        </trans-unit>
        <trans-unit id="7c64642d978f251aeaa9e771fd6b2e4c8c2a0138" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DI increases cohesion by removing any need to determine the direction of dependency and write any glue code.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DI aumenta la cohesi&amp;oacute;n al eliminar cualquier necesidad de determinar la direcci&amp;oacute;n de dependencia y escribir cualquier c&amp;oacute;digo de pegamento.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8cd65eebe518df31a3d3e8b816fd1032b277e646" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DI reduces coupling by making all of your components modular (i.e. replacable) and have well-defined interfaces to each other.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DI reduce el acoplamiento al hacer que todos sus componentes sean modulares (es decir, reemplazables) y tengan interfaces bien definidas entre s&amp;iacute;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2f6f530262aaa812ba33a2511d7964178350822" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I found this funny example in terms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot;&gt;loose coupling&lt;/a&gt;:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Encontr&amp;eacute; este ejemplo divertido en t&amp;eacute;rminos de &lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot;&gt;acoplamiento flojo&lt;/a&gt; :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62fe0e1a78daa62d9061df07333b1c387f953b07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Using&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Using&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81d7f6f687485d5dc12f6f5268a195c72b70fee8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) 2) 3) Using&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 2) 3) Usando&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="134d462b40518572cfc8a34cb9179e98a9817f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Then what does the &lt;code&gt;Dependency Injection&lt;/code&gt; do for us...?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Entonces, &amp;iquest;qu&amp;eacute; hace la &lt;code&gt;Dependency Injection&lt;/code&gt; para nosotros ...?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64e35a8a257eda0748b950b4efd25aebaab56d6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After using dependency injection:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Despu&amp;eacute;s de usar la inyecci&amp;oacute;n de dependencia:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e118dd44c7e67af1dc63de6f5672af7d0d76495d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the above answers are good, my aim is to explain the concept in a simple way so that anyone without a programming knowledge can also understand concept&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Todas las respuestas anteriores son buenas, mi objetivo es explicar el concepto de una manera simple para que cualquier persona sin conocimientos de programaci&amp;oacute;n tambi&amp;eacute;n pueda entender el concepto&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21f37caa4106b3b41630895455450baa84ccfb77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Alternative solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n alternativa&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fe080fcf8cd21d9cdaa29a5c39e27707035ab956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DI, DIP and SOLID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DI, DIP y S&amp;Oacute;LIDO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e78d489aa9f4c7df98e18605184dfcf430472ba1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency Injection&lt;/strong&gt; and &lt;strong&gt;dependency Injection Containers&lt;/strong&gt; are different things:</source>
          <target state="translated">&lt;strong&gt;La inyecci&amp;oacute;n de&lt;/strong&gt; &lt;strong&gt;dependencia&lt;/strong&gt; y &lt;strong&gt;los contenedores de inyecci&amp;oacute;n de dependencia&lt;/strong&gt; son cosas diferentes:</target>
        </trans-unit>
        <trans-unit id="4e7a19bc0d7c4175394cf98e210ddbeaca200985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency Injection&lt;/strong&gt; is passing dependency to other &lt;strong&gt;objects&lt;/strong&gt; or &lt;strong&gt;framework&lt;/strong&gt;( dependency injector).</source>
          <target state="translated">&lt;strong&gt;Inyecci&amp;oacute;n de dependencia&lt;/strong&gt; es pasar dependencia a otros &lt;strong&gt;objetos&lt;/strong&gt; o &lt;strong&gt;marco&lt;/strong&gt; (inyector de dependencia).</target>
        </trans-unit>
        <trans-unit id="9050dff2d4e01dd22dab4a30a3b18b836dbca3a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Disadvantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="352fe1ffa66ad058937206892159aa0c751d3d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example for Dependency injection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo de inyecci&amp;oacute;n de dependencia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89779a6f30decc7c58d031e6da0ce5e9759d2d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Next Steps&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pr&amp;oacute;ximos pasos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73b8706173c462cc0bdd6d2632616f2d7f4a120a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; : The creation / mapping / projection (via &lt;code&gt;new ..()&lt;/code&gt;) of POCO / POJO / Serialization DTOs / Entity Graphs / Anonymous JSON projections et al - i.e. &quot;Data only&quot; classes or records - used or returned from methods are &lt;em&gt;not&lt;/em&gt; regarded as Dependencies (in the UML sense) and not subject to DI. Using &lt;code&gt;new&lt;/code&gt; to project these is just fine.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La creaci&amp;oacute;n / mapeo / proyecci&amp;oacute;n (a trav&amp;eacute;s de &lt;code&gt;new ..()&lt;/code&gt; ) de POCO / POJO / DTO de serializaci&amp;oacute;n / Gr&amp;aacute;ficos de entidades / Proyecciones JSON an&amp;oacute;nimas y otros, es decir, clases o registros de &quot;solo datos&quot;, &lt;em&gt;no se&lt;/em&gt; consideran usados ​​o devueltos por m&amp;eacute;todos como dependencias (en el sentido UML) y no sujeto a DI. Usar &lt;code&gt;new&lt;/code&gt; para proyectar esto est&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="d98f2b4bd341257a9dbd8120abd05530994fcf1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem&lt;/strong&gt;:
If &lt;code&gt;myObject&lt;/code&gt; involves complex tasks such as disk access or network access, it is &lt;strong&gt;hard&lt;/strong&gt; to do unit test on &lt;code&gt;SomeClass()&lt;/code&gt;. Programmers have to mock &lt;code&gt;myObject&lt;/code&gt; and might &lt;strong&gt;intercept&lt;/strong&gt; the factory call.</source>
          <target state="translated">&lt;strong&gt;Problema&lt;/strong&gt; : si &lt;code&gt;myObject&lt;/code&gt; involucra tareas complejas como el acceso al disco o el acceso a la red, es &lt;strong&gt;dif&amp;iacute;cil&lt;/strong&gt; hacer una prueba unitaria en &lt;code&gt;SomeClass()&lt;/code&gt; . Los programadores tienen que burlarse de &lt;code&gt;myObject&lt;/code&gt; y pueden &lt;strong&gt;interceptar&lt;/strong&gt; la llamada de f&amp;aacute;brica.</target>
        </trans-unit>
        <trans-unit id="3caa217db0a9feb519ccfb83c5360a0fd9379499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Watched course about EF Core from Julie Lerman recently and also liked her short definition about DI.</source>
          <target state="translated">&lt;strong&gt;ACTUALIZACI&amp;Oacute;N:&lt;/strong&gt; Recientemente vi un curso sobre EF Core de Julie Lerman y tambi&amp;eacute;n me gust&amp;oacute; su breve definici&amp;oacute;n sobre DI.</target>
        </trans-unit>
        <trans-unit id="bb8fdb2caf0495723a2bfa5cae2542c71d3df90c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Using&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fed09c4b3a548192ce23e86d0d3ac85024ca7184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 1)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Camino 1)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5287e00dc55d1b18cf0490002f5097515ab0af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 1)&lt;/strong&gt; Constructor injection</source>
          <target state="translated">&lt;strong&gt;Camino 1)&lt;/strong&gt; Inyecci&amp;oacute;n del constructor</target>
        </trans-unit>
        <trans-unit id="cffbc9253561d5f6c70f7781944f336db2c95227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 2)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Camino 2)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfccbb774df62a67ec9d3bdc2292dd944115740" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 2)&lt;/strong&gt; Setter injection</source>
          <target state="translated">&lt;strong&gt;Camino 2)&lt;/strong&gt; Inyecci&amp;oacute;n Setter</target>
        </trans-unit>
        <trans-unit id="6b6b88724bc7d2fd56ed9b90ed70c1bf61d456de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 3)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Camino 3)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7be335f5337bca5a01d1e24ed56b2f2d716bba6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 3)&lt;/strong&gt; Interface injection</source>
          <target state="translated">&lt;strong&gt;Forma 3)&lt;/strong&gt; inyecci&amp;oacute;n de interfaz</target>
        </trans-unit>
        <trans-unit id="e997684d5231d7a45924a857d44b5b8961d9a17d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Dependency Injection (DI)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; es la inyecci&amp;oacute;n de dependencia (DI)?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a57f9d5d3eb174e62bab1bb6baa6ed97f6dfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is dependency injection and when/why should or shouldn't it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; es la inyecci&amp;oacute;n de dependencia y cu&amp;aacute;ndo / por qu&amp;eacute; deber&amp;iacute;a o no deber&amp;iacute;a usarse?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b431da6264f45e0d6035801527ad040d6ae12bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When to use DI?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;ndo usar DI?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd3cb919485762e2f7ae20824d2553c1b374d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why use DIP (and DI)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; usar DIP (y DI)?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e626bfdc41d8d0154fb13bbccc4a07c5bdea697f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without Dependency Injection (DI):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sin inyecci&amp;oacute;n de dependencia (DI):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b41ad2ddaf8a9d9eee7a1bdd549ad0e74faf4d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;clean&lt;/strong&gt; of dependency initialization code</source>
          <target state="translated">c&amp;oacute;digo de inicializaci&amp;oacute;n &lt;strong&gt;limpio&lt;/strong&gt; de dependencia</target>
        </trans-unit>
        <trans-unit id="175b3654ce89f52bed835b1e1354adc55d5bff80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stable&lt;/strong&gt; regardless of dependency used</source>
          <target state="translated">&lt;strong&gt;estable&lt;/strong&gt; independientemente de la dependencia utilizada</target>
        </trans-unit>
        <trans-unit id="b64cc2760536699c09c33fd0c38b16350e500872" translate="yes" xml:space="preserve">
          <source>===</source>
          <target state="translated">===</target>
        </trans-unit>
        <trans-unit id="6b0acc829dd60bf821accdbecbe0f34bcc950c1b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Car&lt;/code&gt; depends on wheels, engine, fuel, battery, etc. to run. Traditionally we define the brand of such dependent objects along with the definition of the &lt;code&gt;Car&lt;/code&gt; object.</source>
          <target state="translated">Un &lt;code&gt;Car&lt;/code&gt; depende de las ruedas, el motor, el combustible, la bater&amp;iacute;a, etc. para funcionar. Tradicionalmente definimos la marca de dichos objetos dependientes junto con la definici&amp;oacute;n del objeto &lt;code&gt;Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76a8eb0e78cd5206cc6a627c1d56ea296a18f598" translate="yes" xml:space="preserve">
          <source>A dependency is an object that can be used (&lt;code&gt;Service&lt;/code&gt;)</source>
          <target state="translated">Una dependencia es un objeto que se puede usar ( &lt;code&gt;Service&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d726743d668b3ba1c937402de85725ec11622168" translate="yes" xml:space="preserve">
          <source>A nice comment by Jose Maria Arranz on DI</source>
          <target state="translated">Un bonito comentario de José María Arranz sobre el DI</target>
        </trans-unit>
        <trans-unit id="55bbd203453572a1a2a8545b2a4e406f89f8d6bc" translate="yes" xml:space="preserve">
          <source>About replaceable: with a very simple .properties archive and Class.forName you can define wich classes can change. If ANY class of your code can be changed, Java is not for you, use an scripting language.  By the way: annotations cannot be changed without recompiling.</source>
          <target state="translated">Acerca de lo reemplazable:con un archivo .properties muy simple y Class.forName puedes definir qué clases pueden cambiar.Si CUALQUIER clase de tu código puede ser cambiada,Java no es para ti,usa un lenguaje de scripting.Por cierto:las anotaciones no pueden ser cambiadas sin recompilar.</target>
        </trans-unit>
        <trans-unit id="e431d362be915c2e12e2e8aec306dfb48350104c" translate="yes" xml:space="preserve">
          <source>Actually,Suppose in java you created two different classes as class A and class B, and whatever the function are available in class B you want to use in class A, So at that time dependency injection can be used.
where you can crate object of one class in other,in the same way you can inject an entire class in another class to make it accessible.
by this way dependency can be overcome.</source>
          <target state="translated">En realidad,supongamos que en java has creado dos clases diferentes como clase A y clase B,y que cualquiera que sea la función disponible en la clase B que quieras usar en la clase A,entonces en ese momento la inyección de la dependencia puede ser usada.donde puedes encajonar el objeto de una clase en otra,de la misma manera puedes inyectar una clase entera en otra clase para hacerla accesible.de esta manera la dependencia puede ser superada.</target>
        </trans-unit>
        <trans-unit id="b5e7a0d53d6a3064057c2db69d7bd1bb143ac3e8" translate="yes" xml:space="preserve">
          <source>All the three classes can be hidden for it's own implementation. Now we can use this code for DI:</source>
          <target state="translated">Las tres clases pueden ser ocultadas para su propia implementación.Ahora podemos usar este código para el DI:</target>
        </trans-unit>
        <trans-unit id="9f4e112e7a703ff0642590623727505b80c743dd" translate="yes" xml:space="preserve">
          <source>Allowing expensive resources or services to be created as late as possible and only when needed.</source>
          <target state="translated">Permitiendo que se creen recursos o servicios costosos lo más tarde posible y sólo cuando se necesiten.</target>
        </trans-unit>
        <trans-unit id="b73b678b4942a0f37f86394e629e8cffab4b632e" translate="yes" xml:space="preserve">
          <source>Also when we have many dependencies it is very good practice to use Inversion of Control(IoC) containers which we can tell which interfaces should be mapped to which concrete implementations for all our dependencies and we can have it resolve those dependencies for us when it constructs our object. For example, we could specify in the mapping for the IoC container that the &lt;strong&gt;IEngine&lt;/strong&gt; dependency should be mapped to the &lt;strong&gt;GasEngine&lt;/strong&gt; class and when we ask the IoC container for an instance of our &lt;strong&gt;Car&lt;/strong&gt; class, it will automatically construct our &lt;strong&gt;Car&lt;/strong&gt; class with a &lt;strong&gt;GasEngine&lt;/strong&gt; dependency passed in.</source>
          <target state="translated">Adem&amp;aacute;s, cuando tenemos muchas dependencias, es una muy buena pr&amp;aacute;ctica usar contenedores de Inversi&amp;oacute;n de Control (IoC), que podemos decir qu&amp;eacute; interfaces deben asignarse a qu&amp;eacute; implementaciones concretas para todas nuestras dependencias y podemos hacer que resuelva esas dependencias cuando construya nuestro objeto Por ejemplo, podr&amp;iacute;amos especificar en la asignaci&amp;oacute;n para el contenedor IoC que la dependencia de &lt;strong&gt;IEngine&lt;/strong&gt; deber&amp;iacute;a asignarse a la clase &lt;strong&gt;GasEngine&lt;/strong&gt; y cuando le pedimos al contenedor IoC una instancia de nuestra clase &lt;strong&gt;Car&lt;/strong&gt; , construir&amp;aacute; autom&amp;aacute;ticamente nuestra clase &lt;strong&gt;Car&lt;/strong&gt; con una dependencia &lt;strong&gt;GasEngine&lt;/strong&gt; aprobada en.</target>
        </trans-unit>
        <trans-unit id="992414fdd7e72886a072118a7f3b02c1d3b532c2" translate="yes" xml:space="preserve">
          <source>Although seemingly innocuous, it has two &lt;code&gt;static&lt;/code&gt; dependencies on two other classes, &lt;code&gt;System.DateTime&lt;/code&gt; and &lt;code&gt;System.Console&lt;/code&gt;, which not only limit the logging output options (logging to console will be worthless if no one is watching), but worse, it is difficult to automatically test given the dependency on a non-deterministic system clock.</source>
          <target state="translated">Aunque parece inocuo, tiene dos dependencias &lt;code&gt;static&lt;/code&gt; en otras dos clases, &lt;code&gt;System.DateTime&lt;/code&gt; y &lt;code&gt;System.Console&lt;/code&gt; , que no solo limitan las opciones de salida de registro (el registro en la consola no valdr&amp;aacute; nada si nadie est&amp;aacute; mirando), pero lo que es peor, es dif&amp;iacute;cil para probar autom&amp;aacute;ticamente dada la dependencia de un reloj de sistema no determinista.</target>
        </trans-unit>
        <trans-unit id="608e86855b2a65e39ae912fd39a0fa1102aef2e4" translate="yes" xml:space="preserve">
          <source>An automated Unit Test can be built, which definitively proves that our logger is working correctly, as we now have control over the dependencies - the time, and we can spy on the written output:</source>
          <target state="translated">Se puede construir una prueba de unidad automatizada,que prueba definitivamente que nuestro registrador funciona correctamente,ya que ahora tenemos el control de las dependencias-el tiempo,y podemos espiar la salida escrita:</target>
        </trans-unit>
        <trans-unit id="70687f8f4f2b763df000dbed64d4fb27b23ff917" translate="yes" xml:space="preserve">
          <source>An injection is the passing of a dependency (&lt;code&gt;Service&lt;/code&gt;) to a dependent object (&lt;code&gt;Client&lt;/code&gt;) that would use it</source>
          <target state="translated">Una inyecci&amp;oacute;n es el paso de una dependencia ( &lt;code&gt;Service&lt;/code&gt; ) a un objeto dependiente ( &lt;code&gt;Client&lt;/code&gt; e ) que lo usar&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="22de376201dcf4ad21e64690cf593a42ea12c2ce" translate="yes" xml:space="preserve">
          <source>And to instantiate the Car class we will use next code:</source>
          <target state="translated">Y para instanciar la clase de auto usaremos el siguiente código:</target>
        </trans-unit>
        <trans-unit id="5d989001b3ba666eebb2d9b73b1ed4f8b0f5b41d" translate="yes" xml:space="preserve">
          <source>Any application is composed of many objects that collaborate with each other to perform some useful stuff. Traditionally each object is responsible for obtaining its own references to the dependent objects (dependencies) it collaborate with. This leads to highly coupled classes and hard-to-test code.</source>
          <target state="translated">Cualquier aplicación se compone de muchos objetos que colaboran entre sí para realizar algunas cosas útiles.Tradicionalmente cada objeto es responsable de obtener sus propias referencias de los objetos dependientes (dependencias)con los que colabora.Esto conduce a clases altamente acopladas y código difícil de probar.</target>
        </trans-unit>
        <trans-unit id="dcd3c9a7013d9400c6621023f7f9889b2d159708" translate="yes" xml:space="preserve">
          <source>Any time where you will need to unit test the methods of a class in isolation of its dependencies,</source>
          <target state="translated">En cualquier momento en que se necesite probar los métodos de una clase en forma aislada de sus dependencias,</target>
        </trans-unit>
        <trans-unit id="8a5fc50e3ceaa03d10efa641f9932ed3164ec099" translate="yes" xml:space="preserve">
          <source>Application calls Foo</source>
          <target state="translated">La aplicación llama a Foo</target>
        </trans-unit>
        <trans-unit id="ac42390e19be354858b8262243637ee16d63efc2" translate="yes" xml:space="preserve">
          <source>Application creates Bar and gives it Bim</source>
          <target state="translated">La aplicación crea la barra y le da a Bim</target>
        </trans-unit>
        <trans-unit id="cc24fa2cfa1ade20a4b0568072650d805b3f7a37" translate="yes" xml:space="preserve">
          <source>Application creates Bim</source>
          <target state="translated">La aplicación crea Bim</target>
        </trans-unit>
        <trans-unit id="70579284eb400d7297fa45f23e86008434a5dae7" translate="yes" xml:space="preserve">
          <source>Application creates Foo</source>
          <target state="translated">La aplicación crea Foo</target>
        </trans-unit>
        <trans-unit id="c0f19361a5c397f8b9f7a8e3a097732fbca45296" translate="yes" xml:space="preserve">
          <source>Application creates Foo and gives it Bar</source>
          <target state="translated">La aplicación crea Foo y le da Bar</target>
        </trans-unit>
        <trans-unit id="7f33a152d579b4e1ccdf69ca92b2a96ddcd2dca4" translate="yes" xml:space="preserve">
          <source>Application gets Foo from the Container, so:</source>
          <target state="translated">La aplicación obtiene Foo del contenedor,así que:</target>
        </trans-unit>
        <trans-unit id="1a435d46695a15e5ef97ebb4802372a00c982aa2" translate="yes" xml:space="preserve">
          <source>Application needs Foo (e.g. a controller), so:</source>
          <target state="translated">La aplicación necesita Foo (por ejemplo,un controlador),así que:</target>
        </trans-unit>
        <trans-unit id="63f0eb90a103bbcdae0831a58efe78a5893f2f45" translate="yes" xml:space="preserve">
          <source>Application needs Foo so:</source>
          <target state="translated">La solicitud necesita Foo so:</target>
        </trans-unit>
        <trans-unit id="9be6e530a74dcafa45c7b24d7025184525c1bc10" translate="yes" xml:space="preserve">
          <source>Application needs Foo, which needs Bar, which needs Bim, so:</source>
          <target state="translated">La aplicación necesita a Foo,que necesita a Bar,que necesita a Bim,así que:</target>
        </trans-unit>
        <trans-unit id="41f971b49b630ecc0dbd5fbc5a28c4f03ee52f5d" translate="yes" xml:space="preserve">
          <source>As others have said, &lt;em&gt;Dependency Injection(DI)&lt;/em&gt; removes the responsibility of direct creation, and management of the lifespan, of other object instances upon which our class of interest (consumer class) is dependent (in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency&quot;&gt;UML sense&lt;/a&gt;). These instances are instead passed to our consumer class, typically as constructor parameters or via property setters (the management of the dependency object instancing and passing to the consumer class is usually performed by an &lt;em&gt;Inversion of Control (IoC)&lt;/em&gt; container, but that's another topic).</source>
          <target state="translated">Como han dicho otros, la &lt;em&gt;inyecci&amp;oacute;n de dependencia (DI)&lt;/em&gt; elimina la responsabilidad de la creaci&amp;oacute;n directa y la gesti&amp;oacute;n de la vida &amp;uacute;til de otras instancias de objeto de las que depende nuestra clase de inter&amp;eacute;s (clase de consumidor) (en el &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency&quot;&gt;sentido UML&lt;/a&gt; ). En su lugar, estas instancias se pasan a nuestra clase de consumidor, generalmente como par&amp;aacute;metros de constructor o mediante establecedores de propiedades (la gesti&amp;oacute;n de la instancia del objeto de dependencia y el paso a la clase de consumidor generalmente se realiza mediante un contenedor &lt;em&gt;de Inversi&amp;oacute;n de control (IoC)&lt;/em&gt; , pero ese es otro tema) .</target>
        </trans-unit>
        <trans-unit id="08399bcb01b547cab14e44b28e00c30b6c0663f3" translate="yes" xml:space="preserve">
          <source>As per above example, decoupling of dependencies does require some design effort, and for the developer, there is a paradigm shift needed to break the habit of &lt;code&gt;new&lt;/code&gt;ing dependencies directly, and instead trusting the container to manage dependencies.</source>
          <target state="translated">Seg&amp;uacute;n el ejemplo anterior, el desacoplamiento de dependencias requiere cierto esfuerzo de dise&amp;ntilde;o, y para el desarrollador, se necesita un cambio de paradigma para romper el h&amp;aacute;bito de &lt;code&gt;new&lt;/code&gt; dependencias directamente, y en su lugar confiar en el contenedor para administrar las dependencias.</target>
        </trans-unit>
        <trans-unit id="fff41238dbef5b816e589fb9ecf3cbde7896731e" translate="yes" xml:space="preserve">
          <source>Bar creates Bim</source>
          <target state="translated">Bar crea a Bim</target>
        </trans-unit>
        <trans-unit id="452099fc339bb9ab1a4137666deb3f1f3b017433" translate="yes" xml:space="preserve">
          <source>Bar does something</source>
          <target state="translated">El bar hace algo</target>
        </trans-unit>
        <trans-unit id="2b2cfde5abc29f811788f8a477a12b0d271a2ada" translate="yes" xml:space="preserve">
          <source>Bar needs Bim (a service, a repository,
&amp;hellip;), so:</source>
          <target state="translated">Bar necesita Bim (un servicio, un repositorio, ...), entonces:</target>
        </trans-unit>
        <trans-unit id="ae219b96ca6e4a1b3a53e426dca90a803fe2da20" translate="yes" xml:space="preserve">
          <source>But consider the following example&amp;hellip; Suppose you have a class with ten methods that have no dependencies, but you&amp;rsquo;re adding a new method that does have a dependency on IDAO. You could change the constructor to use Constructor Injection, but this may force you to changes to all constructor calls all over the place. Alternatively, you could just add a new constructor that takes the dependency, but then how does a developer easily know when to use one constructor over the other. Finally, if the dependency is very expensive to create, why should it be created and passed to the constructor when it may only be used rarely? &amp;ldquo;Setter Injection&amp;rdquo; is another DI technique that can be used in situations such as this.</source>
          <target state="translated">Pero considere el siguiente ejemplo ... Suponga que tiene una clase con diez m&amp;eacute;todos que no tienen dependencias, pero est&amp;aacute; agregando un nuevo m&amp;eacute;todo que s&amp;iacute; depende de IDAO. Puede cambiar el constructor para usar la inyecci&amp;oacute;n de constructor, pero esto puede obligarlo a cambiar todas las llamadas de constructor por todas partes. Alternativamente, podr&amp;iacute;a agregar un nuevo constructor que tome la dependencia, pero entonces, &amp;iquest;c&amp;oacute;mo sabe un desarrollador f&amp;aacute;cilmente cu&amp;aacute;ndo usar un constructor sobre el otro? Finalmente, si la dependencia es muy costosa de crear, &amp;iquest;por qu&amp;eacute; deber&amp;iacute;a crearse y pasarse al constructor cuando solo puede usarse raramente? La &quot;inyecci&amp;oacute;n Setter&quot; es otra t&amp;eacute;cnica de DI que se puede utilizar en situaciones como esta.</target>
        </trans-unit>
        <trans-unit id="1778648e0dd763c5f5a9c7958ded52526966ceb6" translate="yes" xml:space="preserve">
          <source>But it's a generic approach to split concerns of:</source>
          <target state="translated">Pero es un enfoque genérico para dividir las preocupaciones de:</target>
        </trans-unit>
        <trans-unit id="19a17a99cb30f6d4a5536c327bad501717385b19" translate="yes" xml:space="preserve">
          <source>But the benefits are many, especially in the ability to thoroughly test your class of interest.</source>
          <target state="translated">Pero los beneficios son muchos,especialmente en la capacidad de probar a fondo su clase de interés.</target>
        </trans-unit>
        <trans-unit id="f690c20291f1b4d985514efeb98b89687022ac96" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;https://en.wikipedia.org/wiki/Dependency_injection&lt;/a&gt;</source>
          <target state="translated">Verifique &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;https://en.wikipedia.org/wiki/Dependency_injection&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e531036736b85e446725e4e4e6164a78cdfb8c9c" translate="yes" xml:space="preserve">
          <source>Consider simple &lt;code&gt;dependent.sh&lt;/code&gt; script:</source>
          <target state="translated">Considere la secuencia de comandos &lt;code&gt;dependent.sh&lt;/code&gt; simple:</target>
        </trans-unit>
        <trans-unit id="a938a98716a29fea8b403330f964cb8cf46392e9" translate="yes" xml:space="preserve">
          <source>Constructor Injection</source>
          <target state="translated">Inyección de Constructor</target>
        </trans-unit>
        <trans-unit id="b5773fd2800024a3f838fe7729940f9f8e15e065" translate="yes" xml:space="preserve">
          <source>Constructor injection</source>
          <target state="translated">Inyección del constructor</target>
        </trans-unit>
        <trans-unit id="26032cadfd8928d408ef47b863c4b45733ef2d0d" translate="yes" xml:space="preserve">
          <source>Constructor with dependency injection:</source>
          <target state="translated">Constructor con inyección de dependencia:</target>
        </trans-unit>
        <trans-unit id="3f2bf7f408c28388ad6bd617db22886b5fe56b26" translate="yes" xml:space="preserve">
          <source>Constructor without dependency injection:</source>
          <target state="translated">Constructor sin inyección de dependencia:</target>
        </trans-unit>
        <trans-unit id="b2146937a33bfcabf2430053c4204e88638eba30" translate="yes" xml:space="preserve">
          <source>Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on other class.</source>
          <target state="translated">El DI basado en el constructor se logra cuando el contenedor invoca a un constructor de clase con una serie de argumentos,cada uno de los cuales representa una dependencia de otra clase.</target>
        </trans-unit>
        <trans-unit id="faa2e023d8bf9a1b5e13e711551447a2e6bc4da2" translate="yes" xml:space="preserve">
          <source>Container creates Bar and gives it Bim</source>
          <target state="translated">El contenedor crea el Bar y le da a Bim</target>
        </trans-unit>
        <trans-unit id="e72228b222f6d8727f4e55af720a28149a261110" translate="yes" xml:space="preserve">
          <source>Container creates Bim</source>
          <target state="translated">El contenedor crea a Bim</target>
        </trans-unit>
        <trans-unit id="6653855bc3a85ec8d066669874a2916aaf0d2c9e" translate="yes" xml:space="preserve">
          <source>Container creates Foo and gives it Bar</source>
          <target state="translated">El contenedor crea Foo y le da Bar</target>
        </trans-unit>
        <trans-unit id="8ac27f6a08ba25f489c38925c6e85a272db84091" translate="yes" xml:space="preserve">
          <source>DEPENDENCY INJECTION IS SIMPLY GLUING TWO CLASSES AND AT THE SAME TIME KEEPING THEM SEPARATE.</source>
          <target state="translated">LA INYECCIÓN DE DEPENDENCIA ES SIMPLEMENTE PEGAR DOS CLASES Y AL MISMO TIEMPO MANTENERLAS SEPARADAS.</target>
        </trans-unit>
        <trans-unit id="08ebf9ead9196a1af9ffc22cd9c1eeb51be76894" translate="yes" xml:space="preserve">
          <source>DI brings you closer to the Single Responsibility (SR) principle, like the &lt;code&gt;surgeon who can concentrate on surgery&lt;/code&gt;.</source>
          <target state="translated">DI lo acerca al principio de responsabilidad &amp;uacute;nica (SR), como el &lt;code&gt;surgeon who can concentrate on surgery&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a43f9d298673ad95516fee4e62a2a823a586584a" translate="yes" xml:space="preserve">
          <source>DI for short, is a technique to remove a common additional responsibility (burden) on components to fetch the dependent components, by providing them to it.</source>
          <target state="translated">DI para abreviar,es una técnica para eliminar una responsabilidad (carga)adicional común sobre los componentes para ir a buscar los componentes dependientes,proporcionándoselos.</target>
        </trans-unit>
        <trans-unit id="4f5d36ed84699163eaf23e5a7fdfc103b0bbc15e" translate="yes" xml:space="preserve">
          <source>DI is a particular form of IoC, whereby the process of finding your dependencies is
  outside the direct control of your currently executing code.</source>
          <target state="translated">DI es una forma particular de IoC,por la cual el proceso de encontrar sus dependencias está fuera del control directo de su código de ejecución actual.</target>
        </trans-unit>
        <trans-unit id="feb00fd97973bff59f7d3245f637dd67debab5a4" translate="yes" xml:space="preserve">
          <source>DI is analogous to this in the world of Object Oriented programming.  The values there instead of constant literals are whole objects - but the reason to move the code creating them out from the class code is similar - the objects change more frequently then the code that uses them.  One important case where such a change is needed is tests.</source>
          <target state="translated">DI es análogo a esto en el mundo de la programación orientada a objetos.Los valores allí en lugar de literales constantes son objetos enteros-pero la razón para mover el código que los crea fuera del código de la clase es similar-los objetos cambian más frecuentemente que el código que los usa.Un caso importante en el que se necesita tal cambio son las pruebas.</target>
        </trans-unit>
        <trans-unit id="2e8b1223bba2170ce6128ed0e576d38e0241b406" translate="yes" xml:space="preserve">
          <source>DI is not as largely emphasized and popularized as in Java frameworks.</source>
          <target state="translated">El DI no se destaca ni se populariza tanto como en los marcos de Java.</target>
        </trans-unit>
        <trans-unit id="e75ded6d3588df205b0011e584a93bde9df27a8f" translate="yes" xml:space="preserve">
          <source>DI is the implementation of IOC principal of Spring which says &quot;Don't call us we will call you&quot;. Using dependency injection programmer doesn't need to create object using the new keyword.</source>
          <target state="translated">DI es la aplicación del director de la COI de la primavera que dice &quot;No nos llames,nosotros te llamaremos&quot;.Usando la inyección de dependencia el programador no necesita crear el objeto usando la nueva palabra clave.</target>
        </trans-unit>
        <trans-unit id="88de733e17606a4266cbf096951b24a70dd9b893" translate="yes" xml:space="preserve">
          <source>DI means there is an intermediate level between the caller and the constructor which manages dependencies. A Makefile is a simple example of dependency injection. The &quot;caller&quot; is the person typing &quot;make bar&quot; on the command line, and the &quot;constructor&quot; is the compiler. The Makefile specifies that bar depends on foo, and it does a</source>
          <target state="translated">DI significa que hay un nivel intermedio entre el llamante y el constructor que gestiona las dependencias.Un Makefile es un ejemplo simple de inyección de dependencia.El &quot;llamador&quot; es la persona que teclea &quot;make bar&quot; en la línea de comandos,y el &quot;constructor&quot; es el compilador.El Makefile especifica que la barra depende de foo,y hace un</target>
        </trans-unit>
        <trans-unit id="007835874d333d08ff81faee651cdd6f320b4cd1" translate="yes" xml:space="preserve">
          <source>Decoupling dependencies between classes in this way allows for &lt;em&gt;easy substitution&lt;/em&gt; of these dependency classes with other implementations which also fulfil the prerequisites of the abstraction (e.g. the dependency can be switched with another implementation of the same interface). Moreover, as others have mentioned, possibly &lt;em&gt;the&lt;/em&gt; most common reason to decouple classes via the DIP is to allow a consuming class to be tested in isolation, as these same dependencies can now be stubbed and/or mocked.</source>
          <target state="translated">El desacoplamiento de las dependencias entre clases de esta manera permite una &lt;em&gt;f&amp;aacute;cil sustituci&amp;oacute;n&lt;/em&gt; de estas clases de dependencia con otras implementaciones que tambi&amp;eacute;n cumplen los requisitos previos de la abstracci&amp;oacute;n (por ejemplo, la dependencia se puede cambiar con otra implementaci&amp;oacute;n de la misma interfaz). Adem&amp;aacute;s, como otros han mencionado, posiblemente &lt;em&gt;la&lt;/em&gt; raz&amp;oacute;n m&amp;aacute;s com&amp;uacute;n para desacoplar clases a trav&amp;eacute;s del DIP es permitir que una clase consumidora se pruebe de forma aislada, ya que estas mismas dependencias ahora se pueden tropezar y / o burlar.</target>
        </trans-unit>
        <trans-unit id="8373baaef22105a8574ebe7cace135c9de92ef3f" translate="yes" xml:space="preserve">
          <source>Dependencies can be injected into objects by many means (such as constructor injection or setter injection). One can even use specialized dependency injection frameworks (e.g. Spring) to do that, but they certainly aren't required. You don't need those frameworks to have dependency injection. Instantiating and passing objects (dependencies) explicitly is just as good an injection as injection by framework.</source>
          <target state="translated">Las dependencias pueden ser inyectadas en los objetos por muchos medios (como la inyección de constructor o la inyección de fijador).Incluso se pueden utilizar marcos especializados de inyección de dependencias (por ejemplo,Spring)para hacerlo,pero ciertamente no son necesarios.No se necesitan esos armazones para tener una inyección de dependencia.Instanciar y pasar objetos (dependencias)explícitamente es tan bueno como la inyección por marco.</target>
        </trans-unit>
        <trans-unit id="805edc480d58383c8e5e2cdbb15c0f0b990469a8" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is one from Design Patterns, which uses the basic feature of OOP - the relationship in one object with another object. While inheritance inherits one object to do more complex and specific another object, relationship or association simply creates a pointer to another object from one object using attribute. The power of DI is in combination with other features of OOP as are interfaces and hiding code.
Suppose, we have a customer (subscriber) in the library, which can borrow only one book for simplicity.</source>
          <target state="translated">La Inyección de Dependencia (DI)es una de los Patrones de Diseño,que utiliza la característica básica de OOP-la relación en un objeto con otro objeto.Mientras que la herencia hereda un objeto para hacer más complejo y específico otro objeto,la relación o asociación simplemente crea un puntero a otro objeto de un objeto usando un atributo.El poder de DI está en combinación con otras características de OOP como son las interfaces y el código oculto.Supongamos que tenemos un cliente (suscriptor)en la biblioteca,que sólo puede pedir prestado un libro por simplicidad.</target>
        </trans-unit>
        <trans-unit id="2eaf5885c756aab73a83e3523b8617e6e5448a02" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is part of Dependency Inversion Principle (DIP) practice, which is also called Inversion of Control (IoC). Basically you need to do DIP because you want to make your code more modular and unit testable, instead of just one monolithic system. So you start identifying parts of the code that can be separated from the class and abstracted away. Now the implementation of the abstraction need to be injected from outside of the class. Normally this can be done via constructor. So you create a constructor that accepts the abstraction as a parameter, and this is called dependency injection (via constructor). For more explanation about DIP, DI, and IoC container you can read &lt;a href=&quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">La inyecci&amp;oacute;n de dependencia (DI) es parte de la pr&amp;aacute;ctica del Principio de inversi&amp;oacute;n de dependencia (DIP), que tambi&amp;eacute;n se llama Inversi&amp;oacute;n de control (IoC). B&amp;aacute;sicamente, debe hacer DIP porque desea hacer que su c&amp;oacute;digo sea m&amp;aacute;s modular y comprobable por unidad, en lugar de un solo sistema monol&amp;iacute;tico. Entonces comienza a identificar partes del c&amp;oacute;digo que pueden separarse de la clase y extraerse. Ahora, la implementaci&amp;oacute;n de la abstracci&amp;oacute;n debe ser inyectada desde fuera de la clase. Normalmente esto se puede hacer a trav&amp;eacute;s del constructor. Entonces crea un constructor que acepta la abstracci&amp;oacute;n como un par&amp;aacute;metro, y esto se llama inyecci&amp;oacute;n de dependencia (a trav&amp;eacute;s del constructor). Para obtener m&amp;aacute;s explicaciones sobre el contenedor DIP, DI y IoC, puede leer &lt;a href=&quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec9e1e9a757b12d7ba7015b1965d7e8d66b82118" translate="yes" xml:space="preserve">
          <source>Dependency Injection definition</source>
          <target state="translated">Definición de inyección de dependencia</target>
        </trans-unit>
        <trans-unit id="cb2cb0f05e812293b7ad0ba1d7be1914b8ecef4e" translate="yes" xml:space="preserve">
          <source>Dependency Injection is a method for writing better code</source>
          <target state="translated">La inyección de dependencia es un método para escribir mejor el código</target>
        </trans-unit>
        <trans-unit id="cddf49311cde392103b798084c33da2a7ca7c60e" translate="yes" xml:space="preserve">
          <source>Dependency Injection is a practice where objects are designed in a manner where they receive instances of the objects from other pieces of code, instead of constructing them internally. This means that any object implementing the interface which is required by the object can be substituted in without changing the code, which simplifies testing, and improves decoupling.</source>
          <target state="translated">La inyección de dependencia es una práctica en la que los objetos se diseñan de manera que reciben instancias de los objetos de otras piezas de código,en lugar de construirlos internamente.Esto significa que cualquier objeto que implemente la interfaz requerida por el objeto puede ser sustituido sin cambiar el código,lo que simplifica las pruebas y mejora el desacoplamiento.</target>
        </trans-unit>
        <trans-unit id="afcfc311b0f222c1476db1b255d403234af0b4db" translate="yes" xml:space="preserve">
          <source>Dependency Injection is the process of creating the static, stateless
  graph of service objects, where each service is parametrised by its
  dependencies.</source>
          <target state="translated">La inyección de dependencia es el proceso de creación del gráfico estático y sin estado de los objetos de servicio,donde cada servicio está parametrizado por sus dependencias.</target>
        </trans-unit>
        <trans-unit id="64a15438c3caa440c0a5dc9eb291180789196b8d" translate="yes" xml:space="preserve">
          <source>Dependency Injection(DI) means to decouple the objects which are dependent on each other. Say object A is dependent on Object B so the idea is to decouple these object from each other. We don&amp;rsquo;t need to hard code the object using new keyword rather sharing dependencies to objects at runtime in spite of compile time.
If we talk about</source>
          <target state="translated">La inyecci&amp;oacute;n de dependencia (DI) significa desacoplar los objetos que dependen unos de otros. Digamos que el objeto A depende del objeto B, por lo que la idea es desacoplar estos objetos entre s&amp;iacute;. No necesitamos codificar el objeto con una nueva palabra clave, en lugar de compartir dependencias con los objetos en tiempo de ejecuci&amp;oacute;n a pesar del tiempo de compilaci&amp;oacute;n. Si hablamos de</target>
        </trans-unit>
        <trans-unit id="5ca81c175fbe0a8a94fd156ed8fda57771b7acaa" translate="yes" xml:space="preserve">
          <source>Dependency injection is a pattern to allow your application to inject
  objects on the fly to classes that need them, without forcing those
  classes to be responsible for those objects. It allows your code to be
  more loosely coupled, and Entity Framework Core plugs in to this same
  system of services.</source>
          <target state="translated">La inyección de dependencia es un patrón que permite a su aplicación inyectar objetos sobre la marcha a las clases que los necesitan,sin obligar a esas clases a ser responsables de esos objetos.Permite que su código esté acoplado más libremente,y Entity Framework Core se conecta a este mismo sistema de servicios.</target>
        </trans-unit>
        <trans-unit id="f51897ce4672efc871df38ef9ec8a1e2a4f4a7a3" translate="yes" xml:space="preserve">
          <source>Dependency injection is a pattern used to create instances of objects that other objects rely upon without knowing at compile time which class will be used to provide that functionality or simply the way of injecting properties to an object is called dependency injection.</source>
          <target state="translated">La inyección de dependencia es un patrón utilizado para crear instancias de objetos en los que otros objetos dependen sin saber en el momento de la compilación qué clase se utilizará para proporcionar esa funcionalidad o simplemente la forma de inyectar propiedades a un objeto se denomina inyección de dependencia.</target>
        </trans-unit>
        <trans-unit id="c8bcf420f928a840f91a5b1e5c82929829ba86a5" translate="yes" xml:space="preserve">
          <source>Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It's a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.</source>
          <target state="translated">La inyección de dependencia es básicamente proporcionar los objetos que un objeto necesita (sus dependencias)en lugar de hacer que los construya él mismo.Es una técnica muy útil para las pruebas,ya que permite que las dependencias sean burladas o eliminadas.</target>
        </trans-unit>
        <trans-unit id="eb5f2c3f9e29f385abcc1436959a966409e80529" translate="yes" xml:space="preserve">
          <source>Dependency injection is invariably associated with an &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Inversion of Control container(IoC)&lt;/a&gt;, to inject (provide) the concrete dependency instances, and to manage lifespan instances. During the configuration / bootstrapping process, &lt;code&gt;IoC&lt;/code&gt; containers allow the following to be defined:</source>
          <target state="translated">La inyecci&amp;oacute;n de dependencia se asocia invariablemente con un &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;contenedor de Inversi&amp;oacute;n de control (IoC)&lt;/a&gt; , para inyectar (proporcionar) las instancias de dependencia concretas y para administrar instancias de vida &amp;uacute;til. Durante el proceso de configuraci&amp;oacute;n / arranque, los contenedores &lt;code&gt;IoC&lt;/code&gt; permiten definir lo siguiente:</target>
        </trans-unit>
        <trans-unit id="ca79292d85a27dbcae58c833ab50a3d5b3915751" translate="yes" xml:space="preserve">
          <source>Dependency injection is one of the design pattern that help us to create complex systems in a simpler manner.</source>
          <target state="translated">La inyección de dependencia es uno de los patrones de diseño que nos ayudan a crear sistemas complejos de una manera más simple.</target>
        </trans-unit>
        <trans-unit id="69c4857065501ad52a336a3696b71d18e67bed61" translate="yes" xml:space="preserve">
          <source>Dependency injection is one possible solution to what could generally be termed the &quot;Dependency Obfuscation&quot; requirement. Dependency Obfuscation is a method of taking the 'obvious' nature out of the process of providing a dependency to a class that requires it and therefore obfuscating, in some way, the provision of said dependency to said class. This is not necessarily a bad thing. In fact, by obfuscating the manner by which a dependency is provided to a class then something outside the class is responsible for creating the dependency which means, in various scenarios, a different implementation of the dependency can be supplied to the class without making any changes to the class. This is great for switching between production and testing modes (eg., using a 'mock' service dependency).</source>
          <target state="translated">La inyección de dependencia es una posible solución a lo que podría denominarse generalmente el requisito de &quot;Ofuscación de dependencia&quot;.La ofuscación de la dependencia es un método para eliminar la naturaleza &quot;obvia&quot; del proceso de proporcionar una dependencia a una clase que la requiere y,por lo tanto,ofuscar,de alguna manera,la provisión de dicha dependencia a dicha clase.Esto no es necesariamente algo malo.De hecho,al ofuscar la forma en que se proporciona una dependencia a una clase,entonces algo fuera de la clase se encarga de crear la dependencia,lo que significa que,en varios escenarios,se puede proporcionar una implementación diferente de la dependencia a la clase sin hacer ningún cambio en la misma.Esto es ideal para cambiar entre los modos de producción y de prueba (por ejemplo,utilizando una dependencia de servicio &quot;simulada&quot;).</target>
        </trans-unit>
        <trans-unit id="0170849003cd6320060ea1c729c9aa49b34c7fd9" translate="yes" xml:space="preserve">
          <source>Dependency injection is the heart of the concept related with Spring Framework.While creating the framework of any project spring may perform a vital role,and here dependency injection come in pitcher.</source>
          <target state="translated">La inyección de dependencia es el corazón del concepto relacionado con el Marco de Primavera.Mientras que la creación del marco de cualquier proyecto de primavera puede desempeñar un papel vital,y aquí la inyección de dependencia viene en jarra.</target>
        </trans-unit>
        <trans-unit id="e58f7f11fd58e3edec005e7035583eb40983e40f" translate="yes" xml:space="preserve">
          <source>Dependency injection makes testing easier. The injection can be done through &lt;strong&gt;constructor&lt;/strong&gt;.</source>
          <target state="translated">La inyecci&amp;oacute;n de dependencia facilita las pruebas. La inyecci&amp;oacute;n puede hacerse a trav&amp;eacute;s del &lt;strong&gt;constructor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ff309b1b6291468565c4f9a9f51b36a3e04dd3" translate="yes" xml:space="preserve">
          <source>Dependency:</source>
          <target state="translated">Dependency:</target>
        </trans-unit>
        <trans-unit id="7ffc6ee12bdc72c1564366d1210f30e558da7c21" translate="yes" xml:space="preserve">
          <source>Difference between Inversion of Control &amp;amp; Dependency Injection</source>
          <target state="translated">Diferencia entre inversi&amp;oacute;n de control e inyecci&amp;oacute;n de dependencia</target>
        </trans-unit>
        <trans-unit id="be57f0e0c6c38a3c5499991aa97bdbb4642cde74" translate="yes" xml:space="preserve">
          <source>Doesn't &quot;dependency injection&quot; just mean using parameterized constructors and public setters?</source>
          <target state="translated">¿La &quot;inyección de dependencia&quot; no significa sólo usar constructores parametrizados y fijadores públicos?</target>
        </trans-unit>
        <trans-unit id="dce70f9dbaf63e1888206b128af00b53f6dd310d" translate="yes" xml:space="preserve">
          <source>Everytime I want to change what objects my AClass needs, I need to now look into two places - The class itself and the configuration file. How does that make life easier?</source>
          <target state="translated">Cada vez que quiero cambiar los objetos que necesita mi AClass,tengo que mirar en dos sitios:la clase en sí y el archivo de configuración.¿Cómo hace eso más fácil la vida?</target>
        </trans-unit>
        <trans-unit id="624d5b857fe09b27ef0b52a651428cfe9bdeb229" translate="yes" xml:space="preserve">
          <source>Example, we have 2 class &lt;code&gt;Client&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt;. &lt;code&gt;Client&lt;/code&gt; will use &lt;code&gt;Service&lt;/code&gt;</source>
          <target state="translated">Ejemplo, tenemos 2 clases de &lt;code&gt;Client&lt;/code&gt; e y &lt;code&gt;Service&lt;/code&gt; . &lt;code&gt;Client&lt;/code&gt; usar&amp;aacute; el &lt;code&gt;Service&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cc967eb9e93b5533d3da79d75ffcafa1c607fa2" translate="yes" xml:space="preserve">
          <source>Example: DI with shell script</source>
          <target state="translated">Ejemplo:DI con shell script</target>
        </trans-unit>
        <trans-unit id="2f74df37b1ea988409f33c42af68c3062f522296" translate="yes" xml:space="preserve">
          <source>Example: removing DI</source>
          <target state="translated">Ejemplo:eliminar la DI</target>
        </trans-unit>
        <trans-unit id="4d32216898588a9d6769484729321b2a32005852" translate="yes" xml:space="preserve">
          <source>Externalizing dependency and looking only on responsibility.</source>
          <target state="translated">Externalizando la dependencia y mirando sólo a la responsabilidad.</target>
        </trans-unit>
        <trans-unit id="f94c5803a635417a4c63406b77fcbb7801e90db0" translate="yes" xml:space="preserve">
          <source>False. The direction of dependencies is in XML form or as annotations, your dependencies are written as XML code and annotations. XML and annotations ARE source code.</source>
          <target state="translated">Falso.La dirección de las dependencias está en forma de XML o como anotaciones,sus dependencias están escritas como código XML y anotaciones.El XML y las anotaciones SON código fuente.</target>
        </trans-unit>
        <trans-unit id="c66a3755f7748dad912a8f295d8660519cb19da7" translate="yes" xml:space="preserve">
          <source>False. You do not need a DI framework to build a modular code based on interfaces.</source>
          <target state="translated">Falso.No se necesita un marco DI para construir un código modular basado en interfaces.</target>
        </trans-unit>
        <trans-unit id="e9044ac31a8995f5ad62b7e9f444f33bf9e08657" translate="yes" xml:space="preserve">
          <source>Foo calls Bar</source>
          <target state="translated">Foo llama a Bar</target>
        </trans-unit>
        <trans-unit id="36a8c8318b6369919a71996fd940aacf3965166d" translate="yes" xml:space="preserve">
          <source>Foo creates Bar</source>
          <target state="translated">Foo crea el Bar</target>
        </trans-unit>
        <trans-unit id="c2cfcdd995da76d7e30b4bb8c5a58a247fe77380" translate="yes" xml:space="preserve">
          <source>Foo needs Bar (e.g. a service), so:</source>
          <target state="translated">Foo necesita un bar (por ejemplo,un servicio),así que:</target>
        </trans-unit>
        <trans-unit id="b181ce4ed346bf93fb78e315f5b4e0fdc64a362e" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Car&lt;/code&gt; object.</source>
          <target state="translated">Por ejemplo, considere un objeto &lt;code&gt;Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773f448aa74e9ddd91521dd1c2732d809239a14b" translate="yes" xml:space="preserve">
          <source>For example, consider these clases:</source>
          <target state="translated">Por ejemplo,considere estas clases:</target>
        </trans-unit>
        <trans-unit id="6301c293c982fc83aecdf06eaf96df22050f4fa1" translate="yes" xml:space="preserve">
          <source>From Christoffer Noring, Pablo Deeleman's book &amp;ldquo;Learning Angular - Second Edition&amp;rdquo;:</source>
          <target state="translated">De Christoffer Noring, el libro de Pablo Deeleman &quot;Learning Angular - Second Edition&quot;:</target>
        </trans-unit>
        <trans-unit id="d2f6f2619a4fc19e9326d217edd2b9cb13d7536f" translate="yes" xml:space="preserve">
          <source>From the Book, '&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1617290068&quot;&gt;Well-Grounded Java Developer: Vital techniques of Java 7 and polyglot programming&lt;/a&gt;</source>
          <target state="translated">Del libro, ' &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1617290068&quot;&gt;Desarrollador Java bien fundamentado: t&amp;eacute;cnicas vitales de Java 7 y programaci&amp;oacute;n pol&amp;iacute;glota&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="565b14720ba865ef973ba05f90a124c36bd9081e" translate="yes" xml:space="preserve">
          <source>From: Anton Moiseev. book &amp;ldquo;Angular Development with Typescript, Second Edition.&amp;rdquo;:</source>
          <target state="translated">De: Anton Moiseev. libro &quot;Desarrollo angular con mecanografiado, segunda edici&amp;oacute;n&quot;:</target>
        </trans-unit>
        <trans-unit id="7cc777757b505d7bbd1af628607007866c70d979" translate="yes" xml:space="preserve">
          <source>Going back to the first question. If using new object() is bad, how come we inject the implementation and not the interface? I think a lot of you are saying we're in fact injecting the interface but the configuration makes you specify the implementation of that interface ..not at runtime .. it is hardcoded during compile time.</source>
          <target state="translated">Volviendo a la primera pregunta.Si usar un nuevo objeto()es malo,¿cómo es que inyectamos la implementación y no la interfaz? Creo que muchos de ustedes están diciendo que de hecho estamos inyectando la interfaz,pero la configuración hace que se especifique la implementación de esa interfaz...no en tiempo de ejecución...está hardcoded durante el tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="28843d4be0ee34f253cca7cab2361c2a39ee4828" translate="yes" xml:space="preserve">
          <source>Hard for test &lt;code&gt;Client&lt;/code&gt; class</source>
          <target state="translated">Dif&amp;iacute;cil para probar Clase de &lt;code&gt;Client&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aed8ebadb57ba9dd2776c20874fb02210f043c0" translate="yes" xml:space="preserve">
          <source>Here is the example of how the above code would look like:</source>
          <target state="translated">Aquí está el ejemplo de cómo se vería el código anterior:</target>
        </trans-unit>
        <trans-unit id="43c80abc12795e6e4cb2a72b1e6d9012d550d4e0" translate="yes" xml:space="preserve">
          <source>Here we basically inject(pass) our dependency(Engine instance) to Car constructor. So now our classes have loose coupling between objects and their dependencies, and we can easily add new types of engines without changing the Car class.</source>
          <target state="translated">Aquí básicamente inyectamos nuestra dependencia al constructor de coches.Así que ahora nuestras clases tienen un acoplamiento flojo entre los objetos y sus dependencias,y podemos añadir fácilmente nuevos tipos de motores sin cambiar la clase de coche.</target>
        </trans-unit>
        <trans-unit id="371a2ec52294658d0a3b4228a46b7d8f33efffe9" translate="yes" xml:space="preserve">
          <source>Here's a simple C# implementation. Given the below Consuming class:</source>
          <target state="translated">Aquí hay una simple implementación de C#.Dada la siguiente clase de consumo:</target>
        </trans-unit>
        <trans-unit id="922004128193bca294dd5fdb14c71cac1cae1545" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;Car&lt;/code&gt; object &lt;em&gt;is responsible for creating the dependent objects.&lt;/em&gt;</source>
          <target state="translated">Aqu&amp;iacute;, el objeto &lt;code&gt;Car&lt;/code&gt; &lt;em&gt;es responsable de crear los objetos dependientes.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0969f6c9b11047ca63ee874c7cf8c550f36eaef" translate="yes" xml:space="preserve">
          <source>Here, we are &lt;strong&gt;injecting&lt;/strong&gt; the &lt;strong&gt;dependencies&lt;/strong&gt; (Wheel and Battery) at runtime. Hence the term : &lt;em&gt;Dependency Injection.&lt;/em&gt;</source>
          <target state="translated">Aqu&amp;iacute;, estamos &lt;strong&gt;inyectando&lt;/strong&gt; las &lt;strong&gt;dependencias&lt;/strong&gt; (Wheel y Battery) en tiempo de ejecuci&amp;oacute;n. De ah&amp;iacute; el t&amp;eacute;rmino: &lt;em&gt;inyecci&amp;oacute;n de dependencia.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="379dffc1a3970a2596b05e27d433878025eb9945" translate="yes" xml:space="preserve">
          <source>High cohesion and loose coupling.</source>
          <target state="translated">Alta cohesión y acoplamiento flojo.</target>
        </trans-unit>
        <trans-unit id="00bf8b24a1d88295bc7cfc6557e03947a6402c26" translate="yes" xml:space="preserve">
          <source>How Dependency Injection works in Spring:</source>
          <target state="translated">Cómo funciona la inyección de dependencia en primavera:</target>
        </trans-unit>
        <trans-unit id="57367ae4f39a638d3dbf05ee497ca936efcff588" translate="yes" xml:space="preserve">
          <source>However, we still use &lt;code&gt;new Service()&lt;/code&gt; many time and it is not good when change &lt;code&gt;Service&lt;/code&gt; constructor. To prevent it, we can use DI injector like</source>
          <target state="translated">Sin embargo, todav&amp;iacute;a usamos el &lt;code&gt;new Service()&lt;/code&gt; muchas veces y no es bueno cuando cambiamos el constructor del &lt;code&gt;Service&lt;/code&gt; . Para evitarlo, podemos usar inyectores DI como</target>
        </trans-unit>
        <trans-unit id="f0d455ffdb1c3dbcd06e6b82c66932dc9c227efa" translate="yes" xml:space="preserve">
          <source>I know there are already many answers, but I found this very helpful: &lt;a href=&quot;http://tutorials.jenkov.com/dependency-injection/index.html&quot;&gt;http://tutorials.jenkov.com/dependency-injection/index.html&lt;/a&gt;</source>
          <target state="translated">S&amp;eacute; que ya hay muchas respuestas, pero encontr&amp;eacute; esto muy &amp;uacute;til: &lt;a href=&quot;http://tutorials.jenkov.com/dependency-injection/index.html&quot;&gt;http://tutorials.jenkov.com/dependency-injection/index.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed04f29160674f83a072681c6eb371dd9cb26716" translate="yes" xml:space="preserve">
          <source>I think since everyone has written for DI, let me ask a few questions..</source>
          <target state="translated">Creo que ya que todo el mundo ha escrito para el DI,déjame hacer algunas preguntas...</target>
        </trans-unit>
        <trans-unit id="2e46bcee2ea4c8bc4943d46d73203933dc4b2714" translate="yes" xml:space="preserve">
          <source>I would propose a slightly different, short and precise definition of what Dependency Injection is, focusing on the primary goal, not on the technical means (following along from &lt;a href=&quot;https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f&quot;&gt;here&lt;/a&gt;):</source>
          <target state="translated">Propondr&amp;iacute;a una definici&amp;oacute;n ligeramente diferente, breve y precisa de lo que es la inyecci&amp;oacute;n de dependencia, centr&amp;aacute;ndome en el objetivo principal, no en los medios t&amp;eacute;cnicos (siguiendo a &lt;a href=&quot;https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="af50e26570dc36b5b468480dbae632233aa97929" translate="yes" xml:space="preserve">
          <source>IOC is a general concept and it can be expressed in many different ways and Dependency Injection is one concrete example of IOC.</source>
          <target state="translated">El COI es un concepto general y puede expresarse de muchas maneras diferentes y la inyección de dependencia es un ejemplo concreto de COI.</target>
        </trans-unit>
        <trans-unit id="0718ee8859576506cf86f7bd25325cd7eca7c302" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dependent.sh&lt;/code&gt; script used dependencies directly, the approach would be called &lt;em&gt;dependency lookup&lt;/em&gt; (which is opposite to &lt;em&gt;dependency injection&lt;/em&gt;):</source>
          <target state="translated">Si el script &lt;code&gt;dependent.sh&lt;/code&gt; usara dependencias directamente, el enfoque se llamar&amp;iacute;a &lt;em&gt;b&amp;uacute;squeda de dependencias&lt;/em&gt; (que es opuesto a &lt;em&gt;la inyecci&amp;oacute;n de dependencias&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="ed73d2934d77992080e551028a74bcbaafd9ce4d" translate="yes" xml:space="preserve">
          <source>If Aproperty of AClass is not injected, is it harder to mock it out?</source>
          <target state="translated">Si no se inyecta Aproperty of AClass,¿es más difícil burlarse de él?</target>
        </trans-unit>
        <trans-unit id="327557f3bb6a180cff634bb5925c6178d29f71c3" translate="yes" xml:space="preserve">
          <source>If lifespan control of dependencies by the consuming class needs to be retained, control can be re-established by injecting an (abstract) factory for creating the dependency class instances, into the consumer class. The consumer will be able to obtain instances via a &lt;code&gt;Create&lt;/code&gt; on the factory as needed, and dispose of these instances once complete.</source>
          <target state="translated">Si es necesario mantener el control de la vida &amp;uacute;til de las dependencias por parte de la clase consumidora, se puede restablecer el control inyectando una f&amp;aacute;brica (abstracta) para crear las instancias de clase de dependencia en la clase de consumidor. El consumidor podr&amp;aacute; obtener instancias a trav&amp;eacute;s de &lt;code&gt;Create&lt;/code&gt; en la f&amp;aacute;brica seg&amp;uacute;n sea necesario, y eliminar estas instancias una vez que est&amp;eacute;n completas.</target>
        </trans-unit>
        <trans-unit id="17ad58325899b3161d70302101921cd886c5bcce" translate="yes" xml:space="preserve">
          <source>If we use the first one we need to open the machine to change the reel.
if we opt for the second one, that is placing a hook for reel, we are getting an added benefit of playing any music by changing the reel. and also reducing the function only to playing whatever in the reel.</source>
          <target state="translated">Si usamos el primero,necesitamos abrir la máquina para cambiar el carrete.Si optamos por el segundo,que es colocar un gancho para el carrete,estamos obteniendo un beneficio adicional de reproducir cualquier música cambiando el carrete.y también reduciendo la función sólo a reproducir lo que sea en el carrete.</target>
        </trans-unit>
        <trans-unit id="8114d9a89619251a62658a6e49b95469bb138929" translate="yes" xml:space="preserve">
          <source>If you occasionally work outside of Java, recall how &lt;code&gt;source&lt;/code&gt; is often used in many scripting languages (Shell, Tcl, etc., or even &lt;code&gt;import&lt;/code&gt; in Python misused for this purpose).</source>
          <target state="translated">Si ocasionalmente trabaja fuera de Java, recuerde c&amp;oacute;mo la &lt;code&gt;source&lt;/code&gt; se usa a menudo en muchos lenguajes de script (Shell, Tcl, etc., o incluso &lt;code&gt;import&lt;/code&gt; e en Python mal usado para este prop&amp;oacute;sito).</target>
        </trans-unit>
        <trans-unit id="b06602d95600aa4bf8101370b37215812a7573e0" translate="yes" xml:space="preserve">
          <source>If you use use &lt;code&gt;Constructor Injection&lt;/code&gt;, the &lt;code&gt;Service&lt;/code&gt; object is created when &lt;code&gt;Client&lt;/code&gt; created, sometime we use function in &lt;code&gt;Client&lt;/code&gt; class without use &lt;code&gt;Service&lt;/code&gt; so created &lt;code&gt;Service&lt;/code&gt; is wasted</source>
          <target state="translated">Si usa el uso de &lt;code&gt;Constructor Injection&lt;/code&gt; , el objeto de &lt;code&gt;Service&lt;/code&gt; se crea cuando se crea el &lt;code&gt;Client&lt;/code&gt; , en alg&amp;uacute;n momento usamos la funci&amp;oacute;n en la clase de &lt;code&gt;Client&lt;/code&gt; sin usar el &lt;code&gt;Service&lt;/code&gt; por lo que se desperdicia</target>
        </trans-unit>
        <trans-unit id="0673d4f21f33e89f895b29060653f72b9912e5ee" translate="yes" xml:space="preserve">
          <source>If you use use &lt;code&gt;Constructor Injection&lt;/code&gt;, when you look at constructor of &lt;code&gt;Client&lt;/code&gt;, you will see how many dependency of &lt;code&gt;Client&lt;/code&gt; class</source>
          <target state="translated">Si usa el uso de &lt;code&gt;Constructor Injection&lt;/code&gt; , cuando mira al constructor de &lt;code&gt;Client&lt;/code&gt; e , ver&amp;aacute; cu&amp;aacute;ntas dependencias de la clase de &lt;code&gt;Client&lt;/code&gt; e</target>
        </trans-unit>
        <trans-unit id="fe36ce97b13993591149a7d6ee89ed548e32abbb" translate="yes" xml:space="preserve">
          <source>In .Net, IoC containers are aware of protocols such as &lt;code&gt;IDisposable&lt;/code&gt; and will take on the responsibility of &lt;code&gt;Disposing&lt;/code&gt; dependencies in line with the configured lifespan management.</source>
          <target state="translated">En .Net, los contenedores de IoC conocen los protocolos como &lt;code&gt;IDisposable&lt;/code&gt; y asumir&amp;aacute;n la responsabilidad de &lt;code&gt;Disposing&lt;/code&gt; dependencias de acuerdo con la gesti&amp;oacute;n de vida &amp;uacute;til configurada.</target>
        </trans-unit>
        <trans-unit id="5874ec6c4d7578e3bf3f97834e478c385a3a81da" translate="yes" xml:space="preserve">
          <source>In 2013, when I wrote this answer, this was a major theme on the &lt;a href=&quot;http://googletesting.blogspot.com/&quot;&gt;Google Testing Blog&lt;/a&gt;. It remains the biggest advantage to me, as programmers not always need the extra flexibility in their run-time design (for instance, for service locator or similar patterns). Programmers often need to isolate the classes during testing.</source>
          <target state="translated">En 2013, cuando escrib&amp;iacute; esta respuesta, este era un tema importante en el &lt;a href=&quot;http://googletesting.blogspot.com/&quot;&gt;blog de Google Testing&lt;/a&gt; . Sigue siendo la mayor ventaja para m&amp;iacute;, ya que los programadores no siempre necesitan la flexibilidad adicional en su dise&amp;ntilde;o de tiempo de ejecuci&amp;oacute;n (por ejemplo, para el localizador de servicios o patrones similares). Los programadores a menudo necesitan aislar las clases durante las pruebas.</target>
        </trans-unit>
        <trans-unit id="8dd39bee0cfeef6f907d686e8fca98428110580e" translate="yes" xml:space="preserve">
          <source>In my opinion there is one only reason for DI frameworks: boiler plate reduction. With a well done factory system you can do the same, more controlled and more predictable as your preferred DI framework, DI frameworks promise code reduction (XML and annotations are source code too). The problem is this boiler plate reduction is just real in very very simple cases (one instance-per class and similar), sometimes in the real world picking the appropriated service object is not as easy as mapping a class to a singleton object.</source>
          <target state="translated">En mi opinión hay una única razón para los marcos DI:la reducción de la placa de la caldera.Con un sistema de fábrica bien hecho puedes hacer lo mismo,más controlado y más predecible como tu marco DI preferido,los marcos DI prometen la reducción de código (XML y las anotaciones son código fuente también).El problema es que esta reducción de la placa de la caldera es simplemente real en casos muy simples (un caso por clase y similares),a veces en el mundo real elegir el objeto de servicio apropiado no es tan fácil como mapear una clase a un objeto de una sola tonelada.</target>
        </trans-unit>
        <trans-unit id="945ef8affad419ee07825f142d4a71064182f46f" translate="yes" xml:space="preserve">
          <source>In other words with this approach is that our high level Car class is dependent on the lower level GasEngine class which violate Dependency Inversion Principle(DIP) from SOLID. DIP suggests that we should depend on abstractions, not concrete classes. So to satisfy this we introduce IEngine interface and rewrite code like below:</source>
          <target state="translated">En otras palabras,con este enfoque es que nuestra clase de coches de alto nivel depende de la clase de motores de gas de nivel inferior que viola el principio de inversión de la dependencia (DIP)de SOLID.El DIP sugiere que debemos depender de abstracciones,no de clases concretas.Así que para satisfacer esto introducimos la interfaz de IEngine y reescribimos el código como abajo:</target>
        </trans-unit>
        <trans-unit id="bc6abe43c16188f9d3e1b34e8bf777645960925f" translate="yes" xml:space="preserve">
          <source>In simple words dependency injection (DI) is the way to remove dependencies or tight coupling between different object. Dependency Injection gives a cohesive behavior to each object.</source>
          <target state="translated">En palabras sencillas,la inyección de dependencia (DI)es la forma de eliminar las dependencias o el estrecho acoplamiento entre diferentes objetos.La Inyección de Dependencia da un comportamiento cohesivo a cada objeto.</target>
        </trans-unit>
        <trans-unit id="2e58974612fd6fe0036631984f3609c239eab907" translate="yes" xml:space="preserve">
          <source>In this example, the implementation of &lt;code&gt;PersonService::addManager&lt;/code&gt; and &lt;code&gt;PersonService::removeManager&lt;/code&gt; would need an instance of the &lt;code&gt;GroupMembershipService&lt;/code&gt; in order to do its work. Without Dependency Injection, the traditional way of doing this would be to instantiate a new &lt;code&gt;GroupMembershipService&lt;/code&gt; in the constructor of &lt;code&gt;PersonService&lt;/code&gt; and use that instance attribute in both functions. However, if the constructor of &lt;code&gt;GroupMembershipService&lt;/code&gt; has multiple things it requires, or worse yet, there are some initialization &quot;setters&quot; that need to be called on the &lt;code&gt;GroupMembershipService&lt;/code&gt;, the code grows rather quickly, and the &lt;code&gt;PersonService&lt;/code&gt; now depends not only on the &lt;code&gt;GroupMembershipService&lt;/code&gt; but also everything else that &lt;code&gt;GroupMembershipService&lt;/code&gt; depends on. Furthermore, the linkage to &lt;code&gt;GroupMembershipService&lt;/code&gt; is hardcoded into the &lt;code&gt;PersonService&lt;/code&gt; which means that you can't &quot;dummy up&quot; a &lt;code&gt;GroupMembershipService&lt;/code&gt; for testing purposes, or to use a strategy pattern in different parts of your application.</source>
          <target state="translated">En este ejemplo, la implementaci&amp;oacute;n de &lt;code&gt;PersonService::addManager&lt;/code&gt; y PersonService &lt;code&gt;PersonService::removeManager&lt;/code&gt; necesitar&amp;iacute;a una instancia de &lt;code&gt;GroupMembershipService&lt;/code&gt; para hacer su trabajo. Sin la Inyecci&amp;oacute;n de dependencias, la forma tradicional de hacerlo ser&amp;iacute;a crear una instancia de un &lt;code&gt;GroupMembershipService&lt;/code&gt; nuevo en el constructor de &lt;code&gt;PersonService&lt;/code&gt; y usar ese atributo de instancia en ambas funciones. Sin embargo, si el constructor de &lt;code&gt;GroupMembershipService&lt;/code&gt; tiene varias cosas que requiere, o peor a&amp;uacute;n, hay algunos &quot;configuradores&quot; de inicializaci&amp;oacute;n que deben llamarse en &lt;code&gt;GroupMembershipService&lt;/code&gt; , el c&amp;oacute;digo crece bastante r&amp;aacute;pido y el &lt;code&gt;PersonService&lt;/code&gt; ahora depende no solo del &lt;code&gt;GroupMembershipService&lt;/code&gt; sino tambi&amp;eacute;n tambi&amp;eacute;n todo lo dem&amp;aacute;s de lo que depende &lt;code&gt;GroupMembershipService&lt;/code&gt; . Adem&amp;aacute;s, el enlace a &lt;code&gt;GroupMembershipService&lt;/code&gt; est&amp;aacute; codificado en &lt;code&gt;PersonService&lt;/code&gt; ,lo que significa que no puede &quot; &lt;code&gt;GroupMembershipService&lt;/code&gt; &quot; un GroupMembershipService con fines de prueba o para utilizar un patr&amp;oacute;n de estrategia en diferentes partes de su aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3945063a7ab43002ea39d3d24e40ac75108803b6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;source&lt;/code&gt;-ing implementation script directly in the dependent one, you use an &lt;code&gt;injector.sh&lt;/code&gt; &quot;container&quot; which wraps both &quot;components&quot;:</source>
          <target state="translated">En lugar de la secuencia de comandos de implementaci&amp;oacute;n de &lt;code&gt;source&lt;/code&gt; directamente en el dependiente, utiliza un &quot;contenedor&quot; &lt;code&gt;injector.sh&lt;/code&gt; que envuelve ambos &quot;componentes&quot;:</target>
        </trans-unit>
        <trans-unit id="a32a54b9d71ad0ec3f835fab1768f5cabb2ce808" translate="yes" xml:space="preserve">
          <source>Interface of book:</source>
          <target state="translated">Interfaz del libro:</target>
        </trans-unit>
        <trans-unit id="87ce48016c0abd40898b021fa36510c98da3c3f6" translate="yes" xml:space="preserve">
          <source>Inversion of Control (IOC)</source>
          <target state="translated">Inversión de control (COI)</target>
        </trans-unit>
        <trans-unit id="c6f589e1a346ddca493c03b3d62843ee5c496a03" translate="yes" xml:space="preserve">
          <source>It helps to develop high quality components since they are independently developed they are properly tested.</source>
          <target state="translated">Ayuda a desarrollar componentes de alta calidad ya que se desarrollan independientemente y se prueban adecuadamente.</target>
        </trans-unit>
        <trans-unit id="fe52190c660276a5234fd25313a1d7025785a9b1" translate="yes" xml:space="preserve">
          <source>It helps to replace the component with another if one fails.</source>
          <target state="translated">Ayuda a reemplazar el componente con otro si uno falla.</target>
        </trans-unit>
        <trans-unit id="12a6359f43afb8218185323269fc89edefe3a5f9" translate="yes" xml:space="preserve">
          <source>It is harder to isolate components in unit testing without dependency injection.</source>
          <target state="translated">Es más difícil aislar los componentes en las pruebas unitarias sin la inyección de dependencia.</target>
        </trans-unit>
        <trans-unit id="5315cf7c004aa65a5379bfbf68f8aa368640746e" translate="yes" xml:space="preserve">
          <source>It means that objects should only have as many dependencies as is needed to do their job and the dependencies should be few. Furthermore, an object&amp;rsquo;s dependencies should be on interfaces and not on &amp;ldquo;concrete&amp;rdquo; objects, when possible. (A concrete object is any object created with the keyword new.) Loose coupling promotes greater reusability, easier maintainability, and allows you to easily provide &amp;ldquo;mock&amp;rdquo; objects in place of expensive services.</source>
          <target state="translated">Significa que los objetos solo deber&amp;iacute;an tener tantas dependencias como sea necesario para hacer su trabajo y las dependencias deber&amp;iacute;an ser pocas. Adem&amp;aacute;s, las dependencias de un objeto deben estar en interfaces y no en objetos &quot;concretos&quot;, cuando sea posible. (Un objeto concreto es cualquier objeto creado con la palabra clave new.) El acoplamiento flojo promueve una mayor reutilizaci&amp;oacute;n, una capacidad de mantenimiento m&amp;aacute;s f&amp;aacute;cil y le permite proporcionar f&amp;aacute;cilmente objetos &quot;simulados&quot; en lugar de servicios caros.</target>
        </trans-unit>
        <trans-unit id="150a68e160c591532e3796e7a048e6a35a2b271c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s the technique of passing objects dependencies to its constructor.</source>
          <target state="translated">Es la t&amp;eacute;cnica de pasar dependencias de objetos a su constructor.</target>
        </trans-unit>
        <trans-unit id="aa27b9815cfca97bc09894174bbc5029fa7ea762" translate="yes" xml:space="preserve">
          <source>Last words</source>
          <target state="translated">Últimas palabras</target>
        </trans-unit>
        <trans-unit id="101f50890da169b761f4204e13794649557a2715" translate="yes" xml:space="preserve">
          <source>Let's imagine that you want to go fishing:</source>
          <target state="translated">Imaginemos que quieres ir a pescar:</target>
        </trans-unit>
        <trans-unit id="3fb3f6b5b730e2955d7fc11411b3be83f4438c60" translate="yes" xml:space="preserve">
          <source>Let's try simple example with &lt;strong&gt;Car&lt;/strong&gt; and &lt;strong&gt;Engine&lt;/strong&gt; classes, any car need an engine to go anywhere, at least for now. So below how code will look without dependency injection.</source>
          <target state="translated">Probemos un ejemplo simple con las clases de &lt;strong&gt;Autom&amp;oacute;vil&lt;/strong&gt; y &lt;strong&gt;Motor&lt;/strong&gt; , cualquier autom&amp;oacute;vil necesita un motor para ir a cualquier parte, al menos por ahora. A continuaci&amp;oacute;n, c&amp;oacute;mo se ver&amp;aacute; el c&amp;oacute;digo sin inyecci&amp;oacute;n de dependencia.</target>
        </trans-unit>
        <trans-unit id="0743bd397ad0bae662ab3527bca83ae55d5c97e6" translate="yes" xml:space="preserve">
          <source>Like wise dependency injection is the  process of externalizing the dependencies to focus only on the specific functionality of the component so that independent components can be coupled together to form a complex system.</source>
          <target state="translated">De la misma manera,la inyección de dependencia es el proceso de externalización de las dependencias para centrarse únicamente en la funcionalidad específica del componente,de manera que los componentes independientes puedan acoplarse para formar un sistema complejo.</target>
        </trans-unit>
        <trans-unit id="a77c6a3de980ebb5dc42a0edc1ee999977beda1e" translate="yes" xml:space="preserve">
          <source>Make test easier</source>
          <target state="translated">Facilitar la prueba</target>
        </trans-unit>
        <trans-unit id="78928cbc17b1ac78636f5d533c2894682e0a6266" translate="yes" xml:space="preserve">
          <source>Making things as components and to combine to form a large systems with high capabilities.</source>
          <target state="translated">Haciendo que las cosas sean componentes y se combinen para formar un gran sistema con altas capacidades.</target>
        </trans-unit>
        <trans-unit id="04faf2b31cb2eb82166edebcf0b8fa045081749b" translate="yes" xml:space="preserve">
          <source>Modifying &lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James&lt;/a&gt; Example for Switch and Bulb:</source>
          <target state="translated">Modificaci&amp;oacute;n de &lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James&lt;/a&gt; Ejemplo para Switch y Bulb:</target>
        </trans-unit>
        <trans-unit id="38837e9f2c549ac0d1e7a54cf6258ccf4df0c3f2" translate="yes" xml:space="preserve">
          <source>NOTE:
It is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the if we use annotation based than @Required annotation on a setter can be used to make setters as a required dependencies.</source>
          <target state="translated">NOTA:Es una buena regla general utilizar argumentos de construcción para las dependencias obligatorias y argumentos para las dependencias opcionales.Tenga en cuenta que si usamos la anotación basada en la anotación @Required en un setter se puede utilizar para hacer setters como una dependencia obligatoria.</target>
        </trans-unit>
        <trans-unit id="8360dc1497a3895cbb0ae2365dd63cd62fb85433" translate="yes" xml:space="preserve">
          <source>Next we can have many kind of books; one of type is fiction:</source>
          <target state="translated">A continuación podemos tener muchos tipos de libros;uno de ellos es de ficción:</target>
        </trans-unit>
        <trans-unit id="381bcfef8f062363621c6445f025fc1ec1ecb6e0" translate="yes" xml:space="preserve">
          <source>No Dependency:</source>
          <target state="translated">No hay dependencia:</target>
        </trans-unit>
        <trans-unit id="148aedccb1c30aae863f891e9230b9918c3c26e5" translate="yes" xml:space="preserve">
          <source>Note that the constructor accepts an interface and not concrete object. Also, note that an exception is thrown if the orderDao parameter is null. This emphasizes the importance of receiving a valid dependency. Constructor Injection is, in my opinion, the preferred mechanism for giving an object its dependencies. It is clear to the developer while invoking the object which dependencies need to be given to the &amp;ldquo;Person&amp;rdquo; object for proper execution.</source>
          <target state="translated">Tenga en cuenta que el constructor acepta una interfaz y no un objeto concreto. Adem&amp;aacute;s, tenga en cuenta que se produce una excepci&amp;oacute;n si el par&amp;aacute;metro de orden de venta es nulo. Esto enfatiza la importancia de recibir una dependencia v&amp;aacute;lida. La inyecci&amp;oacute;n de constructor es, en mi opini&amp;oacute;n, el mecanismo preferido para dar a un objeto sus dependencias. Es claro para el desarrollador al invocar al objeto qu&amp;eacute; dependencias deben darse al objeto &quot;Persona&quot; para una ejecuci&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="52a2afd82b94f21efe4003a5f77702e673692a03" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;DataSourceImpl&lt;/code&gt; instantiation is moved into a constructor. The constructor takes four parameters which are the four values needed by the &lt;code&gt;DataSourceImpl&lt;/code&gt;. Though the &lt;code&gt;MyDao&lt;/code&gt; class still depends on these four values, it no longer satisfies these dependencies itself. They are provided by whatever class creating a &lt;code&gt;MyDao&lt;/code&gt; instance.</source>
          <target state="translated">Observe c&amp;oacute;mo la instanciaci&amp;oacute;n &lt;code&gt;DataSourceImpl&lt;/code&gt; se traslada a un constructor. El constructor toma cuatro par&amp;aacute;metros, que son los cuatro valores que necesita &lt;code&gt;DataSourceImpl&lt;/code&gt; . Aunque la clase &lt;code&gt;MyDao&lt;/code&gt; todav&amp;iacute;a depende de estos cuatro valores, ya no satisface estas dependencias. Los proporciona cualquier clase que cree una instancia de &lt;code&gt;MyDao&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9bf32a5cd289e031981b513bdc34931168fff08" translate="yes" xml:space="preserve">
          <source>Now a days these concept forms the basis of well known frameworks in programming world.
The Spring Angular etc are the well-known software frameworks built on the top of this concept</source>
          <target state="translated">Hoy en día estos conceptos forman la base de marcos bien conocidos en el mundo de la programación.El Spring Angular,etc.son los conocidos marcos de software construidos sobre este concepto.</target>
        </trans-unit>
        <trans-unit id="3f568c10c487626292e158f1321b91077bbdfb85" translate="yes" xml:space="preserve">
          <source>Now our Car class is dependent on only the IEngine interface, not a specific implementation of engine. 
Now, the only trick is how do we create an instance of the Car and give it an actual concrete Engine class like GasEngine or ElectricityEngine. That's where &lt;strong&gt;Dependency Injection&lt;/strong&gt; comes in.</source>
          <target state="translated">Ahora nuestra clase Car depende solo de la interfaz IEngine, no de una implementaci&amp;oacute;n espec&amp;iacute;fica del motor. Ahora, el &amp;uacute;nico truco es c&amp;oacute;mo creamos una instancia del autom&amp;oacute;vil y le damos una clase real de motor concreto como GasEngine o ElectricityEngine. Ah&amp;iacute; es donde entra la &lt;strong&gt;inyecci&amp;oacute;n de dependencia&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="294a5073bdc9a6339404dadb5c21756e099a6869" translate="yes" xml:space="preserve">
          <source>Now subscriber can have association to the book:</source>
          <target state="translated">Ahora el suscriptor puede asociarse al libro:</target>
        </trans-unit>
        <trans-unit id="3c4442a341c09f2a8337cd53e8c9d7b14c1f8d57" translate="yes" xml:space="preserve">
          <source>Now the problem is that dependent &quot;component&quot; has to perform initialization itself.</source>
          <target state="translated">Ahora el problema es que el &quot;componente&quot; dependiente tiene que realizar la inicialización por sí mismo.</target>
        </trans-unit>
        <trans-unit id="244d7754a9d504a1f45d44ae1bdf5c41e24ccff1" translate="yes" xml:space="preserve">
          <source>Now, this code is already follow &lt;code&gt;Dependency Injection&lt;/code&gt; and it is easier for test &lt;code&gt;Client&lt;/code&gt; class.</source>
          <target state="translated">Ahora, este c&amp;oacute;digo ya sigue &lt;code&gt;Dependency Injection&lt;/code&gt; y es m&amp;aacute;s f&amp;aacute;cil para probar la clase de &lt;code&gt;Client&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01cf15bf0efc21fae58f14423988c7d39bcbc525" translate="yes" xml:space="preserve">
          <source>Objects are once loaded in Spring container and then we reuse them whenever we need them by fetching those objects from Spring container using getBean(String beanName) method.</source>
          <target state="translated">Los objetos se cargan una vez en el contenedor de primavera y luego los reutilizamos siempre que los necesitemos trayendo esos objetos desde el contenedor de primavera usando el método getBean(String beanName).</target>
        </trans-unit>
        <trans-unit id="6cf40f56e8e4c0d23d55ca133079493612e29b47" translate="yes" xml:space="preserve">
          <source>One common alternative is defining a &lt;strong&gt;do-nothing constructor&lt;/strong&gt;. Dependency injection can be done through setters. (h/t @MikeVella).</source>
          <target state="translated">Una alternativa com&amp;uacute;n es definir un &lt;strong&gt;constructor de no hacer nada&lt;/strong&gt; . La inyecci&amp;oacute;n de dependencia se puede hacer a trav&amp;eacute;s de setters. (h / t @ MikeVella).</target>
        </trans-unit>
        <trans-unit id="e85085db2ea4a2409b650b063f440106471f7755" translate="yes" xml:space="preserve">
          <source>One consequence of DI is that the lifespan management of dependency object instances is no longer controlled by a consuming class, as the dependency object is now passed into the consuming class (via constructor or setter injection).</source>
          <target state="translated">Una consecuencia del DI es que la gestión de la vida útil de las instancias de los objetos de dependencia ya no está controlada por una clase consumidora,ya que el objeto de dependencia pasa ahora a la clase consumidora (mediante la inyección de constructor o colocador).</target>
        </trans-unit>
        <trans-unit id="0e87d7a02651091658f2b2651ada0186577a5e58" translate="yes" xml:space="preserve">
          <source>One requirement is that the services must be parametrised by their dependencies. What this means exactly depends on the language and approach taken in a given system. Usually, this takes the form of constructor parameters, but using setters is also an option. This also means that the dependencies of a service are hidden (when invoking a service method) from the users of the service.</source>
          <target state="translated">Un requisito es que los servicios deben ser parametrizados por sus dependencias.Lo que esto significa exactamente depende del lenguaje y el enfoque adoptado en un sistema determinado.Normalmente,esto toma la forma de parámetros de construcción,pero el uso de configuradores también es una opción.Esto también significa que las dependencias de un servicio están ocultas (cuando se invoca un método de servicio)a los usuarios del servicio.</target>
        </trans-unit>
        <trans-unit id="159c3350bcfe189a7b428c479d9201ea48faf507" translate="yes" xml:space="preserve">
          <source>Or, lifespan control of dependency instances can be relinquished to an IoC container (more about this below).</source>
          <target state="translated">O bien,el control de la vida útil de las instancias de dependencia puede ser cedido a un contenedor de IO (más sobre esto a continuación).</target>
        </trans-unit>
        <trans-unit id="93d225da5e27eb45ee9a17d2a3dcf555280a505b" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;myObject&lt;/code&gt; in as an argument to the constructor</source>
          <target state="translated">Pasar &lt;code&gt;myObject&lt;/code&gt; como argumento al constructor</target>
        </trans-unit>
        <trans-unit id="21b3ab899d3e7a2f72bd43dcfb14037ae113a442" translate="yes" xml:space="preserve">
          <source>Practically, every design pattern separates concerns to make future changes affect minimum files.</source>
          <target state="translated">Prácticamente,cada patrón de diseño separa las preocupaciones para que los futuros cambios afecten a los archivos mínimos.</target>
        </trans-unit>
        <trans-unit id="d9f5010baa893f9ad98e960248019e1ff603968f" translate="yes" xml:space="preserve">
          <source>Previously we are writing code like this</source>
          <target state="translated">Anteriormente estamos escribiendo un código como este</target>
        </trans-unit>
        <trans-unit id="533e261383d8b2d3e59f53c2e9d59c559259294d" translate="yes" xml:space="preserve">
          <source>Programmers have understood the dependency obfuscation requirement for years and many alternative solutions have evolved both before and after dependency injection was conceived. There are Factory patterns but there are also many options using ThreadLocal where no injection to a particular instance is needed - the dependency is effectively injected into the thread which has the benefit of making the object available (via convenience static getter methods) to &lt;em&gt;any&lt;/em&gt; class that requires it without having to add annotations to the classes that require it and set up intricate XML 'glue' to make it happen. When your dependencies are required for persistence (JPA/JDO or whatever) it allows you to achieve 'tranaparent persistence' much easier and with domain model and business model classes made up purely of POJOs (i.e. no framework specific/locked in annotations).</source>
          <target state="translated">Los programadores han entendido el requisito de ofuscaci&amp;oacute;n de dependencia durante a&amp;ntilde;os y muchas soluciones alternativas han evolucionado tanto antes como despu&amp;eacute;s de concebir la inyecci&amp;oacute;n de dependencia. Existen patrones de f&amp;aacute;brica, pero tambi&amp;eacute;n hay muchas opciones que usan ThreadLocal donde no se necesita una inyecci&amp;oacute;n en una instancia particular: la dependencia se inyecta efectivamente en el hilo que tiene el beneficio de hacer que el objeto est&amp;eacute; disponible (a trav&amp;eacute;s de m&amp;eacute;todos convenientes de obtenci&amp;oacute;n est&amp;aacute;tica) a &lt;em&gt;cualquier&lt;/em&gt; clase que lo requiere sin tener que agregar anotaciones a las clases que lo requieren y configurar intrincado 'pegamento' XML para que suceda. Cuando sus dependencias son necesarias para la persistencia (JPA / JDO o lo que sea), le permite lograr una 'persistencia tranaparent' mucho m&amp;aacute;s f&amp;aacute;cil y con clases de modelo de dominio y modelo de negocio formadas exclusivamente por POJO (es decir, sin marco espec&amp;iacute;fico / bloqueado en anotaciones).</target>
        </trans-unit>
        <trans-unit id="6fbc5d43864c0ac8fa3636a03653618ac21757e7" translate="yes" xml:space="preserve">
          <source>Setter Injection</source>
          <target state="translated">Inyección de Setter</target>
        </trans-unit>
        <trans-unit id="5a34561d27d0c82f9fb28bebbfcc20bc74ddc2a1" translate="yes" xml:space="preserve">
          <source>Setter Injection does not force dependencies to be passed to the constructor. Instead, the dependencies are set onto public properties exposed by the object in need. As implied previously, the primary motivators for doing this include:</source>
          <target state="translated">La Inyección de Setter no obliga a que las dependencias pasen al constructor.En su lugar,las dependencias se fijan en propiedades públicas expuestas por el objeto en cuestión.Como se ha dado a entender anteriormente,los principales motivadores para hacer esto incluyen:</target>
        </trans-unit>
        <trans-unit id="3ba4002363cebe927c87f145292fe23279da4fc4" translate="yes" xml:space="preserve">
          <source>Setter injection</source>
          <target state="translated">Inyección de Setter</target>
        </trans-unit>
        <trans-unit id="b8cb1079b38327369ec318ba6d8358b7e9c456ba" translate="yes" xml:space="preserve">
          <source>Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.</source>
          <target state="translated">La DI basada en el fijador se logra mediante el contenedor llamando a los métodos de fijador en sus frijoles después de invocar un constructor sin argumentos o un método de fábrica estática sin argumentos para instanciar su frijol.</target>
        </trans-unit>
        <trans-unit id="de72ea9e60d3b0389fb7873c1d21268b088fa6d4" translate="yes" xml:space="preserve">
          <source>Simple</source>
          <target state="translated">Simple</target>
        </trans-unit>
        <trans-unit id="53b5b8696132c7f14a83c7efaf53a8df90f22d0e" translate="yes" xml:space="preserve">
          <source>So in the end &lt;strong&gt;Dependency injection&lt;/strong&gt; is just a technique for
  achieving loose coupling between objects and their dependencies.
  Rather than directly instantiating dependencies that class needs in
  order to perform its actions, dependencies are provided to the class
  (most often) via constructor injection.</source>
          <target state="translated">Entonces, al final, la &lt;strong&gt;inyecci&amp;oacute;n de dependencia&lt;/strong&gt; es solo una t&amp;eacute;cnica para lograr un acoplamiento flexible entre los objetos y sus dependencias. En lugar de instanciar directamente las dependencias que la clase necesita para realizar sus acciones, las dependencias se proporcionan a la clase (con mayor frecuencia) a trav&amp;eacute;s de la inyecci&amp;oacute;n del constructor.</target>
        </trans-unit>
        <trans-unit id="7da9dbfe443ff7c3e18888265c12bc4c6d7027ed" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html&quot;&gt;Understanding dependency injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Fuente: &lt;em&gt;&lt;a href=&quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html&quot;&gt;Comprender la inyecci&amp;oacute;n de dependencia&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5974b915c67629f3fb291858490061a4113d7288" translate="yes" xml:space="preserve">
          <source>Specifically, in the paradigm of Robert C Martin's &lt;a href=&quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;SOLID principles of Object Oriented Design&lt;/a&gt;, &lt;code&gt;DI&lt;/code&gt; is one of the possible implementations of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;Dependency Inversion Principle (DIP)&lt;/a&gt;. The &lt;a href=&quot;https://stackoverflow.com/q/27978841/314291&quot;&gt;DIP is the &lt;code&gt;D&lt;/code&gt; of the &lt;code&gt;SOLID&lt;/code&gt; mantra&lt;/a&gt;  - other DIP implementations include the Service Locator, and Plugin patterns.</source>
          <target state="translated">Espec&amp;iacute;ficamente, en el paradigma de los &lt;a href=&quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;principios S&amp;Oacute;LIDOS&lt;/a&gt; de Robert C Martin de Dise&amp;ntilde;o Orientado a Objetos , &lt;code&gt;DI&lt;/code&gt; es una de las posibles implementaciones del &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;Principio de Inversi&amp;oacute;n de Dependencia (DIP)&lt;/a&gt; . El &lt;a href=&quot;https://stackoverflow.com/q/27978841/314291&quot;&gt;DIP es el &lt;code&gt;D&lt;/code&gt; del mantra &lt;code&gt;SOLID&lt;/code&gt; &lt;/a&gt; ; otras implementaciones de DIP incluyen el Localizador de servicios y los patrones de complementos.</target>
        </trans-unit>
        <trans-unit id="f4b86bb17c077dd81ce6f0d78a2ce285c974111f" translate="yes" xml:space="preserve">
          <source>Supporting dependency injection without having to modify the constructor of a legacy class.</source>
          <target state="translated">Apoyar la inyección de dependencia sin tener que modificar el constructor de una clase de legado.</target>
        </trans-unit>
        <trans-unit id="ad518a2bfe35a440dc057b8df89372141fdee4b1" translate="yes" xml:space="preserve">
          <source>Switch -&amp;gt; Bulb1 OR Bulb2 OR NightBulb (injected dependency)</source>
          <target state="translated">Switch -&amp;gt; Bulb1 OR Bulb2 OR NightBulb (dependencia inyectada)</target>
        </trans-unit>
        <trans-unit id="1f8e6772695db9bb64683f23fba3fcc305250d9e" translate="yes" xml:space="preserve">
          <source>Switch -&amp;gt; PermanentBulb &lt;em&gt;//switch is directly connected to permanent bulb, testing not possible easily&lt;/em&gt;</source>
          <target state="translated">Interruptor -&amp;gt; PermanentBulb &lt;em&gt;// el interruptor est&amp;aacute; conectado directamente a una bombilla permanente, no es posible realizar pruebas f&amp;aacute;cilmente&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c4c8437fc5346d142f060317a5f268dabd0d961" translate="yes" xml:space="preserve">
          <source>Switch needs to know beforehand which bulb I am connected to (hard-coded dependency). So,</source>
          <target state="translated">El interruptor necesita saber de antemano a qué bombilla estoy conectado (dependencia de código duro).Así que..,</target>
        </trans-unit>
        <trans-unit id="4d7495d3cc88447e63485a25f72ecf731763671c" translate="yes" xml:space="preserve">
          <source>Switch only knows I need to turn on/off whichever Bulb is passed to me. So,</source>
          <target state="translated">El interruptor sólo sabe que debo apagar la bombilla que se me pase.Así que..,</target>
        </trans-unit>
        <trans-unit id="4c1913b877e14f9958c5e5bb105932590816f59f" translate="yes" xml:space="preserve">
          <source>The &quot;component&quot;'s source code is neither &lt;strong&gt;clean&lt;/strong&gt; nor &lt;strong&gt;stable&lt;/strong&gt; because every changes in initialization of dependencies requires new release for &quot;components&quot;'s source code file as well.</source>
          <target state="translated">El c&amp;oacute;digo fuente del &quot;componente&quot; no es &lt;strong&gt;limpio&lt;/strong&gt; ni &lt;strong&gt;estable&lt;/strong&gt; porque cada cambio en la inicializaci&amp;oacute;n de dependencias requiere una nueva versi&amp;oacute;n para el archivo de c&amp;oacute;digo fuente de los &quot;componentes&quot;.</target>
        </trans-unit>
        <trans-unit id="73264d2706ed99c7c3cf1d84437da53a400c9eb1" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Dependency Injection&amp;rdquo; (DI) is also known as &amp;ldquo;Inversion of Control&amp;rdquo; (IoC), can be used as a technique for encouraging this loose coupling.</source>
          <target state="translated">La &quot;Inyecci&amp;oacute;n de dependencia&quot; (DI) tambi&amp;eacute;n se conoce como &quot;Inversi&amp;oacute;n de control&quot; (IoC), se puede utilizar como una t&amp;eacute;cnica para fomentar este acoplamiento flojo.</target>
        </trans-unit>
        <trans-unit id="4ce8e8f58189f93cac9d7dcd25f82fad19ea42c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;archive_files&lt;/code&gt;&lt;em&gt;dependency&lt;/em&gt; has just been &lt;em&gt;injected&lt;/em&gt; into &lt;em&gt;dependent&lt;/em&gt; script.</source>
          <target state="translated">La &lt;em&gt;dependencia&lt;/em&gt; &lt;code&gt;archive_files&lt;/code&gt; acaba de &lt;em&gt;inyectarse&lt;/em&gt; en &lt;em&gt;un&lt;/em&gt; script &lt;em&gt;dependiente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="57f5c2a4c3648bf44c57e0b10c21224b7534177d" translate="yes" xml:space="preserve">
          <source>The above image is an image of Reel-to-reel portable tape recorder, mid-20th century. &lt;a href=&quot;https://www.britannica.com/technology/tape-recorder&quot;&gt;Source&lt;/a&gt;.</source>
          <target state="translated">La imagen de arriba es una imagen de una grabadora de cinta port&amp;aacute;til de carrete a mediados del siglo XX. &lt;a href=&quot;https://www.britannica.com/technology/tape-recorder&quot;&gt;Fuente&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc174d974fc2630ad90c3952d5479067c5370ff0" translate="yes" xml:space="preserve">
          <source>The accepted answer is a good one - but I would like to add to this that DI is very much like the classic avoiding of hardcoded constants in the code.</source>
          <target state="translated">La respuesta aceptada es buena,pero me gustaría añadir que el DI es muy parecido a la clásica evasión de las constantes del código.</target>
        </trans-unit>
        <trans-unit id="a38ac33b8fba8d81022fa8e5992560f5f98cbdc3" translate="yes" xml:space="preserve">
          <source>The best analogy I can think of is the surgeon and his assistant(s) in an operation theater, where the surgeon is the main person and his assistant who provides the various surgical components when he needs it so that the surgeon can concentrate on the one thing he does best (surgery). Without the assistant the surgeon has to get the components himself every time he needs one.</source>
          <target state="translated">La mejor analogía que se me ocurre es la del cirujano y su(s)asistente(s)en un quirófano,donde el cirujano es la persona principal y su asistente que proporciona los diversos componentes quirúrgicos cuando los necesita para que el cirujano pueda concentrarse en lo que mejor sabe hacer (la cirugía).Sin el asistente el cirujano tiene que conseguir los componentes él mismo cada vez que lo necesita.</target>
        </trans-unit>
        <trans-unit id="a41ea95353f5d528dfa619f0e43f5976252872f7" translate="yes" xml:space="preserve">
          <source>The best definition I've found so far is &lt;a href=&quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;one by James Shore&lt;/a&gt;:</source>
          <target state="translated">La mejor definici&amp;oacute;n que he encontrado hasta ahora es &lt;a href=&quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;una de James Shore&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="888a31b520ca5d4997c6aa72d7a98329f15bff71" translate="yes" xml:space="preserve">
          <source>The issue with this code that we tightly coupled to GasEngine and if we decide to change it to ElectricityEngine then we will need to rewrite Car class. And the bigger the application the more issues and headache we will have to add and use new type of engine.</source>
          <target state="translated">El problema con este código es que nos acoplamos estrechamente a GasEngine y si decidimos cambiarlo a ElectricityEngine entonces tendremos que reescribir Car class.Y cuanto más grande sea la aplicación,más problemas y dolores de cabeza tendremos que añadir y usar un nuevo tipo de motor.</target>
        </trans-unit>
        <trans-unit id="55cafcb834ee14f42eff09928fdaf624281b81f7" translate="yes" xml:space="preserve">
          <source>The key to DI-friendly code is to avoid static coupling of classes, and not to use new() for the creation of Dependencies</source>
          <target state="translated">La clave del código DI-friendly es evitar el acoplamiento estático de las clases,y no usar new()para la creación de dependencias</target>
        </trans-unit>
        <trans-unit id="5ca5815f45aca9074db82cb4273a806d37ea2c5b" translate="yes" xml:space="preserve">
          <source>The main benefit of the &lt;strong&gt;Dependency Injection&lt;/strong&gt; that classes are more loosely coupled, because they do not have hard-coded dependencies. This follows the Dependency Inversion Principle, which was mentioned above. Instead of referencing specific implementations, classes request abstractions (usually &lt;strong&gt;interfaces&lt;/strong&gt;) which are provided to them when the class is constructed.</source>
          <target state="translated">El principal beneficio de la &lt;strong&gt;Inyecci&amp;oacute;n de dependencias es&lt;/strong&gt; que las clases se acoplan m&amp;aacute;s libremente, porque no tienen dependencias codificadas. Esto sigue el principio de inversi&amp;oacute;n de dependencia, que se mencion&amp;oacute; anteriormente. En lugar de hacer referencia a implementaciones espec&amp;iacute;ficas, las clases solicitan abstracciones (generalmente &lt;strong&gt;interfaces&lt;/strong&gt; ) que se les proporcionan cuando se construye la clase.</target>
        </trans-unit>
        <trans-unit id="473698f3e91170575e3a1dd7c3f14effd0d4dbdd" translate="yes" xml:space="preserve">
          <source>The main benefits we achieved by using dependency injection.</source>
          <target state="translated">Los principales beneficios que obtuvimos con el uso de la inyección de dependencia.</target>
        </trans-unit>
        <trans-unit id="3a01d41764fb9f4deb184c6238b397910d66d4e7" translate="yes" xml:space="preserve">
          <source>The main purpose of the intermediate level is not just to pass in the dependencies to the constructor, but to list all the dependencies in &lt;em&gt;just one place&lt;/em&gt;, and to hide them from the coder (not to make the coder provide them).</source>
          <target state="translated">El objetivo principal del nivel intermedio no es solo pasar las dependencias al constructor, sino enumerar todas las dependencias en &lt;em&gt;un solo lugar&lt;/em&gt; y ocultarlas del codificador (no hacer que el codificador las proporcione).</target>
        </trans-unit>
        <trans-unit id="675567e15eedcab72deecf5182fe51cdda38c6b1" translate="yes" xml:space="preserve">
          <source>The module graph - the graph of service objects - is typically created on application startup. This can be done using a container, such as Spring, but can also be done manually, by passing parameters to object constructors. Both ways have their pros and cons, but a framework definitely isn&amp;rsquo;t necessary to use DI in your application.</source>
          <target state="translated">El gr&amp;aacute;fico del m&amp;oacute;dulo, el gr&amp;aacute;fico de los objetos de servicio, generalmente se crea al iniciar la aplicaci&amp;oacute;n. Esto se puede hacer usando un contenedor, como Spring, pero tambi&amp;eacute;n se puede hacer manualmente, pasando par&amp;aacute;metros a los constructores de objetos. Ambas formas tienen sus pros y sus contras, pero definitivamente no es necesario un marco para usar DI en su aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1345d93e55da0a02f0e73cb3294e155c0fcd0c41" translate="yes" xml:space="preserve">
          <source>The objective of the DIP is to decouple tight, concrete dependencies between classes, and instead, to loosen the coupling by means of an abstraction, which can be achieved via an &lt;code&gt;interface&lt;/code&gt;, &lt;code&gt;abstract class&lt;/code&gt; or &lt;code&gt;pure virtual class&lt;/code&gt;, depending on the language and approach used.</source>
          <target state="translated">El objetivo del DIP es desacoplar dependencias apretadas y concretas entre clases y, en cambio, aflojar el acoplamiento mediante una abstracci&amp;oacute;n, que se puede lograr a trav&amp;eacute;s de una &lt;code&gt;interface&lt;/code&gt; , &lt;code&gt;abstract class&lt;/code&gt; o &lt;code&gt;pure virtual class&lt;/code&gt; , dependiendo del lenguaje y el enfoque utilizado .</target>
        </trans-unit>
        <trans-unit id="13ddfae2bc42d77fabc17f4670bf62cf40aa3c4a" translate="yes" xml:space="preserve">
          <source>The objects that we create in our applications (regardless if we use Java, C# or other object-oriented language) usually fall into one of two categories: stateless, static and global &amp;ldquo;service objects&amp;rdquo; (modules), and stateful, dynamic and local &amp;ldquo;data objects&amp;rdquo;.</source>
          <target state="translated">Los objetos que creamos en nuestras aplicaciones (independientemente de si usamos Java, C # u otro lenguaje orientado a objetos) generalmente se dividen en una de dos categor&amp;iacute;as: &quot;objetos de servicio&quot; (m&amp;oacute;dulos) sin estado, est&amp;aacute;ticos y globales, y con estado, din&amp;aacute;mico y local. &quot;Objetos de datos&quot;.</target>
        </trans-unit>
        <trans-unit id="fccd88c774cbd85630c6ee5e8c38793343e3457d" translate="yes" xml:space="preserve">
          <source>The person typing &quot;make bar&quot; doesn't need to know that bar depends on foo. The dependency was injected between &quot;make bar&quot; and gcc.</source>
          <target state="translated">La persona que teclea &quot;hacer barra&quot; no necesita saber que la barra depende del foo.La dependencia se inyectó entre &quot;make bar&quot; y GCC.</target>
        </trans-unit>
        <trans-unit id="c8b03c2d69af0fb222af1edc1d1a6a786e0d51c4" translate="yes" xml:space="preserve">
          <source>The popular answers are unhelpful, because they define dependency injection in a way that isn't useful. Let's agree that by &quot;dependency&quot; we mean some pre-existing other object that our object X needs. But we don't say we're doing &quot;dependency injection&quot; when we say</source>
          <target state="translated">Las respuestas populares no son útiles,porque definen la inyección de dependencia de una manera que no es útil.Acordemos que por &quot;dependencia&quot; nos referimos a algún otro objeto preexistente que nuestro objeto X necesita.Pero no decimos que estamos haciendo &quot;inyección de dependencia&quot; cuando decimos</target>
        </trans-unit>
        <trans-unit id="bbadfee066654ad4aea424424e4eade208a93f88" translate="yes" xml:space="preserve">
          <source>The primary intention of a tape recorder machine is to record or playback sound.</source>
          <target state="translated">La intención principal de una grabadora es grabar o reproducir el sonido.</target>
        </trans-unit>
        <trans-unit id="72621a62fc0916c8f0e046dcd1a82521dee3ad8a" translate="yes" xml:space="preserve">
          <source>The purpose of dependency injection is to decouple the work of
  resolving external software components from your application business
  logic.Without dependency injection, the details of how a component
  accesses required services can get muddled in with the component&amp;rsquo;s
  code. This not only increases the potential for errors, adds code
  bloat, and magnifies maintenance complexities; it couples components
  together more closely, making it difficult to modify dependencies when
  refactoring or testing.</source>
          <target state="translated">El prop&amp;oacute;sito de la inyecci&amp;oacute;n de dependencia es desacoplar el trabajo de resolver los componentes de software externos de la l&amp;oacute;gica de negocio de su aplicaci&amp;oacute;n. Sin la inyecci&amp;oacute;n de dependencia, los detalles de c&amp;oacute;mo un componente accede a los servicios requeridos pueden confundirse con el c&amp;oacute;digo del componente. Esto no solo aumenta la posibilidad de errores, agrega una gran cantidad de c&amp;oacute;digo y aumenta las complejidades de mantenimiento; une componentes m&amp;aacute;s juntos, lo que dificulta la modificaci&amp;oacute;n de dependencias al refactorizar o probar.</target>
        </trans-unit>
        <trans-unit id="0597c45b3f09c949a793674e4746ee654b8e2e31" translate="yes" xml:space="preserve">
          <source>The script is dependent: it won't execute successfully on its own (&lt;code&gt;archive_files&lt;/code&gt; is not defined).</source>
          <target state="translated">El script depende: no se ejecutar&amp;aacute; con &amp;eacute;xito por s&amp;iacute; solo ( &lt;code&gt;archive_files&lt;/code&gt; no est&amp;aacute; definido).</target>
        </trans-unit>
        <trans-unit id="1771cd5e467d2af2b6f2a767136b82451f592144" translate="yes" xml:space="preserve">
          <source>The specific domain of DI is delegation of dependency configuration and initialization.</source>
          <target state="translated">El dominio específico del DI es la delegación de la configuración de la dependencia y la inicialización.</target>
        </trans-unit>
        <trans-unit id="cd6b99e6180e4829c33bd4547e92926e1044e126" translate="yes" xml:space="preserve">
          <source>The whole point of Dependency Injection (DI) is to keep application source code &lt;strong&gt;clean&lt;/strong&gt; and &lt;strong&gt;stable&lt;/strong&gt;:</source>
          <target state="translated">El objetivo de la Inyecci&amp;oacute;n de dependencias (DI) es mantener el c&amp;oacute;digo fuente de la aplicaci&amp;oacute;n &lt;strong&gt;limpio&lt;/strong&gt; y &lt;strong&gt;estable&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="27e320b7600e5266bce3ce68ab1e42620f41d50b" translate="yes" xml:space="preserve">
          <source>There are many different ways how to use dependency injection. It is possible to combine it with Singleton, etc., but still in basic it is only association realized by creating attribute of object type inside another object.
The usefulness is only and only in feature, that code, which we should write again and again is always prepared and done for us forward. This is why DI so closely binded with Inversion of Control (IoC) which means, that our program passes control another running module, which does injections of beans to our code. (Each object, which can be injected can be signed or considered as a Bean.) For example in Spring it is done by creating and initialization &lt;em&gt;ApplicationContext&lt;/em&gt; container, which does this work for us. We simply in our code create the Context and invoke initialization the beans. In that moment injection has been done automatically.</source>
          <target state="translated">Hay muchas formas diferentes de usar la inyecci&amp;oacute;n de dependencia. Es posible combinarlo con Singleton, etc., pero a&amp;uacute;n as&amp;iacute;, en la base, solo es una asociaci&amp;oacute;n realizada al crear un atributo de tipo de objeto dentro de otro objeto. La utilidad es &amp;uacute;nica y &amp;uacute;nica en la caracter&amp;iacute;stica, ese c&amp;oacute;digo, que deber&amp;iacute;amos escribir una y otra vez, siempre est&amp;aacute; preparado y hecho para que lo enviemos. Esta es la raz&amp;oacute;n por la cual DI se vincul&amp;oacute; tan estrechamente con la Inversi&amp;oacute;n de control (IoC), lo que significa que nuestro programa pasa el control de otro m&amp;oacute;dulo en ejecuci&amp;oacute;n, que realiza inyecciones de beans en nuestro c&amp;oacute;digo. (Cada objeto, que se puede inyectar, se puede firmar o considerar como un Bean). Por ejemplo, en Spring se hace creando e inicializando el contenedor &lt;em&gt;ApplicationContext&lt;/em&gt; , lo que nos sirve. Simplemente en nuestro c&amp;oacute;digo creamos el Contexto e invocamos la inicializaci&amp;oacute;n de los beans. En ese momento la inyecci&amp;oacute;n se ha realizado autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="4bbc78d6e852d2e63980ceadf582e6e2cde07680" translate="yes" xml:space="preserve">
          <source>There are two primary approaches to implementing DI:</source>
          <target state="translated">Hay dos enfoques principales para la aplicación del DI:</target>
        </trans-unit>
        <trans-unit id="e94b174e1d5cc2e2152c883c5d77b0f60deea3d8" translate="yes" xml:space="preserve">
          <source>There have been several questions already posted with specific questions about &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, such as when to use it and what frameworks are there for it. However,</source>
          <target state="translated">Ya se han publicado varias preguntas con preguntas espec&amp;iacute;ficas sobre &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;la inyecci&amp;oacute;n de dependencia&lt;/a&gt; , como cu&amp;aacute;ndo usarla y qu&amp;eacute; marcos existen para ello. Sin embargo,</target>
        </trans-unit>
        <trans-unit id="bc485497e5c277af6e8ba89ddeb765c26b3e96ea" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;an article by Martin Fowler&lt;/a&gt; that may prove useful, too.</source>
          <target state="translated">Hay &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;un art&amp;iacute;culo de Martin Fowler&lt;/a&gt; que tambi&amp;eacute;n puede resultar &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="815c6163aa7ffe62c24c7f4421caa35a91b5752f" translate="yes" xml:space="preserve">
          <source>This can be viewed in different ways:</source>
          <target state="translated">Esto se puede ver de diferentes maneras:</target>
        </trans-unit>
        <trans-unit id="252c2fc56bbf461770e127f5279e75e5c6e1a9ef" translate="yes" xml:space="preserve">
          <source>This is based on the answer @Adam N posted.</source>
          <target state="translated">Esto se basa en la respuesta que @Adam N publicó.</target>
        </trans-unit>
        <trans-unit id="3214625379bb5b7d1b275f45dbd054121808f8f3" translate="yes" xml:space="preserve">
          <source>To make Dependency Injection concept simple to understand. Let's take an example of switch button to toggle(on/off) a bulb.</source>
          <target state="translated">Para que el concepto de Inyección de Dependencia sea fácil de entender.Tomemos un ejemplo de botón para encender y apagar una bombilla.</target>
        </trans-unit>
        <trans-unit id="5343d4544799a720118861acb1f47462973d60f8" translate="yes" xml:space="preserve">
          <source>Two types of Dependency Injection:</source>
          <target state="translated">Dos tipos de inyección de dependencia:</target>
        </trans-unit>
        <trans-unit id="63568b370a821de5c78ae9aa707bb16d7ed41fac" translate="yes" xml:space="preserve">
          <source>Typically, once IoC containers have been configured / bootstrapped, they operate seamlessly in the background allowing the coder to focus on the code at hand rather than worrying about dependencies.</source>
          <target state="translated">Típicamente,una vez que los contenedores de IO han sido configurados bootstrap,operan sin problemas en el fondo permitiendo al codificador centrarse en el código en cuestión en lugar de preocuparse por las dependencias.</target>
        </trans-unit>
        <trans-unit id="182c61d24602b96b1f93b9d02ddeddadb6b2993d" translate="yes" xml:space="preserve">
          <source>Unfortunately the bad part is that some people have assumed you need a specialized framework to do dependency obfuscation and that you are somehow a 'lesser' programmer if you choose not to use a particular framework to do it. Another, extremely disturbing myth, believed by many, is that dependency injection is the only way of achieving dependency obfuscation. This is demonstrably and historically and obviously 100% wrong but you will have trouble convincing some people that there are alternatives to dependency injection for your dependency obfuscation requirements.</source>
          <target state="translated">Desafortunadamente la parte mala es que algunas personas han asumido que se necesita un marco especializado para hacer la ofuscación de la dependencia y que de alguna manera se es un programador &quot;menor&quot; si se elige no usar un marco particular para hacerlo.Otro mito extremadamente perturbador,creído por muchos,es que la inyección de dependencia es la única forma de lograr la ofuscación de dependencia.Esto es demostrable e históricamente y obviamente 100% erróneo,pero tendrá problemas para convencer a algunas personas de que existen alternativas a la inyección de dependencia para sus requisitos de ofuscación de dependencia.</target>
        </trans-unit>
        <trans-unit id="3848296892c89c589ff3cd256248c78c171b9a63" translate="yes" xml:space="preserve">
          <source>Use Dependency Injection</source>
          <target state="translated">Usar la inyección de dependencia</target>
        </trans-unit>
        <trans-unit id="b5b26b6f5a26c971914a39f28f7610b2ff42bb58" translate="yes" xml:space="preserve">
          <source>Using a Dependency Injection Container</source>
          <target state="translated">Uso de un contenedor de inyección de dependencia</target>
        </trans-unit>
        <trans-unit id="38051c244ec62e5af7798f63213cc9da83353e86" translate="yes" xml:space="preserve">
          <source>Using configuration only with &lt;em&gt;dependency lookup&lt;/em&gt; does not help as number of configuration parameters may change per dependency (e.g. new authentication type) as well as number of supported types of dependencies (e.g. new database type).</source>
          <target state="translated">El uso de la configuraci&amp;oacute;n solo con &lt;em&gt;la b&amp;uacute;squeda de dependencias&lt;/em&gt; no ayuda, ya que el n&amp;uacute;mero de par&amp;aacute;metros de configuraci&amp;oacute;n puede cambiar por dependencia (por ejemplo, nuevo tipo de autenticaci&amp;oacute;n), as&amp;iacute; como el n&amp;uacute;mero de tipos de dependencias compatibles (por ejemplo, nuevo tipo de base de datos).</target>
        </trans-unit>
        <trans-unit id="cd86d58fd77887709d26819ecdbbed88c3b2259e" translate="yes" xml:space="preserve">
          <source>Usually the intermediate level provides factories for the constructed objects, which must provide a role that each requested object type must satisfy. That's because by having an intermediate level that hides the details of construction, you've already incurred the abstraction penalty imposed by factories, so you might as well use factories.</source>
          <target state="translated">Normalmente el nivel intermedio proporciona fábricas para los objetos construidos,que deben proporcionar un papel que cada tipo de objeto solicitado debe satisfacer.Eso es porque al tener un nivel intermedio que oculta los detalles de la construcción,ya se ha incurrido en la pena de abstracción impuesta por las fábricas,por lo que bien podría utilizar fábricas.</target>
        </trans-unit>
        <trans-unit id="f80646d8467ba758d39c4c0efe8023f67e2f3d51" translate="yes" xml:space="preserve">
          <source>We can also loosen the dependency on &lt;code&gt;Console&lt;/code&gt; to an abstraction, such as a &lt;code&gt;TextWriter&lt;/code&gt;. Dependency Injection is typically implemented as either &lt;code&gt;constructor&lt;/code&gt; injection (passing an abstraction to a dependency as a parameter to the constructor of a consuming class) or &lt;code&gt;Setter Injection&lt;/code&gt; (passing the dependency via a &lt;code&gt;setXyz()&lt;/code&gt; setter or a .Net Property with &lt;code&gt;{set;}&lt;/code&gt; defined). Constructor Injection is preferred, as this guarantees the class will be in a correct state after construction, and allows the internal dependency fields to be marked as &lt;code&gt;readonly&lt;/code&gt; (C#) or &lt;code&gt;final&lt;/code&gt; (Java). So using constructor injection on the above example, this leaves us with:</source>
          <target state="translated">Tambi&amp;eacute;n podemos aflojar la dependencia de la &lt;code&gt;Console&lt;/code&gt; a una abstracci&amp;oacute;n, como un &lt;code&gt;TextWriter&lt;/code&gt; . La Inyecci&amp;oacute;n de dependencias generalmente se implementa como inyecci&amp;oacute;n de &lt;code&gt;constructor&lt;/code&gt; (pasando una abstracci&amp;oacute;n a una dependencia como par&amp;aacute;metro al constructor de una clase consumidora) o &lt;code&gt;Setter Injection&lt;/code&gt; (pasando la dependencia a trav&amp;eacute;s de un setter &lt;code&gt;setXyz()&lt;/code&gt; o una Propiedad .Net con &lt;code&gt;{set;}&lt;/code&gt; definido). Se prefiere la inyecci&amp;oacute;n de constructor, ya que esto garantiza que la clase estar&amp;aacute; en un estado correcto despu&amp;eacute;s de la construcci&amp;oacute;n y permite que los campos de dependencia internos se &lt;code&gt;readonly&lt;/code&gt; como de solo lectura (C #) o &lt;code&gt;final&lt;/code&gt; (Java). Entonces, usando la inyecci&amp;oacute;n del constructor en el ejemplo anterior, esto nos deja con:</target>
        </trans-unit>
        <trans-unit id="86284d96e43cd594072665725439a4504abe091b" translate="yes" xml:space="preserve">
          <source>We can however apply &lt;code&gt;DIP&lt;/code&gt; to this class, by abstracting out the the concern of timestamping as a dependency, and coupling &lt;code&gt;MyLogger&lt;/code&gt; only to a simple interface:</source>
          <target state="translated">Sin embargo, podemos aplicar &lt;code&gt;DIP&lt;/code&gt; a esta clase, &lt;code&gt;MyLogger&lt;/code&gt; la preocupaci&amp;oacute;n de la marca de tiempo como una dependencia, y acoplando MyLogger solo a una interfaz simple:</target>
        </trans-unit>
        <trans-unit id="4d76ed5465c1e8ece422b3fde5fc9eac7b93e015" translate="yes" xml:space="preserve">
          <source>We can see a wide variety of application of this pattern in our day to day life.
Some of the examples are Tape recorder, VCD, CD Drive etc.</source>
          <target state="translated">Podemos ver una amplia variedad de aplicaciones de este patrón en nuestra vida diaria.Algunos de los ejemplos son la grabadora de cinta,VCD,unidad de CD,etc.</target>
        </trans-unit>
        <trans-unit id="699f2807e416a1b822a3e5508ecc546ba1097cee" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to hard code the object using new keyword rather define the bean dependency in the configuration file. The spring container will be responsible for hooking up all.</source>
          <target state="translated">No necesitamos codificar el objeto con una nueva palabra clave sino definir la dependencia del bean en el archivo de configuraci&amp;oacute;n. El contenedor de resorte ser&amp;aacute; responsable de conectar todo.</target>
        </trans-unit>
        <trans-unit id="e6a519ea1c63ceedd483bc62f122abf4b1705040" translate="yes" xml:space="preserve">
          <source>We just call that passing parameters into the constructor. We've been doing that regularly ever since constructors were invented.</source>
          <target state="translated">A eso le llamamos parámetros de paso en el constructor.Lo hemos hecho regularmente desde que se inventaron los constructores.</target>
        </trans-unit>
        <trans-unit id="4939eb99c093f041eb14a0ea96bcb8652ea8525e" translate="yes" xml:space="preserve">
          <source>What if I want to change the object at runtime? For example, my config already says when I instantiate MyController, inject for FileLogger as ILogger. But I might want to inject DatabaseLogger.</source>
          <target state="translated">¿Y si quiero cambiar el objeto en tiempo de ejecución? Por ejemplo,mi config ya dice cuando instancio MyController,inyectar para FileLogger como ILogger.Pero puede que quiera inyectar DatabaseLogger.</target>
        </trans-unit>
        <trans-unit id="3e2750129099d2d658ea524bc22e6b383e10d747" translate="yes" xml:space="preserve">
          <source>What if we want to change the type of its dependent object - say &lt;code&gt;Wheel&lt;/code&gt; - after the initial &lt;code&gt;NepaliRubberWheel()&lt;/code&gt; punctures?
We need to recreate the Car object with its new dependency say &lt;code&gt;ChineseRubberWheel()&lt;/code&gt;, but only the &lt;code&gt;Car&lt;/code&gt; manufacturer can do that.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; &lt;code&gt;NepaliRubberWheel()&lt;/code&gt; si queremos cambiar el tipo de su objeto dependiente, digamos &lt;code&gt;Wheel&lt;/code&gt; , despu&amp;eacute;s de los pinchazos iniciales de NepaliRubberWheel () ? Necesitamos recrear el objeto Car con su nueva dependencia, por ejemplo &lt;code&gt;ChineseRubberWheel()&lt;/code&gt; , pero solo el fabricante de &lt;code&gt;Car&lt;/code&gt; puede hacer eso.</target>
        </trans-unit>
        <trans-unit id="d12d549f3851beb3cde5e7133f1816376aac4516" translate="yes" xml:space="preserve">
          <source>What is dependency Injection?</source>
          <target state="translated">¿Qué es la inyección para la dependencia?</target>
        </trans-unit>
        <trans-unit id="2a58e8a199dcdef3591f016058aadf67a10b6ea0" translate="yes" xml:space="preserve">
          <source>What is dependency injection</source>
          <target state="translated">¿Qué es la inyección para la dependencia?</target>
        </trans-unit>
        <trans-unit id="96816fe77c474fe522ad8e991ee6edf78f7425c0" translate="yes" xml:space="preserve">
          <source>When to use DI : I would recommend using DI in almost all production projects ( small/big), particularly in ever changing business environments :)</source>
          <target state="translated">Cuándo usar el DI:Recomendaría usar el DI en casi todos los proyectos de producción(smallbig),particularmente en entornos empresariales siempre cambiantes :)</target>
        </trans-unit>
        <trans-unit id="f48ccb208f603d34093b9d2e0d7b264d9656e30f" translate="yes" xml:space="preserve">
          <source>When to use? I would say whenever the application is large enough that encapsulating logic into separate modules, with a dependency graph between the modules gives a gain in readability and explorability of the code.</source>
          <target state="translated">¿Cuándo usar? Diría que cuando la aplicación es lo suficientemente grande como para encapsular la lógica en módulos separados,con un gráfico de dependencia entre los módulos da una ganancia en la legibilidad y la explorabilidad del código.</target>
        </trans-unit>
        <trans-unit id="eed4b47b27cb37bd0ec38f924963811f2806030d" translate="yes" xml:space="preserve">
          <source>When using dependency injection, objects are given their dependencies &lt;em&gt;at run time rather than compile time (car manufacturing time)&lt;/em&gt;.
So that we can now change the &lt;code&gt;Wheel&lt;/code&gt; whenever we want. Here, the &lt;code&gt;dependency&lt;/code&gt; (&lt;code&gt;wheel&lt;/code&gt;) can be injected into &lt;code&gt;Car&lt;/code&gt; at run time.</source>
          <target state="translated">Cuando se usa la inyecci&amp;oacute;n de dependencias, los objetos reciben sus dependencias &lt;em&gt;en tiempo de ejecuci&amp;oacute;n en lugar de tiempo de compilaci&amp;oacute;n (tiempo de fabricaci&amp;oacute;n del autom&amp;oacute;vil)&lt;/em&gt; . Para que ahora podamos cambiar la &lt;code&gt;Wheel&lt;/code&gt; cuando queramos. Aqu&amp;iacute;, la &lt;code&gt;dependency&lt;/code&gt; ( &lt;code&gt;wheel&lt;/code&gt; ) se puede inyectar en el &lt;code&gt;Car&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="abc4d8921a46969ecc613e5055f52eca2c65ee07" translate="yes" xml:space="preserve">
          <source>When we change &lt;code&gt;Service&lt;/code&gt; constructor, we need to change code in all place create &lt;code&gt;Service&lt;/code&gt; object</source>
          <target state="translated">Cuando cambiamos el constructor del &lt;code&gt;Service&lt;/code&gt; , necesitamos cambiar el c&amp;oacute;digo en todo lugar, crear el objeto del &lt;code&gt;Service&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60a4437333ad60740280d7819cb15d4da2c92233" translate="yes" xml:space="preserve">
          <source>When you change the &lt;code&gt;Service&lt;/code&gt;, you only need to change it in Injector class</source>
          <target state="translated">Cuando cambia el &lt;code&gt;Service&lt;/code&gt; , solo necesita cambiarlo en la clase Inyector</target>
        </trans-unit>
        <trans-unit id="f19469b25d4ea3f9876fe4907b1de5c966b79296" translate="yes" xml:space="preserve">
          <source>When you have a configuration of DI where all the actual implementations(not interfaces) that are going to be injected into a class (for e.g services to a controller) why is that not some sort of hard-coding?</source>
          <target state="translated">Cuando se tiene una configuración de DI donde todas las implementaciones reales (no las interfaces)que van a ser inyectadas en una clase (por ejemplo,servicios a un controlador)¿por qué no es una especie de código duro?</target>
        </trans-unit>
        <trans-unit id="e0e2e926020e782ca430259f6c4e7d67c44e4d4d" translate="yes" xml:space="preserve">
          <source>When you use some constant like a database name you'd quickly move it from the inside of the code to some config file and pass a variable containing that value to the place where it is needed.  The reason to do that is that these constants usually change more frequently than the rest of the code.  For example if you'd like to test the code in a test database.</source>
          <target state="translated">Cuando usas alguna constante como el nombre de una base de datos,la mueves rápidamente desde el interior del código a algún archivo de configuración y pasas una variable que contiene ese valor al lugar donde se necesita.La razón para hacer eso es que estas constantes suelen cambiar con más frecuencia que el resto del código.Por ejemplo,si quieres probar el código en una base de datos de prueba.</target>
        </trans-unit>
        <trans-unit id="f13093462f2a85a2c0797285aa9864b8c2e8b0bb" translate="yes" xml:space="preserve">
          <source>Where there likely will be a need to substitute a dependency for an equivalent implementation,</source>
          <target state="translated">En los casos en que sea probable que sea necesario sustituir una dependencia por una aplicación equivalente,</target>
        </trans-unit>
        <trans-unit id="bd97b161d9e5c8373340c65f6128ec2d5bcf0fbe" translate="yes" xml:space="preserve">
          <source>Where uncertainty of the lifespan of a dependency may warrant experimentation (e.g. Hey, &lt;code&gt;MyDepClass&lt;/code&gt; is thread safe - what if we make it a singleton and inject the same instance into all consumers?)</source>
          <target state="translated">Donde la incertidumbre de la vida &amp;uacute;til de una dependencia puede justificar la experimentaci&amp;oacute;n (por ejemplo, Hey, &lt;code&gt;MyDepClass&lt;/code&gt; es seguro para subprocesos, &amp;iquest;qu&amp;eacute; pasa si lo convertimos en un singleton e inyectamos la misma instancia a todos los consumidores?)</target>
        </trans-unit>
        <trans-unit id="59a5dadbd1f1b46c880e4228a933e3575c4621e6" translate="yes" xml:space="preserve">
          <source>Whereas after application of the DIP, the requirement is loosened, and the concern of obtaining and managing the lifespan of the &lt;code&gt;Foo&lt;/code&gt; dependency has been removed:</source>
          <target state="translated">Mientras que despu&amp;eacute;s de la aplicaci&amp;oacute;n del DIP, el requisito se afloja y se elimina la preocupaci&amp;oacute;n de obtener y administrar la vida &amp;uacute;til de la dependencia de &lt;code&gt;Foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8fd3870a84afb43d089851d3d66aefbefd8208" translate="yes" xml:space="preserve">
          <source>While designing a system it require a reel to record or playback sound or music. There are two possibilities for designing this system</source>
          <target state="translated">Al diseñar un sistema se requiere un carrete para grabar o reproducir sonido o música.Hay dos posibilidades para diseñar este sistema</target>
        </trans-unit>
        <trans-unit id="f24455302b22cf5f3be2af86011a77cc94c7bdb3" translate="yes" xml:space="preserve">
          <source>Why : Because you want your code to be easily testable, mockable etc so that you can quickly test your changes and push it to the market. Besides why would you not when you there are lots of awesome free tools/frameworks to support you in your journey to a codebase where you have more control.</source>
          <target state="translated">Por qué:Porque quieres que tu código sea fácilmente comprobable,burlable,etc.,para que puedas probar rápidamente tus cambios y empujarlo al mercado.Además,¿por qué no lo harías cuando hay un montón de increíbles marcos de herramientas gratuitas para apoyarte en tu viaje a una base de código donde tienes más control.</target>
        </trans-unit>
        <trans-unit id="155c0f309806e222f377eeb338deeddb4ac2035d" translate="yes" xml:space="preserve">
          <source>Why does PersonService no longer have to worry about GroupMembershipService? You just mentioned GroupMembership has multiple things(objects/properties) it depends on. If GMService was required in PService, you'd have it as a property. You can mock that out regardless of whether you injected it or not. The only time I'd like it to be injected is if GMService had more specific child classes, which you wouldn't know until runtime. Then you'd want to inject the subclass. Or if you wanted to use that as either singleton or prototype. To be honest, the configuration file has everything hardcoded as far as what subclass for a type (interface) it is going to inject during compile time.</source>
          <target state="translated">¿Por qué PersonService ya no tiene que preocuparse de GroupMembershipService? Acabas de mencionar que el servicio de membresía de grupo tiene múltiples cosas (objetos-propiedades)de las que depende.Si GMService fuera requerido en PService,lo tendrías como una propiedad.Puedes burlarte de eso sin importar si lo inyectaste o no.La única vez que me gustaría que se inyectara es si el GMService tuviera clases para niños más específicas,lo cual no sabría hasta el tiempo de ejecución.Entonces querrías inyectar la subclase.O si quisieras usar eso como singleton o como prototipo.Para ser honesto,el archivo de configuración tiene todo codificado en cuanto a qué subclase para un tipo (interfaz)va a inyectar durante el tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="316cb2abaec2a090bd29421bce7b593838a6bd08" translate="yes" xml:space="preserve">
          <source>With Dependency Injection</source>
          <target state="translated">Con la inyección de dependencia</target>
        </trans-unit>
        <trans-unit id="1233c83a1bf8dee2cadec4b76cd3eec49f5d8602" translate="yes" xml:space="preserve">
          <source>With Dependency Injection, instead of instantiating the &lt;code&gt;GroupMembershipService&lt;/code&gt; within your &lt;code&gt;PersonService&lt;/code&gt;, you'd either pass it in to the &lt;code&gt;PersonService&lt;/code&gt; constructor, or else add a Property (getter and setter) to set a local instance of it. This means that your &lt;code&gt;PersonService&lt;/code&gt; no longer has to worry about how to create a &lt;code&gt;GroupMembershipService&lt;/code&gt;, it just accepts the ones it's given, and works with them.  This also means that anything which is a subclass of &lt;code&gt;GroupMembershipService&lt;/code&gt;, or implements the &lt;code&gt;GroupMembershipService&lt;/code&gt; interface can be &quot;injected&quot; into the &lt;code&gt;PersonService&lt;/code&gt;, and the &lt;code&gt;PersonService&lt;/code&gt; doesn't need to know about the change.</source>
          <target state="translated">Con la Inyecci&amp;oacute;n de dependencias, en lugar de crear una instancia del &lt;code&gt;GroupMembershipService&lt;/code&gt; dentro de su &lt;code&gt;PersonService&lt;/code&gt; , puede pasarlo al constructor &lt;code&gt;PersonService&lt;/code&gt; o agregar una Propiedad (getter y setter) para establecer una instancia local del mismo. Esto significa que su &lt;code&gt;PersonService&lt;/code&gt; ya no tiene que preocuparse por c&amp;oacute;mo crear un &lt;code&gt;GroupMembershipService&lt;/code&gt; , solo acepta los que se le proporcionan y trabaja con ellos. Esto tambi&amp;eacute;n significa que cualquier cosa que sea una subclase de &lt;code&gt;GroupMembershipService&lt;/code&gt; o que implemente la interfaz &lt;code&gt;GroupMembershipService&lt;/code&gt; se puede &quot;inyectar&quot; en &lt;code&gt;PersonService&lt;/code&gt; , y &lt;code&gt;PersonService&lt;/code&gt; no necesita saber sobre el cambio.</target>
        </trans-unit>
        <trans-unit id="0f0a3b5beff6045bb4f3fe845c538ad21014ce5e" translate="yes" xml:space="preserve">
          <source>With Dependency injection, the dependency injector will take off the instantiation for us</source>
          <target state="translated">Con la inyección de dependencia,el inyector de dependencia nos quitará la instanciación</target>
        </trans-unit>
        <trans-unit id="55cdf21af285a1570d5d341608f193842fd5a672" translate="yes" xml:space="preserve">
          <source>With dependency injection, someone else takes care of all the preparation and makes the required equipment available to you. You will receive (&quot;be injected&quot;) the boat, the fishing rod and the bait - all ready to use.</source>
          <target state="translated">Con la inyección para la dependencia,otra persona se encarga de toda la preparación y pone a su disposición el equipo necesario.Recibirá (&quot;se inyectará&quot;)el bote,la caña de pescar y el cebo,todo listo para usar.</target>
        </trans-unit>
        <trans-unit id="f9f5cf6442cf84c858a561c2c1aa9e63fe5c3866" translate="yes" xml:space="preserve">
          <source>Without Dependency Injection</source>
          <target state="translated">Sin la inyección de dependencia</target>
        </trans-unit>
        <trans-unit id="3b220ed590066bbf10e392ad2dd726fec3be4180" translate="yes" xml:space="preserve">
          <source>Without dependency injection, you need to take care of everything yourself. You need to find a boat, to buy a fishing rod, to look for bait, etc. It's possible, of course, but it puts a lot of responsibility on you. In software terms, it means that you have to perform a lookup for all these things.</source>
          <target state="translated">Sin la inyección de dependencia,tienes que ocuparte de todo tú mismo.Necesitas encontrar un bote,comprar una caña de pescar,buscar carnada,etc.Es posible,por supuesto,pero te da mucha responsabilidad.En términos de software,significa que tienes que realizar una búsqueda de todas estas cosas.</target>
        </trans-unit>
        <trans-unit id="49f49ef1de77737ae4e3ae770e87d4b807452cda" translate="yes" xml:space="preserve">
          <source>Without the DIP, our code (I've called this 'consuming class') is directly coupled to a concrete dependency and is also often burdened with the responsibility of knowing how to obtain, and manage, an instance of this dependency, i.e. conceptually:</source>
          <target state="translated">Sin el DIP,nuestro código (he llamado a esta &quot;clase consumidora&quot;)está directamente acoplado a una dependencia concreta y también a menudo está cargado con la responsabilidad de saber cómo obtener,y manejar,una instancia de esta dependencia,es decir,conceptualmente:</target>
        </trans-unit>
        <trans-unit id="1b0617f8014f1a76dc7ba00100921c6326f40868" translate="yes" xml:space="preserve">
          <source>You can also read</source>
          <target state="translated">También puedes leer</target>
        </trans-unit>
        <trans-unit id="e84e5e5caa3f2b230be8ecf0ca3d63c1bcbc6707" translate="yes" xml:space="preserve">
          <source>You could have injected dependency which implements &lt;code&gt;archive_files&lt;/code&gt; using &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;.</source>
          <target state="translated">Podr&amp;iacute;a haber inyectado dependencia que implementa &lt;code&gt;archive_files&lt;/code&gt; usando &lt;code&gt;tar&lt;/code&gt; o &lt;code&gt;xz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c14f594f01f1de9fd2aab048e30d8d2194a66f7" translate="yes" xml:space="preserve">
          <source>You define &lt;code&gt;archive_files&lt;/code&gt; in &lt;code&gt;archive_files_zip.sh&lt;/code&gt; implementation script (using &lt;code&gt;zip&lt;/code&gt; in this case):</source>
          <target state="translated">Define &lt;code&gt;archive_files&lt;/code&gt; en el script de implementaci&amp;oacute;n &lt;code&gt;archive_files_zip.sh&lt;/code&gt; (usando &lt;code&gt;zip&lt;/code&gt; en este caso):</target>
        </trans-unit>
        <trans-unit id="7444b1acde932a72f7dd1189c7b8bfd322ca3632" translate="yes" xml:space="preserve">
          <source>You don't need a container to do dependency injection. However a container can help you.</source>
          <target state="translated">No necesitas un contenedor para hacer la inyección de dependencia.Sin embargo,un recipiente puede ayudarle.</target>
        </trans-unit>
        <trans-unit id="bbf99c4996fccfe9e7a0ac73dbccffb4a67c6cea" translate="yes" xml:space="preserve">
          <source>a DI Container is a tool to help injecting dependencies</source>
          <target state="translated">un contenedor de DI es una herramienta para ayudar a inyectar las dependencias</target>
        </trans-unit>
        <trans-unit id="4a4aad97c907cbb008e7b8b26d6f30985b32b8aa" translate="yes" xml:space="preserve">
          <source>application &lt;strong&gt;deployment&lt;/strong&gt; (&lt;strong&gt;multiple&lt;/strong&gt; target environments with independent lifecycles)</source>
          <target state="translated">&lt;strong&gt;implementaci&amp;oacute;n de&lt;/strong&gt; aplicaciones ( &lt;strong&gt;m&amp;uacute;ltiples&lt;/strong&gt; entornos de destino con ciclos de vida independientes)</target>
        </trans-unit>
        <trans-unit id="a32ef176365fadc9778959691ce81fd982d81b42" translate="yes" xml:space="preserve">
          <source>application &lt;strong&gt;development&lt;/strong&gt; (&lt;strong&gt;single&lt;/strong&gt; source code release lifecycle)</source>
          <target state="translated">&lt;strong&gt;desarrollo de&lt;/strong&gt; aplicaciones (ciclo de vida de lanzamiento de c&amp;oacute;digo fuente &lt;strong&gt;&amp;uacute;nico&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="c2ae11a3ef2bc13a293ffe2bcc4ea4cf9c7088db" translate="yes" xml:space="preserve">
          <source>before doing a</source>
          <target state="translated">antes de hacer un</target>
        </trans-unit>
        <trans-unit id="fb1802bd1e16e969815bc074b7285e09e6c78cfd" translate="yes" xml:space="preserve">
          <source>from Book &lt;strong&gt;Apress.Spring.Persistence.with.Hibernate.Oct.2010&lt;/strong&gt;</source>
          <target state="translated">de Book &lt;strong&gt;Apress.Spring.Persistence.with.Hibernate.Oct.2010&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="472f32380d47285104826da06f61443568994b00" translate="yes" xml:space="preserve">
          <source>mapping between each abstraction and the configured concrete implementation (e.g. &lt;em&gt;&quot;any time a consumer requests an &lt;code&gt;IBar&lt;/code&gt;, return a &lt;code&gt;ConcreteBar&lt;/code&gt; instance&quot;&lt;/em&gt;)</source>
          <target state="translated">mapeo entre cada abstracci&amp;oacute;n y la implementaci&amp;oacute;n concreta configurada (por ejemplo, &lt;em&gt;&quot;cada vez que un consumidor solicita un &lt;code&gt;IBar&lt;/code&gt; , devuelve una instancia de &lt;code&gt;ConcreteBar&lt;/code&gt; &quot;&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="a89dcdc02705c87126898e6ee6b1fbd5bdb0786f" translate="yes" xml:space="preserve">
          <source>policies can be set up for the lifespan management of each dependency, e.g. to create a new object for each consumer instance, to share a singleton dependency instance across all consumers, to share the same dependency instance only across the same thread, etc.</source>
          <target state="translated">pueden establecerse políticas para la gestión de la vida útil de cada dependencia,por ejemplo,para crear un nuevo objeto para cada caso de consumo,para compartir un caso de dependencia único entre todos los consumidores,para compartir el mismo caso de dependencia sólo a través del mismo hilo,etc.</target>
        </trans-unit>
        <trans-unit id="036711eff2961f7a9eb870a48ad40790feff55dd" translate="yes" xml:space="preserve">
          <source>we can place the reel inside the machine</source>
          <target state="translated">podemos colocar el carrete dentro de la máquina</target>
        </trans-unit>
        <trans-unit id="0a91593e00bce6f1bb48c8658c6f3c6f186cbbf2" translate="yes" xml:space="preserve">
          <source>we can provide a hook for the reel where it can be placed.</source>
          <target state="translated">podemos proporcionar un gancho para el carrete donde se puede colocar.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
