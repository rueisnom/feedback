<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/130794">
    <body>
      <group id="130794">
        <trans-unit id="075303a37c1db7777d673503bd42ea6517e55270" translate="yes" xml:space="preserve">
          <source>&quot;As our &lt;strong&gt;applications&lt;/strong&gt; grow and evolves, each one of our &lt;strong&gt;code entities&lt;/strong&gt; will internally require &lt;strong&gt;instances of other objects&lt;/strong&gt;, which are better known as &lt;strong&gt;dependencies&lt;/strong&gt; in the world of software engineering. The &lt;strong&gt;action&lt;/strong&gt; of passing such &lt;strong&gt;dependencies&lt;/strong&gt; to the dependent client is known as &lt;strong&gt;injection&lt;/strong&gt;, and it also entails the participation of another code entity, named the &lt;strong&gt;injector&lt;/strong&gt;. The &lt;strong&gt;injector&lt;/strong&gt; will take responsibility for &lt;strong&gt;instantiating&lt;/strong&gt; and &lt;strong&gt;bootstrapping&lt;/strong&gt; the required &lt;strong&gt;dependencies&lt;/strong&gt; so they are ready for use from the very moment they are successfully injected in the client. This is very important since the client knows nothing about how to &lt;strong&gt;instantiate&lt;/strong&gt; its own &lt;strong&gt;dependencies&lt;/strong&gt; and is only aware of the &lt;strong&gt;interface&lt;/strong&gt; they implement in order to use them.&quot;</source>
          <target state="translated">&quot;우리의 &lt;strong&gt;응용 프로그램이&lt;/strong&gt; 성장하고 발전함에 따라 각 &lt;strong&gt;코드 엔터티&lt;/strong&gt; 는 내부적으로 소프트웨어 엔지니어링 세계에서 &lt;strong&gt;종속성&lt;/strong&gt; 으로 더 잘 알려진 &lt;strong&gt;다른 객체의 인스턴스를&lt;/strong&gt; 필요로 &lt;strong&gt;합니다&lt;/strong&gt; . 이러한 &lt;strong&gt;종속성&lt;/strong&gt; 을 종속 클라이언트에 전달하는 &lt;strong&gt;동작&lt;/strong&gt; 은 &lt;strong&gt;injection&lt;/strong&gt; , 또한 &lt;strong&gt;인젝터&lt;/strong&gt; 라는 다른 코드 엔터티의 참여가 수반됩니다. &lt;strong&gt;인젝터&lt;/strong&gt; 는 필요한 &lt;strong&gt;종속성&lt;/strong&gt; 을 &lt;strong&gt;인스턴스화&lt;/strong&gt; 하고 &lt;strong&gt;부트 스트래핑&lt;/strong&gt; 해야 할 책임이 있으므로 클라이언트에 성공적으로 주입 된 순간부터 사용할 수 있습니다. 클라이언트는 자신의 &lt;strong&gt;의존성&lt;/strong&gt; 을 &lt;strong&gt;인스턴스화&lt;/strong&gt; 하는 방법에 대해 아무것도 모르고 사용하기 위해 구현 한 &lt;strong&gt;인터페이스&lt;/strong&gt; 만 알고 있습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="88ba72c68eb66f9403511df347aad31c0ffb36bb" translate="yes" xml:space="preserve">
          <source>&quot;Dependency Injection&quot; is a 25-dollar
  term for a 5-cent concept. [...]
  Dependency injection means giving an
  object its instance variables. [...].</source>
          <target state="translated">&quot;종속성 주입&quot;은 5 센트 개념의 25 달러 용어입니다. [...] 의존성 주입은 객체에 인스턴스 변수를 부여하는 것을 의미합니다. [...].</target>
        </trans-unit>
        <trans-unit id="884583105d69da013b6572c7250c4e2a8f722ed6" translate="yes" xml:space="preserve">
          <source>&quot;Dependency injection&quot; is considered a type of &quot;inversion of control&quot;, which means that some logic is taken out of the caller. That isn't the case when the caller passes in parameters, so if that were DI, DI would not imply inversion of control.</source>
          <target state="translated">&quot;종속성 주입&quot;은 &quot;제어 역전&quot;의 한 유형으로 간주되는데, 이는 일부 로직이 호출자로부터 제거됨을 의미합니다. 호출자가 매개 변수를 전달하는 경우에는 해당되지 않으므로 DI 인 경우 DI는 제어 반전을 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="559316cc487d0d2d80076d1938d00fe314c1d36f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;In short, &lt;strong&gt;DI&lt;/strong&gt; helps you write code in a &lt;strong&gt;loosely coupled&lt;/strong&gt; way and makes your &lt;strong&gt;code&lt;/strong&gt; more &lt;strong&gt;testable&lt;/strong&gt; and &lt;strong&gt;reusable&lt;/strong&gt;.&amp;rdquo;</source>
          <target state="translated">즉, &lt;strong&gt;DI&lt;/strong&gt; 는 &lt;strong&gt;느슨하게 결합 된&lt;/strong&gt; 방식으로 코드를 작성하는 데 도움이 &lt;strong&gt;되며&lt;/strong&gt; &lt;strong&gt;코드를&lt;/strong&gt; 더욱 &lt;strong&gt;테스트&lt;/strong&gt; 하고 &lt;strong&gt;재사용&lt;/strong&gt; 할 수있게합니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ec42628a9387e4101c1904f5ffcd31e7a85677db" translate="yes" xml:space="preserve">
          <source>(A concrete &lt;code&gt;Clock&lt;/code&gt; needs to be provided, which of course could revert to &lt;code&gt;DateTime.Now&lt;/code&gt;, and the two dependencies need to be provided by an IoC container via constructor injection)</source>
          <target state="translated">(구체적인 &lt;code&gt;Clock&lt;/code&gt; 을 제공해야합니다. 물론 &lt;code&gt;DateTime.Now&lt;/code&gt; 로 되돌릴 수 있으며 두 개의 종속성은 생성자 주입을 통해 IoC 컨테이너에 의해 제공되어야합니다)</target>
        </trans-unit>
        <trans-unit id="7c77d04844ca55b45c4e29a2ad4bd0663b614dc7" translate="yes" xml:space="preserve">
          <source>1) Simple manual &lt;code&gt;Injector&lt;/code&gt;</source>
          <target state="translated">1) 간단한 수동 &lt;code&gt;Injector&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b8c8a3c4e4de08de9d47e21c94fca818f3e508e" translate="yes" xml:space="preserve">
          <source>1.    Constructor-based dependency injection:</source>
          <target state="translated">1. 생성자 기반 의존성 주입 :</target>
        </trans-unit>
        <trans-unit id="0fd3eb9210cba499046c01b805cb7de8b0581cf6" translate="yes" xml:space="preserve">
          <source>2) Use library: For Android &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;</source>
          <target state="translated">2) 라이브러리 사용 : Android &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1dc2ccd951284c98a3bde560294a5c88093316a" translate="yes" xml:space="preserve">
          <source>2.    Setter-based dependency injection:</source>
          <target state="translated">2. 세터 기반 의존성 주입 :</target>
        </trans-unit>
        <trans-unit id="20d1910df8e94fb0fa91e3b643d5709d2d44f250" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://martinfowler.com/articles/injection.html#InterfaceInjection&quot;&gt;Martin Fowler&lt;/a&gt; documents a third alternative (h/t @MarcDix), where &lt;strong&gt;classes explicitly implement an interface&lt;/strong&gt; for the dependencies programmers wish injected.</source>
          <target state="translated">&lt;a href=&quot;http://martinfowler.com/articles/injection.html#InterfaceInjection&quot;&gt;Martin Fowler&lt;/a&gt; 는 세 번째 대안 (h / t @MarcDix)을 문서화했으며, 여기서 &lt;strong&gt;클래스&lt;/strong&gt; 는 프로그래머가 주입하고자하는 종속성에 &lt;strong&gt;대한 인터페이스&lt;/strong&gt; 를 &lt;strong&gt;명시 적으로 구현합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="139cc1158c0803cacea84c6bb86ce8b3cd6a16e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php-di.org/doc/understanding-di.html&quot;&gt;This&lt;/a&gt; is the most simple explanation about &lt;strong&gt;Dependency Injection&lt;/strong&gt; and &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; I have ever seen:</source>
          <target state="translated">&lt;a href=&quot;http://php-di.org/doc/understanding-di.html&quot;&gt;이것은&lt;/a&gt; 내가 본 &lt;strong&gt;의존성 주입&lt;/strong&gt; 및 &lt;strong&gt;의존성 주입 컨테이너&lt;/strong&gt; 에 대한 가장 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="ea2f6774ac13f40817f28f4fc553b644d8059a9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James Shore's article shows the following examples for comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James Shore의 기사는 다음 비교 예제를 보여줍니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5dd4547c12b988e4cf971119a75e17e9ed5a4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency Injection&lt;/a&gt; means a way (actually &lt;strong&gt;any-way&lt;/strong&gt;) for one part of code (e.g a class) to have access to dependencies (other parts of code, e.g other classes, it depends upon) in a modular way without them being hardcoded (so they can change or be overriden freely, or even be loaded at another time, as needed)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;의존성 주입&lt;/a&gt; 은 코드의 한 부분 (예 : 클래스)이 하드 코딩되지 않은 모듈 식 방식으로 종속성 (다른 코드, 예를 들어 다른 클래스, 의존하는)에 액세스 할 수있는 방법 (실제로 &lt;strong&gt;어쨌든&lt;/strong&gt; )을 의미합니다. 필요에 따라 자유롭게 변경하거나 재정의하거나 다른 시간에로드 할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="489243935980044f46caf00a1da3950eb72480f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SomeClass()&lt;/code&gt; has its constructor as following:</source>
          <target state="translated">&lt;code&gt;SomeClass()&lt;/code&gt; 의 생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7be66ff5c1f2bead4f99265aacf00180d5bd3fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myObject&lt;/code&gt; can be passed directly which makes testing easier.</source>
          <target state="translated">&lt;code&gt;myObject&lt;/code&gt; 를 직접 전달하면 테스트가 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="9bd7701ca83f91008241672a8066b98e80ce7fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and ps , yes it has become an overly-hyped 25$ name for a rather simple, concept)&lt;/em&gt;, my &lt;code&gt;.25&lt;/code&gt; cents</source>
          <target state="translated">&lt;em&gt;(그리고 ps, 그렇습니다. 그것은 다소 단순한 개념으로 지나치게 과장된 25 $ 이름이되었습니다)&lt;/em&gt; , 내 &lt;code&gt;.25&lt;/code&gt; 센트</target>
        </trans-unit>
        <trans-unit id="7c64642d978f251aeaa9e771fd6b2e4c8c2a0138" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DI increases cohesion by removing any need to determine the direction of dependency and write any glue code.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DI는 의존 방향을 결정하고 글루 코드를 작성할 필요가 없어 응집력을 높입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8cd65eebe518df31a3d3e8b816fd1032b277e646" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DI reduces coupling by making all of your components modular (i.e. replacable) and have well-defined interfaces to each other.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DI는 모든 구성 요소를 모듈 식 (예 : 교체 가능)으로 만들고 연결이 잘 정의되어있어 커플 링을 줄입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2f6f530262aaa812ba33a2511d7964178350822" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I found this funny example in terms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot;&gt;loose coupling&lt;/a&gt;:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot;&gt;느슨한 커플 링&lt;/a&gt; 측면 에서이 재미있는 예를 찾았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62fe0e1a78daa62d9061df07333b1c387f953b07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Using&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Using&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81d7f6f687485d5dc12f6f5268a195c72b70fee8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) 2) 3) Using&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 2) 3) 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="134d462b40518572cfc8a34cb9179e98a9817f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Then what does the &lt;code&gt;Dependency Injection&lt;/code&gt; do for us...?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;그렇다면 &lt;code&gt;Dependency Injection&lt;/code&gt; 은 우리를 위해 무엇을합니까?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64e35a8a257eda0748b950b4efd25aebaab56d6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After using dependency injection:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의존성 주입을 사용한 후 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e118dd44c7e67af1dc63de6f5672af7d0d76495d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the above answers are good, my aim is to explain the concept in a simple way so that anyone without a programming knowledge can also understand concept&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;위의 모든 대답은 훌륭합니다. 제 목표는 프로그래밍 지식이없는 사람도 개념을 이해할 수 있도록 간단한 방법으로 개념을 설명하는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21f37caa4106b3b41630895455450baa84ccfb77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Alternative solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;대체 솔루션&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fe080fcf8cd21d9cdaa29a5c39e27707035ab956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DI, DIP and SOLID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DI, DIP 및 SOLID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e78d489aa9f4c7df98e18605184dfcf430472ba1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency Injection&lt;/strong&gt; and &lt;strong&gt;dependency Injection Containers&lt;/strong&gt; are different things:</source>
          <target state="translated">&lt;strong&gt;의존성 주입&lt;/strong&gt; 과 &lt;strong&gt;의존성 주입 컨테이너&lt;/strong&gt; 는 서로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4e7a19bc0d7c4175394cf98e210ddbeaca200985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency Injection&lt;/strong&gt; is passing dependency to other &lt;strong&gt;objects&lt;/strong&gt; or &lt;strong&gt;framework&lt;/strong&gt;( dependency injector).</source>
          <target state="translated">&lt;strong&gt;의존성 주입&lt;/strong&gt; 은 다른 &lt;strong&gt;객체&lt;/strong&gt; 나 &lt;strong&gt;프레임 워크&lt;/strong&gt; (종속성 인젝터)에 의존성을 전달하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9050dff2d4e01dd22dab4a30a3b18b836dbca3a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Disadvantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="352fe1ffa66ad058937206892159aa0c751d3d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example for Dependency injection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의존성 주입의 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89779a6f30decc7c58d031e6da0ce5e9759d2d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Next Steps&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다음 단계&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73b8706173c462cc0bdd6d2632616f2d7f4a120a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; : The creation / mapping / projection (via &lt;code&gt;new ..()&lt;/code&gt;) of POCO / POJO / Serialization DTOs / Entity Graphs / Anonymous JSON projections et al - i.e. &quot;Data only&quot; classes or records - used or returned from methods are &lt;em&gt;not&lt;/em&gt; regarded as Dependencies (in the UML sense) and not subject to DI. Using &lt;code&gt;new&lt;/code&gt; to project these is just fine.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : POCO / POJO / 직렬화 DTO / 엔티티 그래프 / 익명 JSON 프로젝션 등의 생성 / 매핑 / 투영 ( &lt;code&gt;new ..()&lt;/code&gt; 통해) 메소드 (예 : &quot;데이터 만&quot;) 클래스 또는 레코드-메소드에서 사용 또는 반환 된 것으로 간주 &lt;em&gt;되지 않습니다.&lt;/em&gt; DI의 영향을받지 않는 UML 의미의 종속성으로. &lt;code&gt;new&lt;/code&gt; 를 사용하여 이것들을 투영하는 것은 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d98f2b4bd341257a9dbd8120abd05530994fcf1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem&lt;/strong&gt;:
If &lt;code&gt;myObject&lt;/code&gt; involves complex tasks such as disk access or network access, it is &lt;strong&gt;hard&lt;/strong&gt; to do unit test on &lt;code&gt;SomeClass()&lt;/code&gt;. Programmers have to mock &lt;code&gt;myObject&lt;/code&gt; and might &lt;strong&gt;intercept&lt;/strong&gt; the factory call.</source>
          <target state="translated">&lt;strong&gt;문제점&lt;/strong&gt; : &lt;code&gt;myObject&lt;/code&gt; 에 디스크 액세스 또는 네트워크 액세스와 같은 복잡한 작업이 포함 된 경우 &lt;code&gt;SomeClass()&lt;/code&gt; 에서 단위 테스트를 수행하기가 &lt;strong&gt;어렵&lt;/strong&gt; 습니다. 프로그래머는 &lt;code&gt;myObject&lt;/code&gt; 를 조롱해야하며 팩토리 호출을 &lt;strong&gt;가로 챌&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3caa217db0a9feb519ccfb83c5360a0fd9379499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Watched course about EF Core from Julie Lerman recently and also liked her short definition about DI.</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; 최근 Julie Lerman의 EF Core에 대한 코스를 보았고 DI에 대한 짧은 정의를 좋아했습니다.</target>
        </trans-unit>
        <trans-unit id="bb8fdb2caf0495723a2bfa5cae2542c71d3df90c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Using&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fed09c4b3a548192ce23e86d0d3ac85024ca7184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 1)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 1)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5287e00dc55d1b18cf0490002f5097515ab0af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 1)&lt;/strong&gt; Constructor injection</source>
          <target state="translated">&lt;strong&gt;방법 1)&lt;/strong&gt; 생성자 주입</target>
        </trans-unit>
        <trans-unit id="cffbc9253561d5f6c70f7781944f336db2c95227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 2)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 2)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfccbb774df62a67ec9d3bdc2292dd944115740" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 2)&lt;/strong&gt; Setter injection</source>
          <target state="translated">&lt;strong&gt;방법 2)&lt;/strong&gt; 세터 주입</target>
        </trans-unit>
        <trans-unit id="6b6b88724bc7d2fd56ed9b90ed70c1bf61d456de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 3)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 3)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7be335f5337bca5a01d1e24ed56b2f2d716bba6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Way 3)&lt;/strong&gt; Interface injection</source>
          <target state="translated">&lt;strong&gt;방법 3)&lt;/strong&gt; 인터페이스 주입</target>
        </trans-unit>
        <trans-unit id="e997684d5231d7a45924a857d44b5b8961d9a17d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Dependency Injection (DI)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의존성 주입 (DI)이란 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a57f9d5d3eb174e62bab1bb6baa6ed97f6dfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is dependency injection and when/why should or shouldn't it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의존성 주입이란 무엇이며 언제 / 왜 사용해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b431da6264f45e0d6035801527ad040d6ae12bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When to use DI?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DI는 언제 사용합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd3cb919485762e2f7ae20824d2553c1b374d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why use DIP (and DI)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DIP (및 DI)를 사용하는 이유는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e626bfdc41d8d0154fb13bbccc4a07c5bdea697f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without Dependency Injection (DI):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의존성 주입이없는 경우 (DI) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b41ad2ddaf8a9d9eee7a1bdd549ad0e74faf4d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;clean&lt;/strong&gt; of dependency initialization code</source>
          <target state="translated">종속성 초기화 코드 &lt;strong&gt;정리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="175b3654ce89f52bed835b1e1354adc55d5bff80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stable&lt;/strong&gt; regardless of dependency used</source>
          <target state="translated">사용 된 의존성에 관계없이 &lt;strong&gt;안정적&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b64cc2760536699c09c33fd0c38b16350e500872" translate="yes" xml:space="preserve">
          <source>===</source>
          <target state="translated">===</target>
        </trans-unit>
        <trans-unit id="6b0acc829dd60bf821accdbecbe0f34bcc950c1b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Car&lt;/code&gt; depends on wheels, engine, fuel, battery, etc. to run. Traditionally we define the brand of such dependent objects along with the definition of the &lt;code&gt;Car&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Car&lt;/code&gt; 는 바퀴, 엔진, 연료, 배터리 등에 달려 있습니다. 전통적으로 우리는 &lt;code&gt;Car&lt;/code&gt; 객체의 정의와 함께 이러한 종속 객체의 브랜드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="76a8eb0e78cd5206cc6a627c1d56ea296a18f598" translate="yes" xml:space="preserve">
          <source>A dependency is an object that can be used (&lt;code&gt;Service&lt;/code&gt;)</source>
          <target state="translated">종속성은 사용할 수있는 객체입니다 ( &lt;code&gt;Service&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d726743d668b3ba1c937402de85725ec11622168" translate="yes" xml:space="preserve">
          <source>A nice comment by Jose Maria Arranz on DI</source>
          <target state="translated">DI에 관한 Jose Maria Arranz의 멋진 코멘트</target>
        </trans-unit>
        <trans-unit id="55bbd203453572a1a2a8545b2a4e406f89f8d6bc" translate="yes" xml:space="preserve">
          <source>About replaceable: with a very simple .properties archive and Class.forName you can define wich classes can change. If ANY class of your code can be changed, Java is not for you, use an scripting language.  By the way: annotations cannot be changed without recompiling.</source>
          <target state="translated">교체 가능 정보 : 매우 간단한 .properties 아카이브와 Class.forName을 사용하면 클래스가 변경 될 수있는 것을 정의 할 수 있습니다. 코드의 모든 클래스를 변경할 수 있으면 Java가 아닙니다. 스크립팅 언어를 사용하십시오. 그건 그렇고 : 다시 컴파일하지 않고 주석을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e431d362be915c2e12e2e8aec306dfb48350104c" translate="yes" xml:space="preserve">
          <source>Actually,Suppose in java you created two different classes as class A and class B, and whatever the function are available in class B you want to use in class A, So at that time dependency injection can be used.
where you can crate object of one class in other,in the same way you can inject an entire class in another class to make it accessible.
by this way dependency can be overcome.</source>
          <target state="translated">실제로 java에서 클래스 A와 클래스 B로 두 개의 서로 다른 클래스를 만들고 클래스 A에서 사용할 수있는 함수가 무엇이든 클래스 A에서 사용하려는 경우 종속성 주입을 사용할 수 있습니다. 한 클래스의 객체를 다른 클래스에 넣을 수 있습니다. 같은 방식으로 다른 클래스에 전체 클래스를 주입하여 액세스 할 수 있습니다. 이러한 방식으로 의존성을 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e7a0d53d6a3064057c2db69d7bd1bb143ac3e8" translate="yes" xml:space="preserve">
          <source>All the three classes can be hidden for it's own implementation. Now we can use this code for DI:</source>
          <target state="translated">세 가지 클래스 모두 자체 구현을 위해 숨길 수 있습니다. 이제 DI에이 코드를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9f4e112e7a703ff0642590623727505b80c743dd" translate="yes" xml:space="preserve">
          <source>Allowing expensive resources or services to be created as late as possible and only when needed.</source>
          <target state="translated">고가의 리소스 나 서비스를 가능한 한 늦게 만들고 필요할 때만 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73b678b4942a0f37f86394e629e8cffab4b632e" translate="yes" xml:space="preserve">
          <source>Also when we have many dependencies it is very good practice to use Inversion of Control(IoC) containers which we can tell which interfaces should be mapped to which concrete implementations for all our dependencies and we can have it resolve those dependencies for us when it constructs our object. For example, we could specify in the mapping for the IoC container that the &lt;strong&gt;IEngine&lt;/strong&gt; dependency should be mapped to the &lt;strong&gt;GasEngine&lt;/strong&gt; class and when we ask the IoC container for an instance of our &lt;strong&gt;Car&lt;/strong&gt; class, it will automatically construct our &lt;strong&gt;Car&lt;/strong&gt; class with a &lt;strong&gt;GasEngine&lt;/strong&gt; dependency passed in.</source>
          <target state="translated">또한 많은 의존성이있는 경우 컨트롤의 IoC (Inversion of Control) 컨테이너를 사용하는 것이 좋습니다.이 인터페이스를 사용하면 모든 인터페이스에 대해 어떤 구체적인 구현에 어떤 인터페이스를 매핑해야하는지 알 수 있으며 구성 할 때 해당 종속성을 해결할 수 있습니다 우리의 목표. 예를 들어, IoC 컨테이너의 매핑에서 &lt;strong&gt;IEngine&lt;/strong&gt; 종속성이 &lt;strong&gt;GasEngine&lt;/strong&gt; 클래스에 매핑되어야한다고 지정할 수 있으며 IoC 컨테이너에 &lt;strong&gt;Car&lt;/strong&gt; 클래스의 인스턴스를 요청하면 &lt;strong&gt;GasEngine&lt;/strong&gt; 종속성으로 &lt;strong&gt;Car&lt;/strong&gt; 클래스가 자동으로 생성됩니다. 통과했다.</target>
        </trans-unit>
        <trans-unit id="992414fdd7e72886a072118a7f3b02c1d3b532c2" translate="yes" xml:space="preserve">
          <source>Although seemingly innocuous, it has two &lt;code&gt;static&lt;/code&gt; dependencies on two other classes, &lt;code&gt;System.DateTime&lt;/code&gt; and &lt;code&gt;System.Console&lt;/code&gt;, which not only limit the logging output options (logging to console will be worthless if no one is watching), but worse, it is difficult to automatically test given the dependency on a non-deterministic system clock.</source>
          <target state="translated">무해한 것처럼 보이지만 &lt;code&gt;System.DateTime&lt;/code&gt; 및 &lt;code&gt;System.Console&lt;/code&gt; 이라는 두 개의 다른 클래스에는 두 가지 &lt;code&gt;static&lt;/code&gt; 종속성이 있습니다. 이는 로깅 출력 옵션을 제한 할뿐만 아니라 아무도보고 있지 않으면 콘솔에 로깅하는 것이 가치가 없습니다. 비 결정적 시스템 클럭에 대한 종속성을 자동으로 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="608e86855b2a65e39ae912fd39a0fa1102aef2e4" translate="yes" xml:space="preserve">
          <source>An automated Unit Test can be built, which definitively proves that our logger is working correctly, as we now have control over the dependencies - the time, and we can spy on the written output:</source>
          <target state="translated">자동화 된 단위 테스트 (Unit Test)를 구축 할 수 있는데, 이제 의존성-시간을 제어 할 수 있고 기록 된 결과를 감시 할 수 있기 때문에 로거가 올바르게 작동하고 있음을 확실하게 증명할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70687f8f4f2b763df000dbed64d4fb27b23ff917" translate="yes" xml:space="preserve">
          <source>An injection is the passing of a dependency (&lt;code&gt;Service&lt;/code&gt;) to a dependent object (&lt;code&gt;Client&lt;/code&gt;) that would use it</source>
          <target state="translated">주입은 의존성 ( &lt;code&gt;Service&lt;/code&gt; )을 그것을 사용하는 의존성 객체 ( &lt;code&gt;Client&lt;/code&gt; )로 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="22de376201dcf4ad21e64690cf593a42ea12c2ce" translate="yes" xml:space="preserve">
          <source>And to instantiate the Car class we will use next code:</source>
          <target state="translated">Car 클래스를 인스턴스화하기 위해 다음 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d989001b3ba666eebb2d9b73b1ed4f8b0f5b41d" translate="yes" xml:space="preserve">
          <source>Any application is composed of many objects that collaborate with each other to perform some useful stuff. Traditionally each object is responsible for obtaining its own references to the dependent objects (dependencies) it collaborate with. This leads to highly coupled classes and hard-to-test code.</source>
          <target state="translated">모든 응용 프로그램은 서로 협력하여 유용한 작업을 수행하는 많은 개체로 구성됩니다. 전통적으로 각 오브젝트는 협업하는 종속 오브젝트 (종속성)에 대한 자체 참조를 가져옵니다. 이것은 고도로 결합 된 클래스와 테스트하기 어려운 코드로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="dcd3c9a7013d9400c6621023f7f9889b2d159708" translate="yes" xml:space="preserve">
          <source>Any time where you will need to unit test the methods of a class in isolation of its dependencies,</source>
          <target state="translated">의존성을 분리하여 클래스의 메소드를 단위 테스트해야 할 때마다,</target>
        </trans-unit>
        <trans-unit id="8a5fc50e3ceaa03d10efa641f9932ed3164ec099" translate="yes" xml:space="preserve">
          <source>Application calls Foo</source>
          <target state="translated">응용 프로그램 호출 Foo</target>
        </trans-unit>
        <trans-unit id="ac42390e19be354858b8262243637ee16d63efc2" translate="yes" xml:space="preserve">
          <source>Application creates Bar and gives it Bim</source>
          <target state="translated">응용 프로그램은 막대를 만들어 Bim을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc24fa2cfa1ade20a4b0568072650d805b3f7a37" translate="yes" xml:space="preserve">
          <source>Application creates Bim</source>
          <target state="translated">응용 프로그램이 Bim을 만듭니다</target>
        </trans-unit>
        <trans-unit id="70579284eb400d7297fa45f23e86008434a5dae7" translate="yes" xml:space="preserve">
          <source>Application creates Foo</source>
          <target state="translated">응용 프로그램이 Foo를 만듭니다</target>
        </trans-unit>
        <trans-unit id="c0f19361a5c397f8b9f7a8e3a097732fbca45296" translate="yes" xml:space="preserve">
          <source>Application creates Foo and gives it Bar</source>
          <target state="translated">응용 프로그램이 Foo를 작성하고이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7f33a152d579b4e1ccdf69ca92b2a96ddcd2dca4" translate="yes" xml:space="preserve">
          <source>Application gets Foo from the Container, so:</source>
          <target state="translated">응용 프로그램은 컨테이너에서 Foo를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a435d46695a15e5ef97ebb4802372a00c982aa2" translate="yes" xml:space="preserve">
          <source>Application needs Foo (e.g. a controller), so:</source>
          <target state="translated">응용 프로그램에는 Foo (예 : 컨트롤러)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="63f0eb90a103bbcdae0831a58efe78a5893f2f45" translate="yes" xml:space="preserve">
          <source>Application needs Foo so:</source>
          <target state="translated">응용 프로그램은 Foo가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9be6e530a74dcafa45c7b24d7025184525c1bc10" translate="yes" xml:space="preserve">
          <source>Application needs Foo, which needs Bar, which needs Bim, so:</source>
          <target state="translated">응용 프로그램에는 Boo가 필요한 Foo가 필요하고 Bim이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="41f971b49b630ecc0dbd5fbc5a28c4f03ee52f5d" translate="yes" xml:space="preserve">
          <source>As others have said, &lt;em&gt;Dependency Injection(DI)&lt;/em&gt; removes the responsibility of direct creation, and management of the lifespan, of other object instances upon which our class of interest (consumer class) is dependent (in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency&quot;&gt;UML sense&lt;/a&gt;). These instances are instead passed to our consumer class, typically as constructor parameters or via property setters (the management of the dependency object instancing and passing to the consumer class is usually performed by an &lt;em&gt;Inversion of Control (IoC)&lt;/em&gt; container, but that's another topic).</source>
          <target state="translated">다른 사람들이 말했듯이, &lt;em&gt;Dependency Injection (DI)&lt;/em&gt; 은 우리의 관심 클래스 (소비자 클래스)가 의존하는 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency&quot;&gt;UML 의미에서&lt;/a&gt; ) 다른 객체 인스턴스의 직접 생성 및 수명 관리에 대한 책임을 제거합니다. 이러한 인스턴스는 일반적으로 생성자 매개 변수 또는 속성 설정자를 통해 소비자 클래스로 전달됩니다 (종속성 개체 인스턴스 관리 및 소비자 클래스로 전달은 일반적으로 &lt;em&gt;IoC (Inversion of Control)&lt;/em&gt; 컨테이너에서 수행되지만 다른 주제입니다) .</target>
        </trans-unit>
        <trans-unit id="08399bcb01b547cab14e44b28e00c30b6c0663f3" translate="yes" xml:space="preserve">
          <source>As per above example, decoupling of dependencies does require some design effort, and for the developer, there is a paradigm shift needed to break the habit of &lt;code&gt;new&lt;/code&gt;ing dependencies directly, and instead trusting the container to manage dependencies.</source>
          <target state="translated">위의 예에 따라 종속성의 디커플링에는 약간의 디자인 노력이 필요하며 개발자에게는 &lt;code&gt;new&lt;/code&gt; 종속성의 습관을 직접 깨뜨리고 대신 컨테이너를 신뢰하여 종속성을 관리하는 패러다임 전환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fff41238dbef5b816e589fb9ecf3cbde7896731e" translate="yes" xml:space="preserve">
          <source>Bar creates Bim</source>
          <target state="translated">바는 Bim을 만듭니다</target>
        </trans-unit>
        <trans-unit id="452099fc339bb9ab1a4137666deb3f1f3b017433" translate="yes" xml:space="preserve">
          <source>Bar does something</source>
          <target state="translated">바 뭔가를</target>
        </trans-unit>
        <trans-unit id="2b2cfde5abc29f811788f8a477a12b0d271a2ada" translate="yes" xml:space="preserve">
          <source>Bar needs Bim (a service, a repository,
&amp;hellip;), so:</source>
          <target state="translated">Bar는 Bim (서비스, 저장소 등)이 필요하므로 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="ae219b96ca6e4a1b3a53e426dca90a803fe2da20" translate="yes" xml:space="preserve">
          <source>But consider the following example&amp;hellip; Suppose you have a class with ten methods that have no dependencies, but you&amp;rsquo;re adding a new method that does have a dependency on IDAO. You could change the constructor to use Constructor Injection, but this may force you to changes to all constructor calls all over the place. Alternatively, you could just add a new constructor that takes the dependency, but then how does a developer easily know when to use one constructor over the other. Finally, if the dependency is very expensive to create, why should it be created and passed to the constructor when it may only be used rarely? &amp;ldquo;Setter Injection&amp;rdquo; is another DI technique that can be used in situations such as this.</source>
          <target state="translated">그러나 다음 예제를 고려해보십시오. 종속성이없는 10 개의 메소드가있는 클래스가 있지만 IDAO에 종속 된 새 메소드를 추가한다고 가정하십시오. 생성자 생성자를 사용하도록 생성자를 변경할 수 있지만 이로 인해 모든 곳에서 모든 생성자 호출을 변경해야 할 수 있습니다. 또는 의존성을 취하는 새로운 생성자를 추가 할 수 있지만 개발자는 한 생성자를 다른 생성자보다 언제 사용 해야하는지 쉽게 알 수 있습니다. 마지막으로, 종속성이 작성하는 데 비용이 많이 드는 경우, 드물게 사용될 수있을 때 작성하여 작성해야하는 이유는 무엇입니까? &quot;세터 주입&quot;은 이와 같은 상황에서 사용할 수있는 또 다른 DI 기술입니다.</target>
        </trans-unit>
        <trans-unit id="1778648e0dd763c5f5a9c7958ded52526966ceb6" translate="yes" xml:space="preserve">
          <source>But it's a generic approach to split concerns of:</source>
          <target state="translated">그러나 다음과 같은 우려를 나누기위한 일반적인 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="19a17a99cb30f6d4a5536c327bad501717385b19" translate="yes" xml:space="preserve">
          <source>But the benefits are many, especially in the ability to thoroughly test your class of interest.</source>
          <target state="translated">그러나 장점은 특히 관심있는 클래스를 철저히 테스트 할 수있는 능력에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f690c20291f1b4d985514efeb98b89687022ac96" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;https://en.wikipedia.org/wiki/Dependency_injection&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;https://en.wikipedia.org/wiki/Dependency_injection을&lt;/a&gt; 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="e531036736b85e446725e4e4e6164a78cdfb8c9c" translate="yes" xml:space="preserve">
          <source>Consider simple &lt;code&gt;dependent.sh&lt;/code&gt; script:</source>
          <target state="translated">간단한 &lt;code&gt;dependent.sh&lt;/code&gt; 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a938a98716a29fea8b403330f964cb8cf46392e9" translate="yes" xml:space="preserve">
          <source>Constructor Injection</source>
          <target state="translated">생성자 주입</target>
        </trans-unit>
        <trans-unit id="b5773fd2800024a3f838fe7729940f9f8e15e065" translate="yes" xml:space="preserve">
          <source>Constructor injection</source>
          <target state="translated">생성자 주입</target>
        </trans-unit>
        <trans-unit id="26032cadfd8928d408ef47b863c4b45733ef2d0d" translate="yes" xml:space="preserve">
          <source>Constructor with dependency injection:</source>
          <target state="translated">의존성 주입을 가진 생성자 :</target>
        </trans-unit>
        <trans-unit id="3f2bf7f408c28388ad6bd617db22886b5fe56b26" translate="yes" xml:space="preserve">
          <source>Constructor without dependency injection:</source>
          <target state="translated">의존성 주입이없는 생성자 :</target>
        </trans-unit>
        <trans-unit id="b2146937a33bfcabf2430053c4204e88638eba30" translate="yes" xml:space="preserve">
          <source>Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on other class.</source>
          <target state="translated">생성자 기반 DI는 컨테이너가 다른 클래스에 대한 종속성을 나타내는 여러 개의 인수로 클래스 생성자를 호출 할 때 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="faa2e023d8bf9a1b5e13e711551447a2e6bc4da2" translate="yes" xml:space="preserve">
          <source>Container creates Bar and gives it Bim</source>
          <target state="translated">컨테이너가 Bar를 생성하고 Bim에게 제공</target>
        </trans-unit>
        <trans-unit id="e72228b222f6d8727f4e55af720a28149a261110" translate="yes" xml:space="preserve">
          <source>Container creates Bim</source>
          <target state="translated">컨테이너가 Bim을 생성</target>
        </trans-unit>
        <trans-unit id="6653855bc3a85ec8d066669874a2916aaf0d2c9e" translate="yes" xml:space="preserve">
          <source>Container creates Foo and gives it Bar</source>
          <target state="translated">컨테이너가 Foo를 생성하고 Bar를 제공합니다</target>
        </trans-unit>
        <trans-unit id="8ac27f6a08ba25f489c38925c6e85a272db84091" translate="yes" xml:space="preserve">
          <source>DEPENDENCY INJECTION IS SIMPLY GLUING TWO CLASSES AND AT THE SAME TIME KEEPING THEM SEPARATE.</source>
          <target state="translated">종속성 주입은 두 클래스를 간단하게 붙이고 동시에 별도의 시간을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="08ebf9ead9196a1af9ffc22cd9c1eeb51be76894" translate="yes" xml:space="preserve">
          <source>DI brings you closer to the Single Responsibility (SR) principle, like the &lt;code&gt;surgeon who can concentrate on surgery&lt;/code&gt;.</source>
          <target state="translated">DI는 &lt;code&gt;surgeon who can concentrate on surgery&lt;/code&gt; 있는 외과 의사 와 같은 SR (Single Responsibility) 원칙에 더 가까이 다가갑니다.</target>
        </trans-unit>
        <trans-unit id="a43f9d298673ad95516fee4e62a2a823a586584a" translate="yes" xml:space="preserve">
          <source>DI for short, is a technique to remove a common additional responsibility (burden) on components to fetch the dependent components, by providing them to it.</source>
          <target state="translated">간단히 말해 DI는 종속 구성 요소를 제공하여 구성 요소에 대한 일반적인 추가 책임 (부담)을 제거하는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="4f5d36ed84699163eaf23e5a7fdfc103b0bbc15e" translate="yes" xml:space="preserve">
          <source>DI is a particular form of IoC, whereby the process of finding your dependencies is
  outside the direct control of your currently executing code.</source>
          <target state="translated">DI는 특정 형태의 IoC이며, 따라서 종속성을 찾는 프로세스는 현재 실행중인 코드를 직접 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="feb00fd97973bff59f7d3245f637dd67debab5a4" translate="yes" xml:space="preserve">
          <source>DI is analogous to this in the world of Object Oriented programming.  The values there instead of constant literals are whole objects - but the reason to move the code creating them out from the class code is similar - the objects change more frequently then the code that uses them.  One important case where such a change is needed is tests.</source>
          <target state="translated">DI는 객체 지향 프로그래밍 세계에서 이와 유사합니다. 상수 리터럴 대신 값이 전체 객체이지만 클래스 코드에서 코드를 생성하는 이유는 비슷합니다. 객체가이를 사용하는 코드보다 자주 변경됩니다. 이러한 변경이 필요한 중요한 경우는 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="2e8b1223bba2170ce6128ed0e576d38e0241b406" translate="yes" xml:space="preserve">
          <source>DI is not as largely emphasized and popularized as in Java frameworks.</source>
          <target state="translated">DI는 Java 프레임 워크 에서처럼 크게 강조되고 대중화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e75ded6d3588df205b0011e584a93bde9df27a8f" translate="yes" xml:space="preserve">
          <source>DI is the implementation of IOC principal of Spring which says &quot;Don't call us we will call you&quot;. Using dependency injection programmer doesn't need to create object using the new keyword.</source>
          <target state="translated">DI는 Spring의 IOC 교장의 구현으로 &quot;우리에게 전화하지 마십시오&quot;라고 말합니다. 의존성 주입 프로그래머를 사용하면 새로운 키워드를 사용하여 객체를 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="88de733e17606a4266cbf096951b24a70dd9b893" translate="yes" xml:space="preserve">
          <source>DI means there is an intermediate level between the caller and the constructor which manages dependencies. A Makefile is a simple example of dependency injection. The &quot;caller&quot; is the person typing &quot;make bar&quot; on the command line, and the &quot;constructor&quot; is the compiler. The Makefile specifies that bar depends on foo, and it does a</source>
          <target state="translated">DI는 호출자와 생성자를 사이에 의존성을 관리하는 중간 레벨이 있음을 의미합니다. Makefile은 의존성 주입의 간단한 예입니다. &quot;caller&quot;는 명령 행에 &quot;make bar&quot;를 입력하는 사람이고 &quot;constructor&quot;는 컴파일러입니다. Makefile은 bar가 foo에 의존하도록 지정하고</target>
        </trans-unit>
        <trans-unit id="007835874d333d08ff81faee651cdd6f320b4cd1" translate="yes" xml:space="preserve">
          <source>Decoupling dependencies between classes in this way allows for &lt;em&gt;easy substitution&lt;/em&gt; of these dependency classes with other implementations which also fulfil the prerequisites of the abstraction (e.g. the dependency can be switched with another implementation of the same interface). Moreover, as others have mentioned, possibly &lt;em&gt;the&lt;/em&gt; most common reason to decouple classes via the DIP is to allow a consuming class to be tested in isolation, as these same dependencies can now be stubbed and/or mocked.</source>
          <target state="translated">이러한 방식으로 클래스 간 종속성을 분리하면 이러한 종속성 클래스를 추상화의 전제 조건을 충족시키는 다른 구현으로 &lt;em&gt;쉽게 대체&lt;/em&gt; 할 수 있습니다 (예 : 종속성은 동일한 인터페이스의 다른 구현으로 전환 될 수 있음). 또한 다른 사람들이 언급했듯이 DIP를 통해 클래스를 분리 &lt;em&gt;하는&lt;/em&gt; 가장 일반적인 이유는 소비되는 클래스를 독립적으로 테스트 할 수 있기 때문입니다. 이러한 동일한 종속성을 이제 스텁 및 / 또는 조롱 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8373baaef22105a8574ebe7cace135c9de92ef3f" translate="yes" xml:space="preserve">
          <source>Dependencies can be injected into objects by many means (such as constructor injection or setter injection). One can even use specialized dependency injection frameworks (e.g. Spring) to do that, but they certainly aren't required. You don't need those frameworks to have dependency injection. Instantiating and passing objects (dependencies) explicitly is just as good an injection as injection by framework.</source>
          <target state="translated">종속성은 많은 방법 (생성자 주입 또는 세터 주입과 같은)을 통해 오브젝트에 주입 될 수 있습니다. 특별한 의존성 주입 프레임 워크 (예 : Spring)를 사용하여 그렇게 할 수도 있지만 반드시 필요한 것은 아닙니다. 의존성 주입을 위해 이러한 프레임 워크가 필요하지 않습니다. 객체 (종속성)를 명시 적으로 인스턴스화하고 전달하는 것은 프레임 워크에 의한 주입만큼이나 좋은 주입입니다.</target>
        </trans-unit>
        <trans-unit id="805edc480d58383c8e5e2cdbb15c0f0b990469a8" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is one from Design Patterns, which uses the basic feature of OOP - the relationship in one object with another object. While inheritance inherits one object to do more complex and specific another object, relationship or association simply creates a pointer to another object from one object using attribute. The power of DI is in combination with other features of OOP as are interfaces and hiding code.
Suppose, we have a customer (subscriber) in the library, which can borrow only one book for simplicity.</source>
          <target state="translated">DI (종속성 주입)는 OOP의 기본 기능인 하나의 개체와 다른 개체의 관계를 사용하는 디자인 패턴의 것입니다. 상속은 하나의 객체를 상속하여 더 복잡하고 구체적인 다른 객체를 수행하지만 관계 또는 연관은 단순히 속성을 사용하여 한 객체에서 다른 객체에 대한 포인터를 만듭니다. DI의 강력한 기능은 인터페이스 및 숨김 코드와 마찬가지로 OOP의 다른 기능과 결합됩니다. 라이브러리에 고객 (구독자)이 있다고 가정하면 단순성을 위해 단 하나의 책만 빌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eaf5885c756aab73a83e3523b8617e6e5448a02" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is part of Dependency Inversion Principle (DIP) practice, which is also called Inversion of Control (IoC). Basically you need to do DIP because you want to make your code more modular and unit testable, instead of just one monolithic system. So you start identifying parts of the code that can be separated from the class and abstracted away. Now the implementation of the abstraction need to be injected from outside of the class. Normally this can be done via constructor. So you create a constructor that accepts the abstraction as a parameter, and this is called dependency injection (via constructor). For more explanation about DIP, DI, and IoC container you can read &lt;a href=&quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">의존성 주입 (DI)은 의존성 역전 원리 (DIP) 관행의 일부이며, IoC (Inversion of Control)라고도합니다. 기본적으로 하나의 모 놀리 식 시스템 대신 코드를 모듈 식 및 단위로 테스트 할 수 있도록하려면 DIP를 수행해야합니다. 따라서 클래스에서 분리하여 추상화 할 수있는 코드 부분을 식별하기 시작합니다. 이제 추상화의 구현은 클래스 외부에서 주입되어야합니다. 일반적으로 이것은 생성자를 통해 수행 할 수 있습니다. 따라서 추상화를 매개 변수로 받아들이는 생성자를 만들고이를 생성자를 통해 종속성 주입이라고합니다. DIP, DI 및 IoC 컨테이너에 대한 자세한 내용은 &lt;a href=&quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html&quot;&gt;여기를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec9e1e9a757b12d7ba7015b1965d7e8d66b82118" translate="yes" xml:space="preserve">
          <source>Dependency Injection definition</source>
          <target state="translated">의존성 주입 정의</target>
        </trans-unit>
        <trans-unit id="cb2cb0f05e812293b7ad0ba1d7be1914b8ecef4e" translate="yes" xml:space="preserve">
          <source>Dependency Injection is a method for writing better code</source>
          <target state="translated">의존성 주입은 더 나은 코드를 작성하는 방법입니다</target>
        </trans-unit>
        <trans-unit id="cddf49311cde392103b798084c33da2a7ca7c60e" translate="yes" xml:space="preserve">
          <source>Dependency Injection is a practice where objects are designed in a manner where they receive instances of the objects from other pieces of code, instead of constructing them internally. This means that any object implementing the interface which is required by the object can be substituted in without changing the code, which simplifies testing, and improves decoupling.</source>
          <target state="translated">의존성 주입은 객체를 내부적으로 구성하는 대신 다른 코드 조각으로부터 객체의 인스턴스를 수신하는 방식으로 객체를 설계하는 방법입니다. 즉, 코드를 변경하지 않고도 객체에 필요한 인터페이스를 구현하는 모든 객체를 대체 할 수있어 테스트가 간소화되고 디커플링이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="afcfc311b0f222c1476db1b255d403234af0b4db" translate="yes" xml:space="preserve">
          <source>Dependency Injection is the process of creating the static, stateless
  graph of service objects, where each service is parametrised by its
  dependencies.</source>
          <target state="translated">의존성 주입은 서비스 객체의 정적, 무 상태 그래프를 생성하는 프로세스로, 각 서비스는 의존성에 의해 매개 변수화됩니다.</target>
        </trans-unit>
        <trans-unit id="64a15438c3caa440c0a5dc9eb291180789196b8d" translate="yes" xml:space="preserve">
          <source>Dependency Injection(DI) means to decouple the objects which are dependent on each other. Say object A is dependent on Object B so the idea is to decouple these object from each other. We don&amp;rsquo;t need to hard code the object using new keyword rather sharing dependencies to objects at runtime in spite of compile time.
If we talk about</source>
          <target state="translated">의존성 주입 (DI)은 서로 의존하는 객체를 분리하는 것을 의미합니다. 객체 A가 객체 B에 종속되어 있다고 생각하면 이러한 객체를 서로 분리하는 것이 좋습니다. 컴파일 시간에도 불구하고 런타임에 객체에 종속성을 공유하는 대신 새로운 키워드를 사용하여 객체를 하드 코딩 할 필요가 없습니다. 우리가 이야기하면</target>
        </trans-unit>
        <trans-unit id="5ca81c175fbe0a8a94fd156ed8fda57771b7acaa" translate="yes" xml:space="preserve">
          <source>Dependency injection is a pattern to allow your application to inject
  objects on the fly to classes that need them, without forcing those
  classes to be responsible for those objects. It allows your code to be
  more loosely coupled, and Entity Framework Core plugs in to this same
  system of services.</source>
          <target state="translated">종속성 주입은 응용 프로그램이 필요한 클래스에 객체를 즉시 주입 할 수 있도록하는 패턴으로, 해당 클래스가 해당 객체에 대한 책임을 가지지 않도록합니다. 코드를 느슨하게 결합 할 수 있으며 Entity Framework Core는이 동일한 서비스 시스템에 플러그인됩니다.</target>
        </trans-unit>
        <trans-unit id="f51897ce4672efc871df38ef9ec8a1e2a4f4a7a3" translate="yes" xml:space="preserve">
          <source>Dependency injection is a pattern used to create instances of objects that other objects rely upon without knowing at compile time which class will be used to provide that functionality or simply the way of injecting properties to an object is called dependency injection.</source>
          <target state="translated">의존성 주입은 컴파일 타임에 어떤 클래스가 해당 기능을 제공하는 데 사용되는지 또는 단순히 객체에 속성을 주입하는 방법을 알지 않고도 다른 객체가 의존하는 객체의 인스턴스를 만드는 데 사용되는 패턴을 의존성 주입이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c8bcf420f928a840f91a5b1e5c82929829ba86a5" translate="yes" xml:space="preserve">
          <source>Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It's a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.</source>
          <target state="translated">의존성 주입은 기본적으로 객체 자체를 구성하는 대신 객체가 필요로하는 객체 (종속성)를 제공합니다. 의존성을 조롱하거나 스텁 아웃 할 수 있기 때문에 테스트에 매우 유용한 기술입니다.</target>
        </trans-unit>
        <trans-unit id="eb5f2c3f9e29f385abcc1436959a966409e80529" translate="yes" xml:space="preserve">
          <source>Dependency injection is invariably associated with an &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Inversion of Control container(IoC)&lt;/a&gt;, to inject (provide) the concrete dependency instances, and to manage lifespan instances. During the configuration / bootstrapping process, &lt;code&gt;IoC&lt;/code&gt; containers allow the following to be defined:</source>
          <target state="translated">의존성 주입은 &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;제어 컨테이너 (IoC)&lt;/a&gt; 의 반전 과 항상 연관되어 있으며, 구체적인 의존성 인스턴스를 주입 (제공)하고 수명 인스턴스를 관리합니다. 구성 / 부트 스트랩 프로세스 중에 &lt;code&gt;IoC&lt;/code&gt; 컨테이너를 사용하면 다음을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca79292d85a27dbcae58c833ab50a3d5b3915751" translate="yes" xml:space="preserve">
          <source>Dependency injection is one of the design pattern that help us to create complex systems in a simpler manner.</source>
          <target state="translated">의존성 주입은 복잡한 시스템을보다 간단한 방식으로 만드는 데 도움이되는 디자인 패턴 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="69c4857065501ad52a336a3696b71d18e67bed61" translate="yes" xml:space="preserve">
          <source>Dependency injection is one possible solution to what could generally be termed the &quot;Dependency Obfuscation&quot; requirement. Dependency Obfuscation is a method of taking the 'obvious' nature out of the process of providing a dependency to a class that requires it and therefore obfuscating, in some way, the provision of said dependency to said class. This is not necessarily a bad thing. In fact, by obfuscating the manner by which a dependency is provided to a class then something outside the class is responsible for creating the dependency which means, in various scenarios, a different implementation of the dependency can be supplied to the class without making any changes to the class. This is great for switching between production and testing modes (eg., using a 'mock' service dependency).</source>
          <target state="translated">의존성 주입은 일반적으로 &quot;의존성 난독 화 (Dependency Obfuscation)&quot;요구 사항에 대한 해결책 중 하나입니다. 의존성 난독 화는 그것을 필요로하는 클래스에 대한 의존성을 제공하는 과정에서 '명백한'성질을 취하여 어떤 식 으로든 상기 클래스에 대한 상기 의존성의 제공을 난독 화하는 방법이다. 이것은 반드시 나쁜 것은 아닙니다. 실제로, 클래스에 의존성이 제공되는 방식을 난독 화함으로써 클래스 외부의 무언가가 의존성을 생성하는 책임이 있으며, 이는 다양한 시나리오에서 변경없이 다른 의존성 구현이 클래스에 제공 될 수 있음을 의미합니다. 수업에. 이는 프로덕션 모드와 테스트 모드 간 전환에 유용합니다 (예 : '모의'서비스 종속성 사용).</target>
        </trans-unit>
        <trans-unit id="0170849003cd6320060ea1c729c9aa49b34c7fd9" translate="yes" xml:space="preserve">
          <source>Dependency injection is the heart of the concept related with Spring Framework.While creating the framework of any project spring may perform a vital role,and here dependency injection come in pitcher.</source>
          <target state="translated">의존성 주입은 Spring Framework와 관련된 개념의 핵심입니다. 프로젝트의 프레임 워크를 만드는 것이 중요한 역할을 할 수 있지만 여기서 의존성 주입은 투수에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e58f7f11fd58e3edec005e7035583eb40983e40f" translate="yes" xml:space="preserve">
          <source>Dependency injection makes testing easier. The injection can be done through &lt;strong&gt;constructor&lt;/strong&gt;.</source>
          <target state="translated">의존성 주입은 테스트를 더 쉽게 만듭니다. 주입은 &lt;strong&gt;constructor을&lt;/strong&gt; 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3ff309b1b6291468565c4f9a9f51b36a3e04dd3" translate="yes" xml:space="preserve">
          <source>Dependency:</source>
          <target state="translated">Dependency:</target>
        </trans-unit>
        <trans-unit id="7ffc6ee12bdc72c1564366d1210f30e558da7c21" translate="yes" xml:space="preserve">
          <source>Difference between Inversion of Control &amp;amp; Dependency Injection</source>
          <target state="translated">제어 역전 및 의존성 주입의 차이점</target>
        </trans-unit>
        <trans-unit id="be57f0e0c6c38a3c5499991aa97bdbb4642cde74" translate="yes" xml:space="preserve">
          <source>Doesn't &quot;dependency injection&quot; just mean using parameterized constructors and public setters?</source>
          <target state="translated">&quot;종속성 주입&quot;이 매개 변수화 된 생성자와 공용 세터를 사용한다는 의미는 아닙니까?</target>
        </trans-unit>
        <trans-unit id="dce70f9dbaf63e1888206b128af00b53f6dd310d" translate="yes" xml:space="preserve">
          <source>Everytime I want to change what objects my AClass needs, I need to now look into two places - The class itself and the configuration file. How does that make life easier?</source>
          <target state="translated">AClass에 필요한 객체를 변경할 때마다 클래스 자체와 구성 파일의 두 위치를 살펴 봐야합니다. 그렇게하면 인생이 쉬워 집니까?</target>
        </trans-unit>
        <trans-unit id="624d5b857fe09b27ef0b52a651428cfe9bdeb229" translate="yes" xml:space="preserve">
          <source>Example, we have 2 class &lt;code&gt;Client&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt;. &lt;code&gt;Client&lt;/code&gt; will use &lt;code&gt;Service&lt;/code&gt;</source>
          <target state="translated">예를 들어, 2 클래스 &lt;code&gt;Client&lt;/code&gt; 및 &lt;code&gt;Service&lt;/code&gt; 있습니다. &lt;code&gt;Client&lt;/code&gt; 은 &lt;code&gt;Service&lt;/code&gt; 를 사용 합니다</target>
        </trans-unit>
        <trans-unit id="4cc967eb9e93b5533d3da79d75ffcafa1c607fa2" translate="yes" xml:space="preserve">
          <source>Example: DI with shell script</source>
          <target state="translated">예 : 쉘 스크립트가있는 DI</target>
        </trans-unit>
        <trans-unit id="2f74df37b1ea988409f33c42af68c3062f522296" translate="yes" xml:space="preserve">
          <source>Example: removing DI</source>
          <target state="translated">예 : DI 제거</target>
        </trans-unit>
        <trans-unit id="4d32216898588a9d6769484729321b2a32005852" translate="yes" xml:space="preserve">
          <source>Externalizing dependency and looking only on responsibility.</source>
          <target state="translated">의존성을 외부화하고 책임 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="f94c5803a635417a4c63406b77fcbb7801e90db0" translate="yes" xml:space="preserve">
          <source>False. The direction of dependencies is in XML form or as annotations, your dependencies are written as XML code and annotations. XML and annotations ARE source code.</source>
          <target state="translated">그릇된. 종속성의 방향은 XML 형식 또는 주석으로되어 있으며, 종속성은 XML 코드 및 주석으로 작성됩니다. XML과 주석은 소스 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c66a3755f7748dad912a8f295d8660519cb19da7" translate="yes" xml:space="preserve">
          <source>False. You do not need a DI framework to build a modular code based on interfaces.</source>
          <target state="translated">그릇된. 인터페이스를 기반으로 모듈 식 코드를 빌드하기 위해 DI 프레임 워크가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9044ac31a8995f5ad62b7e9f444f33bf9e08657" translate="yes" xml:space="preserve">
          <source>Foo calls Bar</source>
          <target state="translated">푸 콜 바</target>
        </trans-unit>
        <trans-unit id="36a8c8318b6369919a71996fd940aacf3965166d" translate="yes" xml:space="preserve">
          <source>Foo creates Bar</source>
          <target state="translated">푸는 바를 만듭니다</target>
        </trans-unit>
        <trans-unit id="c2cfcdd995da76d7e30b4bb8c5a58a247fe77380" translate="yes" xml:space="preserve">
          <source>Foo needs Bar (e.g. a service), so:</source>
          <target state="translated">Foo에는 Bar (예 : 서비스)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b181ce4ed346bf93fb78e315f5b4e0fdc64a362e" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Car&lt;/code&gt; object.</source>
          <target state="translated">예를 들어 &lt;code&gt;Car&lt;/code&gt; 객체를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="773f448aa74e9ddd91521dd1c2732d809239a14b" translate="yes" xml:space="preserve">
          <source>For example, consider these clases:</source>
          <target state="translated">예를 들어 다음과 같은 걸쇠를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6301c293c982fc83aecdf06eaf96df22050f4fa1" translate="yes" xml:space="preserve">
          <source>From Christoffer Noring, Pablo Deeleman's book &amp;ldquo;Learning Angular - Second Edition&amp;rdquo;:</source>
          <target state="translated">Christoffer Noring의 Pablo Deeleman의 저서&amp;ldquo;Learning Angular-Second Edition&amp;rdquo;:</target>
        </trans-unit>
        <trans-unit id="d2f6f2619a4fc19e9326d217edd2b9cb13d7536f" translate="yes" xml:space="preserve">
          <source>From the Book, '&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1617290068&quot;&gt;Well-Grounded Java Developer: Vital techniques of Java 7 and polyglot programming&lt;/a&gt;</source>
          <target state="translated">책에서 ' &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1617290068&quot;&gt;잘 다듬어 진 Java 개발자 : Java 7 및 폴리 글 로트 프로그래밍의 핵심 기술&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="565b14720ba865ef973ba05f90a124c36bd9081e" translate="yes" xml:space="preserve">
          <source>From: Anton Moiseev. book &amp;ldquo;Angular Development with Typescript, Second Edition.&amp;rdquo;:</source>
          <target state="translated">보낸 사람 : Anton Moiseev. &amp;ldquo;Typescript를 사용한 각도 개발, 제 2 판&amp;rdquo;책 :</target>
        </trans-unit>
        <trans-unit id="7cc777757b505d7bbd1af628607007866c70d979" translate="yes" xml:space="preserve">
          <source>Going back to the first question. If using new object() is bad, how come we inject the implementation and not the interface? I think a lot of you are saying we're in fact injecting the interface but the configuration makes you specify the implementation of that interface ..not at runtime .. it is hardcoded during compile time.</source>
          <target state="translated">첫 번째 질문으로 돌아갑니다. new object () 사용이 나쁘다면 인터페이스가 아닌 구현을 어떻게 주입합니까? 많은 사람들이 실제로 인터페이스를 주입한다고 말하고 있지만 구성을 사용하면 런타임에 해당 인터페이스의 구현을 지정할 수 없습니다. 컴파일 시간 동안 하드 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="28843d4be0ee34f253cca7cab2361c2a39ee4828" translate="yes" xml:space="preserve">
          <source>Hard for test &lt;code&gt;Client&lt;/code&gt; class</source>
          <target state="translated">테스트 &lt;code&gt;Client&lt;/code&gt; 클래스에 적합</target>
        </trans-unit>
        <trans-unit id="4aed8ebadb57ba9dd2776c20874fb02210f043c0" translate="yes" xml:space="preserve">
          <source>Here is the example of how the above code would look like:</source>
          <target state="translated">위 코드가 어떻게 보이는지에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43c80abc12795e6e4cb2a72b1e6d9012d550d4e0" translate="yes" xml:space="preserve">
          <source>Here we basically inject(pass) our dependency(Engine instance) to Car constructor. So now our classes have loose coupling between objects and their dependencies, and we can easily add new types of engines without changing the Car class.</source>
          <target state="translated">여기서 기본적으로 의존성 (Engine instance)을 Car 생성자에 주입 (전달)합니다. 이제 우리 클래스는 객체와 그 종속성 사이의 느슨한 결합을 가지고 있으며 Car 클래스를 변경하지 않고도 새로운 유형의 엔진을 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="371a2ec52294658d0a3b4228a46b7d8f33efffe9" translate="yes" xml:space="preserve">
          <source>Here's a simple C# implementation. Given the below Consuming class:</source>
          <target state="translated">다음은 간단한 C # 구현입니다. 아래 소비 클래스가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="922004128193bca294dd5fdb14c71cac1cae1545" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;Car&lt;/code&gt; object &lt;em&gt;is responsible for creating the dependent objects.&lt;/em&gt;</source>
          <target state="translated">여기서 &lt;code&gt;Car&lt;/code&gt; 객체 &lt;em&gt;는 종속 객체를 생성합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0969f6c9b11047ca63ee874c7cf8c550f36eaef" translate="yes" xml:space="preserve">
          <source>Here, we are &lt;strong&gt;injecting&lt;/strong&gt; the &lt;strong&gt;dependencies&lt;/strong&gt; (Wheel and Battery) at runtime. Hence the term : &lt;em&gt;Dependency Injection.&lt;/em&gt;</source>
          <target state="translated">여기서는 런타임에 &lt;strong&gt;종속성&lt;/strong&gt; (휠 및 배터리)을 &lt;strong&gt;주입&lt;/strong&gt; 하고 있습니다. 따라서 용어 : &lt;em&gt;의존성 주입.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="379dffc1a3970a2596b05e27d433878025eb9945" translate="yes" xml:space="preserve">
          <source>High cohesion and loose coupling.</source>
          <target state="translated">높은 응집력과 느슨한 결합.</target>
        </trans-unit>
        <trans-unit id="00bf8b24a1d88295bc7cfc6557e03947a6402c26" translate="yes" xml:space="preserve">
          <source>How Dependency Injection works in Spring:</source>
          <target state="translated">Spring에서 Dependency Injection이 작동하는 방식 :</target>
        </trans-unit>
        <trans-unit id="57367ae4f39a638d3dbf05ee497ca936efcff588" translate="yes" xml:space="preserve">
          <source>However, we still use &lt;code&gt;new Service()&lt;/code&gt; many time and it is not good when change &lt;code&gt;Service&lt;/code&gt; constructor. To prevent it, we can use DI injector like</source>
          <target state="translated">그러나 우리는 여전히 많은 시간을 &lt;code&gt;new Service()&lt;/code&gt; 사용하며 &lt;code&gt;Service&lt;/code&gt; 생성자를 변경할 때 좋지 않습니다. 이를 방지하기 위해 DI 인젝터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d455ffdb1c3dbcd06e6b82c66932dc9c227efa" translate="yes" xml:space="preserve">
          <source>I know there are already many answers, but I found this very helpful: &lt;a href=&quot;http://tutorials.jenkov.com/dependency-injection/index.html&quot;&gt;http://tutorials.jenkov.com/dependency-injection/index.html&lt;/a&gt;</source>
          <target state="translated">나는 이미 많은 답변이 있다는 것을 알고 있지만 이것이 매우 유용하다는 것을 알았습니다 : &lt;a href=&quot;http://tutorials.jenkov.com/dependency-injection/index.html&quot;&gt;http://tutorials.jenkov.com/dependency-injection/index.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed04f29160674f83a072681c6eb371dd9cb26716" translate="yes" xml:space="preserve">
          <source>I think since everyone has written for DI, let me ask a few questions..</source>
          <target state="translated">모두가 DI를 위해 글을 썼기 때문에 몇 가지 질문을하겠습니다 ..</target>
        </trans-unit>
        <trans-unit id="2e46bcee2ea4c8bc4943d46d73203933dc4b2714" translate="yes" xml:space="preserve">
          <source>I would propose a slightly different, short and precise definition of what Dependency Injection is, focusing on the primary goal, not on the technical means (following along from &lt;a href=&quot;https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f&quot;&gt;here&lt;/a&gt;):</source>
          <target state="translated">나는 기술적 인 수단이 아닌 주요 목표에 중점을 둔 Dependency Injection이 무엇인지에 대해 약간 다르고 짧고 정확한 정의를 제안합니다 ( &lt;a href=&quot;https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f&quot;&gt;여기&lt;/a&gt; 부터 이어짐 ).</target>
        </trans-unit>
        <trans-unit id="af50e26570dc36b5b468480dbae632233aa97929" translate="yes" xml:space="preserve">
          <source>IOC is a general concept and it can be expressed in many different ways and Dependency Injection is one concrete example of IOC.</source>
          <target state="translated">IOC는 일반적인 개념이며 다양한 방식으로 표현 될 수 있으며 Dependency Injection은 IOC의 구체적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="0718ee8859576506cf86f7bd25325cd7eca7c302" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dependent.sh&lt;/code&gt; script used dependencies directly, the approach would be called &lt;em&gt;dependency lookup&lt;/em&gt; (which is opposite to &lt;em&gt;dependency injection&lt;/em&gt;):</source>
          <target state="translated">&lt;code&gt;dependent.sh&lt;/code&gt; 스크립트가 종속성을 직접 사용한 경우이 접근 방식을 &lt;em&gt;종속성 검색&lt;/em&gt; 이라고합니다 ( &lt;em&gt;종속성 주입&lt;/em&gt; 과 반대).</target>
        </trans-unit>
        <trans-unit id="ed73d2934d77992080e551028a74bcbaafd9ce4d" translate="yes" xml:space="preserve">
          <source>If Aproperty of AClass is not injected, is it harder to mock it out?</source>
          <target state="translated">AClass의 Aproperty가 주입되지 않으면 그것을 조롱하기가 더 어렵습니까?</target>
        </trans-unit>
        <trans-unit id="327557f3bb6a180cff634bb5925c6178d29f71c3" translate="yes" xml:space="preserve">
          <source>If lifespan control of dependencies by the consuming class needs to be retained, control can be re-established by injecting an (abstract) factory for creating the dependency class instances, into the consumer class. The consumer will be able to obtain instances via a &lt;code&gt;Create&lt;/code&gt; on the factory as needed, and dispose of these instances once complete.</source>
          <target state="translated">소비 클래스에 의한 종속성의 수명 제어를 유지해야하는 경우 종속성 클래스 인스턴스를 작성하기위한 (추상) 팩토리를 소비자 클래스에 삽입하여 제어를 다시 설정할 수 있습니다. 소비자는 필요에 따라 팩토리에서 &lt;code&gt;Create&lt;/code&gt; 을 통해 인스턴스를 얻을 수 있으며 완료되면 이러한 인스턴스를 폐기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ad58325899b3161d70302101921cd886c5bcce" translate="yes" xml:space="preserve">
          <source>If we use the first one we need to open the machine to change the reel.
if we opt for the second one, that is placing a hook for reel, we are getting an added benefit of playing any music by changing the reel. and also reducing the function only to playing whatever in the reel.</source>
          <target state="translated">첫 번째를 사용하는 경우 릴을 변경하려면 기계를 열어야합니다. 우리가 두 번째 것을 선택한다면, 그것은 릴을위한 고리를 놓는 것입니다. 우리는 릴을 바꿔서 음악을 연주 할 수있는 추가적인 이점을 얻고 있습니다. 또한 릴에있는 것만 재생하는 기능을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="8114d9a89619251a62658a6e49b95469bb138929" translate="yes" xml:space="preserve">
          <source>If you occasionally work outside of Java, recall how &lt;code&gt;source&lt;/code&gt; is often used in many scripting languages (Shell, Tcl, etc., or even &lt;code&gt;import&lt;/code&gt; in Python misused for this purpose).</source>
          <target state="translated">Java 외부에서 가끔 작업하는 경우 &lt;code&gt;source&lt;/code&gt; 가 많은 스크립팅 언어 (Shell, Tcl 등)에서 사용되는 방식 또는이 목적으로 잘못 사용 된 Python에서 &lt;code&gt;import&lt;/code&gt; 을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="b06602d95600aa4bf8101370b37215812a7573e0" translate="yes" xml:space="preserve">
          <source>If you use use &lt;code&gt;Constructor Injection&lt;/code&gt;, the &lt;code&gt;Service&lt;/code&gt; object is created when &lt;code&gt;Client&lt;/code&gt; created, sometime we use function in &lt;code&gt;Client&lt;/code&gt; class without use &lt;code&gt;Service&lt;/code&gt; so created &lt;code&gt;Service&lt;/code&gt; is wasted</source>
          <target state="translated">&lt;code&gt;Constructor Injection&lt;/code&gt; 을 사용하면 &lt;code&gt;Client&lt;/code&gt; 가 생성 될 때 &lt;code&gt;Service&lt;/code&gt; 객체가 생성되고 때로는 &lt;code&gt;Service&lt;/code&gt; 를 사용하지 않고 &lt;code&gt;Client&lt;/code&gt; 클래스에서 함수를 사용하므로 생성 된 &lt;code&gt;Service&lt;/code&gt; 가 낭비됩니다</target>
        </trans-unit>
        <trans-unit id="0673d4f21f33e89f895b29060653f72b9912e5ee" translate="yes" xml:space="preserve">
          <source>If you use use &lt;code&gt;Constructor Injection&lt;/code&gt;, when you look at constructor of &lt;code&gt;Client&lt;/code&gt;, you will see how many dependency of &lt;code&gt;Client&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Constructor Injection&lt;/code&gt; 사용을 사용하면 &lt;code&gt;Client&lt;/code&gt; 의 생성자를 볼 때 &lt;code&gt;Client&lt;/code&gt; 클래스의 종속성 수를 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fe36ce97b13993591149a7d6ee89ed548e32abbb" translate="yes" xml:space="preserve">
          <source>In .Net, IoC containers are aware of protocols such as &lt;code&gt;IDisposable&lt;/code&gt; and will take on the responsibility of &lt;code&gt;Disposing&lt;/code&gt; dependencies in line with the configured lifespan management.</source>
          <target state="translated">.Net에서 IoC 컨테이너는 &lt;code&gt;IDisposable&lt;/code&gt; 과 같은 프로토콜을 알고 있으며 구성된 수명 관리에 따라 종속성을 &lt;code&gt;Disposing&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="5874ec6c4d7578e3bf3f97834e478c385a3a81da" translate="yes" xml:space="preserve">
          <source>In 2013, when I wrote this answer, this was a major theme on the &lt;a href=&quot;http://googletesting.blogspot.com/&quot;&gt;Google Testing Blog&lt;/a&gt;. It remains the biggest advantage to me, as programmers not always need the extra flexibility in their run-time design (for instance, for service locator or similar patterns). Programmers often need to isolate the classes during testing.</source>
          <target state="translated">2013 년에이 답변을 썼을 때 &lt;a href=&quot;http://googletesting.blogspot.com/&quot;&gt;Google 테스팅 블로그&lt;/a&gt; 의 주요 주제였습니다. 프로그래머가 항상 런타임 디자인 (예 : 서비스 로케이터 또는 유사한 패턴)에서 추가 유연성을 필요로하는 것은 아니기 때문에 나에게 가장 큰 장점으로 남아 있습니다. 프로그래머는 종종 테스트 중에 클래스를 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dd39bee0cfeef6f907d686e8fca98428110580e" translate="yes" xml:space="preserve">
          <source>In my opinion there is one only reason for DI frameworks: boiler plate reduction. With a well done factory system you can do the same, more controlled and more predictable as your preferred DI framework, DI frameworks promise code reduction (XML and annotations are source code too). The problem is this boiler plate reduction is just real in very very simple cases (one instance-per class and similar), sometimes in the real world picking the appropriated service object is not as easy as mapping a class to a singleton object.</source>
          <target state="translated">제 생각에는 DI 프레임 워크의 유일한 이유는 보일러 플레이트 감소입니다. 잘 구성된 공장 시스템을 사용하면 선호하는 DI 프레임 워크와 동일하고보다 제어 가능하며 예측 가능한 작업을 수행 할 수 있습니다. DI 프레임 워크는 코드 축소를 약속합니다 (XML 및 주석도 소스 코드 임). 문제는 보일러 플레이트 축소가 매우 간단한 경우 (클래스 당 하나의 인스턴스와 유사한 경우)에 실제로 적용되기도하며, 실제 환경에서 적절한 서비스 개체를 선택하는 것은 클래스를 단일 개체에 매핑하는 것만 큼 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="945ef8affad419ee07825f142d4a71064182f46f" translate="yes" xml:space="preserve">
          <source>In other words with this approach is that our high level Car class is dependent on the lower level GasEngine class which violate Dependency Inversion Principle(DIP) from SOLID. DIP suggests that we should depend on abstractions, not concrete classes. So to satisfy this we introduce IEngine interface and rewrite code like below:</source>
          <target state="translated">다시 말해,이 접근 방식을 사용하는 경우 당사의 고급 자동차 등급은 SOLID의 DIP (Dependency Inversion Principle)를 위반하는 하위 레벨 GasEngine 등급에 의존합니다. DIP는 구체적인 클래스가 아닌 추상화에 의존해야한다고 제안합니다. 이를 만족시키기 위해 IEngine 인터페이스를 소개하고 아래와 같이 코드를 다시 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="bc6abe43c16188f9d3e1b34e8bf777645960925f" translate="yes" xml:space="preserve">
          <source>In simple words dependency injection (DI) is the way to remove dependencies or tight coupling between different object. Dependency Injection gives a cohesive behavior to each object.</source>
          <target state="translated">간단히 말하면 DI (종속성 주입)는 서로 다른 개체 간의 종속성 또는 긴밀한 연결을 제거하는 방법입니다. 의존성 주입은 각 객체에 응집력있는 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e58974612fd6fe0036631984f3609c239eab907" translate="yes" xml:space="preserve">
          <source>In this example, the implementation of &lt;code&gt;PersonService::addManager&lt;/code&gt; and &lt;code&gt;PersonService::removeManager&lt;/code&gt; would need an instance of the &lt;code&gt;GroupMembershipService&lt;/code&gt; in order to do its work. Without Dependency Injection, the traditional way of doing this would be to instantiate a new &lt;code&gt;GroupMembershipService&lt;/code&gt; in the constructor of &lt;code&gt;PersonService&lt;/code&gt; and use that instance attribute in both functions. However, if the constructor of &lt;code&gt;GroupMembershipService&lt;/code&gt; has multiple things it requires, or worse yet, there are some initialization &quot;setters&quot; that need to be called on the &lt;code&gt;GroupMembershipService&lt;/code&gt;, the code grows rather quickly, and the &lt;code&gt;PersonService&lt;/code&gt; now depends not only on the &lt;code&gt;GroupMembershipService&lt;/code&gt; but also everything else that &lt;code&gt;GroupMembershipService&lt;/code&gt; depends on. Furthermore, the linkage to &lt;code&gt;GroupMembershipService&lt;/code&gt; is hardcoded into the &lt;code&gt;PersonService&lt;/code&gt; which means that you can't &quot;dummy up&quot; a &lt;code&gt;GroupMembershipService&lt;/code&gt; for testing purposes, or to use a strategy pattern in different parts of your application.</source>
          <target state="translated">이 예제에서 &lt;code&gt;PersonService::addManager&lt;/code&gt; 및 PersonService &lt;code&gt;PersonService::removeManager&lt;/code&gt; 구현하려면 &lt;code&gt;GroupMembershipService&lt;/code&gt; 의 인스턴스가 필요합니다. Dependency Injection이 없으면 &lt;code&gt;PersonService&lt;/code&gt; 생성자에서 새 &lt;code&gt;GroupMembershipService&lt;/code&gt; 를 인스턴스화하고 두 인스턴스 모두에서 해당 인스턴스 속성을 사용하는 것이 기존의 방법입니다. 그러나 &lt;code&gt;GroupMembershipService&lt;/code&gt; 의 생성자가 여러 항목을 필요로하거나 더 나쁜 경우 &lt;code&gt;GroupMembershipService&lt;/code&gt; 에서 호출해야하는 초기화 &quot;세터&quot;가 있으면 코드가 빠르게 커지고 &lt;code&gt;PersonService&lt;/code&gt; 는 &lt;code&gt;GroupMembershipService&lt;/code&gt; 뿐만 아니라 GroupMembershipService 에만 의존합니다. &lt;code&gt;GroupMembershipService&lt;/code&gt; 가 의존하는 다른 모든 것. 또한 &lt;code&gt;GroupMembershipService&lt;/code&gt; 와의 연계는 PersonService 에 하드 코딩되어있어 테스트 목적으로 &lt;code&gt;GroupMembershipService&lt;/code&gt; 를 &quot;더미&quot;하거나 응용 프로그램의 다른 부분에서 전략 패턴을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3945063a7ab43002ea39d3d24e40ac75108803b6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;source&lt;/code&gt;-ing implementation script directly in the dependent one, you use an &lt;code&gt;injector.sh&lt;/code&gt; &quot;container&quot; which wraps both &quot;components&quot;:</source>
          <target state="translated">종속 스크립트에서 직접 &lt;code&gt;source&lt;/code&gt; 작성 구현 스크립트 대신 두 &quot;구성 요소&quot;를 모두 감싸는 &lt;code&gt;injector.sh&lt;/code&gt; &quot;컨테이너&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a32a54b9d71ad0ec3f835fab1768f5cabb2ce808" translate="yes" xml:space="preserve">
          <source>Interface of book:</source>
          <target state="translated">책의 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="87ce48016c0abd40898b021fa36510c98da3c3f6" translate="yes" xml:space="preserve">
          <source>Inversion of Control (IOC)</source>
          <target state="translated">제어 역전 (IOC)</target>
        </trans-unit>
        <trans-unit id="c6f589e1a346ddca493c03b3d62843ee5c496a03" translate="yes" xml:space="preserve">
          <source>It helps to develop high quality components since they are independently developed they are properly tested.</source>
          <target state="translated">독립적으로 개발되어 적절히 테스트되었으므로 고품질 구성 요소를 개발하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="fe52190c660276a5234fd25313a1d7025785a9b1" translate="yes" xml:space="preserve">
          <source>It helps to replace the component with another if one fails.</source>
          <target state="translated">구성 요소가 고장 나면 구성 요소를 다른 것으로 교체하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="12a6359f43afb8218185323269fc89edefe3a5f9" translate="yes" xml:space="preserve">
          <source>It is harder to isolate components in unit testing without dependency injection.</source>
          <target state="translated">의존성 주입없이 단위 테스트에서 구성 요소를 분리하는 것이 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5315cf7c004aa65a5379bfbf68f8aa368640746e" translate="yes" xml:space="preserve">
          <source>It means that objects should only have as many dependencies as is needed to do their job and the dependencies should be few. Furthermore, an object&amp;rsquo;s dependencies should be on interfaces and not on &amp;ldquo;concrete&amp;rdquo; objects, when possible. (A concrete object is any object created with the keyword new.) Loose coupling promotes greater reusability, easier maintainability, and allows you to easily provide &amp;ldquo;mock&amp;rdquo; objects in place of expensive services.</source>
          <target state="translated">즉, 개체는 작업을 수행하는 데 필요한만큼의 종속성 만 가져야하며 종속성은 적어야합니다. 또한 객체의 종속성은 가능한 경우 &quot;콘크리트&quot;객체가 아닌 인터페이스에 있어야합니다. (콘크리트 객체는 new 키워드로 생성 된 객체입니다.) 느슨한 커플 링은 재사용 성이 향상되고 유지 관리가 쉬워지며 고가의 서비스 대신 &quot;모의&quot;객체를 쉽게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="150a68e160c591532e3796e7a048e6a35a2b271c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s the technique of passing objects dependencies to its constructor.</source>
          <target state="translated">객체 의존성을 생성자에 전달하는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="aa27b9815cfca97bc09894174bbc5029fa7ea762" translate="yes" xml:space="preserve">
          <source>Last words</source>
          <target state="translated">마지막 말</target>
        </trans-unit>
        <trans-unit id="101f50890da169b761f4204e13794649557a2715" translate="yes" xml:space="preserve">
          <source>Let's imagine that you want to go fishing:</source>
          <target state="translated">낚시하러 가고 싶다고 상상해 봅시다.</target>
        </trans-unit>
        <trans-unit id="3fb3f6b5b730e2955d7fc11411b3be83f4438c60" translate="yes" xml:space="preserve">
          <source>Let's try simple example with &lt;strong&gt;Car&lt;/strong&gt; and &lt;strong&gt;Engine&lt;/strong&gt; classes, any car need an engine to go anywhere, at least for now. So below how code will look without dependency injection.</source>
          <target state="translated">&lt;strong&gt;Car&lt;/strong&gt; 클래스와 &lt;strong&gt;Engine&lt;/strong&gt; 클래스를 사용하여 간단한 예제를 시도해 봅시다. 모든 자동차는 적어도 지금은 어디든 갈 수있는 엔진이 필요합니다. 아래 코드는 의존성 주입없이 어떻게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="0743bd397ad0bae662ab3527bca83ae55d5c97e6" translate="yes" xml:space="preserve">
          <source>Like wise dependency injection is the  process of externalizing the dependencies to focus only on the specific functionality of the component so that independent components can be coupled together to form a complex system.</source>
          <target state="translated">현명한 의존성 주입은 의존성을 외부화하여 구성 요소의 특정 기능에만 중점을 두어 독립적 인 구성 요소를 결합하여 복잡한 시스템을 형성 할 수 있도록하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="a77c6a3de980ebb5dc42a0edc1ee999977beda1e" translate="yes" xml:space="preserve">
          <source>Make test easier</source>
          <target state="translated">시험을 더 쉽게</target>
        </trans-unit>
        <trans-unit id="78928cbc17b1ac78636f5d533c2894682e0a6266" translate="yes" xml:space="preserve">
          <source>Making things as components and to combine to form a large systems with high capabilities.</source>
          <target state="translated">구성 요소로 물건을 만들고 결합하여 고성능의 대형 시스템을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="04faf2b31cb2eb82166edebcf0b8fa045081749b" translate="yes" xml:space="preserve">
          <source>Modifying &lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James&lt;/a&gt; Example for Switch and Bulb:</source>
          <target state="translated">스위치 및 전구에 대한 &lt;a href=&quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James&lt;/a&gt; 예제 수정 :</target>
        </trans-unit>
        <trans-unit id="38837e9f2c549ac0d1e7a54cf6258ccf4df0c3f2" translate="yes" xml:space="preserve">
          <source>NOTE:
It is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the if we use annotation based than @Required annotation on a setter can be used to make setters as a required dependencies.</source>
          <target state="translated">참고 : 필수 종속성에 대해서는 생성자 인수를 사용하고 선택적 종속성에 대해서는 세터를 사용하는 것이 좋습니다. 세터에서 @Required 어노테이션에 기반한 어노테이션을 사용하는 경우 세터를 필수 종속성으로 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8360dc1497a3895cbb0ae2365dd63cd62fb85433" translate="yes" xml:space="preserve">
          <source>Next we can have many kind of books; one of type is fiction:</source>
          <target state="translated">다음으로 우리는 많은 종류의 책을 가질 수 있습니다. 유형 중 하나는 허구입니다.</target>
        </trans-unit>
        <trans-unit id="381bcfef8f062363621c6445f025fc1ec1ecb6e0" translate="yes" xml:space="preserve">
          <source>No Dependency:</source>
          <target state="translated">의존성 없음 :</target>
        </trans-unit>
        <trans-unit id="148aedccb1c30aae863f891e9230b9918c3c26e5" translate="yes" xml:space="preserve">
          <source>Note that the constructor accepts an interface and not concrete object. Also, note that an exception is thrown if the orderDao parameter is null. This emphasizes the importance of receiving a valid dependency. Constructor Injection is, in my opinion, the preferred mechanism for giving an object its dependencies. It is clear to the developer while invoking the object which dependencies need to be given to the &amp;ldquo;Person&amp;rdquo; object for proper execution.</source>
          <target state="translated">생성자는 구체적인 객체가 아닌 인터페이스를 허용합니다. 또한 orderDao 매개 변수가 널인 경우 예외가 발생합니다. 이것은 유효한 의존성을받는 것의 중요성을 강조합니다. 제 생각에 생성자 주입은 객체에 종속성을 부여하는 데 선호되는 메커니즘입니다. 적절한 실행을 위해&amp;ldquo;Person&amp;rdquo;객체에 종속되어야하는 객체를 호출하는 동안 개발자에게 분명합니다.</target>
        </trans-unit>
        <trans-unit id="52a2afd82b94f21efe4003a5f77702e673692a03" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;DataSourceImpl&lt;/code&gt; instantiation is moved into a constructor. The constructor takes four parameters which are the four values needed by the &lt;code&gt;DataSourceImpl&lt;/code&gt;. Though the &lt;code&gt;MyDao&lt;/code&gt; class still depends on these four values, it no longer satisfies these dependencies itself. They are provided by whatever class creating a &lt;code&gt;MyDao&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;DataSourceImpl&lt;/code&gt; 인스턴스화가 생성자로 어떻게 이동하는지 확인하십시오. 생성자는 &lt;code&gt;DataSourceImpl&lt;/code&gt; 에 필요한 4 개의 값인 4 개의 매개 변수를 사용합니다. &lt;code&gt;MyDao&lt;/code&gt; 클래스는 여전히이 네 가지 값에 의존하지만 더 이상 이러한 종속성 자체를 만족시키지 않습니다. &lt;code&gt;MyDao&lt;/code&gt; 인스턴스를 생성하는 모든 클래스에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b9bf32a5cd289e031981b513bdc34931168fff08" translate="yes" xml:space="preserve">
          <source>Now a days these concept forms the basis of well known frameworks in programming world.
The Spring Angular etc are the well-known software frameworks built on the top of this concept</source>
          <target state="translated">오늘날 이러한 개념은 프로그래밍 세계에서 잘 알려진 프레임 워크의 기초를 형성합니다. Spring Angular 등은이 개념 위에 구축 된 잘 알려진 소프트웨어 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="3f568c10c487626292e158f1321b91077bbdfb85" translate="yes" xml:space="preserve">
          <source>Now our Car class is dependent on only the IEngine interface, not a specific implementation of engine. 
Now, the only trick is how do we create an instance of the Car and give it an actual concrete Engine class like GasEngine or ElectricityEngine. That's where &lt;strong&gt;Dependency Injection&lt;/strong&gt; comes in.</source>
          <target state="translated">이제 Car 클래스는 엔진의 특정 구현이 아니라 IEngine 인터페이스에만 의존합니다. 이제 유일한 트릭은 어떻게 Car 인스턴스를 생성하고 GasEngine 또는 ElectricityEngine과 같은 실제 콘크리트 엔진 클래스를 제공 하는가입니다. 바로 그곳에서 &lt;strong&gt;Dependency Injection&lt;/strong&gt; 이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="294a5073bdc9a6339404dadb5c21756e099a6869" translate="yes" xml:space="preserve">
          <source>Now subscriber can have association to the book:</source>
          <target state="translated">이제 구독자는 책에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4442a341c09f2a8337cd53e8c9d7b14c1f8d57" translate="yes" xml:space="preserve">
          <source>Now the problem is that dependent &quot;component&quot; has to perform initialization itself.</source>
          <target state="translated">이제 문제는 종속적 인 &quot;component&quot;가 초기화 자체를 수행해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="244d7754a9d504a1f45d44ae1bdf5c41e24ccff1" translate="yes" xml:space="preserve">
          <source>Now, this code is already follow &lt;code&gt;Dependency Injection&lt;/code&gt; and it is easier for test &lt;code&gt;Client&lt;/code&gt; class.</source>
          <target state="translated">이제이 코드는 이미 &lt;code&gt;Dependency Injection&lt;/code&gt; 을 따르고 있으며 &lt;code&gt;Client&lt;/code&gt; 클래스 테스트가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="01cf15bf0efc21fae58f14423988c7d39bcbc525" translate="yes" xml:space="preserve">
          <source>Objects are once loaded in Spring container and then we reuse them whenever we need them by fetching those objects from Spring container using getBean(String beanName) method.</source>
          <target state="translated">객체는 일단 Spring 컨테이너에로드 된 다음 getBean (String beanName) 메소드를 사용하여 Spring 컨테이너에서 해당 객체를 가져 와서 필요할 때마다 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="6cf40f56e8e4c0d23d55ca133079493612e29b47" translate="yes" xml:space="preserve">
          <source>One common alternative is defining a &lt;strong&gt;do-nothing constructor&lt;/strong&gt;. Dependency injection can be done through setters. (h/t @MikeVella).</source>
          <target state="translated">일반적인 대안 중 하나는 &lt;strong&gt;do-nothing 생성자를&lt;/strong&gt; 정의하는 &lt;strong&gt;것&lt;/strong&gt; 입니다. 의존성 주입은 세터를 통해 수행 할 수 있습니다. (h / t @MikeVella).</target>
        </trans-unit>
        <trans-unit id="e85085db2ea4a2409b650b063f440106471f7755" translate="yes" xml:space="preserve">
          <source>One consequence of DI is that the lifespan management of dependency object instances is no longer controlled by a consuming class, as the dependency object is now passed into the consuming class (via constructor or setter injection).</source>
          <target state="translated">DI의 한 가지 결과는 종속성 개체가 이제 생성자 또는 설정자 주입을 통해 소비 클래스로 전달되므로 종속성 개체 인스턴스의 수명 관리가 더 이상 소비 클래스에 의해 제어되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0e87d7a02651091658f2b2651ada0186577a5e58" translate="yes" xml:space="preserve">
          <source>One requirement is that the services must be parametrised by their dependencies. What this means exactly depends on the language and approach taken in a given system. Usually, this takes the form of constructor parameters, but using setters is also an option. This also means that the dependencies of a service are hidden (when invoking a service method) from the users of the service.</source>
          <target state="translated">한 가지 요구 사항은 서비스가 종속성으로 매개 변수화되어야한다는 것입니다. 이것이 의미하는 것은 주어진 시스템에서 취한 언어와 접근 방식에 정확히 달려 있습니다. 일반적으로 생성자 매개 변수의 형태를 취하지 만 setter를 사용하는 것도 옵션입니다. 이것은 또한 서비스의 종속성이 서비스의 사용자로부터 숨겨져 있음을 의미합니다 (서비스 메소드를 호출 할 때).</target>
        </trans-unit>
        <trans-unit id="159c3350bcfe189a7b428c479d9201ea48faf507" translate="yes" xml:space="preserve">
          <source>Or, lifespan control of dependency instances can be relinquished to an IoC container (more about this below).</source>
          <target state="translated">또는 종속성 인스턴스의 수명 제어를 IoC 컨테이너에 양도 할 수 있습니다 (자세한 내용은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="93d225da5e27eb45ee9a17d2a3dcf555280a505b" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;myObject&lt;/code&gt; in as an argument to the constructor</source>
          <target state="translated">생성자에 대한 인수로 &lt;code&gt;myObject&lt;/code&gt; 전달</target>
        </trans-unit>
        <trans-unit id="21b3ab899d3e7a2f72bd43dcfb14037ae113a442" translate="yes" xml:space="preserve">
          <source>Practically, every design pattern separates concerns to make future changes affect minimum files.</source>
          <target state="translated">실제로 모든 디자인 패턴은 향후 변경 사항이 최소 파일에 영향을 미치도록 우려를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="d9f5010baa893f9ad98e960248019e1ff603968f" translate="yes" xml:space="preserve">
          <source>Previously we are writing code like this</source>
          <target state="translated">이전에는 이와 같은 코드를 작성하고 있습니다</target>
        </trans-unit>
        <trans-unit id="533e261383d8b2d3e59f53c2e9d59c559259294d" translate="yes" xml:space="preserve">
          <source>Programmers have understood the dependency obfuscation requirement for years and many alternative solutions have evolved both before and after dependency injection was conceived. There are Factory patterns but there are also many options using ThreadLocal where no injection to a particular instance is needed - the dependency is effectively injected into the thread which has the benefit of making the object available (via convenience static getter methods) to &lt;em&gt;any&lt;/em&gt; class that requires it without having to add annotations to the classes that require it and set up intricate XML 'glue' to make it happen. When your dependencies are required for persistence (JPA/JDO or whatever) it allows you to achieve 'tranaparent persistence' much easier and with domain model and business model classes made up purely of POJOs (i.e. no framework specific/locked in annotations).</source>
          <target state="translated">프로그래머들은 수년간 의존성 난독 화 요구 사항을 이해했으며 의존성 주입이 고안된 전후에 많은 대안 솔루션이 발전해 왔습니다. 팩토리 패턴이 있지만 특정 인스턴스에 대한 주입이 필요하지 않은 ThreadLocal을 사용하는 많은 옵션이 있습니다-종속성은 스레드에 효과적으로 주입되어 편리하게 정적 getter 메소드를 통해 객체를 클래스에 사용할 수 있다는 이점이 있습니다 필요한 클래스에 주석을 추가하지 않고 복잡한 XML '접착제'를 설정하지 않아도됩니다. 의존성 (JPA / JDO 또는 기타)에 의존성이 필요한 경우 POJO로 구성된 도메인 모델 및 비즈니스 모델 클래스를 사용하여 훨씬 쉽게 '투명성 지속성'을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fbc5d43864c0ac8fa3636a03653618ac21757e7" translate="yes" xml:space="preserve">
          <source>Setter Injection</source>
          <target state="translated">세터 주입</target>
        </trans-unit>
        <trans-unit id="5a34561d27d0c82f9fb28bebbfcc20bc74ddc2a1" translate="yes" xml:space="preserve">
          <source>Setter Injection does not force dependencies to be passed to the constructor. Instead, the dependencies are set onto public properties exposed by the object in need. As implied previously, the primary motivators for doing this include:</source>
          <target state="translated">Setter Injection은 종속성을 생성자에 강제로 전달하지 않습니다. 대신, 종속성은 필요한 개체에 의해 노출 된 공용 속성에 설정됩니다. 앞에서 암시 한 바와 같이,이를 수행하는 주요 동기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ba4002363cebe927c87f145292fe23279da4fc4" translate="yes" xml:space="preserve">
          <source>Setter injection</source>
          <target state="translated">세터 주입</target>
        </trans-unit>
        <trans-unit id="b8cb1079b38327369ec318ba6d8358b7e9c456ba" translate="yes" xml:space="preserve">
          <source>Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.</source>
          <target state="translated">Setter 기반 DI는 Bean을 인스턴스화하기 위해 인수가없는 생성자 또는 인수가없는 정적 팩토리 메소드를 호출 한 후 Bean에서 컨테이너의 setter 메소드를 호출하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="de72ea9e60d3b0389fb7873c1d21268b088fa6d4" translate="yes" xml:space="preserve">
          <source>Simple</source>
          <target state="translated">Simple</target>
        </trans-unit>
        <trans-unit id="53b5b8696132c7f14a83c7efaf53a8df90f22d0e" translate="yes" xml:space="preserve">
          <source>So in the end &lt;strong&gt;Dependency injection&lt;/strong&gt; is just a technique for
  achieving loose coupling between objects and their dependencies.
  Rather than directly instantiating dependencies that class needs in
  order to perform its actions, dependencies are provided to the class
  (most often) via constructor injection.</source>
          <target state="translated">결국 &lt;strong&gt;의존성 주입&lt;/strong&gt; 은 객체와 그 의존성 사이의 느슨한 결합을 달성하는 기술 일뿐입니다. 클래스가 작업을 수행하기 위해 필요한 종속성을 직접 인스턴스화하지 않고 생성자 주입을 통해 클래스에 종속성을 제공합니다 (대부분의 경우).</target>
        </trans-unit>
        <trans-unit id="7da9dbfe443ff7c3e18888265c12bc4c6d7027ed" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html&quot;&gt;Understanding dependency injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">출처 : &lt;em&gt;&lt;a href=&quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html&quot;&gt;의존성 주입 이해&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5974b915c67629f3fb291858490061a4113d7288" translate="yes" xml:space="preserve">
          <source>Specifically, in the paradigm of Robert C Martin's &lt;a href=&quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;SOLID principles of Object Oriented Design&lt;/a&gt;, &lt;code&gt;DI&lt;/code&gt; is one of the possible implementations of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;Dependency Inversion Principle (DIP)&lt;/a&gt;. The &lt;a href=&quot;https://stackoverflow.com/q/27978841/314291&quot;&gt;DIP is the &lt;code&gt;D&lt;/code&gt; of the &lt;code&gt;SOLID&lt;/code&gt; mantra&lt;/a&gt;  - other DIP implementations include the Service Locator, and Plugin patterns.</source>
          <target state="translated">특히 Robert C Martin의 &lt;a href=&quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;SOLID (Object Oriented Design) 원칙의&lt;/a&gt; 패러다임에서 &lt;code&gt;DI&lt;/code&gt; 는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;DIP (Dependency Inversion Principle)의&lt;/a&gt; 구현 중 하나입니다. &lt;a href=&quot;https://stackoverflow.com/q/27978841/314291&quot;&gt;DIP는 &lt;code&gt;SOLID&lt;/code&gt; mantra의 &lt;code&gt;D&lt;/code&gt; 입니다.&lt;/a&gt; 다른 DIP 구현에는 Service Locator 및 플러그인 패턴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b86bb17c077dd81ce6f0d78a2ce285c974111f" translate="yes" xml:space="preserve">
          <source>Supporting dependency injection without having to modify the constructor of a legacy class.</source>
          <target state="translated">레거시 클래스의 생성자를 수정하지 않고도 종속성 주입을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ad518a2bfe35a440dc057b8df89372141fdee4b1" translate="yes" xml:space="preserve">
          <source>Switch -&amp;gt; Bulb1 OR Bulb2 OR NightBulb (injected dependency)</source>
          <target state="translated">스위치-&amp;gt; Bulb1 OR Bulb2 OR NightBulb (주사 된 의존성)</target>
        </trans-unit>
        <trans-unit id="1f8e6772695db9bb64683f23fba3fcc305250d9e" translate="yes" xml:space="preserve">
          <source>Switch -&amp;gt; PermanentBulb &lt;em&gt;//switch is directly connected to permanent bulb, testing not possible easily&lt;/em&gt;</source>
          <target state="translated">Switch-&amp;gt; PermanentBulb &lt;em&gt;// 스위치는 영구 전구에 직접 연결되어있어 쉽게 테스트 할 수 없습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c4c8437fc5346d142f060317a5f268dabd0d961" translate="yes" xml:space="preserve">
          <source>Switch needs to know beforehand which bulb I am connected to (hard-coded dependency). So,</source>
          <target state="translated">스위치는 내가 어떤 전구에 연결되어 있는지 미리 알아야합니다 (하드 코딩 된 종속성). 그래서,</target>
        </trans-unit>
        <trans-unit id="4d7495d3cc88447e63485a25f72ecf731763671c" translate="yes" xml:space="preserve">
          <source>Switch only knows I need to turn on/off whichever Bulb is passed to me. So,</source>
          <target state="translated">Switch는 나에게 Bulb가 전달 될 때마다 켜거나 끌 필요가 있다는 것을 알고 있습니다. 그래서,</target>
        </trans-unit>
        <trans-unit id="4c1913b877e14f9958c5e5bb105932590816f59f" translate="yes" xml:space="preserve">
          <source>The &quot;component&quot;'s source code is neither &lt;strong&gt;clean&lt;/strong&gt; nor &lt;strong&gt;stable&lt;/strong&gt; because every changes in initialization of dependencies requires new release for &quot;components&quot;'s source code file as well.</source>
          <target state="translated">종속성의 초기화가 변경 될 때마다 &quot;컴포넌트&quot;의 소스 코드 파일에 대한 새로운 릴리스가 필요하기 때문에 &quot;컴포넌트&quot;의 소스 코드는 &lt;strong&gt;깨끗&lt;/strong&gt; 하거나 &lt;strong&gt;안정적이지&lt;/strong&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="73264d2706ed99c7c3cf1d84437da53a400c9eb1" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Dependency Injection&amp;rdquo; (DI) is also known as &amp;ldquo;Inversion of Control&amp;rdquo; (IoC), can be used as a technique for encouraging this loose coupling.</source>
          <target state="translated">&quot;종속 주입&quot;(DI)은 &quot;제어 역전&quot;(IoC)으로도 알려져 있으며,이 느슨한 결합을 장려하는 기술로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ce8e8f58189f93cac9d7dcd25f82fad19ea42c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;archive_files&lt;/code&gt;&lt;em&gt;dependency&lt;/em&gt; has just been &lt;em&gt;injected&lt;/em&gt; into &lt;em&gt;dependent&lt;/em&gt; script.</source>
          <target state="translated">&lt;code&gt;archive_files&lt;/code&gt; &lt;em&gt;종속성&lt;/em&gt; 이 &lt;em&gt;종속&lt;/em&gt; 스크립트에 &lt;em&gt;삽입&lt;/em&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="57f5c2a4c3648bf44c57e0b10c21224b7534177d" translate="yes" xml:space="preserve">
          <source>The above image is an image of Reel-to-reel portable tape recorder, mid-20th century. &lt;a href=&quot;https://www.britannica.com/technology/tape-recorder&quot;&gt;Source&lt;/a&gt;.</source>
          <target state="translated">위 이미지는 20 세기 중반 Reel-to-Reel 휴대용 테이프 레코더의 이미지입니다. &lt;a href=&quot;https://www.britannica.com/technology/tape-recorder&quot;&gt;출처&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc174d974fc2630ad90c3952d5479067c5370ff0" translate="yes" xml:space="preserve">
          <source>The accepted answer is a good one - but I would like to add to this that DI is very much like the classic avoiding of hardcoded constants in the code.</source>
          <target state="translated">받아 들일만한 대답은 좋은 것입니다.하지만 DI는 코드에서 하드 코딩 된 상수를 피하는 고전과 매우 흡사합니다.</target>
        </trans-unit>
        <trans-unit id="a38ac33b8fba8d81022fa8e5992560f5f98cbdc3" translate="yes" xml:space="preserve">
          <source>The best analogy I can think of is the surgeon and his assistant(s) in an operation theater, where the surgeon is the main person and his assistant who provides the various surgical components when he needs it so that the surgeon can concentrate on the one thing he does best (surgery). Without the assistant the surgeon has to get the components himself every time he needs one.</source>
          <target state="translated">제가 생각할 수있는 가장 좋은 비유는 수술실의 외과의와 그의 조수입니다. 외과의는 주된 사람이자 외과의가 그에게 집중할 수 있도록 필요할 때 다양한 외과 용 구성 요소를 제공하는 조수입니다. 그가 최선을 다하는 것 (외과). 보조자가 없으면 의사는 필요할 때마다 구성 요소를 직접 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="a41ea95353f5d528dfa619f0e43f5976252872f7" translate="yes" xml:space="preserve">
          <source>The best definition I've found so far is &lt;a href=&quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;one by James Shore&lt;/a&gt;:</source>
          <target state="translated">지금까지 찾은 최고의 정의는 &lt;a href=&quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html&quot;&gt;James Shore&lt;/a&gt; 가 정의한 것입니다.</target>
        </trans-unit>
        <trans-unit id="888a31b520ca5d4997c6aa72d7a98329f15bff71" translate="yes" xml:space="preserve">
          <source>The issue with this code that we tightly coupled to GasEngine and if we decide to change it to ElectricityEngine then we will need to rewrite Car class. And the bigger the application the more issues and headache we will have to add and use new type of engine.</source>
          <target state="translated">우리가 GasEngine에 밀접하게 결합 한이 코드의 문제는 그것을 ElectricityEngine으로 변경하기로 결정한 경우 Car 클래스를 다시 작성해야합니다. 그리고 응용 프로그램이 클수록 더 많은 문제와 두통이 발생하여 새로운 유형의 엔진을 추가하고 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55cafcb834ee14f42eff09928fdaf624281b81f7" translate="yes" xml:space="preserve">
          <source>The key to DI-friendly code is to avoid static coupling of classes, and not to use new() for the creation of Dependencies</source>
          <target state="translated">DI 친화적 인 코드의 핵심은 클래스의 정적 결합을 피하고 의존성 작성에 new ()를 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ca5815f45aca9074db82cb4273a806d37ea2c5b" translate="yes" xml:space="preserve">
          <source>The main benefit of the &lt;strong&gt;Dependency Injection&lt;/strong&gt; that classes are more loosely coupled, because they do not have hard-coded dependencies. This follows the Dependency Inversion Principle, which was mentioned above. Instead of referencing specific implementations, classes request abstractions (usually &lt;strong&gt;interfaces&lt;/strong&gt;) which are provided to them when the class is constructed.</source>
          <target state="translated">클래스가 하드 코딩 된 종속성을 갖지 않기 때문에 클래스가 더 느슨하게 결합되어 있다는 &lt;strong&gt;Dependency Injection&lt;/strong&gt; 의 주요 이점입니다. 이것은 위에서 언급 한 종속성 반전 원리를 따릅니다. 클래스는 특정 구현을 참조하는 대신 클래스가 생성 될 때 제공되는 추상화 (일반적으로 &lt;strong&gt;인터페이스&lt;/strong&gt; )를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="473698f3e91170575e3a1dd7c3f14effd0d4dbdd" translate="yes" xml:space="preserve">
          <source>The main benefits we achieved by using dependency injection.</source>
          <target state="translated">의존성 주입을 사용하여 달성 한 주요 이점.</target>
        </trans-unit>
        <trans-unit id="3a01d41764fb9f4deb184c6238b397910d66d4e7" translate="yes" xml:space="preserve">
          <source>The main purpose of the intermediate level is not just to pass in the dependencies to the constructor, but to list all the dependencies in &lt;em&gt;just one place&lt;/em&gt;, and to hide them from the coder (not to make the coder provide them).</source>
          <target state="translated">중간 수준의 주요 목적은 생성자에게 종속성을 전달하는 것이 아니라 모든 종속성을 &lt;em&gt;한곳에&lt;/em&gt; 나열하고 코더에서 숨기는 것입니다 (코더가 제공하지 않도록).</target>
        </trans-unit>
        <trans-unit id="675567e15eedcab72deecf5182fe51cdda38c6b1" translate="yes" xml:space="preserve">
          <source>The module graph - the graph of service objects - is typically created on application startup. This can be done using a container, such as Spring, but can also be done manually, by passing parameters to object constructors. Both ways have their pros and cons, but a framework definitely isn&amp;rsquo;t necessary to use DI in your application.</source>
          <target state="translated">서비스 객체의 그래프 인 모듈 그래프는 일반적으로 응용 프로그램 시작시 생성됩니다. 이것은 Spring과 같은 컨테이너를 사용하여 수행 할 수 있지만 매개 변수를 객체 생성자에 전달하여 수동으로 수행 할 수도 있습니다. 두 가지 방법 모두 장단점이 있지만 응용 프로그램에서 DI를 사용하기 위해 프레임 워크가 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1345d93e55da0a02f0e73cb3294e155c0fcd0c41" translate="yes" xml:space="preserve">
          <source>The objective of the DIP is to decouple tight, concrete dependencies between classes, and instead, to loosen the coupling by means of an abstraction, which can be achieved via an &lt;code&gt;interface&lt;/code&gt;, &lt;code&gt;abstract class&lt;/code&gt; or &lt;code&gt;pure virtual class&lt;/code&gt;, depending on the language and approach used.</source>
          <target state="translated">DIP의 목적은 사용되는 언어와 접근 방식에 따라 &lt;code&gt;interface&lt;/code&gt; , &lt;code&gt;abstract class&lt;/code&gt; 또는 &lt;code&gt;pure virtual class&lt;/code&gt; 를 통해 달성 할 수있는 추상화를 통해 결합을 느슨하게하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="13ddfae2bc42d77fabc17f4670bf62cf40aa3c4a" translate="yes" xml:space="preserve">
          <source>The objects that we create in our applications (regardless if we use Java, C# or other object-oriented language) usually fall into one of two categories: stateless, static and global &amp;ldquo;service objects&amp;rdquo; (modules), and stateful, dynamic and local &amp;ldquo;data objects&amp;rdquo;.</source>
          <target state="translated">애플리케이션에서 작성하는 객체 (Java, C # 또는 기타 객체 지향 언어 사용 여부에 관계없이)는 일반적으로 상태 비 저장, 정적 및 전역 &quot;서비스 객체&quot;(모듈) 및 상태 저장, 동적 및 로컬의 두 가지 범주 중 하나에 속합니다. &amp;ldquo;데이터 객체&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="fccd88c774cbd85630c6ee5e8c38793343e3457d" translate="yes" xml:space="preserve">
          <source>The person typing &quot;make bar&quot; doesn't need to know that bar depends on foo. The dependency was injected between &quot;make bar&quot; and gcc.</source>
          <target state="translated">&quot;make bar&quot;를 입력하는 사람은 그 바가 foo에 의존한다는 것을 알 필요가 없습니다. &quot;make bar&quot;와 gcc간에 종속성이 주입되었습니다.</target>
        </trans-unit>
        <trans-unit id="c8b03c2d69af0fb222af1edc1d1a6a786e0d51c4" translate="yes" xml:space="preserve">
          <source>The popular answers are unhelpful, because they define dependency injection in a way that isn't useful. Let's agree that by &quot;dependency&quot; we mean some pre-existing other object that our object X needs. But we don't say we're doing &quot;dependency injection&quot; when we say</source>
          <target state="translated">인기있는 답변은 유용하지 않은 방식으로 의존성 주입을 정의하기 때문에 도움이되지 않습니다. &quot;종속성&quot;이란 객체 X가 필요로하는 기존의 다른 객체를 의미한다는 것에 동의합시다. 그러나 우리가 말할 때 &quot;종속성 주입&quot;을하고 있다고 말하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbadfee066654ad4aea424424e4eade208a93f88" translate="yes" xml:space="preserve">
          <source>The primary intention of a tape recorder machine is to record or playback sound.</source>
          <target state="translated">테이프 레코더 기계의 주요 목적은 사운드를 녹음하거나 재생하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="72621a62fc0916c8f0e046dcd1a82521dee3ad8a" translate="yes" xml:space="preserve">
          <source>The purpose of dependency injection is to decouple the work of
  resolving external software components from your application business
  logic.Without dependency injection, the details of how a component
  accesses required services can get muddled in with the component&amp;rsquo;s
  code. This not only increases the potential for errors, adds code
  bloat, and magnifies maintenance complexities; it couples components
  together more closely, making it difficult to modify dependencies when
  refactoring or testing.</source>
          <target state="translated">종속성 주입의 목적은 응용 프로그램 비즈니스 논리에서 외부 소프트웨어 구성 요소를 해결하는 작업을 분리하는 것입니다. 종속성 주입없이 구성 요소가 필요한 서비스에 액세스하는 방법에 대한 세부 정보가 구성 요소의 코드와 혼동 될 수 있습니다. 이는 오류 가능성을 높이고 코드 팽창을 추가하며 유지 관리 복잡성을 확대합니다. 구성 요소를보다 밀접하게 결합하므로 리팩토링 또는 테스트시 종속성을 수정하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="0597c45b3f09c949a793674e4746ee654b8e2e31" translate="yes" xml:space="preserve">
          <source>The script is dependent: it won't execute successfully on its own (&lt;code&gt;archive_files&lt;/code&gt; is not defined).</source>
          <target state="translated">스크립트는 종속적입니다. 자체적으로 성공적으로 실행되지 않습니다 ( &lt;code&gt;archive_files&lt;/code&gt; 가 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="1771cd5e467d2af2b6f2a767136b82451f592144" translate="yes" xml:space="preserve">
          <source>The specific domain of DI is delegation of dependency configuration and initialization.</source>
          <target state="translated">DI의 특정 도메인은 종속성 구성 및 초기화 위임입니다.</target>
        </trans-unit>
        <trans-unit id="cd6b99e6180e4829c33bd4547e92926e1044e126" translate="yes" xml:space="preserve">
          <source>The whole point of Dependency Injection (DI) is to keep application source code &lt;strong&gt;clean&lt;/strong&gt; and &lt;strong&gt;stable&lt;/strong&gt;:</source>
          <target state="translated">DI (Dependency Injection)의 핵심은 응용 프로그램 소스 코드를 &lt;strong&gt;깨끗&lt;/strong&gt; 하고 &lt;strong&gt;안정적으로 유지하는 것입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="27e320b7600e5266bce3ce68ab1e42620f41d50b" translate="yes" xml:space="preserve">
          <source>There are many different ways how to use dependency injection. It is possible to combine it with Singleton, etc., but still in basic it is only association realized by creating attribute of object type inside another object.
The usefulness is only and only in feature, that code, which we should write again and again is always prepared and done for us forward. This is why DI so closely binded with Inversion of Control (IoC) which means, that our program passes control another running module, which does injections of beans to our code. (Each object, which can be injected can be signed or considered as a Bean.) For example in Spring it is done by creating and initialization &lt;em&gt;ApplicationContext&lt;/em&gt; container, which does this work for us. We simply in our code create the Context and invoke initialization the beans. In that moment injection has been done automatically.</source>
          <target state="translated">의존성 주입을 사용하는 방법에는 여러 가지가 있습니다. Singleton 등과 결합하는 것이 가능하지만 여전히 기본적으로 다른 객체 안에 객체 유형의 속성을 작성하여 실현됩니다. 유용성은 단지 기능적인면에 있으며, 우리가 반복해서 작성해야하는 코드는 항상 우리를 위해 준비되고 완성되었습니다. 이것이 DI가 IoC (Inversion of Control)와 긴밀하게 결합하는 이유입니다. 즉, 프로그램이 다른 실행중인 모듈을 제어하여 코드에 Bean을 삽입하는 제어를 전달합니다. (주입 할 수있는 각 객체는 서명되거나 Bean으로 간주 될 수 있습니다.) 예를 들어 Spring에서는 &lt;em&gt;ApplicationContext&lt;/em&gt; 컨테이너를 생성하고 초기화하여이 작업을 수행합니다. 우리는 단순히 코드에서 컨텍스트를 작성하고 초기화 Bean을 호출합니다. 그 순간 주입이 자동으로 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="4bbc78d6e852d2e63980ceadf582e6e2cde07680" translate="yes" xml:space="preserve">
          <source>There are two primary approaches to implementing DI:</source>
          <target state="translated">DI를 구현하는 데는 두 가지 주요 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e94b174e1d5cc2e2152c883c5d77b0f60deea3d8" translate="yes" xml:space="preserve">
          <source>There have been several questions already posted with specific questions about &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, such as when to use it and what frameworks are there for it. However,</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;의존성 주입&lt;/a&gt; 에 대한 특정 질문, 사용시기 및 프레임 워크와 같은 몇 가지 질문이 이미 게시되었습니다. 하나,</target>
        </trans-unit>
        <trans-unit id="bc485497e5c277af6e8ba89ddeb765c26b3e96ea" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;an article by Martin Fowler&lt;/a&gt; that may prove useful, too.</source>
          <target state="translated">&lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Martin Fowler의 기사&lt;/a&gt; 도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="815c6163aa7ffe62c24c7f4421caa35a91b5752f" translate="yes" xml:space="preserve">
          <source>This can be viewed in different ways:</source>
          <target state="translated">이것은 다른 방법으로 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="252c2fc56bbf461770e127f5279e75e5c6e1a9ef" translate="yes" xml:space="preserve">
          <source>This is based on the answer @Adam N posted.</source>
          <target state="translated">이것은 @Adam N이 게시 한 답변을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3214625379bb5b7d1b275f45dbd054121808f8f3" translate="yes" xml:space="preserve">
          <source>To make Dependency Injection concept simple to understand. Let's take an example of switch button to toggle(on/off) a bulb.</source>
          <target state="translated">의존성 주입 개념을 이해하기 쉽게 만듭니다. 전구를 토글 (켜기 / 끄기)하기위한 스위치 버튼을 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5343d4544799a720118861acb1f47462973d60f8" translate="yes" xml:space="preserve">
          <source>Two types of Dependency Injection:</source>
          <target state="translated">두 가지 유형의 의존성 주입 :</target>
        </trans-unit>
        <trans-unit id="63568b370a821de5c78ae9aa707bb16d7ed41fac" translate="yes" xml:space="preserve">
          <source>Typically, once IoC containers have been configured / bootstrapped, they operate seamlessly in the background allowing the coder to focus on the code at hand rather than worrying about dependencies.</source>
          <target state="translated">일반적으로 IoC 컨테이너가 구성 / 부트 스트랩되면 백그라운드에서 원활하게 작동하여 코더가 종속성에 대해 걱정하지 않고 현재 코드에 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="182c61d24602b96b1f93b9d02ddeddadb6b2993d" translate="yes" xml:space="preserve">
          <source>Unfortunately the bad part is that some people have assumed you need a specialized framework to do dependency obfuscation and that you are somehow a 'lesser' programmer if you choose not to use a particular framework to do it. Another, extremely disturbing myth, believed by many, is that dependency injection is the only way of achieving dependency obfuscation. This is demonstrably and historically and obviously 100% wrong but you will have trouble convincing some people that there are alternatives to dependency injection for your dependency obfuscation requirements.</source>
          <target state="translated">불행히도 나쁜 부분은 일부 사람들이 의존성 난독 화를 수행하기 위해 특수 프레임 워크가 필요하다고 가정하고 특정 프레임 워크를 사용하지 않기로 결정한 경우 어떻게 든 더 적은 프로그래머입니다. 많은 사람들이 믿고있는 또 다른 매우 혼란스러운 신화는 의존성 주입이 의존성 난독 화를 달성하는 유일한 방법이라는 것입니다. 이것은 명백하고 역사적으로 명백히 100 % 잘못되었지만 일부 사람들에게 의존성 난독 화 요구 사항에 대한 의존성 주입에 대한 대안이 있다는 것을 확신시키는 데 어려움을 겪을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3848296892c89c589ff3cd256248c78c171b9a63" translate="yes" xml:space="preserve">
          <source>Use Dependency Injection</source>
          <target state="translated">의존성 주입 사용</target>
        </trans-unit>
        <trans-unit id="b5b26b6f5a26c971914a39f28f7610b2ff42bb58" translate="yes" xml:space="preserve">
          <source>Using a Dependency Injection Container</source>
          <target state="translated">의존성 주입 컨테이너 사용</target>
        </trans-unit>
        <trans-unit id="38051c244ec62e5af7798f63213cc9da83353e86" translate="yes" xml:space="preserve">
          <source>Using configuration only with &lt;em&gt;dependency lookup&lt;/em&gt; does not help as number of configuration parameters may change per dependency (e.g. new authentication type) as well as number of supported types of dependencies (e.g. new database type).</source>
          <target state="translated">&lt;em&gt;종속성 조회&lt;/em&gt; 와 함께 구성 만 사용 &lt;em&gt;하는&lt;/em&gt; 것은 지원되는 종속성 유형 (예 : 새 데이터베이스 유형)뿐만 아니라 종속성마다 구성 매개 변수 (예 : 새 인증 유형)가 변경 될 수 있으므로 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd86d58fd77887709d26819ecdbbed88c3b2259e" translate="yes" xml:space="preserve">
          <source>Usually the intermediate level provides factories for the constructed objects, which must provide a role that each requested object type must satisfy. That's because by having an intermediate level that hides the details of construction, you've already incurred the abstraction penalty imposed by factories, so you might as well use factories.</source>
          <target state="translated">일반적으로 중간 수준은 생성 된 개체에 대한 팩토리를 제공하며 요청 된 각 개체 유형이 충족해야하는 역할을 제공해야합니다. 건설 세부 사항을 숨기는 중간 레벨을 가짐으로써 이미 공장에서 부과 한 추상화 패널티가 발생 했으므로 공장을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f80646d8467ba758d39c4c0efe8023f67e2f3d51" translate="yes" xml:space="preserve">
          <source>We can also loosen the dependency on &lt;code&gt;Console&lt;/code&gt; to an abstraction, such as a &lt;code&gt;TextWriter&lt;/code&gt;. Dependency Injection is typically implemented as either &lt;code&gt;constructor&lt;/code&gt; injection (passing an abstraction to a dependency as a parameter to the constructor of a consuming class) or &lt;code&gt;Setter Injection&lt;/code&gt; (passing the dependency via a &lt;code&gt;setXyz()&lt;/code&gt; setter or a .Net Property with &lt;code&gt;{set;}&lt;/code&gt; defined). Constructor Injection is preferred, as this guarantees the class will be in a correct state after construction, and allows the internal dependency fields to be marked as &lt;code&gt;readonly&lt;/code&gt; (C#) or &lt;code&gt;final&lt;/code&gt; (Java). So using constructor injection on the above example, this leaves us with:</source>
          <target state="translated">또한 &lt;code&gt;TextWriter&lt;/code&gt; 와 같은 추상화에 대한 &lt;code&gt;Console&lt;/code&gt; 의 종속성을 완화 할 수 있습니다. 의존성 주입은 일반적으로 &lt;code&gt;constructor&lt;/code&gt; 주입 (소비자에 대한 추상화를 소비 클래스의 생성자에 매개 변수로 전달) 또는 &lt;code&gt;Setter Injection&lt;/code&gt; ( &lt;code&gt;setXyz()&lt;/code&gt; setter 또는 &lt;code&gt;{set;}&lt;/code&gt; 을 사용하여 .Net 속성을 통해 전달)으로 구현 됩니다. 한정된). 생성자 클래스는 생성 후 클래스가 올바른 상태가되고 내부 종속성 필드가 &lt;code&gt;readonly&lt;/code&gt; (C #) 또는 &lt;code&gt;final&lt;/code&gt; (Java)으로 표시 될 수 있으므로 생성자 주입이 선호됩니다. 위의 예제에서 생성자 주입을 사용하면 다음과 같이 남습니다.</target>
        </trans-unit>
        <trans-unit id="86284d96e43cd594072665725439a4504abe091b" translate="yes" xml:space="preserve">
          <source>We can however apply &lt;code&gt;DIP&lt;/code&gt; to this class, by abstracting out the the concern of timestamping as a dependency, and coupling &lt;code&gt;MyLogger&lt;/code&gt; only to a simple interface:</source>
          <target state="translated">그러나 타임 스탬프 문제를 종속성으로 추상화하고 &lt;code&gt;MyLogger&lt;/code&gt; 를 간단한 인터페이스에만 연결하여 &lt;code&gt;DIP&lt;/code&gt; 를이 클래스에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d76ed5465c1e8ece422b3fde5fc9eac7b93e015" translate="yes" xml:space="preserve">
          <source>We can see a wide variety of application of this pattern in our day to day life.
Some of the examples are Tape recorder, VCD, CD Drive etc.</source>
          <target state="translated">우리는 일상 생활에서이 패턴의 다양한 적용을 볼 수 있습니다. 테이프 레코더, VCD, CD 드라이브 등이 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="699f2807e416a1b822a3e5508ecc546ba1097cee" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to hard code the object using new keyword rather define the bean dependency in the configuration file. The spring container will be responsible for hooking up all.</source>
          <target state="translated">new 키워드를 사용하여 오브젝트를 하드 코딩 할 필요는 없으며 구성 파일에서 Bean 종속성을 정의하십시오. 스프링 컨테이너는 모든 연결을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="e6a519ea1c63ceedd483bc62f122abf4b1705040" translate="yes" xml:space="preserve">
          <source>We just call that passing parameters into the constructor. We've been doing that regularly ever since constructors were invented.</source>
          <target state="translated">우리는 그 전달 매개 변수를 생성자에 호출합니다. 우리는 생성자가 발명 된 이후로 정기적으로 해왔습니다.</target>
        </trans-unit>
        <trans-unit id="4939eb99c093f041eb14a0ea96bcb8652ea8525e" translate="yes" xml:space="preserve">
          <source>What if I want to change the object at runtime? For example, my config already says when I instantiate MyController, inject for FileLogger as ILogger. But I might want to inject DatabaseLogger.</source>
          <target state="translated">런타임에 객체를 변경하려면 어떻게합니까? 예를 들어, MyController를 인스턴스화 할 때 구성에 이미 FileLogger를 ILogger로 주입한다고 말합니다. 그러나 DatabaseLogger를 주입하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2750129099d2d658ea524bc22e6b383e10d747" translate="yes" xml:space="preserve">
          <source>What if we want to change the type of its dependent object - say &lt;code&gt;Wheel&lt;/code&gt; - after the initial &lt;code&gt;NepaliRubberWheel()&lt;/code&gt; punctures?
We need to recreate the Car object with its new dependency say &lt;code&gt;ChineseRubberWheel()&lt;/code&gt;, but only the &lt;code&gt;Car&lt;/code&gt; manufacturer can do that.</source>
          <target state="translated">초기 &lt;code&gt;NepaliRubberWheel()&lt;/code&gt; 펑크 후 종속 객체의 유형 (예 : &lt;code&gt;Wheel&lt;/code&gt; ) 을 변경하려면 어떻게해야합니까? 우리는 &lt;code&gt;ChineseRubberWheel()&lt;/code&gt; 이라는 새로운 의존성을 가지고 Car 객체를 재생성해야하지만 &lt;code&gt;Car&lt;/code&gt; 제조업체 만이 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12d549f3851beb3cde5e7133f1816376aac4516" translate="yes" xml:space="preserve">
          <source>What is dependency Injection?</source>
          <target state="translated">의존성 주입이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2a58e8a199dcdef3591f016058aadf67a10b6ea0" translate="yes" xml:space="preserve">
          <source>What is dependency injection</source>
          <target state="translated">의존성 주입이란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="96816fe77c474fe522ad8e991ee6edf78f7425c0" translate="yes" xml:space="preserve">
          <source>When to use DI : I would recommend using DI in almost all production projects ( small/big), particularly in ever changing business environments :)</source>
          <target state="translated">DI 사용시기 : 거의 모든 프로덕션 프로젝트 (소규모 / 대규모), 특히 끊임없이 변화하는 비즈니스 환경에서 DI를 사용하는 것이 좋습니다. :)</target>
        </trans-unit>
        <trans-unit id="f48ccb208f603d34093b9d2e0d7b264d9656e30f" translate="yes" xml:space="preserve">
          <source>When to use? I would say whenever the application is large enough that encapsulating logic into separate modules, with a dependency graph between the modules gives a gain in readability and explorability of the code.</source>
          <target state="translated">언제 사용합니까? 응용 프로그램이 로직을 별도의 모듈로 캡슐화 할 수있을만큼 충분히 클 때마다 모듈 간의 종속성 그래프를 통해 코드의 가독성과 탐색 성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="eed4b47b27cb37bd0ec38f924963811f2806030d" translate="yes" xml:space="preserve">
          <source>When using dependency injection, objects are given their dependencies &lt;em&gt;at run time rather than compile time (car manufacturing time)&lt;/em&gt;.
So that we can now change the &lt;code&gt;Wheel&lt;/code&gt; whenever we want. Here, the &lt;code&gt;dependency&lt;/code&gt; (&lt;code&gt;wheel&lt;/code&gt;) can be injected into &lt;code&gt;Car&lt;/code&gt; at run time.</source>
          <target state="translated">의존성 주입을 사용할 때 객체는 &lt;em&gt;컴파일 타임 (자동차 제조 시간)이 아닌 런타임에&lt;/em&gt; 종속성 &lt;em&gt;을 갖습니다&lt;/em&gt; . 이제 언제든지 원할 때 &lt;code&gt;Wheel&lt;/code&gt; 변경할 수 있습니다. 여기서, &lt;code&gt;dependency&lt;/code&gt; ( &lt;code&gt;wheel&lt;/code&gt; )은 런타임에 &lt;code&gt;Car&lt;/code&gt; 에 주입 될 수있다.</target>
        </trans-unit>
        <trans-unit id="abc4d8921a46969ecc613e5055f52eca2c65ee07" translate="yes" xml:space="preserve">
          <source>When we change &lt;code&gt;Service&lt;/code&gt; constructor, we need to change code in all place create &lt;code&gt;Service&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;Service&lt;/code&gt; 생성자를 변경할 때 모든 곳에서 코드를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="60a4437333ad60740280d7819cb15d4da2c92233" translate="yes" xml:space="preserve">
          <source>When you change the &lt;code&gt;Service&lt;/code&gt;, you only need to change it in Injector class</source>
          <target state="translated">&lt;code&gt;Service&lt;/code&gt; 를 변경할 때 인젝터 클래스에서만 서비스 를 변경하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f19469b25d4ea3f9876fe4907b1de5c966b79296" translate="yes" xml:space="preserve">
          <source>When you have a configuration of DI where all the actual implementations(not interfaces) that are going to be injected into a class (for e.g services to a controller) why is that not some sort of hard-coding?</source>
          <target state="translated">클래스에 주입 될 모든 실제 구현 (인터페이스가 아닌) (예 : 컨트롤러에 대한 서비스)에 DI 구성이있는 경우 왜 일종의 하드 코딩이 아닌가?</target>
        </trans-unit>
        <trans-unit id="e0e2e926020e782ca430259f6c4e7d67c44e4d4d" translate="yes" xml:space="preserve">
          <source>When you use some constant like a database name you'd quickly move it from the inside of the code to some config file and pass a variable containing that value to the place where it is needed.  The reason to do that is that these constants usually change more frequently than the rest of the code.  For example if you'd like to test the code in a test database.</source>
          <target state="translated">데이터베이스 이름과 같은 상수를 사용하면 코드 내부에서 구성 파일로 빠르게 이동하고 해당 값을 포함하는 변수를 필요한 위치로 전달합니다. 그렇게하는 이유는 이러한 상수가 일반적으로 나머지 코드보다 자주 변경되기 때문입니다. 예를 들어 테스트 데이터베이스에서 코드를 테스트하려는 경우.</target>
        </trans-unit>
        <trans-unit id="f13093462f2a85a2c0797285aa9864b8c2e8b0bb" translate="yes" xml:space="preserve">
          <source>Where there likely will be a need to substitute a dependency for an equivalent implementation,</source>
          <target state="translated">동등한 구현을 위해 종속성을 대체해야 할 가능성이있는 경우,</target>
        </trans-unit>
        <trans-unit id="bd97b161d9e5c8373340c65f6128ec2d5bcf0fbe" translate="yes" xml:space="preserve">
          <source>Where uncertainty of the lifespan of a dependency may warrant experimentation (e.g. Hey, &lt;code&gt;MyDepClass&lt;/code&gt; is thread safe - what if we make it a singleton and inject the same instance into all consumers?)</source>
          <target state="translated">의존성 수명의 불확실성이 실험을 보장 할 수있는 경우 (예 : &lt;code&gt;MyDepClass&lt;/code&gt; 는 스레드로부터 안전합니다. 싱글 톤으로 만들고 모든 인스턴스에 동일한 인스턴스를 주입하면 어떻게 되나요?)</target>
        </trans-unit>
        <trans-unit id="59a5dadbd1f1b46c880e4228a933e3575c4621e6" translate="yes" xml:space="preserve">
          <source>Whereas after application of the DIP, the requirement is loosened, and the concern of obtaining and managing the lifespan of the &lt;code&gt;Foo&lt;/code&gt; dependency has been removed:</source>
          <target state="translated">DIP를 적용한 후 요구 사항이 완화되고 &lt;code&gt;Foo&lt;/code&gt; 종속성의 수명을 확보하고 관리 할 필요가 없어졌습니다.</target>
        </trans-unit>
        <trans-unit id="2f8fd3870a84afb43d089851d3d66aefbefd8208" translate="yes" xml:space="preserve">
          <source>While designing a system it require a reel to record or playback sound or music. There are two possibilities for designing this system</source>
          <target state="translated">시스템을 설계하는 동안 사운드 나 음악을 녹음하거나 재생하려면 릴이 필요합니다. 이 시스템을 설계 할 수있는 두 가지 가능성이 있습니다</target>
        </trans-unit>
        <trans-unit id="f24455302b22cf5f3be2af86011a77cc94c7bdb3" translate="yes" xml:space="preserve">
          <source>Why : Because you want your code to be easily testable, mockable etc so that you can quickly test your changes and push it to the market. Besides why would you not when you there are lots of awesome free tools/frameworks to support you in your journey to a codebase where you have more control.</source>
          <target state="translated">이유 : 변경 사항을 신속하게 테스트하고 시장에 적용 할 수 있도록 코드를 쉽게 테스트하고 조롱 할 수 있기를 원하기 때문입니다. 게다가 더 많은 제어가 가능한 코드베이스로의 여행을 지원하는 멋진 무료 도구 / 프레임 워크가 많이있을 때 왜 그렇지 않겠습니까?</target>
        </trans-unit>
        <trans-unit id="155c0f309806e222f377eeb338deeddb4ac2035d" translate="yes" xml:space="preserve">
          <source>Why does PersonService no longer have to worry about GroupMembershipService? You just mentioned GroupMembership has multiple things(objects/properties) it depends on. If GMService was required in PService, you'd have it as a property. You can mock that out regardless of whether you injected it or not. The only time I'd like it to be injected is if GMService had more specific child classes, which you wouldn't know until runtime. Then you'd want to inject the subclass. Or if you wanted to use that as either singleton or prototype. To be honest, the configuration file has everything hardcoded as far as what subclass for a type (interface) it is going to inject during compile time.</source>
          <target state="translated">PersonService가 더 이상 GroupMembershipService에 대해 걱정할 필요가없는 이유는 무엇입니까? 방금 GroupMembership에 의존하는 여러 가지 (개체 / 속성)가 있다고 언급했습니다. PService에 GMService가 필요한 경우 속성으로 사용합니다. 주사 여부에 관계없이 그것을 조롱 할 수 있습니다. GMService에 더 구체적인 하위 클래스가 있는지 런타임에만 알 수 있습니다. 런타임까지 알 수 없었습니다. 그런 다음 서브 클래스를 주입하려고합니다. 또는 싱글 톤 또는 프로토 타입으로 사용하려는 경우. 솔직히 말해서, 구성 파일에는 컴파일 타임 동안 어떤 유형 (인터페이스)의 서브 클래스에 어떤 서브 클래스가 삽입 될 수 있는지에 대한 모든 것이 하드 코딩되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="316cb2abaec2a090bd29421bce7b593838a6bd08" translate="yes" xml:space="preserve">
          <source>With Dependency Injection</source>
          <target state="translated">의존성 주입</target>
        </trans-unit>
        <trans-unit id="1233c83a1bf8dee2cadec4b76cd3eec49f5d8602" translate="yes" xml:space="preserve">
          <source>With Dependency Injection, instead of instantiating the &lt;code&gt;GroupMembershipService&lt;/code&gt; within your &lt;code&gt;PersonService&lt;/code&gt;, you'd either pass it in to the &lt;code&gt;PersonService&lt;/code&gt; constructor, or else add a Property (getter and setter) to set a local instance of it. This means that your &lt;code&gt;PersonService&lt;/code&gt; no longer has to worry about how to create a &lt;code&gt;GroupMembershipService&lt;/code&gt;, it just accepts the ones it's given, and works with them.  This also means that anything which is a subclass of &lt;code&gt;GroupMembershipService&lt;/code&gt;, or implements the &lt;code&gt;GroupMembershipService&lt;/code&gt; interface can be &quot;injected&quot; into the &lt;code&gt;PersonService&lt;/code&gt;, and the &lt;code&gt;PersonService&lt;/code&gt; doesn't need to know about the change.</source>
          <target state="translated">Dependency Injection을 사용하면 &lt;code&gt;GroupMembershipService&lt;/code&gt; 내에서 GroupMembershipService 를 인스턴스화하는 대신 &lt;code&gt;PersonService&lt;/code&gt; 생성자에 전달하거나 속성 (getter 및 setter)을 추가하여 로컬 인스턴스를 설정할 수 있습니다. 즉, &lt;code&gt;PersonService&lt;/code&gt; 는 더 이상 &lt;code&gt;GroupMembershipService&lt;/code&gt; 를 작성하는 방법에 대해 걱정할 필요가 없으며 제공된 것을 승인하고 함께 작동합니다. 이는 또한 &lt;code&gt;GroupMembershipService&lt;/code&gt; 의 서브 클래스이거나 &lt;code&gt;GroupMembershipService&lt;/code&gt; 인터페이스를 구현하는 것은 PersonService에 &quot;주입&quot;될 수 있으며 &lt;code&gt;PersonService&lt;/code&gt; 는 변경에 대해 알 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0f0a3b5beff6045bb4f3fe845c538ad21014ce5e" translate="yes" xml:space="preserve">
          <source>With Dependency injection, the dependency injector will take off the instantiation for us</source>
          <target state="translated">의존성 주입을 사용하면 의존성 인젝터가 인스턴스화를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="55cdf21af285a1570d5d341608f193842fd5a672" translate="yes" xml:space="preserve">
          <source>With dependency injection, someone else takes care of all the preparation and makes the required equipment available to you. You will receive (&quot;be injected&quot;) the boat, the fishing rod and the bait - all ready to use.</source>
          <target state="translated">의존성 주입을 사용하면 다른 사람이 모든 준비를 처리하고 필요한 장비를 사용할 수 있습니다. 보트, 낚싯대 및 미끼를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f5cf6442cf84c858a561c2c1aa9e63fe5c3866" translate="yes" xml:space="preserve">
          <source>Without Dependency Injection</source>
          <target state="translated">의존성 주입없이</target>
        </trans-unit>
        <trans-unit id="3b220ed590066bbf10e392ad2dd726fec3be4180" translate="yes" xml:space="preserve">
          <source>Without dependency injection, you need to take care of everything yourself. You need to find a boat, to buy a fishing rod, to look for bait, etc. It's possible, of course, but it puts a lot of responsibility on you. In software terms, it means that you have to perform a lookup for all these things.</source>
          <target state="translated">의존성 주입이 없으면 모든 것을 스스로 관리해야합니다. 보트를 찾고, 낚싯대를 구입하고, 미끼 등을 찾는 것이 필요합니다. 물론 가능하지만, 그것은 당신에게 많은 책임을 부여합니다. 소프트웨어 용어로,이 모든 것을 찾아야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49f49ef1de77737ae4e3ae770e87d4b807452cda" translate="yes" xml:space="preserve">
          <source>Without the DIP, our code (I've called this 'consuming class') is directly coupled to a concrete dependency and is also often burdened with the responsibility of knowing how to obtain, and manage, an instance of this dependency, i.e. conceptually:</source>
          <target state="translated">DIP가 없으면 우리의 코드 (이 '소비 클래스'라고 불렀습니다)는 구체적인 의존성에 직접 연결되며 종종이 의존성의 인스턴스를 얻고 관리하는 방법을 아는 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b0617f8014f1a76dc7ba00100921c6326f40868" translate="yes" xml:space="preserve">
          <source>You can also read</source>
          <target state="translated">당신은 또한 읽을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e84e5e5caa3f2b230be8ecf0ca3d63c1bcbc6707" translate="yes" xml:space="preserve">
          <source>You could have injected dependency which implements &lt;code&gt;archive_files&lt;/code&gt; using &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tar&lt;/code&gt; 또는 &lt;code&gt;xz&lt;/code&gt; 를 사용하여 &lt;code&gt;archive_files&lt;/code&gt; 를 구현하는 종속성을 삽입했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c14f594f01f1de9fd2aab048e30d8d2194a66f7" translate="yes" xml:space="preserve">
          <source>You define &lt;code&gt;archive_files&lt;/code&gt; in &lt;code&gt;archive_files_zip.sh&lt;/code&gt; implementation script (using &lt;code&gt;zip&lt;/code&gt; in this case):</source>
          <target state="translated">&lt;code&gt;archive_files_zip.sh&lt;/code&gt; 구현 스크립트에서 archive_files를 정의합니다 (이 경우 &lt;code&gt;zip&lt;/code&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="7444b1acde932a72f7dd1189c7b8bfd322ca3632" translate="yes" xml:space="preserve">
          <source>You don't need a container to do dependency injection. However a container can help you.</source>
          <target state="translated">의존성 주입을 수행하기 위해 컨테이너가 필요하지 않습니다. 그러나 컨테이너가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbf99c4996fccfe9e7a0ac73dbccffb4a67c6cea" translate="yes" xml:space="preserve">
          <source>a DI Container is a tool to help injecting dependencies</source>
          <target state="translated">DI 컨테이너는 의존성 주입을 돕는 도구입니다</target>
        </trans-unit>
        <trans-unit id="4a4aad97c907cbb008e7b8b26d6f30985b32b8aa" translate="yes" xml:space="preserve">
          <source>application &lt;strong&gt;deployment&lt;/strong&gt; (&lt;strong&gt;multiple&lt;/strong&gt; target environments with independent lifecycles)</source>
          <target state="translated">응용 프로그램 &lt;strong&gt;배포&lt;/strong&gt; (독립 수명주기가있는 &lt;strong&gt;여러&lt;/strong&gt; 대상 환경)</target>
        </trans-unit>
        <trans-unit id="a32ef176365fadc9778959691ce81fd982d81b42" translate="yes" xml:space="preserve">
          <source>application &lt;strong&gt;development&lt;/strong&gt; (&lt;strong&gt;single&lt;/strong&gt; source code release lifecycle)</source>
          <target state="translated">응용 프로그램 &lt;strong&gt;개발&lt;/strong&gt; ( &lt;strong&gt;단일&lt;/strong&gt; 소스 코드 릴리스 수명주기)</target>
        </trans-unit>
        <trans-unit id="c2ae11a3ef2bc13a293ffe2bcc4ea4cf9c7088db" translate="yes" xml:space="preserve">
          <source>before doing a</source>
          <target state="translated">하기 전에</target>
        </trans-unit>
        <trans-unit id="fb1802bd1e16e969815bc074b7285e09e6c78cfd" translate="yes" xml:space="preserve">
          <source>from Book &lt;strong&gt;Apress.Spring.Persistence.with.Hibernate.Oct.2010&lt;/strong&gt;</source>
          <target state="translated">Book &lt;strong&gt;Apress.Spring.Persistence.with.Hibernate.2010 년 10 월&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="472f32380d47285104826da06f61443568994b00" translate="yes" xml:space="preserve">
          <source>mapping between each abstraction and the configured concrete implementation (e.g. &lt;em&gt;&quot;any time a consumer requests an &lt;code&gt;IBar&lt;/code&gt;, return a &lt;code&gt;ConcreteBar&lt;/code&gt; instance&quot;&lt;/em&gt;)</source>
          <target state="translated">각 추상화와 구성된 구체적 구현 사이의 매핑 (예 : &lt;em&gt;&quot;소비자가 &lt;code&gt;IBar&lt;/code&gt; 를 요청할 때마다 &lt;code&gt;ConcreteBar&lt;/code&gt; 인스턴스를 반환&quot;&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="a89dcdc02705c87126898e6ee6b1fbd5bdb0786f" translate="yes" xml:space="preserve">
          <source>policies can be set up for the lifespan management of each dependency, e.g. to create a new object for each consumer instance, to share a singleton dependency instance across all consumers, to share the same dependency instance only across the same thread, etc.</source>
          <target state="translated">정책은 각 종속 인스턴스의 수명 관리를 위해 설정 될 수 있습니다 (예 : 각 소비자 인스턴스에 대한 새 객체 생성, 모든 소비자간에 싱글 톤 종속성 인스턴스 공유, 동일한 스레드에서만 동일한 종속성 인스턴스 공유 등).</target>
        </trans-unit>
        <trans-unit id="036711eff2961f7a9eb870a48ad40790feff55dd" translate="yes" xml:space="preserve">
          <source>we can place the reel inside the machine</source>
          <target state="translated">기계 안에 릴을 놓을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0a91593e00bce6f1bb48c8658c6f3c6f186cbbf2" translate="yes" xml:space="preserve">
          <source>we can provide a hook for the reel where it can be placed.</source>
          <target state="translated">릴을 놓을 수있는 고리를 제공 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
