<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/7074">
    <body>
      <group id="7074">
        <trans-unit id="228d68628714cc2360e68afeab589f17918ce691" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;System.String&lt;/code&gt;&quot; a.k.a &quot;String&quot; ( capital &quot;S&quot;) is a &lt;code&gt;.NET&lt;/code&gt; framework data type while &quot;string&quot; is a &lt;code&gt;C#&lt;/code&gt; data type.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;System.String&lt;/code&gt; &amp;raquo; или &amp;laquo;String&amp;raquo; (заглавная &amp;laquo;S&amp;raquo;) - это тип данных &lt;code&gt;.NET&lt;/code&gt; а &amp;laquo;string&amp;raquo; - это тип данных &lt;code&gt;C#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66dc7eeaeac7b1a7dc09e3938dafceafda64d5d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;This YouTube&lt;/a&gt; video demonstrates practically how they differ.</source>
          <target state="translated">&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;Это&lt;/a&gt; видео на YouTube демонстрирует, насколько они отличаются.</target>
        </trans-unit>
        <trans-unit id="26f52da3f6db7a342ae3830a5e6491f9174f7950" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; is an alias in C# for &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; является псевдонимом в C # для &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b042ac29881f76cecc22db88fda9a3b4320d85be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (a developer on the C# compiler and prolific SO user!) wrote a &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;great blog post&lt;/a&gt; on this issue. I think it is worth sharing here. It is a nice perspective on our subject.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (разработчик компилятора C # и плодотворный пользователь SO!) Написал &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;отличную запись в блоге&lt;/a&gt; на эту тему. Я думаю, что здесь стоит поделиться. Это хороший взгляд на нашу тему.</target>
        </trans-unit>
        <trans-unit id="e63e166e9fed4ca1e3a3e31ed1fd9eabcb1c9955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; is not a keyword and it can be used as Identifier whereas &lt;code&gt;string&lt;/code&gt; is a keyword and cannot be used as Identifier. And in function point of view both are same.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; не является ключевым словом и может использоваться в качестве идентификатора, тогда как &lt;code&gt;string&lt;/code&gt; является ключевым словом и не может использоваться в качестве идентификатора. И с функциональной точки зрения оба одинаковы.</target>
        </trans-unit>
        <trans-unit id="b90e7af3ecb39b51fb79fa8592f0f1d9ae9ddcb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; stands for &lt;code&gt;System.String&lt;/code&gt; and it is a .NET Framework type. &lt;strong&gt;&lt;code&gt;string&lt;/code&gt; is an alias&lt;/strong&gt; in the C# language for  &lt;code&gt;System.String&lt;/code&gt;. Both of them are compiled to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt; in IL&lt;/strong&gt; (Intermediate Language), so there is no difference. Choose what you like and use that. If you code in C#, I'd prefer &lt;code&gt;string&lt;/code&gt; as it's a C# type alias and well-known by C# programmers.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; означает &lt;code&gt;System.String&lt;/code&gt; , и это тип .NET Framework. &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; является псевдонимом&lt;/strong&gt; в языке C # для &lt;code&gt;System.String&lt;/code&gt; . Оба они скомпилированы в &lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; в IL&lt;/strong&gt; (промежуточный язык), поэтому нет никакой разницы. Выберите то, что вам нравится, и используйте это. Если вы пишете код на C #, я бы предпочел &lt;code&gt;string&lt;/code&gt; ,так как это псевдоним C # и хорошо известен программистам C #.</target>
        </trans-unit>
        <trans-unit id="21dfdc708b7c6d9ddde1026c9f823a48e07357f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System.String&lt;/code&gt; is the .NET string class - in C# &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt; - so in use they are the same.</source>
          <target state="translated">&lt;code&gt;System.String&lt;/code&gt; является классом строки .NET - в C # &lt;code&gt;string&lt;/code&gt; является псевдонимом для &lt;code&gt;System.String&lt;/code&gt; - поэтому при использовании они совпадают.</target>
        </trans-unit>
        <trans-unit id="e4be40d094b8761d8b0a8af7779ee11906a863a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are identical in all ways (except the uppercase &quot;S&quot;).  There are no performance implications either way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; и &lt;code&gt;String&lt;/code&gt; идентичны во всех отношениях (кроме заглавной буквы &quot;S&quot;). В любом случае нет никаких последствий для производительности.</target>
        </trans-unit>
        <trans-unit id="d8840747d529a1ab2e607b537ad66fd66839abb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is a reserved word, but &lt;code&gt;String&lt;/code&gt; is just a class name. 
This means that &lt;code&gt;string&lt;/code&gt; cannot be used as a variable name by itself.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; - зарезервированное слово, а &lt;code&gt;String&lt;/code&gt; - просто имя класса. Это означает, что &lt;code&gt;string&lt;/code&gt; не может быть использована как имя переменной сама по себе.</target>
        </trans-unit>
        <trans-unit id="da5062e4b9764acaa414144e97820d32c0973476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is an alias (or shorthand) of &lt;code&gt;System.String&lt;/code&gt;. That means, by typing &lt;code&gt;string&lt;/code&gt; we meant &lt;code&gt;System.String&lt;/code&gt;. You can read more in think link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string' is an alias/shorthand of System.String.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; является псевдонимом (или сокращением) &lt;code&gt;System.String&lt;/code&gt; . Это означает, что при вводе &lt;code&gt;string&lt;/code&gt; мы имели в виду &lt;code&gt;System.String&lt;/code&gt; . Вы можете прочитать больше в Think Link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'строка' является псевдонимом / сокращением System.String.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d8e4bba708dfba56ed459601d498e8840f3e123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is just an alias for &lt;code&gt;System.String&lt;/code&gt;. The compiler will treat them identically.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; просто псевдоним для &lt;code&gt;System.String&lt;/code&gt; . Компилятор будет относиться к ним одинаково.</target>
        </trans-unit>
        <trans-unit id="f084ec9e9d82162f7fbc5659d6f160720497365a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; is not a style debate</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; против &lt;code&gt;String&lt;/code&gt; не дебаты о стиле</target>
        </trans-unit>
        <trans-unit id="255b406fa6b9e0823de8f80e3455112e9d159128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt; is a type in the CLR.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; является типом в CLR.</target>
        </trans-unit>
        <trans-unit id="26877e9563383a6b546ae7a361569c47dfb9f7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; is a type in C#.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; является типом в C #.</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="012b988247360c0d3de48ea273a8db4bf1d33c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the million dollar question from programmer's point of view So when to use &quot;String&quot; and &quot;string&quot;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Теперь вопрос на миллион долларов с точки зрения программиста. Так когда же использовать &amp;laquo;String&amp;raquo; и &amp;laquo;string&amp;raquo;?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c0d1a72db9895ccfb9110378ecf99a8542224" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String&lt;/strong&gt; is not a keyword, and you can use it as an identifier:</source>
          <target state="translated">&lt;strong&gt;Строка&lt;/strong&gt; не является ключевым словом, и вы можете использовать ее в качестве идентификатора:</target>
        </trans-unit>
        <trans-unit id="0b0d36dbb427e4a1a0640b4c1188d84e0f6b2c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is one difference&lt;/strong&gt; - you can't use &lt;code&gt;String&lt;/code&gt; without &lt;code&gt;using System;&lt;/code&gt; beforehand.</source>
          <target state="translated">&lt;strong&gt;Есть одно отличие&lt;/strong&gt; - вы не можете использовать &lt;code&gt;String&lt;/code&gt; без &lt;code&gt;using System;&lt;/code&gt; заранее.</target>
        </trans-unit>
        <trans-unit id="cbf2f4931f55b8ad0bf613d33ab6ad8bddf5c12a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;string&lt;/strong&gt; is a keyword, and you can't use string as an identifier.</source>
          <target state="translated">&lt;strong&gt;Строка&lt;/strong&gt; является ключевым словом, и вы не можете использовать строку в качестве идентификатора.</target>
        </trans-unit>
        <trans-unit id="b9559fcbc971e124aaf1fe39290213f4b148f9ba" translate="yes" xml:space="preserve">
          <source>Against what seems to be common practice among other programmers, I prefer &lt;code&gt;String&lt;/code&gt; over &lt;code&gt;string&lt;/code&gt;, just to highlight the fact that &lt;code&gt;String&lt;/code&gt; is a reference type, as Jon Skeet mentioned.</source>
          <target state="translated">Против того, что кажется обычной практикой среди других программистов, я предпочитаю &lt;code&gt;String&lt;/code&gt; ,а не &lt;code&gt;string&lt;/code&gt; , просто чтобы подчеркнуть тот факт, что &lt;code&gt;String&lt;/code&gt; является ссылочным типом, как упоминал Джон Скит.</target>
        </trans-unit>
        <trans-unit id="fdb501029b56570afb94f9ed29293d4141dc5953" translate="yes" xml:space="preserve">
          <source>All the predefined types  are mapped directly to
  underlying .NET types. The C# type names (string) are simply aliases for the
  .NET types (String or System.String), so using the .NET names works fine syntactically, although
  this is discouraged. Within a C# program, you should use the C# names
  rather than the .NET names.</source>
          <target state="translated">Все предопределенные типы сопоставляются непосредственно с лежащими в основе .NET типами.Имена (строки)типов C#являются просто псевдонимами для .NET-типов (String или System.String),поэтому использование .NET-имён работает отлично синтаксически,хотя это не рекомендуется.Внутри программы на C#следует использовать имена C#,а не .NET имена.</target>
        </trans-unit>
        <trans-unit id="d98984153e55855cca8c4e5f7e443623850db2b0" translate="yes" xml:space="preserve">
          <source>Also, now, when I see &quot;int&quot; or &quot;string&quot;, it just looks really wrong to me, like I'm looking at 1970's C code.</source>
          <target state="translated">Также,теперь,когда я вижу &quot;int&quot; или &quot;string&quot;,это выглядит очень неправильно для меня,как будто я смотрю на код C 1970 года.</target>
        </trans-unit>
        <trans-unit id="c77c986c978db50c2edb1530b6d7604bb90ae875" translate="yes" xml:space="preserve">
          <source>Another critical difference: Stack Overflow highlights them differently.</source>
          <target state="translated">Еще одна критическая разница:Переполнение стека выделяет их по-другому.</target>
        </trans-unit>
        <trans-unit id="337038535cd28955eae1f640e7096e40e7631b25" translate="yes" xml:space="preserve">
          <source>Another way to visualize the difference is with this sample:</source>
          <target state="translated">Другой способ визуализировать разницу-с помощью этого примера:</target>
        </trans-unit>
        <trans-unit id="a60b6da79539bdc8b7cb297451feb7d858cf6d80" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, the aliases are all to value types. &lt;code&gt;decimal&lt;/code&gt; is a value type, but not a primitive type in the CLR. The only primitive type which doesn't have an alias is &lt;code&gt;System.IntPtr&lt;/code&gt;.</source>
          <target state="translated">Помимо &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;object&lt;/code&gt; , псевдонимы относятся к типам значений. &lt;code&gt;decimal&lt;/code&gt; тип значения, но не примитивный тип в CLR. Единственный примитивный тип, у которого нет псевдонима, это &lt;code&gt;System.IntPtr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbcd6fabeac0fa1e903b96ce302d37cc9ab55a9" translate="yes" xml:space="preserve">
          <source>As far as guidelines, it's generally recommended to use &lt;code&gt;string&lt;/code&gt; any time you're referring to an object.</source>
          <target state="translated">Что касается рекомендаций, обычно рекомендуется использовать &lt;code&gt;string&lt;/code&gt; каждый раз, когда вы ссылаетесь на объект.</target>
        </trans-unit>
        <trans-unit id="0d8db7a7da3c8e55c6ef7583c26653161b5963c8" translate="yes" xml:space="preserve">
          <source>As for guidelines I wouldn't get too bogged down and just use whichever you feel like - there are more important things in life and the code is going to be the same anyway.</source>
          <target state="translated">Что касается руководящих принципов,то я бы не стал слишком сбиваться с толку и просто использую то,что считаешь нужным-в жизни есть вещи поважнее,и код все равно будет один и тот же.</target>
        </trans-unit>
        <trans-unit id="49f6b692ecbc8ab730cec2fc66a93ce1d36c6a77" translate="yes" xml:space="preserve">
          <source>As others have noted, &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;. They compile to the same code, so at execution time there is no difference whatsoever. This is just one of the aliases in C#. The complete list is:</source>
          <target state="translated">Как уже отмечали другие, &lt;code&gt;string&lt;/code&gt; является псевдонимом для &lt;code&gt;System.String&lt;/code&gt; . Они компилируются в один и тот же код, поэтому во время выполнения нет никакой разницы. Это только один из псевдонимов в C #. Полный список:</target>
        </trans-unit>
        <trans-unit id="dfd1c1e7e5f7162b6737b19a1d23e4b8e738b888" translate="yes" xml:space="preserve">
          <source>As the others are saying, they're the same.  StyleCop rules, by default, will enforce you to use &lt;code&gt;string&lt;/code&gt; as a C# code style best practice, except when referencing &lt;code&gt;System.String&lt;/code&gt; static functions, such as &lt;code&gt;String.Format&lt;/code&gt;, &lt;code&gt;String.Join&lt;/code&gt;, &lt;code&gt;String.Concat&lt;/code&gt;, etc...</source>
          <target state="translated">Как говорят другие, они одинаковы. Правила StyleCop по умолчанию заставляют вас использовать &lt;code&gt;string&lt;/code&gt; в качестве передовой практики стиля кода C #, за исключением случаев обращения к статическим функциям &lt;code&gt;System.String&lt;/code&gt; , таким как &lt;code&gt;String.Format&lt;/code&gt; , &lt;code&gt;String.Join&lt;/code&gt; , &lt;code&gt;String.Concat&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="d3e69bc36fcde9e95937ddabcf28d8aa1e3d28c7" translate="yes" xml:space="preserve">
          <source>Both are same. But from coding guidelines perspective it's better to use &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;. This is what generally developers use. e.g. instead of using &lt;code&gt;Int32&lt;/code&gt; we use &lt;code&gt;int&lt;/code&gt; as &lt;code&gt;int&lt;/code&gt; is alias to &lt;code&gt;Int32&lt;/code&gt;</source>
          <target state="translated">Оба одинаковы. Но с точки зрения правил кодирования лучше использовать &lt;code&gt;string&lt;/code&gt; вместо &lt;code&gt;String&lt;/code&gt; . Это то, что обычно используют разработчики. Например, вместо &lt;code&gt;Int32&lt;/code&gt; мы используем &lt;code&gt;int&lt;/code&gt; ,так как &lt;code&gt;int&lt;/code&gt; является псевдонимом &lt;code&gt;Int32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a99bfdab95ac5c2ba17b81950872e8650ba272" translate="yes" xml:space="preserve">
          <source>But now for a long textual answer.</source>
          <target state="translated">Но теперь,чтобы получить длинный текстовый ответ.</target>
        </trans-unit>
        <trans-unit id="bf90ee429ac8f8bc62dfdefed6e11fb05e6fc23e" translate="yes" xml:space="preserve">
          <source>C# is a language which is used together with the CLR.</source>
          <target state="translated">C#-это язык,который используется вместе с CLR.</target>
        </trans-unit>
        <trans-unit id="9d5c764a1acaa5b5bcb96101fe97b4133de42c33" translate="yes" xml:space="preserve">
          <source>Coming late to the party: I use the CLR types 100% of the time (well, except if &lt;em&gt;forced&lt;/em&gt; to use the C# type, but I don't remember when the last time that was).</source>
          <target state="translated">Опаздываю на вечеринку: я использую типы CLR 100% времени (ну, за исключением случаев, когда &lt;em&gt;вынужден&lt;/em&gt; использовать тип C #, но я не помню, когда это было в последний раз).</target>
        </trans-unit>
        <trans-unit id="84b6fa77f09cddf191ebef51dd09349c2e4423ea" translate="yes" xml:space="preserve">
          <source>Conditional and control keywords (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;) are lowercase and colored dark blue (by default). And I would rather not have the disagreement in use and format.</source>
          <target state="translated">Условные и управляющие ключевые слова (например, &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; и &lt;code&gt;return&lt;/code&gt; ) строчные и темно-синие (по умолчанию). И я бы предпочел не иметь разногласий в использовании и формате.</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="63cf87d7199d567617ea4b6ca5ec4e87620d8625" translate="yes" xml:space="preserve">
          <source>Example (&lt;em&gt;note the case&lt;/em&gt;):</source>
          <target state="translated">Пример ( &lt;em&gt;обратите внимание на случай&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="52936f8d320a5c9edae9467890ff6b3835ae84b6" translate="yes" xml:space="preserve">
          <source>FYI
&amp;ldquo;The keyword string is simply an alias for the predefined class &lt;code&gt;System.String&lt;/code&gt;.&amp;rdquo; - C# Language Specification 4.2.3
&lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</source>
          <target state="translated">К сведению &amp;laquo;Строка ключевого слова - это просто псевдоним для предопределенного класса &lt;code&gt;System.String&lt;/code&gt; &amp;raquo;. - Спецификация языка C # 4.2.3 &lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58792e3b925f31858fc5ea747e687bdc0f62a6ae" translate="yes" xml:space="preserve">
          <source>Finally, when it comes to which to use: personally I use the aliases everywhere for the implementation, but the CLR type for any APIs. It really doesn't matter too much which you use in terms of implementation - consistency among your team is nice, but no-one else is going to care. On the other hand, it's genuinely important that if you refer to a type in an API, you do so in a language-neutral way. A method called &lt;code&gt;ReadInt32&lt;/code&gt; is unambiguous, whereas a method called &lt;code&gt;ReadInt&lt;/code&gt; requires interpretation. The caller could be using a language that defines an &lt;code&gt;int&lt;/code&gt; alias for &lt;code&gt;Int16&lt;/code&gt;, for example. The .NET framework designers have followed this pattern, good examples being in the &lt;code&gt;BitConverter&lt;/code&gt;, &lt;code&gt;BinaryReader&lt;/code&gt; and &lt;code&gt;Convert&lt;/code&gt; classes.</source>
          <target state="translated">Наконец, когда дело доходит до использования: лично я использую псевдонимы везде для реализации, но тип CLR для любых API. На самом деле не имеет большого значения, что вы используете с точки зрения реализации - согласованность в вашей команде - это хорошо, но больше никого не волнует. С другой стороны, действительно важно, что если вы ссылаетесь на тип в API, вы делаете это не зависящим от языка способом. Метод с именем &lt;code&gt;ReadInt32&lt;/code&gt; является однозначным, тогда как метод с именем &lt;code&gt;ReadInt&lt;/code&gt; требует интерпретации. Вызывающий может использовать язык, который определяет псевдоним &lt;code&gt;int&lt;/code&gt; для &lt;code&gt;Int16&lt;/code&gt; , например. Разработчики фреймворка .NET следовали этому шаблону, хорошие примеры были в &lt;code&gt;BitConverter&lt;/code&gt; , &lt;code&gt;BinaryReader&lt;/code&gt; и &lt;code&gt;Convert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361f354e3c112924a67a6cd4e52c6912aa86f34b" translate="yes" xml:space="preserve">
          <source>First thing to avoid confusion use one of them consistently. But from best practices perspective when you do variable declaration it's good to use &quot;string&quot; ( small &quot;s&quot;) and when you are using it as a class name then &quot;String&quot; ( capital &quot;S&quot;) is preferred.</source>
          <target state="translated">Во-первых,чтобы избежать путаницы,используйте один из них последовательно.Но с точки зрения лучшей практики,когда вы делаете объявление переменных,хорошо использовать &quot;string&quot; (маленькие &quot;s&quot;),а когда вы используете его в качестве имени класса,то предпочтительно &quot;String&quot; (заглавная &quot;S&quot;).</target>
        </trans-unit>
        <trans-unit id="901ba968f95a818d5303d46cf8a18ecd2e7bfdd0" translate="yes" xml:space="preserve">
          <source>First, when &lt;code&gt;String&lt;/code&gt; is a &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt; of the current type (or a local variable):</source>
          <target state="translated">Во-первых, когда &lt;code&gt;String&lt;/code&gt; является &lt;strong&gt;&lt;em&gt;значением&lt;/em&gt;&lt;/strong&gt; текущего типа (или локальной переменной):</target>
        </trans-unit>
        <trans-unit id="ee5cc7375a72753d04afe3ef92339bdd63c94ee7" translate="yes" xml:space="preserve">
          <source>I can say the same about &lt;strong&gt;(&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;System.Int32&lt;/code&gt;)&lt;/strong&gt; etc..</source>
          <target state="translated">То же самое можно сказать о &lt;strong&gt;( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;System.Int32&lt;/code&gt; ) и&lt;/strong&gt; т. Д.</target>
        </trans-unit>
        <trans-unit id="ea3e61270f6cf9945f0a83b40b68501c8a543b14" translate="yes" xml:space="preserve">
          <source>I didn't get his opinion before I read the complete paragraph.</source>
          <target state="translated">Я не получил его мнения до того,как прочитал полный абзац.</target>
        </trans-unit>
        <trans-unit id="d5494c0741861941dbb77b1154505ecd11f5b5b3" translate="yes" xml:space="preserve">
          <source>I originally started doing this years ago, as per the CLR books by Ritchie. It made sense to me that all CLR languages ultimately have to be able to support the set of CLR types, so using the CLR types yourself provided clearer, and possibly more &quot;reusable&quot; code.</source>
          <target state="translated">Изначально я начал делать это много лет назад,согласно книгам Ричи CLR.Для меня было понятно,что все языки CLR,в конечном счете,должны поддерживать набор типов CLR,поэтому использование самих CLR-типов обеспечило более ясный и,возможно,более &quot;многоразовый&quot; код.</target>
        </trans-unit>
        <trans-unit id="b41709e8dc275dd7834960616cb7974a5926cbc8" translate="yes" xml:space="preserve">
          <source>I prefer the capitalized &lt;code&gt;.NET&lt;/code&gt; types (rather than the aliases) for formatting reasons. The &lt;code&gt;.NET&lt;/code&gt; types are colored the same as other object types (the value types are proper objects, after all).</source>
          <target state="translated">Я предпочитаю прописные типы &lt;code&gt;.NET&lt;/code&gt; (а не псевдонимы) по причинам форматирования. Типы &lt;code&gt;.NET&lt;/code&gt; окрашиваются так же, как и другие типы объектов (в конце концов, типы значений являются собственными объектами).</target>
        </trans-unit>
        <trans-unit id="5a239d3ab937b3004575ec484c47a6e4ed49e68f" translate="yes" xml:space="preserve">
          <source>I shall provide two examples where &lt;em&gt;&lt;code&gt;using&lt;/code&gt; directives will not help&lt;/em&gt;.</source>
          <target state="translated">Я приведу два примера, где &lt;em&gt; &lt;code&gt;using&lt;/code&gt; директив не поможет&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa93903e288f3d4e16cf4bb1f90b96f48052393" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt;
  or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# &lt;strong&gt;string&lt;/strong&gt; (a keyword) maps exactly to
  &lt;strong&gt;System.String&lt;/strong&gt; (an FCL type), there is no difference and either can be used. Similarly,
  I&amp;rsquo;ve heard some developers say that &lt;strong&gt;int&lt;/strong&gt; represents a 32-bit integer when the application
  is running on a 32-bit OS and that it represents a 64-bit integer when the application
  is running on a 64-bit OS. This statement is absolutely false: in C#, an &lt;strong&gt;int&lt;/strong&gt; always maps
  to &lt;strong&gt;System.Int32&lt;/strong&gt;, and therefore it represents a 32-bit integer regardless of the OS the
  code is running on. If programmers would use &lt;strong&gt;Int32&lt;/strong&gt; in their code, then this potential
  confusion is also eliminated.</source>
          <target state="translated">Я видел, что некоторые разработчики были сбиты с толку, не зная, использовать ли в своем коде &lt;strong&gt;строку&lt;/strong&gt; или &lt;strong&gt;строку&lt;/strong&gt; . Поскольку в C # &lt;strong&gt;строка&lt;/strong&gt; (ключевое слово) отображается точно на &lt;strong&gt;System.String&lt;/strong&gt; (тип FCL), нет никакой разницы, и любой из них может быть использован. Точно так же я слышал, что некоторые разработчики говорят, что &lt;strong&gt;int&lt;/strong&gt; представляет 32-разрядное целое число, когда приложение работает в 32-разрядной ОС, и что оно представляет 64-разрядное целое число, когда приложение выполняется в 64-разрядной ОС. Это утверждение абсолютно неверно: в C # &lt;strong&gt;int&lt;/strong&gt; всегда отображается на &lt;strong&gt;System.Int32&lt;/strong&gt; , и поэтому оно представляет 32-разрядное целое число независимо от ОС, в которой выполняется код. Если программисты будут использовать &lt;strong&gt;Int32&lt;/strong&gt; в своем коде, то эта потенциальная путаница также устраняется.</target>
        </trans-unit>
        <trans-unit id="fa954e4cefc7a46db782057de61937b12e9e5aed" translate="yes" xml:space="preserve">
          <source>I'd just like to add this to lfousts answer, from Ritchers book:</source>
          <target state="translated">Я просто хотел бы добавить это к ответу lfousts,из книги Ритчеров:</target>
        </trans-unit>
        <trans-unit id="21899fca0863f132973844812fab0c779022a7b9" translate="yes" xml:space="preserve">
          <source>I've seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt; or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# the string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used.</source>
          <target state="translated">Я видел, что некоторые разработчики были сбиты с толку, не зная, использовать ли в своем коде &lt;strong&gt;строку&lt;/strong&gt; или &lt;strong&gt;строку&lt;/strong&gt; . Поскольку в C # строка (ключевое слово) отображается точно в System.String (тип FCL), нет никакой разницы, и любой из них может быть использован.</target>
        </trans-unit>
        <trans-unit id="6b7d898ac30d5c92342d8ac9760039cee7099d78" translate="yes" xml:space="preserve">
          <source>If for some reason you wanted a variable called &lt;em&gt;string&lt;/em&gt;, you'd see only the first of these compiles:</source>
          <target state="translated">Если по какой-то причине вам нужна переменная с именем &lt;em&gt;string&lt;/em&gt; , вы увидите только первый из этих компиляций:</target>
        </trans-unit>
        <trans-unit id="4415225af42f5d012580c28bcbef4acf554c9d6c" translate="yes" xml:space="preserve">
          <source>If you find yourselves building systems where it is necessary to specify the size of the integers you are using and so tend to use &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt; etc. then it might look more natural to use &lt;code&gt;String&lt;/code&gt; - and when moving around between different .net languages it might make things more understandable - otherwise I would use string and int.</source>
          <target state="translated">Если вы обнаружите, что строите системы, в которых необходимо указать размер используемых вами целых чисел, и, как правило, используете &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;UInt16&lt;/code&gt; , &lt;code&gt;UInt32&lt;/code&gt; и т. Д., Тогда может показаться более естественным использование &lt;code&gt;String&lt;/code&gt; - и при перемещении между различными Языки .net это может сделать вещи более понятными - в противном случае я бы использовал string и int.</target>
        </trans-unit>
        <trans-unit id="fc3d0d8990fb3765be09111a7c669c84b913e5c0" translate="yes" xml:space="preserve">
          <source>If you really want a variable name called &lt;em&gt;string&lt;/em&gt; you can use &lt;code&gt;@&lt;/code&gt; as a prefix:</source>
          <target state="translated">Если вам действительно нужно имя переменной с именем &lt;em&gt;string,&lt;/em&gt; вы можете использовать &lt;code&gt;@&lt;/code&gt; в качестве префикса:</target>
        </trans-unit>
        <trans-unit id="5da7f23835ffc9c6b22e25e2d55eb0854a9abafa" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt;
  could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does treat &lt;strong&gt;long&lt;/strong&gt; as an &lt;strong&gt;Int32&lt;/strong&gt;.
  Someone reading source code in one language could easily misinterpret the code&amp;rsquo;s
  intention if he or she were used to programming in a different programming language.
  In fact, most languages won&amp;rsquo;t even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won&amp;rsquo;t compile code
  that uses it.</source>
          <target state="translated">В C # &lt;strong&gt;long&lt;/strong&gt; отображается на &lt;strong&gt;System.Int64&lt;/strong&gt; , но на другом языке программирования &lt;strong&gt;long&lt;/strong&gt; может отображаться на &lt;strong&gt;Int16&lt;/strong&gt; или &lt;strong&gt;Int32&lt;/strong&gt; . На самом деле, C ++ / CLI долго обрабатывает &lt;strong&gt;Int32&lt;/strong&gt; . Кто-то, читающий исходный код на одном языке, может легко неверно истолковать намерение кода, если он или она привыкли к программированию на другом языке программирования. На самом деле, большинство языков даже не будут рассматривать ключевое слово &lt;strong&gt;долго&lt;/strong&gt; и не будут компилировать код, который его использует.</target>
        </trans-unit>
        <trans-unit id="c34719d5baf69cca85f742773fbc5ad7584b58a0" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt; could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does in fact treat long as an &lt;strong&gt;Int32&lt;/strong&gt;. Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language. In fact, most languages won't even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won't compile code that uses it.</source>
          <target state="translated">В C # &lt;strong&gt;long&lt;/strong&gt; отображается на &lt;strong&gt;System.Int64&lt;/strong&gt; , но на другом языке программирования &lt;strong&gt;long&lt;/strong&gt; может отображаться на &lt;strong&gt;Int16&lt;/strong&gt; или &lt;strong&gt;Int32&lt;/strong&gt; . Фактически, C ++ / CLI фактически обрабатывает долго как &lt;strong&gt;Int32&lt;/strong&gt; . Кто-то, читающий исходный код на одном языке, может легко неверно истолковать намерение кода, если он или она привыкли к программированию на другом языке программирования. На самом деле, большинство языков даже не будут рассматривать ключевое слово &lt;strong&gt;долго&lt;/strong&gt; и не будут компилировать код, который его использует.</target>
        </trans-unit>
        <trans-unit id="7b36107e9559a09694a8183cb99815886d4e78c3" translate="yes" xml:space="preserve">
          <source>In short &quot;String&quot; is an alias ( the same thing called with different names) of &quot;string&quot;. So technically both the below code statements will give the same output.</source>
          <target state="translated">Короче говоря,&quot;String&quot;-это псевдоним (то же самое,что называется с разными именами)&quot;string&quot;.Так что технически оба нижеприведенных выражения кода дадут один и тот же результат.</target>
        </trans-unit>
        <trans-unit id="e6dc65980fe8a04364550bf8267b4a0752724591" translate="yes" xml:space="preserve">
          <source>In the below code the left hand side is a variable declaration and it declared using &quot;string&quot;. At the right hand side we are calling a method so &quot;String&quot; is more sensible.</source>
          <target state="translated">В приведенном ниже коде слева находится объявление переменной и оно объявлено с помощью &quot;string&quot;.С правой стороны мы вызываем метод,поэтому &quot;строка&quot; более разумна.</target>
        </trans-unit>
        <trans-unit id="f98303445c332e612954049bbaf882f4fa3cb7e9" translate="yes" xml:space="preserve">
          <source>In the same way there are aliases for other c# data type as shown below:-</source>
          <target state="translated">Точно так же существуют псевдонимы для других типов данных c#,как показано ниже:-</target>
        </trans-unit>
        <trans-unit id="57dee12da4dec3aa9f4c4e8403aa2ad08617efcc" translate="yes" xml:space="preserve">
          <source>In the spec, the value type aliases are known as &quot;simple types&quot;. Literals can be used for constant values of every simple type; no other value types have literal forms available. (Compare this with VB, which allows &lt;code&gt;DateTime&lt;/code&gt; literals, and has an alias for it too.)</source>
          <target state="translated">В спецификации псевдонимы типа значения известны как &amp;laquo;простые типы&amp;raquo;. Литералы могут использоваться для постоянных значений любого простого типа; никакие другие типы значений не имеют доступных литеральных форм. (Сравните это с VB, который допускает литералы &lt;code&gt;DateTime&lt;/code&gt; и также имеет псевдоним.)</target>
        </trans-unit>
        <trans-unit id="483cab40a51898204e58cfed265106143d7f4953" translate="yes" xml:space="preserve">
          <source>It appears that the guidance in this area may have changed, as &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; now enforces the use of the C# specific aliases.</source>
          <target state="translated">Похоже, что руководство в этой области, возможно, изменилось, так как &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; теперь принудительно использует специальные псевдонимы C #.</target>
        </trans-unit>
        <trans-unit id="ff67dae909a99ee9a9e7def47187588639f45a8f" translate="yes" xml:space="preserve">
          <source>It's a matter of convention, really.  &lt;code&gt;string&lt;/code&gt; just looks more like C/C++ style.  The general convention is to use whatever shortcuts your chosen language has provided (int/Int for &lt;code&gt;Int32&lt;/code&gt;).  This goes for &quot;object&quot; and &lt;code&gt;decimal&lt;/code&gt; as well.</source>
          <target state="translated">Это действительно условно. &lt;code&gt;string&lt;/code&gt; просто больше похожа на стиль C / C ++. Общее соглашение состоит в том, чтобы использовать любые ярлыки, которые предоставил выбранный вами язык (int / Int для &lt;code&gt;Int32&lt;/code&gt; ). Это относится и к &amp;laquo;объекту&amp;raquo;, и к &lt;code&gt;decimal&lt;/code&gt; типу.</target>
        </trans-unit>
        <trans-unit id="3838b064aeaafbf213d49b0394cdd6a50f24ba3e" translate="yes" xml:space="preserve">
          <source>It's been covered above; however, you can't use &lt;code&gt;string&lt;/code&gt; in reflection; you must use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Это было покрыто выше; однако вы не можете использовать &lt;code&gt;string&lt;/code&gt; в отражении; Вы должны использовать &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e09d862931ec0e2748cdc4ff36fc4d9cad4e1d6a" translate="yes" xml:space="preserve">
          <source>Just for the sake of completeness, here's a brain dump of related information...</source>
          <target state="translated">Просто для полноты,вот свалка сопутствующей информации...</target>
        </trans-unit>
        <trans-unit id="5e78ed6411bc19fbcef0b5786cecd66b3134b765" translate="yes" xml:space="preserve">
          <source>Likewise, I think it's generally recommended to use &lt;code&gt;String&lt;/code&gt; if you need to refer specifically to the class.</source>
          <target state="translated">Точно так же я думаю, что обычно рекомендуется использовать &lt;code&gt;String&lt;/code&gt; , если вам нужно обратиться именно к классу.</target>
        </trans-unit>
        <trans-unit id="bc04acca921cef20c01ada3297aed735cee9b09f" translate="yes" xml:space="preserve">
          <source>Lower case &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;.
They are the same in &lt;code&gt;C#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; нижнем регистре является псевдонимом для &lt;code&gt;System.String&lt;/code&gt; . Они одинаковы в &lt;code&gt;C#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa9ccdfd7c726f6e226b0942c75a549ff6e70b5d" translate="yes" xml:space="preserve">
          <source>Lowercase &lt;code&gt;string&lt;/code&gt; is preferred in most projects due to the syntax highlighting</source>
          <target state="translated">Строчная строчка предпочтительнее в большинстве проектов из-за подсветки синтаксиса</target>
        </trans-unit>
        <trans-unit id="b6133573d560cd3eea08983f58c0042a25059f55" translate="yes" xml:space="preserve">
          <source>Many programmers that use C# exclusively tend to forget that other programming
  languages can be used against the CLR, and because of this, C#-isms creep into the
  class library code. For example, Microsoft&amp;rsquo;s FCL is almost exclusively written in C# and
  developers on the FCL team have now introduced methods into the library such as
  &lt;strong&gt;Array&lt;/strong&gt;&amp;rsquo;s &lt;strong&gt;GetLongLength&lt;/strong&gt;, which returns an &lt;strong&gt;Int64&lt;/strong&gt; value that is a &lt;strong&gt;long&lt;/strong&gt; in C# but not
  in other languages (like C++/CLI). Another example is &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;&amp;rsquo;s
  &lt;strong&gt;LongCount&lt;/strong&gt; method.</source>
          <target state="translated">Многие программисты, использующие исключительно C #, склонны забывать, что другие языки программирования могут использоваться против CLR, и из-за этого C # -измы заползают в код библиотеки классов. Например, Microsoft FCL почти полностью написана на C #, и разработчики из команды FCL теперь ввели в библиотеку методы, такие как &lt;strong&gt;GetLongLength&lt;/strong&gt; &lt;strong&gt;Array&lt;/strong&gt; , который возвращает значение &lt;strong&gt;Int64,&lt;/strong&gt; которое является &lt;strong&gt;длинным&lt;/strong&gt; в C #, но не в других языках (таких как C ++). / CLI). Другим примером является метод &lt;strong&gt;LongCount&lt;/strong&gt; &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9df02f88b75a5ae9238b00816debf524d9b6d4bb" translate="yes" xml:space="preserve">
          <source>Many will argue that while this is information technically accurate using &lt;code&gt;String&lt;/code&gt; is still fine because it&amp;rsquo;s exceedingly rare that a code base would define a type of this name. Or that when &lt;code&gt;String&lt;/code&gt; is defined it&amp;rsquo;s a sign of a bad code base.</source>
          <target state="translated">Многие утверждают, что, хотя технически точная информация является правильной, использование &lt;code&gt;String&lt;/code&gt; все же хорошо, потому что крайне редко кодовая база определяет тип этого имени. Или, когда определено &lt;code&gt;String&lt;/code&gt; , это признак плохой базы кода.</target>
        </trans-unit>
        <trans-unit id="4969c66ffc5656f3999a26d516caf717157af60a" translate="yes" xml:space="preserve">
          <source>Neither statement in the &lt;code&gt;Example&lt;/code&gt; method compiles. Here &lt;code&gt;String&lt;/code&gt; is always a piano &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;string&lt;/a&gt;, &lt;code&gt;MyPiano.String&lt;/code&gt;. No member (&lt;code&gt;static&lt;/code&gt; or not) &lt;code&gt;Format&lt;/code&gt; exists on it (or is inherited from its base class). And the value &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; cannot be converted into it.</source>
          <target state="translated">Ни один оператор в методе &lt;code&gt;Example&lt;/code&gt; не компилируется. Здесь &lt;code&gt;String&lt;/code&gt; - это всегда фортепианная &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;струна&lt;/a&gt; &lt;code&gt;MyPiano.String&lt;/code&gt; . Отсутствует член ( &lt;code&gt;static&lt;/code&gt; или нет) &lt;code&gt;Format&lt;/code&gt; существует на нем (или унаследован от его базового класса). И значение &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; не может быть преобразовано в него.</target>
        </trans-unit>
        <trans-unit id="2fa06e504f29a303da31352f8e430b6dc30c1883" translate="yes" xml:space="preserve">
          <source>New answer after 6 years and 5 months (procrastination).</source>
          <target state="translated">Новый ответ через 6 лет и 5 месяцев (отсрочка).</target>
        </trans-unit>
        <trans-unit id="296daf449bf0c8664c9e6d199847c7929ad529f1" translate="yes" xml:space="preserve">
          <source>Note: I copy/pasted most of the blog post for archive reason. I ignore some parts, so I recommend to skip and to read the &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;blog post&lt;/a&gt; if you can.</source>
          <target state="translated">Примечание: я скопировал / вставил большую часть сообщения блога по причине архива. Я игнорирую некоторые части, поэтому я рекомендую пропустить и прочитать &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;сообщение&lt;/a&gt; в блоге, если можете.</target>
        </trans-unit>
        <trans-unit id="022ba2779e8f9a2cb535c438e2a28ea7b0dd3e80" translate="yes" xml:space="preserve">
          <source>Now that I've been doing it for years, it's a habit and I like the coloration that VS shows for the CLR types.</source>
          <target state="translated">Теперь,когда я делаю это в течение многих лет,это привычка,и мне нравится цвет,который VS показывает для CLR-типов.</target>
        </trans-unit>
        <trans-unit id="b3ab40a90e383fb18e0e975a4f3ebb4b8b3eaeff" translate="yes" xml:space="preserve">
          <source>Secondly, when &lt;code&gt;String&lt;/code&gt; is another &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, nested inside the current type:</source>
          <target state="translated">Во-вторых, когда &lt;code&gt;String&lt;/code&gt; является другим &lt;strong&gt;&lt;em&gt;типом&lt;/em&gt;&lt;/strong&gt; , вложенным в текущий тип:</target>
        </trans-unit>
        <trans-unit id="e101d4a69cdea700b7d60c87527fa5d12e284702" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;int&lt;/code&gt; maps to &lt;code&gt;System.Int32&lt;/code&gt;.</source>
          <target state="translated">Аналогично, &lt;code&gt;int&lt;/code&gt; сопоставляется с &lt;code&gt;System.Int32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="689346a590d26a7f24b31d23dd2fbc483406fd3b" translate="yes" xml:space="preserve">
          <source>So remember when you see the &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; debate this is about semantics, not style. Choosing string gives crisp meaning to your code base. Choosing &lt;code&gt;String&lt;/code&gt; isn&amp;rsquo;t wrong but it&amp;rsquo;s leaving the door open for surprises in the future.</source>
          <target state="translated">Поэтому помните, что когда вы видите дебаты &amp;laquo; &lt;code&gt;String&lt;/code&gt; против &lt;code&gt;string&lt;/code&gt; , речь идет о семантике, а не о стиле. Выбор строки дает четкий смысл вашей кодовой базе. Выбор &lt;code&gt;String&lt;/code&gt; не является неправильным, но он оставляет дверь открытой для сюрпризов в будущем.</target>
        </trans-unit>
        <trans-unit id="9cb50509dd63b7929b71e5a34e498aabbd13f875" translate="yes" xml:space="preserve">
          <source>So technically, there is no difference.  It's like &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt;&lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Технически нет никакой разницы. Это как &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;em&gt;против&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2325db982bbc83b6294b8c0dff80dba26d189b" translate="yes" xml:space="preserve">
          <source>So there you have it. I think these are all really good points. I however, don't find myself using Jeffrey's advice in my own code. Maybe I am too stuck in my C# world but I end up trying to make my code look like the framework code.</source>
          <target state="translated">Итак,вот оно.Я думаю,что все это действительно хорошие очки.Однако,я не использую советы Джеффри в моем собственном коде.Может быть,я слишком застрял в своём мире C#,но в конце концов я пытаюсь сделать свой код похожим на код фреймворка.</target>
        </trans-unit>
        <trans-unit id="84d84cfed9ed57bbe7f2bacafbaddfb81576cf17" translate="yes" xml:space="preserve">
          <source>String (&lt;code&gt;System.String&lt;/code&gt;) is a class in the base class library. string (lower case) is a reserved work in C# that is an alias for System.String. Int32 vs int is a similar situation as is &lt;code&gt;Boolean vs. bool&lt;/code&gt;. These C# language specific keywords enable you to declare primitives in a style similar to C.</source>
          <target state="translated">String ( &lt;code&gt;System.String&lt;/code&gt; ) - это класс в библиотеке базовых классов. Строка (нижний регистр) - это зарезервированная работа в C #, которая является псевдонимом для System.String. Int32 vs int - ситуация, аналогичная &lt;code&gt;Boolean vs. bool&lt;/code&gt; . Эти ключевые слова для языка C # позволяют объявлять примитивы в стиле, аналогичном C.</target>
        </trans-unit>
        <trans-unit id="49ce6a3b5fc76630de40afb2fe0abba3f193580b" translate="yes" xml:space="preserve">
          <source>That's just a matter of the way the spec defines enum declarations - the part after the colon has to be the &lt;em&gt;integral-type&lt;/em&gt; production, which is one token of &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;... as opposed to a &lt;em&gt;type&lt;/em&gt; production as used by variable declarations for example. It doesn't indicate any other difference.</source>
          <target state="translated">Это просто вопрос того, как спецификация определяет объявления enum - часть после двоеточия должна быть продукцией &lt;em&gt;целочисленного типа&lt;/em&gt; , которая является одним токеном &lt;code&gt;sbyte&lt;/code&gt; , &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;ushort&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;uint&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;ulong&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; . ... в отличие от производства &lt;em&gt;типа,&lt;/em&gt; используемого, например, объявлениями переменных. Это не указывает на другие различия.</target>
        </trans-unit>
        <trans-unit id="57cd8f4f9cafb98e0ff1960638924dc3de76b39d" translate="yes" xml:space="preserve">
          <source>The C# keyword &lt;code&gt;string&lt;/code&gt; maps to the .NET type &lt;code&gt;System.String&lt;/code&gt; - it is an alias that keeps to the naming conventions of the language.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; ключевого слова C # соответствует типу .NET &lt;code&gt;System.String&lt;/code&gt; - это псевдоним, который соответствует соглашениям об именах языка.</target>
        </trans-unit>
        <trans-unit id="f49eb70607b2497b91d8c266445436a4abe3155d" translate="yes" xml:space="preserve">
          <source>The C# language specification states, &amp;ldquo;As a matter of style, use of the keyword is favored over
  use of the complete system type name.&amp;rdquo; I disagree with the language specification; I prefer
  to use the FCL type names and completely avoid the primitive type names. In fact, I wish that
  compilers didn&amp;rsquo;t even offer the primitive type names and forced developers to use the FCL
  type names instead. Here are my reasons:</source>
          <target state="translated">Спецификация языка C # гласит: &amp;laquo;По стилю, использование ключевого слова предпочтительнее, чем использование полного имени типа системы&amp;raquo;. Я не согласен с языковой спецификацией; Я предпочитаю использовать имена типов FCL и полностью избегать имен примитивных типов. На самом деле, я бы хотел, чтобы компиляторы даже не предлагали имена примитивных типов и заставляли разработчиков использовать вместо них имена типов FCL. Вот мои причины:</target>
        </trans-unit>
        <trans-unit id="fce2e5a5f468c7b1c34cd9768434166999ddbdb0" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For
  example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;,
  &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as
  &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it&amp;rsquo;s legal to write the following
  code, the line with &lt;strong&gt;float&lt;/strong&gt; feels very unnatural to me, and it&amp;rsquo;s not obvious that the line is
  correct:</source>
          <target state="translated">В FCL есть много методов, имена которых являются частью имен их методов. Например, тип &lt;strong&gt;BinaryReader&lt;/strong&gt; предлагает такие методы, как &lt;strong&gt;ReadBoolean&lt;/strong&gt; , &lt;strong&gt;ReadInt32&lt;/strong&gt; , &lt;strong&gt;ReadSingle&lt;/strong&gt; и т. Д., А тип &lt;strong&gt;System.Convert&lt;/strong&gt; предлагает такие методы, как &lt;strong&gt;ToBoolean&lt;/strong&gt; , &lt;strong&gt;ToInt32&lt;/strong&gt; , &lt;strong&gt;ToSingle&lt;/strong&gt; и т. Д. Хотя написать следующий код законно, строка с &lt;strong&gt;плавающей точкой&lt;/strong&gt; мне кажется неестественной, и не очевидно, что строка правильная:</target>
        </trans-unit>
        <trans-unit id="d241e925f9c6c70e65ab7201f55f79ecdaebf9ce" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;, &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it's legal to write the following code, the line with float feels very unnatural to me, and it's not obvious that the line is correct:</source>
          <target state="translated">В FCL есть много методов, имена которых являются частью имен их методов. Например, тип &lt;strong&gt;BinaryReader&lt;/strong&gt; предлагает такие методы, как &lt;strong&gt;ReadBoolean&lt;/strong&gt; , &lt;strong&gt;ReadInt32&lt;/strong&gt; , &lt;strong&gt;ReadSingle&lt;/strong&gt; и т. Д., А тип &lt;strong&gt;System.Convert&lt;/strong&gt; предлагает такие методы, как &lt;strong&gt;ToBoolean&lt;/strong&gt; , &lt;strong&gt;ToInt32&lt;/strong&gt; , &lt;strong&gt;ToSingle&lt;/strong&gt; и т. Д. Хотя написать следующий код законно, строка с плавающей точкой мне кажется неестественной, и не очевидно, что строка правильная:</target>
        </trans-unit>
        <trans-unit id="245547d31df063b9be5afb5f9f9e26bb654e9990" translate="yes" xml:space="preserve">
          <source>The above will not compile because &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; does not have a non-static member called &lt;code&gt;Format&lt;/code&gt;, and no extension methods apply. In the above case, it may still be possible to use &lt;code&gt;String&lt;/code&gt; in other contexts where a &lt;em&gt;type&lt;/em&gt; is the only possibility syntactically. For example &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; could be OK (depending on namespace and &lt;code&gt;using&lt;/code&gt; directives).</source>
          <target state="translated">Выше не будет компилироваться, потому что &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; не имеет нестатического члена с именем &lt;code&gt;Format&lt;/code&gt; , и методы расширения не применяются. В вышеупомянутом случае все еще может быть возможно использовать &lt;code&gt;String&lt;/code&gt; в других контекстах, где &lt;em&gt;тип&lt;/em&gt; является единственной возможностью синтаксически. Например &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; может быть в порядке (в зависимости от пространства имен и &lt;code&gt;using&lt;/code&gt; директив).</target>
        </trans-unit>
        <trans-unit id="8d7a9de8ca807f30e0d84dd6099bf753c98ce135" translate="yes" xml:space="preserve">
          <source>The actual meaning of &lt;code&gt;String&lt;/code&gt; will always depend on name resolution.
  That means it depends on all the source files in the project and all
  the types defined in all the referenced assemblies. In short it
  requires quite a bit of context to &lt;em&gt;know&lt;/em&gt; what it means.</source>
          <target state="translated">Фактическое значение &lt;code&gt;String&lt;/code&gt; всегда будет зависеть от разрешения имени. Это означает, что это зависит от всех исходных файлов в проекте и всех типов, определенных во всех ссылочных сборках. Короче говоря, для &lt;em&gt;понимания&lt;/em&gt; того, что это значит, требуется немало контекста.</target>
        </trans-unit>
        <trans-unit id="93322148b52efc519b4bbcaebbed28fabcc67ec3" translate="yes" xml:space="preserve">
          <source>The best answer I have ever heard about using the provided type aliases in C# comes from Jeffrey Richter in his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C#&lt;/a&gt;. Here are his 3 reasons:</source>
          <target state="translated">Лучший ответ, который я когда-либо слышал об использовании предоставленных псевдонимов типов в C #, дан Джеффри Рихтером в его книге &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C #&lt;/a&gt; . Вот его 3 причины:</target>
        </trans-unit>
        <trans-unit id="04f4e2e05e59044015a06ab9e5709ace1067caeb" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;String&lt;/code&gt; though has no concrete meaning in C#. It is an identifier that goes through all the name lookup rules as &lt;code&gt;Widget&lt;/code&gt;, &lt;code&gt;Student&lt;/code&gt;, etc &amp;hellip; It could bind to string or it could bind to a type in another assembly entirely whose purposes may be entirely different than &lt;code&gt;string&lt;/code&gt;. Worse it could be defined in a way such that code like &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt;; continued to compile.</source>
          <target state="translated">Хотя идентификатор &lt;code&gt;String&lt;/code&gt; не имеет конкретного значения в C #. Это идентификатор, который проходит через все правила поиска имен, такие как &lt;code&gt;Widget&lt;/code&gt; , &lt;code&gt;Student&lt;/code&gt; и т. Д. Он может связываться со строкой или связываться с типом в другой сборке, цели которого могут полностью отличаться от &lt;code&gt;string&lt;/code&gt; . Хуже того, это может быть определено таким образом, чтобы код типа &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt; ; продолжил компилировать.</target>
        </trans-unit>
        <trans-unit id="3f48daaabbe068f8c313923060dc1ce87907e97a" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt;  is an alias for
 &lt;code&gt;System.String&lt;/code&gt; aside from the keyword issue, the two are exactly
 equivalent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; ключевого слова является псевдонимом для &lt;code&gt;System.String&lt;/code&gt; , кроме вопроса о ключевых словах, они в точности эквивалентны.</target>
        </trans-unit>
        <trans-unit id="d5c514298559badf24fce9b8b392cc6d91008feb" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt; has concrete meaning in C#. It is the type &lt;code&gt;System.String&lt;/code&gt; which exists in the core runtime assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings in .NET. Its presence is so critical to C# that if that type doesn&amp;rsquo;t exist the compiler will exit before attempting to even parse a line of code. Hence &lt;code&gt;string&lt;/code&gt; has a precise, unambiguous meaning in C# code.</source>
          <target state="translated">Ключевое слово &lt;code&gt;string&lt;/code&gt; имеет конкретное значение в C #. Это тип &lt;code&gt;System.String&lt;/code&gt; , который существует в основной сборке времени выполнения. Среда выполнения по сути понимает этот тип и предоставляет возможности, ожидаемые разработчиками для строк в .NET. Его присутствие настолько критично для C #, что, если этот тип не существует, компилятор завершит работу, прежде чем пытаться даже проанализировать строку кода. Следовательно, &lt;code&gt;string&lt;/code&gt; имеет точное, однозначное значение в коде C #.</target>
        </trans-unit>
        <trans-unit id="baaf13d4a47a17e15308fe16fb596475d6a15088" translate="yes" xml:space="preserve">
          <source>The only practical difference is the syntax highlighting as you mention, and that you have to write &lt;code&gt;using System&lt;/code&gt; if you use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Единственное практическое отличие - это выделение синтаксиса, как вы упомянули, и то, что вы должны писать &lt;code&gt;using System&lt;/code&gt; если вы используете &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8668abfb621e1b2a22882756e57d856bcfbf3e47" translate="yes" xml:space="preserve">
          <source>The only real downer is that auto-complete uses the C# type, so I end up re-typing automatically generated types to specify the CLR type instead.</source>
          <target state="translated">Единственным настоящим даунером является то,что auto-complete использует тип C#,поэтому я в конце концов перепечатываю автоматически сгенерированные типы для указания типа CLR вместо него.</target>
        </trans-unit>
        <trans-unit id="9c532ca7d467cf6352c36952f31402d9053b7bfb" translate="yes" xml:space="preserve">
          <source>Theoretically this could help to port code into some future 64-bit standard in which &quot;int&quot; might mean &lt;code&gt;Int64&lt;/code&gt;, but that's not the point, and I would expect any upgrade wizard to change any &lt;code&gt;int&lt;/code&gt; references to &lt;code&gt;Int32&lt;/code&gt; anyway just to be safe.</source>
          <target state="translated">Теоретически это может помочь перенести код в какой-то будущий 64-битный стандарт, в котором &amp;laquo;int&amp;raquo; может означать &lt;code&gt;Int64&lt;/code&gt; , но это не главное, и я ожидаю, что любой мастер обновления в любом случае изменит любые ссылки на &lt;code&gt;int&lt;/code&gt; на int, чтобы быть в безопасности.</target>
        </trans-unit>
        <trans-unit id="1b43e8aad6972ff5253750d89b626a58fe50142a" translate="yes" xml:space="preserve">
          <source>Theoretically, you could implement a C#-compiler that generated Java bytecode. A sensible implementation of this compiler would probably map &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/strong&gt; in order to interoperate with the Java runtime library.</source>
          <target state="translated">Теоретически, вы могли бы реализовать C # -компилятор, который генерировал байт-код Java. Разумная реализация этого компилятора, вероятно, будет отображать &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; в &lt;strong&gt; &lt;code&gt;java.lang.String&lt;/code&gt; &lt;/strong&gt; для взаимодействия с библиотекой времени выполнения Java.</target>
        </trans-unit>
        <trans-unit id="b9cef7d16318b618f7d7e05ce428e421145a3eb1" translate="yes" xml:space="preserve">
          <source>There is no difference.</source>
          <target state="translated">Нет никакой разницы.</target>
        </trans-unit>
        <trans-unit id="e724cb1ff2ea7523a1d7006294c3e2e3b6908113" translate="yes" xml:space="preserve">
          <source>There is one circumstance in which you &lt;em&gt;have&lt;/em&gt; to use the aliases: when explicitly specifying an enum's underlying type. For instance:</source>
          <target state="translated">Есть одно обстоятельство, при котором вы &lt;em&gt;должны&lt;/em&gt; использовать псевдонимы: при явном указании основного типа перечисления. Например:</target>
        </trans-unit>
        <trans-unit id="db457529845002230c6c5b574e656447dd4b91e6" translate="yes" xml:space="preserve">
          <source>There's a debate over whether you should use the System types (&lt;code&gt;System.Int32&lt;/code&gt;, &lt;code&gt;System.String&lt;/code&gt;, etc.) types or the &lt;code&gt;C# aliases&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, etc). I personally believe you should use the &lt;code&gt;C# aliases&lt;/code&gt;, but that's just my personal preference.</source>
          <target state="translated">Спорят о том, следует ли вам использовать типы System ( &lt;code&gt;System.Int32&lt;/code&gt; , &lt;code&gt;System.String&lt;/code&gt; и т. Д.) Или &lt;code&gt;C# aliases&lt;/code&gt; ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; и т. Д.). Я лично считаю, что вы должны использовать &lt;code&gt;C# aliases&lt;/code&gt; , но это только мое личное предпочтение.</target>
        </trans-unit>
        <trans-unit id="591cd0b1a64565e8d55765f16e4e309da97495fb" translate="yes" xml:space="preserve">
          <source>There's a quote on this issue from &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;Daniel Solis' book&lt;/a&gt;.</source>
          <target state="translated">По этому вопросу есть цитата из &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;книги Дэниела Солиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd310fee67eed80e9424306ba0e405b3b78a9e96" translate="yes" xml:space="preserve">
          <source>This is the style that Microsoft tends to use in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;their examples&lt;/a&gt;.</source>
          <target state="translated">Это стиль, который Microsoft стремится использовать в &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;своих примерах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a887af1a34c7a21a8c77639ce417b3bb91f2d6" translate="yes" xml:space="preserve">
          <source>True that in the vast majority of cases &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; will bind to
  the same type. But using &lt;code&gt;String&lt;/code&gt; still means developers are leaving
  their program up to interpretation in places where there is only one
  correct answer. When &lt;code&gt;String&lt;/code&gt; does bind to the wrong type it can leave
  developers debugging for hours, filing bugs on the compiler team and
  generally wasting time that could&amp;rsquo;ve been saved by using &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Правда, в подавляющем большинстве случаев &lt;code&gt;String&lt;/code&gt; и &lt;code&gt;string&lt;/code&gt; будут привязываться к одному типу. Но использование &lt;code&gt;String&lt;/code&gt; все еще означает, что разработчики оставляют свою программу на интерпретацию в местах, где есть только один правильный ответ. Когда &lt;code&gt;String&lt;/code&gt; связывается с неправильным типом, это может привести к тому, что разработчики отладят часы на несколько часов, регистрируя ошибки в команде компилятора и обычно тратя время, которое можно было бы сэкономить с помощью &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080151d9d06a4a0841ea36ef9ee84dcdb90f489e" translate="yes" xml:space="preserve">
          <source>Using System types makes it easier to port between C# and VB.Net, if you are into that sort of thing.</source>
          <target state="translated">Использование типов System облегчает перенос между C#и VB.Net,если вы увлекаетесь подобными вещами.</target>
        </trans-unit>
        <trans-unit id="bbaa6241d89ea80c39692aa3b5ba27d31a981924" translate="yes" xml:space="preserve">
          <source>What are the &lt;strong&gt;&lt;em&gt;guidelines&lt;/em&gt;&lt;/strong&gt; for the use of each? And what are the &lt;strong&gt;&lt;em&gt;differences&lt;/em&gt;&lt;/strong&gt;?</source>
          <target state="translated">Каковы &lt;strong&gt;&lt;em&gt;правила&lt;/em&gt;&lt;/strong&gt; использования каждого из них? И в чем &lt;strong&gt;&lt;em&gt;различия&lt;/em&gt;&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="bd9579b2d38cc31bb5131600b18e1a9c58740e90" translate="yes" xml:space="preserve">
          <source>What is the difference between String and string in C#</source>
          <target state="translated">В чем разница между строкой и строкой в C#</target>
        </trans-unit>
        <trans-unit id="e71d05ee8c65811fde766fc86a9a2312a31589aa" translate="yes" xml:space="preserve">
          <source>When we talk about &lt;code&gt;.NET&lt;/code&gt; there are two different things one there is &lt;code&gt;.NET&lt;/code&gt; framework and the other there are languages ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; etc) which use that framework.</source>
          <target state="translated">Когда мы говорим о &lt;code&gt;.NET&lt;/code&gt; , есть две разные вещи: одна - это &lt;code&gt;.NET&lt;/code&gt; а другая - языки ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; и т. Д.), Которые используют эту среду.</target>
        </trans-unit>
        <trans-unit id="1f3e96542caf20f14fe703e23e36cf1f92b45e0e" translate="yes" xml:space="preserve">
          <source>When you use C# together with the CLR &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; will be mapped to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Когда вы используете C # вместе со &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; CLR, она будет сопоставлена ​​с &lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6da5e0c25b5beda54e8637b0d410f9bcc6da7930" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;string&lt;/code&gt; is a reserved C# keyword that always has a fixed meaning, &lt;code&gt;String&lt;/code&gt; is just an ordinary &lt;em&gt;identifier&lt;/em&gt; which could refer to anything. Depending on members of the current type, the current namespace and the applied &lt;code&gt;using&lt;/code&gt; directives and their placement, &lt;code&gt;String&lt;/code&gt; could be a value or a type distinct from &lt;code&gt;global::System.String&lt;/code&gt;.</source>
          <target state="translated">Хотя &lt;code&gt;string&lt;/code&gt; - это зарезервированное ключевое слово C #, которое всегда имеет фиксированное значение, &lt;code&gt;String&lt;/code&gt; - это просто обычный &lt;em&gt;идентификатор,&lt;/em&gt; который может ссылаться на что угодно. В зависимости от членов текущего типа, текущего пространства имен и применяемых директив &lt;code&gt;using&lt;/code&gt; и их размещения &lt;code&gt;String&lt;/code&gt; может быть значением или типом, отличным от &lt;code&gt;global::System.String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d746517e1decf0d12e57b19ed8b079d7d2ff727" translate="yes" xml:space="preserve">
          <source>Worse: Saying &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; will likely (depending on &lt;code&gt;using&lt;/code&gt;s) go to the Linq extension method &lt;code&gt;Enumerable.Concat&lt;/code&gt;. It will not go to the static method &lt;code&gt;string.Concat&lt;/code&gt;.</source>
          <target state="translated">Хуже того: Saying &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; , скорее всего, (в зависимости от &lt;code&gt;using&lt;/code&gt; s) перейдет к методу расширения Linq &lt;code&gt;Enumerable.Concat&lt;/code&gt; . Это не будет идти к статическому методу &lt;code&gt;string.Concat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="825f170ba301d67aee52cb32cfb74d6313352781" translate="yes" xml:space="preserve">
          <source>Yes, that's no difference between them, just like the &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">Да, между ними нет никакой разницы, как в случае с &lt;code&gt;bool&lt;/code&gt; и &lt;code&gt;Boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bfe5ac3a85fb8412165790973b10eb661d8a34a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that &lt;code&gt;String&lt;/code&gt; is defined for a number of completely valid purposes: reflection helpers, serialization libraries, lexers, protocols, etc &amp;hellip; For any of these libraries &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; has real consequences depending on where the code is used.</source>
          <target state="translated">Вы увидите, что &lt;code&gt;String&lt;/code&gt; определен для ряда полностью допустимых целей: помощников по отражению, библиотек сериализации, лексеров, протоколов и т. Д. Для любой из этих библиотек &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; имеет реальные последствия в зависимости от того, где используется код.</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="7f23f0b182ad02e9f6f6309b506e9b8da87ba491" translate="yes" xml:space="preserve">
          <source>object: &lt;code&gt;System.Object&lt;/code&gt;, string: &lt;code&gt;System.String&lt;/code&gt;, bool: &lt;code&gt;System.Boolean&lt;/code&gt;, byte: &lt;code&gt;System.Byte&lt;/code&gt;, sbyte: &lt;code&gt;System.SByte&lt;/code&gt;, short: &lt;code&gt;System.Int16&lt;/code&gt; and so on</source>
          <target state="translated">объект: &lt;code&gt;System.Object&lt;/code&gt; , строка: &lt;code&gt;System.String&lt;/code&gt; , bool: &lt;code&gt;System.Boolean&lt;/code&gt; , байт: &lt;code&gt;System.Byte&lt;/code&gt; , sbyte: &lt;code&gt;System.SByte&lt;/code&gt; , short: &lt;code&gt;System.Int16&lt;/code&gt; и т. д.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
