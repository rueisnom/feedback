<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/7074">
    <body>
      <group id="7074">
        <trans-unit id="228d68628714cc2360e68afeab589f17918ce691" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;System.String&lt;/code&gt;&quot; a.k.a &quot;String&quot; ( capital &quot;S&quot;) is a &lt;code&gt;.NET&lt;/code&gt; framework data type while &quot;string&quot; is a &lt;code&gt;C#&lt;/code&gt; data type.</source>
          <target state="translated">&quot; &lt;code&gt;System.String&lt;/code&gt; &quot;別名 &quot;String&quot;（大文字の &quot;S&quot;）は &lt;code&gt;.NET&lt;/code&gt; フレームワークのデータ型であり、 &quot;string&quot;は &lt;code&gt;C#&lt;/code&gt; データ型です。</target>
        </trans-unit>
        <trans-unit id="66dc7eeaeac7b1a7dc09e3938dafceafda64d5d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;This YouTube&lt;/a&gt; video demonstrates practically how they differ.</source>
          <target state="translated">&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;このYouTube&lt;/a&gt;ビデオは、実際の違いを示しています。</target>
        </trans-unit>
        <trans-unit id="26f52da3f6db7a342ae3830a5e6491f9174f7950" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; is an alias in C# for &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;はC＃の&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt; &lt;code&gt;System.String&lt;/code&gt; の&lt;/a&gt;エイリアスです。</target>
        </trans-unit>
        <trans-unit id="b042ac29881f76cecc22db88fda9a3b4320d85be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (a developer on the C# compiler and prolific SO user!) wrote a &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;great blog post&lt;/a&gt; on this issue. I think it is worth sharing here. It is a nice perspective on our subject.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; （C＃コンパイラの開発者であり、多作なSOユーザーです！）が、この問題について&lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;素晴らしいブログ投稿&lt;/a&gt;を書いています。 ここで共有する価値があると思います。 それは私たちのテーマについての素晴らしい見方です。</target>
        </trans-unit>
        <trans-unit id="e63e166e9fed4ca1e3a3e31ed1fd9eabcb1c9955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; is not a keyword and it can be used as Identifier whereas &lt;code&gt;string&lt;/code&gt; is a keyword and cannot be used as Identifier. And in function point of view both are same.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; &lt;code&gt;string&lt;/code&gt; はキーワードではなく識別子として使用できますが、 文字列はキーワードであり、識別子としては使用できません。 そして、機能の観点では、両方とも同じです。</target>
        </trans-unit>
        <trans-unit id="b90e7af3ecb39b51fb79fa8592f0f1d9ae9ddcb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; stands for &lt;code&gt;System.String&lt;/code&gt; and it is a .NET Framework type. &lt;strong&gt;&lt;code&gt;string&lt;/code&gt; is an alias&lt;/strong&gt; in the C# language for  &lt;code&gt;System.String&lt;/code&gt;. Both of them are compiled to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt; in IL&lt;/strong&gt; (Intermediate Language), so there is no difference. Choose what you like and use that. If you code in C#, I'd prefer &lt;code&gt;string&lt;/code&gt; as it's a C# type alias and well-known by C# programmers.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; は &lt;code&gt;System.String&lt;/code&gt; を表し、.NET Frameworkタイプです。 &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; は&lt;/strong&gt; C.言語の &lt;code&gt;System.String&lt;/code&gt; の &lt;strong&gt;エイリアス&lt;/strong&gt;です。 どちらも&lt;strong&gt;IL&lt;/strong&gt; （中間言語）の&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; に&lt;/strong&gt;コンパイルされるため、違いはありません。 あなたが好きなものを選んでそれを使ってください。 C＃でコーディングする場合は、C＃タイプのエイリアスであり、C＃プログラマーによく知られている &lt;code&gt;string&lt;/code&gt; をお勧めします。</target>
        </trans-unit>
        <trans-unit id="21dfdc708b7c6d9ddde1026c9f823a48e07357f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System.String&lt;/code&gt; is the .NET string class - in C# &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt; - so in use they are the same.</source>
          <target state="translated">&lt;code&gt;System.String&lt;/code&gt; は.NET文字列クラスです。C＃では、 &lt;code&gt;string&lt;/code&gt; は &lt;code&gt;System.String&lt;/code&gt; のエイリアスです。したがって、使用中は同じです。</target>
        </trans-unit>
        <trans-unit id="e4be40d094b8761d8b0a8af7779ee11906a863a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are identical in all ways (except the uppercase &quot;S&quot;).  There are no performance implications either way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; はすべての点で同じです（大文字の &quot;S&quot;を除く）。 どちらの方法でもパフォーマンスへの影響はありません。</target>
        </trans-unit>
        <trans-unit id="d8840747d529a1ab2e607b537ad66fd66839abb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is a reserved word, but &lt;code&gt;String&lt;/code&gt; is just a class name. 
This means that &lt;code&gt;string&lt;/code&gt; cannot be used as a variable name by itself.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; は予約語ですが、 &lt;code&gt;String&lt;/code&gt; は単なるクラス名です。 つまり、 &lt;code&gt;string&lt;/code&gt; をそれ自体で変数名として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="da5062e4b9764acaa414144e97820d32c0973476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is an alias (or shorthand) of &lt;code&gt;System.String&lt;/code&gt;. That means, by typing &lt;code&gt;string&lt;/code&gt; we meant &lt;code&gt;System.String&lt;/code&gt;. You can read more in think link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string' is an alias/shorthand of System.String.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; は &lt;code&gt;System.String&lt;/code&gt; のエイリアス（または省略形）です。 つまり、 &lt;code&gt;string&lt;/code&gt; を入力するということは、 &lt;code&gt;System.String&lt;/code&gt; を意味するということです。 think linkで詳細を読むことができます： &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string'はSystem.Stringのエイリアス/省略形です。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d8e4bba708dfba56ed459601d498e8840f3e123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is just an alias for &lt;code&gt;System.String&lt;/code&gt;. The compiler will treat them identically.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; は &lt;code&gt;System.String&lt;/code&gt; の単なるエイリアスです。 コンパイラはそれらを同じように扱います。</target>
        </trans-unit>
        <trans-unit id="f084ec9e9d82162f7fbc5659d6f160720497365a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; is not a style debate</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; はスタイルの議論ではありません</target>
        </trans-unit>
        <trans-unit id="255b406fa6b9e0823de8f80e3455112e9d159128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt; is a type in the CLR.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt;はCLRの型です。</target>
        </trans-unit>
        <trans-unit id="26877e9563383a6b546ae7a361569c47dfb9f7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; is a type in C#.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt;はC＃の型です。</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="012b988247360c0d3de48ea273a8db4bf1d33c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the million dollar question from programmer's point of view So when to use &quot;String&quot; and &quot;string&quot;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プログラマーの観点から見た100万ドルの質問では、「文字列」と「文字列」をいつ使用するのでしょうか。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c0d1a72db9895ccfb9110378ecf99a8542224" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String&lt;/strong&gt; is not a keyword, and you can use it as an identifier:</source>
          <target state="translated">&lt;strong&gt;文字列&lt;/strong&gt;はキーワードではないため、識別子として使用できます。</target>
        </trans-unit>
        <trans-unit id="0b0d36dbb427e4a1a0640b4c1188d84e0f6b2c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is one difference&lt;/strong&gt; - you can't use &lt;code&gt;String&lt;/code&gt; without &lt;code&gt;using System;&lt;/code&gt; beforehand.</source>
          <target state="translated">&lt;strong&gt;違いが1つあり&lt;/strong&gt; &lt;code&gt;using System;&lt;/code&gt; を使用せずに &lt;code&gt;String&lt;/code&gt; を使用することはできません。 予め。</target>
        </trans-unit>
        <trans-unit id="cbf2f4931f55b8ad0bf613d33ab6ad8bddf5c12a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;string&lt;/strong&gt; is a keyword, and you can't use string as an identifier.</source>
          <target state="translated">&lt;strong&gt;string&lt;/strong&gt;はキーワードであり、stringを識別子として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="b9559fcbc971e124aaf1fe39290213f4b148f9ba" translate="yes" xml:space="preserve">
          <source>Against what seems to be common practice among other programmers, I prefer &lt;code&gt;String&lt;/code&gt; over &lt;code&gt;string&lt;/code&gt;, just to highlight the fact that &lt;code&gt;String&lt;/code&gt; is a reference type, as Jon Skeet mentioned.</source>
          <target state="translated">Jon Skeetが述べたように、他のプログラマーの間で一般的な慣行のように思われるものに対して、私は &lt;code&gt;String&lt;/code&gt; が参照型であるという事実を強調するために、 &lt;code&gt;string&lt;/code&gt; よりも &lt;code&gt;String&lt;/code&gt; を好みます。</target>
        </trans-unit>
        <trans-unit id="fdb501029b56570afb94f9ed29293d4141dc5953" translate="yes" xml:space="preserve">
          <source>All the predefined types  are mapped directly to
  underlying .NET types. The C# type names (string) are simply aliases for the
  .NET types (String or System.String), so using the .NET names works fine syntactically, although
  this is discouraged. Within a C# program, you should use the C# names
  rather than the .NET names.</source>
          <target state="translated">定義済みの型はすべて、その下にある .NET 型に直接マッピングされています。C#の型名(文字列)は .NET 型(String または System.String)の単なるエイリアスなので、.NET 名を使用しても構文的には問題ありませんが、お勧めできません。C#プログラム内では、.NET名ではなくC#名を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d98984153e55855cca8c4e5f7e443623850db2b0" translate="yes" xml:space="preserve">
          <source>Also, now, when I see &quot;int&quot; or &quot;string&quot;, it just looks really wrong to me, like I'm looking at 1970's C code.</source>
          <target state="translated">また、&quot;int &quot;や &quot;string &quot;を見ると、まるで1970年代のC言語のコードを見ているかのように、本当に間違っているように見えます。</target>
        </trans-unit>
        <trans-unit id="c77c986c978db50c2edb1530b6d7604bb90ae875" translate="yes" xml:space="preserve">
          <source>Another critical difference: Stack Overflow highlights them differently.</source>
          <target state="translated">もう一つの決定的な違い。スタックオーバーフローは、それらを異なる形で強調しています。</target>
        </trans-unit>
        <trans-unit id="337038535cd28955eae1f640e7096e40e7631b25" translate="yes" xml:space="preserve">
          <source>Another way to visualize the difference is with this sample:</source>
          <target state="translated">違いを可視化するもう一つの方法が、このサンプルです。</target>
        </trans-unit>
        <trans-unit id="a60b6da79539bdc8b7cb297451feb7d858cf6d80" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, the aliases are all to value types. &lt;code&gt;decimal&lt;/code&gt; is a value type, but not a primitive type in the CLR. The only primitive type which doesn't have an alias is &lt;code&gt;System.IntPtr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; と &lt;code&gt;object&lt;/code&gt; を除いて、エイリアスはすべて値型です。 &lt;code&gt;decimal&lt;/code&gt; は値型ですが、CLRのプリミティブ型ではありません。 エイリアスを持たないプリミティブ型は &lt;code&gt;System.IntPtr&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="ccbcd6fabeac0fa1e903b96ce302d37cc9ab55a9" translate="yes" xml:space="preserve">
          <source>As far as guidelines, it's generally recommended to use &lt;code&gt;string&lt;/code&gt; any time you're referring to an object.</source>
          <target state="translated">ガイドラインに関しては、オブジェクトを参照するときは常に &lt;code&gt;string&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0d8db7a7da3c8e55c6ef7583c26653161b5963c8" translate="yes" xml:space="preserve">
          <source>As for guidelines I wouldn't get too bogged down and just use whichever you feel like - there are more important things in life and the code is going to be the same anyway.</source>
          <target state="translated">ガイドラインについては、私はあまり泥沼化せずに、あなたが好きだと感じるものを使ってください-人生でもっと重要なことがありますし、コードはいずれにせよ同じになるでしょう。</target>
        </trans-unit>
        <trans-unit id="49f6b692ecbc8ab730cec2fc66a93ce1d36c6a77" translate="yes" xml:space="preserve">
          <source>As others have noted, &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;. They compile to the same code, so at execution time there is no difference whatsoever. This is just one of the aliases in C#. The complete list is:</source>
          <target state="translated">他の人が指摘したように、 &lt;code&gt;string&lt;/code&gt; は &lt;code&gt;System.String&lt;/code&gt; のエイリアスです。 それらは同じコードにコンパイルされるため、実行時に違いはありません。 これはC＃のエイリアスの1つにすぎません。 完全なリストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dfd1c1e7e5f7162b6737b19a1d23e4b8e738b888" translate="yes" xml:space="preserve">
          <source>As the others are saying, they're the same.  StyleCop rules, by default, will enforce you to use &lt;code&gt;string&lt;/code&gt; as a C# code style best practice, except when referencing &lt;code&gt;System.String&lt;/code&gt; static functions, such as &lt;code&gt;String.Format&lt;/code&gt;, &lt;code&gt;String.Join&lt;/code&gt;, &lt;code&gt;String.Concat&lt;/code&gt;, etc...</source>
          <target state="translated">他の人が言っているように、彼らは同じです。 StyleCopルールでは、デフォルトで、 &lt;code&gt;String.Format&lt;/code&gt; 、 &lt;code&gt;String.Join&lt;/code&gt; 、 &lt;code&gt;String.Concat&lt;/code&gt; などの &lt;code&gt;System.String&lt;/code&gt; 静的関数を参照する場合を除き、C＃コードスタイルのベストプラクティスとして &lt;code&gt;string&lt;/code&gt; を使用するように強制します。</target>
        </trans-unit>
        <trans-unit id="d3e69bc36fcde9e95937ddabcf28d8aa1e3d28c7" translate="yes" xml:space="preserve">
          <source>Both are same. But from coding guidelines perspective it's better to use &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;. This is what generally developers use. e.g. instead of using &lt;code&gt;Int32&lt;/code&gt; we use &lt;code&gt;int&lt;/code&gt; as &lt;code&gt;int&lt;/code&gt; is alias to &lt;code&gt;Int32&lt;/code&gt;</source>
          <target state="translated">どちらも同じです。 ただし、コーディングガイドラインの観点からは、 &lt;code&gt;String&lt;/code&gt; ではなく &lt;code&gt;string&lt;/code&gt; を使用することをお勧めします。 これは一般的に開発者が使用するものです。 たとえば、 &lt;code&gt;Int32&lt;/code&gt; を使用する代わりに、 &lt;code&gt;int&lt;/code&gt; は &lt;code&gt;Int32&lt;/code&gt; のエイリアスであるため、 intを使用します。</target>
        </trans-unit>
        <trans-unit id="11a99bfdab95ac5c2ba17b81950872e8650ba272" translate="yes" xml:space="preserve">
          <source>But now for a long textual answer.</source>
          <target state="translated">しかし、長文の回答になりました。</target>
        </trans-unit>
        <trans-unit id="bf90ee429ac8f8bc62dfdefed6e11fb05e6fc23e" translate="yes" xml:space="preserve">
          <source>C# is a language which is used together with the CLR.</source>
          <target state="translated">C#はCLRと一緒に使われる言語です。</target>
        </trans-unit>
        <trans-unit id="9d5c764a1acaa5b5bcb96101fe97b4133de42c33" translate="yes" xml:space="preserve">
          <source>Coming late to the party: I use the CLR types 100% of the time (well, except if &lt;em&gt;forced&lt;/em&gt; to use the C# type, but I don't remember when the last time that was).</source>
          <target state="translated">パーティーに遅れる：私はCLRタイプを100％使用します（まあ、C＃タイプを使用するよう&lt;em&gt;強制さ&lt;/em&gt;れた場合を除いて、最後にいつだったか覚えていません）。</target>
        </trans-unit>
        <trans-unit id="84b6fa77f09cddf191ebef51dd09349c2e4423ea" translate="yes" xml:space="preserve">
          <source>Conditional and control keywords (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;) are lowercase and colored dark blue (by default). And I would rather not have the disagreement in use and format.</source>
          <target state="translated">条件キーワードと制御キーワード（ &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;switch&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt; など ）は小文字で、濃い青色（デフォルト）です。 そして、私はどちらかと言えば、使用方法と形式に不一致がありません。</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="63cf87d7199d567617ea4b6ca5ec4e87620d8625" translate="yes" xml:space="preserve">
          <source>Example (&lt;em&gt;note the case&lt;/em&gt;):</source>
          <target state="translated">例（ &lt;em&gt;ケースに注意してください&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="52936f8d320a5c9edae9467890ff6b3835ae84b6" translate="yes" xml:space="preserve">
          <source>FYI
&amp;ldquo;The keyword string is simply an alias for the predefined class &lt;code&gt;System.String&lt;/code&gt;.&amp;rdquo; - C# Language Specification 4.2.3
&lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</source>
          <target state="translated">FYI「キーワード文字列は、事前定義されたクラス &lt;code&gt;System.String&lt;/code&gt; の単なるエイリアスです。」 -C＃言語仕様4.2.3 &lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58792e3b925f31858fc5ea747e687bdc0f62a6ae" translate="yes" xml:space="preserve">
          <source>Finally, when it comes to which to use: personally I use the aliases everywhere for the implementation, but the CLR type for any APIs. It really doesn't matter too much which you use in terms of implementation - consistency among your team is nice, but no-one else is going to care. On the other hand, it's genuinely important that if you refer to a type in an API, you do so in a language-neutral way. A method called &lt;code&gt;ReadInt32&lt;/code&gt; is unambiguous, whereas a method called &lt;code&gt;ReadInt&lt;/code&gt; requires interpretation. The caller could be using a language that defines an &lt;code&gt;int&lt;/code&gt; alias for &lt;code&gt;Int16&lt;/code&gt;, for example. The .NET framework designers have followed this pattern, good examples being in the &lt;code&gt;BitConverter&lt;/code&gt;, &lt;code&gt;BinaryReader&lt;/code&gt; and &lt;code&gt;Convert&lt;/code&gt; classes.</source>
          <target state="translated">最後に、どちらを使用するかということになると、個人的には実装のエイリアスをどこでも使用しますが、APIの場合はCLRタイプを使用します。 実装に関してどれを使用するかはそれほど重要ではありません。チーム間の一貫性は良好ですが、他の誰も気にしません。 一方、APIで型を参照する場合は、言語に依存しない方法で参照することが本当に重要です。 &lt;code&gt;ReadInt32&lt;/code&gt; と呼ばれるメソッドは明確ですが、 &lt;code&gt;ReadInt&lt;/code&gt; と呼ばれるメソッドは解釈が必要です。 呼び出し元は、たとえば &lt;code&gt;Int16&lt;/code&gt; の &lt;code&gt;int&lt;/code&gt; エイリアスを定義する言語を使用している可能性があります。 .NETフレームワークの設計者は、このパターンに従っています。良い例は、 &lt;code&gt;BitConverter&lt;/code&gt; 、 &lt;code&gt;BinaryReader&lt;/code&gt; 、および &lt;code&gt;Convert&lt;/code&gt; クラスです。</target>
        </trans-unit>
        <trans-unit id="361f354e3c112924a67a6cd4e52c6912aa86f34b" translate="yes" xml:space="preserve">
          <source>First thing to avoid confusion use one of them consistently. But from best practices perspective when you do variable declaration it's good to use &quot;string&quot; ( small &quot;s&quot;) and when you are using it as a class name then &quot;String&quot; ( capital &quot;S&quot;) is preferred.</source>
          <target state="translated">混乱を避けるためには、まず、どちらかを一貫して使うことです。しかし、ベストプラクティスの観点からは、変数宣言を行う際には &quot;string&quot;(小さな &quot;s&quot;)を使用するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="901ba968f95a818d5303d46cf8a18ecd2e7bfdd0" translate="yes" xml:space="preserve">
          <source>First, when &lt;code&gt;String&lt;/code&gt; is a &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt; of the current type (or a local variable):</source>
          <target state="translated">まず、 &lt;code&gt;String&lt;/code&gt; が現在のタイプ（またはローカル変数）の&lt;strong&gt;&lt;em&gt;値&lt;/em&gt;&lt;/strong&gt;である&lt;strong&gt;&lt;em&gt;場合&lt;/em&gt;&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="ee5cc7375a72753d04afe3ef92339bdd63c94ee7" translate="yes" xml:space="preserve">
          <source>I can say the same about &lt;strong&gt;(&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;System.Int32&lt;/code&gt;)&lt;/strong&gt; etc..</source>
          <target state="translated">&lt;strong&gt;（ &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;System.Int32&lt;/code&gt; ）&lt;/strong&gt;などについても同じことが言えます。</target>
        </trans-unit>
        <trans-unit id="ea3e61270f6cf9945f0a83b40b68501c8a543b14" translate="yes" xml:space="preserve">
          <source>I didn't get his opinion before I read the complete paragraph.</source>
          <target state="translated">完全な段落を読む前に、彼の意見が出てこなかった。</target>
        </trans-unit>
        <trans-unit id="d5494c0741861941dbb77b1154505ecd11f5b5b3" translate="yes" xml:space="preserve">
          <source>I originally started doing this years ago, as per the CLR books by Ritchie. It made sense to me that all CLR languages ultimately have to be able to support the set of CLR types, so using the CLR types yourself provided clearer, and possibly more &quot;reusable&quot; code.</source>
          <target state="translated">私は数年前に、リッチーの CLR の本にあるように、これを始めました。すべてのCLR言語が最終的にはCLRタイプのセットをサポートできなければならないというのは理にかなっていると思います。</target>
        </trans-unit>
        <trans-unit id="b41709e8dc275dd7834960616cb7974a5926cbc8" translate="yes" xml:space="preserve">
          <source>I prefer the capitalized &lt;code&gt;.NET&lt;/code&gt; types (rather than the aliases) for formatting reasons. The &lt;code&gt;.NET&lt;/code&gt; types are colored the same as other object types (the value types are proper objects, after all).</source>
          <target state="translated">フォーマットの理由から、（エイリアスではなく）大文字の &lt;code&gt;.NET&lt;/code&gt; タイプを使用します。 &lt;code&gt;.NET&lt;/code&gt; タイプは、他のオブジェクトタイプと同じように色付けされます（結局、値タイプは適切なオブジェクトです）。</target>
        </trans-unit>
        <trans-unit id="5a239d3ab937b3004575ec484c47a6e4ed49e68f" translate="yes" xml:space="preserve">
          <source>I shall provide two examples where &lt;em&gt;&lt;code&gt;using&lt;/code&gt; directives will not help&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;ディレクティブを &lt;code&gt;using&lt;/code&gt; も役に立たない&lt;/em&gt; 2つの例を示し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa93903e288f3d4e16cf4bb1f90b96f48052393" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt;
  or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# &lt;strong&gt;string&lt;/strong&gt; (a keyword) maps exactly to
  &lt;strong&gt;System.String&lt;/strong&gt; (an FCL type), there is no difference and either can be used. Similarly,
  I&amp;rsquo;ve heard some developers say that &lt;strong&gt;int&lt;/strong&gt; represents a 32-bit integer when the application
  is running on a 32-bit OS and that it represents a 64-bit integer when the application
  is running on a 64-bit OS. This statement is absolutely false: in C#, an &lt;strong&gt;int&lt;/strong&gt; always maps
  to &lt;strong&gt;System.Int32&lt;/strong&gt;, and therefore it represents a 32-bit integer regardless of the OS the
  code is running on. If programmers would use &lt;strong&gt;Int32&lt;/strong&gt; in their code, then this potential
  confusion is also eliminated.</source>
          <target state="translated">コードで&lt;strong&gt;文字列&lt;/strong&gt;を使用するか&lt;strong&gt;文字列&lt;/strong&gt;を使用するかわからない多くの開発者が混乱しているのを見てきました。 C＃では、 &lt;strong&gt;文字列&lt;/strong&gt; （キーワード）は&lt;strong&gt;System.String&lt;/strong&gt; （FCLタイプ）に正確にマップされるため、違いはなく、どちらも使用できます。 同様に、アプリケーションが32ビットOSで実行されている場合、 &lt;strong&gt;int&lt;/strong&gt;は32ビット整数を表し、アプリケーションが64ビットOSで実行されている場合、64ビット整数を表すと一部の開発者が言うのを聞いたことがあります。 このステートメントは完全に偽です。C＃では、 &lt;strong&gt;intは&lt;/strong&gt;常に&lt;strong&gt;System.Int32&lt;/strong&gt;にマップされるため、コードが実行されているOSに関係なく、32ビット整数を表します。 プログラマが&lt;strong&gt;Int32&lt;/strong&gt;をコードで使用する場合、この潜在的な混乱も解消されます。</target>
        </trans-unit>
        <trans-unit id="fa954e4cefc7a46db782057de61937b12e9e5aed" translate="yes" xml:space="preserve">
          <source>I'd just like to add this to lfousts answer, from Ritchers book:</source>
          <target state="translated">リッチャーズの本の中にあった、ロフストの答えに付け加えたいと思います。</target>
        </trans-unit>
        <trans-unit id="21899fca0863f132973844812fab0c779022a7b9" translate="yes" xml:space="preserve">
          <source>I've seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt; or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# the string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used.</source>
          <target state="translated">コードで&lt;strong&gt;文字列&lt;/strong&gt;を使用するか&lt;strong&gt;文字列&lt;/strong&gt;を使用するかわからない多くの開発者が混乱しているのを見てきました。 C＃では、文字列（キーワード）はSystem.String（FCLタイプ）に正確にマッピングされるため、違いはなく、どちらも使用できます。</target>
        </trans-unit>
        <trans-unit id="6b7d898ac30d5c92342d8ac9760039cee7099d78" translate="yes" xml:space="preserve">
          <source>If for some reason you wanted a variable called &lt;em&gt;string&lt;/em&gt;, you'd see only the first of these compiles:</source>
          <target state="translated">なんらかの理由で&lt;em&gt;string&lt;/em&gt;という変数が必要な場合は、最初のコンパイルのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="4415225af42f5d012580c28bcbef4acf554c9d6c" translate="yes" xml:space="preserve">
          <source>If you find yourselves building systems where it is necessary to specify the size of the integers you are using and so tend to use &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt; etc. then it might look more natural to use &lt;code&gt;String&lt;/code&gt; - and when moving around between different .net languages it might make things more understandable - otherwise I would use string and int.</source>
          <target state="translated">使用している整数のサイズを指定する必要があるシステムを構築していて、 &lt;code&gt;Int16&lt;/code&gt; 、 &lt;code&gt;Int32&lt;/code&gt; 、 &lt;code&gt;UInt16&lt;/code&gt; 、 &lt;code&gt;UInt32&lt;/code&gt; などを使用する傾向がある場合は、 &lt;code&gt;String&lt;/code&gt; を使用する方が自然に見える場合があります。 .net言語は、物事をより理解しやすくするかもしれません-そうでなければ、文字列とintを使用します。</target>
        </trans-unit>
        <trans-unit id="fc3d0d8990fb3765be09111a7c669c84b913e5c0" translate="yes" xml:space="preserve">
          <source>If you really want a variable name called &lt;em&gt;string&lt;/em&gt; you can use &lt;code&gt;@&lt;/code&gt; as a prefix:</source>
          <target state="translated">&lt;em&gt;string&lt;/em&gt;という変数名が本当に必要な場合は、 &lt;code&gt;@&lt;/code&gt; を接頭辞として使用できます。</target>
        </trans-unit>
        <trans-unit id="5da7f23835ffc9c6b22e25e2d55eb0854a9abafa" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt;
  could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does treat &lt;strong&gt;long&lt;/strong&gt; as an &lt;strong&gt;Int32&lt;/strong&gt;.
  Someone reading source code in one language could easily misinterpret the code&amp;rsquo;s
  intention if he or she were used to programming in a different programming language.
  In fact, most languages won&amp;rsquo;t even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won&amp;rsquo;t compile code
  that uses it.</source>
          <target state="translated">C＃では、 &lt;strong&gt;long&lt;/strong&gt;は&lt;strong&gt;System.Int64&lt;/strong&gt;にマップされますが、別のプログラミング言語では、 &lt;strong&gt;long&lt;/strong&gt;は&lt;strong&gt;Int16&lt;/strong&gt;または&lt;strong&gt;Int32に&lt;/strong&gt;マップできます。 実際、C ++ / CLIは&lt;strong&gt;Int32&lt;/strong&gt;として&lt;strong&gt;長く&lt;/strong&gt;扱います。 ある言語でソースコードを読んでいる誰かが、別のプログラミング言語でのプログラミングに慣れていると、コードの意図を簡単に誤って解釈する可能性があります。 実際、ほとんどの言語では、キーワードとして&lt;strong&gt;長く&lt;/strong&gt;扱われることも、それを使用するコードをコンパイルすることもありません。</target>
        </trans-unit>
        <trans-unit id="c34719d5baf69cca85f742773fbc5ad7584b58a0" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt; could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does in fact treat long as an &lt;strong&gt;Int32&lt;/strong&gt;. Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language. In fact, most languages won't even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won't compile code that uses it.</source>
          <target state="translated">C＃では、 &lt;strong&gt;long&lt;/strong&gt;は&lt;strong&gt;System.Int64&lt;/strong&gt;にマップされますが、別のプログラミング言語では、 &lt;strong&gt;long&lt;/strong&gt;は&lt;strong&gt;Int16&lt;/strong&gt;または&lt;strong&gt;Int32に&lt;/strong&gt;マップできます。 実際、C ++ / CLIは実際には&lt;strong&gt;Int32&lt;/strong&gt;として長く扱います。 ある言語でソースコードを読んでいる誰かが、別のプログラミング言語でのプログラミングに慣れていると、コードの意図を簡単に誤って解釈する可能性があります。 実際、ほとんどの言語では、キーワードとして&lt;strong&gt;長く&lt;/strong&gt;扱われることも、それを使用するコードをコンパイルすることもありません。</target>
        </trans-unit>
        <trans-unit id="7b36107e9559a09694a8183cb99815886d4e78c3" translate="yes" xml:space="preserve">
          <source>In short &quot;String&quot; is an alias ( the same thing called with different names) of &quot;string&quot;. So technically both the below code statements will give the same output.</source>
          <target state="translated">要するに、&quot;String &quot;は &quot;string &quot;のエイリアス(名前を変えて呼ばれる同じもの)です。そのため、技術的には以下のコード文はどちらも同じ出力になります。</target>
        </trans-unit>
        <trans-unit id="e6dc65980fe8a04364550bf8267b4a0752724591" translate="yes" xml:space="preserve">
          <source>In the below code the left hand side is a variable declaration and it declared using &quot;string&quot;. At the right hand side we are calling a method so &quot;String&quot; is more sensible.</source>
          <target state="translated">下のコードでは、左側が変数宣言で、&quot;string &quot;を使って宣言しています。右側ではメソッドを呼び出しているので、&quot;String &quot;の方が賢明です。</target>
        </trans-unit>
        <trans-unit id="f98303445c332e612954049bbaf882f4fa3cb7e9" translate="yes" xml:space="preserve">
          <source>In the same way there are aliases for other c# data type as shown below:-</source>
          <target state="translated">同様に、以下に示すように、他のc#データ型のエイリアスがあります。</target>
        </trans-unit>
        <trans-unit id="57dee12da4dec3aa9f4c4e8403aa2ad08617efcc" translate="yes" xml:space="preserve">
          <source>In the spec, the value type aliases are known as &quot;simple types&quot;. Literals can be used for constant values of every simple type; no other value types have literal forms available. (Compare this with VB, which allows &lt;code&gt;DateTime&lt;/code&gt; literals, and has an alias for it too.)</source>
          <target state="translated">仕様では、値タイプのエイリアスは「単純タイプ」と呼ばれています。 リテラルは、すべての単純型の定数値に使用できます。 他の値タイプには、使用可能なリテラル形式はありません。 （これを、 &lt;code&gt;DateTime&lt;/code&gt; リテラルを許可し、エイリアスも持つVBと比較してください。）</target>
        </trans-unit>
        <trans-unit id="483cab40a51898204e58cfed265106143d7f4953" translate="yes" xml:space="preserve">
          <source>It appears that the guidance in this area may have changed, as &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; now enforces the use of the C# specific aliases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt;がC＃固有のエイリアスの使用を強制するようになったため、この領域のガイダンスが変更された可能性があります。</target>
        </trans-unit>
        <trans-unit id="ff67dae909a99ee9a9e7def47187588639f45a8f" translate="yes" xml:space="preserve">
          <source>It's a matter of convention, really.  &lt;code&gt;string&lt;/code&gt; just looks more like C/C++ style.  The general convention is to use whatever shortcuts your chosen language has provided (int/Int for &lt;code&gt;Int32&lt;/code&gt;).  This goes for &quot;object&quot; and &lt;code&gt;decimal&lt;/code&gt; as well.</source>
          <target state="translated">本当に、それは慣習の問題です。 &lt;code&gt;string&lt;/code&gt; はC / C ++スタイルに似ています。 一般的な規則では、選択した言語で提供されているショートカットを使用します（int / Int for &lt;code&gt;Int32&lt;/code&gt; ）。 これは「オブジェクト」と &lt;code&gt;decimal&lt;/code&gt; にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="3838b064aeaafbf213d49b0394cdd6a50f24ba3e" translate="yes" xml:space="preserve">
          <source>It's been covered above; however, you can't use &lt;code&gt;string&lt;/code&gt; in reflection; you must use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">これは上記でカバーされています。 ただし、リフレクションで &lt;code&gt;string&lt;/code&gt; を使用することはできません。 &lt;code&gt;String&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e09d862931ec0e2748cdc4ff36fc4d9cad4e1d6a" translate="yes" xml:space="preserve">
          <source>Just for the sake of completeness, here's a brain dump of related information...</source>
          <target state="translated">念のため、ここに関連情報のブレインダンプがあります...</target>
        </trans-unit>
        <trans-unit id="5e78ed6411bc19fbcef0b5786cecd66b3134b765" translate="yes" xml:space="preserve">
          <source>Likewise, I think it's generally recommended to use &lt;code&gt;String&lt;/code&gt; if you need to refer specifically to the class.</source>
          <target state="translated">同様に、クラスを具体的に参照する必要がある場合は、通常、 &lt;code&gt;String&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bc04acca921cef20c01ada3297aed735cee9b09f" translate="yes" xml:space="preserve">
          <source>Lower case &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;.
They are the same in &lt;code&gt;C#&lt;/code&gt;.</source>
          <target state="translated">小文字の &lt;code&gt;string&lt;/code&gt; は &lt;code&gt;System.String&lt;/code&gt; のエイリアスです。 &lt;code&gt;C#&lt;/code&gt; でも同じです。</target>
        </trans-unit>
        <trans-unit id="aa9ccdfd7c726f6e226b0942c75a549ff6e70b5d" translate="yes" xml:space="preserve">
          <source>Lowercase &lt;code&gt;string&lt;/code&gt; is preferred in most projects due to the syntax highlighting</source>
          <target state="translated">構文の強調表示のため、ほとんどのプロジェクトでは小文字の &lt;code&gt;string&lt;/code&gt; が推奨されます</target>
        </trans-unit>
        <trans-unit id="b6133573d560cd3eea08983f58c0042a25059f55" translate="yes" xml:space="preserve">
          <source>Many programmers that use C# exclusively tend to forget that other programming
  languages can be used against the CLR, and because of this, C#-isms creep into the
  class library code. For example, Microsoft&amp;rsquo;s FCL is almost exclusively written in C# and
  developers on the FCL team have now introduced methods into the library such as
  &lt;strong&gt;Array&lt;/strong&gt;&amp;rsquo;s &lt;strong&gt;GetLongLength&lt;/strong&gt;, which returns an &lt;strong&gt;Int64&lt;/strong&gt; value that is a &lt;strong&gt;long&lt;/strong&gt; in C# but not
  in other languages (like C++/CLI). Another example is &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;&amp;rsquo;s
  &lt;strong&gt;LongCount&lt;/strong&gt; method.</source>
          <target state="translated">C＃を独占的に使用する多くのプログラマーは、他のプログラミング言語をCLRに対して使用できることを忘れがちです。そのため、C＃の機能はクラスライブラリコードに侵入します。 たとえば、MicrosoftのFCLはほぼすべてC＃で記述されており、FCLチームの開発者は、 &lt;strong&gt;Array&lt;/strong&gt;の&lt;strong&gt;GetLongLength&lt;/strong&gt;などのメソッドをライブラリに導入しました。 / CLI）。 別の例は、 &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;の&lt;strong&gt;LongCount&lt;/strong&gt;メソッドです。</target>
        </trans-unit>
        <trans-unit id="9df02f88b75a5ae9238b00816debf524d9b6d4bb" translate="yes" xml:space="preserve">
          <source>Many will argue that while this is information technically accurate using &lt;code&gt;String&lt;/code&gt; is still fine because it&amp;rsquo;s exceedingly rare that a code base would define a type of this name. Or that when &lt;code&gt;String&lt;/code&gt; is defined it&amp;rsquo;s a sign of a bad code base.</source>
          <target state="translated">これは情報ですが、 &lt;code&gt;String&lt;/code&gt; を使用して技術的に正確な情報であるにもかかわらず、コードベースがこの名前のタイプを定義することは非常にまれであるため、多くの人が主張します。 または、 &lt;code&gt;String&lt;/code&gt; が定義されている場合、それはコードベースが不良であることを示しています。</target>
        </trans-unit>
        <trans-unit id="4969c66ffc5656f3999a26d516caf717157af60a" translate="yes" xml:space="preserve">
          <source>Neither statement in the &lt;code&gt;Example&lt;/code&gt; method compiles. Here &lt;code&gt;String&lt;/code&gt; is always a piano &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;string&lt;/a&gt;, &lt;code&gt;MyPiano.String&lt;/code&gt;. No member (&lt;code&gt;static&lt;/code&gt; or not) &lt;code&gt;Format&lt;/code&gt; exists on it (or is inherited from its base class). And the value &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; cannot be converted into it.</source>
          <target state="translated">&lt;code&gt;Example&lt;/code&gt; メソッドのどちらのステートメントもコンパイルされません。 ここで、 &lt;code&gt;String&lt;/code&gt; は常にピアノの&lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;弦&lt;/a&gt; 、 &lt;code&gt;MyPiano.String&lt;/code&gt; です。 メンバー（ &lt;code&gt;static&lt;/code&gt; かどうかに関係なく）の &lt;code&gt;Format&lt;/code&gt; 存在しません（またはその基本クラスから継承されます）。 また、 &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; という値は変換できません。</target>
        </trans-unit>
        <trans-unit id="2fa06e504f29a303da31352f8e430b6dc30c1883" translate="yes" xml:space="preserve">
          <source>New answer after 6 years and 5 months (procrastination).</source>
          <target state="translated">6年5ヶ月ぶりの新回答(先延ばし)。</target>
        </trans-unit>
        <trans-unit id="296daf449bf0c8664c9e6d199847c7929ad529f1" translate="yes" xml:space="preserve">
          <source>Note: I copy/pasted most of the blog post for archive reason. I ignore some parts, so I recommend to skip and to read the &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;blog post&lt;/a&gt; if you can.</source>
          <target state="translated">注：アーカイブのために、ブログのほとんどの投稿をコピー/貼り付けました。 一部を無視しているので、できればスキップして&lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;ブログ記事&lt;/a&gt;を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="022ba2779e8f9a2cb535c438e2a28ea7b0dd3e80" translate="yes" xml:space="preserve">
          <source>Now that I've been doing it for years, it's a habit and I like the coloration that VS shows for the CLR types.</source>
          <target state="translated">何年も前からやっている今では癖になっているし、CLR系のVSが見せる色使いが好きだ。</target>
        </trans-unit>
        <trans-unit id="b3ab40a90e383fb18e0e975a4f3ebb4b8b3eaeff" translate="yes" xml:space="preserve">
          <source>Secondly, when &lt;code&gt;String&lt;/code&gt; is another &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, nested inside the current type:</source>
          <target state="translated">次に、 &lt;code&gt;String&lt;/code&gt; が別の&lt;strong&gt;&lt;em&gt;タイプの&lt;/em&gt;&lt;/strong&gt;場合、現在のタイプ内にネストされます。</target>
        </trans-unit>
        <trans-unit id="e101d4a69cdea700b7d60c87527fa5d12e284702" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;int&lt;/code&gt; maps to &lt;code&gt;System.Int32&lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;int&lt;/code&gt; は &lt;code&gt;System.Int32&lt;/code&gt; にマップします。</target>
        </trans-unit>
        <trans-unit id="689346a590d26a7f24b31d23dd2fbc483406fd3b" translate="yes" xml:space="preserve">
          <source>So remember when you see the &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; debate this is about semantics, not style. Choosing string gives crisp meaning to your code base. Choosing &lt;code&gt;String&lt;/code&gt; isn&amp;rsquo;t wrong but it&amp;rsquo;s leaving the door open for surprises in the future.</source>
          <target state="translated">ですから、 &lt;code&gt;String&lt;/code&gt; と &lt;code&gt;string&lt;/code&gt; 議論を見るとき、これはスタイルではなく意味論についてです。 文字列を選択すると、コードベースに明確な意味が与えられます。 &lt;code&gt;String&lt;/code&gt; 選択することは間違いではありませんが、将来の驚きのためにドアを開いたままにしておきます。</target>
        </trans-unit>
        <trans-unit id="9cb50509dd63b7929b71e5a34e498aabbd13f875" translate="yes" xml:space="preserve">
          <source>So technically, there is no difference.  It's like &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt;&lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">したがって、技術的には違いはありません。 これは、 &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt; &lt;/a&gt;のようなものです。</target>
        </trans-unit>
        <trans-unit id="ff2325db982bbc83b6294b8c0dff80dba26d189b" translate="yes" xml:space="preserve">
          <source>So there you have it. I think these are all really good points. I however, don't find myself using Jeffrey's advice in my own code. Maybe I am too stuck in my C# world but I end up trying to make my code look like the framework code.</source>
          <target state="translated">そうですね。これらはすべて本当に良い点だと思います。しかし、私は自分のコードにジェフリーのアドバイスを使っていることに気がつきません。私はC#の世界にはまり込みすぎているのかもしれませんが、結局自分のコードをフレームワークのコードのように見せようとしてしまいます。</target>
        </trans-unit>
        <trans-unit id="84d84cfed9ed57bbe7f2bacafbaddfb81576cf17" translate="yes" xml:space="preserve">
          <source>String (&lt;code&gt;System.String&lt;/code&gt;) is a class in the base class library. string (lower case) is a reserved work in C# that is an alias for System.String. Int32 vs int is a similar situation as is &lt;code&gt;Boolean vs. bool&lt;/code&gt;. These C# language specific keywords enable you to declare primitives in a style similar to C.</source>
          <target state="translated">文字列（ &lt;code&gt;System.String&lt;/code&gt; ）は、基本クラスライブラリのクラスです。 文字列（小文字）はC＃で予約されている作業で、System.Stringのエイリアスです。 Int32とintは、 &lt;code&gt;Boolean vs. bool&lt;/code&gt; 場合と同様の状況です。 これらのC＃言語固有のキーワードを使用すると、Cと同様のスタイルでプリミティブを宣言できます。</target>
        </trans-unit>
        <trans-unit id="49ce6a3b5fc76630de40afb2fe0abba3f193580b" translate="yes" xml:space="preserve">
          <source>That's just a matter of the way the spec defines enum declarations - the part after the colon has to be the &lt;em&gt;integral-type&lt;/em&gt; production, which is one token of &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;... as opposed to a &lt;em&gt;type&lt;/em&gt; production as used by variable declarations for example. It doesn't indicate any other difference.</source>
          <target state="translated">これは、仕様が列挙型宣言を定義する方法の問題です-コロンの後の部分は、 &lt;em&gt;整数型の&lt;/em&gt;生成でなければなりません。これは、 &lt;code&gt;sbyte&lt;/code&gt; 、 &lt;code&gt;byte&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;ushort&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;uint&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;ulong&lt;/code&gt; 、 &lt;code&gt;char&lt;/code&gt; の 1つのトークンです。 ..たとえば、変数宣言で使用される&lt;em&gt;型&lt;/em&gt;生成とは対照的です。 その他の違いはありません。</target>
        </trans-unit>
        <trans-unit id="57cd8f4f9cafb98e0ff1960638924dc3de76b39d" translate="yes" xml:space="preserve">
          <source>The C# keyword &lt;code&gt;string&lt;/code&gt; maps to the .NET type &lt;code&gt;System.String&lt;/code&gt; - it is an alias that keeps to the naming conventions of the language.</source>
          <target state="translated">C＃キーワード &lt;code&gt;string&lt;/code&gt; は、.NETタイプの &lt;code&gt;System.String&lt;/code&gt; にマップされます 。これは、言語の命名規則に準拠するエイリアスです。</target>
        </trans-unit>
        <trans-unit id="f49eb70607b2497b91d8c266445436a4abe3155d" translate="yes" xml:space="preserve">
          <source>The C# language specification states, &amp;ldquo;As a matter of style, use of the keyword is favored over
  use of the complete system type name.&amp;rdquo; I disagree with the language specification; I prefer
  to use the FCL type names and completely avoid the primitive type names. In fact, I wish that
  compilers didn&amp;rsquo;t even offer the primitive type names and forced developers to use the FCL
  type names instead. Here are my reasons:</source>
          <target state="translated">C＃言語仕様には、「スタイルの問題として、完全なシステムタイプ名を使用するよりもキーワードを使用する方が好ましい」と記載されています。 言語仕様に同意しません。 私はFCLタイプ名を使用し、プリミティブタイプ名を完全に避けることを好みます。 実際、コンパイラーがプリミティブ型名さえ提供せず、開発者に代わりにFCL型名を使用するように強制したいのですが。 ここに私の理由があります：</target>
        </trans-unit>
        <trans-unit id="fce2e5a5f468c7b1c34cd9768434166999ddbdb0" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For
  example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;,
  &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as
  &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it&amp;rsquo;s legal to write the following
  code, the line with &lt;strong&gt;float&lt;/strong&gt; feels very unnatural to me, and it&amp;rsquo;s not obvious that the line is
  correct:</source>
          <target state="translated">FCLには、メソッド名の一部として型名を持つ多くのメソッドがあります。 たとえば、 &lt;strong&gt;BinaryReader&lt;/strong&gt;型は&lt;strong&gt;ReadBoolean&lt;/strong&gt; 、 &lt;strong&gt;ReadInt32&lt;/strong&gt; 、 &lt;strong&gt;ReadSingle&lt;/strong&gt;などのメソッドを提供し、 &lt;strong&gt;System.Convert&lt;/strong&gt;型は&lt;strong&gt;ToBoolean&lt;/strong&gt; 、 &lt;strong&gt;ToInt32&lt;/strong&gt; 、 &lt;strong&gt;ToSingle&lt;/strong&gt;などのメソッドを提供します。 次のコードを書くことは合法ですが、 &lt;strong&gt;floatを含む&lt;/strong&gt;行は私には非常に不自然に感じられ、行が正しいかどうかは明らかではありません。</target>
        </trans-unit>
        <trans-unit id="d241e925f9c6c70e65ab7201f55f79ecdaebf9ce" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;, &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it's legal to write the following code, the line with float feels very unnatural to me, and it's not obvious that the line is correct:</source>
          <target state="translated">FCLには、メソッド名の一部として型名を持つ多くのメソッドがあります。 たとえば、 &lt;strong&gt;BinaryReader&lt;/strong&gt;型は&lt;strong&gt;ReadBoolean&lt;/strong&gt; 、 &lt;strong&gt;ReadInt32&lt;/strong&gt; 、 &lt;strong&gt;ReadSingle&lt;/strong&gt;などのメソッドを提供し、 &lt;strong&gt;System.Convert&lt;/strong&gt;型は&lt;strong&gt;ToBoolean&lt;/strong&gt; 、 &lt;strong&gt;ToInt32&lt;/strong&gt; 、 &lt;strong&gt;ToSingle&lt;/strong&gt;などのメソッドを提供します。 次のコードを書くことは合法ですが、floatを含む行は私には非常に不自然に感じられ、行が正しいかどうかは明らかではありません。</target>
        </trans-unit>
        <trans-unit id="245547d31df063b9be5afb5f9f9e26bb654e9990" translate="yes" xml:space="preserve">
          <source>The above will not compile because &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; does not have a non-static member called &lt;code&gt;Format&lt;/code&gt;, and no extension methods apply. In the above case, it may still be possible to use &lt;code&gt;String&lt;/code&gt; in other contexts where a &lt;em&gt;type&lt;/em&gt; is the only possibility syntactically. For example &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; could be OK (depending on namespace and &lt;code&gt;using&lt;/code&gt; directives).</source>
          <target state="translated">&lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; は &lt;code&gt;Format&lt;/code&gt; と呼ばれる非静的メンバーがないため、上記はコンパイルされず、拡張メソッドは適用されません。 上記の場合、 &lt;em&gt;タイプ&lt;/em&gt;が構文的に唯一の可能性である他のコンテキストで &lt;code&gt;String&lt;/code&gt; を使用することはまだ可能です。 たとえば、 &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; （ネームスペースとディレクティブの &lt;code&gt;using&lt;/code&gt; 応じて）OKである可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d7a9de8ca807f30e0d84dd6099bf753c98ce135" translate="yes" xml:space="preserve">
          <source>The actual meaning of &lt;code&gt;String&lt;/code&gt; will always depend on name resolution.
  That means it depends on all the source files in the project and all
  the types defined in all the referenced assemblies. In short it
  requires quite a bit of context to &lt;em&gt;know&lt;/em&gt; what it means.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; の実際の意味は、常に名前解決に依存します。 つまり、プロジェクト内のすべてのソースファイルと、参照されるすべてのアセンブリで定義されているすべてのタイプに依存します。 要するに、それが何を意味するのかを&lt;em&gt;知る&lt;/em&gt;にはかなりのコンテキストが必要です。</target>
        </trans-unit>
        <trans-unit id="93322148b52efc519b4bbcaebbed28fabcc67ec3" translate="yes" xml:space="preserve">
          <source>The best answer I have ever heard about using the provided type aliases in C# comes from Jeffrey Richter in his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C#&lt;/a&gt;. Here are his 3 reasons:</source>
          <target state="translated">提供された型エイリアスをC＃で使用することについて私がこれまで聞いた最良の答えは、Jeffrey Richterの著書&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C＃にあり&lt;/a&gt;ます。 彼の3つの理由は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="04f4e2e05e59044015a06ab9e5709ace1067caeb" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;String&lt;/code&gt; though has no concrete meaning in C#. It is an identifier that goes through all the name lookup rules as &lt;code&gt;Widget&lt;/code&gt;, &lt;code&gt;Student&lt;/code&gt;, etc &amp;hellip; It could bind to string or it could bind to a type in another assembly entirely whose purposes may be entirely different than &lt;code&gt;string&lt;/code&gt;. Worse it could be defined in a way such that code like &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt;; continued to compile.</source>
          <target state="translated">C＃では、識別子 &lt;code&gt;String&lt;/code&gt; は具体的な意味を持ちません。 これは、 &lt;code&gt;Widget&lt;/code&gt; 、 &lt;code&gt;Student&lt;/code&gt; などのすべての名前ルックアップルールを通過する識別子です。文字列にバインドすることも、 &lt;code&gt;string&lt;/code&gt; とは完全に異なる目的を持つ別のアセンブリの型にバインドすることもできます 。 さらに悪いことに、 &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt; ようなコードで定義することもできます。 コンパイルし続けました。</target>
        </trans-unit>
        <trans-unit id="3f48daaabbe068f8c313923060dc1ce87907e97a" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt;  is an alias for
 &lt;code&gt;System.String&lt;/code&gt; aside from the keyword issue, the two are exactly
 equivalent.</source>
          <target state="translated">キーワード &lt;code&gt;string&lt;/code&gt; は、キーワードの問題を除いて、 &lt;code&gt;System.String&lt;/code&gt; のエイリアスです。この2つはまったく同じです。</target>
        </trans-unit>
        <trans-unit id="d5c514298559badf24fce9b8b392cc6d91008feb" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt; has concrete meaning in C#. It is the type &lt;code&gt;System.String&lt;/code&gt; which exists in the core runtime assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings in .NET. Its presence is so critical to C# that if that type doesn&amp;rsquo;t exist the compiler will exit before attempting to even parse a line of code. Hence &lt;code&gt;string&lt;/code&gt; has a precise, unambiguous meaning in C# code.</source>
          <target state="translated">キーワード &lt;code&gt;string&lt;/code&gt; は、C＃では具体的な意味があります。 コアランタイムアセンブリに存在するタイプ &lt;code&gt;System.String&lt;/code&gt; です。 ランタイムは本質的にこのタイプを理解し、開発者が.NETの文字列に期待する機能を提供します。 その存在はC＃にとって非常に重要であるため、その型が存在しない場合、コンパイラーはコード行の解析を試みる前に終了します。 したがって、C＃コードでは &lt;code&gt;string&lt;/code&gt; は正確で明確な意味を持っています。</target>
        </trans-unit>
        <trans-unit id="baaf13d4a47a17e15308fe16fb596475d6a15088" translate="yes" xml:space="preserve">
          <source>The only practical difference is the syntax highlighting as you mention, and that you have to write &lt;code&gt;using System&lt;/code&gt; if you use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">唯一の実際的な違いは、あなたが言及するように構文の強調表示であり、 &lt;code&gt;String&lt;/code&gt; を使用する場合は &lt;code&gt;using System&lt;/code&gt; を使用して記述する必要があることです。</target>
        </trans-unit>
        <trans-unit id="8668abfb621e1b2a22882756e57d856bcfbf3e47" translate="yes" xml:space="preserve">
          <source>The only real downer is that auto-complete uses the C# type, so I end up re-typing automatically generated types to specify the CLR type instead.</source>
          <target state="translated">唯一のマイナス点は、オートコンプリートがC#型を使用していることで、自動生成された型を代わりにCLR型を指定するために再入力してしまうことです。</target>
        </trans-unit>
        <trans-unit id="9c532ca7d467cf6352c36952f31402d9053b7bfb" translate="yes" xml:space="preserve">
          <source>Theoretically this could help to port code into some future 64-bit standard in which &quot;int&quot; might mean &lt;code&gt;Int64&lt;/code&gt;, but that's not the point, and I would expect any upgrade wizard to change any &lt;code&gt;int&lt;/code&gt; references to &lt;code&gt;Int32&lt;/code&gt; anyway just to be safe.</source>
          <target state="translated">理論的には、これは &quot;int&quot;が &lt;code&gt;Int64&lt;/code&gt; を意味する可能性がある将来の64ビット標準にコードを移植するのに役立ちますが、それは重要ではありません。安全のために、アップグレードウィザードで &lt;code&gt;Int32&lt;/code&gt; への &lt;code&gt;int&lt;/code&gt; 参照を変更すると予想されます。</target>
        </trans-unit>
        <trans-unit id="1b43e8aad6972ff5253750d89b626a58fe50142a" translate="yes" xml:space="preserve">
          <source>Theoretically, you could implement a C#-compiler that generated Java bytecode. A sensible implementation of this compiler would probably map &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/strong&gt; in order to interoperate with the Java runtime library.</source>
          <target state="translated">理論的には、Javaバイトコードを生成するC＃コンパイラを実装できます。 このコンパイラーの賢明な実装は、Javaランタイムライブラリと相互運用するために、おそらく&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt;を&lt;strong&gt; &lt;code&gt;java.lang.String&lt;/code&gt; &lt;/strong&gt;にマップし&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9cef7d16318b618f7d7e05ce428e421145a3eb1" translate="yes" xml:space="preserve">
          <source>There is no difference.</source>
          <target state="translated">違いはありません。</target>
        </trans-unit>
        <trans-unit id="e724cb1ff2ea7523a1d7006294c3e2e3b6908113" translate="yes" xml:space="preserve">
          <source>There is one circumstance in which you &lt;em&gt;have&lt;/em&gt; to use the aliases: when explicitly specifying an enum's underlying type. For instance:</source>
          <target state="translated">エイリアスを使用しなければなら&lt;em&gt;ない&lt;/em&gt;状況が1つあります。列挙型の基礎となる型を明示的に指定する場合です。 例えば：</target>
        </trans-unit>
        <trans-unit id="db457529845002230c6c5b574e656447dd4b91e6" translate="yes" xml:space="preserve">
          <source>There's a debate over whether you should use the System types (&lt;code&gt;System.Int32&lt;/code&gt;, &lt;code&gt;System.String&lt;/code&gt;, etc.) types or the &lt;code&gt;C# aliases&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, etc). I personally believe you should use the &lt;code&gt;C# aliases&lt;/code&gt;, but that's just my personal preference.</source>
          <target state="translated">Systemタイプ（ &lt;code&gt;System.Int32&lt;/code&gt; 、 &lt;code&gt;System.String&lt;/code&gt; など）タイプと &lt;code&gt;C# aliases&lt;/code&gt; （ &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; など）のどちらを使用するかについては、議論があります 。 私は個人的には &lt;code&gt;C# aliases&lt;/code&gt; 使用するべきだと信じていますが、それは私の個人的な好みにすぎません。</target>
        </trans-unit>
        <trans-unit id="591cd0b1a64565e8d55765f16e4e309da97495fb" translate="yes" xml:space="preserve">
          <source>There's a quote on this issue from &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;Daniel Solis' book&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;ダニエル・ソリスの本&lt;/a&gt;からこの問題についての引用があります。</target>
        </trans-unit>
        <trans-unit id="cd310fee67eed80e9424306ba0e405b3b78a9e96" translate="yes" xml:space="preserve">
          <source>This is the style that Microsoft tends to use in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;their examples&lt;/a&gt;.</source>
          <target state="translated">これは、マイクロソフトが&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;例で&lt;/a&gt;使用する傾向があるスタイルです。</target>
        </trans-unit>
        <trans-unit id="f6a887af1a34c7a21a8c77639ce417b3bb91f2d6" translate="yes" xml:space="preserve">
          <source>True that in the vast majority of cases &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; will bind to
  the same type. But using &lt;code&gt;String&lt;/code&gt; still means developers are leaving
  their program up to interpretation in places where there is only one
  correct answer. When &lt;code&gt;String&lt;/code&gt; does bind to the wrong type it can leave
  developers debugging for hours, filing bugs on the compiler team and
  generally wasting time that could&amp;rsquo;ve been saved by using &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;string&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; と文字列は同じ型にバインドされます。 ただし、 &lt;code&gt;String&lt;/code&gt; を使用するということは、開発者が正しい答えが1つしかない場所でプログラムを解釈に任せることを意味します。 &lt;code&gt;String&lt;/code&gt; が間違った型にバインドされると、開発者は何時間もデバッグを続け、コンパイラチームにバグを報告し、通常は &lt;code&gt;string&lt;/code&gt; を使用することで節約できた時間を無駄にする可能性があります 。</target>
        </trans-unit>
        <trans-unit id="080151d9d06a4a0841ea36ef9ee84dcdb90f489e" translate="yes" xml:space="preserve">
          <source>Using System types makes it easier to port between C# and VB.Net, if you are into that sort of thing.</source>
          <target state="translated">システム型を使うことで、C#とVB.Netの間での移植が容易になります。</target>
        </trans-unit>
        <trans-unit id="bbaa6241d89ea80c39692aa3b5ba27d31a981924" translate="yes" xml:space="preserve">
          <source>What are the &lt;strong&gt;&lt;em&gt;guidelines&lt;/em&gt;&lt;/strong&gt; for the use of each? And what are the &lt;strong&gt;&lt;em&gt;differences&lt;/em&gt;&lt;/strong&gt;?</source>
          <target state="translated">それぞれの使用&lt;strong&gt;&lt;em&gt;に関するガイドライン&lt;/em&gt;&lt;/strong&gt;は何ですか？ そして、 &lt;strong&gt;&lt;em&gt;違いは&lt;/em&gt;&lt;/strong&gt;何ですか？</target>
        </trans-unit>
        <trans-unit id="bd9579b2d38cc31bb5131600b18e1a9c58740e90" translate="yes" xml:space="preserve">
          <source>What is the difference between String and string in C#</source>
          <target state="translated">C#のStringとstringの違いは?</target>
        </trans-unit>
        <trans-unit id="e71d05ee8c65811fde766fc86a9a2312a31589aa" translate="yes" xml:space="preserve">
          <source>When we talk about &lt;code&gt;.NET&lt;/code&gt; there are two different things one there is &lt;code&gt;.NET&lt;/code&gt; framework and the other there are languages ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; etc) which use that framework.</source>
          <target state="translated">&lt;code&gt;.NET&lt;/code&gt; について話すとき、2つの異なるものがあり &lt;code&gt;.NET&lt;/code&gt; 。1つは.NETフレームワークで、もう1つはそのフレームワークを使用する言語（ &lt;code&gt;C#&lt;/code&gt; 、 &lt;code&gt;VB.NET&lt;/code&gt; など）です。</target>
        </trans-unit>
        <trans-unit id="1f3e96542caf20f14fe703e23e36cf1f92b45e0e" translate="yes" xml:space="preserve">
          <source>When you use C# together with the CLR &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; will be mapped to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">C＃をCLRと共に使用すると、 &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt;は&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt;にマップされ&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6da5e0c25b5beda54e8637b0d410f9bcc6da7930" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;string&lt;/code&gt; is a reserved C# keyword that always has a fixed meaning, &lt;code&gt;String&lt;/code&gt; is just an ordinary &lt;em&gt;identifier&lt;/em&gt; which could refer to anything. Depending on members of the current type, the current namespace and the applied &lt;code&gt;using&lt;/code&gt; directives and their placement, &lt;code&gt;String&lt;/code&gt; could be a value or a type distinct from &lt;code&gt;global::System.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; は常に固定された意味を持つ予約済みのC＃キーワードですが、 &lt;code&gt;String&lt;/code&gt; は何でも参照できる通常の&lt;em&gt;識別子に&lt;/em&gt;すぎません。 現在のタイプのメンバー、現在の名前空間、適用された &lt;code&gt;using&lt;/code&gt; ディレクティブとその配置に応じて、 &lt;code&gt;String&lt;/code&gt; は、 &lt;code&gt;global::System.String&lt;/code&gt; 異なる値またはタイプになる可能性があります 。</target>
        </trans-unit>
        <trans-unit id="9d746517e1decf0d12e57b19ed8b079d7d2ff727" translate="yes" xml:space="preserve">
          <source>Worse: Saying &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; will likely (depending on &lt;code&gt;using&lt;/code&gt;s) go to the Linq extension method &lt;code&gt;Enumerable.Concat&lt;/code&gt;. It will not go to the static method &lt;code&gt;string.Concat&lt;/code&gt;.</source>
          <target state="translated">さらに悪いことに、 &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; と言うと（ sの &lt;code&gt;using&lt;/code&gt; 応じて）、Linq拡張メソッド &lt;code&gt;Enumerable.Concat&lt;/code&gt; に移動する可能性があります 。 静的メソッド &lt;code&gt;string.Concat&lt;/code&gt; には移動しません。</target>
        </trans-unit>
        <trans-unit id="825f170ba301d67aee52cb32cfb74d6313352781" translate="yes" xml:space="preserve">
          <source>Yes, that's no difference between them, just like the &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">はい、 &lt;code&gt;bool&lt;/code&gt; と &lt;code&gt;Boolean&lt;/code&gt; 値のように、それらの違いはありません。</target>
        </trans-unit>
        <trans-unit id="9bfe5ac3a85fb8412165790973b10eb661d8a34a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that &lt;code&gt;String&lt;/code&gt; is defined for a number of completely valid purposes: reflection helpers, serialization libraries, lexers, protocols, etc &amp;hellip; For any of these libraries &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; has real consequences depending on where the code is used.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; は、リフレクションヘルパー、シリアル化ライブラリ、レクサー、プロトコルなど、いくつかの完全に有効な目的で定義されていることがわかります。これらのライブラリのいずれについても、 &lt;code&gt;String&lt;/code&gt; と &lt;code&gt;string&lt;/code&gt; は、コードが使用される場所に応じて実際に影響を及ぼします。</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="7f23f0b182ad02e9f6f6309b506e9b8da87ba491" translate="yes" xml:space="preserve">
          <source>object: &lt;code&gt;System.Object&lt;/code&gt;, string: &lt;code&gt;System.String&lt;/code&gt;, bool: &lt;code&gt;System.Boolean&lt;/code&gt;, byte: &lt;code&gt;System.Byte&lt;/code&gt;, sbyte: &lt;code&gt;System.SByte&lt;/code&gt;, short: &lt;code&gt;System.Int16&lt;/code&gt; and so on</source>
          <target state="translated">オブジェクト： &lt;code&gt;System.Object&lt;/code&gt; 、文字列： &lt;code&gt;System.String&lt;/code&gt; 、ブール： &lt;code&gt;System.Boolean&lt;/code&gt; 、バイト： &lt;code&gt;System.Byte&lt;/code&gt; 、sbyte： &lt;code&gt;System.SByte&lt;/code&gt; 、short： &lt;code&gt;System.Int16&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
