<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/7074">
    <body>
      <group id="7074">
        <trans-unit id="228d68628714cc2360e68afeab589f17918ce691" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;System.String&lt;/code&gt;&quot; a.k.a &quot;String&quot; ( capital &quot;S&quot;) is a &lt;code&gt;.NET&lt;/code&gt; framework data type while &quot;string&quot; is a &lt;code&gt;C#&lt;/code&gt; data type.</source>
          <target state="translated">&quot; &lt;code&gt;System.String&lt;/code&gt; &quot; &quot;일명&quot;String &quot;(대문자&quot;S &quot;)은 &lt;code&gt;.NET&lt;/code&gt; 프레임 워크 데이터 유형이고&quot;string &quot;은 &lt;code&gt;C#&lt;/code&gt; 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="66dc7eeaeac7b1a7dc09e3938dafceafda64d5d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;This YouTube&lt;/a&gt; video demonstrates practically how they differ.</source>
          <target state="translated">&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;이 YouTube&lt;/a&gt; 동영상은 실제로 어떻게 다른지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="26f52da3f6db7a342ae3830a5e6491f9174f7950" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; is an alias in C# for &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 은 C.에서 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/a&gt; 에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="b042ac29881f76cecc22db88fda9a3b4320d85be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (a developer on the C# compiler and prolific SO user!) wrote a &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;great blog post&lt;/a&gt; on this issue. I think it is worth sharing here. It is a nice perspective on our subject.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (C # 컴파일러 개발자 및 많은 SO 사용자!)는이 문제에 대한 &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;훌륭한 블로그 게시물&lt;/a&gt; 을 작성했습니다. 여기서 공유 할 가치가 있다고 생각합니다. 우리의 주제에 대한 좋은 관점입니다.</target>
        </trans-unit>
        <trans-unit id="e63e166e9fed4ca1e3a3e31ed1fd9eabcb1c9955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; is not a keyword and it can be used as Identifier whereas &lt;code&gt;string&lt;/code&gt; is a keyword and cannot be used as Identifier. And in function point of view both are same.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 은 키워드가 아니며 식별자로 사용할 수 있지만 &lt;code&gt;string&lt;/code&gt; 은 키워드이며 식별자로 사용할 수 없습니다. 그리고 기능적인 관점에서 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b90e7af3ecb39b51fb79fa8592f0f1d9ae9ddcb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; stands for &lt;code&gt;System.String&lt;/code&gt; and it is a .NET Framework type. &lt;strong&gt;&lt;code&gt;string&lt;/code&gt; is an alias&lt;/strong&gt; in the C# language for  &lt;code&gt;System.String&lt;/code&gt;. Both of them are compiled to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt; in IL&lt;/strong&gt; (Intermediate Language), so there is no difference. Choose what you like and use that. If you code in C#, I'd prefer &lt;code&gt;string&lt;/code&gt; as it's a C# type alias and well-known by C# programmers.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 은 &lt;code&gt;System.String&lt;/code&gt; 의 약자이며 .NET Framework 유형입니다. &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; 은&lt;/strong&gt; &lt;code&gt;System.String&lt;/code&gt; 에 대한 C # 언어 &lt;strong&gt;의 별명&lt;/strong&gt; 입니다. 둘 다 &lt;strong&gt;IL&lt;/strong&gt; (Intermediate Language)의 &lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; 으로 컴파일되므로 차이가 없습니다. 원하는 것을 선택하고 사용하십시오. C #으로 코딩하는 경우 C # 유형 별칭이므로 C # 프로그래머에게 잘 알려진 &lt;code&gt;string&lt;/code&gt; 을 선호 합니다 .</target>
        </trans-unit>
        <trans-unit id="21dfdc708b7c6d9ddde1026c9f823a48e07357f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System.String&lt;/code&gt; is the .NET string class - in C# &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt; - so in use they are the same.</source>
          <target state="translated">&lt;code&gt;System.String&lt;/code&gt; 은 .NET 문자열 클래스입니다. C # &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;System.String&lt;/code&gt; 의 별칭이므로 사용시 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e4be40d094b8761d8b0a8af7779ee11906a863a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are identical in all ways (except the uppercase &quot;S&quot;).  There are no performance implications either way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; 은 모든면에서 동일합니다 (대문자 &quot;S&quot;제외). 어느 쪽의 성능 영향도 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8840747d529a1ab2e607b537ad66fd66839abb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is a reserved word, but &lt;code&gt;String&lt;/code&gt; is just a class name. 
This means that &lt;code&gt;string&lt;/code&gt; cannot be used as a variable name by itself.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 예약어이지만 &lt;code&gt;String&lt;/code&gt; 은 단지 클래스 이름입니다. 이는 &lt;code&gt;string&lt;/code&gt; 자체를 변수 이름으로 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="da5062e4b9764acaa414144e97820d32c0973476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is an alias (or shorthand) of &lt;code&gt;System.String&lt;/code&gt;. That means, by typing &lt;code&gt;string&lt;/code&gt; we meant &lt;code&gt;System.String&lt;/code&gt;. You can read more in think link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string' is an alias/shorthand of System.String.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;System.String&lt;/code&gt; 의 별명 (또는 속기)입니다. 즉, &lt;code&gt;string&lt;/code&gt; 을 입력하여 &lt;code&gt;System.String&lt;/code&gt; 을 의미했습니다. think 링크에서 더 읽을 수 있습니다 : &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string'은 System.String의 별칭 / 속기입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d8e4bba708dfba56ed459601d498e8840f3e123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is just an alias for &lt;code&gt;System.String&lt;/code&gt;. The compiler will treat them identically.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;System.String&lt;/code&gt; 의 별칭입니다. 컴파일러는 그것들을 동일하게 취급 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f084ec9e9d82162f7fbc5659d6f160720497365a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; is not a style debate</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 대 &lt;code&gt;String&lt;/code&gt; 은 스타일 토론이 아닙니다</target>
        </trans-unit>
        <trans-unit id="255b406fa6b9e0823de8f80e3455112e9d159128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt; is a type in the CLR.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; 은 CLR의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="26877e9563383a6b546ae7a361569c47dfb9f7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; is a type in C#.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; 은 C #의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="012b988247360c0d3de48ea273a8db4bf1d33c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the million dollar question from programmer's point of view So when to use &quot;String&quot; and &quot;string&quot;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 프로그래머의 관점에서 백만 달러짜리 질문 &quot;String&quot;과 &quot;string&quot;을 언제 사용해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c0d1a72db9895ccfb9110378ecf99a8542224" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String&lt;/strong&gt; is not a keyword, and you can use it as an identifier:</source>
          <target state="translated">&lt;strong&gt;문자열&lt;/strong&gt; 은 키워드가 아니며 식별자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0d36dbb427e4a1a0640b4c1188d84e0f6b2c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is one difference&lt;/strong&gt; - you can't use &lt;code&gt;String&lt;/code&gt; without &lt;code&gt;using System;&lt;/code&gt; beforehand.</source>
          <target state="translated">&lt;strong&gt;한 가지 차이점&lt;/strong&gt; 이 있습니다 &lt;code&gt;using System;&lt;/code&gt; 을 사용 하지 않으면 &lt;code&gt;String&lt;/code&gt; 을 사용할 수 없습니다 . 미리.</target>
        </trans-unit>
        <trans-unit id="cbf2f4931f55b8ad0bf613d33ab6ad8bddf5c12a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;string&lt;/strong&gt; is a keyword, and you can't use string as an identifier.</source>
          <target state="translated">&lt;strong&gt;string&lt;/strong&gt; 은 키워드이므로 string을 식별자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9559fcbc971e124aaf1fe39290213f4b148f9ba" translate="yes" xml:space="preserve">
          <source>Against what seems to be common practice among other programmers, I prefer &lt;code&gt;String&lt;/code&gt; over &lt;code&gt;string&lt;/code&gt;, just to highlight the fact that &lt;code&gt;String&lt;/code&gt; is a reference type, as Jon Skeet mentioned.</source>
          <target state="translated">Jon Skeet이 언급했듯이 &lt;code&gt;String&lt;/code&gt; 은 참조 유형이라는 사실을 강조하기 위해 다른 프로그래머들 사이에서 일반적인 관행으로 보이는 것보다 &lt;code&gt;String&lt;/code&gt; 을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="fdb501029b56570afb94f9ed29293d4141dc5953" translate="yes" xml:space="preserve">
          <source>All the predefined types  are mapped directly to
  underlying .NET types. The C# type names (string) are simply aliases for the
  .NET types (String or System.String), so using the .NET names works fine syntactically, although
  this is discouraged. Within a C# program, you should use the C# names
  rather than the .NET names.</source>
          <target state="translated">미리 정의 된 모든 유형은 기본 .NET 유형에 직접 매핑됩니다. C # 형식 이름 (문자열)은 단순히 .NET 형식 (문자열 또는 System.String)의 별칭이므로 .NET 이름을 사용하는 것은 권장되지 않지만 구문 상으로는 잘 작동합니다. C # 프로그램 내에서 .NET 이름 대신 C # 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d98984153e55855cca8c4e5f7e443623850db2b0" translate="yes" xml:space="preserve">
          <source>Also, now, when I see &quot;int&quot; or &quot;string&quot;, it just looks really wrong to me, like I'm looking at 1970's C code.</source>
          <target state="translated">또한, &quot;int&quot;또는 &quot;string&quot;을 볼 때 1970 년대 C 코드를보고있는 것처럼 그것은 나에게 정말로 잘못 보입니다.</target>
        </trans-unit>
        <trans-unit id="c77c986c978db50c2edb1530b6d7604bb90ae875" translate="yes" xml:space="preserve">
          <source>Another critical difference: Stack Overflow highlights them differently.</source>
          <target state="translated">또 다른 중요한 차이점 : 스택 오버플로는 다르게 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="337038535cd28955eae1f640e7096e40e7631b25" translate="yes" xml:space="preserve">
          <source>Another way to visualize the difference is with this sample:</source>
          <target state="translated">차이점을 시각화하는 또 다른 방법은이 샘플을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a60b6da79539bdc8b7cb297451feb7d858cf6d80" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, the aliases are all to value types. &lt;code&gt;decimal&lt;/code&gt; is a value type, but not a primitive type in the CLR. The only primitive type which doesn't have an alias is &lt;code&gt;System.IntPtr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;object&lt;/code&gt; 외에도 별명은 모두 값 유형입니다. &lt;code&gt;decimal&lt;/code&gt; 은 값 형식이지만 CLR의 기본 형식은 아닙니다. 별명이없는 유일한 기본 유형은 &lt;code&gt;System.IntPtr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccbcd6fabeac0fa1e903b96ce302d37cc9ab55a9" translate="yes" xml:space="preserve">
          <source>As far as guidelines, it's generally recommended to use &lt;code&gt;string&lt;/code&gt; any time you're referring to an object.</source>
          <target state="translated">지침에 따르면 일반적으로 객체를 참조 할 때마다 &lt;code&gt;string&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0d8db7a7da3c8e55c6ef7583c26653161b5963c8" translate="yes" xml:space="preserve">
          <source>As for guidelines I wouldn't get too bogged down and just use whichever you feel like - there are more important things in life and the code is going to be the same anyway.</source>
          <target state="translated">지침에 관해서는 너무 혼란스럽지 않고 당신이 느끼는 것을 사용하십시오-인생에서 더 중요한 것들이 있으며 코드는 어쨌든 동일합니다.</target>
        </trans-unit>
        <trans-unit id="49f6b692ecbc8ab730cec2fc66a93ce1d36c6a77" translate="yes" xml:space="preserve">
          <source>As others have noted, &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;. They compile to the same code, so at execution time there is no difference whatsoever. This is just one of the aliases in C#. The complete list is:</source>
          <target state="translated">다른 사람들이 지적했듯이 &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;System.String&lt;/code&gt; 의 별칭입니다. 그것들은 동일한 코드로 컴파일되므로 실행 시간에는 아무런 차이가 없습니다. 이것은 C #의 별칭 중 하나 일뿐입니다. 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dfd1c1e7e5f7162b6737b19a1d23e4b8e738b888" translate="yes" xml:space="preserve">
          <source>As the others are saying, they're the same.  StyleCop rules, by default, will enforce you to use &lt;code&gt;string&lt;/code&gt; as a C# code style best practice, except when referencing &lt;code&gt;System.String&lt;/code&gt; static functions, such as &lt;code&gt;String.Format&lt;/code&gt;, &lt;code&gt;String.Join&lt;/code&gt;, &lt;code&gt;String.Concat&lt;/code&gt;, etc...</source>
          <target state="translated">다른 사람들이 말했듯이 그들은 동일합니다. StyleCop 규칙은 기본적으로 &lt;code&gt;String.Format&lt;/code&gt; , &lt;code&gt;String.Join&lt;/code&gt; , &lt;code&gt;String.Concat&lt;/code&gt; 등과 같은 &lt;code&gt;System.String&lt;/code&gt; 정적 함수를 참조 할 때를 제외하고 &lt;code&gt;string&lt;/code&gt; 을 C # 코드 스타일 모범 사례로 사용하도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="d3e69bc36fcde9e95937ddabcf28d8aa1e3d28c7" translate="yes" xml:space="preserve">
          <source>Both are same. But from coding guidelines perspective it's better to use &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;. This is what generally developers use. e.g. instead of using &lt;code&gt;Int32&lt;/code&gt; we use &lt;code&gt;int&lt;/code&gt; as &lt;code&gt;int&lt;/code&gt; is alias to &lt;code&gt;Int32&lt;/code&gt;</source>
          <target state="translated">둘 다 동일합니다. 그러나 코딩 지침 관점에서 &lt;code&gt;String&lt;/code&gt; 대신 &lt;code&gt;string&lt;/code&gt; 을 사용하는 것이 좋습니다. 이것이 일반적으로 개발자들이 사용하는 것입니다. 예를 들어 &lt;code&gt;Int32&lt;/code&gt; 를 사용하는 대신 &lt;code&gt;int&lt;/code&gt; 는 &lt;code&gt;Int32&lt;/code&gt; 의 별칭이므로 int를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11a99bfdab95ac5c2ba17b81950872e8650ba272" translate="yes" xml:space="preserve">
          <source>But now for a long textual answer.</source>
          <target state="translated">그러나 지금은 긴 텍스트 답변입니다.</target>
        </trans-unit>
        <trans-unit id="bf90ee429ac8f8bc62dfdefed6e11fb05e6fc23e" translate="yes" xml:space="preserve">
          <source>C# is a language which is used together with the CLR.</source>
          <target state="translated">C #은 CLR과 함께 사용되는 언어입니다.</target>
        </trans-unit>
        <trans-unit id="9d5c764a1acaa5b5bcb96101fe97b4133de42c33" translate="yes" xml:space="preserve">
          <source>Coming late to the party: I use the CLR types 100% of the time (well, except if &lt;em&gt;forced&lt;/em&gt; to use the C# type, but I don't remember when the last time that was).</source>
          <target state="translated">파티에 늦게 : 나는 CLR 유형을 100 % 사용합니다 (C # 유형을 사용해야하는 경우를 제외하고는 마지막이지만 시간이 언제인지는 기억하지 못합니다).</target>
        </trans-unit>
        <trans-unit id="84b6fa77f09cddf191ebef51dd09349c2e4423ea" translate="yes" xml:space="preserve">
          <source>Conditional and control keywords (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;) are lowercase and colored dark blue (by default). And I would rather not have the disagreement in use and format.</source>
          <target state="translated">조건부 및 제어 키워드 ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; 및 &lt;code&gt;return&lt;/code&gt; 등 )는 소문자이며 진한 파란색 (기본적으로)으로 표시됩니다. 그리고 나는 사용과 형식에 대한 의견 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="63cf87d7199d567617ea4b6ca5ec4e87620d8625" translate="yes" xml:space="preserve">
          <source>Example (&lt;em&gt;note the case&lt;/em&gt;):</source>
          <target state="translated">예 ( &lt;em&gt;사례 참고&lt;/em&gt; ) :</target>
        </trans-unit>
        <trans-unit id="52936f8d320a5c9edae9467890ff6b3835ae84b6" translate="yes" xml:space="preserve">
          <source>FYI
&amp;ldquo;The keyword string is simply an alias for the predefined class &lt;code&gt;System.String&lt;/code&gt;.&amp;rdquo; - C# Language Specification 4.2.3
&lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</source>
          <target state="translated">참고로&amp;ldquo;키워드 문자열은 미리 정의 된 클래스 &lt;code&gt;System.String&lt;/code&gt; 의 별칭입니다.&amp;rdquo; -C # 언어 사양 4.2.3 &lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58792e3b925f31858fc5ea747e687bdc0f62a6ae" translate="yes" xml:space="preserve">
          <source>Finally, when it comes to which to use: personally I use the aliases everywhere for the implementation, but the CLR type for any APIs. It really doesn't matter too much which you use in terms of implementation - consistency among your team is nice, but no-one else is going to care. On the other hand, it's genuinely important that if you refer to a type in an API, you do so in a language-neutral way. A method called &lt;code&gt;ReadInt32&lt;/code&gt; is unambiguous, whereas a method called &lt;code&gt;ReadInt&lt;/code&gt; requires interpretation. The caller could be using a language that defines an &lt;code&gt;int&lt;/code&gt; alias for &lt;code&gt;Int16&lt;/code&gt;, for example. The .NET framework designers have followed this pattern, good examples being in the &lt;code&gt;BitConverter&lt;/code&gt;, &lt;code&gt;BinaryReader&lt;/code&gt; and &lt;code&gt;Convert&lt;/code&gt; classes.</source>
          <target state="translated">마지막으로 사용할 때 : 개인적으로 구현의 모든 곳에서 별칭을 사용하지만 API의 경우 CLR 유형을 사용합니다. 구현 측면에서 어느 것을 사용하는지는 중요하지 않습니다. 팀 간의 일관성은 좋지만 아무도 신경 쓰지 않습니다. 반면에 API에서 유형을 참조하는 경우 언어 중립적 인 방식으로 수행하는 것이 중요합니다. &lt;code&gt;ReadInt32&lt;/code&gt; 라는 메서드 는 명확하지만 &lt;code&gt;ReadInt&lt;/code&gt; 라는 메서드는 해석이 필요합니다. 예를 들어 호출자는 &lt;code&gt;Int16&lt;/code&gt; 의 &lt;code&gt;int&lt;/code&gt; 별칭을 정의하는 언어를 사용할 수 있습니다. .NET 프레임 워크 디자이너는이 패턴을 따랐으며 &lt;code&gt;BitConverter&lt;/code&gt; , &lt;code&gt;BinaryReader&lt;/code&gt; 및 &lt;code&gt;Convert&lt;/code&gt; 클래스에 좋은 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="361f354e3c112924a67a6cd4e52c6912aa86f34b" translate="yes" xml:space="preserve">
          <source>First thing to avoid confusion use one of them consistently. But from best practices perspective when you do variable declaration it's good to use &quot;string&quot; ( small &quot;s&quot;) and when you are using it as a class name then &quot;String&quot; ( capital &quot;S&quot;) is preferred.</source>
          <target state="translated">혼동을 피하기 위해 가장 먼저해야 할 일은 일관성있게 사용하는 것입니다. 그러나 모범 사례 관점에서 변수 선언을 수행 할 때는 &quot;문자열&quot;(작은 &quot;s&quot;)을 사용하는 것이 좋으며 클래스 이름으로 사용하는 경우 &quot;문자열&quot;(자본 &quot;S&quot;)이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="901ba968f95a818d5303d46cf8a18ecd2e7bfdd0" translate="yes" xml:space="preserve">
          <source>First, when &lt;code&gt;String&lt;/code&gt; is a &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt; of the current type (or a local variable):</source>
          <target state="translated">먼저 &lt;code&gt;String&lt;/code&gt; 이 현재 유형 (또는 로컬 변수)의 &lt;strong&gt;&lt;em&gt;값인&lt;/em&gt;&lt;/strong&gt; 경우 :</target>
        </trans-unit>
        <trans-unit id="ee5cc7375a72753d04afe3ef92339bdd63c94ee7" translate="yes" xml:space="preserve">
          <source>I can say the same about &lt;strong&gt;(&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;System.Int32&lt;/code&gt;)&lt;/strong&gt; etc..</source>
          <target state="translated">&lt;strong&gt;( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;System.Int32&lt;/code&gt; )&lt;/strong&gt; 등에 대해 동일하게 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3e61270f6cf9945f0a83b40b68501c8a543b14" translate="yes" xml:space="preserve">
          <source>I didn't get his opinion before I read the complete paragraph.</source>
          <target state="translated">나는 완전한 단락을 읽기 전에 그의 의견을 얻지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="d5494c0741861941dbb77b1154505ecd11f5b5b3" translate="yes" xml:space="preserve">
          <source>I originally started doing this years ago, as per the CLR books by Ritchie. It made sense to me that all CLR languages ultimately have to be able to support the set of CLR types, so using the CLR types yourself provided clearer, and possibly more &quot;reusable&quot; code.</source>
          <target state="translated">Ritchie의 CLR 서적에 따라 원래 몇 년 전에 작업을 시작했습니다. 모든 CLR 언어는 궁극적으로 CLR 유형 집합을 지원할 수 있어야하므로 CLR 유형을 사용하면 더 명확하고 &quot;재사용 가능한&quot;코드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41709e8dc275dd7834960616cb7974a5926cbc8" translate="yes" xml:space="preserve">
          <source>I prefer the capitalized &lt;code&gt;.NET&lt;/code&gt; types (rather than the aliases) for formatting reasons. The &lt;code&gt;.NET&lt;/code&gt; types are colored the same as other object types (the value types are proper objects, after all).</source>
          <target state="translated">형식화 이유로 대문자 대신 &lt;code&gt;.NET&lt;/code&gt; 유형을 선호합니다. &lt;code&gt;.NET&lt;/code&gt; 유형은 다른 객체 유형과 동일한 색상으로 표시됩니다 (값 유형은 결국 적절한 객체입니다).</target>
        </trans-unit>
        <trans-unit id="5a239d3ab937b3004575ec484c47a6e4ed49e68f" translate="yes" xml:space="preserve">
          <source>I shall provide two examples where &lt;em&gt;&lt;code&gt;using&lt;/code&gt; directives will not help&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;지시어를 사용하는 것이 도움이되지 않는&lt;/em&gt; 두 가지 예를 제시 &lt;em&gt;하겠습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa93903e288f3d4e16cf4bb1f90b96f48052393" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt;
  or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# &lt;strong&gt;string&lt;/strong&gt; (a keyword) maps exactly to
  &lt;strong&gt;System.String&lt;/strong&gt; (an FCL type), there is no difference and either can be used. Similarly,
  I&amp;rsquo;ve heard some developers say that &lt;strong&gt;int&lt;/strong&gt; represents a 32-bit integer when the application
  is running on a 32-bit OS and that it represents a 64-bit integer when the application
  is running on a 64-bit OS. This statement is absolutely false: in C#, an &lt;strong&gt;int&lt;/strong&gt; always maps
  to &lt;strong&gt;System.Int32&lt;/strong&gt;, and therefore it represents a 32-bit integer regardless of the OS the
  code is running on. If programmers would use &lt;strong&gt;Int32&lt;/strong&gt; in their code, then this potential
  confusion is also eliminated.</source>
          <target state="translated">코드에서 &lt;strong&gt;문자열&lt;/strong&gt; 또는 &lt;strong&gt;문자열&lt;/strong&gt; 을 사용할지 여부를 모르고 많은 개발자들이 혼란스러워하는 것을 보았습니다. C # &lt;strong&gt;문자열&lt;/strong&gt; (키워드)에서 &lt;strong&gt;System.String&lt;/strong&gt; (FCL 유형)에 정확하게 매핑되므로 차이가 없으며 둘 다 사용할 수 있습니다. 마찬가지로 일부 개발자는 응용 프로그램이 32 비트 OS에서 실행될 때 &lt;strong&gt;int&lt;/strong&gt; 가 32 비트 정수를 나타내고 응용 프로그램이 64 비트 OS에서 실행될 때 64 비트 정수를 나타낸다고 말합니다. 이 문장은 절대로 거짓입니다. C #에서 &lt;strong&gt;int는&lt;/strong&gt; 항상 &lt;strong&gt;System.Int32에&lt;/strong&gt; 매핑되므로 코드가 실행되는 OS에 관계없이 32 비트 정수를 나타냅니다. 프로그래머가 코드에서 &lt;strong&gt;Int32&lt;/strong&gt; 를 사용하면 이러한 잠재적 혼란도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fa954e4cefc7a46db782057de61937b12e9e5aed" translate="yes" xml:space="preserve">
          <source>I'd just like to add this to lfousts answer, from Ritchers book:</source>
          <target state="translated">Ritchers 책에서 lfousts 답변에 이것을 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="21899fca0863f132973844812fab0c779022a7b9" translate="yes" xml:space="preserve">
          <source>I've seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt; or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# the string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used.</source>
          <target state="translated">코드에서 &lt;strong&gt;문자열&lt;/strong&gt; 또는 &lt;strong&gt;문자열&lt;/strong&gt; 을 사용할지 여부를 모르고 많은 개발자들이 혼란스러워하는 것을 보았습니다. C #에서 문자열 (키워드)은 System.String (FCL 유형)에 정확하게 매핑되므로 차이가 없으며 둘 다 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b7d898ac30d5c92342d8ac9760039cee7099d78" translate="yes" xml:space="preserve">
          <source>If for some reason you wanted a variable called &lt;em&gt;string&lt;/em&gt;, you'd see only the first of these compiles:</source>
          <target state="translated">어떤 이유로 &lt;em&gt;string&lt;/em&gt; 이라는 변수를 원한다면 다음 컴파일 중 첫 번째 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4415225af42f5d012580c28bcbef4acf554c9d6c" translate="yes" xml:space="preserve">
          <source>If you find yourselves building systems where it is necessary to specify the size of the integers you are using and so tend to use &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt; etc. then it might look more natural to use &lt;code&gt;String&lt;/code&gt; - and when moving around between different .net languages it might make things more understandable - otherwise I would use string and int.</source>
          <target state="translated">사용중인 정수의 크기를 지정해야하고 &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;UInt16&lt;/code&gt; , &lt;code&gt;UInt32&lt;/code&gt; 등을 사용하는 경향이있는 건물 시스템을 찾으면 &lt;code&gt;String&lt;/code&gt; 을 사용하는 것이 더 자연스럽게 보일 수 있습니다. .net 언어를 사용하면 이해하기 쉽습니다. 그렇지 않으면 string과 int를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc3d0d8990fb3765be09111a7c669c84b913e5c0" translate="yes" xml:space="preserve">
          <source>If you really want a variable name called &lt;em&gt;string&lt;/em&gt; you can use &lt;code&gt;@&lt;/code&gt; as a prefix:</source>
          <target state="translated">&lt;em&gt;string&lt;/em&gt; 이라는 변수 이름을 정말로 원한다면 &lt;code&gt;@&lt;/code&gt; 를 접두사로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5da7f23835ffc9c6b22e25e2d55eb0854a9abafa" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt;
  could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does treat &lt;strong&gt;long&lt;/strong&gt; as an &lt;strong&gt;Int32&lt;/strong&gt;.
  Someone reading source code in one language could easily misinterpret the code&amp;rsquo;s
  intention if he or she were used to programming in a different programming language.
  In fact, most languages won&amp;rsquo;t even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won&amp;rsquo;t compile code
  that uses it.</source>
          <target state="translated">C #에서 &lt;strong&gt;long&lt;/strong&gt; 은 &lt;strong&gt;System.Int64로&lt;/strong&gt; 매핑되지만 다른 프로그래밍 언어에서는 &lt;strong&gt;long&lt;/strong&gt; 으로 &lt;strong&gt;Int16&lt;/strong&gt; 또는 &lt;strong&gt;Int32로&lt;/strong&gt; 매핑 될 수 있습니다. 실제로 C ++ / CLI는 &lt;strong&gt;오랫동안&lt;/strong&gt; &lt;strong&gt;Int32&lt;/strong&gt; 로 취급합니다. 한 언어로 된 소스 코드를 읽는 사람이 다른 프로그래밍 언어로 프로그래밍하는 데 익숙한 경우 코드의 의도를 쉽게 잘못 해석 할 수 있습니다. 실제로 대부분의 언어는 키워드로 취급하지 않으며 키워드를 사용하는 코드를 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c34719d5baf69cca85f742773fbc5ad7584b58a0" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt; could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does in fact treat long as an &lt;strong&gt;Int32&lt;/strong&gt;. Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language. In fact, most languages won't even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won't compile code that uses it.</source>
          <target state="translated">C #에서 &lt;strong&gt;long&lt;/strong&gt; 은 &lt;strong&gt;System.Int64로&lt;/strong&gt; 매핑되지만 다른 프로그래밍 언어에서는 &lt;strong&gt;long&lt;/strong&gt; 으로 &lt;strong&gt;Int16&lt;/strong&gt; 또는 &lt;strong&gt;Int32로&lt;/strong&gt; 매핑 될 수 있습니다. 실제로 C ++ / CLI는 실제로 &lt;strong&gt;Int32&lt;/strong&gt; 로 취급합니다. 한 언어로 된 소스 코드를 읽는 사람이 다른 프로그래밍 언어로 프로그래밍하는 데 익숙한 경우 코드의 의도를 쉽게 잘못 해석 할 수 있습니다. 실제로 대부분의 언어는 키워드로 취급하지 않으며 키워드를 사용하는 코드를 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b36107e9559a09694a8183cb99815886d4e78c3" translate="yes" xml:space="preserve">
          <source>In short &quot;String&quot; is an alias ( the same thing called with different names) of &quot;string&quot;. So technically both the below code statements will give the same output.</source>
          <target state="translated">간단히 말해서 &quot;String&quot;은 &quot;string&quot;의 별명 (다른 이름으로 호출 된 것과 동일한 것)입니다. 따라서 기술적으로 아래 코드 문 모두 동일한 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e6dc65980fe8a04364550bf8267b4a0752724591" translate="yes" xml:space="preserve">
          <source>In the below code the left hand side is a variable declaration and it declared using &quot;string&quot;. At the right hand side we are calling a method so &quot;String&quot; is more sensible.</source>
          <target state="translated">아래 코드에서 왼쪽은 변수 선언이며 &quot;string&quot;을 사용하여 선언되었습니다. 오른쪽에서 우리는 메소드를 호출하여 &quot;String&quot;이 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="f98303445c332e612954049bbaf882f4fa3cb7e9" translate="yes" xml:space="preserve">
          <source>In the same way there are aliases for other c# data type as shown below:-</source>
          <target state="translated">같은 방법으로 다른 c # 데이터 형식에 대한 별칭이 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="57dee12da4dec3aa9f4c4e8403aa2ad08617efcc" translate="yes" xml:space="preserve">
          <source>In the spec, the value type aliases are known as &quot;simple types&quot;. Literals can be used for constant values of every simple type; no other value types have literal forms available. (Compare this with VB, which allows &lt;code&gt;DateTime&lt;/code&gt; literals, and has an alias for it too.)</source>
          <target state="translated">스펙에서 값 유형 별명은 &quot;단순 유형&quot;으로 알려져 있습니다. 리터럴은 모든 단순 유형의 상수 값에 사용될 수 있습니다. 다른 값 유형에는 리터럴 양식을 사용할 수 없습니다. (VB와 비교하면 &lt;code&gt;DateTime&lt;/code&gt; 리터럴을 허용하고 별칭도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="483cab40a51898204e58cfed265106143d7f4953" translate="yes" xml:space="preserve">
          <source>It appears that the guidance in this area may have changed, as &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; now enforces the use of the C# specific aliases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop은&lt;/a&gt; 이제 C # 고유의 별칭을 사용 하므로이 영역의 지침이 변경되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff67dae909a99ee9a9e7def47187588639f45a8f" translate="yes" xml:space="preserve">
          <source>It's a matter of convention, really.  &lt;code&gt;string&lt;/code&gt; just looks more like C/C++ style.  The general convention is to use whatever shortcuts your chosen language has provided (int/Int for &lt;code&gt;Int32&lt;/code&gt;).  This goes for &quot;object&quot; and &lt;code&gt;decimal&lt;/code&gt; as well.</source>
          <target state="translated">정말 관습의 문제입니다. &lt;code&gt;string&lt;/code&gt; 은 C / C ++ 스타일과 비슷합니다. 일반적인 규칙은 선택한 언어가 제공 한 모든 단축키 (int / Int for &lt;code&gt;Int32&lt;/code&gt; )를 사용하는 것입니다. 이것은 &quot;객체&quot;와 &lt;code&gt;decimal&lt;/code&gt; 에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3838b064aeaafbf213d49b0394cdd6a50f24ba3e" translate="yes" xml:space="preserve">
          <source>It's been covered above; however, you can't use &lt;code&gt;string&lt;/code&gt; in reflection; you must use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">그것은 위에 덮여있다; 그러나 반영에 &lt;code&gt;string&lt;/code&gt; 을 사용할 수 없습니다. &lt;code&gt;String&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e09d862931ec0e2748cdc4ff36fc4d9cad4e1d6a" translate="yes" xml:space="preserve">
          <source>Just for the sake of completeness, here's a brain dump of related information...</source>
          <target state="translated">완벽을 기하기 위해 여기에 관련된 정보의 두뇌 덤프가 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="5e78ed6411bc19fbcef0b5786cecd66b3134b765" translate="yes" xml:space="preserve">
          <source>Likewise, I think it's generally recommended to use &lt;code&gt;String&lt;/code&gt; if you need to refer specifically to the class.</source>
          <target state="translated">마찬가지로 클래스를 구체적으로 참조 해야하는 경우 일반적으로 &lt;code&gt;String&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bc04acca921cef20c01ada3297aed735cee9b09f" translate="yes" xml:space="preserve">
          <source>Lower case &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;.
They are the same in &lt;code&gt;C#&lt;/code&gt;.</source>
          <target state="translated">소문자 &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;System.String&lt;/code&gt; 의 별칭입니다. &lt;code&gt;C#&lt;/code&gt; 에서도 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aa9ccdfd7c726f6e226b0942c75a549ff6e70b5d" translate="yes" xml:space="preserve">
          <source>Lowercase &lt;code&gt;string&lt;/code&gt; is preferred in most projects due to the syntax highlighting</source>
          <target state="translated">구문 강조로 인해 대부분의 프로젝트에서 소문자 &lt;code&gt;string&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="b6133573d560cd3eea08983f58c0042a25059f55" translate="yes" xml:space="preserve">
          <source>Many programmers that use C# exclusively tend to forget that other programming
  languages can be used against the CLR, and because of this, C#-isms creep into the
  class library code. For example, Microsoft&amp;rsquo;s FCL is almost exclusively written in C# and
  developers on the FCL team have now introduced methods into the library such as
  &lt;strong&gt;Array&lt;/strong&gt;&amp;rsquo;s &lt;strong&gt;GetLongLength&lt;/strong&gt;, which returns an &lt;strong&gt;Int64&lt;/strong&gt; value that is a &lt;strong&gt;long&lt;/strong&gt; in C# but not
  in other languages (like C++/CLI). Another example is &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;&amp;rsquo;s
  &lt;strong&gt;LongCount&lt;/strong&gt; method.</source>
          <target state="translated">C #을 독점적으로 사용하는 많은 프로그래머는 다른 프로그래밍 언어가 CLR에 대해 사용될 수 있다는 사실을 잊어 버리는 경향이 있으며, 이로 인해 C # -ism은 클래스 라이브러리 코드로 들어갑니다. 예를 들어, Microsoft의 FCL은 거의 독점적으로 C #으로 작성되었으며 FCL 팀의 개발자는 이제 &lt;strong&gt;Array&lt;/strong&gt; 의 &lt;strong&gt;GetLongLength&lt;/strong&gt; 와 같은 메소드를 라이브러리에 도입하여 C #에서는 &lt;strong&gt;길지만&lt;/strong&gt; C ++과 같은 다른 언어로는 &lt;strong&gt;Int64&lt;/strong&gt; 값을 반환합니다. / CLI). 또 다른 예는 &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt; s &lt;strong&gt;LongCount&lt;/strong&gt; 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9df02f88b75a5ae9238b00816debf524d9b6d4bb" translate="yes" xml:space="preserve">
          <source>Many will argue that while this is information technically accurate using &lt;code&gt;String&lt;/code&gt; is still fine because it&amp;rsquo;s exceedingly rare that a code base would define a type of this name. Or that when &lt;code&gt;String&lt;/code&gt; is defined it&amp;rsquo;s a sign of a bad code base.</source>
          <target state="translated">많은 사람들은 이것이 &lt;code&gt;String&lt;/code&gt; 사용하여 기술적으로 정확한 정보이지만 코드베이스 가이 이름의 유형을 정의하는 것은 매우 드물기 때문에 여전히 훌륭하다고 주장합니다. 또는 &lt;code&gt;String&lt;/code&gt; 이 정의되면 잘못된 코드베이스의 표시입니다.</target>
        </trans-unit>
        <trans-unit id="4969c66ffc5656f3999a26d516caf717157af60a" translate="yes" xml:space="preserve">
          <source>Neither statement in the &lt;code&gt;Example&lt;/code&gt; method compiles. Here &lt;code&gt;String&lt;/code&gt; is always a piano &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;string&lt;/a&gt;, &lt;code&gt;MyPiano.String&lt;/code&gt;. No member (&lt;code&gt;static&lt;/code&gt; or not) &lt;code&gt;Format&lt;/code&gt; exists on it (or is inherited from its base class). And the value &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; cannot be converted into it.</source>
          <target state="translated">&lt;code&gt;Example&lt;/code&gt; 메소드의 명령문은 컴파일되지 않습니다. 여기서 &lt;code&gt;String&lt;/code&gt; 은 항상 피아노 &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;문자열&lt;/a&gt; &lt;code&gt;MyPiano.String&lt;/code&gt; 입니다. 멤버가 없습니다 ( &lt;code&gt;static&lt;/code&gt; 이든 아니든). &lt;code&gt;Format&lt;/code&gt; 이 존재하거나 기본 클래스에서 상속됩니다. 그리고 &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; 값은이 값으로 변환 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fa06e504f29a303da31352f8e430b6dc30c1883" translate="yes" xml:space="preserve">
          <source>New answer after 6 years and 5 months (procrastination).</source>
          <target state="translated">6 년 5 개월 후의 새로운 답변 (발견).</target>
        </trans-unit>
        <trans-unit id="296daf449bf0c8664c9e6d199847c7929ad529f1" translate="yes" xml:space="preserve">
          <source>Note: I copy/pasted most of the blog post for archive reason. I ignore some parts, so I recommend to skip and to read the &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;blog post&lt;/a&gt; if you can.</source>
          <target state="translated">참고 : 보관 이유 때문에 대부분의 블로그 게시물을 복사 / 붙여 넣었습니다. 일부 부분은 무시하므로 가능하면 &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;블로그 게시물&lt;/a&gt; 을 건너 뛰고 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="022ba2779e8f9a2cb535c438e2a28ea7b0dd3e80" translate="yes" xml:space="preserve">
          <source>Now that I've been doing it for years, it's a habit and I like the coloration that VS shows for the CLR types.</source>
          <target state="translated">이제 몇 년 동안 해왔으므로 습관이되고 VS가 CLR 유형에 대해 보여주는 채색이 마음에 듭니다.</target>
        </trans-unit>
        <trans-unit id="b3ab40a90e383fb18e0e975a4f3ebb4b8b3eaeff" translate="yes" xml:space="preserve">
          <source>Secondly, when &lt;code&gt;String&lt;/code&gt; is another &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, nested inside the current type:</source>
          <target state="translated">둘째, &lt;code&gt;String&lt;/code&gt; 이 다른 &lt;strong&gt;&lt;em&gt;유형&lt;/em&gt;&lt;/strong&gt; 인 경우 현재 유형 내에 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="e101d4a69cdea700b7d60c87527fa5d12e284702" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;int&lt;/code&gt; maps to &lt;code&gt;System.Int32&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;int&lt;/code&gt; 는 &lt;code&gt;System.Int32&lt;/code&gt; 에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="689346a590d26a7f24b31d23dd2fbc483406fd3b" translate="yes" xml:space="preserve">
          <source>So remember when you see the &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; debate this is about semantics, not style. Choosing string gives crisp meaning to your code base. Choosing &lt;code&gt;String&lt;/code&gt; isn&amp;rsquo;t wrong but it&amp;rsquo;s leaving the door open for surprises in the future.</source>
          <target state="translated">따라서 &lt;code&gt;String&lt;/code&gt; 대 &lt;code&gt;string&lt;/code&gt; 토론을 볼 때 이것이 스타일이 아니라 시맨틱에 관한 것임을 기억하십시오. 문자열을 선택하면 코드 기반에 뚜렷한 의미가 있습니다. &lt;code&gt;String&lt;/code&gt; 선택하는 것은 잘못된 것이 아니지만 앞으로 놀랍도록 문을 열어두고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cb50509dd63b7929b71e5a34e498aabbd13f875" translate="yes" xml:space="preserve">
          <source>So technically, there is no difference.  It's like &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt;&lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">따라서 기술적으로 차이는 없습니다. &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt; &lt;/a&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff2325db982bbc83b6294b8c0dff80dba26d189b" translate="yes" xml:space="preserve">
          <source>So there you have it. I think these are all really good points. I however, don't find myself using Jeffrey's advice in my own code. Maybe I am too stuck in my C# world but I end up trying to make my code look like the framework code.</source>
          <target state="translated">그래서 당신은 그것을 가지고 있습니다. 나는 이것들이 모두 정말 좋은 포인트라고 생각합니다. 그러나 제 코드에서 Jeffrey의 조언을 사용하지 마십시오. 어쩌면 나는 C # 세계에 갇혀 있지만 코드를 프레임 워크 코드처럼 보이게하려고합니다.</target>
        </trans-unit>
        <trans-unit id="84d84cfed9ed57bbe7f2bacafbaddfb81576cf17" translate="yes" xml:space="preserve">
          <source>String (&lt;code&gt;System.String&lt;/code&gt;) is a class in the base class library. string (lower case) is a reserved work in C# that is an alias for System.String. Int32 vs int is a similar situation as is &lt;code&gt;Boolean vs. bool&lt;/code&gt;. These C# language specific keywords enable you to declare primitives in a style similar to C.</source>
          <target state="translated">문자열 ( &lt;code&gt;System.String&lt;/code&gt; )은 기본 클래스 라이브러리의 클래스입니다. string (소문자)은 System.String의 별칭 인 C #에서 예약 된 작업입니다. Int32 vs int는 &lt;code&gt;Boolean vs. bool&lt;/code&gt; 과 비슷한 상황입니다. 이러한 C # 언어 별 키워드를 사용하면 C와 유사한 스타일로 기본 요소를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49ce6a3b5fc76630de40afb2fe0abba3f193580b" translate="yes" xml:space="preserve">
          <source>That's just a matter of the way the spec defines enum declarations - the part after the colon has to be the &lt;em&gt;integral-type&lt;/em&gt; production, which is one token of &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;... as opposed to a &lt;em&gt;type&lt;/em&gt; production as used by variable declarations for example. It doesn't indicate any other difference.</source>
          <target state="translated">그것은 스펙이 열거 선언을 정의하는 방식의 문제입니다. 콜론 다음 부분은 &lt;code&gt;sbyte&lt;/code&gt; , &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;ushort&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;uint&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;ulong&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; 중 하나의 토큰 인 &lt;em&gt;정수 유형&lt;/em&gt; 생산이어야합니다. .. 예를 들어 변수 선언에서 사용되는 &lt;em&gt;형식&lt;/em&gt; 생성과 반대입니다. 다른 차이점은 없습니다.</target>
        </trans-unit>
        <trans-unit id="57cd8f4f9cafb98e0ff1960638924dc3de76b39d" translate="yes" xml:space="preserve">
          <source>The C# keyword &lt;code&gt;string&lt;/code&gt; maps to the .NET type &lt;code&gt;System.String&lt;/code&gt; - it is an alias that keeps to the naming conventions of the language.</source>
          <target state="translated">C # 키워드 &lt;code&gt;string&lt;/code&gt; 은 .NET 유형 &lt;code&gt;System.String&lt;/code&gt; 에 매핑됩니다. 이는 언어의 명명 규칙을 유지하는 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="f49eb70607b2497b91d8c266445436a4abe3155d" translate="yes" xml:space="preserve">
          <source>The C# language specification states, &amp;ldquo;As a matter of style, use of the keyword is favored over
  use of the complete system type name.&amp;rdquo; I disagree with the language specification; I prefer
  to use the FCL type names and completely avoid the primitive type names. In fact, I wish that
  compilers didn&amp;rsquo;t even offer the primitive type names and forced developers to use the FCL
  type names instead. Here are my reasons:</source>
          <target state="translated">C # 언어 사양에는 &quot;스타일에 따라 전체 시스템 유형 이름보다 키워드를 사용하는 것이 좋습니다.&quot; 언어 사양에 동의하지 않습니다. FCL 유형 이름을 사용하고 기본 유형 이름을 완전히 피하는 것을 선호합니다. 실제로 컴파일러가 기본 유형 이름을 제공하지 않았고 개발자가 FCL 유형 이름을 대신 사용하도록 강요했습니다. 내 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fce2e5a5f468c7b1c34cd9768434166999ddbdb0" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For
  example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;,
  &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as
  &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it&amp;rsquo;s legal to write the following
  code, the line with &lt;strong&gt;float&lt;/strong&gt; feels very unnatural to me, and it&amp;rsquo;s not obvious that the line is
  correct:</source>
          <target state="translated">FCL에는 메소드 이름의 일부로 유형 이름이있는 많은 메소드가 있습니다. 예를 들어 &lt;strong&gt;BinaryReader&lt;/strong&gt; 형식은 &lt;strong&gt;ReadBoolean&lt;/strong&gt; , &lt;strong&gt;ReadInt32&lt;/strong&gt; , &lt;strong&gt;ReadSingle&lt;/strong&gt; 등과 같은 메서드를 제공하고 &lt;strong&gt;System.Convert&lt;/strong&gt; 형식은 &lt;strong&gt;ToBoolean&lt;/strong&gt; , &lt;strong&gt;ToInt32&lt;/strong&gt; , &lt;strong&gt;ToSingle&lt;/strong&gt; 등과 같은 메서드를 제공합니다. 다음 코드를 작성하는 것이 합법적이지만 &lt;strong&gt;float&lt;/strong&gt; 가있는 줄은 나에게 부자연스럽고 줄이 올바른지 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d241e925f9c6c70e65ab7201f55f79ecdaebf9ce" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;, &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it's legal to write the following code, the line with float feels very unnatural to me, and it's not obvious that the line is correct:</source>
          <target state="translated">FCL에는 메소드 이름의 일부로 유형 이름이있는 많은 메소드가 있습니다. 예를 들어 &lt;strong&gt;BinaryReader&lt;/strong&gt; 형식은 &lt;strong&gt;ReadBoolean&lt;/strong&gt; , &lt;strong&gt;ReadInt32&lt;/strong&gt; , &lt;strong&gt;ReadSingle&lt;/strong&gt; 등과 같은 메서드를 제공하고 &lt;strong&gt;System.Convert&lt;/strong&gt; 형식은 &lt;strong&gt;ToBoolean&lt;/strong&gt; , &lt;strong&gt;ToInt32&lt;/strong&gt; , &lt;strong&gt;ToSingle&lt;/strong&gt; 등과 같은 메서드를 제공합니다. 다음 코드를 작성하는 것이 합법적이지만 float가있는 줄은 나에게 부자연스럽고 줄이 올바른지 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="245547d31df063b9be5afb5f9f9e26bb654e9990" translate="yes" xml:space="preserve">
          <source>The above will not compile because &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; does not have a non-static member called &lt;code&gt;Format&lt;/code&gt;, and no extension methods apply. In the above case, it may still be possible to use &lt;code&gt;String&lt;/code&gt; in other contexts where a &lt;em&gt;type&lt;/em&gt; is the only possibility syntactically. For example &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; could be OK (depending on namespace and &lt;code&gt;using&lt;/code&gt; directives).</source>
          <target state="translated">&lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; &lt;code&gt;Format&lt;/code&gt; 이라는 비 정적 멤버가 없으며 확장 메소드가 적용되지 않기 때문에 위의 내용은 컴파일되지 않습니다. 위의 경우 구문이 유일한 &lt;em&gt;유형 인&lt;/em&gt; 다른 컨텍스트에서 &lt;code&gt;String&lt;/code&gt; 을 계속 사용할 수 있습니다. 예를 들어 &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; 네임 스페이스에 따라 지시문을 &lt;code&gt;using&lt;/code&gt; OK 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d7a9de8ca807f30e0d84dd6099bf753c98ce135" translate="yes" xml:space="preserve">
          <source>The actual meaning of &lt;code&gt;String&lt;/code&gt; will always depend on name resolution.
  That means it depends on all the source files in the project and all
  the types defined in all the referenced assemblies. In short it
  requires quite a bit of context to &lt;em&gt;know&lt;/em&gt; what it means.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 실제 의미는 항상 이름 확인에 달려 있습니다. 이는 프로젝트의 모든 소스 파일과 참조 된 모든 어셈블리에 정의 된 모든 유형에 따라 달라집니다. 요컨대 그것이 무엇을 의미하는지 &lt;em&gt;알기&lt;/em&gt; 위해서는 약간의 맥락이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="93322148b52efc519b4bbcaebbed28fabcc67ec3" translate="yes" xml:space="preserve">
          <source>The best answer I have ever heard about using the provided type aliases in C# comes from Jeffrey Richter in his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C#&lt;/a&gt;. Here are his 3 reasons:</source>
          <target state="translated">C #에서 제공된 유형 별칭을 사용하는 것에 대해 들었던 가장 좋은 대답은 Jeffrey Richter가 그의 책 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C #&lt;/a&gt; 에서 왔습니다. 그의 세 가지 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04f4e2e05e59044015a06ab9e5709ace1067caeb" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;String&lt;/code&gt; though has no concrete meaning in C#. It is an identifier that goes through all the name lookup rules as &lt;code&gt;Widget&lt;/code&gt;, &lt;code&gt;Student&lt;/code&gt;, etc &amp;hellip; It could bind to string or it could bind to a type in another assembly entirely whose purposes may be entirely different than &lt;code&gt;string&lt;/code&gt;. Worse it could be defined in a way such that code like &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt;; continued to compile.</source>
          <target state="translated">C #에서는 식별자 &lt;code&gt;String&lt;/code&gt; 구체적인 의미가 없습니다. 모든 이름 조회 규칙을 &lt;code&gt;Widget&lt;/code&gt; , &lt;code&gt;Student&lt;/code&gt; 등으로 처리하는 식별자입니다. 문자열에 바인딩하거나 문자열과 목적이 완전히 다른 다른 어셈블리의 유형에 바인딩 할 수 있습니다. 더 나쁜 것은 &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt; 와 같은 코드와 같은 방식으로 정의 될 수 있습니다. 계속 컴파일했다.</target>
        </trans-unit>
        <trans-unit id="3f48daaabbe068f8c313923060dc1ce87907e97a" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt;  is an alias for
 &lt;code&gt;System.String&lt;/code&gt; aside from the keyword issue, the two are exactly
 equivalent.</source>
          <target state="translated">키워드 &lt;code&gt;string&lt;/code&gt; 은 키워드 문제를 제외하고 &lt;code&gt;System.String&lt;/code&gt; 의 별칭이며 둘은 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d5c514298559badf24fce9b8b392cc6d91008feb" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt; has concrete meaning in C#. It is the type &lt;code&gt;System.String&lt;/code&gt; which exists in the core runtime assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings in .NET. Its presence is so critical to C# that if that type doesn&amp;rsquo;t exist the compiler will exit before attempting to even parse a line of code. Hence &lt;code&gt;string&lt;/code&gt; has a precise, unambiguous meaning in C# code.</source>
          <target state="translated">키워드 &lt;code&gt;string&lt;/code&gt; 은 C #에서 구체적인 의미를 갖습니다. 핵심 런타임 어셈블리에 존재하는 &lt;code&gt;System.String&lt;/code&gt; 유형입니다. 런타임은 본질적으로이 유형을 이해하고 개발자가 .NET의 문자열에 기대하는 기능을 제공합니다. 그 존재는 C #에 매우 중요하므로 해당 유형이 존재하지 않으면 코드 줄을 구문 분석하기 전에 컴파일러가 종료됩니다. 따라서 &lt;code&gt;string&lt;/code&gt; 은 C # 코드에서 정확하고 명확한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="baaf13d4a47a17e15308fe16fb596475d6a15088" translate="yes" xml:space="preserve">
          <source>The only practical difference is the syntax highlighting as you mention, and that you have to write &lt;code&gt;using System&lt;/code&gt; if you use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">실용적인 차이점은 언급 한 것처럼 구문 강조 표시이며 &lt;code&gt;String&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;using System&lt;/code&gt; 을 사용 하여 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8668abfb621e1b2a22882756e57d856bcfbf3e47" translate="yes" xml:space="preserve">
          <source>The only real downer is that auto-complete uses the C# type, so I end up re-typing automatically generated types to specify the CLR type instead.</source>
          <target state="translated">유일한 단점은 자동 완성이 C # 유형을 사용한다는 것입니다. 따라서 자동 생성 된 유형을 다시 입력하여 CLR 유형을 대신 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9c532ca7d467cf6352c36952f31402d9053b7bfb" translate="yes" xml:space="preserve">
          <source>Theoretically this could help to port code into some future 64-bit standard in which &quot;int&quot; might mean &lt;code&gt;Int64&lt;/code&gt;, but that's not the point, and I would expect any upgrade wizard to change any &lt;code&gt;int&lt;/code&gt; references to &lt;code&gt;Int32&lt;/code&gt; anyway just to be safe.</source>
          <target state="translated">이론적으로 이것은 &quot;int&quot;가 &lt;code&gt;Int64&lt;/code&gt; 를 의미하는 미래의 64 비트 표준으로 코드를 포팅하는 데 도움이 될 수 있지만, 요점은 아니며 업그레이드 마법사가 int32에 대한 &lt;code&gt;int&lt;/code&gt; 참조를 안전하게 변경하기를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="1b43e8aad6972ff5253750d89b626a58fe50142a" translate="yes" xml:space="preserve">
          <source>Theoretically, you could implement a C#-compiler that generated Java bytecode. A sensible implementation of this compiler would probably map &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/strong&gt; in order to interoperate with the Java runtime library.</source>
          <target state="translated">이론적으로 Java 바이트 코드를 생성 한 C # 컴파일러를 구현할 수 있습니다. 이 컴파일러의 현명한 구현은 Java 런타임 라이브러리와 상호 운용하기 위해 &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; 을 &lt;strong&gt; &lt;code&gt;java.lang.String&lt;/code&gt; &lt;/strong&gt; 에 맵핑 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b9cef7d16318b618f7d7e05ce428e421145a3eb1" translate="yes" xml:space="preserve">
          <source>There is no difference.</source>
          <target state="translated">다른 점이 없다.</target>
        </trans-unit>
        <trans-unit id="e724cb1ff2ea7523a1d7006294c3e2e3b6908113" translate="yes" xml:space="preserve">
          <source>There is one circumstance in which you &lt;em&gt;have&lt;/em&gt; to use the aliases: when explicitly specifying an enum's underlying type. For instance:</source>
          <target state="translated">열거 형의 기본 유형을 명시 적으로 지정할 때 별칭을 사용해야하는 한 가지 상황이 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="db457529845002230c6c5b574e656447dd4b91e6" translate="yes" xml:space="preserve">
          <source>There's a debate over whether you should use the System types (&lt;code&gt;System.Int32&lt;/code&gt;, &lt;code&gt;System.String&lt;/code&gt;, etc.) types or the &lt;code&gt;C# aliases&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, etc). I personally believe you should use the &lt;code&gt;C# aliases&lt;/code&gt;, but that's just my personal preference.</source>
          <target state="translated">시스템 유형 ( &lt;code&gt;System.Int32&lt;/code&gt; , &lt;code&gt;System.String&lt;/code&gt; 등) 유형을 사용해야하는지 또는 &lt;code&gt;C# aliases&lt;/code&gt; ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; 등)을 사용해야하는지에 대한 논쟁이 있습니다. 나는 개인적으로 &lt;code&gt;C# aliases&lt;/code&gt; 을 사용해야한다고 생각하지만 그것은 내 개인적인 취향 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="591cd0b1a64565e8d55765f16e4e309da97495fb" translate="yes" xml:space="preserve">
          <source>There's a quote on this issue from &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;Daniel Solis' book&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;Daniel Solis의 저서&lt;/a&gt; 에서이 문제에 대한 인용문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd310fee67eed80e9424306ba0e405b3b78a9e96" translate="yes" xml:space="preserve">
          <source>This is the style that Microsoft tends to use in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;their examples&lt;/a&gt;.</source>
          <target state="translated">이것은 Microsoft &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;가 예제&lt;/a&gt; 에서 사용하는 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="f6a887af1a34c7a21a8c77639ce417b3bb91f2d6" translate="yes" xml:space="preserve">
          <source>True that in the vast majority of cases &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; will bind to
  the same type. But using &lt;code&gt;String&lt;/code&gt; still means developers are leaving
  their program up to interpretation in places where there is only one
  correct answer. When &lt;code&gt;String&lt;/code&gt; does bind to the wrong type it can leave
  developers debugging for hours, filing bugs on the compiler team and
  generally wasting time that could&amp;rsquo;ve been saved by using &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;string&lt;/code&gt; 이 동일한 유형에 바인딩됩니다. 그러나 &lt;code&gt;String&lt;/code&gt; 사용한다는 것은 개발자가 정답이 하나만있는 곳에서 프로그램을 해석 할 수있게하는 것을 의미합니다. &lt;code&gt;String&lt;/code&gt; 이 잘못된 유형에 바인딩되면 개발자가 몇 시간 동안 디버깅하고 컴파일러 팀에 버그를 제기하고 일반적으로 &lt;code&gt;string&lt;/code&gt; 을 사용하여 절약 할 수있는 시간을 낭비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="080151d9d06a4a0841ea36ef9ee84dcdb90f489e" translate="yes" xml:space="preserve">
          <source>Using System types makes it easier to port between C# and VB.Net, if you are into that sort of thing.</source>
          <target state="translated">시스템 유형을 사용하면 C #과 VB.Net 간을 쉽게 이식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbaa6241d89ea80c39692aa3b5ba27d31a981924" translate="yes" xml:space="preserve">
          <source>What are the &lt;strong&gt;&lt;em&gt;guidelines&lt;/em&gt;&lt;/strong&gt; for the use of each? And what are the &lt;strong&gt;&lt;em&gt;differences&lt;/em&gt;&lt;/strong&gt;?</source>
          <target state="translated">각각의 사용에 대한 &lt;strong&gt;&lt;em&gt;지침&lt;/em&gt;&lt;/strong&gt; 은 무엇입니까? &lt;strong&gt;&lt;em&gt;차이점&lt;/em&gt;&lt;/strong&gt; 은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bd9579b2d38cc31bb5131600b18e1a9c58740e90" translate="yes" xml:space="preserve">
          <source>What is the difference between String and string in C#</source>
          <target state="translated">C #에서 문자열과 문자열의 차이점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="e71d05ee8c65811fde766fc86a9a2312a31589aa" translate="yes" xml:space="preserve">
          <source>When we talk about &lt;code&gt;.NET&lt;/code&gt; there are two different things one there is &lt;code&gt;.NET&lt;/code&gt; framework and the other there are languages ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; etc) which use that framework.</source>
          <target state="translated">&lt;code&gt;.NET&lt;/code&gt; 에 대해 이야기 할 때 &lt;code&gt;.NET&lt;/code&gt; 프레임 워크가 있고 다른 프레임 워크를 사용하는 언어 ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; 등)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f3e96542caf20f14fe703e23e36cf1f92b45e0e" translate="yes" xml:space="preserve">
          <source>When you use C# together with the CLR &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; will be mapped to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">C #을 CLR &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; 과 함께 사용하면 &lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; 에&lt;/strong&gt; 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="6da5e0c25b5beda54e8637b0d410f9bcc6da7930" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;string&lt;/code&gt; is a reserved C# keyword that always has a fixed meaning, &lt;code&gt;String&lt;/code&gt; is just an ordinary &lt;em&gt;identifier&lt;/em&gt; which could refer to anything. Depending on members of the current type, the current namespace and the applied &lt;code&gt;using&lt;/code&gt; directives and their placement, &lt;code&gt;String&lt;/code&gt; could be a value or a type distinct from &lt;code&gt;global::System.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 항상 고정 된 의미를 갖는 예약 된 C # 키워드이지만 &lt;code&gt;String&lt;/code&gt; 은 무엇이든 참조 할 수있는 일반적인 &lt;em&gt;식별자&lt;/em&gt; 입니다. 현재 유형의 멤버, 현재 네임 스페이스 및 적용된 &lt;code&gt;using&lt;/code&gt; 지시문 및 해당 배치에 따라 &lt;code&gt;String&lt;/code&gt; 은 &lt;code&gt;global::System.String&lt;/code&gt; 다른 값 또는 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d746517e1decf0d12e57b19ed8b079d7d2ff727" translate="yes" xml:space="preserve">
          <source>Worse: Saying &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; will likely (depending on &lt;code&gt;using&lt;/code&gt;s) go to the Linq extension method &lt;code&gt;Enumerable.Concat&lt;/code&gt;. It will not go to the static method &lt;code&gt;string.Concat&lt;/code&gt;.</source>
          <target state="translated">더 나쁜 것은 : &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; 이 (s &lt;code&gt;using&lt;/code&gt; 에 따라 다름) Linq 확장 메소드 &lt;code&gt;Enumerable.Concat&lt;/code&gt; 으로 갈 것입니다. 정적 메소드 &lt;code&gt;string.Concat&lt;/code&gt; 로 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="825f170ba301d67aee52cb32cfb74d6313352781" translate="yes" xml:space="preserve">
          <source>Yes, that's no difference between them, just like the &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">예, &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;Boolean&lt;/code&gt; 과 같이 차이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bfe5ac3a85fb8412165790973b10eb661d8a34a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that &lt;code&gt;String&lt;/code&gt; is defined for a number of completely valid purposes: reflection helpers, serialization libraries, lexers, protocols, etc &amp;hellip; For any of these libraries &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; has real consequences depending on where the code is used.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 은 리플렉션 헬퍼, 시리얼 라이 제이션 라이브러리, 어휘 분석기, 프로토콜 등 여러 가지 유효한 목적으로 정의되어 있음을 알 수 있습니다. 이러한 라이브러리 중 하나에 대해 &lt;code&gt;String&lt;/code&gt; 대 &lt;code&gt;string&lt;/code&gt; 은 코드가 사용되는 위치에 따라 실제 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="7f23f0b182ad02e9f6f6309b506e9b8da87ba491" translate="yes" xml:space="preserve">
          <source>object: &lt;code&gt;System.Object&lt;/code&gt;, string: &lt;code&gt;System.String&lt;/code&gt;, bool: &lt;code&gt;System.Boolean&lt;/code&gt;, byte: &lt;code&gt;System.Byte&lt;/code&gt;, sbyte: &lt;code&gt;System.SByte&lt;/code&gt;, short: &lt;code&gt;System.Int16&lt;/code&gt; and so on</source>
          <target state="translated">object : &lt;code&gt;System.Object&lt;/code&gt; , 문자열 : &lt;code&gt;System.String&lt;/code&gt; , bool : &lt;code&gt;System.Boolean&lt;/code&gt; , byte : &lt;code&gt;System.Byte&lt;/code&gt; , sbyte : &lt;code&gt;System.SByte&lt;/code&gt; , short : &lt;code&gt;System.Int16&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
