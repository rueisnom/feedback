<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/7074">
    <body>
      <group id="7074">
        <trans-unit id="228d68628714cc2360e68afeab589f17918ce691" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;System.String&lt;/code&gt;&quot; a.k.a &quot;String&quot; ( capital &quot;S&quot;) is a &lt;code&gt;.NET&lt;/code&gt; framework data type while &quot;string&quot; is a &lt;code&gt;C#&lt;/code&gt; data type.</source>
          <target state="translated">&quot; &lt;code&gt;System.String&lt;/code&gt; &quot;, tambi&amp;eacute;n conocido como &quot;String&quot; (may&amp;uacute;scula &quot;S&quot;) es un tipo de datos de marco &lt;code&gt;.NET&lt;/code&gt; , mientras que &quot;string&quot; es un tipo de datos &lt;code&gt;C#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66dc7eeaeac7b1a7dc09e3938dafceafda64d5d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;This YouTube&lt;/a&gt; video demonstrates practically how they differ.</source>
          <target state="translated">&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;Este&lt;/a&gt; video de YouTube demuestra pr&amp;aacute;cticamente c&amp;oacute;mo se diferencian.</target>
        </trans-unit>
        <trans-unit id="26f52da3f6db7a342ae3830a5e6491f9174f7950" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; is an alias in C# for &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; es un alias en C # para &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b042ac29881f76cecc22db88fda9a3b4320d85be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (a developer on the C# compiler and prolific SO user!) wrote a &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;great blog post&lt;/a&gt; on this issue. I think it is worth sharing here. It is a nice perspective on our subject.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (un desarrollador en el compilador de C # y prol&amp;iacute;fico usuario SO!) Escribi&amp;oacute; una &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;gran publicaci&amp;oacute;n de blog&lt;/a&gt; sobre este tema. Creo que vale la pena compartirlo aqu&amp;iacute;. Es una buena perspectiva sobre nuestro tema.</target>
        </trans-unit>
        <trans-unit id="e63e166e9fed4ca1e3a3e31ed1fd9eabcb1c9955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; is not a keyword and it can be used as Identifier whereas &lt;code&gt;string&lt;/code&gt; is a keyword and cannot be used as Identifier. And in function point of view both are same.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; no es una palabra clave y se puede usar como identificador, mientras que la &lt;code&gt;string&lt;/code&gt; es una palabra clave y no se puede usar como identificador. Y en el punto de vista funcional, ambos son iguales.</target>
        </trans-unit>
        <trans-unit id="b90e7af3ecb39b51fb79fa8592f0f1d9ae9ddcb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; stands for &lt;code&gt;System.String&lt;/code&gt; and it is a .NET Framework type. &lt;strong&gt;&lt;code&gt;string&lt;/code&gt; is an alias&lt;/strong&gt; in the C# language for  &lt;code&gt;System.String&lt;/code&gt;. Both of them are compiled to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt; in IL&lt;/strong&gt; (Intermediate Language), so there is no difference. Choose what you like and use that. If you code in C#, I'd prefer &lt;code&gt;string&lt;/code&gt; as it's a C# type alias and well-known by C# programmers.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; significa &lt;code&gt;System.String&lt;/code&gt; y es un tipo de .NET Framework. &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; es un alias&lt;/strong&gt; en el lenguaje C # para &lt;code&gt;System.String&lt;/code&gt; . Ambos est&amp;aacute;n compilados en &lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; en IL&lt;/strong&gt; (lenguaje intermedio), por lo que no hay diferencia. Elige lo que te gusta y &amp;uacute;salo. Si codifica en C #, preferir&amp;iacute;a una &lt;code&gt;string&lt;/code&gt; ya que es un alias de tipo C # y muy conocido por los programadores de C #.</target>
        </trans-unit>
        <trans-unit id="21dfdc708b7c6d9ddde1026c9f823a48e07357f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System.String&lt;/code&gt; is the .NET string class - in C# &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt; - so in use they are the same.</source>
          <target state="translated">&lt;code&gt;System.String&lt;/code&gt; es la clase de cadena .NET, en C # &lt;code&gt;string&lt;/code&gt; es un alias para &lt;code&gt;System.String&lt;/code&gt; , por lo que en uso son lo mismo.</target>
        </trans-unit>
        <trans-unit id="e4be40d094b8761d8b0a8af7779ee11906a863a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are identical in all ways (except the uppercase &quot;S&quot;).  There are no performance implications either way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; y &lt;code&gt;String&lt;/code&gt; son id&amp;eacute;nticos en todos los sentidos (excepto la &quot;S&quot; may&amp;uacute;scula). No hay implicaciones de rendimiento de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="d8840747d529a1ab2e607b537ad66fd66839abb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is a reserved word, but &lt;code&gt;String&lt;/code&gt; is just a class name. 
This means that &lt;code&gt;string&lt;/code&gt; cannot be used as a variable name by itself.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; es una palabra reservada, pero &lt;code&gt;String&lt;/code&gt; es solo un nombre de clase. Esto significa que la &lt;code&gt;string&lt;/code&gt; no se puede usar como un nombre de variable por s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="da5062e4b9764acaa414144e97820d32c0973476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is an alias (or shorthand) of &lt;code&gt;System.String&lt;/code&gt;. That means, by typing &lt;code&gt;string&lt;/code&gt; we meant &lt;code&gt;System.String&lt;/code&gt;. You can read more in think link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string' is an alias/shorthand of System.String.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; es un alias (o abreviatura) de &lt;code&gt;System.String&lt;/code&gt; . Eso significa que, al escribir &lt;code&gt;string&lt;/code&gt; , nos referimos a &lt;code&gt;System.String&lt;/code&gt; . Puede leer m&amp;aacute;s en think link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string' es un alias / abreviatura de System.String.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d8e4bba708dfba56ed459601d498e8840f3e123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is just an alias for &lt;code&gt;System.String&lt;/code&gt;. The compiler will treat them identically.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; es solo un alias para &lt;code&gt;System.String&lt;/code&gt; . El compilador los tratar&amp;aacute; de forma id&amp;eacute;ntica.</target>
        </trans-unit>
        <trans-unit id="f084ec9e9d82162f7fbc5659d6f160720497365a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; is not a style debate</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; no es un debate de estilo</target>
        </trans-unit>
        <trans-unit id="255b406fa6b9e0823de8f80e3455112e9d159128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt; is a type in the CLR.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; es un tipo en el CLR.</target>
        </trans-unit>
        <trans-unit id="26877e9563383a6b546ae7a361569c47dfb9f7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; is a type in C#.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; es un tipo en C #.</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="012b988247360c0d3de48ea273a8db4bf1d33c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the million dollar question from programmer's point of view So when to use &quot;String&quot; and &quot;string&quot;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ahora la pregunta del mill&amp;oacute;n desde el punto de vista del programador Entonces, &amp;iquest;cu&amp;aacute;ndo usar &quot;String&quot; y &quot;string&quot;?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c0d1a72db9895ccfb9110378ecf99a8542224" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String&lt;/strong&gt; is not a keyword, and you can use it as an identifier:</source>
          <target state="translated">&lt;strong&gt;La cadena&lt;/strong&gt; no es una palabra clave, y puede usarla como identificador:</target>
        </trans-unit>
        <trans-unit id="0b0d36dbb427e4a1a0640b4c1188d84e0f6b2c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is one difference&lt;/strong&gt; - you can't use &lt;code&gt;String&lt;/code&gt; without &lt;code&gt;using System;&lt;/code&gt; beforehand.</source>
          <target state="translated">&lt;strong&gt;Hay una diferencia&lt;/strong&gt; : no puede usar &lt;code&gt;String&lt;/code&gt; sin &lt;code&gt;using System;&lt;/code&gt; antemano.</target>
        </trans-unit>
        <trans-unit id="cbf2f4931f55b8ad0bf613d33ab6ad8bddf5c12a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;string&lt;/strong&gt; is a keyword, and you can't use string as an identifier.</source>
          <target state="translated">&lt;strong&gt;string&lt;/strong&gt; es una palabra clave y no puede usar string como identificador.</target>
        </trans-unit>
        <trans-unit id="b9559fcbc971e124aaf1fe39290213f4b148f9ba" translate="yes" xml:space="preserve">
          <source>Against what seems to be common practice among other programmers, I prefer &lt;code&gt;String&lt;/code&gt; over &lt;code&gt;string&lt;/code&gt;, just to highlight the fact that &lt;code&gt;String&lt;/code&gt; is a reference type, as Jon Skeet mentioned.</source>
          <target state="translated">Frente a lo que parece ser una pr&amp;aacute;ctica com&amp;uacute;n entre otros programadores, prefiero &lt;code&gt;String&lt;/code&gt; sobre &lt;code&gt;string&lt;/code&gt; , solo para resaltar el hecho de que &lt;code&gt;String&lt;/code&gt; es un tipo de referencia, como mencion&amp;oacute; Jon Skeet.</target>
        </trans-unit>
        <trans-unit id="fdb501029b56570afb94f9ed29293d4141dc5953" translate="yes" xml:space="preserve">
          <source>All the predefined types  are mapped directly to
  underlying .NET types. The C# type names (string) are simply aliases for the
  .NET types (String or System.String), so using the .NET names works fine syntactically, although
  this is discouraged. Within a C# program, you should use the C# names
  rather than the .NET names.</source>
          <target state="translated">Todos los tipos predefinidos están mapeados directamente a los tipos .NET subyacentes.Los nombres de los tipos C#(string)son simplemente alias para los tipos .NET (String o System.String),por lo que usar los nombres .NET funciona bien sintácticamente,aunque esto se desaconseja.Dentro de un programa de C#,debería utilizar los nombres de C#en lugar de los de .NET.</target>
        </trans-unit>
        <trans-unit id="d98984153e55855cca8c4e5f7e443623850db2b0" translate="yes" xml:space="preserve">
          <source>Also, now, when I see &quot;int&quot; or &quot;string&quot;, it just looks really wrong to me, like I'm looking at 1970's C code.</source>
          <target state="translated">Además,ahora,cuando veo &quot;int&quot; o &quot;string&quot;,me parece que está muy mal,como si estuviera viendo un código C de 1970.</target>
        </trans-unit>
        <trans-unit id="c77c986c978db50c2edb1530b6d7604bb90ae875" translate="yes" xml:space="preserve">
          <source>Another critical difference: Stack Overflow highlights them differently.</source>
          <target state="translated">Otra diferencia crítica:El desbordamiento de la pila los resalta de manera diferente.</target>
        </trans-unit>
        <trans-unit id="337038535cd28955eae1f640e7096e40e7631b25" translate="yes" xml:space="preserve">
          <source>Another way to visualize the difference is with this sample:</source>
          <target state="translated">Otra forma de visualizar la diferencia es con esta muestra:</target>
        </trans-unit>
        <trans-unit id="a60b6da79539bdc8b7cb297451feb7d858cf6d80" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, the aliases are all to value types. &lt;code&gt;decimal&lt;/code&gt; is a value type, but not a primitive type in the CLR. The only primitive type which doesn't have an alias is &lt;code&gt;System.IntPtr&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la &lt;code&gt;string&lt;/code&gt; y el &lt;code&gt;object&lt;/code&gt; , los alias son todos para los tipos de valor. &lt;code&gt;decimal&lt;/code&gt; es un tipo de valor, pero no un tipo primitivo en el CLR. El &amp;uacute;nico tipo primitivo que no tiene un alias es &lt;code&gt;System.IntPtr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbcd6fabeac0fa1e903b96ce302d37cc9ab55a9" translate="yes" xml:space="preserve">
          <source>As far as guidelines, it's generally recommended to use &lt;code&gt;string&lt;/code&gt; any time you're referring to an object.</source>
          <target state="translated">En cuanto a las pautas, generalmente se recomienda usar &lt;code&gt;string&lt;/code&gt; cada vez que se refiera a un objeto.</target>
        </trans-unit>
        <trans-unit id="0d8db7a7da3c8e55c6ef7583c26653161b5963c8" translate="yes" xml:space="preserve">
          <source>As for guidelines I wouldn't get too bogged down and just use whichever you feel like - there are more important things in life and the code is going to be the same anyway.</source>
          <target state="translated">En cuanto a las directrices,no me quedaría demasiado atascado y usaría lo que quisieras,hay cosas más importantes en la vida y el código va a ser el mismo de todos modos.</target>
        </trans-unit>
        <trans-unit id="49f6b692ecbc8ab730cec2fc66a93ce1d36c6a77" translate="yes" xml:space="preserve">
          <source>As others have noted, &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;. They compile to the same code, so at execution time there is no difference whatsoever. This is just one of the aliases in C#. The complete list is:</source>
          <target state="translated">Como otros han notado, &lt;code&gt;string&lt;/code&gt; es un alias para &lt;code&gt;System.String&lt;/code&gt; . Se compilan con el mismo c&amp;oacute;digo, por lo que en el momento de la ejecuci&amp;oacute;n no hay diferencia alguna. Este es solo uno de los alias en C #. La lista completa es:</target>
        </trans-unit>
        <trans-unit id="dfd1c1e7e5f7162b6737b19a1d23e4b8e738b888" translate="yes" xml:space="preserve">
          <source>As the others are saying, they're the same.  StyleCop rules, by default, will enforce you to use &lt;code&gt;string&lt;/code&gt; as a C# code style best practice, except when referencing &lt;code&gt;System.String&lt;/code&gt; static functions, such as &lt;code&gt;String.Format&lt;/code&gt;, &lt;code&gt;String.Join&lt;/code&gt;, &lt;code&gt;String.Concat&lt;/code&gt;, etc...</source>
          <target state="translated">Como dicen los dem&amp;aacute;s, son lo mismo. Las reglas de StyleCop, de forma predeterminada, le obligar&amp;aacute;n a usar &lt;code&gt;string&lt;/code&gt; como una pr&amp;aacute;ctica recomendada de estilo de c&amp;oacute;digo C #, excepto cuando haga referencia a funciones est&amp;aacute;ticas de &lt;code&gt;System.String&lt;/code&gt; , como &lt;code&gt;String.Format&lt;/code&gt; , &lt;code&gt;String.Join&lt;/code&gt; , &lt;code&gt;String.Concat&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="d3e69bc36fcde9e95937ddabcf28d8aa1e3d28c7" translate="yes" xml:space="preserve">
          <source>Both are same. But from coding guidelines perspective it's better to use &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;. This is what generally developers use. e.g. instead of using &lt;code&gt;Int32&lt;/code&gt; we use &lt;code&gt;int&lt;/code&gt; as &lt;code&gt;int&lt;/code&gt; is alias to &lt;code&gt;Int32&lt;/code&gt;</source>
          <target state="translated">Ambos son lo mismo. Pero desde la perspectiva de las pautas de codificaci&amp;oacute;n, es mejor usar &lt;code&gt;string&lt;/code&gt; en lugar de &lt;code&gt;String&lt;/code&gt; . Esto es lo que generalmente usan los desarrolladores. por ejemplo, en lugar de usar &lt;code&gt;Int32&lt;/code&gt; , usamos &lt;code&gt;int&lt;/code&gt; como &lt;code&gt;int&lt;/code&gt; es un alias de &lt;code&gt;Int32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11a99bfdab95ac5c2ba17b81950872e8650ba272" translate="yes" xml:space="preserve">
          <source>But now for a long textual answer.</source>
          <target state="translated">Pero ahora para una larga respuesta textual.</target>
        </trans-unit>
        <trans-unit id="bf90ee429ac8f8bc62dfdefed6e11fb05e6fc23e" translate="yes" xml:space="preserve">
          <source>C# is a language which is used together with the CLR.</source>
          <target state="translated">La C#es un lenguaje que se usa junto con el CLR.</target>
        </trans-unit>
        <trans-unit id="9d5c764a1acaa5b5bcb96101fe97b4133de42c33" translate="yes" xml:space="preserve">
          <source>Coming late to the party: I use the CLR types 100% of the time (well, except if &lt;em&gt;forced&lt;/em&gt; to use the C# type, but I don't remember when the last time that was).</source>
          <target state="translated">Llegando tarde a la fiesta: uso los tipos CLR el 100% del tiempo (bueno, excepto si me veo &lt;em&gt;obligado&lt;/em&gt; a usar el tipo C #, pero no recuerdo cu&amp;aacute;ndo fue la &amp;uacute;ltima vez).</target>
        </trans-unit>
        <trans-unit id="84b6fa77f09cddf191ebef51dd09349c2e4423ea" translate="yes" xml:space="preserve">
          <source>Conditional and control keywords (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;) are lowercase and colored dark blue (by default). And I would rather not have the disagreement in use and format.</source>
          <target state="translated">Las palabras clave condicionales y de control (como &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; y &lt;code&gt;return&lt;/code&gt; ) son min&amp;uacute;sculas y de color azul oscuro (por defecto). Y preferir&amp;iacute;a no tener el desacuerdo en el uso y el formato.</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="63cf87d7199d567617ea4b6ca5ec4e87620d8625" translate="yes" xml:space="preserve">
          <source>Example (&lt;em&gt;note the case&lt;/em&gt;):</source>
          <target state="translated">Ejemplo ( &lt;em&gt;tenga en cuenta el caso&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="52936f8d320a5c9edae9467890ff6b3835ae84b6" translate="yes" xml:space="preserve">
          <source>FYI
&amp;ldquo;The keyword string is simply an alias for the predefined class &lt;code&gt;System.String&lt;/code&gt;.&amp;rdquo; - C# Language Specification 4.2.3
&lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</source>
          <target state="translated">FYI &quot;La cadena de palabras clave es simplemente un alias para la clase predefinida &lt;code&gt;System.String&lt;/code&gt; &quot;. - Especificaci&amp;oacute;n del lenguaje C # 4.2.3 &lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58792e3b925f31858fc5ea747e687bdc0f62a6ae" translate="yes" xml:space="preserve">
          <source>Finally, when it comes to which to use: personally I use the aliases everywhere for the implementation, but the CLR type for any APIs. It really doesn't matter too much which you use in terms of implementation - consistency among your team is nice, but no-one else is going to care. On the other hand, it's genuinely important that if you refer to a type in an API, you do so in a language-neutral way. A method called &lt;code&gt;ReadInt32&lt;/code&gt; is unambiguous, whereas a method called &lt;code&gt;ReadInt&lt;/code&gt; requires interpretation. The caller could be using a language that defines an &lt;code&gt;int&lt;/code&gt; alias for &lt;code&gt;Int16&lt;/code&gt;, for example. The .NET framework designers have followed this pattern, good examples being in the &lt;code&gt;BitConverter&lt;/code&gt;, &lt;code&gt;BinaryReader&lt;/code&gt; and &lt;code&gt;Convert&lt;/code&gt; classes.</source>
          <target state="translated">Finalmente, cuando se trata de cu&amp;aacute;l usar: personalmente uso los alias en todas partes para la implementaci&amp;oacute;n, pero el tipo CLR para cualquier API. Realmente no importa demasiado lo que use en t&amp;eacute;rminos de implementaci&amp;oacute;n: la consistencia entre su equipo es agradable, pero a nadie m&amp;aacute;s le importar&amp;aacute;. Por otro lado, es realmente importante que si se refiere a un tipo en una API, lo haga de forma neutral en cuanto al idioma. Un m&amp;eacute;todo llamado &lt;code&gt;ReadInt32&lt;/code&gt; no es ambiguo, mientras que un m&amp;eacute;todo llamado &lt;code&gt;ReadInt&lt;/code&gt; requiere interpretaci&amp;oacute;n. La persona que llama podr&amp;iacute;a estar usando un lenguaje que define un alias &lt;code&gt;int&lt;/code&gt; para &lt;code&gt;Int16&lt;/code&gt; , por ejemplo. Los dise&amp;ntilde;adores de .NET Framework han seguido este patr&amp;oacute;n, siendo buenos ejemplos en las &lt;code&gt;BitConverter&lt;/code&gt; , &lt;code&gt;BinaryReader&lt;/code&gt; y &lt;code&gt;Convert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361f354e3c112924a67a6cd4e52c6912aa86f34b" translate="yes" xml:space="preserve">
          <source>First thing to avoid confusion use one of them consistently. But from best practices perspective when you do variable declaration it's good to use &quot;string&quot; ( small &quot;s&quot;) and when you are using it as a class name then &quot;String&quot; ( capital &quot;S&quot;) is preferred.</source>
          <target state="translated">Lo primero que hay que hacer para evitar confusiones es usar uno de ellos de forma consistente.Pero desde la perspectiva de las mejores prácticas cuando se hace la declaración de variables es bueno usar &quot;cadena&quot; (&quot;s&quot; pequeña)y cuando se usa como nombre de clase se prefiere &quot;Cadena&quot; (&quot;S&quot; mayúscula).</target>
        </trans-unit>
        <trans-unit id="901ba968f95a818d5303d46cf8a18ecd2e7bfdd0" translate="yes" xml:space="preserve">
          <source>First, when &lt;code&gt;String&lt;/code&gt; is a &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt; of the current type (or a local variable):</source>
          <target state="translated">Primero, cuando &lt;code&gt;String&lt;/code&gt; es un &lt;strong&gt;&lt;em&gt;valor&lt;/em&gt;&lt;/strong&gt; del tipo actual (o una variable local):</target>
        </trans-unit>
        <trans-unit id="ee5cc7375a72753d04afe3ef92339bdd63c94ee7" translate="yes" xml:space="preserve">
          <source>I can say the same about &lt;strong&gt;(&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;System.Int32&lt;/code&gt;)&lt;/strong&gt; etc..</source>
          <target state="translated">Puedo decir lo mismo sobre &lt;strong&gt;( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;System.Int32&lt;/code&gt; )&lt;/strong&gt; etc.</target>
        </trans-unit>
        <trans-unit id="ea3e61270f6cf9945f0a83b40b68501c8a543b14" translate="yes" xml:space="preserve">
          <source>I didn't get his opinion before I read the complete paragraph.</source>
          <target state="translated">No conseguí su opinión antes de leer el párrafo completo.</target>
        </trans-unit>
        <trans-unit id="d5494c0741861941dbb77b1154505ecd11f5b5b3" translate="yes" xml:space="preserve">
          <source>I originally started doing this years ago, as per the CLR books by Ritchie. It made sense to me that all CLR languages ultimately have to be able to support the set of CLR types, so using the CLR types yourself provided clearer, and possibly more &quot;reusable&quot; code.</source>
          <target state="translated">Empecé a hacer esto hace años,según los libros de CLR de Ritchie.Tenía sentido para mí que todos los lenguajes CLR en última instancia tienen que ser capaces de soportar el conjunto de tipos CLR,así que el uso de los tipos CLR usted mismo proporcionó un código más claro,y posiblemente más &quot;reutilizable&quot;.</target>
        </trans-unit>
        <trans-unit id="b41709e8dc275dd7834960616cb7974a5926cbc8" translate="yes" xml:space="preserve">
          <source>I prefer the capitalized &lt;code&gt;.NET&lt;/code&gt; types (rather than the aliases) for formatting reasons. The &lt;code&gt;.NET&lt;/code&gt; types are colored the same as other object types (the value types are proper objects, after all).</source>
          <target state="translated">Prefiero los tipos &lt;code&gt;.NET&lt;/code&gt; en may&amp;uacute;sculas (en lugar de los alias) por razones de formato. Los tipos &lt;code&gt;.NET&lt;/code&gt; tienen el mismo color que otros tipos de objetos (los tipos de valor son objetos adecuados, despu&amp;eacute;s de todo).</target>
        </trans-unit>
        <trans-unit id="5a239d3ab937b3004575ec484c47a6e4ed49e68f" translate="yes" xml:space="preserve">
          <source>I shall provide two examples where &lt;em&gt;&lt;code&gt;using&lt;/code&gt; directives will not help&lt;/em&gt;.</source>
          <target state="translated">Proporcionar&amp;eacute; dos ejemplos donde &lt;em&gt; &lt;code&gt;using&lt;/code&gt; directivas no ayudar&amp;aacute;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa93903e288f3d4e16cf4bb1f90b96f48052393" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt;
  or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# &lt;strong&gt;string&lt;/strong&gt; (a keyword) maps exactly to
  &lt;strong&gt;System.String&lt;/strong&gt; (an FCL type), there is no difference and either can be used. Similarly,
  I&amp;rsquo;ve heard some developers say that &lt;strong&gt;int&lt;/strong&gt; represents a 32-bit integer when the application
  is running on a 32-bit OS and that it represents a 64-bit integer when the application
  is running on a 64-bit OS. This statement is absolutely false: in C#, an &lt;strong&gt;int&lt;/strong&gt; always maps
  to &lt;strong&gt;System.Int32&lt;/strong&gt;, and therefore it represents a 32-bit integer regardless of the OS the
  code is running on. If programmers would use &lt;strong&gt;Int32&lt;/strong&gt; in their code, then this potential
  confusion is also eliminated.</source>
          <target state="translated">He visto a varios desarrolladores confundidos, sin saber si usar &lt;strong&gt;string&lt;/strong&gt; o &lt;strong&gt;String&lt;/strong&gt; en su c&amp;oacute;digo. Debido a que en la &lt;strong&gt;cadena&lt;/strong&gt; C # (una palabra clave) se asigna exactamente a &lt;strong&gt;System.String&lt;/strong&gt; (un tipo FCL), no hay diferencia y tampoco se puede usar. De manera similar, escuch&amp;eacute; que algunos desarrolladores dicen que &lt;strong&gt;int&lt;/strong&gt; representa un n&amp;uacute;mero entero de 32 bits cuando la aplicaci&amp;oacute;n se ejecuta en un sistema operativo de 32 bits y que representa un n&amp;uacute;mero entero de 64 bits cuando la aplicaci&amp;oacute;n se ejecuta en un sistema operativo de 64 bits. Esta declaraci&amp;oacute;n es absolutamente falsa: en C #, un &lt;strong&gt;int&lt;/strong&gt; siempre se asigna a &lt;strong&gt;System.Int32&lt;/strong&gt; y, por lo tanto, representa un n&amp;uacute;mero entero de 32 bits independientemente del sistema operativo en el que se ejecuta el c&amp;oacute;digo. Si los programadores usar&amp;iacute;an &lt;strong&gt;Int32&lt;/strong&gt; en su c&amp;oacute;digo, entonces esta confusi&amp;oacute;n potencial tambi&amp;eacute;n se elimina.</target>
        </trans-unit>
        <trans-unit id="fa954e4cefc7a46db782057de61937b12e9e5aed" translate="yes" xml:space="preserve">
          <source>I'd just like to add this to lfousts answer, from Ritchers book:</source>
          <target state="translated">Me gustaría añadir esto a la respuesta de lfousts,del libro de Ritchers:</target>
        </trans-unit>
        <trans-unit id="21899fca0863f132973844812fab0c779022a7b9" translate="yes" xml:space="preserve">
          <source>I've seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt; or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# the string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used.</source>
          <target state="translated">He visto a varios desarrolladores confundidos, sin saber si usar &lt;strong&gt;string&lt;/strong&gt; o &lt;strong&gt;String&lt;/strong&gt; en su c&amp;oacute;digo. Debido a que en C # la cadena (una palabra clave) se asigna exactamente a System.String (un tipo de FCL), no hay diferencia y tampoco se puede usar.</target>
        </trans-unit>
        <trans-unit id="6b7d898ac30d5c92342d8ac9760039cee7099d78" translate="yes" xml:space="preserve">
          <source>If for some reason you wanted a variable called &lt;em&gt;string&lt;/em&gt;, you'd see only the first of these compiles:</source>
          <target state="translated">Si por alguna raz&amp;oacute;n quisieras una variable llamada &lt;em&gt;cadena&lt;/em&gt; , solo ver&amp;iacute;as la primera de estas compilaciones:</target>
        </trans-unit>
        <trans-unit id="4415225af42f5d012580c28bcbef4acf554c9d6c" translate="yes" xml:space="preserve">
          <source>If you find yourselves building systems where it is necessary to specify the size of the integers you are using and so tend to use &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt; etc. then it might look more natural to use &lt;code&gt;String&lt;/code&gt; - and when moving around between different .net languages it might make things more understandable - otherwise I would use string and int.</source>
          <target state="translated">Si se encuentran construyendo sistemas donde es necesario especificar el tama&amp;ntilde;o de los enteros que est&amp;aacute;n utilizando y tienden a usar &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;UInt16&lt;/code&gt; , &lt;code&gt;UInt32&lt;/code&gt; , etc., entonces puede parecer m&amp;aacute;s natural usar &lt;code&gt;String&lt;/code&gt; , y al moverse entre diferentes .net puede hacer que las cosas sean m&amp;aacute;s comprensibles; de lo contrario, usar&amp;iacute;a string e int.</target>
        </trans-unit>
        <trans-unit id="fc3d0d8990fb3765be09111a7c669c84b913e5c0" translate="yes" xml:space="preserve">
          <source>If you really want a variable name called &lt;em&gt;string&lt;/em&gt; you can use &lt;code&gt;@&lt;/code&gt; as a prefix:</source>
          <target state="translated">Si realmente desea un nombre de variable llamado &lt;em&gt;cadena&lt;/em&gt; , puede usar &lt;code&gt;@&lt;/code&gt; como prefijo:</target>
        </trans-unit>
        <trans-unit id="5da7f23835ffc9c6b22e25e2d55eb0854a9abafa" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt;
  could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does treat &lt;strong&gt;long&lt;/strong&gt; as an &lt;strong&gt;Int32&lt;/strong&gt;.
  Someone reading source code in one language could easily misinterpret the code&amp;rsquo;s
  intention if he or she were used to programming in a different programming language.
  In fact, most languages won&amp;rsquo;t even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won&amp;rsquo;t compile code
  that uses it.</source>
          <target state="translated">En C #, &lt;strong&gt;long se&lt;/strong&gt; asigna a &lt;strong&gt;System.Int64&lt;/strong&gt; , pero en un lenguaje de programaci&amp;oacute;n diferente, &lt;strong&gt;long&lt;/strong&gt; podr&amp;iacute;a &lt;strong&gt;asignarse&lt;/strong&gt; a &lt;strong&gt;Int16&lt;/strong&gt; o &lt;strong&gt;Int32&lt;/strong&gt; . De hecho, C ++ / CLI trata por &lt;strong&gt;mucho tiempo&lt;/strong&gt; como &lt;strong&gt;Int32&lt;/strong&gt; . Alguien que lea el c&amp;oacute;digo fuente en un idioma podr&amp;iacute;a malinterpretar f&amp;aacute;cilmente la intenci&amp;oacute;n del c&amp;oacute;digo si estuviera acostumbrado a programar en un lenguaje de programaci&amp;oacute;n diferente. De hecho, la mayor&amp;iacute;a de los idiomas ni siquiera se tratar&amp;aacute;n como palabras clave y no compilar&amp;aacute;n el c&amp;oacute;digo que lo usa.</target>
        </trans-unit>
        <trans-unit id="c34719d5baf69cca85f742773fbc5ad7584b58a0" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt; could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does in fact treat long as an &lt;strong&gt;Int32&lt;/strong&gt;. Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language. In fact, most languages won't even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won't compile code that uses it.</source>
          <target state="translated">En C #, &lt;strong&gt;long se&lt;/strong&gt; asigna a &lt;strong&gt;System.Int64&lt;/strong&gt; , pero en un lenguaje de programaci&amp;oacute;n diferente, &lt;strong&gt;long&lt;/strong&gt; podr&amp;iacute;a &lt;strong&gt;asignarse&lt;/strong&gt; a &lt;strong&gt;Int16&lt;/strong&gt; o &lt;strong&gt;Int32&lt;/strong&gt; . De hecho, C ++ / CLI de hecho trata durante mucho tiempo como un &lt;strong&gt;Int32&lt;/strong&gt; . Alguien que lea el c&amp;oacute;digo fuente en un idioma podr&amp;iacute;a malinterpretar f&amp;aacute;cilmente la intenci&amp;oacute;n del c&amp;oacute;digo si estuviera acostumbrado a programar en un lenguaje de programaci&amp;oacute;n diferente. De hecho, la mayor&amp;iacute;a de los idiomas ni siquiera se tratar&amp;aacute;n como palabras clave y no compilar&amp;aacute;n el c&amp;oacute;digo que lo usa.</target>
        </trans-unit>
        <trans-unit id="7b36107e9559a09694a8183cb99815886d4e78c3" translate="yes" xml:space="preserve">
          <source>In short &quot;String&quot; is an alias ( the same thing called with different names) of &quot;string&quot;. So technically both the below code statements will give the same output.</source>
          <target state="translated">En resumen,&quot;String&quot; es un alias (la misma cosa llamada con diferentes nombres)de &quot;cadena&quot;.Así que técnicamente las dos declaraciones de código siguientes darán la misma salida.</target>
        </trans-unit>
        <trans-unit id="e6dc65980fe8a04364550bf8267b4a0752724591" translate="yes" xml:space="preserve">
          <source>In the below code the left hand side is a variable declaration and it declared using &quot;string&quot;. At the right hand side we are calling a method so &quot;String&quot; is more sensible.</source>
          <target state="translated">En el código de abajo,la parte izquierda es una declaración variable y se declara usando &quot;cadena&quot;.En el lado derecho estamos llamando a un método para que &quot;String&quot; sea más sensato.</target>
        </trans-unit>
        <trans-unit id="f98303445c332e612954049bbaf882f4fa3cb7e9" translate="yes" xml:space="preserve">
          <source>In the same way there are aliases for other c# data type as shown below:-</source>
          <target state="translated">De la misma manera hay alias para otros tipos de datos c#como se muestra a continuación:-</target>
        </trans-unit>
        <trans-unit id="57dee12da4dec3aa9f4c4e8403aa2ad08617efcc" translate="yes" xml:space="preserve">
          <source>In the spec, the value type aliases are known as &quot;simple types&quot;. Literals can be used for constant values of every simple type; no other value types have literal forms available. (Compare this with VB, which allows &lt;code&gt;DateTime&lt;/code&gt; literals, and has an alias for it too.)</source>
          <target state="translated">En la especificaci&amp;oacute;n, los alias de tipo de valor se conocen como &quot;tipos simples&quot;. Los literales se pueden usar para valores constantes de cada tipo simple; ning&amp;uacute;n otro tipo de valor tiene formas literales disponibles. (Compare esto con VB, que permite los literales &lt;code&gt;DateTime&lt;/code&gt; y tambi&amp;eacute;n tiene un alias).</target>
        </trans-unit>
        <trans-unit id="483cab40a51898204e58cfed265106143d7f4953" translate="yes" xml:space="preserve">
          <source>It appears that the guidance in this area may have changed, as &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; now enforces the use of the C# specific aliases.</source>
          <target state="translated">Parece que la orientaci&amp;oacute;n en esta &amp;aacute;rea puede haber cambiado, ya que &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; ahora impone el uso de los alias espec&amp;iacute;ficos de C #.</target>
        </trans-unit>
        <trans-unit id="ff67dae909a99ee9a9e7def47187588639f45a8f" translate="yes" xml:space="preserve">
          <source>It's a matter of convention, really.  &lt;code&gt;string&lt;/code&gt; just looks more like C/C++ style.  The general convention is to use whatever shortcuts your chosen language has provided (int/Int for &lt;code&gt;Int32&lt;/code&gt;).  This goes for &quot;object&quot; and &lt;code&gt;decimal&lt;/code&gt; as well.</source>
          <target state="translated">Es una cuesti&amp;oacute;n de convenci&amp;oacute;n, de verdad. &lt;code&gt;string&lt;/code&gt; simplemente se parece m&amp;aacute;s al estilo C / C ++. La convenci&amp;oacute;n general es usar cualquier atajo que haya proporcionado el idioma elegido (int / Int para &lt;code&gt;Int32&lt;/code&gt; ). Esto va para &quot;objeto&quot; y &lt;code&gt;decimal&lt;/code&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="3838b064aeaafbf213d49b0394cdd6a50f24ba3e" translate="yes" xml:space="preserve">
          <source>It's been covered above; however, you can't use &lt;code&gt;string&lt;/code&gt; in reflection; you must use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Ha sido cubierto arriba; sin embargo, no puedes usar &lt;code&gt;string&lt;/code&gt; en la reflexi&amp;oacute;n; debes usar &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e09d862931ec0e2748cdc4ff36fc4d9cad4e1d6a" translate="yes" xml:space="preserve">
          <source>Just for the sake of completeness, here's a brain dump of related information...</source>
          <target state="translated">Sólo para completar,aquí hay una descarga de información relacionada...</target>
        </trans-unit>
        <trans-unit id="5e78ed6411bc19fbcef0b5786cecd66b3134b765" translate="yes" xml:space="preserve">
          <source>Likewise, I think it's generally recommended to use &lt;code&gt;String&lt;/code&gt; if you need to refer specifically to the class.</source>
          <target state="translated">Del mismo modo, creo que generalmente se recomienda usar &lt;code&gt;String&lt;/code&gt; si necesita referirse espec&amp;iacute;ficamente a la clase.</target>
        </trans-unit>
        <trans-unit id="bc04acca921cef20c01ada3297aed735cee9b09f" translate="yes" xml:space="preserve">
          <source>Lower case &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;.
They are the same in &lt;code&gt;C#&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;string&lt;/code&gt; min&amp;uacute;scula es un alias para &lt;code&gt;System.String&lt;/code&gt; . Son lo mismo en &lt;code&gt;C#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa9ccdfd7c726f6e226b0942c75a549ff6e70b5d" translate="yes" xml:space="preserve">
          <source>Lowercase &lt;code&gt;string&lt;/code&gt; is preferred in most projects due to the syntax highlighting</source>
          <target state="translated">La &lt;code&gt;string&lt;/code&gt; min&amp;uacute;sculas se prefiere en la mayor&amp;iacute;a de los proyectos debido al resaltado de sintaxis</target>
        </trans-unit>
        <trans-unit id="b6133573d560cd3eea08983f58c0042a25059f55" translate="yes" xml:space="preserve">
          <source>Many programmers that use C# exclusively tend to forget that other programming
  languages can be used against the CLR, and because of this, C#-isms creep into the
  class library code. For example, Microsoft&amp;rsquo;s FCL is almost exclusively written in C# and
  developers on the FCL team have now introduced methods into the library such as
  &lt;strong&gt;Array&lt;/strong&gt;&amp;rsquo;s &lt;strong&gt;GetLongLength&lt;/strong&gt;, which returns an &lt;strong&gt;Int64&lt;/strong&gt; value that is a &lt;strong&gt;long&lt;/strong&gt; in C# but not
  in other languages (like C++/CLI). Another example is &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;&amp;rsquo;s
  &lt;strong&gt;LongCount&lt;/strong&gt; method.</source>
          <target state="translated">Muchos programadores que usan C # exclusivamente tienden a olvidar que se pueden usar otros lenguajes de programaci&amp;oacute;n contra el CLR, y debido a esto, los C # se arrastran en el c&amp;oacute;digo de la biblioteca de clases. Por ejemplo, el FCL de Microsoft est&amp;aacute; escrito casi exclusivamente en C # y los desarrolladores del equipo de FCL ahora han introducido m&amp;eacute;todos en la biblioteca como &lt;strong&gt;GetLongLength de&lt;/strong&gt; &lt;strong&gt;Array&lt;/strong&gt; , que devuelve un valor &lt;strong&gt;Int64&lt;/strong&gt; que es &lt;strong&gt;largo&lt;/strong&gt; en C # pero no en otros lenguajes (como C ++ / CLI). Otro ejemplo es el m&amp;eacute;todo &lt;strong&gt;LongCount de&lt;/strong&gt; &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9df02f88b75a5ae9238b00816debf524d9b6d4bb" translate="yes" xml:space="preserve">
          <source>Many will argue that while this is information technically accurate using &lt;code&gt;String&lt;/code&gt; is still fine because it&amp;rsquo;s exceedingly rare that a code base would define a type of this name. Or that when &lt;code&gt;String&lt;/code&gt; is defined it&amp;rsquo;s a sign of a bad code base.</source>
          <target state="translated">Muchos argumentar&amp;aacute;n que si bien esta informaci&amp;oacute;n es t&amp;eacute;cnicamente precisa, el uso de &lt;code&gt;String&lt;/code&gt; todav&amp;iacute;a est&amp;aacute; bien porque es extremadamente raro que una base de c&amp;oacute;digo defina un tipo de este nombre. O que cuando se define &lt;code&gt;String&lt;/code&gt; es una se&amp;ntilde;al de una mala base de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="4969c66ffc5656f3999a26d516caf717157af60a" translate="yes" xml:space="preserve">
          <source>Neither statement in the &lt;code&gt;Example&lt;/code&gt; method compiles. Here &lt;code&gt;String&lt;/code&gt; is always a piano &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;string&lt;/a&gt;, &lt;code&gt;MyPiano.String&lt;/code&gt;. No member (&lt;code&gt;static&lt;/code&gt; or not) &lt;code&gt;Format&lt;/code&gt; exists on it (or is inherited from its base class). And the value &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; cannot be converted into it.</source>
          <target state="translated">Ninguna de las declaraciones en el m&amp;eacute;todo &lt;code&gt;Example&lt;/code&gt; compila. Aqu&amp;iacute; &lt;code&gt;String&lt;/code&gt; es siempre una &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;cuerda de&lt;/a&gt; piano, &lt;code&gt;MyPiano.String&lt;/code&gt; . No existe ning&amp;uacute;n miembro ( &lt;code&gt;static&lt;/code&gt; o no) &lt;code&gt;Format&lt;/code&gt; o (o se hereda de su clase base). Y el valor &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; no se puede convertir en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="2fa06e504f29a303da31352f8e430b6dc30c1883" translate="yes" xml:space="preserve">
          <source>New answer after 6 years and 5 months (procrastination).</source>
          <target state="translated">Nueva respuesta después de 6 años y 5 meses (postergación).</target>
        </trans-unit>
        <trans-unit id="296daf449bf0c8664c9e6d199847c7929ad529f1" translate="yes" xml:space="preserve">
          <source>Note: I copy/pasted most of the blog post for archive reason. I ignore some parts, so I recommend to skip and to read the &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;blog post&lt;/a&gt; if you can.</source>
          <target state="translated">Nota: Copi&amp;eacute; / pegu&amp;eacute; la mayor parte de la publicaci&amp;oacute;n del blog por razones de archivo. Ignoro algunas partes, por lo que recomiendo omitir y leer la &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;publicaci&amp;oacute;n&lt;/a&gt; del blog si puedes.</target>
        </trans-unit>
        <trans-unit id="022ba2779e8f9a2cb535c438e2a28ea7b0dd3e80" translate="yes" xml:space="preserve">
          <source>Now that I've been doing it for years, it's a habit and I like the coloration that VS shows for the CLR types.</source>
          <target state="translated">Ahora que llevo años haciéndolo,es un hábito y me gusta la coloración que muestra VS para los tipos de CLR.</target>
        </trans-unit>
        <trans-unit id="b3ab40a90e383fb18e0e975a4f3ebb4b8b3eaeff" translate="yes" xml:space="preserve">
          <source>Secondly, when &lt;code&gt;String&lt;/code&gt; is another &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, nested inside the current type:</source>
          <target state="translated">En segundo lugar, cuando &lt;code&gt;String&lt;/code&gt; es otro &lt;strong&gt;&lt;em&gt;tipo&lt;/em&gt;&lt;/strong&gt; , anidado dentro del tipo actual:</target>
        </trans-unit>
        <trans-unit id="e101d4a69cdea700b7d60c87527fa5d12e284702" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;int&lt;/code&gt; maps to &lt;code&gt;System.Int32&lt;/code&gt;.</source>
          <target state="translated">Del mismo modo, &lt;code&gt;int&lt;/code&gt; se asigna a &lt;code&gt;System.Int32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="689346a590d26a7f24b31d23dd2fbc483406fd3b" translate="yes" xml:space="preserve">
          <source>So remember when you see the &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; debate this is about semantics, not style. Choosing string gives crisp meaning to your code base. Choosing &lt;code&gt;String&lt;/code&gt; isn&amp;rsquo;t wrong but it&amp;rsquo;s leaving the door open for surprises in the future.</source>
          <target state="translated">As&amp;iacute; que recuerde cuando vea el debate de &lt;code&gt;String&lt;/code&gt; contra &lt;code&gt;string&lt;/code&gt; , se trata de sem&amp;aacute;ntica, no de estilo. Elegir una cadena le da un significado n&amp;iacute;tido a su base de c&amp;oacute;digo. Elegir &lt;code&gt;String&lt;/code&gt; no est&amp;aacute; mal, pero est&amp;aacute; dejando la puerta abierta para sorpresas en el futuro.</target>
        </trans-unit>
        <trans-unit id="9cb50509dd63b7929b71e5a34e498aabbd13f875" translate="yes" xml:space="preserve">
          <source>So technically, there is no difference.  It's like &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt;&lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Entonces, t&amp;eacute;cnicamente, no hay diferencia. Es como &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2325db982bbc83b6294b8c0dff80dba26d189b" translate="yes" xml:space="preserve">
          <source>So there you have it. I think these are all really good points. I however, don't find myself using Jeffrey's advice in my own code. Maybe I am too stuck in my C# world but I end up trying to make my code look like the framework code.</source>
          <target state="translated">Así que ahí lo tienes.Creo que todos estos son puntos muy buenos.Sin embargo,no me encuentro usando el consejo de Jeffrey en mi propio código.Tal vez estoy demasiado atascado en mi mundo C#pero termino tratando de hacer que mi código se vea como el código del marco.</target>
        </trans-unit>
        <trans-unit id="84d84cfed9ed57bbe7f2bacafbaddfb81576cf17" translate="yes" xml:space="preserve">
          <source>String (&lt;code&gt;System.String&lt;/code&gt;) is a class in the base class library. string (lower case) is a reserved work in C# that is an alias for System.String. Int32 vs int is a similar situation as is &lt;code&gt;Boolean vs. bool&lt;/code&gt;. These C# language specific keywords enable you to declare primitives in a style similar to C.</source>
          <target state="translated">String ( &lt;code&gt;System.String&lt;/code&gt; ) es una clase en la biblioteca de clases base. string (min&amp;uacute;scula) es un trabajo reservado en C # que es un alias para System.String. Int32 vs int es una situaci&amp;oacute;n similar a la de &lt;code&gt;Boolean vs. bool&lt;/code&gt; . Estas palabras clave espec&amp;iacute;ficas del lenguaje C # le permiten declarar primitivas en un estilo similar a C.</target>
        </trans-unit>
        <trans-unit id="49ce6a3b5fc76630de40afb2fe0abba3f193580b" translate="yes" xml:space="preserve">
          <source>That's just a matter of the way the spec defines enum declarations - the part after the colon has to be the &lt;em&gt;integral-type&lt;/em&gt; production, which is one token of &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;... as opposed to a &lt;em&gt;type&lt;/em&gt; production as used by variable declarations for example. It doesn't indicate any other difference.</source>
          <target state="translated">Esa es solo una cuesti&amp;oacute;n de la forma en que la especificaci&amp;oacute;n define las declaraciones de enumeraci&amp;oacute;n: la parte posterior al colon debe ser la producci&amp;oacute;n de &lt;em&gt;tipo integral&lt;/em&gt; , que es una muestra de &lt;code&gt;sbyte&lt;/code&gt; , &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;ushort&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;uint&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;ulong&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; . .. a diferencia de un &lt;em&gt;tipo de&lt;/em&gt; producci&amp;oacute;n como el utilizado por las declaraciones de variables, por ejemplo. No indica ninguna otra diferencia.</target>
        </trans-unit>
        <trans-unit id="57cd8f4f9cafb98e0ff1960638924dc3de76b39d" translate="yes" xml:space="preserve">
          <source>The C# keyword &lt;code&gt;string&lt;/code&gt; maps to the .NET type &lt;code&gt;System.String&lt;/code&gt; - it is an alias that keeps to the naming conventions of the language.</source>
          <target state="translated">La &lt;code&gt;string&lt;/code&gt; palabras clave C # se asigna al tipo .NET &lt;code&gt;System.String&lt;/code&gt; : es un alias que se ajusta a las convenciones de nomenclatura del lenguaje.</target>
        </trans-unit>
        <trans-unit id="f49eb70607b2497b91d8c266445436a4abe3155d" translate="yes" xml:space="preserve">
          <source>The C# language specification states, &amp;ldquo;As a matter of style, use of the keyword is favored over
  use of the complete system type name.&amp;rdquo; I disagree with the language specification; I prefer
  to use the FCL type names and completely avoid the primitive type names. In fact, I wish that
  compilers didn&amp;rsquo;t even offer the primitive type names and forced developers to use the FCL
  type names instead. Here are my reasons:</source>
          <target state="translated">La especificaci&amp;oacute;n del lenguaje C # establece: &quot;Como cuesti&amp;oacute;n de estilo, se favorece el uso de la palabra clave sobre el uso del nombre completo del tipo de sistema&quot;. No estoy de acuerdo con la especificaci&amp;oacute;n del lenguaje; Prefiero usar los nombres de tipo FCL y evitar por completo los nombres de tipo primitivos. De hecho, desear&amp;iacute;a que los compiladores ni siquiera ofrecieran los nombres de tipo primitivos y forzaran a los desarrolladores a usar los nombres de tipo FCL. Aqu&amp;iacute; est&amp;aacute;n mis razones:</target>
        </trans-unit>
        <trans-unit id="fce2e5a5f468c7b1c34cd9768434166999ddbdb0" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For
  example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;,
  &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as
  &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it&amp;rsquo;s legal to write the following
  code, the line with &lt;strong&gt;float&lt;/strong&gt; feels very unnatural to me, and it&amp;rsquo;s not obvious that the line is
  correct:</source>
          <target state="translated">El FCL tiene muchos m&amp;eacute;todos que tienen nombres de tipo como parte de sus nombres de m&amp;eacute;todo. Por ejemplo, el tipo &lt;strong&gt;BinaryReader&lt;/strong&gt; ofrece m&amp;eacute;todos como &lt;strong&gt;ReadBoolean&lt;/strong&gt; , &lt;strong&gt;ReadInt32&lt;/strong&gt; , &lt;strong&gt;ReadSingle&lt;/strong&gt; , etc., y el tipo &lt;strong&gt;System.Convert&lt;/strong&gt; ofrece m&amp;eacute;todos como &lt;strong&gt;ToBoolean&lt;/strong&gt; , &lt;strong&gt;ToInt32&lt;/strong&gt; , &lt;strong&gt;ToSingle&lt;/strong&gt; , etc. Aunque es legal escribir el siguiente c&amp;oacute;digo, la l&amp;iacute;nea con &lt;strong&gt;flotante me&lt;/strong&gt; parece muy poco natural, y no es obvio que la l&amp;iacute;nea sea correcta:</target>
        </trans-unit>
        <trans-unit id="d241e925f9c6c70e65ab7201f55f79ecdaebf9ce" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;, &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it's legal to write the following code, the line with float feels very unnatural to me, and it's not obvious that the line is correct:</source>
          <target state="translated">El FCL tiene muchos m&amp;eacute;todos que tienen nombres de tipo como parte de sus nombres de m&amp;eacute;todo. Por ejemplo, el tipo &lt;strong&gt;BinaryReader&lt;/strong&gt; ofrece m&amp;eacute;todos como &lt;strong&gt;ReadBoolean&lt;/strong&gt; , &lt;strong&gt;ReadInt32&lt;/strong&gt; , &lt;strong&gt;ReadSingle&lt;/strong&gt; , etc., y el tipo &lt;strong&gt;System.Convert&lt;/strong&gt; ofrece m&amp;eacute;todos como &lt;strong&gt;ToBoolean&lt;/strong&gt; , &lt;strong&gt;ToInt32&lt;/strong&gt; , &lt;strong&gt;ToSingle&lt;/strong&gt; , etc. Aunque es legal escribir el siguiente c&amp;oacute;digo, la l&amp;iacute;nea con flotante me parece muy poco natural, y no es obvio que la l&amp;iacute;nea sea correcta:</target>
        </trans-unit>
        <trans-unit id="245547d31df063b9be5afb5f9f9e26bb654e9990" translate="yes" xml:space="preserve">
          <source>The above will not compile because &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; does not have a non-static member called &lt;code&gt;Format&lt;/code&gt;, and no extension methods apply. In the above case, it may still be possible to use &lt;code&gt;String&lt;/code&gt; in other contexts where a &lt;em&gt;type&lt;/em&gt; is the only possibility syntactically. For example &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; could be OK (depending on namespace and &lt;code&gt;using&lt;/code&gt; directives).</source>
          <target state="translated">Lo anterior no se compilar&amp;aacute; porque &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; no tiene un miembro no est&amp;aacute;tico llamado &lt;code&gt;Format&lt;/code&gt; o , y no se aplican m&amp;eacute;todos de extensi&amp;oacute;n. En el caso anterior, a&amp;uacute;n puede ser posible usar &lt;code&gt;String&lt;/code&gt; en otros contextos donde un &lt;em&gt;tipo&lt;/em&gt; es la &amp;uacute;nica posibilidad sint&amp;aacute;ctica. Por ejemplo &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; podr&amp;iacute;a estar bien (dependiendo del espacio de nombres y el &lt;code&gt;using&lt;/code&gt; directivas).</target>
        </trans-unit>
        <trans-unit id="8d7a9de8ca807f30e0d84dd6099bf753c98ce135" translate="yes" xml:space="preserve">
          <source>The actual meaning of &lt;code&gt;String&lt;/code&gt; will always depend on name resolution.
  That means it depends on all the source files in the project and all
  the types defined in all the referenced assemblies. In short it
  requires quite a bit of context to &lt;em&gt;know&lt;/em&gt; what it means.</source>
          <target state="translated">El significado real de &lt;code&gt;String&lt;/code&gt; siempre depender&amp;aacute; de la resoluci&amp;oacute;n del nombre. Eso significa que depende de todos los archivos de origen en el proyecto y todos los tipos definidos en todos los ensamblados a los que se hace referencia. En resumen, requiere bastante contexto para &lt;em&gt;saber&lt;/em&gt; lo que significa.</target>
        </trans-unit>
        <trans-unit id="93322148b52efc519b4bbcaebbed28fabcc67ec3" translate="yes" xml:space="preserve">
          <source>The best answer I have ever heard about using the provided type aliases in C# comes from Jeffrey Richter in his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C#&lt;/a&gt;. Here are his 3 reasons:</source>
          <target state="translated">La mejor respuesta que he escuchado sobre el uso de los alias de tipo proporcionados en C # proviene de Jeffrey Richter en su libro &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C #&lt;/a&gt; . Aqu&amp;iacute; est&amp;aacute;n sus 3 razones:</target>
        </trans-unit>
        <trans-unit id="04f4e2e05e59044015a06ab9e5709ace1067caeb" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;String&lt;/code&gt; though has no concrete meaning in C#. It is an identifier that goes through all the name lookup rules as &lt;code&gt;Widget&lt;/code&gt;, &lt;code&gt;Student&lt;/code&gt;, etc &amp;hellip; It could bind to string or it could bind to a type in another assembly entirely whose purposes may be entirely different than &lt;code&gt;string&lt;/code&gt;. Worse it could be defined in a way such that code like &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt;; continued to compile.</source>
          <target state="translated">Sin embargo, el identificador &lt;code&gt;String&lt;/code&gt; no tiene un significado concreto en C #. Es un identificador que pasa por todas las reglas de b&amp;uacute;squeda de nombres como &lt;code&gt;Widget&lt;/code&gt; , &lt;code&gt;Student&lt;/code&gt; , etc. Puede unirse a una cadena o puede unirse a un tipo en otro ensamblaje completamente cuyos prop&amp;oacute;sitos pueden ser completamente diferentes a la &lt;code&gt;string&lt;/code&gt; . Peor a&amp;uacute;n, podr&amp;iacute;a definirse de tal manera que un c&amp;oacute;digo como &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt; ; continu&amp;oacute; compilando.</target>
        </trans-unit>
        <trans-unit id="3f48daaabbe068f8c313923060dc1ce87907e97a" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt;  is an alias for
 &lt;code&gt;System.String&lt;/code&gt; aside from the keyword issue, the two are exactly
 equivalent.</source>
          <target state="translated">La &lt;code&gt;string&lt;/code&gt; palabra clave es un alias para &lt;code&gt;System.String&lt;/code&gt; aparte del problema de la palabra clave, los dos son exactamente equivalentes.</target>
        </trans-unit>
        <trans-unit id="d5c514298559badf24fce9b8b392cc6d91008feb" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt; has concrete meaning in C#. It is the type &lt;code&gt;System.String&lt;/code&gt; which exists in the core runtime assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings in .NET. Its presence is so critical to C# that if that type doesn&amp;rsquo;t exist the compiler will exit before attempting to even parse a line of code. Hence &lt;code&gt;string&lt;/code&gt; has a precise, unambiguous meaning in C# code.</source>
          <target state="translated">La &lt;code&gt;string&lt;/code&gt; palabras clave tiene un significado concreto en C #. Es el tipo &lt;code&gt;System.String&lt;/code&gt; que existe en el ensamblaje central de tiempo de ejecuci&amp;oacute;n. El tiempo de ejecuci&amp;oacute;n comprende intr&amp;iacute;nsecamente este tipo y proporciona las capacidades que los desarrolladores esperan para las cadenas en .NET. Su presencia es tan cr&amp;iacute;tica para C # que si ese tipo no existe, el compilador se cerrar&amp;aacute; antes de intentar incluso analizar una l&amp;iacute;nea de c&amp;oacute;digo. Por lo tanto, la &lt;code&gt;string&lt;/code&gt; tiene un significado preciso e inequ&amp;iacute;voco en el c&amp;oacute;digo C #.</target>
        </trans-unit>
        <trans-unit id="baaf13d4a47a17e15308fe16fb596475d6a15088" translate="yes" xml:space="preserve">
          <source>The only practical difference is the syntax highlighting as you mention, and that you have to write &lt;code&gt;using System&lt;/code&gt; if you use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">La &amp;uacute;nica diferencia pr&amp;aacute;ctica es el resaltado de sintaxis como mencionas, y que tienes que escribir &lt;code&gt;using System&lt;/code&gt; si usas &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8668abfb621e1b2a22882756e57d856bcfbf3e47" translate="yes" xml:space="preserve">
          <source>The only real downer is that auto-complete uses the C# type, so I end up re-typing automatically generated types to specify the CLR type instead.</source>
          <target state="translated">La única desventaja es que el autocompletado usa el tipo C#,así que termino reescribiendo los tipos generados automáticamente para especificar el tipo CLR en su lugar.</target>
        </trans-unit>
        <trans-unit id="9c532ca7d467cf6352c36952f31402d9053b7bfb" translate="yes" xml:space="preserve">
          <source>Theoretically this could help to port code into some future 64-bit standard in which &quot;int&quot; might mean &lt;code&gt;Int64&lt;/code&gt;, but that's not the point, and I would expect any upgrade wizard to change any &lt;code&gt;int&lt;/code&gt; references to &lt;code&gt;Int32&lt;/code&gt; anyway just to be safe.</source>
          <target state="translated">Te&amp;oacute;ricamente, esto podr&amp;iacute;a ayudar a portar c&amp;oacute;digo en alg&amp;uacute;n est&amp;aacute;ndar futuro de 64 bits en el que &quot;int&quot; podr&amp;iacute;a significar &lt;code&gt;Int64&lt;/code&gt; , pero ese no es el punto, y esperar&amp;iacute;a que cualquier asistente de actualizaci&amp;oacute;n cambie cualquier referencia &lt;code&gt;int&lt;/code&gt; a &lt;code&gt;Int32&lt;/code&gt; de todos modos solo para estar seguro.</target>
        </trans-unit>
        <trans-unit id="1b43e8aad6972ff5253750d89b626a58fe50142a" translate="yes" xml:space="preserve">
          <source>Theoretically, you could implement a C#-compiler that generated Java bytecode. A sensible implementation of this compiler would probably map &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/strong&gt; in order to interoperate with the Java runtime library.</source>
          <target state="translated">Te&amp;oacute;ricamente, podr&amp;iacute;a implementar un compilador C # que gener&amp;oacute; el c&amp;oacute;digo de bytes de Java. Una implementaci&amp;oacute;n sensata de este compilador probablemente mapear&amp;iacute;a &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; a &lt;strong&gt; &lt;code&gt;java.lang.String&lt;/code&gt; &lt;/strong&gt; para interoperar con la biblioteca de tiempo de ejecuci&amp;oacute;n Java.</target>
        </trans-unit>
        <trans-unit id="b9cef7d16318b618f7d7e05ce428e421145a3eb1" translate="yes" xml:space="preserve">
          <source>There is no difference.</source>
          <target state="translated">No hay ninguna diferencia.</target>
        </trans-unit>
        <trans-unit id="e724cb1ff2ea7523a1d7006294c3e2e3b6908113" translate="yes" xml:space="preserve">
          <source>There is one circumstance in which you &lt;em&gt;have&lt;/em&gt; to use the aliases: when explicitly specifying an enum's underlying type. For instance:</source>
          <target state="translated">Hay una circunstancia en la que debe usar los alias: cuando especifica expl&amp;iacute;citamente el tipo subyacente de una enumeraci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="db457529845002230c6c5b574e656447dd4b91e6" translate="yes" xml:space="preserve">
          <source>There's a debate over whether you should use the System types (&lt;code&gt;System.Int32&lt;/code&gt;, &lt;code&gt;System.String&lt;/code&gt;, etc.) types or the &lt;code&gt;C# aliases&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, etc). I personally believe you should use the &lt;code&gt;C# aliases&lt;/code&gt;, but that's just my personal preference.</source>
          <target state="translated">Existe un debate sobre si debe usar los tipos de Sistema ( &lt;code&gt;System.Int32&lt;/code&gt; , &lt;code&gt;System.String&lt;/code&gt; , etc.) o los &lt;code&gt;C# aliases&lt;/code&gt; ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , etc.). Personalmente, creo que deber&amp;iacute;as usar los &lt;code&gt;C# aliases&lt;/code&gt; , pero esa es solo mi preferencia personal.</target>
        </trans-unit>
        <trans-unit id="591cd0b1a64565e8d55765f16e4e309da97495fb" translate="yes" xml:space="preserve">
          <source>There's a quote on this issue from &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;Daniel Solis' book&lt;/a&gt;.</source>
          <target state="translated">Hay una cita sobre este tema del &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;libro&lt;/a&gt; de Daniel Solis .</target>
        </trans-unit>
        <trans-unit id="cd310fee67eed80e9424306ba0e405b3b78a9e96" translate="yes" xml:space="preserve">
          <source>This is the style that Microsoft tends to use in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;their examples&lt;/a&gt;.</source>
          <target state="translated">Este es el estilo que Microsoft tiende a usar en &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;sus ejemplos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a887af1a34c7a21a8c77639ce417b3bb91f2d6" translate="yes" xml:space="preserve">
          <source>True that in the vast majority of cases &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; will bind to
  the same type. But using &lt;code&gt;String&lt;/code&gt; still means developers are leaving
  their program up to interpretation in places where there is only one
  correct answer. When &lt;code&gt;String&lt;/code&gt; does bind to the wrong type it can leave
  developers debugging for hours, filing bugs on the compiler team and
  generally wasting time that could&amp;rsquo;ve been saved by using &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Es cierto que en la gran mayor&amp;iacute;a de los casos, &lt;code&gt;String&lt;/code&gt; y &lt;code&gt;string&lt;/code&gt; se unir&amp;aacute;n al mismo tipo. Pero usar &lt;code&gt;String&lt;/code&gt; a&amp;uacute;n significa que los desarrolladores est&amp;aacute;n dejando su programa a la interpretaci&amp;oacute;n en lugares donde solo hay una respuesta correcta. Cuando &lt;code&gt;String&lt;/code&gt; se une al tipo incorrecto, puede dejar a los desarrolladores depurando durante horas, archivando errores en el equipo del compilador y, en general, perdiendo el tiempo que podr&amp;iacute;a haberse ahorrado usando &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080151d9d06a4a0841ea36ef9ee84dcdb90f489e" translate="yes" xml:space="preserve">
          <source>Using System types makes it easier to port between C# and VB.Net, if you are into that sort of thing.</source>
          <target state="translated">El uso de los tipos de sistema hace más fácil pasar de C#a VB.Net,si te gusta ese tipo de cosas.</target>
        </trans-unit>
        <trans-unit id="bbaa6241d89ea80c39692aa3b5ba27d31a981924" translate="yes" xml:space="preserve">
          <source>What are the &lt;strong&gt;&lt;em&gt;guidelines&lt;/em&gt;&lt;/strong&gt; for the use of each? And what are the &lt;strong&gt;&lt;em&gt;differences&lt;/em&gt;&lt;/strong&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son las &lt;strong&gt;&lt;em&gt;pautas&lt;/em&gt;&lt;/strong&gt; para el uso de cada uno? &amp;iquest;Y cu&amp;aacute;les son las &lt;strong&gt;&lt;em&gt;diferencias&lt;/em&gt;&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="bd9579b2d38cc31bb5131600b18e1a9c58740e90" translate="yes" xml:space="preserve">
          <source>What is the difference between String and string in C#</source>
          <target state="translated">¿Cuál es la diferencia entre la cuerda y el cordón en Do#</target>
        </trans-unit>
        <trans-unit id="e71d05ee8c65811fde766fc86a9a2312a31589aa" translate="yes" xml:space="preserve">
          <source>When we talk about &lt;code&gt;.NET&lt;/code&gt; there are two different things one there is &lt;code&gt;.NET&lt;/code&gt; framework and the other there are languages ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; etc) which use that framework.</source>
          <target state="translated">Cuando hablamos de &lt;code&gt;.NET&lt;/code&gt; hay dos cosas diferentes, una es &lt;code&gt;.NET&lt;/code&gt; Framework y la otra hay lenguajes ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; , etc.) que usan ese marco.</target>
        </trans-unit>
        <trans-unit id="1f3e96542caf20f14fe703e23e36cf1f92b45e0e" translate="yes" xml:space="preserve">
          <source>When you use C# together with the CLR &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; will be mapped to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Cuando usa C # junto con la &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt; CLR se asignar&amp;aacute; a &lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6da5e0c25b5beda54e8637b0d410f9bcc6da7930" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;string&lt;/code&gt; is a reserved C# keyword that always has a fixed meaning, &lt;code&gt;String&lt;/code&gt; is just an ordinary &lt;em&gt;identifier&lt;/em&gt; which could refer to anything. Depending on members of the current type, the current namespace and the applied &lt;code&gt;using&lt;/code&gt; directives and their placement, &lt;code&gt;String&lt;/code&gt; could be a value or a type distinct from &lt;code&gt;global::System.String&lt;/code&gt;.</source>
          <target state="translated">Si bien &lt;code&gt;string&lt;/code&gt; es una palabra clave reservada de C # que siempre tiene un significado fijo, &lt;code&gt;String&lt;/code&gt; es solo un &lt;em&gt;identificador&lt;/em&gt; ordinario que podr&amp;iacute;a referirse a cualquier cosa. Dependiendo de los miembros del tipo actual, el espacio de nombres actual y las directivas aplicadas y su ubicaci&amp;oacute;n, &lt;code&gt;String&lt;/code&gt; podr&amp;iacute;a ser un valor o un tipo distinto de &lt;code&gt;global::System.String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d746517e1decf0d12e57b19ed8b079d7d2ff727" translate="yes" xml:space="preserve">
          <source>Worse: Saying &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; will likely (depending on &lt;code&gt;using&lt;/code&gt;s) go to the Linq extension method &lt;code&gt;Enumerable.Concat&lt;/code&gt;. It will not go to the static method &lt;code&gt;string.Concat&lt;/code&gt;.</source>
          <target state="translated">Peor a&amp;uacute;n: es &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; decir String.Concat (someSequence) (seg&amp;uacute;n el &lt;code&gt;using&lt;/code&gt; s) vaya al m&amp;eacute;todo de extensi&amp;oacute;n Linq &lt;code&gt;Enumerable.Concat&lt;/code&gt; . No ir&amp;aacute; al m&amp;eacute;todo est&amp;aacute;tico &lt;code&gt;string.Concat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="825f170ba301d67aee52cb32cfb74d6313352781" translate="yes" xml:space="preserve">
          <source>Yes, that's no difference between them, just like the &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">S&amp;iacute;, no hay diferencia entre ellos, al igual que el &lt;code&gt;bool&lt;/code&gt; y el &lt;code&gt;Boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bfe5ac3a85fb8412165790973b10eb661d8a34a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that &lt;code&gt;String&lt;/code&gt; is defined for a number of completely valid purposes: reflection helpers, serialization libraries, lexers, protocols, etc &amp;hellip; For any of these libraries &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; has real consequences depending on where the code is used.</source>
          <target state="translated">Ver&amp;aacute; que &lt;code&gt;String&lt;/code&gt; se define para varios prop&amp;oacute;sitos completamente v&amp;aacute;lidos: ayudantes de reflexi&amp;oacute;n, bibliotecas de serializaci&amp;oacute;n, lexers, protocolos, etc. Para cualquiera de estas bibliotecas, &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; tiene consecuencias reales dependiendo de d&amp;oacute;nde se use el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="7f23f0b182ad02e9f6f6309b506e9b8da87ba491" translate="yes" xml:space="preserve">
          <source>object: &lt;code&gt;System.Object&lt;/code&gt;, string: &lt;code&gt;System.String&lt;/code&gt;, bool: &lt;code&gt;System.Boolean&lt;/code&gt;, byte: &lt;code&gt;System.Byte&lt;/code&gt;, sbyte: &lt;code&gt;System.SByte&lt;/code&gt;, short: &lt;code&gt;System.Int16&lt;/code&gt; and so on</source>
          <target state="translated">objeto: &lt;code&gt;System.Object&lt;/code&gt; , cadena: &lt;code&gt;System.String&lt;/code&gt; , bool: &lt;code&gt;System.Boolean&lt;/code&gt; , byte: &lt;code&gt;System.Byte&lt;/code&gt; , sbyte: &lt;code&gt;System.SByte&lt;/code&gt; , corto: &lt;code&gt;System.Int16&lt;/code&gt; y as&amp;iacute; sucesivamente</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
