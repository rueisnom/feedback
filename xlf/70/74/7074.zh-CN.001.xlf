<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/7074">
    <body>
      <group id="7074">
        <trans-unit id="228d68628714cc2360e68afeab589f17918ce691" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;System.String&lt;/code&gt;&quot; a.k.a &quot;String&quot; ( capital &quot;S&quot;) is a &lt;code&gt;.NET&lt;/code&gt; framework data type while &quot;string&quot; is a &lt;code&gt;C#&lt;/code&gt; data type.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;System.String&lt;/code&gt; &amp;rdquo;又名&amp;ldquo; String&amp;rdquo;（大写的&amp;ldquo; S&amp;rdquo;）是 &lt;code&gt;.NET&lt;/code&gt; Framework数据类型，而&amp;ldquo; string&amp;rdquo;是 &lt;code&gt;C#&lt;/code&gt; 数据类型。</target>
        </trans-unit>
        <trans-unit id="66dc7eeaeac7b1a7dc09e3938dafceafda64d5d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;This YouTube&lt;/a&gt; video demonstrates practically how they differ.</source>
          <target state="translated">&lt;a href=&quot;http://www.youtube.com/watch?v=ikqUUIg8gmk&quot;&gt;该YouTube&lt;/a&gt;视频实际上演示了它们之间的区别。</target>
        </trans-unit>
        <trans-unit id="26f52da3f6db7a342ae3830a5e6491f9174f7950" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; is an alias in C# for &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;是C＃中&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string&quot;&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="b042ac29881f76cecc22db88fda9a3b4320d85be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; (a developer on the C# compiler and prolific SO user!) wrote a &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;great blog post&lt;/a&gt; on this issue. I think it is worth sharing here. It is a nice perspective on our subject.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/23283/jaredpar&quot;&gt;@JaredPar&lt;/a&gt; （C＃编译器的开发人员和大量SO用户！）就此问题撰写了一篇&lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;很棒的博客文章&lt;/a&gt; 。 我认为值得在这里分享。 这是关于我们主题的一个很好的观点。</target>
        </trans-unit>
        <trans-unit id="e63e166e9fed4ca1e3a3e31ed1fd9eabcb1c9955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; is not a keyword and it can be used as Identifier whereas &lt;code&gt;string&lt;/code&gt; is a keyword and cannot be used as Identifier. And in function point of view both are same.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 不是关键字，可以用作标识符，而 &lt;code&gt;string&lt;/code&gt; 是关键字，不能用作标识符。 并且在功能上都相同。</target>
        </trans-unit>
        <trans-unit id="b90e7af3ecb39b51fb79fa8592f0f1d9ae9ddcb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; stands for &lt;code&gt;System.String&lt;/code&gt; and it is a .NET Framework type. &lt;strong&gt;&lt;code&gt;string&lt;/code&gt; is an alias&lt;/strong&gt; in the C# language for  &lt;code&gt;System.String&lt;/code&gt;. Both of them are compiled to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt; in IL&lt;/strong&gt; (Intermediate Language), so there is no difference. Choose what you like and use that. If you code in C#, I'd prefer &lt;code&gt;string&lt;/code&gt; as it's a C# type alias and well-known by C# programmers.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 表示 &lt;code&gt;System.String&lt;/code&gt; ，它是.NET Framework类型。 &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; 是&lt;/strong&gt; C＃语言中 &lt;code&gt;System.String&lt;/code&gt; &lt;strong&gt;的别名&lt;/strong&gt; 。 它们都被编译为&lt;strong&gt;IL&lt;/strong&gt; （中间语言）中的&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; ，所以没有区别。 选择您喜欢的东西并使用它。 如果您使用C＃编写代码，则我更喜欢 &lt;code&gt;string&lt;/code&gt; ,因为它是C＃类型的别名，并且为C＃程序员所熟知。</target>
        </trans-unit>
        <trans-unit id="21dfdc708b7c6d9ddde1026c9f823a48e07357f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System.String&lt;/code&gt; is the .NET string class - in C# &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt; - so in use they are the same.</source>
          <target state="translated">&lt;code&gt;System.String&lt;/code&gt; 是.NET字符串类-C＃ &lt;code&gt;string&lt;/code&gt; 是 &lt;code&gt;System.String&lt;/code&gt; 的别名-因此在使用中它们是相同的。</target>
        </trans-unit>
        <trans-unit id="e4be40d094b8761d8b0a8af7779ee11906a863a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are identical in all ways (except the uppercase &quot;S&quot;).  There are no performance implications either way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 在所有方面都相同（大写字母&amp;ldquo; S&amp;rdquo;除外）。 两种方式都不会影响性能。</target>
        </trans-unit>
        <trans-unit id="d8840747d529a1ab2e607b537ad66fd66839abb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is a reserved word, but &lt;code&gt;String&lt;/code&gt; is just a class name. 
This means that &lt;code&gt;string&lt;/code&gt; cannot be used as a variable name by itself.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 是保留字，而 &lt;code&gt;String&lt;/code&gt; 只是类名。 这意味着 &lt;code&gt;string&lt;/code&gt; 本身不能用作变量名。</target>
        </trans-unit>
        <trans-unit id="da5062e4b9764acaa414144e97820d32c0973476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is an alias (or shorthand) of &lt;code&gt;System.String&lt;/code&gt;. That means, by typing &lt;code&gt;string&lt;/code&gt; we meant &lt;code&gt;System.String&lt;/code&gt;. You can read more in think link: &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string' is an alias/shorthand of System.String.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 是 &lt;code&gt;System.String&lt;/code&gt; 的别名（或简称）。 这意味着，通过键入 &lt;code&gt;string&lt;/code&gt; ,我们的意思是 &lt;code&gt;System.String&lt;/code&gt; 。 您可以在think链接中阅读更多内容： &lt;a href=&quot;http://www.jeeshenlee.com/2011/10/difference-between-string-and.html&quot;&gt;'string'是System.String的别名/缩写。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d8e4bba708dfba56ed459601d498e8840f3e123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is just an alias for &lt;code&gt;System.String&lt;/code&gt;. The compiler will treat them identically.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 只是 &lt;code&gt;System.String&lt;/code&gt; 的别名。 编译器将对它们进行相同的处理。</target>
        </trans-unit>
        <trans-unit id="f084ec9e9d82162f7fbc5659d6f160720497365a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; is not a style debate</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 与 &lt;code&gt;String&lt;/code&gt; 不是样式辩论</target>
        </trans-unit>
        <trans-unit id="255b406fa6b9e0823de8f80e3455112e9d159128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt; is a type in the CLR.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt;是CLR中的一种类型。</target>
        </trans-unit>
        <trans-unit id="26877e9563383a6b546ae7a361569c47dfb9f7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; is a type in C#.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt;是C＃中的类型。</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="012b988247360c0d3de48ea273a8db4bf1d33c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the million dollar question from programmer's point of view So when to use &quot;String&quot; and &quot;string&quot;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;现在从程序员的角度来看百万美元的问题那么，什么时候使用&amp;ldquo;字符串&amp;rdquo;和&amp;ldquo;字符串&amp;rdquo;呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c0d1a72db9895ccfb9110378ecf99a8542224" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String&lt;/strong&gt; is not a keyword, and you can use it as an identifier:</source>
          <target state="translated">&lt;strong&gt;字符串&lt;/strong&gt;不是关键字，您可以将其用作标识符：</target>
        </trans-unit>
        <trans-unit id="0b0d36dbb427e4a1a0640b4c1188d84e0f6b2c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is one difference&lt;/strong&gt; - you can't use &lt;code&gt;String&lt;/code&gt; without &lt;code&gt;using System;&lt;/code&gt; beforehand.</source>
          <target state="translated">&lt;strong&gt;有一个区别&lt;/strong&gt; -不 &lt;code&gt;using System;&lt;/code&gt; 就不能使用 &lt;code&gt;String&lt;/code&gt; ； 预先。</target>
        </trans-unit>
        <trans-unit id="cbf2f4931f55b8ad0bf613d33ab6ad8bddf5c12a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;string&lt;/strong&gt; is a keyword, and you can't use string as an identifier.</source>
          <target state="translated">&lt;strong&gt;string&lt;/strong&gt;是一个关键字，您不能使用string作为标识符。</target>
        </trans-unit>
        <trans-unit id="b9559fcbc971e124aaf1fe39290213f4b148f9ba" translate="yes" xml:space="preserve">
          <source>Against what seems to be common practice among other programmers, I prefer &lt;code&gt;String&lt;/code&gt; over &lt;code&gt;string&lt;/code&gt;, just to highlight the fact that &lt;code&gt;String&lt;/code&gt; is a reference type, as Jon Skeet mentioned.</source>
          <target state="translated">与其他程序员似乎不常见的做法相反，我更喜欢 &lt;code&gt;String&lt;/code&gt; 而不是 &lt;code&gt;string&lt;/code&gt; ，只是为了强调这一事实，正如Jon Skeet提到的那样。</target>
        </trans-unit>
        <trans-unit id="fdb501029b56570afb94f9ed29293d4141dc5953" translate="yes" xml:space="preserve">
          <source>All the predefined types  are mapped directly to
  underlying .NET types. The C# type names (string) are simply aliases for the
  .NET types (String or System.String), so using the .NET names works fine syntactically, although
  this is discouraged. Within a C# program, you should use the C# names
  rather than the .NET names.</source>
          <target state="translated">所有预定义的类型都直接映射到底层的.NET类型。C#的类型名称(字符串)只是.NET类型(String或System.String)的别名,所以使用.NET的名称在语法上很好,尽管不建议使用。在C#程序中,你应该使用C#的名字,而不是.NET的名字。</target>
        </trans-unit>
        <trans-unit id="d98984153e55855cca8c4e5f7e443623850db2b0" translate="yes" xml:space="preserve">
          <source>Also, now, when I see &quot;int&quot; or &quot;string&quot;, it just looks really wrong to me, like I'm looking at 1970's C code.</source>
          <target state="translated">另外,现在,当我看到 &quot;int &quot;或 &quot;string &quot;的时候,对我来说,它看起来真的不对,就像我在看70年代的C代码一样。</target>
        </trans-unit>
        <trans-unit id="c77c986c978db50c2edb1530b6d7604bb90ae875" translate="yes" xml:space="preserve">
          <source>Another critical difference: Stack Overflow highlights them differently.</source>
          <target state="translated">另一个关键的区别。Stack Overflow以不同的方式突出了它们。</target>
        </trans-unit>
        <trans-unit id="337038535cd28955eae1f640e7096e40e7631b25" translate="yes" xml:space="preserve">
          <source>Another way to visualize the difference is with this sample:</source>
          <target state="translated">另一个可视化的方法就是用这个样本来实现差异化。</target>
        </trans-unit>
        <trans-unit id="a60b6da79539bdc8b7cb297451feb7d858cf6d80" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, the aliases are all to value types. &lt;code&gt;decimal&lt;/code&gt; is a value type, but not a primitive type in the CLR. The only primitive type which doesn't have an alias is &lt;code&gt;System.IntPtr&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;object&lt;/code&gt; ，别名都是值类型。 &lt;code&gt;decimal&lt;/code&gt; 是一种值类型，但不是CLR中的原始类型。 没有别名的唯一基本类型是 &lt;code&gt;System.IntPtr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccbcd6fabeac0fa1e903b96ce302d37cc9ab55a9" translate="yes" xml:space="preserve">
          <source>As far as guidelines, it's generally recommended to use &lt;code&gt;string&lt;/code&gt; any time you're referring to an object.</source>
          <target state="translated">就准则而言，通常建议您在引用对象时都使用 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d8db7a7da3c8e55c6ef7583c26653161b5963c8" translate="yes" xml:space="preserve">
          <source>As for guidelines I wouldn't get too bogged down and just use whichever you feel like - there are more important things in life and the code is going to be the same anyway.</source>
          <target state="translated">至于指导原则,我不会太过纠结,随便用哪个就好--生活中还有更重要的事情,反正代码都是一样的。</target>
        </trans-unit>
        <trans-unit id="49f6b692ecbc8ab730cec2fc66a93ce1d36c6a77" translate="yes" xml:space="preserve">
          <source>As others have noted, &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;. They compile to the same code, so at execution time there is no difference whatsoever. This is just one of the aliases in C#. The complete list is:</source>
          <target state="translated">正如其他人指出的那样， &lt;code&gt;string&lt;/code&gt; 是 &lt;code&gt;System.String&lt;/code&gt; 的别名。 它们编译为相同的代码，因此在执行时没有任何区别。 这只是C＃中的别名之一。 完整列表是：</target>
        </trans-unit>
        <trans-unit id="dfd1c1e7e5f7162b6737b19a1d23e4b8e738b888" translate="yes" xml:space="preserve">
          <source>As the others are saying, they're the same.  StyleCop rules, by default, will enforce you to use &lt;code&gt;string&lt;/code&gt; as a C# code style best practice, except when referencing &lt;code&gt;System.String&lt;/code&gt; static functions, such as &lt;code&gt;String.Format&lt;/code&gt;, &lt;code&gt;String.Join&lt;/code&gt;, &lt;code&gt;String.Concat&lt;/code&gt;, etc...</source>
          <target state="translated">正如其他人所说，它们是相同的。 默认情况下，StyleCop规则将强制您将 &lt;code&gt;string&lt;/code&gt; 用作C＃代码样式的最佳做法，除非引用 &lt;code&gt;System.String&lt;/code&gt; 静态函数，例如 &lt;code&gt;String.Format&lt;/code&gt; ， &lt;code&gt;String.Join&lt;/code&gt; ， &lt;code&gt;String.Concat&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="d3e69bc36fcde9e95937ddabcf28d8aa1e3d28c7" translate="yes" xml:space="preserve">
          <source>Both are same. But from coding guidelines perspective it's better to use &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;. This is what generally developers use. e.g. instead of using &lt;code&gt;Int32&lt;/code&gt; we use &lt;code&gt;int&lt;/code&gt; as &lt;code&gt;int&lt;/code&gt; is alias to &lt;code&gt;Int32&lt;/code&gt;</source>
          <target state="translated">两者都一样。 但是从编码准则的角度来看，最好使用 &lt;code&gt;string&lt;/code&gt; 而不是 &lt;code&gt;String&lt;/code&gt; 。 这是开发人员通常使用的。 例如，我们使用 &lt;code&gt;int&lt;/code&gt; 代替 &lt;code&gt;Int32&lt;/code&gt; ,因为 &lt;code&gt;int&lt;/code&gt; 是 &lt;code&gt;Int32&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="11a99bfdab95ac5c2ba17b81950872e8650ba272" translate="yes" xml:space="preserve">
          <source>But now for a long textual answer.</source>
          <target state="translated">但现在要做一个长文的回答。</target>
        </trans-unit>
        <trans-unit id="bf90ee429ac8f8bc62dfdefed6e11fb05e6fc23e" translate="yes" xml:space="preserve">
          <source>C# is a language which is used together with the CLR.</source>
          <target state="translated">C#是一种与CLR一起使用的语言。</target>
        </trans-unit>
        <trans-unit id="9d5c764a1acaa5b5bcb96101fe97b4133de42c33" translate="yes" xml:space="preserve">
          <source>Coming late to the party: I use the CLR types 100% of the time (well, except if &lt;em&gt;forced&lt;/em&gt; to use the C# type, but I don't remember when the last time that was).</source>
          <target state="translated">迟到了：我100％的时间都使用CLR类型（嗯，除非&lt;em&gt;被迫&lt;/em&gt;使用C＃类型，但我不记得上一次是什么时候）。</target>
        </trans-unit>
        <trans-unit id="84b6fa77f09cddf191ebef51dd09349c2e4423ea" translate="yes" xml:space="preserve">
          <source>Conditional and control keywords (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;) are lowercase and colored dark blue (by default). And I would rather not have the disagreement in use and format.</source>
          <target state="translated">条件和控制关键字（例如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; ）为小写字母，颜色为深蓝色（默认情况下）。 我宁愿在使用和格式方面没有分歧。</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="63cf87d7199d567617ea4b6ca5ec4e87620d8625" translate="yes" xml:space="preserve">
          <source>Example (&lt;em&gt;note the case&lt;/em&gt;):</source>
          <target state="translated">示例（ &lt;em&gt;注意情况&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="52936f8d320a5c9edae9467890ff6b3835ae84b6" translate="yes" xml:space="preserve">
          <source>FYI
&amp;ldquo;The keyword string is simply an alias for the predefined class &lt;code&gt;System.String&lt;/code&gt;.&amp;rdquo; - C# Language Specification 4.2.3
&lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&lt;/a&gt;</source>
          <target state="translated">仅供参考：&amp;ldquo;关键字字符串只是预定义类 &lt;code&gt;System.String&lt;/code&gt; 的别名。&amp;rdquo; -C＃语言规范4.2.3 &lt;a href=&quot;http://msdn2.microsoft.com/En-US/library/aa691153.aspx&quot;&gt;http://msdn2.microsoft.com/zh-CN/library/aa691153.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58792e3b925f31858fc5ea747e687bdc0f62a6ae" translate="yes" xml:space="preserve">
          <source>Finally, when it comes to which to use: personally I use the aliases everywhere for the implementation, but the CLR type for any APIs. It really doesn't matter too much which you use in terms of implementation - consistency among your team is nice, but no-one else is going to care. On the other hand, it's genuinely important that if you refer to a type in an API, you do so in a language-neutral way. A method called &lt;code&gt;ReadInt32&lt;/code&gt; is unambiguous, whereas a method called &lt;code&gt;ReadInt&lt;/code&gt; requires interpretation. The caller could be using a language that defines an &lt;code&gt;int&lt;/code&gt; alias for &lt;code&gt;Int16&lt;/code&gt;, for example. The .NET framework designers have followed this pattern, good examples being in the &lt;code&gt;BitConverter&lt;/code&gt;, &lt;code&gt;BinaryReader&lt;/code&gt; and &lt;code&gt;Convert&lt;/code&gt; classes.</source>
          <target state="translated">最后，涉及到使用什么：我个人将别名用于实现，但对于任何API均使用CLR类型。 在实现方面，您使用哪一个确实无关紧要-团队之间的一致性很好，但是没有人会在意。 另一方面，真正重要的是，如果您在API中引用类型，则必须以与语言无关的方式进行。 称为 &lt;code&gt;ReadInt32&lt;/code&gt; 的方法是明确的，而称为 &lt;code&gt;ReadInt&lt;/code&gt; 的方法需要解释。 例如，调用者可能使用的语言为 &lt;code&gt;Int16&lt;/code&gt; 定义了 &lt;code&gt;int&lt;/code&gt; 别名。 .NET框架设计人员遵循了这种模式， &lt;code&gt;BitConverter&lt;/code&gt; ， &lt;code&gt;BinaryReader&lt;/code&gt; 和 &lt;code&gt;Convert&lt;/code&gt; 类中的例子很好。</target>
        </trans-unit>
        <trans-unit id="361f354e3c112924a67a6cd4e52c6912aa86f34b" translate="yes" xml:space="preserve">
          <source>First thing to avoid confusion use one of them consistently. But from best practices perspective when you do variable declaration it's good to use &quot;string&quot; ( small &quot;s&quot;) and when you are using it as a class name then &quot;String&quot; ( capital &quot;S&quot;) is preferred.</source>
          <target state="translated">首先,为了避免混淆,请一致使用其中的一个。但从最佳实践的角度来看,当你做变量声明时,最好使用 &quot;string&quot;(小 &quot;s&quot;),而当你把它作为类名时,最好使用 &quot;String&quot;(大写的 &quot;S&quot;)。</target>
        </trans-unit>
        <trans-unit id="901ba968f95a818d5303d46cf8a18ecd2e7bfdd0" translate="yes" xml:space="preserve">
          <source>First, when &lt;code&gt;String&lt;/code&gt; is a &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt; of the current type (or a local variable):</source>
          <target state="translated">首先，当 &lt;code&gt;String&lt;/code&gt; 是当前类型的&lt;strong&gt;&lt;em&gt;值&lt;/em&gt;&lt;/strong&gt; （或局部变量）时：</target>
        </trans-unit>
        <trans-unit id="ee5cc7375a72753d04afe3ef92339bdd63c94ee7" translate="yes" xml:space="preserve">
          <source>I can say the same about &lt;strong&gt;(&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;System.Int32&lt;/code&gt;)&lt;/strong&gt; etc..</source>
          <target state="translated">我可以对&lt;strong&gt;（ &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;System.Int32&lt;/code&gt; ）&lt;/strong&gt;等说同样的话。</target>
        </trans-unit>
        <trans-unit id="ea3e61270f6cf9945f0a83b40b68501c8a543b14" translate="yes" xml:space="preserve">
          <source>I didn't get his opinion before I read the complete paragraph.</source>
          <target state="translated">在我读完这一段之前,我没有得到他的意见。</target>
        </trans-unit>
        <trans-unit id="d5494c0741861941dbb77b1154505ecd11f5b5b3" translate="yes" xml:space="preserve">
          <source>I originally started doing this years ago, as per the CLR books by Ritchie. It made sense to me that all CLR languages ultimately have to be able to support the set of CLR types, so using the CLR types yourself provided clearer, and possibly more &quot;reusable&quot; code.</source>
          <target state="translated">我最初是在多年前开始做的,按照Ritchie的CLR书籍的说法,我开始做这件事。在我看来,所有的CLR语言最终都必须能够支持CLR类型集,所以使用CLR类型自己提供的代码更清晰,可能也更 &quot;可重用&quot;。</target>
        </trans-unit>
        <trans-unit id="b41709e8dc275dd7834960616cb7974a5926cbc8" translate="yes" xml:space="preserve">
          <source>I prefer the capitalized &lt;code&gt;.NET&lt;/code&gt; types (rather than the aliases) for formatting reasons. The &lt;code&gt;.NET&lt;/code&gt; types are colored the same as other object types (the value types are proper objects, after all).</source>
          <target state="translated">由于格式化的原因，我更喜欢使用大写的 &lt;code&gt;.NET&lt;/code&gt; 类型（而不是别名）。 &lt;code&gt;.NET&lt;/code&gt; 类型的颜色与其他对象类型相同（毕竟，值类型是正确的对象）。</target>
        </trans-unit>
        <trans-unit id="5a239d3ab937b3004575ec484c47a6e4ed49e68f" translate="yes" xml:space="preserve">
          <source>I shall provide two examples where &lt;em&gt;&lt;code&gt;using&lt;/code&gt; directives will not help&lt;/em&gt;.</source>
          <target state="translated">我将提供两个示例，其中&lt;em&gt; &lt;code&gt;using&lt;/code&gt; 指令无济于事&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa93903e288f3d4e16cf4bb1f90b96f48052393" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt;
  or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# &lt;strong&gt;string&lt;/strong&gt; (a keyword) maps exactly to
  &lt;strong&gt;System.String&lt;/strong&gt; (an FCL type), there is no difference and either can be used. Similarly,
  I&amp;rsquo;ve heard some developers say that &lt;strong&gt;int&lt;/strong&gt; represents a 32-bit integer when the application
  is running on a 32-bit OS and that it represents a 64-bit integer when the application
  is running on a 64-bit OS. This statement is absolutely false: in C#, an &lt;strong&gt;int&lt;/strong&gt; always maps
  to &lt;strong&gt;System.Int32&lt;/strong&gt;, and therefore it represents a 32-bit integer regardless of the OS the
  code is running on. If programmers would use &lt;strong&gt;Int32&lt;/strong&gt; in their code, then this potential
  confusion is also eliminated.</source>
          <target state="translated">我看到许多开发人员感到困惑，他们不知道在他们的代码中使用&lt;strong&gt;字符串&lt;/strong&gt;还是&lt;strong&gt;字符串&lt;/strong&gt; 。 因为在C＃中， &lt;strong&gt;字符串&lt;/strong&gt; （关键字）精确地映射到&lt;strong&gt;System.String&lt;/strong&gt; （FCL类型），所以没有区别，并且两者都可以使用。 同样，我听到一些开发人员说，当应用程序在32位操作系统上运行时， &lt;strong&gt;int&lt;/strong&gt;表示32位整数，而当应用程序在64位操作系统上运行时， &lt;strong&gt;int&lt;/strong&gt;表示64位整数。 该语句绝对是错误的：在C＃中，一个&lt;strong&gt;int&lt;/strong&gt;始终映射到&lt;strong&gt;System.Int32&lt;/strong&gt; ，因此，无论代码运行在哪个OS上，它都表示一个32位整数。 如果程序员在他们的代码中使用&lt;strong&gt;Int32&lt;/strong&gt; ，那么这种潜在的混乱也将消除。</target>
        </trans-unit>
        <trans-unit id="fa954e4cefc7a46db782057de61937b12e9e5aed" translate="yes" xml:space="preserve">
          <source>I'd just like to add this to lfousts answer, from Ritchers book:</source>
          <target state="translated">我只想把这句话补充到lfousts的答案里,从Ritchers的书里。</target>
        </trans-unit>
        <trans-unit id="21899fca0863f132973844812fab0c779022a7b9" translate="yes" xml:space="preserve">
          <source>I've seen a number of developers confused, not knowing whether to use &lt;strong&gt;string&lt;/strong&gt; or &lt;strong&gt;String&lt;/strong&gt; in their code. Because in C# the string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used.</source>
          <target state="translated">我看到许多开发人员感到困惑，他们不知道在他们的代码中使用&lt;strong&gt;字符串&lt;/strong&gt;还是&lt;strong&gt;字符串&lt;/strong&gt; 。 因为在C＃中，字符串（关键字）精确地映射到System.String（FCL类型），所以没有区别，并且两者都可以使用。</target>
        </trans-unit>
        <trans-unit id="6b7d898ac30d5c92342d8ac9760039cee7099d78" translate="yes" xml:space="preserve">
          <source>If for some reason you wanted a variable called &lt;em&gt;string&lt;/em&gt;, you'd see only the first of these compiles:</source>
          <target state="translated">如果由于某种原因您想要一个名为&lt;em&gt;string&lt;/em&gt;的变量，那么您只会看到以下第一个编译：</target>
        </trans-unit>
        <trans-unit id="4415225af42f5d012580c28bcbef4acf554c9d6c" translate="yes" xml:space="preserve">
          <source>If you find yourselves building systems where it is necessary to specify the size of the integers you are using and so tend to use &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt; etc. then it might look more natural to use &lt;code&gt;String&lt;/code&gt; - and when moving around between different .net languages it might make things more understandable - otherwise I would use string and int.</source>
          <target state="translated">如果您发现自己需要指定所使用整数的大小的构建系统，因此倾向于使用 &lt;code&gt;Int16&lt;/code&gt; ， &lt;code&gt;Int32&lt;/code&gt; ， &lt;code&gt;UInt16&lt;/code&gt; ， &lt;code&gt;UInt32&lt;/code&gt; 等。那么使用 &lt;code&gt;String&lt;/code&gt; 看起来更自然-并且在不同位置之间移动时.net语言可能会使事情更容易理解-否则我将使用字符串和整数。</target>
        </trans-unit>
        <trans-unit id="fc3d0d8990fb3765be09111a7c669c84b913e5c0" translate="yes" xml:space="preserve">
          <source>If you really want a variable name called &lt;em&gt;string&lt;/em&gt; you can use &lt;code&gt;@&lt;/code&gt; as a prefix:</source>
          <target state="translated">如果您确实想要一个名为&lt;em&gt;string&lt;/em&gt;的变量名，则可以使用 &lt;code&gt;@&lt;/code&gt; 作为前缀：</target>
        </trans-unit>
        <trans-unit id="5da7f23835ffc9c6b22e25e2d55eb0854a9abafa" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt;
  could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does treat &lt;strong&gt;long&lt;/strong&gt; as an &lt;strong&gt;Int32&lt;/strong&gt;.
  Someone reading source code in one language could easily misinterpret the code&amp;rsquo;s
  intention if he or she were used to programming in a different programming language.
  In fact, most languages won&amp;rsquo;t even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won&amp;rsquo;t compile code
  that uses it.</source>
          <target state="translated">在C＃中， &lt;strong&gt;long&lt;/strong&gt;映射到&lt;strong&gt;System.Int64&lt;/strong&gt; ，但在另一种编程语言中， &lt;strong&gt;long&lt;/strong&gt;可以映射到&lt;strong&gt;Int16&lt;/strong&gt;或&lt;strong&gt;Int32&lt;/strong&gt; 。 实际上，C ++ / CLI确实将&lt;strong&gt;Int32&lt;/strong&gt;视为&lt;strong&gt;长期&lt;/strong&gt;使用。 如果有人习惯使用一种语言来阅读源代码，则很容易会误解该代码的意图。 实际上，大多数语言甚至都不会将其当作关键字使用很&lt;strong&gt;长时间&lt;/strong&gt; ，也不会编译使用该关键字的代码。</target>
        </trans-unit>
        <trans-unit id="c34719d5baf69cca85f742773fbc5ad7584b58a0" translate="yes" xml:space="preserve">
          <source>In C#, &lt;strong&gt;long&lt;/strong&gt; maps to &lt;strong&gt;System.Int64&lt;/strong&gt;, but in a different programming language, &lt;strong&gt;long&lt;/strong&gt; could map to an &lt;strong&gt;Int16&lt;/strong&gt; or &lt;strong&gt;Int32&lt;/strong&gt;. In fact, C++/CLI does in fact treat long as an &lt;strong&gt;Int32&lt;/strong&gt;. Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language. In fact, most languages won't even treat &lt;strong&gt;long&lt;/strong&gt; as a keyword and won't compile code that uses it.</source>
          <target state="translated">在C＃中， &lt;strong&gt;long&lt;/strong&gt;映射到&lt;strong&gt;System.Int64&lt;/strong&gt; ，但在另一种编程语言中， &lt;strong&gt;long&lt;/strong&gt;可以映射到&lt;strong&gt;Int16&lt;/strong&gt;或&lt;strong&gt;Int32&lt;/strong&gt; 。 实际上，C ++ / CLI实际上确实像&lt;strong&gt;Int32&lt;/strong&gt;一样对待。 如果有人习惯使用一种语言来阅读源代码，则很容易会误解该代码的意图。 实际上，大多数语言甚至都不会将其当作关键字使用很&lt;strong&gt;长时间&lt;/strong&gt; ，也不会编译使用该关键字的代码。</target>
        </trans-unit>
        <trans-unit id="7b36107e9559a09694a8183cb99815886d4e78c3" translate="yes" xml:space="preserve">
          <source>In short &quot;String&quot; is an alias ( the same thing called with different names) of &quot;string&quot;. So technically both the below code statements will give the same output.</source>
          <target state="translated">简而言之,&quot;String &quot;是 &quot;string &quot;的别名(同样的东西用不同的名字来称呼)。所以从技术上讲,下面的代码语句都会给出相同的输出。</target>
        </trans-unit>
        <trans-unit id="e6dc65980fe8a04364550bf8267b4a0752724591" translate="yes" xml:space="preserve">
          <source>In the below code the left hand side is a variable declaration and it declared using &quot;string&quot;. At the right hand side we are calling a method so &quot;String&quot; is more sensible.</source>
          <target state="translated">在下面的代码中,左边是一个变量声明,用 &quot;string &quot;声明。在右手边,我们正在调用一个方法,所以用 &quot;String &quot;比较合理。</target>
        </trans-unit>
        <trans-unit id="f98303445c332e612954049bbaf882f4fa3cb7e9" translate="yes" xml:space="preserve">
          <source>In the same way there are aliases for other c# data type as shown below:-</source>
          <target state="translated">同样,其他c#数据类型也有别名,如下图所示:--</target>
        </trans-unit>
        <trans-unit id="57dee12da4dec3aa9f4c4e8403aa2ad08617efcc" translate="yes" xml:space="preserve">
          <source>In the spec, the value type aliases are known as &quot;simple types&quot;. Literals can be used for constant values of every simple type; no other value types have literal forms available. (Compare this with VB, which allows &lt;code&gt;DateTime&lt;/code&gt; literals, and has an alias for it too.)</source>
          <target state="translated">在规范中，值类型别名称为&amp;ldquo;简单类型&amp;rdquo;。 文字可用于每种简单类型的常量值； 没有其他值类型具有文字形式可用。 （将此与VB进行比较，后者允许 &lt;code&gt;DateTime&lt;/code&gt; 文字，并且也具有别名。）</target>
        </trans-unit>
        <trans-unit id="483cab40a51898204e58cfed265106143d7f4953" translate="yes" xml:space="preserve">
          <source>It appears that the guidance in this area may have changed, as &lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt; now enforces the use of the C# specific aliases.</source>
          <target state="translated">似乎此区域中的指南可能已更改，因为&lt;a href=&quot;https://github.com/StyleCop&quot;&gt;StyleCop&lt;/a&gt;现在强制使用C＃特定别名。</target>
        </trans-unit>
        <trans-unit id="ff67dae909a99ee9a9e7def47187588639f45a8f" translate="yes" xml:space="preserve">
          <source>It's a matter of convention, really.  &lt;code&gt;string&lt;/code&gt; just looks more like C/C++ style.  The general convention is to use whatever shortcuts your chosen language has provided (int/Int for &lt;code&gt;Int32&lt;/code&gt;).  This goes for &quot;object&quot; and &lt;code&gt;decimal&lt;/code&gt; as well.</source>
          <target state="translated">确实，这是惯例问题。 &lt;code&gt;string&lt;/code&gt; 看起来更像是C / C ++样式。 一般约定是使用所选语言提供的任何快捷方式（ &lt;code&gt;Int32&lt;/code&gt; 的in / Int）。 这也适用于&amp;ldquo;对象&amp;rdquo;和 &lt;code&gt;decimal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3838b064aeaafbf213d49b0394cdd6a50f24ba3e" translate="yes" xml:space="preserve">
          <source>It's been covered above; however, you can't use &lt;code&gt;string&lt;/code&gt; in reflection; you must use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">上面已经讲过了； 但是，不能在反射中使用 &lt;code&gt;string&lt;/code&gt; 。 您必须使用 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e09d862931ec0e2748cdc4ff36fc4d9cad4e1d6a" translate="yes" xml:space="preserve">
          <source>Just for the sake of completeness, here's a brain dump of related information...</source>
          <target state="translated">为了完整,下面是脑补一下相关信息......</target>
        </trans-unit>
        <trans-unit id="5e78ed6411bc19fbcef0b5786cecd66b3134b765" translate="yes" xml:space="preserve">
          <source>Likewise, I think it's generally recommended to use &lt;code&gt;String&lt;/code&gt; if you need to refer specifically to the class.</source>
          <target state="translated">同样，我认为如果需要专门引用该类，通常建议使用 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc04acca921cef20c01ada3297aed735cee9b09f" translate="yes" xml:space="preserve">
          <source>Lower case &lt;code&gt;string&lt;/code&gt; is an alias for &lt;code&gt;System.String&lt;/code&gt;.
They are the same in &lt;code&gt;C#&lt;/code&gt;.</source>
          <target state="translated">小写 &lt;code&gt;string&lt;/code&gt; 是 &lt;code&gt;System.String&lt;/code&gt; 的别名。 它们在 &lt;code&gt;C#&lt;/code&gt; 中是相同的。</target>
        </trans-unit>
        <trans-unit id="aa9ccdfd7c726f6e226b0942c75a549ff6e70b5d" translate="yes" xml:space="preserve">
          <source>Lowercase &lt;code&gt;string&lt;/code&gt; is preferred in most projects due to the syntax highlighting</source>
          <target state="translated">由于语法突出显示，因此在大多数项目中首选小写 &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6133573d560cd3eea08983f58c0042a25059f55" translate="yes" xml:space="preserve">
          <source>Many programmers that use C# exclusively tend to forget that other programming
  languages can be used against the CLR, and because of this, C#-isms creep into the
  class library code. For example, Microsoft&amp;rsquo;s FCL is almost exclusively written in C# and
  developers on the FCL team have now introduced methods into the library such as
  &lt;strong&gt;Array&lt;/strong&gt;&amp;rsquo;s &lt;strong&gt;GetLongLength&lt;/strong&gt;, which returns an &lt;strong&gt;Int64&lt;/strong&gt; value that is a &lt;strong&gt;long&lt;/strong&gt; in C# but not
  in other languages (like C++/CLI). Another example is &lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;&amp;rsquo;s
  &lt;strong&gt;LongCount&lt;/strong&gt; method.</source>
          <target state="translated">许多专门使用C＃的程序员往往会忘记可以将其他编程语言用于CLR，因此，C＃原理会渗入类库代码中。 例如，Microsoft的FCL几乎完全是用C＃编写的，并且FCL团队的开发人员现在已将方法引入到库中，例如&lt;strong&gt;Array&lt;/strong&gt;的&lt;strong&gt;GetLongLength&lt;/strong&gt; ，该方法返回的&lt;strong&gt;Int64&lt;/strong&gt;值在C＃中&lt;strong&gt;很长&lt;/strong&gt; ，但在其他语言中（例如C ++） / CLI）。 另一个示例是&lt;strong&gt;System.Linq.Enumerable&lt;/strong&gt;的&lt;strong&gt;LongCount&lt;/strong&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9df02f88b75a5ae9238b00816debf524d9b6d4bb" translate="yes" xml:space="preserve">
          <source>Many will argue that while this is information technically accurate using &lt;code&gt;String&lt;/code&gt; is still fine because it&amp;rsquo;s exceedingly rare that a code base would define a type of this name. Or that when &lt;code&gt;String&lt;/code&gt; is defined it&amp;rsquo;s a sign of a bad code base.</source>
          <target state="translated">许多人会争辩说，尽管这在技术上是准确的信息，但使用 &lt;code&gt;String&lt;/code&gt; 还是可以的，因为很少有代码库会定义此名称的类型。 否则，当定义 &lt;code&gt;String&lt;/code&gt; 时,就表明代码基础不正确。</target>
        </trans-unit>
        <trans-unit id="4969c66ffc5656f3999a26d516caf717157af60a" translate="yes" xml:space="preserve">
          <source>Neither statement in the &lt;code&gt;Example&lt;/code&gt; method compiles. Here &lt;code&gt;String&lt;/code&gt; is always a piano &lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;string&lt;/a&gt;, &lt;code&gt;MyPiano.String&lt;/code&gt;. No member (&lt;code&gt;static&lt;/code&gt; or not) &lt;code&gt;Format&lt;/code&gt; exists on it (or is inherited from its base class). And the value &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; cannot be converted into it.</source>
          <target state="translated">&lt;code&gt;Example&lt;/code&gt; 方法中的任何一条语句都不会编译。 这里 &lt;code&gt;String&lt;/code&gt; 始终是钢琴&lt;a href=&quot;http://en.wikipedia.org/wiki/String_(music)&quot;&gt;字符串&lt;/a&gt; &lt;code&gt;MyPiano.String&lt;/code&gt; 。 没有成员（ &lt;code&gt;static&lt;/code&gt; 或非静态 ） &lt;code&gt;Format&lt;/code&gt; （或从其基类继承）。 并且值 &lt;code&gt;&quot;Goodbye&quot;&lt;/code&gt; 不能转换为它。</target>
        </trans-unit>
        <trans-unit id="2fa06e504f29a303da31352f8e430b6dc30c1883" translate="yes" xml:space="preserve">
          <source>New answer after 6 years and 5 months (procrastination).</source>
          <target state="translated">6年5个月后的新答案(拖延症)。</target>
        </trans-unit>
        <trans-unit id="296daf449bf0c8664c9e6d199847c7929ad529f1" translate="yes" xml:space="preserve">
          <source>Note: I copy/pasted most of the blog post for archive reason. I ignore some parts, so I recommend to skip and to read the &lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;blog post&lt;/a&gt; if you can.</source>
          <target state="translated">注意：出于存档原因，我复制/粘贴了大多数博客文章。 我忽略了某些部分，因此建议您跳过并阅读&lt;a href=&quot;http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html&quot;&gt;博客文章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="022ba2779e8f9a2cb535c438e2a28ea7b0dd3e80" translate="yes" xml:space="preserve">
          <source>Now that I've been doing it for years, it's a habit and I like the coloration that VS shows for the CLR types.</source>
          <target state="translated">现在我已经做了很多年了,这已经是一种习惯了,而且我喜欢VS显示的CLR类型的着色,这也是我喜欢的。</target>
        </trans-unit>
        <trans-unit id="b3ab40a90e383fb18e0e975a4f3ebb4b8b3eaeff" translate="yes" xml:space="preserve">
          <source>Secondly, when &lt;code&gt;String&lt;/code&gt; is another &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, nested inside the current type:</source>
          <target state="translated">其次，当 &lt;code&gt;String&lt;/code&gt; 是另一个&lt;strong&gt;&lt;em&gt;类型时&lt;/em&gt;&lt;/strong&gt; ，嵌套在当前类型内：</target>
        </trans-unit>
        <trans-unit id="e101d4a69cdea700b7d60c87527fa5d12e284702" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;int&lt;/code&gt; maps to &lt;code&gt;System.Int32&lt;/code&gt;.</source>
          <target state="translated">同样， &lt;code&gt;int&lt;/code&gt; 映射到 &lt;code&gt;System.Int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="689346a590d26a7f24b31d23dd2fbc483406fd3b" translate="yes" xml:space="preserve">
          <source>So remember when you see the &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; debate this is about semantics, not style. Choosing string gives crisp meaning to your code base. Choosing &lt;code&gt;String&lt;/code&gt; isn&amp;rsquo;t wrong but it&amp;rsquo;s leaving the door open for surprises in the future.</source>
          <target state="translated">因此，请记住，当您看到有关 &lt;code&gt;String&lt;/code&gt; 与 &lt;code&gt;string&lt;/code&gt; 争论时，这是关于语义而非样式的。 选择字符串可使代码库具有清晰的含义。 选择 &lt;code&gt;String&lt;/code&gt; 并没有错，但它为将来的惊喜打开了大门。</target>
        </trans-unit>
        <trans-unit id="9cb50509dd63b7929b71e5a34e498aabbd13f875" translate="yes" xml:space="preserve">
          <source>So technically, there is no difference.  It's like &lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt;&lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">因此，从技术上讲，没有区别。 就像&lt;a href=&quot;https://stackoverflow.com/questions/62503/c-int-or-int32-should-i-care&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;em&gt;vs.&lt;/em&gt; &lt;code&gt;System.Int32&lt;/code&gt; 一样&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2325db982bbc83b6294b8c0dff80dba26d189b" translate="yes" xml:space="preserve">
          <source>So there you have it. I think these are all really good points. I however, don't find myself using Jeffrey's advice in my own code. Maybe I am too stuck in my C# world but I end up trying to make my code look like the framework code.</source>
          <target state="translated">所以,你有了它。我认为这些都是非常好的观点。但是,我没有发现自己在自己的代码中使用Jeffrey的建议。也许是我太沉浸在自己的C#世界里了,但我最终还是试图让自己的代码看起来像框架代码一样。</target>
        </trans-unit>
        <trans-unit id="84d84cfed9ed57bbe7f2bacafbaddfb81576cf17" translate="yes" xml:space="preserve">
          <source>String (&lt;code&gt;System.String&lt;/code&gt;) is a class in the base class library. string (lower case) is a reserved work in C# that is an alias for System.String. Int32 vs int is a similar situation as is &lt;code&gt;Boolean vs. bool&lt;/code&gt;. These C# language specific keywords enable you to declare primitives in a style similar to C.</source>
          <target state="translated">String（ &lt;code&gt;System.String&lt;/code&gt; ）是基类库中的类。 字符串（小写）是C＃中的保留作品，它是System.String的别名。 Int32 vs int与 &lt;code&gt;Boolean vs. bool&lt;/code&gt; 类似。 这些特定于C＃语言的关键字使您能够以类似于C的样式声明基元。</target>
        </trans-unit>
        <trans-unit id="49ce6a3b5fc76630de40afb2fe0abba3f193580b" translate="yes" xml:space="preserve">
          <source>That's just a matter of the way the spec defines enum declarations - the part after the colon has to be the &lt;em&gt;integral-type&lt;/em&gt; production, which is one token of &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;... as opposed to a &lt;em&gt;type&lt;/em&gt; production as used by variable declarations for example. It doesn't indicate any other difference.</source>
          <target state="translated">这只是规范定义枚举声明的方式的问题-冒号后面的部分必须是&lt;em&gt;整型&lt;/em&gt;生产，这是 &lt;code&gt;sbyte&lt;/code&gt; ， &lt;code&gt;byte&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;ushort&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;uint&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;ulong&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; 的一个标记。 ..与例如变量声明所使用的&lt;em&gt;类型&lt;/em&gt;产生相反。 它并不表示其他任何区别。</target>
        </trans-unit>
        <trans-unit id="57cd8f4f9cafb98e0ff1960638924dc3de76b39d" translate="yes" xml:space="preserve">
          <source>The C# keyword &lt;code&gt;string&lt;/code&gt; maps to the .NET type &lt;code&gt;System.String&lt;/code&gt; - it is an alias that keeps to the naming conventions of the language.</source>
          <target state="translated">C＃关键字 &lt;code&gt;string&lt;/code&gt; 映射到.NET类型 &lt;code&gt;System.String&lt;/code&gt; -它是一个别名，保留了该语言的命名约定。</target>
        </trans-unit>
        <trans-unit id="f49eb70607b2497b91d8c266445436a4abe3155d" translate="yes" xml:space="preserve">
          <source>The C# language specification states, &amp;ldquo;As a matter of style, use of the keyword is favored over
  use of the complete system type name.&amp;rdquo; I disagree with the language specification; I prefer
  to use the FCL type names and completely avoid the primitive type names. In fact, I wish that
  compilers didn&amp;rsquo;t even offer the primitive type names and forced developers to use the FCL
  type names instead. Here are my reasons:</source>
          <target state="translated">C＃语言规范指出：&amp;ldquo;就样式而言，使用关键字胜于使用完整的系统类型名称。&amp;rdquo; 我不同意语言规范； 我更喜欢使用FCL类型名称，而完全避免使用原始类型名称。 实际上，我希望编译器甚至不提供原始类型名称，而强迫开发人员改用FCL类型名称。 这是我的原因：</target>
        </trans-unit>
        <trans-unit id="fce2e5a5f468c7b1c34cd9768434166999ddbdb0" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For
  example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;,
  &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as
  &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it&amp;rsquo;s legal to write the following
  code, the line with &lt;strong&gt;float&lt;/strong&gt; feels very unnatural to me, and it&amp;rsquo;s not obvious that the line is
  correct:</source>
          <target state="translated">FCL有许多方法，这些方法的名称中包含类型名称。 例如， &lt;strong&gt;BinaryReader&lt;/strong&gt;类型提供诸如&lt;strong&gt;ReadBoolean&lt;/strong&gt; ， &lt;strong&gt;ReadInt32&lt;/strong&gt; ， &lt;strong&gt;ReadSingle&lt;/strong&gt;等方法，而&lt;strong&gt;System.Convert&lt;/strong&gt;类型提供诸如&lt;strong&gt;ToBoolean&lt;/strong&gt; ， &lt;strong&gt;ToInt32&lt;/strong&gt; ， &lt;strong&gt;ToSingle&lt;/strong&gt;等方法。 尽管编写以下代码是合法的，但带&lt;strong&gt;float&lt;/strong&gt;的行对我来说感觉很不自然，并且显然该行是正确的：</target>
        </trans-unit>
        <trans-unit id="d241e925f9c6c70e65ab7201f55f79ecdaebf9ce" translate="yes" xml:space="preserve">
          <source>The FCL has many methods that have type names as part of their method names. For example, the &lt;strong&gt;BinaryReader&lt;/strong&gt; type offers methods such as &lt;strong&gt;ReadBoolean&lt;/strong&gt;, &lt;strong&gt;ReadInt32&lt;/strong&gt;, &lt;strong&gt;ReadSingle&lt;/strong&gt;, and so on, and the &lt;strong&gt;System.Convert&lt;/strong&gt; type offers methods such as &lt;strong&gt;ToBoolean&lt;/strong&gt;, &lt;strong&gt;ToInt32&lt;/strong&gt;, &lt;strong&gt;ToSingle&lt;/strong&gt;, and so on. Although it's legal to write the following code, the line with float feels very unnatural to me, and it's not obvious that the line is correct:</source>
          <target state="translated">FCL有许多方法，这些方法的名称中包含类型名称。 例如， &lt;strong&gt;BinaryReader&lt;/strong&gt;类型提供诸如&lt;strong&gt;ReadBoolean&lt;/strong&gt; ， &lt;strong&gt;ReadInt32&lt;/strong&gt; ， &lt;strong&gt;ReadSingle&lt;/strong&gt;等方法，而&lt;strong&gt;System.Convert&lt;/strong&gt;类型提供诸如&lt;strong&gt;ToBoolean&lt;/strong&gt; ， &lt;strong&gt;ToInt32&lt;/strong&gt; ， &lt;strong&gt;ToSingle&lt;/strong&gt;等方法。 尽管编写以下代码是合法的，但带float的行对我来说感觉很不自然，并且显然该行是正确的：</target>
        </trans-unit>
        <trans-unit id="245547d31df063b9be5afb5f9f9e26bb654e9990" translate="yes" xml:space="preserve">
          <source>The above will not compile because &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; does not have a non-static member called &lt;code&gt;Format&lt;/code&gt;, and no extension methods apply. In the above case, it may still be possible to use &lt;code&gt;String&lt;/code&gt; in other contexts where a &lt;em&gt;type&lt;/em&gt; is the only possibility syntactically. For example &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; could be OK (depending on namespace and &lt;code&gt;using&lt;/code&gt; directives).</source>
          <target state="translated">由于 &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; 没有名为 &lt;code&gt;Format&lt;/code&gt; 的非静态成员，并且没有适用的扩展方法，因此上述内容将无法编译。 在上述情况下，在语法上唯一可能的&lt;em&gt;类型&lt;/em&gt;是其他上下文中，仍然可以使用 &lt;code&gt;String&lt;/code&gt; 。 例如 &lt;code&gt;String local = &quot;Hi mum!&quot;;&lt;/code&gt; 可能没问题（取决于名称空间和 &lt;code&gt;using&lt;/code&gt; 指令）。</target>
        </trans-unit>
        <trans-unit id="8d7a9de8ca807f30e0d84dd6099bf753c98ce135" translate="yes" xml:space="preserve">
          <source>The actual meaning of &lt;code&gt;String&lt;/code&gt; will always depend on name resolution.
  That means it depends on all the source files in the project and all
  the types defined in all the referenced assemblies. In short it
  requires quite a bit of context to &lt;em&gt;know&lt;/em&gt; what it means.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 的实际含义将始终取决于名称解析。 这意味着它取决于项目中的所有源文件以及所有引用的程序集中定义的所有类型。 简而言之，要&lt;em&gt;了解&lt;/em&gt;它的含义需要相当多的上下文。</target>
        </trans-unit>
        <trans-unit id="93322148b52efc519b4bbcaebbed28fabcc67ec3" translate="yes" xml:space="preserve">
          <source>The best answer I have ever heard about using the provided type aliases in C# comes from Jeffrey Richter in his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C#&lt;/a&gt;. Here are his 3 reasons:</source>
          <target state="translated">我听说过的关于在C＃中使用提供的类型别名的最佳答案来自Jeffrey Richter在他的书&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0735621632&quot;&gt;CLR Via C＃中&lt;/a&gt; 。 这是他的3个原因：</target>
        </trans-unit>
        <trans-unit id="04f4e2e05e59044015a06ab9e5709ace1067caeb" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;String&lt;/code&gt; though has no concrete meaning in C#. It is an identifier that goes through all the name lookup rules as &lt;code&gt;Widget&lt;/code&gt;, &lt;code&gt;Student&lt;/code&gt;, etc &amp;hellip; It could bind to string or it could bind to a type in another assembly entirely whose purposes may be entirely different than &lt;code&gt;string&lt;/code&gt;. Worse it could be defined in a way such that code like &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt;; continued to compile.</source>
          <target state="translated">标识符 &lt;code&gt;String&lt;/code&gt; 在C＃中没有具体含义。 它是一个标识符，它通过 &lt;code&gt;Widget&lt;/code&gt; ， &lt;code&gt;Student&lt;/code&gt; 等所有名称查找规则进行处理&amp;hellip;&amp;hellip;它可以绑定到字符串，也可以绑定到另一个程序集中的某个类型，其目的可能与 &lt;code&gt;string&lt;/code&gt; 完全不同。 更糟糕的是，它的定义方式是像 &lt;code&gt;String s = &quot;hello&quot;&lt;/code&gt; 这样的代码； 继续编译。</target>
        </trans-unit>
        <trans-unit id="3f48daaabbe068f8c313923060dc1ce87907e97a" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt;  is an alias for
 &lt;code&gt;System.String&lt;/code&gt; aside from the keyword issue, the two are exactly
 equivalent.</source>
          <target state="translated">关键字 &lt;code&gt;string&lt;/code&gt; 是 &lt;code&gt;System.String&lt;/code&gt; 的别名，除了关键字issue之外，两者是完全等效的。</target>
        </trans-unit>
        <trans-unit id="d5c514298559badf24fce9b8b392cc6d91008feb" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;string&lt;/code&gt; has concrete meaning in C#. It is the type &lt;code&gt;System.String&lt;/code&gt; which exists in the core runtime assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings in .NET. Its presence is so critical to C# that if that type doesn&amp;rsquo;t exist the compiler will exit before attempting to even parse a line of code. Hence &lt;code&gt;string&lt;/code&gt; has a precise, unambiguous meaning in C# code.</source>
          <target state="translated">关键字 &lt;code&gt;string&lt;/code&gt; 在C＃中具有具体含义。 它是核心运行时程序集中存在的 &lt;code&gt;System.String&lt;/code&gt; 类型。 运行时从本质上理解这种类型，并提供了开发人员期望的.NET字符串功能。 它的存在对C＃至关重要，如果不存在该类型，编译器将在尝试解析一行代码之前退出。 因此， &lt;code&gt;string&lt;/code&gt; 在C＃代码中具有精确，明确的含义。</target>
        </trans-unit>
        <trans-unit id="baaf13d4a47a17e15308fe16fb596475d6a15088" translate="yes" xml:space="preserve">
          <source>The only practical difference is the syntax highlighting as you mention, and that you have to write &lt;code&gt;using System&lt;/code&gt; if you use &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">唯一实际的区别是您提到的语法突出显示，如果使用 &lt;code&gt;String&lt;/code&gt; ,则必须使用 &lt;code&gt;using System&lt;/code&gt; 编写。</target>
        </trans-unit>
        <trans-unit id="8668abfb621e1b2a22882756e57d856bcfbf3e47" translate="yes" xml:space="preserve">
          <source>The only real downer is that auto-complete uses the C# type, so I end up re-typing automatically generated types to specify the CLR type instead.</source>
          <target state="translated">唯一真正的缺点是,自动完成使用C#类型,所以我最终不得不重新输入自动生成的类型来指定CLR类型。</target>
        </trans-unit>
        <trans-unit id="9c532ca7d467cf6352c36952f31402d9053b7bfb" translate="yes" xml:space="preserve">
          <source>Theoretically this could help to port code into some future 64-bit standard in which &quot;int&quot; might mean &lt;code&gt;Int64&lt;/code&gt;, but that's not the point, and I would expect any upgrade wizard to change any &lt;code&gt;int&lt;/code&gt; references to &lt;code&gt;Int32&lt;/code&gt; anyway just to be safe.</source>
          <target state="translated">从理论上讲，这可以帮助将代码移植到将来的64位标准中，其中&amp;ldquo; int&amp;rdquo;可能表示 &lt;code&gt;Int64&lt;/code&gt; ，但这不是重点，我希望任何升级向导都可以更改对 &lt;code&gt;Int32&lt;/code&gt; 的任何 &lt;code&gt;int&lt;/code&gt; 引用，以确保安全。</target>
        </trans-unit>
        <trans-unit id="1b43e8aad6972ff5253750d89b626a58fe50142a" translate="yes" xml:space="preserve">
          <source>Theoretically, you could implement a C#-compiler that generated Java bytecode. A sensible implementation of this compiler would probably map &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/strong&gt; in order to interoperate with the Java runtime library.</source>
          <target state="translated">从理论上讲，您可以实现一个生成Java字节码的C＃编译器。 为了与Java运行时库进行互操作，此编译器的明智实现可能会将&lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt;映射到&lt;strong&gt; &lt;code&gt;java.lang.String&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9cef7d16318b618f7d7e05ce428e421145a3eb1" translate="yes" xml:space="preserve">
          <source>There is no difference.</source>
          <target state="translated">没有什么区别。</target>
        </trans-unit>
        <trans-unit id="e724cb1ff2ea7523a1d7006294c3e2e3b6908113" translate="yes" xml:space="preserve">
          <source>There is one circumstance in which you &lt;em&gt;have&lt;/em&gt; to use the aliases: when explicitly specifying an enum's underlying type. For instance:</source>
          <target state="translated">在一种情况下，您&lt;em&gt;必须&lt;/em&gt;使用别名：在显式指定枚举的基础类型时。 例如：</target>
        </trans-unit>
        <trans-unit id="db457529845002230c6c5b574e656447dd4b91e6" translate="yes" xml:space="preserve">
          <source>There's a debate over whether you should use the System types (&lt;code&gt;System.Int32&lt;/code&gt;, &lt;code&gt;System.String&lt;/code&gt;, etc.) types or the &lt;code&gt;C# aliases&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, etc). I personally believe you should use the &lt;code&gt;C# aliases&lt;/code&gt;, but that's just my personal preference.</source>
          <target state="translated">关于是否应该使用系统类型（ &lt;code&gt;System.Int32&lt;/code&gt; ， &lt;code&gt;System.String&lt;/code&gt; 等）类型或 &lt;code&gt;C# aliases&lt;/code&gt; （ &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; 等），存在争议。 我个人认为您应该使用 &lt;code&gt;C# aliases&lt;/code&gt; ，但这只是我个人的偏爱。</target>
        </trans-unit>
        <trans-unit id="591cd0b1a64565e8d55765f16e4e309da97495fb" translate="yes" xml:space="preserve">
          <source>There's a quote on this issue from &lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;Daniel Solis' book&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.goodreads.com/book/show/14975275-illustrated-c-2012&quot;&gt;丹尼尔&amp;middot;索利斯（Daniel Solis）的书&lt;/a&gt;对此事做了引用。</target>
        </trans-unit>
        <trans-unit id="cd310fee67eed80e9424306ba0e405b3b78a9e96" translate="yes" xml:space="preserve">
          <source>This is the style that Microsoft tends to use in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;their examples&lt;/a&gt;.</source>
          <target state="translated">这是Microsoft倾向于在&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.string.format#examples&quot;&gt;示例中&lt;/a&gt;使用的样式。</target>
        </trans-unit>
        <trans-unit id="f6a887af1a34c7a21a8c77639ce417b3bb91f2d6" translate="yes" xml:space="preserve">
          <source>True that in the vast majority of cases &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; will bind to
  the same type. But using &lt;code&gt;String&lt;/code&gt; still means developers are leaving
  their program up to interpretation in places where there is only one
  correct answer. When &lt;code&gt;String&lt;/code&gt; does bind to the wrong type it can leave
  developers debugging for hours, filing bugs on the compiler team and
  generally wasting time that could&amp;rsquo;ve been saved by using &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">的确，在大多数情况下， &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 将绑定到同一类型。 但是使用 &lt;code&gt;String&lt;/code&gt; 仍然意味着开发人员只能在只有一个正确答案的地方进行程序解释。 当 &lt;code&gt;String&lt;/code&gt; 确实绑定到错误的类型时，它可能会使开发人员进行数小时的调试，将错误提交给编译器团队，并且通常会浪费时间，这可以通过使用 &lt;code&gt;string&lt;/code&gt; 节省。</target>
        </trans-unit>
        <trans-unit id="080151d9d06a4a0841ea36ef9ee84dcdb90f489e" translate="yes" xml:space="preserve">
          <source>Using System types makes it easier to port between C# and VB.Net, if you are into that sort of thing.</source>
          <target state="translated">使用System类型可以让C#和VB.Net之间的移植变得更加容易,如果你喜欢这种东西的话。</target>
        </trans-unit>
        <trans-unit id="bbaa6241d89ea80c39692aa3b5ba27d31a981924" translate="yes" xml:space="preserve">
          <source>What are the &lt;strong&gt;&lt;em&gt;guidelines&lt;/em&gt;&lt;/strong&gt; for the use of each? And what are the &lt;strong&gt;&lt;em&gt;differences&lt;/em&gt;&lt;/strong&gt;?</source>
          <target state="translated">每种使用的&lt;strong&gt;&lt;em&gt;准则&lt;/em&gt;&lt;/strong&gt;是什么？ 有什么&lt;strong&gt;&lt;em&gt;区别&lt;/em&gt;&lt;/strong&gt; ？</target>
        </trans-unit>
        <trans-unit id="bd9579b2d38cc31bb5131600b18e1a9c58740e90" translate="yes" xml:space="preserve">
          <source>What is the difference between String and string in C#</source>
          <target state="translated">C#中String和string的区别是什么?</target>
        </trans-unit>
        <trans-unit id="e71d05ee8c65811fde766fc86a9a2312a31589aa" translate="yes" xml:space="preserve">
          <source>When we talk about &lt;code&gt;.NET&lt;/code&gt; there are two different things one there is &lt;code&gt;.NET&lt;/code&gt; framework and the other there are languages ( &lt;code&gt;C#&lt;/code&gt; , &lt;code&gt;VB.NET&lt;/code&gt; etc) which use that framework.</source>
          <target state="translated">当我们谈论 &lt;code&gt;.NET&lt;/code&gt; 时 ，有两种不同的东西，一种是 &lt;code&gt;.NET&lt;/code&gt; 框架，另一种是使用该框架的语言（ &lt;code&gt;C#&lt;/code&gt; ， &lt;code&gt;VB.NET&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="1f3e96542caf20f14fe703e23e36cf1f92b45e0e" translate="yes" xml:space="preserve">
          <source>When you use C# together with the CLR &lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt; will be mapped to &lt;strong&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">当您将C＃与CLR &lt;strong&gt; &lt;code&gt;string&lt;/code&gt; &lt;/strong&gt;一起使用时，将被映射到&lt;strong&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6da5e0c25b5beda54e8637b0d410f9bcc6da7930" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;string&lt;/code&gt; is a reserved C# keyword that always has a fixed meaning, &lt;code&gt;String&lt;/code&gt; is just an ordinary &lt;em&gt;identifier&lt;/em&gt; which could refer to anything. Depending on members of the current type, the current namespace and the applied &lt;code&gt;using&lt;/code&gt; directives and their placement, &lt;code&gt;String&lt;/code&gt; could be a value or a type distinct from &lt;code&gt;global::System.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 是保留的C＃关键字，始终具有固定的含义，而 &lt;code&gt;String&lt;/code&gt; 只是可以引用任何内容的普通&lt;em&gt;标识符&lt;/em&gt; 。 根据当前类型的成员，当前名称空间以及所应用的 &lt;code&gt;using&lt;/code&gt; 指令及其位置， &lt;code&gt;String&lt;/code&gt; 可以是值或类型，可与 &lt;code&gt;global::System.String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d746517e1decf0d12e57b19ed8b079d7d2ff727" translate="yes" xml:space="preserve">
          <source>Worse: Saying &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; will likely (depending on &lt;code&gt;using&lt;/code&gt;s) go to the Linq extension method &lt;code&gt;Enumerable.Concat&lt;/code&gt;. It will not go to the static method &lt;code&gt;string.Concat&lt;/code&gt;.</source>
          <target state="translated">更糟糕：说 &lt;code&gt;String.Concat(someSequence)&lt;/code&gt; 可能（取决于 &lt;code&gt;using&lt;/code&gt; s）转到Linq扩展方法 &lt;code&gt;Enumerable.Concat&lt;/code&gt; 。 它不会转到静态方法 &lt;code&gt;string.Concat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="825f170ba301d67aee52cb32cfb74d6313352781" translate="yes" xml:space="preserve">
          <source>Yes, that's no difference between them, just like the &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">是的，它们之间没有什么区别，就像 &lt;code&gt;bool&lt;/code&gt; 和 &lt;code&gt;Boolean&lt;/code&gt; 一样 。</target>
        </trans-unit>
        <trans-unit id="9bfe5ac3a85fb8412165790973b10eb661d8a34a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that &lt;code&gt;String&lt;/code&gt; is defined for a number of completely valid purposes: reflection helpers, serialization libraries, lexers, protocols, etc &amp;hellip; For any of these libraries &lt;code&gt;String&lt;/code&gt; vs. &lt;code&gt;string&lt;/code&gt; has real consequences depending on where the code is used.</source>
          <target state="translated">您会看到 &lt;code&gt;String&lt;/code&gt; 是为许多完全有效的目的定义的：反射帮助器，序列化库，词法分析器，协议等&amp;hellip;对于这些库中的任何一个， &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 产生实际影响，具体取决于使用代码的位置。</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="7f23f0b182ad02e9f6f6309b506e9b8da87ba491" translate="yes" xml:space="preserve">
          <source>object: &lt;code&gt;System.Object&lt;/code&gt;, string: &lt;code&gt;System.String&lt;/code&gt;, bool: &lt;code&gt;System.Boolean&lt;/code&gt;, byte: &lt;code&gt;System.Byte&lt;/code&gt;, sbyte: &lt;code&gt;System.SByte&lt;/code&gt;, short: &lt;code&gt;System.Int16&lt;/code&gt; and so on</source>
          <target state="translated">对象： &lt;code&gt;System.Object&lt;/code&gt; ，字符串： &lt;code&gt;System.String&lt;/code&gt; ，bool： &lt;code&gt;System.Boolean&lt;/code&gt; ，字节： &lt;code&gt;System.Byte&lt;/code&gt; ，sbyte： &lt;code&gt;System.SByte&lt;/code&gt; ，short： &lt;code&gt;System.Int16&lt;/code&gt; 等</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
