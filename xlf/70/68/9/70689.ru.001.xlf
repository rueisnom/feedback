<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/70689">
    <body>
      <group id="70689">
        <trans-unit id="d0e7abff310a4025796fb8127bff3a00cdf49cf9" translate="yes" xml:space="preserve">
          <source>&quot;This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, &lt;strong&gt;a single-element enum type is the best way to implement a singleton&lt;/strong&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Этот подход функционально эквивалентен подходу открытого поля, за исключением того, что он более лаконичен, предоставляет механизм сериализации бесплатно и обеспечивает железную гарантию от множественных экземпляров, даже перед лицом сложных атак сериализации или рефлексии. Хотя этот подход имеет Все еще широко распространенный, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;одноэлементный тип перечисления является лучшим способом реализации синглтона&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d92bd02c3c63ee0ed64ba4245fb3a982d203b6" translate="yes" xml:space="preserve">
          <source>-Joshua Bloch in &quot;Effective Java&quot;</source>
          <target state="translated">-Джошуа Блох в фильме &quot;Эффективная Ява&quot;.</target>
        </trans-unit>
        <trans-unit id="08d9fe87472c62e1e954d12a6dac491ca298dd21" translate="yes" xml:space="preserve">
          <source>1) Enum</source>
          <target state="translated">1)Перечень</target>
        </trans-unit>
        <trans-unit id="d2d52ad19eaadabdfadda897ef4c0d186a866fd7" translate="yes" xml:space="preserve">
          <source>1. Lazy loading</source>
          <target state="translated">1.Ленивая погрузка</target>
        </trans-unit>
        <trans-unit id="079dc82c2bdf9ccd588072d932c3947e40fede85" translate="yes" xml:space="preserve">
          <source>1.12    Serialization of Enum Constants</source>
          <target state="translated">1.12 Сериализация констант перечисления</target>
        </trans-unit>
        <trans-unit id="2cd0140a25a4d1a85fb94d0761891417c4dc4984" translate="yes" xml:space="preserve">
          <source>2) Double checked Locking /Lazy loading</source>
          <target state="translated">2)Двойная проверка Блокировка Ленивая погрузка</target>
        </trans-unit>
        <trans-unit id="08f82b326d21f0209551fd37f400406131162a05" translate="yes" xml:space="preserve">
          <source>2. Early loading</source>
          <target state="translated">2.Ранняя погрузка</target>
        </trans-unit>
        <trans-unit id="4c7750893106bc2853b3923c39390400fecd2f63" translate="yes" xml:space="preserve">
          <source>3) Static factory method</source>
          <target state="translated">3)статический заводской метод</target>
        </trans-unit>
        <trans-unit id="5ff5ef5674939ac9c059ad5c77a4b4e9f1e23eca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; I have just summarized all of the awesome answers and wrote it in my words.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отказ от ответственности:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; я только что суммировал все удивительные ответы и написал это в моих словах.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30628e72df671cf84d40652d24c88b86db31f004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Double checked locking&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Двойная проверка блокировки&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3195614dcff1f3528172d85cbffa6b9a4089c087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;: 
@Bno 's answer details the approach recommended by Bill Pugh (FindBugs) and is arguable better.  Go read and vote up his answer too.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;РЕДАКТИРОВАТЬ 2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : Ответ @Bno подробно описывает подход, рекомендованный Биллом Пью (FindBugs), и, возможно, лучше. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Читайте и голосуйте за его ответ тоже.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c62c92240dd0a4c0e46e65c24fd4c21e1a44e94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: Pay attention to the &lt;code&gt;volatile&lt;/code&gt; modifier here.  :)  It is important because without it, other threads are not guaranteed by the JMM (Java Memory Model) to see changes to its value.  The synchronization &lt;em&gt;does not&lt;/em&gt; take care of that--it only serializes access to that block of code.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;РЕДАКТИРОВАТЬ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : Обратите внимание на &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;модификатор &lt;/font&gt;&lt;/font&gt; &lt;code&gt;volatile&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; здесь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:) Это важно, потому что без него JMM (модель памяти Java) не гарантирует другие потоки, чтобы увидеть изменения в его значении. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Синхронизация &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; заботится об этом - она ​​только сериализует доступ к этому блоку кода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bb36a38fdf6c84e6a71484fcd968f8d949b0141b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Early loading Singleton (works even before Java 1.5)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ранняя загрузка Singleton (работает еще до Java 1.5)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72cbea399de93731f0e7101d06f9d2d1a574c4ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; An &lt;a href=&quot;http://www.ddj.com/java/208403883?pgno=3&quot;&gt;online portion of &quot;Effective Java&quot;&lt;/a&gt; says:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Edit: &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.ddj.com/java/208403883?pgno=3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;онлайн часть &amp;laquo;Эффективное Java&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , говорит:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="307bb6f80695a03d34d6fd0a9d21d290e3ad9313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enum singleton&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Enum singleton&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56dddc61df291744c7df167e2ba5c4fbc619af1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good Read&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хорошо для чтения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b768ec3d338078db9ffc311717a61b05c7f46cf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Версия 1:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed1d2772abb6c6974f7deddced2292b250baa718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Версия 2:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bda23d30aeb1eeb2070de09f96721b3c09f96127" translate="yes" xml:space="preserve">
          <source>And we have came so far, here is the best way to achieve everything we did is best possible way</source>
          <target state="translated">И мы зашли так далеко,что вот лучший способ достичь всего,что мы сделали,это лучший возможный способ.</target>
        </trans-unit>
        <trans-unit id="38bb16500de69328e3b17998a373f42c6fa738bb" translate="yes" xml:space="preserve">
          <source>Another argument often used against Singletons are their testability problems. Singletons are not easily mockable for testing purposes. If this turns out to be a problem, I like to make the following slight modification:</source>
          <target state="translated">Еще одним аргументом,часто используемым против синглетов,являются их проблемы с контролепригодностью.Однополюсники нелегко высмеивать для целей тестирования.Если это окажется проблемой,я хотел бы внести следующие небольшие изменения:</target>
        </trans-unit>
        <trans-unit id="5a305003db33fc59491a9b2510c4cad977d2c3c3" translate="yes" xml:space="preserve">
          <source>Another problem with conventional Singletons are that once you implement &lt;code&gt;Serializable&lt;/code&gt; interface, they no longer remain Singleton because &lt;code&gt;readObject()&lt;/code&gt; method always return a new instance  like constructor in Java. This can be avoided by using &lt;code&gt;readResolve()&lt;/code&gt; and discarding newly created instance by replacing with singleton like below</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другая проблема с обычными &lt;/font&gt; &lt;code&gt;readObject()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; том, что после реализации &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интерфейса &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; они больше не остаются синглтонами, потому что &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод readObject ()&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; всегда возвращает новый экземпляр, подобный конструктору в Java. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этого можно избежать, используя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и отбрасывая вновь созданный экземпляр, заменив его на singleton, как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;показано&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ниже&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81316ae241d3865f37b7d5da2e372416ecd88025" translate="yes" xml:space="preserve">
          <source>As per Joshua Bloch - Enum would be the best.</source>
          <target state="translated">Согласно Иешуа Блох-Enum был бы лучшим.</target>
        </trans-unit>
        <trans-unit id="3c3778d4d24f299f28881cec97f7840ac08f30c0" translate="yes" xml:space="preserve">
          <source>As the double checking pattern is not guaranteed to work (due to some issue with compilers, I don't know anything more about that.), you could also try to synchronize the whole getInstance-method or create a registry for all your Singletons.</source>
          <target state="translated">Так как шаблон двойной проверки не гарантированно работает (из-за некоторых проблем с компиляторами,я больше ничего об этом не знаю),вы также можете попробовать синхронизировать весь getInstance-метод или создать реестр для всех ваших синглетов.</target>
        </trans-unit>
        <trans-unit id="b23dd736696f30fd3946f179df3014700e480a54" translate="yes" xml:space="preserve">
          <source>As we have added the Synchronized keyword before getInstance, we have avoided the race condition in the case when two threads call the getInstance at the same time.</source>
          <target state="translated">Так как мы добавили ключевое слово Synchronized перед getInstance,мы избежали состояния гонки в случае,когда два потока вызывают getInstance одновременно.</target>
        </trans-unit>
        <trans-unit id="9872f9d1cf5a148d81f6618ffcfb77b475ddd945" translate="yes" xml:space="preserve">
          <source>But this implementation has a problem. Multi-threaded applications will have a race condition on the creation of the single instance. If multiple threads of execution hit the getInstance() method at (or around) the same time, they will each see the INSTANCE member as null. This will result in each thread creating a new MySingleton instance and subsequently setting the INSTANCE member.</source>
          <target state="translated">Но у этой реализации есть проблема.Многопоточные приложения будут иметь состояние гонки при создании одного экземпляра.Если несколько потоков выполнения попадут в метод getInstance()одновременно (или около него),то каждый из них будет считать член INSTANCE нулевым.Это приведет к тому,что каждый поток создаст новый экземпляр MySingleton и впоследствии установит член INSTANCE.</target>
        </trans-unit>
        <trans-unit id="4bffec330193be3f47d3dd37823b7f72184fbd13" translate="yes" xml:space="preserve">
          <source>But this simple change comes at a cost. Because we are bypassing the CPU cache, we will take a performance hit each time we operate on the volatile INSTANCE member &amp;mdash; which we do 4 times. We double-check existence (1 and 2), set the value (3), and then return the value (4). One could argue that this path is the fringe case as we only create the instance during the first call of the method. Perhaps a performance hit on creation is tolerable. But even our main use-case, reads, will operate on the volatile member twice. Once to check existence, and again to return its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но это простое изменение имеет свою цену. Поскольку мы обходим кэш-память ЦП, мы будем снижать производительность каждый раз, когда работаем с изменчивым членом INSTANCE, что мы делаем 4 раза. Мы дважды проверяем существование (1 и 2), устанавливаем значение (3), а затем возвращаем значение (4). Можно утверждать, что этот путь является крайним случаем, поскольку мы создаем экземпляр только во время первого вызова метода. Возможно, удар по производительности на создание терпимо. Но даже наш основной вариант использования, читает, будет работать на volatile член дважды. Один раз проверить существование, и снова вернуть его значение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17e7851eae8628811d4f175deed2ffc97753ae75" translate="yes" xml:space="preserve">
          <source>Depending on the usage, there are several &quot;correct&quot; answers.</source>
          <target state="translated">В зависимости от использования,есть несколько &quot;правильных&quot; ответов.</target>
        </trans-unit>
        <trans-unit id="6376ee8d7ecb240ca2e7ac33a3adc4bc45c9c27e" translate="yes" xml:space="preserve">
          <source>Double-checked locking and the Singleton pattern</source>
          <target state="translated">Двойная блокировка и однокнопочный шаблон</target>
        </trans-unit>
        <trans-unit id="db9d8df06d494bd593e263605d3d29426f3aacc6" translate="yes" xml:space="preserve">
          <source>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, &lt;code&gt;ObjectOutputStream&lt;/code&gt; writes the value returned by the enum constant's name method. To deserialize an enum constant, &lt;code&gt;ObjectInputStream&lt;/code&gt; reads the constant name from the stream; the deserialized constant is then obtained by calling the &lt;code&gt;java.lang.Enum.valueOf&lt;/code&gt; method, passing the constant's enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Константы перечисления сериализуются иначе, чем обычные сериализуемые или экстернализуемые объекты. Сериализованная форма константы перечисления состоит исключительно из ее имени; Значения поля константы отсутствуют в форме. Чтобы сериализовать константу перечисления, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectOutputStream&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; записывает значение, возвращаемое методом имени константы перечисления. Чтобы десериализовать константу перечисления, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectInputStream&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; считывает имя константы из потока; десериализованная константа затем получается путем вызова &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метода &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Enum.valueOf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , передавая тип перечисления константы вместе с полученным именем константы в качестве аргументов. Как и другие сериализуемые или экстернализуемые объекты, константы перечисления могут функционировать как цели обратных ссылок, появляющихся впоследствии в потоке сериализации.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ceb04d0bf6d359988aa55fd0ab46e6fbd0ac88d" translate="yes" xml:space="preserve">
          <source>Enums, Singletons and Deserialization</source>
          <target state="translated">Перечисления,синглеты и десериализация</target>
        </trans-unit>
        <trans-unit id="ad7444993cf50fd2b00245cc896506e7174251b7" translate="yes" xml:space="preserve">
          <source>Even inner static class can be used.</source>
          <target state="translated">Можно использовать даже класс внутренней статики.</target>
        </trans-unit>
        <trans-unit id="e8407c8536a920696620341c8d56ee215bf8ab27" translate="yes" xml:space="preserve">
          <source>Everything is good except its early loaded singleton. Lets try lazy loaded singleton</source>
          <target state="translated">Все хорошо,за исключением ранней загрузки одной кнопки.Давайте попробуем ленивый заряженный сингл.</target>
        </trans-unit>
        <trans-unit id="13c1641e1e78a21a27ed901675c0fb58e566e905" translate="yes" xml:space="preserve">
          <source>Examples of GoF Design Patterns in Java's core libraries</source>
          <target state="translated">Примеры шаблонов дизайна GoF в основных библиотеках Java</target>
        </trans-unit>
        <trans-unit id="694f20fe271ac257cf93f8c43bbc55ae37aea518" translate="yes" xml:space="preserve">
          <source>Finally we have added enough protection  against threads and serialization but our code is looking bulky and ugly. Lets give our hero a make over</source>
          <target state="translated">Наконец-то мы добавили достаточно защиты от потоков и сериализации,но наш код выглядит громоздким и уродливым.Давайте дадим нашему герою шанс</target>
        </trans-unit>
        <trans-unit id="669d1ad80c1897dcc9c350b124bcb770181e306a" translate="yes" xml:space="preserve">
          <source>Following are 3 different approaches</source>
          <target state="translated">Ниже приведены 3 различных подхода</target>
        </trans-unit>
        <trans-unit id="87c36aa5ed8b30192f0a868029407fecc727cc10" translate="yes" xml:space="preserve">
          <source>For JSE 5.0 and above take the Enum approach, otherwise use static singleton holder approach ( (a lazy loading approach described by Bill Pugh). Latter solution is also thread-safe without requiring special language constructs (i.e. volatile or synchronized).</source>
          <target state="translated">Для JSE 5.0 и выше используйте подход Enum,в противном случае используйте статический однокнопочный подход (подход с ленивой загрузкой,описанный Биллом Пью).Более позднее решение также является потокобезопасным,не требующим специальных языковых конструкций (т.е.нестабильным или синхронизированным).</target>
        </trans-unit>
        <trans-unit id="9b9714e50bd4daa7b29e38926f2d72e66aa42aa0" translate="yes" xml:space="preserve">
          <source>For details :  &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для получения дополнительной информации: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea40150d9fb3a40c99b1e699a4f5bc78fddf39bf" translate="yes" xml:space="preserve">
          <source>Forget &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_initialization&quot;&gt;lazy initialization&lt;/a&gt;, it's too problematic. This is the simplest solution:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Забудьте о &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ленивой инициализации&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , это слишком проблематично. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это самое простое решение:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59059ebb0b7402bf9c92da6476af7654cefbc8a2" translate="yes" xml:space="preserve">
          <source>From the best answer's &quot;Singleton&quot; section,</source>
          <target state="translated">Из лучшей секции ответа &quot;Одиночка&quot;,</target>
        </trans-unit>
        <trans-unit id="625479fdef81f36c1ab97a359b96e9e84c247479" translate="yes" xml:space="preserve">
          <source>Have a look at this post.</source>
          <target state="translated">Посмотрите на этот пост.</target>
        </trans-unit>
        <trans-unit id="2c84fb11ab9057630b8bfa9b38aec5ad9e99c0a2" translate="yes" xml:space="preserve">
          <source>Here we have the MySingleton class which has a private static member called INSTANCE, and a public static method called getInstance(). The first time getInstance() is called, the INSTANCE member is null. The flow will then fall into the creation condition and create a new instance of the MySingleton class. Subsequent calls to getInstance() will find that the INSTANCE variable is already set, and therefore not create another MySingleton instance. This ensures there is only one instance of MySingleton which is shared among all callers of getInstance().</source>
          <target state="translated">Здесь у нас есть класс MySingleton,который имеет частный статический член INSTANCE,и публичный статический метод getInstance().При первом вызове getInstance()член INSTANCE равен нулю.Затем поток попадает в условие создания и создает новый экземпляр класса MySingleton.Последующие вызовы getInstance()обнаружат,что переменная INSTANCE уже установлена,и,следовательно,не создадут еще один экземпляр класса MySingleton.Это гарантирует,что существует только один экземпляр MySingleton,который совместно используется всеми вызывающими функциями getInstance().</target>
        </trans-unit>
        <trans-unit id="2e5384598935f29c9b1e729f63a7964aa522e9b7" translate="yes" xml:space="preserve">
          <source>Here we issue another check from INSIDE the block. If the INSTANCE member has already been set, we&amp;rsquo;ll skip initialization. This is called double-checked locking.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Здесь мы выдаем еще одну проверку изнутри блока. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если элемент INSTANCE уже установлен, мы пропустим инициализацию. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это называется двойной проверкой блокировки.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4d2ad2ed1e46d507a87415c705db9a38a9c8631" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve moved synchronization from the method signature, to a synchronized block that wraps the creation of the MySingleton instance. But does this solve our problem? Well, we are no longer blocking on reads, but we&amp;rsquo;ve also taken a step backward. Multiple threads will hit the getInstance() method at or around the same time and they will all see the INSTANCE member as null. They will then hit the synchronized block where one will obtain the lock and create the instance. When that thread exits the block, the other threads will contend for the lock, and one by one each thread will fall through the block and create a new instance of our class. So we are right back where we started.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Здесь мы переместили синхронизацию из сигнатуры метода в синхронизированный блок, который оборачивает создание экземпляра MySingleton. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но решает ли это нашу проблему? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что ж, мы больше не блокируем чтение, но мы также сделали шаг назад. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Несколько потоков будут попадать в метод getInstance () в одно и то же время или около того, и все они будут видеть элемент INSTANCE как нулевой. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем они попадут в синхронизированный блок, где можно получить блокировку и создать экземпляр. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда этот поток выходит из блока, другие потоки будут бороться за блокировку, и один за другим каждый поток будет проходить через блок и создавать новый экземпляр нашего класса. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, мы вернулись туда, откуда начали.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="df8f4dd0518f2a157d601eef2563a409c8be073f" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve used the synchronized keyword in the method signature to synchronize the getInstance() method. This will certainly fix our race condition. Threads will now block and enter the method one at a time. But it also creates a performance problem. Not only does this implementation synchronize the creation of the single instance, it synchronizes all calls to getInstance(), including reads. Reads do not need to be synchronized as they simply return the value of INSTANCE. Since reads will make up the bulk of our calls (remember, instantiation only happens on the first call), we will incur an unnecessary performance hit by synchronizing the entire method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Здесь мы использовали ключевое слово synchronized в сигнатуре метода для синхронизации метода getInstance (). Это, безусловно, исправит наше состояние гонки. Теперь потоки будут блокироваться и вводить метод по одному. Но это также создает проблему производительности. Эта реализация не только синхронизирует создание отдельного экземпляра, но и все вызовы getInstance (), включая чтение. Чтения не должны быть синхронизированы, поскольку они просто возвращают значение INSTANCE. Поскольку чтение будет составлять основную часть наших вызовов (помните, что создание экземпляров происходит только при первом вызове), мы подвергнемся ненужному снижению производительности при синхронизации всего метода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78bce48dfe4ac1df6adfc647b4139137aa6d82ec" translate="yes" xml:space="preserve">
          <source>I still think after java 1.5, enum is the best available singleton implementation available as it also ensures that even in the multi threaded environments - only one instance is created.</source>
          <target state="translated">Я все еще думаю,что после java 1.5,enum является лучшей доступной однокнопочной реализацией,так как она также гарантирует,что даже в многопоточных средах-создается только один экземпляр.</target>
        </trans-unit>
        <trans-unit id="889368f1848c86a7463020ef822a9db09e8274ba" translate="yes" xml:space="preserve">
          <source>I use the Spring Framework to manage my singletons.  It doesn't enforce the &quot;singleton-ness&quot; of the class (which you can't really do anyway if there are multiple class loaders involved) but provides a really easy way to build and configure different factories for creating different types of objects.</source>
          <target state="translated">Я использую &quot;Весенний каркас&quot; для управления моими синглонами.Она не навязывает &quot;singleton-ness&quot; класса (что вы все равно не можете сделать,если вовлечено несколько загрузчиков класса),а предоставляет действительно простой способ построения и настройки различных фабрик для создания различных типов объектов.</target>
        </trans-unit>
        <trans-unit id="ed23e9e9e4913fecc55d825c0498fb0496c7f8a6" translate="yes" xml:space="preserve">
          <source>I would say Enum singleton</source>
          <target state="translated">Я бы сказал,Enum singleton</target>
        </trans-unit>
        <trans-unit id="afa6bc6c9963a7910bf3a4b45b55b520b11cb54d" translate="yes" xml:space="preserve">
          <source>I wrote an article about this recently. &lt;a href=&quot;https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5&quot;&gt;Deconstructing The Singleton&lt;/a&gt;. You can find more info on these examples and an example of the &quot;holder&quot; pattern there. There is also a real-world example showcasing the double-checked volatile approach. Hope this helps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я недавно написал статью об этом. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Деконструкция Синглтона&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете найти больше информации об этих примерах и пример паттерна &quot;holder&quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует также реальный пример, демонстрирующий изменчивый подход с двойной проверкой. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Надеюсь это поможет.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab17279cd20fd4b1687c230a64664d6a72159390" translate="yes" xml:space="preserve">
          <source>I'm mystified by some of the answers that suggest DI as an alternative to using singletons; these are unrelated concepts. You can use DI to inject either singleton or non-singleton (e.g. per-thread) instances. At least this is true if you use Spring 2.x, I can't speak for other DI frameworks.</source>
          <target state="translated">Я озадачен некоторыми ответами,которые предлагают DI в качестве альтернативы использованию синглонов;это не связанные между собой понятия.Вы можете использовать ИР для инъекций как однотонных,так и не однотонных (например,на одну резьбу)экземпляров.По крайней мере,это верно,если вы используете Spring 2.x,я не могу говорить о других концепциях ИР.</target>
        </trans-unit>
        <trans-unit id="577011040f77feb24314bebcebb9dd9fde8ba1ea" translate="yes" xml:space="preserve">
          <source>If you do not need lazy loading then simply try</source>
          <target state="translated">Если вам не нужна ленивая погрузка,то просто попробуйте</target>
        </trans-unit>
        <trans-unit id="710c65236f4c85b7918088ab9764fa4fe32f4e52" translate="yes" xml:space="preserve">
          <source>If you really need one then wikipedia has a good example of a proper implementation of a singleton.</source>
          <target state="translated">Если вам действительно нужно,то у Википедии есть хороший пример правильной реализации одиночной кнопки.</target>
        </trans-unit>
        <trans-unit id="6577d11ba941eea89cd233d6d86c997fce516f3c" translate="yes" xml:space="preserve">
          <source>If you want lazy loading and you want your Singleton to be thread-safe, try the double-checking pattern</source>
          <target state="translated">Если вы хотите ленивой загрузки,и вы хотите,чтобы ваш синглтон,чтобы быть нить-безопасным,попробуйте перепроверки шаблон</target>
        </trans-unit>
        <trans-unit id="a3855b5c69e8ee65b0b5745f601e591577ad0129" translate="yes" xml:space="preserve">
          <source>If you want to code a &amp;ldquo;classic&amp;rdquo; singleton that works in a multithreaded environment (starting from Java 1.5) you should use this one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите закодировать &amp;laquo;классический&amp;raquo; синглтон, который работает в многопоточной среде (начиная с Java 1.5), вы должны использовать это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d8270ca97b87f403744a722f1dc68510486cf68" translate="yes" xml:space="preserve">
          <source>In addition, if the singleton needs to be seriliazble, all other fields needs to be transient and readResolve() method needs to be implemented in order to maintain the singleton object invariant. Otherwise, each time the object is deserialized, a new instance of the object will be created. What readResolve() does is replace the new object read by readObject(), which forced that new object to be garbage collected as there is no variable referring to it.</source>
          <target state="translated">Кроме того,если синглтон должен быть сериализован,то все остальные поля должны быть переходными,а метод readResolve()должен быть реализован для поддержания инвариантности объекта синглтона.В противном случае каждый раз при десериализации объекта будет создаваться новый экземпляр объекта.Что делает функция readResolve(),так это заменяет прочитанный новый объект функцией readObject(),которая заставляет этот новый объект собирать мусор,так как нет никакой переменной,ссылающейся на него.</target>
        </trans-unit>
        <trans-unit id="c7d8c92f19b91f623b57babd3358dff0e0040f4a" translate="yes" xml:space="preserve">
          <source>It supports lazy initialization</source>
          <target state="translated">Поддерживает ленивую инициализацию</target>
        </trans-unit>
        <trans-unit id="ebcba64c45c23ff901884aec98da59f574d38bb0" translate="yes" xml:space="preserve">
          <source>It's easy to forget the volatile statement and difficult to understand why it is necessary. Without the volatile this code would not be thread safe anymore due to the double-checked locking antipattern. See more about this in paragraph 16.2.4 of &lt;a href=&quot;http://jcip.net/&quot;&gt;Java Concurrency in Practice&lt;/a&gt;. In short: This pattern (prior to Java5.0 or without the volatile statement) could return a reference to the Bar object that is (still) in an incorrect state.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Легко забыть изменчивое утверждение и трудно понять, почему это необходимо. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Без volatile этот код больше не был бы безопасен для потоков из-за двойной проверки антипаттерна блокировки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подробнее об этом см. В параграфе 16.2.4 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://jcip.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java-параллелизма на практике&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вкратце: этот шаблон (до Java5.0 или без оператора volatile) может возвращать ссылку на объект Bar, который (все еще) находится в неправильном состоянии.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aed94d32746ef6f2b1030893cf2c63e4473de7b9" translate="yes" xml:space="preserve">
          <source>It's generic and reusable</source>
          <target state="translated">Он универсальный и многоразовый</target>
        </trans-unit>
        <trans-unit id="80ce64e9d168cca4d45ad01dd786a3a3d622a3eb" translate="yes" xml:space="preserve">
          <source>It's only synchronized until it has been initialized, then the blocking supplier is replaced with a non-blocking supplier.</source>
          <target state="translated">Он синхронизируется только до тех пор,пока не будет инициализирован,затем поставщик блокировки заменяется на неблокирующего поставщика.</target>
        </trans-unit>
        <trans-unit id="449c13963dfa95bddabe3876c74d3b40442953df" translate="yes" xml:space="preserve">
          <source>Joshua Bloch explained this approach in his &lt;a href=&quot;http://sites.google.com/site/io/effective-java-reloaded&quot;&gt;Effective Java Reloaded&lt;/a&gt; talk at Google I/O 2008: &lt;a href=&quot;http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s&quot;&gt;link to video&lt;/a&gt;. Also see slides 30-32 of his presentation (&lt;a href=&quot;https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&amp;amp;attredirects=0&quot;&gt;effective_java_reloaded.pdf&lt;/a&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Джошуа Блох объяснил этот подход в своем &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;выступлении &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sites.google.com/site/io/effective-java-reloaded&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эффективная Java Reloaded&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на Google I / O 2008: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ссылка на видео&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Также см. Слайды 30-32 его презентации ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&amp;amp;attredirects=0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ffective_java_reloaded.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="793c23aca34d846cb2973e2995675836910ca030" translate="yes" xml:space="preserve">
          <source>Lazy loading adds bit overhead(lots of to be honest) so use it only when you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.Otherwise choosing early loading is a good choice.</source>
          <target state="translated">Ленивая загрузка добавляет немного накладных расходов (если честно,много),так что используйте ее только тогда,когда у вас есть очень большой объект или тяжелый строительный код,а также есть другие доступные статические методы или поля,которые могут быть использованы до того,как понадобится экземпляр,тогда и только тогда вам нужно использовать ленивую инициализацию,иначе выбор ранней загрузки является хорошим выбором.</target>
        </trans-unit>
        <trans-unit id="02fefdeb69ee5d29a7c948927ea167ebab436a0f" translate="yes" xml:space="preserve">
          <source>Lazy loading, thread safe with blocking, low performance because of &lt;code&gt;synchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ленивая загрузка, потокобезопасность с блокировкой, низкая производительность из-за &lt;/font&gt;&lt;/font&gt; &lt;code&gt;synchronized&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d407b886496d8e0094a35acef4bd5685c8ff45f" translate="yes" xml:space="preserve">
          <source>Lazy loading, thread safe with non-blocking, high performance.</source>
          <target state="translated">Ленивая погрузка,резьба безопасна с неблокирующим эффектом,высокая производительность.</target>
        </trans-unit>
        <trans-unit id="f54e23f25888e8257c17de0c8827649ac27396d2" translate="yes" xml:space="preserve">
          <source>Let's go over the code. First, you want the class to be final. In this case, I've used the &lt;code&gt;final&lt;/code&gt; keyword to let the users know it is final. Then you need to make the constructor private to prevent users to create their own Foo. Throwing an exception from the constructor prevents users to use reflection to create a second Foo. Then you create a &lt;code&gt;private static final Foo&lt;/code&gt; field to hold the only instance, and a &lt;code&gt;public static Foo getInstance()&lt;/code&gt; method to return it. The Java specification makes sure that the constructor is only called when the class is first used.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Давайте пройдемся по коду. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Во-первых, вы хотите, чтобы урок был окончательным. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае я использовал &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ключевое слово &lt;/font&gt;&lt;/font&gt; &lt;code&gt;final&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы пользователи знали, что оно final. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем вам нужно сделать конструктор закрытым, чтобы пользователи не могли создавать свои собственные Foo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Создание исключения из конструктора не позволяет пользователям использовать отражение для создания второго Foo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем вы создаете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поле &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Foo&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для хранения единственного экземпляра и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;public static Foo getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; метод &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Foo getInstance ()&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для его возврата. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Спецификация Java гарантирует, что конструктор вызывается только при первом использовании класса.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9c873dc1a8784c864c5dd3081fbf40b67576f0d" translate="yes" xml:space="preserve">
          <source>Make it part of your DI configuration whether your dependencies are singletons, request scoped, session scoped, or whatever.</source>
          <target state="translated">Сделайте это частью вашей конфигурации DI,независимо от того,являются ли ваши зависимости синглонами,обработаны ли запросы,обработаны ли сеансы или что-то в этом роде.</target>
        </trans-unit>
        <trans-unit id="fd66bccb948073440dd0db12f2ca6e04f0d6a6dc" translate="yes" xml:space="preserve">
          <source>Make sure that you really need it. Do a google for &quot;singleton anti-pattern&quot; to see some arguments against it. There's nothing inherently wrong with it I suppose but it's just a mechanism for exposing some global resource/data so make sure that this is the best way. In particular I've found dependency injection more useful particularly if you are also using unit tests because DI allows you to use mocked resources for testing purposes.</source>
          <target state="translated">Убедись,что он тебе действительно нужен.Сделайте Google для &quot;одной кнопки анти-шаблона&quot;,чтобы увидеть некоторые аргументы против него.Полагаю,в этом нет ничего плохого,но это всего лишь механизм разоблачения некоторых глобальных ресурсов,так что убедитесь,что это лучший способ.В частности,я нашел инъекцию зависимостей более полезной,особенно если вы также используете юнит-тесты,потому что DI позволяет использовать высмеянные ресурсы для тестирования.</target>
        </trans-unit>
        <trans-unit id="9cf1fc929b39778cf9f0128785173350eab34054" translate="yes" xml:space="preserve">
          <source>Might be a little late to the game on this, but there is a lot of nuance around implementing a singleton. The holder pattern can not be used in many situations. And IMO when using a volatile - you should also use a local variable. Let's start at the beginning and iterate on the problem. You'll see what I mean.</source>
          <target state="translated">Может быть немного поздно для игры на этом,но есть много нюансов вокруг реализации одиночки.Шаблон держателя не может быть использован во многих ситуациях.А IMO при использовании волатильности-следует также использовать локальную переменную.Давайте начнем с начала и выполним итерацию по проблеме.Вы поймете,о чем я.</target>
        </trans-unit>
        <trans-unit id="1a476004e24909d4497d2c94b9c51634c0fb9800" translate="yes" xml:space="preserve">
          <source>Most simple way of implementing Singleton is</source>
          <target state="translated">Самый простой способ реализации Singleton -</target>
        </trans-unit>
        <trans-unit id="684056e9a0e6e7d9bfae63756efde4ae038ff5d9" translate="yes" xml:space="preserve">
          <source>Now we are sure about evil thread but what about the cruel serialization? We have to make sure even while de-serialiaztion no new object is created</source>
          <target state="translated">Теперь мы уверены насчет злой нити,но как же жестокая сериализация? Мы должны быть уверены,что даже при де-сериализации не будет создан новый объект.</target>
        </trans-unit>
        <trans-unit id="9484e9bddcf6bf03ecbdd460165f19a93ef91143" translate="yes" xml:space="preserve">
          <source>Now what happens? The class is loaded via the class loader. Directly after the class was interpreted from a byte Array, the VM executes the &lt;strong&gt;static { }&lt;/strong&gt; - block. that's the whole secret: The static-block is only called once, the time the given class (name) of the given package is loaded by this one class loader.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что теперь происходит? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Класс загружается через загрузчик классов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Непосредственно после того, как класс был интерпретирован из байтового массива, виртуальная машина выполняет &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;статический {}&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -блок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в этом весь секрет: статический блок вызывается только один раз, когда данный класс (имя) данного пакета загружается этим одним загрузчиком классов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7e283fe450ff620ebec87128aa5b3eb6c0c2f057" translate="yes" xml:space="preserve">
          <source>Now you might have realized why ENUMS are considered as best way to implement Singleton and thanks for your patience :)</source>
          <target state="translated">Теперь вы,возможно,поняли,почему ENUMS считается лучшим способом реализации Singleton,и спасибо за ваше терпение :)</target>
        </trans-unit>
        <trans-unit id="e20b619471537c9fdf4fce2cd0526492d4dbf263" translate="yes" xml:space="preserve">
          <source>On the other hand you would have to synchronize any method that instantiates the singleton variable as such. Synchronisation is not bad as such, but it can lead to performance issues or locking (in very very rare situations using this example. The solution is</source>
          <target state="translated">С другой стороны,вам пришлось бы синхронизировать любой метод,который инстанцирует однокнопочную переменную как таковую.Синхронизация как таковая неплохая,но она может привести к проблемам с производительностью или блокировкой (в очень редких ситуациях,используя этот пример).Решение заключается в следующем</target>
        </trans-unit>
        <trans-unit id="e192152615641c437ec6823a4905298484aa4fcd" translate="yes" xml:space="preserve">
          <source>Personally I try to avoid singletons as often as possible for many reasons, again most of which can be found by googling singletons. I feel that quite often singletons are abused because they're easy to understand by everybody, they're used as a mechanism for getting &quot;global&quot; data into an OO design and they are used because it is easy to circumvent object lifecycle management (or really thinking about how you can do A from inside B). Look at things like Inversion of Control (IoC) or Dependency Injection (DI) for a nice middleground.</source>
          <target state="translated">Лично я стараюсь избегать синглонов как можно чаще по многим причинам,опять же большинство из которых можно найти с помощью гуглирования синглонов.Я чувствую,что довольно часто синглонами злоупотребляют,потому что их легко понять всем,они используются как механизм получения &quot;глобальных&quot; данных в конструкции OO,и они используются потому,что их легко обойти управление жизненным циклом объекта (или действительно подумать о том,как можно сделать A изнутри B).Посмотрите на такие вещи,как инверсия контроля (IoC)или впрыск зависимостей (DI)для хорошего среднего уровня.</target>
        </trans-unit>
        <trans-unit id="1e5603ff1860ef0178d46a84735151ebbc81412b" translate="yes" xml:space="preserve">
          <source>Pre java5, the most simple case is:</source>
          <target state="translated">Pre java5,самый простой случай:</target>
        </trans-unit>
        <trans-unit id="60cf150afaede3481521c6a09f00d10fa2b78c34" translate="yes" xml:space="preserve">
          <source>Quoted from Oracle docs</source>
          <target state="translated">Процитировано из документов Oracle</target>
        </trans-unit>
        <trans-unit id="35da73343bd35c600a36425fc3769d474da87faf" translate="yes" xml:space="preserve">
          <source>Really consider why you need a singleton before writing it. There is a quasi-religious debate about using them which you can quite easily stumble over if you google singletons in Java.</source>
          <target state="translated">Правда,подумай,зачем тебе нужна одна кнопка,прежде чем писать ее.Есть квази-религиозные дебаты об их использовании,на которые вы можете довольно легко наткнуться,если вы будете гуглить синглоны на Java.</target>
        </trans-unit>
        <trans-unit id="a4b911bd10db59f7158b81f9dff1479d45dabc42" translate="yes" xml:space="preserve">
          <source>See below:</source>
          <target state="translated">См.ниже:</target>
        </trans-unit>
        <trans-unit id="144acf1b25f939cc5a71dac3e66a60314aa55a25" translate="yes" xml:space="preserve">
          <source>Since java5 the best way to do it is to use an enum:</source>
          <target state="translated">С java5 лучший способ сделать это-использовать перепись:</target>
        </trans-unit>
        <trans-unit id="b08f78b4f933e670f21e1a2a72f765390500cf67" translate="yes" xml:space="preserve">
          <source>Since the line &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; is only executed when the class &lt;code&gt;FooLoader&lt;/code&gt; is actually used, this takes care of the lazy instantiation,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Начиная с строки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;выполняется только тогда, когда класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FooLoader&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; фактически используется, это заботится о ленивом экземпляре,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc6c6e20bf4d28fc65ba4aa328fe47d239aea652" translate="yes" xml:space="preserve">
          <source>Since the line &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Начиная с строки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;выполняется только тогда, когда класс FooLoader фактически используется, это заботится о ленивом экземпляре и гарантированно является потокобезопасным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fa48287c77b71caf8e74418a2ae9c9d8f0b884f" translate="yes" xml:space="preserve">
          <source>Since the performance hit is due to operating directly on the volatile member, let&amp;rsquo;s set a local variable to the value of the volatile and operate on the local variable instead. This will decrease the number of times we operate on the volatile, thereby reclaiming some of our lost performance. Note that we have to set our local variable again when we enter the synchronized block. This ensures it is up to date with any changes that occured while we were waiting for the lock.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку снижение производительности связано с работой непосредственно с volatile-элементом, давайте установим локальную переменную в значение volatile и вместо этого будем работать с локальной переменной. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это уменьшит количество раз, когда мы работаем с энергозависимым, тем самым восстанавливая некоторые из наших потерянных показателей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что мы должны снова установить нашу локальную переменную при входе в синхронизированный блок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это гарантирует, что он в курсе любых изменений, которые произошли, пока мы ожидали блокировки.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4036b3be660b1f0e9d9c15b854523b4c11df6c63" translate="yes" xml:space="preserve">
          <source>Singleton (recognizeable by creational methods returning the same instance (usually of itself) everytime)</source>
          <target state="translated">Одноэлементный (распознаваемый креативными методами,каждый раз возвращающий один и тот же экземпляр (обычно сам по себе)).</target>
        </trans-unit>
        <trans-unit id="b01dd5022b1a1f15d490b388905b81ca48501f60" translate="yes" xml:space="preserve">
          <source>Singleton Pattern</source>
          <target state="translated">Однотонный узор</target>
        </trans-unit>
        <trans-unit id="3690b32d31a6ee5fca52025e9ed22a94485b652a" translate="yes" xml:space="preserve">
          <source>Singleton using enum in Java is generally way to declare enum singleton. Enum singleton may contain instance variable and instance method. For simplicity's sake, also note that if you are using any instance method than you need to ensure thread safety of that method if at all it affect the state of object.</source>
          <target state="translated">Использование enum в Java,как правило,является способом объявления enum singleton.Одиночка enum может содержать переменную экземпляра и метод экземпляра.Для простоты также обратите внимание,что если вы используете какой-либо метод экземпляра,то вам необходимо обеспечить безопасность потока этого метода,если он вообще влияет на состояние объекта.</target>
        </trans-unit>
        <trans-unit id="52b2eff37dbeec148fff787e7ff7e6de02054d3d" translate="yes" xml:space="preserve">
          <source>So far so good but our hero will not survive while fighting alone with multiple evil threads who want many many instance of our hero.
So lets protect it from evil multi threading</source>
          <target state="translated">Пока что хорошо,но наш герой не выживет,сражаясь в одиночку с многочисленными злыми нитями,которым нужны многие экземпляры нашего героя.Так что давайте защитим его от злых многопоточностей.</target>
        </trans-unit>
        <trans-unit id="a431deea175954e157c5356235834f7184a5c3d9" translate="yes" xml:space="preserve">
          <source>So my answer to the OP would be (in all but the most trivial sample code) to:</source>
          <target state="translated">Так что мой ответ на ОП был бы (во всех случаях,кроме самого тривиального кода):</target>
        </trans-unit>
        <trans-unit id="e9825624dff86ece92a2bc0d1f8028de08b5275e" translate="yes" xml:space="preserve">
          <source>Sometimes a simple &quot;&lt;strong&gt;&lt;code&gt;static Foo foo = new Foo();&lt;/code&gt;&lt;/strong&gt;&quot; is not enough. Just think of some basic data insertion you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Иногда простого &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;static Foo foo = new Foo();&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; недостаточно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Просто подумайте о какой-то базовой вставке данных.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1cf01eb108e908af4fc931855b27b85753afa4b3" translate="yes" xml:space="preserve">
          <source>Still, for the possibility of mockup-testing (when needed), this code exposure may be an acceptable price to pay.</source>
          <target state="translated">Тем не менее,для возможности имитационного тестирования (при необходимости),такое кодовое воздействие может быть приемлемой ценой.</target>
        </trans-unit>
        <trans-unit id="7637ce39b2a6ccf5b15f95d3348e1a81e9a82645" translate="yes" xml:space="preserve">
          <source>That's it! No more fear of serialization, threads and ugly code. Also &lt;a href=&quot;https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized&quot;&gt;&lt;strong&gt;ENUMS singleton are lazily initialized&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это оно! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Больше нет страха перед сериализацией, потоками и уродливым кодом. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Также &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ENUMS синглтон лениво инициализируется&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f67dd2a7db1a7c3fc3cc6101abf4ed21718573ce" translate="yes" xml:space="preserve">
          <source>The Right Way to Implement a Serializable Singleton</source>
          <target state="translated">Правильный способ реализации сериализуемой одиночки.</target>
        </trans-unit>
        <trans-unit id="b3e18ec47297de814755ec714fb91e212a427942" translate="yes" xml:space="preserve">
          <source>The added &lt;code&gt;setInstance&lt;/code&gt; method allows setting a mockup implementation of the singleton class during testing:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Добавленный &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setInstance&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; позволяет установить макет реализации синглтон-класса во время тестирования:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4521b53cdada5013dc77f66248a6b2ee60f1f330" translate="yes" xml:space="preserve">
          <source>The best singleton pattern I've ever seen uses the Supplier interface.</source>
          <target state="translated">Лучший однокнопочный шаблон,который я когда-либо видел,использует интерфейс &quot;Поставщик&quot;.</target>
        </trans-unit>
        <trans-unit id="992c69cb4926f648d77809fc7bae30df43dd03fb" translate="yes" xml:space="preserve">
          <source>The first attempt might look something like this:</source>
          <target state="translated">Первая попытка может выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="62a5fcdcf2c0644557b079b56916db57c90e3b1b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readResolve()&lt;/code&gt; will make sure the only instance will be returned, even when the object was serialized in a previous run of our program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет гарантировать, что будет возвращен единственный экземпляр, даже если объект был сериализован в предыдущем запуске нашей программы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a3cda2ac2d8449008fdb6ba3f67bdcaa4ef8e56" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readResolve()&lt;/code&gt; will make sure the only instance will be returned, even when the object was serialized in a previous run of your program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; гарантирует, что единственный экземпляр будет возвращен, даже если объект был сериализован в предыдущем запуске вашей программы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d051f06d522a538ce7b8be3c8c2b7e2852f29b98" translate="yes" xml:space="preserve">
          <source>The process by which enum constants are serialized cannot be customized: any class-specific &lt;code&gt;writeObject&lt;/code&gt;, &lt;code&gt;readObject&lt;/code&gt;, &lt;code&gt;readObjectNoData&lt;/code&gt;, &lt;code&gt;writeReplace&lt;/code&gt;, and &lt;code&gt;readResolve&lt;/code&gt; methods defined by enum types are ignored during serialization and deserialization. Similarly, any &lt;code&gt;serialPersistentFields&lt;/code&gt; or &lt;code&gt;serialVersionUID&lt;/code&gt; field declarations are also ignored--all enum types have a fixed &lt;code&gt;serialVersionUID&lt;/code&gt; of &lt;code&gt;0L&lt;/code&gt;. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Процесс, посредством которого константы перечисления сериализуются, не может быть настроен: любые специфичные для класса &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writeObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObjectNoData&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writeReplace&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; определенные типами enum, игнорируются во время сериализации и десериализации. Аналогично, любые &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialPersistentFields&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialVersionUID&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; декларации поля также игнорируются - все типы перечислений имеют фиксированную &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialVersionUID&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0L&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Документирование сериализуемых полей и данных для перечислимых типов не требуется, так как нет никаких изменений в типе отправляемых данных.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88232c86e9921f355cbedefbf606e1ec4b0222cb" translate="yes" xml:space="preserve">
          <source>The simplest way to implement a Singleton that is thread-safe is using an Enum</source>
          <target state="translated">Самый простой способ реализации Singleton,который является потокобезопасным,это использование Enum</target>
        </trans-unit>
        <trans-unit id="324fafbf3dd017a25265072d69c1504f6acc9259" translate="yes" xml:space="preserve">
          <source>The solution posted by Stu Thompson is valid in Java5.0 and later. But I would prefer not to use it because I think it is error prone.</source>
          <target state="translated">Решение,размещенное Стю Томпсоном,действует на Java5.0 и более поздних версиях.Но я бы предпочел не использовать его,потому что думаю,что он склонен к ошибкам.</target>
        </trans-unit>
        <trans-unit id="edd7245e8448aa583319dd5b5f37ca9516437706" translate="yes" xml:space="preserve">
          <source>The use of an enum is very easy to implement and has no drawbacks regarding serializable objects, which have to be circumvented in the other ways.</source>
          <target state="translated">Использование перечисления очень просто и не имеет недостатков в отношении сериализуемых объектов,которые необходимо обходить другими способами.</target>
        </trans-unit>
        <trans-unit id="b114fda2f6ec08d969eb2bb4e56a779dc3bcf423" translate="yes" xml:space="preserve">
          <source>This also works with early initialization approaches:</source>
          <target state="translated">Это также работает с подходами ранней инициализации:</target>
        </trans-unit>
        <trans-unit id="cd43b28c24b9b93c4a94bb6e35e416c97e534d68" translate="yes" xml:space="preserve">
          <source>This approach gives you a nice decoupled (and therefore flexible and testable) architecture where whether to use a singleton is an easily reversible implementation detail (provided any singletons you use are threadsafe, of course).</source>
          <target state="translated">Этот подход дает вам хорошую развязанную (а значит,гибкую и тестируемую)архитектуру,в которой использование одиночной кнопки является легко реверсируемой деталью реализации (при условии,конечно,что все используемые одиночные кнопки являются потокотокобезопасными).</target>
        </trans-unit>
        <trans-unit id="23a12931b83c281e5be65a44b857d308e3e4b439" translate="yes" xml:space="preserve">
          <source>This approach is functionally equivalent to the public field approach,
  except that it is more concise, provides the serialization machinery
  for free, and provides an  ironclad guarantee against multiple
  instantiation, even in the face of sophisticated serialization or
  reflection attacks. While this approach has yet to be widely  adopted,
  a single-element enum type is the best way to implement a singleton.</source>
          <target state="translated">Такой подход функционально эквивалентен подходу,применяемому в общественном секторе,за исключением того,что он более лаконичен,предоставляет механизм сериализации бесплатно и обеспечивает железную гарантию от множественных инстанцинаций,даже перед лицом изощренных сериализационных или отражающих атак.Хотя этот подход еще не получил широкого распространения,одноэлементный тип перечисления является наилучшим способом реализации одноэлементного.</target>
        </trans-unit>
        <trans-unit id="0fb64c36eb4df7481b8185546e14c30c29a59641" translate="yes" xml:space="preserve">
          <source>This can become even more complex if your Singleton Class maintain state, as you need to make them transient, but with in Enum Singleton, Serialization is guaranteed by JVM.</source>
          <target state="translated">Это может стать еще более сложным,если ваш класс Singleton поддерживать состояние,как вы должны сделать их переходными,но с в Enum Singleton,Сериализация гарантируется JVM.</target>
        </trans-unit>
        <trans-unit id="5c43167556dc43196560c28fccf6cf8a83bd7631" translate="yes" xml:space="preserve">
          <source>This code works since the introduction of Enum in Java 1.5</source>
          <target state="translated">Этот код работает с момента введения Enum в Java 1.5.</target>
        </trans-unit>
        <trans-unit id="07783588bd4a0a5ac185259a31d40270814cbf31" translate="yes" xml:space="preserve">
          <source>This has the drawback of exposing this functionality to the normal application too. Other developers working on that code could be tempted to use the &amp;acute;setInstance&amp;acute; method to alter alter a specific function and thus changing the whole application behaviour, therefore this method should contain at least a good warning in it's javadoc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это имеет недостаток предоставления этой функциональности и обычному приложению. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другие разработчики, работающие над этим кодом, могут испытывать соблазн использовать метод &amp;laquo;setInstance&amp;raquo; для изменения определенной функции и, таким образом, изменения поведения всего приложения, поэтому этот метод должен содержать хотя бы хорошее предупреждение в своем javadoc.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f0e4dffb57ee9f672603e4caac113f7aa7a29784" translate="yes" xml:space="preserve">
          <source>This implementation instantiates the singleton when the class is loaded and provides thread safety.</source>
          <target state="translated">Эта реализация инстанцирует одиночную кнопку при загрузке класса и обеспечивает безопасность потока.</target>
        </trans-unit>
        <trans-unit id="3bcdfd6657ae1d877f13ff4b71f5aa0b6a1e61ca" translate="yes" xml:space="preserve">
          <source>This is called &quot;Double-Checked Locking idiom&quot;. It's easy to forget the volatile statement and difficult to understand why it is necessary.</source>
          <target state="translated">Это называется &quot;Идиома двойной проверки блокировки&quot;.Легко забыть волатильное утверждение и трудно понять,зачем оно нужно.</target>
        </trans-unit>
        <trans-unit id="85183f87aa9e976e97a8bf574c183e173f4602d0" translate="yes" xml:space="preserve">
          <source>This is how to implement a simple &lt;code&gt;singleton&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот как реализовать простой &lt;/font&gt;&lt;/font&gt; &lt;code&gt;singleton&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b7f2b8b2f3a3bb36011ef27da112effbbcca494" translate="yes" xml:space="preserve">
          <source>This is how to properly lazy create your &lt;code&gt;singleton&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот как правильно лениво создать свой &lt;/font&gt;&lt;/font&gt; &lt;code&gt;singleton&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c226a0d50b9cf5f1f7f7584597d4a9bb7aa0b47" translate="yes" xml:space="preserve">
          <source>This is not thread-safe before 1.5 because the implementation of the volatile keyword was different.</source>
          <target state="translated">Это не является потокобезопасным до 1.5,так как реализация нестабильного ключевого слова была другой.</target>
        </trans-unit>
        <trans-unit id="0eae784989f658fbb0307199e73140ce0ea1b6ee" translate="yes" xml:space="preserve">
          <source>This pattern was invented for performance optimization. But this is really not a real concern anymore. The following lazy initialization code is fast and -more importantly- easier to read.</source>
          <target state="translated">Эта модель была изобретена для оптимизации производительности.Но на самом деле это больше не является реальной проблемой.Следующий ленивый код инициализации быстр и-что более важно-легче читается.</target>
        </trans-unit>
        <trans-unit id="2de7e75929ecc9f2fafb60ca0908a1d88f37e8f4" translate="yes" xml:space="preserve">
          <source>This solves our problem of multiple instantiation. But once again, our solution has presented another challenge. Other threads might not &amp;ldquo;see&amp;rdquo; that the INSTANCE member has been updated. This is because of how Java optimizes memory operations. Threads copy the original values of variables from main memory into the CPU&amp;rsquo;s cache. Changes to values are then written to, and read from, that cache. This is a feature of Java designed to optimize performance. But this creates a problem for our singleton implementation. A second thread &amp;mdash; being processed by a different CPU or core, using a different cache &amp;mdash; will not see the changes made by the first. This will cause the second thread to see the INSTANCE member as null forcing a new instance of our singleton to be created.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это решает нашу проблему множественной реализации. Но еще раз, наше решение поставило еще одну проблему. Другие темы могут не &amp;laquo;видеть&amp;raquo;, что элемент INSTANCE обновлен. Это из-за того, как Java оптимизирует операции с памятью. Потоки копируют исходные значения переменных из основной памяти в кэш процессора. Изменения значений затем записываются и считываются из этого кэша. Это особенность Java, предназначенная для оптимизации производительности. Но это создает проблему для нашей одноэлементной реализации. Второй поток, обрабатываемый другим процессором или ядром с использованием другого кэша, не увидит изменений, внесенных первым. Это приведет к тому, что второй поток увидит член INSTANCE как ноль, заставляя создать новый экземпляр нашего синглтона.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3982534593f5cf37c205bccd98c6c2c2ed3e5381" translate="yes" xml:space="preserve">
          <source>Thread safe in Java 5+:</source>
          <target state="translated">Безопасность резьбы на Java 5+:</target>
        </trans-unit>
        <trans-unit id="04b4f72d8a23d7425a5b14131f70d156c7dc2761" translate="yes" xml:space="preserve">
          <source>Updated it on my &lt;a href=&quot;http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html&quot;&gt;&lt;strong&gt;blog&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обновил его в моем &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;блоге&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9161ee3cf60f6074cfb5c48f3cb43e426db90017" translate="yes" xml:space="preserve">
          <source>Use a DI framework like Spring, then</source>
          <target state="translated">Использовать структуру DI,такую как Spring,то...</target>
        </trans-unit>
        <trans-unit id="e4a5ae13c99482e816948dfcb8fe12927d55920c" translate="yes" xml:space="preserve">
          <source>Use an enum:</source>
          <target state="translated">Используй перепись:</target>
        </trans-unit>
        <trans-unit id="776cfab9b61501bc78411c540b320617fa616521" translate="yes" xml:space="preserve">
          <source>Various ways to make singleton object:</source>
          <target state="translated">Различные способы сделать однотонный объект:</target>
        </trans-unit>
        <trans-unit id="9ad13e2ae424b0243ecb89f19638cd41ed1925d8" translate="yes" xml:space="preserve">
          <source>We solve this by using the volatile keyword on the declaration of the INSTANCE member. This will tell the compiler to always read from, and write to, main memory, and not the CPU cache.</source>
          <target state="translated">Мы решаем эту проблему,используя волатильное ключевое слово на декларации члена ИНСТАНСИИ.Это подскажет компилятору всегда читать из оперативной памяти и записывать в нее,а не в кэш процессора.</target>
        </trans-unit>
        <trans-unit id="1bf5b3bf3c10dd18e5ebfca2eaf0228fc7fbfb5f" translate="yes" xml:space="preserve">
          <source>What is an efficient way to implement a singleton pattern in Java</source>
          <target state="translated">Что является эффективным способом реализации однокнопочного шаблона на Java</target>
        </trans-unit>
        <trans-unit id="f349af906b6a57f91d39044acff051886e44c477" translate="yes" xml:space="preserve">
          <source>What is an efficient way to implement a singleton pattern in Java?</source>
          <target state="translated">Что является эффективным способом реализации однокнопочного шаблона в Java?</target>
        </trans-unit>
        <trans-unit id="57287d24baa49f04d3f6b5f7078cfe13762fe008" translate="yes" xml:space="preserve">
          <source>When you also want to be able to serialize your object you need to make sure that deserialization won't create a copy.</source>
          <target state="translated">Когда вы также хотите иметь возможность сериализовать ваш объект,вам нужно убедиться,что десериализация не создаст копию.</target>
        </trans-unit>
        <trans-unit id="80541c0ebffb0d27ed0ef1c021dac3462b5a7ff4" translate="yes" xml:space="preserve">
          <source>When you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.</source>
          <target state="translated">Когда у вас есть очень большой объект или тяжелый конструкционный код,а также другие доступные статические методы или поля,которые могут быть использованы до того,как понадобится экземпляр,то и только тогда нужно использовать ленивую инициализацию.</target>
        </trans-unit>
        <trans-unit id="20ae263969c6f45c33763ef5b07b053acb1b5085" translate="yes" xml:space="preserve">
          <source>Which internally will be treated like</source>
          <target state="translated">Который внутри будет рассматриваться как</target>
        </trans-unit>
        <trans-unit id="9fc41d526f2830fe033c939964b2725da50bb8b2" translate="yes" xml:space="preserve">
          <source>While implementing Singleton we have 2 options</source>
          <target state="translated">При внедрении Singleton у нас есть 2 варианта</target>
        </trans-unit>
        <trans-unit id="7943deba045650ecf620b5fc602f8e7f40df67bf" translate="yes" xml:space="preserve">
          <source>Wikipedia has some &lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;examples&lt;/a&gt; of singletons, also in Java. The Java 5 implementation looks pretty complete, and is thread-safe (double-checked locking applied).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В Википедии есть несколько &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;примеров&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; синглетонов, в том числе и на Java. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реализация Java 5 выглядит довольно полной и поточно-ориентированной (применяется двойная проверка блокировки).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25a9c997c2a0f10d5c983669f0d673357b7f536a" translate="yes" xml:space="preserve">
          <source>Yes this is our very same hero :)</source>
          <target state="translated">Да,это наш тот самый герой :)</target>
        </trans-unit>
        <trans-unit id="163c3ae95955d8d2c53ef90772f314e7d4a5456e" translate="yes" xml:space="preserve">
          <source>You can access it by &lt;code&gt;Singleton.INSTANCE&lt;/code&gt;, much easier than calling &lt;code&gt;getInstance()&lt;/code&gt; method on Singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете получить к нему доступ с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Singleton.INSTANCE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что гораздо проще, чем вызов &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метода &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в Singleton.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="165226e14a9b8a0bc7611c1d847342885fa6b327" translate="yes" xml:space="preserve">
          <source>You can also learn the example of Singleton from Java native classes themselves.</source>
          <target state="translated">Вы также можете сами изучить пример Singleton из классов на Java native.</target>
        </trans-unit>
        <trans-unit id="da1cdd3c6b13c229a5cef9295f865b1db2ba6086" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;private static class&lt;/code&gt; to load the instance. The code would then look like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для загрузки экземпляра. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код будет выглядеть так:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da8eb20a2c0def105bbda60af4028ebd2a0428ec" translate="yes" xml:space="preserve">
          <source>You need &lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;double-checking&lt;/a&gt; idiom if you need to load the instance variable of a class lazily. 
If you need to load a static variable or a singleton lazily, you need &lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;initilization on demand holder&lt;/a&gt; idiom.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам нужно &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;дважды проверить&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; идиому, если вам нужно лениво загрузить переменную экземпляра класса. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вам нужно лениво загрузить статическую переменную или синглтон, вам нужна &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;инициализация по требованию&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7299bef205f9fbe8285ad8fd92fe078c02885760" translate="yes" xml:space="preserve">
          <source>and is it guaranteed to be thread safe.</source>
          <target state="translated">и гарантированно ли он безопасен для резьбы.</target>
        </trans-unit>
        <trans-unit id="1dade600888158a285ff5b9f54f469f410ee1879" translate="yes" xml:space="preserve">
          <source>and you are done !!!</source>
          <target state="translated">и тебе конец!!!</target>
        </trans-unit>
        <trans-unit id="37ad954d0f8bf18aadbea1b38b8284ba8a25ce8b" translate="yes" xml:space="preserve">
          <source>but it is not enough to protect out hero, Really!!! This is the best we can/should do to help our hero</source>
          <target state="translated">но этого недостаточно,чтобы защитить своего героя,Правда!!! Это лучшее,что мы можем сделать,чтобы помочь нашему герою...</target>
        </trans-unit>
        <trans-unit id="9faec8995d83b9be3b7e6f2fda57cb3f6eae1310" translate="yes" xml:space="preserve">
          <source>java.awt.Desktop#getDesktop()</source>
          <target state="translated">java.awt.Desktop#getDesktop()</target>
        </trans-unit>
        <trans-unit id="feb09ab6bb59cc909d31090f3c92bfd63af74174" translate="yes" xml:space="preserve">
          <source>java.lang.Runtime#getRuntime()</source>
          <target state="translated">java.lang.Runtime#getRuntime()</target>
        </trans-unit>
        <trans-unit id="ae51ce6d9a7b1d933f6941c6e05cfe4d216830e0" translate="yes" xml:space="preserve">
          <source>java.lang.System#getSecurityManager()</source>
          <target state="translated">java.lang.System#getSecurityManager()</target>
        </trans-unit>
        <trans-unit id="3081145acbbe9e3b7e7bb4c880b445b436f215cc" translate="yes" xml:space="preserve">
          <source>simplest singleton class</source>
          <target state="translated">простейший одноэлементный класс</target>
        </trans-unit>
        <trans-unit id="f3368e90e82c1f778e6130853ddc2c2df1799d82" translate="yes" xml:space="preserve">
          <source>you can use double check locking also.</source>
          <target state="translated">можно также использовать блокировку двойного контроля.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
