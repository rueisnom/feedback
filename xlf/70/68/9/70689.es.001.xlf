<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/70689">
    <body>
      <group id="70689">
        <trans-unit id="d0e7abff310a4025796fb8127bff3a00cdf49cf9" translate="yes" xml:space="preserve">
          <source>&quot;This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, &lt;strong&gt;a single-element enum type is the best way to implement a singleton&lt;/strong&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Este enfoque es funcionalmente equivalente al enfoque de campo p&amp;uacute;blico, excepto que es m&amp;aacute;s conciso, proporciona la maquinaria de serializaci&amp;oacute;n de forma gratuita y proporciona una garant&amp;iacute;a irrefrenable contra la creaci&amp;oacute;n de instancias m&amp;uacute;ltiples, incluso ante ataques de reflexi&amp;oacute;n o serializaci&amp;oacute;n sofisticados. Si bien este enfoque tiene a&amp;uacute;n no se ha adoptado ampliamente, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un tipo de enumeraci&amp;oacute;n de un solo elemento es la mejor manera de implementar un singleton&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d92bd02c3c63ee0ed64ba4245fb3a982d203b6" translate="yes" xml:space="preserve">
          <source>-Joshua Bloch in &quot;Effective Java&quot;</source>
          <target state="translated">-Joshua Bloch en &quot;Effective Java&quot;</target>
        </trans-unit>
        <trans-unit id="08d9fe87472c62e1e954d12a6dac491ca298dd21" translate="yes" xml:space="preserve">
          <source>1) Enum</source>
          <target state="translated">1)Enum</target>
        </trans-unit>
        <trans-unit id="d2d52ad19eaadabdfadda897ef4c0d186a866fd7" translate="yes" xml:space="preserve">
          <source>1. Lazy loading</source>
          <target state="translated">1.Carga perezosa</target>
        </trans-unit>
        <trans-unit id="079dc82c2bdf9ccd588072d932c3947e40fede85" translate="yes" xml:space="preserve">
          <source>1.12    Serialization of Enum Constants</source>
          <target state="translated">1.12 Serialización de las constantes de enum</target>
        </trans-unit>
        <trans-unit id="2cd0140a25a4d1a85fb94d0761891417c4dc4984" translate="yes" xml:space="preserve">
          <source>2) Double checked Locking /Lazy loading</source>
          <target state="translated">2)Doble control de bloqueo de la carga de Lazy</target>
        </trans-unit>
        <trans-unit id="08f82b326d21f0209551fd37f400406131162a05" translate="yes" xml:space="preserve">
          <source>2. Early loading</source>
          <target state="translated">2.Carga temprana</target>
        </trans-unit>
        <trans-unit id="4c7750893106bc2853b3923c39390400fecd2f63" translate="yes" xml:space="preserve">
          <source>3) Static factory method</source>
          <target state="translated">3)Método de fábrica estática</target>
        </trans-unit>
        <trans-unit id="5ff5ef5674939ac9c059ad5c77a4b4e9f1e23eca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; I have just summarized all of the awesome answers and wrote it in my words.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Descargo de responsabilidad:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; acabo de resumir todas las incre&amp;iacute;bles respuestas y lo escrib&amp;iacute; en mis palabras.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30628e72df671cf84d40652d24c88b86db31f004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Double checked locking&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Doble control de bloqueo&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3195614dcff1f3528172d85cbffa6b9a4089c087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;: 
@Bno 's answer details the approach recommended by Bill Pugh (FindBugs) and is arguable better.  Go read and vote up his answer too.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EDIT 2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : la respuesta de @Bno detalla el enfoque recomendado por Bill Pugh (FindBugs) y es discutible mejor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ve a leer y vota su respuesta tambi&amp;eacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c62c92240dd0a4c0e46e65c24fd4c21e1a44e94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: Pay attention to the &lt;code&gt;volatile&lt;/code&gt; modifier here.  :)  It is important because without it, other threads are not guaranteed by the JMM (Java Memory Model) to see changes to its value.  The synchronization &lt;em&gt;does not&lt;/em&gt; take care of that--it only serializes access to that block of code.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EDITAR&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : Presta atenci&amp;oacute;n al &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;modificador &lt;/font&gt;&lt;/font&gt; &lt;code&gt;volatile&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; aqu&amp;iacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:) Es importante porque sin &amp;eacute;l, el JMM (Java Memory Model) no garantiza otros hilos para ver los cambios en su valor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La sincronizaci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se ocupa de eso, solo serializa el acceso a ese bloque de c&amp;oacute;digo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bb36a38fdf6c84e6a71484fcd968f8d949b0141b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Early loading Singleton (works even before Java 1.5)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Singleton de carga temprana (funciona incluso antes de Java 1.5)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72cbea399de93731f0e7101d06f9d2d1a574c4ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; An &lt;a href=&quot;http://www.ddj.com/java/208403883?pgno=3&quot;&gt;online portion of &quot;Effective Java&quot;&lt;/a&gt; says:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Editar:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Una &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.ddj.com/java/208403883?pgno=3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;parte en l&amp;iacute;nea de &quot;Java efectivo&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dice:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="307bb6f80695a03d34d6fd0a9d21d290e3ad9313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enum singleton&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Enum singleton&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56dddc61df291744c7df167e2ba5c4fbc619af1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good Read&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Buena lectura&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b768ec3d338078db9ffc311717a61b05c7f46cf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Versi&amp;oacute;n 1:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed1d2772abb6c6974f7deddced2292b250baa718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Versi&amp;oacute;n 2:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bda23d30aeb1eeb2070de09f96721b3c09f96127" translate="yes" xml:space="preserve">
          <source>And we have came so far, here is the best way to achieve everything we did is best possible way</source>
          <target state="translated">Y hemos llegado tan lejos,aquí está la mejor manera de lograr todo lo que hicimos es la mejor manera posible</target>
        </trans-unit>
        <trans-unit id="38bb16500de69328e3b17998a373f42c6fa738bb" translate="yes" xml:space="preserve">
          <source>Another argument often used against Singletons are their testability problems. Singletons are not easily mockable for testing purposes. If this turns out to be a problem, I like to make the following slight modification:</source>
          <target state="translated">Otro argumento que se usa a menudo contra los Singletons son sus problemas de comprobabilidad.Los monolitos no son fácilmente burlados para propósitos de prueba.Si esto resulta ser un problema,me gustaría hacer la siguiente pequeña modificación:</target>
        </trans-unit>
        <trans-unit id="5a305003db33fc59491a9b2510c4cad977d2c3c3" translate="yes" xml:space="preserve">
          <source>Another problem with conventional Singletons are that once you implement &lt;code&gt;Serializable&lt;/code&gt; interface, they no longer remain Singleton because &lt;code&gt;readObject()&lt;/code&gt; method always return a new instance  like constructor in Java. This can be avoided by using &lt;code&gt;readResolve()&lt;/code&gt; and discarding newly created instance by replacing with singleton like below</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro problema con Singletons convencionales es que una vez que implementa la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;interfaz &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ya no siguen siendo Singleton porque el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObject()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; siempre devuelve una nueva instancia como constructor en Java. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se puede evitar mediante el uso de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y descartando la instancia reci&amp;eacute;n creada reemplazando con singleton como se muestra a continuaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81316ae241d3865f37b7d5da2e372416ecd88025" translate="yes" xml:space="preserve">
          <source>As per Joshua Bloch - Enum would be the best.</source>
          <target state="translated">Según Joshua Bloch-Enum sería el mejor.</target>
        </trans-unit>
        <trans-unit id="3c3778d4d24f299f28881cec97f7840ac08f30c0" translate="yes" xml:space="preserve">
          <source>As the double checking pattern is not guaranteed to work (due to some issue with compilers, I don't know anything more about that.), you could also try to synchronize the whole getInstance-method or create a registry for all your Singletons.</source>
          <target state="translated">Como no se garantiza que el patrón de doble control funcione (debido a algún problema con los compiladores,no sé nada más al respecto.),también podrías intentar sincronizar todo el método getInstance o crear un registro para todos tus Singletons.</target>
        </trans-unit>
        <trans-unit id="b23dd736696f30fd3946f179df3014700e480a54" translate="yes" xml:space="preserve">
          <source>As we have added the Synchronized keyword before getInstance, we have avoided the race condition in the case when two threads call the getInstance at the same time.</source>
          <target state="translated">Como hemos añadido la palabra clave sincronizada antes de getInstance,hemos evitado la condición de carrera en el caso de que dos hilos llamen a getInstance al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="9872f9d1cf5a148d81f6618ffcfb77b475ddd945" translate="yes" xml:space="preserve">
          <source>But this implementation has a problem. Multi-threaded applications will have a race condition on the creation of the single instance. If multiple threads of execution hit the getInstance() method at (or around) the same time, they will each see the INSTANCE member as null. This will result in each thread creating a new MySingleton instance and subsequently setting the INSTANCE member.</source>
          <target state="translated">Pero esta implementación tiene un problema.Las aplicaciones multi-hilo tendrán una condición de carrera en la creación de la instancia única.Si múltiples hilos de ejecución golpean el método getInstance()en (o alrededor de)el mismo momento,cada uno de ellos verá el miembro INSTANCE como nulo.Esto hará que cada hilo de ejecución cree una nueva instancia de MySingleton y posteriormente establezca el miembro INSTANCE.</target>
        </trans-unit>
        <trans-unit id="4bffec330193be3f47d3dd37823b7f72184fbd13" translate="yes" xml:space="preserve">
          <source>But this simple change comes at a cost. Because we are bypassing the CPU cache, we will take a performance hit each time we operate on the volatile INSTANCE member &amp;mdash; which we do 4 times. We double-check existence (1 and 2), set the value (3), and then return the value (4). One could argue that this path is the fringe case as we only create the instance during the first call of the method. Perhaps a performance hit on creation is tolerable. But even our main use-case, reads, will operate on the volatile member twice. Once to check existence, and again to return its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero este simple cambio tiene un costo. Debido a que estamos evitando el cach&amp;eacute; de la CPU, tomaremos un impacto en el rendimiento cada vez que operemos en el miembro vol&amp;aacute;til INSTANCE, lo que hacemos 4 veces. Verificamos dos veces la existencia (1 y 2), establecemos el valor (3) y luego devolvemos el valor (4). Se podr&amp;iacute;a argumentar que este camino es el caso marginal, ya que solo creamos la instancia durante la primera llamada del m&amp;eacute;todo. Tal vez un golpe de rendimiento en la creaci&amp;oacute;n es tolerable. Pero incluso nuestro caso de uso principal, lee, operar&amp;aacute; en el miembro vol&amp;aacute;til dos veces. Una vez para verificar la existencia, y nuevamente para devolver su valor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17e7851eae8628811d4f175deed2ffc97753ae75" translate="yes" xml:space="preserve">
          <source>Depending on the usage, there are several &quot;correct&quot; answers.</source>
          <target state="translated">Dependiendo del uso,hay varias respuestas &quot;correctas&quot;.</target>
        </trans-unit>
        <trans-unit id="6376ee8d7ecb240ca2e7ac33a3adc4bc45c9c27e" translate="yes" xml:space="preserve">
          <source>Double-checked locking and the Singleton pattern</source>
          <target state="translated">El bloqueo doblemente comprobado y el patrón de Singleton</target>
        </trans-unit>
        <trans-unit id="db9d8df06d494bd593e263605d3d29426f3aacc6" translate="yes" xml:space="preserve">
          <source>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, &lt;code&gt;ObjectOutputStream&lt;/code&gt; writes the value returned by the enum constant's name method. To deserialize an enum constant, &lt;code&gt;ObjectInputStream&lt;/code&gt; reads the constant name from the stream; the deserialized constant is then obtained by calling the &lt;code&gt;java.lang.Enum.valueOf&lt;/code&gt; method, passing the constant's enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las constantes de enumeraci&amp;oacute;n se serializan de manera diferente a los objetos serializables o externalizables ordinarios. La forma serializada de una constante enum consiste &amp;uacute;nicamente en su nombre; Los valores de campo de la constante no est&amp;aacute;n presentes en el formulario. Para serializar una constante enum, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectOutputStream&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; escribe el valor devuelto por el m&amp;eacute;todo de nombre de la constante enum. Para deserializar una constante enum, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectInputStream&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lee el nombre constante de la secuencia; la constante deserializada se obtiene llamando al &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Enum.valueOf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pasando el tipo de enumeraci&amp;oacute;n de la constante junto con el nombre de la constante recibida como argumentos. Al igual que otros objetos serializables o externalizables, las constantes de enumeraci&amp;oacute;n pueden funcionar como objetivos de referencias posteriores que aparecen posteriormente en la secuencia de serializaci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ceb04d0bf6d359988aa55fd0ab46e6fbd0ac88d" translate="yes" xml:space="preserve">
          <source>Enums, Singletons and Deserialization</source>
          <target state="translated">Enums,Singletons y Deserialización</target>
        </trans-unit>
        <trans-unit id="ad7444993cf50fd2b00245cc896506e7174251b7" translate="yes" xml:space="preserve">
          <source>Even inner static class can be used.</source>
          <target state="translated">Incluso se puede utilizar la clase estática interna.</target>
        </trans-unit>
        <trans-unit id="e8407c8536a920696620341c8d56ee215bf8ab27" translate="yes" xml:space="preserve">
          <source>Everything is good except its early loaded singleton. Lets try lazy loaded singleton</source>
          <target state="translated">Todo está bien excepto su primer singleton cargado.Intentemos con el singleton cargado y perezoso</target>
        </trans-unit>
        <trans-unit id="13c1641e1e78a21a27ed901675c0fb58e566e905" translate="yes" xml:space="preserve">
          <source>Examples of GoF Design Patterns in Java's core libraries</source>
          <target state="translated">Ejemplos de patrones de diseño de GoF en las bibliotecas centrales de Java</target>
        </trans-unit>
        <trans-unit id="694f20fe271ac257cf93f8c43bbc55ae37aea518" translate="yes" xml:space="preserve">
          <source>Finally we have added enough protection  against threads and serialization but our code is looking bulky and ugly. Lets give our hero a make over</source>
          <target state="translated">Finalmente hemos añadido suficiente protección contra los hilos y la serialización pero nuestro código se ve voluminoso y feo.Démosle a nuestro héroe un cambio de imagen</target>
        </trans-unit>
        <trans-unit id="669d1ad80c1897dcc9c350b124bcb770181e306a" translate="yes" xml:space="preserve">
          <source>Following are 3 different approaches</source>
          <target state="translated">A continuación se presentan 3 enfoques diferentes</target>
        </trans-unit>
        <trans-unit id="87c36aa5ed8b30192f0a868029407fecc727cc10" translate="yes" xml:space="preserve">
          <source>For JSE 5.0 and above take the Enum approach, otherwise use static singleton holder approach ( (a lazy loading approach described by Bill Pugh). Latter solution is also thread-safe without requiring special language constructs (i.e. volatile or synchronized).</source>
          <target state="translated">Para JSE 5.0 y superiores,tome el enfoque Enum,de lo contrario utilice el enfoque de la carga estática de un solo tonel (un enfoque de carga perezosa descrito por Bill Pugh).Esta última solución también es segura para los hilos sin necesidad de utilizar construcciones especiales de lenguaje (es decir,volátiles o sincronizadas).</target>
        </trans-unit>
        <trans-unit id="9b9714e50bd4daa7b29e38926f2d72e66aa42aa0" translate="yes" xml:space="preserve">
          <source>For details :  &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para m&amp;aacute;s detalles: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea40150d9fb3a40c99b1e699a4f5bc78fddf39bf" translate="yes" xml:space="preserve">
          <source>Forget &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_initialization&quot;&gt;lazy initialization&lt;/a&gt;, it's too problematic. This is the simplest solution:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Olv&amp;iacute;date de la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;inicializaci&amp;oacute;n perezosa&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , es demasiado problem&amp;aacute;tico. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta es la soluci&amp;oacute;n m&amp;aacute;s simple:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59059ebb0b7402bf9c92da6476af7654cefbc8a2" translate="yes" xml:space="preserve">
          <source>From the best answer's &quot;Singleton&quot; section,</source>
          <target state="translated">De la sección &quot;Singleton&quot; de la mejor respuesta,</target>
        </trans-unit>
        <trans-unit id="625479fdef81f36c1ab97a359b96e9e84c247479" translate="yes" xml:space="preserve">
          <source>Have a look at this post.</source>
          <target state="translated">Echa un vistazo a este post.</target>
        </trans-unit>
        <trans-unit id="2c84fb11ab9057630b8bfa9b38aec5ad9e99c0a2" translate="yes" xml:space="preserve">
          <source>Here we have the MySingleton class which has a private static member called INSTANCE, and a public static method called getInstance(). The first time getInstance() is called, the INSTANCE member is null. The flow will then fall into the creation condition and create a new instance of the MySingleton class. Subsequent calls to getInstance() will find that the INSTANCE variable is already set, and therefore not create another MySingleton instance. This ensures there is only one instance of MySingleton which is shared among all callers of getInstance().</source>
          <target state="translated">Aquí tenemos la clase MySingleton que tiene un miembro estático privado llamado INSTANCE,y un método estático público llamado getInstance().La primera vez que se llama getInstance(),el miembro INSTANCE es nulo.El flujo entonces caerá en la condición de creación y creará una nueva instancia de la clase MySingleton.Las llamadas posteriores a getInstance()encontrarán que la variable INSTANCE ya está establecida,y por lo tanto no crearán otra instancia de MySingleton.Esto asegura que sólo hay una instancia de MySingleton que se comparte entre todos los que llaman a getInstance().</target>
        </trans-unit>
        <trans-unit id="2e5384598935f29c9b1e729f63a7964aa522e9b7" translate="yes" xml:space="preserve">
          <source>Here we issue another check from INSIDE the block. If the INSTANCE member has already been set, we&amp;rsquo;ll skip initialization. This is called double-checked locking.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; emitimos otro cheque DENTRO del bloque. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si el miembro INSTANCE ya se ha configurado, omitiremos la inicializaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se llama bloqueo de doble verificaci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4d2ad2ed1e46d507a87415c705db9a38a9c8631" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve moved synchronization from the method signature, to a synchronized block that wraps the creation of the MySingleton instance. But does this solve our problem? Well, we are no longer blocking on reads, but we&amp;rsquo;ve also taken a step backward. Multiple threads will hit the getInstance() method at or around the same time and they will all see the INSTANCE member as null. They will then hit the synchronized block where one will obtain the lock and create the instance. When that thread exits the block, the other threads will contend for the lock, and one by one each thread will fall through the block and create a new instance of our class. So we are right back where we started.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hemos movido la sincronizaci&amp;oacute;n de la firma del m&amp;eacute;todo a un bloque sincronizado que envuelve la creaci&amp;oacute;n de la instancia de MySingleton. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Pero esto resuelve nuestro problema? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bueno, ya no estamos bloqueando las lecturas, pero tambi&amp;eacute;n hemos dado un paso atr&amp;aacute;s. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Varios subprocesos alcanzar&amp;aacute;n el m&amp;eacute;todo getInstance () aproximadamente al mismo tiempo y todos ver&amp;aacute;n al miembro de INSTANCE como nulo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego golpear&amp;aacute;n el bloque sincronizado donde se obtendr&amp;aacute; el bloqueo y crear&amp;aacute; la instancia. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando ese hilo sale del bloque, los otros hilos competir&amp;aacute;n por el bloqueo, y uno por uno cada hilo caer&amp;aacute; a trav&amp;eacute;s del bloque y crear&amp;aacute; una nueva instancia de nuestra clase. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; que estamos de vuelta donde empezamos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="df8f4dd0518f2a157d601eef2563a409c8be073f" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve used the synchronized keyword in the method signature to synchronize the getInstance() method. This will certainly fix our race condition. Threads will now block and enter the method one at a time. But it also creates a performance problem. Not only does this implementation synchronize the creation of the single instance, it synchronizes all calls to getInstance(), including reads. Reads do not need to be synchronized as they simply return the value of INSTANCE. Since reads will make up the bulk of our calls (remember, instantiation only happens on the first call), we will incur an unnecessary performance hit by synchronizing the entire method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hemos usado la palabra clave sincronizada en la firma del m&amp;eacute;todo para sincronizar el m&amp;eacute;todo getInstance (). Esto ciertamente arreglar&amp;aacute; nuestra condici&amp;oacute;n de carrera. Los hilos ahora se bloquear&amp;aacute;n e ingresar&amp;aacute;n al m&amp;eacute;todo de uno en uno. Pero tambi&amp;eacute;n crea un problema de rendimiento. Esta implementaci&amp;oacute;n no solo sincroniza la creaci&amp;oacute;n de la instancia &amp;uacute;nica, sino que sincroniza todas las llamadas a getInstance (), incluidas las lecturas. Las lecturas no necesitan ser sincronizadas ya que simplemente devuelven el valor de INSTANCE. Dado que las lecturas constituir&amp;aacute;n la mayor parte de nuestras llamadas (recuerde, la creaci&amp;oacute;n de instancias solo ocurre en la primera llamada), incurriremos en un rendimiento innecesario al sincronizar todo el m&amp;eacute;todo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78bce48dfe4ac1df6adfc647b4139137aa6d82ec" translate="yes" xml:space="preserve">
          <source>I still think after java 1.5, enum is the best available singleton implementation available as it also ensures that even in the multi threaded environments - only one instance is created.</source>
          <target state="translated">Sigo pensando que después de java 1.5,enum es la mejor implementación de singleton disponible,ya que también asegura que incluso en los entornos de múltiples hilos-sólo se crea una instancia.</target>
        </trans-unit>
        <trans-unit id="889368f1848c86a7463020ef822a9db09e8274ba" translate="yes" xml:space="preserve">
          <source>I use the Spring Framework to manage my singletons.  It doesn't enforce the &quot;singleton-ness&quot; of the class (which you can't really do anyway if there are multiple class loaders involved) but provides a really easy way to build and configure different factories for creating different types of objects.</source>
          <target state="translated">Utilizo el marco de primavera para manejar mis monocitos.No refuerza el &quot;singleton-ness&quot; de la clase (lo cual no se puede hacer de todas formas si hay varios cargadores de clase involucrados)pero proporciona una forma muy fácil de construir y configurar diferentes fábricas para crear diferentes tipos de objetos.</target>
        </trans-unit>
        <trans-unit id="ed23e9e9e4913fecc55d825c0498fb0496c7f8a6" translate="yes" xml:space="preserve">
          <source>I would say Enum singleton</source>
          <target state="translated">Yo diría que Enum singleton</target>
        </trans-unit>
        <trans-unit id="afa6bc6c9963a7910bf3a4b45b55b520b11cb54d" translate="yes" xml:space="preserve">
          <source>I wrote an article about this recently. &lt;a href=&quot;https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5&quot;&gt;Deconstructing The Singleton&lt;/a&gt;. You can find more info on these examples and an example of the &quot;holder&quot; pattern there. There is also a real-world example showcasing the double-checked volatile approach. Hope this helps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Escrib&amp;iacute; un art&amp;iacute;culo sobre esto recientemente. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Deconstruyendo The Singleton&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede encontrar m&amp;aacute;s informaci&amp;oacute;n sobre estos ejemplos y un ejemplo del patr&amp;oacute;n &quot;titular&quot; all&amp;iacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n hay un ejemplo del mundo real que muestra el enfoque vol&amp;aacute;til doblemente verificado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Espero que esto ayude.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab17279cd20fd4b1687c230a64664d6a72159390" translate="yes" xml:space="preserve">
          <source>I'm mystified by some of the answers that suggest DI as an alternative to using singletons; these are unrelated concepts. You can use DI to inject either singleton or non-singleton (e.g. per-thread) instances. At least this is true if you use Spring 2.x, I can't speak for other DI frameworks.</source>
          <target state="translated">Estoy desconcertado por algunas de las respuestas que sugieren el DI como alternativa al uso de singletons;estos son conceptos no relacionados.Puedes usar el DI para inyectar instancias de un solo botón o no (por ejemplo,por hilo).Al menos esto es cierto si usas Spring 2.x,no puedo hablar por otros marcos DI.</target>
        </trans-unit>
        <trans-unit id="577011040f77feb24314bebcebb9dd9fde8ba1ea" translate="yes" xml:space="preserve">
          <source>If you do not need lazy loading then simply try</source>
          <target state="translated">Si no necesitas una carga perezosa,entonces simplemente intenta</target>
        </trans-unit>
        <trans-unit id="710c65236f4c85b7918088ab9764fa4fe32f4e52" translate="yes" xml:space="preserve">
          <source>If you really need one then wikipedia has a good example of a proper implementation of a singleton.</source>
          <target state="translated">Si realmente necesitas uno,entonces Wikipedia tiene un buen ejemplo de una implementación adecuada de un singleton.</target>
        </trans-unit>
        <trans-unit id="6577d11ba941eea89cd233d6d86c997fce516f3c" translate="yes" xml:space="preserve">
          <source>If you want lazy loading and you want your Singleton to be thread-safe, try the double-checking pattern</source>
          <target state="translated">Si quieres una carga perezosa y quieres que tu Singleton sea seguro para el hilo,prueba el patrón de doble comprobación</target>
        </trans-unit>
        <trans-unit id="a3855b5c69e8ee65b0b5745f601e591577ad0129" translate="yes" xml:space="preserve">
          <source>If you want to code a &amp;ldquo;classic&amp;rdquo; singleton that works in a multithreaded environment (starting from Java 1.5) you should use this one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea codificar un singleton &quot;cl&amp;aacute;sico&quot; que funciona en un entorno multiproceso (a partir de Java 1.5), debe utilizar este.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d8270ca97b87f403744a722f1dc68510486cf68" translate="yes" xml:space="preserve">
          <source>In addition, if the singleton needs to be seriliazble, all other fields needs to be transient and readResolve() method needs to be implemented in order to maintain the singleton object invariant. Otherwise, each time the object is deserialized, a new instance of the object will be created. What readResolve() does is replace the new object read by readObject(), which forced that new object to be garbage collected as there is no variable referring to it.</source>
          <target state="translated">Además,si el singleton necesita ser seriliazble,todos los demás campos necesitan ser transitorios y el método readResolve()necesita ser implementado para mantener invariable el objeto singleton.De lo contrario,cada vez que se deserialice el objeto,se creará una nueva instancia del objeto.Lo que hace readResolve()es reemplazar el nuevo objeto leído por readObject(),lo que obligó a que ese nuevo objeto fuera basura recogida ya que no hay ninguna variable que se refiera a él.</target>
        </trans-unit>
        <trans-unit id="c7d8c92f19b91f623b57babd3358dff0e0040f4a" translate="yes" xml:space="preserve">
          <source>It supports lazy initialization</source>
          <target state="translated">Apoya la inicialización perezosa</target>
        </trans-unit>
        <trans-unit id="ebcba64c45c23ff901884aec98da59f574d38bb0" translate="yes" xml:space="preserve">
          <source>It's easy to forget the volatile statement and difficult to understand why it is necessary. Without the volatile this code would not be thread safe anymore due to the double-checked locking antipattern. See more about this in paragraph 16.2.4 of &lt;a href=&quot;http://jcip.net/&quot;&gt;Java Concurrency in Practice&lt;/a&gt;. In short: This pattern (prior to Java5.0 or without the volatile statement) could return a reference to the Bar object that is (still) in an incorrect state.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es f&amp;aacute;cil olvidar la declaraci&amp;oacute;n vol&amp;aacute;til y dif&amp;iacute;cil de entender por qu&amp;eacute; es necesario. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin el vol&amp;aacute;til, este c&amp;oacute;digo ya no ser&amp;iacute;a seguro para subprocesos debido al antipatr&amp;oacute;n de bloqueo doblemente verificado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Vea m&amp;aacute;s sobre esto en el p&amp;aacute;rrafo 16.2.4 de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://jcip.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la concurrencia&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java en la pr&amp;aacute;ctica&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En resumen: este patr&amp;oacute;n (anterior a Java5.0 o sin la declaraci&amp;oacute;n vol&amp;aacute;til) podr&amp;iacute;a devolver una referencia al objeto Bar que (todav&amp;iacute;a) est&amp;aacute; en un estado incorrecto.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aed94d32746ef6f2b1030893cf2c63e4473de7b9" translate="yes" xml:space="preserve">
          <source>It's generic and reusable</source>
          <target state="translated">Es genérico y reutilizable</target>
        </trans-unit>
        <trans-unit id="80ce64e9d168cca4d45ad01dd786a3a3d622a3eb" translate="yes" xml:space="preserve">
          <source>It's only synchronized until it has been initialized, then the blocking supplier is replaced with a non-blocking supplier.</source>
          <target state="translated">Sólo se sincroniza hasta que se ha inicializado,entonces el proveedor bloqueador se sustituye por un proveedor no bloqueador.</target>
        </trans-unit>
        <trans-unit id="449c13963dfa95bddabe3876c74d3b40442953df" translate="yes" xml:space="preserve">
          <source>Joshua Bloch explained this approach in his &lt;a href=&quot;http://sites.google.com/site/io/effective-java-reloaded&quot;&gt;Effective Java Reloaded&lt;/a&gt; talk at Google I/O 2008: &lt;a href=&quot;http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s&quot;&gt;link to video&lt;/a&gt;. Also see slides 30-32 of his presentation (&lt;a href=&quot;https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&amp;amp;attredirects=0&quot;&gt;effective_java_reloaded.pdf&lt;/a&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joshua Bloch explic&amp;oacute; este enfoque en su &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;charla &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sites.google.com/site/io/effective-java-reloaded&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Efectiva Java Reloaded&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en Google I / O 2008: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;enlace al video&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n vea las diapositivas 30-32 de su presentaci&amp;oacute;n ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&amp;amp;attredirects=0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;efectiva_java_reloaded.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="793c23aca34d846cb2973e2995675836910ca030" translate="yes" xml:space="preserve">
          <source>Lazy loading adds bit overhead(lots of to be honest) so use it only when you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.Otherwise choosing early loading is a good choice.</source>
          <target state="translated">La carga lenta agrega un poco de sobrecarga (mucha para ser honesto),así que úsala sólo cuando tengas un objeto muy grande o un código de construcción pesado Y también tienes otros métodos estáticos accesibles o campos que pueden ser usados antes de que se necesite una instancia,entonces y sólo entonces necesitas usar la inicialización lenta.</target>
        </trans-unit>
        <trans-unit id="02fefdeb69ee5d29a7c948927ea167ebab436a0f" translate="yes" xml:space="preserve">
          <source>Lazy loading, thread safe with blocking, low performance because of &lt;code&gt;synchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Carga lenta, hilo seguro con bloqueo, bajo rendimiento debido a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;synchronized&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d407b886496d8e0094a35acef4bd5685c8ff45f" translate="yes" xml:space="preserve">
          <source>Lazy loading, thread safe with non-blocking, high performance.</source>
          <target state="translated">Carga perezosa,hilo seguro sin bloqueo,de alto rendimiento.</target>
        </trans-unit>
        <trans-unit id="f54e23f25888e8257c17de0c8827649ac27396d2" translate="yes" xml:space="preserve">
          <source>Let's go over the code. First, you want the class to be final. In this case, I've used the &lt;code&gt;final&lt;/code&gt; keyword to let the users know it is final. Then you need to make the constructor private to prevent users to create their own Foo. Throwing an exception from the constructor prevents users to use reflection to create a second Foo. Then you create a &lt;code&gt;private static final Foo&lt;/code&gt; field to hold the only instance, and a &lt;code&gt;public static Foo getInstance()&lt;/code&gt; method to return it. The Java specification makes sure that the constructor is only called when the class is first used.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Repasemos el c&amp;oacute;digo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Primero, quieres que la clase sea final. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En este caso, he usado la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;palabra clave &lt;/font&gt;&lt;/font&gt; &lt;code&gt;final&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para que los usuarios sepan que es final. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego debe hacer que el constructor sea privado para evitar que los usuarios creen su propio Foo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lanzar una excepci&amp;oacute;n del constructor evita que los usuarios usen la reflexi&amp;oacute;n para crear un segundo Foo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego, crea un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;campo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para contener la &amp;uacute;nica instancia y un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;public static Foo getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para devolverlo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La especificaci&amp;oacute;n Java asegura que solo se llama al constructor cuando se usa la clase por primera vez.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9c873dc1a8784c864c5dd3081fbf40b67576f0d" translate="yes" xml:space="preserve">
          <source>Make it part of your DI configuration whether your dependencies are singletons, request scoped, session scoped, or whatever.</source>
          <target state="translated">Haz que sea parte de tu configuración DI,ya sea que tus dependencias sean monolíticas,de solicitud,de sesión,o lo que sea.</target>
        </trans-unit>
        <trans-unit id="fd66bccb948073440dd0db12f2ca6e04f0d6a6dc" translate="yes" xml:space="preserve">
          <source>Make sure that you really need it. Do a google for &quot;singleton anti-pattern&quot; to see some arguments against it. There's nothing inherently wrong with it I suppose but it's just a mechanism for exposing some global resource/data so make sure that this is the best way. In particular I've found dependency injection more useful particularly if you are also using unit tests because DI allows you to use mocked resources for testing purposes.</source>
          <target state="translated">Asegúrate de que realmente lo necesitas.Busca en Google &quot;anti-patrón de Singleton&quot; para ver algunos argumentos en contra.Supongo que no hay nada inherentemente malo en ello,pero es sólo un mecanismo para exponer algunos recursos globales,así que asegúrate de que es la mejor manera.En particular,he encontrado que la inyección de dependencia es más útil,sobre todo si también se utilizan las pruebas de unidad,porque el DI permite utilizar los recursos burlados con fines de prueba.</target>
        </trans-unit>
        <trans-unit id="9cf1fc929b39778cf9f0128785173350eab34054" translate="yes" xml:space="preserve">
          <source>Might be a little late to the game on this, but there is a lot of nuance around implementing a singleton. The holder pattern can not be used in many situations. And IMO when using a volatile - you should also use a local variable. Let's start at the beginning and iterate on the problem. You'll see what I mean.</source>
          <target state="translated">Puede que sea un poco tarde para el juego en esto,pero hay un montón de matices en torno a la aplicación de un singleton.El patrón de sujeción no puede ser usado en muchas situaciones.Y la OMI cuando se utiliza un volátil-también debe utilizar una variable local.Empecemos por el principio e iteremos sobre el problema.Verá lo que quiero decir.</target>
        </trans-unit>
        <trans-unit id="1a476004e24909d4497d2c94b9c51634c0fb9800" translate="yes" xml:space="preserve">
          <source>Most simple way of implementing Singleton is</source>
          <target state="translated">La forma más simple de implementar Singleton es</target>
        </trans-unit>
        <trans-unit id="684056e9a0e6e7d9bfae63756efde4ae038ff5d9" translate="yes" xml:space="preserve">
          <source>Now we are sure about evil thread but what about the cruel serialization? We have to make sure even while de-serialiaztion no new object is created</source>
          <target state="translated">Ahora estamos seguros del hilo del mal,pero ¿qué hay de la cruel serialización? Tenemos que asegurarnos de que incluso mientras la des-serialización no se cree ningún nuevo objeto</target>
        </trans-unit>
        <trans-unit id="9484e9bddcf6bf03ecbdd460165f19a93ef91143" translate="yes" xml:space="preserve">
          <source>Now what happens? The class is loaded via the class loader. Directly after the class was interpreted from a byte Array, the VM executes the &lt;strong&gt;static { }&lt;/strong&gt; - block. that's the whole secret: The static-block is only called once, the time the given class (name) of the given package is loaded by this one class loader.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora que pasa? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La clase se carga a trav&amp;eacute;s del cargador de clases. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Directamente despu&amp;eacute;s de que la clase fue interpretada desde una matriz de bytes, la VM ejecuta el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bloque &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;est&amp;aacute;tico {}&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ese es todo el secreto: el bloque est&amp;aacute;tico solo se llama una vez, el tiempo en que este cargador de clases carga la clase (nombre) dada del paquete dado.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7e283fe450ff620ebec87128aa5b3eb6c0c2f057" translate="yes" xml:space="preserve">
          <source>Now you might have realized why ENUMS are considered as best way to implement Singleton and thanks for your patience :)</source>
          <target state="translated">Ahora te habrás dado cuenta de por qué los ENUMS son considerados como la mejor manera de implementar Singleton y gracias por tu paciencia :)</target>
        </trans-unit>
        <trans-unit id="e20b619471537c9fdf4fce2cd0526492d4dbf263" translate="yes" xml:space="preserve">
          <source>On the other hand you would have to synchronize any method that instantiates the singleton variable as such. Synchronisation is not bad as such, but it can lead to performance issues or locking (in very very rare situations using this example. The solution is</source>
          <target state="translated">Por otro lado,habría que sincronizar cualquier método que instale la variable singleton como tal.La sincronización no es mala como tal,pero puede llevar a problemas de rendimiento o de bloqueo (en situaciones muy,muy raras usando este ejemplo.La solución es</target>
        </trans-unit>
        <trans-unit id="e192152615641c437ec6823a4905298484aa4fcd" translate="yes" xml:space="preserve">
          <source>Personally I try to avoid singletons as often as possible for many reasons, again most of which can be found by googling singletons. I feel that quite often singletons are abused because they're easy to understand by everybody, they're used as a mechanism for getting &quot;global&quot; data into an OO design and they are used because it is easy to circumvent object lifecycle management (or really thinking about how you can do A from inside B). Look at things like Inversion of Control (IoC) or Dependency Injection (DI) for a nice middleground.</source>
          <target state="translated">Personalmente trato de evitar a los solteros tan a menudo como sea posible por muchas razones,de nuevo la mayoría de las cuales se pueden encontrar buscando en Google.Creo que muy a menudo se abusa de los solteros porque son fáciles de entender para todos,se utilizan como un mecanismo para obtener datos &quot;globales&quot; en un diseño OO y se utilizan porque es fácil eludir la gestión del ciclo de vida de los objetos (o realmente pensando en cómo se puede hacer A desde el interior de B).Mira cosas como la inversión de control (IoC)o la inyección de dependencia (DI)para un buen medio ambiente.</target>
        </trans-unit>
        <trans-unit id="1e5603ff1860ef0178d46a84735151ebbc81412b" translate="yes" xml:space="preserve">
          <source>Pre java5, the most simple case is:</source>
          <target state="translated">Pre java5,el caso más simple es:</target>
        </trans-unit>
        <trans-unit id="60cf150afaede3481521c6a09f00d10fa2b78c34" translate="yes" xml:space="preserve">
          <source>Quoted from Oracle docs</source>
          <target state="translated">Citado de los documentos del Oráculo</target>
        </trans-unit>
        <trans-unit id="35da73343bd35c600a36425fc3769d474da87faf" translate="yes" xml:space="preserve">
          <source>Really consider why you need a singleton before writing it. There is a quasi-religious debate about using them which you can quite easily stumble over if you google singletons in Java.</source>
          <target state="translated">Considere realmente por qué necesita un singleton antes de escribirlo.Hay un debate cuasi religioso sobre su uso,que puede ser fácilmente encontrado si buscas en Google singletons en Java.</target>
        </trans-unit>
        <trans-unit id="a4b911bd10db59f7158b81f9dff1479d45dabc42" translate="yes" xml:space="preserve">
          <source>See below:</source>
          <target state="translated">Ver abajo:</target>
        </trans-unit>
        <trans-unit id="144acf1b25f939cc5a71dac3e66a60314aa55a25" translate="yes" xml:space="preserve">
          <source>Since java5 the best way to do it is to use an enum:</source>
          <target state="translated">Desde java5 la mejor manera de hacerlo es usar un enum:</target>
        </trans-unit>
        <trans-unit id="b08f78b4f933e670f21e1a2a72f765390500cf67" translate="yes" xml:space="preserve">
          <source>Since the line &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; is only executed when the class &lt;code&gt;FooLoader&lt;/code&gt; is actually used, this takes care of the lazy instantiation,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde la l&amp;iacute;nea &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;solo se ejecuta cuando la clase &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FooLoader&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se usa realmente, esto se encarga de la instanciaci&amp;oacute;n perezosa,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc6c6e20bf4d28fc65ba4aa328fe47d239aea652" translate="yes" xml:space="preserve">
          <source>Since the line &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde la l&amp;iacute;nea &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;solo se ejecuta cuando se usa realmente la clase FooLoader, esto se encarga de la instanciaci&amp;oacute;n perezosa y se garantiza que sea seguro para subprocesos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fa48287c77b71caf8e74418a2ae9c9d8f0b884f" translate="yes" xml:space="preserve">
          <source>Since the performance hit is due to operating directly on the volatile member, let&amp;rsquo;s set a local variable to the value of the volatile and operate on the local variable instead. This will decrease the number of times we operate on the volatile, thereby reclaiming some of our lost performance. Note that we have to set our local variable again when we enter the synchronized block. This ensures it is up to date with any changes that occured while we were waiting for the lock.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dado que el impacto en el rendimiento se debe a que opera directamente en el miembro vol&amp;aacute;til, establezcamos una variable local en el valor del vol&amp;aacute;til y, en su lugar, operemos en la variable local. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto disminuir&amp;aacute; la cantidad de veces que operamos en el vol&amp;aacute;til, recuperando as&amp;iacute; parte de nuestro rendimiento perdido. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que tenemos que establecer nuestra variable local nuevamente cuando ingresamos al bloque sincronizado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto garantiza que est&amp;eacute; actualizado con los cambios que ocurrieron mientras esper&amp;aacute;bamos el bloqueo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4036b3be660b1f0e9d9c15b854523b4c11df6c63" translate="yes" xml:space="preserve">
          <source>Singleton (recognizeable by creational methods returning the same instance (usually of itself) everytime)</source>
          <target state="translated">Singleton (reconocible por los métodos creativos que devuelven la misma instancia (generalmente de sí mismo)cada vez)</target>
        </trans-unit>
        <trans-unit id="b01dd5022b1a1f15d490b388905b81ca48501f60" translate="yes" xml:space="preserve">
          <source>Singleton Pattern</source>
          <target state="translated">Patrón Singleton</target>
        </trans-unit>
        <trans-unit id="3690b32d31a6ee5fca52025e9ed22a94485b652a" translate="yes" xml:space="preserve">
          <source>Singleton using enum in Java is generally way to declare enum singleton. Enum singleton may contain instance variable and instance method. For simplicity's sake, also note that if you are using any instance method than you need to ensure thread safety of that method if at all it affect the state of object.</source>
          <target state="translated">El uso de &quot;enum&quot; en Java es generalmente una forma de declarar &quot;enum singleton&quot;.Enum singleton puede contener una variable de instancia y un método de instancia.Por simplicidad,también hay que tener en cuenta que si se utiliza cualquier método de instancia,hay que garantizar la seguridad de los hilos de ese método,si es que afecta al estado del objeto.</target>
        </trans-unit>
        <trans-unit id="52b2eff37dbeec148fff787e7ff7e6de02054d3d" translate="yes" xml:space="preserve">
          <source>So far so good but our hero will not survive while fighting alone with multiple evil threads who want many many instance of our hero.
So lets protect it from evil multi threading</source>
          <target state="translated">Hasta ahora todo va bien,pero nuestro héroe no sobrevivirá mientras luche solo con múltiples hilos malignos que quieren muchos muchos ejemplos de nuestro héroe.Así que vamos a protegerlo de los múltiples hilos del mal</target>
        </trans-unit>
        <trans-unit id="a431deea175954e157c5356235834f7184a5c3d9" translate="yes" xml:space="preserve">
          <source>So my answer to the OP would be (in all but the most trivial sample code) to:</source>
          <target state="translated">Así que mi respuesta a la OP sería (en todos los códigos de muestra menos el más trivial)a:</target>
        </trans-unit>
        <trans-unit id="e9825624dff86ece92a2bc0d1f8028de08b5275e" translate="yes" xml:space="preserve">
          <source>Sometimes a simple &quot;&lt;strong&gt;&lt;code&gt;static Foo foo = new Foo();&lt;/code&gt;&lt;/strong&gt;&quot; is not enough. Just think of some basic data insertion you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algunas veces un simple &quot; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;static Foo foo = new Foo();&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; no es suficiente. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo piense en la inserci&amp;oacute;n de datos b&amp;aacute;sicos que desea hacer.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1cf01eb108e908af4fc931855b27b85753afa4b3" translate="yes" xml:space="preserve">
          <source>Still, for the possibility of mockup-testing (when needed), this code exposure may be an acceptable price to pay.</source>
          <target state="translated">Aún así,para la posibilidad de realizar pruebas de simulación (cuando sea necesario),la exposición a este código puede ser un precio aceptable a pagar.</target>
        </trans-unit>
        <trans-unit id="7637ce39b2a6ccf5b15f95d3348e1a81e9a82645" translate="yes" xml:space="preserve">
          <source>That's it! No more fear of serialization, threads and ugly code. Also &lt;a href=&quot;https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized&quot;&gt;&lt;strong&gt;ENUMS singleton are lazily initialized&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl;Eso es! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No m&amp;aacute;s miedo a la serializaci&amp;oacute;n, hilos y c&amp;oacute;digo feo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ENUMS singleton est&amp;aacute;n perezosamente inicializados&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f67dd2a7db1a7c3fc3cc6101abf4ed21718573ce" translate="yes" xml:space="preserve">
          <source>The Right Way to Implement a Serializable Singleton</source>
          <target state="translated">La manera correcta de implementar un Singleton serializable</target>
        </trans-unit>
        <trans-unit id="b3e18ec47297de814755ec714fb91e212a427942" translate="yes" xml:space="preserve">
          <source>The added &lt;code&gt;setInstance&lt;/code&gt; method allows setting a mockup implementation of the singleton class during testing:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setInstance&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; agregado &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;permite configurar una implementaci&amp;oacute;n de maqueta de la clase singleton durante la prueba:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4521b53cdada5013dc77f66248a6b2ee60f1f330" translate="yes" xml:space="preserve">
          <source>The best singleton pattern I've ever seen uses the Supplier interface.</source>
          <target state="translated">El mejor patrón de un solo botón que he visto usa la interfaz del Proveedor.</target>
        </trans-unit>
        <trans-unit id="992c69cb4926f648d77809fc7bae30df43dd03fb" translate="yes" xml:space="preserve">
          <source>The first attempt might look something like this:</source>
          <target state="translated">El primer intento podría parecerse a esto:</target>
        </trans-unit>
        <trans-unit id="62a5fcdcf2c0644557b079b56916db57c90e3b1b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readResolve()&lt;/code&gt; will make sure the only instance will be returned, even when the object was serialized in a previous run of our program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se asegurar&amp;aacute; de que se devuelva la &amp;uacute;nica instancia, incluso cuando el objeto se serializ&amp;oacute; en una ejecuci&amp;oacute;n anterior de nuestro programa.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a3cda2ac2d8449008fdb6ba3f67bdcaa4ef8e56" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readResolve()&lt;/code&gt; will make sure the only instance will be returned, even when the object was serialized in a previous run of your program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se asegurar&amp;aacute; de que se devuelva la &amp;uacute;nica instancia, incluso cuando el objeto se serializ&amp;oacute; en una ejecuci&amp;oacute;n anterior de su programa.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d051f06d522a538ce7b8be3c8c2b7e2852f29b98" translate="yes" xml:space="preserve">
          <source>The process by which enum constants are serialized cannot be customized: any class-specific &lt;code&gt;writeObject&lt;/code&gt;, &lt;code&gt;readObject&lt;/code&gt;, &lt;code&gt;readObjectNoData&lt;/code&gt;, &lt;code&gt;writeReplace&lt;/code&gt;, and &lt;code&gt;readResolve&lt;/code&gt; methods defined by enum types are ignored during serialization and deserialization. Similarly, any &lt;code&gt;serialPersistentFields&lt;/code&gt; or &lt;code&gt;serialVersionUID&lt;/code&gt; field declarations are also ignored--all enum types have a fixed &lt;code&gt;serialVersionUID&lt;/code&gt; of &lt;code&gt;0L&lt;/code&gt;. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El proceso por el cual las constantes enum se serializan no se puede personalizar: cualquier &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writeObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObjectNoData&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writeReplace&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; espec&amp;iacute;fico de la clase &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;definidos por los tipos enum se ignoran durante la serializaci&amp;oacute;n y la deserializaci&amp;oacute;n. Del mismo modo, cualquier &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialPersistentFields&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialVersionUID&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; declaraciones de campos tambi&amp;eacute;n se ignoran - todos los tipos de enumeraci&amp;oacute;n tienen un fijo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialVersionUID&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0L&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Documentar campos y datos serializables para tipos de enumeraci&amp;oacute;n es innecesario, ya que no hay variaci&amp;oacute;n en el tipo de datos enviados.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88232c86e9921f355cbedefbf606e1ec4b0222cb" translate="yes" xml:space="preserve">
          <source>The simplest way to implement a Singleton that is thread-safe is using an Enum</source>
          <target state="translated">La forma más simple de implementar un Singleton que es seguro para los hilos es usando un Enum</target>
        </trans-unit>
        <trans-unit id="324fafbf3dd017a25265072d69c1504f6acc9259" translate="yes" xml:space="preserve">
          <source>The solution posted by Stu Thompson is valid in Java5.0 and later. But I would prefer not to use it because I think it is error prone.</source>
          <target state="translated">La solución publicada por Stu Thompson es válida en Java5.0 y posteriores.Pero preferiría no usarla porque creo que es propensa a errores.</target>
        </trans-unit>
        <trans-unit id="edd7245e8448aa583319dd5b5f37ca9516437706" translate="yes" xml:space="preserve">
          <source>The use of an enum is very easy to implement and has no drawbacks regarding serializable objects, which have to be circumvented in the other ways.</source>
          <target state="translated">El uso de un enum es muy fácil de implementar y no tiene ningún inconveniente en lo que respecta a los objetos serializables,que deben ser eludidos de las demás maneras.</target>
        </trans-unit>
        <trans-unit id="b114fda2f6ec08d969eb2bb4e56a779dc3bcf423" translate="yes" xml:space="preserve">
          <source>This also works with early initialization approaches:</source>
          <target state="translated">Esto también funciona con los enfoques de inicialización temprana:</target>
        </trans-unit>
        <trans-unit id="cd43b28c24b9b93c4a94bb6e35e416c97e534d68" translate="yes" xml:space="preserve">
          <source>This approach gives you a nice decoupled (and therefore flexible and testable) architecture where whether to use a singleton is an easily reversible implementation detail (provided any singletons you use are threadsafe, of course).</source>
          <target state="translated">Este enfoque le da una agradable arquitectura desacoplada (y por lo tanto flexible y comprobable)en la que la utilización de un singleton es un detalle de implementación fácilmente reversible (siempre que cualquier singleton que utilice sea seguro para los hilos,por supuesto).</target>
        </trans-unit>
        <trans-unit id="23a12931b83c281e5be65a44b857d308e3e4b439" translate="yes" xml:space="preserve">
          <source>This approach is functionally equivalent to the public field approach,
  except that it is more concise, provides the serialization machinery
  for free, and provides an  ironclad guarantee against multiple
  instantiation, even in the face of sophisticated serialization or
  reflection attacks. While this approach has yet to be widely  adopted,
  a single-element enum type is the best way to implement a singleton.</source>
          <target state="translated">Este enfoque es funcionalmente equivalente al enfoque de campo público,salvo que es más conciso,proporciona gratuitamente la maquinaria de serialización y ofrece una garantía férrea contra la instanciación múltiple,incluso ante ataques sofisticados de serialización o reflexión.Si bien este enfoque aún no se ha adoptado ampliamente,un tipo de enumeración de un solo elemento es la mejor manera de aplicar un singleton.</target>
        </trans-unit>
        <trans-unit id="0fb64c36eb4df7481b8185546e14c30c29a59641" translate="yes" xml:space="preserve">
          <source>This can become even more complex if your Singleton Class maintain state, as you need to make them transient, but with in Enum Singleton, Serialization is guaranteed by JVM.</source>
          <target state="translated">Esto puede llegar a ser aún más complejo si su Clase Singleton mantiene el estado,ya que necesita hacerlos transitorios,pero con en Enum Singleton,la serialización está garantizada por JVM.</target>
        </trans-unit>
        <trans-unit id="5c43167556dc43196560c28fccf6cf8a83bd7631" translate="yes" xml:space="preserve">
          <source>This code works since the introduction of Enum in Java 1.5</source>
          <target state="translated">Este código funciona desde la introducción de Enum en Java 1.5</target>
        </trans-unit>
        <trans-unit id="07783588bd4a0a5ac185259a31d40270814cbf31" translate="yes" xml:space="preserve">
          <source>This has the drawback of exposing this functionality to the normal application too. Other developers working on that code could be tempted to use the &amp;acute;setInstance&amp;acute; method to alter alter a specific function and thus changing the whole application behaviour, therefore this method should contain at least a good warning in it's javadoc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto tiene el inconveniente de exponer esta funcionalidad a la aplicaci&amp;oacute;n normal tambi&amp;eacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otros desarrolladores que trabajan en ese c&amp;oacute;digo podr&amp;iacute;an verse tentados a usar el m&amp;eacute;todo 'setInstance' para alterar, alterar una funci&amp;oacute;n espec&amp;iacute;fica y, por lo tanto, cambiar el comportamiento completo de la aplicaci&amp;oacute;n, por lo tanto, este m&amp;eacute;todo debe contener al menos una buena advertencia en su javadoc.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f0e4dffb57ee9f672603e4caac113f7aa7a29784" translate="yes" xml:space="preserve">
          <source>This implementation instantiates the singleton when the class is loaded and provides thread safety.</source>
          <target state="translated">Esta implementación instancia el singleton cuando la clase está cargada y proporciona seguridad al hilo.</target>
        </trans-unit>
        <trans-unit id="3bcdfd6657ae1d877f13ff4b71f5aa0b6a1e61ca" translate="yes" xml:space="preserve">
          <source>This is called &quot;Double-Checked Locking idiom&quot;. It's easy to forget the volatile statement and difficult to understand why it is necessary.</source>
          <target state="translated">Esto se llama &quot;Idioma de bloqueo doblemente comprobado&quot;.Es fácil olvidar la frase volátil y difícil de entender por qué es necesaria.</target>
        </trans-unit>
        <trans-unit id="85183f87aa9e976e97a8bf574c183e173f4602d0" translate="yes" xml:space="preserve">
          <source>This is how to implement a simple &lt;code&gt;singleton&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; es como implementar un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;singleton&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; simple &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b7f2b8b2f3a3bb36011ef27da112effbbcca494" translate="yes" xml:space="preserve">
          <source>This is how to properly lazy create your &lt;code&gt;singleton&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; es como crear pereza correctamente su &lt;/font&gt;&lt;/font&gt; &lt;code&gt;singleton&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c226a0d50b9cf5f1f7f7584597d4a9bb7aa0b47" translate="yes" xml:space="preserve">
          <source>This is not thread-safe before 1.5 because the implementation of the volatile keyword was different.</source>
          <target state="translated">Esto no es seguro antes del 1.5 porque la implementación de la palabra clave volátil fue diferente.</target>
        </trans-unit>
        <trans-unit id="0eae784989f658fbb0307199e73140ce0ea1b6ee" translate="yes" xml:space="preserve">
          <source>This pattern was invented for performance optimization. But this is really not a real concern anymore. The following lazy initialization code is fast and -more importantly- easier to read.</source>
          <target state="translated">Este patrón fue inventado para la optimización del rendimiento.Pero esto ya no es una preocupación real.El siguiente código de inicialización perezoso es rápido y,lo que es más importante,más fácil de leer.</target>
        </trans-unit>
        <trans-unit id="2de7e75929ecc9f2fafb60ca0908a1d88f37e8f4" translate="yes" xml:space="preserve">
          <source>This solves our problem of multiple instantiation. But once again, our solution has presented another challenge. Other threads might not &amp;ldquo;see&amp;rdquo; that the INSTANCE member has been updated. This is because of how Java optimizes memory operations. Threads copy the original values of variables from main memory into the CPU&amp;rsquo;s cache. Changes to values are then written to, and read from, that cache. This is a feature of Java designed to optimize performance. But this creates a problem for our singleton implementation. A second thread &amp;mdash; being processed by a different CPU or core, using a different cache &amp;mdash; will not see the changes made by the first. This will cause the second thread to see the INSTANCE member as null forcing a new instance of our singleton to be created.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto resuelve nuestro problema de instanciaci&amp;oacute;n m&amp;uacute;ltiple. Pero una vez m&amp;aacute;s, nuestra soluci&amp;oacute;n ha presentado otro desaf&amp;iacute;o. Es posible que otros hilos no &quot;vean&quot; que el miembro de INSTANCE ha sido actualizado. Esto se debe a c&amp;oacute;mo Java optimiza las operaciones de memoria. Los subprocesos copian los valores originales de las variables de la memoria principal en el cach&amp;eacute; de la CPU. Los cambios en los valores se escriben y leen desde ese cach&amp;eacute;. Esta es una caracter&amp;iacute;stica de Java dise&amp;ntilde;ada para optimizar el rendimiento. Pero esto crea un problema para nuestra implementaci&amp;oacute;n de singleton. Un segundo subproceso, que est&amp;aacute; siendo procesado por una CPU o n&amp;uacute;cleo diferente, usando un cach&amp;eacute; diferente, no ver&amp;aacute; los cambios realizados por el primero. Esto har&amp;aacute; que el segundo subproceso vea al miembro de INSTANCE como nulo, lo que obligar&amp;aacute; a crear una nueva instancia de nuestro singleton.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3982534593f5cf37c205bccd98c6c2c2ed3e5381" translate="yes" xml:space="preserve">
          <source>Thread safe in Java 5+:</source>
          <target state="translated">Hilo seguro en Java 5+:</target>
        </trans-unit>
        <trans-unit id="04b4f72d8a23d7425a5b14131f70d156c7dc2761" translate="yes" xml:space="preserve">
          <source>Updated it on my &lt;a href=&quot;http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html&quot;&gt;&lt;strong&gt;blog&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo actualic&amp;eacute; en mi &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;blog&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9161ee3cf60f6074cfb5c48f3cb43e426db90017" translate="yes" xml:space="preserve">
          <source>Use a DI framework like Spring, then</source>
          <target state="translated">Usar un marco de DI como Spring,entonces...</target>
        </trans-unit>
        <trans-unit id="e4a5ae13c99482e816948dfcb8fe12927d55920c" translate="yes" xml:space="preserve">
          <source>Use an enum:</source>
          <target state="translated">Use un enum:</target>
        </trans-unit>
        <trans-unit id="776cfab9b61501bc78411c540b320617fa616521" translate="yes" xml:space="preserve">
          <source>Various ways to make singleton object:</source>
          <target state="translated">Varias formas de hacer un objeto único:</target>
        </trans-unit>
        <trans-unit id="9ad13e2ae424b0243ecb89f19638cd41ed1925d8" translate="yes" xml:space="preserve">
          <source>We solve this by using the volatile keyword on the declaration of the INSTANCE member. This will tell the compiler to always read from, and write to, main memory, and not the CPU cache.</source>
          <target state="translated">Resolvemos esto usando la palabra clave volátil en la declaración del miembro de la INSTANCIA.Esto le dirá al compilador que siempre lea y escriba en la memoria principal,y no en la caché de la CPU.</target>
        </trans-unit>
        <trans-unit id="1bf5b3bf3c10dd18e5ebfca2eaf0228fc7fbfb5f" translate="yes" xml:space="preserve">
          <source>What is an efficient way to implement a singleton pattern in Java</source>
          <target state="translated">¿Cuál es una manera eficiente de implementar un patrón de un solo tonelaje en Java</target>
        </trans-unit>
        <trans-unit id="f349af906b6a57f91d39044acff051886e44c477" translate="yes" xml:space="preserve">
          <source>What is an efficient way to implement a singleton pattern in Java?</source>
          <target state="translated">¿Cuál es una forma eficiente de implementar un patrón de singleton en Java?</target>
        </trans-unit>
        <trans-unit id="57287d24baa49f04d3f6b5f7078cfe13762fe008" translate="yes" xml:space="preserve">
          <source>When you also want to be able to serialize your object you need to make sure that deserialization won't create a copy.</source>
          <target state="translated">Cuando también quieres poder serializar tu objeto,tienes que asegurarte de que la deserialización no creará una copia.</target>
        </trans-unit>
        <trans-unit id="80541c0ebffb0d27ed0ef1c021dac3462b5a7ff4" translate="yes" xml:space="preserve">
          <source>When you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.</source>
          <target state="translated">Cuando se tiene un objeto muy grande o un código de construcción pesado Y también se tienen otros métodos o campos estáticos accesibles que podrían utilizarse antes de que se necesite una instancia,entonces y sólo entonces es necesario utilizar la inicialización perezosa.</target>
        </trans-unit>
        <trans-unit id="20ae263969c6f45c33763ef5b07b053acb1b5085" translate="yes" xml:space="preserve">
          <source>Which internally will be treated like</source>
          <target state="translated">Que internamente será tratado como</target>
        </trans-unit>
        <trans-unit id="9fc41d526f2830fe033c939964b2725da50bb8b2" translate="yes" xml:space="preserve">
          <source>While implementing Singleton we have 2 options</source>
          <target state="translated">Al implementar Singleton tenemos 2 opciones</target>
        </trans-unit>
        <trans-unit id="7943deba045650ecf620b5fc602f8e7f40df67bf" translate="yes" xml:space="preserve">
          <source>Wikipedia has some &lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;examples&lt;/a&gt; of singletons, also in Java. The Java 5 implementation looks pretty complete, and is thread-safe (double-checked locking applied).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia tiene algunos &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ejemplos&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de singletons, tambi&amp;eacute;n en Java. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La implementaci&amp;oacute;n de Java 5 parece bastante completa y es segura para subprocesos (se aplica un bloqueo de doble verificaci&amp;oacute;n).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25a9c997c2a0f10d5c983669f0d673357b7f536a" translate="yes" xml:space="preserve">
          <source>Yes this is our very same hero :)</source>
          <target state="translated">Sí,este es nuestro mismo héroe.)</target>
        </trans-unit>
        <trans-unit id="163c3ae95955d8d2c53ef90772f314e7d4a5456e" translate="yes" xml:space="preserve">
          <source>You can access it by &lt;code&gt;Singleton.INSTANCE&lt;/code&gt;, much easier than calling &lt;code&gt;getInstance()&lt;/code&gt; method on Singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede acceder mediante &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Singleton.INSTANCE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , mucho m&amp;aacute;s f&amp;aacute;cil que llamar al &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en Singleton.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="165226e14a9b8a0bc7611c1d847342885fa6b327" translate="yes" xml:space="preserve">
          <source>You can also learn the example of Singleton from Java native classes themselves.</source>
          <target state="translated">También puedes aprender el ejemplo de Singleton de las propias clases nativas de Java.</target>
        </trans-unit>
        <trans-unit id="da1cdd3c6b13c229a5cef9295f865b1db2ba6086" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;private static class&lt;/code&gt; to load the instance. The code would then look like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede usar una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para cargar la instancia. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El c&amp;oacute;digo entonces se ver&amp;iacute;a as&amp;iacute;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da8eb20a2c0def105bbda60af4028ebd2a0428ec" translate="yes" xml:space="preserve">
          <source>You need &lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;double-checking&lt;/a&gt; idiom if you need to load the instance variable of a class lazily. 
If you need to load a static variable or a singleton lazily, you need &lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;initilization on demand holder&lt;/a&gt; idiom.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Necesita &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lenguaje de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;verificaci&amp;oacute;n doble&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; si necesita cargar la variable de instancia de una clase perezosamente. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si necesita cargar una variable est&amp;aacute;tica o un singleton de manera perezosa, necesita &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; idioma de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;titularizaci&amp;oacute;n de inicializaci&amp;oacute;n bajo demanda&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7299bef205f9fbe8285ad8fd92fe078c02885760" translate="yes" xml:space="preserve">
          <source>and is it guaranteed to be thread safe.</source>
          <target state="translated">y está garantizado que el hilo es seguro.</target>
        </trans-unit>
        <trans-unit id="1dade600888158a285ff5b9f54f469f410ee1879" translate="yes" xml:space="preserve">
          <source>and you are done !!!</source>
          <target state="translated">...y estás acabado!!!</target>
        </trans-unit>
        <trans-unit id="37ad954d0f8bf18aadbea1b38b8284ba8a25ce8b" translate="yes" xml:space="preserve">
          <source>but it is not enough to protect out hero, Really!!! This is the best we can/should do to help our hero</source>
          <target state="translated">pero no es suficiente para proteger a nuestro héroe,¡¡De verdad!! Esto es lo mejor que podemos hacer para ayudar a nuestro héroe.</target>
        </trans-unit>
        <trans-unit id="9faec8995d83b9be3b7e6f2fda57cb3f6eae1310" translate="yes" xml:space="preserve">
          <source>java.awt.Desktop#getDesktop()</source>
          <target state="translated">java.awt.Desktop#getDesktop()</target>
        </trans-unit>
        <trans-unit id="feb09ab6bb59cc909d31090f3c92bfd63af74174" translate="yes" xml:space="preserve">
          <source>java.lang.Runtime#getRuntime()</source>
          <target state="translated">java.lang.Runtime#getRuntime()</target>
        </trans-unit>
        <trans-unit id="ae51ce6d9a7b1d933f6941c6e05cfe4d216830e0" translate="yes" xml:space="preserve">
          <source>java.lang.System#getSecurityManager()</source>
          <target state="translated">java.lang.System#getSecurityManager()</target>
        </trans-unit>
        <trans-unit id="3081145acbbe9e3b7e7bb4c880b445b436f215cc" translate="yes" xml:space="preserve">
          <source>simplest singleton class</source>
          <target state="translated">la clase más simple de singleton</target>
        </trans-unit>
        <trans-unit id="f3368e90e82c1f778e6130853ddc2c2df1799d82" translate="yes" xml:space="preserve">
          <source>you can use double check locking also.</source>
          <target state="translated">puedes usar el bloqueo de doble control también.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
