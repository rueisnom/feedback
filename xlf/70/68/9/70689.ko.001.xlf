<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/70689">
    <body>
      <group id="70689">
        <trans-unit id="d0e7abff310a4025796fb8127bff3a00cdf49cf9" translate="yes" xml:space="preserve">
          <source>&quot;This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, &lt;strong&gt;a single-element enum type is the best way to implement a singleton&lt;/strong&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;이 접근법은보다 간결하고 직렬화 기계를 무료로 제공하며 정교한 직렬화 또는 리플렉션 공격에도 불구하고 다중 인스턴스화에 대한 확실한 보증을 제공한다는 점을 제외하고는 공공 현장 접근법과 기능적으로 동일합니다. 아직 널리 채택되지는 않았지만, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 요소 열거 형이 싱글 톤을 구현하는 가장 좋은 방법&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d92bd02c3c63ee0ed64ba4245fb3a982d203b6" translate="yes" xml:space="preserve">
          <source>-Joshua Bloch in &quot;Effective Java&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;유효한 Java&quot;의 Joshua Bloch&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="08d9fe87472c62e1e954d12a6dac491ca298dd21" translate="yes" xml:space="preserve">
          <source>1) Enum</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) 열거 형&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2d52ad19eaadabdfadda897ef4c0d186a866fd7" translate="yes" xml:space="preserve">
          <source>1. Lazy loading</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1. 게으른 로딩&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="079dc82c2bdf9ccd588072d932c3947e40fede85" translate="yes" xml:space="preserve">
          <source>1.12    Serialization of Enum Constants</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1.12 열거 형 상수의 직렬화&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cd0140a25a4d1a85fb94d0761891417c4dc4984" translate="yes" xml:space="preserve">
          <source>2) Double checked Locking /Lazy loading</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2) 이중 잠금 / 게재&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="08f82b326d21f0209551fd37f400406131162a05" translate="yes" xml:space="preserve">
          <source>2. Early loading</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2. 초기 로딩&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c7750893106bc2853b3923c39390400fecd2f63" translate="yes" xml:space="preserve">
          <source>3) Static factory method</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) 정적 공장 방법&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ff5ef5674939ac9c059ad5c77a4b4e9f1e23eca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; I have just summarized all of the awesome answers and wrote it in my words.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;면책 조항 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 나는 모든 훌륭한 답변을 요약하고 내 말로 썼습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30628e72df671cf84d40652d24c88b86db31f004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Double checked locking&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 점검 잠금&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3195614dcff1f3528172d85cbffa6b9a4089c087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;: 
@Bno 's answer details the approach recommended by Bill Pugh (FindBugs) and is arguable better.  Go read and vote up his answer too.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집 2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : @Bno의 답변은 Bill Pugh (FindBugs)가 권장하는 접근 방식을 자세히 설명하며 논쟁의 여지가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가서 그의 답변도 투표하세요.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c62c92240dd0a4c0e46e65c24fd4c21e1a44e94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: Pay attention to the &lt;code&gt;volatile&lt;/code&gt; modifier here.  :)  It is important because without it, other threads are not guaranteed by the JMM (Java Memory Model) to see changes to its value.  The synchronization &lt;em&gt;does not&lt;/em&gt; take care of that--it only serializes access to that block of code.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;volatile&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 수정 자에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:) 그렇지 않으면 JMM (Java Memory Model)에서 다른 스레드의 값 변경을 보증하지 않으므로 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동기화 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는이&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 처리 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않으며&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해당 코드 블록에 대한 액세스 만 직렬화합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bb36a38fdf6c84e6a71484fcd968f8d949b0141b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Early loading Singleton (works even before Java 1.5)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 조기로드 (Java 1.5 이전에도 작동)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72cbea399de93731f0e7101d06f9d2d1a574c4ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; An &lt;a href=&quot;http://www.ddj.com/java/208403883?pgno=3&quot;&gt;online portion of &quot;Effective Java&quot;&lt;/a&gt; says:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집 : &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.ddj.com/java/208403883?pgno=3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Effective Java&quot;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;온라인 부분&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="307bb6f80695a03d34d6fd0a9d21d290e3ad9313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enum singleton&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형 싱글 톤&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56dddc61df291744c7df167e2ba5c4fbc619af1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good Read&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘 읽다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b768ec3d338078db9ffc311717a61b05c7f46cf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;버전 1 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed1d2772abb6c6974f7deddced2292b250baa718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;버전 2 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bda23d30aeb1eeb2070de09f96721b3c09f96127" translate="yes" xml:space="preserve">
          <source>And we have came so far, here is the best way to achieve everything we did is best possible way</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 우리는 지금까지 왔으며, 우리가 한 모든 것을 달성하는 가장 좋은 방법은 최선의 방법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38bb16500de69328e3b17998a373f42c6fa738bb" translate="yes" xml:space="preserve">
          <source>Another argument often used against Singletons are their testability problems. Singletons are not easily mockable for testing purposes. If this turns out to be a problem, I like to make the following slight modification:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤에 대해 종종 사용되는 또 다른 주장은 테스트 가능성 문제입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤은 테스트 목적으로 쉽게 조롱 할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 문제로 판명되면 다음과 같이 약간 수정하고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a305003db33fc59491a9b2510c4cad977d2c3c3" translate="yes" xml:space="preserve">
          <source>Another problem with conventional Singletons are that once you implement &lt;code&gt;Serializable&lt;/code&gt; interface, they no longer remain Singleton because &lt;code&gt;readObject()&lt;/code&gt; method always return a new instance  like constructor in Java. This can be avoided by using &lt;code&gt;readResolve()&lt;/code&gt; and discarding newly created instance by replacing with singleton like below</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적인 Singleton의 또 다른 문제점은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인터페이스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 구현 한 후에는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObject()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드가 항상 Java의 생성자와 같은 새 인스턴스를 반환 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하기 때문에 더 이상 Singleton으로 유지되지 않는다는 것 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하고 아래와 같이 싱글 톤으로 교체하여 새로 생성 된 인스턴스를 삭제 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 피할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81316ae241d3865f37b7d5da2e372416ecd88025" translate="yes" xml:space="preserve">
          <source>As per Joshua Bloch - Enum would be the best.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joshua Bloch에 따르면 Enum이 가장 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c3778d4d24f299f28881cec97f7840ac08f30c0" translate="yes" xml:space="preserve">
          <source>As the double checking pattern is not guaranteed to work (due to some issue with compilers, I don't know anything more about that.), you could also try to synchronize the whole getInstance-method or create a registry for all your Singletons.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 검사 패턴이 작동한다고 보장되지 않기 때문에 (컴파일러의 일부 문제로 인해 더 이상 아무것도 모릅니다) 전체 getInstance 메소드를 동기화하거나 모든 싱글 톤에 대한 레지스트리를 만들 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b23dd736696f30fd3946f179df3014700e480a54" translate="yes" xml:space="preserve">
          <source>As we have added the Synchronized keyword before getInstance, we have avoided the race condition in the case when two threads call the getInstance at the same time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getInstance 앞에 Synchronized 키워드를 추가 했으므로 두 스레드가 동시에 getInstance를 호출하는 경우 경쟁 조건을 피했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9872f9d1cf5a148d81f6618ffcfb77b475ddd945" translate="yes" xml:space="preserve">
          <source>But this implementation has a problem. Multi-threaded applications will have a race condition on the creation of the single instance. If multiple threads of execution hit the getInstance() method at (or around) the same time, they will each see the INSTANCE member as null. This will result in each thread creating a new MySingleton instance and subsequently setting the INSTANCE member.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나이 구현에는 문제가 있습니다. 멀티 스레드 애플리케이션은 단일 인스턴스 생성시 경쟁 조건을 갖습니다. 여러 실행 스레드가 동시에 getInstance () 메소드에 도달하면 각각 INSTANCE 멤버가 널로 표시됩니다. 이로 인해 각 스레드는 새 MySingleton 인스턴스를 작성하고 INSTANCE 멤버를 설정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bffec330193be3f47d3dd37823b7f72184fbd13" translate="yes" xml:space="preserve">
          <source>But this simple change comes at a cost. Because we are bypassing the CPU cache, we will take a performance hit each time we operate on the volatile INSTANCE member &amp;mdash; which we do 4 times. We double-check existence (1 and 2), set the value (3), and then return the value (4). One could argue that this path is the fringe case as we only create the instance during the first call of the method. Perhaps a performance hit on creation is tolerable. But even our main use-case, reads, will operate on the volatile member twice. Once to check existence, and again to return its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나이 간단한 변화는 비용이 듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 CPU 캐시를 우회하기 때문에 휘발성 INSTANCE 멤버 (4 번)에서 작업 할 때마다 성능이 저하됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;존재 (1과 2)를 다시 확인하고 값 (3)을 설정 한 다음 값 (4)을 반환합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드를 처음 호출 할 때만 인스턴스를 생성하므로이 경로가 프린지 케이스라고 주장 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 창조에 대한 성능 저하는 용납 될 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 우리의 주요 사용 사례 인 읽기조차도 휘발성 멤버에서 두 번 작동합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 번 존재를 확인하고 다시 값을 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17e7851eae8628811d4f175deed2ffc97753ae75" translate="yes" xml:space="preserve">
          <source>Depending on the usage, there are several &quot;correct&quot; answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용법에 따라 몇 가지 &quot;올바른&quot;답변이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6376ee8d7ecb240ca2e7ac33a3adc4bc45c9c27e" translate="yes" xml:space="preserve">
          <source>Double-checked locking and the Singleton pattern</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 점검 잠금 및 싱글 톤 패턴&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db9d8df06d494bd593e263605d3d29426f3aacc6" translate="yes" xml:space="preserve">
          <source>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, &lt;code&gt;ObjectOutputStream&lt;/code&gt; writes the value returned by the enum constant's name method. To deserialize an enum constant, &lt;code&gt;ObjectInputStream&lt;/code&gt; reads the constant name from the stream; the deserialized constant is then obtained by calling the &lt;code&gt;java.lang.Enum.valueOf&lt;/code&gt; method, passing the constant's enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형 상수는 일반 직렬화 가능 객체 또는 외부화 가능 객체와 다르게 직렬화됩니다. 열거 형 상수의 직렬화 된 형식은 이름으로 만 구성됩니다. 상수의 필드 값은 양식에 없습니다. 열거 형 상수를 직렬화하기 위해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectOutputStream&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 열거 형 상수의 이름 메소드에서 리턴 한 값을 기록합니다. 열거 형 상수를 직렬화 해제하기 위해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ObjectInputStream&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 스트림에서 상수 이름을 읽습니다. deserialized 상수는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Enum.valueOf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 호출 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 상수의 열거 형과 함께 수신 된 상수 이름을 인수로 전달하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;얻습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 다른 직렬화 가능 객체 또는 외부화 가능 객체와 마찬가지로 열거 형 상수는 직렬화 스트림에 이후에 나타나는 역 참조 대상으로 작동 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ceb04d0bf6d359988aa55fd0ab46e6fbd0ac88d" translate="yes" xml:space="preserve">
          <source>Enums, Singletons and Deserialization</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형, 싱글 톤 및 역 직렬화&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad7444993cf50fd2b00245cc896506e7174251b7" translate="yes" xml:space="preserve">
          <source>Even inner static class can be used.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부 정적 클래스도 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8407c8536a920696620341c8d56ee215bf8ab27" translate="yes" xml:space="preserve">
          <source>Everything is good except its early loaded singleton. Lets try lazy loaded singleton</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기로드 된 싱글 톤을 제외한 모든 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게으른로드 된 싱글 톤을 시도 할 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13c1641e1e78a21a27ed901675c0fb58e566e905" translate="yes" xml:space="preserve">
          <source>Examples of GoF Design Patterns in Java's core libraries</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 핵심 라이브러리의 GoF 디자인 패턴 예&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="694f20fe271ac257cf93f8c43bbc55ae37aea518" translate="yes" xml:space="preserve">
          <source>Finally we have added enough protection  against threads and serialization but our code is looking bulky and ugly. Lets give our hero a make over</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 스레드와 직렬화에 대한 충분한 보호 기능을 추가했지만 코드가 거대하고보기 흉해 보입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리의 영웅에게 화장을 줄 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="669d1ad80c1897dcc9c350b124bcb770181e306a" translate="yes" xml:space="preserve">
          <source>Following are 3 different approaches</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 3 가지 접근 방식입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87c36aa5ed8b30192f0a868029407fecc727cc10" translate="yes" xml:space="preserve">
          <source>For JSE 5.0 and above take the Enum approach, otherwise use static singleton holder approach ( (a lazy loading approach described by Bill Pugh). Latter solution is also thread-safe without requiring special language constructs (i.e. volatile or synchronized).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSE 5.0 이상의 경우 Enum 방식을 사용하고, 그렇지 않으면 정적 싱글 톤 홀더 방식 (Bill Pugh가 설명하는 게으른 로딩 방식)을 사용하십시오. 이후 솔루션은 특수 언어 구성 (예 : 휘발성 또는 동기화)이 없어도 스레드로부터 안전합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b9714e50bd4daa7b29e38926f2d72e66aa42aa0" translate="yes" xml:space="preserve">
          <source>For details :  &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 내용은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea40150d9fb3a40c99b1e699a4f5bc78fddf39bf" translate="yes" xml:space="preserve">
          <source>Forget &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_initialization&quot;&gt;lazy initialization&lt;/a&gt;, it's too problematic. This is the simplest solution:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게으른 초기화를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 잊어 버려 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;너무 문제가 많습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 가장 간단한 해결책입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59059ebb0b7402bf9c92da6476af7654cefbc8a2" translate="yes" xml:space="preserve">
          <source>From the best answer's &quot;Singleton&quot; section,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 좋은 답변의 &quot;Singleton&quot;섹션에서&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="625479fdef81f36c1ab97a359b96e9e84c247479" translate="yes" xml:space="preserve">
          <source>Have a look at this post.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 게시물을 살펴보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c84fb11ab9057630b8bfa9b38aec5ad9e99c0a2" translate="yes" xml:space="preserve">
          <source>Here we have the MySingleton class which has a private static member called INSTANCE, and a public static method called getInstance(). The first time getInstance() is called, the INSTANCE member is null. The flow will then fall into the creation condition and create a new instance of the MySingleton class. Subsequent calls to getInstance() will find that the INSTANCE variable is already set, and therefore not create another MySingleton instance. This ensures there is only one instance of MySingleton which is shared among all callers of getInstance().</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에는 INSTANCE라는 개인 정적 멤버와 getInstance ()라는 공개 정적 메서드가있는 MySingleton 클래스가 있습니다. getInstance ()가 처음 호출 될 때 INSTANCE 멤버는 널입니다. 그러면 플로우가 작성 조건에 들어가고 MySingleton 클래스의 새 인스턴스가 작성됩니다. 이후의 getInstance () 호출은 INSTANCE 변수가 이미 설정되어 있으므로 다른 MySingleton 인스턴스를 작성하지 않습니다. 이렇게하면 getInstance ()의 모든 호출자간에 공유되는 MySingleton 인스턴스가 하나만있게됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e5384598935f29c9b1e729f63a7964aa522e9b7" translate="yes" xml:space="preserve">
          <source>Here we issue another check from INSIDE the block. If the INSTANCE member has already been set, we&amp;rsquo;ll skip initialization. This is called double-checked locking.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 우리는 블록 내부에서 또 다른 검사를 발행합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;INSTANCE 멤버가 이미 설정된 경우 초기화를 건너 뜁니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 이중 점검 잠금이라고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4d2ad2ed1e46d507a87415c705db9a38a9c8631" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve moved synchronization from the method signature, to a synchronized block that wraps the creation of the MySingleton instance. But does this solve our problem? Well, we are no longer blocking on reads, but we&amp;rsquo;ve also taken a step backward. Multiple threads will hit the getInstance() method at or around the same time and they will all see the INSTANCE member as null. They will then hit the synchronized block where one will obtain the lock and create the instance. When that thread exits the block, the other threads will contend for the lock, and one by one each thread will fall through the block and create a new instance of our class. So we are right back where we started.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에서는 메소드 서명에서 MySingleton 인스턴스 작성을 래핑하는 동기화 된 블록으로 동기화를 이동했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이것이 우리의 문제를 해결합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 우리는 더 이상 읽기를 차단하지 않지만, 한 걸음 뒤로 물러났습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 스레드가 동시에 또는 거의 동시에 getInstance () 메소드에 도달하고 모두 INSTANCE 멤버가 널로 표시됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 동기화 된 블록에 도달하여 잠금을 획득하고 인스턴스를 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 스레드가 블록을 종료하면 다른 스레드가 잠금을 위해 경쟁하고 각 스레드가 하나씩 블록을 통과하여 클래스의 새 인스턴스를 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 우리는 시작한 곳으로 돌아 왔습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="df8f4dd0518f2a157d601eef2563a409c8be073f" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve used the synchronized keyword in the method signature to synchronize the getInstance() method. This will certainly fix our race condition. Threads will now block and enter the method one at a time. But it also creates a performance problem. Not only does this implementation synchronize the creation of the single instance, it synchronizes all calls to getInstance(), including reads. Reads do not need to be synchronized as they simply return the value of INSTANCE. Since reads will make up the bulk of our calls (remember, instantiation only happens on the first call), we will incur an unnecessary performance hit by synchronizing the entire method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서는 메소드 서명에서 synchronized 키워드를 사용하여 getInstance () 메소드를 동기화했습니다. 이것은 확실히 우리의 경쟁 조건을 해결합니다. 스레드는 이제 한 번에 하나씩 메소드를 차단하고 입력합니다. 그러나 성능 문제도 발생합니다. 이 구현은 단일 인스턴스 작성을 동기화 할뿐만 아니라 읽기를 포함하여 getInstance ()에 대한 모든 호출을 동기화합니다. 읽기는 단순히 INSTANCE 값을 반환하기 때문에 동기화 할 필요가 없습니다. 읽기는 대부분의 호출을 구성하므로 (인스턴스화는 첫 번째 호출에서만 발생 함을 명심하십시오) 전체 메소드를 동기화하여 불필요한 성능 저하가 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78bce48dfe4ac1df6adfc647b4139137aa6d82ec" translate="yes" xml:space="preserve">
          <source>I still think after java 1.5, enum is the best available singleton implementation available as it also ensures that even in the multi threaded environments - only one instance is created.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 1.5 이후에도 enum은 사용 가능한 최상의 싱글 톤 구현이며 멀티 스레드 환경에서도 하나의 인스턴스 만 생성되도록 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="889368f1848c86a7463020ef822a9db09e8274ba" translate="yes" xml:space="preserve">
          <source>I use the Spring Framework to manage my singletons.  It doesn't enforce the &quot;singleton-ness&quot; of the class (which you can't really do anyway if there are multiple class loaders involved) but provides a really easy way to build and configure different factories for creating different types of objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스프링 프레임 워크를 사용하여 싱글 톤을 관리합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스의 &quot;단일성&quot;을 강요하지는 않지만 (여러 클래스 로더가 포함 된 경우 실제로는 수행 할 수 없음) 서로 다른 유형의 오브젝트를 작성하기 위해 서로 다른 팩토리를 빌드하고 구성하는 정말 쉬운 방법을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed23e9e9e4913fecc55d825c0498fb0496c7f8a6" translate="yes" xml:space="preserve">
          <source>I would say Enum singleton</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 Enum singleton이라고 말할 것입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afa6bc6c9963a7910bf3a4b45b55b520b11cb54d" translate="yes" xml:space="preserve">
          <source>I wrote an article about this recently. &lt;a href=&quot;https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5&quot;&gt;Deconstructing The Singleton&lt;/a&gt;. You can find more info on these examples and an example of the &quot;holder&quot; pattern there. There is also a real-world example showcasing the double-checked volatile approach. Hope this helps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최근에 이것에 관한 기사를 썼습니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 해체&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 예에 대한 자세한 정보와 &quot;홀더&quot;패턴의 예를 찾을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 점검 휘발성 접근 방식을 보여주는 실제 사례도 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도움이 되었기를 바랍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab17279cd20fd4b1687c230a64664d6a72159390" translate="yes" xml:space="preserve">
          <source>I'm mystified by some of the answers that suggest DI as an alternative to using singletons; these are unrelated concepts. You can use DI to inject either singleton or non-singleton (e.g. per-thread) instances. At least this is true if you use Spring 2.x, I can't speak for other DI frameworks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 싱글 톤을 사용하는 것에 대한 대안으로 DI를 제안하는 답변 중 일부에 대해 신비합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이들은 관련이없는 개념입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DI를 사용하여 싱글 톤 또는 비 싱글 톤 (예 : 스레드 당) 인스턴스를 주입 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring 2.x를 사용하는 경우 적어도 이것이 사실입니다. 다른 DI 프레임 워크에 대해서는 말할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="577011040f77feb24314bebcebb9dd9fde8ba1ea" translate="yes" xml:space="preserve">
          <source>If you do not need lazy loading then simply try</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게으른 로딩이 필요하지 않으면 간단히 시도하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="710c65236f4c85b7918088ab9764fa4fe32f4e52" translate="yes" xml:space="preserve">
          <source>If you really need one then wikipedia has a good example of a proper implementation of a singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정말로 필요한 경우 wikipedia에는 ​​싱글 톤의 올바른 구현에 대한 좋은 예가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6577d11ba941eea89cd233d6d86c997fce516f3c" translate="yes" xml:space="preserve">
          <source>If you want lazy loading and you want your Singleton to be thread-safe, try the double-checking pattern</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게으른 로딩을 원하고 Singleton을 스레드로부터 안전하게하려면 이중 확인 패턴을 사용해보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3855b5c69e8ee65b0b5745f601e591577ad0129" translate="yes" xml:space="preserve">
          <source>If you want to code a &amp;ldquo;classic&amp;rdquo; singleton that works in a multithreaded environment (starting from Java 1.5) you should use this one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레드 환경 (Java 1.5에서 시작)에서 작동하는 &quot;클래식&quot;싱글 톤을 코딩하려면이 것을 사용해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d8270ca97b87f403744a722f1dc68510486cf68" translate="yes" xml:space="preserve">
          <source>In addition, if the singleton needs to be seriliazble, all other fields needs to be transient and readResolve() method needs to be implemented in order to maintain the singleton object invariant. Otherwise, each time the object is deserialized, a new instance of the object will be created. What readResolve() does is replace the new object read by readObject(), which forced that new object to be garbage collected as there is no variable referring to it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 싱글 톤이 서비스 가능해야하는 경우 다른 모든 필드는 일시적이어야하며 싱글 톤 객체를 불변으로 유지하려면 readResolve () 메소드를 구현해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않으면 객체가 직렬화 해제 될 때마다 객체의 새 인스턴스가 작성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;readResolve ()가하는 것은 readObject ()가 읽은 새로운 객체를 대체하는 것인데,이 객체를 참조하는 변수가 없기 때문에 새로운 객체를 가비지 수집해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c7d8c92f19b91f623b57babd3358dff0e0040f4a" translate="yes" xml:space="preserve">
          <source>It supports lazy initialization</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게으른 초기화를 지원합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebcba64c45c23ff901884aec98da59f574d38bb0" translate="yes" xml:space="preserve">
          <source>It's easy to forget the volatile statement and difficult to understand why it is necessary. Without the volatile this code would not be thread safe anymore due to the double-checked locking antipattern. See more about this in paragraph 16.2.4 of &lt;a href=&quot;http://jcip.net/&quot;&gt;Java Concurrency in Practice&lt;/a&gt;. In short: This pattern (prior to Java5.0 or without the volatile statement) could return a reference to the Bar object that is (still) in an incorrect state.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;변덕스러운 진술을 잊기 쉽고 그것이 왜 필요한지 이해하기 어렵다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;휘발성이 없으면이 코드는 이중 점검 잠금 반 패턴으로 인해 더 이상 스레드로부터 안전하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이에 대한 자세한 내용은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://jcip.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Concurrency in Practice의&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 16.2.4 단락을 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한마디로 :이 패턴 (Java5.0 이전 또는 휘발성 명령문이없는)은 잘못된 상태에있는 Bar 오브젝트에 대한 참조를 리턴 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aed94d32746ef6f2b1030893cf2c63e4473de7b9" translate="yes" xml:space="preserve">
          <source>It's generic and reusable</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적이며 재사용 가능&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80ce64e9d168cca4d45ad01dd786a3a3d622a3eb" translate="yes" xml:space="preserve">
          <source>It's only synchronized until it has been initialized, then the blocking supplier is replaced with a non-blocking supplier.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기화 될 때까지만 동기화 된 다음 차단 공급 업체가 비 차단 공급 업체로 교체됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="449c13963dfa95bddabe3876c74d3b40442953df" translate="yes" xml:space="preserve">
          <source>Joshua Bloch explained this approach in his &lt;a href=&quot;http://sites.google.com/site/io/effective-java-reloaded&quot;&gt;Effective Java Reloaded&lt;/a&gt; talk at Google I/O 2008: &lt;a href=&quot;http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s&quot;&gt;link to video&lt;/a&gt;. Also see slides 30-32 of his presentation (&lt;a href=&quot;https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&amp;amp;attredirects=0&quot;&gt;effective_java_reloaded.pdf&lt;/a&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joshua Bloch는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Google I / O 2008에서의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sites.google.com/site/io/effective-java-reloaded&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;효과적인 Java Reloaded&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 강연에서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비디오에 대한 링크&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서이 접근 방식을 설명했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그의 프레젠테이션 30-32 슬라이드 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&amp;amp;attredirects=0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;effective_java_reloaded.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="793c23aca34d846cb2973e2995675836910ca030" translate="yes" xml:space="preserve">
          <source>Lazy loading adds bit overhead(lots of to be honest) so use it only when you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.Otherwise choosing early loading is a good choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게으른 로딩은 비트 오버 헤드 (많은 솔직함)를 추가하므로 매우 큰 객체 또는 무거운 구성 코드가 있고 인스턴스가 필요하기 전에 사용할 수있는 다른 액세스 가능한 정적 메소드 또는 필드가있는 경우에만 사용하십시오 초기 로딩을 선택하는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02fefdeb69ee5d29a7c948927ea167ebab436a0f" translate="yes" xml:space="preserve">
          <source>Lazy loading, thread safe with blocking, low performance because of &lt;code&gt;synchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지연 로딩, 블로킹으로 스레드 안전, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;synchronized&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인한 낮은 성능 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d407b886496d8e0094a35acef4bd5685c8ff45f" translate="yes" xml:space="preserve">
          <source>Lazy loading, thread safe with non-blocking, high performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지연없는 로딩, 비 차단, 고성능 스레드 안전.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f54e23f25888e8257c17de0c8827649ac27396d2" translate="yes" xml:space="preserve">
          <source>Let's go over the code. First, you want the class to be final. In this case, I've used the &lt;code&gt;final&lt;/code&gt; keyword to let the users know it is final. Then you need to make the constructor private to prevent users to create their own Foo. Throwing an exception from the constructor prevents users to use reflection to create a second Foo. Then you create a &lt;code&gt;private static final Foo&lt;/code&gt; field to hold the only instance, and a &lt;code&gt;public static Foo getInstance()&lt;/code&gt; method to return it. The Java specification makes sure that the constructor is only called when the class is first used.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드를 살펴 봅시다. 먼저, 당신은 수업이 마무리되기를 원합니다. 이 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;final&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 키워드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 사용자에게 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최종&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 키워드를 알 렸습니다. 그런 다음 사용자가 자신의 Foo를 만들지 못하도록 생성자를 비공개로 만들어야합니다. 생성자에서 예외를 throw하면 사용자가 리플렉션을 사용하여 두 번째 Foo를 만들 수 없습니다. 그런 다음 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 유일한 인스턴스를 보유하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;public static Foo getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드를 작성하여 리턴하십시오. Java 스펙은 생성자가 클래스를 처음 사용할 때만 호출되도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9c873dc1a8784c864c5dd3081fbf40b67576f0d" translate="yes" xml:space="preserve">
          <source>Make it part of your DI configuration whether your dependencies are singletons, request scoped, session scoped, or whatever.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;종속성이 싱글 톤인지, 요청 범위, 세션 범위 등 무엇이든 DI 구성의 일부로 만드십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd66bccb948073440dd0db12f2ca6e04f0d6a6dc" translate="yes" xml:space="preserve">
          <source>Make sure that you really need it. Do a google for &quot;singleton anti-pattern&quot; to see some arguments against it. There's nothing inherently wrong with it I suppose but it's just a mechanism for exposing some global resource/data so make sure that this is the best way. In particular I've found dependency injection more useful particularly if you are also using unit tests because DI allows you to use mocked resources for testing purposes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 필요한지 확인하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이에 대한 몇 가지 주장을 보려면 &quot;단일 안티 패턴&quot;에 대한 Google을 수행하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;본질적으로 잘못된 점은 없지만 전 세계 리소스 / 데이터를 노출하는 메커니즘 일뿐이므로 이것이 최선의 방법인지 확인하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히 DI가 테스트 목적으로 조롱 된 리소스를 사용할 수 있기 때문에 단위 테스트를 사용하는 경우 특히 종속성 주입이 더 유용하다는 것을 알았습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cf1fc929b39778cf9f0128785173350eab34054" translate="yes" xml:space="preserve">
          <source>Might be a little late to the game on this, but there is a lot of nuance around implementing a singleton. The holder pattern can not be used in many situations. And IMO when using a volatile - you should also use a local variable. Let's start at the beginning and iterate on the problem. You'll see what I mean.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것에 대해 게임에 약간 늦을 수도 있지만 싱글 톤을 구현하는 데 많은 뉘앙스가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;홀더 패턴은 여러 상황에서 사용할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;휘발성을 사용할 때 IMO-로컬 변수도 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처음부터 시작하여 문제를 반복합시다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 내가 무슨 뜻인지 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a476004e24909d4497d2c94b9c51634c0fb9800" translate="yes" xml:space="preserve">
          <source>Most simple way of implementing Singleton is</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤을 구현하는 가장 간단한 방법은&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="684056e9a0e6e7d9bfae63756efde4ae038ff5d9" translate="yes" xml:space="preserve">
          <source>Now we are sure about evil thread but what about the cruel serialization? We have to make sure even while de-serialiaztion no new object is created</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 우리는 사악한 스레드에 대해 확신하지만 잔인한 직렬화는 어떻습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de-serialization이 새 개체를 만들지 않아도 확인해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9484e9bddcf6bf03ecbdd460165f19a93ef91143" translate="yes" xml:space="preserve">
          <source>Now what happens? The class is loaded via the class loader. Directly after the class was interpreted from a byte Array, the VM executes the &lt;strong&gt;static { }&lt;/strong&gt; - block. that's the whole secret: The static-block is only called once, the time the given class (name) of the given package is loaded by this one class loader.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 어떻게됩니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스는 클래스 로더를 통해로드됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바이트 배열에서 클래스가 해석 된 직후 VM은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 {}&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -블록을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실행합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 비밀입니다. 정적 블록은 한 번만 호출되며, 주어진 패키지의 주어진 클래스 (이름)가이 하나의 클래스 로더에 의해로드 된 시간입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7e283fe450ff620ebec87128aa5b3eb6c0c2f057" translate="yes" xml:space="preserve">
          <source>Now you might have realized why ENUMS are considered as best way to implement Singleton and thanks for your patience :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 ENUMS가 Singleton을 구현하는 가장 좋은 방법으로 간주되는 이유를 알게되었으므로 양해 해 주셔서 감사합니다. :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e20b619471537c9fdf4fce2cd0526492d4dbf263" translate="yes" xml:space="preserve">
          <source>On the other hand you would have to synchronize any method that instantiates the singleton variable as such. Synchronisation is not bad as such, but it can lead to performance issues or locking (in very very rare situations using this example. The solution is</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 싱글 톤 변수를 인스턴스화하는 모든 메소드를 동기화해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동기화는 그렇게 나쁘지는 않지만 성능 문제 또는 잠금을 유발할 수 있습니다 (이 예를 사용하는 매우 드문 상황)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e192152615641c437ec6823a4905298484aa4fcd" translate="yes" xml:space="preserve">
          <source>Personally I try to avoid singletons as often as possible for many reasons, again most of which can be found by googling singletons. I feel that quite often singletons are abused because they're easy to understand by everybody, they're used as a mechanism for getting &quot;global&quot; data into an OO design and they are used because it is easy to circumvent object lifecycle management (or really thinking about how you can do A from inside B). Look at things like Inversion of Control (IoC) or Dependency Injection (DI) for a nice middleground.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인적으로 나는 여러 가지 이유로 가능한 한 자주 싱글 톤을 피하려고 노력하며, 대부분은 인터넷 검색 싱글 톤으로 찾을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 사람들이 이해하기 쉽기 때문에 싱글 톤이 남용되는 경우가 많으며, &quot;글로벌&quot;데이터를 OO 디자인으로 가져 오기위한 메커니즘으로 사용되며 객체 수명주기 관리를 우회하기 쉽기 때문에 사용됩니다. 실제로 B 내부에서 A를 수행하는 방법에 대해 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중간 정도의 제어를 위해 IoC (Inversion of Control) 또는 DI (Dependency Injection)와 같은 것을 살펴보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e5603ff1860ef0178d46a84735151ebbc81412b" translate="yes" xml:space="preserve">
          <source>Pre java5, the most simple case is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pre java5에서 가장 간단한 경우는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60cf150afaede3481521c6a09f00d10fa2b78c34" translate="yes" xml:space="preserve">
          <source>Quoted from Oracle docs</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오라클 문서에서 인용&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35da73343bd35c600a36425fc3769d474da87faf" translate="yes" xml:space="preserve">
          <source>Really consider why you need a singleton before writing it. There is a quasi-religious debate about using them which you can quite easily stumble over if you google singletons in Java.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성하기 전에 왜 싱글 톤이 필요한지 고려하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바에서 구글 싱글 톤을 사용하는 경우 쉽게 넘어 질 수있는 그것들을 사용하는 것에 대한 유사 종교적 논쟁이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4b911bd10db59f7158b81f9dff1479d45dabc42" translate="yes" xml:space="preserve">
          <source>See below:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래를보십시오 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="144acf1b25f939cc5a71dac3e66a60314aa55a25" translate="yes" xml:space="preserve">
          <source>Since java5 the best way to do it is to use an enum:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;java5부터 가장 좋은 방법은 열거 형을 사용하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08f78b4f933e670f21e1a2a72f765390500cf67" translate="yes" xml:space="preserve">
          <source>Since the line &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; is only executed when the class &lt;code&gt;FooLoader&lt;/code&gt; is actually used, this takes care of the lazy instantiation,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라인 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;FooLoader&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 실제로 사용될 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때만 실행 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되며, 게으른 인스턴스화를 처리합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc6c6e20bf4d28fc65ba4aa328fe47d239aea652" translate="yes" xml:space="preserve">
          <source>Since the line &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라인 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final Foo INSTANCE = new Foo();&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 FooLoader가 실제로 사용될 때만 실행되며, 지연 인스턴스화를 처리하고 스레드 안전을 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fa48287c77b71caf8e74418a2ae9c9d8f0b884f" translate="yes" xml:space="preserve">
          <source>Since the performance hit is due to operating directly on the volatile member, let&amp;rsquo;s set a local variable to the value of the volatile and operate on the local variable instead. This will decrease the number of times we operate on the volatile, thereby reclaiming some of our lost performance. Note that we have to set our local variable again when we enter the synchronized block. This ensures it is up to date with any changes that occured while we were waiting for the lock.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능 적중은 휘발성 멤버에서 직접 작동하기 때문에 로컬 변수를 휘발성 값으로 설정하고 대신 로컬 변수에서 작동합시다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 휘발성에 대한 작업 횟수가 줄어들어 일부 손실 된 성능이 회복됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동기화 된 블록에 들어갈 때 로컬 변수를 다시 설정해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 잠금을 기다리는 동안 발생한 모든 변경 사항이 최신 상태로 유지됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4036b3be660b1f0e9d9c15b854523b4c11df6c63" translate="yes" xml:space="preserve">
          <source>Singleton (recognizeable by creational methods returning the same instance (usually of itself) everytime)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 (매번 동일한 인스턴스 (보통 자체)을 리턴하는 작성 메소드로 인식 가능)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b01dd5022b1a1f15d490b388905b81ca48501f60" translate="yes" xml:space="preserve">
          <source>Singleton Pattern</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 패턴&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3690b32d31a6ee5fca52025e9ed22a94485b652a" translate="yes" xml:space="preserve">
          <source>Singleton using enum in Java is generally way to declare enum singleton. Enum singleton may contain instance variable and instance method. For simplicity's sake, also note that if you are using any instance method than you need to ensure thread safety of that method if at all it affect the state of object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서 enum을 사용하는 싱글 톤은 일반적으로 enum 싱글 톤을 선언하는 방법입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형 싱글 톤에는 인스턴스 변수와 인스턴스 메소드가 포함될 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단하게하기 위해 인스턴스 메소드를 사용하는 경우 해당 메소드의 스레드 안전성을 보장해야하는 경우보다 오브젝트의 상태에 영향을주는 경우가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="52b2eff37dbeec148fff787e7ff7e6de02054d3d" translate="yes" xml:space="preserve">
          <source>So far so good but our hero will not survive while fighting alone with multiple evil threads who want many many instance of our hero.
So lets protect it from evil multi threading</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지금까지는 좋지만 우리의 영웅은 많은 영웅을 원하는 여러 악의 실과 혼자 싸우면서 생존하지 못합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사악한 멀티 스레딩으로부터 보호하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a431deea175954e157c5356235834f7184a5c3d9" translate="yes" xml:space="preserve">
          <source>So my answer to the OP would be (in all but the most trivial sample code) to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 OP에 대한 나의 대답은 (가장 간단한 샘플 코드를 제외하고) 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9825624dff86ece92a2bc0d1f8028de08b5275e" translate="yes" xml:space="preserve">
          <source>Sometimes a simple &quot;&lt;strong&gt;&lt;code&gt;static Foo foo = new Foo();&lt;/code&gt;&lt;/strong&gt;&quot; is not enough. Just think of some basic data insertion you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때로는 단순한 &quot; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;static Foo foo = new Foo();&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로는&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 충분하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이하고 싶은 몇 가지 기본 데이터 삽입을 생각하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1cf01eb108e908af4fc931855b27b85753afa4b3" translate="yes" xml:space="preserve">
          <source>Still, for the possibility of mockup-testing (when needed), this code exposure may be an acceptable price to pay.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여전히 모형 테스트 (필요한 경우)의 가능성을 위해이 코드 노출은 허용되는 가격이 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7637ce39b2a6ccf5b15f95d3348e1a81e9a82645" translate="yes" xml:space="preserve">
          <source>That's it! No more fear of serialization, threads and ugly code. Also &lt;a href=&quot;https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized&quot;&gt;&lt;strong&gt;ENUMS singleton are lazily initialized&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그게 다야! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 직렬화, 스레드 및 못생긴 코드에 대한 두려움이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ENUMS 싱글 톤은 느리게 초기화&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f67dd2a7db1a7c3fc3cc6101abf4ed21718573ce" translate="yes" xml:space="preserve">
          <source>The Right Way to Implement a Serializable Singleton</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직렬화 가능한 싱글 톤을 구현하는 올바른 방법&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3e18ec47297de814755ec714fb91e212a427942" translate="yes" xml:space="preserve">
          <source>The added &lt;code&gt;setInstance&lt;/code&gt; method allows setting a mockup implementation of the singleton class during testing:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추가 된 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setInstance&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드를 사용하면 테스트 중에 싱글 톤 클래스의 모형 구현을 설정할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4521b53cdada5013dc77f66248a6b2ee60f1f330" translate="yes" xml:space="preserve">
          <source>The best singleton pattern I've ever seen uses the Supplier interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 본 최고의 싱글 톤 패턴은 공급 업체 인터페이스를 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="992c69cb4926f648d77809fc7bae30df43dd03fb" translate="yes" xml:space="preserve">
          <source>The first attempt might look something like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 시도는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62a5fcdcf2c0644557b079b56916db57c90e3b1b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readResolve()&lt;/code&gt; will make sure the only instance will be returned, even when the object was serialized in a previous run of our program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 객체가 이전 프로그램 실행에서 직렬화 된 경우에도 유일한 인스턴스가 반환되도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a3cda2ac2d8449008fdb6ba3f67bdcaa4ef8e56" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readResolve()&lt;/code&gt; will make sure the only instance will be returned, even when the object was serialized in a previous run of your program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 객체가 프로그램의 이전 실행에서 직렬화 된 경우에도 유일한 인스턴스가 반환되도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d051f06d522a538ce7b8be3c8c2b7e2852f29b98" translate="yes" xml:space="preserve">
          <source>The process by which enum constants are serialized cannot be customized: any class-specific &lt;code&gt;writeObject&lt;/code&gt;, &lt;code&gt;readObject&lt;/code&gt;, &lt;code&gt;readObjectNoData&lt;/code&gt;, &lt;code&gt;writeReplace&lt;/code&gt;, and &lt;code&gt;readResolve&lt;/code&gt; methods defined by enum types are ignored during serialization and deserialization. Similarly, any &lt;code&gt;serialPersistentFields&lt;/code&gt; or &lt;code&gt;serialVersionUID&lt;/code&gt; field declarations are also ignored--all enum types have a fixed &lt;code&gt;serialVersionUID&lt;/code&gt; of &lt;code&gt;0L&lt;/code&gt;. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형 상수를 직렬화하는 프로세스는 사용자 정의 할 수 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 직렬화 및 역 직렬화에서는 열거 형에 의해 정의 된 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 별 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writeObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readObjectNoData&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;writeReplace&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;readResolve&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드가 무시됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마찬가지로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialPersistentFields&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialVersionUID&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드 선언도 무시됩니다. 모든 열거 형 유형의 고정 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;serialVersionUID&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0L&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전송 된 데이터 유형에 변동이 없으므로 열거 형 유형에 대한 직렬화 가능 필드 및 데이터를 문서화 할 필요가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88232c86e9921f355cbedefbf606e1ec4b0222cb" translate="yes" xml:space="preserve">
          <source>The simplest way to implement a Singleton that is thread-safe is using an Enum</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드로부터 안전한 싱글 톤을 구현하는 가장 간단한 방법은 Enum을 사용하는 것입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="324fafbf3dd017a25265072d69c1504f6acc9259" translate="yes" xml:space="preserve">
          <source>The solution posted by Stu Thompson is valid in Java5.0 and later. But I would prefer not to use it because I think it is error prone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Stu Thompson이 게시 한 솔루션은 Java5.0 이상에서 유효합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 오류가 발생하기 쉽다고 생각하기 때문에 사용하지 않는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edd7245e8448aa583319dd5b5f37ca9516437706" translate="yes" xml:space="preserve">
          <source>The use of an enum is very easy to implement and has no drawbacks regarding serializable objects, which have to be circumvented in the other ways.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형을 사용하면 구현하기가 매우 쉽고 직렬화 가능 객체와 관련하여 단점이 없으며 다른 방식으로 우회해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b114fda2f6ec08d969eb2bb4e56a779dc3bcf423" translate="yes" xml:space="preserve">
          <source>This also works with early initialization approaches:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 초기 초기화 접근 방식에서도 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd43b28c24b9b93c4a94bb6e35e416c97e534d68" translate="yes" xml:space="preserve">
          <source>This approach gives you a nice decoupled (and therefore flexible and testable) architecture where whether to use a singleton is an easily reversible implementation detail (provided any singletons you use are threadsafe, of course).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 접근 방식은 싱글 톤을 사용할지 여부를 쉽게 되돌릴 수있는 구현 세부 사항 (물론 스레드 안전성이 제공되는 경우)으로 분리 된 (따라서 유연하고 테스트 가능한) 아키텍처를 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23a12931b83c281e5be65a44b857d308e3e4b439" translate="yes" xml:space="preserve">
          <source>This approach is functionally equivalent to the public field approach,
  except that it is more concise, provides the serialization machinery
  for free, and provides an  ironclad guarantee against multiple
  instantiation, even in the face of sophisticated serialization or
  reflection attacks. While this approach has yet to be widely  adopted,
  a single-element enum type is the best way to implement a singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 방법은보다 간결하고 직렬화 장치를 무료로 제공하며 정교한 직렬화 또는 리플렉션 공격에도 불구하고 다중 인스턴스화에 대한 확실한 보장을 제공한다는 점을 제외하고는 공공 현장 접근 방식과 기능적으로 동일합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 방법은 아직 널리 채택되지 않았지만 단일 요소 열거 형 유형이 단일 톤을 구현하는 가장 좋은 방법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fb64c36eb4df7481b8185546e14c30c29a59641" translate="yes" xml:space="preserve">
          <source>This can become even more complex if your Singleton Class maintain state, as you need to make them transient, but with in Enum Singleton, Serialization is guaranteed by JVM.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과도하게 만들어야하기 때문에 Singleton 클래스가 상태를 유지하는 경우 훨씬 더 복잡해질 수 있지만 Enum Singleton에서는 직렬화가 JVM에 의해 보장됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c43167556dc43196560c28fccf6cf8a83bd7631" translate="yes" xml:space="preserve">
          <source>This code works since the introduction of Enum in Java 1.5</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 코드는 Java 1.5에서의 Enum 도입 이후 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07783588bd4a0a5ac185259a31d40270814cbf31" translate="yes" xml:space="preserve">
          <source>This has the drawback of exposing this functionality to the normal application too. Other developers working on that code could be tempted to use the &amp;acute;setInstance&amp;acute; method to alter alter a specific function and thus changing the whole application behaviour, therefore this method should contain at least a good warning in it's javadoc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은이 기능을 일반 응용 프로그램에 노출시키는 단점도 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 코드를 작업하는 다른 개발자는 'setInstance'메소드를 사용하여 특정 기능을 변경하여 전체 애플리케이션 동작을 변경하려는 유혹을받을 수 있으므로이 메소드에는 적어도 javadoc에 대한 경고가 포함되어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f0e4dffb57ee9f672603e4caac113f7aa7a29784" translate="yes" xml:space="preserve">
          <source>This implementation instantiates the singleton when the class is loaded and provides thread safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 구현은 클래스가로드 될 때 싱글 톤을 인스턴스화하고 스레드 안전성을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3bcdfd6657ae1d877f13ff4b71f5aa0b6a1e61ca" translate="yes" xml:space="preserve">
          <source>This is called &quot;Double-Checked Locking idiom&quot;. It's easy to forget the volatile statement and difficult to understand why it is necessary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 &quot;이중 확인 잠금 관용구&quot;라고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;변덕스러운 진술을 잊기 쉽고 그것이 왜 필요한지 이해하기 어렵다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85183f87aa9e976e97a8bf574c183e173f4602d0" translate="yes" xml:space="preserve">
          <source>This is how to implement a simple &lt;code&gt;singleton&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 간단한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;singleton&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 구현하는 방법입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b7f2b8b2f3a3bb36011ef27da112effbbcca494" translate="yes" xml:space="preserve">
          <source>This is how to properly lazy create your &lt;code&gt;singleton&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;singleton&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 올바르게 게으르게 만드는 방법입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c226a0d50b9cf5f1f7f7584597d4a9bb7aa0b47" translate="yes" xml:space="preserve">
          <source>This is not thread-safe before 1.5 because the implementation of the volatile keyword was different.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;volatile 키워드의 구현이 다르기 때문에 1.5 이전의 스레드로부터 안전하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eae784989f658fbb0307199e73140ce0ea1b6ee" translate="yes" xml:space="preserve">
          <source>This pattern was invented for performance optimization. But this is really not a real concern anymore. The following lazy initialization code is fast and -more importantly- easier to read.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 패턴은 성능 최적화를 위해 고안되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이것은 더 이상 진짜 관심사가 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음의 게으른 초기화 코드는 빠르고 더 읽기 쉽습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2de7e75929ecc9f2fafb60ca0908a1d88f37e8f4" translate="yes" xml:space="preserve">
          <source>This solves our problem of multiple instantiation. But once again, our solution has presented another challenge. Other threads might not &amp;ldquo;see&amp;rdquo; that the INSTANCE member has been updated. This is because of how Java optimizes memory operations. Threads copy the original values of variables from main memory into the CPU&amp;rsquo;s cache. Changes to values are then written to, and read from, that cache. This is a feature of Java designed to optimize performance. But this creates a problem for our singleton implementation. A second thread &amp;mdash; being processed by a different CPU or core, using a different cache &amp;mdash; will not see the changes made by the first. This will cause the second thread to see the INSTANCE member as null forcing a new instance of our singleton to be created.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 통해 다중 인스턴스화 문제를 해결할 수 있습니다. 그러나 다시 한 번, 우리의 솔루션은 또 다른 도전을 제시했습니다. 다른 스레드는 INSTANCE 멤버가 업데이트되었음을 ​​&quot;보지&quot;않을 수 있습니다. 이것은 Java가 메모리 작업을 최적화하는 방법 때문입니다. 스레드는 변수의 원래 값을 기본 메모리에서 CPU의 캐시로 복사합니다. 그런 다음 값에 대한 변경 사항이 해당 캐시에 기록되고 해당 캐시에서 읽습니다. 이것은 성능을 최적화하도록 설계된 Java의 기능입니다. 그러나 이것은 싱글 톤 구현에 문제가됩니다. 다른 캐시를 사용하여 다른 CPU 또는 코어에서 처리중인 두 번째 스레드는 첫 번째 스레드의 변경 사항을 볼 수 없습니다. 그러면 두 번째 스레드가 INSTANCE 멤버를 null로 간주하여 싱글 톤의 새 인스턴스를 만듭니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3982534593f5cf37c205bccd98c6c2c2ed3e5381" translate="yes" xml:space="preserve">
          <source>Thread safe in Java 5+:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 5 이상에서 스레드 안전 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04b4f72d8a23d7425a5b14131f70d156c7dc2761" translate="yes" xml:space="preserve">
          <source>Updated it on my &lt;a href=&quot;http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html&quot;&gt;&lt;strong&gt;blog&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;블로그&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 업데이트했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9161ee3cf60f6074cfb5c48f3cb43e426db90017" translate="yes" xml:space="preserve">
          <source>Use a DI framework like Spring, then</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring과 같은 DI 프레임 워크를 사용하고&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4a5ae13c99482e816948dfcb8fe12927d55920c" translate="yes" xml:space="preserve">
          <source>Use an enum:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열거 형을 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="776cfab9b61501bc78411c540b320617fa616521" translate="yes" xml:space="preserve">
          <source>Various ways to make singleton object:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 객체를 만드는 다양한 방법 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ad13e2ae424b0243ecb89f19638cd41ed1925d8" translate="yes" xml:space="preserve">
          <source>We solve this by using the volatile keyword on the declaration of the INSTANCE member. This will tell the compiler to always read from, and write to, main memory, and not the CPU cache.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;INSTANCE 멤버 선언에 volatile 키워드를 사용하여이 문제를 해결합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 컴파일러에게 항상 CPU 캐시가 아닌 메인 메모리를 읽고 쓰도록 지시합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1bf5b3bf3c10dd18e5ebfca2eaf0228fc7fbfb5f" translate="yes" xml:space="preserve">
          <source>What is an efficient way to implement a singleton pattern in Java</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서 싱글 톤 패턴을 구현하는 효율적인 방법은 무엇입니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f349af906b6a57f91d39044acff051886e44c477" translate="yes" xml:space="preserve">
          <source>What is an efficient way to implement a singleton pattern in Java?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서 싱글 톤 패턴을 구현하는 효율적인 방법은 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57287d24baa49f04d3f6b5f7078cfe13762fe008" translate="yes" xml:space="preserve">
          <source>When you also want to be able to serialize your object you need to make sure that deserialization won't create a copy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체를 직렬화하려면 직렬화 해제로 인해 사본이 생성되지 않아야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80541c0ebffb0d27ed0ef1c021dac3462b5a7ff4" translate="yes" xml:space="preserve">
          <source>When you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체가 크거나 구성 코드가 많고 인스턴스가 필요하기 전에 사용할 수있는 다른 액세스 가능한 정적 메서드 나 필드가있는 경우에만 지연 초기화를 사용해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20ae263969c6f45c33763ef5b07b053acb1b5085" translate="yes" xml:space="preserve">
          <source>Which internally will be treated like</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떤 내부적으로 취급 될 것인가&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fc41d526f2830fe033c939964b2725da50bb8b2" translate="yes" xml:space="preserve">
          <source>While implementing Singleton we have 2 options</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤을 구현하는 동안 우리는 두 가지 옵션이 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7943deba045650ecf620b5fc602f8e7f40df67bf" translate="yes" xml:space="preserve">
          <source>Wikipedia has some &lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;examples&lt;/a&gt; of singletons, also in Java. The Java 5 implementation looks pretty complete, and is thread-safe (double-checked locking applied).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia에는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서도 싱글 톤 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예제&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 5 구현은 매우 완벽 해 보이며 스레드로부터 안전합니다 (더블 체크 잠금 적용).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25a9c997c2a0f10d5c983669f0d673357b7f536a" translate="yes" xml:space="preserve">
          <source>Yes this is our very same hero :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예, 이것은 우리의 동일한 영웅입니다 :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="163c3ae95955d8d2c53ef90772f314e7d4a5456e" translate="yes" xml:space="preserve">
          <source>You can access it by &lt;code&gt;Singleton.INSTANCE&lt;/code&gt;, much easier than calling &lt;code&gt;getInstance()&lt;/code&gt; method on Singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;Singleton.INSTANCE&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 액세스 할 수 있으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Singleton&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메서드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호출하는 것보다 훨씬 쉽습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="165226e14a9b8a0bc7611c1d847342885fa6b327" translate="yes" xml:space="preserve">
          <source>You can also learn the example of Singleton from Java native classes themselves.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 네이티브 클래스 자체에서 Singleton의 예를 배울 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da1cdd3c6b13c229a5cef9295f865b1db2ba6086" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;private static class&lt;/code&gt; to load the instance. The code would then look like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;private static class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하여 인스턴스를로드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da8eb20a2c0def105bbda60af4028ebd2a0428ec" translate="yes" xml:space="preserve">
          <source>You need &lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;double-checking&lt;/a&gt; idiom if you need to load the instance variable of a class lazily. 
If you need to load a static variable or a singleton lazily, you need &lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;initilization on demand holder&lt;/a&gt; idiom.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 필요가 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 번 확인&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관용구를 사용하면 게으르게 클래스의 인스턴스 변수를로드해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 변수 또는 싱글 톤을 느리게로드해야하는 경우 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주문형 홀더&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 관용구를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기화&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7299bef205f9fbe8285ad8fd92fe078c02885760" translate="yes" xml:space="preserve">
          <source>and is it guaranteed to be thread safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전성을 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1dade600888158a285ff5b9f54f469f410ee1879" translate="yes" xml:space="preserve">
          <source>and you are done !!!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 당신은 끝났습니다!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37ad954d0f8bf18aadbea1b38b8284ba8a25ce8b" translate="yes" xml:space="preserve">
          <source>but it is not enough to protect out hero, Really!!! This is the best we can/should do to help our hero</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 영웅을 보호하기에는 충분하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;영웅을 돕기 위해 할 수있는 최선의 방법&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9faec8995d83b9be3b7e6f2fda57cb3f6eae1310" translate="yes" xml:space="preserve">
          <source>java.awt.Desktop#getDesktop()</source>
          <target state="translated">java.awt.Desktop#getDesktop()</target>
        </trans-unit>
        <trans-unit id="feb09ab6bb59cc909d31090f3c92bfd63af74174" translate="yes" xml:space="preserve">
          <source>java.lang.Runtime#getRuntime()</source>
          <target state="translated">java.lang.Runtime#getRuntime()</target>
        </trans-unit>
        <trans-unit id="ae51ce6d9a7b1d933f6941c6e05cfe4d216830e0" translate="yes" xml:space="preserve">
          <source>java.lang.System#getSecurityManager()</source>
          <target state="translated">java.lang.System#getSecurityManager()</target>
        </trans-unit>
        <trans-unit id="3081145acbbe9e3b7e7bb4c880b445b436f215cc" translate="yes" xml:space="preserve">
          <source>simplest singleton class</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 간단한 싱글턴 클래스&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3368e90e82c1f778e6130853ddc2c2df1799d82" translate="yes" xml:space="preserve">
          <source>you can use double check locking also.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 점검 잠금도 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
