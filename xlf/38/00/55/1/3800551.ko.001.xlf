<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3800551">
    <body>
      <group id="3800551">
        <trans-unit id="8b0e51f015b82c172dc08a72abec676ab68cdcb1" translate="yes" xml:space="preserve">
          <source>&amp;forall;x T(customer,id) &amp;gt; T(customer,x) (this total is higher than all other
total for that customer)</source>
          <target state="translated">&amp;forall;x T (고객, ID)&amp;gt; T (고객, x) (이 총계는 해당 고객의 다른 총계보다 높습니다)</target>
        </trans-unit>
        <trans-unit id="9eb86ef810547924021ae07751ee563a0d148b2f" translate="yes" xml:space="preserve">
          <source>&amp;not;&amp;exist;x T(customer, id) &amp;lt; T(customer, x)   (there exists no higher total for
that customer)</source>
          <target state="translated">&amp;not;&amp;exist;x T (고객, id) &amp;lt;T (고객, x) (해당 고객에 대해 더 높은 합계는 없음)</target>
        </trans-unit>
        <trans-unit id="465adca06e7c71101cc6c980483c14bd4b5cd6ea" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;row_number()&lt;/code&gt; in CTE, (&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">1. CTE의 &lt;code&gt;row_number()&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;다른 답변 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8904cac1304e73d4439e2e0cd4fe04a5bcbbda5a" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;row_number()&lt;/code&gt; in subquery (my optimization)</source>
          <target state="translated">2. 하위 쿼리의 &lt;code&gt;row_number()&lt;/code&gt; (내 최적화)</target>
        </trans-unit>
        <trans-unit id="96334568f816862e91fdb22411296b51a9047ba9" translate="yes" xml:space="preserve">
          <source>3. &lt;code&gt;DISTINCT ON&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">3. &lt;code&gt;DISTINCT ON&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;다른 답변 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ab58eba8c40ca272a6b0399c814468cd2bf10833" translate="yes" xml:space="preserve">
          <source>4. rCTE with &lt;code&gt;LATERAL&lt;/code&gt; subquery (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">4. LATERAL 하위 쿼리가있는 &lt;code&gt;LATERAL&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;여기 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="388a20a693d53df52778b80eb7ce5e395fe52dbe" translate="yes" xml:space="preserve">
          <source>5. &lt;code&gt;customer&lt;/code&gt; table with &lt;code&gt;LATERAL&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">5. &lt;code&gt;LATERAL&lt;/code&gt; &lt;code&gt;customer&lt;/code&gt; 테이블 ( &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;여기 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="28a71a270d0b490ab8b65fcb9dd0ec0dc252b602" translate="yes" xml:space="preserve">
          <source>6. &lt;code&gt;array_agg()&lt;/code&gt; with &lt;code&gt;ORDER BY&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 와 함께 &lt;code&gt;array_agg()&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;다른 답변을 참조하십시오&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e77fc13c9b4bac378cdc79c530cff8444a76a91f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt;&lt;code&gt;DISTINCT ON&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; is a PostgreSQL extension of the standard (where only &lt;code&gt;DISTINCT&lt;/code&gt; on the whole &lt;code&gt;SELECT&lt;/code&gt; list is defined).</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt; &lt;code&gt;DISTINCT ON&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 은 표준의 PostgreSQL 확장입니다 (전체 &lt;code&gt;SELECT&lt;/code&gt; 목록에서 &lt;code&gt;DISTINCT&lt;/code&gt; 만 정의 됨).</target>
        </trans-unit>
        <trans-unit id="e5dbfddeb30f08b54049675c47334097b5e10ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DISTINCT ON&lt;/code&gt; can be combined with &lt;strong&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/strong&gt;. Leading expressions in &lt;code&gt;ORDER BY&lt;/code&gt; must be in the set of expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt;, but you can rearrange order among those freely. &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;Example.&lt;/a&gt; You can add &lt;em&gt;additional&lt;/em&gt; expressions to &lt;code&gt;ORDER BY&lt;/code&gt; to pick a particular row from each group of peers. Or, as &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;the manual puts it&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 은 &lt;strong&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/strong&gt; 와 결합 될 수 있습니다. &lt;code&gt;ORDER BY&lt;/code&gt; 의 선행 표현식은 &lt;code&gt;DISTINCT ON&lt;/code&gt; 의 표현식 세트에 있어야하지만 자유롭게 순서를 다시 정렬 할 수 있습니다. &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;예.&lt;/a&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 에 &lt;em&gt;추가&lt;/em&gt; 표현식을 추가하여 각 피어 그룹에서 특정 행을 선택할 수 있습니다. 또는 &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;매뉴얼에 따르면&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8d496993b6d839bb9dea36ac37618f3a3cee55d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; is an aggregate function, so it works with &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; 는 집계 함수이므로 &lt;code&gt;GROUP BY&lt;/code&gt; 와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0ea589215973faa22621d36017e60710d4720f84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; lets you specify an ordering scoped to just itself, so it doesn't constrain the structure of the whole query. There is also syntax for how you sort NULLs, if you need to do something different from the default.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; 를 사용하면 그 자체로 범위가 지정된 순서를 지정할 수 있으므로 전체 쿼리의 구조를 제한하지 않습니다. 기본값과 다른 작업을 수행해야하는 경우 NULL을 정렬하는 방법에 대한 구문도 있습니다.</target>
        </trans-unit>
        <trans-unit id="324791d057789de362088760368f72733ec8e3a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;customer&lt;/code&gt; table - for superior query</source>
          <target state="translated">&lt;code&gt;customer&lt;/code&gt; 테이블-우수한 쿼리</target>
        </trans-unit>
        <trans-unit id="9b6347bcc54c96a5d6afc6a91c3b2766235d6e38" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Pick the row with the smallest &lt;code&gt;id&lt;/code&gt; from each group sharing the highest &lt;code&gt;total&lt;/code&gt;.&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;각 그룹에서 가장 작은 &lt;code&gt;id&lt;/code&gt; 를 가진 행을 선택하여 가장 높은 &lt;code&gt;total&lt;/code&gt; 공유하십시오.&quot;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ef8596eaf70407a2a70716e980229133cc09244" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; queries used an &lt;strong&gt;Index Only Scan&lt;/strong&gt; on &lt;code&gt;purchases2_3c_idx&lt;/code&gt; (among other steps). Some of them just for the smaller size of the index, others more effectively.</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 쿼리는 &lt;code&gt;purchases2_3c_idx&lt;/code&gt; (다른 단계 중)에서 &lt;strong&gt;인덱스 전용 스캔&lt;/strong&gt; 을 사용했습니다. 그들 중 일부는 단지 더 작은 크기의 색인을 위해, 다른 일부는 더 효과적으로.</target>
        </trans-unit>
        <trans-unit id="ba89b37ddd35fa61a293ee1c8d26550a43e5c312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;Optimize GROUP BY query to retrieve latest row per user&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;사용자 당 최신 행을 검색하도록 GROUP BY 쿼리 최적화&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce0fdf92dae6576eb974a49b5cfb0cacb7bf8227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to SQL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SQL로 돌아 가기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5ae4ba7872bce65b6f09a8ef56edcc82bcf22b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: the &lt;code&gt;using (...)&lt;/code&gt; clause is currently not supported in MS-SQL and Oracle db as of this edit on Jan 2017. You have to expand it yourself to e.g. &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; etc.  The USING syntax works in SQLite, MySQL and PostgreSQL.</source>
          <target state="translated">&lt;strong&gt;주의 사항&lt;/strong&gt; : &lt;code&gt;using (...)&lt;/code&gt; 절은 현재 2017 년 1 월 편집에서 MS-SQL 및 Oracle db에서 지원되지 않습니다. 예를 들어 &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; 등 으로 직접 확장해야합니다. USING 구문 SQLite, MySQL 및 PostgreSQL에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ed70ea16198c5d6d45b8fbf0ed2b70660f594b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예상 출력 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f6f14e2b0acb25bca7f5a61efae0972b838c25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HOW DOES THAT WORK!&lt;/strong&gt; (I've been there)</source>
          <target state="translated">&lt;strong&gt;작동하는 방법!&lt;/strong&gt; (나 거기 가봤 어)</target>
        </trans-unit>
        <trans-unit id="919ebd27c03cd325e823c752933e84712e574cd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;My Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;내 결과 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddcfd8371e55c2c354271ed9883696c5245698b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some Theoretical Stuff&lt;/strong&gt; (skip this part if you only want to understand the query)</source>
          <target state="translated">&lt;strong&gt;일부 이론적 내용&lt;/strong&gt; (쿼리 만 이해하려는 경우이 부분을 생략)</target>
        </trans-unit>
        <trans-unit id="bbf1697f55b063038beadb0181046028cc7cdf1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;SELECT&lt;/code&gt; list&lt;/strong&gt; is not constrained by expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; in any way. (Not needed in the simple case above):</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;SELECT&lt;/code&gt; 리스트&lt;/strong&gt; 는 어떤 식 으로든 &lt;code&gt;DISTINCT ON&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 의 표현식으로 제한되지 않습니다. (위의 간단한 경우에는 필요하지 않음) :</target>
        </trans-unit>
        <trans-unit id="20c7b5fd52a03a8d3c11b5edcf49e361b626b681" translate="yes" xml:space="preserve">
          <source>A. Postgres 9.4 with 200k rows and ~ 20 per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">A. Postgres 9.4 (200k 행 및 &lt;code&gt;customer_id&lt;/code&gt; 당 ~ 20)</target>
        </trans-unit>
        <trans-unit id="d8f970457bbe96b6e3501f8789c7b9f915513e61" translate="yes" xml:space="preserve">
          <source>And that's the answer we need.</source>
          <target state="translated">그리고 그것이 우리가 필요로하는 답변입니다.</target>
        </trans-unit>
        <trans-unit id="e23feb77084817360c7083a788a14965fc076e58" translate="yes" xml:space="preserve">
          <source>As the title suggests, I'd like to select the first row of each set of rows grouped with a &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">제목에서 알 수 있듯이 &lt;code&gt;GROUP BY&lt;/code&gt; 그룹화 된 각 행 집합의 첫 번째 행을 선택하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="8b1bd75cf1de2fdedb624fae5aa55e8a18adac06" translate="yes" xml:space="preserve">
          <source>B. The same with Postgres 9.5</source>
          <target state="translated">B. Postgres 9.5와 동일</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="52825791dd909cc4202b88eeaef7b54ec3becfa8" translate="yes" xml:space="preserve">
          <source>Bold emphasis mine.</source>
          <target state="translated">대담한 강조 광산.</target>
        </trans-unit>
        <trans-unit id="17aca40b4c23fbfe02d34fb72e4c61a9292f08d4" translate="yes" xml:space="preserve">
          <source>But if you wanna to do such things you probably looking for &lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">그러나 그런 일을하고 싶다면 아마도 &lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;창 기능을&lt;/a&gt; 찾고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9fbf6bba2ca0f73231f0d374c9c473e11adbfc0" translate="yes" xml:space="preserve">
          <source>But you need to add logic to break ties:</source>
          <target state="translated">그러나 관계를 끊기 위해 논리를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b0bad02864780888057ce496e6b9fabc038f2aa" translate="yes" xml:space="preserve">
          <source>C. Same as B., but with ~ 2.3 rows per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">C. B.와 동일하지만 &lt;code&gt;customer_id&lt;/code&gt; 당 ~ 2.3 행</target>
        </trans-unit>
        <trans-unit id="4f2ab710e696b3feb525a155fedbbf8f5f5c12ea" translate="yes" xml:space="preserve">
          <source>CAVEAT: It ignore's NULL rows</source>
          <target state="translated">주의 사항 : NULL 행을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a687cecffae4f0c8632214b84368c59a2e6e7153" translate="yes" xml:space="preserve">
          <source>Comparing &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies'&lt;/a&gt; first query (&lt;strong&gt;&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;) to the &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;above &lt;code&gt;DISTINCT ON&lt;/code&gt; solution&lt;/a&gt; (&lt;strong&gt;&lt;code&gt;B&lt;/code&gt;&lt;/strong&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies의&lt;/a&gt; 첫 번째 쿼리 ( &lt;strong&gt; &lt;code&gt;A&lt;/code&gt; &lt;/strong&gt; )를 &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;위의 &lt;code&gt;DISTINCT ON&lt;/code&gt; 솔루션&lt;/a&gt; ( &lt;strong&gt; &lt;code&gt;B&lt;/code&gt; &lt;/strong&gt; )과 비교 :</target>
        </trans-unit>
        <trans-unit id="acd80818ac5bcea9c24fdae3e88fceaa5145fe2c" translate="yes" xml:space="preserve">
          <source>Configuration parameter work_mem in PostgreSQL on Linux</source>
          <target state="translated">Linux에서 PostgreSQL의 구성 매개 변수 work_mem</target>
        </trans-unit>
        <trans-unit id="7fe2e8c8108bab0f14186604f0961d23506e1bc6" translate="yes" xml:space="preserve">
          <source>Dummy data, PK, index - a typical table also has some dead tuples:</source>
          <target state="translated">더미 데이터, PK, 인덱스-일반적인 테이블에는 죽은 튜플이 있습니다.</target>
        </trans-unit>
        <trans-unit id="174c079c51c262737b6aa7163fe40695d570268e" translate="yes" xml:space="preserve">
          <source>Edit 1 - Use the postgres extension instead</source>
          <target state="translated">편집 1-대신 postgres 확장을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="fce82fa3164babb13876442255a3ad8934a0e437" translate="yes" xml:space="preserve">
          <source>Edit 2 - Ordering and filtering</source>
          <target state="translated">편집 2-주문 및 필터링</target>
        </trans-unit>
        <trans-unit id="75737715bd2086a23ae530d9cc64724b33734c1e" translate="yes" xml:space="preserve">
          <source>Effectiveness / Performance optimization</source>
          <target state="translated">효과 / 성능 최적화</target>
        </trans-unit>
        <trans-unit id="ad6c60c32c0a2398914d7e2f0d2c91d41fd6fbf6" translate="yes" xml:space="preserve">
          <source>Execution time for above queries with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; (and all options &lt;em&gt;off&lt;/em&gt;), &lt;em&gt;best of 5 runs&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; (및 모든 옵션 &lt;em&gt;해제&lt;/em&gt; )를 사용하여 위의 쿼리에 대한 실행 시간 &lt;em&gt;은 5 회 중 최고입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64d9744934093551048060bf300f0c928c0bed3f" translate="yes" xml:space="preserve">
          <source>Explaination:Here  &lt;strong&gt;Group by&lt;/strong&gt; is done on the basis of customer and then order it by total then each such group is given serial number as StRank and we are taking out first 1 customer whose StRank is 1</source>
          <target state="translated">설명 : 여기에 &lt;strong&gt;의해 그룹화&lt;/strong&gt; 는 고객을 기준으로 수행 한 다음 총계로 주문 한 다음 각 그룹에 StRank와 같은 일련 번호가 부여되며 StRank가 1 인 첫 번째 고객 1 명을 꺼내고 있습니다</target>
        </trans-unit>
        <trans-unit id="67f4bc89bd0ee8c2f20b19ee9c93d80b26582d05" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;few&lt;/em&gt; rows per customer&lt;/strong&gt; (high cardinality in column &lt;code&gt;customer&lt;/code&gt;), this is very efficient. Even more so if you need sorted output anyway. The benefit shrinks with a growing number of rows per customer.</source>
          <target state="translated">&lt;strong&gt;고객 당 행 수가 적 으면&lt;/strong&gt; (컬럼 &lt;code&gt;customer&lt;/code&gt; 의 높은 카디널리티) 매우 효율적입니다. 어쨌든 정렬 된 출력이 필요한 경우 더욱 그렇습니다. 고객 당 행 수가 늘어 나면 혜택이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="e7c26ad56f293277760cdbfe5b97e01026505b3d" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;many&lt;/em&gt; rows per customer&lt;/strong&gt; (low cardinality in column &lt;code&gt;customer&lt;/code&gt;), a &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;loose index scan&lt;/strong&gt;&lt;/a&gt; (a.k.a. &quot;skip scan&quot;) would be (much) more efficient, but that's not implemented up to Postgres 12. (An implementation for index-only scans is in development for Postgres 13. See &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">&lt;strong&gt;고객 당 &lt;em&gt;많은&lt;/em&gt; 행&lt;/strong&gt; (열 &lt;code&gt;customer&lt;/code&gt; 카디널리티가 낮음)의 경우 &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;느슨한 인덱스 스캔&lt;/strong&gt;&lt;/a&gt; (일명 &quot;건너 뛰기 스캔&quot;)이 훨씬 효율적이지만 Postgres 12까지는 구현되지 않습니다. (인덱스 전용 스캔의 구현은 Postgres 13 개발 중입니다. &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;여기&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3573651362ae5e478981982b3b1e27c37c25fabf" translate="yes" xml:space="preserve">
          <source>For Postgres 9.5 I ran a 2nd test with effectively 86446 distinct customers. See below (&lt;em&gt;avg. 2.3 rows per customer&lt;/em&gt;).</source>
          <target state="translated">Postgres 9.5의 경우 효과적으로 86446 명의 개별 고객을 대상으로 2 차 테스트를 실시했습니다. 아래를 참조하십시오 ( &lt;em&gt;고객 당 평균 2.3 행&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="5885b552b6ab83e07125a70548b0c986996b8178" translate="yes" xml:space="preserve">
          <source>For SQl Server the most efficient way is:</source>
          <target state="translated">SQl Server의 경우 가장 효율적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fa33ded2a46b10ad416ee2d3ffc070fa4d90ff9" translate="yes" xml:space="preserve">
          <source>For now, there are &lt;strong&gt;faster query techniques&lt;/strong&gt; to substitute for this. In particular if you have a separate table holding unique customers, which is the typical use case. But also if you don't:</source>
          <target state="translated">현재로서는이를 대체 할 &lt;strong&gt;빠른 쿼리 기술&lt;/strong&gt; 이 있습니다. 특히 고유 한 고객을 보유하는 별도의 테이블이있는 경우 이는 일반적인 사용 사례입니다. 그러나 그렇지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="adc98243acc2f50c6cd9268d1a23bdb2ac5b1062" translate="yes" xml:space="preserve">
          <source>Generated with &lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;this query&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;이 쿼리로&lt;/a&gt; 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="01d1b9a5f5078d105e1cc0eaa95c676eae08b4ea" translate="yes" xml:space="preserve">
          <source>Here I provide a same-approach, but more complete and clean any-database solution.   Ties are considered (assume desire to get only one row for each customer, even multiple records for max total per customer), and other purchase fields (e.g. purchase_payment_id) will be selected for the real matching rows in the purchase table.</source>
          <target state="translated">여기서는 동일한 접근 방식을 제공하지만 더 완벽하고 깨끗한 모든 데이터베이스 솔루션을 제공합니다. 동점을 고려하고 (각 고객 당 하나의 행만 가져 오려고하고, 고객 당 최대 총계까지 여러 레코드를 확보하려는 경우) 구매 테이블의 실제 일치하는 행에 대해 다른 구매 필드 (예 : purchase_payment_id)가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3129050964ca90864ffa2acb569e107645deb0" translate="yes" xml:space="preserve">
          <source>Here is a new one by &quot;ogr&quot; testing with &lt;strong&gt;10M rows and 60k unique &quot;customers&quot;&lt;/strong&gt; on &lt;strong&gt;Postgres 11.5&lt;/strong&gt; (current as of Sep. 2019). Results are still in line with what we have seen so far:</source>
          <target state="translated">다음은 &lt;strong&gt;Postgres 11.5&lt;/strong&gt; (2019 년 9 월 현재)에서 &lt;strong&gt;10M 개의 행과 60k의 고유 한 &quot;고객&quot;&lt;/strong&gt; 을 사용한 &quot;ogr&quot;테스트에 의한 새로운 것입니다. 결과는 여전히 우리가 지금까지 본 것과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f098395b6ea6fcdc083ec3a7f6ea0975316c1705" translate="yes" xml:space="preserve">
          <source>I added &lt;code&gt;id&lt;/code&gt; as last item to break ties:</source>
          <target state="translated">관계를 끊기 위해 마지막 항목으로 &lt;code&gt;id&lt;/code&gt; 를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c90b5abd370bd36ee6b7906498a63b93f5448bf7" translate="yes" xml:space="preserve">
          <source>I created a composite &lt;code&gt;(id, total)&lt;/code&gt;, so both values are returned by the same aggregate. You can of course always apply &lt;code&gt;first_value()&lt;/code&gt; twice.</source>
          <target state="translated">복합 &lt;code&gt;(id, total)&lt;/code&gt; 만들었으므로 두 값이 모두 동일한 집계로 반환됩니다. 물론 항상 &lt;code&gt;first_value()&lt;/code&gt; 두 번 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="130b1834e42433119953b32cd075fdef4902f9c6" translate="yes" xml:space="preserve">
          <source>I had a simple benchmark here which is outdated by now. I replaced it with a &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;detailed benchmark in this separate answer&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">나는 여기에 오래된 벤치 마크가 있습니다. &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;이 별도의 답변에서 자세한 벤치 마크로&lt;/strong&gt;&lt;/a&gt; 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="e09671f3bd26252ac5be9d0a7116458ae0d8bc22" translate="yes" xml:space="preserve">
          <source>I ran three tests with PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt; on a real life table of 65579 rows and single-column btree indexes on each of the three columns involved and took the best &lt;em&gt;execution time&lt;/em&gt; of 5 runs.</source>
          <target state="translated">PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt; 을 사용하여 65579 행의 실제 테이블과 관련된 세 열 각각의 단일 열 btree 인덱스에서 세 가지 테스트를 &lt;em&gt;실행&lt;/em&gt; 했으며 5 번의 &lt;em&gt;실행 시간&lt;/em&gt; 을 가장 잘 &lt;em&gt;수행했습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50ef525b77740b26d2f800be1f31dc196cd1a5b7" translate="yes" xml:space="preserve">
          <source>I tested with Postgres versions 8.3 &amp;ndash; 12. But the feature has been there at least since version 7.1, so basically always.</source>
          <target state="translated">Postgres 버전 8.3 &amp;ndash; 12로 테스트했습니다. 그러나이 기능은 최소한 버전 7.1 이후 기본적으로 항상 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="63fe6b185c7bbea3849dd47a10061ff96c0bd0d6" translate="yes" xml:space="preserve">
          <source>I use a &lt;code&gt;serial&lt;/code&gt; (PK constraint added below) and an integer &lt;code&gt;customer_id&lt;/code&gt; since that's a more typical setup. Also added &lt;code&gt;some_column&lt;/code&gt; to make up for typically more columns.</source>
          <target state="translated">더 일반적인 설정이므로 &lt;code&gt;serial&lt;/code&gt; (아래에 추가 된 PK 제약 조건)과 정수 &lt;code&gt;customer_id&lt;/code&gt; 를 사용합니다. 또한 일반적으로 더 많은 열을 보충하기 위해 &lt;code&gt;some_column&lt;/code&gt; 을 추가 했습니다 .</target>
        </trans-unit>
        <trans-unit id="e6eee036e14e840a888fce846d96052e9490f45f" translate="yes" xml:space="preserve">
          <source>I use this way (postgresql only): &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&lt;/a&gt;</source>
          <target state="translated">이 방법을 사용합니다 (postgresql 만 해당) : &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="058e05d7a94c12abe5d88dcda3d94f529d56876e" translate="yes" xml:space="preserve">
          <source>I'd like to query for the &lt;code&gt;id&lt;/code&gt; of the largest purchase (&lt;code&gt;total&lt;/code&gt;) made by each &lt;code&gt;customer&lt;/code&gt;. Something like this:</source>
          <target state="translated">각 &lt;code&gt;customer&lt;/code&gt; 구매 한 최대 구매 ( &lt;code&gt;total&lt;/code&gt; ) &lt;code&gt;id&lt;/code&gt; 를 문의하고 싶습니다. 이 같은:</target>
        </trans-unit>
        <trans-unit id="49e5ca82598636f91cd9a8e958c6a1d9a9469aa9" translate="yes" xml:space="preserve">
          <source>Ideally, you have enough &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to process the involved sort step in RAM and not spill to disk. But generally setting &lt;code&gt;work_mem&lt;/code&gt;&lt;em&gt;too&lt;/em&gt; high can have adverse effects. Consider &lt;code&gt;SET LOCAL&lt;/code&gt; for exceptionally big queries. Find how much you need with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;. Mention of &quot;&lt;em&gt;Disk:&lt;/em&gt;&quot; in the sort step indicates the need for more:</source>
          <target state="translated">이상적으로는 RAM의 관련 정렬 단계를 처리하고 디스크에 유출되지 않는 &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 이 충분합니다. 그러나 일반적으로 &lt;code&gt;work_mem&lt;/code&gt; 을 &lt;em&gt;너무&lt;/em&gt; 높게 설정 하면 부작용이 발생할 수 있습니다. 매우 큰 쿼리에는 &lt;code&gt;SET LOCAL&lt;/code&gt; 을 고려하십시오. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 로 필요한 금액을 찾으십시오. 정렬 단계에서 &quot; &lt;em&gt;Disk :&lt;/em&gt; &quot;라고 언급하면 ​​다음 사항이 더 필요합니다.</target>
        </trans-unit>
        <trans-unit id="115e7329106b556464ad2183dc9b3466d332e3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL (won't hurt either way, but you'll want to &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;match existing indexes&lt;/a&gt;):</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; 이 NULL 일 수있는 경우 (어느 쪽도 다 치지 않지만 &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;기존 인덱스와 일치&lt;/a&gt; 시키려는 경우) :</target>
        </trans-unit>
        <trans-unit id="885869bd8bb57ffb30ae77b739b5f2d997c205b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL, you &lt;em&gt;most probably&lt;/em&gt; want the row with the greatest non-null value. Add &lt;strong&gt;&lt;code&gt;NULLS LAST&lt;/code&gt;&lt;/strong&gt; like demonstrated. See:</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; 이 NULL 일 수있는 경우 널이 아닌 값이 가장 큰 행을 원할 &lt;em&gt;것입니다&lt;/em&gt; . 설명 된 것처럼 &lt;strong&gt; &lt;code&gt;NULLS LAST&lt;/code&gt; 를 마지막에&lt;/strong&gt; 추가하십시오. 보다:</target>
        </trans-unit>
        <trans-unit id="f3ff0102a461bc45f392997d6b4457df923ab8d8" translate="yes" xml:space="preserve">
          <source>If we left joins the table on the name and total being less than the joined table:</source>
          <target state="translated">이름에 테이블을 조인하고 합계가 조인 된 테이블보다 작은 경우 :</target>
        </trans-unit>
        <trans-unit id="1bc90c6679c8f97e7e0ae81bc6b9546fcda369ac" translate="yes" xml:space="preserve">
          <source>If you use aggregate functions (like these), you can order the results, without the need to have the data already ordered:</source>
          <target state="translated">이와 같은 집계 함수를 사용하는 경우 데이터를 이미 주문하지 않아도 결과를 주문할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513b52421e643bf265232a5b0303884aee1f29a9" translate="yes" xml:space="preserve">
          <source>If you want to select any (by your some specific condition) row from the set of aggregated rows.</source>
          <target state="translated">집계 된 행 세트에서 특정 조건에 따라 행을 선택하려는 경우.</target>
        </trans-unit>
        <trans-unit id="14f29bfc41c897a3e227d298f67de89585505bbf" translate="yes" xml:space="preserve">
          <source>If you want to use another (&lt;code&gt;sum/avg&lt;/code&gt;) aggregation function in addition to &lt;code&gt;max/min&lt;/code&gt;. Thus you can not use clue with &lt;code&gt;DISTINCT ON&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;max/min&lt;/code&gt; 외에 다른 ( &lt;code&gt;sum/avg&lt;/code&gt; ) 집계 함수를 사용하려는 경우. 따라서 &lt;code&gt;DISTINCT ON&lt;/code&gt; 으로 실마리를 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="95f04d79bc6e9f1a1a378d50e9a21929eef79e61" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PostgreSQL&lt;/strong&gt; this is typically &lt;strong&gt;simpler and faster&lt;/strong&gt; (more performance optimization below):</source>
          <target state="translated">&lt;strong&gt;PostgreSQL&lt;/strong&gt; 에서는 일반적으로이 방법이 &lt;strong&gt;더 간단하고 빠릅니다&lt;/strong&gt; (아래에 더 성능 최적화).</target>
        </trans-unit>
        <trans-unit id="3030a2fec9c767d8ff7ccbf769b9e4f47aa7fac4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, another possibility is to use the &lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt;&lt;code&gt;first_value&lt;/code&gt;&lt;/a&gt; window function in combination with &lt;code&gt;SELECT DISTINCT&lt;/code&gt;:</source>
          <target state="translated">PostgreSQL에서 또 다른 가능성은 &lt;code&gt;SELECT DISTINCT&lt;/code&gt; 와 함께 &lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt; &lt;code&gt;first_value&lt;/code&gt; &lt;/a&gt; 창 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70b88621817cca0608b7dda4ed35638f90c58d08" translate="yes" xml:space="preserve">
          <source>In Postgres you can use &lt;code&gt;array_agg&lt;/code&gt; like this:</source>
          <target state="translated">Postgres에서는 다음과 같이 &lt;code&gt;array_agg&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b958a892b980456789c653c74f646b5dec93aaf4" translate="yes" xml:space="preserve">
          <source>In SQL Server you can do this:</source>
          <target state="translated">SQL Server에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaadf570b7bb1e4a6396c6bcba18cbed9639f58a" translate="yes" xml:space="preserve">
          <source>In my &lt;strong&gt;second test&lt;/strong&gt; for 9.5 I used the same setup, but with &lt;code&gt;random() * 100000&lt;/code&gt; to generate &lt;code&gt;customer_id&lt;/code&gt; to get only few rows per &lt;code&gt;customer_id&lt;/code&gt;.</source>
          <target state="translated">9.5에 대한 &lt;strong&gt;두 번째 테스트&lt;/strong&gt; 에서 동일한 설정을 사용했지만 &lt;code&gt;random() * 100000&lt;/code&gt; 으로 &lt;code&gt;customer_id&lt;/code&gt; 를 생성하여 customer_id 당 몇 행만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="76ff0109afd7a40bd9c16251d32e49ec91dea601" translate="yes" xml:space="preserve">
          <source>It's a postgres extension that gives you first and last functions; apparently faster than the above way.</source>
          <target state="translated">첫 번째 기능과 마지막 기능을 제공하는 postgres 확장입니다. 분명히 위의 방법보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d991a62bb10a62ed754485867ff0e408d74d7e89" translate="yes" xml:space="preserve">
          <source>Let Total be a function T(customer,id) where it returns a value given the name and id
To prove that the given total (T(customer,id)) is the highest we have to prove that
We want to prove either</source>
          <target state="translated">Total을 이름과 ID가 주어진 값을 반환하는 함수 T (customer, id)로하자. 주어진 총계 (T (customer, id))가 우리가 어느 쪽이든 증명하고 싶다는 것을 증명해야하는 최고임을 증명하기 위해</target>
        </trans-unit>
        <trans-unit id="2e5632d0f807b3f34cf7f69dec1047fe433b911d" translate="yes" xml:space="preserve">
          <source>List any number of expressions in the &lt;code&gt;DISTINCT ON&lt;/code&gt; clause, the combined row value defines duplicates. &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;The manual:&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 절에 여러 표현식을 나열하십시오. 결합 된 행 값은 중복을 정의합니다. &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;매뉴얼 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="464f7790b102ce69cf3acd7d69f43f9a52b82086" translate="yes" xml:space="preserve">
          <source>Main table</source>
          <target state="translated">메인 테이블</target>
        </trans-unit>
        <trans-unit id="9e85255a09c56ff34c3fc3aaf30b6b3e8b91258b" translate="yes" xml:space="preserve">
          <source>Major points</source>
          <target state="translated">주요 포인트</target>
        </trans-unit>
        <trans-unit id="d12153394231071e15cd8c3b11dfb9916cc27f28" translate="yes" xml:space="preserve">
          <source>May be too specialized. But use it if read performance for the particular query is crucial. If you have &lt;code&gt;DESC NULLS LAST&lt;/code&gt; in the query, use the same in the index so that sort order matches and the index is applicable.</source>
          <target state="translated">너무 전문적 일 수 있습니다. 그러나 특정 쿼리에 대한 읽기 성능이 중요한 경우 사용하십시오. 쿼리에 &lt;code&gt;DESC NULLS LAST&lt;/code&gt; 가 있으면 정렬 순서가 일치하고 인덱스를 적용 할 수 있도록 인덱스에서 동일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dfff4eefffc08fe064edf770d418be997d8af5cd" translate="yes" xml:space="preserve">
          <source>Note that bunch of solutions to this common problem can surprisingly be found in the one of most official sources, &lt;strong&gt;MySQL manual&lt;/strong&gt;! See &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;Examples of Common Queries :: The Rows Holding the Group-wise Maximum of a Certain Column&lt;/a&gt;.</source>
          <target state="translated">이 일반적인 문제에 대한 많은 솔루션은 놀랍게도 가장 공식적인 소스 중 하나 인 &lt;strong&gt;MySQL 매뉴얼&lt;/strong&gt; 에서 찾을 수 &lt;strong&gt;있습니다&lt;/strong&gt; ! &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;일반적인 쿼리 예 :: 특정 열의 그룹 별 최대 값을 유지하는 행을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df659bc5a4cb564a96f76217ff3e2438b57ef8b7" translate="yes" xml:space="preserve">
          <source>Now I use this way: &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http://pgxn.org/dist/first_last_agg/&lt;/a&gt;</source>
          <target state="translated">이제이 방법을 사용합니다 : &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http://pgxn.org/dist/first_last_agg/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="ae8661bf223d4e024221cc558b5e2889d1ab01aa" translate="yes" xml:space="preserve">
          <source>Object sizes for table &lt;code&gt;purchases&lt;/code&gt;</source>
          <target state="translated">테이블 &lt;code&gt;purchases&lt;/code&gt; 위한 객체 크기</target>
        </trans-unit>
        <trans-unit id="0c3894fd7032a7b8b88d3da5aa8a3469655ef31d" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least
  one column value. &lt;strong&gt;Null values are considered equal in this comparison.&lt;/strong&gt;</source>
          <target state="translated">분명히 하나 이상의 열 값이 다르면 두 개의 행이 구별되는 것으로 간주됩니다. &lt;strong&gt;이 비교에서 널값은 동일한 것으로 간주됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="311285b287ae794f8a6e6e16f340d4537b8dfbc1" translate="yes" xml:space="preserve">
          <source>Of course you can order and filter as you deem fit within the aggregate; it's very powerful syntax.</source>
          <target state="translated">물론 골재 내에 맞는 것으로 주문하고 필터링 할 수 있습니다. 매우 강력한 구문입니다.</target>
        </trans-unit>
        <trans-unit id="982f7546a2eb8df6633eb73d3e3883d3525fe955" translate="yes" xml:space="preserve">
          <source>On Oracle 9.2+ (not 8i+ as originally stated), SQL Server 2005+, PostgreSQL 8.4+, DB2, Firebird 3.0+, Teradata, Sybase, Vertica:</source>
          <target state="translated">Oracle 9.2+ (원래 언급 한대로 8i + 아님)에서 SQL Server 2005+, PostgreSQL 8.4+, DB2, Firebird 3.0+, Teradata, Sybase, Vertica :</target>
        </trans-unit>
        <trans-unit id="0ea92a1813c9ad07657cdc2ac29023c0cbfc39c1" translate="yes" xml:space="preserve">
          <source>Once we build the array, we take the first element. (Postgres arrays are 1-indexed, not 0-indexed).</source>
          <target state="translated">배열을 빌드하면 첫 번째 요소를 가져옵니다. (Postgres 어레이는 0 인덱스가 아닌 1 인덱스입니다.)</target>
        </trans-unit>
        <trans-unit id="b8a1b609b59584ecf9bb25c6e8bacdb3704cca90" translate="yes" xml:space="preserve">
          <source>Optimize groupwise maximum query</source>
          <target state="translated">그룹 별 최대 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="bf017f217553f1cf968db1e65b41af2ab992d2d5" translate="yes" xml:space="preserve">
          <source>Optimize simple query using ORDER BY date and text</source>
          <target state="translated">ORDER BY 날짜 및 텍스트를 사용하여 간단한 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="a67837359416b99ab5311803744d610256a22309" translate="yes" xml:space="preserve">
          <source>Or shorter (if not as clear) with ordinal numbers of output columns:</source>
          <target state="translated">또는 순서 번호의 출력 열이 더 짧거나 (명확하지 않은 경우) :</target>
        </trans-unit>
        <trans-unit id="24fa5a2c8e0b4079cb5f9fe868a9bd59518f7bc4" translate="yes" xml:space="preserve">
          <source>Original (outdated) benchmark from 2011</source>
          <target state="translated">2011 년의 원래 (오래된) 벤치 마크</target>
        </trans-unit>
        <trans-unit id="323c83c0f69c9372d7ee234ccace23a4e5de3ce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL sort by datetime asc, null first?</source>
          <target state="translated">PostgreSQL을 datetime asc로 정렬하면 먼저 null입니까?</target>
        </trans-unit>
        <trans-unit id="b244b2217c8b6c534f37d1f03cf14604ed7ba5e5" translate="yes" xml:space="preserve">
          <source>Proper way to access latest row for each individual identifier?</source>
          <target state="translated">각 개별 식별자에 대한 최신 행에 액세스하는 올바른 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="0b8a47b88d837280e3fab94fe4d2bd803b3c158f" translate="yes" xml:space="preserve">
          <source>Query last N related rows per row</source>
          <target state="translated">행당 마지막 N 관련 행 쿼리</target>
        </trans-unit>
        <trans-unit id="e8536401a76da15c6c761038b81a6fa0d744d0c4" translate="yes" xml:space="preserve">
          <source>Related benchmarks</source>
          <target state="translated">관련 벤치 마크</target>
        </trans-unit>
        <trans-unit id="a88f66d2299b63003d3d871345537088ff79ce05" translate="yes" xml:space="preserve">
          <source>Remark:</source>
          <target state="translated">Remark:</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="ba1151ed7036215586ab2deb08df3dd651d11cd8" translate="yes" xml:space="preserve">
          <source>Same test repeated with the index described in the other answer</source>
          <target state="translated">다른 답변에 설명 된 색인으로 동일한 테스트를 반복했습니다.</target>
        </trans-unit>
        <trans-unit id="02fa4b7c2eb7288cc2dd7860b97e7fcc7c3c81d0" translate="yes" xml:space="preserve">
          <source>Select a single customer with &lt;code&gt;WHERE customer = x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE customer = x&lt;/code&gt; 단일 고객을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="253368c0449de38cab696b8fe6b4a86a8b102762" translate="yes" xml:space="preserve">
          <source>Select first row in each GROUP BY group</source>
          <target state="translated">각 GROUP BY 그룹에서 첫 번째 행을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="584e375ddcb38e2b1f417648316c35cf906dbf11" translate="yes" xml:space="preserve">
          <source>Select the whole table, results in 5958 rows in this case.</source>
          <target state="translated">이 경우 전체 테이블을 선택하면 결과는 5958 행입니다.</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="25075eb661f7180b5138442fe9b8c1612f5add01" translate="yes" xml:space="preserve">
          <source>Snowflake/Teradata supports &lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt;&lt;code&gt;QUALIFY&lt;/code&gt;&lt;/a&gt; clause which works like &lt;code&gt;HAVING&lt;/code&gt; for windowed functions:</source>
          <target state="translated">Snowflake / Teradata는 윈도우 함수에 대한 &lt;code&gt;HAVING&lt;/code&gt; 과 같은 &lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt; &lt;code&gt;QUALIFY&lt;/code&gt; &lt;/a&gt; 절을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a77cdea121464bd8808b2f7a4d983ddee817a186" translate="yes" xml:space="preserve">
          <source>So the equivalent example, with ordering would be something like:</source>
          <target state="translated">따라서 순서가있는 동등한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe91dbd517e1619f524c6cc3d78de6f788ca2326" translate="yes" xml:space="preserve">
          <source>Some things to note:</source>
          <target state="translated">참고할 사항 :</target>
        </trans-unit>
        <trans-unit id="24b54af2f3501272eaa2d4bb4a4c29ad87c41036" translate="yes" xml:space="preserve">
          <source>Specifically, if I've got a &lt;code&gt;purchases&lt;/code&gt; table that looks like this:</source>
          <target state="translated">구체적으로 다음과 같은 &lt;code&gt;purchases&lt;/code&gt; 테이블이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="e80c2fdd2ef29bdb9b48c3567af9314011689fa6" translate="yes" xml:space="preserve">
          <source>Supported by any database:</source>
          <target state="translated">모든 데이터베이스에서 지원 :</target>
        </trans-unit>
        <trans-unit id="7e5062ca17fb1a192f52106e7c6e38c488fdd328" translate="yes" xml:space="preserve">
          <source>Testing the most interesting candidates with Postgres &lt;strong&gt;9.4&lt;/strong&gt; and &lt;strong&gt;9.5&lt;/strong&gt; with a halfway realistic table of &lt;strong&gt;200k rows&lt;/strong&gt; in &lt;code&gt;purchases&lt;/code&gt; and &lt;strong&gt;10k distinct &lt;code&gt;customer_id&lt;/code&gt;&lt;/strong&gt; (&lt;em&gt;avg. 20 rows per customer&lt;/em&gt;).</source>
          <target state="translated">Postgres &lt;strong&gt;9.4&lt;/strong&gt; 및 &lt;strong&gt;9.5&lt;/strong&gt; 로 가장 흥미로운 후보자를 테스트합니다. &lt;code&gt;purchases&lt;/code&gt; &lt;strong&gt;200k 행&lt;/strong&gt; 과 &lt;strong&gt;10k 개별 &lt;code&gt;customer_id&lt;/code&gt; &lt;/strong&gt; ( &lt;em&gt;고객 당 평균 20 행&lt;/em&gt; )의 반 사실적인 표.</target>
        </trans-unit>
        <trans-unit id="4c0349a949a02df07cfe9df6fb72a596095aac53" translate="yes" xml:space="preserve">
          <source>That will help us filter for the highest total for each purchase with no grouping needed:</source>
          <target state="translated">이렇게하면 그룹화없이 각 구매에 대해 가장 높은 총계를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8263d90ff6ffdae1372239c757291f48e712a876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DISTINCT ON&lt;/code&gt; expression(s) must match the leftmost &lt;code&gt;ORDER BY&lt;/code&gt;
  expression(s). The &lt;code&gt;ORDER BY&lt;/code&gt; clause will normally contain additional
  expression(s) that determine the desired precedence of rows within
  each &lt;code&gt;DISTINCT ON&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 표현식은 가장 왼쪽의 &lt;code&gt;ORDER BY&lt;/code&gt; 표현식과 일치해야합니다. &lt;code&gt;ORDER BY&lt;/code&gt; 절은 일반적으로 각 &lt;code&gt;DISTINCT ON&lt;/code&gt; 그룹 내에서 원하는 행의 우선 순위를 결정하는 추가 표현식을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f13e19f9b15111fb7b1bde58351508e53c21d6dc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;perfect&lt;/em&gt; index for the above query would be a &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;multi-column index&lt;/a&gt; spanning all three columns in matching sequence and with matching sort order:</source>
          <target state="translated">위의 쿼리에 대한 &lt;em&gt;완벽한&lt;/em&gt; 인덱스는 일치하는 순서와 정렬 순서로 세 열 모두에 걸친 &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;다중 열 인덱스입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1b4aba07ab733b78ed9bef8497132427b3cab0" translate="yes" xml:space="preserve">
          <source>The Query:</source>
          <target state="translated">쿼리 :</target>
        </trans-unit>
        <trans-unit id="183fa3d4a15533a9e707bd462d1faacae935ae4e" translate="yes" xml:space="preserve">
          <source>The accepted OMG Ponies' &quot;Supported by any database&quot; solution has good speed from my test.</source>
          <target state="translated">승인 된 OMG Ponies의 &quot;모든 데이터베이스에서 지원&quot;솔루션은 제 테스트에서 속도가 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="6502ba17b0b16f09c8a81764063487d6e256b438" translate="yes" xml:space="preserve">
          <source>The first approach will need us to get all the records for that name which I do not really like.</source>
          <target state="translated">첫 번째 방법은 내가 싫어하는 그 이름에 대한 모든 기록을 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="d766cf318ecc2510338dec9362ebccbe8d7c0677" translate="yes" xml:space="preserve">
          <source>The index is used because it delivers pre-sorted data. In Postgres 9.2 or later the query can also benefit from an &lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;index only scan&lt;/a&gt;&lt;/strong&gt; if the index is smaller than the underlying table. The index has to be scanned in its entirety, though.</source>
          <target state="translated">인덱스는 미리 정렬 된 데이터를 전달하기 때문에 사용됩니다. Postgres 9.2 이상에서는 인덱스가 기본 테이블보다 작은 경우 &lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;인덱스 만 스캔을&lt;/a&gt;&lt;/strong&gt; 통해 쿼리를 활용할 수도 있습니다. 그러나 인덱스는 전체적으로 스캔해야합니다.</target>
        </trans-unit>
        <trans-unit id="05df13c53001ea7238498c9bd30e304edb5a0a31" translate="yes" xml:space="preserve">
          <source>The second one will need a smart way to say there can be no record higher than this one.</source>
          <target state="translated">두 번째는 이보다 더 높은 레코드가 없다고 말하는 현명한 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0a3460435b2ba05f43754f4db17512ff936ee290" translate="yes" xml:space="preserve">
          <source>The solution is not very efficient as pointed by Erwin, because of presence of SubQs</source>
          <target state="translated">SubQ가 존재하기 때문에 Erwin이 지적한 것처럼 솔루션이 그리 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c14ef83d661641de58fc6d2cfd57cb77febe4cb3" translate="yes" xml:space="preserve">
          <source>Then your example should work &lt;em&gt;almost&lt;/em&gt; as is:</source>
          <target state="translated">그런 다음 예제는 &lt;em&gt;거의&lt;/em&gt; 그대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="14af5152d85077e382ef162c9c2c6ca124d91883" translate="yes" xml:space="preserve">
          <source>This is common &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem, which already has well tested and highly &lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;optimized solutions&lt;/a&gt;. Personally I prefer the &lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;left join solution by Bill Karwin&lt;/a&gt; (the &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;original post with lots of other solutions&lt;/a&gt;).</source>
          <target state="translated">이것은 &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;그룹별로 가장 큰 N 개&lt;/a&gt; 문제이며, 이미 잘 테스트되고 &lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;최적화 된 솔루션을 가지고&lt;/a&gt; 있습니다. 개인적 &lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;으로 Bill Karwin&lt;/a&gt; 의 왼쪽 조인 솔루션 ( &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;다른 솔루션이 많은 원본 게시물)을&lt;/a&gt; 선호합니다.</target>
        </trans-unit>
        <trans-unit id="9f6bb60b44756b7628cdf5d79a2596547457d1a3" translate="yes" xml:space="preserve">
          <source>This query is reasonably fast especially when there is a composite index like (customer, total) on the purchase table.</source>
          <target state="translated">이 쿼리는 특히 구매 테이블에 (고객, 총계)와 같은 복합 인덱스가있는 경우 상당히 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0a08adcb0b93966d68f2bc6f7a603c1356fcf793" translate="yes" xml:space="preserve">
          <source>This will give you the &lt;code&gt;id&lt;/code&gt; of each customer's largest purchase.</source>
          <target state="translated">그러면 각 고객의 최대 구매 &lt;code&gt;id&lt;/code&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8bd5672beabcb0e52175bab260889953b1655e" translate="yes" xml:space="preserve">
          <source>To install on ubuntu 14.04:</source>
          <target state="translated">우분투 14.04에 설치하려면 :</target>
        </trans-unit>
        <trans-unit id="3db7721a0740ae1052b100a1e77bf4b8e03a8a7b" translate="yes" xml:space="preserve">
          <source>To order results in a way that disagrees with the sort order determining the first per group, you can nest above query in an outer query with another &lt;code&gt;ORDER BY&lt;/code&gt;. &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;Example.&lt;/a&gt;</source>
          <target state="translated">그룹당 첫 번째를 결정하는 정렬 순서에 동의하지 않는 방식으로 결과를 정렬하려면 다른 &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하여 외부 쿼리에서 쿼리 위에 중첩 할 수 있습니다. &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;예.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46ed51fa8a387f78df24cb7924cc5d43ab1faeb1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;DISTINCT ON&lt;/code&gt;, using &lt;code&gt;array_agg&lt;/code&gt; lets you keep your &lt;code&gt;GROUP BY&lt;/code&gt;, in case you want that for other reasons.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 과 달리 &lt;code&gt;array_agg&lt;/code&gt; 를 사용하면 다른 이유로 원하는 경우 &lt;code&gt;GROUP BY&lt;/code&gt; 를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9409fc69c35c5edb50908ff3ef3bccafb2a22f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ARRAY_AGG&lt;/code&gt; function for &lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt;, and &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt; , &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt; , &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt; 및 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL에&lt;/a&gt; &lt;code&gt;ARRAY_AGG&lt;/code&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a1f57e731466c6b4c22dbef205787a34542575cf" translate="yes" xml:space="preserve">
          <source>Use condition &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; resulting in 1000 rows.</source>
          <target state="translated">&lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; 에 1000 개의 행이있는 조건을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="479bc7f3be51824caa77d22a6caca1d270a0d65b" translate="yes" xml:space="preserve">
          <source>Very fast solution</source>
          <target state="translated">매우 빠른 솔루션</target>
        </trans-unit>
        <trans-unit id="17affe0f45ae018cfaeeaaec42cd75a97768f98a" translate="yes" xml:space="preserve">
          <source>We want to make sure that we only have the highest total for each purchase.</source>
          <target state="translated">구매할 때마다 가장 높은 총계 만 갖기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="5c100673b890deacae49fafdc2ea596fde78f6a1" translate="yes" xml:space="preserve">
          <source>Weigh cost and benefit before creating tailored indexes for each query. The potential of above index largely depends on &lt;strong&gt;data distribution&lt;/strong&gt;.</source>
          <target state="translated">각 쿼리에 대해 맞춤형 인덱스를 생성하기 전에 비용과 이점을 측정하십시오. 위의 색인의 가능성은 &lt;strong&gt;데이터 분포&lt;/strong&gt; 에 크게 좌우됩니다.</target>
        </trans-unit>
        <trans-unit id="06f515e1d1ba4e92316990ed365daa5ce9e800bc" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; include any other expression in the &lt;code&gt;SELECT&lt;/code&gt; list. This is instrumental for replacing much more complex queries with subqueries and aggregate / window functions.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 목록에 다른 식을 포함시킬 수 &lt;em&gt;있습니다&lt;/em&gt; . 이는 훨씬 복잡한 쿼리를 하위 쿼리 및 집계 / 창 함수로 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="50d72a485d91aa310f99089fed392d899b7d2143" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don't have to&lt;/em&gt; include any of the expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 에 표현식 &lt;em&gt;을&lt;/em&gt; 포함 &lt;em&gt;하지 않아도됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4335d470451a86c659a4bb868ff8503b753296c3" translate="yes" xml:space="preserve">
          <source>You can replace &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; with any condition you want with one restriction: This subquery must not return more than one row</source>
          <target state="translated">한 번의 제한으로 &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; 를 원하는 조건으로 바꿀 수 있습니다.이 하위 쿼리는 둘 이상의 행을 반환해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="ff8ad01ccf2ca61d81d3b6151da26b5764ea41ec" translate="yes" xml:space="preserve">
          <source>You can use next subquery:</source>
          <target state="translated">다음 하위 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780f59927c03bd3be899b36571f8ee337f8e53df" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;array_agg&lt;/code&gt; in a similar way for your third output column, but &lt;code&gt;max(total)&lt;/code&gt; is simpler.</source>
          <target state="translated">세 번째 출력 열과 비슷한 방식으로 &lt;code&gt;array_agg&lt;/code&gt; 를 사용할 수 있지만 &lt;code&gt;max(total)&lt;/code&gt; 이 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="0a9176588fee007a7b61d9f6efb42dd41d191785" translate="yes" xml:space="preserve">
          <source>and don't forget to create clustered index for used columns</source>
          <target state="translated">사용 된 열에 대한 클러스터형 인덱스를 만드는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="88200cf876dc2073e81590d595033eb094e2c28d" translate="yes" xml:space="preserve">
          <source>and really very fast if table is indexed by id:</source>
          <target state="translated">테이블이 id로 색인되면 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="bf114a4fa7e29ac34c48f6e08b28e60a65ca3444" translate="yes" xml:space="preserve">
          <source>t1, t2 are subquery alias which could be removed depending on database.</source>
          <target state="translated">t1, t2는 데이터베이스에 따라 제거 될 수있는 서브 쿼리 별명입니다.</target>
        </trans-unit>
        <trans-unit id="70beadc9f0fa5a1f69a14a41423854c7849012e4" translate="yes" xml:space="preserve">
          <source>we make sure that all records that have another record with the higher total for the same user to be joined:</source>
          <target state="translated">동일한 사용자에 대해 더 높은 총계를 가진 다른 레코드가있는 모든 레코드를 결합해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
