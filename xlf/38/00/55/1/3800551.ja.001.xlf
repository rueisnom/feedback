<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3800551">
    <body>
      <group id="3800551">
        <trans-unit id="8b0e51f015b82c172dc08a72abec676ab68cdcb1" translate="yes" xml:space="preserve">
          <source>&amp;forall;x T(customer,id) &amp;gt; T(customer,x) (this total is higher than all other
total for that customer)</source>
          <target state="translated">&amp;forall;xT（customer、id）&amp;gt; T（customer、x）（この合計は、その顧客の他のすべての合計よりも高い）</target>
        </trans-unit>
        <trans-unit id="9eb86ef810547924021ae07751ee563a0d148b2f" translate="yes" xml:space="preserve">
          <source>&amp;not;&amp;exist;x T(customer, id) &amp;lt; T(customer, x)   (there exists no higher total for
that customer)</source>
          <target state="translated">&amp;not;&amp;exist;xT（customer、id）&amp;lt;T（customer、x）（その顧客にはそれ以上の合計は存在しません）</target>
        </trans-unit>
        <trans-unit id="465adca06e7c71101cc6c980483c14bd4b5cd6ea" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;row_number()&lt;/code&gt; in CTE, (&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">1. CTEの &lt;code&gt;row_number()&lt;/code&gt; 、（ &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;他の回答を参照&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="8904cac1304e73d4439e2e0cd4fe04a5bcbbda5a" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;row_number()&lt;/code&gt; in subquery (my optimization)</source>
          <target state="translated">2.サブクエリの &lt;code&gt;row_number()&lt;/code&gt; （私の最適化）</target>
        </trans-unit>
        <trans-unit id="96334568f816862e91fdb22411296b51a9047ba9" translate="yes" xml:space="preserve">
          <source>3. &lt;code&gt;DISTINCT ON&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">3. &lt;code&gt;DISTINCT ON&lt;/code&gt; （ &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;他の回答を参照&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab58eba8c40ca272a6b0399c814468cd2bf10833" translate="yes" xml:space="preserve">
          <source>4. rCTE with &lt;code&gt;LATERAL&lt;/code&gt; subquery (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">4. LATERALサブクエリを使用した &lt;code&gt;LATERAL&lt;/code&gt; （ &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;ここを参照&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="388a20a693d53df52778b80eb7ce5e395fe52dbe" translate="yes" xml:space="preserve">
          <source>5. &lt;code&gt;customer&lt;/code&gt; table with &lt;code&gt;LATERAL&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">5. &lt;code&gt;LATERAL&lt;/code&gt; を使用した &lt;code&gt;customer&lt;/code&gt; テーブル（ &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;ここを参照&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="28a71a270d0b490ab8b65fcb9dd0ec0dc252b602" translate="yes" xml:space="preserve">
          <source>6. &lt;code&gt;array_agg()&lt;/code&gt; with &lt;code&gt;ORDER BY&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">6. &lt;code&gt;ORDER BY&lt;/code&gt; を &lt;code&gt;array_agg()&lt;/code&gt; （ &lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;他の回答を参照&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="e77fc13c9b4bac378cdc79c530cff8444a76a91f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt;&lt;code&gt;DISTINCT ON&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; is a PostgreSQL extension of the standard (where only &lt;code&gt;DISTINCT&lt;/code&gt; on the whole &lt;code&gt;SELECT&lt;/code&gt; list is defined).</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt; &lt;code&gt;DISTINCT ON&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;は、標準のPostgreSQL拡張機能です（ &lt;code&gt;SELECT&lt;/code&gt; リスト全体で &lt;code&gt;DISTINCT&lt;/code&gt; のみが定義されています）。</target>
        </trans-unit>
        <trans-unit id="e5dbfddeb30f08b54049675c47334097b5e10ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DISTINCT ON&lt;/code&gt; can be combined with &lt;strong&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/strong&gt;. Leading expressions in &lt;code&gt;ORDER BY&lt;/code&gt; must be in the set of expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt;, but you can rearrange order among those freely. &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;Example.&lt;/a&gt; You can add &lt;em&gt;additional&lt;/em&gt; expressions to &lt;code&gt;ORDER BY&lt;/code&gt; to pick a particular row from each group of peers. Or, as &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;the manual puts it&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; は&lt;strong&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/strong&gt;と組み合わせることができます。 &lt;code&gt;ORDER BY&lt;/code&gt; の先頭の式は &lt;code&gt;DISTINCT ON&lt;/code&gt; の式のセットに含まれている必要がありますが、それらの間で順序を自由に並べ替えることができます。 &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;例。&lt;/a&gt; &lt;code&gt;ORDER BY&lt;/code&gt; に式を追加して、ピアの各グループから特定の行を選択できます。 または、 &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;マニュアルにあるように&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="8d496993b6d839bb9dea36ac37618f3a3cee55d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; is an aggregate function, so it works with &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; は集約関数であるため、 &lt;code&gt;GROUP BY&lt;/code&gt; で機能します。</target>
        </trans-unit>
        <trans-unit id="0ea589215973faa22621d36017e60710d4720f84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; lets you specify an ordering scoped to just itself, so it doesn't constrain the structure of the whole query. There is also syntax for how you sort NULLs, if you need to do something different from the default.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; を使用すると、それ自体だけをスコープとする順序を指定できるため、クエリ全体の構造が制約されません。 デフォルトとは異なる何かをする必要がある場合に、NULLをソートする方法の構文もあります。</target>
        </trans-unit>
        <trans-unit id="324791d057789de362088760368f72733ec8e3a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;customer&lt;/code&gt; table - for superior query</source>
          <target state="translated">&lt;code&gt;customer&lt;/code&gt; テーブル-優れたクエリ用</target>
        </trans-unit>
        <trans-unit id="9b6347bcc54c96a5d6afc6a91c3b2766235d6e38" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Pick the row with the smallest &lt;code&gt;id&lt;/code&gt; from each group sharing the highest &lt;code&gt;total&lt;/code&gt;.&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;「 &lt;code&gt;total&lt;/code&gt; が最も高い各グループから、最小の &lt;code&gt;id&lt;/code&gt; を持つ行を選択します。」&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ef8596eaf70407a2a70716e980229133cc09244" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; queries used an &lt;strong&gt;Index Only Scan&lt;/strong&gt; on &lt;code&gt;purchases2_3c_idx&lt;/code&gt; (among other steps). Some of them just for the smaller size of the index, others more effectively.</source>
          <target state="translated">&lt;em&gt;すべての&lt;/em&gt;クエリで、 &lt;code&gt;purchases2_3c_idx&lt;/code&gt; （他の手順の中でも特に）に対して&lt;strong&gt;インデックスのみのスキャンが&lt;/strong&gt;使用されました。 インデックスのサイズが小さい場合もあれば、より効果的な場合もあります。</target>
        </trans-unit>
        <trans-unit id="ba89b37ddd35fa61a293ee1c8d26550a43e5c312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;Optimize GROUP BY query to retrieve latest row per user&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;GROUP BYクエリを最適化して、ユーザーごとに最新の行を取得する&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce0fdf92dae6576eb974a49b5cfb0cacb7bf8227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to SQL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SQLに戻る&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5ae4ba7872bce65b6f09a8ef56edcc82bcf22b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: the &lt;code&gt;using (...)&lt;/code&gt; clause is currently not supported in MS-SQL and Oracle db as of this edit on Jan 2017. You have to expand it yourself to e.g. &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; etc.  The USING syntax works in SQLite, MySQL and PostgreSQL.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ： &lt;code&gt;using (...)&lt;/code&gt; 句は現在、2017年1月のこの編集の時点でMS-SQLおよびOracle dbでサポートされていません。たとえば &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; などに自分で拡張する必要があります。USING構文SQLite、MySQL、PostgreSQLで動作します。</target>
        </trans-unit>
        <trans-unit id="8ed70ea16198c5d6d45b8fbf0ed2b70660f594b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;期待される出力：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f6f14e2b0acb25bca7f5a61efae0972b838c25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HOW DOES THAT WORK!&lt;/strong&gt; (I've been there)</source>
          <target state="translated">&lt;strong&gt;それはどのように機能しますか？&lt;/strong&gt; （そこに行ったことがある）</target>
        </trans-unit>
        <trans-unit id="919ebd27c03cd325e823c752933e84712e574cd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;My Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;私の出力：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddcfd8371e55c2c354271ed9883696c5245698b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some Theoretical Stuff&lt;/strong&gt; (skip this part if you only want to understand the query)</source>
          <target state="translated">&lt;strong&gt;理論的なもの&lt;/strong&gt; （クエリを理解したいだけの場合は、この部分をスキップしてください）</target>
        </trans-unit>
        <trans-unit id="bbf1697f55b063038beadb0181046028cc7cdf1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;SELECT&lt;/code&gt; list&lt;/strong&gt; is not constrained by expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; in any way. (Not needed in the simple case above):</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;SELECT&lt;/code&gt; リスト&lt;/strong&gt;は、 &lt;code&gt;DISTINCT ON&lt;/code&gt; または &lt;code&gt;ORDER BY&lt;/code&gt; の式による制約を受けません。 （上記の単純なケースでは必要ありません）：</target>
        </trans-unit>
        <trans-unit id="20c7b5fd52a03a8d3c11b5edcf49e361b626b681" translate="yes" xml:space="preserve">
          <source>A. Postgres 9.4 with 200k rows and ~ 20 per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">A. Postgres 9.4、20万行、 &lt;code&gt;customer_id&lt;/code&gt; あたり20以下</target>
        </trans-unit>
        <trans-unit id="d8f970457bbe96b6e3501f8789c7b9f915513e61" translate="yes" xml:space="preserve">
          <source>And that's the answer we need.</source>
          <target state="translated">それが必要な答えだ</target>
        </trans-unit>
        <trans-unit id="e23feb77084817360c7083a788a14965fc076e58" translate="yes" xml:space="preserve">
          <source>As the title suggests, I'd like to select the first row of each set of rows grouped with a &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">タイトルが示すように、 &lt;code&gt;GROUP BY&lt;/code&gt; でグループ化された行の各セットの最初の行を選択したいと思います。</target>
        </trans-unit>
        <trans-unit id="8b1bd75cf1de2fdedb624fae5aa55e8a18adac06" translate="yes" xml:space="preserve">
          <source>B. The same with Postgres 9.5</source>
          <target state="translated">B.Postgres 9.5でも同様</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="52825791dd909cc4202b88eeaef7b54ec3becfa8" translate="yes" xml:space="preserve">
          <source>Bold emphasis mine.</source>
          <target state="translated">太字で強調しています。</target>
        </trans-unit>
        <trans-unit id="17aca40b4c23fbfe02d34fb72e4c61a9292f08d4" translate="yes" xml:space="preserve">
          <source>But if you wanna to do such things you probably looking for &lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">しかし、そのようなことをしたい場合は、おそらく&lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;ウィンドウ関数を&lt;/a&gt;探します</target>
        </trans-unit>
        <trans-unit id="f9fbf6bba2ca0f73231f0d374c9c473e11adbfc0" translate="yes" xml:space="preserve">
          <source>But you need to add logic to break ties:</source>
          <target state="translated">しかし、絆を断ち切るためにはロジックを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b0bad02864780888057ce496e6b9fabc038f2aa" translate="yes" xml:space="preserve">
          <source>C. Same as B., but with ~ 2.3 rows per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">C. Bと同じですが、 &lt;code&gt;customer_id&lt;/code&gt; ごとに約2.3行あります</target>
        </trans-unit>
        <trans-unit id="4f2ab710e696b3feb525a155fedbbf8f5f5c12ea" translate="yes" xml:space="preserve">
          <source>CAVEAT: It ignore's NULL rows</source>
          <target state="translated">CAVEAT:NULL行を無視します。</target>
        </trans-unit>
        <trans-unit id="a687cecffae4f0c8632214b84368c59a2e6e7153" translate="yes" xml:space="preserve">
          <source>Comparing &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies'&lt;/a&gt; first query (&lt;strong&gt;&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;) to the &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;above &lt;code&gt;DISTINCT ON&lt;/code&gt; solution&lt;/a&gt; (&lt;strong&gt;&lt;code&gt;B&lt;/code&gt;&lt;/strong&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPoniesの&lt;/a&gt;最初のクエリ（ &lt;strong&gt; &lt;code&gt;A&lt;/code&gt; &lt;/strong&gt; ）を&lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;上記の &lt;code&gt;DISTINCT ON&lt;/code&gt; ソリューション&lt;/a&gt; （ &lt;strong&gt; &lt;code&gt;B&lt;/code&gt; &lt;/strong&gt; ）と比較します 。</target>
        </trans-unit>
        <trans-unit id="acd80818ac5bcea9c24fdae3e88fceaa5145fe2c" translate="yes" xml:space="preserve">
          <source>Configuration parameter work_mem in PostgreSQL on Linux</source>
          <target state="translated">Linux上のPostgreSQLの設定パラメータwork_mem</target>
        </trans-unit>
        <trans-unit id="7fe2e8c8108bab0f14186604f0961d23506e1bc6" translate="yes" xml:space="preserve">
          <source>Dummy data, PK, index - a typical table also has some dead tuples:</source>
          <target state="translated">ダミーデータ、PK、インデックス-典型的なテーブルは、いくつかの死んだタプルも持っています。</target>
        </trans-unit>
        <trans-unit id="174c079c51c262737b6aa7163fe40695d570268e" translate="yes" xml:space="preserve">
          <source>Edit 1 - Use the postgres extension instead</source>
          <target state="translated">編集1-代わりにpostgresの拡張子を使用する</target>
        </trans-unit>
        <trans-unit id="fce82fa3164babb13876442255a3ad8934a0e437" translate="yes" xml:space="preserve">
          <source>Edit 2 - Ordering and filtering</source>
          <target state="translated">編集2-注文とフィルタリング</target>
        </trans-unit>
        <trans-unit id="75737715bd2086a23ae530d9cc64724b33734c1e" translate="yes" xml:space="preserve">
          <source>Effectiveness / Performance optimization</source>
          <target state="translated">効果 パフォーマンスの最適化</target>
        </trans-unit>
        <trans-unit id="ad6c60c32c0a2398914d7e2f0d2c91d41fd6fbf6" translate="yes" xml:space="preserve">
          <source>Execution time for above queries with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; (and all options &lt;em&gt;off&lt;/em&gt;), &lt;em&gt;best of 5 runs&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を使用した上記のクエリの実行時間（およびすべてのオプションを&lt;em&gt;オフ&lt;/em&gt; ）、 &lt;em&gt;最高5回の実行&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="64d9744934093551048060bf300f0c928c0bed3f" translate="yes" xml:space="preserve">
          <source>Explaination:Here  &lt;strong&gt;Group by&lt;/strong&gt; is done on the basis of customer and then order it by total then each such group is given serial number as StRank and we are taking out first 1 customer whose StRank is 1</source>
          <target state="translated">説明：ここでは、 &lt;strong&gt;Group by&lt;/strong&gt;は顧客に基づいて行われ、それを合計で注文します。次に、そのような各グループにStRankとしてシリアル番号が与えられ、StRankが1である最初の1人の顧客を取り出します。</target>
        </trans-unit>
        <trans-unit id="67f4bc89bd0ee8c2f20b19ee9c93d80b26582d05" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;few&lt;/em&gt; rows per customer&lt;/strong&gt; (high cardinality in column &lt;code&gt;customer&lt;/code&gt;), this is very efficient. Even more so if you need sorted output anyway. The benefit shrinks with a growing number of rows per customer.</source>
          <target state="translated">&lt;strong&gt;顧客あたり数行の&lt;/strong&gt;場合（列 &lt;code&gt;customer&lt;/code&gt; のカーディナリティが高い場合）、これは非常に効率的です。 とにかくソートされた出力が必要な場合はさらにそうです。 顧客あたりの行数が増えると、メリットは小さくなります。</target>
        </trans-unit>
        <trans-unit id="e7c26ad56f293277760cdbfe5b97e01026505b3d" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;many&lt;/em&gt; rows per customer&lt;/strong&gt; (low cardinality in column &lt;code&gt;customer&lt;/code&gt;), a &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;loose index scan&lt;/strong&gt;&lt;/a&gt; (a.k.a. &quot;skip scan&quot;) would be (much) more efficient, but that's not implemented up to Postgres 12. (An implementation for index-only scans is in development for Postgres 13. See &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">&lt;strong&gt;顧客あたりの行数が&lt;em&gt;多い&lt;/em&gt;&lt;/strong&gt;場合（列 &lt;code&gt;customer&lt;/code&gt; のカーディナリティが低い場合）、 &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;緩やかなインデックススキャン&lt;/strong&gt;&lt;/a&gt; （別名 &quot;スキップスキャン&quot;）の方が（はるかに）効率的ですが、Postgres 12までは実装されていません（インデックスのみのスキャンの実装はPostgres 13の開発中です。 &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;ここ&lt;/a&gt;と&lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;ここを&lt;/a&gt;参照してください 。）</target>
        </trans-unit>
        <trans-unit id="3573651362ae5e478981982b3b1e27c37c25fabf" translate="yes" xml:space="preserve">
          <source>For Postgres 9.5 I ran a 2nd test with effectively 86446 distinct customers. See below (&lt;em&gt;avg. 2.3 rows per customer&lt;/em&gt;).</source>
          <target state="translated">Postgres 9.5の場合、86446人の異なる顧客を対象に2番目のテストを実行しました。 以下を参照してください（ &lt;em&gt;顧客あたり平均2.3行&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5885b552b6ab83e07125a70548b0c986996b8178" translate="yes" xml:space="preserve">
          <source>For SQl Server the most efficient way is:</source>
          <target state="translated">SQlサーバーの場合は、最も効率的な方法です。</target>
        </trans-unit>
        <trans-unit id="3fa33ded2a46b10ad416ee2d3ffc070fa4d90ff9" translate="yes" xml:space="preserve">
          <source>For now, there are &lt;strong&gt;faster query techniques&lt;/strong&gt; to substitute for this. In particular if you have a separate table holding unique customers, which is the typical use case. But also if you don't:</source>
          <target state="translated">現時点では、これに代わる&lt;strong&gt;より高速なクエリ手法&lt;/strong&gt;があり&lt;strong&gt;ます&lt;/strong&gt; 。 特に、一意の顧客を保持する別のテーブルがある場合は、これが一般的な使用例です。 しかし、あなたがそうしない場合：</target>
        </trans-unit>
        <trans-unit id="adc98243acc2f50c6cd9268d1a23bdb2ac5b1062" translate="yes" xml:space="preserve">
          <source>Generated with &lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;this query&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;このクエリで&lt;/a&gt;生成されます 。</target>
        </trans-unit>
        <trans-unit id="01d1b9a5f5078d105e1cc0eaa95c676eae08b4ea" translate="yes" xml:space="preserve">
          <source>Here I provide a same-approach, but more complete and clean any-database solution.   Ties are considered (assume desire to get only one row for each customer, even multiple records for max total per customer), and other purchase fields (e.g. purchase_payment_id) will be selected for the real matching rows in the purchase table.</source>
          <target state="translated">ここで私は同じアプローチを提供しますが、より完全でクリーンな任意のデータベースのソリューションです。タイが考慮されます(各顧客のために1つの行だけを取得したいと仮定しても、顧客ごとの最大合計のための複数のレコード)、および他の購入フィールド(例えば、購入_支払い_id)は、購入テーブル内の実際の一致する行のために選択されます。</target>
        </trans-unit>
        <trans-unit id="1e3129050964ca90864ffa2acb569e107645deb0" translate="yes" xml:space="preserve">
          <source>Here is a new one by &quot;ogr&quot; testing with &lt;strong&gt;10M rows and 60k unique &quot;customers&quot;&lt;/strong&gt; on &lt;strong&gt;Postgres 11.5&lt;/strong&gt; (current as of Sep. 2019). Results are still in line with what we have seen so far:</source>
          <target state="translated">&lt;strong&gt;Postgres 11.5&lt;/strong&gt; （2019年9月現在）で1千万&lt;strong&gt;行と6万の一意の「顧客」&lt;/strong&gt;を使った「ogr」テストによる新しいものを次に示します。 結果は、これまでに見てきたことと一致しています。</target>
        </trans-unit>
        <trans-unit id="f098395b6ea6fcdc083ec3a7f6ea0975316c1705" translate="yes" xml:space="preserve">
          <source>I added &lt;code&gt;id&lt;/code&gt; as last item to break ties:</source>
          <target state="translated">私は結びを壊すために最後のアイテムとして &lt;code&gt;id&lt;/code&gt; を追加しました：</target>
        </trans-unit>
        <trans-unit id="c90b5abd370bd36ee6b7906498a63b93f5448bf7" translate="yes" xml:space="preserve">
          <source>I created a composite &lt;code&gt;(id, total)&lt;/code&gt;, so both values are returned by the same aggregate. You can of course always apply &lt;code&gt;first_value()&lt;/code&gt; twice.</source>
          <target state="translated">私はコンポジット &lt;code&gt;(id, total)&lt;/code&gt; を作成したので、両方の値が同じ集計から返されます。 もちろん、常に &lt;code&gt;first_value()&lt;/code&gt; を 2回適用することもできます。</target>
        </trans-unit>
        <trans-unit id="130b1834e42433119953b32cd075fdef4902f9c6" translate="yes" xml:space="preserve">
          <source>I had a simple benchmark here which is outdated by now. I replaced it with a &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;detailed benchmark in this separate answer&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">私はここに今では時代遅れになっている簡単なベンチマークを持っていました。 &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;この別の回答&lt;/strong&gt;&lt;/a&gt;では、 &lt;strong&gt;詳細なベンチマーク&lt;/strong&gt;に置き換えました。</target>
        </trans-unit>
        <trans-unit id="e09671f3bd26252ac5be9d0a7116458ae0d8bc22" translate="yes" xml:space="preserve">
          <source>I ran three tests with PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt; on a real life table of 65579 rows and single-column btree indexes on each of the three columns involved and took the best &lt;em&gt;execution time&lt;/em&gt; of 5 runs.</source>
          <target state="translated">私は、PostgreSQL &lt;strong&gt;9.1を使用&lt;/strong&gt;して、65579行の実際のテーブルと、関連する3列のそれぞれに単一列のbtreeインデックスを使用して3つのテストを&lt;em&gt;実行し&lt;/em&gt; 、5回の&lt;em&gt;実行で&lt;/em&gt;最高の&lt;em&gt;実行時間&lt;/em&gt;を費やしました。</target>
        </trans-unit>
        <trans-unit id="50ef525b77740b26d2f800be1f31dc196cd1a5b7" translate="yes" xml:space="preserve">
          <source>I tested with Postgres versions 8.3 &amp;ndash; 12. But the feature has been there at least since version 7.1, so basically always.</source>
          <target state="translated">私はPostgresバージョン8.3〜12でテストしましたが、この機能は少なくともバージョン7.1以降に存在しているため、基本的には常にそうです。</target>
        </trans-unit>
        <trans-unit id="63fe6b185c7bbea3849dd47a10061ff96c0bd0d6" translate="yes" xml:space="preserve">
          <source>I use a &lt;code&gt;serial&lt;/code&gt; (PK constraint added below) and an integer &lt;code&gt;customer_id&lt;/code&gt; since that's a more typical setup. Also added &lt;code&gt;some_column&lt;/code&gt; to make up for typically more columns.</source>
          <target state="translated">&lt;code&gt;serial&lt;/code&gt; （以下に追加するPK制約）と整数の &lt;code&gt;customer_id&lt;/code&gt; を使用しています。これは、より一般的な設定だからです。 また、通常より多くの列を補うために &lt;code&gt;some_column&lt;/code&gt; を追加しました。</target>
        </trans-unit>
        <trans-unit id="e6eee036e14e840a888fce846d96052e9490f45f" translate="yes" xml:space="preserve">
          <source>I use this way (postgresql only): &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&lt;/a&gt;</source>
          <target state="translated">私はこの方法を使用しています（postgresqlのみ）： &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https&lt;/a&gt; : //wiki.postgresql.org/wiki/First/last_%28aggregate%29</target>
        </trans-unit>
        <trans-unit id="058e05d7a94c12abe5d88dcda3d94f529d56876e" translate="yes" xml:space="preserve">
          <source>I'd like to query for the &lt;code&gt;id&lt;/code&gt; of the largest purchase (&lt;code&gt;total&lt;/code&gt;) made by each &lt;code&gt;customer&lt;/code&gt;. Something like this:</source>
          <target state="translated">各 &lt;code&gt;customer&lt;/code&gt; 行った最大の購入（ &lt;code&gt;total&lt;/code&gt; ）の &lt;code&gt;id&lt;/code&gt; を照会したいと思います 。 このようなもの：</target>
        </trans-unit>
        <trans-unit id="49e5ca82598636f91cd9a8e958c6a1d9a9469aa9" translate="yes" xml:space="preserve">
          <source>Ideally, you have enough &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to process the involved sort step in RAM and not spill to disk. But generally setting &lt;code&gt;work_mem&lt;/code&gt;&lt;em&gt;too&lt;/em&gt; high can have adverse effects. Consider &lt;code&gt;SET LOCAL&lt;/code&gt; for exceptionally big queries. Find how much you need with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;. Mention of &quot;&lt;em&gt;Disk:&lt;/em&gt;&quot; in the sort step indicates the need for more:</source>
          <target state="translated">理想的には、関与するソート手順をRAMで処理し、ディスクに流出しないのに十分な&lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;があります。 ただし、一般的に &lt;code&gt;work_mem&lt;/code&gt; の設定&lt;em&gt;が&lt;/em&gt;高&lt;em&gt;すぎる&lt;/em&gt;と、悪影響が生じる可能性があります。 非常に大きなクエリの場合は、 &lt;code&gt;SET LOCAL&lt;/code&gt; を検討してください。 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; で必要な量を見つけます。 並べ替え手順での「 &lt;em&gt;ディスク：&lt;/em&gt; 」の言及は、さらに必要なことを示しています。</target>
        </trans-unit>
        <trans-unit id="115e7329106b556464ad2183dc9b3466d332e3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL (won't hurt either way, but you'll want to &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;match existing indexes&lt;/a&gt;):</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; がNULLになる可能性がある場合（どちらにしても害はありませんが、 &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;既存のインデックス&lt;/a&gt;と一致させる必要があります ）：</target>
        </trans-unit>
        <trans-unit id="885869bd8bb57ffb30ae77b739b5f2d997c205b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL, you &lt;em&gt;most probably&lt;/em&gt; want the row with the greatest non-null value. Add &lt;strong&gt;&lt;code&gt;NULLS LAST&lt;/code&gt;&lt;/strong&gt; like demonstrated. See:</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; がNULLになる可能性がある場合は、 &lt;em&gt;おそらく&lt;/em&gt; 、null以外の最大の値を持つ行が必要です。 示されているように&lt;strong&gt; &lt;code&gt;NULLS LAST&lt;/code&gt; を&lt;/strong&gt;追加します。 見る：</target>
        </trans-unit>
        <trans-unit id="f3ff0102a461bc45f392997d6b4457df923ab8d8" translate="yes" xml:space="preserve">
          <source>If we left joins the table on the name and total being less than the joined table:</source>
          <target state="translated">名前と合計が結合されたテーブルよりも小さいテーブルを結合したままにしておくと、テーブルの名前と合計が結合されたテーブルよりも小さくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="1bc90c6679c8f97e7e0ae81bc6b9546fcda369ac" translate="yes" xml:space="preserve">
          <source>If you use aggregate functions (like these), you can order the results, without the need to have the data already ordered:</source>
          <target state="translated">集約関数(これらのようなもの)を使用する場合は、データがすでに順番になっている必要はなく、結果を順番に並べることができます。</target>
        </trans-unit>
        <trans-unit id="513b52421e643bf265232a5b0303884aee1f29a9" translate="yes" xml:space="preserve">
          <source>If you want to select any (by your some specific condition) row from the set of aggregated rows.</source>
          <target state="translated">集約された行の集合から任意の(特定の条件で)行を選択したい場合。</target>
        </trans-unit>
        <trans-unit id="14f29bfc41c897a3e227d298f67de89585505bbf" translate="yes" xml:space="preserve">
          <source>If you want to use another (&lt;code&gt;sum/avg&lt;/code&gt;) aggregation function in addition to &lt;code&gt;max/min&lt;/code&gt;. Thus you can not use clue with &lt;code&gt;DISTINCT ON&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;max/min&lt;/code&gt; に加えて別の（ &lt;code&gt;sum/avg&lt;/code&gt; ）集約関数を使用する場合。 したがって、 &lt;code&gt;DISTINCT ON&lt;/code&gt; でクルーを使用することはできません</target>
        </trans-unit>
        <trans-unit id="95f04d79bc6e9f1a1a378d50e9a21929eef79e61" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PostgreSQL&lt;/strong&gt; this is typically &lt;strong&gt;simpler and faster&lt;/strong&gt; (more performance optimization below):</source>
          <target state="translated">&lt;strong&gt;PostgreSQLでは、&lt;/strong&gt;これは通常&lt;strong&gt;より単純で高速です&lt;/strong&gt; （以下でより多くのパフォーマンス最適化）。</target>
        </trans-unit>
        <trans-unit id="3030a2fec9c767d8ff7ccbf769b9e4f47aa7fac4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, another possibility is to use the &lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt;&lt;code&gt;first_value&lt;/code&gt;&lt;/a&gt; window function in combination with &lt;code&gt;SELECT DISTINCT&lt;/code&gt;:</source>
          <target state="translated">PostgreSQLでは、 &lt;code&gt;SELECT DISTINCT&lt;/code&gt; と組み合わせて&lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt; &lt;code&gt;first_value&lt;/code&gt; &lt;/a&gt;ウィンドウ関数を使用することもでき ます 。</target>
        </trans-unit>
        <trans-unit id="70b88621817cca0608b7dda4ed35638f90c58d08" translate="yes" xml:space="preserve">
          <source>In Postgres you can use &lt;code&gt;array_agg&lt;/code&gt; like this:</source>
          <target state="translated">Postgresでは、 &lt;code&gt;array_agg&lt;/code&gt; ようにarray_aggを使用できます。</target>
        </trans-unit>
        <trans-unit id="b958a892b980456789c653c74f646b5dec93aaf4" translate="yes" xml:space="preserve">
          <source>In SQL Server you can do this:</source>
          <target state="translated">SQL Serverでは、このようなことができます。</target>
        </trans-unit>
        <trans-unit id="eaadf570b7bb1e4a6396c6bcba18cbed9639f58a" translate="yes" xml:space="preserve">
          <source>In my &lt;strong&gt;second test&lt;/strong&gt; for 9.5 I used the same setup, but with &lt;code&gt;random() * 100000&lt;/code&gt; to generate &lt;code&gt;customer_id&lt;/code&gt; to get only few rows per &lt;code&gt;customer_id&lt;/code&gt;.</source>
          <target state="translated">9.5の&lt;strong&gt;2番目のテスト&lt;/strong&gt;では、同じ設定を使用しましたが、 &lt;code&gt;customer_id&lt;/code&gt; を生成するために &lt;code&gt;random() * 100000&lt;/code&gt; を使用し、 customer_idごとに数行のみを取得しました。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="76ff0109afd7a40bd9c16251d32e49ec91dea601" translate="yes" xml:space="preserve">
          <source>It's a postgres extension that gives you first and last functions; apparently faster than the above way.</source>
          <target state="translated">これは、最初と最後の関数を与えてくれるpostgresの拡張機能です;上記の方法よりも明らかに速いです。</target>
        </trans-unit>
        <trans-unit id="d991a62bb10a62ed754485867ff0e408d74d7e89" translate="yes" xml:space="preserve">
          <source>Let Total be a function T(customer,id) where it returns a value given the name and id
To prove that the given total (T(customer,id)) is the highest we have to prove that
We want to prove either</source>
          <target state="translated">Totalを関数T(customer,id)とします。ここでは、名前とidが与えられた値を返します。</target>
        </trans-unit>
        <trans-unit id="2e5632d0f807b3f34cf7f69dec1047fe433b911d" translate="yes" xml:space="preserve">
          <source>List any number of expressions in the &lt;code&gt;DISTINCT ON&lt;/code&gt; clause, the combined row value defines duplicates. &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;The manual:&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 句に任意の数の式をリストします。結合された行の値は重複を定義します。 &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;マニュアル：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="464f7790b102ce69cf3acd7d69f43f9a52b82086" translate="yes" xml:space="preserve">
          <source>Main table</source>
          <target state="translated">メインテーブル</target>
        </trans-unit>
        <trans-unit id="9e85255a09c56ff34c3fc3aaf30b6b3e8b91258b" translate="yes" xml:space="preserve">
          <source>Major points</source>
          <target state="translated">主なポイント</target>
        </trans-unit>
        <trans-unit id="d12153394231071e15cd8c3b11dfb9916cc27f28" translate="yes" xml:space="preserve">
          <source>May be too specialized. But use it if read performance for the particular query is crucial. If you have &lt;code&gt;DESC NULLS LAST&lt;/code&gt; in the query, use the same in the index so that sort order matches and the index is applicable.</source>
          <target state="translated">専門的すぎるかもしれません。 ただし、特定のクエリの読み取りパフォーマンスが重要な場合に使用します。 クエリに &lt;code&gt;DESC NULLS LAST&lt;/code&gt; がある場合は、インデックスで同じを使用して、ソート順が一致し、インデックスが適用されるようにします。</target>
        </trans-unit>
        <trans-unit id="dfff4eefffc08fe064edf770d418be997d8af5cd" translate="yes" xml:space="preserve">
          <source>Note that bunch of solutions to this common problem can surprisingly be found in the one of most official sources, &lt;strong&gt;MySQL manual&lt;/strong&gt;! See &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;Examples of Common Queries :: The Rows Holding the Group-wise Maximum of a Certain Column&lt;/a&gt;.</source>
          <target state="translated">この一般的な問題に対する一連の解決策は、驚くべきことに、最も公式なソースの1つである&lt;strong&gt;MySQLマニュアルにあります&lt;/strong&gt; 。 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;一般的なクエリの例::特定の列のグループごとの最大値を保持する行を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="df659bc5a4cb564a96f76217ff3e2438b57ef8b7" translate="yes" xml:space="preserve">
          <source>Now I use this way: &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http://pgxn.org/dist/first_last_agg/&lt;/a&gt;</source>
          <target state="translated">今私はこの方法を使用します： &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http&lt;/a&gt; : //pgxn.org/dist/first_last_agg/</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="ae8661bf223d4e024221cc558b5e2889d1ab01aa" translate="yes" xml:space="preserve">
          <source>Object sizes for table &lt;code&gt;purchases&lt;/code&gt;</source>
          <target state="translated">テーブル &lt;code&gt;purchases&lt;/code&gt; オブジェクトサイズ</target>
        </trans-unit>
        <trans-unit id="0c3894fd7032a7b8b88d3da5aa8a3469655ef31d" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least
  one column value. &lt;strong&gt;Null values are considered equal in this comparison.&lt;/strong&gt;</source>
          <target state="translated">明らかに、2つの行が少なくとも1つの列の値で異なる場合、それらは異なると見なされます。 &lt;strong&gt;この比較では、ヌル値は等しいと見なされます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="311285b287ae794f8a6e6e16f340d4537b8dfbc1" translate="yes" xml:space="preserve">
          <source>Of course you can order and filter as you deem fit within the aggregate; it's very powerful syntax.</source>
          <target state="translated">もちろん、集合体の中で適当と思われるように順序付けやフィルタリングを行うことができます。</target>
        </trans-unit>
        <trans-unit id="982f7546a2eb8df6633eb73d3e3883d3525fe955" translate="yes" xml:space="preserve">
          <source>On Oracle 9.2+ (not 8i+ as originally stated), SQL Server 2005+, PostgreSQL 8.4+, DB2, Firebird 3.0+, Teradata, Sybase, Vertica:</source>
          <target state="translated">Oracle 9.2+(当初の記載では8i+ではありません)、SQL Server 2005+、PostgreSQL 8.4+、DB2、Firebird 3.0+、Teradata、Sybase、Vertica。</target>
        </trans-unit>
        <trans-unit id="0ea92a1813c9ad07657cdc2ac29023c0cbfc39c1" translate="yes" xml:space="preserve">
          <source>Once we build the array, we take the first element. (Postgres arrays are 1-indexed, not 0-indexed).</source>
          <target state="translated">配列を構築したら、最初の要素を取ります。(Postgresの配列は0インデックスではなく1インデックスです)。</target>
        </trans-unit>
        <trans-unit id="b8a1b609b59584ecf9bb25c6e8bacdb3704cca90" translate="yes" xml:space="preserve">
          <source>Optimize groupwise maximum query</source>
          <target state="translated">グループワイズ最大クエリの最適化</target>
        </trans-unit>
        <trans-unit id="bf017f217553f1cf968db1e65b41af2ab992d2d5" translate="yes" xml:space="preserve">
          <source>Optimize simple query using ORDER BY date and text</source>
          <target state="translated">日付とテキストのORDER BYを使用した簡単なクエリの最適化</target>
        </trans-unit>
        <trans-unit id="a67837359416b99ab5311803744d610256a22309" translate="yes" xml:space="preserve">
          <source>Or shorter (if not as clear) with ordinal numbers of output columns:</source>
          <target state="translated">あるいは、出力列の序数で短く(明確でなければ)する。</target>
        </trans-unit>
        <trans-unit id="24fa5a2c8e0b4079cb5f9fe868a9bd59518f7bc4" translate="yes" xml:space="preserve">
          <source>Original (outdated) benchmark from 2011</source>
          <target state="translated">2011年からのオリジナル(時代遅れの)ベンチマーク</target>
        </trans-unit>
        <trans-unit id="323c83c0f69c9372d7ee234ccace23a4e5de3ce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL sort by datetime asc, null first?</source>
          <target state="translated">PostgreSQLのソートはdatetime asc、nullの最初の?</target>
        </trans-unit>
        <trans-unit id="b244b2217c8b6c534f37d1f03cf14604ed7ba5e5" translate="yes" xml:space="preserve">
          <source>Proper way to access latest row for each individual identifier?</source>
          <target state="translated">個々の識別子の最新の行にアクセスする適切な方法は?</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="0b8a47b88d837280e3fab94fe4d2bd803b3c158f" translate="yes" xml:space="preserve">
          <source>Query last N related rows per row</source>
          <target state="translated">行ごとに最後のN個の関連する行をクエリします。</target>
        </trans-unit>
        <trans-unit id="e8536401a76da15c6c761038b81a6fa0d744d0c4" translate="yes" xml:space="preserve">
          <source>Related benchmarks</source>
          <target state="translated">関連ベンチマーク</target>
        </trans-unit>
        <trans-unit id="a88f66d2299b63003d3d871345537088ff79ce05" translate="yes" xml:space="preserve">
          <source>Remark:</source>
          <target state="translated">Remark:</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="ba1151ed7036215586ab2deb08df3dd651d11cd8" translate="yes" xml:space="preserve">
          <source>Same test repeated with the index described in the other answer</source>
          <target state="translated">他の回答に記載されているインデックスを用いて同じテストを繰り返す</target>
        </trans-unit>
        <trans-unit id="02fa4b7c2eb7288cc2dd7860b97e7fcc7c3c81d0" translate="yes" xml:space="preserve">
          <source>Select a single customer with &lt;code&gt;WHERE customer = x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE customer = x&lt;/code&gt; 単一の顧客を選択します。</target>
        </trans-unit>
        <trans-unit id="253368c0449de38cab696b8fe6b4a86a8b102762" translate="yes" xml:space="preserve">
          <source>Select first row in each GROUP BY group</source>
          <target state="translated">各GROUP BYグループの最初の行を選択</target>
        </trans-unit>
        <trans-unit id="584e375ddcb38e2b1f417648316c35cf906dbf11" translate="yes" xml:space="preserve">
          <source>Select the whole table, results in 5958 rows in this case.</source>
          <target state="translated">テーブル全体を選択すると、この場合は5958行になります。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="25075eb661f7180b5138442fe9b8c1612f5add01" translate="yes" xml:space="preserve">
          <source>Snowflake/Teradata supports &lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt;&lt;code&gt;QUALIFY&lt;/code&gt;&lt;/a&gt; clause which works like &lt;code&gt;HAVING&lt;/code&gt; for windowed functions:</source>
          <target state="translated">Snowflake / Teradataは、ウィンドウ関数の &lt;code&gt;HAVING&lt;/code&gt; のように機能する&lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt; &lt;code&gt;QUALIFY&lt;/code&gt; &lt;/a&gt;句をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a77cdea121464bd8808b2f7a4d983ddee817a186" translate="yes" xml:space="preserve">
          <source>So the equivalent example, with ordering would be something like:</source>
          <target state="translated">そのため、同等の例としては、順序をつけて、次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="fe91dbd517e1619f524c6cc3d78de6f788ca2326" translate="yes" xml:space="preserve">
          <source>Some things to note:</source>
          <target state="translated">注意すべき点がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="24b54af2f3501272eaa2d4bb4a4c29ad87c41036" translate="yes" xml:space="preserve">
          <source>Specifically, if I've got a &lt;code&gt;purchases&lt;/code&gt; table that looks like this:</source>
          <target state="translated">具体的には、次のような &lt;code&gt;purchases&lt;/code&gt; テーブルがある場合：</target>
        </trans-unit>
        <trans-unit id="e80c2fdd2ef29bdb9b48c3567af9314011689fa6" translate="yes" xml:space="preserve">
          <source>Supported by any database:</source>
          <target state="translated">任意のデータベースでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7e5062ca17fb1a192f52106e7c6e38c488fdd328" translate="yes" xml:space="preserve">
          <source>Testing the most interesting candidates with Postgres &lt;strong&gt;9.4&lt;/strong&gt; and &lt;strong&gt;9.5&lt;/strong&gt; with a halfway realistic table of &lt;strong&gt;200k rows&lt;/strong&gt; in &lt;code&gt;purchases&lt;/code&gt; and &lt;strong&gt;10k distinct &lt;code&gt;customer_id&lt;/code&gt;&lt;/strong&gt; (&lt;em&gt;avg. 20 rows per customer&lt;/em&gt;).</source>
          <target state="translated">Postgres &lt;strong&gt;9.4&lt;/strong&gt;および&lt;strong&gt;9.5&lt;/strong&gt;で最も興味深い候補をテストし、 &lt;code&gt;purchases&lt;/code&gt; に&lt;strong&gt;200k行&lt;/strong&gt;と&lt;strong&gt;10kの個別の &lt;code&gt;customer_id&lt;/code&gt; &lt;/strong&gt; （ &lt;em&gt;顧客あたり平均20行&lt;/em&gt; ）の中間的な現実的なテーブルを使用してテストし&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c0349a949a02df07cfe9df6fb72a596095aac53" translate="yes" xml:space="preserve">
          <source>That will help us filter for the highest total for each purchase with no grouping needed:</source>
          <target state="translated">これは、グループ化する必要がなく、各購入品の最高合計をフィルタリングするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="8263d90ff6ffdae1372239c757291f48e712a876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DISTINCT ON&lt;/code&gt; expression(s) must match the leftmost &lt;code&gt;ORDER BY&lt;/code&gt;
  expression(s). The &lt;code&gt;ORDER BY&lt;/code&gt; clause will normally contain additional
  expression(s) that determine the desired precedence of rows within
  each &lt;code&gt;DISTINCT ON&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 式は、左端の &lt;code&gt;ORDER BY&lt;/code&gt; 式と一致する必要があります。 通常、 &lt;code&gt;ORDER BY&lt;/code&gt; 句には、各 &lt;code&gt;DISTINCT ON&lt;/code&gt; グループ内の行の優先順位を決定する追加の式が含まれます 。</target>
        </trans-unit>
        <trans-unit id="f13e19f9b15111fb7b1bde58351508e53c21d6dc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;perfect&lt;/em&gt; index for the above query would be a &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;multi-column index&lt;/a&gt; spanning all three columns in matching sequence and with matching sort order:</source>
          <target state="translated">上記のクエリの&lt;em&gt;完全な&lt;/em&gt;インデックスは、3つの列すべてに一致するシーケンスで、一致するソート順を持つ&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;複数列のインデックスになり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9e1b4aba07ab733b78ed9bef8497132427b3cab0" translate="yes" xml:space="preserve">
          <source>The Query:</source>
          <target state="translated">クエリです。</target>
        </trans-unit>
        <trans-unit id="183fa3d4a15533a9e707bd462d1faacae935ae4e" translate="yes" xml:space="preserve">
          <source>The accepted OMG Ponies' &quot;Supported by any database&quot; solution has good speed from my test.</source>
          <target state="translated">受け入れられたOMGポニーの「どのデータベースにも対応している」ソリューションは、私のテストでは良い速度を持っています。</target>
        </trans-unit>
        <trans-unit id="6502ba17b0b16f09c8a81764063487d6e256b438" translate="yes" xml:space="preserve">
          <source>The first approach will need us to get all the records for that name which I do not really like.</source>
          <target state="translated">最初のアプローチは、私たちが本当に好きではないその名前のためのすべてのレコードを取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="d766cf318ecc2510338dec9362ebccbe8d7c0677" translate="yes" xml:space="preserve">
          <source>The index is used because it delivers pre-sorted data. In Postgres 9.2 or later the query can also benefit from an &lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;index only scan&lt;/a&gt;&lt;/strong&gt; if the index is smaller than the underlying table. The index has to be scanned in its entirety, though.</source>
          <target state="translated">インデックスは、事前にソートされたデータを配信するために使用されます。 Postgres 9.2以降では、インデックスが基になるテーブルよりも小さい場合、クエリは&lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;インデックスのみのスキャン&lt;/a&gt;&lt;/strong&gt;からもメリットを得ることができます。 ただし、インデックス全体をスキャンする必要があります。</target>
        </trans-unit>
        <trans-unit id="05df13c53001ea7238498c9bd30e304edb5a0a31" translate="yes" xml:space="preserve">
          <source>The second one will need a smart way to say there can be no record higher than this one.</source>
          <target state="translated">2枚目はこれより上の記録はありえないと言う賢い言い方が必要になります。</target>
        </trans-unit>
        <trans-unit id="0a3460435b2ba05f43754f4db17512ff936ee290" translate="yes" xml:space="preserve">
          <source>The solution is not very efficient as pointed by Erwin, because of presence of SubQs</source>
          <target state="translated">SubQが存在するため、Erwinが指摘したように解はあまり効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="c14ef83d661641de58fc6d2cfd57cb77febe4cb3" translate="yes" xml:space="preserve">
          <source>Then your example should work &lt;em&gt;almost&lt;/em&gt; as is:</source>
          <target state="translated">次に、あなたの例は&lt;em&gt;ほとんど&lt;/em&gt;そのまま動作します：</target>
        </trans-unit>
        <trans-unit id="14af5152d85077e382ef162c9c2c6ca124d91883" translate="yes" xml:space="preserve">
          <source>This is common &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem, which already has well tested and highly &lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;optimized solutions&lt;/a&gt;. Personally I prefer the &lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;left join solution by Bill Karwin&lt;/a&gt; (the &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;original post with lots of other solutions&lt;/a&gt;).</source>
          <target state="translated">これは、よくテストされ、高度に&lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;最適化されたソリューション&lt;/a&gt;をすでに持っている、 &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;グループあたりの最大の&lt;/a&gt;問題です。 個人的には&lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;、Bill Karwinによる左結合ソリューション&lt;/a&gt; （ &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;他の多くのソリューションを含む元の投稿&lt;/a&gt; ）を好みます 。</target>
        </trans-unit>
        <trans-unit id="9f6bb60b44756b7628cdf5d79a2596547457d1a3" translate="yes" xml:space="preserve">
          <source>This query is reasonably fast especially when there is a composite index like (customer, total) on the purchase table.</source>
          <target state="translated">このクエリは、特に購入テーブルに(顧客、合計)のような複合インデックスがある場合には、合理的に高速です。</target>
        </trans-unit>
        <trans-unit id="0a08adcb0b93966d68f2bc6f7a603c1356fcf793" translate="yes" xml:space="preserve">
          <source>This will give you the &lt;code&gt;id&lt;/code&gt; of each customer's largest purchase.</source>
          <target state="translated">これにより、各顧客の最大の購入の &lt;code&gt;id&lt;/code&gt; が得られます。</target>
        </trans-unit>
        <trans-unit id="fc8bd5672beabcb0e52175bab260889953b1655e" translate="yes" xml:space="preserve">
          <source>To install on ubuntu 14.04:</source>
          <target state="translated">ubuntu 14.04にインストールするには。</target>
        </trans-unit>
        <trans-unit id="3db7721a0740ae1052b100a1e77bf4b8e03a8a7b" translate="yes" xml:space="preserve">
          <source>To order results in a way that disagrees with the sort order determining the first per group, you can nest above query in an outer query with another &lt;code&gt;ORDER BY&lt;/code&gt;. &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;Example.&lt;/a&gt;</source>
          <target state="translated">グループごとの最初のクエリを決定するソート順と一致しない方法で結果を並べ替えるには、別の &lt;code&gt;ORDER BY&lt;/code&gt; を使用して、外部クエリのクエリの上にネストすることができます。 &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;例。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46ed51fa8a387f78df24cb7924cc5d43ab1faeb1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;DISTINCT ON&lt;/code&gt;, using &lt;code&gt;array_agg&lt;/code&gt; lets you keep your &lt;code&gt;GROUP BY&lt;/code&gt;, in case you want that for other reasons.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; とは異なり、 &lt;code&gt;array_agg&lt;/code&gt; を使用すると、他の理由で必要な場合に備えて &lt;code&gt;GROUP BY&lt;/code&gt; を保持できます。</target>
        </trans-unit>
        <trans-unit id="5d9409fc69c35c5edb50908ff3ef3bccafb2a22f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ARRAY_AGG&lt;/code&gt; function for &lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt;, and &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt; 、 &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt; 、 &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt; 、および&lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQLで&lt;/a&gt; &lt;code&gt;ARRAY_AGG&lt;/code&gt; 関数を使用します 。</target>
        </trans-unit>
        <trans-unit id="a1f57e731466c6b4c22dbef205787a34542575cf" translate="yes" xml:space="preserve">
          <source>Use condition &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; resulting in 1000 rows.</source>
          <target state="translated">条件 &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; を使用すると、1000行になります。</target>
        </trans-unit>
        <trans-unit id="479bc7f3be51824caa77d22a6caca1d270a0d65b" translate="yes" xml:space="preserve">
          <source>Very fast solution</source>
          <target state="translated">非常に迅速な解決策</target>
        </trans-unit>
        <trans-unit id="17affe0f45ae018cfaeeaaec42cd75a97768f98a" translate="yes" xml:space="preserve">
          <source>We want to make sure that we only have the highest total for each purchase.</source>
          <target state="translated">一回の購入で一番高い合計金額だけにしたいと思っています。</target>
        </trans-unit>
        <trans-unit id="5c100673b890deacae49fafdc2ea596fde78f6a1" translate="yes" xml:space="preserve">
          <source>Weigh cost and benefit before creating tailored indexes for each query. The potential of above index largely depends on &lt;strong&gt;data distribution&lt;/strong&gt;.</source>
          <target state="translated">クエリごとに調整されたインデックスを作成する前に、コストとメリットを比較検討してください。 上記のインデックスの可能性は、 &lt;strong&gt;データの分布に&lt;/strong&gt;大きく依存し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="06f515e1d1ba4e92316990ed365daa5ce9e800bc" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; include any other expression in the &lt;code&gt;SELECT&lt;/code&gt; list. This is instrumental for replacing much more complex queries with subqueries and aggregate / window functions.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; リストには他の式を含めること&lt;em&gt;ができ&lt;/em&gt;ます。 これは、はるかに複雑なクエリをサブクエリおよび集約/ウィンドウ関数に置き換えるための手段です。</target>
        </trans-unit>
        <trans-unit id="50d72a485d91aa310f99089fed392d899b7d2143" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don't have to&lt;/em&gt; include any of the expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; または &lt;code&gt;ORDER BY&lt;/code&gt; に式&lt;em&gt;を&lt;/em&gt;含める&lt;em&gt;必要はありません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="4335d470451a86c659a4bb868ff8503b753296c3" translate="yes" xml:space="preserve">
          <source>You can replace &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; with any condition you want with one restriction: This subquery must not return more than one row</source>
          <target state="translated">次のように、 &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; を任意の条件に置き換えることができます。 ただし、このサブクエリは複数の行を返してはいけません。</target>
        </trans-unit>
        <trans-unit id="ff8ad01ccf2ca61d81d3b6151da26b5764ea41ec" translate="yes" xml:space="preserve">
          <source>You can use next subquery:</source>
          <target state="translated">次のサブクエリが使えます。</target>
        </trans-unit>
        <trans-unit id="780f59927c03bd3be899b36571f8ee337f8e53df" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;array_agg&lt;/code&gt; in a similar way for your third output column, but &lt;code&gt;max(total)&lt;/code&gt; is simpler.</source>
          <target state="translated">3番目の出力列にも同じように &lt;code&gt;array_agg&lt;/code&gt; を使用できますが、 &lt;code&gt;max(total)&lt;/code&gt; の方が簡単です。</target>
        </trans-unit>
        <trans-unit id="0a9176588fee007a7b61d9f6efb42dd41d191785" translate="yes" xml:space="preserve">
          <source>and don't forget to create clustered index for used columns</source>
          <target state="translated">そして、使用されるカラムのためにクラスタ化されたインデックスを作成することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="88200cf876dc2073e81590d595033eb094e2c28d" translate="yes" xml:space="preserve">
          <source>and really very fast if table is indexed by id:</source>
          <target state="translated">テーブルが id でインデックス化されている場合は、非常に高速になります。</target>
        </trans-unit>
        <trans-unit id="bf114a4fa7e29ac34c48f6e08b28e60a65ca3444" translate="yes" xml:space="preserve">
          <source>t1, t2 are subquery alias which could be removed depending on database.</source>
          <target state="translated">t1,t2はサブクエリのエイリアスで、データベースによっては削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="70beadc9f0fa5a1f69a14a41423854c7849012e4" translate="yes" xml:space="preserve">
          <source>we make sure that all records that have another record with the higher total for the same user to be joined:</source>
          <target state="translated">私たちは、同じユーザーのためのより高い合計を持つ別のレコードを持っているすべてのレコードが参加するようにします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
