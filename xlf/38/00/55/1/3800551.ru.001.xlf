<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3800551">
    <body>
      <group id="3800551">
        <trans-unit id="8b0e51f015b82c172dc08a72abec676ab68cdcb1" translate="yes" xml:space="preserve">
          <source>&amp;forall;x T(customer,id) &amp;gt; T(customer,x) (this total is higher than all other
total for that customer)</source>
          <target state="translated">Tx T (customer, id)&amp;gt; T (customer, x) (эта сумма выше, чем все остальные суммы для этого клиента)</target>
        </trans-unit>
        <trans-unit id="9eb86ef810547924021ae07751ee563a0d148b2f" translate="yes" xml:space="preserve">
          <source>&amp;not;&amp;exist;x T(customer, id) &amp;lt; T(customer, x)   (there exists no higher total for
that customer)</source>
          <target state="translated">&amp;not;&amp;exist;x T (customer, id) &amp;lt;T (customer, x) (для этого клиента не существует более высокой суммы)</target>
        </trans-unit>
        <trans-unit id="465adca06e7c71101cc6c980483c14bd4b5cd6ea" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;row_number()&lt;/code&gt; in CTE, (&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">1. &lt;code&gt;row_number()&lt;/code&gt; в CTE ( &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;см. Другой ответ&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8904cac1304e73d4439e2e0cd4fe04a5bcbbda5a" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;row_number()&lt;/code&gt; in subquery (my optimization)</source>
          <target state="translated">2. &lt;code&gt;row_number()&lt;/code&gt; в подзапросе (моя оптимизация)</target>
        </trans-unit>
        <trans-unit id="96334568f816862e91fdb22411296b51a9047ba9" translate="yes" xml:space="preserve">
          <source>3. &lt;code&gt;DISTINCT ON&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">3. &lt;code&gt;DISTINCT ON&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;см. Другой ответ&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ab58eba8c40ca272a6b0399c814468cd2bf10833" translate="yes" xml:space="preserve">
          <source>4. rCTE with &lt;code&gt;LATERAL&lt;/code&gt; subquery (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">4. rCTE с LATERAL подзапросом ( &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;см. Здесь&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="388a20a693d53df52778b80eb7ce5e395fe52dbe" translate="yes" xml:space="preserve">
          <source>5. &lt;code&gt;customer&lt;/code&gt; table with &lt;code&gt;LATERAL&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">5. таблица &lt;code&gt;customer&lt;/code&gt; с &lt;code&gt;LATERAL&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;см. Здесь&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="28a71a270d0b490ab8b65fcb9dd0ec0dc252b602" translate="yes" xml:space="preserve">
          <source>6. &lt;code&gt;array_agg()&lt;/code&gt; with &lt;code&gt;ORDER BY&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">6. &lt;code&gt;array_agg()&lt;/code&gt; с &lt;code&gt;ORDER BY&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;см. Другой ответ&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e77fc13c9b4bac378cdc79c530cff8444a76a91f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt;&lt;code&gt;DISTINCT ON&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; is a PostgreSQL extension of the standard (where only &lt;code&gt;DISTINCT&lt;/code&gt; on the whole &lt;code&gt;SELECT&lt;/code&gt; list is defined).</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt; &lt;code&gt;DISTINCT ON&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; - расширение стандарта PostgreSQL (где определяется только &lt;code&gt;DISTINCT&lt;/code&gt; во всем списке &lt;code&gt;SELECT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e5dbfddeb30f08b54049675c47334097b5e10ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DISTINCT ON&lt;/code&gt; can be combined with &lt;strong&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/strong&gt;. Leading expressions in &lt;code&gt;ORDER BY&lt;/code&gt; must be in the set of expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt;, but you can rearrange order among those freely. &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;Example.&lt;/a&gt; You can add &lt;em&gt;additional&lt;/em&gt; expressions to &lt;code&gt;ORDER BY&lt;/code&gt; to pick a particular row from each group of peers. Or, as &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;the manual puts it&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; можно комбинировать с &lt;strong&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/strong&gt; . Ведущие выражения в &lt;code&gt;ORDER BY&lt;/code&gt; должны быть в наборе выражений в &lt;code&gt;DISTINCT ON&lt;/code&gt; , но вы можете свободно менять порядок среди них. &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;Пример.&lt;/a&gt; Вы можете добавить &lt;em&gt;дополнительные&lt;/em&gt; выражения в &lt;code&gt;ORDER BY&lt;/code&gt; , чтобы выбрать определенную строку из каждой группы пиров. Или, как &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;сказано в руководстве&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8d496993b6d839bb9dea36ac37618f3a3cee55d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; is an aggregate function, so it works with &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; - агрегатная функция, поэтому она работает с &lt;code&gt;GROUP BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea589215973faa22621d36017e60710d4720f84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; lets you specify an ordering scoped to just itself, so it doesn't constrain the structure of the whole query. There is also syntax for how you sort NULLs, if you need to do something different from the default.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; позволяет вам указать порядок, ограниченный только им самим, поэтому он не ограничивает структуру всего запроса. Существует также синтаксис для сортировки значений NULL, если вам нужно сделать что-то отличное от значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="324791d057789de362088760368f72733ec8e3a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;customer&lt;/code&gt; table - for superior query</source>
          <target state="translated">таблица &lt;code&gt;customer&lt;/code&gt; - для лучшего запроса</target>
        </trans-unit>
        <trans-unit id="9b6347bcc54c96a5d6afc6a91c3b2766235d6e38" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Pick the row with the smallest &lt;code&gt;id&lt;/code&gt; from each group sharing the highest &lt;code&gt;total&lt;/code&gt;.&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;laquo;Выберите строку с наименьшим &lt;code&gt;id&lt;/code&gt; из каждой группы, разделяющей наибольшее &lt;code&gt;total&lt;/code&gt; &amp;raquo;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ef8596eaf70407a2a70716e980229133cc09244" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; queries used an &lt;strong&gt;Index Only Scan&lt;/strong&gt; on &lt;code&gt;purchases2_3c_idx&lt;/code&gt; (among other steps). Some of them just for the smaller size of the index, others more effectively.</source>
          <target state="translated">&lt;em&gt;Во всех&lt;/em&gt; запросах использовалось &lt;strong&gt;сканирование только&lt;/strong&gt; по &lt;strong&gt;индексу&lt;/strong&gt; на &lt;code&gt;purchases2_3c_idx&lt;/code&gt; (среди прочих шагов). Некоторые из них только для меньшего размера индекса, другие более эффективно.</target>
        </trans-unit>
        <trans-unit id="ba89b37ddd35fa61a293ee1c8d26550a43e5c312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;Optimize GROUP BY query to retrieve latest row per user&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;Оптимизировать запрос GROUP BY для получения последней строки для пользователя&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce0fdf92dae6576eb974a49b5cfb0cacb7bf8227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to SQL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вернуться к SQL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5ae4ba7872bce65b6f09a8ef56edcc82bcf22b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: the &lt;code&gt;using (...)&lt;/code&gt; clause is currently not supported in MS-SQL and Oracle db as of this edit on Jan 2017. You have to expand it yourself to e.g. &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; etc.  The USING syntax works in SQLite, MySQL and PostgreSQL.</source>
          <target state="translated">&lt;strong&gt;Предостережение&lt;/strong&gt; : предложение &lt;code&gt;using (...)&lt;/code&gt; в настоящее время не поддерживается в MS-SQL и Oracle db по состоянию на январь 2017 года. Вы должны расширить его, например, до &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; и т. Д. Синтаксис USING работает в SQLite, MySQL и PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="8ed70ea16198c5d6d45b8fbf0ed2b70660f594b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ожидаемый результат:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f6f14e2b0acb25bca7f5a61efae0972b838c25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HOW DOES THAT WORK!&lt;/strong&gt; (I've been there)</source>
          <target state="translated">&lt;strong&gt;КАК ЭТО РАБОТАЕТ!&lt;/strong&gt; (Я был там)</target>
        </trans-unit>
        <trans-unit id="919ebd27c03cd325e823c752933e84712e574cd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;My Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Мой вывод:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddcfd8371e55c2c354271ed9883696c5245698b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some Theoretical Stuff&lt;/strong&gt; (skip this part if you only want to understand the query)</source>
          <target state="translated">&lt;strong&gt;Некоторые теоретические материалы&lt;/strong&gt; (пропустите эту часть, если вы хотите понять только запрос)</target>
        </trans-unit>
        <trans-unit id="bbf1697f55b063038beadb0181046028cc7cdf1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;SELECT&lt;/code&gt; list&lt;/strong&gt; is not constrained by expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; in any way. (Not needed in the simple case above):</source>
          <target state="translated">&lt;strong&gt;Список &lt;code&gt;SELECT&lt;/code&gt; &lt;/strong&gt; никак не ограничен выражениями в &lt;code&gt;DISTINCT ON&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; . (Не требуется в простом случае выше):</target>
        </trans-unit>
        <trans-unit id="20c7b5fd52a03a8d3c11b5edcf49e361b626b681" translate="yes" xml:space="preserve">
          <source>A. Postgres 9.4 with 200k rows and ~ 20 per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">A. Postgres 9.4 с 200 тыс. Строк и ~ 20 на &lt;code&gt;customer_id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8f970457bbe96b6e3501f8789c7b9f915513e61" translate="yes" xml:space="preserve">
          <source>And that's the answer we need.</source>
          <target state="translated">И это ответ,который нам нужен.</target>
        </trans-unit>
        <trans-unit id="e23feb77084817360c7083a788a14965fc076e58" translate="yes" xml:space="preserve">
          <source>As the title suggests, I'd like to select the first row of each set of rows grouped with a &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">Как следует из заголовка, я бы хотел выбрать первую строку каждого набора строк, сгруппированных с помощью &lt;code&gt;GROUP BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1bd75cf1de2fdedb624fae5aa55e8a18adac06" translate="yes" xml:space="preserve">
          <source>B. The same with Postgres 9.5</source>
          <target state="translated">B.То же самое с Постгресом 9.5</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="52825791dd909cc4202b88eeaef7b54ec3becfa8" translate="yes" xml:space="preserve">
          <source>Bold emphasis mine.</source>
          <target state="translated">Смелый акцент.</target>
        </trans-unit>
        <trans-unit id="17aca40b4c23fbfe02d34fb72e4c61a9292f08d4" translate="yes" xml:space="preserve">
          <source>But if you wanna to do such things you probably looking for &lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">Но если вы хотите делать такие вещи, вы, вероятно, ищете &lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;оконные функции&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9fbf6bba2ca0f73231f0d374c9c473e11adbfc0" translate="yes" xml:space="preserve">
          <source>But you need to add logic to break ties:</source>
          <target state="translated">Но тебе нужно добавить логику,чтобы разорвать связи:</target>
        </trans-unit>
        <trans-unit id="6b0bad02864780888057ce496e6b9fabc038f2aa" translate="yes" xml:space="preserve">
          <source>C. Same as B., but with ~ 2.3 rows per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">C. То же, что и B., но с ~ 2,3 строками на &lt;code&gt;customer_id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f2ab710e696b3feb525a155fedbbf8f5f5c12ea" translate="yes" xml:space="preserve">
          <source>CAVEAT: It ignore's NULL rows</source>
          <target state="translated">Игнорирует NULL строки.</target>
        </trans-unit>
        <trans-unit id="a687cecffae4f0c8632214b84368c59a2e6e7153" translate="yes" xml:space="preserve">
          <source>Comparing &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies'&lt;/a&gt; first query (&lt;strong&gt;&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;) to the &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;above &lt;code&gt;DISTINCT ON&lt;/code&gt; solution&lt;/a&gt; (&lt;strong&gt;&lt;code&gt;B&lt;/code&gt;&lt;/strong&gt;):</source>
          <target state="translated">Сравнение первого запроса &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies&lt;/a&gt; ( &lt;strong&gt; &lt;code&gt;A&lt;/code&gt; &lt;/strong&gt; ) с &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;вышеупомянутым решением &lt;code&gt;DISTINCT ON&lt;/code&gt; &lt;/a&gt; ( &lt;strong&gt; &lt;code&gt;B&lt;/code&gt; &lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="acd80818ac5bcea9c24fdae3e88fceaa5145fe2c" translate="yes" xml:space="preserve">
          <source>Configuration parameter work_mem in PostgreSQL on Linux</source>
          <target state="translated">Параметр конфигурации work_mem в PostgreSQL на Linux</target>
        </trans-unit>
        <trans-unit id="7fe2e8c8108bab0f14186604f0961d23506e1bc6" translate="yes" xml:space="preserve">
          <source>Dummy data, PK, index - a typical table also has some dead tuples:</source>
          <target state="translated">Фальшивые данные,PK,индекс-в типичной таблице также есть несколько мертвых кортежей:</target>
        </trans-unit>
        <trans-unit id="174c079c51c262737b6aa7163fe40695d570268e" translate="yes" xml:space="preserve">
          <source>Edit 1 - Use the postgres extension instead</source>
          <target state="translated">Правка 1-используйте вместо этого расширение postgres</target>
        </trans-unit>
        <trans-unit id="fce82fa3164babb13876442255a3ad8934a0e437" translate="yes" xml:space="preserve">
          <source>Edit 2 - Ordering and filtering</source>
          <target state="translated">Редактирование 2-Заказ и фильтрация</target>
        </trans-unit>
        <trans-unit id="75737715bd2086a23ae530d9cc64724b33734c1e" translate="yes" xml:space="preserve">
          <source>Effectiveness / Performance optimization</source>
          <target state="translated">Эффективность Оптимизация производительности</target>
        </trans-unit>
        <trans-unit id="ad6c60c32c0a2398914d7e2f0d2c91d41fd6fbf6" translate="yes" xml:space="preserve">
          <source>Execution time for above queries with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; (and all options &lt;em&gt;off&lt;/em&gt;), &lt;em&gt;best of 5 runs&lt;/em&gt;.</source>
          <target state="translated">Время выполнения вышеупомянутых запросов с &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; (и все опции &lt;em&gt;отключены&lt;/em&gt; ), &lt;em&gt;лучший из 5 запусков&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64d9744934093551048060bf300f0c928c0bed3f" translate="yes" xml:space="preserve">
          <source>Explaination:Here  &lt;strong&gt;Group by&lt;/strong&gt; is done on the basis of customer and then order it by total then each such group is given serial number as StRank and we are taking out first 1 customer whose StRank is 1</source>
          <target state="translated">Пояснение: здесь &lt;strong&gt;Группировка по&lt;/strong&gt; производится на основе клиента, а затем заказывается по сумме, затем каждой такой группе присваивается серийный номер как StRank, и мы выбираем первого 1 клиента, чей StRank равен 1</target>
        </trans-unit>
        <trans-unit id="67f4bc89bd0ee8c2f20b19ee9c93d80b26582d05" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;few&lt;/em&gt; rows per customer&lt;/strong&gt; (high cardinality in column &lt;code&gt;customer&lt;/code&gt;), this is very efficient. Even more so if you need sorted output anyway. The benefit shrinks with a growing number of rows per customer.</source>
          <target state="translated">Для &lt;strong&gt;&lt;em&gt;нескольких&lt;/em&gt; строк на клиента&lt;/strong&gt; (высокая мощность в столбце &lt;code&gt;customer&lt;/code&gt; ) это очень эффективно. Тем более, если вам все равно нужен отсортированный вывод. Преимущество уменьшается с ростом числа строк на одного клиента.</target>
        </trans-unit>
        <trans-unit id="e7c26ad56f293277760cdbfe5b97e01026505b3d" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;many&lt;/em&gt; rows per customer&lt;/strong&gt; (low cardinality in column &lt;code&gt;customer&lt;/code&gt;), a &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;loose index scan&lt;/strong&gt;&lt;/a&gt; (a.k.a. &quot;skip scan&quot;) would be (much) more efficient, but that's not implemented up to Postgres 12. (An implementation for index-only scans is in development for Postgres 13. See &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">Для &lt;strong&gt;&lt;em&gt;многих&lt;/em&gt; строк на одного клиента&lt;/strong&gt; (низкая мощность в столбце &lt;code&gt;customer&lt;/code&gt; ) &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;свободное сканирование индекса&lt;/strong&gt;&lt;/a&gt; (так называемое &amp;laquo;сканирование с пропуском&amp;raquo;) будет (намного) более эффективным, но оно не реализовано до Postgres 12. (Реализация сканирования только по индексу в разработке для Postgres 13. Смотрите &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;здесь&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;здесь&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="3573651362ae5e478981982b3b1e27c37c25fabf" translate="yes" xml:space="preserve">
          <source>For Postgres 9.5 I ran a 2nd test with effectively 86446 distinct customers. See below (&lt;em&gt;avg. 2.3 rows per customer&lt;/em&gt;).</source>
          <target state="translated">Для Postgres 9.5 я провел второй тест с 86446 различными клиентами. Смотрите ниже (в &lt;em&gt;среднем 2,3 строки на клиента&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="5885b552b6ab83e07125a70548b0c986996b8178" translate="yes" xml:space="preserve">
          <source>For SQl Server the most efficient way is:</source>
          <target state="translated">Для SQl Server самый эффективный способ:</target>
        </trans-unit>
        <trans-unit id="3fa33ded2a46b10ad416ee2d3ffc070fa4d90ff9" translate="yes" xml:space="preserve">
          <source>For now, there are &lt;strong&gt;faster query techniques&lt;/strong&gt; to substitute for this. In particular if you have a separate table holding unique customers, which is the typical use case. But also if you don't:</source>
          <target state="translated">Пока есть &lt;strong&gt;более быстрые методы запроса,&lt;/strong&gt; чтобы заменить это. В частности, если у вас есть отдельная таблица с уникальными клиентами, это типичный вариант использования. Но также, если вы этого не сделаете:</target>
        </trans-unit>
        <trans-unit id="adc98243acc2f50c6cd9268d1a23bdb2ac5b1062" translate="yes" xml:space="preserve">
          <source>Generated with &lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;this query&lt;/a&gt;.</source>
          <target state="translated">Сгенерировано с &lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;этим запросом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01d1b9a5f5078d105e1cc0eaa95c676eae08b4ea" translate="yes" xml:space="preserve">
          <source>Here I provide a same-approach, but more complete and clean any-database solution.   Ties are considered (assume desire to get only one row for each customer, even multiple records for max total per customer), and other purchase fields (e.g. purchase_payment_id) will be selected for the real matching rows in the purchase table.</source>
          <target state="translated">Здесь я предоставляю одинаковый подход,но более полное и чистое решение для любой базы данных.Рассматриваются связи (предположим,желание получить только одну строку для каждого покупателя,даже несколько записей для макс.общей суммы на одного покупателя),а другие поля покупки (например,purchase_payment_id)будут выбраны для реальных совпадающих строк в таблице покупок.</target>
        </trans-unit>
        <trans-unit id="1e3129050964ca90864ffa2acb569e107645deb0" translate="yes" xml:space="preserve">
          <source>Here is a new one by &quot;ogr&quot; testing with &lt;strong&gt;10M rows and 60k unique &quot;customers&quot;&lt;/strong&gt; on &lt;strong&gt;Postgres 11.5&lt;/strong&gt; (current as of Sep. 2019). Results are still in line with what we have seen so far:</source>
          <target state="translated">Вот новый тест &quot;ogr&quot; с &lt;strong&gt;10M строками и 60k уникальных &quot;клиентов&quot;&lt;/strong&gt; на &lt;strong&gt;Postgres 11.5&lt;/strong&gt; (по состоянию на сентябрь 2019 года). Результаты по-прежнему соответствуют тому, что мы видели до сих пор:</target>
        </trans-unit>
        <trans-unit id="f098395b6ea6fcdc083ec3a7f6ea0975316c1705" translate="yes" xml:space="preserve">
          <source>I added &lt;code&gt;id&lt;/code&gt; as last item to break ties:</source>
          <target state="translated">Я добавил &lt;code&gt;id&lt;/code&gt; как последний элемент для разрыва связей:</target>
        </trans-unit>
        <trans-unit id="c90b5abd370bd36ee6b7906498a63b93f5448bf7" translate="yes" xml:space="preserve">
          <source>I created a composite &lt;code&gt;(id, total)&lt;/code&gt;, so both values are returned by the same aggregate. You can of course always apply &lt;code&gt;first_value()&lt;/code&gt; twice.</source>
          <target state="translated">Я создал композит &lt;code&gt;(id, total)&lt;/code&gt; , поэтому оба значения возвращаются одним и тем же агрегатом. Конечно, вы всегда можете применить &lt;code&gt;first_value()&lt;/code&gt; дважды.</target>
        </trans-unit>
        <trans-unit id="130b1834e42433119953b32cd075fdef4902f9c6" translate="yes" xml:space="preserve">
          <source>I had a simple benchmark here which is outdated by now. I replaced it with a &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;detailed benchmark in this separate answer&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">У меня был простой тест, который уже устарел. Я заменил его &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;подробным тестом в этом отдельном ответе&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e09671f3bd26252ac5be9d0a7116458ae0d8bc22" translate="yes" xml:space="preserve">
          <source>I ran three tests with PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt; on a real life table of 65579 rows and single-column btree indexes on each of the three columns involved and took the best &lt;em&gt;execution time&lt;/em&gt; of 5 runs.</source>
          <target state="translated">Я выполнил три теста с PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt; для реальной таблицы из 65579 строк и одностолбцовых индексов btree для каждого из трех задействованных столбцов и показал лучшее &lt;em&gt;время выполнения&lt;/em&gt; из 5 запусков.</target>
        </trans-unit>
        <trans-unit id="50ef525b77740b26d2f800be1f31dc196cd1a5b7" translate="yes" xml:space="preserve">
          <source>I tested with Postgres versions 8.3 &amp;ndash; 12. But the feature has been there at least since version 7.1, so basically always.</source>
          <target state="translated">Я тестировал с Postgres версии 8.3 - 12. Но эта функция была там, по крайней мере, начиная с версии 7.1, так что в основном всегда.</target>
        </trans-unit>
        <trans-unit id="63fe6b185c7bbea3849dd47a10061ff96c0bd0d6" translate="yes" xml:space="preserve">
          <source>I use a &lt;code&gt;serial&lt;/code&gt; (PK constraint added below) and an integer &lt;code&gt;customer_id&lt;/code&gt; since that's a more typical setup. Also added &lt;code&gt;some_column&lt;/code&gt; to make up for typically more columns.</source>
          <target state="translated">Я использую &lt;code&gt;serial&lt;/code&gt; (ограничение PK добавлено ниже) и целое число &lt;code&gt;customer_id&lt;/code&gt; , так как это более типичная установка. Также добавлен &lt;code&gt;some_column&lt;/code&gt; , чтобы компенсировать обычно больше столбцов.</target>
        </trans-unit>
        <trans-unit id="e6eee036e14e840a888fce846d96052e9490f45f" translate="yes" xml:space="preserve">
          <source>I use this way (postgresql only): &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&lt;/a&gt;</source>
          <target state="translated">Я использую этот способ (только postgresql): &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="058e05d7a94c12abe5d88dcda3d94f529d56876e" translate="yes" xml:space="preserve">
          <source>I'd like to query for the &lt;code&gt;id&lt;/code&gt; of the largest purchase (&lt;code&gt;total&lt;/code&gt;) made by each &lt;code&gt;customer&lt;/code&gt;. Something like this:</source>
          <target state="translated">Я хотел бы запросить &lt;code&gt;id&lt;/code&gt; самой крупной покупки ( &lt;code&gt;total&lt;/code&gt; ), совершенной каждым &lt;code&gt;customer&lt;/code&gt; . Что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="49e5ca82598636f91cd9a8e958c6a1d9a9469aa9" translate="yes" xml:space="preserve">
          <source>Ideally, you have enough &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to process the involved sort step in RAM and not spill to disk. But generally setting &lt;code&gt;work_mem&lt;/code&gt;&lt;em&gt;too&lt;/em&gt; high can have adverse effects. Consider &lt;code&gt;SET LOCAL&lt;/code&gt; for exceptionally big queries. Find how much you need with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;. Mention of &quot;&lt;em&gt;Disk:&lt;/em&gt;&quot; in the sort step indicates the need for more:</source>
          <target state="translated">В идеале, у вас достаточно &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; для обработки соответствующего шага сортировки в оперативной памяти, а не для сброса на диск. Но обычно &lt;em&gt;слишком&lt;/em&gt; высокое значение &lt;code&gt;work_mem&lt;/code&gt; может иметь негативные последствия. Рассмотрим &lt;code&gt;SET LOCAL&lt;/code&gt; для исключительно больших запросов. Узнайте, сколько вам нужно с &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; . Упоминание &amp;laquo; &lt;em&gt;Диск:&lt;/em&gt; &amp;raquo; на этапе сортировки указывает на необходимость большего:</target>
        </trans-unit>
        <trans-unit id="115e7329106b556464ad2183dc9b3466d332e3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL (won't hurt either way, but you'll want to &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;match existing indexes&lt;/a&gt;):</source>
          <target state="translated">Если &lt;code&gt;total&lt;/code&gt; может быть NULL (не повредит в любом случае, но вы захотите &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;соответствовать существующим индексам&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="885869bd8bb57ffb30ae77b739b5f2d997c205b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL, you &lt;em&gt;most probably&lt;/em&gt; want the row with the greatest non-null value. Add &lt;strong&gt;&lt;code&gt;NULLS LAST&lt;/code&gt;&lt;/strong&gt; like demonstrated. See:</source>
          <target state="translated">Если &lt;code&gt;total&lt;/code&gt; может быть NULL, вы, &lt;em&gt;скорее всего,&lt;/em&gt; захотите строку с наибольшим ненулевым значением. Добавьте &lt;strong&gt; &lt;code&gt;NULLS LAST&lt;/code&gt; ,&lt;/strong&gt; как показано. Увидеть:</target>
        </trans-unit>
        <trans-unit id="f3ff0102a461bc45f392997d6b4457df923ab8d8" translate="yes" xml:space="preserve">
          <source>If we left joins the table on the name and total being less than the joined table:</source>
          <target state="translated">Если мы оставим присоединение к таблице по имени,то общая сумма будет меньше,чем присоединенная таблица:</target>
        </trans-unit>
        <trans-unit id="1bc90c6679c8f97e7e0ae81bc6b9546fcda369ac" translate="yes" xml:space="preserve">
          <source>If you use aggregate functions (like these), you can order the results, without the need to have the data already ordered:</source>
          <target state="translated">Если вы используете функции агрегирования (как эти),вы можете заказать результаты,без необходимости иметь уже заказанные данные:</target>
        </trans-unit>
        <trans-unit id="513b52421e643bf265232a5b0303884aee1f29a9" translate="yes" xml:space="preserve">
          <source>If you want to select any (by your some specific condition) row from the set of aggregated rows.</source>
          <target state="translated">Если вы хотите выбрать любую (по вашему определенному условию)строку из набора агрегированных строк.</target>
        </trans-unit>
        <trans-unit id="14f29bfc41c897a3e227d298f67de89585505bbf" translate="yes" xml:space="preserve">
          <source>If you want to use another (&lt;code&gt;sum/avg&lt;/code&gt;) aggregation function in addition to &lt;code&gt;max/min&lt;/code&gt;. Thus you can not use clue with &lt;code&gt;DISTINCT ON&lt;/code&gt;</source>
          <target state="translated">Если вы хотите использовать другую ( &lt;code&gt;sum/avg&lt;/code&gt; ) функцию агрегирования в дополнение к &lt;code&gt;max/min&lt;/code&gt; . Таким образом, вы не можете использовать ключ с &lt;code&gt;DISTINCT ON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95f04d79bc6e9f1a1a378d50e9a21929eef79e61" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PostgreSQL&lt;/strong&gt; this is typically &lt;strong&gt;simpler and faster&lt;/strong&gt; (more performance optimization below):</source>
          <target state="translated">В &lt;strong&gt;PostgreSQL&lt;/strong&gt; это обычно &lt;strong&gt;проще и быстрее&lt;/strong&gt; (подробнее об оптимизации производительности ниже):</target>
        </trans-unit>
        <trans-unit id="3030a2fec9c767d8ff7ccbf769b9e4f47aa7fac4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, another possibility is to use the &lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt;&lt;code&gt;first_value&lt;/code&gt;&lt;/a&gt; window function in combination with &lt;code&gt;SELECT DISTINCT&lt;/code&gt;:</source>
          <target state="translated">В PostgreSQL другой возможностью является использование оконной функции &lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt; &lt;code&gt;first_value&lt;/code&gt; &lt;/a&gt; в сочетании с &lt;code&gt;SELECT DISTINCT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70b88621817cca0608b7dda4ed35638f90c58d08" translate="yes" xml:space="preserve">
          <source>In Postgres you can use &lt;code&gt;array_agg&lt;/code&gt; like this:</source>
          <target state="translated">В Postgres вы можете использовать &lt;code&gt;array_agg&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b958a892b980456789c653c74f646b5dec93aaf4" translate="yes" xml:space="preserve">
          <source>In SQL Server you can do this:</source>
          <target state="translated">В SQL Server это можно сделать:</target>
        </trans-unit>
        <trans-unit id="eaadf570b7bb1e4a6396c6bcba18cbed9639f58a" translate="yes" xml:space="preserve">
          <source>In my &lt;strong&gt;second test&lt;/strong&gt; for 9.5 I used the same setup, but with &lt;code&gt;random() * 100000&lt;/code&gt; to generate &lt;code&gt;customer_id&lt;/code&gt; to get only few rows per &lt;code&gt;customer_id&lt;/code&gt;.</source>
          <target state="translated">Во &lt;strong&gt;втором тесте&lt;/strong&gt; для 9.5 я использовал ту же настройку, но с &lt;code&gt;random() * 100000&lt;/code&gt; чтобы сгенерировать &lt;code&gt;customer_id&lt;/code&gt; и получить только несколько строк на &lt;code&gt;customer_id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="76ff0109afd7a40bd9c16251d32e49ec91dea601" translate="yes" xml:space="preserve">
          <source>It's a postgres extension that gives you first and last functions; apparently faster than the above way.</source>
          <target state="translated">Это расширение postgres,которое дает вам первую и последнюю функции;очевидно,быстрее,чем описанный выше способ.</target>
        </trans-unit>
        <trans-unit id="d991a62bb10a62ed754485867ff0e408d74d7e89" translate="yes" xml:space="preserve">
          <source>Let Total be a function T(customer,id) where it returns a value given the name and id
To prove that the given total (T(customer,id)) is the highest we have to prove that
We want to prove either</source>
          <target state="translated">Пусть Всего будет функция T (клиент,id),где он возвращает значение,данное имя и ID Чтобы доказать,что данное общее (T (клиент,id))является самым высоким мы должны доказать,что мы хотим доказать,что или</target>
        </trans-unit>
        <trans-unit id="2e5632d0f807b3f34cf7f69dec1047fe433b911d" translate="yes" xml:space="preserve">
          <source>List any number of expressions in the &lt;code&gt;DISTINCT ON&lt;/code&gt; clause, the combined row value defines duplicates. &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;The manual:&lt;/a&gt;</source>
          <target state="translated">Укажите любое количество выражений в предложении &lt;code&gt;DISTINCT ON&lt;/code&gt; , объединенное значение строки определяет дубликаты. &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;Руководство:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="464f7790b102ce69cf3acd7d69f43f9a52b82086" translate="yes" xml:space="preserve">
          <source>Main table</source>
          <target state="translated">Главный стол</target>
        </trans-unit>
        <trans-unit id="9e85255a09c56ff34c3fc3aaf30b6b3e8b91258b" translate="yes" xml:space="preserve">
          <source>Major points</source>
          <target state="translated">Основные моменты</target>
        </trans-unit>
        <trans-unit id="d12153394231071e15cd8c3b11dfb9916cc27f28" translate="yes" xml:space="preserve">
          <source>May be too specialized. But use it if read performance for the particular query is crucial. If you have &lt;code&gt;DESC NULLS LAST&lt;/code&gt; in the query, use the same in the index so that sort order matches and the index is applicable.</source>
          <target state="translated">Может быть слишком специализированным. Но используйте его, если производительность чтения для конкретного запроса имеет решающее значение. Если в запросе указано значение &lt;code&gt;DESC NULLS LAST&lt;/code&gt; , используйте его в индексе, чтобы порядок сортировки соответствовал и индекс был применим.</target>
        </trans-unit>
        <trans-unit id="dfff4eefffc08fe064edf770d418be997d8af5cd" translate="yes" xml:space="preserve">
          <source>Note that bunch of solutions to this common problem can surprisingly be found in the one of most official sources, &lt;strong&gt;MySQL manual&lt;/strong&gt;! See &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;Examples of Common Queries :: The Rows Holding the Group-wise Maximum of a Certain Column&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что кучу решений этой распространенной проблемы можно найти в одном из самых официальных источников, &lt;strong&gt;руководстве по MySQL&lt;/strong&gt; ! См. &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;Примеры общих запросов :: Строки, содержащие групповой максимум определенного столбца&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df659bc5a4cb564a96f76217ff3e2438b57ef8b7" translate="yes" xml:space="preserve">
          <source>Now I use this way: &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http://pgxn.org/dist/first_last_agg/&lt;/a&gt;</source>
          <target state="translated">Теперь я использую этот способ: &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http://pgxn.org/dist/first_last_agg/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="ae8661bf223d4e024221cc558b5e2889d1ab01aa" translate="yes" xml:space="preserve">
          <source>Object sizes for table &lt;code&gt;purchases&lt;/code&gt;</source>
          <target state="translated">Размеры объекта для &lt;code&gt;purchases&lt;/code&gt; стола</target>
        </trans-unit>
        <trans-unit id="0c3894fd7032a7b8b88d3da5aa8a3469655ef31d" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least
  one column value. &lt;strong&gt;Null values are considered equal in this comparison.&lt;/strong&gt;</source>
          <target state="translated">Очевидно, что две строки считаются разными, если они отличаются хотя бы одним значением столбца. &lt;strong&gt;Нулевые значения считаются равными в этом сравнении.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="311285b287ae794f8a6e6e16f340d4537b8dfbc1" translate="yes" xml:space="preserve">
          <source>Of course you can order and filter as you deem fit within the aggregate; it's very powerful syntax.</source>
          <target state="translated">Конечно,вы можете заказывать и фильтровать так,как считаете нужным внутри агрегата;это очень мощный синтаксис.</target>
        </trans-unit>
        <trans-unit id="982f7546a2eb8df6633eb73d3e3883d3525fe955" translate="yes" xml:space="preserve">
          <source>On Oracle 9.2+ (not 8i+ as originally stated), SQL Server 2005+, PostgreSQL 8.4+, DB2, Firebird 3.0+, Teradata, Sybase, Vertica:</source>
          <target state="translated">На Oracle 9.2+(а не 8i+,как было заявлено изначально),SQL Server 2005+,PostgreSQL 8.4+,DB2,Firebird 3.0+,Teradata,Sybase,Vertica:</target>
        </trans-unit>
        <trans-unit id="0ea92a1813c9ad07657cdc2ac29023c0cbfc39c1" translate="yes" xml:space="preserve">
          <source>Once we build the array, we take the first element. (Postgres arrays are 1-indexed, not 0-indexed).</source>
          <target state="translated">Как только мы строим массив,мы берем первый элемент.(Массивы Postgres-1-индексированные,а не 0-индексированные).</target>
        </trans-unit>
        <trans-unit id="b8a1b609b59584ecf9bb25c6e8bacdb3704cca90" translate="yes" xml:space="preserve">
          <source>Optimize groupwise maximum query</source>
          <target state="translated">Оптимизировать групповой максимальный запрос</target>
        </trans-unit>
        <trans-unit id="bf017f217553f1cf968db1e65b41af2ab992d2d5" translate="yes" xml:space="preserve">
          <source>Optimize simple query using ORDER BY date and text</source>
          <target state="translated">Оптимизация простого запроса с помощью команды ЗАПИСЬ по дате и тексту</target>
        </trans-unit>
        <trans-unit id="a67837359416b99ab5311803744d610256a22309" translate="yes" xml:space="preserve">
          <source>Or shorter (if not as clear) with ordinal numbers of output columns:</source>
          <target state="translated">Или короче (если не так ясно)с порядковыми номерами выходных столбцов:</target>
        </trans-unit>
        <trans-unit id="24fa5a2c8e0b4079cb5f9fe868a9bd59518f7bc4" translate="yes" xml:space="preserve">
          <source>Original (outdated) benchmark from 2011</source>
          <target state="translated">Оригинальный (устаревший)эталон 2011 года</target>
        </trans-unit>
        <trans-unit id="323c83c0f69c9372d7ee234ccace23a4e5de3ce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL sort by datetime asc, null first?</source>
          <target state="translated">PostgreSQL сортирует по восходящей дате,ноль первым?</target>
        </trans-unit>
        <trans-unit id="b244b2217c8b6c534f37d1f03cf14604ed7ba5e5" translate="yes" xml:space="preserve">
          <source>Proper way to access latest row for each individual identifier?</source>
          <target state="translated">Правильный способ доступа к последней строке для каждого отдельного идентификатора?</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="0b8a47b88d837280e3fab94fe4d2bd803b3c158f" translate="yes" xml:space="preserve">
          <source>Query last N related rows per row</source>
          <target state="translated">Последний запрос N строк на строку</target>
        </trans-unit>
        <trans-unit id="e8536401a76da15c6c761038b81a6fa0d744d0c4" translate="yes" xml:space="preserve">
          <source>Related benchmarks</source>
          <target state="translated">Соответствующие контрольные показатели</target>
        </trans-unit>
        <trans-unit id="a88f66d2299b63003d3d871345537088ff79ce05" translate="yes" xml:space="preserve">
          <source>Remark:</source>
          <target state="translated">Remark:</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="ba1151ed7036215586ab2deb08df3dd651d11cd8" translate="yes" xml:space="preserve">
          <source>Same test repeated with the index described in the other answer</source>
          <target state="translated">Тот же тест повторяется с индексом,описанным в другом ответе.</target>
        </trans-unit>
        <trans-unit id="02fa4b7c2eb7288cc2dd7860b97e7fcc7c3c81d0" translate="yes" xml:space="preserve">
          <source>Select a single customer with &lt;code&gt;WHERE customer = x&lt;/code&gt;.</source>
          <target state="translated">Выберите одного клиента с &lt;code&gt;WHERE customer = x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253368c0449de38cab696b8fe6b4a86a8b102762" translate="yes" xml:space="preserve">
          <source>Select first row in each GROUP BY group</source>
          <target state="translated">Выберите первую строку в каждой группе GROUP BY</target>
        </trans-unit>
        <trans-unit id="584e375ddcb38e2b1f417648316c35cf906dbf11" translate="yes" xml:space="preserve">
          <source>Select the whole table, results in 5958 rows in this case.</source>
          <target state="translated">Выберите всю таблицу,в этом случае получится 5958 строк.</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="25075eb661f7180b5138442fe9b8c1612f5add01" translate="yes" xml:space="preserve">
          <source>Snowflake/Teradata supports &lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt;&lt;code&gt;QUALIFY&lt;/code&gt;&lt;/a&gt; clause which works like &lt;code&gt;HAVING&lt;/code&gt; for windowed functions:</source>
          <target state="translated">Snowflake / Teradata поддерживает предложение &lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt; &lt;code&gt;QUALIFY&lt;/code&gt; &lt;/a&gt; , которое работает как &lt;code&gt;HAVING&lt;/code&gt; для оконных функций:</target>
        </trans-unit>
        <trans-unit id="a77cdea121464bd8808b2f7a4d983ddee817a186" translate="yes" xml:space="preserve">
          <source>So the equivalent example, with ordering would be something like:</source>
          <target state="translated">Так что эквивалентным примером,с заказом,было бы что-то вроде:</target>
        </trans-unit>
        <trans-unit id="fe91dbd517e1619f524c6cc3d78de6f788ca2326" translate="yes" xml:space="preserve">
          <source>Some things to note:</source>
          <target state="translated">Некоторые вещи нужно отметить:</target>
        </trans-unit>
        <trans-unit id="24b54af2f3501272eaa2d4bb4a4c29ad87c41036" translate="yes" xml:space="preserve">
          <source>Specifically, if I've got a &lt;code&gt;purchases&lt;/code&gt; table that looks like this:</source>
          <target state="translated">В частности, если у меня есть таблица &lt;code&gt;purchases&lt;/code&gt; которая выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="e80c2fdd2ef29bdb9b48c3567af9314011689fa6" translate="yes" xml:space="preserve">
          <source>Supported by any database:</source>
          <target state="translated">Поддерживается любой базой данных:</target>
        </trans-unit>
        <trans-unit id="7e5062ca17fb1a192f52106e7c6e38c488fdd328" translate="yes" xml:space="preserve">
          <source>Testing the most interesting candidates with Postgres &lt;strong&gt;9.4&lt;/strong&gt; and &lt;strong&gt;9.5&lt;/strong&gt; with a halfway realistic table of &lt;strong&gt;200k rows&lt;/strong&gt; in &lt;code&gt;purchases&lt;/code&gt; and &lt;strong&gt;10k distinct &lt;code&gt;customer_id&lt;/code&gt;&lt;/strong&gt; (&lt;em&gt;avg. 20 rows per customer&lt;/em&gt;).</source>
          <target state="translated">Тестирование наиболее интересных кандидатов с Postgres &lt;strong&gt;9.4&lt;/strong&gt; и &lt;strong&gt;9.5&lt;/strong&gt; с наполовину реалистичной таблицей &lt;strong&gt;200 тыс. Строк&lt;/strong&gt; в &lt;code&gt;purchases&lt;/code&gt; и &lt;strong&gt;10 тыс. Различных &lt;code&gt;customer_id&lt;/code&gt; &lt;/strong&gt; (в &lt;em&gt;среднем 20 строк на клиента&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c0349a949a02df07cfe9df6fb72a596095aac53" translate="yes" xml:space="preserve">
          <source>That will help us filter for the highest total for each purchase with no grouping needed:</source>
          <target state="translated">Это поможет нам отфильтровывать наивысшую общую сумму для каждой покупки без необходимости группировки:</target>
        </trans-unit>
        <trans-unit id="8263d90ff6ffdae1372239c757291f48e712a876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DISTINCT ON&lt;/code&gt; expression(s) must match the leftmost &lt;code&gt;ORDER BY&lt;/code&gt;
  expression(s). The &lt;code&gt;ORDER BY&lt;/code&gt; clause will normally contain additional
  expression(s) that determine the desired precedence of rows within
  each &lt;code&gt;DISTINCT ON&lt;/code&gt; group.</source>
          <target state="translated">Выражения &lt;code&gt;DISTINCT ON&lt;/code&gt; должны соответствовать крайнему левому выражению &lt;code&gt;ORDER BY&lt;/code&gt; . Предложение &lt;code&gt;ORDER BY&lt;/code&gt; обычно содержит дополнительные выражения, которые определяют желаемый приоритет строк в каждой группе &lt;code&gt;DISTINCT ON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f13e19f9b15111fb7b1bde58351508e53c21d6dc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;perfect&lt;/em&gt; index for the above query would be a &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;multi-column index&lt;/a&gt; spanning all three columns in matching sequence and with matching sort order:</source>
          <target state="translated">&lt;em&gt;Идеальным&lt;/em&gt; индексом для вышеуказанного запроса будет &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;индекс&lt;/a&gt; из нескольких столбцов, охватывающий все три столбца в соответствующей последовательности и с соответствующим порядком сортировки:</target>
        </trans-unit>
        <trans-unit id="9e1b4aba07ab733b78ed9bef8497132427b3cab0" translate="yes" xml:space="preserve">
          <source>The Query:</source>
          <target state="translated">Запрос:</target>
        </trans-unit>
        <trans-unit id="183fa3d4a15533a9e707bd462d1faacae935ae4e" translate="yes" xml:space="preserve">
          <source>The accepted OMG Ponies' &quot;Supported by any database&quot; solution has good speed from my test.</source>
          <target state="translated">Принятое решение OMG Ponies' &quot;Поддерживаемое любой базой данных&quot; имеет хорошую скорость от моего теста.</target>
        </trans-unit>
        <trans-unit id="6502ba17b0b16f09c8a81764063487d6e256b438" translate="yes" xml:space="preserve">
          <source>The first approach will need us to get all the records for that name which I do not really like.</source>
          <target state="translated">При первом подходе нам понадобятся все записи для этого имени,которое мне не очень нравится.</target>
        </trans-unit>
        <trans-unit id="d766cf318ecc2510338dec9362ebccbe8d7c0677" translate="yes" xml:space="preserve">
          <source>The index is used because it delivers pre-sorted data. In Postgres 9.2 or later the query can also benefit from an &lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;index only scan&lt;/a&gt;&lt;/strong&gt; if the index is smaller than the underlying table. The index has to be scanned in its entirety, though.</source>
          <target state="translated">Индекс используется потому, что он предоставляет предварительно отсортированные данные. В Postgres 9.2 или более поздних версиях запрос также может быть полезен при &lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;сканировании только индекса,&lt;/a&gt;&lt;/strong&gt; если индекс меньше базовой таблицы. Тем не менее, индекс должен быть отсканирован полностью.</target>
        </trans-unit>
        <trans-unit id="05df13c53001ea7238498c9bd30e304edb5a0a31" translate="yes" xml:space="preserve">
          <source>The second one will need a smart way to say there can be no record higher than this one.</source>
          <target state="translated">Второму понадобится умный способ сказать,что не может быть рекордов выше этого.</target>
        </trans-unit>
        <trans-unit id="0a3460435b2ba05f43754f4db17512ff936ee290" translate="yes" xml:space="preserve">
          <source>The solution is not very efficient as pointed by Erwin, because of presence of SubQs</source>
          <target state="translated">Решение не очень эффективное,как указал Эрвин,из-за наличия SubQs</target>
        </trans-unit>
        <trans-unit id="c14ef83d661641de58fc6d2cfd57cb77febe4cb3" translate="yes" xml:space="preserve">
          <source>Then your example should work &lt;em&gt;almost&lt;/em&gt; as is:</source>
          <target state="translated">Тогда ваш пример должен работать &lt;em&gt;почти&lt;/em&gt; так:</target>
        </trans-unit>
        <trans-unit id="14af5152d85077e382ef162c9c2c6ca124d91883" translate="yes" xml:space="preserve">
          <source>This is common &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem, which already has well tested and highly &lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;optimized solutions&lt;/a&gt;. Personally I prefer the &lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;left join solution by Bill Karwin&lt;/a&gt; (the &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;original post with lots of other solutions&lt;/a&gt;).</source>
          <target state="translated">Это общая проблема с &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;наибольшим числом групп&lt;/a&gt; , которая уже имеет хорошо протестированные и высоко &lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;оптимизированные решения&lt;/a&gt; . Лично я предпочитаю &lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;левое решение Билла Карвина&lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;оригинальный пост с множеством других решений&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9f6bb60b44756b7628cdf5d79a2596547457d1a3" translate="yes" xml:space="preserve">
          <source>This query is reasonably fast especially when there is a composite index like (customer, total) on the purchase table.</source>
          <target state="translated">Этот запрос является достаточно быстрым,особенно когда есть составной индекс,как (клиент,итог)в таблице покупок.</target>
        </trans-unit>
        <trans-unit id="0a08adcb0b93966d68f2bc6f7a603c1356fcf793" translate="yes" xml:space="preserve">
          <source>This will give you the &lt;code&gt;id&lt;/code&gt; of each customer's largest purchase.</source>
          <target state="translated">Это даст вам &lt;code&gt;id&lt;/code&gt; крупнейшей покупки каждого клиента.</target>
        </trans-unit>
        <trans-unit id="fc8bd5672beabcb0e52175bab260889953b1655e" translate="yes" xml:space="preserve">
          <source>To install on ubuntu 14.04:</source>
          <target state="translated">Для установки на убунту 14.04:</target>
        </trans-unit>
        <trans-unit id="3db7721a0740ae1052b100a1e77bf4b8e03a8a7b" translate="yes" xml:space="preserve">
          <source>To order results in a way that disagrees with the sort order determining the first per group, you can nest above query in an outer query with another &lt;code&gt;ORDER BY&lt;/code&gt;. &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;Example.&lt;/a&gt;</source>
          <target state="translated">Чтобы упорядочить результаты способом, который не согласуется с порядком сортировки, определяющим первое для каждой группы, вы можете вкладывать вышеуказанный запрос во внешний запрос с другим &lt;code&gt;ORDER BY&lt;/code&gt; . &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;Пример.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46ed51fa8a387f78df24cb7924cc5d43ab1faeb1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;DISTINCT ON&lt;/code&gt;, using &lt;code&gt;array_agg&lt;/code&gt; lets you keep your &lt;code&gt;GROUP BY&lt;/code&gt;, in case you want that for other reasons.</source>
          <target state="translated">В отличие от &lt;code&gt;DISTINCT ON&lt;/code&gt; , использование &lt;code&gt;array_agg&lt;/code&gt; позволяет вам сохранить ваш &lt;code&gt;GROUP BY&lt;/code&gt; , если вы хотите этого по другим причинам.</target>
        </trans-unit>
        <trans-unit id="5d9409fc69c35c5edb50908ff3ef3bccafb2a22f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ARRAY_AGG&lt;/code&gt; function for &lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt;, and &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL&lt;/a&gt;:</source>
          <target state="translated">Используйте функцию &lt;code&gt;ARRAY_AGG&lt;/code&gt; для &lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt; , &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt; , &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt; и &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a1f57e731466c6b4c22dbef205787a34542575cf" translate="yes" xml:space="preserve">
          <source>Use condition &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; resulting in 1000 rows.</source>
          <target state="translated">Используйте условие &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; результате чего 1000 строк.</target>
        </trans-unit>
        <trans-unit id="479bc7f3be51824caa77d22a6caca1d270a0d65b" translate="yes" xml:space="preserve">
          <source>Very fast solution</source>
          <target state="translated">Очень быстрое решение</target>
        </trans-unit>
        <trans-unit id="17affe0f45ae018cfaeeaaec42cd75a97768f98a" translate="yes" xml:space="preserve">
          <source>We want to make sure that we only have the highest total for each purchase.</source>
          <target state="translated">Мы хотим быть уверены,что у нас есть только самая высокая сумма за каждую покупку.</target>
        </trans-unit>
        <trans-unit id="5c100673b890deacae49fafdc2ea596fde78f6a1" translate="yes" xml:space="preserve">
          <source>Weigh cost and benefit before creating tailored indexes for each query. The potential of above index largely depends on &lt;strong&gt;data distribution&lt;/strong&gt;.</source>
          <target state="translated">Взвесьте стоимость и выгоду перед созданием индивидуальных индексов для каждого запроса. Потенциал вышеуказанного индекса во многом зависит от &lt;strong&gt;распределения данных&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="06f515e1d1ba4e92316990ed365daa5ce9e800bc" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; include any other expression in the &lt;code&gt;SELECT&lt;/code&gt; list. This is instrumental for replacing much more complex queries with subqueries and aggregate / window functions.</source>
          <target state="translated">Вы &lt;em&gt;можете&lt;/em&gt; включить любое другое выражение в список &lt;code&gt;SELECT&lt;/code&gt; . Это способствует замене гораздо более сложных запросов подзапросами и агрегатными / оконными функциями.</target>
        </trans-unit>
        <trans-unit id="50d72a485d91aa310f99089fed392d899b7d2143" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don't have to&lt;/em&gt; include any of the expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">Вам &lt;em&gt;не нужно&lt;/em&gt; включать какие-либо выражения в &lt;code&gt;DISTINCT ON&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4335d470451a86c659a4bb868ff8503b753296c3" translate="yes" xml:space="preserve">
          <source>You can replace &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; with any condition you want with one restriction: This subquery must not return more than one row</source>
          <target state="translated">Вы можете заменить &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; любым условием с одним ограничением: этот подзапрос не должен возвращать более одной строки</target>
        </trans-unit>
        <trans-unit id="ff8ad01ccf2ca61d81d3b6151da26b5764ea41ec" translate="yes" xml:space="preserve">
          <source>You can use next subquery:</source>
          <target state="translated">Вы можете использовать следующий подзапрос:</target>
        </trans-unit>
        <trans-unit id="780f59927c03bd3be899b36571f8ee337f8e53df" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;array_agg&lt;/code&gt; in a similar way for your third output column, but &lt;code&gt;max(total)&lt;/code&gt; is simpler.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;array_agg&lt;/code&gt; аналогичным образом для третьего выходного столбца, но &lt;code&gt;max(total)&lt;/code&gt; проще.</target>
        </trans-unit>
        <trans-unit id="0a9176588fee007a7b61d9f6efb42dd41d191785" translate="yes" xml:space="preserve">
          <source>and don't forget to create clustered index for used columns</source>
          <target state="translated">и не забудьте создать кластерный индекс для использованных столбцов.</target>
        </trans-unit>
        <trans-unit id="88200cf876dc2073e81590d595033eb094e2c28d" translate="yes" xml:space="preserve">
          <source>and really very fast if table is indexed by id:</source>
          <target state="translated">и очень быстро,если таблица проиндексирована по id:</target>
        </trans-unit>
        <trans-unit id="bf114a4fa7e29ac34c48f6e08b28e60a65ca3444" translate="yes" xml:space="preserve">
          <source>t1, t2 are subquery alias which could be removed depending on database.</source>
          <target state="translated">t1,t2-это псевдонимы подзапросов,которые могут быть удалены в зависимости от базы данных.</target>
        </trans-unit>
        <trans-unit id="70beadc9f0fa5a1f69a14a41423854c7849012e4" translate="yes" xml:space="preserve">
          <source>we make sure that all records that have another record with the higher total for the same user to be joined:</source>
          <target state="translated">мы следим за тем,чтобы все записи,у которых есть еще одна запись с более высокой общей суммой для одного и того же пользователя,были присоединены:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
