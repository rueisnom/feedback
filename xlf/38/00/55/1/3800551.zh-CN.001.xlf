<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3800551">
    <body>
      <group id="3800551">
        <trans-unit id="8b0e51f015b82c172dc08a72abec676ab68cdcb1" translate="yes" xml:space="preserve">
          <source>&amp;forall;x T(customer,id) &amp;gt; T(customer,x) (this total is higher than all other
total for that customer)</source>
          <target state="translated">&amp;forall;xT（客户，id）&amp;gt; T（客户，x）（此总和高于该客户的所有其他总和）</target>
        </trans-unit>
        <trans-unit id="9eb86ef810547924021ae07751ee563a0d148b2f" translate="yes" xml:space="preserve">
          <source>&amp;not;&amp;exist;x T(customer, id) &amp;lt; T(customer, x)   (there exists no higher total for
that customer)</source>
          <target state="translated">&amp;not;&amp;exist;T（客户，id）&amp;lt;T（客户，x）（该客户没有更高的总数）</target>
        </trans-unit>
        <trans-unit id="465adca06e7c71101cc6c980483c14bd4b5cd6ea" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;row_number()&lt;/code&gt; in CTE, (&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">1. CTE中的 &lt;code&gt;row_number()&lt;/code&gt; ，（ &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;请参阅其他答案&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="8904cac1304e73d4439e2e0cd4fe04a5bcbbda5a" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;row_number()&lt;/code&gt; in subquery (my optimization)</source>
          <target state="translated">2.子查询中的 &lt;code&gt;row_number()&lt;/code&gt; （我的优化）</target>
        </trans-unit>
        <trans-unit id="96334568f816862e91fdb22411296b51a9047ba9" translate="yes" xml:space="preserve">
          <source>3. &lt;code&gt;DISTINCT ON&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">3. &lt;code&gt;DISTINCT ON&lt;/code&gt; （ &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;请参阅其他答案&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab58eba8c40ca272a6b0399c814468cd2bf10833" translate="yes" xml:space="preserve">
          <source>4. rCTE with &lt;code&gt;LATERAL&lt;/code&gt; subquery (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">4.带有 &lt;code&gt;LATERAL&lt;/code&gt; 子查询的rCTE（ &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;请参阅此处&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="388a20a693d53df52778b80eb7ce5e395fe52dbe" translate="yes" xml:space="preserve">
          <source>5. &lt;code&gt;customer&lt;/code&gt; table with &lt;code&gt;LATERAL&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;see here&lt;/a&gt;)</source>
          <target state="translated">5.带有 &lt;code&gt;LATERAL&lt;/code&gt; 的 &lt;code&gt;customer&lt;/code&gt; 表（ &lt;a href=&quot;https://stackoverflow.com/a/25536748/939860&quot;&gt;请参阅此处&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="28a71a270d0b490ab8b65fcb9dd0ec0dc252b602" translate="yes" xml:space="preserve">
          <source>6. &lt;code&gt;array_agg()&lt;/code&gt; with &lt;code&gt;ORDER BY&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;see other answer&lt;/a&gt;)</source>
          <target state="translated">6. &lt;code&gt;array_agg()&lt;/code&gt; 与 &lt;code&gt;ORDER BY&lt;/code&gt; （ &lt;a href=&quot;https://stackoverflow.com/a/25534279/939860&quot;&gt;请参阅其他答案&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="e77fc13c9b4bac378cdc79c530cff8444a76a91f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt;&lt;code&gt;DISTINCT ON&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; is a PostgreSQL extension of the standard (where only &lt;code&gt;DISTINCT&lt;/code&gt; on the whole &lt;code&gt;SELECT&lt;/code&gt; list is defined).</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;&lt;strong&gt; &lt;code&gt;DISTINCT ON&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;是该标准的PostgreSQL扩展（仅在整个 &lt;code&gt;SELECT&lt;/code&gt; 列表上定义了 &lt;code&gt;DISTINCT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e5dbfddeb30f08b54049675c47334097b5e10ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DISTINCT ON&lt;/code&gt; can be combined with &lt;strong&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/strong&gt;. Leading expressions in &lt;code&gt;ORDER BY&lt;/code&gt; must be in the set of expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt;, but you can rearrange order among those freely. &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;Example.&lt;/a&gt; You can add &lt;em&gt;additional&lt;/em&gt; expressions to &lt;code&gt;ORDER BY&lt;/code&gt; to pick a particular row from each group of peers. Or, as &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;the manual puts it&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 可以与&lt;strong&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/strong&gt;结合使用。 &lt;code&gt;ORDER BY&lt;/code&gt; 中的前导表达式必须在 &lt;code&gt;DISTINCT ON&lt;/code&gt; 中的表达式集中，但是您可以在这些表达式之间自由地重新排列顺序。 &lt;a href=&quot;https://dba.stackexchange.com/a/89786/3684&quot;&gt;例。&lt;/a&gt; 您可以向 &lt;code&gt;ORDER BY&lt;/code&gt; 添加&lt;em&gt;其他&lt;/em&gt;表达式，以从每组对等体中选择特定的行。 或者，如&lt;a href=&quot;https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT&quot;&gt;手册所述&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="8d496993b6d839bb9dea36ac37618f3a3cee55d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; is an aggregate function, so it works with &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; 是一个聚合函数，因此可以与 &lt;code&gt;GROUP BY&lt;/code&gt; 一起使用 。</target>
        </trans-unit>
        <trans-unit id="0ea589215973faa22621d36017e60710d4720f84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_agg&lt;/code&gt; lets you specify an ordering scoped to just itself, so it doesn't constrain the structure of the whole query. There is also syntax for how you sort NULLs, if you need to do something different from the default.</source>
          <target state="translated">&lt;code&gt;array_agg&lt;/code&gt; 允许您指定仅限于自身的排序，因此它不会限制整个查询的结构。 如果需要执行一些与默认值不同的操作，则还提供了有关如何对NULL进行排序的语法。</target>
        </trans-unit>
        <trans-unit id="324791d057789de362088760368f72733ec8e3a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;customer&lt;/code&gt; table - for superior query</source>
          <target state="translated">&lt;code&gt;customer&lt;/code&gt; 表-用于高级查询</target>
        </trans-unit>
        <trans-unit id="9b6347bcc54c96a5d6afc6a91c3b2766235d6e38" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Pick the row with the smallest &lt;code&gt;id&lt;/code&gt; from each group sharing the highest &lt;code&gt;total&lt;/code&gt;.&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;ldquo;从每个组中选择 &lt;code&gt;id&lt;/code&gt; 最小的行，共享 &lt;code&gt;total&lt;/code&gt; 最大的行。&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ef8596eaf70407a2a70716e980229133cc09244" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; queries used an &lt;strong&gt;Index Only Scan&lt;/strong&gt; on &lt;code&gt;purchases2_3c_idx&lt;/code&gt; (among other steps). Some of them just for the smaller size of the index, others more effectively.</source>
          <target state="translated">&lt;em&gt;所有&lt;/em&gt;查询&lt;em&gt;都对&lt;/em&gt; Purchases2_3c_idx使用&amp;ldquo; &lt;strong&gt;仅索引扫描&lt;/strong&gt; &amp;rdquo;（以及其他步骤）。 其中一些只是针对较小的索引大小，而其他一些则更有效。</target>
        </trans-unit>
        <trans-unit id="ba89b37ddd35fa61a293ee1c8d26550a43e5c312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;Optimize GROUP BY query to retrieve latest row per user&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25536422/optimize-group-by-query-to-retrieve-latest-record-per-user/25536748#25536748&quot;&gt;优化GROUP BY查询以检索每个用户的最新行&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce0fdf92dae6576eb974a49b5cfb0cacb7bf8227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to SQL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;返回SQL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5ae4ba7872bce65b6f09a8ef56edcc82bcf22b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: the &lt;code&gt;using (...)&lt;/code&gt; clause is currently not supported in MS-SQL and Oracle db as of this edit on Jan 2017. You have to expand it yourself to e.g. &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; etc.  The USING syntax works in SQLite, MySQL and PostgreSQL.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：2017年1月进行此编辑时，MS-SQL和Oracle db当前不支持 &lt;code&gt;using (...)&lt;/code&gt; 子句。您必须自己将其扩展为例如 &lt;code&gt;on t2.id = purchase.id&lt;/code&gt; 等。USING语法适用于SQLite，MySQL和PostgreSQL。</target>
        </trans-unit>
        <trans-unit id="8ed70ea16198c5d6d45b8fbf0ed2b70660f594b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;预期产量：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f6f14e2b0acb25bca7f5a61efae0972b838c25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HOW DOES THAT WORK!&lt;/strong&gt; (I've been there)</source>
          <target state="translated">&lt;strong&gt;这是如何运作的！&lt;/strong&gt; （我去过那儿）</target>
        </trans-unit>
        <trans-unit id="919ebd27c03cd325e823c752933e84712e574cd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;My Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我的输出：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddcfd8371e55c2c354271ed9883696c5245698b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some Theoretical Stuff&lt;/strong&gt; (skip this part if you only want to understand the query)</source>
          <target state="translated">&lt;strong&gt;一些理论知识&lt;/strong&gt; （如果您只想了解查询，请跳过此部分）</target>
        </trans-unit>
        <trans-unit id="bbf1697f55b063038beadb0181046028cc7cdf1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;SELECT&lt;/code&gt; list&lt;/strong&gt; is not constrained by expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; in any way. (Not needed in the simple case above):</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;SELECT&lt;/code&gt; 列表&lt;/strong&gt;不受 &lt;code&gt;DISTINCT ON&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 中的表达式的任何限制。 （在上面的简单情况下不需要）：</target>
        </trans-unit>
        <trans-unit id="20c7b5fd52a03a8d3c11b5edcf49e361b626b681" translate="yes" xml:space="preserve">
          <source>A. Postgres 9.4 with 200k rows and ~ 20 per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">A. Postgres 9.4，具有20万行，每个 &lt;code&gt;customer_id&lt;/code&gt; 20个</target>
        </trans-unit>
        <trans-unit id="d8f970457bbe96b6e3501f8789c7b9f915513e61" translate="yes" xml:space="preserve">
          <source>And that's the answer we need.</source>
          <target state="translated">而这就是我们需要的答案。</target>
        </trans-unit>
        <trans-unit id="e23feb77084817360c7083a788a14965fc076e58" translate="yes" xml:space="preserve">
          <source>As the title suggests, I'd like to select the first row of each set of rows grouped with a &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">顾名思义，我想选择以 &lt;code&gt;GROUP BY&lt;/code&gt; 分组的每组行的第一行。</target>
        </trans-unit>
        <trans-unit id="8b1bd75cf1de2fdedb624fae5aa55e8a18adac06" translate="yes" xml:space="preserve">
          <source>B. The same with Postgres 9.5</source>
          <target state="translated">B.与Postgres 9.5相同</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="52825791dd909cc4202b88eeaef7b54ec3becfa8" translate="yes" xml:space="preserve">
          <source>Bold emphasis mine.</source>
          <target state="translated">大胆强调我的。</target>
        </trans-unit>
        <trans-unit id="17aca40b4c23fbfe02d34fb72e4c61a9292f08d4" translate="yes" xml:space="preserve">
          <source>But if you wanna to do such things you probably looking for &lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">但是，如果您想做这样的事情，您可能会寻找&lt;a href=&quot;https://www.postgresql.org/docs/current/static/tutorial-window.html&quot;&gt;窗口功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9fbf6bba2ca0f73231f0d374c9c473e11adbfc0" translate="yes" xml:space="preserve">
          <source>But you need to add logic to break ties:</source>
          <target state="translated">但你需要添加逻辑来打破纽带。</target>
        </trans-unit>
        <trans-unit id="6b0bad02864780888057ce496e6b9fabc038f2aa" translate="yes" xml:space="preserve">
          <source>C. Same as B., but with ~ 2.3 rows per &lt;code&gt;customer_id&lt;/code&gt;</source>
          <target state="translated">C.与B.相同，但每个 &lt;code&gt;customer_id&lt;/code&gt; 具有〜2.3行</target>
        </trans-unit>
        <trans-unit id="4f2ab710e696b3feb525a155fedbbf8f5f5c12ea" translate="yes" xml:space="preserve">
          <source>CAVEAT: It ignore's NULL rows</source>
          <target state="translated">CAVEAT:它忽略了NULL行。</target>
        </trans-unit>
        <trans-unit id="a687cecffae4f0c8632214b84368c59a2e6e7153" translate="yes" xml:space="preserve">
          <source>Comparing &lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies'&lt;/a&gt; first query (&lt;strong&gt;&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;) to the &lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;above &lt;code&gt;DISTINCT ON&lt;/code&gt; solution&lt;/a&gt; (&lt;strong&gt;&lt;code&gt;B&lt;/code&gt;&lt;/strong&gt;):</source>
          <target state="translated">将&lt;a href=&quot;https://stackoverflow.com/a/3800572/939860&quot;&gt;@OMGPonies的&lt;/a&gt;第一个查询（ &lt;strong&gt; &lt;code&gt;A&lt;/code&gt; &lt;/strong&gt; ）与&lt;a href=&quot;https://stackoverflow.com/a/7630564/939860&quot;&gt;上述 &lt;code&gt;DISTINCT ON&lt;/code&gt; 解决方案&lt;/a&gt; （ &lt;strong&gt; &lt;code&gt;B&lt;/code&gt; &lt;/strong&gt; ）进行比较：</target>
        </trans-unit>
        <trans-unit id="acd80818ac5bcea9c24fdae3e88fceaa5145fe2c" translate="yes" xml:space="preserve">
          <source>Configuration parameter work_mem in PostgreSQL on Linux</source>
          <target state="translated">PostgreSQL在Linux上的配置参数work_mem</target>
        </trans-unit>
        <trans-unit id="7fe2e8c8108bab0f14186604f0961d23506e1bc6" translate="yes" xml:space="preserve">
          <source>Dummy data, PK, index - a typical table also has some dead tuples:</source>
          <target state="translated">假数据、PK、索引----一个典型的表也有一些死的tuple。</target>
        </trans-unit>
        <trans-unit id="174c079c51c262737b6aa7163fe40695d570268e" translate="yes" xml:space="preserve">
          <source>Edit 1 - Use the postgres extension instead</source>
          <target state="translated">编辑1--使用postgres扩展,而不是使用postgres扩展。</target>
        </trans-unit>
        <trans-unit id="fce82fa3164babb13876442255a3ad8934a0e437" translate="yes" xml:space="preserve">
          <source>Edit 2 - Ordering and filtering</source>
          <target state="translated">编辑2-排序和过滤</target>
        </trans-unit>
        <trans-unit id="75737715bd2086a23ae530d9cc64724b33734c1e" translate="yes" xml:space="preserve">
          <source>Effectiveness / Performance optimization</source>
          <target state="translated">效能优化</target>
        </trans-unit>
        <trans-unit id="ad6c60c32c0a2398914d7e2f0d2c91d41fd6fbf6" translate="yes" xml:space="preserve">
          <source>Execution time for above queries with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; (and all options &lt;em&gt;off&lt;/em&gt;), &lt;em&gt;best of 5 runs&lt;/em&gt;.</source>
          <target state="translated">使用 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; （和所有选项均&lt;em&gt;关闭&lt;/em&gt; ）进行上述查询的执行时间， &lt;em&gt;最好执行5次&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="64d9744934093551048060bf300f0c928c0bed3f" translate="yes" xml:space="preserve">
          <source>Explaination:Here  &lt;strong&gt;Group by&lt;/strong&gt; is done on the basis of customer and then order it by total then each such group is given serial number as StRank and we are taking out first 1 customer whose StRank is 1</source>
          <target state="translated">说明：这里的&lt;strong&gt;分组依据&lt;/strong&gt;是根据客户进行的，然后按总数进行订购，然后为每个这样的组指定序列号为StRank，我们要取出第一个有1个StRank为1的客户</target>
        </trans-unit>
        <trans-unit id="67f4bc89bd0ee8c2f20b19ee9c93d80b26582d05" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;few&lt;/em&gt; rows per customer&lt;/strong&gt; (high cardinality in column &lt;code&gt;customer&lt;/code&gt;), this is very efficient. Even more so if you need sorted output anyway. The benefit shrinks with a growing number of rows per customer.</source>
          <target state="translated">对于&lt;strong&gt;每个客户&lt;em&gt;几&lt;/em&gt;行&lt;/strong&gt; （列 &lt;code&gt;customer&lt;/code&gt; 基数高），这是非常有效的。 如果您仍然需要排序的输出，则更是如此。 随着每个客户行数的增加，收益也随之减少。</target>
        </trans-unit>
        <trans-unit id="e7c26ad56f293277760cdbfe5b97e01026505b3d" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&lt;em&gt;many&lt;/em&gt; rows per customer&lt;/strong&gt; (low cardinality in column &lt;code&gt;customer&lt;/code&gt;), a &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;loose index scan&lt;/strong&gt;&lt;/a&gt; (a.k.a. &quot;skip scan&quot;) would be (much) more efficient, but that's not implemented up to Postgres 12. (An implementation for index-only scans is in development for Postgres 13. See &lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">对于&lt;strong&gt;每个客户&lt;em&gt;很多&lt;/em&gt;行&lt;/strong&gt; （列 &lt;code&gt;customer&lt;/code&gt; 基数低）， &lt;a href=&quot;https://wiki.postgresql.org/wiki/Loose_indexscan&quot;&gt;&lt;strong&gt;松散的索引扫描&lt;/strong&gt;&lt;/a&gt; （也称为&amp;ldquo;跳过扫描&amp;rdquo;）会（很多）更有效率，但是直到Postgres 12才实现。（仅索引扫描的实现是正在开发Postgres13。请&lt;a href=&quot;https://commitfest.postgresql.org/19/1741/&quot;&gt;在此处&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/message-id/flat/707b6f68-16fa-7aa7-96e5-eeb4865e6a30@redhat.com&quot;&gt;此处&lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="3573651362ae5e478981982b3b1e27c37c25fabf" translate="yes" xml:space="preserve">
          <source>For Postgres 9.5 I ran a 2nd test with effectively 86446 distinct customers. See below (&lt;em&gt;avg. 2.3 rows per customer&lt;/em&gt;).</source>
          <target state="translated">对于Postgres 9.5，我进行了有效测试86446个不同客户的第二次测试。 参见下文（ &lt;em&gt;每个客户平均2.3行&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5885b552b6ab83e07125a70548b0c986996b8178" translate="yes" xml:space="preserve">
          <source>For SQl Server the most efficient way is:</source>
          <target state="translated">对于SQl Server来说,最有效的方法是。</target>
        </trans-unit>
        <trans-unit id="3fa33ded2a46b10ad416ee2d3ffc070fa4d90ff9" translate="yes" xml:space="preserve">
          <source>For now, there are &lt;strong&gt;faster query techniques&lt;/strong&gt; to substitute for this. In particular if you have a separate table holding unique customers, which is the typical use case. But also if you don't:</source>
          <target state="translated">目前，有&lt;strong&gt;更快的查询技术&lt;/strong&gt;可以代替它。 特别是如果您有一个单独的表来容纳唯一客户，这是典型的用例。 但是，如果您不这样做：</target>
        </trans-unit>
        <trans-unit id="adc98243acc2f50c6cd9268d1a23bdb2ac5b1062" translate="yes" xml:space="preserve">
          <source>Generated with &lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;this query&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://dba.stackexchange.com/questions/23879/measure-the-size-of-a-postgresql-table-row/23933#23933&quot;&gt;此查询&lt;/a&gt;生成。</target>
        </trans-unit>
        <trans-unit id="01d1b9a5f5078d105e1cc0eaa95c676eae08b4ea" translate="yes" xml:space="preserve">
          <source>Here I provide a same-approach, but more complete and clean any-database solution.   Ties are considered (assume desire to get only one row for each customer, even multiple records for max total per customer), and other purchase fields (e.g. purchase_payment_id) will be selected for the real matching rows in the purchase table.</source>
          <target state="translated">在这里,我提供了一个同样的方法,但更完整和干净的任何数据库解决方案。考虑到结账(假设希望为每个客户只得到一行,甚至每个客户最大总记录的多条记录),其他的购买字段(如购买_purchase_payment_id)将被选择为购买表中真正匹配的行。</target>
        </trans-unit>
        <trans-unit id="1e3129050964ca90864ffa2acb569e107645deb0" translate="yes" xml:space="preserve">
          <source>Here is a new one by &quot;ogr&quot; testing with &lt;strong&gt;10M rows and 60k unique &quot;customers&quot;&lt;/strong&gt; on &lt;strong&gt;Postgres 11.5&lt;/strong&gt; (current as of Sep. 2019). Results are still in line with what we have seen so far:</source>
          <target state="translated">这是在&lt;strong&gt;Postgres 11.5&lt;/strong&gt; （截至2019年9月）上通过&lt;strong&gt;1000万行和6万个唯一&amp;ldquo;客户&amp;rdquo;&lt;/strong&gt;进行的&amp;ldquo; ogr&amp;rdquo;测试得出的新结果。 结果仍然符合我们到目前为止所看到的：</target>
        </trans-unit>
        <trans-unit id="f098395b6ea6fcdc083ec3a7f6ea0975316c1705" translate="yes" xml:space="preserve">
          <source>I added &lt;code&gt;id&lt;/code&gt; as last item to break ties:</source>
          <target state="translated">我添加了 &lt;code&gt;id&lt;/code&gt; 作为打破联系的最后一项：</target>
        </trans-unit>
        <trans-unit id="c90b5abd370bd36ee6b7906498a63b93f5448bf7" translate="yes" xml:space="preserve">
          <source>I created a composite &lt;code&gt;(id, total)&lt;/code&gt;, so both values are returned by the same aggregate. You can of course always apply &lt;code&gt;first_value()&lt;/code&gt; twice.</source>
          <target state="translated">我创建了一个Composite &lt;code&gt;(id, total)&lt;/code&gt; ，所以两个值都由同一聚合返回。 您当然可以始终两次应用 &lt;code&gt;first_value()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="130b1834e42433119953b32cd075fdef4902f9c6" translate="yes" xml:space="preserve">
          <source>I had a simple benchmark here which is outdated by now. I replaced it with a &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;detailed benchmark in this separate answer&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">我这里有一个简单的基准，现在已经过时了。 &lt;a href=&quot;https://stackoverflow.com/a/34715134/939860&quot;&gt;&lt;strong&gt;在这个单独的答案中，&lt;/strong&gt;&lt;/a&gt;我用&lt;strong&gt;详细的基准&lt;/strong&gt;代替了它。</target>
        </trans-unit>
        <trans-unit id="e09671f3bd26252ac5be9d0a7116458ae0d8bc22" translate="yes" xml:space="preserve">
          <source>I ran three tests with PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt; on a real life table of 65579 rows and single-column btree indexes on each of the three columns involved and took the best &lt;em&gt;execution time&lt;/em&gt; of 5 runs.</source>
          <target state="translated">我使用PostgreSQL &lt;strong&gt;9.1&lt;/strong&gt;在实际的65579行表和涉及的三列中的每一列上的单列btree索引上运行了三个测试，并以5次运行的最佳&lt;em&gt;执行时间&lt;/em&gt;进行了测试。</target>
        </trans-unit>
        <trans-unit id="50ef525b77740b26d2f800be1f31dc196cd1a5b7" translate="yes" xml:space="preserve">
          <source>I tested with Postgres versions 8.3 &amp;ndash; 12. But the feature has been there at least since version 7.1, so basically always.</source>
          <target state="translated">我使用Postgres 8.3 &amp;ndash; 12版进行了测试。但是至少从7.1版开始，该功能就存在了，因此基本上总是如此。</target>
        </trans-unit>
        <trans-unit id="63fe6b185c7bbea3849dd47a10061ff96c0bd0d6" translate="yes" xml:space="preserve">
          <source>I use a &lt;code&gt;serial&lt;/code&gt; (PK constraint added below) and an integer &lt;code&gt;customer_id&lt;/code&gt; since that's a more typical setup. Also added &lt;code&gt;some_column&lt;/code&gt; to make up for typically more columns.</source>
          <target state="translated">我使用一个 &lt;code&gt;serial&lt;/code&gt; （下面添加了PK约束）和一个整数 &lt;code&gt;customer_id&lt;/code&gt; ,因为这是更典型的设置。 还添加了 &lt;code&gt;some_column&lt;/code&gt; 以弥补通常更多的列。</target>
        </trans-unit>
        <trans-unit id="e6eee036e14e840a888fce846d96052e9490f45f" translate="yes" xml:space="preserve">
          <source>I use this way (postgresql only): &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&lt;/a&gt;</source>
          <target state="translated">我使用这种方式（仅限于PostgreSQL）： &lt;a href=&quot;https://wiki.postgresql.org/wiki/First/last_%28aggregate%29&quot;&gt;https&lt;/a&gt; : //wiki.postgresql.org/wiki/First/last_%28aggregate%29</target>
        </trans-unit>
        <trans-unit id="058e05d7a94c12abe5d88dcda3d94f529d56876e" translate="yes" xml:space="preserve">
          <source>I'd like to query for the &lt;code&gt;id&lt;/code&gt; of the largest purchase (&lt;code&gt;total&lt;/code&gt;) made by each &lt;code&gt;customer&lt;/code&gt;. Something like this:</source>
          <target state="translated">我想查询每个 &lt;code&gt;customer&lt;/code&gt; 购买的最大商品的 &lt;code&gt;id&lt;/code&gt; （ &lt;code&gt;total&lt;/code&gt; ）。 像这样：</target>
        </trans-unit>
        <trans-unit id="49e5ca82598636f91cd9a8e958c6a1d9a9469aa9" translate="yes" xml:space="preserve">
          <source>Ideally, you have enough &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to process the involved sort step in RAM and not spill to disk. But generally setting &lt;code&gt;work_mem&lt;/code&gt;&lt;em&gt;too&lt;/em&gt; high can have adverse effects. Consider &lt;code&gt;SET LOCAL&lt;/code&gt; for exceptionally big queries. Find how much you need with &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;. Mention of &quot;&lt;em&gt;Disk:&lt;/em&gt;&quot; in the sort step indicates the need for more:</source>
          <target state="translated">理想情况下，您有足够的&lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM&quot;&gt;&lt;strong&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;来处理RAM中涉及的排序步骤，并且不会溢出到磁盘上。 但是通常将 &lt;code&gt;work_mem&lt;/code&gt; 设置&lt;em&gt;得&lt;/em&gt;太高会产生不利影响。 考虑将 &lt;code&gt;SET LOCAL&lt;/code&gt; 用于特别大的查询。 使用 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 查找您需要多少。 在排序步骤中提到&amp;ldquo; &lt;em&gt;磁盘：&lt;/em&gt; &amp;rdquo;表示需要更多：</target>
        </trans-unit>
        <trans-unit id="115e7329106b556464ad2183dc9b3466d332e3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL (won't hurt either way, but you'll want to &lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;match existing indexes&lt;/a&gt;):</source>
          <target state="translated">如果 &lt;code&gt;total&lt;/code&gt; 可以为NULL（无论哪种方式都没有问题，但是您需要&lt;a href=&quot;https://dba.stackexchange.com/q/254731/3684&quot;&gt;匹配现有索引&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="885869bd8bb57ffb30ae77b739b5f2d997c205b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;total&lt;/code&gt; can be NULL, you &lt;em&gt;most probably&lt;/em&gt; want the row with the greatest non-null value. Add &lt;strong&gt;&lt;code&gt;NULLS LAST&lt;/code&gt;&lt;/strong&gt; like demonstrated. See:</source>
          <target state="translated">如果 &lt;code&gt;total&lt;/code&gt; 可以为NULL，则您&lt;em&gt;很可能&lt;/em&gt;希望具有最大非空值的行。 &lt;strong&gt; &lt;code&gt;NULLS LAST&lt;/code&gt; &lt;/strong&gt;添加&lt;strong&gt;NULLS LAST&lt;/strong&gt; 。 看到：</target>
        </trans-unit>
        <trans-unit id="f3ff0102a461bc45f392997d6b4457df923ab8d8" translate="yes" xml:space="preserve">
          <source>If we left joins the table on the name and total being less than the joined table:</source>
          <target state="translated">如果我们离开加入表上的名字和总数小于加入表。</target>
        </trans-unit>
        <trans-unit id="1bc90c6679c8f97e7e0ae81bc6b9546fcda369ac" translate="yes" xml:space="preserve">
          <source>If you use aggregate functions (like these), you can order the results, without the need to have the data already ordered:</source>
          <target state="translated">如果你使用聚合函数(像这样的),你就可以对结果进行排序,而不需要已经排序的数据。</target>
        </trans-unit>
        <trans-unit id="513b52421e643bf265232a5b0303884aee1f29a9" translate="yes" xml:space="preserve">
          <source>If you want to select any (by your some specific condition) row from the set of aggregated rows.</source>
          <target state="translated">如果你想从聚合行集合中选择任何(由你的一些特定条件)行。</target>
        </trans-unit>
        <trans-unit id="14f29bfc41c897a3e227d298f67de89585505bbf" translate="yes" xml:space="preserve">
          <source>If you want to use another (&lt;code&gt;sum/avg&lt;/code&gt;) aggregation function in addition to &lt;code&gt;max/min&lt;/code&gt;. Thus you can not use clue with &lt;code&gt;DISTINCT ON&lt;/code&gt;</source>
          <target state="translated">如果要使用除 &lt;code&gt;max/min&lt;/code&gt; 之外的其他（ &lt;code&gt;sum/avg&lt;/code&gt; ）聚合函数。 因此，您不能在 &lt;code&gt;DISTINCT ON&lt;/code&gt; 上使用线索</target>
        </trans-unit>
        <trans-unit id="95f04d79bc6e9f1a1a378d50e9a21929eef79e61" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;PostgreSQL&lt;/strong&gt; this is typically &lt;strong&gt;simpler and faster&lt;/strong&gt; (more performance optimization below):</source>
          <target state="translated">在&lt;strong&gt;PostgreSQL中，&lt;/strong&gt;这通常&lt;strong&gt;更简单，更快捷&lt;/strong&gt; （下面将进行更多性能优化）：</target>
        </trans-unit>
        <trans-unit id="3030a2fec9c767d8ff7ccbf769b9e4f47aa7fac4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, another possibility is to use the &lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt;&lt;code&gt;first_value&lt;/code&gt;&lt;/a&gt; window function in combination with &lt;code&gt;SELECT DISTINCT&lt;/code&gt;:</source>
          <target state="translated">在PostgreSQL中，另一种可能性是将&lt;a href=&quot;https://www.postgresql.org/docs/current/functions-window.html&quot;&gt; &lt;code&gt;first_value&lt;/code&gt; &lt;/a&gt;窗口函数与 &lt;code&gt;SELECT DISTINCT&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="70b88621817cca0608b7dda4ed35638f90c58d08" translate="yes" xml:space="preserve">
          <source>In Postgres you can use &lt;code&gt;array_agg&lt;/code&gt; like this:</source>
          <target state="translated">在Postgres中，您可以像这样使用 &lt;code&gt;array_agg&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b958a892b980456789c653c74f646b5dec93aaf4" translate="yes" xml:space="preserve">
          <source>In SQL Server you can do this:</source>
          <target state="translated">在SQL Server中,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="eaadf570b7bb1e4a6396c6bcba18cbed9639f58a" translate="yes" xml:space="preserve">
          <source>In my &lt;strong&gt;second test&lt;/strong&gt; for 9.5 I used the same setup, but with &lt;code&gt;random() * 100000&lt;/code&gt; to generate &lt;code&gt;customer_id&lt;/code&gt; to get only few rows per &lt;code&gt;customer_id&lt;/code&gt;.</source>
          <target state="translated">在针对9.5的&lt;strong&gt;第二次测试中&lt;/strong&gt; ，我使用了相同的设置，但是使用 &lt;code&gt;random() * 100000&lt;/code&gt; 生成 &lt;code&gt;customer_id&lt;/code&gt; ，每个 &lt;code&gt;customer_id&lt;/code&gt; 仅获得几行。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="76ff0109afd7a40bd9c16251d32e49ec91dea601" translate="yes" xml:space="preserve">
          <source>It's a postgres extension that gives you first and last functions; apparently faster than the above way.</source>
          <target state="translated">这是一个postgres的扩展,可以给你提供首尾函数;显然比上面的方式要快。</target>
        </trans-unit>
        <trans-unit id="d991a62bb10a62ed754485867ff0e408d74d7e89" translate="yes" xml:space="preserve">
          <source>Let Total be a function T(customer,id) where it returns a value given the name and id
To prove that the given total (T(customer,id)) is the highest we have to prove that
We want to prove either</source>
          <target state="translated">让Total是一个函数T(customer,id),它返回一个给定名称和id的值。</target>
        </trans-unit>
        <trans-unit id="2e5632d0f807b3f34cf7f69dec1047fe433b911d" translate="yes" xml:space="preserve">
          <source>List any number of expressions in the &lt;code&gt;DISTINCT ON&lt;/code&gt; clause, the combined row value defines duplicates. &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;The manual:&lt;/a&gt;</source>
          <target state="translated">在 &lt;code&gt;DISTINCT ON&lt;/code&gt; 子句中列出任意数量的表达式，组合的行值定义重复项。 &lt;a href=&quot;https://www.postgresql.org/docs/current/queries-select-lists.html#QUERIES-DISTINCT&quot;&gt;手册：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="464f7790b102ce69cf3acd7d69f43f9a52b82086" translate="yes" xml:space="preserve">
          <source>Main table</source>
          <target state="translated">主表</target>
        </trans-unit>
        <trans-unit id="9e85255a09c56ff34c3fc3aaf30b6b3e8b91258b" translate="yes" xml:space="preserve">
          <source>Major points</source>
          <target state="translated">要点</target>
        </trans-unit>
        <trans-unit id="d12153394231071e15cd8c3b11dfb9916cc27f28" translate="yes" xml:space="preserve">
          <source>May be too specialized. But use it if read performance for the particular query is crucial. If you have &lt;code&gt;DESC NULLS LAST&lt;/code&gt; in the query, use the same in the index so that sort order matches and the index is applicable.</source>
          <target state="translated">可能太专业了。 但是，如果特定查询的读取性能至关重要，请使用它。 如果查询中具有 &lt;code&gt;DESC NULLS LAST&lt;/code&gt; ，则在索引中使用相同的字符，以便排序顺序匹配并且索引适用。</target>
        </trans-unit>
        <trans-unit id="dfff4eefffc08fe064edf770d418be997d8af5cd" translate="yes" xml:space="preserve">
          <source>Note that bunch of solutions to this common problem can surprisingly be found in the one of most official sources, &lt;strong&gt;MySQL manual&lt;/strong&gt;! See &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;Examples of Common Queries :: The Rows Holding the Group-wise Maximum of a Certain Column&lt;/a&gt;.</source>
          <target state="translated">注意，在大多数官方资料之一&lt;strong&gt;MySQL手册中&lt;/strong&gt; ，可以惊奇地找到许多针对这个常见问题的解决方案！ 请参阅&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/example-maximum-column-group-row.html&quot;&gt;常见查询的示例::持有特定列的按组最大值的行&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="df659bc5a4cb564a96f76217ff3e2438b57ef8b7" translate="yes" xml:space="preserve">
          <source>Now I use this way: &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http://pgxn.org/dist/first_last_agg/&lt;/a&gt;</source>
          <target state="translated">现在，我使用这种方式： &lt;a href=&quot;http://pgxn.org/dist/first_last_agg/&quot;&gt;http&lt;/a&gt; : //pgxn.org/dist/first_last_agg/</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="ae8661bf223d4e024221cc558b5e2889d1ab01aa" translate="yes" xml:space="preserve">
          <source>Object sizes for table &lt;code&gt;purchases&lt;/code&gt;</source>
          <target state="translated">表 &lt;code&gt;purchases&lt;/code&gt; 对象大小</target>
        </trans-unit>
        <trans-unit id="0c3894fd7032a7b8b88d3da5aa8a3469655ef31d" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least
  one column value. &lt;strong&gt;Null values are considered equal in this comparison.&lt;/strong&gt;</source>
          <target state="translated">显然，如果两行至少有一个列值不同，则认为它们是不同的。 &lt;strong&gt;在此比较中，将空值视为相等。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="311285b287ae794f8a6e6e16f340d4537b8dfbc1" translate="yes" xml:space="preserve">
          <source>Of course you can order and filter as you deem fit within the aggregate; it's very powerful syntax.</source>
          <target state="translated">当然,你可以在聚合中按你认为合适的方式进行排序和过滤,这是非常强大的语法。</target>
        </trans-unit>
        <trans-unit id="982f7546a2eb8df6633eb73d3e3883d3525fe955" translate="yes" xml:space="preserve">
          <source>On Oracle 9.2+ (not 8i+ as originally stated), SQL Server 2005+, PostgreSQL 8.4+, DB2, Firebird 3.0+, Teradata, Sybase, Vertica:</source>
          <target state="translated">在Oracle 9.2+(不是原来说的8i+)、SQL Server 2005+、PostgreSQL 8.4+、DB2、Firebird 3.0+、Teradata、Sybase、Vertica上。</target>
        </trans-unit>
        <trans-unit id="0ea92a1813c9ad07657cdc2ac29023c0cbfc39c1" translate="yes" xml:space="preserve">
          <source>Once we build the array, we take the first element. (Postgres arrays are 1-indexed, not 0-indexed).</source>
          <target state="translated">一旦我们建立了数组,我们就取第一个元素。Postgres数组是1-indexed,而不是0-indexed)。</target>
        </trans-unit>
        <trans-unit id="b8a1b609b59584ecf9bb25c6e8bacdb3704cca90" translate="yes" xml:space="preserve">
          <source>Optimize groupwise maximum query</source>
          <target state="translated">优化组内最大查询</target>
        </trans-unit>
        <trans-unit id="bf017f217553f1cf968db1e65b41af2ab992d2d5" translate="yes" xml:space="preserve">
          <source>Optimize simple query using ORDER BY date and text</source>
          <target state="translated">使用ORDER BY日期和文本优化简单查询</target>
        </trans-unit>
        <trans-unit id="a67837359416b99ab5311803744d610256a22309" translate="yes" xml:space="preserve">
          <source>Or shorter (if not as clear) with ordinal numbers of output columns:</source>
          <target state="translated">或者更短(如果不那么清晰),输出列数为序号。</target>
        </trans-unit>
        <trans-unit id="24fa5a2c8e0b4079cb5f9fe868a9bd59518f7bc4" translate="yes" xml:space="preserve">
          <source>Original (outdated) benchmark from 2011</source>
          <target state="translated">2011年的原始(过时的)基准</target>
        </trans-unit>
        <trans-unit id="323c83c0f69c9372d7ee234ccace23a4e5de3ce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL sort by datetime asc, null first?</source>
          <target state="translated">PostgreSQL按datetime asc排序,null first?</target>
        </trans-unit>
        <trans-unit id="b244b2217c8b6c534f37d1f03cf14604ed7ba5e5" translate="yes" xml:space="preserve">
          <source>Proper way to access latest row for each individual identifier?</source>
          <target state="translated">如何正确访问每一个标识符的最新行?</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="0b8a47b88d837280e3fab94fe4d2bd803b3c158f" translate="yes" xml:space="preserve">
          <source>Query last N related rows per row</source>
          <target state="translated">查询每行最后的N条相关记录</target>
        </trans-unit>
        <trans-unit id="e8536401a76da15c6c761038b81a6fa0d744d0c4" translate="yes" xml:space="preserve">
          <source>Related benchmarks</source>
          <target state="translated">相关基准</target>
        </trans-unit>
        <trans-unit id="a88f66d2299b63003d3d871345537088ff79ce05" translate="yes" xml:space="preserve">
          <source>Remark:</source>
          <target state="translated">Remark:</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="ba1151ed7036215586ab2deb08df3dd651d11cd8" translate="yes" xml:space="preserve">
          <source>Same test repeated with the index described in the other answer</source>
          <target state="translated">用另一个答案中描述的指数重复进行相同的测试。</target>
        </trans-unit>
        <trans-unit id="02fa4b7c2eb7288cc2dd7860b97e7fcc7c3c81d0" translate="yes" xml:space="preserve">
          <source>Select a single customer with &lt;code&gt;WHERE customer = x&lt;/code&gt;.</source>
          <target state="translated">选择 &lt;code&gt;WHERE customer = x&lt;/code&gt; 的单个客户。</target>
        </trans-unit>
        <trans-unit id="253368c0449de38cab696b8fe6b4a86a8b102762" translate="yes" xml:space="preserve">
          <source>Select first row in each GROUP BY group</source>
          <target state="translated">选择每个组中的第一行</target>
        </trans-unit>
        <trans-unit id="584e375ddcb38e2b1f417648316c35cf906dbf11" translate="yes" xml:space="preserve">
          <source>Select the whole table, results in 5958 rows in this case.</source>
          <target state="translated">选择整张表,结果在这种情况下有5958行。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="25075eb661f7180b5138442fe9b8c1612f5add01" translate="yes" xml:space="preserve">
          <source>Snowflake/Teradata supports &lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt;&lt;code&gt;QUALIFY&lt;/code&gt;&lt;/a&gt; clause which works like &lt;code&gt;HAVING&lt;/code&gt; for windowed functions:</source>
          <target state="translated">Snowflake / Teradata支持&lt;a href=&quot;https://docs.snowflake.net/manuals/sql-reference/constructs/qualify.html&quot;&gt; &lt;code&gt;QUALIFY&lt;/code&gt; &lt;/a&gt;子句，该子句的作用类似于 &lt;code&gt;HAVING&lt;/code&gt; 的窗口函数：</target>
        </trans-unit>
        <trans-unit id="a77cdea121464bd8808b2f7a4d983ddee817a186" translate="yes" xml:space="preserve">
          <source>So the equivalent example, with ordering would be something like:</source>
          <target state="translated">所以等价的例子是这样的:</target>
        </trans-unit>
        <trans-unit id="fe91dbd517e1619f524c6cc3d78de6f788ca2326" translate="yes" xml:space="preserve">
          <source>Some things to note:</source>
          <target state="translated">一些需要注意的事情。</target>
        </trans-unit>
        <trans-unit id="24b54af2f3501272eaa2d4bb4a4c29ad87c41036" translate="yes" xml:space="preserve">
          <source>Specifically, if I've got a &lt;code&gt;purchases&lt;/code&gt; table that looks like this:</source>
          <target state="translated">具体来说，如果我有一个如下所示的 &lt;code&gt;purchases&lt;/code&gt; 表：</target>
        </trans-unit>
        <trans-unit id="e80c2fdd2ef29bdb9b48c3567af9314011689fa6" translate="yes" xml:space="preserve">
          <source>Supported by any database:</source>
          <target state="translated">由任何数据库支持。</target>
        </trans-unit>
        <trans-unit id="7e5062ca17fb1a192f52106e7c6e38c488fdd328" translate="yes" xml:space="preserve">
          <source>Testing the most interesting candidates with Postgres &lt;strong&gt;9.4&lt;/strong&gt; and &lt;strong&gt;9.5&lt;/strong&gt; with a halfway realistic table of &lt;strong&gt;200k rows&lt;/strong&gt; in &lt;code&gt;purchases&lt;/code&gt; and &lt;strong&gt;10k distinct &lt;code&gt;customer_id&lt;/code&gt;&lt;/strong&gt; (&lt;em&gt;avg. 20 rows per customer&lt;/em&gt;).</source>
          <target state="translated">使用Postgres &lt;strong&gt;9.4&lt;/strong&gt;和&lt;strong&gt;9.5&lt;/strong&gt;测试中最有趣的候选者，其中包含一个&lt;strong&gt;200k行&lt;/strong&gt; &lt;code&gt;purchases&lt;/code&gt; 和&lt;strong&gt;10k个不同的 &lt;code&gt;customer_id&lt;/code&gt; &lt;/strong&gt; （ &lt;em&gt;每个客户平均20行&lt;/em&gt; ）的中途现实表。</target>
        </trans-unit>
        <trans-unit id="4c0349a949a02df07cfe9df6fb72a596095aac53" translate="yes" xml:space="preserve">
          <source>That will help us filter for the highest total for each purchase with no grouping needed:</source>
          <target state="translated">这将有助于我们在不需要分组的情况下,筛选出每次购买的最高总额。</target>
        </trans-unit>
        <trans-unit id="8263d90ff6ffdae1372239c757291f48e712a876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DISTINCT ON&lt;/code&gt; expression(s) must match the leftmost &lt;code&gt;ORDER BY&lt;/code&gt;
  expression(s). The &lt;code&gt;ORDER BY&lt;/code&gt; clause will normally contain additional
  expression(s) that determine the desired precedence of rows within
  each &lt;code&gt;DISTINCT ON&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 表达式必须与最左边的 &lt;code&gt;ORDER BY&lt;/code&gt; 表达式匹配。 &lt;code&gt;ORDER BY&lt;/code&gt; 子句通常将包含其他表达式，这些表达式确定每个 &lt;code&gt;DISTINCT ON&lt;/code&gt; 组内所需的行优先级。</target>
        </trans-unit>
        <trans-unit id="f13e19f9b15111fb7b1bde58351508e53c21d6dc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;perfect&lt;/em&gt; index for the above query would be a &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;multi-column index&lt;/a&gt; spanning all three columns in matching sequence and with matching sort order:</source>
          <target state="translated">上面查询的&lt;em&gt;理想&lt;/em&gt;索引是一个&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-multicolumn.html&quot;&gt;多列索引，它&lt;/a&gt;以匹配顺序和匹配的排序顺序跨越所有三列：</target>
        </trans-unit>
        <trans-unit id="9e1b4aba07ab733b78ed9bef8497132427b3cab0" translate="yes" xml:space="preserve">
          <source>The Query:</source>
          <target state="translated">的查询。</target>
        </trans-unit>
        <trans-unit id="183fa3d4a15533a9e707bd462d1faacae935ae4e" translate="yes" xml:space="preserve">
          <source>The accepted OMG Ponies' &quot;Supported by any database&quot; solution has good speed from my test.</source>
          <target state="translated">接受OMG小马的 &quot;支持任何数据库 &quot;的方案,从我的测试来看,有不错的速度。</target>
        </trans-unit>
        <trans-unit id="6502ba17b0b16f09c8a81764063487d6e256b438" translate="yes" xml:space="preserve">
          <source>The first approach will need us to get all the records for that name which I do not really like.</source>
          <target state="translated">第一种方法需要我们拿到这个名字的所有记录,我不太喜欢。</target>
        </trans-unit>
        <trans-unit id="d766cf318ecc2510338dec9362ebccbe8d7c0677" translate="yes" xml:space="preserve">
          <source>The index is used because it delivers pre-sorted data. In Postgres 9.2 or later the query can also benefit from an &lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;index only scan&lt;/a&gt;&lt;/strong&gt; if the index is smaller than the underlying table. The index has to be scanned in its entirety, though.</source>
          <target state="translated">使用索引是因为它提供了预排序的数据。 在Postgres 9.2或更高版本中，如果索引小于基础表，则查询也可以受益于&lt;strong&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-index-only-scans.html&quot;&gt;仅索引扫描&lt;/a&gt;&lt;/strong&gt; 。 但是，必须完整扫描索引。</target>
        </trans-unit>
        <trans-unit id="05df13c53001ea7238498c9bd30e304edb5a0a31" translate="yes" xml:space="preserve">
          <source>The second one will need a smart way to say there can be no record higher than this one.</source>
          <target state="translated">第二种要想说没有比这一种更高的记录,就需要一个聪明的方法。</target>
        </trans-unit>
        <trans-unit id="0a3460435b2ba05f43754f4db17512ff936ee290" translate="yes" xml:space="preserve">
          <source>The solution is not very efficient as pointed by Erwin, because of presence of SubQs</source>
          <target state="translated">正如Erwin指出的那样,由于SubQs的存在,该方案的效率并不高。</target>
        </trans-unit>
        <trans-unit id="c14ef83d661641de58fc6d2cfd57cb77febe4cb3" translate="yes" xml:space="preserve">
          <source>Then your example should work &lt;em&gt;almost&lt;/em&gt; as is:</source>
          <target state="translated">然后，您的示例应该&lt;em&gt;几乎可以&lt;/em&gt;按以下方式工作：</target>
        </trans-unit>
        <trans-unit id="14af5152d85077e382ef162c9c2c6ca124d91883" translate="yes" xml:space="preserve">
          <source>This is common &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem, which already has well tested and highly &lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;optimized solutions&lt;/a&gt;. Personally I prefer the &lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;left join solution by Bill Karwin&lt;/a&gt; (the &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;original post with lots of other solutions&lt;/a&gt;).</source>
          <target state="translated">这是&lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;最&lt;/a&gt;常见的每组最多n个问题，该问题已经过测试和高度&lt;a href=&quot;https://stackoverflow.com/q/8748986/684229&quot;&gt;优化&lt;/a&gt; 。 就我个人而言，我更喜欢&lt;a href=&quot;https://stackoverflow.com/a/8749095/684229&quot;&gt;Bill Karwin&lt;/a&gt;的左联接解决方案 （ &lt;a href=&quot;https://stackoverflow.com/a/123481/684229&quot;&gt;带有许多其他解决方案&lt;/a&gt;的原始帖子 ）。</target>
        </trans-unit>
        <trans-unit id="9f6bb60b44756b7628cdf5d79a2596547457d1a3" translate="yes" xml:space="preserve">
          <source>This query is reasonably fast especially when there is a composite index like (customer, total) on the purchase table.</source>
          <target state="translated">这个查询的速度是相当快的,特别是当购买表上有一个像(customer,total)这样的复合索引时。</target>
        </trans-unit>
        <trans-unit id="0a08adcb0b93966d68f2bc6f7a603c1356fcf793" translate="yes" xml:space="preserve">
          <source>This will give you the &lt;code&gt;id&lt;/code&gt; of each customer's largest purchase.</source>
          <target state="translated">这将为您提供每个客户最大购买量的 &lt;code&gt;id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc8bd5672beabcb0e52175bab260889953b1655e" translate="yes" xml:space="preserve">
          <source>To install on ubuntu 14.04:</source>
          <target state="translated">要在ubuntu 14.04上安装。</target>
        </trans-unit>
        <trans-unit id="3db7721a0740ae1052b100a1e77bf4b8e03a8a7b" translate="yes" xml:space="preserve">
          <source>To order results in a way that disagrees with the sort order determining the first per group, you can nest above query in an outer query with another &lt;code&gt;ORDER BY&lt;/code&gt;. &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;Example.&lt;/a&gt;</source>
          <target state="translated">要以与确定每个组第一个的排序顺序不同的方式对结果进行排序，可以将上面的查询嵌套在另一个 &lt;code&gt;ORDER BY&lt;/code&gt; 的外部查询中。 &lt;a href=&quot;https://stackoverflow.com/a/9796104/939860&quot;&gt;例。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46ed51fa8a387f78df24cb7924cc5d43ab1faeb1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;DISTINCT ON&lt;/code&gt;, using &lt;code&gt;array_agg&lt;/code&gt; lets you keep your &lt;code&gt;GROUP BY&lt;/code&gt;, in case you want that for other reasons.</source>
          <target state="translated">与 &lt;code&gt;DISTINCT ON&lt;/code&gt; 不同，使用 &lt;code&gt;array_agg&lt;/code&gt; 可使您保留 &lt;code&gt;GROUP BY&lt;/code&gt; ，以防其他原因。</target>
        </trans-unit>
        <trans-unit id="5d9409fc69c35c5edb50908ff3ef3bccafb2a22f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ARRAY_AGG&lt;/code&gt; function for &lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt;, and &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL&lt;/a&gt;:</source>
          <target state="translated">对&lt;a href=&quot;https://www.postgresql.org/docs/9.5/functions-aggregate.html&quot;&gt;PostgreSQL&lt;/a&gt; ， &lt;a href=&quot;https://docs.microsoft.com/en-us/u-sql/functions/aggregate/array-agg&quot;&gt;U-SQL&lt;/a&gt; ， &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050494.html&quot;&gt;IBM DB2&lt;/a&gt;和&lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg&quot;&gt;Google BigQuery SQL&lt;/a&gt;使用 &lt;code&gt;ARRAY_AGG&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a1f57e731466c6b4c22dbef205787a34542575cf" translate="yes" xml:space="preserve">
          <source>Use condition &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; resulting in 1000 rows.</source>
          <target state="translated">使用条件 &lt;code&gt;WHERE customer BETWEEN x AND y&lt;/code&gt; 产生1000行。</target>
        </trans-unit>
        <trans-unit id="479bc7f3be51824caa77d22a6caca1d270a0d65b" translate="yes" xml:space="preserve">
          <source>Very fast solution</source>
          <target state="translated">非常快速的解决方案</target>
        </trans-unit>
        <trans-unit id="17affe0f45ae018cfaeeaaec42cd75a97768f98a" translate="yes" xml:space="preserve">
          <source>We want to make sure that we only have the highest total for each purchase.</source>
          <target state="translated">我们要确保每次采购的时候,我们只有最高的总量。</target>
        </trans-unit>
        <trans-unit id="5c100673b890deacae49fafdc2ea596fde78f6a1" translate="yes" xml:space="preserve">
          <source>Weigh cost and benefit before creating tailored indexes for each query. The potential of above index largely depends on &lt;strong&gt;data distribution&lt;/strong&gt;.</source>
          <target state="translated">在为每个查询创建量身定制的索引之前，请权衡成本和收益。 上述指标的潜力在很大程度上取决于&lt;strong&gt;数据分布&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="06f515e1d1ba4e92316990ed365daa5ce9e800bc" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; include any other expression in the &lt;code&gt;SELECT&lt;/code&gt; list. This is instrumental for replacing much more complex queries with subqueries and aggregate / window functions.</source>
          <target state="translated">您&lt;em&gt;可以&lt;/em&gt;在 &lt;code&gt;SELECT&lt;/code&gt; 列表中包括任何其他表达式。 这有助于用子查询和聚合/窗口函数替换更复杂的查询。</target>
        </trans-unit>
        <trans-unit id="50d72a485d91aa310f99089fed392d899b7d2143" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don't have to&lt;/em&gt; include any of the expressions in &lt;code&gt;DISTINCT ON&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">您&lt;em&gt;不必&lt;/em&gt;在 &lt;code&gt;DISTINCT ON&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 中包含任何表达式。</target>
        </trans-unit>
        <trans-unit id="4335d470451a86c659a4bb868ff8503b753296c3" translate="yes" xml:space="preserve">
          <source>You can replace &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; with any condition you want with one restriction: This subquery must not return more than one row</source>
          <target state="translated">您可以使用任意条件（一个限制 &lt;code&gt;amount = MAX( tf.amount )&lt;/code&gt; 替换amount = MAX（tf.amount） ：此子查询不得返回多于一行</target>
        </trans-unit>
        <trans-unit id="ff8ad01ccf2ca61d81d3b6151da26b5764ea41ec" translate="yes" xml:space="preserve">
          <source>You can use next subquery:</source>
          <target state="translated">你可以使用下一个子查询。</target>
        </trans-unit>
        <trans-unit id="780f59927c03bd3be899b36571f8ee337f8e53df" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;array_agg&lt;/code&gt; in a similar way for your third output column, but &lt;code&gt;max(total)&lt;/code&gt; is simpler.</source>
          <target state="translated">您可以类似的方式将 &lt;code&gt;array_agg&lt;/code&gt; 用于第三输出列，但 &lt;code&gt;max(total)&lt;/code&gt; 更简单。</target>
        </trans-unit>
        <trans-unit id="0a9176588fee007a7b61d9f6efb42dd41d191785" translate="yes" xml:space="preserve">
          <source>and don't forget to create clustered index for used columns</source>
          <target state="translated">不要忘记为使用过的列创建群集索引</target>
        </trans-unit>
        <trans-unit id="88200cf876dc2073e81590d595033eb094e2c28d" translate="yes" xml:space="preserve">
          <source>and really very fast if table is indexed by id:</source>
          <target state="translated">而且如果表是由id索引的,真的非常快。</target>
        </trans-unit>
        <trans-unit id="bf114a4fa7e29ac34c48f6e08b28e60a65ca3444" translate="yes" xml:space="preserve">
          <source>t1, t2 are subquery alias which could be removed depending on database.</source>
          <target state="translated">t1、t2是子查询的别名,可以根据数据库的不同而删除。</target>
        </trans-unit>
        <trans-unit id="70beadc9f0fa5a1f69a14a41423854c7849012e4" translate="yes" xml:space="preserve">
          <source>we make sure that all records that have another record with the higher total for the same user to be joined:</source>
          <target state="translated">我们确保所有的记录都有另一个记录的总和较高的同一用户加入。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
