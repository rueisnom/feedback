<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/38549">
    <body>
      <group id="38549">
        <trans-unit id="18f4dae56d000f66774339b0c0e242ddd46d6a69" translate="yes" xml:space="preserve">
          <source>(For &lt;strong&gt;RIGHT JOIN&lt;/strong&gt; just change place of tables)</source>
          <target state="translated">（对于&lt;strong&gt;RIGHT JOIN，&lt;/strong&gt;只需更改桌子的位置即可）</target>
        </trans-unit>
        <trans-unit id="1103d9f7e49fa59bb4074196eee8d1cc11e9f824" translate="yes" xml:space="preserve">
          <source>(For outer joins only) add back in any outer rows that were lost in step 2.</source>
          <target state="translated">(仅适用于外接行)将步骤2中丢失的外接行加回来。</target>
        </trans-unit>
        <trans-unit id="7ab6f3a5b416e50e9aa35680b1c87835b2e12327" translate="yes" xml:space="preserve">
          <source>(NB: In practice the query optimiser may find more efficient ways of executing the query than the purely logical description above but the final result must be the same)</source>
          <target state="translated">(注:在实践中,查询优化器可能会发现比上面的纯逻辑描述更有效的查询执行方式,但最终的结果必须是一样的)</target>
        </trans-unit>
        <trans-unit id="2ee9c87a5025a8fadd7bd0d40432d7015ebee4ab" translate="yes" xml:space="preserve">
          <source>(SQL Standard 2006 SQL/Foundation 7.7 Syntax Rules 1, General Rules 1 b, 3 c &amp;amp; d, 5 b.)</source>
          <target state="translated">（SQL Standard 2006 SQL / Foundation 7.7语法规则1，通用规则1b，3c和d，5b。）</target>
        </trans-unit>
        <trans-unit id="1ca5c7e8c7520721660e2d5b90ab18a76334dae3" translate="yes" xml:space="preserve">
          <source>... And then the &quot;Where&quot; clause runs. &lt;code&gt;NULL= 'Green'&lt;/code&gt; does not evaluate to true so the row preserved by the outer join ends up discarded (along with the blue one) effectively converting the join back to an inner one.</source>
          <target state="translated">...然后运行&amp;ldquo; Where&amp;rdquo;子句。 &lt;code&gt;NULL= 'Green'&lt;/code&gt; 不等于true，因此外部联接保留的行最终被丢弃（与蓝色联接在一起），从而有效地将联接转换回内部联接。</target>
        </trans-unit>
        <trans-unit id="1112ab72c09d2e02ab65a877e02f6bc42cc5cdc6" translate="yes" xml:space="preserve">
          <source>1.&lt;strong&gt;INNER JOIN OR EQUI JOIN :&lt;/strong&gt; Returns the resultset that matches only the condition in both the tables.</source>
          <target state="translated">1. &lt;strong&gt;INNER JOIN或EQUI JOIN：&lt;/strong&gt;返回仅与两个表中的条件均匹配的结果集。</target>
        </trans-unit>
        <trans-unit id="eda19804921bc29a121c3bfc2de8f437ab66668a" translate="yes" xml:space="preserve">
          <source>1.&lt;strong&gt;Inner Join:&lt;/strong&gt; Also called as Join. It returns the rows present in both the Left table, and right table only &lt;strong&gt;if there is a match&lt;/strong&gt;. Otherwise, it returns zero records.</source>
          <target state="translated">1. &lt;strong&gt;内部联接：&lt;/strong&gt;也称为联接。 仅&lt;strong&gt;当存在match时&lt;/strong&gt; ，它才返回Left表和right表中都存在的行。 否则，它将返回零记录。</target>
        </trans-unit>
        <trans-unit id="5a17b9cadd901452497715957e323f90d02a6c59" translate="yes" xml:space="preserve">
          <source>2.&lt;strong&gt;Full Outer Join:&lt;/strong&gt; Also called as Full Join. It returns &lt;strong&gt;all the rows&lt;/strong&gt; present in both the Left table, and right table.</source>
          <target state="translated">2. &lt;strong&gt;完全外部联接：&lt;/strong&gt;也称为完全联接。 它返回在左表和右表中都存在的&lt;strong&gt;所有行&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e7e8150506fc72fa39878d7596a0a5abd9b4e0d" translate="yes" xml:space="preserve">
          <source>2.&lt;strong&gt;OUTER JOIN :&lt;/strong&gt; Returns the resultset of all the values from both the tables even if there is condition match or not.</source>
          <target state="translated">2. &lt;strong&gt;OUTER JOIN：&lt;/strong&gt;返回两个表中所有值的结果集，即使条件匹配与否。</target>
        </trans-unit>
        <trans-unit id="74154242c76c8e95e2c83f1d2ddf909e1815b8c6" translate="yes" xml:space="preserve">
          <source>3.&lt;strong&gt;LEFT JOIN :&lt;/strong&gt; Returns the resultset of all the values from left table and only rows that match the condition in right table.</source>
          <target state="translated">3. &lt;strong&gt;LEFT JOIN：&lt;/strong&gt;返回左表中所有值的结果集，并且仅返回与右表中的条件匹配的行。</target>
        </trans-unit>
        <trans-unit id="cfe2a4e137476117eea71a6afe177dfbef898b8b" translate="yes" xml:space="preserve">
          <source>3.&lt;strong&gt;Left Outer join:&lt;/strong&gt; Or simply called as Left Join. It returns all the rows present in the Left table and matching rows from the right table (if any).</source>
          <target state="translated">3. &lt;strong&gt;左外部&lt;/strong&gt;联接&lt;strong&gt;：&lt;/strong&gt;或简称为&amp;ldquo;左联接&amp;rdquo;。 它返回左侧表中存在的所有行以及右侧表中的匹配行（如果有）。</target>
        </trans-unit>
        <trans-unit id="330d91e4b7487e86a60cd4d82b8dfbc3571eff96" translate="yes" xml:space="preserve">
          <source>4.&lt;strong&gt;RIGHT JOIN :&lt;/strong&gt; Returns the resultset of all the values from right table and only rows that match the condition in left table.</source>
          <target state="translated">4. &lt;strong&gt;RIGHT JOIN：&lt;/strong&gt;返回右表中所有值的结果集，仅返回与左表中条件匹配的行。</target>
        </trans-unit>
        <trans-unit id="9a13a69d7e540c64e1fedbd654b70146f78680c3" translate="yes" xml:space="preserve">
          <source>4.&lt;strong&gt;Right Outer Join:&lt;/strong&gt; Also called as Right Join. It returns matching rows from the left table (if any), and all the rows present in the Right table.</source>
          <target state="translated">4. &lt;strong&gt;右外连接：&lt;/strong&gt;也称为右连接。 它从左表（如果有）返回匹配的行，并在右表中返回所有行。</target>
        </trans-unit>
        <trans-unit id="0e0211c520493270996754e361691ef861688e9a" translate="yes" xml:space="preserve">
          <source>5.&lt;strong&gt;FULL JOIN :&lt;/strong&gt; Full Join and Full outer Join are same.</source>
          <target state="translated">5. &lt;strong&gt;FULL JOIN：&lt;/strong&gt;完全联接和完全外部联接是相同的。</target>
        </trans-unit>
        <trans-unit id="e48205af2864cbc106e18ca7d298a5e7250ed96c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;... ON 1 = 0&lt;/code&gt; (just as sample)</source>
          <target state="translated">&lt;code&gt;... ON 1 = 0&lt;/code&gt; （仅作为示例）</target>
        </trans-unit>
        <trans-unit id="b3e1a7771d5b56f5b9f95b695f281768cd942fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;... ON T1.title = T2.title AND T1.version &amp;lt; T2.version&lt;/code&gt; ( =&amp;gt; see this post as a sample usage: &lt;a href=&quot;https://stackoverflow.com/a/7745635/2803565&quot;&gt;Select only rows with max value on a column&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;... ON T1.title = T2.title AND T1.version &amp;lt; T2.version&lt;/code&gt; （=&amp;gt;参见本文示例： &lt;a href=&quot;https://stackoverflow.com/a/7745635/2803565&quot;&gt;仅选择列上具有最大值的行&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="575a2e502aa66398db5e33f9089780a6317d6706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FULL JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Unmatched data on &lt;strong&gt;both right and left&lt;/strong&gt; tables with &lt;code&gt;Null&lt;/code&gt; matches.</source>
          <target state="translated">&lt;code&gt;FULL JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + &lt;strong&gt;左右&lt;/strong&gt;表上具有 &lt;code&gt;Null&lt;/code&gt; 匹配项的不匹配数据。</target>
        </trans-unit>
        <trans-unit id="6289c9ea3e06c1ca068e7d56c25784109d8d514e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FULL JOIN&lt;/code&gt; is the combination of &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; and &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; without duplication.</source>
          <target state="translated">&lt;code&gt;FULL JOIN&lt;/code&gt; 是 &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; 和 &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; 的组合，没有重复。</target>
        </trans-unit>
        <trans-unit id="822f29aeb6f972bc582fbb7a8c486c1cd1097dc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HR&lt;/code&gt; and &lt;code&gt;R&amp;amp;D&lt;/code&gt; rows are not printed from &lt;strong&gt;Department&lt;/strong&gt; table as they didn't find a match in the Emp table on dept_id.</source>
          <target state="translated">&lt;code&gt;HR&lt;/code&gt; 和 &lt;code&gt;R&amp;amp;D&lt;/code&gt; 行未从&lt;strong&gt;Department&lt;/strong&gt;表中打印出来，因为它们在dept_id的Emp表中找不到匹配项。</target>
        </trans-unit>
        <trans-unit id="e6e142abeea80887a54bd7d2fdcc43630b5aa003" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INNER JOIN&lt;/code&gt; most typical join for two or more tables.
It returns data match on both table ON primarykey and forignkey relation.</source>
          <target state="translated">&lt;code&gt;INNER JOIN&lt;/code&gt; 用于两个或多个表的最典型的联接 。 它返回表ON主键和外键关系上的数据匹配。</target>
        </trans-unit>
        <trans-unit id="a81746573fd5f741e95779845fade8dc5adfee55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INNER JOIN&lt;/code&gt; requires there is at least a match in comparing the two tables. For example, table A and table B which implies A ٨ B (A intersection B).</source>
          <target state="translated">&lt;code&gt;INNER JOIN&lt;/code&gt; 要求比较两个表时至少要有一个匹配项。 例如，表A和表B表示A ٨ B（交点B）。</target>
        </trans-unit>
        <trans-unit id="44ff51705f35e156b7b175cad63c95b269504282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; is a join that combined tables based on matching tuples, whereas &lt;code&gt;outer join&lt;/code&gt; is a join that combined table based on both matched and unmatched tuple.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; 是基于匹配元组合并表的联接，而 &lt;code&gt;outer join&lt;/code&gt; 是基于匹配和不匹配元组合并表的联接。</target>
        </trans-unit>
        <trans-unit id="aa510743eceda6ddcbe15136913f53c2f3c411cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; is like an intersection operation, whereas &lt;code&gt;outer join&lt;/code&gt; is like an union operation.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; 就像一个交集操作，而 &lt;code&gt;outer join&lt;/code&gt; 就像一个联合操作。</target>
        </trans-unit>
        <trans-unit id="6dd05de6038af0dbf0be21a24b2253dee03f45f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; is two types, whereas &lt;code&gt;outer join&lt;/code&gt; are three types.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; 是两种类型，而 &lt;code&gt;outer join&lt;/code&gt; 是三种类型。</target>
        </trans-unit>
        <trans-unit id="dce48c3731e0e5f728db35dfd36030db8ad4f454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; merges matched row from two table in where unmatched row are omitted, whereas &lt;code&gt;outer join&lt;/code&gt; merges rows from two tables and unmatched rows fill with null value.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; 联接合并两个表中的匹配行，其中省略不匹配的行，而 &lt;code&gt;outer join&lt;/code&gt; 联接合并两个表中的行，不匹配的行填充为空值。</target>
        </trans-unit>
        <trans-unit id="614b3893311249a7b79ac47c031269a0687cba36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LEFT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Unmatched data of &lt;strong&gt;left&lt;/strong&gt; table with &lt;code&gt;Null&lt;/code&gt; match on right table.</source>
          <target state="translated">&lt;code&gt;LEFT JOIN&lt;/code&gt; =内 &lt;code&gt;INNER JOIN&lt;/code&gt; + &lt;strong&gt;左&lt;/strong&gt;表的不匹配数据与&lt;strong&gt;右&lt;/strong&gt;表的 &lt;code&gt;Null&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="4ed07293ac076ad142ca1134247060f8edc28dd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; and &lt;code&gt;LEFT JOIN&lt;/code&gt; are the same. It gives all the records matching in both tables and all possibilities of the left table.</source>
          <target state="translated">&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; 和 &lt;code&gt;LEFT JOIN&lt;/code&gt; 相同。 它提供了两个表中都匹配的所有记录以及左侧表的所有可能性。</target>
        </trans-unit>
        <trans-unit id="cbf275c3e36ea19fb32c15b4179006a63e397144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OUTER JOIN&lt;/code&gt; is same as &lt;code&gt;INNER JOIN&lt;/code&gt;, but it also include &lt;code&gt;NULL&lt;/code&gt; data on ResultSet.</source>
          <target state="translated">&lt;code&gt;OUTER JOIN&lt;/code&gt; 与 &lt;code&gt;INNER JOIN&lt;/code&gt; 相同，但在ResultSet上还包括 &lt;code&gt;NULL&lt;/code&gt; 数据。</target>
        </trans-unit>
        <trans-unit id="6a076b02468de7fa04b232ba09a0c8c9ea97042f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RIGHT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Unmatched data of &lt;strong&gt;right&lt;/strong&gt; table with &lt;code&gt;Null&lt;/code&gt; match on left table.</source>
          <target state="translated">&lt;code&gt;RIGHT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + &lt;strong&gt;右&lt;/strong&gt;表的不匹配数据与&lt;strong&gt;左&lt;/strong&gt;表的 &lt;code&gt;Null&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="d7bd754c9a615d028748e0f1f328653527347d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;full join on&lt;/code&gt; (aka &lt;code&gt;full outer join on&lt;/code&gt;) returns &lt;code&gt;inner join on&lt;/code&gt; rows&lt;code&gt;union all&lt;/code&gt; unmatched left table rows extended by nulls &lt;code&gt;union all&lt;/code&gt; unmatched right table rows extended by nulls.</source>
          <target state="translated">&lt;code&gt;full join on&lt;/code&gt; （也称为 &lt;code&gt;full outer join on&lt;/code&gt; ）返回行上的 &lt;code&gt;inner join on&lt;/code&gt; &lt;code&gt;union all&lt;/code&gt; 不匹配的左表行扩展为null &lt;code&gt;union all&lt;/code&gt; 合并所有不匹配的右表行扩展为null。</target>
        </trans-unit>
        <trans-unit id="8f439d43890134d6d07dd557f2ec7a687d2939b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left join on&lt;/code&gt; (aka &lt;code&gt;left outer join on&lt;/code&gt;) returns &lt;code&gt;inner join on&lt;/code&gt; rows &lt;code&gt;union all&lt;/code&gt; unmatched left table rows extended by nulls.</source>
          <target state="translated">&lt;code&gt;left join on&lt;/code&gt; （即上的 &lt;code&gt;left outer join on&lt;/code&gt; ）在行 &lt;code&gt;union all&lt;/code&gt; 返回所有不匹配的左表行（由null扩展）时返回 &lt;code&gt;inner join on&lt;/code&gt; 联接。</target>
        </trans-unit>
        <trans-unit id="17bed42a91d97b616e5c4bd9f7011808c6f64d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;outer join&lt;/code&gt; is faster than &lt;code&gt;inner join&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;outer join&lt;/code&gt; 快于 &lt;code&gt;inner join&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d51cb34608e46c8887d549402781593f0baf2d05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right join (on&lt;/code&gt; aka  &lt;code&gt;right outer join on&lt;/code&gt;) returns &lt;code&gt;inner join on&lt;/code&gt; rows &lt;code&gt;union all&lt;/code&gt; unmatched right table rows extended by nulls.</source>
          <target state="translated">&lt;code&gt;right join (on&lt;/code&gt; 也称为上的 &lt;code&gt;right outer join on&lt;/code&gt; ） &lt;code&gt;inner join on&lt;/code&gt; &lt;code&gt;union all&lt;/code&gt; 匹配的右表行扩展为null的行联合 上返回内部联接。</target>
        </trans-unit>
        <trans-unit id="5284108496f45688da6ccc63a30bd50179ad1757" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.datamartist.com/sql-inner-join-left-outer-join-full-outer-join-examples-with-syntax-for-sql-server&quot;&gt;Inner and outer joins SQL examples and the Join block&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.datamartist.com/sql-inner-join-left-outer-join-full-outer-join-examples-with-syntax-for-sql-server&quot;&gt;内联接和外联接SQL示例和Join块&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce5ba03d43753d11f87c795c5b48c794f4ccccfe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.techonthenet.com/sql/joins.php&quot;&gt;SQL: JOINS&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.techonthenet.com/sql/joins.php&quot;&gt;SQL：联接&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6e1007b6009f8e3ab441a83e2c983c9706bb816" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt;&lt;/strong&gt; returns all the rows from the first table, even if there are no matches in the second table.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; &lt;/strong&gt;返回第一个表中的所有行，即使第二个表中没有匹配项也是如此。</target>
        </trans-unit>
        <trans-unit id="6f61e3f03800c5f13aba9ecab327fd48a84190bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt;&lt;/strong&gt; returns all the rows from the second table, even if there are no matches in the first table.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; &lt;/strong&gt;返回第二个表中的所有行，即使第一个表中没有匹配项也是如此。</target>
        </trans-unit>
        <trans-unit id="58a118bcd3f1f96eba707eb674be4151cb0f0b81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner Join:-&lt;/em&gt;&lt;/strong&gt;
Inner join creates a new result table by combining column values of two tables (&lt;em&gt;Employee&lt;/em&gt; and &lt;em&gt;Location&lt;/em&gt;) based upon the join-predicate. The query compares each row of &lt;em&gt;Employee&lt;/em&gt; with each row of &lt;em&gt;Location&lt;/em&gt; to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied by matching non-NULL values, column values for each matched pair of rows of &lt;em&gt;Employee&lt;/em&gt; and &lt;em&gt;Location&lt;/em&gt; are combined into a result row.
Here&amp;rsquo;s what the SQL for an inner join will look like:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;内部联接：-内部联接通过基于联接&lt;/em&gt;&lt;/strong&gt;谓词组合两个表（ &lt;em&gt;Employee&lt;/em&gt;和&lt;em&gt;Location&lt;/em&gt; ）的列值来创建新的结果表。 该查询将&lt;em&gt;Employee&lt;/em&gt;的每一行与&lt;em&gt;Location的&lt;/em&gt;每一行进行比较，以找到满足join谓词的所有行对。 当通过匹配非NULL值满足连接谓词时，将&lt;em&gt;Employee&lt;/em&gt;和&lt;em&gt;Location的&lt;/em&gt;每对匹配行对的列值组合到结果行中。 内部联接的SQL如下所示：</target>
        </trans-unit>
        <trans-unit id="a15ad963841cdb86b7d8026843acdf4cb8197887" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left Outer Join:-&lt;/em&gt;&lt;/strong&gt;
The result of a left outer join (or simply left join) for tables &lt;em&gt;Employee&lt;/em&gt; and &lt;em&gt;Location&lt;/em&gt; always contains all records of the &quot;left&quot; table (&lt;em&gt;Employee&lt;/em&gt;), even if the join-condition does not find any matching record in the &quot;right&quot; table (&lt;em&gt;Location&lt;/em&gt;).
Here is what the SQL for a left outer join would look like, using the tables above:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;左外部联接：-&lt;/em&gt;&lt;/strong&gt;表&lt;em&gt;Employee&lt;/em&gt;和&lt;em&gt;Location的&lt;/em&gt; &lt;strong&gt;&lt;em&gt;左外部联接&lt;/em&gt;&lt;/strong&gt; （或简单地称为左&lt;strong&gt;&lt;em&gt;联接）&lt;/em&gt;&lt;/strong&gt;的结果始终包含&amp;ldquo; left&amp;rdquo;表（ &lt;em&gt;Employee&lt;/em&gt; ）的所有记录，即使&lt;strong&gt;&lt;em&gt;联接&lt;/em&gt;&lt;/strong&gt;条件未在其中找到任何匹配的记录&amp;ldquo;正确的&amp;rdquo;表（ &lt;em&gt;Location&lt;/em&gt; ）。 使用上面的表，这是用于左外部联接的SQL的样子：</target>
        </trans-unit>
        <trans-unit id="41ca6e24300fb269772c1cc9086a8eec08019638" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right Outer Join:-&lt;/em&gt;&lt;/strong&gt;
A right outer join (or right join) closely resembles a left outer join, except with the treatment of the tables reversed. Every row from the &quot;right&quot; table (&lt;em&gt;Location&lt;/em&gt;) will appear in the joined table at least once. If no matching row from the &quot;left&quot; table (&lt;em&gt;Employee&lt;/em&gt;) exists, NULL will appear in columns from &lt;em&gt;Employee&lt;/em&gt; for those records that have no match in &lt;em&gt;Location&lt;/em&gt;.
This is what the SQL looks like:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;右外部联接：-右外部联接&lt;/em&gt;&lt;/strong&gt; （或右&lt;strong&gt;&lt;em&gt;联接&lt;/em&gt;&lt;/strong&gt; ）与左外部&lt;strong&gt;&lt;em&gt;联接&lt;/em&gt;&lt;/strong&gt;非常相似，除了对表的处理相反。 &amp;ldquo;右&amp;rdquo;表（ &lt;em&gt;Location&lt;/em&gt; ）中的每一行将至少出现在联接表中一次。 如果不存在来自&amp;ldquo;左&amp;rdquo;表（ &lt;em&gt;Employee&lt;/em&gt; ）的匹配行，则对于&lt;em&gt;Location中&lt;/em&gt;不匹配的那些记录， &lt;em&gt;Employee的&lt;/em&gt;列中将出现NULL。 这是SQL的样子：</target>
        </trans-unit>
        <trans-unit id="a88ee6ce41bb758a1c7ecd962a86705fec6431ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages of Joins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;加盟优势&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f138526350b5c761db0f9d4abfb112cf8c7bed5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CROSS JOIN / OUTER JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;交叉联接/外部联接：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ea910727472da9ec70ace66a1b4a1a05b1bed49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Department&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Department&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="539f024185b0baf36ba38aad0d4d345bb0cf0316" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Diagramatically it looks like :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;图表上看起来像：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92a734c432871adb34884645a7f02ae747c9de88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EMP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EMP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45b2be8766b746717f8ddf1d843872db09e7a25d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;范例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccb0dd8032485f8f35689068fced368200e253e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FULL OUTER JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;全外连接：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01ffd668136c44363b82ba5e7df29e048725f431" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full Outer Join.&lt;/strong&gt; Same as inner join then preserve left non matched rows as in left outer join and right non matching rows as per right outer join.</source>
          <target state="translated">&lt;strong&gt;完全外部联接。&lt;/strong&gt; 与内部联接相同，然后保留与左侧外部联接相同的左侧不匹配行，以及根据右侧外部联接的右侧不匹配行。</target>
        </trans-unit>
        <trans-unit id="56c8be7219c9a2ee1cd260a55a8d9fbe6390af53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full Outer Joins:-&lt;/strong&gt;
Full Outer Join or Full Join is to retain the nonmatching information by including nonmatching rows in the results of a join, use a full outer join. It includes all rows from both tables, regardless of whether or not the other table has a matching value.</source>
          <target state="translated">&lt;strong&gt;完全外部联接：-&lt;/strong&gt;完全外部联接或完全联接通过在&lt;strong&gt;联接&lt;/strong&gt;结果中包括不匹配的行来保留不匹配的信息，请使用&lt;strong&gt;完全外部联接&lt;/strong&gt; 。 它包括两个表中的所有行，而不管另一个表是否具有匹配值。</target>
        </trans-unit>
        <trans-unit id="d9e06b97202e04700b8b18d88f1af2781135c024" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full outer join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;完全外部联接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc733d04ff45a9ce464953247405bc5d271e0d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full outer join&lt;/strong&gt; - A &lt;strong&gt;full outer join&lt;/strong&gt; will give you the union of A and B, i.e. All the rows in A and all the rows in B. If something in A doesn't have a corresponding datum in B, then the B portion is null, and vice versay</source>
          <target state="translated">&lt;strong&gt;完全外部联接&lt;/strong&gt; - &lt;strong&gt;完全外部联接&lt;/strong&gt;将为您提供A和B的并集，即A中的所有行和B中的所有行。如果A中的某项在B中没有对应的基准，则B部分为null，反之亦然</target>
        </trans-unit>
        <trans-unit id="7b30597ad78976015f31241855e62d379c34261a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full&lt;/strong&gt;: All rows in all tables. It doesn't matter if there is a match or not</source>
          <target state="translated">&lt;strong&gt;完整&lt;/strong&gt; ：所有表中的所有行。 是否有比赛都没关系</target>
        </trans-unit>
        <trans-unit id="ed14c016e0ac78259f5e85c6cc1728daa259b18a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INNER JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;内部联接 ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5cbfc9c56fcf57758b0af848351b5beb3770208" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner Join.&lt;/strong&gt; Evaluate the condition in the &quot;ON&quot; clause for all rows in the cross join result. If true return the joined row. Otherwise discard it.</source>
          <target state="translated">&lt;strong&gt;内部联接。&lt;/strong&gt; 评估交叉连接结果中所有行的&amp;ldquo; ON&amp;rdquo;子句中的条件。 如果为true，则返回加入的行。 否则将其丢弃。</target>
        </trans-unit>
        <trans-unit id="6b80cd7d8aff0220e91177b0d7443f545f08f98e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;内部联接。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf4f53bda2e26f5d8fe75953e418352a7fc87b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;内部联接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8b3216f52d096ce1d812ec134509fc124fba772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join&lt;/strong&gt; - An &lt;strong&gt;inner join&lt;/strong&gt; using either of the equivalent queries gives the intersection of the two &lt;em&gt;tables&lt;/em&gt;, i.e. the two rows they have in common.</source>
          <target state="translated">&lt;strong&gt;内部联接&lt;/strong&gt; -使用任一等效查询的&lt;strong&gt;内部&lt;/strong&gt;联接给出两个&lt;em&gt;表&lt;/em&gt;的交集，即它们共有的两行。</target>
        </trans-unit>
        <trans-unit id="e0a06e0a1a3e5f17d188a6e0e46f02524b07ce0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join&lt;/strong&gt; -&amp;gt; Take ONLY common records from parent and child tables WHERE primary key of Parent table matches Foreign key in Child table.</source>
          <target state="translated">&lt;strong&gt;内部联接&lt;/strong&gt; -&amp;gt;仅从父表和子表中获取公共记录，而父表的主键与子表中的外键匹配。</target>
        </trans-unit>
        <trans-unit id="d0b0b7b590379bd14f2e4e22acd6d64547e96a99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner joins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;内部联接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f1a22da8a9e21b166575fe0c6a64f79c9ad1909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Joins&lt;/strong&gt; are used to combine the data from two tables, with the result being a new, temporary table. Joins are performed based on something called a predicate, which specifies the condition to use in order to perform a join.  The difference between an inner join and an outer join is that an inner join will return only the rows that actually match based on the join predicate.
For eg- Lets consider Employee and Location table:</source>
          <target state="translated">&lt;strong&gt;联接&lt;/strong&gt;用于合并两个表中的数据，结果是一个新的临时表。 联接是根据称为谓词的事物执行的，谓词指定了执行联接所使用的条件。 内部联接和外部联接之间的区别在于，内部联接将仅基于联接谓词返回实际匹配的行。 例如-让我们考虑Employee和Location表：</target>
        </trans-unit>
        <trans-unit id="d18b92884fb13bc0cb8c87d213a654438c175a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEFT [OUTER] JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;左[外部]加入：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a559787709b5b41c77a29388d0541dff14769689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left Outer Join.&lt;/strong&gt; Same as inner join then for any rows in the left table that did not match anything output these with NULL values for the right table columns.</source>
          <target state="translated">&lt;strong&gt;左外联接。&lt;/strong&gt; 与内部联接相同，然后对左表中任何不匹配的行输出这些，并为右表列输出NULL值。</target>
        </trans-unit>
        <trans-unit id="53575125ed477eb69ada490c455c9e25177f42e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left join&lt;/strong&gt; -&amp;gt;</source>
          <target state="translated">&lt;strong&gt;左联接&lt;/strong&gt; -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dce91a02c7a774ef76673db65ccd35a893ac9311" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left joins&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;左联接&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="174304e29fef1d1cc0deee5e5dabfe3f148771fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left outer join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;左外连接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8712f8d5a0f4608e7ea22668028b0f8a95fb331c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left outer join&lt;/strong&gt; - A &lt;strong&gt;left outer join&lt;/strong&gt; will give all rows in A, plus any common rows in B.</source>
          <target state="translated">&lt;strong&gt;左外部联接&lt;/strong&gt; - &lt;strong&gt;左外部联接&lt;/strong&gt;将给出A中的所有行，以及B中的所有常见行。</target>
        </trans-unit>
        <trans-unit id="e16795df7cdd2665784158bfb2cac6ae80c3b99e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left&lt;/strong&gt;: Matched rows in the right table and all rows in the left table</source>
          <target state="translated">&lt;strong&gt;左&lt;/strong&gt; ：右表中的匹配行以及左表中的所有行</target>
        </trans-unit>
        <trans-unit id="4fd60bff71f22aa6b0b98c37c8b77c4a59628810" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意 ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec38125fea23e909737762fe542652b742f97695" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Left Join = Left Outer Join, Right Join = Right Outer Join.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;左联接=左外部联接，右联接=右外部联接。</target>
        </trans-unit>
        <trans-unit id="1669d6ff06bba52b87371eaf1add930e3f46b74f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the condition specified in &lt;code&gt;ON&lt;/code&gt; clause could be anything, it is not required to use &lt;em&gt;Primary Keys&lt;/em&gt; (and you don't need to always refer to Columns from both tables)! For example:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;ON&lt;/code&gt; 子句中指定的条件可以是任何条件，不需要使用&lt;em&gt;主键&lt;/em&gt; （并且您不必始终引用两个表中的列）！ 例如：</target>
        </trans-unit>
        <trans-unit id="e0125e1961b14e5f72809e1b306754f6dd1d557b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrderDetails&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OrderDetails&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99197cdb083371d63ccf4a6f592f6b40ee3c9f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Orders&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Orders&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="987d4648c56000a9b822eda388ee8a43a55aee81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer Join.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;外连接。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b81edde9767222220000353746080c4d42719" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer Join:-&lt;/strong&gt;
An outer join does not require each record in the two joined tables to have a matching record. The joined table retains each record&amp;mdash;even if no other matching record exists. Outer joins subdivide further into left outer joins and right outer joins, depending on which table's rows are retained (left or right).</source>
          <target state="translated">&lt;strong&gt;外部联接：-外部联接&lt;/strong&gt;不需要两个联接表中的每个记录都具有匹配的记录。 联接的表将保留每个记录，即使不存在其他匹配的记录也是如此。 外连接细分为左外连接和右外连接，具体取决于保留的是表的行（左还是右）。</target>
        </trans-unit>
        <trans-unit id="4cb071d1262bd436475d7c178d6425cf0db93afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer join&lt;/strong&gt; : Show all records in Both tables &lt;code&gt;No matter what&lt;/code&gt;. If records in Left table are not matching to right table based on Primary , Forieign key , use NULL value as result of join .</source>
          <target state="translated">&lt;strong&gt;外部联接&lt;/strong&gt; ：无论如何都显示两个表中的所有记录。 如果基于主键，外键，左表中的记录与右表不匹配，请使用NULL值作为连接的结果。</target>
        </trans-unit>
        <trans-unit id="eced74db5e696cb15b7ab26918d85d2337300984" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer joins&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;外连接&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="5c9bbd2155fde57ed39bbffcb354fa2f112dc90c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right Outer Join.&lt;/strong&gt; Same as inner join then for any rows in the right table that did not  match anything output these with NULL values for the left table columns.</source>
          <target state="translated">&lt;strong&gt;右外连接。&lt;/strong&gt; 与内部联接相同，然后在右表中与所有表都不匹配的任何行中，用左表列的NULL值输出这些行。</target>
        </trans-unit>
        <trans-unit id="81a52d354bc5e020d41acec86ba3f33a03a9ea4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right join&lt;/strong&gt; : Exactly opposite of left join . Put name of table in LEFT JOIN at right side in Right join , you get same output as LEFT JOIN.</source>
          <target state="translated">&lt;strong&gt;右连接&lt;/strong&gt; ：与左连接正好相反。 将表名放在LEFT JOIN右边的LEFT JOIN中，您将得到与LEFT JOIN相同的输出。</target>
        </trans-unit>
        <trans-unit id="87a56baa424f4d3d1c65526a248f64f6557e109b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right outer join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;右外连接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e1f4e50af5ade43e7c4b0265aff9e0e30f5cc11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right&lt;/strong&gt;: Matched rows in the left table and all rows in the right table or</source>
          <target state="translated">&lt;strong&gt;右&lt;/strong&gt; ：左表中的匹配行以及右表中的所有行或</target>
        </trans-unit>
        <trans-unit id="d9095cfef51f85ff92303a876e55e4a02594c67c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SELECT A.Colour, B.Colour FROM A CROSS JOIN B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;从交叉连接B中选择A.颜色，B。颜色&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2778817bca2e05faa3992a19f2ba20acb9c70416" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON 1 =1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;从1 = 1的内部联接B中选择A.颜色，B。颜色&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="223522858ed35c3fce45c53b1c91da94d9f00803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour = B.Colour&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;从A.Colour = B.Colour的内部联接B中选择A.Colour，B.Colour&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e916e9b725386e99ccdfa4fbe05053d6c922eba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest Definitions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最简单的定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d76c86f84b68aa1fafefb7b28fa40643fc9eb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, INNER JOIN or just JOIN, returns only matching rows.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;因此，INNER JOIN或仅JOIN仅返回匹配的行。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e202b3c8958dac32387b787dbac8ca5fa28e9775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, LEFT JOIN returns ALL rows from Left table and only matching rows from RIGHT table.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;因此，LEFT JOIN返回Left表中的所有行，并且仅返回Right表中的匹配行。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50f7a1b719d912578b790c7fb99c73e430f11940" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source Tables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;源表&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c106dd3cf97ee7ddbfa022157d7c3dcd0e70d200" translate="yes" xml:space="preserve">
          <source>A (left) outer join shows rows for each record on the left hand side, even if there are no matching rows on the other (right) side of the join. If there is no matching row, the columns for the other (right) side would show NULLs.</source>
          <target state="translated">一个(左)外连接显示左手边的每条记录的记录,即使在连接的另一边(右)没有匹配的记录。如果没有匹配的记录,另一边(右边)的列将显示为NULL。</target>
        </trans-unit>
        <trans-unit id="0175d4d4f5205701306812c25bdd93a4cc62e401" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;left join&lt;/em&gt; attempts to find match up the rows from the first table to rows in the second table. If it can&amp;rsquo;t find a match, it will return the columns from the first table and leave the columns from the second table blank (null).</source>
          <target state="translated">&lt;em&gt;左联接&lt;/em&gt;尝试查找匹配从第一个表到第二个表中的行的行。 如果找不到匹配项，它将返回第一个表中的列，并将第二个表中的列留空（空）。</target>
        </trans-unit>
        <trans-unit id="3b0bc92acd1df6008dc3045386942512625a2778" translate="yes" xml:space="preserve">
          <source>A full outer join will give you the union of A and B, i.e. all the rows in A and all the rows in B. If something in A doesn't have a corresponding datum in B, then the B portion is null, and vice versa.</source>
          <target state="translated">如果A中的东西在B中没有对应的数据,那么B的部分就是空的,反之亦然。</target>
        </trans-unit>
        <trans-unit id="401e7906157d60ee13780daa764f11a986077666" translate="yes" xml:space="preserve">
          <source>A inner join only shows rows if there is a matching record on the other (right) side of the join.</source>
          <target state="translated">一个内连接只有在连接的另一边(右边)有匹配的记录时才会显示行。</target>
        </trans-unit>
        <trans-unit id="cb633e94a5bc361a6ad45e9358a8d72f370f614e" translate="yes" xml:space="preserve">
          <source>A join is combining the rows from two tables. An &lt;em&gt;inner join&lt;/em&gt; attempts to match up the two tables based on the criteria you specify in the query, and only returns the rows that match. If a row from the first table in the join matches two rows in the second table, then two rows will be returned in the results. If there&amp;rsquo;s a row in the first table that doesn&amp;rsquo;t match a row in the second, it&amp;rsquo;s not returned; likewise, if there&amp;rsquo;s a row in the second table that doesn&amp;rsquo;t match a row in the first, it&amp;rsquo;s not returned.</source>
          <target state="translated">联接是合并两个表中的行。 &lt;em&gt;内部联接&lt;/em&gt;尝试根据您在查询中指定的条件来匹配两个表，并且仅返回匹配的行。 如果联接中第一个表中的一行与第二个表中的两行匹配，那么结果中将返回两行。 如果第一个表中的行与第二个表中的行不匹配，则不返回该行； 同样，如果第二个表中的行与第一个表中的行不匹配，则不返回该行。</target>
        </trans-unit>
        <trans-unit id="681011899ce6e47d6505296eaf8081e38e600231" translate="yes" xml:space="preserve">
          <source>A left outer join will give all rows in A, plus any common rows in B.</source>
          <target state="translated">左边的外接将给出A中的所有行,再加上B中的任何共同行。</target>
        </trans-unit>
        <trans-unit id="aa107a67a3385ec798974161b60e92ac5ad8a8ae" translate="yes" xml:space="preserve">
          <source>A right outer join will give all rows in B, plus any common rows in A.</source>
          <target state="translated">一个右外连将给出B中的所有行,加上A中的任何共同行。</target>
        </trans-unit>
        <trans-unit id="28cfdab67f0cb5cd074c585745a5fd7206cd12e3" translate="yes" xml:space="preserve">
          <source>Also how do &lt;code&gt;LEFT JOIN&lt;/code&gt;, &lt;code&gt;RIGHT JOIN&lt;/code&gt; and &lt;code&gt;FULL JOIN&lt;/code&gt; fit in?</source>
          <target state="translated">&lt;code&gt;LEFT JOIN&lt;/code&gt; ， &lt;code&gt;RIGHT JOIN&lt;/code&gt; 和 &lt;code&gt;FULL JOIN&lt;/code&gt; 又如何配合？</target>
        </trans-unit>
        <trans-unit id="8304b207dd8971f684ed013c26bdc913335bc02d" translate="yes" xml:space="preserve">
          <source>Although @Martin Smith's answer is the best of this bunch by a long way, his only shows the key column from each table, whereas I think ideally non-key columns should also be shown.</source>
          <target state="translated">虽然@Martin Smith的答案是这一堆中最好的,但他的答案只显示了每个表的关键列,而我认为理想的情况下,非关键列也应该显示出来。</target>
        </trans-unit>
        <trans-unit id="32028e1a0290f9ff4dcd428c844422deb3ec3d2d" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;inner join&lt;/strong&gt; retrieve the matched rows only.</source>
          <target state="translated">&lt;strong&gt;内部&lt;/strong&gt;联接仅检索匹配的行。</target>
        </trans-unit>
        <trans-unit id="8c70d375b06fbdba4a33de00d121d22a779fffc1" translate="yes" xml:space="preserve">
          <source>An inner join of A and B gives the result of A intersect B, i.e. the inner part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Venn_diagram&quot;&gt;Venn diagram&lt;/a&gt; intersection.</source>
          <target state="translated">A和B的内部连接给出A相交的结果B，即&lt;a href=&quot;http://en.wikipedia.org/wiki/Venn_diagram&quot;&gt;维恩图&lt;/a&gt;相交的内部。</target>
        </trans-unit>
        <trans-unit id="af8106ce1b0aff06c7faba1de937e3e4e79a2ecd" translate="yes" xml:space="preserve">
          <source>An inner join using either of the equivalent queries gives the intersection of the two tables, i.e. the two rows they have in common.</source>
          <target state="translated">使用其中任何一个等价查询的内连接给出了两个表的交点,也就是它们有共同点的两行。</target>
        </trans-unit>
        <trans-unit id="23e5ead469bf02733fa0f70c48673da5f64b887a" translate="yes" xml:space="preserve">
          <source>An outer join of A and B gives the results of A union B, i.e. the outer parts of a Venn diagram union.</source>
          <target state="translated">A和B的外接,给出了A结合B的结果,即维恩图结合的外接。</target>
        </trans-unit>
        <trans-unit id="ff985aed95f0c3baa1020892f628c068098bfd97" translate="yes" xml:space="preserve">
          <source>And also in &lt;code&gt;MySQL&lt;/code&gt; there is no &lt;code&gt;FULL OUTER JOIN&lt;/code&gt;.</source>
          <target state="translated">而且在 &lt;code&gt;MySQL&lt;/code&gt; 中 ，没有 &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c895c5eb910d6ee9cd60878eec381c3926e2263" translate="yes" xml:space="preserve">
          <source>Animated Version</source>
          <target state="translated">动画版</target>
        </trans-unit>
        <trans-unit id="9d58c3163d45066573df6cc7b4053300727decb3" translate="yes" xml:space="preserve">
          <source>Are left outer joins associative?</source>
          <target state="translated">左侧外接是联想的吗?</target>
        </trans-unit>
        <trans-unit id="462652c8be314887cc13b7ffac128334714692b0" translate="yes" xml:space="preserve">
          <source>As you see above, &lt;code&gt;Jose&lt;/code&gt; is not printed from &lt;strong&gt;EMP&lt;/strong&gt; in the output as it's dept_id &lt;code&gt;6&lt;/code&gt; does not find a match in the Department table.  Similarly, &lt;code&gt;HR&lt;/code&gt; and &lt;code&gt;R&amp;amp;D&lt;/code&gt; rows are not printed from &lt;strong&gt;Department&lt;/strong&gt; table as they didn't find a match in the Emp table.</source>
          <target state="translated">如上所见，由于输出的dept_id &lt;code&gt;6&lt;/code&gt; 在Department表中找不到匹配项，因此未从&lt;strong&gt;EMP&lt;/strong&gt;中打印出 &lt;code&gt;Jose&lt;/code&gt; 。 同样， &lt;code&gt;HR&lt;/code&gt; 和 &lt;code&gt;R&amp;amp;D&lt;/code&gt; 行也不会从&lt;strong&gt;Department&lt;/strong&gt;表中打印出来，因为它们在Emp表中找不到匹配项。</target>
        </trans-unit>
        <trans-unit id="33141ee86bcf69d70d6b8fb50be630537de73109" translate="yes" xml:space="preserve">
          <source>Assuming you're joining on columns with no duplicates, which is a very common case:</source>
          <target state="translated">假设你是在没有重复的列上加入,这是很常见的情况。</target>
        </trans-unit>
        <trans-unit id="be816f7507dbf5ebdda589f01ad663973af3dab2" translate="yes" xml:space="preserve">
          <source>Basically, more often than not, queries &lt;code&gt;JOIN&lt;/code&gt; boils down to two cases :</source>
          <target state="translated">基本上，查询 &lt;code&gt;JOIN&lt;/code&gt; 通常会归结为两种情况：</target>
        </trans-unit>
        <trans-unit id="14f75c805d0a3ac97c1cd36b886251b790e385bc" translate="yes" xml:space="preserve">
          <source>Can also check DEMO &lt;a href=&quot;https://dbfiddle.uk/?rdbms=postgres_11&amp;amp;fiddle=9dbdd6cf405ae24c5e2a0798a732d389&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">也可以&lt;a href=&quot;https://dbfiddle.uk/?rdbms=postgres_11&amp;amp;fiddle=9dbdd6cf405ae24c5e2a0798a732d389&quot;&gt;在这里&lt;/a&gt;检查DEMO。</target>
        </trans-unit>
        <trans-unit id="510383ffbe9a9158e1b6b7b9537b060a814c8cb2" translate="yes" xml:space="preserve">
          <source>Consider all rows from second table beside it: &lt;code&gt;(a, b[i])&lt;/code&gt;</source>
          <target state="translated">考虑第二个表旁边的所有行： &lt;code&gt;(a, b[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87938a89e313e609e2777db1a5df0151577a103d" translate="yes" xml:space="preserve">
          <source>Consider below 2 tables:</source>
          <target state="translated">考虑到以下2个表。</target>
        </trans-unit>
        <trans-unit id="ce34c8c542402b0ee86027639be2b5d04f3c6b66" translate="yes" xml:space="preserve">
          <source>CustomerName</source>
          <target state="translated">CustomerName</target>
        </trans-unit>
        <trans-unit id="1c4705ae4081e199eef0ae21419928673a34f530" translate="yes" xml:space="preserve">
          <source>Does the join order matter in SQL?</source>
          <target state="translated">SQL中的连接顺序是否重要?</target>
        </trans-unit>
        <trans-unit id="ffc74ecd826f75ff4389d038f58a02a3e90a95ed" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;code&gt;ON ...&lt;/code&gt; clause against each pair: &lt;code&gt;ON( a, b[i] ) = true/false?&lt;/code&gt;</source>
          <target state="translated">对每个对评估 &lt;code&gt;ON ...&lt;/code&gt; 子句： &lt;code&gt;ON( a, b[i] ) = true/false?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b345aed11cf2a02526a7d160db1c1112ab536293" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;code&gt;on&lt;/code&gt; clause against all rows from step 1 keeping those where the predicate evaluates to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">针对步骤1中的所有行评估 &lt;code&gt;on&lt;/code&gt; 子句，使谓词评估为 &lt;code&gt;true&lt;/code&gt; 的那些行</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="6c613ffe714b20b920d18cb37927e35e9165b59a" translate="yes" xml:space="preserve">
          <source>Executes faster.</source>
          <target state="translated">执行速度更快。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="0d18db2aff4d65846fbea636403661ad3950fe12" translate="yes" xml:space="preserve">
          <source>Find out &lt;a href=&quot;https://stackoverflow.com/a/25957600/3404097&quot;&gt;what rows &lt;code&gt;inner join&lt;/code&gt; returns&lt;/a&gt;.</source>
          <target state="translated">找出&lt;a href=&quot;https://stackoverflow.com/a/25957600/3404097&quot;&gt; &lt;code&gt;inner join&lt;/code&gt; 返回的行&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c0abeed924e57f0cc2a06658f26cdea64ce7f03" translate="yes" xml:space="preserve">
          <source>Find out all employees and their department names:</source>
          <target state="translated">找出所有员工及其部门名称。</target>
        </trans-unit>
        <trans-unit id="c04b36ffbc005e1021ab6fe662d901b6f4a392c7" translate="yes" xml:space="preserve">
          <source>First start with a &lt;code&gt;CROSS JOIN&lt;/code&gt; (AKA Cartesian Product). This does not have an &lt;code&gt;ON&lt;/code&gt; clause and simply returns every combination of rows from the two tables.</source>
          <target state="translated">首先从 &lt;code&gt;CROSS JOIN&lt;/code&gt; （又称笛卡尔积）开始。 它没有 &lt;code&gt;ON&lt;/code&gt; 子句，仅返回两个表中行的每个组合。</target>
        </trans-unit>
        <trans-unit id="d04fb52672a2a1c2f1ce96d71e2fce592689817c" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;SELECT&lt;/code&gt; subset of data &lt;code&gt;A&lt;/code&gt; :</source>
          <target state="translated">对于数据 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;SELECT&lt;/code&gt; 子集：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="4ebfe80cebc7a6b6fc3d511e706dfce3960f083c" translate="yes" xml:space="preserve">
          <source>For instance, you have an Orders and an OrderDetails table. They are related by an &quot;OrderID&quot;.</source>
          <target state="translated">例如,你有一个Order和一个OrderDetails表。它们是通过 &quot;OrderID &quot;关联的。</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">全外部加盟</target>
        </trans-unit>
        <trans-unit id="8bfd54988f970615c4e74fce0600de184f98e299" translate="yes" xml:space="preserve">
          <source>Full Outer Join: Returns matched and &lt;strong&gt;unmatched records&lt;/strong&gt; from both tables with null for unmatched records from &lt;strong&gt;Both Tables&lt;/strong&gt;.</source>
          <target state="translated">完全外部联接：从两个表返回匹配和&lt;strong&gt;不匹配的记录&lt;/strong&gt; ，对于来自两个表的&lt;strong&gt;不匹配记录&lt;/strong&gt;返回null。</target>
        </trans-unit>
        <trans-unit id="1f3d31cd72b0a483838a8970f65c751f713013f5" translate="yes" xml:space="preserve">
          <source>Full outer joins combine the behaviour of left and right joins and preserve the non matching rows from both the left and the right tables.</source>
          <target state="translated">完全的外接法结合了左、右接法的行为,保留了左、右表的非匹配行。</target>
        </trans-unit>
        <trans-unit id="6411570fcdc35dfc78de7f609c4b71ace43cae52" translate="yes" xml:space="preserve">
          <source>Generally it is a good practice to try to use &lt;code&gt;INNER JOIN&lt;/code&gt; instead of the different kind of joins. (Of course if it is possible considering the expected result set.)</source>
          <target state="translated">通常，尝试使用 &lt;code&gt;INNER JOIN&lt;/code&gt; 而不是其他类型的联接是一个好习惯。 （当然，如果可以考虑预期结果集。）</target>
        </trans-unit>
        <trans-unit id="c35ab13a279d3d6a71addf0c0c926b9637452a9c" translate="yes" xml:space="preserve">
          <source>Having criticized the much-loved red-shaded Venn diagram, I thought it only fair to post my own attempt.</source>
          <target state="translated">批评了一下大家都很喜欢的红影维恩图,我觉得只有贴出自己的尝试才是公平的。</target>
        </trans-unit>
        <trans-unit id="ad1124e76cf6f5218f0d3a45651d7babcd328eb7" translate="yes" xml:space="preserve">
          <source>Here , employees table is Master table , phone_numbers_employees is child table(it contains &lt;code&gt;emp_id&lt;/code&gt; as foreign key which connects &lt;code&gt;employee.id&lt;/code&gt; so its child table.)</source>
          <target state="translated">在这里，employees表是Master表，phone_numbers_employees是子表（它包含 &lt;code&gt;emp_id&lt;/code&gt; 作为将 &lt;code&gt;employee.id&lt;/code&gt; 与它的子表连接的外键。）</target>
        </trans-unit>
        <trans-unit id="d9a94736cec341670bde435c21aedde70db93a5e" translate="yes" xml:space="preserve">
          <source>Here take only matching rows on primary key = foreign key as explained above.Here non matching rows on primary key = foreign key are skipped as result of join.</source>
          <target state="translated">这里只取主键=外键上的匹配行,如上所述。</target>
        </trans-unit>
        <trans-unit id="c9ed6f85d1a101c06aa6f1658ea9aa6b59660e48" translate="yes" xml:space="preserve">
          <source>I don't see much details about performance and optimizer in the other answers.</source>
          <target state="translated">在其他答案中,我没有看到很多关于性能和优化器的细节。</target>
        </trans-unit>
        <trans-unit id="93a0642b23a99dec05f5e26b605d8eef3a7f0c33" translate="yes" xml:space="preserve">
          <source>I'll start off with an animated version of a &lt;strong&gt;full outer join&lt;/strong&gt;. Further explanation follows.</source>
          <target state="translated">我将以&lt;strong&gt;完整外部联接&lt;/strong&gt;的动画版本开始。 接下来是进一步的解释。</target>
        </trans-unit>
        <trans-unit id="1a2726acbd71bf2259089b5a4a5c3ec69bf22762" translate="yes" xml:space="preserve">
          <source>If the intention was to include only rows from B where Colour is Green and all rows from A regardless the correct syntax would be</source>
          <target state="translated">如果只包括来自B的行,其中Colour是绿色的,而来自A的所有行,无论如何,正确的语法是</target>
        </trans-unit>
        <trans-unit id="3c1266feff7c44326ee6d344d966bdb79fe985b5" translate="yes" xml:space="preserve">
          <source>If you change it to OUTER LEFT JOIN</source>
          <target state="translated">如果你把它改为OUTER LEFT JOIN</target>
        </trans-unit>
        <trans-unit id="21db8be499d2d750d835639da29f05c3d94c9e45" translate="yes" xml:space="preserve">
          <source>Image Source</source>
          <target state="translated">图片来源</target>
        </trans-unit>
        <trans-unit id="fbad4385f9cf327937fb57784e13cacc32509589" translate="yes" xml:space="preserve">
          <source>Imagine a cross join.</source>
          <target state="translated">想象一下,交叉加盟。</target>
        </trans-unit>
        <trans-unit id="b8bd227340485f216d9f687d400cc002452fbcb2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SQLite&lt;/code&gt; there is no &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; or &lt;code&gt;FULL OUTER JOIN&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;SQLite&lt;/code&gt; 中 ，没有 &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; 或 &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f7efb00c93f4548f598f16f503c32e704bad44e" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;&lt;code&gt;OUTER JOIN&lt;/code&gt;&lt;/strong&gt; the resulting table may have empty columns. Outer join may be either &lt;code&gt;LEFT&lt;/code&gt; or &lt;code&gt;RIGHT&lt;/code&gt;.</source>
          <target state="translated">在&lt;strong&gt; &lt;code&gt;OUTER JOIN&lt;/code&gt; &lt;/strong&gt; ，结果表可能具有空列。 外部连接可以是 &lt;code&gt;LEFT&lt;/code&gt; 或 &lt;code&gt;RIGHT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6941fa11ca0dac876d7571fc193479465f3b02cb" translate="yes" xml:space="preserve">
          <source>In Simple Terms,</source>
          <target state="translated">简单的说就是:</target>
        </trans-unit>
        <trans-unit id="6311bfbab6f0ce905c898d3037a4bffed4c85f98" translate="yes" xml:space="preserve">
          <source>In simple words :</source>
          <target state="translated">简单来说,就是:</target>
        </trans-unit>
        <trans-unit id="d0c84010367b3b1669cacd2b79cfdd7e88cb34e5" translate="yes" xml:space="preserve">
          <source>In simple words:</source>
          <target state="translated">简单来说。</target>
        </trans-unit>
        <trans-unit id="cc229704b94d0147c90b5d7ff85d17d93957823a" translate="yes" xml:space="preserve">
          <source>In-Short</source>
          <target state="translated">In-Short</target>
        </trans-unit>
        <trans-unit id="bba8637f720ddb113daf64553a3dfa902c8fd82c" translate="yes" xml:space="preserve">
          <source>Inner Join</source>
          <target state="translated">内参</target>
        </trans-unit>
        <trans-unit id="ed0f4dc8bd3c86cc0d852fa3661f82aa25d1b977" translate="yes" xml:space="preserve">
          <source>Inner Join:</source>
          <target state="translated">内部加盟。</target>
        </trans-unit>
        <trans-unit id="c8d9dc73c8c1abcee44bb2201d574c5bdd397e3e" translate="yes" xml:space="preserve">
          <source>Inner Join: Returns &lt;strong&gt;matched records&lt;/strong&gt; from both tables.</source>
          <target state="translated">内部联接：从两个表中返回&lt;strong&gt;匹配的记录&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fb89a7e2ab0c42a98e269eb6b45b2b2eacdcbc9" translate="yes" xml:space="preserve">
          <source>Inner and Outer joins have an &quot;ON&quot; clause predicate.</source>
          <target state="translated">内接和外接有一个 &quot;ON &quot;分句谓语。</target>
        </trans-unit>
        <trans-unit id="77b537fc04c2b26903dc8f8d71874daad50156d7" translate="yes" xml:space="preserve">
          <source>Inner joins require that a record with a related ID exist in the joined table.</source>
          <target state="translated">内部联接要求在加入的表中有一个具有相关ID的记录。</target>
        </trans-unit>
        <trans-unit id="7906e78bd761931c9fb5f6257964f6a06bc48099" translate="yes" xml:space="preserve">
          <source>It is important to select a column for the &lt;code&gt;IS NULL&lt;/code&gt; test that is either not nullable or for which the join condition ensures that any &lt;code&gt;NULL&lt;/code&gt; values will be excluded in order for this pattern to work correctly and avoid just bringing back rows which happen to have a &lt;code&gt;NULL&lt;/code&gt; value for that column in addition to the un matched rows.</source>
          <target state="translated">为 &lt;code&gt;IS NULL&lt;/code&gt; 测试选择一列不可为空或连接条件可确保排除任何 &lt;code&gt;NULL&lt;/code&gt; 值，以使此模式正常工作，并避免仅带回恰好具有行号的行，这一点很重要。除未匹配的行外，该列的 &lt;code&gt;NULL&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="32dae4a14c63f3d06ed14d7e06f8063fb67939e2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN :</source>
          <target state="translated">左键加入 :</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">左外侧加盟</target>
        </trans-unit>
        <trans-unit id="c09c3a8fecce7bef7fd45a493d0eb3a5dfd61aa8" translate="yes" xml:space="preserve">
          <source>Left Outer Join: Returns matched and unmatched records only from table on &lt;strong&gt;Left Side&lt;/strong&gt;.</source>
          <target state="translated">左外部联接：仅从&lt;strong&gt;左侧的&lt;/strong&gt;表返回匹配和不匹配的记录。</target>
        </trans-unit>
        <trans-unit id="a4f33f2f8f6fa36a7f3549da9ace0c8c90f873b4" translate="yes" xml:space="preserve">
          <source>Left join retains all rows of the left table, regardless of whether there is a row that matches on the right table.</source>
          <target state="translated">左联接保留左表的所有行,不管右表上是否有匹配的行。</target>
        </trans-unit>
        <trans-unit id="9dbc826be2a4c87bb15c6e10de01cb1bee8c720e" translate="yes" xml:space="preserve">
          <source>Lets assume now for 2 tables</source>
          <target state="translated">让我们现在假设2个表</target>
        </trans-unit>
        <trans-unit id="578fd28e6e1d6a67881c636cc195809940352310" translate="yes" xml:space="preserve">
          <source>Matched + Left Unmatched + Right Unmatched = &lt;strong&gt;Full Outer Join&lt;/strong&gt;</source>
          <target state="translated">匹配+左无匹配+右无匹配= &lt;strong&gt;完全外部联接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20bef8251179ea981ce069bda2d4439c0f906f" translate="yes" xml:space="preserve">
          <source>Matched + Left Unmatched = &lt;strong&gt;Left Outer Join&lt;/strong&gt;</source>
          <target state="translated">匹配+左不匹配= &lt;strong&gt;左外连接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c20debdcc383531af756af04ac1fb6109eb4e555" translate="yes" xml:space="preserve">
          <source>Matched + Right Unmatched = &lt;strong&gt;Right Outer Join&lt;/strong&gt;</source>
          <target state="translated">匹配+无匹配= &lt;strong&gt;右外部连接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9fafd10f773407a30cbe2d499509f0299ce7bfc" translate="yes" xml:space="preserve">
          <source>Matched = &lt;strong&gt;Inner Join&lt;/strong&gt;</source>
          <target state="translated">匹配= &lt;strong&gt;内部加入&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d284e943eb5fd0ca9657db2a82c58fac67bf1873" translate="yes" xml:space="preserve">
          <source>Mostly written as just &lt;strong&gt;JOIN&lt;/strong&gt; in sql queries. It returns only the matching records between the tables.</source>
          <target state="translated">在SQL查询中通常只写为&lt;strong&gt;JOIN&lt;/strong&gt; 。 它仅返回表之间的匹配记录。</target>
        </trans-unit>
        <trans-unit id="5f4dedd74eef4176dfbffe6c9b0db73766112c08" translate="yes" xml:space="preserve">
          <source>My answer is based on above &lt;strong&gt;Note&lt;/strong&gt;.</source>
          <target state="translated">我的答案是基于上述&lt;strong&gt;Note的&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c82465200a850a68b9a9fa6bf4458ac4b0c2b1a4" translate="yes" xml:space="preserve">
          <source>MySQL 8.0 Reference Manual - Join Syntax</source>
          <target state="translated">MySQL 8.0参考手册-Join语法</target>
        </trans-unit>
        <trans-unit id="eb174e6490ec349d4e09b4ea83a4a1ae58fa3462" translate="yes" xml:space="preserve">
          <source>No rows in the cross join match the &lt;code&gt;1=0&lt;/code&gt; predicate. All rows from both sides are preserved using normal outer join rules with NULL in the columns from the table on the other side.</source>
          <target state="translated">交叉联接中没有行与 &lt;code&gt;1=0&lt;/code&gt; 谓词匹配。 两侧的所有行均使用正常的外部连接规则保留，另一侧的表的列中为NULL。</target>
        </trans-unit>
        <trans-unit id="bcaa9ca6043506ea398e74cca18358fea5a27d5f" translate="yes" xml:space="preserve">
          <source>Note that (1,2) are unique to A, (3,4) are common, and (5,6) are unique to B.</source>
          <target state="translated">注意(1、2)是A独有的,(3、4)是常见的,(5、6)是B独有的。</target>
        </trans-unit>
        <trans-unit id="00a595b79688b3007bb9e1b68113f2cda5be3ae8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;WHERE&lt;/code&gt; clause (if present) logically runs after the join. One common error is to perform a left outer join and then include a WHERE clause with a condition on the right table that ends up excluding the non matching rows. The above ends up performing the outer join...</source>
          <target state="translated">请注意， &lt;code&gt;WHERE&lt;/code&gt; 子句（如果存在）在连接后逻辑上运行。 一个常见的错误是执行左外部联接，然后在右表上包含带有条件的WHERE子句，该条件最终将排除不匹配的行。 以上结束了执行外部联接...</target>
        </trans-unit>
        <trans-unit id="ff243e42183d396280041ad79ffd12833666d910" translate="yes" xml:space="preserve">
          <source>Now, here is what the result of running that SQL would look like:</source>
          <target state="translated">现在,这里是运行那个SQL的结果会是什么样子。</target>
        </trans-unit>
        <trans-unit id="e9ec314891f9b0553314cd5bc1b5e24e1fe7c6da" translate="yes" xml:space="preserve">
          <source>Now, here is what the result of running this SQL would look like:</source>
          <target state="translated">现在,这里是运行这个SQL的结果会是什么样子。</target>
        </trans-unit>
        <trans-unit id="9366d103fdeaf5a08a3a6b1811e27d78ba2778f6" translate="yes" xml:space="preserve">
          <source>Oracle Join operations</source>
          <target state="translated">甲骨文加盟运营</target>
        </trans-unit>
        <trans-unit id="be3fad5644c3cf6262a563f0de6e2fd0998e0bf4" translate="yes" xml:space="preserve">
          <source>OrderDetailID</source>
          <target state="translated">OrderDetailID</target>
        </trans-unit>
        <trans-unit id="600d24f7e0ef1f0898681fc504290cf14d4691a6" translate="yes" xml:space="preserve">
          <source>OrderID</source>
          <target state="translated">OrderID</target>
        </trans-unit>
        <trans-unit id="2e70245241891498db6cad7dc05212a83490cd0c" translate="yes" xml:space="preserve">
          <source>Outer Joins are logically evaluated in the same way as inner joins except that if a row from the left table (for a left join) does not join with any rows from the right hand table at all it is preserved in the result with &lt;code&gt;NULL&lt;/code&gt; values for the right hand columns.</source>
          <target state="translated">外部联接在逻辑上与内部联接的计算方式相同，不同之处在于，如果左表中的行（用于左联接）根本不与右手表中的任何行联接，则结果将保留为 &lt;code&gt;NULL&lt;/code&gt; 值右边的列。</target>
        </trans-unit>
        <trans-unit id="374a336c7ea96113def3455829073de0d8f46525" translate="yes" xml:space="preserve">
          <source>Outer joins will return records for the left side even if nothing exists for the right side.</source>
          <target state="translated">即使右侧的记录不存在,外接将返回左侧的记录。</target>
        </trans-unit>
        <trans-unit id="3e8248e32edfca0c629622b5b669c2d9ce4d0917" translate="yes" xml:space="preserve">
          <source>Price</source>
          <target state="translated">Price</target>
        </trans-unit>
        <trans-unit id="9d714af1e46e653abb32c81ac42098c25716dbb7" translate="yes" xml:space="preserve">
          <source>ProductName</source>
          <target state="translated">ProductName</target>
        </trans-unit>
        <trans-unit id="1e5ff9e500c20c682a037a3a5ced18064af0eb10" translate="yes" xml:space="preserve">
          <source>Qty</source>
          <target state="translated">Qty</target>
        </trans-unit>
        <trans-unit id="3d950760191e5c17a275c5f55c604e9d52587f97" translate="yes" xml:space="preserve">
          <source>Read my comments there re the many confused &amp;amp; poor answers.</source>
          <target state="translated">阅读我的评论，那里有许多令人困惑和糟糕的答案。</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="9b967f2ec09466f8f2f31858c86038b4b048485c" translate="yes" xml:space="preserve">
          <source>Retrieve the matched rows only, that is, &lt;code&gt;A intersect B&lt;/code&gt;.</source>
          <target state="translated">仅检索匹配的行，即 &lt;code&gt;A intersect B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e5114e7789afff7440d75b6a1d33089a6df9df5" translate="yes" xml:space="preserve">
          <source>Right Outer Join: Returns matched and unmatched records only from table on &lt;strong&gt;Right Side&lt;/strong&gt;.</source>
          <target state="translated">右外部联接：仅从&lt;strong&gt;右侧的&lt;/strong&gt;表中返回匹配和不匹配的记录。</target>
        </trans-unit>
        <trans-unit id="f1b2e93b13ae89bdfe2c003685bed4107494b5cb" translate="yes" xml:space="preserve">
          <source>Right outer joins act similarly to left outer joins except they preserve non matching rows from the right table and null extend the left hand columns.</source>
          <target state="translated">右边的外接与左边的外接类似,只是它们保留了右边表格中不匹配的记录,而空的则扩展了左边的列。</target>
        </trans-unit>
        <trans-unit id="2d647db3858ef9c4d4d1b07f011053df11bd1945" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON 1 = 0</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A FULL OUTER JOIN B ON 1=0</target>
        </trans-unit>
        <trans-unit id="cffe4cf34880ac4d7c295b1e0bb80d168c5a44b3" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON A.Colour = B.Colour</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A FULL OUTER JOIN B ON A.Colour=B.Colour</target>
        </trans-unit>
        <trans-unit id="a13e1649aecd1206886059ae14fe7460d24e59da" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour NOT IN ('Green','Blue')</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A INNER JOIN B ON A.Colour NOT IN ('Green','Blue'),B.Colour</target>
        </trans-unit>
        <trans-unit id="d2cd6e1ff7e5116f1a0d5f916881f85f01fd615d" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A LEFT OUTER JOIN B ON A.Colour=B.Colour</target>
        </trans-unit>
        <trans-unit id="3d50844979aa339cbf4da331b98c0e640c6bf0ae" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour AND B.Colour = 'Green'</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A LEFT OUTER JOIN B ON A.Colour=B.Colour AND B.Colour='Green'</target>
        </trans-unit>
        <trans-unit id="e633ac81baec5d384e3e8d94d681236716f1e6c6" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour = 'Green'</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A LEFT OUTER JOIN B ON A.Colour=B.Colour WHERE B.Colour='Green'</target>
        </trans-unit>
        <trans-unit id="91da65b210c38782502b7d13c2e096db98c58b26" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour IS NULL</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A LEFT OUTER JOIN B ON A.Colour=B.Colour WHERE B.Colour IS NULL</target>
        </trans-unit>
        <trans-unit id="57e07cbef7e5897d683d06b9dfb9f60c984010ba" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour = B.Colour</source>
          <target state="translated">SELECT A.Colour,B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour=B.Colour</target>
        </trans-unit>
        <trans-unit id="b0f89b495d78151b223b2078359fd381d2b48a8e" translate="yes" xml:space="preserve">
          <source>SELECT COALESCE(A.Colour, B.Colour) AS Colour FROM A FULL OUTER JOIN B ON 1 = 0</source>
          <target state="translated">SELECT COALESCE(A.Colour,B.Colour)AS Colour FROM A FULL OUTER JOIN B ON 1=0</target>
        </trans-unit>
        <trans-unit id="36a563f27a865c596b19c7761ec4e2b026984fa2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle</source>
          <target state="translated">SQL Fiddle</target>
        </trans-unit>
        <trans-unit id="cb0c31314f39e52437b28c02774906a7a30dc42a" translate="yes" xml:space="preserve">
          <source>See these examples &lt;a href=&quot;http://sqlfiddle.com/#!17/10d3d/29&quot;&gt;run live at SQLFiddle.com&lt;/a&gt;.</source>
          <target state="translated">请参阅这些示例， &lt;a href=&quot;http://sqlfiddle.com/#!17/10d3d/29&quot;&gt;在SQLFiddle.com上实时运行&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="81da6fdad0f70842b42941ca24fc8c73293c8dfc" translate="yes" xml:space="preserve">
          <source>Select all records from the first table, and any records in the second
table that match the joined keys.</source>
          <target state="translated">选择第一张表中的所有记录,以及第二张表中任何符合加入键的记录。</target>
        </trans-unit>
        <trans-unit id="e3ea1a9c1530e2a17b4ec25fc48ebecfd8bda4e9" translate="yes" xml:space="preserve">
          <source>Select all records from the second table, and any records in the first
table that match the joined keys.</source>
          <target state="translated">选择第二张表中的所有记录,以及第一张表中任何符合加入键的记录。</target>
        </trans-unit>
        <trans-unit id="83bef2cc7071931413ea6c15b1d9cbb261201667" translate="yes" xml:space="preserve">
          <source>Self join is not a keyword in SQL, when a table references data in itself knows as self join. Using &lt;code&gt;INNER JOIN&lt;/code&gt; and &lt;code&gt;OUTER JOIN&lt;/code&gt; we can write self join queries.</source>
          <target state="translated">当表本身引用数据时，自连接不是SQL中的关键字，称为自连接。 使用 &lt;code&gt;INNER JOIN&lt;/code&gt; 和 &lt;code&gt;OUTER JOIN&lt;/code&gt; ,我们可以编写自联接查询。</target>
        </trans-unit>
        <trans-unit id="60c27c12ebbc9b0ccdc95adc44b3d6bd42e22ebf" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; and &lt;code&gt;RIGHT JOIN&lt;/code&gt; are the same. It gives all the records matching in both tables and all possibilities of the right table.</source>
          <target state="translated">同样， &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; 和 &lt;code&gt;RIGHT JOIN&lt;/code&gt; 相同。 它提供了两个表中都匹配的所有记录以及右表的所有可能性。</target>
        </trans-unit>
        <trans-unit id="57ac164b04deda9400c97a3c178bcd37f4674dcb" translate="yes" xml:space="preserve">
          <source>So don't &lt;code&gt;outer join&lt;/code&gt; until you know what underlying &lt;code&gt;inner join&lt;/code&gt; is involved.</source>
          <target state="translated">因此，除非您知道所涉及的是底层 &lt;code&gt;inner join&lt;/code&gt; 否则不要进行 &lt;code&gt;outer join&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0239c43496556d996a3ba690826274b35b6de6d6" translate="yes" xml:space="preserve">
          <source>So query would be :</source>
          <target state="translated">所以查询会是:</target>
        </trans-unit>
        <trans-unit id="3a3ef6bdf78356dcb2d8fdf53815126df565e89a" translate="yes" xml:space="preserve">
          <source>So, if you observe the above output, all records from the LEFT table(Emp) are printed with just matching records from RIGHT table.</source>
          <target state="translated">因此,如果你观察到上面的输出,所有来自LEFT表(Emp)的记录都会被打印出来,而RIGHT表的记录则只与之匹配。</target>
        </trans-unit>
        <trans-unit id="76b15ddd9bbae2a42a5c96bc2b644d8162ba90e8" translate="yes" xml:space="preserve">
          <source>Some examples</source>
          <target state="translated">一些例子</target>
        </trans-unit>
        <trans-unit id="c4103bb3eb14901657b76f7f1899071323e5c8cd" translate="yes" xml:space="preserve">
          <source>Sometimes it is good to know that only &lt;code&gt;INNER JOIN&lt;/code&gt; is associative which means the optimizer has the most option to play with it. It can reorder the join order to make it faster keeping the same result. The optimizer can use the most join modes.</source>
          <target state="translated">有时最好知道只有 &lt;code&gt;INNER JOIN&lt;/code&gt; 是关联的，这意味着优化器具有最多的选择。 它可以对连接顺序进行重新排序，以使其更快地保持相同的结果。 优化器可以使用最多的联接模式。</target>
        </trans-unit>
        <trans-unit id="0e94545c59dedc53631e5bf2ea94d07c746c3449" translate="yes" xml:space="preserve">
          <source>Suppose you have two tables, with a single column each, and data as follows:</source>
          <target state="translated">假设你有两张表,每张表只有一列,数据如下。</target>
        </trans-unit>
        <trans-unit id="de05dbfa8bc8b8c89765a1580a72f8d1c53fb687" translate="yes" xml:space="preserve">
          <source>Take each row from the first table: &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">从第一张表中取出每一行：</target>
        </trans-unit>
        <trans-unit id="c7584fafc4a976a172f0acb728079de626672216" translate="yes" xml:space="preserve">
          <source>Take the records of 2 tables &lt;strong&gt;ONLY IF Primary key of employees table(its id) matches Foreign key of Child table phone_numbers_employees(emp_id)&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;仅当雇员表的主键（其id）与子表phone_numbers_employees（emp_id）的外键匹配时&lt;/strong&gt; ，才获取2个表的记录。</target>
        </trans-unit>
        <trans-unit id="b4635a4d9810c755b0fd7ff98effc1f6343585e2" translate="yes" xml:space="preserve">
          <source>The Venn diagrams don't really do it for me.</source>
          <target state="translated">维恩图并不适合我。</target>
        </trans-unit>
        <trans-unit id="a3aad5f7e1572efc104d477450c7cebb3c86f8cb" translate="yes" xml:space="preserve">
          <source>The above is the classic equi join.</source>
          <target state="translated">以上就是经典的等式加盟。</target>
        </trans-unit>
        <trans-unit id="a62f9f75abe497935bbf828702110bb6f41bfa79" translate="yes" xml:space="preserve">
          <source>The answer is in the meaning of each one, so in the results.</source>
          <target state="translated">答案是在每个人的意义上,所以在结果中。</target>
        </trans-unit>
        <trans-unit id="53e041ad0fed92c13129a9acd829713901739e00" translate="yes" xml:space="preserve">
          <source>The best I could do in the half hour allowed, I still don't think it adequately shows that the nulls are there due to absence of key values in &lt;code&gt;TableB&lt;/code&gt; or that &lt;code&gt;OUTER JOIN&lt;/code&gt; is actually a union rather than a join:</source>
          <target state="translated">在允许的半小时内，我能做的最好，但我仍然认为这并不能充分表明空值是由于 &lt;code&gt;TableB&lt;/code&gt; 中缺少键值而导致的，或者 &lt;code&gt;OUTER JOIN&lt;/code&gt; 实际上是联合而不是联接 ：</target>
        </trans-unit>
        <trans-unit id="8f57c73279bb55888b448c5bdc495a588748d6b2" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;inner join&lt;/code&gt; and &lt;code&gt;outer join&lt;/code&gt; is as follow:</source>
          <target state="translated">&lt;code&gt;inner join&lt;/code&gt; 和 &lt;code&gt;outer join&lt;/code&gt; 之间的区别如下：</target>
        </trans-unit>
        <trans-unit id="ed26590cf87cb3aeae866c1693da02c71887e0fb" translate="yes" xml:space="preserve">
          <source>The inner join condition need not necessarily be an equality condition and it need not reference columns from both (or even either) of the tables. Evaluating &lt;code&gt;A.Colour NOT IN ('Green','Blue')&lt;/code&gt; on each row of the cross join returns.</source>
          <target state="translated">内部联接条件不必一定是相等条件，也不需要引用两个表（甚至其中一个表）的列。 在 &lt;code&gt;A.Colour NOT IN ('Green','Blue')&lt;/code&gt; 每一行上评估A.COLOUR NOT IN（&amp;ldquo;绿色&amp;rdquo;，&amp;ldquo;蓝色&amp;rdquo;） 。</target>
        </trans-unit>
        <trans-unit id="aba4f065d0bc304f4809963eab26bdfc99462dc8" translate="yes" xml:space="preserve">
          <source>The join condition evaluates to true for all rows in the cross join result so this is just the same as a cross join. I won't repeat the picture of the 16 rows again.</source>
          <target state="translated">连接条件对交叉连接结果中的所有行都评价为真,所以这和交叉连接一样。关于16行的图片我就不再赘述了。</target>
        </trans-unit>
        <trans-unit id="a9c0f0067130afe8f022fb90a699f83ed307fb70" translate="yes" xml:space="preserve">
          <source>The precise algorithm for &lt;code&gt;INNER JOIN&lt;/code&gt;, &lt;code&gt;LEFT/RIGHT OUTER JOIN&lt;/code&gt; are as following:</source>
          <target state="translated">&lt;code&gt;INNER JOIN&lt;/code&gt; ， &lt;code&gt;LEFT/RIGHT OUTER JOIN&lt;/code&gt; 的精确算法如下：</target>
        </trans-unit>
        <trans-unit id="0314c4ea7fe190fc4c68769257de2b532365173a" translate="yes" xml:space="preserve">
          <source>The request</source>
          <target state="translated">该请求</target>
        </trans-unit>
        <trans-unit id="064e12516d680c606b9271f08193451a42062386" translate="yes" xml:space="preserve">
          <source>Then read my comments here re the many confused &amp;amp; poor answers.</source>
          <target state="translated">然后在这里阅读我的评论，了解许多困惑和糟糕的答案。</target>
        </trans-unit>
        <trans-unit id="f62ba35f901272384724079d8d9a702d631b36d7" translate="yes" xml:space="preserve">
          <source>There are a couple of good examples and explanation here about this strange associative behavior:</source>
          <target state="translated">关于这种奇怪的联想行为,这里有几个好的例子和解释。</target>
        </trans-unit>
        <trans-unit id="af79f3a932c5ca416034380e0e3c369717bfeaac" translate="yes" xml:space="preserve">
          <source>There is a lot of good answers here with very accurate &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_algebra&quot;&gt;relational algebra&lt;/a&gt; examples.  Here is a very simplified answer that might be helpful for amateur or novice coders with SQL coding dilemmas.</source>
          <target state="translated">这里有非常准确的&lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_algebra&quot;&gt;关系代数&lt;/a&gt;示例，有很多很好的答案。 这是一个非常简化的答案，可能对具有SQL编码难题的业余或新手编码员有所帮助。</target>
        </trans-unit>
        <trans-unit id="f100303a3639513408be4936a4e6cc7b73841467" translate="yes" xml:space="preserve">
          <source>There is no substitute for understanding the logical processing and it is relatively straightforward to grasp anyway.</source>
          <target state="translated">对于逻辑处理的理解是无法替代的,反正相对来说是比较直接的掌握。</target>
        </trans-unit>
        <trans-unit id="4778ef7c4e1aa99d9d2b5ca9f2c5fa43583d69e7" translate="yes" xml:space="preserve">
          <source>They don't show any distinction between a cross join and an inner join, for example, or more generally show any distinction between different types of join predicate or provide a framework for reasoning about how they will operate.</source>
          <target state="translated">例如,它们没有显示出交叉连接和内连接之间的任何区别,或者更普遍地显示出不同类型的连接谓语之间的任何区别,也没有提供一个推理它们将如何运作的框架。</target>
        </trans-unit>
        <trans-unit id="40a9fbf518ad99d3cf9f2c242dcb7e9ac085afa8" translate="yes" xml:space="preserve">
          <source>This is a good diagrammatic explanation for all kind of joins</source>
          <target state="translated">这是一个很好的图解,对各种接法都有很好的图解。</target>
        </trans-unit>
        <trans-unit id="25f3df9908570659057e2e6550d4475345358f41" translate="yes" xml:space="preserve">
          <source>This returns all records from the LEFT table and only matching records from the RIGHT table.</source>
          <target state="translated">这将返回左表中的所有记录,只返回右表中的匹配记录。</target>
        </trans-unit>
        <trans-unit id="c7802fed33f09212b06fd43e902012710d8a18e0" translate="yes" xml:space="preserve">
          <source>This simply restricts the previous result to only return the rows where &lt;code&gt;B.Colour IS NULL&lt;/code&gt;. In this particular case these will be the rows that were preserved as they had no match in the right hand table and the query returns the single red row not matched in table &lt;code&gt;B&lt;/code&gt;. This is known as an anti semi join.</source>
          <target state="translated">这只是将先前的结果限制为仅返回 &lt;code&gt;B.Colour IS NULL&lt;/code&gt; 所在的行。 在这种特殊情况下，这些行将被保留，因为它们在右侧表中不匹配，并且查询返回表 &lt;code&gt;B&lt;/code&gt; 中不匹配的单个红色行。 这称为反半连接。</target>
        </trans-unit>
        <trans-unit id="4f72fe6a93efa48588b234ba7af91ed270f584fc" translate="yes" xml:space="preserve">
          <source>Using the tables above, we can show what the result set of a right outer join would look like:</source>
          <target state="translated">利用上面的表格,我们可以展示一个右外连接的结果集会是什么样子。</target>
        </trans-unit>
        <trans-unit id="969d0130ea0f101d149be9545807c1567f0450e7" translate="yes" xml:space="preserve">
          <source>Well, as your need you choose each one that covers your need ;).</source>
          <target state="translated">好吧,根据你的需要,你选择每一个涵盖了你的需要;)。</target>
        </trans-unit>
        <trans-unit id="cae8dd96eef584302609a4891c208f2d7b1b56b2" translate="yes" xml:space="preserve">
          <source>What is the difference between “INNER JOIN” and “OUTER JOIN”</source>
          <target state="translated">&quot;INNER JOIN &quot;和 &quot;OUTER JOIN &quot;有什么区别?</target>
        </trans-unit>
        <trans-unit id="f44fca4ef831061b239894e4f22ea16c7b039773" translate="yes" xml:space="preserve">
          <source>When reach end of second table without any match, and this is an &lt;code&gt;Outer Join&lt;/code&gt; then return a &lt;em&gt;(virtual)&lt;/em&gt; pair using &lt;code&gt;Null&lt;/code&gt; for all columns of other table: &lt;code&gt;(a, Null)&lt;/code&gt; for LEFT outer join or &lt;code&gt;(Null, b)&lt;/code&gt; for RIGHT outer join. This is to ensure all rows of first table exists in final results.</source>
          <target state="translated">当到达第二张表的末尾而没有任何匹配时，这是一个 &lt;code&gt;Outer Join&lt;/code&gt; 然后返回一个&lt;em&gt;（虚拟）&lt;/em&gt;对，对其他表的所有列使用 &lt;code&gt;Null&lt;/code&gt; ： &lt;code&gt;(a, Null)&lt;/code&gt; 代表LEFT外部联接 ，或 &lt;code&gt;(Null, b)&lt;/code&gt; 代表RIGHT外部联接加入。 这是为了确保第一个表的所有行都存在于最终结果中。</target>
        </trans-unit>
        <trans-unit id="46458bcc7be2a6b261798740e5797f2c8e93b556" translate="yes" xml:space="preserve">
          <source>When the condition evaluates to &lt;code&gt;true&lt;/code&gt;, return that combined row  &lt;code&gt;(a, b[i])&lt;/code&gt;.</source>
          <target state="translated">当条件评估为 &lt;code&gt;true&lt;/code&gt; 时 ，返回该组合行 &lt;code&gt;(a, b[i])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df555849cc57a15bca36da039957eadcb8a031d0" translate="yes" xml:space="preserve">
          <source>When you also want to have all rows of the other table in your results you can use &lt;code&gt;FULL OUTER JOIN&lt;/code&gt;:</source>
          <target state="translated">如果您还希望在结果中包含其他表的所有行，则可以使用 &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="58ddb44eac8d428658fec23c0581d51e800d0a93" translate="yes" xml:space="preserve">
          <source>When you have two tables like these:</source>
          <target state="translated">当你有两张这样的桌子时。</target>
        </trans-unit>
        <trans-unit id="651af2720bbc0bab41adea2fe618e68198a14b43" translate="yes" xml:space="preserve">
          <source>When you want to add a filter to above results based on a relation like &lt;code&gt;table1.id = table2.id&lt;/code&gt; you can use &lt;code&gt;INNER JOIN&lt;/code&gt;:</source>
          <target state="translated">当您想基于诸如 &lt;code&gt;table1.id = table2.id&lt;/code&gt; 类的关系向上述结果添加过滤器时，可以使用 &lt;code&gt;INNER JOIN&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e9e497bd07b3a1960453e175763a1967b5d25a53" translate="yes" xml:space="preserve">
          <source>When you want to have all rows of one of tables in the above result -with same relation- you can use &lt;code&gt;LEFT JOIN&lt;/code&gt;:</source>
          <target state="translated">如果要使上述结果中的一个表的所有行具有相同的关系，可以使用 &lt;code&gt;LEFT JOIN&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6205d6e4d1ba0218809cb322a5a7c0c8cdf2d674" translate="yes" xml:space="preserve">
          <source>Whereas an &lt;strong&gt;outer join&lt;/strong&gt; retrieve the matched rows from one table and all rows in other table ....the result depends on which one you are using:</source>
          <target state="translated">而&lt;strong&gt;外部&lt;/strong&gt;联接从一个表中检索匹配的行，而从另一表中检索所有行..结果取决于您使用的是哪一个：</target>
        </trans-unit>
        <trans-unit id="7e8b4ad0f1c4accc3a0d63224ebf61ad7dc8a31d" translate="yes" xml:space="preserve">
          <source>With a minor amend to the preceding query one could simulate a &lt;code&gt;UNION ALL&lt;/code&gt; of the two tables.</source>
          <target state="translated">通过对前面的查询进行较小的修改，可以模拟两个表的 &lt;code&gt;UNION ALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd76f278a4af35c691d8b2e27d68be6abc166d6f" translate="yes" xml:space="preserve">
          <source>You can have all of those tables data with &lt;code&gt;CROSS JOIN&lt;/code&gt; or just with &lt;code&gt;,&lt;/code&gt; like this:</source>
          <target state="translated">您可以使用 &lt;code&gt;CROSS JOIN&lt;/code&gt; 或仅使用拥有所有这些表数据 &lt;code&gt;,&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="1a1e81f049f544da8e827ced9214175f4266ff1e" translate="yes" xml:space="preserve">
          <source>You can use this to find Orders that do not have any OrderDetails indicating a possible orphaned order by adding a where clause like &lt;code&gt;WHERE OrderDetails.OrderID IS NULL&lt;/code&gt;.</source>
          <target state="translated">您可以通过添加诸如 &lt;code&gt;WHERE OrderDetails.OrderID IS NULL&lt;/code&gt; 之类的where子句来查找没有任何OrderDetails指示可能的孤立订单的Order。</target>
        </trans-unit>
        <trans-unit id="c432dc9a8aed93143719f983d09f7dc4ee24f3f2" translate="yes" xml:space="preserve">
          <source>You use &lt;strong&gt;&lt;code&gt;INNER JOIN&lt;/code&gt;&lt;/strong&gt; to return all rows from both tables where there is a match. i.e. In the resulting table all the rows and columns will have values.</source>
          <target state="translated">您可以使用&lt;strong&gt; &lt;code&gt;INNER JOIN&lt;/code&gt; &lt;/strong&gt;从两个匹配的表中返回所有行。 即在结果表中，所有行和列都将具有值。</target>
        </trans-unit>
        <trans-unit id="5ddd1649f6c6d27be685f0befe44428d1f624b7b" translate="yes" xml:space="preserve">
          <source>pseudo code</source>
          <target state="translated">伪代码</target>
        </trans-unit>
        <trans-unit id="90441d92c84393ca73c7ec3bf6e6832e27a0377d" translate="yes" xml:space="preserve">
          <source>source: &lt;a href=&quot;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&quot;&gt;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&quot;&gt;http&lt;/a&gt; ： //ssiddique.info/understanding-sql-joins-in-easy-way.html</target>
        </trans-unit>
        <trans-unit id="c69e4be6cd06f2e7509ef81acef0ab318e493ce0" translate="yes" xml:space="preserve">
          <source>then it will return records from the Orders table even if they have no OrderDetails records.</source>
          <target state="translated">那么它将从订单表中返回记录,即使这些记录没有OrderDetails记录。</target>
        </trans-unit>
        <trans-unit id="e543858eed9e3aab749d5cc296399e70aee10762" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;INNER JOIN&lt;/code&gt; when the related data &lt;code&gt;B&lt;/code&gt; you are looking for &lt;strong&gt;MUST&lt;/strong&gt; exists per database design;</source>
          <target state="translated">根据数据库设计，当您要查找的相关数据 &lt;code&gt;B&lt;/code&gt; &lt;strong&gt;必须&lt;/strong&gt;存在时，请使用 &lt;code&gt;INNER JOIN&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="d149d496aa34dd3b6938dd6b37e601c17b65449f" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;LEFT JOIN&lt;/code&gt; when the related data &lt;code&gt;B&lt;/code&gt; you are looking for &lt;strong&gt;MIGHT&lt;/strong&gt; or &lt;strong&gt;MIGHT NOT&lt;/strong&gt; exists per database design.</source>
          <target state="translated">根据数据库设计，当您正在寻找&lt;strong&gt;MIGHT&lt;/strong&gt;或&lt;strong&gt;MIGHT NOT&lt;/strong&gt;的相关数据 &lt;code&gt;B&lt;/code&gt; 存在时，请使用 &lt;code&gt;LEFT JOIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2af3ad5a640fa2ff80c7fd3d197f32a5c39261e" translate="yes" xml:space="preserve">
          <source>will only return Orders that also have something in the OrderDetails table.</source>
          <target state="translated">将只返回在OrderDetails表中也有东西的订单。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
