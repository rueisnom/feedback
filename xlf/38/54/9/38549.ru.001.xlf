<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/38549">
    <body>
      <group id="38549">
        <trans-unit id="18f4dae56d000f66774339b0c0e242ddd46d6a69" translate="yes" xml:space="preserve">
          <source>(For &lt;strong&gt;RIGHT JOIN&lt;/strong&gt; just change place of tables)</source>
          <target state="translated">(Для &lt;strong&gt;ПРАВИЛЬНОГО СОЕДИНЕНИЯ&lt;/strong&gt; просто поменяйте местами столы)</target>
        </trans-unit>
        <trans-unit id="1103d9f7e49fa59bb4074196eee8d1cc11e9f824" translate="yes" xml:space="preserve">
          <source>(For outer joins only) add back in any outer rows that were lost in step 2.</source>
          <target state="translated">(Только для внешних соединений)добавьте обратно все внешние ряды,которые были потеряны на шаге 2.</target>
        </trans-unit>
        <trans-unit id="7ab6f3a5b416e50e9aa35680b1c87835b2e12327" translate="yes" xml:space="preserve">
          <source>(NB: In practice the query optimiser may find more efficient ways of executing the query than the purely logical description above but the final result must be the same)</source>
          <target state="translated">(NB:На практике оптимизатор запросов может найти более эффективные способы выполнения запроса,чем указанное выше чисто логическое описание,но конечный результат должен быть одинаковым).</target>
        </trans-unit>
        <trans-unit id="2ee9c87a5025a8fadd7bd0d40432d7015ebee4ab" translate="yes" xml:space="preserve">
          <source>(SQL Standard 2006 SQL/Foundation 7.7 Syntax Rules 1, General Rules 1 b, 3 c &amp;amp; d, 5 b.)</source>
          <target state="translated">(SQL Standard 2006 SQL / Foundation 7.7 Синтаксические правила 1, Общие правила 1 b, 3 c &amp;amp; d, 5 b.)</target>
        </trans-unit>
        <trans-unit id="1ca5c7e8c7520721660e2d5b90ab18a76334dae3" translate="yes" xml:space="preserve">
          <source>... And then the &quot;Where&quot; clause runs. &lt;code&gt;NULL= 'Green'&lt;/code&gt; does not evaluate to true so the row preserved by the outer join ends up discarded (along with the blue one) effectively converting the join back to an inner one.</source>
          <target state="translated">... А затем выполняется предложение &quot;Где&quot;. &lt;code&gt;NULL= 'Green'&lt;/code&gt; не оценивается как истина, поэтому строка, сохраненная внешним соединением, в конечном итоге отбрасывается (вместе с синим), эффективно преобразовывая соединение обратно во внутреннее.</target>
        </trans-unit>
        <trans-unit id="1112ab72c09d2e02ab65a877e02f6bc42cc5cdc6" translate="yes" xml:space="preserve">
          <source>1.&lt;strong&gt;INNER JOIN OR EQUI JOIN :&lt;/strong&gt; Returns the resultset that matches only the condition in both the tables.</source>
          <target state="translated">1. &lt;strong&gt;INNER JOIN ИЛИ EQUI JOIN:&lt;/strong&gt; Возвращает &lt;strong&gt;набор&lt;/strong&gt; результатов, который соответствует только условию в обеих таблицах.</target>
        </trans-unit>
        <trans-unit id="eda19804921bc29a121c3bfc2de8f437ab66668a" translate="yes" xml:space="preserve">
          <source>1.&lt;strong&gt;Inner Join:&lt;/strong&gt; Also called as Join. It returns the rows present in both the Left table, and right table only &lt;strong&gt;if there is a match&lt;/strong&gt;. Otherwise, it returns zero records.</source>
          <target state="translated">1. &lt;strong&gt;Внутреннее объединение:&lt;/strong&gt; также называется присоединением. Он возвращает строки, присутствующие как в левой таблице, так и в правой таблице, только &lt;strong&gt;если есть совпадение&lt;/strong&gt; . В противном случае он возвращает ноль записей.</target>
        </trans-unit>
        <trans-unit id="5a17b9cadd901452497715957e323f90d02a6c59" translate="yes" xml:space="preserve">
          <source>2.&lt;strong&gt;Full Outer Join:&lt;/strong&gt; Also called as Full Join. It returns &lt;strong&gt;all the rows&lt;/strong&gt; present in both the Left table, and right table.</source>
          <target state="translated">2. &lt;strong&gt;Полное внешнее соединение:&lt;/strong&gt; также называется полным соединением. Возвращает &lt;strong&gt;все строки,&lt;/strong&gt; присутствующие как в левой таблице, так и в правой таблице.</target>
        </trans-unit>
        <trans-unit id="6e7e8150506fc72fa39878d7596a0a5abd9b4e0d" translate="yes" xml:space="preserve">
          <source>2.&lt;strong&gt;OUTER JOIN :&lt;/strong&gt; Returns the resultset of all the values from both the tables even if there is condition match or not.</source>
          <target state="translated">2. &lt;strong&gt;ВНЕШНЕЕ СОЕДИНЕНИЕ:&lt;/strong&gt; Возвращает набор результатов всех значений из обеих таблиц, даже если условие соответствует или нет.</target>
        </trans-unit>
        <trans-unit id="74154242c76c8e95e2c83f1d2ddf909e1815b8c6" translate="yes" xml:space="preserve">
          <source>3.&lt;strong&gt;LEFT JOIN :&lt;/strong&gt; Returns the resultset of all the values from left table and only rows that match the condition in right table.</source>
          <target state="translated">3. &lt;strong&gt;LEFT JOIN:&lt;/strong&gt; возвращает набор результатов всех значений из левой таблицы и только строк, соответствующих условию в правой таблице.</target>
        </trans-unit>
        <trans-unit id="cfe2a4e137476117eea71a6afe177dfbef898b8b" translate="yes" xml:space="preserve">
          <source>3.&lt;strong&gt;Left Outer join:&lt;/strong&gt; Or simply called as Left Join. It returns all the rows present in the Left table and matching rows from the right table (if any).</source>
          <target state="translated">3. &lt;strong&gt;Левое внешнее соединение:&lt;/strong&gt; или просто называется левым соединением. Он возвращает все строки, присутствующие в левой таблице, и совпадающие строки из правой таблицы (если есть).</target>
        </trans-unit>
        <trans-unit id="330d91e4b7487e86a60cd4d82b8dfbc3571eff96" translate="yes" xml:space="preserve">
          <source>4.&lt;strong&gt;RIGHT JOIN :&lt;/strong&gt; Returns the resultset of all the values from right table and only rows that match the condition in left table.</source>
          <target state="translated">4. &lt;strong&gt;RIGHT JOIN:&lt;/strong&gt; возвращает набор результатов всех значений из правой таблицы и только строк, соответствующих условию в левой таблице.</target>
        </trans-unit>
        <trans-unit id="9a13a69d7e540c64e1fedbd654b70146f78680c3" translate="yes" xml:space="preserve">
          <source>4.&lt;strong&gt;Right Outer Join:&lt;/strong&gt; Also called as Right Join. It returns matching rows from the left table (if any), and all the rows present in the Right table.</source>
          <target state="translated">4. &lt;strong&gt;Правое внешнее соединение:&lt;/strong&gt; также называется правым соединением. Он возвращает совпадающие строки из левой таблицы (если есть) и все строки, присутствующие в правой таблице.</target>
        </trans-unit>
        <trans-unit id="0e0211c520493270996754e361691ef861688e9a" translate="yes" xml:space="preserve">
          <source>5.&lt;strong&gt;FULL JOIN :&lt;/strong&gt; Full Join and Full outer Join are same.</source>
          <target state="translated">5. &lt;strong&gt;ПОЛНОЕ СОЕДИНЕНИЕ:&lt;/strong&gt; полное соединение и полное внешнее соединение - это одно и то же.</target>
        </trans-unit>
        <trans-unit id="e48205af2864cbc106e18ca7d298a5e7250ed96c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;... ON 1 = 0&lt;/code&gt; (just as sample)</source>
          <target state="translated">&lt;code&gt;... ON 1 = 0&lt;/code&gt; (как образец)</target>
        </trans-unit>
        <trans-unit id="b3e1a7771d5b56f5b9f95b695f281768cd942fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;... ON T1.title = T2.title AND T1.version &amp;lt; T2.version&lt;/code&gt; ( =&amp;gt; see this post as a sample usage: &lt;a href=&quot;https://stackoverflow.com/a/7745635/2803565&quot;&gt;Select only rows with max value on a column&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;... ON T1.title = T2.title AND T1.version &amp;lt; T2.version&lt;/code&gt; (=&amp;gt; см. Этот пост в качестве примера использования: &lt;a href=&quot;https://stackoverflow.com/a/7745635/2803565&quot;&gt;выберите только строки с максимальным значением в столбце&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="575a2e502aa66398db5e33f9089780a6317d6706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FULL JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Unmatched data on &lt;strong&gt;both right and left&lt;/strong&gt; tables with &lt;code&gt;Null&lt;/code&gt; matches.</source>
          <target state="translated">&lt;code&gt;FULL JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Несоответствующие данные в &lt;strong&gt;правой и левой&lt;/strong&gt; таблицах с &lt;code&gt;Null&lt;/code&gt; совпадениями.</target>
        </trans-unit>
        <trans-unit id="6289c9ea3e06c1ca068e7d56c25784109d8d514e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FULL JOIN&lt;/code&gt; is the combination of &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; and &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; without duplication.</source>
          <target state="translated">&lt;code&gt;FULL JOIN&lt;/code&gt; - это комбинация &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; и &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; без дублирования.</target>
        </trans-unit>
        <trans-unit id="822f29aeb6f972bc582fbb7a8c486c1cd1097dc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HR&lt;/code&gt; and &lt;code&gt;R&amp;amp;D&lt;/code&gt; rows are not printed from &lt;strong&gt;Department&lt;/strong&gt; table as they didn't find a match in the Emp table on dept_id.</source>
          <target state="translated">Строки &lt;code&gt;HR&lt;/code&gt; и &lt;code&gt;R&amp;amp;D&lt;/code&gt; не выводятся из таблицы &lt;strong&gt;Department, так&lt;/strong&gt; как они не нашли соответствия в таблице Emp на dept_id.</target>
        </trans-unit>
        <trans-unit id="e6e142abeea80887a54bd7d2fdcc43630b5aa003" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INNER JOIN&lt;/code&gt; most typical join for two or more tables.
It returns data match on both table ON primarykey and forignkey relation.</source>
          <target state="translated">&lt;code&gt;INNER JOIN&lt;/code&gt; наиболее типичное объединение для двух или более таблиц. Возвращает совпадение данных как для таблицы ON primarykey, так и для отношения forignkey.</target>
        </trans-unit>
        <trans-unit id="a81746573fd5f741e95779845fade8dc5adfee55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INNER JOIN&lt;/code&gt; requires there is at least a match in comparing the two tables. For example, table A and table B which implies A ٨ B (A intersection B).</source>
          <target state="translated">&lt;code&gt;INNER JOIN&lt;/code&gt; требует, чтобы при сравнении двух таблиц было как минимум совпадение. Например, таблица A и таблица B, которые подразумевают A ٨ B (пересечение A B).</target>
        </trans-unit>
        <trans-unit id="44ff51705f35e156b7b175cad63c95b269504282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; is a join that combined tables based on matching tuples, whereas &lt;code&gt;outer join&lt;/code&gt; is a join that combined table based on both matched and unmatched tuple.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; - это объединение, объединяющее таблицы на основе соответствующих кортежей, тогда как &lt;code&gt;outer join&lt;/code&gt; - это объединение, объединяющее таблицы на основе как сопоставленного, так и несогласованного кортежа.</target>
        </trans-unit>
        <trans-unit id="aa510743eceda6ddcbe15136913f53c2f3c411cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; is like an intersection operation, whereas &lt;code&gt;outer join&lt;/code&gt; is like an union operation.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; похоже на операцию пересечения, тогда как &lt;code&gt;outer join&lt;/code&gt; похоже на операцию объединения.</target>
        </trans-unit>
        <trans-unit id="6dd05de6038af0dbf0be21a24b2253dee03f45f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; is two types, whereas &lt;code&gt;outer join&lt;/code&gt; are three types.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; - два типа, тогда как &lt;code&gt;outer join&lt;/code&gt; - три типа.</target>
        </trans-unit>
        <trans-unit id="dce48c3731e0e5f728db35dfd36030db8ad4f454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Inner join&lt;/code&gt; merges matched row from two table in where unmatched row are omitted, whereas &lt;code&gt;outer join&lt;/code&gt; merges rows from two tables and unmatched rows fill with null value.</source>
          <target state="translated">&lt;code&gt;Inner join&lt;/code&gt; объединяет совпавшую строку из двух таблиц, в которой пропущены несопоставленные строки, тогда как &lt;code&gt;outer join&lt;/code&gt; объединяет строки из двух таблиц, и несопоставленные строки заполняются нулевым значением.</target>
        </trans-unit>
        <trans-unit id="614b3893311249a7b79ac47c031269a0687cba36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LEFT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Unmatched data of &lt;strong&gt;left&lt;/strong&gt; table with &lt;code&gt;Null&lt;/code&gt; match on right table.</source>
          <target state="translated">&lt;code&gt;LEFT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Несоответствующие данные &lt;strong&gt;левой&lt;/strong&gt; таблицы с &lt;code&gt;Null&lt;/code&gt; соответствием в правой таблице.</target>
        </trans-unit>
        <trans-unit id="4ed07293ac076ad142ca1134247060f8edc28dd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; and &lt;code&gt;LEFT JOIN&lt;/code&gt; are the same. It gives all the records matching in both tables and all possibilities of the left table.</source>
          <target state="translated">&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; и &lt;code&gt;LEFT JOIN&lt;/code&gt; - это одно и то же. Это дает все записи, совпадающие в обеих таблицах и все возможности левой таблицы.</target>
        </trans-unit>
        <trans-unit id="cbf275c3e36ea19fb32c15b4179006a63e397144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OUTER JOIN&lt;/code&gt; is same as &lt;code&gt;INNER JOIN&lt;/code&gt;, but it also include &lt;code&gt;NULL&lt;/code&gt; data on ResultSet.</source>
          <target state="translated">&lt;code&gt;OUTER JOIN&lt;/code&gt; - это то же самое, что &lt;code&gt;INNER JOIN&lt;/code&gt; , но оно также включает в себя &lt;code&gt;NULL&lt;/code&gt; - данные в ResultSet.</target>
        </trans-unit>
        <trans-unit id="6a076b02468de7fa04b232ba09a0c8c9ea97042f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RIGHT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Unmatched data of &lt;strong&gt;right&lt;/strong&gt; table with &lt;code&gt;Null&lt;/code&gt; match on left table.</source>
          <target state="translated">&lt;code&gt;RIGHT JOIN&lt;/code&gt; = &lt;code&gt;INNER JOIN&lt;/code&gt; + Несоответствующие данные &lt;strong&gt;правой&lt;/strong&gt; таблицы с &lt;code&gt;Null&lt;/code&gt; соответствием в левой таблице.</target>
        </trans-unit>
        <trans-unit id="d7bd754c9a615d028748e0f1f328653527347d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;full join on&lt;/code&gt; (aka &lt;code&gt;full outer join on&lt;/code&gt;) returns &lt;code&gt;inner join on&lt;/code&gt; rows&lt;code&gt;union all&lt;/code&gt; unmatched left table rows extended by nulls &lt;code&gt;union all&lt;/code&gt; unmatched right table rows extended by nulls.</source>
          <target state="translated">&lt;code&gt;full join on&lt;/code&gt; (он же &lt;code&gt;full outer join on&lt;/code&gt; ) возвращает &lt;code&gt;inner join on&lt;/code&gt; строк, объединяющее &lt;code&gt;union all&lt;/code&gt; несопоставленные строки левой таблицы, расширенные нулями, объединяет все несопоставленные строки правой таблицы, расширенные нулями.</target>
        </trans-unit>
        <trans-unit id="8f439d43890134d6d07dd557f2ec7a687d2939b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left join on&lt;/code&gt; (aka &lt;code&gt;left outer join on&lt;/code&gt;) returns &lt;code&gt;inner join on&lt;/code&gt; rows &lt;code&gt;union all&lt;/code&gt; unmatched left table rows extended by nulls.</source>
          <target state="translated">&lt;code&gt;left join on&lt;/code&gt; включено (или &lt;code&gt;left outer join on&lt;/code&gt; ) возвращает &lt;code&gt;inner join on&lt;/code&gt; строк, объединяющее &lt;code&gt;union all&lt;/code&gt; несопоставленные строки левой таблицы, расширенные нулями.</target>
        </trans-unit>
        <trans-unit id="17bed42a91d97b616e5c4bd9f7011808c6f64d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;outer join&lt;/code&gt; is faster than &lt;code&gt;inner join&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;outer join&lt;/code&gt; быстрее &lt;code&gt;inner join&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d51cb34608e46c8887d549402781593f0baf2d05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right join (on&lt;/code&gt; aka  &lt;code&gt;right outer join on&lt;/code&gt;) returns &lt;code&gt;inner join on&lt;/code&gt; rows &lt;code&gt;union all&lt;/code&gt; unmatched right table rows extended by nulls.</source>
          <target state="translated">&lt;code&gt;right join (on&lt;/code&gt; &lt;code&gt;right outer join on&lt;/code&gt; ) возвращает &lt;code&gt;inner join on&lt;/code&gt; строках, объединяющих &lt;code&gt;union all&lt;/code&gt; несопоставленные правые строки таблицы, расширенные нулями.</target>
        </trans-unit>
        <trans-unit id="5284108496f45688da6ccc63a30bd50179ad1757" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.datamartist.com/sql-inner-join-left-outer-join-full-outer-join-examples-with-syntax-for-sql-server&quot;&gt;Inner and outer joins SQL examples and the Join block&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.datamartist.com/sql-inner-join-left-outer-join-full-outer-join-examples-with-syntax-for-sql-server&quot;&gt;Внутренние и внешние объединения SQL-примеров и блок Join&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce5ba03d43753d11f87c795c5b48c794f4ccccfe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.techonthenet.com/sql/joins.php&quot;&gt;SQL: JOINS&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.techonthenet.com/sql/joins.php&quot;&gt;SQL: СОЕДИНЯЕТСЯ&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6e1007b6009f8e3ab441a83e2c983c9706bb816" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt;&lt;/strong&gt; returns all the rows from the first table, even if there are no matches in the second table.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; &lt;/strong&gt; возвращает все строки из первой таблицы, даже если во второй таблице нет совпадений.</target>
        </trans-unit>
        <trans-unit id="6f61e3f03800c5f13aba9ecab327fd48a84190bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt;&lt;/strong&gt; returns all the rows from the second table, even if there are no matches in the first table.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; &lt;/strong&gt; возвращает все строки из второй таблицы, даже если в первой таблице нет совпадений.</target>
        </trans-unit>
        <trans-unit id="58a118bcd3f1f96eba707eb674be4151cb0f0b81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner Join:-&lt;/em&gt;&lt;/strong&gt;
Inner join creates a new result table by combining column values of two tables (&lt;em&gt;Employee&lt;/em&gt; and &lt;em&gt;Location&lt;/em&gt;) based upon the join-predicate. The query compares each row of &lt;em&gt;Employee&lt;/em&gt; with each row of &lt;em&gt;Location&lt;/em&gt; to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied by matching non-NULL values, column values for each matched pair of rows of &lt;em&gt;Employee&lt;/em&gt; and &lt;em&gt;Location&lt;/em&gt; are combined into a result row.
Here&amp;rsquo;s what the SQL for an inner join will look like:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Внутреннее&lt;/em&gt;&lt;/strong&gt; объединение &lt;strong&gt;&lt;em&gt;: -&lt;/em&gt;&lt;/strong&gt; Внутреннее объединение создает новую таблицу результатов, комбинируя значения столбцов двух таблиц ( &lt;em&gt;Employee&lt;/em&gt; и &lt;em&gt;Location&lt;/em&gt; ) на основе предиката объединения. Запрос сравнивает каждую строку &lt;em&gt;Employee&lt;/em&gt; с каждой строкой &lt;em&gt;Location,&lt;/em&gt; чтобы найти все пары строк, которые удовлетворяют предикату соединения. Когда предикат соединения удовлетворяется путем сопоставления значений, отличных от NULL, значения столбцов для каждой подходящей пары строк &lt;em&gt;Employee&lt;/em&gt; и &lt;em&gt;Location&lt;/em&gt; объединяются в результирующую строку. Вот как будет выглядеть SQL для внутреннего объединения:</target>
        </trans-unit>
        <trans-unit id="a15ad963841cdb86b7d8026843acdf4cb8197887" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left Outer Join:-&lt;/em&gt;&lt;/strong&gt;
The result of a left outer join (or simply left join) for tables &lt;em&gt;Employee&lt;/em&gt; and &lt;em&gt;Location&lt;/em&gt; always contains all records of the &quot;left&quot; table (&lt;em&gt;Employee&lt;/em&gt;), even if the join-condition does not find any matching record in the &quot;right&quot; table (&lt;em&gt;Location&lt;/em&gt;).
Here is what the SQL for a left outer join would look like, using the tables above:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Левое внешнее соединение: -&lt;/em&gt;&lt;/strong&gt; результат левого внешнего соединения (или просто левого соединения) для таблиц &lt;em&gt;Employee&lt;/em&gt; и &lt;em&gt;Location&lt;/em&gt; всегда содержит все записи &amp;laquo;левой&amp;raquo; таблицы ( &lt;em&gt;Employee&lt;/em&gt; ), даже если условие соединения не находит подходящую запись в &amp;laquo;Правильный&amp;raquo; стол ( &lt;em&gt;Location&lt;/em&gt; ). Вот как будет выглядеть SQL для левого внешнего соединения, используя таблицы выше:</target>
        </trans-unit>
        <trans-unit id="41ca6e24300fb269772c1cc9086a8eec08019638" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right Outer Join:-&lt;/em&gt;&lt;/strong&gt;
A right outer join (or right join) closely resembles a left outer join, except with the treatment of the tables reversed. Every row from the &quot;right&quot; table (&lt;em&gt;Location&lt;/em&gt;) will appear in the joined table at least once. If no matching row from the &quot;left&quot; table (&lt;em&gt;Employee&lt;/em&gt;) exists, NULL will appear in columns from &lt;em&gt;Employee&lt;/em&gt; for those records that have no match in &lt;em&gt;Location&lt;/em&gt;.
This is what the SQL looks like:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Правое&lt;/em&gt;&lt;/strong&gt; внешнее соединение &lt;strong&gt;&lt;em&gt;: -&lt;/em&gt;&lt;/strong&gt; Правое внешнее соединение (или правое соединение) очень похоже на левое внешнее соединение, за исключением обработки обращенных таблиц. Каждая строка из &amp;laquo;правой&amp;raquo; таблицы ( &lt;em&gt;Location&lt;/em&gt; ) появится в объединенной таблице хотя бы один раз. Если соответствующая строка из &amp;laquo;левой&amp;raquo; таблицы ( &lt;em&gt;Employee&lt;/em&gt; ) не существует, в столбцах &lt;em&gt;Employee&lt;/em&gt; появится NULL для тех записей, которые не совпадают в &lt;em&gt;Location&lt;/em&gt; . Вот как выглядит SQL:</target>
        </trans-unit>
        <trans-unit id="a88ee6ce41bb758a1c7ecd962a86705fec6431ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages of Joins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Преимущества Joins&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f138526350b5c761db0f9d4abfb112cf8c7bed5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CROSS JOIN / OUTER JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CROSS JOIN / НАРУЖНОЕ СОЕДИНЕНИЕ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ea910727472da9ec70ace66a1b4a1a05b1bed49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Department&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Department&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="539f024185b0baf36ba38aad0d4d345bb0cf0316" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Diagramatically it looks like :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Схематически это выглядит так:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92a734c432871adb34884645a7f02ae747c9de88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EMP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EMP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45b2be8766b746717f8ddf1d843872db09e7a25d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccb0dd8032485f8f35689068fced368200e253e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FULL OUTER JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ПОЛНОЕ НАРУЖНОЕ СОЕДИНЕНИЕ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01ffd668136c44363b82ba5e7df29e048725f431" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full Outer Join.&lt;/strong&gt; Same as inner join then preserve left non matched rows as in left outer join and right non matching rows as per right outer join.</source>
          <target state="translated">&lt;strong&gt;Полное внешнее соединение.&lt;/strong&gt; То же, что и внутреннее соединение, затем сохраняются левые несопоставленные строки, как в левом внешнем соединении, и правые несоответствующие строки в соответствии с правым внешним соединением.</target>
        </trans-unit>
        <trans-unit id="56c8be7219c9a2ee1cd260a55a8d9fbe6390af53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full Outer Joins:-&lt;/strong&gt;
Full Outer Join or Full Join is to retain the nonmatching information by including nonmatching rows in the results of a join, use a full outer join. It includes all rows from both tables, regardless of whether or not the other table has a matching value.</source>
          <target state="translated">&lt;strong&gt;Полное&lt;/strong&gt; внешнее объединение: - Полное внешнее объединение или полное объединение - для сохранения несоответствующей информации путем включения несоответствующих строк в результаты объединения, используйте полное внешнее объединение. Он включает все строки из обеих таблиц, независимо от того, имеет ли другая таблица совпадающее значение.</target>
        </trans-unit>
        <trans-unit id="d9e06b97202e04700b8b18d88f1af2781135c024" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full outer join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Полное внешнее соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc733d04ff45a9ce464953247405bc5d271e0d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full outer join&lt;/strong&gt; - A &lt;strong&gt;full outer join&lt;/strong&gt; will give you the union of A and B, i.e. All the rows in A and all the rows in B. If something in A doesn't have a corresponding datum in B, then the B portion is null, and vice versay</source>
          <target state="translated">&lt;strong&gt;Полное внешнее объединение&lt;/strong&gt; - &lt;strong&gt;полное внешнее объединение&lt;/strong&gt; даст вам объединение A и B, т.е. все строки в A и все строки в B. Если что-то в A не имеет соответствующего элемента в B, то часть B ноль, и наоборот</target>
        </trans-unit>
        <trans-unit id="7b30597ad78976015f31241855e62d379c34261a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full&lt;/strong&gt;: All rows in all tables. It doesn't matter if there is a match or not</source>
          <target state="translated">&lt;strong&gt;Полный&lt;/strong&gt; : все строки во всех таблицах. Неважно, есть ли совпадение или нет</target>
        </trans-unit>
        <trans-unit id="ed14c016e0ac78259f5e85c6cc1728daa259b18a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INNER JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВНУТРЕННЕЕ СОЕДИНЕНИЕ :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5cbfc9c56fcf57758b0af848351b5beb3770208" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner Join.&lt;/strong&gt; Evaluate the condition in the &quot;ON&quot; clause for all rows in the cross join result. If true return the joined row. Otherwise discard it.</source>
          <target state="translated">&lt;strong&gt;Внутреннее соединение.&lt;/strong&gt; Оцените условие в предложении &amp;laquo;ON&amp;raquo; для всех строк в результате перекрестного соединения. Если true, вернуть объединенную строку. В противном случае откажитесь от него.</target>
        </trans-unit>
        <trans-unit id="6b80cd7d8aff0220e91177b0d7443f545f08f98e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внутреннее соединение.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf4f53bda2e26f5d8fe75953e418352a7fc87b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внутреннее соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8b3216f52d096ce1d812ec134509fc124fba772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join&lt;/strong&gt; - An &lt;strong&gt;inner join&lt;/strong&gt; using either of the equivalent queries gives the intersection of the two &lt;em&gt;tables&lt;/em&gt;, i.e. the two rows they have in common.</source>
          <target state="translated">&lt;strong&gt;Внутреннее соединение&lt;/strong&gt; - &lt;strong&gt;внутреннее соединение,&lt;/strong&gt; использующее любой из эквивалентных запросов, дает пересечение двух &lt;em&gt;таблиц&lt;/em&gt; , то есть двух общих строк, которые у них общие.</target>
        </trans-unit>
        <trans-unit id="e0a06e0a1a3e5f17d188a6e0e46f02524b07ce0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner join&lt;/strong&gt; -&amp;gt; Take ONLY common records from parent and child tables WHERE primary key of Parent table matches Foreign key in Child table.</source>
          <target state="translated">&lt;strong&gt;Внутреннее соединение&lt;/strong&gt; -&amp;gt; Возьмите ТОЛЬКО общие записи из родительской и дочерней таблиц, ГДЕ первичный ключ родительской таблицы соответствует внешнему ключу в дочерней таблице.</target>
        </trans-unit>
        <trans-unit id="d0b0b7b590379bd14f2e4e22acd6d64547e96a99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inner joins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внутренние соединения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f1a22da8a9e21b166575fe0c6a64f79c9ad1909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Joins&lt;/strong&gt; are used to combine the data from two tables, with the result being a new, temporary table. Joins are performed based on something called a predicate, which specifies the condition to use in order to perform a join.  The difference between an inner join and an outer join is that an inner join will return only the rows that actually match based on the join predicate.
For eg- Lets consider Employee and Location table:</source>
          <target state="translated">&lt;strong&gt;Объединения&lt;/strong&gt; используются для объединения данных из двух таблиц, в результате чего получается новая временная таблица. Объединения выполняются на основе чего-то, называемого предикатом, в котором указывается условие, используемое для выполнения объединения. Разница между внутренним объединением и внешним объединением заключается в том, что внутреннее объединение будет возвращать только те строки, которые действительно совпадают, основываясь на предикате соединения. Например, давайте рассмотрим таблицу Employee and Location:</target>
        </trans-unit>
        <trans-unit id="d18b92884fb13bc0cb8c87d213a654438c175a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEFT [OUTER] JOIN :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ЛЕВЫЙ [НАРУЖНЫЙ] ПРИСОЕДИНЯЙТЕСЬ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a559787709b5b41c77a29388d0541dff14769689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left Outer Join.&lt;/strong&gt; Same as inner join then for any rows in the left table that did not match anything output these with NULL values for the right table columns.</source>
          <target state="translated">&lt;strong&gt;Оставил Внешнее Соединение.&lt;/strong&gt; То же, что и для внутреннего соединения, для любых строк в левой таблице, которые не совпадают ни с чем, выведите их со значениями NULL для правых столбцов таблицы.</target>
        </trans-unit>
        <trans-unit id="53575125ed477eb69ada490c455c9e25177f42e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left join&lt;/strong&gt; -&amp;gt;</source>
          <target state="translated">&lt;strong&gt;Осталось присоединиться&lt;/strong&gt; -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dce91a02c7a774ef76673db65ccd35a893ac9311" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left joins&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;Левый присоединяется&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="174304e29fef1d1cc0deee5e5dabfe3f148771fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left outer join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Левое внешнее соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8712f8d5a0f4608e7ea22668028b0f8a95fb331c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left outer join&lt;/strong&gt; - A &lt;strong&gt;left outer join&lt;/strong&gt; will give all rows in A, plus any common rows in B.</source>
          <target state="translated">&lt;strong&gt;Левое внешнее соединение&lt;/strong&gt; - &lt;strong&gt;левое внешнее соединение&lt;/strong&gt; даст все строки в A плюс все общие строки в B.</target>
        </trans-unit>
        <trans-unit id="e16795df7cdd2665784158bfb2cac6ae80c3b99e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Left&lt;/strong&gt;: Matched rows in the right table and all rows in the left table</source>
          <target state="translated">&lt;strong&gt;Слева&lt;/strong&gt; : соответствующие строки в правой таблице и все строки в левой таблице</target>
        </trans-unit>
        <trans-unit id="4fd60bff71f22aa6b0b98c37c8b77c4a59628810" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Замечания :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec38125fea23e909737762fe542652b742f97695" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Left Join = Left Outer Join, Right Join = Right Outer Join.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; левое соединение = левое внешнее соединение, правое соединение = правое внешнее соединение.</target>
        </trans-unit>
        <trans-unit id="1669d6ff06bba52b87371eaf1add930e3f46b74f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the condition specified in &lt;code&gt;ON&lt;/code&gt; clause could be anything, it is not required to use &lt;em&gt;Primary Keys&lt;/em&gt; (and you don't need to always refer to Columns from both tables)! For example:</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; условие, указанное в предложении &lt;code&gt;ON&lt;/code&gt; , может быть любым, необязательно использовать &lt;em&gt;первичные ключи&lt;/em&gt; (и вам не нужно всегда ссылаться на столбцы из обеих таблиц)! Например:</target>
        </trans-unit>
        <trans-unit id="e0125e1961b14e5f72809e1b306754f6dd1d557b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrderDetails&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OrderDetails&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99197cdb083371d63ccf4a6f592f6b40ee3c9f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Orders&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Orders&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="987d4648c56000a9b822eda388ee8a43a55aee81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer Join.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внешнее Присоединение.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b81edde9767222220000353746080c4d42719" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer Join:-&lt;/strong&gt;
An outer join does not require each record in the two joined tables to have a matching record. The joined table retains each record&amp;mdash;even if no other matching record exists. Outer joins subdivide further into left outer joins and right outer joins, depending on which table's rows are retained (left or right).</source>
          <target state="translated">&lt;strong&gt;Внешнее соединение: -&lt;/strong&gt; Для внешнего соединения не требуется, чтобы каждая запись в двух соединенных таблицах имела соответствующую запись. Объединенная таблица сохраняет каждую запись, даже если другой соответствующей записи не существует. Внешние объединения подразделяются далее на левые внешние объединения и правые внешние объединения, в зависимости от того, какие строки таблицы сохраняются (левые или правые).</target>
        </trans-unit>
        <trans-unit id="4cb071d1262bd436475d7c178d6425cf0db93afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer join&lt;/strong&gt; : Show all records in Both tables &lt;code&gt;No matter what&lt;/code&gt;. If records in Left table are not matching to right table based on Primary , Forieign key , use NULL value as result of join .</source>
          <target state="translated">&lt;strong&gt;Внешнее соединение&lt;/strong&gt; : Показать все записи в обеих таблицах. Если записи в левой таблице не совпадают с правой таблицей на основе первичного ключа и ключа Forieign, используйте значение NULL в качестве результата объединения.</target>
        </trans-unit>
        <trans-unit id="eced74db5e696cb15b7ab26918d85d2337300984" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Outer joins&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;Внешние соединения&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="5c9bbd2155fde57ed39bbffcb354fa2f112dc90c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right Outer Join.&lt;/strong&gt; Same as inner join then for any rows in the right table that did not  match anything output these with NULL values for the left table columns.</source>
          <target state="translated">&lt;strong&gt;Право Внешнее Соединение.&lt;/strong&gt; То же, что и для внутреннего соединения, для любых строк в правой таблице, которые не совпадают ни с чем, выведите их со значениями NULL для левых столбцов таблицы.</target>
        </trans-unit>
        <trans-unit id="81a52d354bc5e020d41acec86ba3f33a03a9ea4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right join&lt;/strong&gt; : Exactly opposite of left join . Put name of table in LEFT JOIN at right side in Right join , you get same output as LEFT JOIN.</source>
          <target state="translated">&lt;strong&gt;Правое соединение&lt;/strong&gt; : прямо противоположное левому соединению. Поместите имя таблицы в LEFT JOIN справа от правого соединения, вы получите тот же вывод, что и в LEFT JOIN.</target>
        </trans-unit>
        <trans-unit id="87a56baa424f4d3d1c65526a248f64f6557e109b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right outer join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Правое внешнее соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e1f4e50af5ade43e7c4b0265aff9e0e30f5cc11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Right&lt;/strong&gt;: Matched rows in the left table and all rows in the right table or</source>
          <target state="translated">&lt;strong&gt;Справа&lt;/strong&gt; : соответствующие строки в левой таблице и все строки в правой таблице или</target>
        </trans-unit>
        <trans-unit id="d9095cfef51f85ff92303a876e55e4a02594c67c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SELECT A.Colour, B.Colour FROM A CROSS JOIN B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВЫБЕРИТЕ А.ЦВЕТ, Б.ЦВЕТ ИЗ КРЕСТА СОЕДИНИТЕ B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2778817bca2e05faa3992a19f2ba20acb9c70416" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON 1 =1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВЫБЕРИТЕ A.Colour, B.Colour ИЗ ВНУТРЕННЕГО СОЕДИНЕНИЯ B ON 1 = 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="223522858ed35c3fce45c53b1c91da94d9f00803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour = B.Colour&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВЫБЕРИТЕ A.Colour, B.Colour ИЗ ВНУТРЕННЕГО СОЕДИНЕНИЯ B НА A.Colour = B.Colour&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e916e9b725386e99ccdfa4fbe05053d6c922eba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest Definitions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Простейшие определения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d76c86f84b68aa1fafefb7b28fa40643fc9eb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, INNER JOIN or just JOIN, returns only matching rows.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таким образом, INNER JOIN или просто JOIN возвращает только совпадающие строки.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e202b3c8958dac32387b787dbac8ca5fa28e9775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, LEFT JOIN returns ALL rows from Left table and only matching rows from RIGHT table.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таким образом, LEFT JOIN возвращает ВСЕ строки из левой таблицы и только совпадающие строки из правой таблицы.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50f7a1b719d912578b790c7fb99c73e430f11940" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source Tables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Исходные таблицы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c106dd3cf97ee7ddbfa022157d7c3dcd0e70d200" translate="yes" xml:space="preserve">
          <source>A (left) outer join shows rows for each record on the left hand side, even if there are no matching rows on the other (right) side of the join. If there is no matching row, the columns for the other (right) side would show NULLs.</source>
          <target state="translated">A (левый)внешний стык показывает строки для каждой записи с левой стороны,даже если на другой (правой)стороне стыка нет соответствующих строк.Если нет подходящего ряда,столбцы для другой (правой)стороны будут показывать NULL.</target>
        </trans-unit>
        <trans-unit id="0175d4d4f5205701306812c25bdd93a4cc62e401" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;left join&lt;/em&gt; attempts to find match up the rows from the first table to rows in the second table. If it can&amp;rsquo;t find a match, it will return the columns from the first table and leave the columns from the second table blank (null).</source>
          <target state="translated">&lt;em&gt;Левое объединение&lt;/em&gt; пытается найти соответствие строк из первой таблицы и строк во второй таблице. Если он не может найти совпадение, он вернет столбцы из первой таблицы и оставит столбцы из второй таблицы пустыми (пустыми).</target>
        </trans-unit>
        <trans-unit id="3b0bc92acd1df6008dc3045386942512625a2778" translate="yes" xml:space="preserve">
          <source>A full outer join will give you the union of A and B, i.e. all the rows in A and all the rows in B. If something in A doesn't have a corresponding datum in B, then the B portion is null, and vice versa.</source>
          <target state="translated">Полное внешнее соединение даст вам объединение A и B,т.е.все строки в A и все строки в B.Если что-то в A не имеет соответствующего значения в B,то часть B будет нулевой,и наоборот.</target>
        </trans-unit>
        <trans-unit id="401e7906157d60ee13780daa764f11a986077666" translate="yes" xml:space="preserve">
          <source>A inner join only shows rows if there is a matching record on the other (right) side of the join.</source>
          <target state="translated">Внутреннее соединение показывает строки только в том случае,если на другой (правой)стороне соединения есть соответствующая запись.</target>
        </trans-unit>
        <trans-unit id="cb633e94a5bc361a6ad45e9358a8d72f370f614e" translate="yes" xml:space="preserve">
          <source>A join is combining the rows from two tables. An &lt;em&gt;inner join&lt;/em&gt; attempts to match up the two tables based on the criteria you specify in the query, and only returns the rows that match. If a row from the first table in the join matches two rows in the second table, then two rows will be returned in the results. If there&amp;rsquo;s a row in the first table that doesn&amp;rsquo;t match a row in the second, it&amp;rsquo;s not returned; likewise, if there&amp;rsquo;s a row in the second table that doesn&amp;rsquo;t match a row in the first, it&amp;rsquo;s not returned.</source>
          <target state="translated">Объединение объединяет строки из двух таблиц. &lt;em&gt;Внутреннее объединение&lt;/em&gt; пытается сопоставить две таблицы на основе критериев, указанных в запросе, и возвращает только те строки, которые соответствуют. Если строка из первой таблицы в соединении совпадает с двумя строками во второй таблице, то в результатах будут возвращены две строки. Если в первой таблице есть строка, которая не соответствует строке во второй таблице, она не возвращается; аналогично, если во второй таблице есть строка, которая не соответствует строке в первой, она не возвращается.</target>
        </trans-unit>
        <trans-unit id="681011899ce6e47d6505296eaf8081e38e600231" translate="yes" xml:space="preserve">
          <source>A left outer join will give all rows in A, plus any common rows in B.</source>
          <target state="translated">Левый внешний шарнир даст все ряды в A,плюс любые общие ряды в B.</target>
        </trans-unit>
        <trans-unit id="aa107a67a3385ec798974161b60e92ac5ad8a8ae" translate="yes" xml:space="preserve">
          <source>A right outer join will give all rows in B, plus any common rows in A.</source>
          <target state="translated">Правое внешнее соединение даст все ряды в B,плюс любые общие ряды в A.</target>
        </trans-unit>
        <trans-unit id="28cfdab67f0cb5cd074c585745a5fd7206cd12e3" translate="yes" xml:space="preserve">
          <source>Also how do &lt;code&gt;LEFT JOIN&lt;/code&gt;, &lt;code&gt;RIGHT JOIN&lt;/code&gt; and &lt;code&gt;FULL JOIN&lt;/code&gt; fit in?</source>
          <target state="translated">Также как вписываются &lt;code&gt;LEFT JOIN&lt;/code&gt; , &lt;code&gt;RIGHT JOIN&lt;/code&gt; и &lt;code&gt;FULL JOIN&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8304b207dd8971f684ed013c26bdc913335bc02d" translate="yes" xml:space="preserve">
          <source>Although @Martin Smith's answer is the best of this bunch by a long way, his only shows the key column from each table, whereas I think ideally non-key columns should also be shown.</source>
          <target state="translated">Несмотря на то,что ответ Мартина Смита является лучшим из этой связки,он показывает только ключевые столбцы из каждой таблицы,в то время как я думаю,что в идеале неключевые столбцы также должны быть показаны.</target>
        </trans-unit>
        <trans-unit id="32028e1a0290f9ff4dcd428c844422deb3ec3d2d" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;inner join&lt;/strong&gt; retrieve the matched rows only.</source>
          <target state="translated">&lt;strong&gt;Внутреннее соединение&lt;/strong&gt; извлекает только совпадающие строки.</target>
        </trans-unit>
        <trans-unit id="8c70d375b06fbdba4a33de00d121d22a779fffc1" translate="yes" xml:space="preserve">
          <source>An inner join of A and B gives the result of A intersect B, i.e. the inner part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Venn_diagram&quot;&gt;Venn diagram&lt;/a&gt; intersection.</source>
          <target state="translated">Внутреннее соединение A и B дает результат пересечения A B, то есть внутреннюю часть пересечения &lt;a href=&quot;http://en.wikipedia.org/wiki/Venn_diagram&quot;&gt;диаграммы Венна&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af8106ce1b0aff06c7faba1de937e3e4e79a2ecd" translate="yes" xml:space="preserve">
          <source>An inner join using either of the equivalent queries gives the intersection of the two tables, i.e. the two rows they have in common.</source>
          <target state="translated">Внутреннее соединение,использующее любой из эквивалентных запросов,дает пересечение двух таблиц,т.е.две строки,которые у них общие.</target>
        </trans-unit>
        <trans-unit id="23e5ead469bf02733fa0f70c48673da5f64b887a" translate="yes" xml:space="preserve">
          <source>An outer join of A and B gives the results of A union B, i.e. the outer parts of a Venn diagram union.</source>
          <target state="translated">Внешнее соединение A и B дает результаты соединения A,т.е.внешние части диаграммы соединения Венна.</target>
        </trans-unit>
        <trans-unit id="ff985aed95f0c3baa1020892f628c068098bfd97" translate="yes" xml:space="preserve">
          <source>And also in &lt;code&gt;MySQL&lt;/code&gt; there is no &lt;code&gt;FULL OUTER JOIN&lt;/code&gt;.</source>
          <target state="translated">А также в &lt;code&gt;MySQL&lt;/code&gt; нет &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c895c5eb910d6ee9cd60878eec381c3926e2263" translate="yes" xml:space="preserve">
          <source>Animated Version</source>
          <target state="translated">Анимированная версия</target>
        </trans-unit>
        <trans-unit id="9d58c3163d45066573df6cc7b4053300727decb3" translate="yes" xml:space="preserve">
          <source>Are left outer joins associative?</source>
          <target state="translated">Левые внешние соединения ассоциативны?</target>
        </trans-unit>
        <trans-unit id="462652c8be314887cc13b7ffac128334714692b0" translate="yes" xml:space="preserve">
          <source>As you see above, &lt;code&gt;Jose&lt;/code&gt; is not printed from &lt;strong&gt;EMP&lt;/strong&gt; in the output as it's dept_id &lt;code&gt;6&lt;/code&gt; does not find a match in the Department table.  Similarly, &lt;code&gt;HR&lt;/code&gt; and &lt;code&gt;R&amp;amp;D&lt;/code&gt; rows are not printed from &lt;strong&gt;Department&lt;/strong&gt; table as they didn't find a match in the Emp table.</source>
          <target state="translated">Как вы видите выше, &lt;code&gt;Jose&lt;/code&gt; не выводится из &lt;strong&gt;EMP&lt;/strong&gt; в выходных данных, поскольку его dept_id &lt;code&gt;6&lt;/code&gt; не находит соответствия в таблице Department. Точно так же строки &lt;code&gt;HR&lt;/code&gt; и &lt;code&gt;R&amp;amp;D&lt;/code&gt; не печатаются из таблицы &lt;strong&gt;Department,&lt;/strong&gt; поскольку они не нашли соответствия в таблице Emp.</target>
        </trans-unit>
        <trans-unit id="33141ee86bcf69d70d6b8fb50be630537de73109" translate="yes" xml:space="preserve">
          <source>Assuming you're joining on columns with no duplicates, which is a very common case:</source>
          <target state="translated">Предположим,что вы присоединяетесь к колонкам без дубликатов,что очень распространенный случай:</target>
        </trans-unit>
        <trans-unit id="be816f7507dbf5ebdda589f01ad663973af3dab2" translate="yes" xml:space="preserve">
          <source>Basically, more often than not, queries &lt;code&gt;JOIN&lt;/code&gt; boils down to two cases :</source>
          <target state="translated">В основном, чаще всего запросы &lt;code&gt;JOIN&lt;/code&gt; сводятся к двум случаям:</target>
        </trans-unit>
        <trans-unit id="14f75c805d0a3ac97c1cd36b886251b790e385bc" translate="yes" xml:space="preserve">
          <source>Can also check DEMO &lt;a href=&quot;https://dbfiddle.uk/?rdbms=postgres_11&amp;amp;fiddle=9dbdd6cf405ae24c5e2a0798a732d389&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Также можете проверить ДЕМО &lt;a href=&quot;https://dbfiddle.uk/?rdbms=postgres_11&amp;amp;fiddle=9dbdd6cf405ae24c5e2a0798a732d389&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="510383ffbe9a9158e1b6b7b9537b060a814c8cb2" translate="yes" xml:space="preserve">
          <source>Consider all rows from second table beside it: &lt;code&gt;(a, b[i])&lt;/code&gt;</source>
          <target state="translated">Рассмотрим все строки из второй таблицы рядом с ней: &lt;code&gt;(a, b[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87938a89e313e609e2777db1a5df0151577a103d" translate="yes" xml:space="preserve">
          <source>Consider below 2 tables:</source>
          <target state="translated">Рассмотрим 2 таблицы ниже:</target>
        </trans-unit>
        <trans-unit id="ce34c8c542402b0ee86027639be2b5d04f3c6b66" translate="yes" xml:space="preserve">
          <source>CustomerName</source>
          <target state="translated">CustomerName</target>
        </trans-unit>
        <trans-unit id="1c4705ae4081e199eef0ae21419928673a34f530" translate="yes" xml:space="preserve">
          <source>Does the join order matter in SQL?</source>
          <target state="translated">Имеет ли значение порядок соединения в SQL?</target>
        </trans-unit>
        <trans-unit id="ffc74ecd826f75ff4389d038f58a02a3e90a95ed" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;code&gt;ON ...&lt;/code&gt; clause against each pair: &lt;code&gt;ON( a, b[i] ) = true/false?&lt;/code&gt;</source>
          <target state="translated">Оцените предложение &lt;code&gt;ON ...&lt;/code&gt; для каждой пары: &lt;code&gt;ON( a, b[i] ) = true/false?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b345aed11cf2a02526a7d160db1c1112ab536293" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;code&gt;on&lt;/code&gt; clause against all rows from step 1 keeping those where the predicate evaluates to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Оцените предложение &lt;code&gt;on&lt;/code&gt; для всех строк, начиная с шага 1, сохраняя те, где предикат оценивается как &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="6c613ffe714b20b920d18cb37927e35e9165b59a" translate="yes" xml:space="preserve">
          <source>Executes faster.</source>
          <target state="translated">Выполняется быстрее.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="0d18db2aff4d65846fbea636403661ad3950fe12" translate="yes" xml:space="preserve">
          <source>Find out &lt;a href=&quot;https://stackoverflow.com/a/25957600/3404097&quot;&gt;what rows &lt;code&gt;inner join&lt;/code&gt; returns&lt;/a&gt;.</source>
          <target state="translated">Узнайте, &lt;a href=&quot;https://stackoverflow.com/a/25957600/3404097&quot;&gt;какие строки возвращает &lt;code&gt;inner join&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0abeed924e57f0cc2a06658f26cdea64ce7f03" translate="yes" xml:space="preserve">
          <source>Find out all employees and their department names:</source>
          <target state="translated">Узнайте всех сотрудников и названия их отделов:</target>
        </trans-unit>
        <trans-unit id="c04b36ffbc005e1021ab6fe662d901b6f4a392c7" translate="yes" xml:space="preserve">
          <source>First start with a &lt;code&gt;CROSS JOIN&lt;/code&gt; (AKA Cartesian Product). This does not have an &lt;code&gt;ON&lt;/code&gt; clause and simply returns every combination of rows from the two tables.</source>
          <target state="translated">Сначала начните с &lt;code&gt;CROSS JOIN&lt;/code&gt; (AKA Cartesian Product). Это не имеет предложения &lt;code&gt;ON&lt;/code&gt; и просто возвращает каждую комбинацию строк из двух таблиц.</target>
        </trans-unit>
        <trans-unit id="d04fb52672a2a1c2f1ce96d71e2fce592689817c" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;SELECT&lt;/code&gt; subset of data &lt;code&gt;A&lt;/code&gt; :</source>
          <target state="translated">Для &lt;code&gt;SELECT&lt;/code&gt; подмножество данных &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="4ebfe80cebc7a6b6fc3d511e706dfce3960f083c" translate="yes" xml:space="preserve">
          <source>For instance, you have an Orders and an OrderDetails table. They are related by an &quot;OrderID&quot;.</source>
          <target state="translated">Например,у вас есть таблица OrderDetails и OrderDetails.Они связаны &quot;OrderID&quot;.</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">Полное внешнее присоединение</target>
        </trans-unit>
        <trans-unit id="8bfd54988f970615c4e74fce0600de184f98e299" translate="yes" xml:space="preserve">
          <source>Full Outer Join: Returns matched and &lt;strong&gt;unmatched records&lt;/strong&gt; from both tables with null for unmatched records from &lt;strong&gt;Both Tables&lt;/strong&gt;.</source>
          <target state="translated">Полное внешнее объединение: возвращает сопоставленные и &lt;strong&gt;несопоставленные записи&lt;/strong&gt; из обеих таблиц со значением NULL для несопоставленных записей из &lt;strong&gt;обеих таблиц&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1f3d31cd72b0a483838a8970f65c751f713013f5" translate="yes" xml:space="preserve">
          <source>Full outer joins combine the behaviour of left and right joins and preserve the non matching rows from both the left and the right tables.</source>
          <target state="translated">Полные внешние соединения сочетают в себе поведение левого и правого соединений и сохраняют несовпадающие ряды как с левого,так и с правого стола.</target>
        </trans-unit>
        <trans-unit id="6411570fcdc35dfc78de7f609c4b71ace43cae52" translate="yes" xml:space="preserve">
          <source>Generally it is a good practice to try to use &lt;code&gt;INNER JOIN&lt;/code&gt; instead of the different kind of joins. (Of course if it is possible considering the expected result set.)</source>
          <target state="translated">Как правило, рекомендуется использовать &lt;code&gt;INNER JOIN&lt;/code&gt; вместо разных видов соединений. (Конечно, если это возможно, учитывая ожидаемый набор результатов.)</target>
        </trans-unit>
        <trans-unit id="c35ab13a279d3d6a71addf0c0c926b9637452a9c" translate="yes" xml:space="preserve">
          <source>Having criticized the much-loved red-shaded Venn diagram, I thought it only fair to post my own attempt.</source>
          <target state="translated">Критикуя столь любимую красную диаграмму Венна,я подумал,что будет справедливо опубликовать мою собственную попытку.</target>
        </trans-unit>
        <trans-unit id="ad1124e76cf6f5218f0d3a45651d7babcd328eb7" translate="yes" xml:space="preserve">
          <source>Here , employees table is Master table , phone_numbers_employees is child table(it contains &lt;code&gt;emp_id&lt;/code&gt; as foreign key which connects &lt;code&gt;employee.id&lt;/code&gt; so its child table.)</source>
          <target state="translated">Здесь таблица employee - это &lt;code&gt;emp_id&lt;/code&gt; таблица, phone_numbers_employees - это дочерняя таблица (она содержит emp_id в качестве внешнего ключа, который соединяет &lt;code&gt;employee.id&lt;/code&gt; с его дочерней таблицей.)</target>
        </trans-unit>
        <trans-unit id="d9a94736cec341670bde435c21aedde70db93a5e" translate="yes" xml:space="preserve">
          <source>Here take only matching rows on primary key = foreign key as explained above.Here non matching rows on primary key = foreign key are skipped as result of join.</source>
          <target state="translated">Здесь берутся только совпадающие строки на первичном ключе=посторонний ключ,как объяснялось выше.Здесь не совпадающие строки на первичном ключе=посторонний ключ пропускаются в результате соединения.</target>
        </trans-unit>
        <trans-unit id="c9ed6f85d1a101c06aa6f1658ea9aa6b59660e48" translate="yes" xml:space="preserve">
          <source>I don't see much details about performance and optimizer in the other answers.</source>
          <target state="translated">Я не вижу много подробностей о производительности и оптимизаторе в других ответах.</target>
        </trans-unit>
        <trans-unit id="93a0642b23a99dec05f5e26b605d8eef3a7f0c33" translate="yes" xml:space="preserve">
          <source>I'll start off with an animated version of a &lt;strong&gt;full outer join&lt;/strong&gt;. Further explanation follows.</source>
          <target state="translated">Я начну с анимированной версии &lt;strong&gt;полного внешнего соединения&lt;/strong&gt; . Дальнейшее объяснение следует.</target>
        </trans-unit>
        <trans-unit id="1a2726acbd71bf2259089b5a4a5c3ec69bf22762" translate="yes" xml:space="preserve">
          <source>If the intention was to include only rows from B where Colour is Green and all rows from A regardless the correct syntax would be</source>
          <target state="translated">Если бы намерение заключалось в том,чтобы включить только строки из B,где цвет зеленый,и все строки из A,независимо от правильного синтаксиса,было бы следующим</target>
        </trans-unit>
        <trans-unit id="3c1266feff7c44326ee6d344d966bdb79fe985b5" translate="yes" xml:space="preserve">
          <source>If you change it to OUTER LEFT JOIN</source>
          <target state="translated">Если вы поменяете его на ВЛЕВОЕ ЛЕВОЕ СОВМЕСТНОЕ.</target>
        </trans-unit>
        <trans-unit id="21db8be499d2d750d835639da29f05c3d94c9e45" translate="yes" xml:space="preserve">
          <source>Image Source</source>
          <target state="translated">Источник изображения</target>
        </trans-unit>
        <trans-unit id="fbad4385f9cf327937fb57784e13cacc32509589" translate="yes" xml:space="preserve">
          <source>Imagine a cross join.</source>
          <target state="translated">Представь себе крестовое соединение.</target>
        </trans-unit>
        <trans-unit id="b8bd227340485f216d9f687d400cc002452fbcb2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SQLite&lt;/code&gt; there is no &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; or &lt;code&gt;FULL OUTER JOIN&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;SQLite&lt;/code&gt; нет &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; или &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f7efb00c93f4548f598f16f503c32e704bad44e" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;&lt;code&gt;OUTER JOIN&lt;/code&gt;&lt;/strong&gt; the resulting table may have empty columns. Outer join may be either &lt;code&gt;LEFT&lt;/code&gt; or &lt;code&gt;RIGHT&lt;/code&gt;.</source>
          <target state="translated">В &lt;strong&gt; &lt;code&gt;OUTER JOIN&lt;/code&gt; &lt;/strong&gt; результирующая таблица может иметь пустые столбцы. Внешнее соединение может быть как &lt;code&gt;LEFT&lt;/code&gt; и &lt;code&gt;RIGHT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6941fa11ca0dac876d7571fc193479465f3b02cb" translate="yes" xml:space="preserve">
          <source>In Simple Terms,</source>
          <target state="translated">Простыми словами,</target>
        </trans-unit>
        <trans-unit id="6311bfbab6f0ce905c898d3037a4bffed4c85f98" translate="yes" xml:space="preserve">
          <source>In simple words :</source>
          <target state="translated">Простыми словами :</target>
        </trans-unit>
        <trans-unit id="d0c84010367b3b1669cacd2b79cfdd7e88cb34e5" translate="yes" xml:space="preserve">
          <source>In simple words:</source>
          <target state="translated">Простыми словами:</target>
        </trans-unit>
        <trans-unit id="cc229704b94d0147c90b5d7ff85d17d93957823a" translate="yes" xml:space="preserve">
          <source>In-Short</source>
          <target state="translated">In-Short</target>
        </trans-unit>
        <trans-unit id="bba8637f720ddb113daf64553a3dfa902c8fd82c" translate="yes" xml:space="preserve">
          <source>Inner Join</source>
          <target state="translated">Внутреннее присоединение</target>
        </trans-unit>
        <trans-unit id="ed0f4dc8bd3c86cc0d852fa3661f82aa25d1b977" translate="yes" xml:space="preserve">
          <source>Inner Join:</source>
          <target state="translated">Внутреннее Присоединение:</target>
        </trans-unit>
        <trans-unit id="c8d9dc73c8c1abcee44bb2201d574c5bdd397e3e" translate="yes" xml:space="preserve">
          <source>Inner Join: Returns &lt;strong&gt;matched records&lt;/strong&gt; from both tables.</source>
          <target state="translated">Внутреннее объединение: возвращает &lt;strong&gt;сопоставленные записи&lt;/strong&gt; из обеих таблиц.</target>
        </trans-unit>
        <trans-unit id="6fb89a7e2ab0c42a98e269eb6b45b2b2eacdcbc9" translate="yes" xml:space="preserve">
          <source>Inner and Outer joins have an &quot;ON&quot; clause predicate.</source>
          <target state="translated">Внутренние и внешние соединения имеют предикат &quot;ON&quot;.</target>
        </trans-unit>
        <trans-unit id="77b537fc04c2b26903dc8f8d71874daad50156d7" translate="yes" xml:space="preserve">
          <source>Inner joins require that a record with a related ID exist in the joined table.</source>
          <target state="translated">Внутренние соединения требуют наличия записи с соответствующим удостоверением личности в объединенной таблице.</target>
        </trans-unit>
        <trans-unit id="7906e78bd761931c9fb5f6257964f6a06bc48099" translate="yes" xml:space="preserve">
          <source>It is important to select a column for the &lt;code&gt;IS NULL&lt;/code&gt; test that is either not nullable or for which the join condition ensures that any &lt;code&gt;NULL&lt;/code&gt; values will be excluded in order for this pattern to work correctly and avoid just bringing back rows which happen to have a &lt;code&gt;NULL&lt;/code&gt; value for that column in addition to the un matched rows.</source>
          <target state="translated">Важно выбрать столбец для теста &lt;code&gt;IS NULL&lt;/code&gt; , который либо не имеет значения NULL, либо для которого условие соединения гарантирует, что любые значения &lt;code&gt;NULL&lt;/code&gt; будут исключены, чтобы этот шаблон работал правильно и избегал простого возврата строк, которые имеют Значение &lt;code&gt;NULL&lt;/code&gt; для этого столбца в дополнение к несоответствующим строкам.</target>
        </trans-unit>
        <trans-unit id="32dae4a14c63f3d06ed14d7e06f8063fb67939e2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN :</source>
          <target state="translated">ЛЕВОЕ ПОЛОЖЕНИЕ :</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">Левый Внешнее Присоединение</target>
        </trans-unit>
        <trans-unit id="c09c3a8fecce7bef7fd45a493d0eb3a5dfd61aa8" translate="yes" xml:space="preserve">
          <source>Left Outer Join: Returns matched and unmatched records only from table on &lt;strong&gt;Left Side&lt;/strong&gt;.</source>
          <target state="translated">Левое внешнее объединение: возвращает сопоставленные и несопоставленные записи только из таблицы на &lt;strong&gt;левой стороне&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f33f2f8f6fa36a7f3549da9ace0c8c90f873b4" translate="yes" xml:space="preserve">
          <source>Left join retains all rows of the left table, regardless of whether there is a row that matches on the right table.</source>
          <target state="translated">Левое соединение сохраняет все строки левой таблицы,независимо от того,есть ли строка,которая совпадает с правой таблицей.</target>
        </trans-unit>
        <trans-unit id="9dbc826be2a4c87bb15c6e10de01cb1bee8c720e" translate="yes" xml:space="preserve">
          <source>Lets assume now for 2 tables</source>
          <target state="translated">Предположим теперь для 2 таблиц</target>
        </trans-unit>
        <trans-unit id="578fd28e6e1d6a67881c636cc195809940352310" translate="yes" xml:space="preserve">
          <source>Matched + Left Unmatched + Right Unmatched = &lt;strong&gt;Full Outer Join&lt;/strong&gt;</source>
          <target state="translated">Совпадение + Совпадение влево + Совпадение влево = &lt;strong&gt;Полное внешнее соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20bef8251179ea981ce069bda2d4439c0f906f" translate="yes" xml:space="preserve">
          <source>Matched + Left Unmatched = &lt;strong&gt;Left Outer Join&lt;/strong&gt;</source>
          <target state="translated">Совпадение + Левое Несоответствие = &lt;strong&gt;Левое внешнее соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c20debdcc383531af756af04ac1fb6109eb4e555" translate="yes" xml:space="preserve">
          <source>Matched + Right Unmatched = &lt;strong&gt;Right Outer Join&lt;/strong&gt;</source>
          <target state="translated">Совпадение + Право Несоответствие = &lt;strong&gt;Право Внешнее Соединение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9fafd10f773407a30cbe2d499509f0299ce7bfc" translate="yes" xml:space="preserve">
          <source>Matched = &lt;strong&gt;Inner Join&lt;/strong&gt;</source>
          <target state="translated">Matched = &lt;strong&gt;Inner Join&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d284e943eb5fd0ca9657db2a82c58fac67bf1873" translate="yes" xml:space="preserve">
          <source>Mostly written as just &lt;strong&gt;JOIN&lt;/strong&gt; in sql queries. It returns only the matching records between the tables.</source>
          <target state="translated">В основном написано как просто &lt;strong&gt;JOIN&lt;/strong&gt; в SQL-запросах. Он возвращает только совпадающие записи между таблицами.</target>
        </trans-unit>
        <trans-unit id="5f4dedd74eef4176dfbffe6c9b0db73766112c08" translate="yes" xml:space="preserve">
          <source>My answer is based on above &lt;strong&gt;Note&lt;/strong&gt;.</source>
          <target state="translated">Мой ответ основан на вышеупомянутом &lt;strong&gt;примечании&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c82465200a850a68b9a9fa6bf4458ac4b0c2b1a4" translate="yes" xml:space="preserve">
          <source>MySQL 8.0 Reference Manual - Join Syntax</source>
          <target state="translated">Справочное руководство MySQL 8.0-Присоединиться к синтаксису</target>
        </trans-unit>
        <trans-unit id="eb174e6490ec349d4e09b4ea83a4a1ae58fa3462" translate="yes" xml:space="preserve">
          <source>No rows in the cross join match the &lt;code&gt;1=0&lt;/code&gt; predicate. All rows from both sides are preserved using normal outer join rules with NULL in the columns from the table on the other side.</source>
          <target state="translated">Строки в перекрестном соединении не соответствуют предикату &lt;code&gt;1=0&lt;/code&gt; . Все строки с обеих сторон сохраняются с использованием обычных правил внешнего соединения с NULL в столбцах таблицы на другой стороне.</target>
        </trans-unit>
        <trans-unit id="bcaa9ca6043506ea398e74cca18358fea5a27d5f" translate="yes" xml:space="preserve">
          <source>Note that (1,2) are unique to A, (3,4) are common, and (5,6) are unique to B.</source>
          <target state="translated">Обратите внимание,что (1,2)относятся только к A,(3,4)-к обычным и (5,6)-к B.</target>
        </trans-unit>
        <trans-unit id="00a595b79688b3007bb9e1b68113f2cda5be3ae8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;WHERE&lt;/code&gt; clause (if present) logically runs after the join. One common error is to perform a left outer join and then include a WHERE clause with a condition on the right table that ends up excluding the non matching rows. The above ends up performing the outer join...</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;WHERE&lt;/code&gt; (если присутствует) логически выполняется после объединения. Одной из распространенных ошибок является выполнение левого внешнего соединения, а затем включение предложения WHERE с условием в правой таблице, которое заканчивается исключением несовпадающих строк. Вышеуказанное завершает выполнение внешнего соединения ...</target>
        </trans-unit>
        <trans-unit id="ff243e42183d396280041ad79ffd12833666d910" translate="yes" xml:space="preserve">
          <source>Now, here is what the result of running that SQL would look like:</source>
          <target state="translated">Вот как будет выглядеть результат запуска этого SQL:</target>
        </trans-unit>
        <trans-unit id="e9ec314891f9b0553314cd5bc1b5e24e1fe7c6da" translate="yes" xml:space="preserve">
          <source>Now, here is what the result of running this SQL would look like:</source>
          <target state="translated">Вот как будет выглядеть результат работы этого SQL:</target>
        </trans-unit>
        <trans-unit id="9366d103fdeaf5a08a3a6b1811e27d78ba2778f6" translate="yes" xml:space="preserve">
          <source>Oracle Join operations</source>
          <target state="translated">Операции Oracle Join</target>
        </trans-unit>
        <trans-unit id="be3fad5644c3cf6262a563f0de6e2fd0998e0bf4" translate="yes" xml:space="preserve">
          <source>OrderDetailID</source>
          <target state="translated">OrderDetailID</target>
        </trans-unit>
        <trans-unit id="600d24f7e0ef1f0898681fc504290cf14d4691a6" translate="yes" xml:space="preserve">
          <source>OrderID</source>
          <target state="translated">OrderID</target>
        </trans-unit>
        <trans-unit id="2e70245241891498db6cad7dc05212a83490cd0c" translate="yes" xml:space="preserve">
          <source>Outer Joins are logically evaluated in the same way as inner joins except that if a row from the left table (for a left join) does not join with any rows from the right hand table at all it is preserved in the result with &lt;code&gt;NULL&lt;/code&gt; values for the right hand columns.</source>
          <target state="translated">Внешние объединения логически оцениваются так же, как и внутренние, за исключением того, что если строка из левой таблицы (для левого объединения) вообще не объединяется ни с одной строкой из правой таблицы, она сохраняется в результате со значениями &lt;code&gt;NULL&lt;/code&gt; для правые столбцы.</target>
        </trans-unit>
        <trans-unit id="374a336c7ea96113def3455829073de0d8f46525" translate="yes" xml:space="preserve">
          <source>Outer joins will return records for the left side even if nothing exists for the right side.</source>
          <target state="translated">Внешние соединения будут возвращать записи для левой стороны,даже если ничего не существует для правой стороны.</target>
        </trans-unit>
        <trans-unit id="3e8248e32edfca0c629622b5b669c2d9ce4d0917" translate="yes" xml:space="preserve">
          <source>Price</source>
          <target state="translated">Price</target>
        </trans-unit>
        <trans-unit id="9d714af1e46e653abb32c81ac42098c25716dbb7" translate="yes" xml:space="preserve">
          <source>ProductName</source>
          <target state="translated">ProductName</target>
        </trans-unit>
        <trans-unit id="1e5ff9e500c20c682a037a3a5ced18064af0eb10" translate="yes" xml:space="preserve">
          <source>Qty</source>
          <target state="translated">Qty</target>
        </trans-unit>
        <trans-unit id="3d950760191e5c17a275c5f55c604e9d52587f97" translate="yes" xml:space="preserve">
          <source>Read my comments there re the many confused &amp;amp; poor answers.</source>
          <target state="translated">Прочитайте мои комментарии, есть много запутанных и плохих ответов.</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="9b967f2ec09466f8f2f31858c86038b4b048485c" translate="yes" xml:space="preserve">
          <source>Retrieve the matched rows only, that is, &lt;code&gt;A intersect B&lt;/code&gt;.</source>
          <target state="translated">Получить только совпадающие строки, то есть &lt;code&gt;A intersect B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e5114e7789afff7440d75b6a1d33089a6df9df5" translate="yes" xml:space="preserve">
          <source>Right Outer Join: Returns matched and unmatched records only from table on &lt;strong&gt;Right Side&lt;/strong&gt;.</source>
          <target state="translated">Правое внешнее соединение: возвращает сопоставленные и несопоставленные записи только из таблицы на &lt;strong&gt;правой стороне&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b2e93b13ae89bdfe2c003685bed4107494b5cb" translate="yes" xml:space="preserve">
          <source>Right outer joins act similarly to left outer joins except they preserve non matching rows from the right table and null extend the left hand columns.</source>
          <target state="translated">Правые внешние соединения действуют аналогично левым внешним соединениям,за исключением того,что они сохраняют несовпадающие строки из правого стола и ноль выдвигают левые столбцы.</target>
        </trans-unit>
        <trans-unit id="2d647db3858ef9c4d4d1b07f011053df11bd1945" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON 1 = 0</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от Полного Входа B ON 1=0</target>
        </trans-unit>
        <trans-unit id="cffe4cf34880ac4d7c295b1e0bb80d168c5a44b3" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON A.Colour = B.Colour</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от Полного Входа B в А.Цвет=В.Цвет</target>
        </trans-unit>
        <trans-unit id="a13e1649aecd1206886059ae14fe7460d24e59da" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour NOT IN ('Green','Blue')</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от А.ИННЕР СОЕДИНЕНИЯ Б.НА А.Цвет НЕ ВКЛЮЧЕН (&quot;Зеленый&quot;,&quot;Синий&quot;)</target>
        </trans-unit>
        <trans-unit id="d2cd6e1ff7e5116f1a0d5f916881f85f01fd615d" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от ВЛЕВОГО СОЕДИНЕНИЯ В ВКЛЮЧЕНИИ А.Цвет=В.Цвет</target>
        </trans-unit>
        <trans-unit id="3d50844979aa339cbf4da331b98c0e640c6bf0ae" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour AND B.Colour = 'Green'</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от ВЛЕВОГО СОЕДИНЕНИЯ В ВРЕМЕНИ ВКЛЮЧЕНИЯ А.Цвет=В.Цвет и В.Цвет='Зеленый'.</target>
        </trans-unit>
        <trans-unit id="e633ac81baec5d384e3e8d94d681236716f1e6c6" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour = 'Green'</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от ВЛЕВОГО ВЫБОРА В ВЫБОРЕ ВКЛЮЧЕНИЯ А.Цвет=В.Цвет Где В.Цвет='Зеленый'.</target>
        </trans-unit>
        <trans-unit id="91da65b210c38782502b7d13c2e096db98c58b26" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour IS NULL</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет от ВЛЕВОГО СОЕДИНЕНИЯ В ВРЕМЕНИ ВКЛЮЧАЯ А.Цвет=В.Цвет,Где В.Цвет-НОЛЬШЕЕ</target>
        </trans-unit>
        <trans-unit id="57e07cbef7e5897d683d06b9dfb9f60c984010ba" translate="yes" xml:space="preserve">
          <source>SELECT A.Colour, B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour = B.Colour</source>
          <target state="translated">ВЫБЕРИТЕ А.Цвет,В.Цвет с правого входа B в A.Цвет=В.Цвет</target>
        </trans-unit>
        <trans-unit id="b0f89b495d78151b223b2078359fd381d2b48a8e" translate="yes" xml:space="preserve">
          <source>SELECT COALESCE(A.Colour, B.Colour) AS Colour FROM A FULL OUTER JOIN B ON 1 = 0</source>
          <target state="translated">ВЫБЕРИТЕ COALESCE(A.Colour,B.Colour)КАК ЦВЕТ ОТ ПОЛНОГО СОЕДИНЕНИЯ В ВКЛЮЧЕНИЯ 1=0</target>
        </trans-unit>
        <trans-unit id="36a563f27a865c596b19c7761ec4e2b026984fa2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle</source>
          <target state="translated">SQL-скрипка</target>
        </trans-unit>
        <trans-unit id="cb0c31314f39e52437b28c02774906a7a30dc42a" translate="yes" xml:space="preserve">
          <source>See these examples &lt;a href=&quot;http://sqlfiddle.com/#!17/10d3d/29&quot;&gt;run live at SQLFiddle.com&lt;/a&gt;.</source>
          <target state="translated">Посмотрите эти примеры в &lt;a href=&quot;http://sqlfiddle.com/#!17/10d3d/29&quot;&gt;прямом эфире на SQLFiddle.com&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81da6fdad0f70842b42941ca24fc8c73293c8dfc" translate="yes" xml:space="preserve">
          <source>Select all records from the first table, and any records in the second
table that match the joined keys.</source>
          <target state="translated">Выберите все записи из первой таблицы,а также все записи во второй таблице,которые соответствуют объединенным клавишам.</target>
        </trans-unit>
        <trans-unit id="e3ea1a9c1530e2a17b4ec25fc48ebecfd8bda4e9" translate="yes" xml:space="preserve">
          <source>Select all records from the second table, and any records in the first
table that match the joined keys.</source>
          <target state="translated">Выберите все записи из второй таблицы,а также все записи в первой таблице,которые соответствуют объединенным клавишам.</target>
        </trans-unit>
        <trans-unit id="83bef2cc7071931413ea6c15b1d9cbb261201667" translate="yes" xml:space="preserve">
          <source>Self join is not a keyword in SQL, when a table references data in itself knows as self join. Using &lt;code&gt;INNER JOIN&lt;/code&gt; and &lt;code&gt;OUTER JOIN&lt;/code&gt; we can write self join queries.</source>
          <target state="translated">Самостоятельное объединение не является ключевым словом в SQL, когда таблица ссылается на данные, которые сами по себе называются самостоятельным объединением. Используя &lt;code&gt;INNER JOIN&lt;/code&gt; и &lt;code&gt;OUTER JOIN&lt;/code&gt; , мы можем написать запросы на самостоятельное соединение.</target>
        </trans-unit>
        <trans-unit id="60c27c12ebbc9b0ccdc95adc44b3d6bd42e22ebf" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; and &lt;code&gt;RIGHT JOIN&lt;/code&gt; are the same. It gives all the records matching in both tables and all possibilities of the right table.</source>
          <target state="translated">Аналогично, &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; и &lt;code&gt;RIGHT JOIN&lt;/code&gt; одинаковы. Это дает все записи, совпадающие в обеих таблицах и все возможности правой таблицы.</target>
        </trans-unit>
        <trans-unit id="57ac164b04deda9400c97a3c178bcd37f4674dcb" translate="yes" xml:space="preserve">
          <source>So don't &lt;code&gt;outer join&lt;/code&gt; until you know what underlying &lt;code&gt;inner join&lt;/code&gt; is involved.</source>
          <target state="translated">Так что не используйте &lt;code&gt;outer join&lt;/code&gt; пока не узнаете, какое &lt;code&gt;inner join&lt;/code&gt; включено</target>
        </trans-unit>
        <trans-unit id="0239c43496556d996a3ba690826274b35b6de6d6" translate="yes" xml:space="preserve">
          <source>So query would be :</source>
          <target state="translated">Таким образом,запрос был бы :</target>
        </trans-unit>
        <trans-unit id="3a3ef6bdf78356dcb2d8fdf53815126df565e89a" translate="yes" xml:space="preserve">
          <source>So, if you observe the above output, all records from the LEFT table(Emp) are printed with just matching records from RIGHT table.</source>
          <target state="translated">Таким образом,если вы заметите вышеприведенный вывод,то все записи из левой таблицы (Emp)будут распечатаны только с совпадающими записями из правой таблицы.</target>
        </trans-unit>
        <trans-unit id="76b15ddd9bbae2a42a5c96bc2b644d8162ba90e8" translate="yes" xml:space="preserve">
          <source>Some examples</source>
          <target state="translated">Некоторые примеры</target>
        </trans-unit>
        <trans-unit id="c4103bb3eb14901657b76f7f1899071323e5c8cd" translate="yes" xml:space="preserve">
          <source>Sometimes it is good to know that only &lt;code&gt;INNER JOIN&lt;/code&gt; is associative which means the optimizer has the most option to play with it. It can reorder the join order to make it faster keeping the same result. The optimizer can use the most join modes.</source>
          <target state="translated">Иногда полезно знать, что только &lt;code&gt;INNER JOIN&lt;/code&gt; является ассоциативным, что означает, что оптимизатор имеет больше возможностей для игры с ним. Он может изменить порядок соединения, чтобы сделать его быстрее, сохраняя тот же результат. Оптимизатор может использовать большинство режимов соединения.</target>
        </trans-unit>
        <trans-unit id="0e94545c59dedc53631e5bf2ea94d07c746c3449" translate="yes" xml:space="preserve">
          <source>Suppose you have two tables, with a single column each, and data as follows:</source>
          <target state="translated">Предположим,что у вас есть две таблицы,каждая из которых содержит по одному столбцу,и данные,приведенные ниже:</target>
        </trans-unit>
        <trans-unit id="de05dbfa8bc8b8c89765a1580a72f8d1c53fb687" translate="yes" xml:space="preserve">
          <source>Take each row from the first table: &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Возьмите каждый ряд из первой таблицы:</target>
        </trans-unit>
        <trans-unit id="c7584fafc4a976a172f0acb728079de626672216" translate="yes" xml:space="preserve">
          <source>Take the records of 2 tables &lt;strong&gt;ONLY IF Primary key of employees table(its id) matches Foreign key of Child table phone_numbers_employees(emp_id)&lt;/strong&gt;.</source>
          <target state="translated">Принимайте записи только из 2 таблиц, &lt;strong&gt;ЕСЛИ если первичный ключ таблицы сотрудников (его идентификатор) совпадает с внешним ключом дочерней таблицы phone_numbers_employees (emp_id)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b4635a4d9810c755b0fd7ff98effc1f6343585e2" translate="yes" xml:space="preserve">
          <source>The Venn diagrams don't really do it for me.</source>
          <target state="translated">Диаграммы Венна на самом деле не делают этого за меня.</target>
        </trans-unit>
        <trans-unit id="a3aad5f7e1572efc104d477450c7cebb3c86f8cb" translate="yes" xml:space="preserve">
          <source>The above is the classic equi join.</source>
          <target state="translated">Вышеуказанное является классическим соединением оборудования.</target>
        </trans-unit>
        <trans-unit id="a62f9f75abe497935bbf828702110bb6f41bfa79" translate="yes" xml:space="preserve">
          <source>The answer is in the meaning of each one, so in the results.</source>
          <target state="translated">Ответ заключается в значении каждого из них,а значит,и в результатах.</target>
        </trans-unit>
        <trans-unit id="53e041ad0fed92c13129a9acd829713901739e00" translate="yes" xml:space="preserve">
          <source>The best I could do in the half hour allowed, I still don't think it adequately shows that the nulls are there due to absence of key values in &lt;code&gt;TableB&lt;/code&gt; or that &lt;code&gt;OUTER JOIN&lt;/code&gt; is actually a union rather than a join:</source>
          <target state="translated">Лучшее, что я мог сделать за полчаса, я все еще не думаю, что это адекватно показывает, что &lt;code&gt;TableB&lt;/code&gt; значения присутствуют из-за отсутствия значений ключа в TableB или что &lt;code&gt;OUTER JOIN&lt;/code&gt; на самом деле является объединением, а не объединением:</target>
        </trans-unit>
        <trans-unit id="8f57c73279bb55888b448c5bdc495a588748d6b2" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;inner join&lt;/code&gt; and &lt;code&gt;outer join&lt;/code&gt; is as follow:</source>
          <target state="translated">Разница между &lt;code&gt;inner join&lt;/code&gt; и &lt;code&gt;outer join&lt;/code&gt; заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="ed26590cf87cb3aeae866c1693da02c71887e0fb" translate="yes" xml:space="preserve">
          <source>The inner join condition need not necessarily be an equality condition and it need not reference columns from both (or even either) of the tables. Evaluating &lt;code&gt;A.Colour NOT IN ('Green','Blue')&lt;/code&gt; on each row of the cross join returns.</source>
          <target state="translated">Условие внутреннего соединения не обязательно должно быть условием равенства и не должно ссылаться на столбцы обеих (или даже обеих) таблиц. Оценка &lt;code&gt;A.Colour NOT IN ('Green','Blue')&lt;/code&gt; в каждой строке результатов перекрестного соединения.</target>
        </trans-unit>
        <trans-unit id="aba4f065d0bc304f4809963eab26bdfc99462dc8" translate="yes" xml:space="preserve">
          <source>The join condition evaluates to true for all rows in the cross join result so this is just the same as a cross join. I won't repeat the picture of the 16 rows again.</source>
          <target state="translated">Условие соединения оценивается как истинное для всех строк в результате перекрестного соединения,так что это то же самое,что и перекрестное соединение.Я больше не буду повторять картину 16 рядов.</target>
        </trans-unit>
        <trans-unit id="a9c0f0067130afe8f022fb90a699f83ed307fb70" translate="yes" xml:space="preserve">
          <source>The precise algorithm for &lt;code&gt;INNER JOIN&lt;/code&gt;, &lt;code&gt;LEFT/RIGHT OUTER JOIN&lt;/code&gt; are as following:</source>
          <target state="translated">Точный алгоритм для &lt;code&gt;INNER JOIN&lt;/code&gt; , &lt;code&gt;LEFT/RIGHT OUTER JOIN&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="0314c4ea7fe190fc4c68769257de2b532365173a" translate="yes" xml:space="preserve">
          <source>The request</source>
          <target state="translated">Просьба</target>
        </trans-unit>
        <trans-unit id="064e12516d680c606b9271f08193451a42062386" translate="yes" xml:space="preserve">
          <source>Then read my comments here re the many confused &amp;amp; poor answers.</source>
          <target state="translated">Тогда прочитайте мои комментарии, здесь вы найдете много запутанных и плохих ответов.</target>
        </trans-unit>
        <trans-unit id="f62ba35f901272384724079d8d9a702d631b36d7" translate="yes" xml:space="preserve">
          <source>There are a couple of good examples and explanation here about this strange associative behavior:</source>
          <target state="translated">Здесь есть пара хороших примеров и объяснений по поводу этого странного ассоциативного поведения:</target>
        </trans-unit>
        <trans-unit id="af79f3a932c5ca416034380e0e3c369717bfeaac" translate="yes" xml:space="preserve">
          <source>There is a lot of good answers here with very accurate &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_algebra&quot;&gt;relational algebra&lt;/a&gt; examples.  Here is a very simplified answer that might be helpful for amateur or novice coders with SQL coding dilemmas.</source>
          <target state="translated">Здесь есть много хороших ответов с очень точными примерами &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_algebra&quot;&gt;реляционной алгебры&lt;/a&gt; . Вот очень упрощенный ответ, который может быть полезен для начинающих или начинающих программистов с дилеммами кодирования SQL.</target>
        </trans-unit>
        <trans-unit id="f100303a3639513408be4936a4e6cc7b73841467" translate="yes" xml:space="preserve">
          <source>There is no substitute for understanding the logical processing and it is relatively straightforward to grasp anyway.</source>
          <target state="translated">Нет замены пониманию логической обработки и в любом случае она относительно проста в понимании.</target>
        </trans-unit>
        <trans-unit id="4778ef7c4e1aa99d9d2b5ca9f2c5fa43583d69e7" translate="yes" xml:space="preserve">
          <source>They don't show any distinction between a cross join and an inner join, for example, or more generally show any distinction between different types of join predicate or provide a framework for reasoning about how they will operate.</source>
          <target state="translated">Например,они не показывают различия между крестообразным соединением и внутренним соединением,или,в более общем плане,не показывают различия между предикатами различных типов соединений,или не дают основу для рассуждений о том,как они будут работать.</target>
        </trans-unit>
        <trans-unit id="40a9fbf518ad99d3cf9f2c242dcb7e9ac085afa8" translate="yes" xml:space="preserve">
          <source>This is a good diagrammatic explanation for all kind of joins</source>
          <target state="translated">Это хорошее диаграммное объяснение для всех видов соединений.</target>
        </trans-unit>
        <trans-unit id="25f3df9908570659057e2e6550d4475345358f41" translate="yes" xml:space="preserve">
          <source>This returns all records from the LEFT table and only matching records from the RIGHT table.</source>
          <target state="translated">При этом возвращаются все записи из левой таблицы и только совпадающие записи из правой таблицы.</target>
        </trans-unit>
        <trans-unit id="c7802fed33f09212b06fd43e902012710d8a18e0" translate="yes" xml:space="preserve">
          <source>This simply restricts the previous result to only return the rows where &lt;code&gt;B.Colour IS NULL&lt;/code&gt;. In this particular case these will be the rows that were preserved as they had no match in the right hand table and the query returns the single red row not matched in table &lt;code&gt;B&lt;/code&gt;. This is known as an anti semi join.</source>
          <target state="translated">Это просто ограничивает предыдущий результат, возвращая только те строки, где &lt;code&gt;B.Colour IS NULL&lt;/code&gt; . В этом конкретном случае это будут строки, которые были сохранены, так как они не совпадали в правой таблице, и запрос возвращает одну красную строку, не совпадающую в таблице &lt;code&gt;B&lt;/code&gt; . Это известно как анти-полусоединение.</target>
        </trans-unit>
        <trans-unit id="4f72fe6a93efa48588b234ba7af91ed270f584fc" translate="yes" xml:space="preserve">
          <source>Using the tables above, we can show what the result set of a right outer join would look like:</source>
          <target state="translated">Используя таблицы выше,мы можем показать,как будет выглядеть результирующий набор правого внешнего соединения:</target>
        </trans-unit>
        <trans-unit id="969d0130ea0f101d149be9545807c1567f0450e7" translate="yes" xml:space="preserve">
          <source>Well, as your need you choose each one that covers your need ;).</source>
          <target state="translated">Ну,как ваша потребность,вы выбираете каждую,которая покрывает вашу потребность ;).</target>
        </trans-unit>
        <trans-unit id="cae8dd96eef584302609a4891c208f2d7b1b56b2" translate="yes" xml:space="preserve">
          <source>What is the difference between “INNER JOIN” and “OUTER JOIN”</source>
          <target state="translated">В чем разница между &quot;ИННЕР ДжОУН&quot; и &quot;ВЧЕРНЕЙ ДжОУН&quot;?</target>
        </trans-unit>
        <trans-unit id="f44fca4ef831061b239894e4f22ea16c7b039773" translate="yes" xml:space="preserve">
          <source>When reach end of second table without any match, and this is an &lt;code&gt;Outer Join&lt;/code&gt; then return a &lt;em&gt;(virtual)&lt;/em&gt; pair using &lt;code&gt;Null&lt;/code&gt; for all columns of other table: &lt;code&gt;(a, Null)&lt;/code&gt; for LEFT outer join or &lt;code&gt;(Null, b)&lt;/code&gt; for RIGHT outer join. This is to ensure all rows of first table exists in final results.</source>
          <target state="translated">Когда достигните конца второй таблицы без какого-либо соответствия, и это будет &lt;code&gt;Outer Join&lt;/code&gt; тогда верните &lt;em&gt;(виртуальную)&lt;/em&gt; пару, используя &lt;code&gt;Null&lt;/code&gt; для всех столбцов другой таблицы: &lt;code&gt;(a, Null)&lt;/code&gt; для LEFT внешнего соединения или &lt;code&gt;(Null, b)&lt;/code&gt; для RIGHT внешнего присоединиться. Это должно гарантировать, что все строки первой таблицы существуют в конечных результатах.</target>
        </trans-unit>
        <trans-unit id="46458bcc7be2a6b261798740e5797f2c8e93b556" translate="yes" xml:space="preserve">
          <source>When the condition evaluates to &lt;code&gt;true&lt;/code&gt;, return that combined row  &lt;code&gt;(a, b[i])&lt;/code&gt;.</source>
          <target state="translated">Когда условие оценивается как &lt;code&gt;true&lt;/code&gt; , вернуть эту объединенную строку &lt;code&gt;(a, b[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df555849cc57a15bca36da039957eadcb8a031d0" translate="yes" xml:space="preserve">
          <source>When you also want to have all rows of the other table in your results you can use &lt;code&gt;FULL OUTER JOIN&lt;/code&gt;:</source>
          <target state="translated">Если вы также хотите, чтобы в ваших результатах были все строки другой таблицы, вы можете использовать &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58ddb44eac8d428658fec23c0581d51e800d0a93" translate="yes" xml:space="preserve">
          <source>When you have two tables like these:</source>
          <target state="translated">Когда у тебя два таких стола:</target>
        </trans-unit>
        <trans-unit id="651af2720bbc0bab41adea2fe618e68198a14b43" translate="yes" xml:space="preserve">
          <source>When you want to add a filter to above results based on a relation like &lt;code&gt;table1.id = table2.id&lt;/code&gt; you can use &lt;code&gt;INNER JOIN&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите добавить фильтр к вышеуказанным результатам на основе отношения, например &lt;code&gt;table1.id = table2.id&lt;/code&gt; вы можете использовать &lt;code&gt;INNER JOIN&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e9e497bd07b3a1960453e175763a1967b5d25a53" translate="yes" xml:space="preserve">
          <source>When you want to have all rows of one of tables in the above result -with same relation- you can use &lt;code&gt;LEFT JOIN&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите, чтобы все строки одной из таблиц в приведенном выше результате - с одинаковым отношением - вы можете использовать &lt;code&gt;LEFT JOIN&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6205d6e4d1ba0218809cb322a5a7c0c8cdf2d674" translate="yes" xml:space="preserve">
          <source>Whereas an &lt;strong&gt;outer join&lt;/strong&gt; retrieve the matched rows from one table and all rows in other table ....the result depends on which one you are using:</source>
          <target state="translated">Принимая во внимание, что &lt;strong&gt;внешнее соединение&lt;/strong&gt; извлекает сопоставленные строки из одной таблицы и все строки в другой таблице .... результат зависит от того, какую из них вы используете:</target>
        </trans-unit>
        <trans-unit id="7e8b4ad0f1c4accc3a0d63224ebf61ad7dc8a31d" translate="yes" xml:space="preserve">
          <source>With a minor amend to the preceding query one could simulate a &lt;code&gt;UNION ALL&lt;/code&gt; of the two tables.</source>
          <target state="translated">С небольшой поправкой к предыдущему запросу можно смоделировать &lt;code&gt;UNION ALL&lt;/code&gt; из двух таблиц.</target>
        </trans-unit>
        <trans-unit id="bd76f278a4af35c691d8b2e27d68be6abc166d6f" translate="yes" xml:space="preserve">
          <source>You can have all of those tables data with &lt;code&gt;CROSS JOIN&lt;/code&gt; or just with &lt;code&gt;,&lt;/code&gt; like this:</source>
          <target state="translated">Вы можете получить данные всех этих таблиц с помощью &lt;code&gt;CROSS JOIN&lt;/code&gt; или просто с помощью:</target>
        </trans-unit>
        <trans-unit id="1a1e81f049f544da8e827ced9214175f4266ff1e" translate="yes" xml:space="preserve">
          <source>You can use this to find Orders that do not have any OrderDetails indicating a possible orphaned order by adding a where clause like &lt;code&gt;WHERE OrderDetails.OrderID IS NULL&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать это, чтобы найти Заказы, в которых нет OrderDetails, указывающего возможный потерянный заказ, добавив предложение where, например, &lt;code&gt;WHERE OrderDetails.OrderID IS NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c432dc9a8aed93143719f983d09f7dc4ee24f3f2" translate="yes" xml:space="preserve">
          <source>You use &lt;strong&gt;&lt;code&gt;INNER JOIN&lt;/code&gt;&lt;/strong&gt; to return all rows from both tables where there is a match. i.e. In the resulting table all the rows and columns will have values.</source>
          <target state="translated">Вы используете &lt;strong&gt; &lt;code&gt;INNER JOIN&lt;/code&gt; &lt;/strong&gt; для возврата всех строк из обеих таблиц, где есть совпадение. т.е. в результирующей таблице все строки и столбцы будут иметь значения.</target>
        </trans-unit>
        <trans-unit id="5ddd1649f6c6d27be685f0befe44428d1f624b7b" translate="yes" xml:space="preserve">
          <source>pseudo code</source>
          <target state="translated">псевдокод</target>
        </trans-unit>
        <trans-unit id="90441d92c84393ca73c7ec3bf6e6832e27a0377d" translate="yes" xml:space="preserve">
          <source>source: &lt;a href=&quot;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&quot;&gt;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&lt;/a&gt;</source>
          <target state="translated">источник: &lt;a href=&quot;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&quot;&gt;http://ssiddique.info/understanding-sql-joins-in-easy-way.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c69e4be6cd06f2e7509ef81acef0ab318e493ce0" translate="yes" xml:space="preserve">
          <source>then it will return records from the Orders table even if they have no OrderDetails records.</source>
          <target state="translated">то он вернет записи из таблицы Ордеров,даже если у них нет записей OrderDetails.</target>
        </trans-unit>
        <trans-unit id="e543858eed9e3aab749d5cc296399e70aee10762" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;INNER JOIN&lt;/code&gt; when the related data &lt;code&gt;B&lt;/code&gt; you are looking for &lt;strong&gt;MUST&lt;/strong&gt; exists per database design;</source>
          <target state="translated">используйте &lt;code&gt;INNER JOIN&lt;/code&gt; , когда соответствующие данные &lt;code&gt;B&lt;/code&gt; ,которые вы ищете, &lt;strong&gt;ДОЛЖНЫ&lt;/strong&gt; существовать для каждого проекта базы данных;</target>
        </trans-unit>
        <trans-unit id="d149d496aa34dd3b6938dd6b37e601c17b65449f" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;LEFT JOIN&lt;/code&gt; when the related data &lt;code&gt;B&lt;/code&gt; you are looking for &lt;strong&gt;MIGHT&lt;/strong&gt; or &lt;strong&gt;MIGHT NOT&lt;/strong&gt; exists per database design.</source>
          <target state="translated">используйте &lt;code&gt;LEFT JOIN&lt;/code&gt; , когда связанные данные &lt;code&gt;B&lt;/code&gt; ,которые вы ищете, &lt;strong&gt;МОГУТ&lt;/strong&gt; или &lt;strong&gt;МОГУТ НЕ&lt;/strong&gt; существуют для каждого проекта базы данных.</target>
        </trans-unit>
        <trans-unit id="f2af3ad5a640fa2ff80c7fd3d197f32a5c39261e" translate="yes" xml:space="preserve">
          <source>will only return Orders that also have something in the OrderDetails table.</source>
          <target state="translated">вернет только те Ордера,у которых тоже есть что-то в таблице OrderDetails.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
