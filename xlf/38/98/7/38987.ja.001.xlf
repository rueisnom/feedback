<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/38987">
    <body>
      <group id="38987">
        <trans-unit id="762f1a0e69169610829fa8a43f4c74678cbb8a23" translate="yes" xml:space="preserve">
          <source>(For Python2.7* only; there are simpler solutions for Python3*.)</source>
          <target state="translated">(Python2.7*のみ。Python3*にはもっとシンプルな解決策があります。)</target>
        </trans-unit>
        <trans-unit id="26cef14df0be957675f0530429b3a7bde6a3b375" translate="yes" xml:space="preserve">
          <source>(That is, of course, equivalent to &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)</source>
          <target state="translated">（もちろん、これは &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt; と同等ですが、Pythonバージョンがそれに対して十分に新しい場合は、PEP 448スタイルを使用できます。）</target>
        </trans-unit>
        <trans-unit id="c983206bb5c1b9997bd209ce2acce7e071f69644" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;or a&lt;/code&gt; bit in the &lt;code&gt;lambda&lt;/code&gt; is necessary because &lt;code&gt;dict.update&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt; on success.)</source>
          <target state="translated">（成功すると &lt;code&gt;dict.update&lt;/code&gt; は常に &lt;code&gt;None&lt;/code&gt; を返すので、 &lt;code&gt;lambda&lt;/code&gt; の &lt;code&gt;or a&lt;/code&gt; ビットが必要です。）</target>
        </trans-unit>
        <trans-unit id="fc6520d839da1d73fe3d2dc5120a168296e3c8df" translate="yes" xml:space="preserve">
          <source>(To be extra-clear, the last-one-wins conflict-handling of &lt;code&gt;dict.update()&lt;/code&gt; is what I'm looking for as well.)</source>
          <target state="translated">（さらに明確にするために、 &lt;code&gt;dict.update()&lt;/code&gt; の最後に勝った競合処理は私が探しているものでもあります。）</target>
        </trans-unit>
        <trans-unit id="59798fb8386a0602fdd9b6380f0da9334a75b531" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - talk by Brandon Rhodes at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;Dictionary Even Mightier&lt;/a&gt; -Pycon 2017でのBrandon Rhodesによるトーク</target>
        </trans-unit>
        <trans-unit id="8b08b9102b840351132b620d290b145d977714b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Modern Python Dictionaries, A Confluence of Great Ideas&lt;/a&gt; - talk by Raymond Hettinger at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;モダンなPython辞書、素晴らしいアイデアの合流&lt;/a&gt; -Pycon 2017でレイモンドヘッティンガーによる講演</target>
        </trans-unit>
        <trans-unit id="64eaafdd6d026ca8e8e81c2df03a5ad7e0e4f273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; is still the most readable solution for Python 2. Readability counts.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; は、Python 2で最も読みやすいソリューションです。</target>
        </trans-unit>
        <trans-unit id="1bc9f47831b8850843d4bfab7500ddd5d5e01499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;itertools.chain&lt;/code&gt; will chain the iterators over the key-value pairs in the correct order:</source>
          <target state="translated">&lt;code&gt;itertools.chain&lt;/code&gt; はイテレーターをキーと値のペアに正しい順序でチェーンします：</target>
        </trans-unit>
        <trans-unit id="8762df6a9a82f0b36d9893287201772efe7c7ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; has bad performance. See &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; パフォーマンスが悪い。 &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="b30516353c8b7de805be8527f19faa1ebcd7e111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but &lt;code&gt;z2&lt;/code&gt; always seems to come out ahead.  (If you get inconsistent results for the &lt;em&gt;same&lt;/em&gt; test, try passing in &lt;code&gt;-r&lt;/code&gt; with a number larger than the default 3.)</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; は3.5倍程度勝つ。 辞書が異なれば結果もまったく違うようですが、 &lt;code&gt;z2&lt;/code&gt; は常に先に出てくるようです。 （ &lt;em&gt;同じ&lt;/em&gt;テストで一貫性のない結果が得られた場合は、デフォルトの3より大きい数値で &lt;code&gt;-r&lt;/code&gt; を渡してみてください。）</target>
        </trans-unit>
        <trans-unit id="73fb6424cfd11bb18a1c574f3c35c5c9d895216f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by about a factor of 10.  That's a pretty big win in my book!</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; は約10倍勝っています。これは、私の本ではかなり大きな勝利です。</target>
        </trans-unit>
        <trans-unit id="684683c3cfba4b7ae046f86966f4cf852b750b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{**x, **y}&lt;/code&gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</source>
          <target state="translated">&lt;code&gt;{**x, **y}&lt;/code&gt; はネストされた辞書を処理しないようです。 ネストされたキーの内容はマージされず、単に上書きされます[...]再帰的にマージしないこれらの回答に火傷を負ってしまい、誰もそれに言及していなかったので驚きました。 「マージ」という言葉の私の解釈では、これらの答えは「1つのディクテーションを別のディクテーションで更新する」ことを表しており、マージしないことを表しています。</target>
        </trans-unit>
        <trans-unit id="4acb6eec05cf3410b42a7e8367ceb7218e526e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;n個の&lt;/em&gt;辞書&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c750c4b4d745d4a88f3eea8b03ce9ceff63b397a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Python 3.0 and later&lt;/strong&gt;, you can use &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt;&lt;code&gt;collections.ChainMap&lt;/code&gt;&lt;/a&gt; which groups multiple dicts or other mappings together to create a single, updateable view:</source>
          <target state="translated">&lt;strong&gt;Python 3.0以降では&lt;/strong&gt; 、 &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt; &lt;code&gt;collections.ChainMap&lt;/code&gt; &lt;/a&gt;を使用して、複数の辞書または他のマッピングをグループ化して、単一の更新可能なビューを作成できます。</target>
        </trans-unit>
        <trans-unit id="047862db1890195e52368684bf93f77d9a3b9706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this has become a popular answer, but it is important to point out that if &lt;code&gt;y&lt;/code&gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido is not a fan&lt;/a&gt;. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt; ：これは人気のある答えになりましたが、 &lt;code&gt;y&lt;/code&gt; に文字列以外のキーがある場合、これがまったく機能するという事実はCPython実装の詳細の乱用であり、Python 3では機能しないことを指摘することが重要です、またはPyPy、IronPython、またはJython。 また、 &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guidoはファンではありません&lt;/a&gt; 。 したがって、この手法を前方互換またはクロス実装のポータブルコードに推奨することはできません。つまり、完全に回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="56c781e5adb8bad76d8066d046d1c97e28021043" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2つの辞書&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d78daed80f94bbc7108a07b9e271b9fca2cca5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update for Python 3.5 and later&lt;/strong&gt;: You can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; extended dictionary packing and unpacking.  This is fast and easy:</source>
          <target state="translated">&lt;strong&gt;Python 3.5以降の更新&lt;/strong&gt; ： &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt;拡張ディクショナリのパックおよびアンパックを使用できます。 これは速くて簡単です：</target>
        </trans-unit>
        <trans-unit id="4ad22f81594d7603a3fcfc3c26100cb43cf77997" translate="yes" xml:space="preserve">
          <source>A couple more points for python 3. First, note that the &lt;code&gt;dict(x, **y)&lt;/code&gt; trick won't work in python 3 unless the keys in &lt;code&gt;y&lt;/code&gt; are strings.</source>
          <target state="translated">Python 3のポイントをもう2つ追加します。最初に、 &lt;code&gt;dict(x, **y)&lt;/code&gt; トリックは、 &lt;code&gt;y&lt;/code&gt; のキーが文字列でない限り、python 3では機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="52323533fde1038ac6c3239bddef21ed2cd7faa9" translate="yes" xml:space="preserve">
          <source>A few quick tests, e.g.</source>
          <target state="translated">幾つかの簡単なテスト、例えば</target>
        </trans-unit>
        <trans-unit id="5b8d1b61a251a1f4f5f96af395d52351a9c2d234" translate="yes" xml:space="preserve">
          <source>A new syntax for this, proposed in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; and &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;available as of Python 3.5&lt;/a&gt;, is</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt;で提案さ&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;れ、Python 3.5&lt;/a&gt;以降で利用可能な 、この新しい構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d20312b0c332092c94533e037801b46f85f6ff75" translate="yes" xml:space="preserve">
          <source>A typical result:</source>
          <target state="translated">典型的な結果です。</target>
        </trans-unit>
        <trans-unit id="79346271c215b10d408c3a24960c3a8434e1b144" translate="yes" xml:space="preserve">
          <source>Abuse leading to a one-expression solution for &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;マシューの答え&lt;/a&gt;を一式で解く虐待：</target>
        </trans-unit>
        <trans-unit id="bc0fcdd15355dfc94d498254e338806fd4947b01" translate="yes" xml:space="preserve">
          <source>After comparing those two, I wondered if &lt;code&gt;z1&lt;/code&gt;'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</source>
          <target state="translated">これら2つを比較した後、 &lt;code&gt;z1&lt;/code&gt; のパフォーマンスの低下が2つの項目リストを作成するオーバーヘッドに起因しているのではないかと思いました。</target>
        </trans-unit>
        <trans-unit id="3e513e02e5ffef80d9363703f5c690e41e7d947a" translate="yes" xml:space="preserve">
          <source>Again, it doesn't work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. &lt;code&gt;dict&lt;/code&gt; broke this consistency in Python 2:</source>
          <target state="translated">繰り返しになりますが、キーが文字列ではない場合、3では機能しません。 暗黙の呼び出し規約では、名前空間は通常のディクテーションを使用しますが、ユーザーは文字列であるキーワード引数のみを渡す必要があります。 他のすべての呼び出し可能オブジェクトがそれを強制しました。 &lt;code&gt;dict&lt;/code&gt; はPython 2でこの一貫性を壊しました：</target>
        </trans-unit>
        <trans-unit id="37903af1bb3d70c3129ae7ad37c51d78652644c4" translate="yes" xml:space="preserve">
          <source>Also, Raymond Hettinger's Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;answer&lt;/a&gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;from the docs&lt;/a&gt; it looks like it sequentially looks through a list of all the dicts for each lookup:</source>
          <target state="translated">また、レイモンドヘッティンガーのチェーンマップの&lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;回答&lt;/a&gt;は、引数として任意の数のディクテーションを受け取ることができるため、非常にエレガントですが&lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;、ドキュメントからは、&lt;/a&gt;ルックアップごとにすべてのディクテーションのリストを順番に調べているように見えます。</target>
        </trans-unit>
        <trans-unit id="b0e9fc794244c2742a7d0ad09b5a05d65fe3ab05" translate="yes" xml:space="preserve">
          <source>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only):</source>
          <target state="translated">新セイウチ演算子(Python 3.8+のみ)の以下の使い方とさほど変わりませんが。</target>
        </trans-unit>
        <trans-unit id="d64aa96c0baf8816d369af41816223f0d24166b8" translate="yes" xml:space="preserve">
          <source>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life &lt;em&gt;Guido van Rossum&lt;/em&gt; himself!  Someone else suggested half of this, but did not put it in a function.</source>
          <target state="translated">そのような怪しげで疑わしい答えの中で、この輝かしい例はPythonで口述をマージするための唯一無二の良い方法であり、 &lt;em&gt;Guido van Rossum&lt;/em&gt;自身の独裁者によって承認されています！ 他の誰かがこれの半分を提案しましたが、関数に入れませんでした。</target>
        </trans-unit>
        <trans-unit id="b52eb9c15df1a810d482d29e8ce9cd10a248294b" translate="yes" xml:space="preserve">
          <source>An alternative:</source>
          <target state="translated">代替案だ</target>
        </trans-unit>
        <trans-unit id="ad2a670b2ebfd8d5864a5b7bac3632cc392444b7" translate="yes" xml:space="preserve">
          <source>And it is indeed a single expression.</source>
          <target state="translated">そして、それは確かに一つの表現である。</target>
        </trans-unit>
        <trans-unit id="2a68af8ef2b2b3fa71a55eee3ef7e2c9f937685a" translate="yes" xml:space="preserve">
          <source>And it's usage:</source>
          <target state="translated">そして、それは使い方です。</target>
        </trans-unit>
        <trans-unit id="b0b7becbe9ec6ad7a7d8f73a304a045dc8bff483" translate="yes" xml:space="preserve">
          <source>Another hack you should not use:</source>
          <target state="translated">使ってはいけないもう一つのハック</target>
        </trans-unit>
        <trans-unit id="a6df3197072e3a7d3b37983ee4cecb723db3ac60" translate="yes" xml:space="preserve">
          <source>Another, more concise, option:</source>
          <target state="translated">もう一つの、もっと簡潔なオプション。</target>
        </trans-unit>
        <trans-unit id="a90812f162710be72c6673269344a54ff85dec16" translate="yes" xml:space="preserve">
          <source>Answer on how to add new keys to a dictionary</source>
          <target state="translated">辞書に新しいキーを追加する方法についての回答</target>
        </trans-unit>
        <trans-unit id="209d65032f4cdd91a49f9731f909c0f76b26af8f" translate="yes" xml:space="preserve">
          <source>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call
  x.update(y) and return x&quot;. Personally I find it more despicable than
  cool.</source>
          <target state="translated">どうやらdict(x,**y)が「x.update(y)を呼び出してxを返す」というクールなハックとして流行っているようです。個人的にはクールというよりも卑劣だと思う。</target>
        </trans-unit>
        <trans-unit id="1107541abd6568cff679b7beb9d9536a95d8d98c" translate="yes" xml:space="preserve">
          <source>As suggested above, using two lines or writing a function is probably a better way to go.</source>
          <target state="translated">上で提案したように、2行を使うか、関数を書いた方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="9c0a490ce334822e1a4fa03338b9164ecf3e1d0a" translate="yes" xml:space="preserve">
          <source>Assuming two dictionary of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dicts from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</source>
          <target state="translated">2つの辞書を想定すると、1つの関数でそれらを再帰的にマージすることができますが、どちらか一方のソースの辞書を変更しないように注意しなければなりません。キーはハッシュ化可能でなければならず、通常は不変なので、それらをコピーすることは無意味です。</target>
        </trans-unit>
        <trans-unit id="dda59ae142911ee5f815e7544ec0051e45b17ef5" translate="yes" xml:space="preserve">
          <source>Be pythonic. Use a &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;comprehension&lt;/a&gt;:</source>
          <target state="translated">pythonicになる。 &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;理解度を&lt;/a&gt;使用する：</target>
        </trans-unit>
        <trans-unit id="e3e400046d95f67ae3dc116f87dadd13f71f972a" translate="yes" xml:space="preserve">
          <source>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;&lt;/a&gt;.</source>
          <target state="translated">他の値タイプの不測の事態を考えることはこの質問の範囲をはるかに超えているので&lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;、「辞書の辞書のマージ」に関する正規の質問に対する私の回答を紹介し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5ead0c8a43030e9b4ba9dfd6743570550ad79d67" translate="yes" xml:space="preserve">
          <source>Critiques of Other Answers</source>
          <target state="translated">他の回答の批評</target>
        </trans-unit>
        <trans-unit id="c6a7b52934eb4c501f4a60e0e15c80a5bef14889" translate="yes" xml:space="preserve">
          <source>Demonstration:</source>
          <target state="translated">Demonstration:</target>
        </trans-unit>
        <trans-unit id="92ec7b2214ef32933d24b7351f97a6c052ccdf23" translate="yes" xml:space="preserve">
          <source>Depending on the use case it might not be necessary to create a &quot;real&quot; merged dictionary of the given input dictionaries.  A &lt;em&gt;view&lt;/em&gt; which does this might be sufficient in many cases, i. e. an object which acts &lt;em&gt;like&lt;/em&gt; the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak.</source>
          <target state="translated">ユースケースによっては、特定の入力ディクショナリの「実際の」マージされたディクショナリを作成する必要がない場合があります。 多くの場合、これを行う&lt;em&gt;ビュー&lt;/em&gt;で十分です。つまり、マージされた辞書の&lt;em&gt;よう&lt;/em&gt;に機能するオブジェクトは、完全に計算しなくても十分です。 いわば、マージされた辞書の遅延バージョンです。</target>
        </trans-unit>
        <trans-unit id="cf8c4ba0db8a8656b2f2f14c9fc473f2d81f924b" translate="yes" xml:space="preserve">
          <source>Despite what Guido says, &lt;code&gt;dict(x, **y)&lt;/code&gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords.</source>
          <target state="translated">Guidoの言うことにもかかわらず、 &lt;code&gt;dict(x, **y)&lt;/code&gt; はdictの仕様に沿っています。 Python 2とPython 3の両方で機能します。これが文字列キーでのみ機能するという事実は、キーワードパラメータの機能の直接的な結果であり、dictの短さではありません。 この場所で**演算子を使用することも、メカニズムを乱用することもありません。実際、**は、dictをキーワードとして正確に渡すように設計されています。</target>
        </trans-unit>
        <trans-unit id="3d03564e5b15ddf2ca88faedf123c311e047f26b" translate="yes" xml:space="preserve">
          <source>Dicts are intended to take hashable keys (e.g. frozensets or tuples), but &lt;strong&gt;this method fails in Python 3 when keys are not strings.&lt;/strong&gt;</source>
          <target state="translated">Dictはハッシュ可能なキー（例：frozensetsまたはtuples）を取ることを目的とし&lt;strong&gt;ていますが、キーが文字列でない場合、このメソッドはPython 3で失敗します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92d9a054b2288bd1fdd9bdb5e55a39fe412e39ab" translate="yes" xml:space="preserve">
          <source>Don't use what you see in the formerly accepted answer:</source>
          <target state="translated">以前の回答にあるようなものは使わないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="ac898e4932c0e7dcb2f44c27b6aeabf7e53fc70c" translate="yes" xml:space="preserve">
          <source>Drawing on ideas here and elsewhere I've comprehended a function:</source>
          <target state="translated">ここや他の場所のアイデアを参考にして、機能を理解しました。</target>
        </trans-unit>
        <trans-unit id="6c434bcb6a9e583ddd9818e466c89cc4d9768234" translate="yes" xml:space="preserve">
          <source>Even though the answers were good for this &lt;em&gt;shallow&lt;/em&gt; dictionary, none of the methods defined here actually do a deep dictionary merge.</source>
          <target state="translated">回答がこの&lt;em&gt;浅い&lt;/em&gt;辞書に適していたとしても、ここで定義されているメソッドのいずれも実際には深い辞書のマージを行いません。</target>
        </trans-unit>
        <trans-unit id="534c40ca3d6e9c332fb24d30e24866a5884fdf3c" translate="yes" xml:space="preserve">
          <source>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</source>
          <target state="translated">例1:20個の連続した整数を自分自身にマッピングする同一の辞書</target>
        </trans-unit>
        <trans-unit id="5d6468775d296b285af2d4eb8a4fbae02366f7da" translate="yes" xml:space="preserve">
          <source>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</source>
          <target state="translated">例2:252個の短い文字列を整数にマッピングする非重複辞書と、その逆の場合。</target>
        </trans-unit>
        <trans-unit id="51725d04b42e48c95f79400a9ef4bf6dd25aa363" translate="yes" xml:space="preserve">
          <source>Examples follow:</source>
          <target state="translated">例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="417f84c0ab231efe074c376811a745ff0bbaefae" translate="yes" xml:space="preserve">
          <source>For dictionaries &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; becomes a shallowly merged dictionary with values from &lt;code&gt;y&lt;/code&gt; replacing those from &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">辞書 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; の場合、 &lt;code&gt;z&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; からの値を &lt;code&gt;y&lt;/code&gt; からの値に置き換える浅くマージされた辞書になります。</target>
        </trans-unit>
        <trans-unit id="5a7a48fc65c8ec5e1d37a7ac34c58a2610a8718b" translate="yes" xml:space="preserve">
          <source>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</source>
          <target state="translated">両方の辞書にキーがある項目('b')では、どちらが出力されるかを最後に置くことで制御することができます。</target>
        </trans-unit>
        <trans-unit id="66e4468118f12a49669432b591f48cae1db2757b" translate="yes" xml:space="preserve">
          <source>For python3-like behavior in version 2.7, the &lt;code&gt;viewitems&lt;/code&gt; method should work in place of &lt;code&gt;items&lt;/code&gt;:</source>
          <target state="translated">バージョン2.7のpython3のような動作の場合、 &lt;code&gt;items&lt;/code&gt; 代わりに &lt;code&gt;viewitems&lt;/code&gt; メソッドが機能します 。</target>
        </trans-unit>
        <trans-unit id="05f303d92888701b00a3dca7391b2cd0ede31839" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;mailing list&lt;/a&gt;, Guido van Rossum, the creator of the language, wrote:</source>
          <target state="translated">&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;メーリングリスト&lt;/a&gt;から、言語の作成者であるグイドファンロッサムは次のように書いています。</target>
        </trans-unit>
        <trans-unit id="9f63a1b687b569fbbc0abd2c72572d74cf9da35c" translate="yes" xml:space="preserve">
          <source>Here's an example of the usage being &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;remediated in django&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;django&lt;/a&gt;で修正された使用法の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="7fca813712109d4e2606defe725d888aa50dabf0" translate="yes" xml:space="preserve">
          <source>Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:</source>
          <target state="translated">ここでは、yが優先されるべきですが、集合の任意の順序のためにxからの値が保持される例を示します。</target>
        </trans-unit>
        <trans-unit id="eebe1dc7075416ba2cee50e9bcf95a9e8f656e14" translate="yes" xml:space="preserve">
          <source>Here's the straight-forward code of &lt;code&gt;MergeDict&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;MergeDict&lt;/code&gt; の簡単なコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="22cca235a9f80cdc5840a3a67ad0dfe9f75c41d8" translate="yes" xml:space="preserve">
          <source>How can I get that final merged dictionary in &lt;code&gt;z&lt;/code&gt;, not &lt;code&gt;x&lt;/code&gt;?</source>
          <target state="translated">最終的にマージされた辞書を &lt;code&gt;z&lt;/code&gt; ではなくzで取得するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="5b9ed01b74e3b861c8ed3f17f0beccfffc6b9b9b" translate="yes" xml:space="preserve">
          <source>How can I merge two Python dictionaries in a single expression?</source>
          <target state="translated">2つのPython辞書を1つの式にマージするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="8cb6e8e8ba5fdf4ce9658d5ca8f5d8770c5e9e85" translate="yes" xml:space="preserve">
          <source>How do I merge two dictionaries in a single expression</source>
          <target state="translated">2つの辞書を1つの式に統合するには</target>
        </trans-unit>
        <trans-unit id="c8ef4565722ce18107b48e5f9a668982765902bd" translate="yes" xml:space="preserve">
          <source>However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</source>
          <target state="translated">しかし、多くの組織がまだ Python 2 を使用しているので、下位互換性のある方法でこれを行いたい場合があります。Python 2とPython 3.0-3.4で利用可能な古典的なPythonicの方法は、2段階のプロセスとしてこれを行うことです。</target>
        </trans-unit>
        <trans-unit id="a9e2146fc3d130671f68d310625226e3ccce8eab" translate="yes" xml:space="preserve">
          <source>I am fine with
  declaring dict({}, **{1:3}) illegal, since after all it is abuse of
  the ** mechanism.</source>
          <target state="translated">私はdict({},**{1:3})を違法と宣言しても構いません。</target>
        </trans-unit>
        <trans-unit id="11606279b4a4e0c3d7cb38ec7e13e08435b369e0" translate="yes" xml:space="preserve">
          <source>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The &lt;code&gt;update()&lt;/code&gt; method would be what I need, if it returned its result instead of modifying a dictionary in-place.</source>
          <target state="translated">2つのPython辞書があり、これら2つの辞書をマージして返す単一の式を記述したいと思います。 辞書をインプレースで変更するのではなく結果を返す場合、 &lt;code&gt;update()&lt;/code&gt; メソッドが必要です。</target>
        </trans-unit>
        <trans-unit id="56b9ab3e4817a98d072aafad2224e1acb41d827f" translate="yes" xml:space="preserve">
          <source>I just use a simple helper function to solve the problem:</source>
          <target state="translated">簡単なヘルパー機能を使って問題を解決しているだけです。</target>
        </trans-unit>
        <trans-unit id="01c87e18558e3526b4877129f79e0ec875c6b499" translate="yes" xml:space="preserve">
          <source>I know this does not really fit the specifics of the questions (&quot;one liner&quot;), but since &lt;em&gt;none&lt;/em&gt; of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts.</source>
          <target state="translated">これは質問の詳細（「1つのライナー」）に実際には当てはまらないことはわかっていますが、パフォーマンスの問題については多くの回答が取り上げられて&lt;em&gt;いました&lt;/em&gt;が、上記の回答の&lt;em&gt;いずれも&lt;/em&gt;この方向に進んでい&lt;em&gt;なかっ&lt;/em&gt;たため、自分の考えに貢献する必要があると感じました。</target>
        </trans-unit>
        <trans-unit id="bfc266b6f982c3a928236a92c629662068d1aa8b" translate="yes" xml:space="preserve">
          <source>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</source>
          <target state="translated">いずれにしても、(タイトルにあるように)連結というよりは、セットユニオン演算と考えた方が自然な感じがするので、この表記法の方が好きです。</target>
        </trans-unit>
        <trans-unit id="375e440687d005ef88e88f34c7f99f4a5ac588c4" translate="yes" xml:space="preserve">
          <source>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</source>
          <target state="translated">ある言語の一つのバージョンでしか動作しないコードを意図的に書いたり、特定の任意の制約を与えられた場合にしか動作しないコードを書くのは、悪意のある無能であることをあなたに提案します。</target>
        </trans-unit>
        <trans-unit id="7bb9b5043cf7f5771f44311a303420b28a455fba" translate="yes" xml:space="preserve">
          <source>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</source>
          <target state="translated">似たようなものが欲しかったのですが、重複キーの値をどのようにマージするかを指定する機能があったので、これをハックしてみました(ただし、激しいテストはしていません)。明らかにこれは単一の式ではありませんが、単一の関数呼び出しです。</target>
        </trans-unit>
        <trans-unit id="78af1cea1dc16ea253286cd3b93d54839ede508a" translate="yes" xml:space="preserve">
          <source>I'm only going to do the performance analysis of the usages known to behave correctly.</source>
          <target state="translated">正しく振る舞うことがわかっている使い道の性能分析をするだけです。</target>
        </trans-unit>
        <trans-unit id="3b18b7815200328ded8232a4d1a242e6497d1f7f" translate="yes" xml:space="preserve">
          <source>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</source>
          <target state="translated">最初の2つの間のわずかな速度低下は、読みやすさのために価値があると思います。さらに、辞書作成のためのキーワード引数はPython 2.3で追加されただけですが、copy()とupdate()は古いバージョンでも動作します。</target>
        </trans-unit>
        <trans-unit id="80cd4b20ecfc8fde8f0d9999c7ceff52e8d8b72a" translate="yes" xml:space="preserve">
          <source>If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a &lt;em&gt;single expression&lt;/em&gt;, the most performant while correct approach is to put it in a function:</source>
          <target state="translated">まだPython 3.5を使用していない場合、または下位互換性のあるコードを記述する必要があり、これを&lt;em&gt;単一の式&lt;/em&gt;で作成したい場合、正しい方法で最もパフォーマンスが高いのは、それを関数に入れることです。</target>
        </trans-unit>
        <trans-unit id="58f39817135947f0339519f69b794e849b094fff" translate="yes" xml:space="preserve">
          <source>If you do want a copy, PEP 448 style is easiest &lt;code&gt;{**x, **y}&lt;/code&gt;. But if that's not available in your (older) Python version, the &lt;em&gt;let&lt;/em&gt; pattern works here too.</source>
          <target state="translated">コピーが必要な場合は、PEP 448スタイルが最も簡単です &lt;code&gt;{**x, **y}&lt;/code&gt; 。 しかし、それが（古い）Pythonバージョンで利用できない場合、 &lt;em&gt;let&lt;/em&gt;パターンはここでも機能します。</target>
        </trans-unit>
        <trans-unit id="c68f13df74f8081969ebc7396a5bdbb15beb7948" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;x&lt;/code&gt; in a variable yet, you can use &lt;code&gt;lambda&lt;/code&gt; to make a local without using an assignment statement. This amounts to using &lt;code&gt;lambda&lt;/code&gt; as a &lt;em&gt;let expression&lt;/em&gt;, which is a common technique in functional languages, but maybe unpythonic.</source>
          <target state="translated">変数に &lt;code&gt;x&lt;/code&gt; がまだない場合は、 &lt;code&gt;lambda&lt;/code&gt; を使用して、割り当てステートメントを使用せずにローカルを作成できます。 これは、 &lt;code&gt;lambda&lt;/code&gt; を&lt;em&gt;let式&lt;/em&gt;として使用する&lt;em&gt;ことになります&lt;/em&gt; 。これは、関数型言語では一般的な手法ですが、Pythonを使用していない可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e67f1fbb5c4630089b3b15e7da7f230c6351803" translate="yes" xml:space="preserve">
          <source>If you don't mind mutating &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; を変更してもかまわない場合は、</target>
        </trans-unit>
        <trans-unit id="23112b4c7ee35913e4183cf954bd3fbb6f22db7a" translate="yes" xml:space="preserve">
          <source>If you ever felt you would prefer to have a real merged &lt;code&gt;dict&lt;/code&gt;, then calling &lt;code&gt;dict(z)&lt;/code&gt; would produce it (but way more costly than the other solutions of course, so this is just worth mentioning).</source>
          <target state="translated">実際に &lt;code&gt;dict&lt;/code&gt; をマージしたい場合は、 &lt;code&gt;dict(z)&lt;/code&gt; を呼び出すと生成されます（もちろん、他のソリューションよりもコストがかかるため、言及するだけの価値があります）。</target>
        </trans-unit>
        <trans-unit id="91c65288fd2cb6d1ebcbffd2f95dcc6f769de027" translate="yes" xml:space="preserve">
          <source>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</source>
          <target state="translated">ラムダは悪だと思っているなら、それ以上は読まないでください。要求されたように、一つの式で高速でメモリ効率の良い解を書くことができます。</target>
        </trans-unit>
        <trans-unit id="7b3eb5dd9b8564f262213b8ec581f34343fb1155" translate="yes" xml:space="preserve">
          <source>If you use Python 3, it is only a little more complicated.  To create &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">Python 3を使用する場合は、少しだけ複雑です。 &lt;code&gt;z&lt;/code&gt; を作成するには：</target>
        </trans-unit>
        <trans-unit id="d340b513c30c260578d2c3eadac2366554f22a75" translate="yes" xml:space="preserve">
          <source>If you're not averse to importing a standard library module, you can do</source>
          <target state="translated">標準のライブラリモジュールをインポートすることに抵抗がなければ</target>
        </trans-unit>
        <trans-unit id="a4d62fbeb1dc986c159aff37fcf7e409f975fec3" translate="yes" xml:space="preserve">
          <source>In Python 2, (or 3.4 or lower) write a function:</source>
          <target state="translated">Python 2(または3.4以下)では、関数を書く。</target>
        </trans-unit>
        <trans-unit id="cddaaf9db6625675addbc60941262561bfd51d86" translate="yes" xml:space="preserve">
          <source>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. &lt;strong&gt;In Python 3, this will fail&lt;/strong&gt; because you're adding two &lt;code&gt;dict_items&lt;/code&gt; objects together, not two lists -</source>
          <target state="translated">Python 2では、各辞書のメモリ内に2つのリストを作成し、最初の2つをまとめた長さと同じ長さの3つ目のリストをメモリ内に作成し、3つすべてのリストを破棄して辞書を作成します。 &lt;strong&gt;Python 3では、&lt;/strong&gt; 2つのリストではなく2つの &lt;code&gt;dict_items&lt;/code&gt; オブジェクトを一緒に追加&lt;strong&gt;している&lt;/strong&gt;ため&lt;strong&gt;、これは失敗し&lt;/strong&gt;ます-</target>
        </trans-unit>
        <trans-unit id="c145a8d3b1ebc6e2271fc27dc8537d7fd274de6b" translate="yes" xml:space="preserve">
          <source>In Python 2.7 (system Python):</source>
          <target state="translated">Python 2.7(Python系)で。</target>
        </trans-unit>
        <trans-unit id="c0da467e5ff897c9e6741e6911edbfc2c8e28314" translate="yes" xml:space="preserve">
          <source>In Python 3.5 (deadsnakes PPA):</source>
          <target state="translated">Python 3.5(deadsnakes PPA)で。</target>
        </trans-unit>
        <trans-unit id="61986f9755b6245f3a2d4cfab600c14ea75b062c" translate="yes" xml:space="preserve">
          <source>In Python 3.5 or greater:</source>
          <target state="translated">Python 3.5以上で。</target>
        </trans-unit>
        <trans-unit id="7c246f03cced22905d4e5edbf31a21a72dfa1e56" translate="yes" xml:space="preserve">
          <source>In Python 3.9.0a4 or greater (final release date approx October 2020): &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;discussed here&lt;/a&gt;, was implemented to further simplify this:</source>
          <target state="translated">Python 3.9.0a4以降（最終リリース日は2020年10月頃）：これをさらに簡素化するために、 &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;ここ&lt;/a&gt;で説明されている &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;が実装されました。</target>
        </trans-unit>
        <trans-unit id="fb06defc9c6c89decb004ddee3cc8e2971971de4" translate="yes" xml:space="preserve">
          <source>In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be:</source>
          <target state="translated">Pythonでは、これはかなりシンプルで、私の投稿の最後に示されているコードで行うことができます。これが与えられた場合、元の質問への答えは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2694d72958aa5476affbdd9f1fa8e1fb6ade5022" translate="yes" xml:space="preserve">
          <source>In a follow-up answer, you asked about the relative performance of these two alternatives:</source>
          <target state="translated">続いての回答では、この2つの選択肢の相対的なパフォーマンスについて質問されました。</target>
        </trans-unit>
        <trans-unit id="fc9fa0b91a747b146f5bf2910dc05830d2caba46" translate="yes" xml:space="preserve">
          <source>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</source>
          <target state="translated">さらに、.items()(Python 3.0以前)を使うと、辞書の項目を含む新しいリストを作成することになります。辞書が大きい場合、これはかなりのオーバーヘッドになります (マージされたdictが作成されるとすぐに捨てられてしまう2つの大きなリスト)。</target>
        </trans-unit>
        <trans-unit id="dd84518801f2e66815fcf3f25a609ccfebd7ea62" translate="yes" xml:space="preserve">
          <source>In both approaches, &lt;code&gt;y&lt;/code&gt; will come second and its values will replace &lt;code&gt;x&lt;/code&gt;'s values, thus &lt;code&gt;'b'&lt;/code&gt; will point to &lt;code&gt;3&lt;/code&gt; in our final result.</source>
          <target state="translated">どちらのアプローチでも、 &lt;code&gt;y&lt;/code&gt; が2番目になり、その値が &lt;code&gt;x&lt;/code&gt; の値を置き換えます。したがって、最終結果では &lt;code&gt;'b'&lt;/code&gt; は &lt;code&gt;3&lt;/code&gt; を指します。</target>
        </trans-unit>
        <trans-unit id="3840c97bb862e7304c6e3f15f1b99fb6f44f7a27" translate="yes" xml:space="preserve">
          <source>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses &lt;code&gt;dict&lt;/code&gt; in lots of places; optimizing its operations is a big deal.</source>
          <target state="translated">実際、私は、純粋なPythonコードではこれ以上のことを行うことは不可能だと主張するところまで行きます。 また、C拡張モジュールで大幅に改善できる場合は、Pythonの人々がコード（またはアプローチのバリエーション）をPythonコアに組み込むことに興味を持っていると思います。 Pythonは多くの場所で &lt;code&gt;dict&lt;/code&gt; を使用します。 その運用を最適化することは大きな問題です。</target>
        </trans-unit>
        <trans-unit id="bb531282f9af11f54c3641bdd4af885240f75d4e" translate="yes" xml:space="preserve">
          <source>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</source>
          <target state="translated">私の考えでは、余分な関数が必要なく、短いので、「単一の式」の部分のベストアンサーと考えています。</target>
        </trans-unit>
        <trans-unit id="28f989d802777ef28e3ed883ee8ae092d02eb42c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;z0&lt;/code&gt; and &lt;code&gt;z2&lt;/code&gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</source>
          <target state="translated">つまり、 &lt;code&gt;z0&lt;/code&gt; と &lt;code&gt;z2&lt;/code&gt; は基本的に同じパフォーマンスを持っているように見えます。 これは偶然かもしれないと思いますか？ 私はしません...</target>
        </trans-unit>
        <trans-unit id="9bc07c9c43a19f58510985e71e66d75a3b1147f6" translate="yes" xml:space="preserve">
          <source>In python3, the &lt;code&gt;items&lt;/code&gt; method &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;no longer returns a list&lt;/a&gt;, but rather a &lt;em&gt;view&lt;/em&gt;, which acts like a set. In this case you'll need to take the set union since concatenating with &lt;code&gt;+&lt;/code&gt; won't work:</source>
          <target state="translated">python3では、 &lt;code&gt;items&lt;/code&gt; メソッド&lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;はリスト&lt;/a&gt;ではなく、セットのように機能する&lt;em&gt;ビューを&lt;/em&gt; 返します 。 この場合、 &lt;code&gt;+&lt;/code&gt; を使用した連結は機能しないため、セットユニオンを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4b8950cb37108627db33c7d426aad3319f43c846" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;time&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;時間の&lt;/a&gt;面で：</target>
        </trans-unit>
        <trans-unit id="576c81f813e6d5c7574b2bff19e7f7a19584c5ed" translate="yes" xml:space="preserve">
          <source>In your case, what you can do is:</source>
          <target state="translated">あなたの場合は、何ができるかというと</target>
        </trans-unit>
        <trans-unit id="eb9849d8300f85b4b8946c3d18417f7afe6aef40" translate="yes" xml:space="preserve">
          <source>Instead, we get this:</source>
          <target state="translated">代わりにこれを手に入れる。</target>
        </trans-unit>
        <trans-unit id="613f9806d6fd6e5cb5f3886e4f538655d654d6e1" translate="yes" xml:space="preserve">
          <source>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</source>
          <target state="translated">前述のZ0や悪のZ2と同じくらいの速さですが、わかりやすく変化しやすいです。</target>
        </trans-unit>
        <trans-unit id="9270042b2f84bc91d9787a1d06a084ff6685203f" translate="yes" xml:space="preserve">
          <source>It is my understanding (as well as the understanding of the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;creator of the language&lt;/a&gt;) that the intended usage for &lt;code&gt;dict(**y)&lt;/code&gt; is for creating dicts for readability purposes, e.g.:</source>
          <target state="translated">&lt;code&gt;dict(**y)&lt;/code&gt; の使用目的が読みやすさを目的としたdictの&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;作成である&lt;/a&gt;ことが、私の理解（および言語の作成者の理解）です。たとえば、</target>
        </trans-unit>
        <trans-unit id="10e433f1aca9083f13e27caed8d5cca896a01f3e" translate="yes" xml:space="preserve">
          <source>It is now showing as implemented in the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;release schedule for 3.5, PEP 478&lt;/a&gt;, and it has now made its way into &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;What's New in Python 3.5&lt;/a&gt; document.</source>
          <target state="translated">現在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;、3.5、PEP 478のリリーススケジュールに&lt;/a&gt;実装されているように表示されており&lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;、Python 3.5の新機能の&lt;/a&gt;ドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="dea45706ebbfc3fa103ecf69ca8e21e9e39ff372" translate="yes" xml:space="preserve">
          <source>It's faster than &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; but not as fast as &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt;, at least on CPython. This version also works in Python 3 if you change &lt;code&gt;iteritems()&lt;/code&gt; to &lt;code&gt;items()&lt;/code&gt;, which is automatically done by the 2to3 tool.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; は高速ですが、 &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt; ほど高速ではありません。 n.update（b） 、少なくともCPython。 &lt;code&gt;iteritems()&lt;/code&gt; を &lt;code&gt;items()&lt;/code&gt; に変更すると、このバージョンはPython 3でも機能します。これは、2to3ツールによって自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="41964880e9b5b33a4ebc5a2e547cf6b1a1fe1386" translate="yes" xml:space="preserve">
          <source>It's so silly that &lt;code&gt;.update&lt;/code&gt; returns nothing.</source>
          <target state="translated">ばかげているので、 &lt;code&gt;.update&lt;/code&gt; は何も返しません。</target>
        </trans-unit>
        <trans-unit id="e8f3c6ca67433e529b1de06a8936ad80db4f01c3" translate="yes" xml:space="preserve">
          <source>Less Performant But Correct Ad-hocs</source>
          <target state="translated">パフォーマンスは低いが正しいアドホック</target>
        </trans-unit>
        <trans-unit id="47d53f050b02da45cdaa39f901ee75d32b02efe6" translate="yes" xml:space="preserve">
          <source>Lookups search the underlying mappings successively until a key is found.</source>
          <target state="translated">ルックアップは、キーが見つかるまで、基礎となるマッピングを連続的に検索します。</target>
        </trans-unit>
        <trans-unit id="f4717469d98280c4746039a514a7e2bacbf3bfde" translate="yes" xml:space="preserve">
          <source>Mapping two lists into a dictionary</source>
          <target state="translated">2つのリストを辞書にマッピングする</target>
        </trans-unit>
        <trans-unit id="f9f1aa4bbd26bc6ea841d2cf5df62d3193846a18" translate="yes" xml:space="preserve">
          <source>More comments:</source>
          <target state="translated">もっとコメントを。</target>
        </trans-unit>
        <trans-unit id="8ef25359578b2efe9adb36ef344ee5b9c98419fb" translate="yes" xml:space="preserve">
          <source>Mutating methods in the standard library (like &lt;code&gt;.update()&lt;/code&gt;) return &lt;code&gt;None&lt;/code&gt; by convention, so this pattern will work on those too. If you're using a method that doesn't follow this convention, then &lt;code&gt;or&lt;/code&gt; may not work. But, you can use a tuple display and index to make it a single expression, instead. This works regardless of what the first element evaluates to.</source>
          <target state="translated">標準ライブラリの変異メソッド（ &lt;code&gt;.update()&lt;/code&gt; など ）は慣例により &lt;code&gt;None&lt;/code&gt; を返すため、このパターンはそれらでも機能します。 この規則に従わない方法を使用している場合は、動作しない可能性があります。 ただし、タプル表示とインデックスを使用して、単一の式にすることができます。 これは、最初の要素が何に評価されるかに関係なく機能します。</target>
        </trans-unit>
        <trans-unit id="4a4fd9ea7e1bb91ce1c283ee8443542d3f4b5d79" translate="yes" xml:space="preserve">
          <source>My explanation of Python's &lt;strong&gt;dictionary implementation&lt;/strong&gt;, updated for 3.6.</source>
          <target state="translated">Pythonの&lt;strong&gt;ディクショナリ実装&lt;/strong&gt;に関する私の説明、3.6に更新。</target>
        </trans-unit>
        <trans-unit id="5451c5e024244f0cb1d2a834192850cb982c87b8" translate="yes" xml:space="preserve">
          <source>My response: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</source>
          <target state="translated">私の応答： &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; は、読みやすさを実際に懸念している場合、実際には私にははるかに明確に見えます。 また、Python 2のサポートは終了しているため、上位互換性はありません。</target>
        </trans-unit>
        <trans-unit id="a06152fa7c2b5a4be7f84d7628e46f2fff8180df" translate="yes" xml:space="preserve">
          <source>Not yet on Python 3.5, but want a &lt;em&gt;single expression&lt;/em&gt;</source>
          <target state="translated">まだPython 3.5ではありませんが、 &lt;em&gt;単一の式&lt;/em&gt;が必要です</target>
        </trans-unit>
        <trans-unit id="95a364312f027f57dff95eb6f993224d40d8d5d7" translate="yes" xml:space="preserve">
          <source>Note that we can merge in with literal notation as well:</source>
          <target state="translated">リテラル表記でもマージできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="85f3316c38e547312844b492fc59334cdc24d0e8" translate="yes" xml:space="preserve">
          <source>Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case.</source>
          <target state="translated">もちろん、結果をたくさん使う場合は、ある時点で、本当のマージされた辞書を作成した方が早い解決策であったであろう限界に達するでしょう。私が言ったように、それはあなたのユースケースに依存します。</target>
        </trans-unit>
        <trans-unit id="48ac36a7075dd373be352f2840bc51e3b09e06b1" translate="yes" xml:space="preserve">
          <source>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative &lt;code&gt;z2&lt;/code&gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the &lt;code&gt;timeit&lt;/code&gt; module that comes with Python.</source>
          <target state="translated">私のマシンでは、少なくとも（Python 2.5.2を実行しているごく普通のx86_64）、代替 &lt;code&gt;z2&lt;/code&gt; は短くて単純であるだけでなく、大幅に高速です。 Pythonに付属の &lt;code&gt;timeit&lt;/code&gt; モジュールを使用して、これを自分で確認できます。</target>
        </trans-unit>
        <trans-unit id="5693b010303f40e7b6b2989cf211c19701b8fd90" translate="yes" xml:space="preserve">
          <source>One would expect a result of something like this:</source>
          <target state="translated">一つは、このような結果を期待するだろう。</target>
        </trans-unit>
        <trans-unit id="36ccf0d2daf5f0450415093a23f65782376fed7c" translate="yes" xml:space="preserve">
          <source>Or even</source>
          <target state="translated">あるいは</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="af936431e91ad36e97d16ad3fcc34657b6a9c683" translate="yes" xml:space="preserve">
          <source>Performance Analysis</source>
          <target state="translated">パフォーマンス分析</target>
        </trans-unit>
        <trans-unit id="ccac62c217a26cb3460e444b60d39cb6b574af2e" translate="yes" xml:space="preserve">
          <source>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</source>
          <target state="translated">個人的にはこのバージョンが一番気に入っています。唯一の小さな問題は、yからの値がxからの値よりも優先されることが完全に明らかになっていないことですが、それを理解するのは難しいとは思いません。</target>
        </trans-unit>
        <trans-unit id="f2f88b2c502c6ef38181787f69def28accd2b7dd" translate="yes" xml:space="preserve">
          <source>Python 3.5 (PEP 448) allows a nicer syntax option:</source>
          <target state="translated">Python 3.5 (PEP 448)では、より良い構文オプションを使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="31fc173b6064c40551f851f890b41889dde4879b" translate="yes" xml:space="preserve">
          <source>Recursively/deep update a dict</source>
          <target state="translated">再帰的にディープにdictを更新</target>
        </trans-unit>
        <trans-unit id="e28a5f1ec1369c5c0c25a05a06b177d5f18ef2a0" translate="yes" xml:space="preserve">
          <source>Resources on Dictionaries</source>
          <target state="translated">辞書に関するリソース</target>
        </trans-unit>
        <trans-unit id="8e32dd9f3b57b6ccc2e40d0141dc5fa237e75edf" translate="yes" xml:space="preserve">
          <source>Response to comments</source>
          <target state="translated">コメントへの対応</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="0d93e84a8e035a40c9b757a07ddde97ea07443d0" translate="yes" xml:space="preserve">
          <source>Say you have two dicts and you want to merge them into a new dict without altering the original dicts:</source>
          <target state="translated">2つの辞書を持っていて、元の辞書を変更せずにそれらをマージして新しい辞書にしたいとします。</target>
        </trans-unit>
        <trans-unit id="e04ba6f40f9b2060e8c41a7b09e4e62c77d60e4e" translate="yes" xml:space="preserve">
          <source>Similarly, taking the union of &lt;code&gt;items()&lt;/code&gt; in Python 3 (&lt;code&gt;viewitems()&lt;/code&gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, &lt;strong&gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:&lt;/strong&gt;</source>
          <target state="translated">同様に、Python 3の &lt;code&gt;items()&lt;/code&gt; の結合（ Python 2.7の &lt;code&gt;viewitems()&lt;/code&gt; )は、値がハッシュできないオブジェクト（リストなど）の場合も失敗します。 値がハッシュ可能であっても&lt;strong&gt;、セットは意味的に順序付けられていないため、優先順位に関して動作は定義されていません。&lt;/strong&gt; &lt;strong&gt;したがって、これを行わないでください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a63b49fb1159980c455f7b80a5475a5b7a4bbded" translate="yes" xml:space="preserve">
          <source>Simple solution using itertools that preserves order (latter dicts have precedence)</source>
          <target state="translated">順番を保持する itertools を使った簡単な解決法 (後者の辞書が優先される)</target>
        </trans-unit>
        <trans-unit id="1ce6c799d807e8667caa62ff4d2ed81872b44880" translate="yes" xml:space="preserve">
          <source>Simple, readable, performant. You &lt;em&gt;know&lt;/em&gt;&lt;code&gt;update()&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt;, which is a false value. So the above expression will always evaluate to &lt;code&gt;x&lt;/code&gt;, after updating it.</source>
          <target state="translated">シンプルで読みやすく、高性能。 &lt;code&gt;update()&lt;/code&gt; は常に &lt;code&gt;None&lt;/code&gt; を返します。これはfalse値です。 したがって、上記の式は更新後、常に &lt;code&gt;x&lt;/code&gt; に評価されます。</target>
        </trans-unit>
        <trans-unit id="f32e703bd34c95af93956212150aad7a9788da7d" translate="yes" xml:space="preserve">
          <source>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</source>
          <target state="translated">そのため、ルックアップの速度は桁違いに遅い。私はChainmapのファンだが、検索数が多い場合には実用的ではなさそうだ。</target>
        </trans-unit>
        <trans-unit id="a8e2fa47ec0878caa65f8502de5b8cbd1c0786ed" translate="yes" xml:space="preserve">
          <source>Thanks rednaw for edits.</source>
          <target state="translated">rednawさん、編集ありがとうございます。</target>
        </trans-unit>
        <trans-unit id="d4d79546dfca81b3339e87ff38237ad185b2fb4d" translate="yes" xml:space="preserve">
          <source>The 'one' entry should have had 'depth_2' and 'extra' as items inside its dictionary if it truly was a merge.</source>
          <target state="translated">もし本当にマージされたのであれば、'one' エントリには 'depth_2' と 'extra' が辞書の中の項目として含まれているはずです。</target>
        </trans-unit>
        <trans-unit id="d3e70f05e7f6d91452e134d86664d8e73a4261ca" translate="yes" xml:space="preserve">
          <source>The best version I could think while not using copy would be:</source>
          <target state="translated">コピーを使わない間に考えられるベスト版はこれだろう。</target>
        </trans-unit>
        <trans-unit id="14a3e754832e898bf1e858d57c5ffe3967bb05c5" translate="yes" xml:space="preserve">
          <source>The deep merge that rcwesick gave also creates the same result.</source>
          <target state="translated">rcwesick が与えたディープマージでも同じ結果が得られます。</target>
        </trans-unit>
        <trans-unit id="a312af1c908fc9ad75fb286e3bc170573e2c6cc0" translate="yes" xml:space="preserve">
          <source>The desired result is to get a new dictionary (&lt;code&gt;z&lt;/code&gt;) with the values merged, and the second dict's values overwriting those from the first.</source>
          <target state="translated">望ましい結果は、値がマージされた新しい辞書（ &lt;code&gt;z&lt;/code&gt; ）を取得し、2番目の辞書の値が最初の辞書の値を上書きすることです。</target>
        </trans-unit>
        <trans-unit id="99cefd2e5a500633b962557b5eb27824141a25b8" translate="yes" xml:space="preserve">
          <source>The following is done on Ubuntu 14.04</source>
          <target state="translated">以下はUbuntu 14.04で行います。</target>
        </trans-unit>
        <trans-unit id="c3b7bd83073daf49138869cf80438ea437175ad6" translate="yes" xml:space="preserve">
          <source>The official Python &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;docs on dictionaries&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;辞書に関する&lt;/a&gt;公式のPython ドキュメント</target>
        </trans-unit>
        <trans-unit id="7a8b9b328f9958cca0a11b9acc4b8cd695c2636b" translate="yes" xml:space="preserve">
          <source>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</source>
          <target state="translated">これまでに挙げた解決策で私が抱えている問題は、マージされた辞書では、キー「b」の値が10であるが、私の考えでは12であるはずであるということである。その点を考慮して、以下のようにしてみました。</target>
        </trans-unit>
        <trans-unit id="9fcad77208db870fca468aadd90c4da8d6ce0d45" translate="yes" xml:space="preserve">
          <source>These approaches are less performant, but they will provide correct behavior.
They will be &lt;em&gt;much less&lt;/em&gt; performant than &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they &lt;em&gt;do&lt;/em&gt; respect the order of precedence (latter dicts have precedence)</source>
          <target state="translated">これらのアプローチはパフォーマンスが低下しますが、正しい動作を提供します。 それらは、より高い抽象化レベルで各キーと値のペアを反復処理するため、 &lt;code&gt;copy&lt;/code&gt; と &lt;code&gt;update&lt;/code&gt; または新しいアンパッキングよりもパフォーマンスが&lt;em&gt;はるかに低くなり&lt;/em&gt;ますが、優先順位を順守します（後の方が優先されます）。</target>
        </trans-unit>
        <trans-unit id="a0ea664e2a3188bf488d6c2a6055af74fb3539bf" translate="yes" xml:space="preserve">
          <source>This can be done with a single dict comprehension:</source>
          <target state="translated">これは、ディクテーションの理解度を1つにすることができます。</target>
        </trans-unit>
        <trans-unit id="36e6d4df98468539933d14acc5debf6efc5fe4ba" translate="yes" xml:space="preserve">
          <source>This can slow you down if you have a lot of lookups in your application:</source>
          <target state="translated">これは、アプリケーションに多くのルックアップがある場合には、速度を遅くすることができます。</target>
        </trans-unit>
        <trans-unit id="19c42edc088b07647e75e1b22d2ce503ca0cd824" translate="yes" xml:space="preserve">
          <source>This discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the &lt;code&gt;update&lt;/code&gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</source>
          <target state="translated">この議論にはまだ重要なものが欠けています。これは、これらの代替案と、2つのリストをマージする「明白な」方法、つまり &lt;code&gt;update&lt;/code&gt; メソッドを使用した場合のパフォーマンスの比較です。 式を使って物事を平等に保つことを試みるために、いずれもxまたはyを変更しないため、次のようにxをインプレースで変更するのではなく、コピーを作成します。</target>
        </trans-unit>
        <trans-unit id="dc1c7903eae69f6f9e6f83fcb5785373d15617e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates what happens when values are unhashable:</source>
          <target state="translated">この例では、価値観がハッシュ化されていない場合に何が起こるかを示しています。</target>
        </trans-unit>
        <trans-unit id="9157d19d33dc20ac6d37fac9da93fd7fa473ca0f" translate="yes" xml:space="preserve">
          <source>This function will work in Python 2 and 3 for all dicts. e.g. given dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">この関数は、Python 2および3ですべての辞書に対して機能します。 たとえば、辞書に &lt;code&gt;a&lt;/code&gt; から &lt;code&gt;g&lt;/code&gt; が与えられた場合 ：</target>
        </trans-unit>
        <trans-unit id="1dca0e3af9d62b26b6d4ca040a8f1540fe8eaa2f" translate="yes" xml:space="preserve">
          <source>This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</source>
          <target state="translated">Pythonの他の実装(Pypy,Jython,IronPython)では、この矛盾はよくありませんでした。Python 3では、この使用法が変更を妨げる可能性があるため、修正されました。</target>
        </trans-unit>
        <trans-unit id="3c565024f23a6cd2ae73023603f11cac8eb9232b" translate="yes" xml:space="preserve">
          <source>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</source>
          <target state="translated">これはおそらく一般的な答えにはなりませんが、ほとんどの場合、これを実行する必要はありません。 マージしたコピーが必要な場合は、copy（または、 &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;必要&lt;/a&gt;に応じてdeepcopy ）を使用してから更新します。 2行のコードは、.items（）+ .items（）を使用した1行の作成よりもはるかに読みやすく（Pythonicに近く）なります。 明示的は暗黙的よりも優れています。</target>
        </trans-unit>
        <trans-unit id="02a2f32a05821cacdddcb95030b2675f25361e82" translate="yes" xml:space="preserve">
          <source>This should solve your problem.</source>
          <target state="translated">これで問題は解決するはずです。</target>
        </trans-unit>
        <trans-unit id="686c1f44b9d06635a40727397360cca5fb0d76bc" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;dict&lt;/code&gt; constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</source>
          <target state="translated">これは &lt;code&gt;dict&lt;/code&gt; コンストラクターを使用し、非常に高速でメモリ効率がよい（2ステップのプロセスよりも少し多い）が、ここで何が起こっているかを正確に知らない限り（つまり、2番目のdictがキーワード引数としてdictコンストラクタ）、読みにくく、意図した使用法ではないため、Pythonicではありません。</target>
        </trans-unit>
        <trans-unit id="463fe46eebffb482307a2b0a04183fc401c2acf9" translate="yes" xml:space="preserve">
          <source>This will, as you want it, put the final dict in &lt;code&gt;z&lt;/code&gt;, and make the value for key &lt;code&gt;b&lt;/code&gt; be properly overridden by the second (&lt;code&gt;y&lt;/code&gt;) dict's value:</source>
          <target state="translated">これにより、必要に応じて、最後の辞書を &lt;code&gt;z&lt;/code&gt; に配置し 、キー &lt;code&gt;b&lt;/code&gt; の値を2番目の（ &lt;code&gt;y&lt;/code&gt; ）辞書の値で適切にオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="827f523c69cfc77e578e7347bfd913a0423d4505" translate="yes" xml:space="preserve">
          <source>Usage (tested in python 3):</source>
          <target state="translated">使用法 (python 3 でテスト済み)。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e8a5cd8514bfb309e8f3f05950c1200e457ea3dc" translate="yes" xml:space="preserve">
          <source>Using chain also, does not work:</source>
          <target state="translated">チェーンを使っても、うまくいきません。</target>
        </trans-unit>
        <trans-unit id="cfbc3d78519156ea4d38e12324b7f22474d7df90" translate="yes" xml:space="preserve">
          <source>When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed.</source>
          <target state="translated">この新しいオブジェクトを使用するとき、マージされた辞書のように振る舞いますが、オリジナルの辞書をそのままにしたまま、一定の作成時間と一定のメモリフットプリントを持ちます。このオブジェクトを作成することは、提案されている他のソリューションよりもはるかに安価です。</target>
        </trans-unit>
        <trans-unit id="2a93691216c27b37fa080f1bf21889060fcd92b2" translate="yes" xml:space="preserve">
          <source>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</source>
          <target state="translated">すでに何度か解答が出ていますが、この簡単な解答はまだ掲載されていません。</target>
        </trans-unit>
        <trans-unit id="cd809d0ef673f12b00a606ccbe54a8115b1c82af" translate="yes" xml:space="preserve">
          <source>Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I'll update this later once I write a method that does a true merge.</source>
          <target state="translated">そうですね、サンプル辞書をマージするのはうまくいきますが、どれもマージする汎用的な仕組みにはなっていません。真のマージを行うメソッドを書いたら、後でこれを更新します。</target>
        </trans-unit>
        <trans-unit id="2aa391717295fad536baefee8bd2d60a19871d4f" translate="yes" xml:space="preserve">
          <source>Yes. I must refer you back to the question, which is asking for a &lt;em&gt;shallow&lt;/em&gt; merge of &lt;strong&gt;&lt;em&gt;two&lt;/em&gt;&lt;/strong&gt; dictionaries, with the first's values being overwritten by the second's - in a single expression.</source>
          <target state="translated">はい。 1 &lt;strong&gt;&lt;em&gt;つ&lt;/em&gt;&lt;/strong&gt;の式で最初の値が2番目の値で上書きされるという2 &lt;strong&gt;&lt;em&gt;つの&lt;/em&gt;&lt;/strong&gt;辞書の&lt;em&gt;浅い&lt;/em&gt;マージを要求する質問に戻って参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee121489b6e0d4a946801627644c8e2674d2d13d" translate="yes" xml:space="preserve">
          <source>You can also chain the dicts manually inside a dict comprehension:</source>
          <target state="translated">また、ディクト理解の中で手動でディクトを連鎖させることもできます。</target>
        </trans-unit>
        <trans-unit id="e8a9e7391a7cebd4162276bf43babcfe429d286a" translate="yes" xml:space="preserve">
          <source>You can also make a function to merge an undefined number of dicts, from zero to a very large number:</source>
          <target state="translated">未定義の数のディクトをゼロから非常に大きな数までマージする関数を作ることもできます。</target>
        </trans-unit>
        <trans-unit id="d99a90478f3ad33b4d2bc5f254632c7bfd37d59d" translate="yes" xml:space="preserve">
          <source>You can also use this class to make a kind of copy-on-write dictionary:</source>
          <target state="translated">このクラスを使って、コピーオンライト辞書のようなものを作ることもできます。</target>
        </trans-unit>
        <trans-unit id="9cedfd6f2171ececea9d197f9ad610009dfddd7f" translate="yes" xml:space="preserve">
          <source>You could also do this of course if you don't care about copying it:</source>
          <target state="translated">コピーにこだわらなければ、もちろんこれもできます。</target>
        </trans-unit>
        <trans-unit id="58f29ce54e05025dbf326102828358d60d6406e0" translate="yes" xml:space="preserve">
          <source>You could also write this as</source>
          <target state="translated">として書くこともできます。</target>
        </trans-unit>
        <trans-unit id="3ef1d0278a40be0903df836eb1993ad9c45936ba" translate="yes" xml:space="preserve">
          <source>You could use a lambda instead.</source>
          <target state="translated">代わりにラムダを使えばいい</target>
        </trans-unit>
        <trans-unit id="3e45b5c2910ea1c81696ad9de828761856f8df26" translate="yes" xml:space="preserve">
          <source>You said you wanted one expression, so I abused &lt;code&gt;lambda&lt;/code&gt; to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</source>
          <target state="translated">1つの式が必要だと言ったので、 &lt;code&gt;lambda&lt;/code&gt; を悪用して名前をバインドし、タプルを使用してラムダの1つの式の制限を上書きしました。 緊張してください。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9158b7790079767a2ee5155681bc0537e04269f5" translate="yes" xml:space="preserve">
          <source>and key value pairs in &lt;code&gt;g&lt;/code&gt; will take precedence over dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;, and so on.</source>
          <target state="translated">そして、 &lt;code&gt;g&lt;/code&gt; のキーと値のペアは、辞書 &lt;code&gt;a&lt;/code&gt; から &lt;code&gt;f&lt;/code&gt; などに優先します。</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">そして今。</target>
        </trans-unit>
        <trans-unit id="6dc92c5dffb9e2875bb5be2d30824a953e7e8fee" translate="yes" xml:space="preserve">
          <source>and then you have a single expression:</source>
          <target state="translated">と、一つの式が出てきます。</target>
        </trans-unit>
        <trans-unit id="538141bce772b5861479742348306cced3786ed9" translate="yes" xml:space="preserve">
          <source>and you would have to explicitly create them as lists, e.g. &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt;. This is a waste of resources and computation power.</source>
          <target state="translated">そして、それらをリストとして明示的に作成する必要があります。例： &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt; 。 これはリソースと計算能力の浪費です。</target>
        </trans-unit>
        <trans-unit id="feeb579278407bb98d8960ea0156b0f057ac30d9" translate="yes" xml:space="preserve">
          <source>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</source>
          <target state="translated">トニーがするように、しかし(驚くことではありませんが)表記の違いは、パフォーマンスに測定可能な影響を与えないことが判明しました。自分に合った方を使ってください。もちろん、2ステートメントの方がはるかにわかりやすいという指摘は彼の言うとおりです。</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">に代えて</target>
        </trans-unit>
        <trans-unit id="c5d0aeaef87c64e87fa64d76c410acb93a6f6869" translate="yes" xml:space="preserve">
          <source>lead me to conclude that &lt;code&gt;z3&lt;/code&gt; is somewhat faster than &lt;code&gt;z1&lt;/code&gt;, but not nearly as fast as &lt;code&gt;z2&lt;/code&gt;.  Definitely not worth all the extra typing.</source>
          <target state="translated">&lt;code&gt;z3&lt;/code&gt; は &lt;code&gt;z1&lt;/code&gt; よりもいくらか高速ですが、 z2ほど高速ではないと結論付けました。 間違いなくすべての追加のタイピングの価値はありません。</target>
        </trans-unit>
        <trans-unit id="3846c179246b1e2fb787941b7f16f2f7ff81ff9b" translate="yes" xml:space="preserve">
          <source>or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</source>
          <target state="translated">または python 2.6 (そしておそらくジェネレータ式が導入された 2.4 の初期の頃)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
