<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/38987">
    <body>
      <group id="38987">
        <trans-unit id="762f1a0e69169610829fa8a43f4c74678cbb8a23" translate="yes" xml:space="preserve">
          <source>(For Python2.7* only; there are simpler solutions for Python3*.)</source>
          <target state="translated">(Python2.7 * 만 해당; Python3 *에 대한 더 간단한 솔루션이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="26cef14df0be957675f0530429b3a7bde6a3b375" translate="yes" xml:space="preserve">
          <source>(That is, of course, equivalent to &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)</source>
          <target state="translated">(물론 그것은 &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt; 와 동일하지만 파이썬 버전이 충분히 새 버전이라면 PEP 448 스타일을 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="c983206bb5c1b9997bd209ce2acce7e071f69644" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;or a&lt;/code&gt; bit in the &lt;code&gt;lambda&lt;/code&gt; is necessary because &lt;code&gt;dict.update&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt; on success.)</source>
          <target state="translated">&lt;code&gt;dict.update&lt;/code&gt; 는 성공시 항상 &lt;code&gt;None&lt;/code&gt; 을 반환하므로 &lt;code&gt;lambda&lt;/code&gt; &lt;code&gt;or a&lt;/code&gt; 비트 또는 비트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fc6520d839da1d73fe3d2dc5120a168296e3c8df" translate="yes" xml:space="preserve">
          <source>(To be extra-clear, the last-one-wins conflict-handling of &lt;code&gt;dict.update()&lt;/code&gt; is what I'm looking for as well.)</source>
          <target state="translated">(명확하게 &lt;code&gt;dict.update()&lt;/code&gt; , dict.update () 의 최후 1 위의 충돌 처리는 내가 찾고있는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="59798fb8386a0602fdd9b6380f0da9334a75b531" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - talk by Brandon Rhodes at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;Dictionary Even&lt;/a&gt; Mightier-Pycon 2017에서 Brandon Rhodes의 이야기</target>
        </trans-unit>
        <trans-unit id="8b08b9102b840351132b620d290b145d977714b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Modern Python Dictionaries, A Confluence of Great Ideas&lt;/a&gt; - talk by Raymond Hettinger at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;현대 파이썬 사전, 훌륭한 아이디어의 합류&lt;/a&gt; -Pycon 2017에서 Raymond Hettinger의 이야기</target>
        </trans-unit>
        <trans-unit id="64eaafdd6d026ca8e8e81c2df03a5ad7e0e4f273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; is still the most readable solution for Python 2. Readability counts.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; 는 여전히 Python 2에서 가장 읽기 쉬운 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="1bc9f47831b8850843d4bfab7500ddd5d5e01499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;itertools.chain&lt;/code&gt; will chain the iterators over the key-value pairs in the correct order:</source>
          <target state="translated">&lt;code&gt;itertools.chain&lt;/code&gt; 은 키-값 쌍 위에 반복자를 올바른 순서로 연결합니다 :</target>
        </trans-unit>
        <trans-unit id="8762df6a9a82f0b36d9893287201772efe7c7ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; has bad performance. See &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; 성능이 좋지 않습니다. &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/을&lt;/a&gt; 참조 하십시오</target>
        </trans-unit>
        <trans-unit id="b30516353c8b7de805be8527f19faa1ebcd7e111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but &lt;code&gt;z2&lt;/code&gt; always seems to come out ahead.  (If you get inconsistent results for the &lt;em&gt;same&lt;/em&gt; test, try passing in &lt;code&gt;-r&lt;/code&gt; with a number larger than the default 3.)</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; 는 3.5 배 정도 이깁니다. 다른 사전은 매우 다른 결과를 산출하는 것처럼 보이지만 &lt;code&gt;z2&lt;/code&gt; 는 항상 앞서 나오는 것처럼 보입니다. ( &lt;em&gt;동일한&lt;/em&gt; 테스트에 대해 일치하지 않는 결과가 나오면 기본값 3보다 큰 숫자로 &lt;code&gt;-r&lt;/code&gt; 을 전달하십시오.)</target>
        </trans-unit>
        <trans-unit id="73fb6424cfd11bb18a1c574f3c35c5c9d895216f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by about a factor of 10.  That's a pretty big win in my book!</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; 는 약 10의 요소로 이깁니다. 그것은 저의 책에서 꽤 큰 승리입니다!</target>
        </trans-unit>
        <trans-unit id="684683c3cfba4b7ae046f86966f4cf852b750b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{**x, **y}&lt;/code&gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</source>
          <target state="translated">&lt;code&gt;{**x, **y}&lt;/code&gt; 는 중첩 된 사전을 처리하지 않는 것 같습니다. 중첩 된 키의 내용은 단순히 덮어 쓰지 않고 병합되지 않습니다. [...] 나는 재귀 적으로 병합되지 않는 이러한 답변에 의해 화상을 입었고 아무도 그것을 언급하지 않은 것에 놀랐습니다. &quot;병합&quot;이라는 단어를 해석 할 때이 답변은 &quot;한 dict을 다른 dict로 업데이트&quot;하고 병합하지 않는 것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4acb6eec05cf3410b42a7e8367ceb7218e526e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;n 개의&lt;/em&gt; 사전&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c750c4b4d745d4a88f3eea8b03ce9ceff63b397a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Python 3.0 and later&lt;/strong&gt;, you can use &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt;&lt;code&gt;collections.ChainMap&lt;/code&gt;&lt;/a&gt; which groups multiple dicts or other mappings together to create a single, updateable view:</source>
          <target state="translated">&lt;strong&gt;Python 3.0 이상에서는&lt;/strong&gt; &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt; &lt;code&gt;collections.ChainMap&lt;/code&gt; &lt;/a&gt; 을 사용하여 여러 dict 또는 다른 매핑을 그룹화하여 업데이트 가능한 단일 뷰를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047862db1890195e52368684bf93f77d9a3b9706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this has become a popular answer, but it is important to point out that if &lt;code&gt;y&lt;/code&gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido is not a fan&lt;/a&gt;. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 대중적인 대답이되었지만 &lt;code&gt;y&lt;/code&gt; 가 문자열이 아닌 키를 가지고 있다면 이것이 작동한다는 사실은 CPython 구현 세부 사항을 남용한다는 것이며 Python 3에서는 작동하지 않는다는 것을 지적하는 것이 중요합니다 또는 PyPy, IronPython 또는 Jython에 있습니다. 또한 &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido는 팬이 아닙니다&lt;/a&gt; . 따라서 순방향 호환 또는 교차 구현 휴대용 코드에 대해서는이 기술을 권장 할 수 없습니다. 이는 완전히 피해야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="56c781e5adb8bad76d8066d046d1c97e28021043" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;두 사전&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d78daed80f94bbc7108a07b9e271b9fca2cca5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update for Python 3.5 and later&lt;/strong&gt;: You can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; extended dictionary packing and unpacking.  This is fast and easy:</source>
          <target state="translated">&lt;strong&gt;Python 3.5 이상 업데이트&lt;/strong&gt; : &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; 확장 사전 패킹 및 언 패킹을 사용할 수 있습니다. 이것은 빠르고 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4ad22f81594d7603a3fcfc3c26100cb43cf77997" translate="yes" xml:space="preserve">
          <source>A couple more points for python 3. First, note that the &lt;code&gt;dict(x, **y)&lt;/code&gt; trick won't work in python 3 unless the keys in &lt;code&gt;y&lt;/code&gt; are strings.</source>
          <target state="translated">파이썬 3에 대한 몇 가지 점이 더 있습니다. 첫째, &lt;code&gt;dict(x, **y)&lt;/code&gt; 의 키가 문자열이 아닌 한 dict (x, ** y) 트릭은 파이썬 3에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52323533fde1038ac6c3239bddef21ed2cd7faa9" translate="yes" xml:space="preserve">
          <source>A few quick tests, e.g.</source>
          <target state="translated">몇 가지 빠른 테스트, 예 :</target>
        </trans-unit>
        <trans-unit id="5b8d1b61a251a1f4f5f96af395d52351a9c2d234" translate="yes" xml:space="preserve">
          <source>A new syntax for this, proposed in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; and &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;available as of Python 3.5&lt;/a&gt;, is</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; 에서 제안되고 &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;Python 3.5&lt;/a&gt; 에서 사용할 수 있는 새로운 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d20312b0c332092c94533e037801b46f85f6ff75" translate="yes" xml:space="preserve">
          <source>A typical result:</source>
          <target state="translated">전형적인 결과 :</target>
        </trans-unit>
        <trans-unit id="79346271c215b10d408c3a24960c3a8434e1b144" translate="yes" xml:space="preserve">
          <source>Abuse leading to a one-expression solution for &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew의 답변에&lt;/a&gt; 대한 단일 표현 솔루션으로 이어지는 학대 :</target>
        </trans-unit>
        <trans-unit id="bc0fcdd15355dfc94d498254e338806fd4947b01" translate="yes" xml:space="preserve">
          <source>After comparing those two, I wondered if &lt;code&gt;z1&lt;/code&gt;'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</source>
          <target state="translated">이 두 가지를 비교 한 후 &lt;code&gt;z1&lt;/code&gt; 의 성능 저하가 두 항목 목록을 구성하는 오버 헤드로 인한 것일 수 있는지 궁금 해서이 변형이 더 잘 작동하는지 궁금해졌습니다.</target>
        </trans-unit>
        <trans-unit id="3e513e02e5ffef80d9363703f5c690e41e7d947a" translate="yes" xml:space="preserve">
          <source>Again, it doesn't work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. &lt;code&gt;dict&lt;/code&gt; broke this consistency in Python 2:</source>
          <target state="translated">키가 문자열이 아닌 경우에도 3에서 작동하지 않습니다. 암시 적 호출 계약은 네임 스페이스가 일반적인 dicts를 취하는 반면 사용자는 문자열 인 키워드 인수 만 전달해야한다는 것입니다. 다른 모든 소명은 그것을 시행했다. &lt;code&gt;dict&lt;/code&gt; 는 Python 2에서 이러한 일관성을 깨뜨 렸습니다.</target>
        </trans-unit>
        <trans-unit id="37903af1bb3d70c3129ae7ad37c51d78652644c4" translate="yes" xml:space="preserve">
          <source>Also, Raymond Hettinger's Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;answer&lt;/a&gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;from the docs&lt;/a&gt; it looks like it sequentially looks through a list of all the dicts for each lookup:</source>
          <target state="translated">또한 Raymond Hettinger의 Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;답변&lt;/a&gt; 은 인수로 임의의 수의 dicts를 취할 수 있기 때문에 매우 우아합니다. 그러나 &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;문서&lt;/a&gt; 에서 각 조회에 대한 모든 dicts 목록을 순차적으로 보는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="b0e9fc794244c2742a7d0ad09b5a05d65fe3ab05" translate="yes" xml:space="preserve">
          <source>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only):</source>
          <target state="translated">새로운 walrus 연산자 (Python 3.8+ 만 해당)를 다음과 다르게 사용하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d64aa96c0baf8816d369af41816223f0d24166b8" translate="yes" xml:space="preserve">
          <source>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life &lt;em&gt;Guido van Rossum&lt;/em&gt; himself!  Someone else suggested half of this, but did not put it in a function.</source>
          <target state="translated">이러한 그늘지고 모호한 답변 중에서도이 빛나는 예는 독재자가 &lt;em&gt;Guido van Rossum&lt;/em&gt; 생명의 독재자에 의해 승인 된 파이썬에서 받아쓰기를 통합하는 유일한 방법입니다! 다른 사람이 이것의 절반을 제안했지만 기능에 넣지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b52eb9c15df1a810d482d29e8ce9cd10a248294b" translate="yes" xml:space="preserve">
          <source>An alternative:</source>
          <target state="translated">대안:</target>
        </trans-unit>
        <trans-unit id="ad2a670b2ebfd8d5864a5b7bac3632cc392444b7" translate="yes" xml:space="preserve">
          <source>And it is indeed a single expression.</source>
          <target state="translated">그리고 그것은 실제로 하나의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="2a68af8ef2b2b3fa71a55eee3ef7e2c9f937685a" translate="yes" xml:space="preserve">
          <source>And it's usage:</source>
          <target state="translated">그리고 사용법 :</target>
        </trans-unit>
        <trans-unit id="b0b7becbe9ec6ad7a7d8f73a304a045dc8bff483" translate="yes" xml:space="preserve">
          <source>Another hack you should not use:</source>
          <target state="translated">사용하지 말아야 할 또 다른 핵 :</target>
        </trans-unit>
        <trans-unit id="a6df3197072e3a7d3b37983ee4cecb723db3ac60" translate="yes" xml:space="preserve">
          <source>Another, more concise, option:</source>
          <target state="translated">또 다른 간결한 옵션 :</target>
        </trans-unit>
        <trans-unit id="a90812f162710be72c6673269344a54ff85dec16" translate="yes" xml:space="preserve">
          <source>Answer on how to add new keys to a dictionary</source>
          <target state="translated">사전에 새 키를 추가하는 방법에 대한 답변</target>
        </trans-unit>
        <trans-unit id="209d65032f4cdd91a49f9731f909c0f76b26af8f" translate="yes" xml:space="preserve">
          <source>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call
  x.update(y) and return x&quot;. Personally I find it more despicable than
  cool.</source>
          <target state="translated">분명히 dict (x, ** y)는 &quot;call x.update (y) and return x&quot;에 대한 &quot;cool hack&quot;으로 돌아가고 있습니다. 개인적으로 나는 그것이 차가운 것보다 더 비열한 것을 안다.</target>
        </trans-unit>
        <trans-unit id="1107541abd6568cff679b7beb9d9536a95d8d98c" translate="yes" xml:space="preserve">
          <source>As suggested above, using two lines or writing a function is probably a better way to go.</source>
          <target state="translated">위에서 제안했듯이 두 줄을 사용하거나 함수를 작성하는 것이 더 좋은 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c0a490ce334822e1a4fa03338b9164ecf3e1d0a" translate="yes" xml:space="preserve">
          <source>Assuming two dictionary of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dicts from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</source>
          <target state="translated">사전의 두 사전을 가정하면 하나는 재귀 적으로 하나의 함수로 병합 할 수 있지만 두 소스 중 하나에서 dicts를 수정하지 않도록주의해야하며 값을 지정할 때 복사하지 않는 것이 가장 좋습니다. 키는 해시 가능해야하며 일반적으로 불변이므로 키를 복사하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dda59ae142911ee5f815e7544ec0051e45b17ef5" translate="yes" xml:space="preserve">
          <source>Be pythonic. Use a &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;comprehension&lt;/a&gt;:</source>
          <target state="translated">피 토닉이 되십시오. &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;이해력을&lt;/a&gt; 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="e3e400046d95f67ae3dc116f87dadd13f71f972a" translate="yes" xml:space="preserve">
          <source>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;&lt;/a&gt;.</source>
          <target state="translated">다른 값 유형에 대한 우발적 인 문제는이 질문의 범위를 훨씬 넘어서므로 &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;&quot;사전의 사전 병합&quot;에 대한 표준 질문에 대한 답변을 알려 드리겠습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ead0c8a43030e9b4ba9dfd6743570550ad79d67" translate="yes" xml:space="preserve">
          <source>Critiques of Other Answers</source>
          <target state="translated">다른 답변의 비판</target>
        </trans-unit>
        <trans-unit id="c6a7b52934eb4c501f4a60e0e15c80a5bef14889" translate="yes" xml:space="preserve">
          <source>Demonstration:</source>
          <target state="translated">Demonstration:</target>
        </trans-unit>
        <trans-unit id="92ec7b2214ef32933d24b7351f97a6c052ccdf23" translate="yes" xml:space="preserve">
          <source>Depending on the use case it might not be necessary to create a &quot;real&quot; merged dictionary of the given input dictionaries.  A &lt;em&gt;view&lt;/em&gt; which does this might be sufficient in many cases, i. e. an object which acts &lt;em&gt;like&lt;/em&gt; the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak.</source>
          <target state="translated">유스 케이스에 따라 지정된 입력 사전의 &quot;실제&quot;병합 된 사전을 작성하지 않아도됩니다. 이를 수행하는 &lt;em&gt;관점&lt;/em&gt; 은 많은 경우에 충분할 수 있습니다. 즉, 병합 된 사전 &lt;em&gt;처럼&lt;/em&gt; 작동하는 오브젝트는이를 완전히 계산하지 않아도됩니다. 말하자면 병합 된 사전의 게으른 버전입니다.</target>
        </trans-unit>
        <trans-unit id="cf8c4ba0db8a8656b2f2f14c9fc473f2d81f924b" translate="yes" xml:space="preserve">
          <source>Despite what Guido says, &lt;code&gt;dict(x, **y)&lt;/code&gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords.</source>
          <target state="translated">Guido의 말에도 불구하고 &lt;code&gt;dict(x, **y)&lt;/code&gt; 는 dict 사양과 일치합니다 (btw). 이것은 파이썬 2와 3 모두에서 작동합니다. 이것은 문자열 키에서만 작동한다는 사실은 키워드 매개 변수가 작동하는 방식의 직접적인 결과이며 dict의 단점이 아닙니다. ** 대신에 ** 연산자를 사용하여 메커니즘을 남용하지 않습니다. 실제로 **는 dicts를 키워드로 전달하도록 정확하게 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d03564e5b15ddf2ca88faedf123c311e047f26b" translate="yes" xml:space="preserve">
          <source>Dicts are intended to take hashable keys (e.g. frozensets or tuples), but &lt;strong&gt;this method fails in Python 3 when keys are not strings.&lt;/strong&gt;</source>
          <target state="translated">딕셔너리는 해시 가능 키 (예 : 고정 세트 또는 튜플)를 사용하려고하지만 &lt;strong&gt;키가 문자열이 아닌 경우 Python 3에서이 방법이 실패합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92d9a054b2288bd1fdd9bdb5e55a39fe412e39ab" translate="yes" xml:space="preserve">
          <source>Don't use what you see in the formerly accepted answer:</source>
          <target state="translated">이전에 받아 들여진 답변에 표시된 것을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ac898e4932c0e7dcb2f44c27b6aeabf7e53fc70c" translate="yes" xml:space="preserve">
          <source>Drawing on ideas here and elsewhere I've comprehended a function:</source>
          <target state="translated">여기와 다른 곳에서 아이디어를 작성하여 기능을 이해했습니다.</target>
        </trans-unit>
        <trans-unit id="6c434bcb6a9e583ddd9818e466c89cc4d9768234" translate="yes" xml:space="preserve">
          <source>Even though the answers were good for this &lt;em&gt;shallow&lt;/em&gt; dictionary, none of the methods defined here actually do a deep dictionary merge.</source>
          <target state="translated">이 &lt;em&gt;얕은&lt;/em&gt; 사전에는 답이 좋았지 만 여기에 정의 된 방법 중 어느 것도 실제로 깊은 사전 병합을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="534c40ca3d6e9c332fb24d30e24866a5884fdf3c" translate="yes" xml:space="preserve">
          <source>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</source>
          <target state="translated">예 1 : 연속 된 20 개의 정수를 자신에 매핑하는 동일한 사전 :</target>
        </trans-unit>
        <trans-unit id="5d6468775d296b285af2d4eb8a4fbae02366f7da" translate="yes" xml:space="preserve">
          <source>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</source>
          <target state="translated">예제 2 : 겹치지 않는 사전은 252 개의 짧은 문자열을 정수로 매핑하거나 그 반대로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="51725d04b42e48c95f79400a9ef4bf6dd25aa363" translate="yes" xml:space="preserve">
          <source>Examples follow:</source>
          <target state="translated">예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="417f84c0ab231efe074c376811a745ff0bbaefae" translate="yes" xml:space="preserve">
          <source>For dictionaries &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; becomes a shallowly merged dictionary with values from &lt;code&gt;y&lt;/code&gt; replacing those from &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우 &lt;code&gt;z&lt;/code&gt; 는 x의 값을 바꾸는 &lt;code&gt;y&lt;/code&gt; 의 값으로 얕은 병합 된 사전이됩니다.</target>
        </trans-unit>
        <trans-unit id="5a7a48fc65c8ec5e1d37a7ac34c58a2610a8718b" translate="yes" xml:space="preserve">
          <source>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</source>
          <target state="translated">두 사전 ( 'b')에 키가있는 항목의 경우, 마지막에 두어 출력에서 ​​어느 것을 끝내는지를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66e4468118f12a49669432b591f48cae1db2757b" translate="yes" xml:space="preserve">
          <source>For python3-like behavior in version 2.7, the &lt;code&gt;viewitems&lt;/code&gt; method should work in place of &lt;code&gt;items&lt;/code&gt;:</source>
          <target state="translated">버전 2.7의 python3과 유사한 동작의 경우 &lt;code&gt;viewitems&lt;/code&gt; 메소드가 &lt;code&gt;items&lt;/code&gt; 대신 작동해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="05f303d92888701b00a3dca7391b2cd0ede31839" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;mailing list&lt;/a&gt;, Guido van Rossum, the creator of the language, wrote:</source>
          <target state="translated">&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;메일 링리스트&lt;/a&gt; 에서 언어를 만든 Guido van Rossum은 다음과 같이 썼습니다.</target>
        </trans-unit>
        <trans-unit id="9f63a1b687b569fbbc0abd2c72572d74cf9da35c" translate="yes" xml:space="preserve">
          <source>Here's an example of the usage being &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;remediated in django&lt;/a&gt;.</source>
          <target state="translated">다음 &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;은 django에서&lt;/a&gt; 사용되는 사용법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="7fca813712109d4e2606defe725d888aa50dabf0" translate="yes" xml:space="preserve">
          <source>Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:</source>
          <target state="translated">다음은 y가 우선해야하는 예입니다. 대신 x의 값은 임의의 세트 순서로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="eebe1dc7075416ba2cee50e9bcf95a9e8f656e14" translate="yes" xml:space="preserve">
          <source>Here's the straight-forward code of &lt;code&gt;MergeDict&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;MergeDict&lt;/code&gt; 의 간단한 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22cca235a9f80cdc5840a3a67ad0dfe9f75c41d8" translate="yes" xml:space="preserve">
          <source>How can I get that final merged dictionary in &lt;code&gt;z&lt;/code&gt;, not &lt;code&gt;x&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 아닌 &lt;code&gt;z&lt;/code&gt; 에서 최종 병합 사전을 어떻게 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5b9ed01b74e3b861c8ed3f17f0beccfffc6b9b9b" translate="yes" xml:space="preserve">
          <source>How can I merge two Python dictionaries in a single expression?</source>
          <target state="translated">두 개의 파이썬 사전을 단일 표현식으로 병합하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8cb6e8e8ba5fdf4ce9658d5ca8f5d8770c5e9e85" translate="yes" xml:space="preserve">
          <source>How do I merge two dictionaries in a single expression</source>
          <target state="translated">두 개의 사전을 단일 표현식으로 병합하는 방법</target>
        </trans-unit>
        <trans-unit id="c8ef4565722ce18107b48e5f9a668982765902bd" translate="yes" xml:space="preserve">
          <source>However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</source>
          <target state="translated">그러나 많은 조직이 여전히 Python 2를 사용하고 있으므로 이전 버전과 호환되는 방식으로이 작업을 수행 할 수 있습니다. Python 2 및 Python 3.0-3.4에서 사용할 수있는 고전적인 Pythonic 방식은이 작업을 2 단계 프로세스로 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9e2146fc3d130671f68d310625226e3ccce8eab" translate="yes" xml:space="preserve">
          <source>I am fine with
  declaring dict({}, **{1:3}) illegal, since after all it is abuse of
  the ** mechanism.</source>
          <target state="translated">나는 dict ({}, ** {1 : 3})을 불법으로 선언하는 것이 좋습니다. 결국 ** 메커니즘을 남용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="11606279b4a4e0c3d7cb38ec7e13e08435b369e0" translate="yes" xml:space="preserve">
          <source>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The &lt;code&gt;update()&lt;/code&gt; method would be what I need, if it returned its result instead of modifying a dictionary in-place.</source>
          <target state="translated">나는 두 개의 파이썬 사전을 가지고 있으며이 두 사전을 반환하는 단일 표현식을 병합하려고합니다. &lt;code&gt;update()&lt;/code&gt; 메소드는 사전을 수정하지 않고 결과를 반환하면 필요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="56b9ab3e4817a98d072aafad2224e1acb41d827f" translate="yes" xml:space="preserve">
          <source>I just use a simple helper function to solve the problem:</source>
          <target state="translated">간단한 도우미 함수를 사용하여 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="01c87e18558e3526b4877129f79e0ec875c6b499" translate="yes" xml:space="preserve">
          <source>I know this does not really fit the specifics of the questions (&quot;one liner&quot;), but since &lt;em&gt;none&lt;/em&gt; of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts.</source>
          <target state="translated">나는 이것이 질문의 구체적 내용 ( &quot;하나의 라이너&quot;)에 맞지 않는다는 것을 알고 있지만, 위의 답변 &lt;em&gt;중 어느 것도이&lt;/em&gt; 방향으로 진행 &lt;em&gt;되지 않았고&lt;/em&gt; 많은 답변이 성능 문제를 해결했기 때문에 내 생각에 기여해야한다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="bfc266b6f982c3a928236a92c629662068d1aa8b" translate="yes" xml:space="preserve">
          <source>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</source>
          <target state="translated">어쨌든이 표기법을 선호합니다 (제목이 보여 주듯이)를 연결하기보다 정해진 조합 작업으로 생각하는 것이 더 자연 스럽기 때문에 선호합니다.</target>
        </trans-unit>
        <trans-unit id="375e440687d005ef88e88f34c7f99f4a5ac588c4" translate="yes" xml:space="preserve">
          <source>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</source>
          <target state="translated">한 버전의 언어에서만 작동하거나 특정 임의의 제약 조건에서만 작동하는 코드를 의도적으로 작성하는 것은 악의적 인 무능함이라고 귀하에게 제출합니다.</target>
        </trans-unit>
        <trans-unit id="7bb9b5043cf7f5771f44311a303420b28a455fba" translate="yes" xml:space="preserve">
          <source>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</source>
          <target state="translated">비슷한 것을 원했지만 중복 키의 값을 병합하는 방법을 지정할 수있는 기능을 사용하여이를 해킹했습니다 (그러나 많이 테스트하지는 않았습니다). 분명히 이것은 단일 표현식이 아니라 단일 함수 호출입니다.</target>
        </trans-unit>
        <trans-unit id="78af1cea1dc16ea253286cd3b93d54839ede508a" translate="yes" xml:space="preserve">
          <source>I'm only going to do the performance analysis of the usages known to behave correctly.</source>
          <target state="translated">나는 올바르게 작동하는 것으로 알려진 사용법의 성능 분석 만 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b18b7815200328ded8232a4d1a242e6497d1f7f" translate="yes" xml:space="preserve">
          <source>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</source>
          <target state="translated">IMO 첫 두 개 사이의 작은 속도 저하는 가독성을 위해 가치가 있습니다. 또한 사전 생성을위한 키워드 인수는 Python 2.3에서만 추가되었지만 copy () 및 update ()는 이전 버전에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="80cd4b20ecfc8fde8f0d9999c7ceff52e8d8b72a" translate="yes" xml:space="preserve">
          <source>If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a &lt;em&gt;single expression&lt;/em&gt;, the most performant while correct approach is to put it in a function:</source>
          <target state="translated">아직 Python 3.5를 사용하지 않거나 이전 버전과 호환되는 코드를 작성해야하고 &lt;em&gt;단일 표현식으로 작성&lt;/em&gt; 하려는 경우 올바른 접근 방식은 코드를 함수에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58f39817135947f0339519f69b794e849b094fff" translate="yes" xml:space="preserve">
          <source>If you do want a copy, PEP 448 style is easiest &lt;code&gt;{**x, **y}&lt;/code&gt;. But if that's not available in your (older) Python version, the &lt;em&gt;let&lt;/em&gt; pattern works here too.</source>
          <target state="translated">사본을 원하면 PEP 448 스타일이 가장 쉬운 &lt;code&gt;{**x, **y}&lt;/code&gt; 입니다. 그러나 (이전의) Python 버전에서 사용할 수 없다면 &lt;em&gt;let&lt;/em&gt; 패턴도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c68f13df74f8081969ebc7396a5bdbb15beb7948" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;x&lt;/code&gt; in a variable yet, you can use &lt;code&gt;lambda&lt;/code&gt; to make a local without using an assignment statement. This amounts to using &lt;code&gt;lambda&lt;/code&gt; as a &lt;em&gt;let expression&lt;/em&gt;, which is a common technique in functional languages, but maybe unpythonic.</source>
          <target state="translated">변수에 &lt;code&gt;x&lt;/code&gt; 가 없으면 &lt;code&gt;lambda&lt;/code&gt; 를 사용하여 대 입문을 사용하지 않고 지역을 만들 수 있습니다. 이것은 &lt;code&gt;lambda&lt;/code&gt; 를 &lt;em&gt;let expression&lt;/em&gt; 으로 사용하는데, 이는 기능적 언어에서 일반적인 기술이지만 파이썬이 아닌 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e67f1fbb5c4630089b3b15e7da7f230c6351803" translate="yes" xml:space="preserve">
          <source>If you don't mind mutating &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 돌연변이에 신경 쓰지 않으면</target>
        </trans-unit>
        <trans-unit id="23112b4c7ee35913e4183cf954bd3fbb6f22db7a" translate="yes" xml:space="preserve">
          <source>If you ever felt you would prefer to have a real merged &lt;code&gt;dict&lt;/code&gt;, then calling &lt;code&gt;dict(z)&lt;/code&gt; would produce it (but way more costly than the other solutions of course, so this is just worth mentioning).</source>
          <target state="translated">실제 병합 된 &lt;code&gt;dict&lt;/code&gt; 을 선호한다고 느낀다면 &lt;code&gt;dict(z)&lt;/code&gt; 를 호출하면 생성됩니다 (그러나 다른 솔루션보다 비용이 많이들므로 언급 할 가치가 있습니다).</target>
        </trans-unit>
        <trans-unit id="91c65288fd2cb6d1ebcbffd2f95dcc6f769de027" translate="yes" xml:space="preserve">
          <source>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</source>
          <target state="translated">람다가 악하다고 생각하면 더 이상 읽지 마십시오. 요청에 따라 하나의 식으로 빠르고 메모리 효율적인 솔루션을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3eb5dd9b8564f262213b8ec581f34343fb1155" translate="yes" xml:space="preserve">
          <source>If you use Python 3, it is only a little more complicated.  To create &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">Python 3을 사용하면 조금 더 복잡합니다. &lt;code&gt;z&lt;/code&gt; 를 만들려면</target>
        </trans-unit>
        <trans-unit id="d340b513c30c260578d2c3eadac2366554f22a75" translate="yes" xml:space="preserve">
          <source>If you're not averse to importing a standard library module, you can do</source>
          <target state="translated">표준 라이브러리 모듈을 가져 오지 않으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a4d62fbeb1dc986c159aff37fcf7e409f975fec3" translate="yes" xml:space="preserve">
          <source>In Python 2, (or 3.4 or lower) write a function:</source>
          <target state="translated">Python 2에서 (또는 3.4 이하) 함수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cddaaf9db6625675addbc60941262561bfd51d86" translate="yes" xml:space="preserve">
          <source>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. &lt;strong&gt;In Python 3, this will fail&lt;/strong&gt; because you're adding two &lt;code&gt;dict_items&lt;/code&gt; objects together, not two lists -</source>
          <target state="translated">Python 2에서는 각 dict에 대해 메모리에 두 개의 목록을 작성하고 처음 두 개의 길이와 같은 길이의 메모리에 세 번째 목록을 작성한 다음 세 목록을 모두 버리고 dict를 작성하십시오. &lt;strong&gt;Python 3에서는&lt;/strong&gt; 두 개의 목록이 아닌 두 개의 &lt;code&gt;dict_items&lt;/code&gt; 객체를 함께 추가하기 때문에 &lt;strong&gt;실패&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c145a8d3b1ebc6e2271fc27dc8537d7fd274de6b" translate="yes" xml:space="preserve">
          <source>In Python 2.7 (system Python):</source>
          <target state="translated">Python 2.7 (시스템 Python)에서 :</target>
        </trans-unit>
        <trans-unit id="c0da467e5ff897c9e6741e6911edbfc2c8e28314" translate="yes" xml:space="preserve">
          <source>In Python 3.5 (deadsnakes PPA):</source>
          <target state="translated">Python 3.5 (deadsnakes PPA)에서 :</target>
        </trans-unit>
        <trans-unit id="61986f9755b6245f3a2d4cfab600c14ea75b062c" translate="yes" xml:space="preserve">
          <source>In Python 3.5 or greater:</source>
          <target state="translated">Python 3.5 이상에서 :</target>
        </trans-unit>
        <trans-unit id="7c246f03cced22905d4e5edbf31a21a72dfa1e56" translate="yes" xml:space="preserve">
          <source>In Python 3.9.0a4 or greater (final release date approx October 2020): &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;discussed here&lt;/a&gt;, was implemented to further simplify this:</source>
          <target state="translated">Python 3.9.0a4 이상 (최종 출시일 약 2020 년 10 월) : &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;여기&lt;/a&gt; 에서 논의 된 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt; 가이를 더욱 단순화하기 위해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb06defc9c6c89decb004ddee3cc8e2971971de4" translate="yes" xml:space="preserve">
          <source>In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be:</source>
          <target state="translated">파이썬에서 이것은 다소 간단하며 게시물 끝에 표시된 코드로 수행 할 수 있습니다. 이를 통해 원래 질문에 대한 답변은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2694d72958aa5476affbdd9f1fa8e1fb6ade5022" translate="yes" xml:space="preserve">
          <source>In a follow-up answer, you asked about the relative performance of these two alternatives:</source>
          <target state="translated">후속 답변에서이 두 대안의 상대적 성능에 대해 물었습니다.</target>
        </trans-unit>
        <trans-unit id="fc9fa0b91a747b146f5bf2910dc05830d2caba46" translate="yes" xml:space="preserve">
          <source>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</source>
          <target state="translated">또한 .items () (Python 3.0 이전)를 사용하면 dict의 항목을 포함하는 새 목록을 만듭니다. 사전이 크면 오버 헤드가 많이 발생합니다 (병합 된 dict가 작성되는 즉시 버려 질 두 개의 큰 목록). update ()는 항목별로 두 번째 dict을 실행할 수 있기 때문에 더 효율적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd84518801f2e66815fcf3f25a609ccfebd7ea62" translate="yes" xml:space="preserve">
          <source>In both approaches, &lt;code&gt;y&lt;/code&gt; will come second and its values will replace &lt;code&gt;x&lt;/code&gt;'s values, thus &lt;code&gt;'b'&lt;/code&gt; will point to &lt;code&gt;3&lt;/code&gt; in our final result.</source>
          <target state="translated">두 가지 방법 모두에서 &lt;code&gt;y&lt;/code&gt; 는 두 번째가되고 그 값은 &lt;code&gt;x&lt;/code&gt; 의 값을 대체하므로 &lt;code&gt;'b'&lt;/code&gt; 는 최종 결과에서 &lt;code&gt;3&lt;/code&gt; 을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="3840c97bb862e7304c6e3f15f1b99fb6f44f7a27" translate="yes" xml:space="preserve">
          <source>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses &lt;code&gt;dict&lt;/code&gt; in lots of places; optimizing its operations is a big deal.</source>
          <target state="translated">사실, 순수한 파이썬 코드가 이것보다 더 나은 것은 불가능하다고 주장하기까지하였습니다. 그리고 C 확장 모듈에서 훨씬 더 잘 할 수 있다면, 파이썬 사람들이 코드 (또는 접근 방식의 변형)를 파이썬 코어에 통합하는 데 관심이 있다고 생각합니다. 파이썬은 많은 곳에서 &lt;code&gt;dict&lt;/code&gt; 를 사용합니다. 운영 최적화는 큰 문제입니다.</target>
        </trans-unit>
        <trans-unit id="bb531282f9af11f54c3641bdd4af885240f75d4e" translate="yes" xml:space="preserve">
          <source>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</source>
          <target state="translated">필자의 견해로는 추가 함수가 필요하지 않으므로 '단일 표현'부분에 대한 가장 좋은 대답은 짧습니다.</target>
        </trans-unit>
        <trans-unit id="28f989d802777ef28e3ed883ee8ae092d02eb42c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;z0&lt;/code&gt; and &lt;code&gt;z2&lt;/code&gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</source>
          <target state="translated">즉, &lt;code&gt;z0&lt;/code&gt; 과 &lt;code&gt;z2&lt;/code&gt; 는 본질적으로 동일한 성능을 가진 것으로 보입니다. 이것이 우연의 일치라고 생각하십니까? 난 ...</target>
        </trans-unit>
        <trans-unit id="9bc07c9c43a19f58510985e71e66d75a3b1147f6" translate="yes" xml:space="preserve">
          <source>In python3, the &lt;code&gt;items&lt;/code&gt; method &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;no longer returns a list&lt;/a&gt;, but rather a &lt;em&gt;view&lt;/em&gt;, which acts like a set. In this case you'll need to take the set union since concatenating with &lt;code&gt;+&lt;/code&gt; won't work:</source>
          <target state="translated">python3에서 &lt;code&gt;items&lt;/code&gt; 메소드 &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;는 더 이상 list&lt;/a&gt; 처럼 보이지 않고 오히려 &lt;em&gt;view&lt;/em&gt; 처럼 리턴합니다 . 이 경우 &lt;code&gt;+&lt;/code&gt; 와 연결이 작동하지 않으므로 set union을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b8950cb37108627db33c7d426aad3319f43c846" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;time&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;시간&lt;/a&gt; 측면에서 :</target>
        </trans-unit>
        <trans-unit id="576c81f813e6d5c7574b2bff19e7f7a19584c5ed" translate="yes" xml:space="preserve">
          <source>In your case, what you can do is:</source>
          <target state="translated">귀하의 경우 할 수있는 일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb9849d8300f85b4b8946c3d18417f7afe6aef40" translate="yes" xml:space="preserve">
          <source>Instead, we get this:</source>
          <target state="translated">대신, 우리는 이것을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="613f9806d6fd6e5cb5f3886e4f538655d654d6e1" translate="yes" xml:space="preserve">
          <source>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</source>
          <target state="translated">위에서 언급 한 z0 및 z2만큼 빠르지 만 이해하고 변경하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9270042b2f84bc91d9787a1d06a084ff6685203f" translate="yes" xml:space="preserve">
          <source>It is my understanding (as well as the understanding of the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;creator of the language&lt;/a&gt;) that the intended usage for &lt;code&gt;dict(**y)&lt;/code&gt; is for creating dicts for readability purposes, e.g.:</source>
          <target state="translated">&lt;code&gt;dict(**y)&lt;/code&gt; 의 의도 된 사용법은 가독성을위한 dicts 작성을위한 것임을 이해 &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;하고 있습니다&lt;/a&gt; ( 예 : 언어 작성자의 이해 ) .</target>
        </trans-unit>
        <trans-unit id="10e433f1aca9083f13e27caed8d5cca896a01f3e" translate="yes" xml:space="preserve">
          <source>It is now showing as implemented in the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;release schedule for 3.5, PEP 478&lt;/a&gt;, and it has now made its way into &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;What's New in Python 3.5&lt;/a&gt; document.</source>
          <target state="translated">이제 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;3.5, PEP 478 릴리스 일정에&lt;/a&gt; 구현 된 것으로 표시되며 이제 &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;Python 3.5&lt;/a&gt; 문서 의 새로운 기능 으로 전환되었습니다.</target>
        </trans-unit>
        <trans-unit id="dea45706ebbfc3fa103ecf69ca8e21e9e39ff372" translate="yes" xml:space="preserve">
          <source>It's faster than &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; but not as fast as &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt;, at least on CPython. This version also works in Python 3 if you change &lt;code&gt;iteritems()&lt;/code&gt; to &lt;code&gt;items()&lt;/code&gt;, which is automatically done by the 2to3 tool.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; 보다 빠르지 만 &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt; 만큼 빠르지는 않습니다 . 적어도 CPython에서 n.update (b) . 이 버전은 &lt;code&gt;iteritems()&lt;/code&gt; 를 &lt;code&gt;items()&lt;/code&gt; 로 변경하면 Python 3에서도 작동합니다. 이것은 2to3 도구에 의해 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="41964880e9b5b33a4ebc5a2e547cf6b1a1fe1386" translate="yes" xml:space="preserve">
          <source>It's so silly that &lt;code&gt;.update&lt;/code&gt; returns nothing.</source>
          <target state="translated">&lt;code&gt;.update&lt;/code&gt; 가 아무것도 반환하지 않는 것은 너무 바보입니다.</target>
        </trans-unit>
        <trans-unit id="e8f3c6ca67433e529b1de06a8936ad80db4f01c3" translate="yes" xml:space="preserve">
          <source>Less Performant But Correct Ad-hocs</source>
          <target state="translated">성능이 떨어지지 만 정확한 애드혹</target>
        </trans-unit>
        <trans-unit id="47d53f050b02da45cdaa39f901ee75d32b02efe6" translate="yes" xml:space="preserve">
          <source>Lookups search the underlying mappings successively until a key is found.</source>
          <target state="translated">조회는 키를 찾을 때까지 기본 매핑을 연속적으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f4717469d98280c4746039a514a7e2bacbf3bfde" translate="yes" xml:space="preserve">
          <source>Mapping two lists into a dictionary</source>
          <target state="translated">두 목록을 사전에 매핑</target>
        </trans-unit>
        <trans-unit id="f9f1aa4bbd26bc6ea841d2cf5df62d3193846a18" translate="yes" xml:space="preserve">
          <source>More comments:</source>
          <target state="translated">더 많은 의견 :</target>
        </trans-unit>
        <trans-unit id="8ef25359578b2efe9adb36ef344ee5b9c98419fb" translate="yes" xml:space="preserve">
          <source>Mutating methods in the standard library (like &lt;code&gt;.update()&lt;/code&gt;) return &lt;code&gt;None&lt;/code&gt; by convention, so this pattern will work on those too. If you're using a method that doesn't follow this convention, then &lt;code&gt;or&lt;/code&gt; may not work. But, you can use a tuple display and index to make it a single expression, instead. This works regardless of what the first element evaluates to.</source>
          <target state="translated">표준 라이브러리에서 &lt;code&gt;.update()&lt;/code&gt; 와 같은 메서드를 변경하면 규칙에 따라 &lt;code&gt;None&lt;/code&gt; 이 반환되므로이 패턴도 작동합니다. 이 규칙을 따르지 않는 방법을 사용하는 경우 작동하지 않거나 작동하지 않을 수 있습니다. 그러나 튜플 디스플레이 및 인덱스를 사용하여 단일 표현식으로 만들 수 있습니다. 이것은 첫 번째 요소가 무엇을 평가하는지에 관계없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4a4fd9ea7e1bb91ce1c283ee8443542d3f4b5d79" translate="yes" xml:space="preserve">
          <source>My explanation of Python's &lt;strong&gt;dictionary implementation&lt;/strong&gt;, updated for 3.6.</source>
          <target state="translated">파이썬 &lt;strong&gt;사전 구현에&lt;/strong&gt; 대한 나의 설명은 3.6으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="5451c5e024244f0cb1d2a834192850cb982c87b8" translate="yes" xml:space="preserve">
          <source>My response: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</source>
          <target state="translated">내 응답 : &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; 는 실제로 가독성에 관심이 있다면 실제로 나에게 훨씬 명확 해 보입니다. 그리고 파이썬 2가 점점 더 이상 사용되지 않으므로 앞으로 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a06152fa7c2b5a4be7f84d7628e46f2fff8180df" translate="yes" xml:space="preserve">
          <source>Not yet on Python 3.5, but want a &lt;em&gt;single expression&lt;/em&gt;</source>
          <target state="translated">아직 Python 3.5에서는 없지만 &lt;em&gt;단일 표현식을&lt;/em&gt; 원합니다.</target>
        </trans-unit>
        <trans-unit id="95a364312f027f57dff95eb6f993224d40d8d5d7" translate="yes" xml:space="preserve">
          <source>Note that we can merge in with literal notation as well:</source>
          <target state="translated">리터럴 표기법과 병합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f3316c38e547312844b492fc59334cdc24d0e8" translate="yes" xml:space="preserve">
          <source>Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case.</source>
          <target state="translated">물론 결과를 많이 사용하면 실제 병합 사전을 만드는 것이 더 빠른 솔루션이 될 수있는 한계에 도달하게됩니다. 내가 말했듯이 사용 사례에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="48ac36a7075dd373be352f2840bc51e3b09e06b1" translate="yes" xml:space="preserve">
          <source>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative &lt;code&gt;z2&lt;/code&gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the &lt;code&gt;timeit&lt;/code&gt; module that comes with Python.</source>
          <target state="translated">내 컴퓨터에서 (파이썬 2.5.2를 실행하는 상당히 평범한 x86_64) 대체 &lt;code&gt;z2&lt;/code&gt; 는 짧고 간단 할뿐만 아니라 훨씬 빠릅니다. Python과 함께 제공되는 &lt;code&gt;timeit&lt;/code&gt; 모듈을 사용하여이를 직접 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5693b010303f40e7b6b2989cf211c19701b8fd90" translate="yes" xml:space="preserve">
          <source>One would expect a result of something like this:</source>
          <target state="translated">다음과 같은 결과를 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ccf0d2daf5f0450415093a23f65782376fed7c" translate="yes" xml:space="preserve">
          <source>Or even</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="af936431e91ad36e97d16ad3fcc34657b6a9c683" translate="yes" xml:space="preserve">
          <source>Performance Analysis</source>
          <target state="translated">성능 분석</target>
        </trans-unit>
        <trans-unit id="ccac62c217a26cb3460e444b60d39cb6b574af2e" translate="yes" xml:space="preserve">
          <source>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</source>
          <target state="translated">개인적으로이 버전은 단일 기능 구문에서 원하는 것을 상당히 잘 설명하기 때문에 가장 좋습니다. 유일한 사소한 문제는 y의 값이 x의 값보다 우선한다는 것이 완전히 명확하지 않다는 것입니다. 그러나 나는 그것을 알아내는 것이 어렵다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2f88b2c502c6ef38181787f69def28accd2b7dd" translate="yes" xml:space="preserve">
          <source>Python 3.5 (PEP 448) allows a nicer syntax option:</source>
          <target state="translated">Python 3.5 (PEP 448)는 더 좋은 구문 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="31fc173b6064c40551f851f890b41889dde4879b" translate="yes" xml:space="preserve">
          <source>Recursively/deep update a dict</source>
          <target state="translated">재귀 적 / 영향 업데이트</target>
        </trans-unit>
        <trans-unit id="e28a5f1ec1369c5c0c25a05a06b177d5f18ef2a0" translate="yes" xml:space="preserve">
          <source>Resources on Dictionaries</source>
          <target state="translated">사전에 대한 자료</target>
        </trans-unit>
        <trans-unit id="8e32dd9f3b57b6ccc2e40d0141dc5fa237e75edf" translate="yes" xml:space="preserve">
          <source>Response to comments</source>
          <target state="translated">의견에 대한 답변</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">결과 :</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="0d93e84a8e035a40c9b757a07ddde97ea07443d0" translate="yes" xml:space="preserve">
          <source>Say you have two dicts and you want to merge them into a new dict without altering the original dicts:</source>
          <target state="translated">두 개의 dicts가 있고 원래 dicts를 변경하지 않고 새 dict로 병합하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e04ba6f40f9b2060e8c41a7b09e4e62c77d60e4e" translate="yes" xml:space="preserve">
          <source>Similarly, taking the union of &lt;code&gt;items()&lt;/code&gt; in Python 3 (&lt;code&gt;viewitems()&lt;/code&gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, &lt;strong&gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:&lt;/strong&gt;</source>
          <target state="translated">마찬가지로 파이썬 3에서 &lt;code&gt;items()&lt;/code&gt; 의 합집합 ( 파이썬 2.7의 &lt;code&gt;viewitems()&lt;/code&gt; 도 값이 해싱 할 수없는 객체 (예 : 목록) 인 경우 실패합니다. 값이 해시 가능하더라도 &lt;strong&gt;집합이 의미 적으로 정렬되지 않기 때문에 우선 순위와 관련하여 동작이 정의되지 않습니다.&lt;/strong&gt; &lt;strong&gt;따라서 이것을하지 마십시오 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a63b49fb1159980c455f7b80a5475a5b7a4bbded" translate="yes" xml:space="preserve">
          <source>Simple solution using itertools that preserves order (latter dicts have precedence)</source>
          <target state="translated">순서를 유지하는 itertools를 사용하는 간단한 솔루션 (후기가 우선)</target>
        </trans-unit>
        <trans-unit id="1ce6c799d807e8667caa62ff4d2ed81872b44880" translate="yes" xml:space="preserve">
          <source>Simple, readable, performant. You &lt;em&gt;know&lt;/em&gt;&lt;code&gt;update()&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt;, which is a false value. So the above expression will always evaluate to &lt;code&gt;x&lt;/code&gt;, after updating it.</source>
          <target state="translated">간단하고 읽기 쉬운 성능. &lt;code&gt;update()&lt;/code&gt; 항상 &lt;code&gt;None&lt;/code&gt; 을 반환한다는 것을 &lt;em&gt;알고&lt;/em&gt; 있습니다. 이는 잘못된 값입니다. 따라서 위 표현식은 업데이트 후 항상 &lt;code&gt;x&lt;/code&gt; 로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f32e703bd34c95af93956212150aad7a9788da7d" translate="yes" xml:space="preserve">
          <source>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</source>
          <target state="translated">따라서 조회 속도가 약 느려집니다. 저는 Chainmap의 팬이지만 조회가 많은 곳에서는 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8e2fa47ec0878caa65f8502de5b8cbd1c0786ed" translate="yes" xml:space="preserve">
          <source>Thanks rednaw for edits.</source>
          <target state="translated">편집 해 주셔서 감사합니다.</target>
        </trans-unit>
        <trans-unit id="d4d79546dfca81b3339e87ff38237ad185b2fb4d" translate="yes" xml:space="preserve">
          <source>The 'one' entry should have had 'depth_2' and 'extra' as items inside its dictionary if it truly was a merge.</source>
          <target state="translated">'one'항목은 사전에 병합 된 경우 'depth_2'및 'extra'를 사전 내부의 항목으로 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="d3e70f05e7f6d91452e134d86664d8e73a4261ca" translate="yes" xml:space="preserve">
          <source>The best version I could think while not using copy would be:</source>
          <target state="translated">사본을 사용하지 않고 생각할 수있는 가장 좋은 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14a3e754832e898bf1e858d57c5ffe3967bb05c5" translate="yes" xml:space="preserve">
          <source>The deep merge that rcwesick gave also creates the same result.</source>
          <target state="translated">rcwesick이 준 깊은 병합도 같은 결과를 만들어냅니다.</target>
        </trans-unit>
        <trans-unit id="a312af1c908fc9ad75fb286e3bc170573e2c6cc0" translate="yes" xml:space="preserve">
          <source>The desired result is to get a new dictionary (&lt;code&gt;z&lt;/code&gt;) with the values merged, and the second dict's values overwriting those from the first.</source>
          <target state="translated">원하는 결과는 값이 병합 된 새 사전 ( &lt;code&gt;z&lt;/code&gt; )을 가져오고 두 번째 dict의 값은 첫 번째 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="99cefd2e5a500633b962557b5eb27824141a25b8" translate="yes" xml:space="preserve">
          <source>The following is done on Ubuntu 14.04</source>
          <target state="translated">다음은 Ubuntu 14.04에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c3b7bd83073daf49138869cf80438ea437175ad6" translate="yes" xml:space="preserve">
          <source>The official Python &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;docs on dictionaries&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;사전에&lt;/a&gt; 대한 공식 파이썬 문서</target>
        </trans-unit>
        <trans-unit id="7a8b9b328f9958cca0a11b9acc4b8cd695c2636b" translate="yes" xml:space="preserve">
          <source>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</source>
          <target state="translated">지금까지 솔루션에 대해 가지고있는 문제는 병합 된 사전에서 키 &quot;b&quot;의 값이 10이지만 내 생각으로는 12이어야한다는 것입니다. 그런 관점에서 다음을 제시합니다.</target>
        </trans-unit>
        <trans-unit id="9fcad77208db870fca468aadd90c4da8d6ce0d45" translate="yes" xml:space="preserve">
          <source>These approaches are less performant, but they will provide correct behavior.
They will be &lt;em&gt;much less&lt;/em&gt; performant than &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they &lt;em&gt;do&lt;/em&gt; respect the order of precedence (latter dicts have precedence)</source>
          <target state="translated">이러한 접근 방식은 성능이 떨어지지 만 올바른 동작을 제공합니다. 그것들은 더 높은 추상화 레벨에서 각 키-값 쌍을 반복하기 때문에 &lt;code&gt;copy&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 또는 새로운 압축 풀기 &lt;em&gt;보다&lt;/em&gt; 성능이 &lt;em&gt;떨어질&lt;/em&gt; 것입니다. 그러나 우선 순위를 존중합니다 (후기 순서가 우선합니다)</target>
        </trans-unit>
        <trans-unit id="a0ea664e2a3188bf488d6c2a6055af74fb3539bf" translate="yes" xml:space="preserve">
          <source>This can be done with a single dict comprehension:</source>
          <target state="translated">단일 dict 이해력으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e6d4df98468539933d14acc5debf6efc5fe4ba" translate="yes" xml:space="preserve">
          <source>This can slow you down if you have a lot of lookups in your application:</source>
          <target state="translated">응용 프로그램에 조회가 많으면 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c42edc088b07647e75e1b22d2ce503ca0cd824" translate="yes" xml:space="preserve">
          <source>This discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the &lt;code&gt;update&lt;/code&gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</source>
          <target state="translated">이 논의에는 여전히 중요한 것이 빠져 있는데, 이는 두 가지 목록을 병합하는 &quot;명확한&quot;방법과 이러한 대안의 성능을 비교하는 것입니다. x 또는 y를 수정하지 않는 표현식과 동일한 기반을 유지하기 위해 다음과 같이 x를 수정하지 않고 사본을 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc1c7903eae69f6f9e6f83fcb5785373d15617e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates what happens when values are unhashable:</source>
          <target state="translated">이 예제는 값을 해싱 ​​할 수 없을 때 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9157d19d33dc20ac6d37fac9da93fd7fa473ca0f" translate="yes" xml:space="preserve">
          <source>This function will work in Python 2 and 3 for all dicts. e.g. given dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">이 함수는 모든 dicts에 대해 Python 2 및 3에서 작동합니다. 예를 들어 dicts &lt;code&gt;a&lt;/code&gt; ~ &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1dca0e3af9d62b26b6d4ca040a8f1540fe8eaa2f" translate="yes" xml:space="preserve">
          <source>This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</source>
          <target state="translated">파이썬 (Pypy, Jython, IronPython)의 다른 구현을 고려할 때이 불일치가 나빴습니다. 따라서이 사용법은 주요 변경 사항이 될 수 있으므로 Python 3에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c565024f23a6cd2ae73023603f11cac8eb9232b" translate="yes" xml:space="preserve">
          <source>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</source>
          <target state="translated">이것은 아마도 대중적인 대답은 아니지만 아마도 거의 그렇게하고 싶지 않습니다. 병합 된 사본을 원할 경우 copy (또는 원하는 내용에 따라 &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt; )를 사용한 다음 업데이트하십시오. 두 줄의 코드는 .items () + .items ()로 한 줄을 만드는 것보다 훨씬 더 읽기 쉽습니다. 암시적인 것보다 명시적인 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="02a2f32a05821cacdddcb95030b2675f25361e82" translate="yes" xml:space="preserve">
          <source>This should solve your problem.</source>
          <target state="translated">문제가 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="686c1f44b9d06635a40727397360cca5fb0d76bc" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;dict&lt;/code&gt; constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</source>
          <target state="translated">이것은 &lt;code&gt;dict&lt;/code&gt; 생성자를 사용하며 매우 빠르고 메모리 효율적입니다 (우리의 2 단계 프로세스보다 약간 더 많음). 여기서 무슨 일이 일어나고 있는지 정확하게 알지 않는 한 (즉, 두 번째 dict는 dict constructor), 읽기가 어렵고 의도 된 사용법이 아니기 때문에 Pythonic이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="463fe46eebffb482307a2b0a04183fc401c2acf9" translate="yes" xml:space="preserve">
          <source>This will, as you want it, put the final dict in &lt;code&gt;z&lt;/code&gt;, and make the value for key &lt;code&gt;b&lt;/code&gt; be properly overridden by the second (&lt;code&gt;y&lt;/code&gt;) dict's value:</source>
          <target state="translated">원하는대로 최종 dict를 &lt;code&gt;z&lt;/code&gt; 에 넣고 두 번째 ( &lt;code&gt;y&lt;/code&gt; ) dict 값으로 키 &lt;code&gt;b&lt;/code&gt; 의 값을 올바르게 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="827f523c69cfc77e578e7347bfd913a0423d4505" translate="yes" xml:space="preserve">
          <source>Usage (tested in python 3):</source>
          <target state="translated">사용법 (파이썬 3에서 테스트) :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e8a5cd8514bfb309e8f3f05950c1200e457ea3dc" translate="yes" xml:space="preserve">
          <source>Using chain also, does not work:</source>
          <target state="translated">체인을 사용하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfbc3d78519156ea4d38e12324b7f22474d7df90" translate="yes" xml:space="preserve">
          <source>When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed.</source>
          <target state="translated">이 새 객체를 사용하면 병합 된 사전처럼 동작하지만 원래 사전을 그대로 유지하면서 일정한 생성 시간과 일정한 메모리 사용 공간을 갖습니다. 그것을 만드는 것은 제안 된 다른 솔루션보다 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="2a93691216c27b37fa080f1bf21889060fcd92b2" translate="yes" xml:space="preserve">
          <source>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</source>
          <target state="translated">질문에 이미 여러 차례 답변되었지만 문제에 대한이 간단한 해결책은 아직 나열되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cd809d0ef673f12b00a606ccbe54a8115b1c82af" translate="yes" xml:space="preserve">
          <source>Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I'll update this later once I write a method that does a true merge.</source>
          <target state="translated">예, 샘플 사전을 병합하는 것이 좋지만 일반적인 병합 메커니즘은 없습니다. 진정한 병합을 수행하는 메서드를 작성하면 나중에 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2aa391717295fad536baefee8bd2d60a19871d4f" translate="yes" xml:space="preserve">
          <source>Yes. I must refer you back to the question, which is asking for a &lt;em&gt;shallow&lt;/em&gt; merge of &lt;strong&gt;&lt;em&gt;two&lt;/em&gt;&lt;/strong&gt; dictionaries, with the first's values being overwritten by the second's - in a single expression.</source>
          <target state="translated">예. 나는 &lt;strong&gt;&lt;em&gt;두 개의&lt;/em&gt;&lt;/strong&gt; 사전을 &lt;em&gt;얕게&lt;/em&gt; 병합하고 첫 번째 값을 &lt;strong&gt;&lt;em&gt;두&lt;/em&gt;&lt;/strong&gt; 번째 값으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ee121489b6e0d4a946801627644c8e2674d2d13d" translate="yes" xml:space="preserve">
          <source>You can also chain the dicts manually inside a dict comprehension:</source>
          <target state="translated">dict 이해 내에서 dicts를 수동으로 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a9e7391a7cebd4162276bf43babcfe429d286a" translate="yes" xml:space="preserve">
          <source>You can also make a function to merge an undefined number of dicts, from zero to a very large number:</source>
          <target state="translated">정의되지 않은 수의 dict을 0에서 매우 큰 수로 병합하는 함수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d99a90478f3ad33b4d2bc5f254632c7bfd37d59d" translate="yes" xml:space="preserve">
          <source>You can also use this class to make a kind of copy-on-write dictionary:</source>
          <target state="translated">이 클래스를 사용하여 일종의 COW (Copy-On-Write) 사전을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cedfd6f2171ececea9d197f9ad610009dfddd7f" translate="yes" xml:space="preserve">
          <source>You could also do this of course if you don't care about copying it:</source>
          <target state="translated">복사에 신경 쓰지 않으면 물론이 작업을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f29ce54e05025dbf326102828358d60d6406e0" translate="yes" xml:space="preserve">
          <source>You could also write this as</source>
          <target state="translated">이것을 다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef1d0278a40be0903df836eb1993ad9c45936ba" translate="yes" xml:space="preserve">
          <source>You could use a lambda instead.</source>
          <target state="translated">대신 람다를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e45b5c2910ea1c81696ad9de828761856f8df26" translate="yes" xml:space="preserve">
          <source>You said you wanted one expression, so I abused &lt;code&gt;lambda&lt;/code&gt; to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</source>
          <target state="translated">당신은 하나의 표현을 원한다고 말했기 때문에 &lt;code&gt;lambda&lt;/code&gt; 를 남용하여 이름을 묶고 튜플은 람다의 한 표현 제한을 무시합니다. 자유롭게 울부 짖습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9158b7790079767a2ee5155681bc0537e04269f5" translate="yes" xml:space="preserve">
          <source>and key value pairs in &lt;code&gt;g&lt;/code&gt; will take precedence over dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 의 키 값 쌍은 dicts &lt;code&gt;a&lt;/code&gt; ~ &lt;code&gt;f&lt;/code&gt; 보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">그리고 지금:</target>
        </trans-unit>
        <trans-unit id="6dc92c5dffb9e2875bb5be2d30824a953e7e8fee" translate="yes" xml:space="preserve">
          <source>and then you have a single expression:</source>
          <target state="translated">그리고 하나의 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="538141bce772b5861479742348306cced3786ed9" translate="yes" xml:space="preserve">
          <source>and you would have to explicitly create them as lists, e.g. &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt;. This is a waste of resources and computation power.</source>
          <target state="translated">&lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt; 와 같이 명시 적으로 목록으로 만들어야합니다. 이것은 자원과 계산 능력의 낭비입니다.</target>
        </trans-unit>
        <trans-unit id="feeb579278407bb98d8960ea0156b0f057ac30d9" translate="yes" xml:space="preserve">
          <source>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</source>
          <target state="translated">Tony와는 달리 (놀랍지 않게) 표기법의 차이는 성능에 측정 가능한 영향을 미치지 않는 것으로 나타났습니다. 나에게 맞는 것을 사용하십시오. 물론, 그는 2 문장 버전이 훨씬 이해하기 쉽다는 것을 지적하는 것이 옳습니다.</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="c5d0aeaef87c64e87fa64d76c410acb93a6f6869" translate="yes" xml:space="preserve">
          <source>lead me to conclude that &lt;code&gt;z3&lt;/code&gt; is somewhat faster than &lt;code&gt;z1&lt;/code&gt;, but not nearly as fast as &lt;code&gt;z2&lt;/code&gt;.  Definitely not worth all the extra typing.</source>
          <target state="translated">&lt;code&gt;z3&lt;/code&gt; 이 &lt;code&gt;z1&lt;/code&gt; 보다 다소 빠르지 만 &lt;code&gt;z2&lt;/code&gt; 만큼 빠르지 않다는 결론을 내릴 수 있습니다. 추가로 입력 할 가치가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="3846c179246b1e2fb787941b7f16f2f7ff81ff9b" translate="yes" xml:space="preserve">
          <source>or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</source>
          <target state="translated">또는 파이썬 2.6 (및 생성기 표현식이 도입되었을 때 2.4 이전) :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
