<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/38987">
    <body>
      <group id="38987">
        <trans-unit id="762f1a0e69169610829fa8a43f4c74678cbb8a23" translate="yes" xml:space="preserve">
          <source>(For Python2.7* only; there are simpler solutions for Python3*.)</source>
          <target state="translated">(Только для Python2.7*;есть более простые решения для Python3*).</target>
        </trans-unit>
        <trans-unit id="26cef14df0be957675f0530429b3a7bde6a3b375" translate="yes" xml:space="preserve">
          <source>(That is, of course, equivalent to &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)</source>
          <target state="translated">(Это, конечно, эквивалентно &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt; , но если ваша версия Python достаточно новая для этого, тогда будет доступен стиль PEP 448.)</target>
        </trans-unit>
        <trans-unit id="c983206bb5c1b9997bd209ce2acce7e071f69644" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;or a&lt;/code&gt; bit in the &lt;code&gt;lambda&lt;/code&gt; is necessary because &lt;code&gt;dict.update&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt; on success.)</source>
          <target state="translated">(Значение &lt;code&gt;or a&lt;/code&gt; немного в &lt;code&gt;dict.update&lt;/code&gt; необходимо, потому что dict.update всегда возвращает &lt;code&gt;None&lt;/code&gt; в случае успеха.)</target>
        </trans-unit>
        <trans-unit id="fc6520d839da1d73fe3d2dc5120a168296e3c8df" translate="yes" xml:space="preserve">
          <source>(To be extra-clear, the last-one-wins conflict-handling of &lt;code&gt;dict.update()&lt;/code&gt; is what I'm looking for as well.)</source>
          <target state="translated">(Для &lt;code&gt;dict.update()&lt;/code&gt; обработка конфликтов dict.update () с последними победами - это то, что я также ищу.)</target>
        </trans-unit>
        <trans-unit id="59798fb8386a0602fdd9b6380f0da9334a75b531" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - talk by Brandon Rhodes at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;Словарь еще могущественнее&lt;/a&gt; - выступление Брэндона Роудса на Pycon 2017</target>
        </trans-unit>
        <trans-unit id="8b08b9102b840351132b620d290b145d977714b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Modern Python Dictionaries, A Confluence of Great Ideas&lt;/a&gt; - talk by Raymond Hettinger at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Современные словари Python, слияние великих идей&lt;/a&gt; - выступление Раймона Хеттингера на Pycon 2017</target>
        </trans-unit>
        <trans-unit id="64eaafdd6d026ca8e8e81c2df03a5ad7e0e4f273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; is still the most readable solution for Python 2. Readability counts.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; по-прежнему является наиболее читаемым решением для Python 2. Читаемость имеет значение.</target>
        </trans-unit>
        <trans-unit id="1bc9f47831b8850843d4bfab7500ddd5d5e01499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;itertools.chain&lt;/code&gt; will chain the iterators over the key-value pairs in the correct order:</source>
          <target state="translated">&lt;code&gt;itertools.chain&lt;/code&gt; объединит итераторы в пары ключ-значение в правильном порядке:</target>
        </trans-unit>
        <trans-unit id="8762df6a9a82f0b36d9893287201772efe7c7ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; has bad performance. See &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; имеет плохую производительность. Смотрите &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b30516353c8b7de805be8527f19faa1ebcd7e111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but &lt;code&gt;z2&lt;/code&gt; always seems to come out ahead.  (If you get inconsistent results for the &lt;em&gt;same&lt;/em&gt; test, try passing in &lt;code&gt;-r&lt;/code&gt; with a number larger than the default 3.)</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; выигрывает с коэффициентом 3,5 или около того. Различные словари дают разные результаты, но &lt;code&gt;z2&lt;/code&gt; всегда выходит вперед. (Если вы получаете противоречивые результаты для &lt;em&gt;одного и&lt;/em&gt; того &lt;em&gt;же&lt;/em&gt; теста, попробуйте ввести в &lt;code&gt;-r&lt;/code&gt; число, большее, чем значение по умолчанию 3.)</target>
        </trans-unit>
        <trans-unit id="73fb6424cfd11bb18a1c574f3c35c5c9d895216f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by about a factor of 10.  That's a pretty big win in my book!</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; выигрывает примерно в 10 раз. Это довольно большая победа в моей книге!</target>
        </trans-unit>
        <trans-unit id="684683c3cfba4b7ae046f86966f4cf852b750b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{**x, **y}&lt;/code&gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</source>
          <target state="translated">&lt;code&gt;{**x, **y}&lt;/code&gt; , похоже, не обрабатывает вложенные словари. содержимое вложенных ключей просто перезаписывается, а не сливается [...]. В итоге я сгорел от этих ответов, которые не сливаются рекурсивно, и я был удивлен, что никто не упомянул об этом. В моей интерпретации слова &amp;laquo;слияние&amp;raquo; эти ответы описывают &amp;laquo;обновление одного диктанта другим&amp;raquo;, а не слияние.</target>
        </trans-unit>
        <trans-unit id="4acb6eec05cf3410b42a7e8367ceb7218e526e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;русский&lt;/em&gt; словарь&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c750c4b4d745d4a88f3eea8b03ce9ceff63b397a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Python 3.0 and later&lt;/strong&gt;, you can use &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt;&lt;code&gt;collections.ChainMap&lt;/code&gt;&lt;/a&gt; which groups multiple dicts or other mappings together to create a single, updateable view:</source>
          <target state="translated">&lt;strong&gt;В Python 3.0 и более поздних версиях&lt;/strong&gt; вы можете использовать &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt; &lt;code&gt;collections.ChainMap&lt;/code&gt; &lt;/a&gt; который группирует несколько диктовок или других сопоставлений для создания единого обновляемого представления:</target>
        </trans-unit>
        <trans-unit id="047862db1890195e52368684bf93f77d9a3b9706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this has become a popular answer, but it is important to point out that if &lt;code&gt;y&lt;/code&gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido is not a fan&lt;/a&gt;. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : это стало популярным ответом, но важно отметить, что если &lt;code&gt;y&lt;/code&gt; есть нестроковые ключи, то, что это работает вообще, является злоупотреблением деталями реализации CPython, и это не работает в Python 3 или в PyPy, IronPython или Jython. Кроме того, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Гвидо не фанат&lt;/a&gt; . Поэтому я не могу рекомендовать эту технику для совместимого с прямым переносом кода или переносимого кода с перекрестной реализацией, что на самом деле означает, что его следует полностью избегать.</target>
        </trans-unit>
        <trans-unit id="56c781e5adb8bad76d8066d046d1c97e28021043" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Два словаря&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d78daed80f94bbc7108a07b9e271b9fca2cca5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update for Python 3.5 and later&lt;/strong&gt;: You can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; extended dictionary packing and unpacking.  This is fast and easy:</source>
          <target state="translated">&lt;strong&gt;Обновление для Python 3.5 и более поздних версий&lt;/strong&gt; : вы можете использовать расширенную упаковку и распаковку словаря &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; . Это быстро и просто:</target>
        </trans-unit>
        <trans-unit id="4ad22f81594d7603a3fcfc3c26100cb43cf77997" translate="yes" xml:space="preserve">
          <source>A couple more points for python 3. First, note that the &lt;code&gt;dict(x, **y)&lt;/code&gt; trick won't work in python 3 unless the keys in &lt;code&gt;y&lt;/code&gt; are strings.</source>
          <target state="translated">Еще пара моментов для Python 3. Во-первых, обратите внимание, что трюк &lt;code&gt;dict(x, **y)&lt;/code&gt; не будет работать в Python 3, если ключи в &lt;code&gt;y&lt;/code&gt; не являются строками.</target>
        </trans-unit>
        <trans-unit id="52323533fde1038ac6c3239bddef21ed2cd7faa9" translate="yes" xml:space="preserve">
          <source>A few quick tests, e.g.</source>
          <target state="translated">Несколько быстрых тестов,например</target>
        </trans-unit>
        <trans-unit id="5b8d1b61a251a1f4f5f96af395d52351a9c2d234" translate="yes" xml:space="preserve">
          <source>A new syntax for this, proposed in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; and &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;available as of Python 3.5&lt;/a&gt;, is</source>
          <target state="translated">Новый синтаксис для этого, предложенный в &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; и &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;доступный с Python 3.5&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="d20312b0c332092c94533e037801b46f85f6ff75" translate="yes" xml:space="preserve">
          <source>A typical result:</source>
          <target state="translated">Типичный результат:</target>
        </trans-unit>
        <trans-unit id="79346271c215b10d408c3a24960c3a8434e1b144" translate="yes" xml:space="preserve">
          <source>Abuse leading to a one-expression solution for &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew's answer&lt;/a&gt;:</source>
          <target state="translated">Злоупотребление, приводящее к решению с одним выражением для &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;ответа Мэтью&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bc0fcdd15355dfc94d498254e338806fd4947b01" translate="yes" xml:space="preserve">
          <source>After comparing those two, I wondered if &lt;code&gt;z1&lt;/code&gt;'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</source>
          <target state="translated">После сравнения этих двух я подумал, можно ли объяснить низкую производительность &lt;code&gt;z1&lt;/code&gt; из -за накладных расходов на создание двух списков элементов, что, в свою очередь, заставило меня задуматься, может ли этот вариант работать лучше:</target>
        </trans-unit>
        <trans-unit id="3e513e02e5ffef80d9363703f5c690e41e7d947a" translate="yes" xml:space="preserve">
          <source>Again, it doesn't work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. &lt;code&gt;dict&lt;/code&gt; broke this consistency in Python 2:</source>
          <target state="translated">Опять же, это не работает для 3, когда ключи не являются строками. Неявный контракт вызова заключается в том, что пространства имен принимают обычные диктовки, в то время как пользователи должны передавать только ключевые аргументы, которые являются строками. Все другие призывные силы принуждали его. &lt;code&gt;dict&lt;/code&gt; нарушил эту последовательность в Python 2:</target>
        </trans-unit>
        <trans-unit id="37903af1bb3d70c3129ae7ad37c51d78652644c4" translate="yes" xml:space="preserve">
          <source>Also, Raymond Hettinger's Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;answer&lt;/a&gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;from the docs&lt;/a&gt; it looks like it sequentially looks through a list of all the dicts for each lookup:</source>
          <target state="translated">Кроме того, &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;ответ&lt;/a&gt; Рэймонда Хеттингера на Chainmap довольно элегантен, поскольку он может принимать в качестве аргументов произвольное количество диктовок, но &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;из документов&lt;/a&gt; выглядит так, будто он последовательно просматривает список всех диктов для каждого поиска:</target>
        </trans-unit>
        <trans-unit id="b0e9fc794244c2742a7d0ad09b5a05d65fe3ab05" translate="yes" xml:space="preserve">
          <source>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only):</source>
          <target state="translated">Хотя это и не так уж отличается от следующего использования оператора new walrus (только на Python 3.8+):</target>
        </trans-unit>
        <trans-unit id="d64aa96c0baf8816d369af41816223f0d24166b8" translate="yes" xml:space="preserve">
          <source>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life &lt;em&gt;Guido van Rossum&lt;/em&gt; himself!  Someone else suggested half of this, but did not put it in a function.</source>
          <target state="translated">Среди таких сомнительных и сомнительных ответов этот яркий пример - единственный и единственный хороший способ объединить диктанты в Python, одобренный диктатором на всю жизнь &lt;em&gt;Гвидо ван Россумом&lt;/em&gt; ! Кто-то предложил половину этого, но не включил его в работу.</target>
        </trans-unit>
        <trans-unit id="b52eb9c15df1a810d482d29e8ce9cd10a248294b" translate="yes" xml:space="preserve">
          <source>An alternative:</source>
          <target state="translated">Альтернатива:</target>
        </trans-unit>
        <trans-unit id="ad2a670b2ebfd8d5864a5b7bac3632cc392444b7" translate="yes" xml:space="preserve">
          <source>And it is indeed a single expression.</source>
          <target state="translated">И это действительно единственное выражение.</target>
        </trans-unit>
        <trans-unit id="2a68af8ef2b2b3fa71a55eee3ef7e2c9f937685a" translate="yes" xml:space="preserve">
          <source>And it's usage:</source>
          <target state="translated">И это использование:</target>
        </trans-unit>
        <trans-unit id="b0b7becbe9ec6ad7a7d8f73a304a045dc8bff483" translate="yes" xml:space="preserve">
          <source>Another hack you should not use:</source>
          <target state="translated">Еще один взлом,который тебе не стоит использовать:</target>
        </trans-unit>
        <trans-unit id="a6df3197072e3a7d3b37983ee4cecb723db3ac60" translate="yes" xml:space="preserve">
          <source>Another, more concise, option:</source>
          <target state="translated">Другой,более лаконичный вариант:</target>
        </trans-unit>
        <trans-unit id="a90812f162710be72c6673269344a54ff85dec16" translate="yes" xml:space="preserve">
          <source>Answer on how to add new keys to a dictionary</source>
          <target state="translated">Ответьте на вопрос о том,как добавить новые ключи в словарь.</target>
        </trans-unit>
        <trans-unit id="209d65032f4cdd91a49f9731f909c0f76b26af8f" translate="yes" xml:space="preserve">
          <source>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call
  x.update(y) and return x&quot;. Personally I find it more despicable than
  cool.</source>
          <target state="translated">Очевидно,диктат(x,**y)делает &quot;крутой хак&quot; для &quot;вызова x.update(y)и возврата x&quot;.Лично я нахожу это более презренным,чем крутым.</target>
        </trans-unit>
        <trans-unit id="1107541abd6568cff679b7beb9d9536a95d8d98c" translate="yes" xml:space="preserve">
          <source>As suggested above, using two lines or writing a function is probably a better way to go.</source>
          <target state="translated">Как предлагалось выше,использование двух строк или написание функции,вероятно,является лучшим способом.</target>
        </trans-unit>
        <trans-unit id="9c0a490ce334822e1a4fa03338b9164ecf3e1d0a" translate="yes" xml:space="preserve">
          <source>Assuming two dictionary of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dicts from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</source>
          <target state="translated">Предполагая два словаря словарей,один может рекурсивно объединять их в одну функцию,но вы должны быть осторожны,чтобы не изменить эти словари ни из одного из источников,и самый надежный способ избежать этого-сделать копию при назначении значений.Поскольку ключи должны быть хэшируемыми и поэтому обычно являются неизменяемыми,их копирование бессмысленно:</target>
        </trans-unit>
        <trans-unit id="dda59ae142911ee5f815e7544ec0051e45b17ef5" translate="yes" xml:space="preserve">
          <source>Be pythonic. Use a &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;comprehension&lt;/a&gt;:</source>
          <target state="translated">Будьте питоничны. Используйте &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;понимание&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e3e400046d95f67ae3dc116f87dadd13f71f972a" translate="yes" xml:space="preserve">
          <source>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;&lt;/a&gt;.</source>
          <target state="translated">Решение непредвиденных обстоятельств для других типов значений выходит далеко за рамки этого вопроса, поэтому я укажу вам на &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;мой ответ на канонический вопрос &amp;laquo;Словари слияния словарей&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ead0c8a43030e9b4ba9dfd6743570550ad79d67" translate="yes" xml:space="preserve">
          <source>Critiques of Other Answers</source>
          <target state="translated">Критика других ответов</target>
        </trans-unit>
        <trans-unit id="c6a7b52934eb4c501f4a60e0e15c80a5bef14889" translate="yes" xml:space="preserve">
          <source>Demonstration:</source>
          <target state="translated">Demonstration:</target>
        </trans-unit>
        <trans-unit id="92ec7b2214ef32933d24b7351f97a6c052ccdf23" translate="yes" xml:space="preserve">
          <source>Depending on the use case it might not be necessary to create a &quot;real&quot; merged dictionary of the given input dictionaries.  A &lt;em&gt;view&lt;/em&gt; which does this might be sufficient in many cases, i. e. an object which acts &lt;em&gt;like&lt;/em&gt; the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak.</source>
          <target state="translated">В зависимости от варианта использования может не потребоваться создание &amp;laquo;реального&amp;raquo; объединенного словаря из заданных входных словарей. Представление, которое делает это, может быть достаточным во многих случаях, то есть объект, который действует &lt;em&gt;как&lt;/em&gt; объединенный словарь, не вычисляя его полностью. Ленивая версия объединенного словаря, так сказать.</target>
        </trans-unit>
        <trans-unit id="cf8c4ba0db8a8656b2f2f14c9fc473f2d81f924b" translate="yes" xml:space="preserve">
          <source>Despite what Guido says, &lt;code&gt;dict(x, **y)&lt;/code&gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords.</source>
          <target state="translated">Несмотря на то, что говорит Гвидо, &lt;code&gt;dict(x, **y)&lt;/code&gt; соответствует спецификации dict, что, кстати. работает как для Python 2, так и для 3. Тот факт, что это работает только для строковых ключей, является прямым следствием того, как работают параметры ключевых слов, а не коротким переходом к dict. Также использование оператора ** в этом месте не является злоупотреблением механизмом, фактически ** был разработан именно для передачи слов в качестве ключевых слов.</target>
        </trans-unit>
        <trans-unit id="3d03564e5b15ddf2ca88faedf123c311e047f26b" translate="yes" xml:space="preserve">
          <source>Dicts are intended to take hashable keys (e.g. frozensets or tuples), but &lt;strong&gt;this method fails in Python 3 when keys are not strings.&lt;/strong&gt;</source>
          <target state="translated">Dicts предназначены для получения хешируемых ключей (например, frozensets или кортежей), но &lt;strong&gt;этот метод не работает в Python 3, когда ключи не являются строками.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92d9a054b2288bd1fdd9bdb5e55a39fe412e39ab" translate="yes" xml:space="preserve">
          <source>Don't use what you see in the formerly accepted answer:</source>
          <target state="translated">Не используйте то,что вы видите в ранее принятом ответе:</target>
        </trans-unit>
        <trans-unit id="ac898e4932c0e7dcb2f44c27b6aeabf7e53fc70c" translate="yes" xml:space="preserve">
          <source>Drawing on ideas here and elsewhere I've comprehended a function:</source>
          <target state="translated">Опираясь на идеи здесь и в других местах,я понял одну из функций:</target>
        </trans-unit>
        <trans-unit id="6c434bcb6a9e583ddd9818e466c89cc4d9768234" translate="yes" xml:space="preserve">
          <source>Even though the answers were good for this &lt;em&gt;shallow&lt;/em&gt; dictionary, none of the methods defined here actually do a deep dictionary merge.</source>
          <target state="translated">Несмотря на то, что ответы были хорошими для этого &lt;em&gt;мелкого&lt;/em&gt; словаря, ни один из методов, определенных здесь, на самом деле не выполняет глубокое слияние словаря.</target>
        </trans-unit>
        <trans-unit id="534c40ca3d6e9c332fb24d30e24866a5884fdf3c" translate="yes" xml:space="preserve">
          <source>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</source>
          <target state="translated">Пример 1:идентичные словари,сопоставляющие себе 20 последовательных целых чисел:</target>
        </trans-unit>
        <trans-unit id="5d6468775d296b285af2d4eb8a4fbae02366f7da" translate="yes" xml:space="preserve">
          <source>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</source>
          <target state="translated">Пример 2:неперекрывающиеся словари,отображающие 252 короткие строки на целые числа и наоборот:</target>
        </trans-unit>
        <trans-unit id="51725d04b42e48c95f79400a9ef4bf6dd25aa363" translate="yes" xml:space="preserve">
          <source>Examples follow:</source>
          <target state="translated">Ниже приведены примеры:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="417f84c0ab231efe074c376811a745ff0bbaefae" translate="yes" xml:space="preserve">
          <source>For dictionaries &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; becomes a shallowly merged dictionary with values from &lt;code&gt;y&lt;/code&gt; replacing those from &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Для словарей &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; становится мелко объединенным словарем со значениями из &lt;code&gt;y&lt;/code&gt; , заменяющими значения из &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7a48fc65c8ec5e1d37a7ac34c58a2610a8718b" translate="yes" xml:space="preserve">
          <source>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</source>
          <target state="translated">Для элементов с ключами в обоих словарях ('b'),вы можете управлять тем,какой из них окажется на выходе,поставив его последним.</target>
        </trans-unit>
        <trans-unit id="66e4468118f12a49669432b591f48cae1db2757b" translate="yes" xml:space="preserve">
          <source>For python3-like behavior in version 2.7, the &lt;code&gt;viewitems&lt;/code&gt; method should work in place of &lt;code&gt;items&lt;/code&gt;:</source>
          <target state="translated">Для Python3-подобного поведения в версии 2.7 метод &lt;code&gt;viewitems&lt;/code&gt; должен работать вместо &lt;code&gt;items&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05f303d92888701b00a3dca7391b2cd0ede31839" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;mailing list&lt;/a&gt;, Guido van Rossum, the creator of the language, wrote:</source>
          <target state="translated">Создатель языка Гвидо ван Россум из &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;списка рассылки&lt;/a&gt; написал:</target>
        </trans-unit>
        <trans-unit id="9f63a1b687b569fbbc0abd2c72572d74cf9da35c" translate="yes" xml:space="preserve">
          <source>Here's an example of the usage being &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;remediated in django&lt;/a&gt;.</source>
          <target state="translated">Вот пример использования &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;исправления в Django&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fca813712109d4e2606defe725d888aa50dabf0" translate="yes" xml:space="preserve">
          <source>Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:</source>
          <target state="translated">Вот пример,где y должно иметь приоритет,а вместо него значение из x сохраняется из-за произвольного порядка множеств:</target>
        </trans-unit>
        <trans-unit id="eebe1dc7075416ba2cee50e9bcf95a9e8f656e14" translate="yes" xml:space="preserve">
          <source>Here's the straight-forward code of &lt;code&gt;MergeDict&lt;/code&gt;:</source>
          <target state="translated">Вот простой код &lt;code&gt;MergeDict&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22cca235a9f80cdc5840a3a67ad0dfe9f75c41d8" translate="yes" xml:space="preserve">
          <source>How can I get that final merged dictionary in &lt;code&gt;z&lt;/code&gt;, not &lt;code&gt;x&lt;/code&gt;?</source>
          <target state="translated">Как я могу получить этот окончательный объединенный словарь по &lt;code&gt;z&lt;/code&gt; , а не &lt;code&gt;x&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="5b9ed01b74e3b861c8ed3f17f0beccfffc6b9b9b" translate="yes" xml:space="preserve">
          <source>How can I merge two Python dictionaries in a single expression?</source>
          <target state="translated">Как объединить два словаря Python в одно выражение?</target>
        </trans-unit>
        <trans-unit id="8cb6e8e8ba5fdf4ce9658d5ca8f5d8770c5e9e85" translate="yes" xml:space="preserve">
          <source>How do I merge two dictionaries in a single expression</source>
          <target state="translated">Как объединить два словаря в одно выражение.</target>
        </trans-unit>
        <trans-unit id="c8ef4565722ce18107b48e5f9a668982765902bd" translate="yes" xml:space="preserve">
          <source>However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</source>
          <target state="translated">Однако,поскольку многие организации все еще находятся на Python 2,вы,возможно,захотите сделать это обратно совместимым способом.Классический Pythonic способ,доступный на Python 2 и Python 3.0-3.4,состоит в том,чтобы сделать это как двухступенчатый процесс:</target>
        </trans-unit>
        <trans-unit id="a9e2146fc3d130671f68d310625226e3ccce8eab" translate="yes" xml:space="preserve">
          <source>I am fine with
  declaring dict({}, **{1:3}) illegal, since after all it is abuse of
  the ** mechanism.</source>
          <target state="translated">Я не против объявить диктат({},**{1:3})незаконным,так как,в конце концов,это злоупотребление **механизмом.</target>
        </trans-unit>
        <trans-unit id="11606279b4a4e0c3d7cb38ec7e13e08435b369e0" translate="yes" xml:space="preserve">
          <source>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The &lt;code&gt;update()&lt;/code&gt; method would be what I need, if it returned its result instead of modifying a dictionary in-place.</source>
          <target state="translated">У меня есть два словаря Python, и я хочу написать одно выражение, которое возвращает эти два словаря, объединенные. Мне нужен метод &lt;code&gt;update()&lt;/code&gt; , если он вернет свой результат вместо изменения словаря на месте.</target>
        </trans-unit>
        <trans-unit id="56b9ab3e4817a98d072aafad2224e1acb41d827f" translate="yes" xml:space="preserve">
          <source>I just use a simple helper function to solve the problem:</source>
          <target state="translated">Я просто использую простую вспомогательную функцию для решения проблемы:</target>
        </trans-unit>
        <trans-unit id="01c87e18558e3526b4877129f79e0ec875c6b499" translate="yes" xml:space="preserve">
          <source>I know this does not really fit the specifics of the questions (&quot;one liner&quot;), but since &lt;em&gt;none&lt;/em&gt; of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts.</source>
          <target state="translated">Я знаю, что это на самом деле не вписывается в специфику вопросов (&amp;laquo;один вкладыш&amp;raquo;), но поскольку &lt;em&gt;ни один&lt;/em&gt; из приведенных выше ответов не пошел в этом направлении, в то время как многие и многие ответы касались проблемы производительности, я чувствовал, что должен поделиться своими мыслями.</target>
        </trans-unit>
        <trans-unit id="bfc266b6f982c3a928236a92c629662068d1aa8b" translate="yes" xml:space="preserve">
          <source>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</source>
          <target state="translated">В любом случае,я предпочитаю эту нотацию,так как кажется более естественным думать о ней как о согласованной профсоюзной операции,а не как о конкатенации (как видно из названия).</target>
        </trans-unit>
        <trans-unit id="375e440687d005ef88e88f34c7f99f4a5ac588c4" translate="yes" xml:space="preserve">
          <source>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</source>
          <target state="translated">Я утверждаю,что преднамеренное написание кода,который работает только в одной версии языка,или кода,который работает только с определенными произвольными ограничениями,является злонамеренной некомпетентностью.</target>
        </trans-unit>
        <trans-unit id="7bb9b5043cf7f5771f44311a303420b28a455fba" translate="yes" xml:space="preserve">
          <source>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</source>
          <target state="translated">Я хотел что-то похожее,но с возможностью указать,как были объединены значения на дубликатах ключей,поэтому я это взломал (но не сильно тестировал).Очевидно,что это не единственное выражение,но это единственный вызов функции.</target>
        </trans-unit>
        <trans-unit id="78af1cea1dc16ea253286cd3b93d54839ede508a" translate="yes" xml:space="preserve">
          <source>I'm only going to do the performance analysis of the usages known to behave correctly.</source>
          <target state="translated">Я собираюсь провести анализ производительности только тех случаев,когда известно,что поведение корректно.</target>
        </trans-unit>
        <trans-unit id="3b18b7815200328ded8232a4d1a242e6497d1f7f" translate="yes" xml:space="preserve">
          <source>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</source>
          <target state="translated">IMO небольшое замедление между первыми двумя стоит того,чтобы читаемость была удобной.Кроме того,аргументы по ключевым словам для создания словаря были добавлены только на Python 2.3,тогда как copy()и update()будут работать в более старых версиях.</target>
        </trans-unit>
        <trans-unit id="80cd4b20ecfc8fde8f0d9999c7ceff52e8d8b72a" translate="yes" xml:space="preserve">
          <source>If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a &lt;em&gt;single expression&lt;/em&gt;, the most performant while correct approach is to put it in a function:</source>
          <target state="translated">Если вы еще не используете Python 3.5 или вам нужно написать обратно совместимый код, и вы хотите, чтобы это было в &lt;em&gt;одном выражении&lt;/em&gt; , самый эффективный и правильный подход - поместить его в функцию:</target>
        </trans-unit>
        <trans-unit id="58f39817135947f0339519f69b794e849b094fff" translate="yes" xml:space="preserve">
          <source>If you do want a copy, PEP 448 style is easiest &lt;code&gt;{**x, **y}&lt;/code&gt;. But if that's not available in your (older) Python version, the &lt;em&gt;let&lt;/em&gt; pattern works here too.</source>
          <target state="translated">Если вам нужна копия, стиль PEP 448 - самый простой &lt;code&gt;{**x, **y}&lt;/code&gt; . Но если это недоступно в вашей (более старой) версии Python, здесь также работает шаблон &lt;em&gt;let&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c68f13df74f8081969ebc7396a5bdbb15beb7948" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;x&lt;/code&gt; in a variable yet, you can use &lt;code&gt;lambda&lt;/code&gt; to make a local without using an assignment statement. This amounts to using &lt;code&gt;lambda&lt;/code&gt; as a &lt;em&gt;let expression&lt;/em&gt;, which is a common technique in functional languages, but maybe unpythonic.</source>
          <target state="translated">Если у вас еще нет &lt;code&gt;x&lt;/code&gt; в переменной, вы можете использовать &lt;code&gt;lambda&lt;/code&gt; чтобы сделать локальным, не используя оператор присваивания. Это равносильно использованию &lt;code&gt;lambda&lt;/code&gt; в качестве &lt;em&gt;выражения let&lt;/em&gt; , что является распространенной техникой в ​​функциональных языках, но, возможно, не пифонично.</target>
        </trans-unit>
        <trans-unit id="6e67f1fbb5c4630089b3b15e7da7f230c6351803" translate="yes" xml:space="preserve">
          <source>If you don't mind mutating &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">Если вы не против мутировать &lt;code&gt;x&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="23112b4c7ee35913e4183cf954bd3fbb6f22db7a" translate="yes" xml:space="preserve">
          <source>If you ever felt you would prefer to have a real merged &lt;code&gt;dict&lt;/code&gt;, then calling &lt;code&gt;dict(z)&lt;/code&gt; would produce it (but way more costly than the other solutions of course, so this is just worth mentioning).</source>
          <target state="translated">Если вы когда-нибудь чувствовали, что предпочли бы иметь настоящий объединенный &lt;code&gt;dict&lt;/code&gt; , то вызов &lt;code&gt;dict(z)&lt;/code&gt; произведет его (но, конечно, намного дороже, чем другие решения, поэтому об этом просто стоит упомянуть).</target>
        </trans-unit>
        <trans-unit id="91c65288fd2cb6d1ebcbffd2f95dcc6f769de027" translate="yes" xml:space="preserve">
          <source>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</source>
          <target state="translated">Если ты думаешь,что ягнята-это зло,то не читай дальше.По желанию вы можете написать быстрое и эффективное с точки зрения памяти решение одним выражением:</target>
        </trans-unit>
        <trans-unit id="7b3eb5dd9b8564f262213b8ec581f34343fb1155" translate="yes" xml:space="preserve">
          <source>If you use Python 3, it is only a little more complicated.  To create &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">Если вы используете Python 3, это будет немного сложнее. Чтобы создать &lt;code&gt;z&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d340b513c30c260578d2c3eadac2366554f22a75" translate="yes" xml:space="preserve">
          <source>If you're not averse to importing a standard library module, you can do</source>
          <target state="translated">Если вы не против импортировать стандартный модуль библиотеки,вы можете сделать следующее</target>
        </trans-unit>
        <trans-unit id="a4d62fbeb1dc986c159aff37fcf7e409f975fec3" translate="yes" xml:space="preserve">
          <source>In Python 2, (or 3.4 or lower) write a function:</source>
          <target state="translated">На питоне 2 (или 3.4 или ниже)запишите функцию:</target>
        </trans-unit>
        <trans-unit id="cddaaf9db6625675addbc60941262561bfd51d86" translate="yes" xml:space="preserve">
          <source>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. &lt;strong&gt;In Python 3, this will fail&lt;/strong&gt; because you're adding two &lt;code&gt;dict_items&lt;/code&gt; objects together, not two lists -</source>
          <target state="translated">В Python 2 вы создаете два списка в памяти для каждого dict, создаете третий список в памяти с длиной, равной длине первых двух вместе взятых, а затем отбрасываете все три списка для создания dict. &lt;strong&gt;В Python 3 это не удастся,&lt;/strong&gt; потому что вы добавляете два объекта &lt;code&gt;dict_items&lt;/code&gt; вместе, а не два списка -</target>
        </trans-unit>
        <trans-unit id="c145a8d3b1ebc6e2271fc27dc8537d7fd274de6b" translate="yes" xml:space="preserve">
          <source>In Python 2.7 (system Python):</source>
          <target state="translated">На Питоне 2.7 (система Питон):</target>
        </trans-unit>
        <trans-unit id="c0da467e5ff897c9e6741e6911edbfc2c8e28314" translate="yes" xml:space="preserve">
          <source>In Python 3.5 (deadsnakes PPA):</source>
          <target state="translated">На Питоне 3.5 (deadsnakes PPA):</target>
        </trans-unit>
        <trans-unit id="61986f9755b6245f3a2d4cfab600c14ea75b062c" translate="yes" xml:space="preserve">
          <source>In Python 3.5 or greater:</source>
          <target state="translated">На Питоне 3.5 и выше:</target>
        </trans-unit>
        <trans-unit id="7c246f03cced22905d4e5edbf31a21a72dfa1e56" translate="yes" xml:space="preserve">
          <source>In Python 3.9.0a4 or greater (final release date approx October 2020): &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;discussed here&lt;/a&gt;, was implemented to further simplify this:</source>
          <target state="translated">В Python 3.9.0a4 или более поздней версии (окончательная дата выпуска примерно в октябре 2020 г.): &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;обсуждаемый здесь&lt;/a&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt; был реализован для дальнейшего упрощения этого:</target>
        </trans-unit>
        <trans-unit id="fb06defc9c6c89decb004ddee3cc8e2971971de4" translate="yes" xml:space="preserve">
          <source>In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be:</source>
          <target state="translated">На Python это довольно просто и может быть сделано с помощью кода,показанного в конце моего сообщения.Учитывая это,ответом на исходный вопрос будет:</target>
        </trans-unit>
        <trans-unit id="2694d72958aa5476affbdd9f1fa8e1fb6ade5022" translate="yes" xml:space="preserve">
          <source>In a follow-up answer, you asked about the relative performance of these two alternatives:</source>
          <target state="translated">В последующем ответе вы спросили об относительной эффективности этих двух альтернатив:</target>
        </trans-unit>
        <trans-unit id="fc9fa0b91a747b146f5bf2910dc05830d2caba46" translate="yes" xml:space="preserve">
          <source>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</source>
          <target state="translated">Кроме того,когда вы используете .items()(pre Python 3.0),вы создаёте новый список,который содержит элементы из диктата.Если ваши словари большие,то это довольно много накладных расходов (два больших списка,которые будут выброшены,как только будет создан объединенный dict).update()может работать более эффективно,потому что она может запускаться через второй dict item by item.</target>
        </trans-unit>
        <trans-unit id="dd84518801f2e66815fcf3f25a609ccfebd7ea62" translate="yes" xml:space="preserve">
          <source>In both approaches, &lt;code&gt;y&lt;/code&gt; will come second and its values will replace &lt;code&gt;x&lt;/code&gt;'s values, thus &lt;code&gt;'b'&lt;/code&gt; will point to &lt;code&gt;3&lt;/code&gt; in our final result.</source>
          <target state="translated">В обоих подходах &lt;code&gt;y&lt;/code&gt; будет вторым, и его значения будут заменять значения &lt;code&gt;x&lt;/code&gt; , поэтому &lt;code&gt;'b'&lt;/code&gt; будет указывать на &lt;code&gt;3&lt;/code&gt; в нашем конечном результате.</target>
        </trans-unit>
        <trans-unit id="3840c97bb862e7304c6e3f15f1b99fb6f44f7a27" translate="yes" xml:space="preserve">
          <source>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses &lt;code&gt;dict&lt;/code&gt; in lots of places; optimizing its operations is a big deal.</source>
          <target state="translated">На самом деле, я бы зашел так далеко, что утверждал, что чистый код Python не может работать лучше, чем этот. И если вы можете значительно улучшить работу модуля расширения C, я думаю, что пользователи Python вполне могут быть заинтересованы во включении вашего кода (или варианта вашего подхода) в ядро ​​Python. Python использует &lt;code&gt;dict&lt;/code&gt; во многих местах; Оптимизация его операций это большое дело.</target>
        </trans-unit>
        <trans-unit id="bb531282f9af11f54c3641bdd4af885240f75d4e" translate="yes" xml:space="preserve">
          <source>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</source>
          <target state="translated">На мой взгляд,лучший ответ для части &quot;единственное выражение&quot;,так как дополнительные функции не нужны,и он короткий.</target>
        </trans-unit>
        <trans-unit id="28f989d802777ef28e3ed883ee8ae092d02eb42c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;z0&lt;/code&gt; and &lt;code&gt;z2&lt;/code&gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</source>
          <target state="translated">Другими словами, &lt;code&gt;z0&lt;/code&gt; и &lt;code&gt;z2&lt;/code&gt; ,по- видимому, имеют практически одинаковую производительность. Как вы думаете, это может быть совпадением? Я не....</target>
        </trans-unit>
        <trans-unit id="9bc07c9c43a19f58510985e71e66d75a3b1147f6" translate="yes" xml:space="preserve">
          <source>In python3, the &lt;code&gt;items&lt;/code&gt; method &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;no longer returns a list&lt;/a&gt;, but rather a &lt;em&gt;view&lt;/em&gt;, which acts like a set. In this case you'll need to take the set union since concatenating with &lt;code&gt;+&lt;/code&gt; won't work:</source>
          <target state="translated">В python3 метод &lt;code&gt;items&lt;/code&gt; &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;больше не возвращает список&lt;/a&gt; , а скорее &lt;em&gt;представление&lt;/em&gt; , которое действует как набор. В этом случае вам нужно взять объединение множеств, так как объединение с &lt;code&gt;+&lt;/code&gt; не будет работать:</target>
        </trans-unit>
        <trans-unit id="4b8950cb37108627db33c7d426aad3319f43c846" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;time&lt;/a&gt;:</source>
          <target state="translated">С точки зрения &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;времени&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="576c81f813e6d5c7574b2bff19e7f7a19584c5ed" translate="yes" xml:space="preserve">
          <source>In your case, what you can do is:</source>
          <target state="translated">В твоем случае,что ты можешь сделать:</target>
        </trans-unit>
        <trans-unit id="eb9849d8300f85b4b8946c3d18417f7afe6aef40" translate="yes" xml:space="preserve">
          <source>Instead, we get this:</source>
          <target state="translated">Вместо этого мы получаем это:</target>
        </trans-unit>
        <trans-unit id="613f9806d6fd6e5cb5f3886e4f538655d654d6e1" translate="yes" xml:space="preserve">
          <source>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</source>
          <target state="translated">Она такая же быстрая,как z0 и злобная z2,упомянутая выше,но легкая для понимания и изменения.</target>
        </trans-unit>
        <trans-unit id="9270042b2f84bc91d9787a1d06a084ff6685203f" translate="yes" xml:space="preserve">
          <source>It is my understanding (as well as the understanding of the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;creator of the language&lt;/a&gt;) that the intended usage for &lt;code&gt;dict(**y)&lt;/code&gt; is for creating dicts for readability purposes, e.g.:</source>
          <target state="translated">Это мое понимание (а также понимание &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;создателя языка&lt;/a&gt; ), что предполагаемое использование &lt;code&gt;dict(**y)&lt;/code&gt; предназначено для создания dicts в целях читабельности, например:</target>
        </trans-unit>
        <trans-unit id="10e433f1aca9083f13e27caed8d5cca896a01f3e" translate="yes" xml:space="preserve">
          <source>It is now showing as implemented in the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;release schedule for 3.5, PEP 478&lt;/a&gt;, and it has now made its way into &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;What's New in Python 3.5&lt;/a&gt; document.</source>
          <target state="translated">Теперь он показывает, как реализовано в &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;графике выпуска 3.5, PEP 478&lt;/a&gt; , и теперь он появился в документе &amp;laquo; &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;Что нового в Python 3.5&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea45706ebbfc3fa103ecf69ca8e21e9e39ff372" translate="yes" xml:space="preserve">
          <source>It's faster than &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; but not as fast as &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt;, at least on CPython. This version also works in Python 3 if you change &lt;code&gt;iteritems()&lt;/code&gt; to &lt;code&gt;items()&lt;/code&gt;, which is automatically done by the 2to3 tool.</source>
          <target state="translated">Это быстрее, чем &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; но не так быстро, как &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt; n.update (b) , по крайней мере, на CPython. Эта версия также работает в Python 3, если вы измените &lt;code&gt;iteritems()&lt;/code&gt; на &lt;code&gt;items()&lt;/code&gt; , что автоматически выполняется инструментом 2to3.</target>
        </trans-unit>
        <trans-unit id="41964880e9b5b33a4ebc5a2e547cf6b1a1fe1386" translate="yes" xml:space="preserve">
          <source>It's so silly that &lt;code&gt;.update&lt;/code&gt; returns nothing.</source>
          <target state="translated">Это так глупо, что &lt;code&gt;.update&lt;/code&gt; ничего не возвращает.</target>
        </trans-unit>
        <trans-unit id="e8f3c6ca67433e529b1de06a8936ad80db4f01c3" translate="yes" xml:space="preserve">
          <source>Less Performant But Correct Ad-hocs</source>
          <target state="translated">Меньше исполнителя,но правильный Адвокат.</target>
        </trans-unit>
        <trans-unit id="47d53f050b02da45cdaa39f901ee75d32b02efe6" translate="yes" xml:space="preserve">
          <source>Lookups search the underlying mappings successively until a key is found.</source>
          <target state="translated">Поиск последовательно выполняет поиск лежащих в основе связок до тех пор,пока не будет найден ключ.</target>
        </trans-unit>
        <trans-unit id="f4717469d98280c4746039a514a7e2bacbf3bfde" translate="yes" xml:space="preserve">
          <source>Mapping two lists into a dictionary</source>
          <target state="translated">Отображение двух списков в словаре</target>
        </trans-unit>
        <trans-unit id="f9f1aa4bbd26bc6ea841d2cf5df62d3193846a18" translate="yes" xml:space="preserve">
          <source>More comments:</source>
          <target state="translated">Больше комментариев:</target>
        </trans-unit>
        <trans-unit id="8ef25359578b2efe9adb36ef344ee5b9c98419fb" translate="yes" xml:space="preserve">
          <source>Mutating methods in the standard library (like &lt;code&gt;.update()&lt;/code&gt;) return &lt;code&gt;None&lt;/code&gt; by convention, so this pattern will work on those too. If you're using a method that doesn't follow this convention, then &lt;code&gt;or&lt;/code&gt; may not work. But, you can use a tuple display and index to make it a single expression, instead. This works regardless of what the first element evaluates to.</source>
          <target state="translated">Методы Mutating в стандартной библиотеке (например, &lt;code&gt;.update()&lt;/code&gt; ) возвращают &lt;code&gt;None&lt;/code&gt; по соглашению, поэтому этот шаблон будет работать и для них. Если вы используете метод, который не следует этому соглашению, тогда &lt;code&gt;or&lt;/code&gt; может не работать. Но вы можете использовать отображение и индекс кортежа, чтобы сделать его одним выражением. Это работает независимо от того, что оценивает первый элемент.</target>
        </trans-unit>
        <trans-unit id="4a4fd9ea7e1bb91ce1c283ee8443542d3f4b5d79" translate="yes" xml:space="preserve">
          <source>My explanation of Python's &lt;strong&gt;dictionary implementation&lt;/strong&gt;, updated for 3.6.</source>
          <target state="translated">Мое объяснение &lt;strong&gt;реализации словаря&lt;/strong&gt; Python, обновлено для 3.6.</target>
        </trans-unit>
        <trans-unit id="5451c5e024244f0cb1d2a834192850cb982c87b8" translate="yes" xml:space="preserve">
          <source>My response: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</source>
          <target state="translated">Мой ответ: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; самом деле кажется мне намного понятнее, если мы действительно обеспокоены читаемостью. И это не совместимо с форвардом, так как Python 2 все больше и больше не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="a06152fa7c2b5a4be7f84d7628e46f2fff8180df" translate="yes" xml:space="preserve">
          <source>Not yet on Python 3.5, but want a &lt;em&gt;single expression&lt;/em&gt;</source>
          <target state="translated">Еще не на Python 3.5, но хочу &lt;em&gt;одно выражение&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95a364312f027f57dff95eb6f993224d40d8d5d7" translate="yes" xml:space="preserve">
          <source>Note that we can merge in with literal notation as well:</source>
          <target state="translated">Обратите внимание,что мы можем слиться и с буквальной нотацией:</target>
        </trans-unit>
        <trans-unit id="85f3316c38e547312844b492fc59334cdc24d0e8" translate="yes" xml:space="preserve">
          <source>Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case.</source>
          <target state="translated">Конечно,если вы много используете результат,то в какой-то момент достигнете предела,когда создание настоящего объединенного словаря стало бы более быстрым решением.Как я уже говорил,это зависит от вашего варианта использования.</target>
        </trans-unit>
        <trans-unit id="48ac36a7075dd373be352f2840bc51e3b09e06b1" translate="yes" xml:space="preserve">
          <source>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative &lt;code&gt;z2&lt;/code&gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the &lt;code&gt;timeit&lt;/code&gt; module that comes with Python.</source>
          <target state="translated">По крайней мере, на моей машине (довольно обычный x86_64 с Python 2.5.2) альтернатива &lt;code&gt;z2&lt;/code&gt; не только короче и проще, но и значительно быстрее. Вы можете убедиться в этом сами, используя модуль &lt;code&gt;timeit&lt;/code&gt; , который поставляется с Python.</target>
        </trans-unit>
        <trans-unit id="5693b010303f40e7b6b2989cf211c19701b8fd90" translate="yes" xml:space="preserve">
          <source>One would expect a result of something like this:</source>
          <target state="translated">Можно было бы ожидать результата от чего-то подобного:</target>
        </trans-unit>
        <trans-unit id="36ccf0d2daf5f0450415093a23f65782376fed7c" translate="yes" xml:space="preserve">
          <source>Or even</source>
          <target state="translated">Или даже</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="af936431e91ad36e97d16ad3fcc34657b6a9c683" translate="yes" xml:space="preserve">
          <source>Performance Analysis</source>
          <target state="translated">Анализ эффективности</target>
        </trans-unit>
        <trans-unit id="ccac62c217a26cb3460e444b60d39cb6b574af2e" translate="yes" xml:space="preserve">
          <source>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</source>
          <target state="translated">Лично мне больше всего нравится эта версия,потому что она достаточно хорошо описывает то,что я хочу в едином функциональном синтаксисе.Единственная небольшая проблема заключается в том,что не совсем очевидно,что значения из y имеют приоритет над значениями из x,но я не думаю,что это трудно понять.</target>
        </trans-unit>
        <trans-unit id="f2f88b2c502c6ef38181787f69def28accd2b7dd" translate="yes" xml:space="preserve">
          <source>Python 3.5 (PEP 448) allows a nicer syntax option:</source>
          <target state="translated">Python 3.5 (PEP 448)позволяет использовать более красивый синтаксис:</target>
        </trans-unit>
        <trans-unit id="31fc173b6064c40551f851f890b41889dde4879b" translate="yes" xml:space="preserve">
          <source>Recursively/deep update a dict</source>
          <target state="translated">Рекурсивно обновлять диктат</target>
        </trans-unit>
        <trans-unit id="e28a5f1ec1369c5c0c25a05a06b177d5f18ef2a0" translate="yes" xml:space="preserve">
          <source>Resources on Dictionaries</source>
          <target state="translated">Ресурсы по словарям</target>
        </trans-unit>
        <trans-unit id="8e32dd9f3b57b6ccc2e40d0141dc5fa237e75edf" translate="yes" xml:space="preserve">
          <source>Response to comments</source>
          <target state="translated">Ответ на замечания</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">Результаты:</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="0d93e84a8e035a40c9b757a07ddde97ea07443d0" translate="yes" xml:space="preserve">
          <source>Say you have two dicts and you want to merge them into a new dict without altering the original dicts:</source>
          <target state="translated">Скажем,что у вас есть два диктата,и вы хотите объединить их в новый диктат,не изменяя исходных диктатов:</target>
        </trans-unit>
        <trans-unit id="e04ba6f40f9b2060e8c41a7b09e4e62c77d60e4e" translate="yes" xml:space="preserve">
          <source>Similarly, taking the union of &lt;code&gt;items()&lt;/code&gt; in Python 3 (&lt;code&gt;viewitems()&lt;/code&gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, &lt;strong&gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:&lt;/strong&gt;</source>
          <target state="translated">Аналогично, объединение &lt;code&gt;items()&lt;/code&gt; в Python 3 ( &lt;code&gt;viewitems()&lt;/code&gt; в Python 2.7) также не будет выполнено, если значения являются объектами, которые не подлежат изменению (например, списками). Даже если ваши значения являются хэшируемыми, &lt;strong&gt;так как наборы семантически неупорядочены, поведение не определено в отношении приоритета.&lt;/strong&gt; &lt;strong&gt;Так что не делайте этого:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a63b49fb1159980c455f7b80a5475a5b7a4bbded" translate="yes" xml:space="preserve">
          <source>Simple solution using itertools that preserves order (latter dicts have precedence)</source>
          <target state="translated">Простое решение с использованием итертуалов,которые сохраняют порядок (последние имеют приоритет)</target>
        </trans-unit>
        <trans-unit id="1ce6c799d807e8667caa62ff4d2ed81872b44880" translate="yes" xml:space="preserve">
          <source>Simple, readable, performant. You &lt;em&gt;know&lt;/em&gt;&lt;code&gt;update()&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt;, which is a false value. So the above expression will always evaluate to &lt;code&gt;x&lt;/code&gt;, after updating it.</source>
          <target state="translated">Простой, читаемый, производительный. Вы &lt;em&gt;знаете,&lt;/em&gt; &lt;code&gt;update()&lt;/code&gt; всегда возвращает &lt;code&gt;None&lt;/code&gt; , что является ложным значением. Поэтому приведенное выше выражение всегда будет иметь значение &lt;code&gt;x&lt;/code&gt; после его обновления.</target>
        </trans-unit>
        <trans-unit id="f32e703bd34c95af93956212150aad7a9788da7d" translate="yes" xml:space="preserve">
          <source>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</source>
          <target state="translated">Итак,на порядок медленнее для поиска.Я поклонник Chainmap,но выглядит менее практично там,где может быть много просмотров.</target>
        </trans-unit>
        <trans-unit id="a8e2fa47ec0878caa65f8502de5b8cbd1c0786ed" translate="yes" xml:space="preserve">
          <source>Thanks rednaw for edits.</source>
          <target state="translated">Спасибо Реднау за редактирование.</target>
        </trans-unit>
        <trans-unit id="d4d79546dfca81b3339e87ff38237ad185b2fb4d" translate="yes" xml:space="preserve">
          <source>The 'one' entry should have had 'depth_2' and 'extra' as items inside its dictionary if it truly was a merge.</source>
          <target state="translated">Единственная&quot; запись должна была иметь в своем словаре &quot;depth_2&quot; и &quot;extra&quot; в качестве элементов,если это действительно было слияние.</target>
        </trans-unit>
        <trans-unit id="d3e70f05e7f6d91452e134d86664d8e73a4261ca" translate="yes" xml:space="preserve">
          <source>The best version I could think while not using copy would be:</source>
          <target state="translated">Лучшая версия,о которой я мог бы думать,не используя копию,была бы:</target>
        </trans-unit>
        <trans-unit id="14a3e754832e898bf1e858d57c5ffe3967bb05c5" translate="yes" xml:space="preserve">
          <source>The deep merge that rcwesick gave also creates the same result.</source>
          <target state="translated">Глубокое слияние,которое дала rcwesick,также создает тот же результат.</target>
        </trans-unit>
        <trans-unit id="a312af1c908fc9ad75fb286e3bc170573e2c6cc0" translate="yes" xml:space="preserve">
          <source>The desired result is to get a new dictionary (&lt;code&gt;z&lt;/code&gt;) with the values merged, and the second dict's values overwriting those from the first.</source>
          <target state="translated">Желаемый результат - получить новый словарь ( &lt;code&gt;z&lt;/code&gt; ) со слитыми значениями, а значения второго dict перезаписывают значения из первого.</target>
        </trans-unit>
        <trans-unit id="99cefd2e5a500633b962557b5eb27824141a25b8" translate="yes" xml:space="preserve">
          <source>The following is done on Ubuntu 14.04</source>
          <target state="translated">На Убунту 14.04 сделано следующее.</target>
        </trans-unit>
        <trans-unit id="c3b7bd83073daf49138869cf80438ea437175ad6" translate="yes" xml:space="preserve">
          <source>The official Python &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;docs on dictionaries&lt;/a&gt;</source>
          <target state="translated">Официальные &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;документы&lt;/a&gt; Python по словарям</target>
        </trans-unit>
        <trans-unit id="7a8b9b328f9958cca0a11b9acc4b8cd695c2636b" translate="yes" xml:space="preserve">
          <source>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</source>
          <target state="translated">Проблема,которую я имею с решениями,перечисленными на сегодняшний день,заключается в том,что в объединенном словаре значение для ключа &quot;b&quot; равно 10,но,по моему мнению,оно должно быть 12.В этом свете я представляю следующее:</target>
        </trans-unit>
        <trans-unit id="9fcad77208db870fca468aadd90c4da8d6ce0d45" translate="yes" xml:space="preserve">
          <source>These approaches are less performant, but they will provide correct behavior.
They will be &lt;em&gt;much less&lt;/em&gt; performant than &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they &lt;em&gt;do&lt;/em&gt; respect the order of precedence (latter dicts have precedence)</source>
          <target state="translated">Эти подходы менее эффективны, но они обеспечат правильное поведение. Они будут &lt;em&gt;гораздо менее&lt;/em&gt; производительными, чем &lt;code&gt;copy&lt;/code&gt; и &lt;code&gt;update&lt;/code&gt; или новая распаковка, потому что они выполняют итерацию по каждой паре ключ-значение на более высоком уровне абстракции, но они уважают порядок приоритета (последние диктаты имеют приоритет)</target>
        </trans-unit>
        <trans-unit id="a0ea664e2a3188bf488d6c2a6055af74fb3539bf" translate="yes" xml:space="preserve">
          <source>This can be done with a single dict comprehension:</source>
          <target state="translated">Это может быть сделано с единым пониманием диктата:</target>
        </trans-unit>
        <trans-unit id="36e6d4df98468539933d14acc5debf6efc5fe4ba" translate="yes" xml:space="preserve">
          <source>This can slow you down if you have a lot of lookups in your application:</source>
          <target state="translated">Это может замедлить вашу работу,если у вас много просмотров в вашем приложении:</target>
        </trans-unit>
        <trans-unit id="19c42edc088b07647e75e1b22d2ce503ca0cd824" translate="yes" xml:space="preserve">
          <source>This discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the &lt;code&gt;update&lt;/code&gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</source>
          <target state="translated">В этом обсуждении все еще отсутствует что-то важное, а именно сравнение производительности этих альтернатив с &amp;laquo;очевидным&amp;raquo; способом объединения двух списков: с использованием метода &lt;code&gt;update&lt;/code&gt; . Чтобы попытаться удержать вещи в равных условиях с выражениями, ни одно из которых не изменяет x или y, я собираюсь сделать копию x вместо ее изменения на месте следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc1c7903eae69f6f9e6f83fcb5785373d15617e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates what happens when values are unhashable:</source>
          <target state="translated">Этот пример демонстрирует,что происходит,когда значения не поддаются хэшированию:</target>
        </trans-unit>
        <trans-unit id="9157d19d33dc20ac6d37fac9da93fd7fa473ca0f" translate="yes" xml:space="preserve">
          <source>This function will work in Python 2 and 3 for all dicts. e.g. given dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Эта функция будет работать в Python 2 и 3 для всех диктов. например, данные диктует от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1dca0e3af9d62b26b6d4ca040a8f1540fe8eaa2f" translate="yes" xml:space="preserve">
          <source>This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</source>
          <target state="translated">Это несоответствие было плохим,учитывая другие реализации Python (Pypy,Jython,IronPython).Таким образом,оно было исправлено на Python 3,так как это использование могло привести к перерыву в работе.</target>
        </trans-unit>
        <trans-unit id="3c565024f23a6cd2ae73023603f11cac8eb9232b" translate="yes" xml:space="preserve">
          <source>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</source>
          <target state="translated">Это, вероятно, не будет популярным ответом, но вы почти наверняка не хотите этого делать. Если вы хотите копию, которая является слиянием, то используйте копию (или &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;глубокую копию&lt;/a&gt; , в зависимости от того, что вы хотите), а затем обновите. Две строки кода гораздо более читабельны - более Pythonic - чем создание одной строки с помощью .items () + .items (). Явное лучше, чем неявное.</target>
        </trans-unit>
        <trans-unit id="02a2f32a05821cacdddcb95030b2675f25361e82" translate="yes" xml:space="preserve">
          <source>This should solve your problem.</source>
          <target state="translated">Это должно решить твою проблему.</target>
        </trans-unit>
        <trans-unit id="686c1f44b9d06635a40727397360cca5fb0d76bc" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;dict&lt;/code&gt; constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</source>
          <target state="translated">При этом используется конструктор &lt;code&gt;dict&lt;/code&gt; , и он очень быстрый и эффективный в использовании памяти (даже немного больше, чем наш двухэтапный процесс), но если вы точно не знаете, что здесь происходит (то есть второй dict передается в качестве аргументов ключевого слова в dict constructor), его трудно читать, оно не предназначено для использования и поэтому не является Pythonic.</target>
        </trans-unit>
        <trans-unit id="463fe46eebffb482307a2b0a04183fc401c2acf9" translate="yes" xml:space="preserve">
          <source>This will, as you want it, put the final dict in &lt;code&gt;z&lt;/code&gt;, and make the value for key &lt;code&gt;b&lt;/code&gt; be properly overridden by the second (&lt;code&gt;y&lt;/code&gt;) dict's value:</source>
          <target state="translated">Это, как вы хотите, поместит окончательный dict в &lt;code&gt;z&lt;/code&gt; , и значение ключа &lt;code&gt;b&lt;/code&gt; будет должным образом переопределено значением второго ( &lt;code&gt;y&lt;/code&gt; ) dict:</target>
        </trans-unit>
        <trans-unit id="827f523c69cfc77e578e7347bfd913a0423d4505" translate="yes" xml:space="preserve">
          <source>Usage (tested in python 3):</source>
          <target state="translated">Использование (протестировано на питоне 3):</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e8a5cd8514bfb309e8f3f05950c1200e457ea3dc" translate="yes" xml:space="preserve">
          <source>Using chain also, does not work:</source>
          <target state="translated">Использование цепи также не работает:</target>
        </trans-unit>
        <trans-unit id="cfbc3d78519156ea4d38e12324b7f22474d7df90" translate="yes" xml:space="preserve">
          <source>When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed.</source>
          <target state="translated">При использовании этого нового объекта он будет вести себя как объединенный словарь,но при этом будет иметь постоянное время создания и постоянный объем памяти,оставляя исходные словари нетронутыми.Его создание значительно дешевле,чем в других предлагаемых решениях.</target>
        </trans-unit>
        <trans-unit id="2a93691216c27b37fa080f1bf21889060fcd92b2" translate="yes" xml:space="preserve">
          <source>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</source>
          <target state="translated">Несмотря на то,что на вопрос уже несколько раз давали ответ,это простое решение проблемы еще не было перечислено.</target>
        </trans-unit>
        <trans-unit id="cd809d0ef673f12b00a606ccbe54a8115b1c82af" translate="yes" xml:space="preserve">
          <source>Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I'll update this later once I write a method that does a true merge.</source>
          <target state="translated">Да,это будет работать для объединения примеров словарей,но ни один из них не является общим механизмом для объединения.Я обновлю это позже,как только напишу метод,который делает истинное слияние.</target>
        </trans-unit>
        <trans-unit id="2aa391717295fad536baefee8bd2d60a19871d4f" translate="yes" xml:space="preserve">
          <source>Yes. I must refer you back to the question, which is asking for a &lt;em&gt;shallow&lt;/em&gt; merge of &lt;strong&gt;&lt;em&gt;two&lt;/em&gt;&lt;/strong&gt; dictionaries, with the first's values being overwritten by the second's - in a single expression.</source>
          <target state="translated">Да. Я должен отослать вас обратно к вопросу, который требует &lt;em&gt;поверхностного&lt;/em&gt; слияния &lt;strong&gt;&lt;em&gt;двух&lt;/em&gt;&lt;/strong&gt; словарей, при этом значения первого перезаписываются значениями второго - в одном выражении.</target>
        </trans-unit>
        <trans-unit id="ee121489b6e0d4a946801627644c8e2674d2d13d" translate="yes" xml:space="preserve">
          <source>You can also chain the dicts manually inside a dict comprehension:</source>
          <target state="translated">Вы также можете связать диктаты вручную внутри понимания диктата:</target>
        </trans-unit>
        <trans-unit id="e8a9e7391a7cebd4162276bf43babcfe429d286a" translate="yes" xml:space="preserve">
          <source>You can also make a function to merge an undefined number of dicts, from zero to a very large number:</source>
          <target state="translated">Вы также можете сделать функцию для объединения неопределенного числа знаков,от нуля до очень большого числа:</target>
        </trans-unit>
        <trans-unit id="d99a90478f3ad33b4d2bc5f254632c7bfd37d59d" translate="yes" xml:space="preserve">
          <source>You can also use this class to make a kind of copy-on-write dictionary:</source>
          <target state="translated">Вы также можете использовать этот класс для создания своего рода словаря копирования на запись:</target>
        </trans-unit>
        <trans-unit id="9cedfd6f2171ececea9d197f9ad610009dfddd7f" translate="yes" xml:space="preserve">
          <source>You could also do this of course if you don't care about copying it:</source>
          <target state="translated">Ты,конечно же,можешь это сделать,если тебя не волнует,что ты это скопируешь:</target>
        </trans-unit>
        <trans-unit id="58f29ce54e05025dbf326102828358d60d6406e0" translate="yes" xml:space="preserve">
          <source>You could also write this as</source>
          <target state="translated">Вы также можете написать это как</target>
        </trans-unit>
        <trans-unit id="3ef1d0278a40be0903df836eb1993ad9c45936ba" translate="yes" xml:space="preserve">
          <source>You could use a lambda instead.</source>
          <target state="translated">Тебе бы не помешала лямбда.</target>
        </trans-unit>
        <trans-unit id="3e45b5c2910ea1c81696ad9de828761856f8df26" translate="yes" xml:space="preserve">
          <source>You said you wanted one expression, so I abused &lt;code&gt;lambda&lt;/code&gt; to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</source>
          <target state="translated">Вы сказали, что хотите одно выражение, поэтому я злоупотребил &lt;code&gt;lambda&lt;/code&gt; связыванием имени и кортежами, чтобы переопределить лямбда-ограничение одного выражения. Не стесняйтесь съеживаться.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9158b7790079767a2ee5155681bc0537e04269f5" translate="yes" xml:space="preserve">
          <source>and key value pairs in &lt;code&gt;g&lt;/code&gt; will take precedence over dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;, and so on.</source>
          <target state="translated">и пары &amp;laquo;ключ-значение&amp;raquo; в &lt;code&gt;g&lt;/code&gt; будут иметь приоритет над параметрами от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;f&lt;/code&gt; и т. д.</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">и сейчас:</target>
        </trans-unit>
        <trans-unit id="6dc92c5dffb9e2875bb5be2d30824a953e7e8fee" translate="yes" xml:space="preserve">
          <source>and then you have a single expression:</source>
          <target state="translated">и тогда у тебя есть единственное выражение:</target>
        </trans-unit>
        <trans-unit id="538141bce772b5861479742348306cced3786ed9" translate="yes" xml:space="preserve">
          <source>and you would have to explicitly create them as lists, e.g. &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt;. This is a waste of resources and computation power.</source>
          <target state="translated">и вам придется явно создавать их в виде списков, например, &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt; . Это пустая трата ресурсов и вычислительной мощности.</target>
        </trans-unit>
        <trans-unit id="feeb579278407bb98d8960ea0156b0f057ac30d9" translate="yes" xml:space="preserve">
          <source>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</source>
          <target state="translated">как это делает Тони,но (что неудивительно)разница в нотации оказывается не оказывает заметного влияния на производительность.Используйте то,что вам кажется правильным.Конечно,он абсолютно прав,указывая на то,что двухступенчатая версия намного проще для понимания.</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">вместо</target>
        </trans-unit>
        <trans-unit id="c5d0aeaef87c64e87fa64d76c410acb93a6f6869" translate="yes" xml:space="preserve">
          <source>lead me to conclude that &lt;code&gt;z3&lt;/code&gt; is somewhat faster than &lt;code&gt;z1&lt;/code&gt;, but not nearly as fast as &lt;code&gt;z2&lt;/code&gt;.  Definitely not worth all the extra typing.</source>
          <target state="translated">привести меня к выводу, что &lt;code&gt;z3&lt;/code&gt; несколько быстрее, чем &lt;code&gt;z1&lt;/code&gt; , но не так быстро, как &lt;code&gt;z2&lt;/code&gt; . Определенно не стоит всего лишнего набора текста.</target>
        </trans-unit>
        <trans-unit id="3846c179246b1e2fb787941b7f16f2f7ff81ff9b" translate="yes" xml:space="preserve">
          <source>or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</source>
          <target state="translated">или на питоне 2.6 (и,возможно,уже в 2.4,когда были введены выражения генератора):</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
