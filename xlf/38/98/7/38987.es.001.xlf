<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/38987">
    <body>
      <group id="38987">
        <trans-unit id="762f1a0e69169610829fa8a43f4c74678cbb8a23" translate="yes" xml:space="preserve">
          <source>(For Python2.7* only; there are simpler solutions for Python3*.)</source>
          <target state="translated">(Sólo para Python2.7*;hay soluciones más simples para Python3*.)</target>
        </trans-unit>
        <trans-unit id="26cef14df0be957675f0530429b3a7bde6a3b375" translate="yes" xml:space="preserve">
          <source>(That is, of course, equivalent to &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)</source>
          <target state="translated">(Eso es, por supuesto, equivalente a &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt; , pero si su versi&amp;oacute;n de Python es lo suficientemente nueva para eso, entonces el estilo PEP 448 estar&amp;aacute; disponible).</target>
        </trans-unit>
        <trans-unit id="c983206bb5c1b9997bd209ce2acce7e071f69644" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;or a&lt;/code&gt; bit in the &lt;code&gt;lambda&lt;/code&gt; is necessary because &lt;code&gt;dict.update&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt; on success.)</source>
          <target state="translated">(El &lt;code&gt;or a&lt;/code&gt; poco en el &lt;code&gt;lambda&lt;/code&gt; es necesario porque &lt;code&gt;dict.update&lt;/code&gt; siempre devuelve &lt;code&gt;None&lt;/code&gt; en caso de &amp;eacute;xito).</target>
        </trans-unit>
        <trans-unit id="fc6520d839da1d73fe3d2dc5120a168296e3c8df" translate="yes" xml:space="preserve">
          <source>(To be extra-clear, the last-one-wins conflict-handling of &lt;code&gt;dict.update()&lt;/code&gt; is what I'm looking for as well.)</source>
          <target state="translated">(Para ser m&amp;aacute;s claro, lo &amp;uacute;ltimo que &lt;code&gt;dict.update()&lt;/code&gt; es el manejo de conflictos de dict.update () tambi&amp;eacute;n es lo que estoy buscando).</target>
        </trans-unit>
        <trans-unit id="59798fb8386a0602fdd9b6380f0da9334a75b531" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - talk by Brandon Rhodes at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - charla de Brandon Rhodes en Pycon 2017</target>
        </trans-unit>
        <trans-unit id="8b08b9102b840351132b620d290b145d977714b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Modern Python Dictionaries, A Confluence of Great Ideas&lt;/a&gt; - talk by Raymond Hettinger at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Diccionarios modernos de Python, una confluencia de grandes ideas&lt;/a&gt; - charla de Raymond Hettinger en Pycon 2017</target>
        </trans-unit>
        <trans-unit id="64eaafdd6d026ca8e8e81c2df03a5ad7e0e4f273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; is still the most readable solution for Python 2. Readability counts.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; sigue siendo la soluci&amp;oacute;n m&amp;aacute;s legible para Python 2. La legibilidad cuenta.</target>
        </trans-unit>
        <trans-unit id="1bc9f47831b8850843d4bfab7500ddd5d5e01499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;itertools.chain&lt;/code&gt; will chain the iterators over the key-value pairs in the correct order:</source>
          <target state="translated">&lt;code&gt;itertools.chain&lt;/code&gt; encadenar&amp;aacute; los iteradores sobre los pares clave-valor en el orden correcto:</target>
        </trans-unit>
        <trans-unit id="8762df6a9a82f0b36d9893287201772efe7c7ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; has bad performance. See &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; tiene un mal rendimiento. Ver &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b30516353c8b7de805be8527f19faa1ebcd7e111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but &lt;code&gt;z2&lt;/code&gt; always seems to come out ahead.  (If you get inconsistent results for the &lt;em&gt;same&lt;/em&gt; test, try passing in &lt;code&gt;-r&lt;/code&gt; with a number larger than the default 3.)</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; gana por un factor de 3.5 m&amp;aacute;s o menos. Parece que diferentes diccionarios arrojan resultados bastante diferentes, pero &lt;code&gt;z2&lt;/code&gt; siempre parece salir adelante. (Si obtiene resultados inconsistentes para la &lt;em&gt;misma&lt;/em&gt; prueba, intente pasar &lt;code&gt;-r&lt;/code&gt; con un n&amp;uacute;mero mayor que el predeterminado 3.)</target>
        </trans-unit>
        <trans-unit id="73fb6424cfd11bb18a1c574f3c35c5c9d895216f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by about a factor of 10.  That's a pretty big win in my book!</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; gana por un factor de 10. &amp;iexcl;Esa es una gran victoria en mi libro!</target>
        </trans-unit>
        <trans-unit id="684683c3cfba4b7ae046f86966f4cf852b750b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{**x, **y}&lt;/code&gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</source>
          <target state="translated">&lt;code&gt;{**x, **y}&lt;/code&gt; no parece manejar diccionarios anidados. el contenido de las claves anidadas simplemente se sobrescribe, no se fusiona [...] Termin&amp;eacute; quemado por estas respuestas que no se fusionan recursivamente y me sorprendi&amp;oacute; que nadie lo mencionara. En mi interpretaci&amp;oacute;n de la palabra &quot;fusionar&quot; estas respuestas describen &quot;actualizar un dict con otro&quot;, y no fusionar.</target>
        </trans-unit>
        <trans-unit id="4acb6eec05cf3410b42a7e8367ceb7218e526e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; diccionarios&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c750c4b4d745d4a88f3eea8b03ce9ceff63b397a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Python 3.0 and later&lt;/strong&gt;, you can use &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt;&lt;code&gt;collections.ChainMap&lt;/code&gt;&lt;/a&gt; which groups multiple dicts or other mappings together to create a single, updateable view:</source>
          <target state="translated">&lt;strong&gt;En Python 3.0 y&lt;/strong&gt; versiones &lt;strong&gt;posteriores&lt;/strong&gt; , puede usar &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt; &lt;code&gt;collections.ChainMap&lt;/code&gt; &lt;/a&gt; que agrupa varios dictados u otras asignaciones para crear una vista &amp;uacute;nica y actualizable:</target>
        </trans-unit>
        <trans-unit id="047862db1890195e52368684bf93f77d9a3b9706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this has become a popular answer, but it is important to point out that if &lt;code&gt;y&lt;/code&gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido is not a fan&lt;/a&gt;. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta se ha convertido en una respuesta popular, pero es importante se&amp;ntilde;alar que si &lt;code&gt;y&lt;/code&gt; tiene alguna clave que no sea de cadena, el hecho de que esto funcione es un abuso de los detalles de implementaci&amp;oacute;n de CPython, y no funciona en Python 3 , o en PyPy, IronPython o Jython. Adem&amp;aacute;s, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido no es fan&amp;aacute;tico&lt;/a&gt; . Por lo tanto, no puedo recomendar esta t&amp;eacute;cnica para un c&amp;oacute;digo port&amp;aacute;til compatible con versiones posteriores o de implementaci&amp;oacute;n cruzada, lo que realmente significa que debe evitarse por completo.</target>
        </trans-unit>
        <trans-unit id="56c781e5adb8bad76d8066d046d1c97e28021043" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Dos diccionarios&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d78daed80f94bbc7108a07b9e271b9fca2cca5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update for Python 3.5 and later&lt;/strong&gt;: You can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; extended dictionary packing and unpacking.  This is fast and easy:</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n para Python 3.5 y posterior&lt;/strong&gt; : puede usar el empaquetado y desempaquetado extendido del diccionario &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; . Esto es r&amp;aacute;pido y f&amp;aacute;cil:</target>
        </trans-unit>
        <trans-unit id="4ad22f81594d7603a3fcfc3c26100cb43cf77997" translate="yes" xml:space="preserve">
          <source>A couple more points for python 3. First, note that the &lt;code&gt;dict(x, **y)&lt;/code&gt; trick won't work in python 3 unless the keys in &lt;code&gt;y&lt;/code&gt; are strings.</source>
          <target state="translated">Un par de puntos m&amp;aacute;s para python 3. Primero, tenga en cuenta que el truco &lt;code&gt;dict(x, **y)&lt;/code&gt; no funcionar&amp;aacute; en python 3 a menos que las teclas en &lt;code&gt;y&lt;/code&gt; sean cadenas.</target>
        </trans-unit>
        <trans-unit id="52323533fde1038ac6c3239bddef21ed2cd7faa9" translate="yes" xml:space="preserve">
          <source>A few quick tests, e.g.</source>
          <target state="translated">Unas cuantas pruebas rápidas,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="5b8d1b61a251a1f4f5f96af395d52351a9c2d234" translate="yes" xml:space="preserve">
          <source>A new syntax for this, proposed in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; and &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;available as of Python 3.5&lt;/a&gt;, is</source>
          <target state="translated">Una nueva sintaxis para esto, propuesta en &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; y &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;disponible a partir de Python 3.5&lt;/a&gt; , es</target>
        </trans-unit>
        <trans-unit id="d20312b0c332092c94533e037801b46f85f6ff75" translate="yes" xml:space="preserve">
          <source>A typical result:</source>
          <target state="translated">Un resultado típico:</target>
        </trans-unit>
        <trans-unit id="79346271c215b10d408c3a24960c3a8434e1b144" translate="yes" xml:space="preserve">
          <source>Abuse leading to a one-expression solution for &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew's answer&lt;/a&gt;:</source>
          <target state="translated">Abuso que conduce a una soluci&amp;oacute;n de una expresi&amp;oacute;n para &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;la respuesta de Matthew&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bc0fcdd15355dfc94d498254e338806fd4947b01" translate="yes" xml:space="preserve">
          <source>After comparing those two, I wondered if &lt;code&gt;z1&lt;/code&gt;'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</source>
          <target state="translated">Despu&amp;eacute;s de comparar esos dos, me preguntaba si el bajo rendimiento de &lt;code&gt;z1&lt;/code&gt; podr&amp;iacute;a atribuirse a la sobrecarga de construir las dos listas de elementos, lo que a su vez me llev&amp;oacute; a preguntarme si esta variaci&amp;oacute;n podr&amp;iacute;a funcionar mejor:</target>
        </trans-unit>
        <trans-unit id="3e513e02e5ffef80d9363703f5c690e41e7d947a" translate="yes" xml:space="preserve">
          <source>Again, it doesn't work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. &lt;code&gt;dict&lt;/code&gt; broke this consistency in Python 2:</source>
          <target state="translated">Nuevamente, no funciona para 3 cuando las teclas no son cadenas. El contrato de llamada impl&amp;iacute;cito es que los espacios de nombres toman dictados comunes, mientras que los usuarios solo deben pasar argumentos de palabras clave que son cadenas. Todas las otras callables lo hicieron cumplir. &lt;code&gt;dict&lt;/code&gt; rompi&amp;oacute; esta consistencia en Python 2:</target>
        </trans-unit>
        <trans-unit id="37903af1bb3d70c3129ae7ad37c51d78652644c4" translate="yes" xml:space="preserve">
          <source>Also, Raymond Hettinger's Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;answer&lt;/a&gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;from the docs&lt;/a&gt; it looks like it sequentially looks through a list of all the dicts for each lookup:</source>
          <target state="translated">Adem&amp;aacute;s, la &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;respuesta de&lt;/a&gt; Raymond Hettinger en Chainmap es bastante elegante, ya que puede tomar un n&amp;uacute;mero arbitrario de dictados como argumentos, pero &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;de los documentos&lt;/a&gt; parece que busca secuencialmente una lista de todos los dictados para cada b&amp;uacute;squeda:</target>
        </trans-unit>
        <trans-unit id="b0e9fc794244c2742a7d0ad09b5a05d65fe3ab05" translate="yes" xml:space="preserve">
          <source>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only):</source>
          <target state="translated">Aunque no es tan diferente del siguiente uso del nuevo operador de morsa (sólo Python 3.8+):</target>
        </trans-unit>
        <trans-unit id="d64aa96c0baf8816d369af41816223f0d24166b8" translate="yes" xml:space="preserve">
          <source>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life &lt;em&gt;Guido van Rossum&lt;/em&gt; himself!  Someone else suggested half of this, but did not put it in a function.</source>
          <target state="translated">Entre estas respuestas dudosas y dudosas, este brillante ejemplo es la &amp;uacute;nica y &amp;uacute;nica buena manera de fusionar los dictados en Python, &amp;iexcl;respaldado por el dictador de por vida &lt;em&gt;Guido van Rossum&lt;/em&gt; ! Alguien m&amp;aacute;s sugiri&amp;oacute; la mitad de esto, pero no lo puso en una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b52eb9c15df1a810d482d29e8ce9cd10a248294b" translate="yes" xml:space="preserve">
          <source>An alternative:</source>
          <target state="translated">Una alternativa:</target>
        </trans-unit>
        <trans-unit id="ad2a670b2ebfd8d5864a5b7bac3632cc392444b7" translate="yes" xml:space="preserve">
          <source>And it is indeed a single expression.</source>
          <target state="translated">Y es,en efecto,una expresión única.</target>
        </trans-unit>
        <trans-unit id="2a68af8ef2b2b3fa71a55eee3ef7e2c9f937685a" translate="yes" xml:space="preserve">
          <source>And it's usage:</source>
          <target state="translated">Y es el uso:</target>
        </trans-unit>
        <trans-unit id="b0b7becbe9ec6ad7a7d8f73a304a045dc8bff483" translate="yes" xml:space="preserve">
          <source>Another hack you should not use:</source>
          <target state="translated">Otro hack que no deberías usar:</target>
        </trans-unit>
        <trans-unit id="a6df3197072e3a7d3b37983ee4cecb723db3ac60" translate="yes" xml:space="preserve">
          <source>Another, more concise, option:</source>
          <target state="translated">Otra opción más concisa:</target>
        </trans-unit>
        <trans-unit id="a90812f162710be72c6673269344a54ff85dec16" translate="yes" xml:space="preserve">
          <source>Answer on how to add new keys to a dictionary</source>
          <target state="translated">Respuesta sobre cómo añadir nuevas claves a un diccionario</target>
        </trans-unit>
        <trans-unit id="209d65032f4cdd91a49f9731f909c0f76b26af8f" translate="yes" xml:space="preserve">
          <source>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call
  x.update(y) and return x&quot;. Personally I find it more despicable than
  cool.</source>
          <target state="translated">Aparentemente dict(x,**y)está dando vueltas como &quot;cool hack&quot; para &quot;llamar a x.update(y)y devolver x&quot;.Personalmente lo encuentro más despreciable que genial.</target>
        </trans-unit>
        <trans-unit id="1107541abd6568cff679b7beb9d9536a95d8d98c" translate="yes" xml:space="preserve">
          <source>As suggested above, using two lines or writing a function is probably a better way to go.</source>
          <target state="translated">Como se ha sugerido anteriormente,usar dos líneas o escribir una función es probablemente una mejor manera de hacerlo.</target>
        </trans-unit>
        <trans-unit id="9c0a490ce334822e1a4fa03338b9164ecf3e1d0a" translate="yes" xml:space="preserve">
          <source>Assuming two dictionary of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dicts from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</source>
          <target state="translated">Suponiendo dos diccionarios de diccionarios,uno podría fusionarlos recursivamente en una sola función,pero hay que tener cuidado de no modificar los dictados de ninguna de las dos fuentes,y la forma más segura de evitarlo es hacer una copia al asignar los valores.Como las claves deben ser hashable y por lo tanto suelen ser inmutables,es inútil copiarlas:</target>
        </trans-unit>
        <trans-unit id="dda59ae142911ee5f815e7544ec0051e45b17ef5" translate="yes" xml:space="preserve">
          <source>Be pythonic. Use a &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;comprehension&lt;/a&gt;:</source>
          <target state="translated">S&amp;eacute; pit&amp;oacute;nico. Usa una &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;comprensi&amp;oacute;n&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e3e400046d95f67ae3dc116f87dadd13f71f972a" translate="yes" xml:space="preserve">
          <source>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;&lt;/a&gt;.</source>
          <target state="translated">Proponer contingencias para otros tipos de valores est&amp;aacute; mucho m&amp;aacute;s all&amp;aacute; del alcance de esta pregunta, por lo que le indicar&amp;eacute; &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;mi respuesta a la pregunta can&amp;oacute;nica sobre una &quot;combinaci&amp;oacute;n de diccionarios de diccionarios&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ead0c8a43030e9b4ba9dfd6743570550ad79d67" translate="yes" xml:space="preserve">
          <source>Critiques of Other Answers</source>
          <target state="translated">Críticas a otras respuestas</target>
        </trans-unit>
        <trans-unit id="c6a7b52934eb4c501f4a60e0e15c80a5bef14889" translate="yes" xml:space="preserve">
          <source>Demonstration:</source>
          <target state="translated">Demonstration:</target>
        </trans-unit>
        <trans-unit id="92ec7b2214ef32933d24b7351f97a6c052ccdf23" translate="yes" xml:space="preserve">
          <source>Depending on the use case it might not be necessary to create a &quot;real&quot; merged dictionary of the given input dictionaries.  A &lt;em&gt;view&lt;/em&gt; which does this might be sufficient in many cases, i. e. an object which acts &lt;em&gt;like&lt;/em&gt; the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak.</source>
          <target state="translated">Dependiendo del caso de uso, puede no ser necesario crear un diccionario combinado &quot;real&quot; de los diccionarios de entrada dados. Una &lt;em&gt;vista&lt;/em&gt; que hace esto podr&amp;iacute;a ser suficiente en muchos casos, es decir, un objeto que act&amp;uacute;a &lt;em&gt;como&lt;/em&gt; lo har&amp;iacute;a el diccionario combinado sin calcularlo por completo. Una versi&amp;oacute;n perezosa del diccionario combinado, por as&amp;iacute; decirlo.</target>
        </trans-unit>
        <trans-unit id="cf8c4ba0db8a8656b2f2f14c9fc473f2d81f924b" translate="yes" xml:space="preserve">
          <source>Despite what Guido says, &lt;code&gt;dict(x, **y)&lt;/code&gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords.</source>
          <target state="translated">A pesar de lo que dice Guido, &lt;code&gt;dict(x, **y)&lt;/code&gt; est&amp;aacute; en l&amp;iacute;nea con la especificaci&amp;oacute;n dict, que por cierto. funciona tanto para Python 2 como para 3. El hecho de que esto solo funcione para las claves de cadena es una consecuencia directa de c&amp;oacute;mo funcionan los par&amp;aacute;metros de palabras clave y no un corto de dict. Tampoco el uso del operador ** en este lugar es un abuso del mecanismo, de hecho ** fue dise&amp;ntilde;ado precisamente para aprobar dictados como palabras clave.</target>
        </trans-unit>
        <trans-unit id="3d03564e5b15ddf2ca88faedf123c311e047f26b" translate="yes" xml:space="preserve">
          <source>Dicts are intended to take hashable keys (e.g. frozensets or tuples), but &lt;strong&gt;this method fails in Python 3 when keys are not strings.&lt;/strong&gt;</source>
          <target state="translated">Los dictos est&amp;aacute;n destinados a tomar claves hashables (por ejemplo, congelados o tuplas), pero &lt;strong&gt;este m&amp;eacute;todo falla en Python 3 cuando las claves no son cadenas.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92d9a054b2288bd1fdd9bdb5e55a39fe412e39ab" translate="yes" xml:space="preserve">
          <source>Don't use what you see in the formerly accepted answer:</source>
          <target state="translated">No uses lo que ves en la respuesta anteriormente aceptada:</target>
        </trans-unit>
        <trans-unit id="ac898e4932c0e7dcb2f44c27b6aeabf7e53fc70c" translate="yes" xml:space="preserve">
          <source>Drawing on ideas here and elsewhere I've comprehended a function:</source>
          <target state="translated">Basándome en ideas de aquí y de otros lugares he comprendido una función:</target>
        </trans-unit>
        <trans-unit id="6c434bcb6a9e583ddd9818e466c89cc4d9768234" translate="yes" xml:space="preserve">
          <source>Even though the answers were good for this &lt;em&gt;shallow&lt;/em&gt; dictionary, none of the methods defined here actually do a deep dictionary merge.</source>
          <target state="translated">Aunque las respuestas fueron buenas para este diccionario &lt;em&gt;superficial&lt;/em&gt; , ninguno de los m&amp;eacute;todos definidos aqu&amp;iacute; realmente hace una fusi&amp;oacute;n profunda de diccionario.</target>
        </trans-unit>
        <trans-unit id="534c40ca3d6e9c332fb24d30e24866a5884fdf3c" translate="yes" xml:space="preserve">
          <source>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</source>
          <target state="translated">Ejemplo 1:diccionarios idénticos que asignan 20 enteros consecutivos a sí mismos:</target>
        </trans-unit>
        <trans-unit id="5d6468775d296b285af2d4eb8a4fbae02366f7da" translate="yes" xml:space="preserve">
          <source>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</source>
          <target state="translated">Ejemplo 2:diccionarios no superpuestos que asignan 252 cadenas cortas a números enteros y viceversa:</target>
        </trans-unit>
        <trans-unit id="51725d04b42e48c95f79400a9ef4bf6dd25aa363" translate="yes" xml:space="preserve">
          <source>Examples follow:</source>
          <target state="translated">A continuación,algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="417f84c0ab231efe074c376811a745ff0bbaefae" translate="yes" xml:space="preserve">
          <source>For dictionaries &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; becomes a shallowly merged dictionary with values from &lt;code&gt;y&lt;/code&gt; replacing those from &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Para los diccionarios &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; se convierte en un diccionario poco fusionado con valores de &lt;code&gt;y&lt;/code&gt; que reemplazan a los de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7a48fc65c8ec5e1d37a7ac34c58a2610a8718b" translate="yes" xml:space="preserve">
          <source>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</source>
          <target state="translated">Para los elementos con claves en ambos diccionarios ('b'),puedes controlar cuál termina en la salida poniendo ese último.</target>
        </trans-unit>
        <trans-unit id="66e4468118f12a49669432b591f48cae1db2757b" translate="yes" xml:space="preserve">
          <source>For python3-like behavior in version 2.7, the &lt;code&gt;viewitems&lt;/code&gt; method should work in place of &lt;code&gt;items&lt;/code&gt;:</source>
          <target state="translated">Para el comportamiento similar a python3 en la versi&amp;oacute;n 2.7, el m&amp;eacute;todo &lt;code&gt;viewitems&lt;/code&gt; deber&amp;iacute;a funcionar en lugar de &lt;code&gt;items&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05f303d92888701b00a3dca7391b2cd0ede31839" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;mailing list&lt;/a&gt;, Guido van Rossum, the creator of the language, wrote:</source>
          <target state="translated">De la &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;lista de correo&lt;/a&gt; , Guido van Rossum, el creador del lenguaje, escribi&amp;oacute;:</target>
        </trans-unit>
        <trans-unit id="9f63a1b687b569fbbc0abd2c72572d74cf9da35c" translate="yes" xml:space="preserve">
          <source>Here's an example of the usage being &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;remediated in django&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo del uso que se est&amp;aacute; &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;remediando en django&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fca813712109d4e2606defe725d888aa50dabf0" translate="yes" xml:space="preserve">
          <source>Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:</source>
          <target state="translated">He aquí un ejemplo en el que y debería tener precedencia,pero en cambio el valor de x se mantiene debido al orden arbitrario de los conjuntos:</target>
        </trans-unit>
        <trans-unit id="eebe1dc7075416ba2cee50e9bcf95a9e8f656e14" translate="yes" xml:space="preserve">
          <source>Here's the straight-forward code of &lt;code&gt;MergeDict&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo directo de &lt;code&gt;MergeDict&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22cca235a9f80cdc5840a3a67ad0dfe9f75c41d8" translate="yes" xml:space="preserve">
          <source>How can I get that final merged dictionary in &lt;code&gt;z&lt;/code&gt;, not &lt;code&gt;x&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo obtener ese diccionario combinado final en &lt;code&gt;z&lt;/code&gt; , no &lt;code&gt;x&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="5b9ed01b74e3b861c8ed3f17f0beccfffc6b9b9b" translate="yes" xml:space="preserve">
          <source>How can I merge two Python dictionaries in a single expression?</source>
          <target state="translated">¿Cómo puedo fusionar dos diccionarios de pitón en una sola expresión?</target>
        </trans-unit>
        <trans-unit id="8cb6e8e8ba5fdf4ce9658d5ca8f5d8770c5e9e85" translate="yes" xml:space="preserve">
          <source>How do I merge two dictionaries in a single expression</source>
          <target state="translated">¿Cómo puedo fusionar dos diccionarios en una sola expresión</target>
        </trans-unit>
        <trans-unit id="c8ef4565722ce18107b48e5f9a668982765902bd" translate="yes" xml:space="preserve">
          <source>However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</source>
          <target state="translated">Sin embargo,como muchas organizaciones todavía están en Python 2,es posible que desee hacer esto de una manera compatible con el pasado.La forma pitónica clásica,disponible en Python 2 y Python 3.0-3.4,es hacer esto como un proceso de dos pasos:</target>
        </trans-unit>
        <trans-unit id="a9e2146fc3d130671f68d310625226e3ccce8eab" translate="yes" xml:space="preserve">
          <source>I am fine with
  declaring dict({}, **{1:3}) illegal, since after all it is abuse of
  the ** mechanism.</source>
          <target state="translated">Estoy de acuerdo en declarar que dict({},**{1:3})ilegal,ya que después de todo es un abuso del mecanismo **.</target>
        </trans-unit>
        <trans-unit id="11606279b4a4e0c3d7cb38ec7e13e08435b369e0" translate="yes" xml:space="preserve">
          <source>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The &lt;code&gt;update()&lt;/code&gt; method would be what I need, if it returned its result instead of modifying a dictionary in-place.</source>
          <target state="translated">Tengo dos diccionarios Python, y quiero escribir una sola expresi&amp;oacute;n que devuelva estos dos diccionarios, combinados. El m&amp;eacute;todo &lt;code&gt;update()&lt;/code&gt; ser&amp;iacute;a lo que necesito, si devuelve su resultado en lugar de modificar un diccionario en el lugar.</target>
        </trans-unit>
        <trans-unit id="56b9ab3e4817a98d072aafad2224e1acb41d827f" translate="yes" xml:space="preserve">
          <source>I just use a simple helper function to solve the problem:</source>
          <target state="translated">Sólo uso una simple función de ayuda para resolver el problema:</target>
        </trans-unit>
        <trans-unit id="01c87e18558e3526b4877129f79e0ec875c6b499" translate="yes" xml:space="preserve">
          <source>I know this does not really fit the specifics of the questions (&quot;one liner&quot;), but since &lt;em&gt;none&lt;/em&gt; of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts.</source>
          <target state="translated">S&amp;eacute; que esto realmente no se ajusta a los detalles espec&amp;iacute;ficos de las preguntas (&quot;one liner&quot;), pero dado que &lt;em&gt;ninguna&lt;/em&gt; de las respuestas anteriores fue en esta direcci&amp;oacute;n, mientras que muchas respuestas abordaron el problema de rendimiento, sent&amp;iacute; que deber&amp;iacute;a contribuir con mis pensamientos.</target>
        </trans-unit>
        <trans-unit id="bfc266b6f982c3a928236a92c629662068d1aa8b" translate="yes" xml:space="preserve">
          <source>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</source>
          <target state="translated">Prefiero esta notación de todos modos,ya que parece más natural pensar en ella como una operación de unión de conjuntos que como una concatenación (como muestra el título).</target>
        </trans-unit>
        <trans-unit id="375e440687d005ef88e88f34c7f99f4a5ac588c4" translate="yes" xml:space="preserve">
          <source>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</source>
          <target state="translated">Le afirmo que es una incompetencia maliciosa escribir intencionadamente un código que sólo funciona en una versión de un idioma o que sólo funciona con ciertas restricciones arbitrarias.</target>
        </trans-unit>
        <trans-unit id="7bb9b5043cf7f5771f44311a303420b28a455fba" translate="yes" xml:space="preserve">
          <source>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</source>
          <target state="translated">Quería algo similar,pero con la capacidad de especificar cómo se fusionaban los valores de las claves duplicadas,así que lo pirateé (pero no lo probé mucho).Obviamente esto no es una expresión única,pero es una llamada a una función única.</target>
        </trans-unit>
        <trans-unit id="78af1cea1dc16ea253286cd3b93d54839ede508a" translate="yes" xml:space="preserve">
          <source>I'm only going to do the performance analysis of the usages known to behave correctly.</source>
          <target state="translated">Sólo voy a hacer el análisis de rendimiento de los usos que se sabe que se comportan correctamente.</target>
        </trans-unit>
        <trans-unit id="3b18b7815200328ded8232a4d1a242e6497d1f7f" translate="yes" xml:space="preserve">
          <source>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</source>
          <target state="translated">La pequeña disminución entre los dos primeros vale la pena por la legibilidad.Además,los argumentos de palabras clave para la creación de diccionarios sólo se añadieron en Python 2.3,mientras que copy()y update()funcionarán en versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="80cd4b20ecfc8fde8f0d9999c7ceff52e8d8b72a" translate="yes" xml:space="preserve">
          <source>If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a &lt;em&gt;single expression&lt;/em&gt;, the most performant while correct approach is to put it in a function:</source>
          <target state="translated">Si a&amp;uacute;n no est&amp;aacute; en Python 3.5, o necesita escribir c&amp;oacute;digo compatible con versiones anteriores, y desea esto en una &lt;em&gt;sola expresi&amp;oacute;n&lt;/em&gt; , el enfoque m&amp;aacute;s eficaz y correcto es ponerlo en una funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="58f39817135947f0339519f69b794e849b094fff" translate="yes" xml:space="preserve">
          <source>If you do want a copy, PEP 448 style is easiest &lt;code&gt;{**x, **y}&lt;/code&gt;. But if that's not available in your (older) Python version, the &lt;em&gt;let&lt;/em&gt; pattern works here too.</source>
          <target state="translated">Si desea una copia, el estilo PEP 448 es m&amp;aacute;s f&amp;aacute;cil &lt;code&gt;{**x, **y}&lt;/code&gt; . Pero si eso no est&amp;aacute; disponible en su versi&amp;oacute;n de Python (anterior), el patr&amp;oacute;n &lt;em&gt;let tambi&amp;eacute;n&lt;/em&gt; funciona aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="c68f13df74f8081969ebc7396a5bdbb15beb7948" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;x&lt;/code&gt; in a variable yet, you can use &lt;code&gt;lambda&lt;/code&gt; to make a local without using an assignment statement. This amounts to using &lt;code&gt;lambda&lt;/code&gt; as a &lt;em&gt;let expression&lt;/em&gt;, which is a common technique in functional languages, but maybe unpythonic.</source>
          <target state="translated">Si a&amp;uacute;n no tiene &lt;code&gt;x&lt;/code&gt; en una variable, puede usar &lt;code&gt;lambda&lt;/code&gt; para hacer un local sin usar una instrucci&amp;oacute;n de asignaci&amp;oacute;n. Esto equivale a usar &lt;code&gt;lambda&lt;/code&gt; como una &lt;em&gt;expresi&amp;oacute;n let&lt;/em&gt; , que es una t&amp;eacute;cnica com&amp;uacute;n en lenguajes funcionales, pero tal vez no es pit&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="6e67f1fbb5c4630089b3b15e7da7f230c6351803" translate="yes" xml:space="preserve">
          <source>If you don't mind mutating &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">Si no te importa mutar &lt;code&gt;x&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="23112b4c7ee35913e4183cf954bd3fbb6f22db7a" translate="yes" xml:space="preserve">
          <source>If you ever felt you would prefer to have a real merged &lt;code&gt;dict&lt;/code&gt;, then calling &lt;code&gt;dict(z)&lt;/code&gt; would produce it (but way more costly than the other solutions of course, so this is just worth mentioning).</source>
          <target state="translated">Si alguna vez sinti&amp;oacute; que preferir&amp;iacute;a tener un &lt;code&gt;dict&lt;/code&gt; combinado real, entonces llamar a &lt;code&gt;dict(z)&lt;/code&gt; lo producir&amp;iacute;a (pero, por supuesto, es mucho m&amp;aacute;s costoso que las otras soluciones, por lo que vale la pena mencionarlo).</target>
        </trans-unit>
        <trans-unit id="91c65288fd2cb6d1ebcbffd2f95dcc6f769de027" translate="yes" xml:space="preserve">
          <source>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</source>
          <target state="translated">Si crees que los lambdas son malvados,no sigas leyendo.Como se ha pedido,puedes escribir la solución rápida y de memoria con una expresión:</target>
        </trans-unit>
        <trans-unit id="7b3eb5dd9b8564f262213b8ec581f34343fb1155" translate="yes" xml:space="preserve">
          <source>If you use Python 3, it is only a little more complicated.  To create &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">Si usa Python 3, es solo un poco m&amp;aacute;s complicado. Para crear &lt;code&gt;z&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d340b513c30c260578d2c3eadac2366554f22a75" translate="yes" xml:space="preserve">
          <source>If you're not averse to importing a standard library module, you can do</source>
          <target state="translated">Si no eres reacio a importar un módulo estándar de la biblioteca,puedes hacer</target>
        </trans-unit>
        <trans-unit id="a4d62fbeb1dc986c159aff37fcf7e409f975fec3" translate="yes" xml:space="preserve">
          <source>In Python 2, (or 3.4 or lower) write a function:</source>
          <target state="translated">En Python 2,(o 3.4 o inferior)escribe una función:</target>
        </trans-unit>
        <trans-unit id="cddaaf9db6625675addbc60941262561bfd51d86" translate="yes" xml:space="preserve">
          <source>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. &lt;strong&gt;In Python 3, this will fail&lt;/strong&gt; because you're adding two &lt;code&gt;dict_items&lt;/code&gt; objects together, not two lists -</source>
          <target state="translated">En Python 2, crea dos listas en la memoria para cada dict, crea una tercera lista en la memoria con una longitud igual a la longitud de las dos primeras juntas, y luego descarta las tres listas para crear el dict. &lt;strong&gt;En Python 3, esto fallar&amp;aacute;&lt;/strong&gt; porque est&amp;aacute; agregando dos objetos &lt;code&gt;dict_items&lt;/code&gt; juntos, no dos listas:</target>
        </trans-unit>
        <trans-unit id="c145a8d3b1ebc6e2271fc27dc8537d7fd274de6b" translate="yes" xml:space="preserve">
          <source>In Python 2.7 (system Python):</source>
          <target state="translated">En Python 2.7 (sistema Python):</target>
        </trans-unit>
        <trans-unit id="c0da467e5ff897c9e6741e6911edbfc2c8e28314" translate="yes" xml:space="preserve">
          <source>In Python 3.5 (deadsnakes PPA):</source>
          <target state="translated">En Python 3.5 (PPA de serpientes muertas):</target>
        </trans-unit>
        <trans-unit id="61986f9755b6245f3a2d4cfab600c14ea75b062c" translate="yes" xml:space="preserve">
          <source>In Python 3.5 or greater:</source>
          <target state="translated">En Python 3.5 o superior:</target>
        </trans-unit>
        <trans-unit id="7c246f03cced22905d4e5edbf31a21a72dfa1e56" translate="yes" xml:space="preserve">
          <source>In Python 3.9.0a4 or greater (final release date approx October 2020): &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;discussed here&lt;/a&gt;, was implemented to further simplify this:</source>
          <target state="translated">En Python 3.9.0a4 o superior (fecha de lanzamiento final aproximadamente en octubre de 2020): &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt; , &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;discutido aqu&amp;iacute;&lt;/a&gt; , se implement&amp;oacute; para simplificar a&amp;uacute;n m&amp;aacute;s esto:</target>
        </trans-unit>
        <trans-unit id="fb06defc9c6c89decb004ddee3cc8e2971971de4" translate="yes" xml:space="preserve">
          <source>In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be:</source>
          <target state="translated">En Python,esto es bastante simple y se puede hacer con el código que aparece al final de mi post.Dada esta circunstancia,la respuesta a la pregunta original sería:</target>
        </trans-unit>
        <trans-unit id="2694d72958aa5476affbdd9f1fa8e1fb6ade5022" translate="yes" xml:space="preserve">
          <source>In a follow-up answer, you asked about the relative performance of these two alternatives:</source>
          <target state="translated">En una respuesta de seguimiento,usted preguntó sobre el rendimiento relativo de estas dos alternativas:</target>
        </trans-unit>
        <trans-unit id="fc9fa0b91a747b146f5bf2910dc05830d2caba46" translate="yes" xml:space="preserve">
          <source>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</source>
          <target state="translated">Además,cuando usas .items()(pre Python 3.0),estás creando una nueva lista que contiene los elementos del dic.Si tus diccionarios son grandes,entonces eso es un montón de gastos generales (dos listas grandes que se tirarán tan pronto como se cree el dictado fusionado).update()puede trabajar más eficientemente,porque puede funcionar a través del segundo dictado elemento por elemento.</target>
        </trans-unit>
        <trans-unit id="dd84518801f2e66815fcf3f25a609ccfebd7ea62" translate="yes" xml:space="preserve">
          <source>In both approaches, &lt;code&gt;y&lt;/code&gt; will come second and its values will replace &lt;code&gt;x&lt;/code&gt;'s values, thus &lt;code&gt;'b'&lt;/code&gt; will point to &lt;code&gt;3&lt;/code&gt; in our final result.</source>
          <target state="translated">En ambos enfoques, &lt;code&gt;y&lt;/code&gt; ocupar&amp;aacute; el segundo lugar y sus valores reemplazar&amp;aacute;n a los valores de &lt;code&gt;x&lt;/code&gt; , por lo que &lt;code&gt;'b'&lt;/code&gt; apuntar&amp;aacute; a &lt;code&gt;3&lt;/code&gt; en nuestro resultado final.</target>
        </trans-unit>
        <trans-unit id="3840c97bb862e7304c6e3f15f1b99fb6f44f7a27" translate="yes" xml:space="preserve">
          <source>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses &lt;code&gt;dict&lt;/code&gt; in lots of places; optimizing its operations is a big deal.</source>
          <target state="translated">De hecho, ir&amp;iacute;a tan lejos como para afirmar que es imposible para el c&amp;oacute;digo Python puro hacer algo mejor que esto. Y si puede hacerlo significativamente mejor en un m&amp;oacute;dulo de extensi&amp;oacute;n C, imagino que la gente de Python podr&amp;iacute;a estar interesada en incorporar su c&amp;oacute;digo (o una variaci&amp;oacute;n de su enfoque) en el n&amp;uacute;cleo de Python. Python usa &lt;code&gt;dict&lt;/code&gt; en muchos lugares; optimizar sus operaciones es un gran problema.</target>
        </trans-unit>
        <trans-unit id="bb531282f9af11f54c3641bdd4af885240f75d4e" translate="yes" xml:space="preserve">
          <source>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</source>
          <target state="translated">En mi opinión,la mejor respuesta para la parte de la &quot;expresión única&quot;,ya que no se necesitan funciones adicionales,y es corta.</target>
        </trans-unit>
        <trans-unit id="28f989d802777ef28e3ed883ee8ae092d02eb42c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;z0&lt;/code&gt; and &lt;code&gt;z2&lt;/code&gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</source>
          <target state="translated">En otras palabras, &lt;code&gt;z0&lt;/code&gt; y &lt;code&gt;z2&lt;/code&gt; parecen tener un rendimiento esencialmente id&amp;eacute;ntico. &amp;iquest;Crees que esto podr&amp;iacute;a ser una coincidencia? Yo no....</target>
        </trans-unit>
        <trans-unit id="9bc07c9c43a19f58510985e71e66d75a3b1147f6" translate="yes" xml:space="preserve">
          <source>In python3, the &lt;code&gt;items&lt;/code&gt; method &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;no longer returns a list&lt;/a&gt;, but rather a &lt;em&gt;view&lt;/em&gt;, which acts like a set. In this case you'll need to take the set union since concatenating with &lt;code&gt;+&lt;/code&gt; won't work:</source>
          <target state="translated">En python3, el m&amp;eacute;todo de &lt;code&gt;items&lt;/code&gt; &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;ya no devuelve una lista&lt;/a&gt; , sino m&amp;aacute;s bien una &lt;em&gt;vista&lt;/em&gt; , que act&amp;uacute;a como un conjunto. En este caso, deber&amp;aacute; tomar la uni&amp;oacute;n de conjunto, ya que la concatenaci&amp;oacute;n con &lt;code&gt;+&lt;/code&gt; no funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="4b8950cb37108627db33c7d426aad3319f43c846" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;time&lt;/a&gt;:</source>
          <target state="translated">En t&amp;eacute;rminos de &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;tiempo&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="576c81f813e6d5c7574b2bff19e7f7a19584c5ed" translate="yes" xml:space="preserve">
          <source>In your case, what you can do is:</source>
          <target state="translated">En tu caso,lo que puedes hacer es:</target>
        </trans-unit>
        <trans-unit id="eb9849d8300f85b4b8946c3d18417f7afe6aef40" translate="yes" xml:space="preserve">
          <source>Instead, we get this:</source>
          <target state="translated">En cambio,tenemos esto:</target>
        </trans-unit>
        <trans-unit id="613f9806d6fd6e5cb5f3886e4f538655d654d6e1" translate="yes" xml:space="preserve">
          <source>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</source>
          <target state="translated">Es tan rápido como el z0 y el malvado z2 mencionado anteriormente,pero fácil de entender y cambiar.</target>
        </trans-unit>
        <trans-unit id="9270042b2f84bc91d9787a1d06a084ff6685203f" translate="yes" xml:space="preserve">
          <source>It is my understanding (as well as the understanding of the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;creator of the language&lt;/a&gt;) that the intended usage for &lt;code&gt;dict(**y)&lt;/code&gt; is for creating dicts for readability purposes, e.g.:</source>
          <target state="translated">Es mi entendimiento (as&amp;iacute; como el entendimiento del &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;creador del lenguaje&lt;/a&gt; ) que el uso previsto para &lt;code&gt;dict(**y)&lt;/code&gt; es para crear dictados con fines de legibilidad, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="10e433f1aca9083f13e27caed8d5cca896a01f3e" translate="yes" xml:space="preserve">
          <source>It is now showing as implemented in the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;release schedule for 3.5, PEP 478&lt;/a&gt;, and it has now made its way into &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;What's New in Python 3.5&lt;/a&gt; document.</source>
          <target state="translated">Ahora se muestra como implementado en el &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;cronograma de lanzamiento de 3.5, PEP 478&lt;/a&gt; , y ahora ha llegado al documento &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;de Novedades en Python 3.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea45706ebbfc3fa103ecf69ca8e21e9e39ff372" translate="yes" xml:space="preserve">
          <source>It's faster than &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; but not as fast as &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt;, at least on CPython. This version also works in Python 3 if you change &lt;code&gt;iteritems()&lt;/code&gt; to &lt;code&gt;items()&lt;/code&gt;, which is automatically done by the 2to3 tool.</source>
          <target state="translated">Es m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; pero no tan r&amp;aacute;pido como &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt; n.update (b) , al menos en CPython. Esta versi&amp;oacute;n tambi&amp;eacute;n funciona en Python 3 si cambia &lt;code&gt;iteritems()&lt;/code&gt; a &lt;code&gt;items()&lt;/code&gt; , que se realiza autom&amp;aacute;ticamente con la herramienta 2to3.</target>
        </trans-unit>
        <trans-unit id="41964880e9b5b33a4ebc5a2e547cf6b1a1fe1386" translate="yes" xml:space="preserve">
          <source>It's so silly that &lt;code&gt;.update&lt;/code&gt; returns nothing.</source>
          <target state="translated">Es tan tonto que &lt;code&gt;.update&lt;/code&gt; no devuelve nada.</target>
        </trans-unit>
        <trans-unit id="e8f3c6ca67433e529b1de06a8936ad80db4f01c3" translate="yes" xml:space="preserve">
          <source>Less Performant But Correct Ad-hocs</source>
          <target state="translated">Menos rendimiento pero correcto Ad-hocs</target>
        </trans-unit>
        <trans-unit id="47d53f050b02da45cdaa39f901ee75d32b02efe6" translate="yes" xml:space="preserve">
          <source>Lookups search the underlying mappings successively until a key is found.</source>
          <target state="translated">Las búsquedas buscan sucesivamente en los mapas subyacentes hasta que se encuentra una clave.</target>
        </trans-unit>
        <trans-unit id="f4717469d98280c4746039a514a7e2bacbf3bfde" translate="yes" xml:space="preserve">
          <source>Mapping two lists into a dictionary</source>
          <target state="translated">Mapeo de dos listas en un diccionario</target>
        </trans-unit>
        <trans-unit id="f9f1aa4bbd26bc6ea841d2cf5df62d3193846a18" translate="yes" xml:space="preserve">
          <source>More comments:</source>
          <target state="translated">Más comentarios:</target>
        </trans-unit>
        <trans-unit id="8ef25359578b2efe9adb36ef344ee5b9c98419fb" translate="yes" xml:space="preserve">
          <source>Mutating methods in the standard library (like &lt;code&gt;.update()&lt;/code&gt;) return &lt;code&gt;None&lt;/code&gt; by convention, so this pattern will work on those too. If you're using a method that doesn't follow this convention, then &lt;code&gt;or&lt;/code&gt; may not work. But, you can use a tuple display and index to make it a single expression, instead. This works regardless of what the first element evaluates to.</source>
          <target state="translated">Los m&amp;eacute;todos de mutaci&amp;oacute;n en la biblioteca est&amp;aacute;ndar (como &lt;code&gt;.update()&lt;/code&gt; ) devuelven &lt;code&gt;None&lt;/code&gt; por convenci&amp;oacute;n, por lo que este patr&amp;oacute;n tambi&amp;eacute;n funcionar&amp;aacute; en esos. Si est&amp;aacute; utilizando un m&amp;eacute;todo que no sigue esta convenci&amp;oacute;n, entonces &lt;code&gt;or&lt;/code&gt; no puede funcionar. Pero, en su lugar, puede usar una visualizaci&amp;oacute;n e &amp;iacute;ndice de tuplas para convertirlo en una sola expresi&amp;oacute;n. Esto funciona independientemente de lo que eval&amp;uacute;a el primer elemento.</target>
        </trans-unit>
        <trans-unit id="4a4fd9ea7e1bb91ce1c283ee8443542d3f4b5d79" translate="yes" xml:space="preserve">
          <source>My explanation of Python's &lt;strong&gt;dictionary implementation&lt;/strong&gt;, updated for 3.6.</source>
          <target state="translated">Mi explicaci&amp;oacute;n de la &lt;strong&gt;implementaci&amp;oacute;n&lt;/strong&gt; del &lt;strong&gt;diccionario&lt;/strong&gt; de Python, actualizada para 3.6.</target>
        </trans-unit>
        <trans-unit id="5451c5e024244f0cb1d2a834192850cb982c87b8" translate="yes" xml:space="preserve">
          <source>My response: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</source>
          <target state="translated">Mi respuesta: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; realidad me parece mucho m&amp;aacute;s clara, si realmente nos preocupa la legibilidad. Y no es compatible con versiones anteriores, ya que Python 2 est&amp;aacute; cada vez m&amp;aacute;s obsoleto.</target>
        </trans-unit>
        <trans-unit id="a06152fa7c2b5a4be7f84d7628e46f2fff8180df" translate="yes" xml:space="preserve">
          <source>Not yet on Python 3.5, but want a &lt;em&gt;single expression&lt;/em&gt;</source>
          <target state="translated">Todav&amp;iacute;a no en Python 3.5, pero quiere una &lt;em&gt;sola expresi&amp;oacute;n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95a364312f027f57dff95eb6f993224d40d8d5d7" translate="yes" xml:space="preserve">
          <source>Note that we can merge in with literal notation as well:</source>
          <target state="translated">Note que también podemos fusionarnos con la notación literal:</target>
        </trans-unit>
        <trans-unit id="85f3316c38e547312844b492fc59334cdc24d0e8" translate="yes" xml:space="preserve">
          <source>Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case.</source>
          <target state="translated">Por supuesto,si utilizas mucho el resultado,en algún momento llegarás al límite en el que la creación de un verdadero diccionario fusionado habría sido la solución más rápida.Como dije,depende de tu caso de uso.</target>
        </trans-unit>
        <trans-unit id="48ac36a7075dd373be352f2840bc51e3b09e06b1" translate="yes" xml:space="preserve">
          <source>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative &lt;code&gt;z2&lt;/code&gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the &lt;code&gt;timeit&lt;/code&gt; module that comes with Python.</source>
          <target state="translated">En mi m&amp;aacute;quina, al menos (un x86_64 bastante com&amp;uacute;n que ejecuta Python 2.5.2), la alternativa &lt;code&gt;z2&lt;/code&gt; no solo es m&amp;aacute;s corta y simple, sino tambi&amp;eacute;n significativamente m&amp;aacute;s r&amp;aacute;pida. Puede verificar esto usted mismo utilizando el m&amp;oacute;dulo &lt;code&gt;timeit&lt;/code&gt; que viene con Python.</target>
        </trans-unit>
        <trans-unit id="5693b010303f40e7b6b2989cf211c19701b8fd90" translate="yes" xml:space="preserve">
          <source>One would expect a result of something like this:</source>
          <target state="translated">Uno esperaría un resultado de algo como esto:</target>
        </trans-unit>
        <trans-unit id="36ccf0d2daf5f0450415093a23f65782376fed7c" translate="yes" xml:space="preserve">
          <source>Or even</source>
          <target state="translated">O incluso</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="af936431e91ad36e97d16ad3fcc34657b6a9c683" translate="yes" xml:space="preserve">
          <source>Performance Analysis</source>
          <target state="translated">Análisis de rendimiento</target>
        </trans-unit>
        <trans-unit id="ccac62c217a26cb3460e444b60d39cb6b574af2e" translate="yes" xml:space="preserve">
          <source>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</source>
          <target state="translated">Personalmente me gusta más esta versión porque describe bastante bien lo que quiero en una sintaxis funcional única.El único problema menor es que no hace completamente obvio que los valores de y tienen prioridad sobre los valores de x,pero no creo que sea difícil averiguarlo.</target>
        </trans-unit>
        <trans-unit id="f2f88b2c502c6ef38181787f69def28accd2b7dd" translate="yes" xml:space="preserve">
          <source>Python 3.5 (PEP 448) allows a nicer syntax option:</source>
          <target state="translated">Python 3.5 (PEP 448)permite una opción de sintaxis más agradable:</target>
        </trans-unit>
        <trans-unit id="31fc173b6064c40551f851f890b41889dde4879b" translate="yes" xml:space="preserve">
          <source>Recursively/deep update a dict</source>
          <target state="translated">La actualización recurrente de un dictado</target>
        </trans-unit>
        <trans-unit id="e28a5f1ec1369c5c0c25a05a06b177d5f18ef2a0" translate="yes" xml:space="preserve">
          <source>Resources on Dictionaries</source>
          <target state="translated">Recursos en los diccionarios</target>
        </trans-unit>
        <trans-unit id="8e32dd9f3b57b6ccc2e40d0141dc5fa237e75edf" translate="yes" xml:space="preserve">
          <source>Response to comments</source>
          <target state="translated">Respuesta a los comentarios</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">Resultados:</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="0d93e84a8e035a40c9b757a07ddde97ea07443d0" translate="yes" xml:space="preserve">
          <source>Say you have two dicts and you want to merge them into a new dict without altering the original dicts:</source>
          <target state="translated">Digamos que tienes dos dictados y quieres fusionarlos en un nuevo dictado sin alterar los dictados originales:</target>
        </trans-unit>
        <trans-unit id="e04ba6f40f9b2060e8c41a7b09e4e62c77d60e4e" translate="yes" xml:space="preserve">
          <source>Similarly, taking the union of &lt;code&gt;items()&lt;/code&gt; in Python 3 (&lt;code&gt;viewitems()&lt;/code&gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, &lt;strong&gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:&lt;/strong&gt;</source>
          <target state="translated">Del mismo modo, tomar la uni&amp;oacute;n de &lt;code&gt;items()&lt;/code&gt; en Python 3 ( &lt;code&gt;viewitems()&lt;/code&gt; en Python 2.7) tambi&amp;eacute;n fallar&amp;aacute; cuando los valores sean objetos no compartibles (como listas, por ejemplo). Incluso si sus valores son hashable, &lt;strong&gt;ya que los conjuntos est&amp;aacute;n sem&amp;aacute;nticamente desordenados, el comportamiento no est&amp;aacute; definido con respecto a la precedencia.&lt;/strong&gt; &lt;strong&gt;Entonces no hagas esto:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a63b49fb1159980c455f7b80a5475a5b7a4bbded" translate="yes" xml:space="preserve">
          <source>Simple solution using itertools that preserves order (latter dicts have precedence)</source>
          <target state="translated">Solución simple utilizando herramientas de iteración que preservan el orden (los últimos dictados tienen prioridad)</target>
        </trans-unit>
        <trans-unit id="1ce6c799d807e8667caa62ff4d2ed81872b44880" translate="yes" xml:space="preserve">
          <source>Simple, readable, performant. You &lt;em&gt;know&lt;/em&gt;&lt;code&gt;update()&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt;, which is a false value. So the above expression will always evaluate to &lt;code&gt;x&lt;/code&gt;, after updating it.</source>
          <target state="translated">Simple, legible, performante. &lt;em&gt;Sabes que&lt;/em&gt; &lt;code&gt;update()&lt;/code&gt; siempre devuelve &lt;code&gt;None&lt;/code&gt; , que es un valor falso. Entonces, la expresi&amp;oacute;n anterior siempre se evaluar&amp;aacute; a &lt;code&gt;x&lt;/code&gt; , despu&amp;eacute;s de actualizarla.</target>
        </trans-unit>
        <trans-unit id="f32e703bd34c95af93956212150aad7a9788da7d" translate="yes" xml:space="preserve">
          <source>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</source>
          <target state="translated">Así que un orden de magnitud más lento para las búsquedas.Soy un fanático de Chainmap,pero parece menos práctico donde puede haber muchas búsquedas.</target>
        </trans-unit>
        <trans-unit id="a8e2fa47ec0878caa65f8502de5b8cbd1c0786ed" translate="yes" xml:space="preserve">
          <source>Thanks rednaw for edits.</source>
          <target state="translated">Gracias a Rednaw por las ediciones.</target>
        </trans-unit>
        <trans-unit id="d4d79546dfca81b3339e87ff38237ad185b2fb4d" translate="yes" xml:space="preserve">
          <source>The 'one' entry should have had 'depth_2' and 'extra' as items inside its dictionary if it truly was a merge.</source>
          <target state="translated">La entrada &quot;uno&quot; debería haber tenido &quot;profundidad_2&quot; y &quot;extra&quot; como elementos dentro de su diccionario si realmente era una fusión.</target>
        </trans-unit>
        <trans-unit id="d3e70f05e7f6d91452e134d86664d8e73a4261ca" translate="yes" xml:space="preserve">
          <source>The best version I could think while not using copy would be:</source>
          <target state="translated">La mejor versión que podría pensar sin usar la copia sería:</target>
        </trans-unit>
        <trans-unit id="14a3e754832e898bf1e858d57c5ffe3967bb05c5" translate="yes" xml:space="preserve">
          <source>The deep merge that rcwesick gave also creates the same result.</source>
          <target state="translated">La profunda fusión que rcwesick dio también crea el mismo resultado.</target>
        </trans-unit>
        <trans-unit id="a312af1c908fc9ad75fb286e3bc170573e2c6cc0" translate="yes" xml:space="preserve">
          <source>The desired result is to get a new dictionary (&lt;code&gt;z&lt;/code&gt;) with the values merged, and the second dict's values overwriting those from the first.</source>
          <target state="translated">El resultado deseado es obtener un nuevo diccionario ( &lt;code&gt;z&lt;/code&gt; ) con los valores combinados, y los valores del segundo dict sobrescribiendo los del primero.</target>
        </trans-unit>
        <trans-unit id="99cefd2e5a500633b962557b5eb27824141a25b8" translate="yes" xml:space="preserve">
          <source>The following is done on Ubuntu 14.04</source>
          <target state="translated">Lo siguiente se hace en Ubuntu 14.04</target>
        </trans-unit>
        <trans-unit id="c3b7bd83073daf49138869cf80438ea437175ad6" translate="yes" xml:space="preserve">
          <source>The official Python &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;docs on dictionaries&lt;/a&gt;</source>
          <target state="translated">Los &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;documentos&lt;/a&gt; oficiales de Python en los diccionarios</target>
        </trans-unit>
        <trans-unit id="7a8b9b328f9958cca0a11b9acc4b8cd695c2636b" translate="yes" xml:space="preserve">
          <source>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</source>
          <target state="translated">El problema que tengo con las soluciones enumeradas hasta la fecha es que,en el diccionario fusionado,el valor de la clave &quot;b&quot; es 10 pero,a mi modo de ver,debería ser 12.En vista de ello,presento lo siguiente:</target>
        </trans-unit>
        <trans-unit id="9fcad77208db870fca468aadd90c4da8d6ce0d45" translate="yes" xml:space="preserve">
          <source>These approaches are less performant, but they will provide correct behavior.
They will be &lt;em&gt;much less&lt;/em&gt; performant than &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they &lt;em&gt;do&lt;/em&gt; respect the order of precedence (latter dicts have precedence)</source>
          <target state="translated">Estos enfoques son menos efectivos, pero proporcionar&amp;aacute;n un comportamiento correcto. Ser&amp;aacute;n &lt;em&gt;mucho menos&lt;/em&gt; eficaces que &lt;code&gt;copy&lt;/code&gt; y &lt;code&gt;update&lt;/code&gt; o el nuevo desempaquetado porque iteran a trav&amp;eacute;s de cada par clave-valor en un nivel m&amp;aacute;s alto de abstracci&amp;oacute;n, pero respetan el orden de precedencia (los &amp;uacute;ltimos dictados tienen precedencia)</target>
        </trans-unit>
        <trans-unit id="a0ea664e2a3188bf488d6c2a6055af74fb3539bf" translate="yes" xml:space="preserve">
          <source>This can be done with a single dict comprehension:</source>
          <target state="translated">Esto se puede hacer con una sola comprensión del dictado:</target>
        </trans-unit>
        <trans-unit id="36e6d4df98468539933d14acc5debf6efc5fe4ba" translate="yes" xml:space="preserve">
          <source>This can slow you down if you have a lot of lookups in your application:</source>
          <target state="translated">Esto puede ralentizarte si tienes muchas búsquedas en tu aplicación:</target>
        </trans-unit>
        <trans-unit id="19c42edc088b07647e75e1b22d2ce503ca0cd824" translate="yes" xml:space="preserve">
          <source>This discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the &lt;code&gt;update&lt;/code&gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</source>
          <target state="translated">A esta discusi&amp;oacute;n todav&amp;iacute;a le falta algo importante, que es una comparaci&amp;oacute;n de rendimiento de estas alternativas con la forma &quot;obvia&quot; de fusionar dos listas: usar el m&amp;eacute;todo de &lt;code&gt;update&lt;/code&gt; . Para tratar de mantener las cosas en pie de igualdad con las expresiones, ninguna de las cuales modifica x o y, voy a hacer una copia de x en lugar de modificarla en su lugar, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="dc1c7903eae69f6f9e6f83fcb5785373d15617e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates what happens when values are unhashable:</source>
          <target state="translated">Este ejemplo demuestra lo que sucede cuando los valores son incontrolables:</target>
        </trans-unit>
        <trans-unit id="9157d19d33dc20ac6d37fac9da93fd7fa473ca0f" translate="yes" xml:space="preserve">
          <source>This function will work in Python 2 and 3 for all dicts. e.g. given dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Esta funci&amp;oacute;n funcionar&amp;aacute; en Python 2 y 3 para todos los dictados. p. ej., dictados aa &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1dca0e3af9d62b26b6d4ca040a8f1540fe8eaa2f" translate="yes" xml:space="preserve">
          <source>This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</source>
          <target state="translated">Esta inconsistencia fue mala dada la implementación de otras aplicaciones de Python (Pypy,Jython,IronPython).Por lo tanto,se fijó en Python 3,ya que este uso podría ser un cambio de ruptura.</target>
        </trans-unit>
        <trans-unit id="3c565024f23a6cd2ae73023603f11cac8eb9232b" translate="yes" xml:space="preserve">
          <source>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</source>
          <target state="translated">Probablemente esta no sea una respuesta popular, pero es casi seguro que no desea hacerlo. Si desea una copia que sea una fusi&amp;oacute;n, use una copia (o una copia &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;profunda&lt;/a&gt; , seg&amp;uacute;n lo que desee) y luego actualice. Las dos l&amp;iacute;neas de c&amp;oacute;digo son mucho m&amp;aacute;s legibles, m&amp;aacute;s Pythonic, que la creaci&amp;oacute;n de una sola l&amp;iacute;nea con .items () + .items (). Expl&amp;iacute;cito es mejor que impl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="02a2f32a05821cacdddcb95030b2675f25361e82" translate="yes" xml:space="preserve">
          <source>This should solve your problem.</source>
          <target state="translated">Esto debería resolver tu problema.</target>
        </trans-unit>
        <trans-unit id="686c1f44b9d06635a40727397360cca5fb0d76bc" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;dict&lt;/code&gt; constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</source>
          <target state="translated">Esto usa el constructor &lt;code&gt;dict&lt;/code&gt; , y es muy r&amp;aacute;pido y eficiente en la memoria (incluso un poco m&amp;aacute;s que nuestro proceso de dos pasos), pero a menos que sepa exactamente lo que est&amp;aacute; sucediendo aqu&amp;iacute; (es decir, el segundo dict se pasa como argumentos de palabras clave al dict constructor), es dif&amp;iacute;cil de leer, no es el uso previsto, por lo que no es Pythonic.</target>
        </trans-unit>
        <trans-unit id="463fe46eebffb482307a2b0a04183fc401c2acf9" translate="yes" xml:space="preserve">
          <source>This will, as you want it, put the final dict in &lt;code&gt;z&lt;/code&gt;, and make the value for key &lt;code&gt;b&lt;/code&gt; be properly overridden by the second (&lt;code&gt;y&lt;/code&gt;) dict's value:</source>
          <target state="translated">Esto, como lo desee, pondr&amp;aacute; el dict final en &lt;code&gt;z&lt;/code&gt; , y har&amp;aacute; que el valor de la clave &lt;code&gt;b&lt;/code&gt; sea ​​anulado correctamente por el valor del segundo ( &lt;code&gt;y&lt;/code&gt; ) dict:</target>
        </trans-unit>
        <trans-unit id="827f523c69cfc77e578e7347bfd913a0423d4505" translate="yes" xml:space="preserve">
          <source>Usage (tested in python 3):</source>
          <target state="translated">Uso (probado en pitón 3):</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e8a5cd8514bfb309e8f3f05950c1200e457ea3dc" translate="yes" xml:space="preserve">
          <source>Using chain also, does not work:</source>
          <target state="translated">Usar la cadena también,no funciona:</target>
        </trans-unit>
        <trans-unit id="cfbc3d78519156ea4d38e12324b7f22474d7df90" translate="yes" xml:space="preserve">
          <source>When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed.</source>
          <target state="translated">Al usar este nuevo objeto,se comportará como un diccionario fusionado pero tendrá un tiempo de creación constante y una huella de memoria constante,dejando los diccionarios originales intactos.Crearlo es mucho más barato que en las otras soluciones propuestas.</target>
        </trans-unit>
        <trans-unit id="2a93691216c27b37fa080f1bf21889060fcd92b2" translate="yes" xml:space="preserve">
          <source>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</source>
          <target state="translated">Aunque la pregunta ya ha sido contestada varias veces,esta simple solución al problema aún no ha sido listada.</target>
        </trans-unit>
        <trans-unit id="cd809d0ef673f12b00a606ccbe54a8115b1c82af" translate="yes" xml:space="preserve">
          <source>Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I'll update this later once I write a method that does a true merge.</source>
          <target state="translated">Sí,funcionará para fusionar los diccionarios de muestras,pero ninguno de ellos es un mecanismo genérico para fusionar.Actualizaré esto más tarde una vez que escriba un método que haga una verdadera fusión.</target>
        </trans-unit>
        <trans-unit id="2aa391717295fad536baefee8bd2d60a19871d4f" translate="yes" xml:space="preserve">
          <source>Yes. I must refer you back to the question, which is asking for a &lt;em&gt;shallow&lt;/em&gt; merge of &lt;strong&gt;&lt;em&gt;two&lt;/em&gt;&lt;/strong&gt; dictionaries, with the first's values being overwritten by the second's - in a single expression.</source>
          <target state="translated">Si. Debo remitirlo nuevamente a la pregunta, que consiste en una fusi&amp;oacute;n &lt;em&gt;superficial&lt;/em&gt; de &lt;strong&gt;&lt;em&gt;dos&lt;/em&gt;&lt;/strong&gt; diccionarios, con los valores del primero sobrescritos por los segundos, en una sola expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ee121489b6e0d4a946801627644c8e2674d2d13d" translate="yes" xml:space="preserve">
          <source>You can also chain the dicts manually inside a dict comprehension:</source>
          <target state="translated">También puedes encadenar los dictados manualmente dentro de una comprensión de dictado:</target>
        </trans-unit>
        <trans-unit id="e8a9e7391a7cebd4162276bf43babcfe429d286a" translate="yes" xml:space="preserve">
          <source>You can also make a function to merge an undefined number of dicts, from zero to a very large number:</source>
          <target state="translated">También puede hacer una función para fusionar un número indefinido de dictados,desde cero hasta un número muy grande:</target>
        </trans-unit>
        <trans-unit id="d99a90478f3ad33b4d2bc5f254632c7bfd37d59d" translate="yes" xml:space="preserve">
          <source>You can also use this class to make a kind of copy-on-write dictionary:</source>
          <target state="translated">También puedes usar esta clase para hacer una especie de diccionario de copia sobre escritura:</target>
        </trans-unit>
        <trans-unit id="9cedfd6f2171ececea9d197f9ad610009dfddd7f" translate="yes" xml:space="preserve">
          <source>You could also do this of course if you don't care about copying it:</source>
          <target state="translated">También podrías hacer esto,por supuesto,si no te importa copiarlo:</target>
        </trans-unit>
        <trans-unit id="58f29ce54e05025dbf326102828358d60d6406e0" translate="yes" xml:space="preserve">
          <source>You could also write this as</source>
          <target state="translated">También podrías escribir esto como</target>
        </trans-unit>
        <trans-unit id="3ef1d0278a40be0903df836eb1993ad9c45936ba" translate="yes" xml:space="preserve">
          <source>You could use a lambda instead.</source>
          <target state="translated">Podrías usar una lambda en su lugar.</target>
        </trans-unit>
        <trans-unit id="3e45b5c2910ea1c81696ad9de828761856f8df26" translate="yes" xml:space="preserve">
          <source>You said you wanted one expression, so I abused &lt;code&gt;lambda&lt;/code&gt; to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</source>
          <target state="translated">Dijiste que quer&amp;iacute;as una expresi&amp;oacute;n, as&amp;iacute; que abus&amp;eacute; de &lt;code&gt;lambda&lt;/code&gt; para unir un nombre y las tuplas para anular el l&amp;iacute;mite de una expresi&amp;oacute;n de lambda. Si&amp;eacute;ntase libre de encogerse.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9158b7790079767a2ee5155681bc0537e04269f5" translate="yes" xml:space="preserve">
          <source>and key value pairs in &lt;code&gt;g&lt;/code&gt; will take precedence over dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;, and so on.</source>
          <target state="translated">y los pares de valores clave en &lt;code&gt;g&lt;/code&gt; tendr&amp;aacute;n prioridad sobre los dictos &lt;code&gt;a&lt;/code&gt; a &lt;code&gt;f&lt;/code&gt; , y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">y ahora:</target>
        </trans-unit>
        <trans-unit id="6dc92c5dffb9e2875bb5be2d30824a953e7e8fee" translate="yes" xml:space="preserve">
          <source>and then you have a single expression:</source>
          <target state="translated">y entonces tienes una sola expresión:</target>
        </trans-unit>
        <trans-unit id="538141bce772b5861479742348306cced3786ed9" translate="yes" xml:space="preserve">
          <source>and you would have to explicitly create them as lists, e.g. &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt;. This is a waste of resources and computation power.</source>
          <target state="translated">y tendr&amp;iacute;a que crearlos expl&amp;iacute;citamente como listas, por ejemplo, &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt; . Esto es un desperdicio de recursos y poder de c&amp;aacute;lculo.</target>
        </trans-unit>
        <trans-unit id="feeb579278407bb98d8960ea0156b0f057ac30d9" translate="yes" xml:space="preserve">
          <source>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</source>
          <target state="translated">como lo hace Tony,pero (no es sorprendente)la diferencia en la notación resulta no tener ningún efecto medible en el rendimiento.Usa lo que te parezca correcto.Por supuesto,tiene toda la razón al señalar que la versión de dos declaraciones es mucho más fácil de entender.</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">en lugar de</target>
        </trans-unit>
        <trans-unit id="c5d0aeaef87c64e87fa64d76c410acb93a6f6869" translate="yes" xml:space="preserve">
          <source>lead me to conclude that &lt;code&gt;z3&lt;/code&gt; is somewhat faster than &lt;code&gt;z1&lt;/code&gt;, but not nearly as fast as &lt;code&gt;z2&lt;/code&gt;.  Definitely not worth all the extra typing.</source>
          <target state="translated">me llev&amp;oacute; a concluir que &lt;code&gt;z3&lt;/code&gt; es algo m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;z1&lt;/code&gt; , pero no tan r&amp;aacute;pido como &lt;code&gt;z2&lt;/code&gt; . Definitivamente no vale la pena todo el tipeo adicional.</target>
        </trans-unit>
        <trans-unit id="3846c179246b1e2fb787941b7f16f2f7ff81ff9b" translate="yes" xml:space="preserve">
          <source>or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</source>
          <target state="translated">o en la pitón 2.6 (y quizás ya en 2.4 cuando se introdujeron las expresiones generadoras):</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
