<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/38987">
    <body>
      <group id="38987">
        <trans-unit id="762f1a0e69169610829fa8a43f4c74678cbb8a23" translate="yes" xml:space="preserve">
          <source>(For Python2.7* only; there are simpler solutions for Python3*.)</source>
          <target state="translated">(仅适用于Python2.7*;Python3*有更简单的解决方案。)</target>
        </trans-unit>
        <trans-unit id="26cef14df0be957675f0530429b3a7bde6a3b375" translate="yes" xml:space="preserve">
          <source>(That is, of course, equivalent to &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)</source>
          <target state="translated">（当然，这等效于 &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt; ，但是如果您的Python版本足够新，则可以使用PEP 448样式。）</target>
        </trans-unit>
        <trans-unit id="c983206bb5c1b9997bd209ce2acce7e071f69644" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;or a&lt;/code&gt; bit in the &lt;code&gt;lambda&lt;/code&gt; is necessary because &lt;code&gt;dict.update&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt; on success.)</source>
          <target state="translated">（ &lt;code&gt;lambda&lt;/code&gt; 中的 &lt;code&gt;or a&lt;/code&gt; 一点是必需的，因为 &lt;code&gt;dict.update&lt;/code&gt; 成功时总是返回 &lt;code&gt;None&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="fc6520d839da1d73fe3d2dc5120a168296e3c8df" translate="yes" xml:space="preserve">
          <source>(To be extra-clear, the last-one-wins conflict-handling of &lt;code&gt;dict.update()&lt;/code&gt; is what I'm looking for as well.)</source>
          <target state="translated">（更明确地说，我也在寻找 &lt;code&gt;dict.update()&lt;/code&gt; 的最后一个胜利处理方法 。）</target>
        </trans-unit>
        <trans-unit id="59798fb8386a0602fdd9b6380f0da9334a75b531" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - talk by Brandon Rhodes at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot;&gt;词典甚至更强大&lt;/a&gt; -布兰登&amp;middot;罗德斯在Pycon 2017上的演讲</target>
        </trans-unit>
        <trans-unit id="8b08b9102b840351132b620d290b145d977714b3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;Modern Python Dictionaries, A Confluence of Great Ideas&lt;/a&gt; - talk by Raymond Hettinger at Pycon 2017</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot;&gt;现代Python词典，伟大思想的融合&lt;/a&gt; -Raymond Hettinger在Pycon 2017上的演讲</target>
        </trans-unit>
        <trans-unit id="64eaafdd6d026ca8e8e81c2df03a5ad7e0e4f273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; is still the most readable solution for Python 2. Readability counts.</source>
          <target state="translated">&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; 仍然是Python 2可读性最高的解决方案。</target>
        </trans-unit>
        <trans-unit id="1bc9f47831b8850843d4bfab7500ddd5d5e01499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;itertools.chain&lt;/code&gt; will chain the iterators over the key-value pairs in the correct order:</source>
          <target state="translated">&lt;code&gt;itertools.chain&lt;/code&gt; 将以正确的顺序在键值对上链接迭代器：</target>
        </trans-unit>
        <trans-unit id="8762df6a9a82f0b36d9893287201772efe7c7ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; has bad performance. See &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; 性能不好。 参见&lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b30516353c8b7de805be8527f19faa1ebcd7e111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but &lt;code&gt;z2&lt;/code&gt; always seems to come out ahead.  (If you get inconsistent results for the &lt;em&gt;same&lt;/em&gt; test, try passing in &lt;code&gt;-r&lt;/code&gt; with a number larger than the default 3.)</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; 胜出3.5倍左右。 不同的词典似乎会产生完全不同的结果，但 &lt;code&gt;z2&lt;/code&gt; 似乎总是领先。 （如果您在&lt;em&gt;同一&lt;/em&gt;测试中得到的结果不一致，请尝试传递 &lt;code&gt;-r&lt;/code&gt; 大于默认值3的数字。）</target>
        </trans-unit>
        <trans-unit id="73fb6424cfd11bb18a1c574f3c35c5c9d895216f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z2&lt;/code&gt; wins by about a factor of 10.  That's a pretty big win in my book!</source>
          <target state="translated">&lt;code&gt;z2&lt;/code&gt; 赢了大约10倍。这在我的书中是一个很大的胜利！</target>
        </trans-unit>
        <trans-unit id="684683c3cfba4b7ae046f86966f4cf852b750b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{**x, **y}&lt;/code&gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</source>
          <target state="translated">&lt;code&gt;{**x, **y}&lt;/code&gt; 似乎不处理嵌套字典。 嵌套键的内容只是被覆盖，没有被合并，而最终我被这些没有递归合并的答案所烧死，我很惊讶没有人提及它。 在我对&amp;ldquo;合并&amp;rdquo;一词的解释中，这些答案描述的是&amp;ldquo;将一个词典与另一个词典更新&amp;rdquo;，而不是合并。</target>
        </trans-unit>
        <trans-unit id="4acb6eec05cf3410b42a7e8367ceb7218e526e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;n&lt;/em&gt;词典&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c750c4b4d745d4a88f3eea8b03ce9ceff63b397a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Python 3.0 and later&lt;/strong&gt;, you can use &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt;&lt;code&gt;collections.ChainMap&lt;/code&gt;&lt;/a&gt; which groups multiple dicts or other mappings together to create a single, updateable view:</source>
          <target state="translated">&lt;strong&gt;在Python 3.0及更高版本中&lt;/strong&gt; ，可以使用&lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot;&gt; &lt;code&gt;collections.ChainMap&lt;/code&gt; &lt;/a&gt;将多个字典或其他映射组合在一起以创建一个可更新的视图：</target>
        </trans-unit>
        <trans-unit id="047862db1890195e52368684bf93f77d9a3b9706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this has become a popular answer, but it is important to point out that if &lt;code&gt;y&lt;/code&gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido is not a fan&lt;/a&gt;. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：这已经成为一个流行的答案，但必须指出的是，如果 &lt;code&gt;y&lt;/code&gt; 具有任何非字符串键，那么这实际上是对CPython实现细节的滥用，并且在Python 3中不起作用，或者使用PyPy，IronPython或Jython。 另外， &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;Guido也不是粉丝&lt;/a&gt; 。 因此，我不建议将此技术用于前向兼容或交叉实现的可移植代码，这实际上意味着应完全避免使用它。</target>
        </trans-unit>
        <trans-unit id="56c781e5adb8bad76d8066d046d1c97e28021043" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two dictionaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;两本字典&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29d78daed80f94bbc7108a07b9e271b9fca2cca5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update for Python 3.5 and later&lt;/strong&gt;: You can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt; extended dictionary packing and unpacking.  This is fast and easy:</source>
          <target state="translated">&lt;strong&gt;适用于Python 3.5和更高版本的更新&lt;/strong&gt; ：可以使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot;&gt;PEP 448&lt;/a&gt;扩展词典打包和拆包。 快速简便：</target>
        </trans-unit>
        <trans-unit id="4ad22f81594d7603a3fcfc3c26100cb43cf77997" translate="yes" xml:space="preserve">
          <source>A couple more points for python 3. First, note that the &lt;code&gt;dict(x, **y)&lt;/code&gt; trick won't work in python 3 unless the keys in &lt;code&gt;y&lt;/code&gt; are strings.</source>
          <target state="translated">对于python 3还有几点。首先，请注意 &lt;code&gt;dict(x, **y)&lt;/code&gt; 技巧在python 3中不起作用，除非 &lt;code&gt;y&lt;/code&gt; 中的键是字符串。</target>
        </trans-unit>
        <trans-unit id="52323533fde1038ac6c3239bddef21ed2cd7faa9" translate="yes" xml:space="preserve">
          <source>A few quick tests, e.g.</source>
          <target state="translated">几项快速测试,如</target>
        </trans-unit>
        <trans-unit id="5b8d1b61a251a1f4f5f96af395d52351a9c2d234" translate="yes" xml:space="preserve">
          <source>A new syntax for this, proposed in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448&lt;/a&gt; and &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;available as of Python 3.5&lt;/a&gt;, is</source>
          <target state="translated">在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot;&gt;PEP 448中&lt;/a&gt;提出并&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot;&gt;从Python 3.5开始可用&lt;/a&gt;的新语法是</target>
        </trans-unit>
        <trans-unit id="d20312b0c332092c94533e037801b46f85f6ff75" translate="yes" xml:space="preserve">
          <source>A typical result:</source>
          <target state="translated">一个典型的结果。</target>
        </trans-unit>
        <trans-unit id="79346271c215b10d408c3a24960c3a8434e1b144" translate="yes" xml:space="preserve">
          <source>Abuse leading to a one-expression solution for &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew's answer&lt;/a&gt;:</source>
          <target state="translated">滥用导致&lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;马修回答&lt;/a&gt;的单一表达解决方案：</target>
        </trans-unit>
        <trans-unit id="bc0fcdd15355dfc94d498254e338806fd4947b01" translate="yes" xml:space="preserve">
          <source>After comparing those two, I wondered if &lt;code&gt;z1&lt;/code&gt;'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</source>
          <target state="translated">比较了这两个之后，我想知道 &lt;code&gt;z1&lt;/code&gt; 的性能差是否可以归因于构建两个项目列表的开销，这反过来又使我想知道这种变化是否会更好：</target>
        </trans-unit>
        <trans-unit id="3e513e02e5ffef80d9363703f5c690e41e7d947a" translate="yes" xml:space="preserve">
          <source>Again, it doesn't work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. &lt;code&gt;dict&lt;/code&gt; broke this consistency in Python 2:</source>
          <target state="translated">同样，当键为非字符串时，它不适用于3。 隐式调用协定是名称空间采用普通命令，而用户只能传递字符串形式的关键字参数。 所有其他可调用对象都强制执行了它。 &lt;code&gt;dict&lt;/code&gt; 在Python 2中破坏了这种一致性：</target>
        </trans-unit>
        <trans-unit id="37903af1bb3d70c3129ae7ad37c51d78652644c4" translate="yes" xml:space="preserve">
          <source>Also, Raymond Hettinger's Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;answer&lt;/a&gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;from the docs&lt;/a&gt; it looks like it sequentially looks through a list of all the dicts for each lookup:</source>
          <target state="translated">而且，Raymond Hettinger的Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;答案&lt;/a&gt;非常优雅，因为它可以将任意数量的dicts作为参数，但是&lt;a href=&quot;http://docs.python.org/dev/library/collections&quot;&gt;从文档&lt;/a&gt;中看，它似乎依次遍历了每次查找的所有dicts列表：</target>
        </trans-unit>
        <trans-unit id="b0e9fc794244c2742a7d0ad09b5a05d65fe3ab05" translate="yes" xml:space="preserve">
          <source>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only):</source>
          <target state="translated">虽然和下面使用新的海象运算符(仅Python 3.8+)没有太大区别。</target>
        </trans-unit>
        <trans-unit id="d64aa96c0baf8816d369af41816223f0d24166b8" translate="yes" xml:space="preserve">
          <source>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life &lt;em&gt;Guido van Rossum&lt;/em&gt; himself!  Someone else suggested half of this, but did not put it in a function.</source>
          <target state="translated">在这些阴暗而可疑的答案中，这个光辉的例子是在Python中合并字典的唯一且唯一的好方法，这是独裁者终身支持的&lt;em&gt;Guido van Rossum&lt;/em&gt;本人！ 有人提出了一半的建议，但没有将其放在函数中。</target>
        </trans-unit>
        <trans-unit id="b52eb9c15df1a810d482d29e8ce9cd10a248294b" translate="yes" xml:space="preserve">
          <source>An alternative:</source>
          <target state="translated">一个备选方案:</target>
        </trans-unit>
        <trans-unit id="ad2a670b2ebfd8d5864a5b7bac3632cc392444b7" translate="yes" xml:space="preserve">
          <source>And it is indeed a single expression.</source>
          <target state="translated">而这确实是一种单一的表达方式。</target>
        </trans-unit>
        <trans-unit id="2a68af8ef2b2b3fa71a55eee3ef7e2c9f937685a" translate="yes" xml:space="preserve">
          <source>And it's usage:</source>
          <target state="translated">还有它的用途。</target>
        </trans-unit>
        <trans-unit id="b0b7becbe9ec6ad7a7d8f73a304a045dc8bff483" translate="yes" xml:space="preserve">
          <source>Another hack you should not use:</source>
          <target state="translated">另一个你不应该使用的黑客。</target>
        </trans-unit>
        <trans-unit id="a6df3197072e3a7d3b37983ee4cecb723db3ac60" translate="yes" xml:space="preserve">
          <source>Another, more concise, option:</source>
          <target state="translated">另一个,比较简明的选项。</target>
        </trans-unit>
        <trans-unit id="a90812f162710be72c6673269344a54ff85dec16" translate="yes" xml:space="preserve">
          <source>Answer on how to add new keys to a dictionary</source>
          <target state="translated">关于如何在字典中添加新键的答案</target>
        </trans-unit>
        <trans-unit id="209d65032f4cdd91a49f9731f909c0f76b26af8f" translate="yes" xml:space="preserve">
          <source>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call
  x.update(y) and return x&quot;. Personally I find it more despicable than
  cool.</source>
          <target state="translated">显然,dict(x,**y)作为 &quot;调用x.update(y)并返回x &quot;的 &quot;酷黑客 &quot;而流传。就我个人而言,我觉得这比酷更卑鄙。</target>
        </trans-unit>
        <trans-unit id="1107541abd6568cff679b7beb9d9536a95d8d98c" translate="yes" xml:space="preserve">
          <source>As suggested above, using two lines or writing a function is probably a better way to go.</source>
          <target state="translated">如上文所建议的,用两行或写一个函数可能是比较好的方法。</target>
        </trans-unit>
        <trans-unit id="9c0a490ce334822e1a4fa03338b9164ecf3e1d0a" translate="yes" xml:space="preserve">
          <source>Assuming two dictionary of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dicts from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</source>
          <target state="translated">假设有两个字典,可以在一个函数中递归合并它们,但要注意不要修改两个来源的字典,最稳妥的方法是在分配值的时候进行复制。由于键必须是可散列的,因此通常是不可更改的,所以复制它们是没有意义的。</target>
        </trans-unit>
        <trans-unit id="dda59ae142911ee5f815e7544ec0051e45b17ef5" translate="yes" xml:space="preserve">
          <source>Be pythonic. Use a &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;comprehension&lt;/a&gt;:</source>
          <target state="translated">是pythonic。 使用&lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot;&gt;理解&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e3e400046d95f67ae3dc116f87dadd13f71f972a" translate="yes" xml:space="preserve">
          <source>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;&lt;/a&gt;.</source>
          <target state="translated">提出其他值类型的偶发性问题远远超出了此问题的范围，因此，我将为您&lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;回答有关&amp;ldquo;词典合并词典&amp;rdquo;的规范问题&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ead0c8a43030e9b4ba9dfd6743570550ad79d67" translate="yes" xml:space="preserve">
          <source>Critiques of Other Answers</source>
          <target state="translated">对其他答案的批评</target>
        </trans-unit>
        <trans-unit id="c6a7b52934eb4c501f4a60e0e15c80a5bef14889" translate="yes" xml:space="preserve">
          <source>Demonstration:</source>
          <target state="translated">Demonstration:</target>
        </trans-unit>
        <trans-unit id="92ec7b2214ef32933d24b7351f97a6c052ccdf23" translate="yes" xml:space="preserve">
          <source>Depending on the use case it might not be necessary to create a &quot;real&quot; merged dictionary of the given input dictionaries.  A &lt;em&gt;view&lt;/em&gt; which does this might be sufficient in many cases, i. e. an object which acts &lt;em&gt;like&lt;/em&gt; the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak.</source>
          <target state="translated">根据使用情况，可能不必创建给定输入字典的&amp;ldquo;真实&amp;rdquo;合并字典。 在许多情况下，执行此操作的&lt;em&gt;视图&lt;/em&gt;可能就足够了，即， &lt;em&gt;像&lt;/em&gt;合并字典&lt;em&gt;一样工作&lt;/em&gt;的对象将不会完全对其进行计算。 可以这么说，这是合并字典的一种惰性版本。</target>
        </trans-unit>
        <trans-unit id="cf8c4ba0db8a8656b2f2f14c9fc473f2d81f924b" translate="yes" xml:space="preserve">
          <source>Despite what Guido says, &lt;code&gt;dict(x, **y)&lt;/code&gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords.</source>
          <target state="translated">尽管Guido说了什么， &lt;code&gt;dict(x, **y)&lt;/code&gt; 符合dict规范，顺便说一句。 它仅适用于Python 2和3。事实上，这仅适用于字符串键，这是关键字参数如何工作的直接结果，而不是字典的缩写。 在这个地方使用**运算符也不会滥用该机制，实际上**正是为了将dict作为关键字传递而设计的。</target>
        </trans-unit>
        <trans-unit id="3d03564e5b15ddf2ca88faedf123c311e047f26b" translate="yes" xml:space="preserve">
          <source>Dicts are intended to take hashable keys (e.g. frozensets or tuples), but &lt;strong&gt;this method fails in Python 3 when keys are not strings.&lt;/strong&gt;</source>
          <target state="translated">字典旨在获取可散列的键（例如，frozenset或元组），但是&lt;strong&gt;当键不是字符串时&lt;/strong&gt; ， &lt;strong&gt;此方法在Python 3中失败。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92d9a054b2288bd1fdd9bdb5e55a39fe412e39ab" translate="yes" xml:space="preserve">
          <source>Don't use what you see in the formerly accepted answer:</source>
          <target state="translated">不要用以前接受的答案中看到的东西。</target>
        </trans-unit>
        <trans-unit id="ac898e4932c0e7dcb2f44c27b6aeabf7e53fc70c" translate="yes" xml:space="preserve">
          <source>Drawing on ideas here and elsewhere I've comprehended a function:</source>
          <target state="translated">借鉴这里和其他地方的想法,我理解了一个功能。</target>
        </trans-unit>
        <trans-unit id="6c434bcb6a9e583ddd9818e466c89cc4d9768234" translate="yes" xml:space="preserve">
          <source>Even though the answers were good for this &lt;em&gt;shallow&lt;/em&gt; dictionary, none of the methods defined here actually do a deep dictionary merge.</source>
          <target state="translated">即使答案对于此&lt;em&gt;浅表&lt;/em&gt;字典是好的，但此处定义的方法实际上都没有进行深表字典合并。</target>
        </trans-unit>
        <trans-unit id="534c40ca3d6e9c332fb24d30e24866a5884fdf3c" translate="yes" xml:space="preserve">
          <source>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</source>
          <target state="translated">例1:完全相同的字典将20个连续的整数映射到自己。</target>
        </trans-unit>
        <trans-unit id="5d6468775d296b285af2d4eb8a4fbae02366f7da" translate="yes" xml:space="preserve">
          <source>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</source>
          <target state="translated">例2:非重叠字典将252个短字符串映射到整数,反之亦然。</target>
        </trans-unit>
        <trans-unit id="51725d04b42e48c95f79400a9ef4bf6dd25aa363" translate="yes" xml:space="preserve">
          <source>Examples follow:</source>
          <target state="translated">例子如下:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="417f84c0ab231efe074c376811a745ff0bbaefae" translate="yes" xml:space="preserve">
          <source>For dictionaries &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; becomes a shallowly merged dictionary with values from &lt;code&gt;y&lt;/code&gt; replacing those from &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">对于字典 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ， &lt;code&gt;z&lt;/code&gt; 变成浅表合并的字典，其中 &lt;code&gt;y&lt;/code&gt; 的值替换 &lt;code&gt;x&lt;/code&gt; 的值 。</target>
        </trans-unit>
        <trans-unit id="5a7a48fc65c8ec5e1d37a7ac34c58a2610a8718b" translate="yes" xml:space="preserve">
          <source>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</source>
          <target state="translated">对于两个字典中都有键的项目('b'),你可以通过把那一个放在最后,来控制输出中的哪一个。</target>
        </trans-unit>
        <trans-unit id="66e4468118f12a49669432b591f48cae1db2757b" translate="yes" xml:space="preserve">
          <source>For python3-like behavior in version 2.7, the &lt;code&gt;viewitems&lt;/code&gt; method should work in place of &lt;code&gt;items&lt;/code&gt;:</source>
          <target state="translated">对于2.7版中类似python3的行为， &lt;code&gt;viewitems&lt;/code&gt; 方法应该代替 &lt;code&gt;items&lt;/code&gt; 起作用：</target>
        </trans-unit>
        <trans-unit id="05f303d92888701b00a3dca7391b2cd0ede31839" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;mailing list&lt;/a&gt;, Guido van Rossum, the creator of the language, wrote:</source>
          <target state="translated">语言的创建者Guido van Rossum在&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot;&gt;邮件列表中&lt;/a&gt;写道：</target>
        </trans-unit>
        <trans-unit id="9f63a1b687b569fbbc0abd2c72572d74cf9da35c" translate="yes" xml:space="preserve">
          <source>Here's an example of the usage being &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;remediated in django&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot;&gt;在django&lt;/a&gt;中修复的用法的示例。</target>
        </trans-unit>
        <trans-unit id="7fca813712109d4e2606defe725d888aa50dabf0" translate="yes" xml:space="preserve">
          <source>Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:</source>
          <target state="translated">这里有一个例子,y应该有优先级,但由于集的任意顺序,x的值被保留了下来。</target>
        </trans-unit>
        <trans-unit id="eebe1dc7075416ba2cee50e9bcf95a9e8f656e14" translate="yes" xml:space="preserve">
          <source>Here's the straight-forward code of &lt;code&gt;MergeDict&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;MergeDict&lt;/code&gt; 的简单代码：</target>
        </trans-unit>
        <trans-unit id="22cca235a9f80cdc5840a3a67ad0dfe9f75c41d8" translate="yes" xml:space="preserve">
          <source>How can I get that final merged dictionary in &lt;code&gt;z&lt;/code&gt;, not &lt;code&gt;x&lt;/code&gt;?</source>
          <target state="translated">我怎样才能在 &lt;code&gt;z&lt;/code&gt; 而不是 &lt;code&gt;x&lt;/code&gt; 中获得最终的合并字典？</target>
        </trans-unit>
        <trans-unit id="5b9ed01b74e3b861c8ed3f17f0beccfffc6b9b9b" translate="yes" xml:space="preserve">
          <source>How can I merge two Python dictionaries in a single expression?</source>
          <target state="translated">如何将两个Python字典合并到一个表达式中?</target>
        </trans-unit>
        <trans-unit id="8cb6e8e8ba5fdf4ce9658d5ca8f5d8770c5e9e85" translate="yes" xml:space="preserve">
          <source>How do I merge two dictionaries in a single expression</source>
          <target state="translated">如何将两个词典合并为一个表达方式?</target>
        </trans-unit>
        <trans-unit id="c8ef4565722ce18107b48e5f9a668982765902bd" translate="yes" xml:space="preserve">
          <source>However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</source>
          <target state="translated">然而,由于许多组织还在使用Python 2,所以你可能希望用一种向后兼容的方式来做。在Python 2和Python 3.0-3.4中,经典的Pythononic方法是将其作为一个两步走的过程。</target>
        </trans-unit>
        <trans-unit id="a9e2146fc3d130671f68d310625226e3ccce8eab" translate="yes" xml:space="preserve">
          <source>I am fine with
  declaring dict({}, **{1:3}) illegal, since after all it is abuse of
  the ** mechanism.</source>
          <target state="translated">我对宣布dict({},***{1:3})为非法没有问题,因为这毕竟是对**机制的滥用。</target>
        </trans-unit>
        <trans-unit id="11606279b4a4e0c3d7cb38ec7e13e08435b369e0" translate="yes" xml:space="preserve">
          <source>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The &lt;code&gt;update()&lt;/code&gt; method would be what I need, if it returned its result instead of modifying a dictionary in-place.</source>
          <target state="translated">我有两个Python字典，我想编写一个返回这两个字典合并的单个表达式。 如果 &lt;code&gt;update()&lt;/code&gt; 方法返回其结果而不是就地修改字典，则将是我需要的方法。</target>
        </trans-unit>
        <trans-unit id="56b9ab3e4817a98d072aafad2224e1acb41d827f" translate="yes" xml:space="preserve">
          <source>I just use a simple helper function to solve the problem:</source>
          <target state="translated">我只是用一个简单的帮助函数来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="01c87e18558e3526b4877129f79e0ec875c6b499" translate="yes" xml:space="preserve">
          <source>I know this does not really fit the specifics of the questions (&quot;one liner&quot;), but since &lt;em&gt;none&lt;/em&gt; of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts.</source>
          <target state="translated">我知道这确实不适合问题的具体内容（&amp;ldquo;一个班轮&amp;rdquo;），但是由于上面的所有答案&lt;em&gt;都没有&lt;/em&gt;朝这个方向发展，而很多答案都涉及性能问题，所以我觉得我应该贡献自己的思想。</target>
        </trans-unit>
        <trans-unit id="bfc266b6f982c3a928236a92c629662068d1aa8b" translate="yes" xml:space="preserve">
          <source>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</source>
          <target state="translated">无论如何,我更喜欢这种记号法,因为把它看成是一个集合联合运算,而不是串联运算(如标题所示),似乎更自然。</target>
        </trans-unit>
        <trans-unit id="375e440687d005ef88e88f34c7f99f4a5ac588c4" translate="yes" xml:space="preserve">
          <source>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</source>
          <target state="translated">我向你提出,故意写出只在一种语言的一个版本中工作的代码,或者只在某些任意约束下工作的代码,是恶意的无能。</target>
        </trans-unit>
        <trans-unit id="7bb9b5043cf7f5771f44311a303420b28a455fba" translate="yes" xml:space="preserve">
          <source>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</source>
          <target state="translated">我想要一些类似的东西,但要能指定重复键上的值是如何合并的,所以我黑了这个(但没有大量测试)。显然,这不是一个单一的表达式,但它是一个单一的函数调用。</target>
        </trans-unit>
        <trans-unit id="78af1cea1dc16ea253286cd3b93d54839ede508a" translate="yes" xml:space="preserve">
          <source>I'm only going to do the performance analysis of the usages known to behave correctly.</source>
          <target state="translated">我只对已知的使用方法进行性能分析,知道正确的使用方法。</target>
        </trans-unit>
        <trans-unit id="3b18b7815200328ded8232a4d1a242e6497d1f7f" translate="yes" xml:space="preserve">
          <source>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</source>
          <target state="translated">IMO,前两者之间的微小的延迟是值得的,因为它的可读性。此外,创建字典的关键字参数是在Python 2.3中才加入的,而copy()和update()在老版本中也能正常使用。</target>
        </trans-unit>
        <trans-unit id="80cd4b20ecfc8fde8f0d9999c7ceff52e8d8b72a" translate="yes" xml:space="preserve">
          <source>If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a &lt;em&gt;single expression&lt;/em&gt;, the most performant while correct approach is to put it in a function:</source>
          <target state="translated">如果您尚未使用Python 3.5，或者需要编写向后兼容的代码，并且希望在&lt;em&gt;单个表达式中使用它&lt;/em&gt; ，则最有效的方法是将其放入函数中：</target>
        </trans-unit>
        <trans-unit id="58f39817135947f0339519f69b794e849b094fff" translate="yes" xml:space="preserve">
          <source>If you do want a copy, PEP 448 style is easiest &lt;code&gt;{**x, **y}&lt;/code&gt;. But if that's not available in your (older) Python version, the &lt;em&gt;let&lt;/em&gt; pattern works here too.</source>
          <target state="translated">如果确实要复制，则PEP 448样式最简单 &lt;code&gt;{**x, **y}&lt;/code&gt; 。 但是，如果您的（旧）Python版本中没有该功能，则&lt;em&gt;let&lt;/em&gt;模式也可以在这里使用。</target>
        </trans-unit>
        <trans-unit id="c68f13df74f8081969ebc7396a5bdbb15beb7948" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;x&lt;/code&gt; in a variable yet, you can use &lt;code&gt;lambda&lt;/code&gt; to make a local without using an assignment statement. This amounts to using &lt;code&gt;lambda&lt;/code&gt; as a &lt;em&gt;let expression&lt;/em&gt;, which is a common technique in functional languages, but maybe unpythonic.</source>
          <target state="translated">如果变量中还没有 &lt;code&gt;x&lt;/code&gt; ，则可以使用 &lt;code&gt;lambda&lt;/code&gt; 进行局部设置，而无需使用赋值语句。 这相当于使用 &lt;code&gt;lambda&lt;/code&gt; 作为&lt;em&gt;let表达式&lt;/em&gt; ，这是功能语言中的一种常用技术，但可能不是Python语言。</target>
        </trans-unit>
        <trans-unit id="6e67f1fbb5c4630089b3b15e7da7f230c6351803" translate="yes" xml:space="preserve">
          <source>If you don't mind mutating &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">如果您不介意 &lt;code&gt;x&lt;/code&gt; 的变异，</target>
        </trans-unit>
        <trans-unit id="23112b4c7ee35913e4183cf954bd3fbb6f22db7a" translate="yes" xml:space="preserve">
          <source>If you ever felt you would prefer to have a real merged &lt;code&gt;dict&lt;/code&gt;, then calling &lt;code&gt;dict(z)&lt;/code&gt; would produce it (but way more costly than the other solutions of course, so this is just worth mentioning).</source>
          <target state="translated">如果您觉得自己希望有一个真正的合并 &lt;code&gt;dict&lt;/code&gt; ，那么调用 &lt;code&gt;dict(z)&lt;/code&gt; 会生成它（但是当然比其他解决方案要昂贵得多，所以值得一提）。</target>
        </trans-unit>
        <trans-unit id="91c65288fd2cb6d1ebcbffd2f95dcc6f769de027" translate="yes" xml:space="preserve">
          <source>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</source>
          <target state="translated">如果你认为λ是邪恶的,那么不要再读了。按照要求,你可以用一个表达式写出快速、高效记忆的解决方案。</target>
        </trans-unit>
        <trans-unit id="7b3eb5dd9b8564f262213b8ec581f34343fb1155" translate="yes" xml:space="preserve">
          <source>If you use Python 3, it is only a little more complicated.  To create &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">如果您使用Python 3，它只会稍微复杂一点。 要创建 &lt;code&gt;z&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d340b513c30c260578d2c3eadac2366554f22a75" translate="yes" xml:space="preserve">
          <source>If you're not averse to importing a standard library module, you can do</source>
          <target state="translated">如果你不反对导入一个标准库模块,你可以做到</target>
        </trans-unit>
        <trans-unit id="a4d62fbeb1dc986c159aff37fcf7e409f975fec3" translate="yes" xml:space="preserve">
          <source>In Python 2, (or 3.4 or lower) write a function:</source>
          <target state="translated">在Python 2中,(或3.4或更低的版本)写一个函数。</target>
        </trans-unit>
        <trans-unit id="cddaaf9db6625675addbc60941262561bfd51d86" translate="yes" xml:space="preserve">
          <source>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. &lt;strong&gt;In Python 3, this will fail&lt;/strong&gt; because you're adding two &lt;code&gt;dict_items&lt;/code&gt; objects together, not two lists -</source>
          <target state="translated">在Python 2中，您将在每个内存字典中创建两个列表，在内存中创建第三个列表，其长度等于前两个字典的长度，然后丢弃所有三个列表以创建字典。 &lt;strong&gt;在Python 3中，这将失败，&lt;/strong&gt;因为您将两个 &lt;code&gt;dict_items&lt;/code&gt; 对象添加在一起，而不是两个列表-</target>
        </trans-unit>
        <trans-unit id="c145a8d3b1ebc6e2271fc27dc8537d7fd274de6b" translate="yes" xml:space="preserve">
          <source>In Python 2.7 (system Python):</source>
          <target state="translated">在Python 2.7中(系统Python)。</target>
        </trans-unit>
        <trans-unit id="c0da467e5ff897c9e6741e6911edbfc2c8e28314" translate="yes" xml:space="preserve">
          <source>In Python 3.5 (deadsnakes PPA):</source>
          <target state="translated">在Python 3.5中(deadsnakes PPA)。</target>
        </trans-unit>
        <trans-unit id="61986f9755b6245f3a2d4cfab600c14ea75b062c" translate="yes" xml:space="preserve">
          <source>In Python 3.5 or greater:</source>
          <target state="translated">在Python 3.5或更高版本中。</target>
        </trans-unit>
        <trans-unit id="7c246f03cced22905d4e5edbf31a21a72dfa1e56" translate="yes" xml:space="preserve">
          <source>In Python 3.9.0a4 or greater (final release date approx October 2020): &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;discussed here&lt;/a&gt;, was implemented to further simplify this:</source>
          <target state="translated">在Python 3.9.0a4或更高版本中（最终发布日期约为2020年10月）：实施&lt;a href=&quot;https://bugs.python.org/issue36144&quot;&gt;了此处讨论的&lt;/a&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot;&gt;PEP-584&lt;/a&gt;以进一步简化此操作：</target>
        </trans-unit>
        <trans-unit id="fb06defc9c6c89decb004ddee3cc8e2971971de4" translate="yes" xml:space="preserve">
          <source>In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be:</source>
          <target state="translated">在Python中,这相当简单,可以用我帖子末尾的代码来完成。既然如此,那么原问题的答案就是:</target>
        </trans-unit>
        <trans-unit id="2694d72958aa5476affbdd9f1fa8e1fb6ade5022" translate="yes" xml:space="preserve">
          <source>In a follow-up answer, you asked about the relative performance of these two alternatives:</source>
          <target state="translated">在后续的回答中,你问的是这两个备选方案的相对表现。</target>
        </trans-unit>
        <trans-unit id="fc9fa0b91a747b146f5bf2910dc05830d2caba46" translate="yes" xml:space="preserve">
          <source>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</source>
          <target state="translated">此外,当你使用.items()(Python 3.0 之前的)时,你正在创建一个新的列表,其中包含了 dict 中的项目。如果你的字典很大,那么这将是一个相当大的开销(两个大的列表,一旦合并的dict被创建出来,就会被扔掉)。</target>
        </trans-unit>
        <trans-unit id="dd84518801f2e66815fcf3f25a609ccfebd7ea62" translate="yes" xml:space="preserve">
          <source>In both approaches, &lt;code&gt;y&lt;/code&gt; will come second and its values will replace &lt;code&gt;x&lt;/code&gt;'s values, thus &lt;code&gt;'b'&lt;/code&gt; will point to &lt;code&gt;3&lt;/code&gt; in our final result.</source>
          <target state="translated">在这两种方法中， &lt;code&gt;y&lt;/code&gt; 将排第二，其值将替换 &lt;code&gt;x&lt;/code&gt; 的值，因此， &lt;code&gt;'b'&lt;/code&gt; 在我们的最终结果中将指向 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3840c97bb862e7304c6e3f15f1b99fb6f44f7a27" translate="yes" xml:space="preserve">
          <source>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses &lt;code&gt;dict&lt;/code&gt; in lots of places; optimizing its operations is a big deal.</source>
          <target state="translated">实际上，我什至声称纯粹的Python代码不可能做到比这更好。 而且，如果您可以在C扩展模块中做得更好，我想Python人士可能会对将您的代码（或您的方法的变体）并入Python核心感兴趣。 Python在很多地方都使用 &lt;code&gt;dict&lt;/code&gt; ； 优化运营非常重要。</target>
        </trans-unit>
        <trans-unit id="bb531282f9af11f54c3641bdd4af885240f75d4e" translate="yes" xml:space="preserve">
          <source>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</source>
          <target state="translated">在我看来,&quot;单一表达式 &quot;部分最好的答案,因为不需要额外的功能,而且很短。</target>
        </trans-unit>
        <trans-unit id="28f989d802777ef28e3ed883ee8ae092d02eb42c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;z0&lt;/code&gt; and &lt;code&gt;z2&lt;/code&gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</source>
          <target state="translated">换句话说， &lt;code&gt;z0&lt;/code&gt; 和 &lt;code&gt;z2&lt;/code&gt; 似乎具有基本相同的性能。 您认为这可能是巧合吗？ 我不....</target>
        </trans-unit>
        <trans-unit id="9bc07c9c43a19f58510985e71e66d75a3b1147f6" translate="yes" xml:space="preserve">
          <source>In python3, the &lt;code&gt;items&lt;/code&gt; method &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;no longer returns a list&lt;/a&gt;, but rather a &lt;em&gt;view&lt;/em&gt;, which acts like a set. In this case you'll need to take the set union since concatenating with &lt;code&gt;+&lt;/code&gt; won't work:</source>
          <target state="translated">在python3中， &lt;code&gt;items&lt;/code&gt; 方法&lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot;&gt;不再返回list&lt;/a&gt; ，而是返回一个&lt;em&gt;view&lt;/em&gt; ，其作用类似于set。 在这种情况下，您需要采用set并集，因为与 &lt;code&gt;+&lt;/code&gt; 串联将不起作用：</target>
        </trans-unit>
        <trans-unit id="4b8950cb37108627db33c7d426aad3319f43c846" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;time&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot;&gt;时间方面&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="576c81f813e6d5c7574b2bff19e7f7a19584c5ed" translate="yes" xml:space="preserve">
          <source>In your case, what you can do is:</source>
          <target state="translated">在你的情况下,你能做的是:</target>
        </trans-unit>
        <trans-unit id="eb9849d8300f85b4b8946c3d18417f7afe6aef40" translate="yes" xml:space="preserve">
          <source>Instead, we get this:</source>
          <target state="translated">相反,我们得到的是这个。</target>
        </trans-unit>
        <trans-unit id="613f9806d6fd6e5cb5f3886e4f538655d654d6e1" translate="yes" xml:space="preserve">
          <source>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</source>
          <target state="translated">它和上面提到的Z0和邪恶的Z2一样快,但很容易理解和改变。</target>
        </trans-unit>
        <trans-unit id="9270042b2f84bc91d9787a1d06a084ff6685203f" translate="yes" xml:space="preserve">
          <source>It is my understanding (as well as the understanding of the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;creator of the language&lt;/a&gt;) that the intended usage for &lt;code&gt;dict(**y)&lt;/code&gt; is for creating dicts for readability purposes, e.g.:</source>
          <target state="translated">根据我的理解（以及&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot;&gt;对语言创建者&lt;/a&gt;的理解）， &lt;code&gt;dict(**y)&lt;/code&gt; 的预期用途是出于可读性目的创建字典，例如：</target>
        </trans-unit>
        <trans-unit id="10e433f1aca9083f13e27caed8d5cca896a01f3e" translate="yes" xml:space="preserve">
          <source>It is now showing as implemented in the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;release schedule for 3.5, PEP 478&lt;/a&gt;, and it has now made its way into &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;What's New in Python 3.5&lt;/a&gt; document.</source>
          <target state="translated">它现在显示为在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot;&gt;3.5&lt;/a&gt;的发布时间表中实现，PEP 478 ，并且已进入&lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;Python 3.5的新功能&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="dea45706ebbfc3fa103ecf69ca8e21e9e39ff372" translate="yes" xml:space="preserve">
          <source>It's faster than &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; but not as fast as &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt;, at least on CPython. This version also works in Python 3 if you change &lt;code&gt;iteritems()&lt;/code&gt; to &lt;code&gt;items()&lt;/code&gt;, which is automatically done by the 2to3 tool.</source>
          <target state="translated">它比 &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; 快，但不如 &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt; 快。 n.update（b） ，至少在CPython上。 如果将 &lt;code&gt;iteritems()&lt;/code&gt; 更改为 &lt;code&gt;items()&lt;/code&gt; ，则此版本在Python 3中也可以使用，这是2to3工具自动完成的。</target>
        </trans-unit>
        <trans-unit id="41964880e9b5b33a4ebc5a2e547cf6b1a1fe1386" translate="yes" xml:space="preserve">
          <source>It's so silly that &lt;code&gt;.update&lt;/code&gt; returns nothing.</source>
          <target state="translated">太愚蠢了， &lt;code&gt;.update&lt;/code&gt; 什么也不返回。</target>
        </trans-unit>
        <trans-unit id="e8f3c6ca67433e529b1de06a8936ad80db4f01c3" translate="yes" xml:space="preserve">
          <source>Less Performant But Correct Ad-hocs</source>
          <target state="translated">性能较差但正确的Ad-hocs</target>
        </trans-unit>
        <trans-unit id="47d53f050b02da45cdaa39f901ee75d32b02efe6" translate="yes" xml:space="preserve">
          <source>Lookups search the underlying mappings successively until a key is found.</source>
          <target state="translated">查询依次搜索底层映射,直到找到一个键。</target>
        </trans-unit>
        <trans-unit id="f4717469d98280c4746039a514a7e2bacbf3bfde" translate="yes" xml:space="preserve">
          <source>Mapping two lists into a dictionary</source>
          <target state="translated">将两个列表映射到字典中</target>
        </trans-unit>
        <trans-unit id="f9f1aa4bbd26bc6ea841d2cf5df62d3193846a18" translate="yes" xml:space="preserve">
          <source>More comments:</source>
          <target state="translated">更多评论:</target>
        </trans-unit>
        <trans-unit id="8ef25359578b2efe9adb36ef344ee5b9c98419fb" translate="yes" xml:space="preserve">
          <source>Mutating methods in the standard library (like &lt;code&gt;.update()&lt;/code&gt;) return &lt;code&gt;None&lt;/code&gt; by convention, so this pattern will work on those too. If you're using a method that doesn't follow this convention, then &lt;code&gt;or&lt;/code&gt; may not work. But, you can use a tuple display and index to make it a single expression, instead. This works regardless of what the first element evaluates to.</source>
          <target state="translated">标准库中的变异方法（如 &lt;code&gt;.update()&lt;/code&gt; ）按约定返回 &lt;code&gt;None&lt;/code&gt; ，因此该模式也适用于那些方法。 如果您使用的方法不遵循此约定，则可能无法正常工作。 但是，您可以使用元组显示和索引来使其成为单个表达式。 无论第一个元素的计算结果如何，此方法都有效。</target>
        </trans-unit>
        <trans-unit id="4a4fd9ea7e1bb91ce1c283ee8443542d3f4b5d79" translate="yes" xml:space="preserve">
          <source>My explanation of Python's &lt;strong&gt;dictionary implementation&lt;/strong&gt;, updated for 3.6.</source>
          <target state="translated">我对Python &lt;strong&gt;字典实现的&lt;/strong&gt;解释，已于3.6更新。</target>
        </trans-unit>
        <trans-unit id="5451c5e024244f0cb1d2a834192850cb982c87b8" translate="yes" xml:space="preserve">
          <source>My response: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</source>
          <target state="translated">我的回答：如果我们实际上担心可读性，则 &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; 在我看来实际上要清晰得多。 而且它不向前兼容，因为Python 2越来越不推荐使用。</target>
        </trans-unit>
        <trans-unit id="a06152fa7c2b5a4be7f84d7628e46f2fff8180df" translate="yes" xml:space="preserve">
          <source>Not yet on Python 3.5, but want a &lt;em&gt;single expression&lt;/em&gt;</source>
          <target state="translated">尚未在Python 3.5上运行，但需要一个&lt;em&gt;表达式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95a364312f027f57dff95eb6f993224d40d8d5d7" translate="yes" xml:space="preserve">
          <source>Note that we can merge in with literal notation as well:</source>
          <target state="translated">注意,我们也可以和字面符号合并在一起。</target>
        </trans-unit>
        <trans-unit id="85f3316c38e547312844b492fc59334cdc24d0e8" translate="yes" xml:space="preserve">
          <source>Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case.</source>
          <target state="translated">当然,如果你经常使用结果,那么你会在某个时候达到一个极限,在这个时候创建一个真正的合并字典会是更快的解决方案。正如我所说,这取决于你的用例。</target>
        </trans-unit>
        <trans-unit id="48ac36a7075dd373be352f2840bc51e3b09e06b1" translate="yes" xml:space="preserve">
          <source>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative &lt;code&gt;z2&lt;/code&gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the &lt;code&gt;timeit&lt;/code&gt; module that comes with Python.</source>
          <target state="translated">至少在我的机器上（运行Python 2.5.2的相当普通的x86_64），替代 &lt;code&gt;z2&lt;/code&gt; 不仅更短，更简单，而且显着更快。 您可以使用Python随附的 &lt;code&gt;timeit&lt;/code&gt; 模块自行验证。</target>
        </trans-unit>
        <trans-unit id="5693b010303f40e7b6b2989cf211c19701b8fd90" translate="yes" xml:space="preserve">
          <source>One would expect a result of something like this:</source>
          <target state="translated">人们会期待这样的结果。</target>
        </trans-unit>
        <trans-unit id="36ccf0d2daf5f0450415093a23f65782376fed7c" translate="yes" xml:space="preserve">
          <source>Or even</source>
          <target state="translated">甚至</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="af936431e91ad36e97d16ad3fcc34657b6a9c683" translate="yes" xml:space="preserve">
          <source>Performance Analysis</source>
          <target state="translated">性能分析</target>
        </trans-unit>
        <trans-unit id="ccac62c217a26cb3460e444b60d39cb6b574af2e" translate="yes" xml:space="preserve">
          <source>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</source>
          <target state="translated">就我个人而言,我最喜欢这个版本,因为它能很好地描述出我想要的功能语法。唯一的一个小问题是,它没有让y的值优先于x的值,但我不认为这很难弄清楚。</target>
        </trans-unit>
        <trans-unit id="f2f88b2c502c6ef38181787f69def28accd2b7dd" translate="yes" xml:space="preserve">
          <source>Python 3.5 (PEP 448) allows a nicer syntax option:</source>
          <target state="translated">Python 3.5 (PEP 448)允许一个更好的语法选项。</target>
        </trans-unit>
        <trans-unit id="31fc173b6064c40551f851f890b41889dde4879b" translate="yes" xml:space="preserve">
          <source>Recursively/deep update a dict</source>
          <target state="translated">递归深度更新一个dict</target>
        </trans-unit>
        <trans-unit id="e28a5f1ec1369c5c0c25a05a06b177d5f18ef2a0" translate="yes" xml:space="preserve">
          <source>Resources on Dictionaries</source>
          <target state="translated">关于字典的资源</target>
        </trans-unit>
        <trans-unit id="8e32dd9f3b57b6ccc2e40d0141dc5fa237e75edf" translate="yes" xml:space="preserve">
          <source>Response to comments</source>
          <target state="translated">对意见的答复</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">结果是:</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="0d93e84a8e035a40c9b757a07ddde97ea07443d0" translate="yes" xml:space="preserve">
          <source>Say you have two dicts and you want to merge them into a new dict without altering the original dicts:</source>
          <target state="translated">假设你有两个口诀,你想把它们合并成一个新的口诀而不改变原来的口诀。</target>
        </trans-unit>
        <trans-unit id="e04ba6f40f9b2060e8c41a7b09e4e62c77d60e4e" translate="yes" xml:space="preserve">
          <source>Similarly, taking the union of &lt;code&gt;items()&lt;/code&gt; in Python 3 (&lt;code&gt;viewitems()&lt;/code&gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, &lt;strong&gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:&lt;/strong&gt;</source>
          <target state="translated">类似地，当值是不可散列的对象（例如，列表 &lt;code&gt;items()&lt;/code&gt; 在Python 3中合并items（） &lt;code&gt;viewitems()&lt;/code&gt; 在Python 2.7中为viewitems（） ）也将失败。 即使您的值是可哈希的， &lt;strong&gt;由于集合在语义上是无序的，因此关于优先级的行为是不确定的。&lt;/strong&gt; &lt;strong&gt;所以不要这样做：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a63b49fb1159980c455f7b80a5475a5b7a4bbded" translate="yes" xml:space="preserve">
          <source>Simple solution using itertools that preserves order (latter dicts have precedence)</source>
          <target state="translated">使用迭代工具的简单解决方案,保留顺序(后面的dicts有优先级)。</target>
        </trans-unit>
        <trans-unit id="1ce6c799d807e8667caa62ff4d2ed81872b44880" translate="yes" xml:space="preserve">
          <source>Simple, readable, performant. You &lt;em&gt;know&lt;/em&gt;&lt;code&gt;update()&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt;, which is a false value. So the above expression will always evaluate to &lt;code&gt;x&lt;/code&gt;, after updating it.</source>
          <target state="translated">简单，可读，高效。 您&lt;em&gt;知道&lt;/em&gt; &lt;code&gt;update()&lt;/code&gt; 总是返回 &lt;code&gt;None&lt;/code&gt; ，这是一个错误的值。 因此，上面的表达式在更新后将始终计算为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f32e703bd34c95af93956212150aad7a9788da7d" translate="yes" xml:space="preserve">
          <source>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</source>
          <target state="translated">所以查找速度要慢一个数量级。我是Chainmap的粉丝,但在可能有很多查询的地方,看起来不太实用。</target>
        </trans-unit>
        <trans-unit id="a8e2fa47ec0878caa65f8502de5b8cbd1c0786ed" translate="yes" xml:space="preserve">
          <source>Thanks rednaw for edits.</source>
          <target state="translated">谢谢rednaw的编辑。</target>
        </trans-unit>
        <trans-unit id="d4d79546dfca81b3339e87ff38237ad185b2fb4d" translate="yes" xml:space="preserve">
          <source>The 'one' entry should have had 'depth_2' and 'extra' as items inside its dictionary if it truly was a merge.</source>
          <target state="translated">如果真的是合并的话,'one'条目应该有'depth_2'和'extra'作为其字典内的项目。</target>
        </trans-unit>
        <trans-unit id="d3e70f05e7f6d91452e134d86664d8e73a4261ca" translate="yes" xml:space="preserve">
          <source>The best version I could think while not using copy would be:</source>
          <target state="translated">我能想到的最好的版本,而不使用副本的时候,最好的版本是。</target>
        </trans-unit>
        <trans-unit id="14a3e754832e898bf1e858d57c5ffe3967bb05c5" translate="yes" xml:space="preserve">
          <source>The deep merge that rcwesick gave also creates the same result.</source>
          <target state="translated">rcwesick给出的深度合并也产生了同样的结果。</target>
        </trans-unit>
        <trans-unit id="a312af1c908fc9ad75fb286e3bc170573e2c6cc0" translate="yes" xml:space="preserve">
          <source>The desired result is to get a new dictionary (&lt;code&gt;z&lt;/code&gt;) with the values merged, and the second dict's values overwriting those from the first.</source>
          <target state="translated">理想的结果是获得一个合并了值的新字典（ &lt;code&gt;z&lt;/code&gt; ），第二个字典的值覆盖第一个字典的值。</target>
        </trans-unit>
        <trans-unit id="99cefd2e5a500633b962557b5eb27824141a25b8" translate="yes" xml:space="preserve">
          <source>The following is done on Ubuntu 14.04</source>
          <target state="translated">以下是在Ubuntu 14.04上完成的</target>
        </trans-unit>
        <trans-unit id="c3b7bd83073daf49138869cf80438ea437175ad6" translate="yes" xml:space="preserve">
          <source>The official Python &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;docs on dictionaries&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot;&gt;字典上&lt;/a&gt;的官方Python 文档</target>
        </trans-unit>
        <trans-unit id="7a8b9b328f9958cca0a11b9acc4b8cd695c2636b" translate="yes" xml:space="preserve">
          <source>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</source>
          <target state="translated">我对迄今所列举的解决方案的问题是,在合并后的字典中,键 &quot;b &quot;的值是10,但按照我的思维方式,应该是12。有鉴于此,我提出以下几点。</target>
        </trans-unit>
        <trans-unit id="9fcad77208db870fca468aadd90c4da8d6ce0d45" translate="yes" xml:space="preserve">
          <source>These approaches are less performant, but they will provide correct behavior.
They will be &lt;em&gt;much less&lt;/em&gt; performant than &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they &lt;em&gt;do&lt;/em&gt; respect the order of precedence (latter dicts have precedence)</source>
          <target state="translated">这些方法的性能较差，但是它们将提供正确的行为。 它们的性能将比 &lt;code&gt;copy&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 或新的拆包&lt;em&gt;要差&lt;/em&gt;得多，因为它们在更高的抽象级别上遍历每个键值对，但是它们&lt;em&gt;确实&lt;/em&gt;尊重优先级的顺序（后者有优先级）</target>
        </trans-unit>
        <trans-unit id="a0ea664e2a3188bf488d6c2a6055af74fb3539bf" translate="yes" xml:space="preserve">
          <source>This can be done with a single dict comprehension:</source>
          <target state="translated">这一点,可以通过单项听写理解来实现。</target>
        </trans-unit>
        <trans-unit id="36e6d4df98468539933d14acc5debf6efc5fe4ba" translate="yes" xml:space="preserve">
          <source>This can slow you down if you have a lot of lookups in your application:</source>
          <target state="translated">如果你的应用程序中有大量的查询,这可能会拖累你。</target>
        </trans-unit>
        <trans-unit id="19c42edc088b07647e75e1b22d2ce503ca0cd824" translate="yes" xml:space="preserve">
          <source>This discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the &lt;code&gt;update&lt;/code&gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</source>
          <target state="translated">讨论中仍然缺少一些重要的内容，这是这些替代方法与合并两个列表的&amp;ldquo;明显&amp;rdquo;方法的性能比较：使用 &lt;code&gt;update&lt;/code&gt; 方法。 为了使事物与表达式保持一致，而不会修改x或y，我将制作x的副本，而不是就地对其进行修改，如下所示：</target>
        </trans-unit>
        <trans-unit id="dc1c7903eae69f6f9e6f83fcb5785373d15617e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates what happens when values are unhashable:</source>
          <target state="translated">这个例子证明了当价值观不被动摇时,会发生什么。</target>
        </trans-unit>
        <trans-unit id="9157d19d33dc20ac6d37fac9da93fd7fa473ca0f" translate="yes" xml:space="preserve">
          <source>This function will work in Python 2 and 3 for all dicts. e.g. given dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">此功能将在Python 2和3中适用于所有字典。 例如，给定 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;g&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1dca0e3af9d62b26b6d4ca040a8f1540fe8eaa2f" translate="yes" xml:space="preserve">
          <source>This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</source>
          <target state="translated">考虑到Python的其他实现(Pypython、Jython、IronPython),这种不一致是很糟糕的。因此在Python 3中被修复了,因为这种用法可能是一个破坏性的变化。</target>
        </trans-unit>
        <trans-unit id="3c565024f23a6cd2ae73023603f11cac8eb9232b" translate="yes" xml:space="preserve">
          <source>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</source>
          <target state="translated">这可能不是一个流行的答案，但是您几乎可以肯定不想这样做。 如果要合并的副本，请使用copy（或&lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;deepcopy&lt;/a&gt; ，具体取决于您的需求），然后进行更新。 与使用.items（）+ .items（）进行单行创建相比，两行代码更具可读性-更具Python风格。 显式胜于隐式。</target>
        </trans-unit>
        <trans-unit id="02a2f32a05821cacdddcb95030b2675f25361e82" translate="yes" xml:space="preserve">
          <source>This should solve your problem.</source>
          <target state="translated">这应该能解决你的问题。</target>
        </trans-unit>
        <trans-unit id="686c1f44b9d06635a40727397360cca5fb0d76bc" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;dict&lt;/code&gt; constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</source>
          <target state="translated">这使用了 &lt;code&gt;dict&lt;/code&gt; 构造函数，并且非常快且内存效率高（甚至比我们的两步过程略高），但是除非您确切地知道这里正在发生什么（也就是说，第二个dict作为关键字参数传递给了dict构造函数），很难阅读，这不是预期的用法，因此不是Pythonic。</target>
        </trans-unit>
        <trans-unit id="463fe46eebffb482307a2b0a04183fc401c2acf9" translate="yes" xml:space="preserve">
          <source>This will, as you want it, put the final dict in &lt;code&gt;z&lt;/code&gt;, and make the value for key &lt;code&gt;b&lt;/code&gt; be properly overridden by the second (&lt;code&gt;y&lt;/code&gt;) dict's value:</source>
          <target state="translated">可以根据需要将最终的dict放入 &lt;code&gt;z&lt;/code&gt; ，并用第二个（ &lt;code&gt;y&lt;/code&gt; ）dict的值正确覆盖键 &lt;code&gt;b&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="827f523c69cfc77e578e7347bfd913a0423d4505" translate="yes" xml:space="preserve">
          <source>Usage (tested in python 3):</source>
          <target state="translated">使用方法(在python 3中测试)。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e8a5cd8514bfb309e8f3f05950c1200e457ea3dc" translate="yes" xml:space="preserve">
          <source>Using chain also, does not work:</source>
          <target state="translated">用链子也,不行。</target>
        </trans-unit>
        <trans-unit id="cfbc3d78519156ea4d38e12324b7f22474d7df90" translate="yes" xml:space="preserve">
          <source>When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed.</source>
          <target state="translated">当使用这个新对象时,它的行为将像合并后的字典一样,但它的创建时间不变,内存占用也不变,而原来的字典却没有被改变。创建它比其他的解决方案要便宜得多。</target>
        </trans-unit>
        <trans-unit id="2a93691216c27b37fa080f1bf21889060fcd92b2" translate="yes" xml:space="preserve">
          <source>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</source>
          <target state="translated">虽然这个问题已经回答了好几次了,但这个简单的解决方法还没有列出。</target>
        </trans-unit>
        <trans-unit id="cd809d0ef673f12b00a606ccbe54a8115b1c82af" translate="yes" xml:space="preserve">
          <source>Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I'll update this later once I write a method that does a true merge.</source>
          <target state="translated">是的,合并样本字典会起作用,但都不是一个通用的合并机制。等我写出一个真正的合并方法后,再更新一下。</target>
        </trans-unit>
        <trans-unit id="2aa391717295fad536baefee8bd2d60a19871d4f" translate="yes" xml:space="preserve">
          <source>Yes. I must refer you back to the question, which is asking for a &lt;em&gt;shallow&lt;/em&gt; merge of &lt;strong&gt;&lt;em&gt;two&lt;/em&gt;&lt;/strong&gt; dictionaries, with the first's values being overwritten by the second's - in a single expression.</source>
          <target state="translated">是。 我必须回头再问这个问题，该问题要求将&lt;strong&gt;&lt;em&gt;两个&lt;/em&gt;&lt;/strong&gt;字典进行&lt;em&gt;浅层&lt;/em&gt;合并，第一个字典的值将被第二个字典的值覆盖-在一个表达式中。</target>
        </trans-unit>
        <trans-unit id="ee121489b6e0d4a946801627644c8e2674d2d13d" translate="yes" xml:space="preserve">
          <source>You can also chain the dicts manually inside a dict comprehension:</source>
          <target state="translated">你也可以在听写理解里面手动地把听写串联起来。</target>
        </trans-unit>
        <trans-unit id="e8a9e7391a7cebd4162276bf43babcfe429d286a" translate="yes" xml:space="preserve">
          <source>You can also make a function to merge an undefined number of dicts, from zero to a very large number:</source>
          <target state="translated">你也可以做一个函数来合并一个未定义的dicts,从0到一个很大的数字。</target>
        </trans-unit>
        <trans-unit id="d99a90478f3ad33b4d2bc5f254632c7bfd37d59d" translate="yes" xml:space="preserve">
          <source>You can also use this class to make a kind of copy-on-write dictionary:</source>
          <target state="translated">你也可以用这个类来做一种抄写字典。</target>
        </trans-unit>
        <trans-unit id="9cedfd6f2171ececea9d197f9ad610009dfddd7f" translate="yes" xml:space="preserve">
          <source>You could also do this of course if you don't care about copying it:</source>
          <target state="translated">当然,如果你不屑于复制,也可以这样做。</target>
        </trans-unit>
        <trans-unit id="58f29ce54e05025dbf326102828358d60d6406e0" translate="yes" xml:space="preserve">
          <source>You could also write this as</source>
          <target state="translated">你也可以把它写成</target>
        </trans-unit>
        <trans-unit id="3ef1d0278a40be0903df836eb1993ad9c45936ba" translate="yes" xml:space="preserve">
          <source>You could use a lambda instead.</source>
          <target state="translated">你可以用Lambda代替。</target>
        </trans-unit>
        <trans-unit id="3e45b5c2910ea1c81696ad9de828761856f8df26" translate="yes" xml:space="preserve">
          <source>You said you wanted one expression, so I abused &lt;code&gt;lambda&lt;/code&gt; to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</source>
          <target state="translated">您说您想要一个表达式，所以我滥用了 &lt;code&gt;lambda&lt;/code&gt; 来绑定一个名称，使用元组来覆盖lambda的一个表达式的限制。 随时畏缩。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9158b7790079767a2ee5155681bc0537e04269f5" translate="yes" xml:space="preserve">
          <source>and key value pairs in &lt;code&gt;g&lt;/code&gt; will take precedence over dicts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;, and so on.</source>
          <target state="translated">和 &lt;code&gt;g&lt;/code&gt; 中的键值对将优先于字典 &lt;code&gt;a&lt;/code&gt; 至 &lt;code&gt;f&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">而现在,</target>
        </trans-unit>
        <trans-unit id="6dc92c5dffb9e2875bb5be2d30824a953e7e8fee" translate="yes" xml:space="preserve">
          <source>and then you have a single expression:</source>
          <target state="translated">然后你有一个单一的表达方式。</target>
        </trans-unit>
        <trans-unit id="538141bce772b5861479742348306cced3786ed9" translate="yes" xml:space="preserve">
          <source>and you would have to explicitly create them as lists, e.g. &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt;. This is a waste of resources and computation power.</source>
          <target state="translated">并且必须将它们显式创建为列表，例如 &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt; 。 这浪费了资源和计算能力。</target>
        </trans-unit>
        <trans-unit id="feeb579278407bb98d8960ea0156b0f057ac30d9" translate="yes" xml:space="preserve">
          <source>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</source>
          <target state="translated">和Tony的做法一样,但(毫不奇怪),在记号上的差异并没有对性能产生任何可衡量的影响。使用任何一种看起来对你来说都是正确的。当然,他指出双语句的版本更容易理解,这一点是绝对正确的。</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">而不是</target>
        </trans-unit>
        <trans-unit id="c5d0aeaef87c64e87fa64d76c410acb93a6f6869" translate="yes" xml:space="preserve">
          <source>lead me to conclude that &lt;code&gt;z3&lt;/code&gt; is somewhat faster than &lt;code&gt;z1&lt;/code&gt;, but not nearly as fast as &lt;code&gt;z2&lt;/code&gt;.  Definitely not worth all the extra typing.</source>
          <target state="translated">我得出的结论是 &lt;code&gt;z3&lt;/code&gt; 比 &lt;code&gt;z1&lt;/code&gt; 快一些，但不及 &lt;code&gt;z2&lt;/code&gt; 快。 绝对不值得所有额外的输入。</target>
        </trans-unit>
        <trans-unit id="3846c179246b1e2fb787941b7f16f2f7ff81ff9b" translate="yes" xml:space="preserve">
          <source>or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</source>
          <target state="translated">或者在python 2.6中(也许早在2.4引入生成器表达式的时候就已经出现了)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
