<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/381542">
    <body>
      <group id="381542">
        <trans-unit id="1c532b8e159d2f6be41bfbd2e6c1b3c3566c6f16" translate="yes" xml:space="preserve">
          <source>&quot;Pointer Arithmetic&quot; internally calculated as</source>
          <target state="translated">&quot;指针算术 &quot;内部计算为</target>
        </trans-unit>
        <trans-unit id="f90ed12168301e6151719fa19edb73514ba66ab9" translate="yes" xml:space="preserve">
          <source>(And in &lt;code&gt;array[i]&lt;/code&gt;, the array name is implicitly converted to a pointer to the array's first element.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（并且在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;array[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，数组名隐式转换为指向数组第一个元素的指针。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="665d882bc5ec3ea11a78f3e1d6d3b2faede30961" translate="yes" xml:space="preserve">
          <source>1) pointer to data</source>
          <target state="translated">1)指针到数据</target>
        </trans-unit>
        <trans-unit id="6d4a55de86e2c176f93d7c8e25e81b8961a89739" translate="yes" xml:space="preserve">
          <source>2) const pointer to data</source>
          <target state="translated">2)const指针指向数据</target>
        </trans-unit>
        <trans-unit id="dc116f3e7b6cb13d1d9a8ee78be1aaf1c6bdb877" translate="yes" xml:space="preserve">
          <source>3) const pointer to const data</source>
          <target state="translated">3)const pointer to const data</target>
        </trans-unit>
        <trans-unit id="ecd8f0ab071dd440c98d22200e1ba9d53d322230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*(a+3)&lt;/code&gt; equals &lt;code&gt;*(3+a)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*(a+3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(3+a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28201ef096f2131ccdc6a35516a0644b4ea983ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; is a pointer to the first element of the array. &lt;code&gt;a[5]&lt;/code&gt; is the value that's 5 &lt;strong&gt;elements&lt;/strong&gt; further from &lt;code&gt;a&lt;/code&gt;, which is the same as &lt;code&gt;*(a + 5)&lt;/code&gt;, and from elementary school math we know those are equal (addition is &lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot;&gt;commutative&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是指向数组第一个元素的指针。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;距&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; 较&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 5个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元素&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它与&lt;/font&gt; &lt;code&gt;*(a + 5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，从小学数学我们知道它们是相等的（加法是&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可交换的&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="249153e7dded62e636d80b565dbc2016bd13473b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a[2]&lt;/code&gt; is equals to 2[a] because the internal operation on both of this is</source>
          <target state="translated">&lt;code&gt;a[2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等于2 [a]，因为这两个函数的内部运算都是&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7493043c20a2ee1a9aa0b07cb9d465f952679903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p++;&lt;/code&gt; is valid but &lt;code&gt;a++&lt;/code&gt; is invalid</source>
          <target state="translated">&lt;code&gt;p++;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有效，但&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无效&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="985fb68b5b45504442a8d537a1489c21922d8f1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;you can understand easily by&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你可以很容易地理解&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a230fcbc7d44f33ab50dbec09842e1b4d1a49991" translate="yes" xml:space="preserve">
          <source>A little bit of history now.  Among other languages, BCPL had a fairly major influence on C's early development.  If you declared an array in BCPL with something like:</source>
          <target state="translated">现在说一点历史的事情吧。在其他语言中,BCPL对C的早期发展有相当大的影响。如果你在BCPL中声明一个数组,用类似于:</target>
        </trans-unit>
        <trans-unit id="9d3c6f48e3938b4bed030f7359a3407d1923ba45" translate="yes" xml:space="preserve">
          <source>And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).</source>
          <target state="translated">而且多年来,对该规则的任何修改都会打破现有的规范(虽然1989年的ANSI C标准可能是个好机会)。</target>
        </trans-unit>
        <trans-unit id="9c34c03a8950c95878da245890e59067c02e7660" translate="yes" xml:space="preserve">
          <source>And, of course</source>
          <target state="translated">当然还有</target>
        </trans-unit>
        <trans-unit id="41762cb9625c061a27823eda935b612b05021406" translate="yes" xml:space="preserve">
          <source>As Joel points out in &lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;Stack Overflow podcast #34&lt;/a&gt;, in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot;&gt;C Programming Language&lt;/a&gt; (aka: K &amp;amp; R), there is mention of this property of arrays in C: &lt;code&gt;a[5] == 5[a]&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如Joel &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C编程语言&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（又名：K＆R）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Stack Overflow播客＃34中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指出的那样&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中提到了数组的此属性：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c95149555cd6976edeb71b3e72ed11b54a2b5b66" translate="yes" xml:space="preserve">
          <source>As we know that we can't change or modify const value in our program cause it's throws an &lt;strong&gt;ERROR&lt;/strong&gt; at compile time</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如我们所知，我们无法在程序中更改或修改const值，因为它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在编译时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;会引发&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ERROR&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90ab497a5e7b7464cce09bdb9f6aa2d857948dfb" translate="yes" xml:space="preserve">
          <source>Because array access is defined in terms of pointers.  &lt;code&gt;a[i]&lt;/code&gt; is defined to mean &lt;code&gt;*(a + i)&lt;/code&gt;, which is commutative.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为数组访问是根据指针定义的。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被定义为表示&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是可交换的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb668d53c34ceb6271676e0153f41c6ebe7f633f" translate="yes" xml:space="preserve">
          <source>But in this case we're talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)</source>
          <target state="translated">但这里我们具体说的是指针运算,其中一个操作条是指针,另一个是整数。(整数+整数是不同的运算,而指针+指针是无稽之谈)。</target>
        </trans-unit>
        <trans-unit id="aa1359c3969ec4c8fac3ce4354042aa785004056" translate="yes" xml:space="preserve">
          <source>But the commutativity of addition is not all that obvious in this case.</source>
          <target state="translated">但在这种情况下,加法的换向性并不十分明显。</target>
        </trans-unit>
        <trans-unit id="598b1c1d1625a55404599d1e3f3682223df0545c" translate="yes" xml:space="preserve">
          <source>C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;Users' Reference to B&lt;/a&gt;), which got it from &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;BCPL&lt;/a&gt; (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++从C继承了这个定义，C是从B那里得到的（1972年&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用户参考B中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明确提到了数组索引的可交换性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），它是从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BCPL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（1967年手册）得到的，甚至可能从早期语言（CPL？Algol？）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="988dcbc4fe0ee658747db4c81dc1258d95b8c55c" translate="yes" xml:space="preserve">
          <source>Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.</source>
          <target state="translated">把C和C++改成要求把指针放在左边,把整数放在右边,可能会破坏一些现有的代码,但不会损失真正的表现力。</target>
        </trans-unit>
        <trans-unit id="8a6489d5b2c67a7d3726a70e1268159af4a397d9" translate="yes" xml:space="preserve">
          <source>Consider the following declarations:</source>
          <target state="translated">考虑到以下声明:</target>
        </trans-unit>
        <trans-unit id="b652adbdb6a3ed93ed3cfa571249369d1118cb26" translate="yes" xml:space="preserve">
          <source>For addition, either both operands shall have arithmetic type, or &lt;em&gt;the left&lt;/em&gt;
  operand shall be a pointer to a complete object type and the &lt;em&gt;right operand&lt;/em&gt;
  shall have integer type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，两个操作数都应具有算术类型，或者&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 操作数应是指向完整对象类型的指针，而&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右操作数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 应具有整数类型。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d18d0f48b4c944be08073c1f32334fbe7cd130e" translate="yes" xml:space="preserve">
          <source>For addition, either both operands shall have arithmetic type, or one
  operand shall be a pointer to a complete object type and the other
  shall have integer type.</source>
          <target state="translated">此外,要么两个操作符都是算术类型,要么一个操作符是指向完整对象类型的指针,另一个操作符是整数类型。</target>
        </trans-unit>
        <trans-unit id="1403d7ce86f32bda0cd4edd41a6686136925e844" translate="yes" xml:space="preserve">
          <source>For pointers in C, we have</source>
          <target state="translated">对于C语言的指针,我们有</target>
        </trans-unit>
        <trans-unit id="66d14b89e8fc22a7ab29c295425b86d1e3b0db09" translate="yes" xml:space="preserve">
          <source>Hence it is true that &lt;code&gt;a[5] == 5[a].&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt; &lt;code&gt;a[5] == 5[a].&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;是正确的&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e750355f8cd7e882204c80ce48acc16a8fd88644" translate="yes" xml:space="preserve">
          <source>How &lt;code&gt;a[5]&lt;/code&gt; will work -&amp;gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将工作- &amp;gt;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f55bdf5fd546d350e0f04bb758dbb91c556fc521" translate="yes" xml:space="preserve">
          <source>I just find out this ugly syntax could be &quot;useful&quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !</source>
          <target state="translated">我只是发现这个丑陋的语法可能是 &quot;有用的&quot;,或者说至少在你想处理一个数组中的索引指向同一个数组中的位置时,这个语法是非常有趣的。它可以取代嵌套的方括号,使代码更易读!</target>
        </trans-unit>
        <trans-unit id="6523196f463ce8a226b083dadade80781f11a991" translate="yes" xml:space="preserve">
          <source>I know the question is answered, but I couldn't resist sharing this explanation.</source>
          <target state="translated">我知道这个问题已经回答了,但我还是忍不住分享了这个解释。</target>
        </trans-unit>
        <trans-unit id="879d6f03dde6396f4c6ef6e1366e84d24245382a" translate="yes" xml:space="preserve">
          <source>I remember Principles of Compiler design,
Let's assume &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; array and size of &lt;code&gt;int&lt;/code&gt; is 2 bytes,
&amp;amp; Base address for &lt;code&gt;a&lt;/code&gt; is 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我记得编译器设计原理，假设&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大小&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是2个字节，而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基址&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是1000。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4312bd7f2106bff89c992709b29c9074f9f2d5c3" translate="yes" xml:space="preserve">
          <source>I think something is being missed by the other answers.</source>
          <target state="translated">我觉得有些东西被其他答案漏掉了。</target>
        </trans-unit>
        <trans-unit id="0120639388c9d9eb979dfcb56da488ae93a32e77" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://cs-fundamentals.com/c-programming/arrays-in-c.php&quot;&gt;C arrays&lt;/a&gt;, &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; are the same, and their equivalent pointer notations are &lt;code&gt;*(arr + 3)&lt;/code&gt; to &lt;code&gt;*(3 + arr)&lt;/code&gt;. But on the contrary &lt;code&gt;[arr]3&lt;/code&gt; or &lt;code&gt;[3]arr&lt;/code&gt; is not correct and will result into syntax error, as &lt;code&gt;(arr + 3)*&lt;/code&gt; and &lt;code&gt;(3 + arr)*&lt;/code&gt; are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://cs-fundamentals.com/c-programming/arrays-in-c.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C数组中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;arr[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;3[arr]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同，它们的等效指针表示法是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(arr + 3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(3 + arr)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。但是相反，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[arr]3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[3]arr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是不正确的，并且会导致语法错误，因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(arr + 3)*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(3 + arr)*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是有效的表达式。原因是取消引用运算符应放置在表达式产生的地址之前，而不是地址之后。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="750606dee7fb039c0840d301abcb6a2a434c1b8c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;a.out&lt;/em&gt;, the symbol &lt;em&gt;a&lt;/em&gt; is at an address that's the beginning of the array, and symbol &lt;em&gt;p&lt;/em&gt; is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a.out中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，符号&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在数组的开头的地址，而符号&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;p&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在存储指针的地址，并且该内存位置的指针值是数组的开头。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edb025b4d216cf36fb49869edda6fd6ce53178c2" translate="yes" xml:space="preserve">
          <source>In C</source>
          <target state="translated">在C区</target>
        </trans-unit>
        <trans-unit id="0dfdd853ce75c25295e1a1a4ed0060949c855ba6" translate="yes" xml:space="preserve">
          <source>In C++ terms, we really have two sets of overloaded &lt;code&gt;+&lt;/code&gt; operators, which can be loosely described as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用C ++术语来说，我们实际上有两组重载&lt;/font&gt;&lt;/font&gt; &lt;code&gt;+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符，可以将它们大致描述为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="078794ea29568f11e34617aa8c23cdbdff085dea" translate="yes" xml:space="preserve">
          <source>In fact, this is true, i.e wherever one writes &lt;code&gt;a[i]&lt;/code&gt; it can be
  replaced with &lt;code&gt;*(a + i)&lt;/code&gt;  without any problems. In fact, the compiler
  will create the same code in either case. Thus we see that pointer
  arithmetic is the same thing as array indexing. Either syntax produces
  the same result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，这是对的，也就是说，无论在哪里写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，都可以用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;替换，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 而不会出现任何问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，无论哪种情况，编译器都会创建相同的代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我们看到指针算术与数组索引是同一回事。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种语法都会产生相同的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae47d23442a5f0fc06581a19aa48fcb525bb51fa" translate="yes" xml:space="preserve">
          <source>It could just as easily have said:</source>
          <target state="translated">它可以很容易地说:</target>
        </trans-unit>
        <trans-unit id="434d5309f6fb971f10b66d6ec360b256083e8cb2" translate="yes" xml:space="preserve">
          <source>It has very good explanation in &lt;em&gt;A TUTORIAL ON POINTERS AND ARRAYS IN C&lt;/em&gt;
by Ted Jensen.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Ted Jensen &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;撰写的《 C中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针与数组教程》中&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有很好的解释&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2c902ce692b4aec32e849e37c03678874983500" translate="yes" xml:space="preserve">
          <source>It will return me object at location 990.</source>
          <target state="translated">它将在990号地点给我发回对象。</target>
        </trans-unit>
        <trans-unit id="a2e53b6a9b29ea8bc57610fcef4acc120a1007a6" translate="yes" xml:space="preserve">
          <source>Joel says that it's because of pointer arithmetic but I still don't understand. &lt;strong&gt;Why does &lt;code&gt;a[5] == 5[a]&lt;/code&gt;&lt;/strong&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;乔尔（Joel）说，这是因为指针运算，但是我还是不明白。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a]&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a81097ac61f7a18c6ec85fdfc61133c0cc29d155" translate="yes" xml:space="preserve">
          <source>Just want to point out that C pointers and arrays are not the &lt;em&gt;same&lt;/em&gt;, although in this case the difference is not essential.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是想指出C指针和数组是不&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一样的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，尽管在这种情况下区别不是必须的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d2441f535495ef02a1cb465c8735af28bd5b07e" translate="yes" xml:space="preserve">
          <source>Nice question/answers.</source>
          <target state="translated">问得好,答得好。</target>
        </trans-unit>
        <trans-unit id="98bc25e30b7642e738cfd78e993ae40eb02b133f" translate="yes" xml:space="preserve">
          <source>Not an answer, but just some food for thought.
If class is having overloaded index/subscript operator, the expression &lt;code&gt;0[x]&lt;/code&gt; will not work:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是答案，而是一些值得深思的地方。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果类具有重载的索引/下标运算符，则表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0[x]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将不起作用：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e132b0de5ac062a9a7fde0931c25b8dc3c7098ef" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;!&lt;/code&gt; in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of &quot;pointer and integer&quot; was made necessary in C when it gained data types, and &lt;code&gt;sizeof&lt;/code&gt; became a thing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意&lt;/font&gt;&lt;/font&gt; &lt;code&gt;!&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这两种情况下，BCPL中的int既是一元前缀运算符，又是二进制中缀运算符，都是间接的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是二进制形式在执行间接操作之前将两个操作数相加。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑到BCPL（和B）的面向单词的性质，这实际上很有意义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当获取数据类型时，在C中必须使用&amp;ldquo;指针和整数&amp;rdquo;的限制，并且&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变成了问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4369357497b07857aa5f9f0d59e9912e60fc3c7d" translate="yes" xml:space="preserve">
          <source>Now, looking at this last
  expression, part of it.. &lt;code&gt;(a + i)&lt;/code&gt;, is a simple addition using the +
  operator and the rules of C state that such an expression is
  commutative. That is (a + i) is identical to &lt;code&gt;(i + a)&lt;/code&gt;. Thus we could
  write &lt;code&gt;*(i + a)&lt;/code&gt; just as easily as &lt;code&gt;*(a + i)&lt;/code&gt;.
  But &lt;code&gt;*(i + a)&lt;/code&gt; could have come from &lt;code&gt;i[a]&lt;/code&gt; ! From all of this comes the curious
  truth that if:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，看最后一个表达式，它的一部分.. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是使用+运算符和C规则的简单加法，表示该表达式是可交换的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即（a + i）与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我们可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;像&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;一样容易地&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能来自&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有这些都产生了一个奇怪的事实，即：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a0101aaccd31e7c1a382541872ca61e4d2855c1" translate="yes" xml:space="preserve">
          <source>Of course, I'm quite sure that there is no use case for that in real code, but I found it interesting anyway :)</source>
          <target state="translated">当然,我很肯定在实际的代码中没有这样的用例,但我觉得这很有趣:)</target>
        </trans-unit>
        <trans-unit id="87f7ff2ab3e38a0526469ba301a1a7213140a45e" translate="yes" xml:space="preserve">
          <source>One thing no-one seems to have mentioned about Dinah's problem with &lt;code&gt;sizeof&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于Dinah的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题，似乎没有人提到过一件事&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9699ca5988bf85c5aecce06a126016e9f4290eb8" translate="yes" xml:space="preserve">
          <source>Pointer is a &quot;variable&quot;</source>
          <target state="translated">指针是一个 &quot;变量&quot;</target>
        </trans-unit>
        <trans-unit id="cdd18b5479c5c8d9be0aa2854dc3d5207b558735" translate="yes" xml:space="preserve">
          <source>Similarly when the c code is broken down into 3-address code, 
&lt;code&gt;5[a]&lt;/code&gt; will become -&amp;gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，当c代码分解为3地址代码时， &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将变为-&amp;gt;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab8965c2689cf4af80819e57f31c38b5a532dfaa" translate="yes" xml:space="preserve">
          <source>Since we dont have access to &lt;strong&gt;int&lt;/strong&gt; class, this cannot be done:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于我们无权访问&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;int&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类，因此无法完成此操作：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d2f3a2be090331c6ed0efe4d14445e2a9ccaa11" translate="yes" xml:space="preserve">
          <source>So basically both the statements are pointing to the same location in memory and hence, &lt;code&gt;a[5] = 5[a]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，基本上两个语句都指向内存中的同一位置，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] = 5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74bd9aec219e8a876efe5e9dbf297450688134e3" translate="yes" xml:space="preserve">
          <source>So now we have &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; meaning exactly the same thing, though the latter form should never appear outside the &lt;a href=&quot;http://ioccc.org/&quot;&gt;IOCCC&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以现在我们有了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;arr[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;3[arr]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意思是完全一样的，尽管后者的形式永远不会出现在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ioccc.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IOCCC&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之外&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d87c687af6a603b7fae4247fa48fbea9ae67405" translate="yes" xml:space="preserve">
          <source>So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C's ancestor languages.</source>
          <target state="translated">所以,数组索引是用加法来定义的,而且加法,甚至是指针和整数的加法,都是互换的,这个想法可以追溯到几十年前,也就是C语言的祖先语言。</target>
        </trans-unit>
        <trans-unit id="a7dcde299d04157c827d07e041baf08423be13a0" translate="yes" xml:space="preserve">
          <source>So why is it this way?</source>
          <target state="translated">那么,为什么会这样呢?</target>
        </trans-unit>
        <trans-unit id="e4519a10d3120a45f508a759d4090cbf678cee1a" translate="yes" xml:space="preserve">
          <source>So,</source>
          <target state="translated">So,</target>
        </trans-unit>
        <trans-unit id="8c89c7d498821658553bd1ecb86d67fddaaa6e8d" translate="yes" xml:space="preserve">
          <source>Ted Jensen explained it as:</source>
          <target state="translated">Ted Jensen解释为:</target>
        </trans-unit>
        <trans-unit id="a0c02ea0bf226b00f8c97f9fbbcbfce6f19bd500" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;major difference&lt;/strong&gt; I found is...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我发现&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;主要区别&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddf31a3e26ab563612c3b60a159dbc37fda16b6f" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;[]&lt;/code&gt; operator as follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C标准将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符定义如下：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49e0ab5351629c999ecc0c6e397b25834b232a2e" translate="yes" xml:space="preserve">
          <source>The C standard's description of the &lt;code&gt;+&lt;/code&gt; operator (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;N1570&lt;/a&gt; 6.5.6) says:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C标准中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N1570&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 6.5.6）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的描述为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2007e88e85408e8f29febd9ef03d45f9952ac7ed" translate="yes" xml:space="preserve">
          <source>The compiler interprets &lt;code&gt;a[i]&lt;/code&gt; as &lt;code&gt;*(a+i)&lt;/code&gt; and the expression &lt;code&gt;5[a]&lt;/code&gt; evaluates to &lt;code&gt;*(5+a)&lt;/code&gt;. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器解释&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a+i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的计算结果为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(5+a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于加法是可交换的，因此证明两者相等。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，表达式的计算结果为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;true&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e003dbac549e08b0dd4688d334bec18afaeeeaeb" translate="yes" xml:space="preserve">
          <source>The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.</source>
          <target state="translated">后来才出现了一个创新,即省去了额外的存储字,让编译器在命名时插入数组的基地址。根据C语言历史论文,这大约发生在C语言中加入结构的时候。</target>
        </trans-unit>
        <trans-unit id="e1d793f269a6c0a67206e321358c9256e4f0fa74" translate="yes" xml:space="preserve">
          <source>The main reason for this was that back in the 70's when C was designed, computers didn't have much memory (64KB was a lot), so the C compiler didn't do much syntax checking.  Hence &quot;&lt;code&gt;X[Y]&lt;/code&gt;&quot; was rather blindly translated into &quot;&lt;code&gt;*(X+Y)&lt;/code&gt;&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样做的主要原因是，在70年代设计C的时候，计算机没有太多的内存（64KB很大），因此C编译器没有进行太多的语法检查。因此，&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X[Y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;被盲目地翻译为&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(X+Y)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5598417c3877f380e96a22cde55fcdd9a8eba2a1" translate="yes" xml:space="preserve">
          <source>Therefore &lt;code&gt;a[5]&lt;/code&gt; will evaluate to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将评估为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e28410e5118fc1353afc84b39ff63a4c00217208" translate="yes" xml:space="preserve">
          <source>This also explains the &quot;&lt;code&gt;+=&lt;/code&gt;&quot; and &quot;&lt;code&gt;++&lt;/code&gt;&quot; syntaxes.  Everything in the form &quot;&lt;code&gt;A = B + C&lt;/code&gt;&quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn't bright enough to recognize it, so the developer had to (&lt;code&gt;A += C&lt;/code&gt;).   Similarly, if &lt;code&gt;C&lt;/code&gt; was &lt;code&gt;1&lt;/code&gt;, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn't recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这也解释了&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;和&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;语法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = B + C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;形式的所有内容都&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有相同的编译形式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果B与A是同一对象，则可以进行装配级优化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是编译器不够聪明，无法识别它，因此开发人员必须（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A += C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则可以使用不同的程序集级优化，并且由于编译器无法识别它，因此开发人员必须再次使其明确。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（最近，编译器会这样做，因此，如今这些语法在很大程度上是不必要的）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2957c7291e8dd3b7c1bafc7a958af2782509f1ac" translate="yes" xml:space="preserve">
          <source>This explanation is also the reason why negative indexes in arrays work in C.</source>
          <target state="translated">这个解释也是为什么数组中的负索引在C语言中可以工作的原因。</target>
        </trans-unit>
        <trans-unit id="8fc0a843bdfadc65145a35ad68cd5c63d07409c1" translate="yes" xml:space="preserve">
          <source>This is NOT saying that pointers and arrays
  are the same thing, they are not. We are only saying that to identify
  a given element of an array we have the choice of two syntaxes, one
  using array indexing and the other using pointer arithmetic, which
  yield identical results.</source>
          <target state="translated">这并不是说指针和数组是一回事,它们不是一回事。我们只是说,为了识别数组中的一个给定元素,我们可以选择两种语法,一种是使用数组索引,另一种是使用指针算术,它们的结果是一样的。</target>
        </trans-unit>
        <trans-unit id="a225f9d9ce3692ad1562eee23a824ea01f5447d4" translate="yes" xml:space="preserve">
          <source>Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the &lt;code&gt;unsigned&lt;/code&gt; keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn't have occurred to the designers of those languages. If a user wanted to add two &quot;things&quot;, whether those &quot;things&quot; are integers, pointers, or something else, it wasn't up to the language to prevent it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与现代C语言相比，这些语言的强类型要少得多。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特别是，指针和整数之间的区别通常被忽略。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（早期的C程序员有时在将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unsigned&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字添加到语言&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前将指针用作无符号的整数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）因此，由于操作数是不同类型的，所以这些语言的设计人员可能不会想到使加法运算不可交换。 。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果用户想添加两个&amp;ldquo;事物&amp;rdquo;，无论这些&amp;ldquo;事物&amp;rdquo;是整数，指针还是其他东西，都无法阻止该行为。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f65772585dbe5c3f9be396b2762536b24bd6101e" translate="yes" xml:space="preserve">
          <source>To answer the question literally. It is not always true that &lt;code&gt;x == x&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从字面上回答这个问题。&lt;/font&gt; &lt;code&gt;x == x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不总是正确的&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f115cf17db3cd235931483179db65280105e850" translate="yes" xml:space="preserve">
          <source>We can re-initialize the pointer by an address but not the same case with an array.</source>
          <target state="translated">我们可以用一个地址重新初始化指针,但是用数组就不一样了。</target>
        </trans-unit>
        <trans-unit id="8e6493efc14ecc048b709d17d6a46595f95919cb" translate="yes" xml:space="preserve">
          <source>Well, this is a feature that is only possible because of the language support.</source>
          <target state="translated">好吧,这个功能只有在语言的支持下才有可能实现。</target>
        </trans-unit>
        <trans-unit id="06ef8221698e1df9e0d60c9945a8ac3f43b1e272" translate="yes" xml:space="preserve">
          <source>When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: &lt;code&gt;x + y == y + x&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当两个操作数属于同一类型，或者甚至是提升为通用类型的不同数值类型时，可交换性就很有意义：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y == y + x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="016171cdc5bdaa54ed0b2e5083fab7678a06cdf1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;define an array&lt;/strong&gt; at a time one &lt;strong&gt;address is initialize&lt;/strong&gt; in that pointer</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您一次&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义一个数组&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，该指针中的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;地址将被初始化&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc4155f374b80bf76ee1bda0459d1bd13e1acb80" translate="yes" xml:space="preserve">
          <source>With arrays, why is it the case that a[5] == 5[a]</source>
          <target state="translated">对于数组,为什么会出现a[5]==5[a]的情况?</target>
        </trans-unit>
        <trans-unit id="8b25d23d68d162aaa08b9e9252d3485eb5bb4e54" translate="yes" xml:space="preserve">
          <source>Yes, &lt;code&gt;p[i]&lt;/code&gt; is by definition equivalent to &lt;code&gt;*(p+i)&lt;/code&gt;, which (because addition is commutative) is equivalent to &lt;code&gt;*(i+p)&lt;/code&gt;, which (again, by the definition of the &lt;code&gt;[]&lt;/code&gt; operator) is equivalent to &lt;code&gt;i[p]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是的，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据定义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等效于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(p+i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，（由于加法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是可交换的）等效于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i+p)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;*（i + p）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等效&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的定义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）等效到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[p]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0db1547a0d27f180923b634a6c385bb5d0d5200d" translate="yes" xml:space="preserve">
          <source>You can only add an integer to a pointer, you can't add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.</source>
          <target state="translated">只能在指针上加一个整数,不能把两个指针加在一起。这样,在向整数指针添加指针时,或者向指针添加整数时,编译器总是知道哪个位有一个需要考虑的大小。</target>
        </trans-unit>
        <trans-unit id="ce350d74843615e170e417c9b55ec5ae40abbf7e" translate="yes" xml:space="preserve">
          <source>[] - that operator can be replaceable with pointer * .</source>
          <target state="translated">[]-该操作符可以用指针*替换。</target>
        </trans-unit>
        <trans-unit id="6f2172deda32c22bb7ed326f855cd1e60b094d2c" translate="yes" xml:space="preserve">
          <source>a - containing address (people call it as base address) just like an (2) type of pointer in our list</source>
          <target state="translated">a-包含地址(人们称它为基地址),就像我们的列表中的(2)类指针一样</target>
        </trans-unit>
        <trans-unit id="97a88f2c750b6a9b26b40be8f3c5948f70a331d7" translate="yes" xml:space="preserve">
          <source>a[5] is nothing but *(a + 5)</source>
          <target state="translated">a[5]只是*(a+5)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="93091c2e64403052e4bd3ed3f36e43ef771c82a2" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;5[a]&lt;/code&gt; will evaluate to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将评估为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0329e14c13535bcb6359a9184aa3bb549bbac0a" translate="yes" xml:space="preserve">
          <source>and also</source>
          <target state="translated">而且</target>
        </trans-unit>
        <trans-unit id="7b87ed0f8f42e4beea17f77738a242956f749a4c" translate="yes" xml:space="preserve">
          <source>and back to your question...</source>
          <target state="translated">回到你的问题.....</target>
        </trans-unit>
        <trans-unit id="6e14a5162bf2176970b34c6a462fbb0f77fbdaba" translate="yes" xml:space="preserve">
          <source>and the arrays are type of (2) from our list</source>
          <target state="translated">和数组的类型为(2)的列表中的(2)</target>
        </trans-unit>
        <trans-unit id="77b73075908163972d844091f09a9b5bc0421fef" translate="yes" xml:space="preserve">
          <source>are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)</source>
          <target state="translated">是指数组中的元素的不同方式! (一点也不奇怪)</target>
        </trans-unit>
        <trans-unit id="02a97d497b5ebda3f799171a3381d322a9c53bce" translate="yes" xml:space="preserve">
          <source>array name is a &quot;mnemonic&quot; or &quot;synonym&quot;</source>
          <target state="translated">数组名称是一个 &quot;名词表 &quot;或 &quot;同义词&quot;</target>
        </trans-unit>
        <trans-unit id="e650b4bcfab638a85de907196e6b5cfdd86dd6ce" translate="yes" xml:space="preserve">
          <source>i.e. if I access &lt;code&gt;a[-5]&lt;/code&gt; it will give me</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即如果我访问&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[-5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它将给我&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="785229f56486c15d2737b6075a53f6cb6bbec742" translate="yes" xml:space="preserve">
          <source>in c compiler</source>
          <target state="translated">在C语言编译器中</target>
        </trans-unit>
        <trans-unit id="988337ebfe6581049f95ede5081b3071f64d533f" translate="yes" xml:space="preserve">
          <source>in which case both &lt;code&gt;i + p&lt;/code&gt; and &lt;code&gt;i[p]&lt;/code&gt; would be illegal.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i + p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[p]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都是非法的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c94c0e41bc274bd0e78c44d3277f3bef91ccf351" translate="yes" xml:space="preserve">
          <source>is the same as writing</source>
          <target state="translated">等于写</target>
        </trans-unit>
        <trans-unit id="3160b126bd0ef17f439072b3f5f9ec151c6a6c87" translate="yes" xml:space="preserve">
          <source>of which only the first is really necessary.</source>
          <target state="translated">其中只有第一种是真正必要的。</target>
        </trans-unit>
        <trans-unit id="b08aa496bf69321c55248a2a8c6e8a6b6565fcc5" translate="yes" xml:space="preserve">
          <source>pointer types</source>
          <target state="translated">指针类型</target>
        </trans-unit>
        <trans-unit id="b024f8c2bfa6dbc6442cb571d5d5d6243c0ca744" translate="yes" xml:space="preserve">
          <source>prints</source>
          <target state="translated">prints</target>
        </trans-unit>
        <trans-unit id="6049b2ff36f9c94c3a5f5916f9eae4ace9ddc50b" translate="yes" xml:space="preserve">
          <source>really did have to do &lt;code&gt;J = !(V + 5)&lt;/code&gt; (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus &lt;code&gt;V!5&lt;/code&gt; and &lt;code&gt;5!V&lt;/code&gt; were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确实确实必须做&lt;/font&gt;&lt;/font&gt; &lt;code&gt;J = !(V + 5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（使用BCPL语法），因为有必要获取V以获取数组的基地址。因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;V!5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;5!V&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是同义词。有趣的是，WAFL（Warwick函数语言）是用BCPL编写的，据我所知，它倾向于使用后一种语法而不是前一种语法来访问用作数据存储的节点。当然，这是在35到40年前之间的某个地方，所以我的记忆有些生锈。 :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2599991ed8fb7accd72a93b52acec6c9e1462926" translate="yes" xml:space="preserve">
          <source>so finally...</source>
          <target state="translated">所以终于.....</target>
        </trans-unit>
        <trans-unit id="45f0d72226f6c0a5c5c39929b28a3dfa425d4d83" translate="yes" xml:space="preserve">
          <source>that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as</source>
          <target state="translated">寄存器中,实际分配了11个字的内存,而不是10个字。通常情况下,V是第一个,并包含紧随其后的字的地址。因此,与C不同的是,命名V去到那个位置,并拿起了数组中的0eth元素的地址。因此在BCPL中的数组direction,表示为</target>
        </trans-unit>
        <trans-unit id="1935d7b6e1cdaa0cb2a12b33ef6db0f1f938bf83" translate="yes" xml:space="preserve">
          <source>writing</source>
          <target state="translated">writing</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
