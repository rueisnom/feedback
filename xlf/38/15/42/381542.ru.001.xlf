<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/381542">
    <body>
      <group id="381542">
        <trans-unit id="1c532b8e159d2f6be41bfbd2e6c1b3c3566c6f16" translate="yes" xml:space="preserve">
          <source>&quot;Pointer Arithmetic&quot; internally calculated as</source>
          <target state="translated">&quot;Арифметика указателей&quot;,вычисленная изнутри,как</target>
        </trans-unit>
        <trans-unit id="f90ed12168301e6151719fa19edb73514ba66ab9" translate="yes" xml:space="preserve">
          <source>(And in &lt;code&gt;array[i]&lt;/code&gt;, the array name is implicitly converted to a pointer to the array's first element.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(А в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;array[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имя массива неявно преобразуется в указатель на первый элемент массива.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="665d882bc5ec3ea11a78f3e1d6d3b2faede30961" translate="yes" xml:space="preserve">
          <source>1) pointer to data</source>
          <target state="translated">1)указатель на данные</target>
        </trans-unit>
        <trans-unit id="6d4a55de86e2c176f93d7c8e25e81b8961a89739" translate="yes" xml:space="preserve">
          <source>2) const pointer to data</source>
          <target state="translated">2)указатель на данные</target>
        </trans-unit>
        <trans-unit id="dc116f3e7b6cb13d1d9a8ee78be1aaf1c6bdb877" translate="yes" xml:space="preserve">
          <source>3) const pointer to const data</source>
          <target state="translated">3)указатель const на const-данные</target>
        </trans-unit>
        <trans-unit id="ecd8f0ab071dd440c98d22200e1ba9d53d322230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*(a+3)&lt;/code&gt; equals &lt;code&gt;*(3+a)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*(a+3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; равно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(3+a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28201ef096f2131ccdc6a35516a0644b4ea983ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; is a pointer to the first element of the array. &lt;code&gt;a[5]&lt;/code&gt; is the value that's 5 &lt;strong&gt;elements&lt;/strong&gt; further from &lt;code&gt;a&lt;/code&gt;, which is the same as &lt;code&gt;*(a + 5)&lt;/code&gt;, and from elementary school math we know those are equal (addition is &lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot;&gt;commutative&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - указатель на первый элемент массива. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это значение, которое находится на 5 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;элементов&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; дальше от &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что совпадает с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + 5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и из математики начальной школы мы знаем, что они равны (сложение &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;коммутативно&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="249153e7dded62e636d80b565dbc2016bd13473b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a[2]&lt;/code&gt; is equals to 2[a] because the internal operation on both of this is</source>
          <target state="translated">&lt;code&gt;a[2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; равно 2 [a], потому что внутренняя операция в обоих случаях&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7493043c20a2ee1a9aa0b07cb9d465f952679903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p++;&lt;/code&gt; is valid but &lt;code&gt;a++&lt;/code&gt; is invalid</source>
          <target state="translated">&lt;code&gt;p++;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;допустимо, но &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; недействителен&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="985fb68b5b45504442a8d537a1489c21922d8f1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;you can understand easily by&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете легко понять,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a230fcbc7d44f33ab50dbec09842e1b4d1a49991" translate="yes" xml:space="preserve">
          <source>A little bit of history now.  Among other languages, BCPL had a fairly major influence on C's early development.  If you declared an array in BCPL with something like:</source>
          <target state="translated">Теперь немного истории.Среди других языков,BCPL оказал довольно большое влияние на раннее развитие C.Если Вы объявили массив в BCPL с чем-то вроде:</target>
        </trans-unit>
        <trans-unit id="9d3c6f48e3938b4bed030f7359a3407d1923ba45" translate="yes" xml:space="preserve">
          <source>And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).</source>
          <target state="translated">И с годами любое изменение этого правила нарушило бы существующий код (хотя,возможно,хорошей возможностью был бы стандарт ANSI C 1989 года).</target>
        </trans-unit>
        <trans-unit id="9c34c03a8950c95878da245890e59067c02e7660" translate="yes" xml:space="preserve">
          <source>And, of course</source>
          <target state="translated">И,конечно же.</target>
        </trans-unit>
        <trans-unit id="41762cb9625c061a27823eda935b612b05021406" translate="yes" xml:space="preserve">
          <source>As Joel points out in &lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;Stack Overflow podcast #34&lt;/a&gt;, in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot;&gt;C Programming Language&lt;/a&gt; (aka: K &amp;amp; R), there is mention of this property of arrays in C: &lt;code&gt;a[5] == 5[a]&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как указывает Джоэл в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;подкасте № 34 &amp;laquo;Переполнение стека&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;языке программирования C&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (он же K &amp;amp; R), в C упоминается это свойство массивов: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c95149555cd6976edeb71b3e72ed11b54a2b5b66" translate="yes" xml:space="preserve">
          <source>As we know that we can't change or modify const value in our program cause it's throws an &lt;strong&gt;ERROR&lt;/strong&gt; at compile time</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку мы знаем, что мы не можем изменить или изменить значение const в нашей программе, потому что она выдает &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ОШИБКУ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; во время компиляции&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90ab497a5e7b7464cce09bdb9f6aa2d857948dfb" translate="yes" xml:space="preserve">
          <source>Because array access is defined in terms of pointers.  &lt;code&gt;a[i]&lt;/code&gt; is defined to mean &lt;code&gt;*(a + i)&lt;/code&gt;, which is commutative.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Потому что доступ к массиву определяется в терминах указателей. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; определяется как означающее &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что является коммутативным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb668d53c34ceb6271676e0153f41c6ebe7f633f" translate="yes" xml:space="preserve">
          <source>But in this case we're talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)</source>
          <target state="translated">Но в данном случае речь идет именно об арифметике с указателями,где один операнд-это указатель,а другой-целое число.(Целое+целое число-это другая операция,а указатель+указатель-это чушь).</target>
        </trans-unit>
        <trans-unit id="aa1359c3969ec4c8fac3ce4354042aa785004056" translate="yes" xml:space="preserve">
          <source>But the commutativity of addition is not all that obvious in this case.</source>
          <target state="translated">Но коммутативность сложения в данном случае не столь очевидна.</target>
        </trans-unit>
        <trans-unit id="598b1c1d1625a55404599d1e3f3682223df0545c" translate="yes" xml:space="preserve">
          <source>C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;Users' Reference to B&lt;/a&gt;), which got it from &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;BCPL&lt;/a&gt; (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ унаследовал это определение от C, который получил его от B (коммутативность индексации массива явно упоминается в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Справочнике пользователей B&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; за 1972 г. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;), который получил его от &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BCPL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (руководство от 1967 г.), который вполне мог получить его даже от более ранние языки (CPL? Algol?).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="988dcbc4fe0ee658747db4c81dc1258d95b8c55c" translate="yes" xml:space="preserve">
          <source>Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.</source>
          <target state="translated">Изменение C andor C++на требование ставить указатель слева и целое число справа может нарушить некоторый существующий код,но при этом не приведет к потере реальной выразительной силы.</target>
        </trans-unit>
        <trans-unit id="8a6489d5b2c67a7d3726a70e1268159af4a397d9" translate="yes" xml:space="preserve">
          <source>Consider the following declarations:</source>
          <target state="translated">Рассмотрим следующие заявления:</target>
        </trans-unit>
        <trans-unit id="b652adbdb6a3ed93ed3cfa571249369d1118cb26" translate="yes" xml:space="preserve">
          <source>For addition, either both operands shall have arithmetic type, or &lt;em&gt;the left&lt;/em&gt;
  operand shall be a pointer to a complete object type and the &lt;em&gt;right operand&lt;/em&gt;
  shall have integer type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, либо оба операнда должны иметь арифметический тип, либо &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;левый&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; операнд должен быть указателем на полный тип объекта, а &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;правый операнд&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должен иметь целочисленный тип.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d18d0f48b4c944be08073c1f32334fbe7cd130e" translate="yes" xml:space="preserve">
          <source>For addition, either both operands shall have arithmetic type, or one
  operand shall be a pointer to a complete object type and the other
  shall have integer type.</source>
          <target state="translated">Кроме того,либо оба операнда должны иметь арифметический тип,либо один операнд должен быть указателем на полный тип объекта,а другой-целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="1403d7ce86f32bda0cd4edd41a6686136925e844" translate="yes" xml:space="preserve">
          <source>For pointers in C, we have</source>
          <target state="translated">Для указателей в C,у нас есть</target>
        </trans-unit>
        <trans-unit id="66d14b89e8fc22a7ab29c295425b86d1e3b0db09" translate="yes" xml:space="preserve">
          <source>Hence it is true that &lt;code&gt;a[5] == 5[a].&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Следовательно, верно, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a].&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e750355f8cd7e882204c80ce48acc16a8fd88644" translate="yes" xml:space="preserve">
          <source>How &lt;code&gt;a[5]&lt;/code&gt; will work -&amp;gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет работать -&amp;gt;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f55bdf5fd546d350e0f04bb758dbb91c556fc521" translate="yes" xml:space="preserve">
          <source>I just find out this ugly syntax could be &quot;useful&quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !</source>
          <target state="translated">Я только что узнал,что этот уродливый синтаксис может быть &quot;полезным&quot;,или,по крайней мере,очень забавным для игры,когда вы хотите иметь дело с массивом индексов,которые ссылаются на позиции в том же массиве.Он может заменить вложенные квадратные скобки и сделать код более читабельным!</target>
        </trans-unit>
        <trans-unit id="6523196f463ce8a226b083dadade80781f11a991" translate="yes" xml:space="preserve">
          <source>I know the question is answered, but I couldn't resist sharing this explanation.</source>
          <target state="translated">Я знаю,что на вопрос есть ответ,но я не мог устоять перед тем,чтобы поделиться этим объяснением.</target>
        </trans-unit>
        <trans-unit id="879d6f03dde6396f4c6ef6e1366e84d24245382a" translate="yes" xml:space="preserve">
          <source>I remember Principles of Compiler design,
Let's assume &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; array and size of &lt;code&gt;int&lt;/code&gt; is 2 bytes,
&amp;amp; Base address for &lt;code&gt;a&lt;/code&gt; is 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я помню принципы разработки компилятора. Предположим, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;массивом &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а размер &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; равен 2 байта, а базовый адрес для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; равен 1000.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4312bd7f2106bff89c992709b29c9074f9f2d5c3" translate="yes" xml:space="preserve">
          <source>I think something is being missed by the other answers.</source>
          <target state="translated">Я думаю,что-то пропущено другими ответами.</target>
        </trans-unit>
        <trans-unit id="0120639388c9d9eb979dfcb56da488ae93a32e77" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://cs-fundamentals.com/c-programming/arrays-in-c.php&quot;&gt;C arrays&lt;/a&gt;, &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; are the same, and their equivalent pointer notations are &lt;code&gt;*(arr + 3)&lt;/code&gt; to &lt;code&gt;*(3 + arr)&lt;/code&gt;. But on the contrary &lt;code&gt;[arr]3&lt;/code&gt; or &lt;code&gt;[3]arr&lt;/code&gt; is not correct and will result into syntax error, as &lt;code&gt;(arr + 3)*&lt;/code&gt; and &lt;code&gt;(3 + arr)*&lt;/code&gt; are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://cs-fundamentals.com/c-programming/arrays-in-c.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;массивах C&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;arr[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;3[arr]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; являются одинаковыми, и их эквивалентные обозначения являются указатель &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(arr + 3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(3 + arr)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Но, наоборот, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[arr]3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[3]arr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не является правильным и приведет к синтаксической ошибке, так как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(arr + 3)*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(3 + arr)*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не являются допустимыми выражениями. Причина в том, что оператор разыменования должен быть помещен перед адресом, полученным выражением, а не после адреса.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="750606dee7fb039c0840d301abcb6a2a434c1b8c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;a.out&lt;/em&gt;, the symbol &lt;em&gt;a&lt;/em&gt; is at an address that's the beginning of the array, and symbol &lt;em&gt;p&lt;/em&gt; is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a.out&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; символ &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; находится по адресу, который является началом массива, а символ &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;p&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; находится по адресу, где хранится указатель, а значение указателя в этом месте памяти является началом массива.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edb025b4d216cf36fb49869edda6fd6ce53178c2" translate="yes" xml:space="preserve">
          <source>In C</source>
          <target state="translated">в графстве С</target>
        </trans-unit>
        <trans-unit id="0dfdd853ce75c25295e1a1a4ed0060949c855ba6" translate="yes" xml:space="preserve">
          <source>In C++ terms, we really have two sets of overloaded &lt;code&gt;+&lt;/code&gt; operators, which can be loosely described as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В терминах C ++ у нас действительно есть два набора перегруженных &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; операторов, которые можно условно описать так:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="078794ea29568f11e34617aa8c23cdbdff085dea" translate="yes" xml:space="preserve">
          <source>In fact, this is true, i.e wherever one writes &lt;code&gt;a[i]&lt;/code&gt; it can be
  replaced with &lt;code&gt;*(a + i)&lt;/code&gt;  without any problems. In fact, the compiler
  will create the same code in either case. Thus we see that pointer
  arithmetic is the same thing as array indexing. Either syntax produces
  the same result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На самом деле это действительно так, то есть, где бы вы ни записали &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; его можно &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; без проблем &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;заменить на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Фактически, компилятор создаст один и тот же код в любом случае. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, мы видим, что арифметика указателей - это то же самое, что индексирование массива. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Любой синтаксис дает одинаковый результат.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae47d23442a5f0fc06581a19aa48fcb525bb51fa" translate="yes" xml:space="preserve">
          <source>It could just as easily have said:</source>
          <target state="translated">Могло бы так же легко сказать:</target>
        </trans-unit>
        <trans-unit id="434d5309f6fb971f10b66d6ec360b256083e8cb2" translate="yes" xml:space="preserve">
          <source>It has very good explanation in &lt;em&gt;A TUTORIAL ON POINTERS AND ARRAYS IN C&lt;/em&gt;
by Ted Jensen.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У него есть очень хорошее объяснение в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Учебнике по указателям и массивам в Си&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; Теда Дженсена.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2c902ce692b4aec32e849e37c03678874983500" translate="yes" xml:space="preserve">
          <source>It will return me object at location 990.</source>
          <target state="translated">Он вернет мне объект на месте 990.</target>
        </trans-unit>
        <trans-unit id="a2e53b6a9b29ea8bc57610fcef4acc120a1007a6" translate="yes" xml:space="preserve">
          <source>Joel says that it's because of pointer arithmetic but I still don't understand. &lt;strong&gt;Why does &lt;code&gt;a[5] == 5[a]&lt;/code&gt;&lt;/strong&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Джоэл говорит, что это из-за арифметики указателей, но я все еще не понимаю. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Почему &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a]&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a81097ac61f7a18c6ec85fdfc61133c0cc29d155" translate="yes" xml:space="preserve">
          <source>Just want to point out that C pointers and arrays are not the &lt;em&gt;same&lt;/em&gt;, although in this case the difference is not essential.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сразу хочу отметить, что указатели и массивы C не &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;совпадают&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , хотя в этом случае разница несущественна.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d2441f535495ef02a1cb465c8735af28bd5b07e" translate="yes" xml:space="preserve">
          <source>Nice question/answers.</source>
          <target state="translated">Хорошие вопросительные.</target>
        </trans-unit>
        <trans-unit id="98bc25e30b7642e738cfd78e993ae40eb02b133f" translate="yes" xml:space="preserve">
          <source>Not an answer, but just some food for thought.
If class is having overloaded index/subscript operator, the expression &lt;code&gt;0[x]&lt;/code&gt; will not work:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не ответ, а просто пища для размышлений. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если класс перегружен оператором индекса / индекса, выражение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0[x]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не будет работать:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e132b0de5ac062a9a7fde0931c25b8dc3c7098ef" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;!&lt;/code&gt; in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of &quot;pointer and integer&quot; was made necessary in C when it gained data types, and &lt;code&gt;sizeof&lt;/code&gt; became a thing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;!&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в BCPL был и унарный префиксный оператор, и двоичный инфиксный оператор, причем в обоих случаях выполнялось косвенное обращение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;просто двоичная форма включала добавление двух операндов перед выполнением косвенного обращения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Учитывая словоориентированную природу BCPL (и B), это действительно имело большой смысл. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ограничение &amp;laquo;указатель и целое число&amp;raquo; было сделано необходимым в C, когда он получил типы данных, и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; стал чем-то особенным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4369357497b07857aa5f9f0d59e9912e60fc3c7d" translate="yes" xml:space="preserve">
          <source>Now, looking at this last
  expression, part of it.. &lt;code&gt;(a + i)&lt;/code&gt;, is a simple addition using the +
  operator and the rules of C state that such an expression is
  commutative. That is (a + i) is identical to &lt;code&gt;(i + a)&lt;/code&gt;. Thus we could
  write &lt;code&gt;*(i + a)&lt;/code&gt; just as easily as &lt;code&gt;*(a + i)&lt;/code&gt;.
  But &lt;code&gt;*(i + a)&lt;/code&gt; could have come from &lt;code&gt;i[a]&lt;/code&gt; ! From all of this comes the curious
  truth that if:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь, глядя на это последнее выражение, его часть .. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , это простое дополнение, использующее оператор + и правила C утверждают, что такое выражение коммутативно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То есть (a + i) идентично &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, мы могли бы написать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; так же легко, как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; мог прийти от &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Из всего этого вытекает любопытная правда, что если:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a0101aaccd31e7c1a382541872ca61e4d2855c1" translate="yes" xml:space="preserve">
          <source>Of course, I'm quite sure that there is no use case for that in real code, but I found it interesting anyway :)</source>
          <target state="translated">Конечно,я уверен,что в реальном коде для этого нет смысла,но все равно мне это показалось интересным :)</target>
        </trans-unit>
        <trans-unit id="87f7ff2ab3e38a0526469ba301a1a7213140a45e" translate="yes" xml:space="preserve">
          <source>One thing no-one seems to have mentioned about Dinah's problem with &lt;code&gt;sizeof&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кажется, никто не упомянул о проблеме Дины с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9699ca5988bf85c5aecce06a126016e9f4290eb8" translate="yes" xml:space="preserve">
          <source>Pointer is a &quot;variable&quot;</source>
          <target state="translated">Указатель-это &quot;переменная&quot;</target>
        </trans-unit>
        <trans-unit id="cdd18b5479c5c8d9be0aa2854dc3d5207b558735" translate="yes" xml:space="preserve">
          <source>Similarly when the c code is broken down into 3-address code, 
&lt;code&gt;5[a]&lt;/code&gt; will become -&amp;gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Точно так же, когда код c разбит на 3-адресный код, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; станет -&amp;gt;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab8965c2689cf4af80819e57f31c38b5a532dfaa" translate="yes" xml:space="preserve">
          <source>Since we dont have access to &lt;strong&gt;int&lt;/strong&gt; class, this cannot be done:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку у нас нет доступа к &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;классу &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;int&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , это невозможно сделать:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d2f3a2be090331c6ed0efe4d14445e2a9ccaa11" translate="yes" xml:space="preserve">
          <source>So basically both the statements are pointing to the same location in memory and hence, &lt;code&gt;a[5] = 5[a]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, в основном оба оператора указывают на одно и то же место в памяти и, следовательно, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] = 5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74bd9aec219e8a876efe5e9dbf297450688134e3" translate="yes" xml:space="preserve">
          <source>So now we have &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; meaning exactly the same thing, though the latter form should never appear outside the &lt;a href=&quot;http://ioccc.org/&quot;&gt;IOCCC&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, теперь у нас есть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;arr[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;3[arr]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означающие одно и то же, хотя последняя форма никогда не должна появляться за пределами &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ioccc.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IOCCC&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d87c687af6a603b7fae4247fa48fbea9ae67405" translate="yes" xml:space="preserve">
          <source>So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C's ancestor languages.</source>
          <target state="translated">Так что идея о том,что индексация массивов определяется с точки зрения сложения,и что сложение,даже указателя и целого числа,является коммутативным,уходит корнями во многие десятилетия,к языкам-предкам Си.</target>
        </trans-unit>
        <trans-unit id="a7dcde299d04157c827d07e041baf08423be13a0" translate="yes" xml:space="preserve">
          <source>So why is it this way?</source>
          <target state="translated">Так почему же так?</target>
        </trans-unit>
        <trans-unit id="e4519a10d3120a45f508a759d4090cbf678cee1a" translate="yes" xml:space="preserve">
          <source>So,</source>
          <target state="translated">So,</target>
        </trans-unit>
        <trans-unit id="8c89c7d498821658553bd1ecb86d67fddaaa6e8d" translate="yes" xml:space="preserve">
          <source>Ted Jensen explained it as:</source>
          <target state="translated">Тед Дженсен объяснил это так:</target>
        </trans-unit>
        <trans-unit id="a0c02ea0bf226b00f8c97f9fbbcbfce6f19bd500" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;major difference&lt;/strong&gt; I found is...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Основное &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;различие, которое&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; я нашел ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddf31a3e26ab563612c3b60a159dbc37fda16b6f" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;[]&lt;/code&gt; operator as follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Стандарт C определяет &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператор &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; следующим образом:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49e0ab5351629c999ecc0c6e397b25834b232a2e" translate="yes" xml:space="preserve">
          <source>The C standard's description of the &lt;code&gt;+&lt;/code&gt; operator (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;N1570&lt;/a&gt; 6.5.6) says:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Описание &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператора &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+&lt;/code&gt; в&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; стандарте C &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N1570&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 6.5.6) гласит:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2007e88e85408e8f29febd9ef03d45f9952ac7ed" translate="yes" xml:space="preserve">
          <source>The compiler interprets &lt;code&gt;a[i]&lt;/code&gt; as &lt;code&gt;*(a+i)&lt;/code&gt; and the expression &lt;code&gt;5[a]&lt;/code&gt; evaluates to &lt;code&gt;*(5+a)&lt;/code&gt;. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Компилятор интерпретирует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a+i)&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а выражение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; оценивается как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(5+a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку сложение коммутативно, оказывается, что оба равны. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Следовательно, выражение оценивается как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;true&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e003dbac549e08b0dd4688d334bec18afaeeeaeb" translate="yes" xml:space="preserve">
          <source>The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.</source>
          <target state="translated">Новшество-отказ от лишнего слова хранения и вставка компилятором базового адреса массива при его названии-появилось позже.Согласно исторической статье на Си,это произошло примерно в то время,когда структуры были добавлены в Си.</target>
        </trans-unit>
        <trans-unit id="e1d793f269a6c0a67206e321358c9256e4f0fa74" translate="yes" xml:space="preserve">
          <source>The main reason for this was that back in the 70's when C was designed, computers didn't have much memory (64KB was a lot), so the C compiler didn't do much syntax checking.  Hence &quot;&lt;code&gt;X[Y]&lt;/code&gt;&quot; was rather blindly translated into &quot;&lt;code&gt;*(X+Y)&lt;/code&gt;&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Основная причина этого состояла в том, что еще в 70-х годах, когда проектировался C, на компьютерах не было много памяти (64 КБ было много), поэтому компилятор C не делал много проверки синтаксиса. Следовательно, &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X[Y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; было довольно слепо переведено на &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(X+Y)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5598417c3877f380e96a22cde55fcdd9a8eba2a1" translate="yes" xml:space="preserve">
          <source>Therefore &lt;code&gt;a[5]&lt;/code&gt; will evaluate to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет оценивать:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e28410e5118fc1353afc84b39ff63a4c00217208" translate="yes" xml:space="preserve">
          <source>This also explains the &quot;&lt;code&gt;+=&lt;/code&gt;&quot; and &quot;&lt;code&gt;++&lt;/code&gt;&quot; syntaxes.  Everything in the form &quot;&lt;code&gt;A = B + C&lt;/code&gt;&quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn't bright enough to recognize it, so the developer had to (&lt;code&gt;A += C&lt;/code&gt;).   Similarly, if &lt;code&gt;C&lt;/code&gt; was &lt;code&gt;1&lt;/code&gt;, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn't recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это также объясняет &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синтаксис &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; и &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все в форме &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = B + C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; имело ту же скомпилированную форму. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но если B был тем же объектом, что и A, тогда была доступна оптимизация на уровне сборки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но компилятор не был достаточно умным, чтобы распознать его, поэтому разработчик должен был ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A += C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Точно так же, если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; был &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , была доступна другая оптимизация на уровне сборки, и разработчик снова должен был сделать это явным, потому что компилятор не распознал ее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(В последнее время это делают компиляторы, поэтому эти синтаксисы в настоящее время в основном не нужны)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2957c7291e8dd3b7c1bafc7a958af2782509f1ac" translate="yes" xml:space="preserve">
          <source>This explanation is also the reason why negative indexes in arrays work in C.</source>
          <target state="translated">Это объяснение также является причиной того,что отрицательные индексы в массивах работают в C.</target>
        </trans-unit>
        <trans-unit id="8fc0a843bdfadc65145a35ad68cd5c63d07409c1" translate="yes" xml:space="preserve">
          <source>This is NOT saying that pointers and arrays
  are the same thing, they are not. We are only saying that to identify
  a given element of an array we have the choice of two syntaxes, one
  using array indexing and the other using pointer arithmetic, which
  yield identical results.</source>
          <target state="translated">Это не значит,что указатели и массивы-это одно и то же,это не так.Мы лишь говорим,что для идентификации данного элемента массива у нас есть выбор из двух синтаксисов,один из которых использует индексацию массивов,а другой-арифметику с указателями,которые дают одинаковые результаты.</target>
        </trans-unit>
        <trans-unit id="a225f9d9ce3692ad1562eee23a824ea01f5447d4" translate="yes" xml:space="preserve">
          <source>Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the &lt;code&gt;unsigned&lt;/code&gt; keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn't have occurred to the designers of those languages. If a user wanted to add two &quot;things&quot;, whether those &quot;things&quot; are integers, pointers, or something else, it wasn't up to the language to prevent it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эти языки были гораздо менее типизированы, чем современные языки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В частности, различие между указателями и целыми числами часто игнорировалось. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Ранние программисты на C иногда использовали указатели как целые числа без знака до того, как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unsigned&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; слово &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;unsigned&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; было добавлено к языку.) Поэтому идея сделать добавление некоммутативной, поскольку операнды имеют разные типы, вероятно, не возникла бы у разработчиков этих языков. , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если пользователь хотел добавить две &amp;laquo;вещи&amp;raquo;, будь то эти &amp;laquo;вещи&amp;raquo;, являются целыми числами, указателями или чем-то еще, язык не мог предотвратить это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f65772585dbe5c3f9be396b2762536b24bd6101e" translate="yes" xml:space="preserve">
          <source>To answer the question literally. It is not always true that &lt;code&gt;x == x&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответить на вопрос буквально. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не всегда верно, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x == x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f115cf17db3cd235931483179db65280105e850" translate="yes" xml:space="preserve">
          <source>We can re-initialize the pointer by an address but not the same case with an array.</source>
          <target state="translated">Мы можем повторно инициализировать указатель по адресу,но не в том же случае с массивом.</target>
        </trans-unit>
        <trans-unit id="8e6493efc14ecc048b709d17d6a46595f95919cb" translate="yes" xml:space="preserve">
          <source>Well, this is a feature that is only possible because of the language support.</source>
          <target state="translated">Ну,это функция,которая возможна только благодаря языковой поддержке.</target>
        </trans-unit>
        <trans-unit id="06ef8221698e1df9e0d60c9945a8ac3f43b1e272" translate="yes" xml:space="preserve">
          <source>When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: &lt;code&gt;x + y == y + x&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда оба операнда имеют одинаковый тип или даже разные числовые типы, которые переводятся в общий тип, коммутативность имеет смысл: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y == y + x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="016171cdc5bdaa54ed0b2e5083fab7678a06cdf1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;define an array&lt;/strong&gt; at a time one &lt;strong&gt;address is initialize&lt;/strong&gt; in that pointer</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вы &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;определяете массив&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; одновременно, один &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;адрес инициализируется&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в этом указателе&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc4155f374b80bf76ee1bda0459d1bd13e1acb80" translate="yes" xml:space="preserve">
          <source>With arrays, why is it the case that a[5] == 5[a]</source>
          <target state="translated">С массивами,почему a[5]==5[a]</target>
        </trans-unit>
        <trans-unit id="8b25d23d68d162aaa08b9e9252d3485eb5bb4e54" translate="yes" xml:space="preserve">
          <source>Yes, &lt;code&gt;p[i]&lt;/code&gt; is by definition equivalent to &lt;code&gt;*(p+i)&lt;/code&gt;, which (because addition is commutative) is equivalent to &lt;code&gt;*(i+p)&lt;/code&gt;, which (again, by the definition of the &lt;code&gt;[]&lt;/code&gt; operator) is equivalent to &lt;code&gt;i[p]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Да, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;p[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по определению эквивалентно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(p+i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что (поскольку сложение коммутативно) эквивалентно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i+p)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что (опять же, по определению &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператора &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) эквивалентно к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[p]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0db1547a0d27f180923b634a6c385bb5d0d5200d" translate="yes" xml:space="preserve">
          <source>You can only add an integer to a pointer, you can't add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.</source>
          <target state="translated">К указателю можно добавлять только целое число,нельзя добавлять два указателя вместе.Таким образом,добавляя указатель к целому числу или целое число к указателю,компилятор всегда знает,какой бит имеет размер,который необходимо учитывать.</target>
        </trans-unit>
        <trans-unit id="ce350d74843615e170e417c9b55ec5ae40abbf7e" translate="yes" xml:space="preserve">
          <source>[] - that operator can be replaceable with pointer * .</source>
          <target state="translated">[]-этот оператор может быть заменен указателем*.</target>
        </trans-unit>
        <trans-unit id="6f2172deda32c22bb7ed326f855cd1e60b094d2c" translate="yes" xml:space="preserve">
          <source>a - containing address (people call it as base address) just like an (2) type of pointer in our list</source>
          <target state="translated">a-содержащий адрес (люди называют его базовым адресом)точно так же,как (2)тип указателя в нашем списке</target>
        </trans-unit>
        <trans-unit id="97a88f2c750b6a9b26b40be8f3c5948f70a331d7" translate="yes" xml:space="preserve">
          <source>a[5] is nothing but *(a + 5)</source>
          <target state="translated">a[5]это не что иное,как *(a+5)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="93091c2e64403052e4bd3ed3f36e43ef771c82a2" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;5[a]&lt;/code&gt; will evaluate to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет оценивать:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0329e14c13535bcb6359a9184aa3bb549bbac0a" translate="yes" xml:space="preserve">
          <source>and also</source>
          <target state="translated">а также</target>
        </trans-unit>
        <trans-unit id="7b87ed0f8f42e4beea17f77738a242956f749a4c" translate="yes" xml:space="preserve">
          <source>and back to your question...</source>
          <target state="translated">и вернемся к твоему вопросу...</target>
        </trans-unit>
        <trans-unit id="6e14a5162bf2176970b34c6a462fbb0f77fbdaba" translate="yes" xml:space="preserve">
          <source>and the arrays are type of (2) from our list</source>
          <target state="translated">а массивы-это тип (2)из нашего списка.</target>
        </trans-unit>
        <trans-unit id="77b73075908163972d844091f09a9b5bc0421fef" translate="yes" xml:space="preserve">
          <source>are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)</source>
          <target state="translated">это разные способы обращения к элементу в массиве ! (СОВСЕМ НЕ СТРАННО)</target>
        </trans-unit>
        <trans-unit id="02a97d497b5ebda3f799171a3381d322a9c53bce" translate="yes" xml:space="preserve">
          <source>array name is a &quot;mnemonic&quot; or &quot;synonym&quot;</source>
          <target state="translated">имя массива-&quot;мнемонический&quot; или &quot;синоним&quot;.</target>
        </trans-unit>
        <trans-unit id="e650b4bcfab638a85de907196e6b5cfdd86dd6ce" translate="yes" xml:space="preserve">
          <source>i.e. if I access &lt;code&gt;a[-5]&lt;/code&gt; it will give me</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то есть если я получу доступ &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[-5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это даст мне&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="785229f56486c15d2737b6075a53f6cb6bbec742" translate="yes" xml:space="preserve">
          <source>in c compiler</source>
          <target state="translated">в компиляторе c</target>
        </trans-unit>
        <trans-unit id="988337ebfe6581049f95ede5081b3071f64d533f" translate="yes" xml:space="preserve">
          <source>in which case both &lt;code&gt;i + p&lt;/code&gt; and &lt;code&gt;i[p]&lt;/code&gt; would be illegal.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в этом случае и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i + p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[p]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будут недопустимы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c94c0e41bc274bd0e78c44d3277f3bef91ccf351" translate="yes" xml:space="preserve">
          <source>is the same as writing</source>
          <target state="translated">это то же самое,что писать</target>
        </trans-unit>
        <trans-unit id="3160b126bd0ef17f439072b3f5f9ec151c6a6c87" translate="yes" xml:space="preserve">
          <source>of which only the first is really necessary.</source>
          <target state="translated">из которых только первый действительно необходим.</target>
        </trans-unit>
        <trans-unit id="b08aa496bf69321c55248a2a8c6e8a6b6565fcc5" translate="yes" xml:space="preserve">
          <source>pointer types</source>
          <target state="translated">виды указателей</target>
        </trans-unit>
        <trans-unit id="b024f8c2bfa6dbc6442cb571d5d5d6243c0ca744" translate="yes" xml:space="preserve">
          <source>prints</source>
          <target state="translated">prints</target>
        </trans-unit>
        <trans-unit id="6049b2ff36f9c94c3a5f5916f9eae4ace9ddc50b" translate="yes" xml:space="preserve">
          <source>really did have to do &lt;code&gt;J = !(V + 5)&lt;/code&gt; (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus &lt;code&gt;V!5&lt;/code&gt; and &lt;code&gt;5!V&lt;/code&gt; were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;действительно нужно было сделать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;J = !(V + 5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (используя синтаксис BCPL), поскольку было необходимо выбрать V, чтобы получить базовый адрес массива. Таким образом, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;V!5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5!V&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; были синонимами. В качестве эпизодического наблюдения WAFL (функциональный язык Warwick) был написан на BCPL, и, насколько я помню, имел тенденцию использовать последний синтаксис, а не первый для доступа к узлам, используемым в качестве хранилища данных. Конечно, это где-то между 35 и 40 годами назад, так что моя память немного ржавая. :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2599991ed8fb7accd72a93b52acec6c9e1462926" translate="yes" xml:space="preserve">
          <source>so finally...</source>
          <target state="translated">так что,наконец-то...</target>
        </trans-unit>
        <trans-unit id="45f0d72226f6c0a5c5c39929b28a3dfa425d4d83" translate="yes" xml:space="preserve">
          <source>that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as</source>
          <target state="translated">которые на самом деле выделили 11 слов памяти,а не 10.Обычно V было первым,и содержало адрес непосредственно следующего слова.Так что в отличие от C,именование V шло к тому месту и подбиралось по адресу нулевого элемента массива.Следовательно,массив в BCPL был индирективным,выраженным как</target>
        </trans-unit>
        <trans-unit id="1935d7b6e1cdaa0cb2a12b33ef6db0f1f938bf83" translate="yes" xml:space="preserve">
          <source>writing</source>
          <target state="translated">writing</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
