<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/381542">
    <body>
      <group id="381542">
        <trans-unit id="1c532b8e159d2f6be41bfbd2e6c1b3c3566c6f16" translate="yes" xml:space="preserve">
          <source>&quot;Pointer Arithmetic&quot; internally calculated as</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부적으로 계산 된 &quot;포인터 산술&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f90ed12168301e6151719fa19edb73514ba66ab9" translate="yes" xml:space="preserve">
          <source>(And in &lt;code&gt;array[i]&lt;/code&gt;, the array name is implicitly converted to a pointer to the array's first element.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;array[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 배열 이름은 암시 적으로 배열의 첫 번째 요소에 대한 포인터로 변환됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="665d882bc5ec3ea11a78f3e1d6d3b2faede30961" translate="yes" xml:space="preserve">
          <source>1) pointer to data</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) 데이터에 대한 포인터&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d4a55de86e2c176f93d7c8e25e81b8961a89739" translate="yes" xml:space="preserve">
          <source>2) const pointer to data</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2) 데이터에 대한 const 포인터&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc116f3e7b6cb13d1d9a8ee78be1aaf1c6bdb877" translate="yes" xml:space="preserve">
          <source>3) const pointer to const data</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) const 데이터에 대한 const 포인터&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecd8f0ab071dd440c98d22200e1ba9d53d322230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*(a+3)&lt;/code&gt; equals &lt;code&gt;*(3+a)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*(a+3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt; &lt;code&gt;*(3+a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28201ef096f2131ccdc6a35516a0644b4ea983ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; is a pointer to the first element of the array. &lt;code&gt;a[5]&lt;/code&gt; is the value that's 5 &lt;strong&gt;elements&lt;/strong&gt; further from &lt;code&gt;a&lt;/code&gt;, which is the same as &lt;code&gt;*(a + 5)&lt;/code&gt;, and from elementary school math we know those are equal (addition is &lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot;&gt;commutative&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 배열의 첫 번째 요소에 대한 포인터입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt; &lt;code&gt;*(a + 5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 동일한 &lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 5 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요소를&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 더한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이며, 초등학교 수학에서 우리는 그것들이 같다는 것을 알고 있습니다 (더하기는 &lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;commutative&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="249153e7dded62e636d80b565dbc2016bd13473b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a[2]&lt;/code&gt; is equals to 2[a] because the internal operation on both of this is</source>
          <target state="translated">&lt;code&gt;a[2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 2 [a]와 같습니다. 둘 다의 내부 연산이&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7493043c20a2ee1a9aa0b07cb9d465f952679903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p++;&lt;/code&gt; is valid but &lt;code&gt;a++&lt;/code&gt; is invalid</source>
          <target state="translated">&lt;code&gt;p++;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유효하지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 유효하지 않습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="985fb68b5b45504442a8d537a1489c21922d8f1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;you can understand easily by&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 쉽게 이해할 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a230fcbc7d44f33ab50dbec09842e1b4d1a49991" translate="yes" xml:space="preserve">
          <source>A little bit of history now.  Among other languages, BCPL had a fairly major influence on C's early development.  If you declared an array in BCPL with something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 조금 역사가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 언어 중에서도 BCPL은 C의 초기 개발에 상당히 큰 영향을 미쳤습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BCPL에서 다음과 같이 배열을 선언 한 경우 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d3c6f48e3938b4bed030f7359a3407d1923ba45" translate="yes" xml:space="preserve">
          <source>And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 수년에 걸쳐이 규칙을 변경하면 기존 코드가 손상되었을 수 있습니다 (1989 ANSI C 표준이 좋은 기회 였을 수도 있음).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c34c03a8950c95878da245890e59067c02e7660" translate="yes" xml:space="preserve">
          <source>And, of course</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 물론&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41762cb9625c061a27823eda935b612b05021406" translate="yes" xml:space="preserve">
          <source>As Joel points out in &lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;Stack Overflow podcast #34&lt;/a&gt;, in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot;&gt;C Programming Language&lt;/a&gt; (aka: K &amp;amp; R), there is mention of this property of arrays in C: &lt;code&gt;a[5] == 5[a]&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joel &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 &lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 프로그래밍 언어&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (일명 : K &amp;amp; R)의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스택 오버플로 팟 캐스트 # 34&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 지적한 것처럼 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 배열 속성에 대한 언급이 있습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c95149555cd6976edeb71b3e72ed11b54a2b5b66" translate="yes" xml:space="preserve">
          <source>As we know that we can't change or modify const value in our program cause it's throws an &lt;strong&gt;ERROR&lt;/strong&gt; at compile time</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램에서 const 값을 변경하거나 수정할 수 없다는 것을 알고 있으므로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임에 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오류&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90ab497a5e7b7464cce09bdb9f6aa2d857948dfb" translate="yes" xml:space="preserve">
          <source>Because array access is defined in terms of pointers.  &lt;code&gt;a[i]&lt;/code&gt; is defined to mean &lt;code&gt;*(a + i)&lt;/code&gt;, which is commutative.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열 액세스는 포인터 측면에서 정의되기 때문입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 의미하도록 정의되며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 정식입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb668d53c34ceb6271676e0153f41c6ebe7f633f" translate="yes" xml:space="preserve">
          <source>But in this case we're talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나이 경우 포인터 연산에 대해 구체적으로 이야기하고 있습니다. 한 피연산자는 포인터이고 다른 피연산자는 정수입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(정수 + 정수는 다른 연산이며 포인터 + 포인터는 의미가 없습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa1359c3969ec4c8fac3ce4354042aa785004056" translate="yes" xml:space="preserve">
          <source>But the commutativity of addition is not all that obvious in this case.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 더하기의 commutativity가이 경우에 명백한 것은 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="598b1c1d1625a55404599d1e3f3682223df0545c" translate="yes" xml:space="preserve">
          <source>C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;Users' Reference to B&lt;/a&gt;), which got it from &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;BCPL&lt;/a&gt; (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++은 B (배열 인덱스의 교환 법칙이 명시 1972에서 설명한에서있어 C에서이 정의 유전 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B에 대한 사용자의 참조&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서있어) &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BCPL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 아니라 짝수로를 받고있다 (수동 일자 1967), 이전 언어 (CPL? Algol?).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="988dcbc4fe0ee658747db4c81dc1258d95b8c55c" translate="yes" xml:space="preserve">
          <source>Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터를 왼쪽에 놓고 정수를 오른쪽에 놓도록 C 및 / 또는 C ++를 변경하면 일부 기존 코드가 손상 될 수 있지만 실제 표현력이 손실되지는 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a6489d5b2c67a7d3726a70e1268159af4a397d9" translate="yes" xml:space="preserve">
          <source>Consider the following declarations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 선언을 고려하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b652adbdb6a3ed93ed3cfa571249369d1118cb26" translate="yes" xml:space="preserve">
          <source>For addition, either both operands shall have arithmetic type, or &lt;em&gt;the left&lt;/em&gt;
  operand shall be a pointer to a complete object type and the &lt;em&gt;right operand&lt;/em&gt;
  shall have integer type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 두 피연산자 모두 산술 유형을 갖거나 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왼쪽&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 피연산자는 완전한 객체 유형에 대한 포인터이고 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오른쪽 피연산자&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 정수 유형이어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d18d0f48b4c944be08073c1f32334fbe7cd130e" translate="yes" xml:space="preserve">
          <source>For addition, either both operands shall have arithmetic type, or one
  operand shall be a pointer to a complete object type and the other
  shall have integer type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 두 피연산자 모두 산술 유형을 갖거나 한 피연산자는 완전한 객체 유형에 대한 포인터이고 다른 피연산자는 정수 유형이어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1403d7ce86f32bda0cd4edd41a6686136925e844" translate="yes" xml:space="preserve">
          <source>For pointers in C, we have</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C의 포인터에 대해서는&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66d14b89e8fc22a7ab29c295425b86d1e3b0db09" translate="yes" xml:space="preserve">
          <source>Hence it is true that &lt;code&gt;a[5] == 5[a].&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt; &lt;code&gt;a[5] == 5[a].&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것이 사실입니다 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e750355f8cd7e882204c80ce48acc16a8fd88644" translate="yes" xml:space="preserve">
          <source>How &lt;code&gt;a[5]&lt;/code&gt; will work -&amp;gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떻게 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 작동합니다 -&amp;gt;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f55bdf5fd546d350e0f04bb758dbb91c556fc521" translate="yes" xml:space="preserve">
          <source>I just find out this ugly syntax could be &quot;useful&quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 추악한 구문이 &quot;유용&quot;하거나 같은 배열의 위치를 ​​참조하는 인덱스 배열을 다루고 싶을 때 아주 재미있을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중첩 된 대괄호를 대체하고 코드를 더 읽기 쉽게 만들 수 있습니다!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6523196f463ce8a226b083dadade80781f11a991" translate="yes" xml:space="preserve">
          <source>I know the question is answered, but I couldn't resist sharing this explanation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 그 질문에 대한 답을 알고 있지만이 설명을 공유하는 것을 거부 할 수 없었다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="879d6f03dde6396f4c6ef6e1366e84d24245382a" translate="yes" xml:space="preserve">
          <source>I remember Principles of Compiler design,
Let's assume &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; array and size of &lt;code&gt;int&lt;/code&gt; is 2 bytes,
&amp;amp; Base address for &lt;code&gt;a&lt;/code&gt; is 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 컴파일러 디자인의 원칙을 기억의 가정하자 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 배열의 크기 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 2 바이트,에 대한 자료 주소 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 1000이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4312bd7f2106bff89c992709b29c9074f9f2d5c3" translate="yes" xml:space="preserve">
          <source>I think something is being missed by the other answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 답변에서 무언가를 놓치고 있다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0120639388c9d9eb979dfcb56da488ae93a32e77" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://cs-fundamentals.com/c-programming/arrays-in-c.php&quot;&gt;C arrays&lt;/a&gt;, &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; are the same, and their equivalent pointer notations are &lt;code&gt;*(arr + 3)&lt;/code&gt; to &lt;code&gt;*(3 + arr)&lt;/code&gt;. But on the contrary &lt;code&gt;[arr]3&lt;/code&gt; or &lt;code&gt;[3]arr&lt;/code&gt; is not correct and will result into syntax error, as &lt;code&gt;(arr + 3)*&lt;/code&gt; and &lt;code&gt;(3 + arr)*&lt;/code&gt; are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://cs-fundamentals.com/c-programming/arrays-in-c.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 어레이&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;arr[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;3[arr]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 동일하고, 그 등가 포인터 표기법은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(arr + 3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 행 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(3 + arr)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 반대로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[arr]3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[3]arr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 정확하지 않으며 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(arr + 3)*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(3 + arr)*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 유효한 표현이 아니기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때문에 구문 오류가 발생 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유는 역 참조 연산자가 주소 이후가 아니라 표현식에 의해 생성 된 주소 앞에 배치되어야하기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="750606dee7fb039c0840d301abcb6a2a434c1b8c" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;a.out&lt;/em&gt;, the symbol &lt;em&gt;a&lt;/em&gt; is at an address that's the beginning of the array, and symbol &lt;em&gt;p&lt;/em&gt; is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 a.out&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 심볼 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a는&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 어레이의 시작의 어드레스로하고, 심볼 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;P는&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 포인터가 저장되는 주소이고, 그 메모리 위치에 대한 포인터의 값은 상기 어레이의 시작이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edb025b4d216cf36fb49869edda6fd6ce53178c2" translate="yes" xml:space="preserve">
          <source>In C</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C에서&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0dfdd853ce75c25295e1a1a4ed0060949c855ba6" translate="yes" xml:space="preserve">
          <source>In C++ terms, we really have two sets of overloaded &lt;code&gt;+&lt;/code&gt; operators, which can be loosely described as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 용어로, 우리는 두 개의 오버로드 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세트를 실제로 가지고 있으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, 다음과 같이 느슨하게 설명 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="078794ea29568f11e34617aa8c23cdbdff085dea" translate="yes" xml:space="preserve">
          <source>In fact, this is true, i.e wherever one writes &lt;code&gt;a[i]&lt;/code&gt; it can be
  replaced with &lt;code&gt;*(a + i)&lt;/code&gt;  without any problems. In fact, the compiler
  will create the same code in either case. Thus we see that pointer
  arithmetic is the same thing as array indexing. Either syntax produces
  the same result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사실 이것은 사실입니다. 즉, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 쓸 때마다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 아무 문제없이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 바꿀 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 컴파일러는 두 경우 모두 동일한 코드를 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 포인터 산술은 배열 인덱싱과 동일합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어느 구문이든 동일한 결과를 생성합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae47d23442a5f0fc06581a19aa48fcb525bb51fa" translate="yes" xml:space="preserve">
          <source>It could just as easily have said:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 쉽게 말할 수 있습니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="434d5309f6fb971f10b66d6ec360b256083e8cb2" translate="yes" xml:space="preserve">
          <source>It has very good explanation in &lt;em&gt;A TUTORIAL ON POINTERS AND ARRAYS IN C&lt;/em&gt;
by Ted Jensen.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 테드 젠슨 (Ted Jensen)의 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터와 배열&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대한 튜토리얼에&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 설명이 아주 훌륭 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2c902ce692b4aec32e849e37c03678874983500" translate="yes" xml:space="preserve">
          <source>It will return me object at location 990.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위치 990의 객체를 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2e53b6a9b29ea8bc57610fcef4acc120a1007a6" translate="yes" xml:space="preserve">
          <source>Joel says that it's because of pointer arithmetic but I still don't understand. &lt;strong&gt;Why does &lt;code&gt;a[5] == 5[a]&lt;/code&gt;&lt;/strong&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joel은 포인터 산술 때문이지만 여전히 이해하지 못한다고 말합니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] == 5[a]&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a81097ac61f7a18c6ec85fdfc61133c0cc29d155" translate="yes" xml:space="preserve">
          <source>Just want to point out that C pointers and arrays are not the &lt;em&gt;same&lt;/em&gt;, although in this case the difference is not essential.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 포인터와 배열이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하지 않다는 점을 지적하고 싶지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;,이 경우 차이점은 필수적이지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d2441f535495ef02a1cb465c8735af28bd5b07e" translate="yes" xml:space="preserve">
          <source>Nice question/answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좋은 질문 / 답변.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98bc25e30b7642e738cfd78e993ae40eb02b133f" translate="yes" xml:space="preserve">
          <source>Not an answer, but just some food for thought.
If class is having overloaded index/subscript operator, the expression &lt;code&gt;0[x]&lt;/code&gt; will not work:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;답이 아니라 생각을위한 음식입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스에 인덱스 / 첨자 연산자가 오버로드 된 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0[x]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 식이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작동하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e132b0de5ac062a9a7fde0931c25b8dc3c7098ef" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;!&lt;/code&gt; in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of &quot;pointer and integer&quot; was made necessary in C when it gained data types, and &lt;code&gt;sizeof&lt;/code&gt; became a thing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고하십시오 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;!&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BCPL에서 간접적 인 연산자는 이진 접두사 연산자와 이진 접두사 연산자입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 형식에는 간접 처리를 수행하기 전에 두 피연산자가 추가 된 것이 포함되어 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BCPL (및 B)의 단어 지향적 특성을 고려할 때 이것은 실제로 많은 의미가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C에서 데이터 타입을 얻었을 때 「포인터와 정수」의 제한이 필요 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해져 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4369357497b07857aa5f9f0d59e9912e60fc3c7d" translate="yes" xml:space="preserve">
          <source>Now, looking at this last
  expression, part of it.. &lt;code&gt;(a + i)&lt;/code&gt;, is a simple addition using the +
  operator and the rules of C state that such an expression is
  commutative. That is (a + i) is identical to &lt;code&gt;(i + a)&lt;/code&gt;. Thus we could
  write &lt;code&gt;*(i + a)&lt;/code&gt; just as easily as &lt;code&gt;*(a + i)&lt;/code&gt;.
  But &lt;code&gt;*(i + a)&lt;/code&gt; could have come from &lt;code&gt;i[a]&lt;/code&gt; ! From all of this comes the curious
  truth that if:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제이 마지막 표현을 살펴보면, 그 일부가 .. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 + 연산자와 C 표현식의 규칙을 사용하여 이러한 표현이 교환 적이라는 간단한 추가 방법입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉 (a + i)는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 처럼 쉽게 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 쓸 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt; &lt;code&gt;*(i + a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt; &lt;code&gt;i[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 나올 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 모든 것에서 다음과 같은 호기심이 생깁니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a0101aaccd31e7c1a382541872ca61e4d2855c1" translate="yes" xml:space="preserve">
          <source>Of course, I'm quite sure that there is no use case for that in real code, but I found it interesting anyway :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 실제 코드에는 유스 케이스가 없다고 확신하지만 어쨌든 흥미로운 것을 발견했습니다. :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87f7ff2ab3e38a0526469ba301a1a7213140a45e" translate="yes" xml:space="preserve">
          <source>One thing no-one seems to have mentioned about Dinah's problem with &lt;code&gt;sizeof&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dinah의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 문제에 대해 아무도 언급하지 않은 것 같습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9699ca5988bf85c5aecce06a126016e9f4290eb8" translate="yes" xml:space="preserve">
          <source>Pointer is a &quot;variable&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터는 &quot;가변&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdd18b5479c5c8d9be0aa2854dc3d5207b558735" translate="yes" xml:space="preserve">
          <source>Similarly when the c code is broken down into 3-address code, 
&lt;code&gt;5[a]&lt;/code&gt; will become -&amp;gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마찬가지로 c 코드가 3- 주소 코드로 분류되면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는-&amp;gt;가됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab8965c2689cf4af80819e57f31c38b5a532dfaa" translate="yes" xml:space="preserve">
          <source>Since we dont have access to &lt;strong&gt;int&lt;/strong&gt; class, this cannot be done:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;int&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;액세스 할 수 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;없으므로이&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 작업을 수행 할 수 없습니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d2f3a2be090331c6ed0efe4d14445e2a9ccaa11" translate="yes" xml:space="preserve">
          <source>So basically both the statements are pointing to the same location in memory and hence, &lt;code&gt;a[5] = 5[a]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 기본적으로 두 명령문은 메모리에서 동일한 위치를 가리 키므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5] = 5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74bd9aec219e8a876efe5e9dbf297450688134e3" translate="yes" xml:space="preserve">
          <source>So now we have &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; meaning exactly the same thing, though the latter form should never appear outside the &lt;a href=&quot;http://ioccc.org/&quot;&gt;IOCCC&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;arr[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;3[arr]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 정확히 같은 것을 의미하지만 후자는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ioccc.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IOCCC&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 외부에 나타나지 않아야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d87c687af6a603b7fae4247fa48fbea9ae67405" translate="yes" xml:space="preserve">
          <source>So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C's ancestor languages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 배열 인덱싱은 덧셈의 관점에서 정의되고, 덧셈, 심지어 포인터와 정수의 덧셈은 계산적이며 수십 년 전 C의 조상 언어로 거슬러 올라갑니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7dcde299d04157c827d07e041baf08423be13a0" translate="yes" xml:space="preserve">
          <source>So why is it this way?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 이런 식입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4519a10d3120a45f508a759d4090cbf678cee1a" translate="yes" xml:space="preserve">
          <source>So,</source>
          <target state="translated">So,</target>
        </trans-unit>
        <trans-unit id="8c89c7d498821658553bd1ecb86d67fddaaa6e8d" translate="yes" xml:space="preserve">
          <source>Ted Jensen explained it as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테드 젠슨은 다음과 같이 설명했다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0c02ea0bf226b00f8c97f9fbbcbfce6f19bd500" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;major difference&lt;/strong&gt; I found is...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;큰 차이&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내가 찾은입니다 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddf31a3e26ab563612c3b60a159dbc37fda16b6f" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;[]&lt;/code&gt; operator as follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 표준은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정의합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49e0ab5351629c999ecc0c6e397b25834b232a2e" translate="yes" xml:space="preserve">
          <source>The C standard's description of the &lt;code&gt;+&lt;/code&gt; operator (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;N1570&lt;/a&gt; 6.5.6) says:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N1570&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 6.5.6)에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대한 C 표준의 설명 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2007e88e85408e8f29febd9ef03d45f9952ac7ed" translate="yes" xml:space="preserve">
          <source>The compiler interprets &lt;code&gt;a[i]&lt;/code&gt; as &lt;code&gt;*(a+i)&lt;/code&gt; and the expression &lt;code&gt;5[a]&lt;/code&gt; evaluates to &lt;code&gt;*(5+a)&lt;/code&gt;. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a+i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해석 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 표현식 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(5+a)&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 평가됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;덧셈은 교환 적이므로 둘 다 동일하다는 것이 밝혀졌습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 표현식은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;true&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 평가됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e003dbac549e08b0dd4688d334bec18afaeeeaeb" translate="yes" xml:space="preserve">
          <source>The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여분의 스토리지 단어를 사용하지 않고 컴파일러가 어레이의 기본 주소를 나중에 명명 할 때 삽입하도록하는 혁신. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 역사 보고서에 따르면 이것은 구조가 C에 추가 된 시점에서 발생했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1d793f269a6c0a67206e321358c9256e4f0fa74" translate="yes" xml:space="preserve">
          <source>The main reason for this was that back in the 70's when C was designed, computers didn't have much memory (64KB was a lot), so the C compiler didn't do much syntax checking.  Hence &quot;&lt;code&gt;X[Y]&lt;/code&gt;&quot; was rather blindly translated into &quot;&lt;code&gt;*(X+Y)&lt;/code&gt;&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것의 주된 이유는 C가 디자인되었을 때 70 년대에 컴퓨터에 많은 메모리가 없었기 때문에 (64KB는 많았으므로) C 컴파일러는 구문 검사를 많이하지 않았기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X[Y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;는 &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(X+Y)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로 맹목적으로 번역되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5598417c3877f380e96a22cde55fcdd9a8eba2a1" translate="yes" xml:space="preserve">
          <source>Therefore &lt;code&gt;a[5]&lt;/code&gt; will evaluate to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 다음과 같이 평가됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e28410e5118fc1353afc84b39ff63a4c00217208" translate="yes" xml:space="preserve">
          <source>This also explains the &quot;&lt;code&gt;+=&lt;/code&gt;&quot; and &quot;&lt;code&gt;++&lt;/code&gt;&quot; syntaxes.  Everything in the form &quot;&lt;code&gt;A = B + C&lt;/code&gt;&quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn't bright enough to recognize it, so the developer had to (&lt;code&gt;A += C&lt;/code&gt;).   Similarly, if &lt;code&gt;C&lt;/code&gt; was &lt;code&gt;1&lt;/code&gt;, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn't recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;및 &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;구문 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도 설명합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = B + C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;형식의 모든 항목 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 동일한 컴파일 된 형식을가집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 B가 A와 동일한 객체 인 경우 어셈블리 수준 최적화를 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 컴파일러는 그것을 인식하기에 충분히 밝지 않았으므로 개발자는 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A += C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )해야했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마찬가지로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이면 다른 어셈블리 수준 최적화를 사용할 수 있었고 컴파일러는이를 인식하지 못했기 때문에 개발자가 명시 적으로 만들어야했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(더 최근에는 컴파일러가 사용하므로 요즘 구문은 거의 필요하지 않습니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2957c7291e8dd3b7c1bafc7a958af2782509f1ac" translate="yes" xml:space="preserve">
          <source>This explanation is also the reason why negative indexes in arrays work in C.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 설명은 배열의 음수 인덱스가 C에서 작동하는 이유이기도합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fc0a843bdfadc65145a35ad68cd5c63d07409c1" translate="yes" xml:space="preserve">
          <source>This is NOT saying that pointers and arrays
  are the same thing, they are not. We are only saying that to identify
  a given element of an array we have the choice of two syntaxes, one
  using array indexing and the other using pointer arithmetic, which
  yield identical results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 포인터와 배열이 같은 것이 아니라고 말하는 것이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 배열의 주어진 요소를 식별하기 위해 하나는 배열 인덱싱을 사용하고 다른 하나는 포인터 산술을 사용하여 동일한 결과를 산출하는 두 가지 구문을 선택할 수 있다고 말하고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a225f9d9ce3692ad1562eee23a824ea01f5447d4" translate="yes" xml:space="preserve">
          <source>Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the &lt;code&gt;unsigned&lt;/code&gt; keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn't have occurred to the designers of those languages. If a user wanted to add two &quot;things&quot;, whether those &quot;things&quot; are integers, pointers, or something else, it wasn't up to the language to prevent it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 언어들은 현대 C보다 훨씬 덜 타이핑되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히, 포인터와 정수의 구별은 종종 무시되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(초기 C 프로그래머는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unsigned&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 키워드가 언어에 추가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되기 전에 포인터를 부호없는 정수로 사용하기도했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.) 따라서 피연산자가 다른 유형이기 때문에 비정규 식을 추가하는 아이디어는 해당 언어의 설계자에게는 발생하지 않았을 것입니다. . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용자가 정수, 포인터 또는 다른 것 등 두 가지 &quot;사물&quot;을 추가하려는 경우 언어에 따라 달라지지 않았습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f65772585dbe5c3f9be396b2762536b24bd6101e" translate="yes" xml:space="preserve">
          <source>To answer the question literally. It is not always true that &lt;code&gt;x == x&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;말 그대로 질문에 대답하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항상 &lt;/font&gt; &lt;code&gt;x == x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것은 아닙니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f115cf17db3cd235931483179db65280105e850" translate="yes" xml:space="preserve">
          <source>We can re-initialize the pointer by an address but not the same case with an array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주소로 포인터를 다시 초기화 할 수 있지만 배열과 동일한 경우는 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8e6493efc14ecc048b709d17d6a46595f95919cb" translate="yes" xml:space="preserve">
          <source>Well, this is a feature that is only possible because of the language support.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 이것은 언어 지원 때문에 가능한 기능입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="06ef8221698e1df9e0d60c9945a8ac3f43b1e272" translate="yes" xml:space="preserve">
          <source>When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: &lt;code&gt;x + y == y + x&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 피연산자가 같은 유형이거나 공통 유형으로 승격 된 다른 숫자 유형 인 경우, commutativity는 완벽하게 이해됩니다 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y == y + x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="016171cdc5bdaa54ed0b2e5083fab7678a06cdf1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;define an array&lt;/strong&gt; at a time one &lt;strong&gt;address is initialize&lt;/strong&gt; in that pointer</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 번에 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정의하면&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해당 포인터에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주소가 초기화&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc4155f374b80bf76ee1bda0459d1bd13e1acb80" translate="yes" xml:space="preserve">
          <source>With arrays, why is it the case that a[5] == 5[a]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열에서 왜 a [5] == 5 [a]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b25d23d68d162aaa08b9e9252d3485eb5bb4e54" translate="yes" xml:space="preserve">
          <source>Yes, &lt;code&gt;p[i]&lt;/code&gt; is by definition equivalent to &lt;code&gt;*(p+i)&lt;/code&gt;, which (because addition is commutative) is equivalent to &lt;code&gt;*(i+p)&lt;/code&gt;, which (again, by the definition of the &lt;code&gt;[]&lt;/code&gt; operator) is equivalent to &lt;code&gt;i[p]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;p[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 정의에 따라 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(p+i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 동일합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 더하기는 교환 형이기 때문에) &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(i+p)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 동일 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 정의에 따라 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 행 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[p]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0db1547a0d27f180923b634a6c385bb5d0d5200d" translate="yes" xml:space="preserve">
          <source>You can only add an integer to a pointer, you can't add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터에는 정수만 추가 할 수 있으며 두 개의 포인터를 함께 추가 할 수는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 정수에 포인터를, 포인터에 정수를 추가 할 때 컴파일러는 크기를 고려해야하는 비트를 항상 알고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce350d74843615e170e417c9b55ec5ae40abbf7e" translate="yes" xml:space="preserve">
          <source>[] - that operator can be replaceable with pointer * .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[]-해당 연산자를 포인터 *로 바꿀 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f2172deda32c22bb7ed326f855cd1e60b094d2c" translate="yes" xml:space="preserve">
          <source>a - containing address (people call it as base address) just like an (2) type of pointer in our list</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a-리스트에있는 (2) 유형의 포인터와 같이 주소를 포함하는 사람들 (기본 주소라고 함)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97a88f2c750b6a9b26b40be8f3c5948f70a331d7" translate="yes" xml:space="preserve">
          <source>a[5] is nothing but *(a + 5)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a [5]는 * (a + 5)에 지나지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="93091c2e64403052e4bd3ed3f36e43ef771c82a2" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;5[a]&lt;/code&gt; will evaluate to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5[a]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 평가합니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0329e14c13535bcb6359a9184aa3bb549bbac0a" translate="yes" xml:space="preserve">
          <source>and also</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 또한&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7b87ed0f8f42e4beea17f77738a242956f749a4c" translate="yes" xml:space="preserve">
          <source>and back to your question...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;질문으로 돌아가서 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e14a5162bf2176970b34c6a462fbb0f77fbdaba" translate="yes" xml:space="preserve">
          <source>and the arrays are type of (2) from our list</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열은 목록에서 (2) 유형입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77b73075908163972d844091f09a9b5bc0421fef" translate="yes" xml:space="preserve">
          <source>are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열의 요소를 참조하는 다른 방법입니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(전세계가 아님)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02a97d497b5ebda3f799171a3381d322a9c53bce" translate="yes" xml:space="preserve">
          <source>array name is a &quot;mnemonic&quot; or &quot;synonym&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열 이름은 &quot;니모닉&quot;또는 &quot;동의어&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e650b4bcfab638a85de907196e6b5cfdd86dd6ce" translate="yes" xml:space="preserve">
          <source>i.e. if I access &lt;code&gt;a[-5]&lt;/code&gt; it will give me</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 만약 내가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[-5]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 접근 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 그것은 나에게 줄 것이다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="785229f56486c15d2737b6075a53f6cb6bbec742" translate="yes" xml:space="preserve">
          <source>in c compiler</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 컴파일러에서&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="988337ebfe6581049f95ede5081b3071f64d533f" translate="yes" xml:space="preserve">
          <source>in which case both &lt;code&gt;i + p&lt;/code&gt; and &lt;code&gt;i[p]&lt;/code&gt; would be illegal.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i + p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i[p]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 모두 불법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c94c0e41bc274bd0e78c44d3277f3bef91ccf351" translate="yes" xml:space="preserve">
          <source>is the same as writing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;쓰기와 동일&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3160b126bd0ef17f439072b3f5f9ec151c6a6c87" translate="yes" xml:space="preserve">
          <source>of which only the first is really necessary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그중 첫 번째 만이 실제로 필요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08aa496bf69321c55248a2a8c6e8a6b6565fcc5" translate="yes" xml:space="preserve">
          <source>pointer types</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터 유형&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b024f8c2bfa6dbc6442cb571d5d5d6243c0ca744" translate="yes" xml:space="preserve">
          <source>prints</source>
          <target state="translated">prints</target>
        </trans-unit>
        <trans-unit id="6049b2ff36f9c94c3a5f5916f9eae4ace9ddc50b" translate="yes" xml:space="preserve">
          <source>really did have to do &lt;code&gt;J = !(V + 5)&lt;/code&gt; (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus &lt;code&gt;V!5&lt;/code&gt; and &lt;code&gt;5!V&lt;/code&gt; were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배열의 기본 주소를 얻기 위해 V를 페치해야했기 때문에 실제로 BCPL 구문을 사용하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;J = !(V + 5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 수행해야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;V!5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;5!V&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 동의어였습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일화적인 관찰로서 WAFL (Warwick Functional Language)은 BCPL로 작성되었으며, 내 기억을 최대한 활용하기 위해 데이터 저장소로 사용되는 노드에 액세스하기 위해 전자보다 후자의 구문을 사용하는 경향이있었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 35 년에서 40 년 전의 것이 었으므로 나의 기억은 조금 녹슬 었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2599991ed8fb7accd72a93b52acec6c9e1462926" translate="yes" xml:space="preserve">
          <source>so finally...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="45f0d72226f6c0a5c5c39929b28a3dfa425d4d83" translate="yes" xml:space="preserve">
          <source>that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로는 10 단어가 아닌 11 단어의 메모리를 할당했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 C와 달리 이름 지정 V는 해당 위치로 이동하여 배열의 0 번째 요소의 주소를 선택했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 BCPL의 배열 간접 참조&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1935d7b6e1cdaa0cb2a12b33ef6db0f1f938bf83" translate="yes" xml:space="preserve">
          <source>writing</source>
          <target state="translated">writing</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
