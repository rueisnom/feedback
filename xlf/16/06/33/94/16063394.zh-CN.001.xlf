<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/16063394">
    <body>
      <group id="16063394">
        <trans-unit id="74cf125fecd9be94bfb57de2381f05816742688b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Multiple inheritance&quot; with mix ins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;具有混入的&amp;ldquo;多重继承&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f60012486871de55c32083b7c52aef92ab1d2228" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function introduction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;构造函数介绍&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="464c26fcf651c9497932220210a67991e239e32a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extending and overriding Parent functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;扩展和覆盖父函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7422920ac45432c6122783701aa363fe96aaf2b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Inheritance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091e6370d4f77a8fb1c6e19fd7ffd43862df251e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More about prototype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;有关原型的更多信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="905e17e869df8f106b1d829cc87a51393ce68750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object.create to set prototype part of inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Object.create设置继承的原型部分&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5cbcd9b4b225cb9887c626d6879881f3ae6eded" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing (constructor) arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;传递（构造函数）参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ee7541772d496e52c1e2bd3a4d436dc1e23236e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private variables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;私有变量&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b58eaa69cc21de153eaf2108e426b123ef846c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The this variable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这个变量&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24127a0a55a2a41dda788b7ff3a0a8ecd74bbf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.constructor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2c84fbef3dfee70da18aa5795b9c02c1f412822" translate="yes" xml:space="preserve">
          <source>An object can inherit from another object through the use of prototype. You can set the prototype of any object with any other object using &lt;code&gt;Object.create&lt;/code&gt;. In the constructor function introduction we have seen that if a member can't be found on the object then JavaScript will look in the prototpe chain for it.</source>
          <target state="translated">一个对象可以通过使用原型从另一个对象继承。 您可以使用 &lt;code&gt;Object.create&lt;/code&gt; 将任何对象的原型与任何其他对象一起设置。 在构造函数介绍中，我们已经看到，如果在对象上找不到成员，则JavaScript会在原型链中查找该成员。</target>
        </trans-unit>
        <trans-unit id="cbe7e26021ebaa520f3f0662be1d2cd9e0ac3e41" translate="yes" xml:space="preserve">
          <source>Another reason could be that to create a Hamster a lot of complicated calculations need be done on passed arguments that may be not available yet, again you could pass in dummy arguments but it could unnecessarily complicate your code.</source>
          <target state="translated">另一个原因可能是,要创建一个Hamster,需要在传递的参数上做很多复杂的计算,而这些参数可能还不存在,同样,你可以传递假参数,但这可能会使你的代码不必要地复杂化。</target>
        </trans-unit>
        <trans-unit id="b17fe45dfada0a306c0914b347e348b9ca0852b5" translate="yes" xml:space="preserve">
          <source>BUT in Example 1 something else happens:</source>
          <target state="translated">但在例1中,还有一些事情发生。</target>
        </trans-unit>
        <trans-unit id="4ee710d2c9f34cfc2049bc5cdbb2fb193e95ac12" translate="yes" xml:space="preserve">
          <source>Because walk() could not be found on bob directly JavaScript will look for it in the Person.prototype as this is the constructor of bob. If it can't be found there it'll look on Object.prototype. This is called the prototype chain. The prototype part of inheritance is done by lengthening this chain; for example bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (more on inheritance later).</source>
          <target state="translated">由于无法直接在bob上找到walk（），因此JavaScript会在Person.prototype中查找它，因为这是bob的构造函数。 如果找不到，它将查找Object.prototype。 这称为原型链。 继承的原型部分是通过延长此链来完成的。 例如bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype（稍后会详细介绍继承）。</target>
        </trans-unit>
        <trans-unit id="b12c833356fce30b677bb5007b4eca7f1cf9586b" translate="yes" xml:space="preserve">
          <source>By using closures you do not give others a choice and by using the naming convention with documentation you do. This is not specific to JavaScript, in other languages you can decide not to use private members as you trust others to know what they are doing and give them the choice to do as they want (with risks involved).</source>
          <target state="translated">通过使用闭包,你没有给别人选择的余地,而通过使用文档的命名惯例,你却给了别人选择的余地。这并不是特定于JavaScript,在其他语言中,你可以决定不使用私有成员,因为你相信别人知道他们在做什么,并给他们选择权,让他们按照自己的意愿去做(有风险)。</target>
        </trans-unit>
        <trans-unit id="48e7bf94fdffad6556b22447c07ca6a043f61d30" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 1 and for objects that inherit have them run the Parent code as well (Hamster.apply(this,arguments);)</source>
          <target state="translated">创建一个实例运行步骤1中的代码,对于继承的对象,让它们也运行父代码 (Hamster.apply(this,arguments);)</target>
        </trans-unit>
        <trans-unit id="9cafc324364ac8f9b0b7fbc766cc44ec930d2327" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 2.</source>
          <target state="translated">创建一个实例,运行步骤2中的代码。</target>
        </trans-unit>
        <trans-unit id="bab01f763c8928cbac3d62d6a5f840594c8f828b" translate="yes" xml:space="preserve">
          <source>Define an object that has members that will be same for many instances (person is a blueprint for bob and ben and can be for jilly, marie, clair ...)</source>
          <target state="translated">定义一个对象,其成员对许多实例都是相同的(person是bob和ben的蓝图,可以是jilly、marie、clair......)。</target>
        </trans-unit>
        <trans-unit id="0369ebd98eda3b5d7bf11c618aea1f74bd1b7cd8" translate="yes" xml:space="preserve">
          <source>Define instance specific members of an object (functions Hamster and RussionMini).</source>
          <target state="translated">定义一个对象的特定成员实例(函数Hamster和RussionMini)。</target>
        </trans-unit>
        <trans-unit id="15a6e2970bdac2aa16360ffbe8c78946b52ff0eb" translate="yes" xml:space="preserve">
          <source>Define instance specific members that should be unique for instances (bob and ben).</source>
          <target state="translated">定义实例的特定成员,对实例(bob和ben)来说应该是唯一的。</target>
        </trans-unit>
        <trans-unit id="f0566c177d01aa7ea879a7591493f45ebcd632b6" translate="yes" xml:space="preserve">
          <source>Define members that can be shared among instances.(Hamster.prototype and RussionMini.prototype)</source>
          <target state="translated">定义可以在实例之间共享的成员(Hamster.prototype和RussionMini.prototype)。</target>
        </trans-unit>
        <trans-unit id="1cc64015257eb076b900848a79305e97c1168f09" translate="yes" xml:space="preserve">
          <source>Even though bob, ben and all other created Person instances share walk the function will behave differently per instance because in the walk function it uses &lt;code&gt;this&lt;/code&gt;. The value of &lt;code&gt;this&lt;/code&gt; will be the invoking object; for now let's say it's the current instance so for &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot; will be bob. (more on &quot;this&quot; and the invoking object later).</source>
          <target state="translated">即使bob，ben和所有其他创建的Person实例共享walk，该函数的行为也会因每个实例而有所不同，因为在walk函数中它使用 &lt;code&gt;this&lt;/code&gt; 。 此值将成为调用对象； 现在，我们说它是当前实例，因此对于 &lt;code&gt;bob.walk()&lt;/code&gt; , &amp;ldquo; this&amp;rdquo;将是bob。 （有关&amp;ldquo; this&amp;rdquo;和稍后调用对象的更多信息）。</target>
        </trans-unit>
        <trans-unit id="8829ee8adb882bc56fe22bb8afb9246c1e8abb66" translate="yes" xml:space="preserve">
          <source>Every instance of Hamster will share that array</source>
          <target state="translated">仓鼠的每个实例将共享该数组</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">例1:</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">例2:</target>
        </trans-unit>
        <trans-unit id="d74d95fa8fca84cad0d34ec6afae31477e7ee53f" translate="yes" xml:space="preserve">
          <source>For Movable we have instance specific members (like &lt;code&gt;location&lt;/code&gt;). And we have members that are not instance specific (like the function move()). Instance specific members will be set by calling mxIns (added by mixin helper function) when creating an instance. Prototype members will be copied one by one on Cat.prototype from Movable.prototype using the mixin helper function.</source>
          <target state="translated">对于Movable，我们有特定于实例的成员（例如 &lt;code&gt;location&lt;/code&gt; ）。 而且我们的成员不是特定于实例的（例如，函数move（））。 创建实例时，将通过调用mxIns（由mixin helper函数添加）来设置实例特定的成员。 原型成员将使用mixin辅助函数从Movable.prototype上的Cat.prototype上一一复制。</target>
        </trans-unit>
        <trans-unit id="d4034236af5962aabc90bc340970cf5500bed73f" translate="yes" xml:space="preserve">
          <source>From this I understand, that when writing up and adding a new property which doesn't exist, the interpreter will go up the prototype chain until it finds the property, and THEN change it.</source>
          <target state="translated">由此我理解,当写出并添加一个不存在的新属性时,解释器会沿着原型链往上走,直到找到这个属性,然后再修改它。</target>
        </trans-unit>
        <trans-unit id="c6720ee66246445f87a7ba9b7c392e804525fab2" translate="yes" xml:space="preserve">
          <source>Here is the documentation about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;, it basically returns the second argument (not supported in the polyfil) with the first argument as the returned object's prototype.</source>
          <target state="translated">这是有关&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;的文档，它基本上返回第二个参数（polyfil不支持），第一个参数作为返回对象的原型。</target>
        </trans-unit>
        <trans-unit id="e848ec5629ff1294871791ebbf63e38cc2338e10" translate="yes" xml:space="preserve">
          <source>I agree with the following: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; and personally have not used them.</source>
          <target state="translated">我同意以下内容： &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http&lt;/a&gt; : //blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/并且个人没有使用过它们。</target>
        </trans-unit>
        <trans-unit id="cbe2e3d4e71526c44ee323b9c2c5afb89e673b0d" translate="yes" xml:space="preserve">
          <source>I like to define functions that return a function for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; on the prototype to have fine control over the variables that are included in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; scope.</source>
          <target state="translated">我想定义一些函数，这些函数返回原型上的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;闭包&lt;/a&gt;函数，以便对闭 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;包&lt;/a&gt;范围中包含的变量进行精细控制。</target>
        </trans-unit>
        <trans-unit id="51d29e872f0afd793829823b2b7b80ebb354988c" translate="yes" xml:space="preserve">
          <source>I usually pass one object to a function and have that function mutate whatever it needs (set defaults), then that function will pass it to another function that will do the same and so on and so on. Here is an example:</source>
          <target state="translated">我通常会把一个对象传给一个函数,让这个函数对它需要的东西进行突变(设置默认值),然后这个函数会把它传给另一个函数,这个函数会做同样的事情,以此类推。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="3e1c56435bb8295e877cc0c85c18aa7f843177ad" translate="yes" xml:space="preserve">
          <source>I'm confused and cannot see why this happens.</source>
          <target state="translated">我很困惑,不明白为什么会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="fde27a0f508ac6064af12c4d8b939650e52d74e9" translate="yes" xml:space="preserve">
          <source>If after setting prototype part of inheritance you should have it point to the right function again.</source>
          <target state="translated">如果设置好继承的原型部分后,你应该让它再次指向正确的函数。</target>
        </trans-unit>
        <trans-unit id="da522a6c41073e7a1c23b91110e0ce440840c41f" translate="yes" xml:space="preserve">
          <source>If ben was waiting for a red light and and bob was at a green light; then you'll invoke walk() on both ben and bob obviously something different would happen to ben and bob.</source>
          <target state="translated">如果Ben在等红灯,而bob在绿灯处,那么你会对Ben和bob都调用walk(),显然Ben和bob都会有不同的事情发生。</target>
        </trans-unit>
        <trans-unit id="11e4a4b87d427e615f87bbb7d7d0b5574e9d0999" translate="yes" xml:space="preserve">
          <source>If no second argument was given it'll return an empty object with first argument to be used as the returned object's prototype (the first object to be used in the returned object's prototype chain).</source>
          <target state="translated">如果没有给出第二个参数,它将返回一个空对象,第一个参数作为返回对象的原型(返回对象的原型链中的第一个对象)。</target>
        </trans-unit>
        <trans-unit id="45326f667c3b7dd729de1fff54fe465ea292ec6c" translate="yes" xml:space="preserve">
          <source>If you need (and you do in this case) separate instances of food collections for each Hamster, you need to create the property on the instance. For example:</source>
          <target state="translated">如果你需要(在这种情况下,你确实需要)为每个仓鼠的食物收集单独的实例,你需要在实例上创建属性。比如说。</target>
        </trans-unit>
        <trans-unit id="bf65b3d11ae75642ecded1c9d1c19caac84c3201" translate="yes" xml:space="preserve">
          <source>If you still insist on privates then the &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;following&lt;/a&gt; pattern may help. It doesn't implement private though but implements protected.</source>
          <target state="translated">如果您仍然坚持使用私有内容，则&lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;以下&lt;/a&gt;模式可能会有所帮助。 它不是实现私有的，而是实现保护的。</target>
        </trans-unit>
        <trans-unit id="b79b7554eff5c5557c88dc8d14f691a2491ed888" translate="yes" xml:space="preserve">
          <source>In all the example code you'll see &lt;code&gt;this&lt;/code&gt; referring to the current instance.</source>
          <target state="translated">在所有示例代码中，您将看到 &lt;code&gt;this&lt;/code&gt; 是指当前实例。</target>
        </trans-unit>
        <trans-unit id="c51dd0d86d782b26cf283ada041cd94af0aa189e" translate="yes" xml:space="preserve">
          <source>In previous part we have seen that re assignment of members that come from an instance's prototype (ben.walk) will shadow that member (create walk on ben rather than changing Person.prototype.walk).</source>
          <target state="translated">在前面的部分我们看到,来自于实例的原型(ben.walk)的成员的再分配会对该成员产生阴影(在ben上创建walk,而不是改变Person.prototype.walk)。</target>
        </trans-unit>
        <trans-unit id="bd9ce7cacb78c648c9be29a9cf9471ae22e833f0" translate="yes" xml:space="preserve">
          <source>In the following example we assume that a Hamster can run 3km an hour but a Russion mini can only run half as fast. We can hard code 3/2 in RussionMini but if this value were to change we have multiple places in code where it needs changing. Here is how we use Hamster.prototype to get the parent (Hamster) speed.</source>
          <target state="translated">在下面的例子中,我们假设一个仓鼠每小时可以跑3公里,但Russion mini只能跑一半的速度。我们可以在RussionMini中硬编码32,但是如果这个值要改变,我们在代码中会有很多地方需要改变。下面是我们如何使用Hamster.prototype来获取父代(Hamster)的速度。</target>
        </trans-unit>
        <trans-unit id="968367429f9ee5051fb4a6a3e36c91706fe020f5" translate="yes" xml:space="preserve">
          <source>In this code I have removed name from prototype as well as food because you are most likely going to shadow this almost immediately when creating an instance anyway. Name is now an instance specific member with a default value set in the constructor function. Becaus the food member is also moved from prototype to instance specific member it will not affect bob.food when adding food to ben.</source>
          <target state="translated">在这段代码中,我把name从prototype中删除了,因为你很可能在创建一个实例时几乎会立刻就去掉name。name现在是一个实例的特定成员,在构造函数中设置了一个默认值。因为 food 成员也从 prototype 移到了 instance specific member,所以在给 ben 添加 food 时不会影响 bob.food。</target>
        </trans-unit>
        <trans-unit id="782c9829c985ba325100f3f912e7b73c3cc8a8d2" translate="yes" xml:space="preserve">
          <source>It's good because it enables you and others to mock certain members for testing easily. It gives others a chance to easily improve (patch) your code but this is also bad because there is no guarantee that a next version of your code has the same implementation and or private members.</source>
          <target state="translated">这是好的,因为它可以让你和其他人轻松地模拟某些成员进行测试。它给了别人一个机会,可以轻松地改进(补丁)你的代码,但这也是不好的,因为不能保证你的代码的下一个版本有相同的实现和或私有成员。</target>
        </trans-unit>
        <trans-unit id="8a6c3b4d25a0b9e7b9de12cbedcc883a943f7193" translate="yes" xml:space="preserve">
          <source>JavaScript doesn't have a private modifier.</source>
          <target state="translated">JavaScript没有私有修改器。</target>
        </trans-unit>
        <trans-unit id="f4783878a60c2e2bedc9c4cb15e63c2cad8e91a8" translate="yes" xml:space="preserve">
          <source>Most of the patterns I've seen will either break when inheritance level is more than 2 levels (Child =&amp;gt; Parent =&amp;gt; GrandParent) or use more resources by implementing super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt;.</source>
          <target state="translated">我所看到的大多数模式都将在继承级别超过2级时中断（Child =&amp;gt; Parent =&amp;gt; GrandParent），或者通过实现super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;闭包而&lt;/a&gt;使用更多资源。</target>
        </trans-unit>
        <trans-unit id="a86491f8b298b8b31ba2a6f4824cc3d924e08dba" translate="yes" xml:space="preserve">
          <source>Not implementing privates as closures would leak implementation and enable you or users extending your code to use members that are not part of your public API. This can be both good and bad.</source>
          <target state="translated">不实现privates作为闭包会泄露实现,使你或扩展你的代码的用户能够使用不属于你的公共API的成员。这既是好事也是坏事。</target>
        </trans-unit>
        <trans-unit id="554811e64329329de8e99177229051265f514851" translate="yes" xml:space="preserve">
          <source>Person is the constructor function. When you create an instance using Person you have to use the new keyword:</source>
          <target state="translated">Person是构造函数。当你使用Person创建一个实例时,你必须使用新关键字。</target>
        </trans-unit>
        <trans-unit id="3d400767e83f5b3545ee60adf2bcccde144b2840" translate="yes" xml:space="preserve">
          <source>Prototypes are &lt;strong&gt;NOT&lt;/strong&gt; instantiated for each instance of an object.</source>
          <target state="translated">&lt;strong&gt;不会&lt;/strong&gt;为对象的每个实例实例化原型。</target>
        </trans-unit>
        <trans-unit id="cceb329f51a30a7a00183d2d4ed1d0655073e080" translate="yes" xml:space="preserve">
          <source>Prototypical inheritance - writing up</source>
          <target state="translated">原型继承--写起</target>
        </trans-unit>
        <trans-unit id="64b8741afff5b09a35196deea479694b320fa7af" translate="yes" xml:space="preserve">
          <source>Set the prototype part of inheritance (RussionMini.prototype = Object.create(Hamster.prototype))</source>
          <target state="translated">设置继承中的原型部分 (RussionMini.prototype=Object.create(Hamster.prototype))</target>
        </trans-unit>
        <trans-unit id="4b07cce27e263241a4a74f241d33c0a5433426cd" translate="yes" xml:space="preserve">
          <source>Shadowing members happens when we do something like &lt;code&gt;ben.walk=22&lt;/code&gt;, even though bob and ben share &lt;code&gt;walk&lt;/code&gt; the &lt;em&gt;assignment&lt;/em&gt; of 22 to ben.walk will not affect bob.walk. This is because that statement will create a member called &lt;code&gt;walk&lt;/code&gt; on ben directly and assign it a value of 22. There will be 2 different walk members: ben.walk and Person.prototype.walk.</source>
          <target state="translated">当我们执行类似于 &lt;code&gt;ben.walk=22&lt;/code&gt; 的操作时 ，会发生影子成员，即使bob和ben share &lt;code&gt;walk&lt;/code&gt; 将22 &lt;em&gt;分配&lt;/em&gt;给ben.walk也不影响bob.walk。 这是因为该语句将直接在ben上创建一个名为 &lt;code&gt;walk&lt;/code&gt; 的成员，并将其赋值为22。将有2个不同的walk成员：ben.walk和Person.prototype.walk。</target>
        </trans-unit>
        <trans-unit id="525b7ccb7b92ac04a16fabaf6a882aee1fe90b3c" translate="yes" xml:space="preserve">
          <source>So I have these 2 examples, from javascript.info:</source>
          <target state="translated">所以我有这两个例子,来自javascript.info。</target>
        </trans-unit>
        <trans-unit id="1ea63f6cce56c9eca2d72522f3a7e51c6996b13a" translate="yes" xml:space="preserve">
          <source>Some things are better not to be inherited, if a Cat can move and then a Cat should not inherit from Movable. A Cat is not a Movable but rather a Cat can move. In a class based language Cat would have to implement Movable. In JavaScript we can define Movable and define implementation here, Cat can either override, extend it or us it's default implementation.</source>
          <target state="translated">有些东西还是不要继承的好,如果猫咪能动的话,那么猫咪就不要继承可移动的东西。Cat不是Movable,而是Cat可以移动。在基于类的语言中,Cat必须要实现Movable。在JavaScript中,我们可以在这里定义Movable并定义实现,Cat可以覆盖、扩展它,也可以使用它的默认实现。</target>
        </trans-unit>
        <trans-unit id="ef53d380cd63d69c06e94e9adfd7ea3d789beae8" translate="yes" xml:space="preserve">
          <source>Some would set the prototype of RussionMini to an instance of Hamster (RussionMini.prototype = new Hamster()). This is not desirable because even though it accomplishes the same (RussionMini.prototype's prototype is Hamster.prototype) it also sets Hamster instance members as members of RussionMini.prototype. So RussionMini.prototype.food will exist but is a shared member (remember bob and ben in &quot;More about prototype&quot;?). The food member will be shadowed when creating a RussionMini because Hamster code is run with &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; that in turn runs &lt;code&gt;this.food = []&lt;/code&gt; but any Hamster members will still be members of RussionMini.prototype.</source>
          <target state="translated">有人会将RussionMini的原型设置为Hamster的实例（RussionMini.prototype = new Hamster（））。 这是不希望的，因为即使它完成了相同的操作（RussionMini.prototype的原型是Hamster.prototype），它也将Hamster实例成员设置为RussionMini.prototype的成员。 因此RussionMini.prototype.food将存在，但是是共享成员（还​​记得&amp;ldquo;更多关于原型&amp;rdquo;中的bob和ben吗？）。 在创建RussionMini时，食物成员将被遮盖，因为Hamster代码是使用 &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; 依次运行 &lt;code&gt;this.food = []&lt;/code&gt; 但任何仓鼠成员仍将是RussionMini.prototype的成员。</target>
        </trans-unit>
        <trans-unit id="603053b2f1c406cdc9f1aba516ab35aa5644c02a" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;children&lt;/code&gt; need to extend &lt;code&gt;parent&lt;/code&gt; functions.</source>
          <target state="translated">有时 &lt;code&gt;children&lt;/code&gt; 需要扩展 &lt;code&gt;parent&lt;/code&gt; 职能。</target>
        </trans-unit>
        <trans-unit id="dc46bcd4a8dbc5cd0a9473c19363d38ae051b890" translate="yes" xml:space="preserve">
          <source>Start from Example 2: when the code reaches &lt;code&gt;speedy.found&lt;/code&gt;, it finds no &lt;code&gt;found&lt;/code&gt; property in &lt;code&gt;speedy&lt;/code&gt;, and so it climbs up to the prototype and changes it there. That's why &lt;code&gt;food.length&lt;/code&gt; is equal for both hamsters, in other words they have the same stomach.</source>
          <target state="translated">从示例2开始：当代码到达 &lt;code&gt;speedy.found&lt;/code&gt; 时 ，它在 &lt;code&gt;speedy&lt;/code&gt; 中找不到 &lt;code&gt;found&lt;/code&gt; 属性，因此它爬到了原型并在那里进行了更改。 这就是为什么两只仓鼠的 &lt;code&gt;food.length&lt;/code&gt; 相等的原因，换句话说，它们的肚子也一样。</target>
        </trans-unit>
        <trans-unit id="1c5ef60e0f791800e4f9fe96e6386ddd31add8b0" translate="yes" xml:space="preserve">
          <source>The above is a simple implementation that replaces same named functions with whatever mix in is mixed in last.</source>
          <target state="translated">以上是一个简单的实现,用最后混入的任何混入的函数代替相同命名的函数。</target>
        </trans-unit>
        <trans-unit id="91886ea4946327cd43e989ed9081a401237a0d2d" translate="yes" xml:space="preserve">
          <source>The code above shows that ben and bob share members from person. There is only one person, it is set as bob's and ben's prototype (person is used as the first object in the prototype chain to look up requested members that don't exist on the instance). The problem with the above code is that bob and ben should have their own &lt;code&gt;food&lt;/code&gt; member. This is where the constructor function comes in. It is used to create instance specific members. You could also pass arguments to it to set values of these instance specific members.</source>
          <target state="translated">上面的代码显示ben和bob共享person的成员。 只有一个人，它被设置为bob和ben的原型（person被用作原型链中的第一个对象，以查找实例中不存在的请求成员）。 上面的代码的问题在于bob和ben应该有自己的 &lt;code&gt;food&lt;/code&gt; 成员。 这是构造函数进入的地方。它用于创建实例特定的成员。 您还可以将参数传递给它，以设置这些实例特定成员的值。</target>
        </trans-unit>
        <trans-unit id="ce16836f76cd9e02bb10ce77133484da4db12749" translate="yes" xml:space="preserve">
          <source>The constructor property is included in the prototype by JavaScript, you can change it but it should point to the constructor function. So &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; should point to Hamster.</source>
          <target state="translated">JavaScript将该原型包含在构造函数中，您可以对其进行更改，但它应指向构造函数。 因此， &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; 应该指向仓鼠。</target>
        </trans-unit>
        <trans-unit id="ba2e7bfbfcc3ebee3a82668a2127dadc5a3a614c" translate="yes" xml:space="preserve">
          <source>The disadvantage is that you hard code Hamster.prototype. There may be patterns that will give you the advantage of &lt;code&gt;super&lt;/code&gt; as in Java.</source>
          <target state="translated">缺点是您要硬编码Hamster.prototype。 可能有一些模式可以像Java中一样为您提供 &lt;code&gt;super&lt;/code&gt; 的优势。</target>
        </trans-unit>
        <trans-unit id="c0f31cb3709425be0a6f04c9d6a8e9bae7b0bdf4" translate="yes" xml:space="preserve">
          <source>The following code demonstrates the difference between prototype members and instance members by mutating members.</source>
          <target state="translated">下面的代码通过突变成员来演示原型成员和实例成员的区别。</target>
        </trans-unit>
        <trans-unit id="92d7047ac0b211ef42fa97b41187517206e5a323" translate="yes" xml:space="preserve">
          <source>The following code shows how to inherit. The tasks are basically the same as in code before with a little extra</source>
          <target state="translated">下面的代码显示的是如何继承。任务基本与之前的代码相同,但多了一点额外的任务</target>
        </trans-unit>
        <trans-unit id="b31cca01cbdf5bb975254cb59ea3db82b273ae80" translate="yes" xml:space="preserve">
          <source>The instances where this would refer to the wrong object are usually when attaching event listeners, callbacks or timeouts and intervals. In the next 2 lines of code we &lt;code&gt;pass&lt;/code&gt; the function, we don't invoke it. Passing the function is: &lt;code&gt;someObject.aFunction&lt;/code&gt; and invoking it is: &lt;code&gt;someObject.aFunction()&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value does not refer to the object the function was declared on but on the object that &lt;code&gt;invokes&lt;/code&gt; it.</source>
          <target state="translated">通常，当附加事件侦听器，回调或超时和间隔时，此实例将指向错误的对象。 在接下来的两行代码中，我们 &lt;code&gt;pass&lt;/code&gt; 函数，但不调用它。 传递函数是： &lt;code&gt;someObject.aFunction&lt;/code&gt; ，调用它是： &lt;code&gt;someObject.aFunction()&lt;/code&gt; 。 &lt;code&gt;this&lt;/code&gt; 值不引用在其上声明函数的对象，而是在 &lt;code&gt;invokes&lt;/code&gt; 它的对象上。</target>
        </trans-unit>
        <trans-unit id="2d633be38865f4cc00308b578d502e60cb128ba2" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;walk&lt;/code&gt; is part of Person.prototype and is shared for all instances bob and ben are instances of Person so they share the walk member (bob.walk===ben.walk).</source>
          <target state="translated">成员 &lt;code&gt;walk&lt;/code&gt; 是Person.prototype的一部分，并且所有实例bob和ben都是Person的实例共享，因此它们共享walk成员（bob.walk === ben.walk）。</target>
        </trans-unit>
        <trans-unit id="6b7f455cf9ed0f3eee5f17e212f56a94f50505d9" translate="yes" xml:space="preserve">
          <source>The next code shows another way to implement the constructor function, syntax is different but the idea is the same:</source>
          <target state="translated">下面的代码显示了另一种实现构造函数的方法,语法不同,但思想是一样的。</target>
        </trans-unit>
        <trans-unit id="68b7a276695cb91b3cc1a5a46c42b89c5d2e1bc4" translate="yes" xml:space="preserve">
          <source>The property/member &lt;code&gt;name&lt;/code&gt; is instance specific, it's different for bob and ben</source>
          <target state="translated">属性/成员 &lt;code&gt;name&lt;/code&gt; 是特定于实例的，对于bob和ben来说是不同的</target>
        </trans-unit>
        <trans-unit id="34bac27fdaa771c107c0ae1ee0c876c8cccc0390" translate="yes" xml:space="preserve">
          <source>The this variable actually refers to the invoking object, it refers to the object that came before the function.</source>
          <target state="translated">这个变量实际上指的是调用对象,它指的是函数之前的对象。</target>
        </trans-unit>
        <trans-unit id="dbeae5adf6a2e7873a50962c48c4d2650e1cad7a" translate="yes" xml:space="preserve">
          <source>This way of passing arguments in a function chain is useful in many cases. When you're working on code that would calculate a total of something and later you'd like to re factor the total of that something to be in a certain currency you may have to change a lot of functions to pass the value for currency. You could up scope a currency value (even to global like &lt;code&gt;window.currency='USD'&lt;/code&gt;) but that's a bad way to solve it.</source>
          <target state="translated">这种在函数链中传递参数的方法在许多情况下很有用。 当您在编写可以计算总金额的代码时，稍后您想将某种货币的总金额重新分解为某种货币时，您可能必须更改许多函数才能传递货币值。 您可以扩大货币值的范围（甚至像 &lt;code&gt;window.currency='USD'&lt;/code&gt; 这样的全局值），但这是解决它的一种不好的方法。</target>
        </trans-unit>
        <trans-unit id="881d70367fb2cb9071aabd702a8ddae76085a077" translate="yes" xml:space="preserve">
          <source>To answer your question about Example 1, if it doesn't find the property anywhere in the prototype chain, it creates the property on the target object.</source>
          <target state="translated">为了回答你关于例1的问题,如果在原型链的任何地方没有找到该属性,它就会在目标对象上创建该属性。</target>
        </trans-unit>
        <trans-unit id="caa724d08d862109a2da38689f2332f1ce655618" translate="yes" xml:space="preserve">
          <source>To clarify see the following code:</source>
          <target state="translated">要澄清,请看下面的代码。</target>
        </trans-unit>
        <trans-unit id="6fa3de1fe95879c2e0e06bbcc67ffb2a5a9cacd6" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;this&lt;/code&gt; in the above cases refer to someObject you can pass a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; instead of the function directly:</source>
          <target state="translated">在上述情况下，要使它引用someObject，您可以传递&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;闭包&lt;/a&gt;而不是直接传递函数：</target>
        </trans-unit>
        <trans-unit id="95908275067ede0cb508056464f5d825f362df1f" translate="yes" xml:space="preserve">
          <source>To override a Parent (=Hamster) method you do the same but don't do Hamster.prototype.parentMethod.call(this,....</source>
          <target state="translated">要重写一个Parent (=Hamster)方法,你要做同样的操作,但不要做Hamster.prototype.parentMethod.call(this,...)。</target>
        </trans-unit>
        <trans-unit id="30981a69967a6193b8f04b92e8a40f2bd4f43877" translate="yes" xml:space="preserve">
          <source>Using a pattern some would call &quot;classical inheritance&quot;. If you are confused by the syntax I'll be happy to explain more or provide different patterns.</source>
          <target state="translated">使用一种模式,有些人会称之为 &quot;经典继承&quot;。如果你对这种语法感到困惑,我会很乐意为你解释更多,或者提供不同的模式。</target>
        </trans-unit>
        <trans-unit id="9d15948c93f4b3b1f746c221caff8d64929f5020" translate="yes" xml:space="preserve">
          <source>What if we don't re assign but mutate the member? Mutating is (for example) changing sub properties of an Object or invoking functions that will change the object's value. For example:</source>
          <target state="translated">如果我们不重新赋值,而是对成员进行突变呢?突变就是(例如)改变对象的子属性,或者调用函数来改变对象的值。比如说。</target>
        </trans-unit>
        <trans-unit id="d72ec19dd58257fe3e8938b8afc236576f1071ab" translate="yes" xml:space="preserve">
          <source>When Child calls a Parent (&lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt;) we assume that Hamster uses the same arguments as RussionMini in the same order. For functions that call other functions I usually use another way to pass arguments.</source>
          <target state="translated">当Child调用Parent时（ &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; ），我们假定Hamster以与RussionMini相同的顺序使用相同的参数。 对于调用其他函数的函数，我通常使用另一种方式传递参数。</target>
        </trans-unit>
        <trans-unit id="1a8948d65f6b2ed854bc435e20bd64c244a77252" translate="yes" xml:space="preserve">
          <source>When asking for bob.walk you'll get the Person.prototype.walk function because &lt;code&gt;walk&lt;/code&gt; could not be found on bob. Asking for ben.walk however will get you the value 22 because the member walk has been created on ben and since JavaScript found walk on ben it will not look in the Person.prototype.</source>
          <target state="translated">当请求bob.walk时，您将获得Person.prototype.walk函数，因为在bob上找不到 &lt;code&gt;walk&lt;/code&gt; 。 但是，询问ben.walk会为您提供22的值，因为该成员walk是在ben上创建的，并且因为JavaScript在ben上找到了walk，所以它将不在Person.prototype中查找。</target>
        </trans-unit>
        <trans-unit id="dbae9f24b1b441346037a1a711472938fe1b0cdb" translate="yes" xml:space="preserve">
          <source>When using Object.create with 2 arguments, Object.defineProperty or Object.defineProperties shadowing works a bit different. More info on that &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">当使用带有2个参数的Object.create时，Object.defineProperty或Object.defineProperties阴影的工作原理有所不同。 有关&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;此的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="944b2bf97bd3b09291debcbebf9c539ec6b669f8" translate="yes" xml:space="preserve">
          <source>With constructor functions you'll set the prototype in step 2 in the following code we set the prototype in step 3.</source>
          <target state="translated">使用构造函数你会在步骤2中设置原型,在下面的代码中我们在步骤3中设置原型。</target>
        </trans-unit>
        <trans-unit id="9298f1163ca32f5e167b7c0302b9ad1b3d88a666" translate="yes" xml:space="preserve">
          <source>With passing an object you could add currency to &lt;code&gt;args&lt;/code&gt; whenever it's available in the function chain and mutate/use it whenever you need it without changing the other functions (explicitly have to pass it in the function calls).</source>
          <target state="translated">通过传递对象，您可以在函数链中可用时将货币添加到 &lt;code&gt;args&lt;/code&gt; 中，并在需要时随时更改/使用它，而无需更改其他函数（必须在函数调用中显式传递）。</target>
        </trans-unit>
        <trans-unit id="837db40af571b967b8c7124903cd4c716d0b7af4" translate="yes" xml:space="preserve">
          <source>You can implement private members through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; but instance specific private members can only be accessed by functions that are not on the prototype.</source>
          <target state="translated">您可以通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;闭包&lt;/a&gt;来实现私有成员，但是特定于实例的私有成员只能由不在原型上的函数访问。</target>
        </trans-unit>
        <trans-unit id="307959edcb48ff33b2f62e2ee949b4df46321abd" translate="yes" xml:space="preserve">
          <source>You can indicate to other programmers a member is meant to be private by naming it &lt;code&gt;_aPrivate&lt;/code&gt; or putting all the private variables in an object variable called &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">您可以通过将其他成员命名为 &lt;code&gt;_aPrivate&lt;/code&gt; 或将所有私有变量放入称为 &lt;code&gt;_&lt;/code&gt; 的对象变量中，从而向其他程序员表明该成员是私有成员。</target>
        </trans-unit>
        <trans-unit id="62d5c1874c396599b4b5ab6617f2c4fbfc040617" translate="yes" xml:space="preserve">
          <source>You can use a function as a constructor to create objects, if the constructor function is named Person then the object(s) created with that constructor are instances of Person.</source>
          <target state="translated">你可以使用一个函数作为构造函数来创建对象,如果构造函数名为Person,那么使用该构造函数创建的对象就是Person的实例。</target>
        </trans-unit>
        <trans-unit id="1e4718352a5ddbc9ba763c0a0a57cbf4ee7d57b4" translate="yes" xml:space="preserve">
          <source>You may come across similar patterns that are more robust to help with object creation and object definition.</source>
          <target state="translated">你可能会遇到类似的模式,对对象创建和对象定义有更强的帮助。</target>
        </trans-unit>
        <trans-unit id="03c004c041a8ade78e5fa468755470e910975a73" translate="yes" xml:space="preserve">
          <source>You want the 'child' (=RussionMini) to do something extra. When RussionMini can call the Hamster code to do something and then do something extra you don't need to copy and paste Hamster code to RussionMini.</source>
          <target state="translated">你想让 &quot;孩子&quot;(=RussionMini)做一些额外的事情。当RussionMini可以调用Hamster代码来做一些事情,然后做一些额外的事情,你不需要复制并粘贴Hamster代码到RussionMini。</target>
        </trans-unit>
        <trans-unit id="ed3bcead2d06b24e9a79e412965282dc663fdf5e" translate="yes" xml:space="preserve">
          <source>we run &lt;code&gt;rabbit.eat&lt;/code&gt;, which changes &lt;code&gt;rabbit.full&lt;/code&gt;. &lt;code&gt;full&lt;/code&gt; property is nowhere to be found, so it should go up the prototype chain to (to object??), and well, I'm not sure what happens here. In this example the property &lt;code&gt;full&lt;/code&gt; of &lt;code&gt;rabbit&lt;/code&gt; is created and changed, while in the first example it goes up the prototype chain because it cannot find the property.</source>
          <target state="translated">我们运行 &lt;code&gt;rabbit.eat&lt;/code&gt; ，这将更改 &lt;code&gt;rabbit.full&lt;/code&gt; 。 找不到 &lt;code&gt;full&lt;/code&gt; 属性，因此应该将原型链向上（到达对象？），而且，我不确定这里会发生什么。 在此示例中，创建并更改了 &lt;code&gt;full&lt;/code&gt; &lt;code&gt;rabbit&lt;/code&gt; 的属性，而在第一个示例中，由于找不到属性，它沿着原型链向上移动。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
