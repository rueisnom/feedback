<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/16063394">
    <body>
      <group id="16063394">
        <trans-unit id="74cf125fecd9be94bfb57de2381f05816742688b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Multiple inheritance&quot; with mix ins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;믹스 인을 사용한 &quot;다중 상속&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f60012486871de55c32083b7c52aef92ab1d2228" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function introduction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;생성자 함수 소개&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="464c26fcf651c9497932220210a67991e239e32a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extending and overriding Parent functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부모 함수 확장 및 재정의&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7422920ac45432c6122783701aa363fe96aaf2b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Inheritance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091e6370d4f77a8fb1c6e19fd7ffd43862df251e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More about prototype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로토 타입에 대한 추가 정보&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="905e17e869df8f106b1d829cc87a51393ce68750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object.create to set prototype part of inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;상속의 프로토 타입 부분을 설정하기위한 Object.create&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5cbcd9b4b225cb9887c626d6879881f3ae6eded" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing (constructor) arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전달자 (생성자) 인수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ee7541772d496e52c1e2bd3a4d436dc1e23236e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private variables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;개인 변수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b58eaa69cc21de153eaf2108e426b123ef846c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The this variable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 변수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24127a0a55a2a41dda788b7ff3a0a8ecd74bbf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.constructor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2c84fbef3dfee70da18aa5795b9c02c1f412822" translate="yes" xml:space="preserve">
          <source>An object can inherit from another object through the use of prototype. You can set the prototype of any object with any other object using &lt;code&gt;Object.create&lt;/code&gt;. In the constructor function introduction we have seen that if a member can't be found on the object then JavaScript will look in the prototpe chain for it.</source>
          <target state="translated">프로토 타입을 사용하여 객체를 다른 객체에서 상속 할 수 있습니다. &lt;code&gt;Object.create&lt;/code&gt; 를 사용하여 다른 객체와 함께 객체의 프로토 타입을 설정할 수 있습니다. 생성자 함수 소개에서 객체에서 멤버를 찾을 수 없으면 JavaScript가 프로토 타입 체인을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="cbe7e26021ebaa520f3f0662be1d2cd9e0ac3e41" translate="yes" xml:space="preserve">
          <source>Another reason could be that to create a Hamster a lot of complicated calculations need be done on passed arguments that may be not available yet, again you could pass in dummy arguments but it could unnecessarily complicate your code.</source>
          <target state="translated">또 다른 이유는 Hamster를 만들려면 아직 사용할 수없는 전달 된 인수에 대해 복잡한 계산을 많이 수행해야하기 때문에 더미 인수를 전달할 수 있지만 불필요하게 코드가 복잡해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17fe45dfada0a306c0914b347e348b9ca0852b5" translate="yes" xml:space="preserve">
          <source>BUT in Example 1 something else happens:</source>
          <target state="translated">그러나 예 1의 다른 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ee710d2c9f34cfc2049bc5cdbb2fb193e95ac12" translate="yes" xml:space="preserve">
          <source>Because walk() could not be found on bob directly JavaScript will look for it in the Person.prototype as this is the constructor of bob. If it can't be found there it'll look on Object.prototype. This is called the prototype chain. The prototype part of inheritance is done by lengthening this chain; for example bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (more on inheritance later).</source>
          <target state="translated">bob에서 walk ()를 직접 찾을 수 없으므로 JavaScript는 Person.prototype에서 bob의 생성자이므로이를 찾습니다. 찾을 수 없으면 Object.prototype을 찾습니다. 이것을 프로토 타입 체인이라고합니다. 상속의 프로토 타입 부분은이 체인을 길게하여 수행됩니다. 예를 들어 bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (나중에 상속에 대한 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="b12c833356fce30b677bb5007b4eca7f1cf9586b" translate="yes" xml:space="preserve">
          <source>By using closures you do not give others a choice and by using the naming convention with documentation you do. This is not specific to JavaScript, in other languages you can decide not to use private members as you trust others to know what they are doing and give them the choice to do as they want (with risks involved).</source>
          <target state="translated">클로저를 사용하면 다른 사람에게 선택권을 부여하지 않으며 문서와 함께 명명 규칙을 사용합니다. 이것은 JavaScript에만 국한된 것이 아니며 다른 언어에서는 다른 사람들이 자신이하는 일을 알고 자신이 원하는대로 (위험을 수반 함) 할 수있는 선택권을 줄 때 비공개 회원을 사용하지 않기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e7bf94fdffad6556b22447c07ca6a043f61d30" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 1 and for objects that inherit have them run the Parent code as well (Hamster.apply(this,arguments);)</source>
          <target state="translated">1 단계에서 코드를 실행하는 인스턴스를 만들고 상속되는 객체의 경우 부모 코드도 실행합니다 (Hamster.apply (this, arguments);)</target>
        </trans-unit>
        <trans-unit id="9cafc324364ac8f9b0b7fbc766cc44ec930d2327" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 2.</source>
          <target state="translated">2 단계에서 코드를 실행하는 인스턴스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bab01f763c8928cbac3d62d6a5f840594c8f828b" translate="yes" xml:space="preserve">
          <source>Define an object that has members that will be same for many instances (person is a blueprint for bob and ben and can be for jilly, marie, clair ...)</source>
          <target state="translated">많은 인스턴스에 대해 동일한 멤버가있는 오브젝트를 정의하십시오 (사람은 bob 및 ben의 청사진이며 jilly, marie, clair ...).</target>
        </trans-unit>
        <trans-unit id="0369ebd98eda3b5d7bf11c618aea1f74bd1b7cd8" translate="yes" xml:space="preserve">
          <source>Define instance specific members of an object (functions Hamster and RussionMini).</source>
          <target state="translated">객체의 인스턴스 특정 멤버 (함수 Hamster 및 RussionMini)를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="15a6e2970bdac2aa16360ffbe8c78946b52ff0eb" translate="yes" xml:space="preserve">
          <source>Define instance specific members that should be unique for instances (bob and ben).</source>
          <target state="translated">인스턴스 (bob 및 ben)에 고유해야하는 인스턴스 특정 멤버를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="f0566c177d01aa7ea879a7591493f45ebcd632b6" translate="yes" xml:space="preserve">
          <source>Define members that can be shared among instances.(Hamster.prototype and RussionMini.prototype)</source>
          <target state="translated">인스턴스간에 공유 할 수있는 멤버를 정의하십시오 (Hamster.prototype 및 RussionMini.prototype)</target>
        </trans-unit>
        <trans-unit id="1cc64015257eb076b900848a79305e97c1168f09" translate="yes" xml:space="preserve">
          <source>Even though bob, ben and all other created Person instances share walk the function will behave differently per instance because in the walk function it uses &lt;code&gt;this&lt;/code&gt;. The value of &lt;code&gt;this&lt;/code&gt; will be the invoking object; for now let's say it's the current instance so for &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot; will be bob. (more on &quot;this&quot; and the invoking object later).</source>
          <target state="translated">bob, ben 및 기타 모든 생성 된 Person 인스턴스 공유 walk이지만 walk 함수에서는 &lt;code&gt;this&lt;/code&gt; 를 사용하기 때문에 함수가 인스턴스마다 다르게 동작 합니다 . 이것의 값은 호출 객체가 될 것입니다. 지금은 그것이 현재 인스턴스라고하자. &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot;는 bob이 될 것이다. ( &quot;this&quot;및 나중에 호출 오브젝트에 대한 추가 정보).</target>
        </trans-unit>
        <trans-unit id="8829ee8adb882bc56fe22bb8afb9246c1e8abb66" translate="yes" xml:space="preserve">
          <source>Every instance of Hamster will share that array</source>
          <target state="translated">햄스터의 모든 인스턴스는 해당 배열을 공유합니다</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">예 1 :</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">예 2 :</target>
        </trans-unit>
        <trans-unit id="d74d95fa8fca84cad0d34ec6afae31477e7ee53f" translate="yes" xml:space="preserve">
          <source>For Movable we have instance specific members (like &lt;code&gt;location&lt;/code&gt;). And we have members that are not instance specific (like the function move()). Instance specific members will be set by calling mxIns (added by mixin helper function) when creating an instance. Prototype members will be copied one by one on Cat.prototype from Movable.prototype using the mixin helper function.</source>
          <target state="translated">움직일 수 있도록 인스턴스 특정 멤버 ( &lt;code&gt;location&lt;/code&gt; 과 같은)가 있습니다. 그리고 우리는 move () 함수처럼 인스턴스에 특정한 멤버가 없습니다. 인스턴스 별 멤버는 인스턴스를 생성 할 때 mxIns (mixin helper 함수로 추가)를 호출하여 설정됩니다. 프로토 타입 멤버는 mixin 도우미 함수를 사용하여 Movable.prototype의 Cat.prototype에서 하나씩 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d4034236af5962aabc90bc340970cf5500bed73f" translate="yes" xml:space="preserve">
          <source>From this I understand, that when writing up and adding a new property which doesn't exist, the interpreter will go up the prototype chain until it finds the property, and THEN change it.</source>
          <target state="translated">이것으로부터 나는 존재하지 않는 새로운 속성을 작성하고 추가 할 때, 인터프리터는 속성을 찾을 때까지 프로토 타입 체인을 올라가서 변경할 수 있다는 것을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="c6720ee66246445f87a7ba9b7c392e804525fab2" translate="yes" xml:space="preserve">
          <source>Here is the documentation about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;, it basically returns the second argument (not supported in the polyfil) with the first argument as the returned object's prototype.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; 에 대한 문서는 기본적으로 두 번째 인수 (polyfil에서 지원되지 않음)를 반환 된 객체의 프로토 타입으로 첫 번째 인수와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e848ec5629ff1294871791ebbf63e38cc2338e10" translate="yes" xml:space="preserve">
          <source>I agree with the following: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; and personally have not used them.</source>
          <target state="translated">나는 다음에 동의합니다 : &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; 개인적으로 사용하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cbe2e3d4e71526c44ee323b9c2c5afb89e673b0d" translate="yes" xml:space="preserve">
          <source>I like to define functions that return a function for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; on the prototype to have fine control over the variables that are included in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; scope.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;클로저&lt;/a&gt; 범위에 포함 된 변수를 정밀하게 제어 할 수 있도록 프로토 타입에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;클로저&lt;/a&gt; 에 대한 함수를 반환하는 함수를 정의하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="51d29e872f0afd793829823b2b7b80ebb354988c" translate="yes" xml:space="preserve">
          <source>I usually pass one object to a function and have that function mutate whatever it needs (set defaults), then that function will pass it to another function that will do the same and so on and so on. Here is an example:</source>
          <target state="translated">나는 보통 하나의 객체를 함수에 전달하고 그 함수가 필요한 모든 것을 변경하게하고 (기본값 설정) 그 함수는 그것을 동일하게 수행하는 다른 함수로 전달합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1c56435bb8295e877cc0c85c18aa7f843177ad" translate="yes" xml:space="preserve">
          <source>I'm confused and cannot see why this happens.</source>
          <target state="translated">혼란스럽고 왜 이런 일이 발생하는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fde27a0f508ac6064af12c4d8b939650e52d74e9" translate="yes" xml:space="preserve">
          <source>If after setting prototype part of inheritance you should have it point to the right function again.</source>
          <target state="translated">상속의 프로토 타입 부분을 설정 한 후에는 올바른 기능을 다시 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="da522a6c41073e7a1c23b91110e0ce440840c41f" translate="yes" xml:space="preserve">
          <source>If ben was waiting for a red light and and bob was at a green light; then you'll invoke walk() on both ben and bob obviously something different would happen to ben and bob.</source>
          <target state="translated">벤이 붉은 빛을 기다리고 있었고 밥이 초록 빛에 있다면; 그런 다음 ben과 bob 모두에서 walk ()를 호출하면 분명히 ben과 bob에 다른 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="11e4a4b87d427e615f87bbb7d7d0b5574e9d0999" translate="yes" xml:space="preserve">
          <source>If no second argument was given it'll return an empty object with first argument to be used as the returned object's prototype (the first object to be used in the returned object's prototype chain).</source>
          <target state="translated">두 번째 인수가 주어지지 않으면 반환 된 객체의 프로토 타입 (반환 된 객체의 프로토 타입 체인에서 사용되는 첫 번째 객체)으로 사용할 첫 번째 인수와 함께 빈 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45326f667c3b7dd729de1fff54fe465ea292ec6c" translate="yes" xml:space="preserve">
          <source>If you need (and you do in this case) separate instances of food collections for each Hamster, you need to create the property on the instance. For example:</source>
          <target state="translated">각 햄스터에 대해 별도의 음식 모음 인스턴스가 필요한 경우 (및이 경우) 인스턴스에서 속성을 만들어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf65b3d11ae75642ecded1c9d1c19caac84c3201" translate="yes" xml:space="preserve">
          <source>If you still insist on privates then the &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;following&lt;/a&gt; pattern may help. It doesn't implement private though but implements protected.</source>
          <target state="translated">여전히 개인을 고집하는 경우 &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;다음&lt;/a&gt; 패턴이 도움이 될 수 있습니다. 개인은 구현하지 않지만 보호는 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b79b7554eff5c5557c88dc8d14f691a2491ed888" translate="yes" xml:space="preserve">
          <source>In all the example code you'll see &lt;code&gt;this&lt;/code&gt; referring to the current instance.</source>
          <target state="translated">모든 예제 코드에서 현재 인스턴스를 나타내는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c51dd0d86d782b26cf283ada041cd94af0aa189e" translate="yes" xml:space="preserve">
          <source>In previous part we have seen that re assignment of members that come from an instance's prototype (ben.walk) will shadow that member (create walk on ben rather than changing Person.prototype.walk).</source>
          <target state="translated">이전 부분에서 인스턴스 프로토 타입 (ben.walk)에서 온 멤버를 다시 할당하면 해당 멤버가 섀도 잉됩니다 (Person.prototype.walk를 변경하지 않고 벤에서 워크를 생성 함).</target>
        </trans-unit>
        <trans-unit id="bd9ce7cacb78c648c9be29a9cf9471ae22e833f0" translate="yes" xml:space="preserve">
          <source>In the following example we assume that a Hamster can run 3km an hour but a Russion mini can only run half as fast. We can hard code 3/2 in RussionMini but if this value were to change we have multiple places in code where it needs changing. Here is how we use Hamster.prototype to get the parent (Hamster) speed.</source>
          <target state="translated">다음 예에서 햄스터는 한 시간에 3km를 달릴 수 있지만 Russion 미니는 절반 만 달릴 수 있다고 가정합니다. RussionMini에서 3/2를 하드 코딩 할 수 있지만이 값이 변경되면 코드에서 변경해야하는 여러 위치가 있습니다. 다음은 Hamster.prototype을 사용하여 부모 (Hamster) 속도를 얻는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="968367429f9ee5051fb4a6a3e36c91706fe020f5" translate="yes" xml:space="preserve">
          <source>In this code I have removed name from prototype as well as food because you are most likely going to shadow this almost immediately when creating an instance anyway. Name is now an instance specific member with a default value set in the constructor function. Becaus the food member is also moved from prototype to instance specific member it will not affect bob.food when adding food to ben.</source>
          <target state="translated">어쨌든 인스턴스를 만들 때 거의 즉시 그림자를 만들 가능성이 높기 때문에이 코드에서 프로토 타입과 음식에서 이름을 제거했습니다. 이름은 이제 생성자 함수에 기본값이 설정된 인스턴스 별 멤버입니다. 음식 멤버도 프로토 타입에서 인스턴스 특정 멤버로 이동하기 때문에 벤에 음식을 추가 할 때 bob.food에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="782c9829c985ba325100f3f912e7b73c3cc8a8d2" translate="yes" xml:space="preserve">
          <source>It's good because it enables you and others to mock certain members for testing easily. It gives others a chance to easily improve (patch) your code but this is also bad because there is no guarantee that a next version of your code has the same implementation and or private members.</source>
          <target state="translated">그것은 당신과 다른 사람들이 쉽게 테스트하기 위해 특정 회원을 조롱 할 수 있기 때문에 좋습니다. 다른 사람들이 코드를 쉽게 개선 (패치) 할 수있는 기회를 제공하지만 다음 버전의 코드가 동일한 구현 및 / 또는 개인 멤버를 가지고 있다는 보장이 없기 때문에 이것은 나쁘다.</target>
        </trans-unit>
        <trans-unit id="8a6c3b4d25a0b9e7b9de12cbedcc883a943f7193" translate="yes" xml:space="preserve">
          <source>JavaScript doesn't have a private modifier.</source>
          <target state="translated">JavaScript에는 전용 수정자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4783878a60c2e2bedc9c4cb15e63c2cad8e91a8" translate="yes" xml:space="preserve">
          <source>Most of the patterns I've seen will either break when inheritance level is more than 2 levels (Child =&amp;gt; Parent =&amp;gt; GrandParent) or use more resources by implementing super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt;.</source>
          <target state="translated">내가 본 대부분의 패턴은 상속 레벨이 2 레벨 이상일 때 깨지거나 (Child =&amp;gt; Parent =&amp;gt; GrandParent) super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; 를 구현하여 더 많은 리소스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a86491f8b298b8b31ba2a6f4824cc3d924e08dba" translate="yes" xml:space="preserve">
          <source>Not implementing privates as closures would leak implementation and enable you or users extending your code to use members that are not part of your public API. This can be both good and bad.</source>
          <target state="translated">클로저로 비공개를 구현하지 않으면 구현이 누출되고 귀하 또는 사용자가 코드를 확장하여 퍼블릭 API의 일부가 아닌 멤버를 사용할 수 있습니다. 이것은 좋고 나쁠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="554811e64329329de8e99177229051265f514851" translate="yes" xml:space="preserve">
          <source>Person is the constructor function. When you create an instance using Person you have to use the new keyword:</source>
          <target state="translated">Person은 생성자 함수입니다. Person을 사용하여 인스턴스를 만들 때는 새로운 키워드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d400767e83f5b3545ee60adf2bcccde144b2840" translate="yes" xml:space="preserve">
          <source>Prototypes are &lt;strong&gt;NOT&lt;/strong&gt; instantiated for each instance of an object.</source>
          <target state="translated">프로토 타입은 객체의 각 인스턴스에 대해 인스턴스화 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cceb329f51a30a7a00183d2d4ed1d0655073e080" translate="yes" xml:space="preserve">
          <source>Prototypical inheritance - writing up</source>
          <target state="translated">프로토 타입 상속-작성</target>
        </trans-unit>
        <trans-unit id="64b8741afff5b09a35196deea479694b320fa7af" translate="yes" xml:space="preserve">
          <source>Set the prototype part of inheritance (RussionMini.prototype = Object.create(Hamster.prototype))</source>
          <target state="translated">상속의 프로토 타입 부분 설정 (RussionMini.prototype = Object.create (Hamster.prototype))</target>
        </trans-unit>
        <trans-unit id="4b07cce27e263241a4a74f241d33c0a5433426cd" translate="yes" xml:space="preserve">
          <source>Shadowing members happens when we do something like &lt;code&gt;ben.walk=22&lt;/code&gt;, even though bob and ben share &lt;code&gt;walk&lt;/code&gt; the &lt;em&gt;assignment&lt;/em&gt; of 22 to ben.walk will not affect bob.walk. This is because that statement will create a member called &lt;code&gt;walk&lt;/code&gt; on ben directly and assign it a value of 22. There will be 2 different walk members: ben.walk and Person.prototype.walk.</source>
          <target state="translated">bob 및 ben share &lt;code&gt;walk&lt;/code&gt; 에 22를 ben.walk로 지정해도 bob.walk에 영향을 미치지 않더라도 &lt;code&gt;ben.walk=22&lt;/code&gt; 와 같은 작업을 수행 할 때 섀도 잉 멤버가 발생합니다. 이는 해당 명령문이 ben에서 &lt;code&gt;walk&lt;/code&gt; 라는 멤버를 직접 작성하고 22의 값을 지정하기 때문입니다. ben.walk와 Person.prototype.walk의 두 가지 다른 워크 멤버가 있습니다.</target>
        </trans-unit>
        <trans-unit id="525b7ccb7b92ac04a16fabaf6a882aee1fe90b3c" translate="yes" xml:space="preserve">
          <source>So I have these 2 examples, from javascript.info:</source>
          <target state="translated">그래서 javascript.info 에서이 두 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea63f6cce56c9eca2d72522f3a7e51c6996b13a" translate="yes" xml:space="preserve">
          <source>Some things are better not to be inherited, if a Cat can move and then a Cat should not inherit from Movable. A Cat is not a Movable but rather a Cat can move. In a class based language Cat would have to implement Movable. In JavaScript we can define Movable and define implementation here, Cat can either override, extend it or us it's default implementation.</source>
          <target state="translated">고양이가 움직일 수 있고 고양이가 움직일 수 없다면 상속받지 않는 것이 더 좋습니다. 고양이는 움직일 수있는 것이 아니라 고양이가 움직일 수 있습니다. 클래스 기반 언어에서 Cat은 Movable을 구현해야합니다. JavaScript에서 Movable을 정의하고 여기에서 구현을 정의 할 수 있습니다. Cat은이를 재정의하거나 확장하거나 기본 구현입니다.</target>
        </trans-unit>
        <trans-unit id="ef53d380cd63d69c06e94e9adfd7ea3d789beae8" translate="yes" xml:space="preserve">
          <source>Some would set the prototype of RussionMini to an instance of Hamster (RussionMini.prototype = new Hamster()). This is not desirable because even though it accomplishes the same (RussionMini.prototype's prototype is Hamster.prototype) it also sets Hamster instance members as members of RussionMini.prototype. So RussionMini.prototype.food will exist but is a shared member (remember bob and ben in &quot;More about prototype&quot;?). The food member will be shadowed when creating a RussionMini because Hamster code is run with &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; that in turn runs &lt;code&gt;this.food = []&lt;/code&gt; but any Hamster members will still be members of RussionMini.prototype.</source>
          <target state="translated">일부는 RussionMini의 프로토 타입을 Hamster 인스턴스 (RussionMini.prototype = new Hamster ())로 설정했습니다. 이는 동일한 결과 (RussionMini.prototype의 프로토 타입은 Hamster.prototype 임)를 달성하더라도 Hamster 인스턴스 멤버를 RussionMini.prototype의 멤버로 설정하기 때문에 바람직하지 않습니다. 따라서 RussionMini.prototype.food는 존재하지만 공유 멤버입니다 ( &quot;prototype에 대한 추가 정보&quot;에서 bob 및 ben을 기억하십니까?). Hamster 코드가 &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; 실행되므로 RussionMini를 만들 때 음식 구성원이 음영 처리됩니다 . 그 결과 &lt;code&gt;this.food = []&lt;/code&gt; 가 실행되지만 Hamster 멤버는 여전히 RussionMini.prototype의 멤버가됩니다.</target>
        </trans-unit>
        <trans-unit id="603053b2f1c406cdc9f1aba516ab35aa5644c02a" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;children&lt;/code&gt; need to extend &lt;code&gt;parent&lt;/code&gt; functions.</source>
          <target state="translated">때때로 &lt;code&gt;children&lt;/code&gt; 들은 &lt;code&gt;parent&lt;/code&gt; 기능을 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc46bcd4a8dbc5cd0a9473c19363d38ae051b890" translate="yes" xml:space="preserve">
          <source>Start from Example 2: when the code reaches &lt;code&gt;speedy.found&lt;/code&gt;, it finds no &lt;code&gt;found&lt;/code&gt; property in &lt;code&gt;speedy&lt;/code&gt;, and so it climbs up to the prototype and changes it there. That's why &lt;code&gt;food.length&lt;/code&gt; is equal for both hamsters, in other words they have the same stomach.</source>
          <target state="translated">예제 2 : 코드가 &lt;code&gt;speedy.found&lt;/code&gt; 에 도달하면 speedy 에서 &lt;code&gt;found&lt;/code&gt; 속성을 찾지 못하므로 프로토 타입으로 올라가서 변경합니다. 그렇기 때문에 두 햄스터 모두 &lt;code&gt;food.length&lt;/code&gt; 가 동일합니다. 즉, 같은 위를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5ef60e0f791800e4f9fe96e6386ddd31add8b0" translate="yes" xml:space="preserve">
          <source>The above is a simple implementation that replaces same named functions with whatever mix in is mixed in last.</source>
          <target state="translated">위의 동일한 명명 된 함수를 마지막에 혼합 된 혼합으로 바꾸는 간단한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="91886ea4946327cd43e989ed9081a401237a0d2d" translate="yes" xml:space="preserve">
          <source>The code above shows that ben and bob share members from person. There is only one person, it is set as bob's and ben's prototype (person is used as the first object in the prototype chain to look up requested members that don't exist on the instance). The problem with the above code is that bob and ben should have their own &lt;code&gt;food&lt;/code&gt; member. This is where the constructor function comes in. It is used to create instance specific members. You could also pass arguments to it to set values of these instance specific members.</source>
          <target state="translated">위의 코드는 벤과 밥이 사람의 구성원을 공유한다는 것을 보여줍니다. 사람은 한 명 뿐이며 bob 및 ben의 프로토 타입으로 설정됩니다 (사람은 프로토 타입 체인에서 첫 번째 오브젝트로 사용되어 인스턴스에 존재하지 않는 요청 된 멤버를 찾습니다). 위의 코드의 문제점은 bob과 ben에 자체 &lt;code&gt;food&lt;/code&gt; 구성원이 있어야한다는 것입니다. 생성자 함수가 나오는 곳입니다. 인스턴스 특정 멤버를 만드는 데 사용됩니다. 이러한 인스턴스 특정 멤버의 값을 설정하기 위해 인수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce16836f76cd9e02bb10ce77133484da4db12749" translate="yes" xml:space="preserve">
          <source>The constructor property is included in the prototype by JavaScript, you can change it but it should point to the constructor function. So &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; should point to Hamster.</source>
          <target state="translated">생성자 속성은 JavaScript에 의해 프로토 타입에 포함되며 변경할 수 있지만 생성자 함수를 가리켜 야합니다. 따라서 &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; 는 Hamster를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="ba2e7bfbfcc3ebee3a82668a2127dadc5a3a614c" translate="yes" xml:space="preserve">
          <source>The disadvantage is that you hard code Hamster.prototype. There may be patterns that will give you the advantage of &lt;code&gt;super&lt;/code&gt; as in Java.</source>
          <target state="translated">단점은 Hamster.prototype을 하드 코딩한다는 것입니다. Java에서와 같이 &lt;code&gt;super&lt;/code&gt; 의 이점을 제공하는 패턴이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f31cb3709425be0a6f04c9d6a8e9bae7b0bdf4" translate="yes" xml:space="preserve">
          <source>The following code demonstrates the difference between prototype members and instance members by mutating members.</source>
          <target state="translated">다음 코드는 멤버를 변경하여 프로토 타입 멤버와 인스턴스 멤버의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="92d7047ac0b211ef42fa97b41187517206e5a323" translate="yes" xml:space="preserve">
          <source>The following code shows how to inherit. The tasks are basically the same as in code before with a little extra</source>
          <target state="translated">다음 코드는 상속하는 방법을 보여줍니다. 작업은 기본적으로 코드에서와 약간 동일하며 약간 더 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b31cca01cbdf5bb975254cb59ea3db82b273ae80" translate="yes" xml:space="preserve">
          <source>The instances where this would refer to the wrong object are usually when attaching event listeners, callbacks or timeouts and intervals. In the next 2 lines of code we &lt;code&gt;pass&lt;/code&gt; the function, we don't invoke it. Passing the function is: &lt;code&gt;someObject.aFunction&lt;/code&gt; and invoking it is: &lt;code&gt;someObject.aFunction()&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value does not refer to the object the function was declared on but on the object that &lt;code&gt;invokes&lt;/code&gt; it.</source>
          <target state="translated">이것이 잘못된 객체를 참조하는 인스턴스는 일반적으로 이벤트 리스너, 콜백 또는 시간 초과 및 간격을 연결할 때입니다. 다음 두 줄의 코드에서 함수를 &lt;code&gt;pass&lt;/code&gt; 하면 호출하지 않습니다. 함수 전달은 &lt;code&gt;someObject.aFunction&lt;/code&gt; 이고 호출은 &lt;code&gt;someObject.aFunction()&lt;/code&gt; 입니다. &lt;code&gt;this&lt;/code&gt; 값은 함수가 선언 된 개체가 아니라 해당 개체를 &lt;code&gt;invokes&lt;/code&gt; 하는 개체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d633be38865f4cc00308b578d502e60cb128ba2" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;walk&lt;/code&gt; is part of Person.prototype and is shared for all instances bob and ben are instances of Person so they share the walk member (bob.walk===ben.walk).</source>
          <target state="translated">멤버 &lt;code&gt;walk&lt;/code&gt; 는 Person.prototype의 일부이며 모든 인스턴스에 대해 공유됩니다. bob 및 ben은 Person의 인스턴스이므로 워크 멤버를 공유합니다 (bob.walk === ben.walk).</target>
        </trans-unit>
        <trans-unit id="6b7f455cf9ed0f3eee5f17e212f56a94f50505d9" translate="yes" xml:space="preserve">
          <source>The next code shows another way to implement the constructor function, syntax is different but the idea is the same:</source>
          <target state="translated">다음 코드는 생성자 함수를 구현하는 다른 방법을 보여줍니다. 구문은 다르지만 아이디어는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="68b7a276695cb91b3cc1a5a46c42b89c5d2e1bc4" translate="yes" xml:space="preserve">
          <source>The property/member &lt;code&gt;name&lt;/code&gt; is instance specific, it's different for bob and ben</source>
          <target state="translated">속성 / 멤버 &lt;code&gt;name&lt;/code&gt; 은 인스턴스별로 다르며 bob 및 ben마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="34bac27fdaa771c107c0ae1ee0c876c8cccc0390" translate="yes" xml:space="preserve">
          <source>The this variable actually refers to the invoking object, it refers to the object that came before the function.</source>
          <target state="translated">이 변수는 실제로 호출 객체를 나타내며 함수 앞에 온 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dbeae5adf6a2e7873a50962c48c4d2650e1cad7a" translate="yes" xml:space="preserve">
          <source>This way of passing arguments in a function chain is useful in many cases. When you're working on code that would calculate a total of something and later you'd like to re factor the total of that something to be in a certain currency you may have to change a lot of functions to pass the value for currency. You could up scope a currency value (even to global like &lt;code&gt;window.currency='USD'&lt;/code&gt;) but that's a bad way to solve it.</source>
          <target state="translated">함수 체인에서 인수를 전달하는이 방법은 많은 경우에 유용합니다. 총계를 계산하는 코드를 작업 할 때 특정 통화로 총계를 리팩토링하려는 경우 통화 값을 전달하기 위해 많은 기능을 변경해야 할 수도 있습니다. &lt;code&gt;window.currency='USD'&lt;/code&gt; 와 같이 통화 값의 범위를 넓힐 수는 있지만 그것을 해결하는 나쁜 방법입니다.</target>
        </trans-unit>
        <trans-unit id="881d70367fb2cb9071aabd702a8ddae76085a077" translate="yes" xml:space="preserve">
          <source>To answer your question about Example 1, if it doesn't find the property anywhere in the prototype chain, it creates the property on the target object.</source>
          <target state="translated">예제 1에 대한 질문에 대답하기 위해 프로토 타입 체인에서 속성을 찾지 못하면 대상 객체에 속성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="caa724d08d862109a2da38689f2332f1ce655618" translate="yes" xml:space="preserve">
          <source>To clarify see the following code:</source>
          <target state="translated">명확히하려면 다음 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa3de1fe95879c2e0e06bbcc67ffb2a5a9cacd6" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;this&lt;/code&gt; in the above cases refer to someObject you can pass a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; instead of the function directly:</source>
          <target state="translated">위의 경우에 이것을 만들려면 someObject를 참조하십시오. 함수 대신 직접 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;클로저&lt;/a&gt; 를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95908275067ede0cb508056464f5d825f362df1f" translate="yes" xml:space="preserve">
          <source>To override a Parent (=Hamster) method you do the same but don't do Hamster.prototype.parentMethod.call(this,....</source>
          <target state="translated">Parent (= Hamster) 메서드를 재정의하려면 동일하게 수행하지만 Hamster.prototype.parentMethod.call (this, ....)은 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="30981a69967a6193b8f04b92e8a40f2bd4f43877" translate="yes" xml:space="preserve">
          <source>Using a pattern some would call &quot;classical inheritance&quot;. If you are confused by the syntax I'll be happy to explain more or provide different patterns.</source>
          <target state="translated">패턴을 사용하면 &quot;클래식 상속&quot;이라고합니다. 구문이 혼란 스러우면 더 설명하거나 다른 패턴을 제공하게되어 기쁩니다.</target>
        </trans-unit>
        <trans-unit id="9d15948c93f4b3b1f746c221caff8d64929f5020" translate="yes" xml:space="preserve">
          <source>What if we don't re assign but mutate the member? Mutating is (for example) changing sub properties of an Object or invoking functions that will change the object's value. For example:</source>
          <target state="translated">멤버를 다시 할당하지 않고 멤버를 변경하면 어떻게 되나요? 예를 들어, 음소거는 개체의 하위 속성을 변경하거나 개체의 값을 변경하는 함수를 호출하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d72ec19dd58257fe3e8938b8afc236576f1071ab" translate="yes" xml:space="preserve">
          <source>When Child calls a Parent (&lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt;) we assume that Hamster uses the same arguments as RussionMini in the same order. For functions that call other functions I usually use another way to pass arguments.</source>
          <target state="translated">Child가 부모 ( &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; )를 호출 할 때 Hamster는 RussionMini와 동일한 인수를 동일한 순서로 사용한다고 가정합니다. 다른 함수를 호출하는 함수의 경우 일반적으로 인수를 전달하는 다른 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a8948d65f6b2ed854bc435e20bd64c244a77252" translate="yes" xml:space="preserve">
          <source>When asking for bob.walk you'll get the Person.prototype.walk function because &lt;code&gt;walk&lt;/code&gt; could not be found on bob. Asking for ben.walk however will get you the value 22 because the member walk has been created on ben and since JavaScript found walk on ben it will not look in the Person.prototype.</source>
          <target state="translated">bob.walk를 요청하면 bob에서 &lt;code&gt;walk&lt;/code&gt; 찾을 수 없기 때문에 Person.prototype.walk 기능을 사용할 수 있습니다. 그러나 ben.walk를 요청하면 멤버 워크가 ben에서 작성되었으므로 JavaScript가 ben에서 walk를 찾은 이후 Person.prototype을 찾지 않으므로 값 22를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="dbae9f24b1b441346037a1a711472938fe1b0cdb" translate="yes" xml:space="preserve">
          <source>When using Object.create with 2 arguments, Object.defineProperty or Object.defineProperties shadowing works a bit different. More info on that &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">두 개의 인수와 함께 Object.create를 사용하는 경우 Object.defineProperty 또는 Object.defineProperties 섀도 잉은 약간 다르게 작동합니다. &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;여기&lt;/a&gt; 에 더 많은 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="944b2bf97bd3b09291debcbebf9c539ec6b669f8" translate="yes" xml:space="preserve">
          <source>With constructor functions you'll set the prototype in step 2 in the following code we set the prototype in step 3.</source>
          <target state="translated">생성자 함수를 사용하면 다음 코드에서 2 단계에서 프로토 타입을 설정하고 3 단계에서 프로토 타입을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9298f1163ca32f5e167b7c0302b9ad1b3d88a666" translate="yes" xml:space="preserve">
          <source>With passing an object you could add currency to &lt;code&gt;args&lt;/code&gt; whenever it's available in the function chain and mutate/use it whenever you need it without changing the other functions (explicitly have to pass it in the function calls).</source>
          <target state="translated">객체를 전달하면 함수 체인에서 사용할 수있을 때마다 &lt;code&gt;args&lt;/code&gt; 에 통화를 추가하고 다른 함수를 변경하지 않고 필요할 때마다 변경 / 사용할 수 있습니다 (명시 적으로 함수 호출에 전달해야 함).</target>
        </trans-unit>
        <trans-unit id="837db40af571b967b8c7124903cd4c716d0b7af4" translate="yes" xml:space="preserve">
          <source>You can implement private members through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; but instance specific private members can only be accessed by functions that are not on the prototype.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;클로저를&lt;/a&gt; 통해 프라이빗 멤버를 구현할 수 있지만 프로토 타입에없는 함수 만 인스턴스 특정 프라이빗 멤버에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="307959edcb48ff33b2f62e2ee949b4df46321abd" translate="yes" xml:space="preserve">
          <source>You can indicate to other programmers a member is meant to be private by naming it &lt;code&gt;_aPrivate&lt;/code&gt; or putting all the private variables in an object variable called &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">멤버 이름을 &lt;code&gt;_aPrivate&lt;/code&gt; 로 지정하거나 모든 비공개 변수를 &lt;code&gt;_&lt;/code&gt; 이라는 객체 변수에 넣어 다른 프로그래머에게 비공개로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d5c1874c396599b4b5ab6617f2c4fbfc040617" translate="yes" xml:space="preserve">
          <source>You can use a function as a constructor to create objects, if the constructor function is named Person then the object(s) created with that constructor are instances of Person.</source>
          <target state="translated">함수를 생성자로 사용하여 객체를 생성 할 수 있습니다. 생성자 함수의 이름이 Person 인 경우 해당 생성자로 작성된 객체는 Person의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="1e4718352a5ddbc9ba763c0a0a57cbf4ee7d57b4" translate="yes" xml:space="preserve">
          <source>You may come across similar patterns that are more robust to help with object creation and object definition.</source>
          <target state="translated">객체 생성 및 객체 정의에 도움이되는보다 강력한 유사한 패턴이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c004c041a8ade78e5fa468755470e910975a73" translate="yes" xml:space="preserve">
          <source>You want the 'child' (=RussionMini) to do something extra. When RussionMini can call the Hamster code to do something and then do something extra you don't need to copy and paste Hamster code to RussionMini.</source>
          <target state="translated">'자식'(= RussionMini)이 추가 작업을 수행하려고합니다. RussionMini가 Hamster 코드를 호출하여 작업을 수행 한 다음 추가 작업을 수행 할 때 Hamster 코드를 복사하여 RussionMini에 붙여 넣을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed3bcead2d06b24e9a79e412965282dc663fdf5e" translate="yes" xml:space="preserve">
          <source>we run &lt;code&gt;rabbit.eat&lt;/code&gt;, which changes &lt;code&gt;rabbit.full&lt;/code&gt;. &lt;code&gt;full&lt;/code&gt; property is nowhere to be found, so it should go up the prototype chain to (to object??), and well, I'm not sure what happens here. In this example the property &lt;code&gt;full&lt;/code&gt; of &lt;code&gt;rabbit&lt;/code&gt; is created and changed, while in the first example it goes up the prototype chain because it cannot find the property.</source>
          <target state="translated">&lt;code&gt;rabbit.eat&lt;/code&gt; 를 실행하여 rabbit.full 을 변경 &lt;code&gt;rabbit.full&lt;/code&gt; . &lt;code&gt;full&lt;/code&gt; 속성을 찾을 수있는 곳이 없으므로 프로토 타입 체인을 객체로 가져와야합니다. 이 예제에서는 &lt;code&gt;rabbit&lt;/code&gt; 로 &lt;code&gt;full&lt;/code&gt; 속성이 만들어지고 변경되는 반면 첫 번째 예제에서는 속성을 찾을 수 없기 때문에 프로토 타입 체인으로 올라갑니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
