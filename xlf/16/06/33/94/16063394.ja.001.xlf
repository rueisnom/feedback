<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/16063394">
    <body>
      <group id="16063394">
        <trans-unit id="74cf125fecd9be94bfb57de2381f05816742688b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Multiple inheritance&quot; with mix ins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ミックスインによる「多重継承」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f60012486871de55c32083b7c52aef92ab1d2228" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function introduction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;コンストラクター関数の紹介&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="464c26fcf651c9497932220210a67991e239e32a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extending and overriding Parent functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;親関数の拡張とオーバーライド&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7422920ac45432c6122783701aa363fe96aaf2b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Inheritance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091e6370d4f77a8fb1c6e19fd7ffd43862df251e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More about prototype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロトタイプの詳細&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="905e17e869df8f106b1d829cc87a51393ce68750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object.create to set prototype part of inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;継承のプロトタイプ部分を設定するObject.create&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5cbcd9b4b225cb9887c626d6879881f3ae6eded" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing (constructor) arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;（コンストラクタ）引数を渡す&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ee7541772d496e52c1e2bd3a4d436dc1e23236e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private variables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プライベート変数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b58eaa69cc21de153eaf2108e426b123ef846c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The this variable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this変数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24127a0a55a2a41dda788b7ff3a0a8ecd74bbf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.constructor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2c84fbef3dfee70da18aa5795b9c02c1f412822" translate="yes" xml:space="preserve">
          <source>An object can inherit from another object through the use of prototype. You can set the prototype of any object with any other object using &lt;code&gt;Object.create&lt;/code&gt;. In the constructor function introduction we have seen that if a member can't be found on the object then JavaScript will look in the prototpe chain for it.</source>
          <target state="translated">オブジェクトは、プロトタイプを使用して別のオブジェクトから継承できます。 &lt;code&gt;Object.create&lt;/code&gt; を使用して、任意のオブジェクトのプロトタイプを他のオブジェクトと設定できます。 コンストラクター関数の紹介では、オブジェクト上にメンバーが見つからない場合、JavaScriptはそのプロトタイプチェーンを調べます。</target>
        </trans-unit>
        <trans-unit id="cbe7e26021ebaa520f3f0662be1d2cd9e0ac3e41" translate="yes" xml:space="preserve">
          <source>Another reason could be that to create a Hamster a lot of complicated calculations need be done on passed arguments that may be not available yet, again you could pass in dummy arguments but it could unnecessarily complicate your code.</source>
          <target state="translated">もう一つの理由は、ハムスターを作成するために、多くの複雑な計算がまだ利用できないかもしれない引数を渡す必要があるということです。</target>
        </trans-unit>
        <trans-unit id="b17fe45dfada0a306c0914b347e348b9ca0852b5" translate="yes" xml:space="preserve">
          <source>BUT in Example 1 something else happens:</source>
          <target state="translated">しかし、例1では何か別のことが起こります。</target>
        </trans-unit>
        <trans-unit id="4ee710d2c9f34cfc2049bc5cdbb2fb193e95ac12" translate="yes" xml:space="preserve">
          <source>Because walk() could not be found on bob directly JavaScript will look for it in the Person.prototype as this is the constructor of bob. If it can't be found there it'll look on Object.prototype. This is called the prototype chain. The prototype part of inheritance is done by lengthening this chain; for example bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (more on inheritance later).</source>
          <target state="translated">これはbobのコンストラクターであるため、bobでwalk（）を直接見つけることができなかったため、JavaScriptはPerson.prototypeでそれを探します。 そこに見つからない場合は、Object.prototypeを調べます。 これはプロトタイプチェーンと呼ばれます。 継承のプロトタイプ部分は、このチェーンを長くすることによって行われます。 たとえば、bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype（継承については後で詳しく説明します）。</target>
        </trans-unit>
        <trans-unit id="b12c833356fce30b677bb5007b4eca7f1cf9586b" translate="yes" xml:space="preserve">
          <source>By using closures you do not give others a choice and by using the naming convention with documentation you do. This is not specific to JavaScript, in other languages you can decide not to use private members as you trust others to know what they are doing and give them the choice to do as they want (with risks involved).</source>
          <target state="translated">クロージャを使うことで、他の人に選択の余地を与えず、 ドキュメントの命名規則を使うことで、選択の余地を与えます。これは JavaScript に限ったことではありません。他の言語では、他の人が何をしているかを知っていることを信頼しているので、プライベートメンバーを使用しないことを決めることができます。</target>
        </trans-unit>
        <trans-unit id="48e7bf94fdffad6556b22447c07ca6a043f61d30" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 1 and for objects that inherit have them run the Parent code as well (Hamster.apply(this,arguments);)</source>
          <target state="translated">ステップ 1 のコードを実行しているインスタンスを作成し、継承するオブジェクトには Parent コードも実行させます (Hamster.apply(this,arguments);)。</target>
        </trans-unit>
        <trans-unit id="9cafc324364ac8f9b0b7fbc766cc44ec930d2327" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 2.</source>
          <target state="translated">ステップ2のコードを実行するインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="bab01f763c8928cbac3d62d6a5f840594c8f828b" translate="yes" xml:space="preserve">
          <source>Define an object that has members that will be same for many instances (person is a blueprint for bob and ben and can be for jilly, marie, clair ...)</source>
          <target state="translated">多くのインスタンスで同じになるメンバーを持つオブジェクトを定義します(personはbobとbenの青写真であり、jilly、marie、 clair ...のためにすることができます)。</target>
        </trans-unit>
        <trans-unit id="0369ebd98eda3b5d7bf11c618aea1f74bd1b7cd8" translate="yes" xml:space="preserve">
          <source>Define instance specific members of an object (functions Hamster and RussionMini).</source>
          <target state="translated">オブジェクトのインスタンス固有のメンバを定義します(HamsterとRussionMiniの関数)。</target>
        </trans-unit>
        <trans-unit id="15a6e2970bdac2aa16360ffbe8c78946b52ff0eb" translate="yes" xml:space="preserve">
          <source>Define instance specific members that should be unique for instances (bob and ben).</source>
          <target state="translated">インスタンスに対して一意であるべきインスタンス固有のメンバーを定義します(bob と ben)。</target>
        </trans-unit>
        <trans-unit id="f0566c177d01aa7ea879a7591493f45ebcd632b6" translate="yes" xml:space="preserve">
          <source>Define members that can be shared among instances.(Hamster.prototype and RussionMini.prototype)</source>
          <target state="translated">インスタンス間で共有できるメンバーを定義する(Hamster.prototypeとRussionMini.prototype)</target>
        </trans-unit>
        <trans-unit id="1cc64015257eb076b900848a79305e97c1168f09" translate="yes" xml:space="preserve">
          <source>Even though bob, ben and all other created Person instances share walk the function will behave differently per instance because in the walk function it uses &lt;code&gt;this&lt;/code&gt;. The value of &lt;code&gt;this&lt;/code&gt; will be the invoking object; for now let's say it's the current instance so for &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot; will be bob. (more on &quot;this&quot; and the invoking object later).</source>
          <target state="translated">bob、ben、および他のすべての作成されたPersonインスタンスがウォークを共有している場合でも、ウォーク関数では &lt;code&gt;this&lt;/code&gt; 使用するため、関数はインスタンスごとに異なる動作をします。 この値は、呼び出し元のオブジェクトになります。 今のところ、それが現在のインスタンスであるとしましょう &lt;code&gt;bob.walk()&lt;/code&gt; 場合、「this」はbobになります。 （ &quot;this&quot;と呼び出しオブジェクトについては後で詳しく説明します）。</target>
        </trans-unit>
        <trans-unit id="8829ee8adb882bc56fe22bb8afb9246c1e8abb66" translate="yes" xml:space="preserve">
          <source>Every instance of Hamster will share that array</source>
          <target state="translated">Hamster のすべてのインスタンスは、その配列を共有します。</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">例1.</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">例2.</target>
        </trans-unit>
        <trans-unit id="d74d95fa8fca84cad0d34ec6afae31477e7ee53f" translate="yes" xml:space="preserve">
          <source>For Movable we have instance specific members (like &lt;code&gt;location&lt;/code&gt;). And we have members that are not instance specific (like the function move()). Instance specific members will be set by calling mxIns (added by mixin helper function) when creating an instance. Prototype members will be copied one by one on Cat.prototype from Movable.prototype using the mixin helper function.</source>
          <target state="translated">Movableにはインスタンス固有のメンバー（ &lt;code&gt;location&lt;/code&gt; など ）があります。 そして、インスタンス固有ではないメンバーがあります（関数move（）など）。 インスタンス固有のメンバーは、インスタンスの作成時にmxIns（mixinヘルパー関数によって追加）を呼び出すことによって設定されます。 プロトタイプメンバーは、mixinヘルパー関数を使用して、Movable.prototypeからCat.prototypeに1つずつコピーされます。</target>
        </trans-unit>
        <trans-unit id="d4034236af5962aabc90bc340970cf5500bed73f" translate="yes" xml:space="preserve">
          <source>From this I understand, that when writing up and adding a new property which doesn't exist, the interpreter will go up the prototype chain until it finds the property, and THEN change it.</source>
          <target state="translated">このことから、私が理解しているのは、存在しない新しいプロパティを書き上げて追加する場合、インタープリタは、プロパティを見つけるまでプロトタイプの連鎖をさかのぼって、そのプロパティを変更するということです。</target>
        </trans-unit>
        <trans-unit id="c6720ee66246445f87a7ba9b7c392e804525fab2" translate="yes" xml:space="preserve">
          <source>Here is the documentation about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;, it basically returns the second argument (not supported in the polyfil) with the first argument as the returned object's prototype.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;に関するドキュメントは次のとおりです。基本的に2番目の引数（polyfilではサポートされていません）を返し、最初の引数をオブジェクトのプロトタイプとして返​​します。</target>
        </trans-unit>
        <trans-unit id="e848ec5629ff1294871791ebbf63e38cc2338e10" translate="yes" xml:space="preserve">
          <source>I agree with the following: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; and personally have not used them.</source>
          <target state="translated">私は以下に同意します： &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http&lt;/a&gt; : //blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/そして個人的にそれらを使用していません。</target>
        </trans-unit>
        <trans-unit id="cbe2e3d4e71526c44ee323b9c2c5afb89e673b0d" translate="yes" xml:space="preserve">
          <source>I like to define functions that return a function for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; on the prototype to have fine control over the variables that are included in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; scope.</source>
          <target state="translated">プロトタイプの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;クロージャーの&lt;/a&gt;関数を返す関数を定義して、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;クロージャー&lt;/a&gt;スコープに含まれる変数を細かく制御したいと思います。</target>
        </trans-unit>
        <trans-unit id="51d29e872f0afd793829823b2b7b80ebb354988c" translate="yes" xml:space="preserve">
          <source>I usually pass one object to a function and have that function mutate whatever it needs (set defaults), then that function will pass it to another function that will do the same and so on and so on. Here is an example:</source>
          <target state="translated">私は通常、ある関数に1つのオブジェクトを渡して、その関数に必要なものは何でも変異させて(デフォルトを設定して)、その関数は同じことをする別の関数にそれを渡して、同じようなことをする、などのようにしています。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="3e1c56435bb8295e877cc0c85c18aa7f843177ad" translate="yes" xml:space="preserve">
          <source>I'm confused and cannot see why this happens.</source>
          <target state="translated">混乱していて、なぜこのようなことが起こるのかわかりません。</target>
        </trans-unit>
        <trans-unit id="fde27a0f508ac6064af12c4d8b939650e52d74e9" translate="yes" xml:space="preserve">
          <source>If after setting prototype part of inheritance you should have it point to the right function again.</source>
          <target state="translated">継承のプロトタイプ部分を設定した後、再び正しい関数を指すようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="da522a6c41073e7a1c23b91110e0ce440840c41f" translate="yes" xml:space="preserve">
          <source>If ben was waiting for a red light and and bob was at a green light; then you'll invoke walk() on both ben and bob obviously something different would happen to ben and bob.</source>
          <target state="translated">ベンが赤信号を待っていて、ボブが青信号にいたとしたら、 ベンとボブの両方に walk()を呼び出すことになります。</target>
        </trans-unit>
        <trans-unit id="11e4a4b87d427e615f87bbb7d7d0b5574e9d0999" translate="yes" xml:space="preserve">
          <source>If no second argument was given it'll return an empty object with first argument to be used as the returned object's prototype (the first object to be used in the returned object's prototype chain).</source>
          <target state="translated">第2引数が与えられなかった場合は、第1引数が空のオブジェクトを返し、返されたオブジェクトのプロトタイプ(返されたオブジェクトのプロトタイプチェーンで使用される最初のオブジェクト)として使用されます。</target>
        </trans-unit>
        <trans-unit id="45326f667c3b7dd729de1fff54fe465ea292ec6c" translate="yes" xml:space="preserve">
          <source>If you need (and you do in this case) separate instances of food collections for each Hamster, you need to create the property on the instance. For example:</source>
          <target state="translated">ハムスターごとに別々のフードコレクションのインスタンスが必要な場合(この場合はそうなります)、インスタンスにプロパティを作成する必要があります。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="bf65b3d11ae75642ecded1c9d1c19caac84c3201" translate="yes" xml:space="preserve">
          <source>If you still insist on privates then the &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;following&lt;/a&gt; pattern may help. It doesn't implement private though but implements protected.</source>
          <target state="translated">それでもプライベートを主張するなら、 &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;次の&lt;/a&gt;パターンが役立つかもしれません。 プライベートは実装していませんが、保護を実装しています。</target>
        </trans-unit>
        <trans-unit id="b79b7554eff5c5557c88dc8d14f691a2491ed888" translate="yes" xml:space="preserve">
          <source>In all the example code you'll see &lt;code&gt;this&lt;/code&gt; referring to the current instance.</source>
          <target state="translated">すべてのサンプルコードで、現在のインスタンスを参照していることがわかります。</target>
        </trans-unit>
        <trans-unit id="c51dd0d86d782b26cf283ada041cd94af0aa189e" translate="yes" xml:space="preserve">
          <source>In previous part we have seen that re assignment of members that come from an instance's prototype (ben.walk) will shadow that member (create walk on ben rather than changing Person.prototype.walk).</source>
          <target state="translated">前回は、インスタンスのプロトタイプ(ben.walk)から来たメンバの再割り当てが、そのメンバのシャドウイング(Person.prototype.walkを変更するのではなく、benにwalkを作成すること)になることを見ました。</target>
        </trans-unit>
        <trans-unit id="bd9ce7cacb78c648c9be29a9cf9471ae22e833f0" translate="yes" xml:space="preserve">
          <source>In the following example we assume that a Hamster can run 3km an hour but a Russion mini can only run half as fast. We can hard code 3/2 in RussionMini but if this value were to change we have multiple places in code where it needs changing. Here is how we use Hamster.prototype to get the parent (Hamster) speed.</source>
          <target state="translated">次の例では、ハムスターは時速3kmで走れるが、RussionMiniはその半分の速さでしか走れないと仮定しています。RussionMiniでは32とハードコードすることができますが、もしこの値が変更された場合、コードの中で変更が必要な箇所が複数あります。ここではHamster.prototypeを使って親(ハムスター)の速度を取得しています。</target>
        </trans-unit>
        <trans-unit id="968367429f9ee5051fb4a6a3e36c91706fe020f5" translate="yes" xml:space="preserve">
          <source>In this code I have removed name from prototype as well as food because you are most likely going to shadow this almost immediately when creating an instance anyway. Name is now an instance specific member with a default value set in the constructor function. Becaus the food member is also moved from prototype to instance specific member it will not affect bob.food when adding food to ben.</source>
          <target state="translated">このコードでは、プロトタイプから名前とフードを削除しました。nameは、コンストラクタ関数でデフォルト値を設定したインスタンス固有のメンバになりました。food メンバも prototype からインスタンス固有のメンバに移動したので、ben に food を追加しても bob.food には影響しません。</target>
        </trans-unit>
        <trans-unit id="782c9829c985ba325100f3f912e7b73c3cc8a8d2" translate="yes" xml:space="preserve">
          <source>It's good because it enables you and others to mock certain members for testing easily. It gives others a chance to easily improve (patch) your code but this is also bad because there is no guarantee that a next version of your code has the same implementation and or private members.</source>
          <target state="translated">良い点は、あなたや他の人がテストのために特定のメンバーを簡単にモックすることができることです。他の人があなたのコードを簡単に改善 (パッチ)する機会を与えますが、次のバージョンのコードが同じ実装やプライベートなメンバーを持っているという保証がないので、これも良くありません。</target>
        </trans-unit>
        <trans-unit id="8a6c3b4d25a0b9e7b9de12cbedcc883a943f7193" translate="yes" xml:space="preserve">
          <source>JavaScript doesn't have a private modifier.</source>
          <target state="translated">JavaScriptにはプライベート修飾子がありません。</target>
        </trans-unit>
        <trans-unit id="f4783878a60c2e2bedc9c4cb15e63c2cad8e91a8" translate="yes" xml:space="preserve">
          <source>Most of the patterns I've seen will either break when inheritance level is more than 2 levels (Child =&amp;gt; Parent =&amp;gt; GrandParent) or use more resources by implementing super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt;.</source>
          <target state="translated">私が見たほとんどのパターンは、継承レベルが2レベル（子=&amp;gt;親=&amp;gt; GrandParent）を超える場合に壊れるか、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;クロージャーを&lt;/a&gt;介してスーパーを実装することにより、より多くのリソースを使用します。</target>
        </trans-unit>
        <trans-unit id="a86491f8b298b8b31ba2a6f4824cc3d924e08dba" translate="yes" xml:space="preserve">
          <source>Not implementing privates as closures would leak implementation and enable you or users extending your code to use members that are not part of your public API. This can be both good and bad.</source>
          <target state="translated">privates をクロージャとして実装しないと、実装が漏れてしまい、あなたやコードを拡張しているユーザーがパブリック API の一部ではないメンバーを使用できるようになってしまいます。これは良いことでもあり、悪いことでもあります。</target>
        </trans-unit>
        <trans-unit id="554811e64329329de8e99177229051265f514851" translate="yes" xml:space="preserve">
          <source>Person is the constructor function. When you create an instance using Person you have to use the new keyword:</source>
          <target state="translated">Person はコンストラクタ関数です。Personを使用してインスタンスを作成する際には、新しいキーワードを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="3d400767e83f5b3545ee60adf2bcccde144b2840" translate="yes" xml:space="preserve">
          <source>Prototypes are &lt;strong&gt;NOT&lt;/strong&gt; instantiated for each instance of an object.</source>
          <target state="translated">プロトタイプは、オブジェクトのインスタンスごとにインスタンス化され&lt;strong&gt;ません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="cceb329f51a30a7a00183d2d4ed1d0655073e080" translate="yes" xml:space="preserve">
          <source>Prototypical inheritance - writing up</source>
          <target state="translated">プロトタイプ継承-書き上げ</target>
        </trans-unit>
        <trans-unit id="64b8741afff5b09a35196deea479694b320fa7af" translate="yes" xml:space="preserve">
          <source>Set the prototype part of inheritance (RussionMini.prototype = Object.create(Hamster.prototype))</source>
          <target state="translated">継承のプロトタイプ部分を設定する(RussionMini.prototype=Object.create(Hamster.prototype))</target>
        </trans-unit>
        <trans-unit id="4b07cce27e263241a4a74f241d33c0a5433426cd" translate="yes" xml:space="preserve">
          <source>Shadowing members happens when we do something like &lt;code&gt;ben.walk=22&lt;/code&gt;, even though bob and ben share &lt;code&gt;walk&lt;/code&gt; the &lt;em&gt;assignment&lt;/em&gt; of 22 to ben.walk will not affect bob.walk. This is because that statement will create a member called &lt;code&gt;walk&lt;/code&gt; on ben directly and assign it a value of 22. There will be 2 different walk members: ben.walk and Person.prototype.walk.</source>
          <target state="translated">メンバーの &lt;code&gt;ben.walk=22&lt;/code&gt; 、bobとbenの共有 &lt;code&gt;walk&lt;/code&gt; がben.walkへの22の&lt;em&gt;割り当て&lt;/em&gt;がbob.walkに影響を与えない場合でも、 ben.walk = 22のようなことを行うと発生します。 これは、そのステートメントが &lt;code&gt;walk&lt;/code&gt; on benというメンバーを直接作成し、それに22の値を割り当てるためです。2つの異なるwalkメンバーがあります：ben.walkとPerson.prototype.walkです。</target>
        </trans-unit>
        <trans-unit id="525b7ccb7b92ac04a16fabaf6a882aee1fe90b3c" translate="yes" xml:space="preserve">
          <source>So I have these 2 examples, from javascript.info:</source>
          <target state="translated">そのため、以下の2つの例があります。</target>
        </trans-unit>
        <trans-unit id="1ea63f6cce56c9eca2d72522f3a7e51c6996b13a" translate="yes" xml:space="preserve">
          <source>Some things are better not to be inherited, if a Cat can move and then a Cat should not inherit from Movable. A Cat is not a Movable but rather a Cat can move. In a class based language Cat would have to implement Movable. In JavaScript we can define Movable and define implementation here, Cat can either override, extend it or us it's default implementation.</source>
          <target state="translated">猫が動けるなら、猫はMovableを継承しない方が良いものもあります。CatはMovableではなく、Catが動くことができるのです。クラスベースの言語では、CatはMovableを実装しなければなりません。JavaScriptではMovableを定義し、ここで実装を定義することができます。CatはMovableをオーバーライドしたり、拡張したり、デフォルトの実装を使用することができます。</target>
        </trans-unit>
        <trans-unit id="ef53d380cd63d69c06e94e9adfd7ea3d789beae8" translate="yes" xml:space="preserve">
          <source>Some would set the prototype of RussionMini to an instance of Hamster (RussionMini.prototype = new Hamster()). This is not desirable because even though it accomplishes the same (RussionMini.prototype's prototype is Hamster.prototype) it also sets Hamster instance members as members of RussionMini.prototype. So RussionMini.prototype.food will exist but is a shared member (remember bob and ben in &quot;More about prototype&quot;?). The food member will be shadowed when creating a RussionMini because Hamster code is run with &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; that in turn runs &lt;code&gt;this.food = []&lt;/code&gt; but any Hamster members will still be members of RussionMini.prototype.</source>
          <target state="translated">一部のユーザーは、RussionMiniのプロトタイプをHamsterのインスタンスに設定します（RussionMini.prototype = new Hamster（））。 同じことを達成しても（RussionMini.prototypeのプロトタイプはHamster.prototypeです）、HamsterインスタンスメンバーをRussionMini.prototypeのメンバーとして設定するため、これは望ましくありません。 したがって、RussionMini.prototype.foodは存在しますが、共有メンバーです（「プロトタイプについての詳細」でボブとベンを覚えていますか？）。 ハムスターのコードは &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; 実行されるため、RussionMiniを作成するときにフードメンバーはシャドウされます。 これにより &lt;code&gt;this.food = []&lt;/code&gt; が実行されますが、ハムスターのメンバーは引き続きRussionMini.prototypeのメンバーになります。</target>
        </trans-unit>
        <trans-unit id="603053b2f1c406cdc9f1aba516ab35aa5644c02a" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;children&lt;/code&gt; need to extend &lt;code&gt;parent&lt;/code&gt; functions.</source>
          <target state="translated">時々、 &lt;code&gt;children&lt;/code&gt; は &lt;code&gt;parent&lt;/code&gt; 機能を拡張する必要があります。</target>
        </trans-unit>
        <trans-unit id="dc46bcd4a8dbc5cd0a9473c19363d38ae051b890" translate="yes" xml:space="preserve">
          <source>Start from Example 2: when the code reaches &lt;code&gt;speedy.found&lt;/code&gt;, it finds no &lt;code&gt;found&lt;/code&gt; property in &lt;code&gt;speedy&lt;/code&gt;, and so it climbs up to the prototype and changes it there. That's why &lt;code&gt;food.length&lt;/code&gt; is equal for both hamsters, in other words they have the same stomach.</source>
          <target state="translated">例2から始めます。コードが &lt;code&gt;speedy.found&lt;/code&gt; に到達すると、 &lt;code&gt;speedy&lt;/code&gt; でプロパティが &lt;code&gt;found&lt;/code&gt; ないため、プロトタイプに到達し、そこでプロトタイプを変更します。 これが、 &lt;code&gt;food.length&lt;/code&gt; が両方のハムスターで等しい、つまり、 胃が同じである理由です 。</target>
        </trans-unit>
        <trans-unit id="1c5ef60e0f791800e4f9fe96e6386ddd31add8b0" translate="yes" xml:space="preserve">
          <source>The above is a simple implementation that replaces same named functions with whatever mix in is mixed in last.</source>
          <target state="translated">上記は、同じ名前の関数を最後にmix inされたものに置き換えるシンプルな実装です。</target>
        </trans-unit>
        <trans-unit id="91886ea4946327cd43e989ed9081a401237a0d2d" translate="yes" xml:space="preserve">
          <source>The code above shows that ben and bob share members from person. There is only one person, it is set as bob's and ben's prototype (person is used as the first object in the prototype chain to look up requested members that don't exist on the instance). The problem with the above code is that bob and ben should have their own &lt;code&gt;food&lt;/code&gt; member. This is where the constructor function comes in. It is used to create instance specific members. You could also pass arguments to it to set values of these instance specific members.</source>
          <target state="translated">上記のコードは、ベンとボブが個人のメンバーを共有していることを示しています。 人は1人だけで、ボブとベンのプロトタイプとして設定されています（人は、プロトタイプチェーンの最初のオブジェクトとして使用され、インスタンスに存在しない要求されたメンバーを検索します）。 上記のコードの問題は、ボブとベンが独自の &lt;code&gt;food&lt;/code&gt; メンバーを持つ必要があることです。 これは、コンストラクタ関数の出番です。インスタンス固有のメンバーを作成するために使用されます。 また、引数を渡して、これらのインスタンス固有のメンバーの値を設定することもできます。</target>
        </trans-unit>
        <trans-unit id="ce16836f76cd9e02bb10ce77133484da4db12749" translate="yes" xml:space="preserve">
          <source>The constructor property is included in the prototype by JavaScript, you can change it but it should point to the constructor function. So &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; should point to Hamster.</source>
          <target state="translated">コンストラクタプロパティはJavaScriptによってプロトタイプに含まれています。変更できますが、コンストラクタ関数を指す必要があります。 したがって、 &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; はHamsterを指す必要があります。</target>
        </trans-unit>
        <trans-unit id="ba2e7bfbfcc3ebee3a82668a2127dadc5a3a614c" translate="yes" xml:space="preserve">
          <source>The disadvantage is that you hard code Hamster.prototype. There may be patterns that will give you the advantage of &lt;code&gt;super&lt;/code&gt; as in Java.</source>
          <target state="translated">欠点は、Hamster.prototypeをハードコードすることです。 Javaのように &lt;code&gt;super&lt;/code&gt; の利点をもたらすパターンがあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c0f31cb3709425be0a6f04c9d6a8e9bae7b0bdf4" translate="yes" xml:space="preserve">
          <source>The following code demonstrates the difference between prototype members and instance members by mutating members.</source>
          <target state="translated">以下のコードは、メンバーを変異させてプロトタイプメンバーとインスタンスメンバーの違いを示しています。</target>
        </trans-unit>
        <trans-unit id="92d7047ac0b211ef42fa97b41187517206e5a323" translate="yes" xml:space="preserve">
          <source>The following code shows how to inherit. The tasks are basically the same as in code before with a little extra</source>
          <target state="translated">以下のコードは、継承する方法を示しています。タスクは基本的には以前のコードと同じですが、少し余分なものがあります。</target>
        </trans-unit>
        <trans-unit id="b31cca01cbdf5bb975254cb59ea3db82b273ae80" translate="yes" xml:space="preserve">
          <source>The instances where this would refer to the wrong object are usually when attaching event listeners, callbacks or timeouts and intervals. In the next 2 lines of code we &lt;code&gt;pass&lt;/code&gt; the function, we don't invoke it. Passing the function is: &lt;code&gt;someObject.aFunction&lt;/code&gt; and invoking it is: &lt;code&gt;someObject.aFunction()&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value does not refer to the object the function was declared on but on the object that &lt;code&gt;invokes&lt;/code&gt; it.</source>
          <target state="translated">これが間違ったオブジェクトを参照するのは、通常、イベントリスナー、コールバック、またはタイムアウトと間隔をアタッチするときです。 次の2行のコードでは、関数を &lt;code&gt;pass&lt;/code&gt; ますが、呼び出しません。 関数の受け渡しは &lt;code&gt;someObject.aFunction&lt;/code&gt; であり、呼び出しは &lt;code&gt;someObject.aFunction()&lt;/code&gt; です。 &lt;code&gt;this&lt;/code&gt; 値は、関数が宣言されたオブジェクトで &lt;code&gt;invokes&lt;/code&gt; なく、それを呼び出すオブジェクトを参照します 。</target>
        </trans-unit>
        <trans-unit id="2d633be38865f4cc00308b578d502e60cb128ba2" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;walk&lt;/code&gt; is part of Person.prototype and is shared for all instances bob and ben are instances of Person so they share the walk member (bob.walk===ben.walk).</source>
          <target state="translated">メンバー &lt;code&gt;walk&lt;/code&gt; はPerson.prototypeの一部であり、すべてのインスタンスで共有されます。bobとbenはPersonのインスタンスなので、walkメンバーを共有します（bob.walk === ben.walk）。</target>
        </trans-unit>
        <trans-unit id="6b7f455cf9ed0f3eee5f17e212f56a94f50505d9" translate="yes" xml:space="preserve">
          <source>The next code shows another way to implement the constructor function, syntax is different but the idea is the same:</source>
          <target state="translated">次のコードは、コンストラクタ関数を実装する別の方法を示しています。</target>
        </trans-unit>
        <trans-unit id="68b7a276695cb91b3cc1a5a46c42b89c5d2e1bc4" translate="yes" xml:space="preserve">
          <source>The property/member &lt;code&gt;name&lt;/code&gt; is instance specific, it's different for bob and ben</source>
          <target state="translated">プロパティ/メンバー &lt;code&gt;name&lt;/code&gt; はインスタンス固有であり、ボブとベンでは異なります</target>
        </trans-unit>
        <trans-unit id="34bac27fdaa771c107c0ae1ee0c876c8cccc0390" translate="yes" xml:space="preserve">
          <source>The this variable actually refers to the invoking object, it refers to the object that came before the function.</source>
          <target state="translated">この変数は実際には呼び出しオブジェクトを参照しており、関数の前に来たオブジェクトを参照しています。</target>
        </trans-unit>
        <trans-unit id="dbeae5adf6a2e7873a50962c48c4d2650e1cad7a" translate="yes" xml:space="preserve">
          <source>This way of passing arguments in a function chain is useful in many cases. When you're working on code that would calculate a total of something and later you'd like to re factor the total of that something to be in a certain currency you may have to change a lot of functions to pass the value for currency. You could up scope a currency value (even to global like &lt;code&gt;window.currency='USD'&lt;/code&gt;) but that's a bad way to solve it.</source>
          <target state="translated">関数チェーンで引数を渡すこの方法は、多くの場合に役立ちます。 何かの合計を計算するコードで作業していて、後でその合計を特定の通貨であるようにリファクタリングしたい場合、通貨の値を渡すために多くの関数を変更する必要があるかもしれません。 通貨の値を（ &lt;code&gt;window.currency='USD'&lt;/code&gt; のようなグローバルにまで）スコープすることもできますが、それはそれを解決するための悪い方法です。</target>
        </trans-unit>
        <trans-unit id="881d70367fb2cb9071aabd702a8ddae76085a077" translate="yes" xml:space="preserve">
          <source>To answer your question about Example 1, if it doesn't find the property anywhere in the prototype chain, it creates the property on the target object.</source>
          <target state="translated">例1についての質問に答えると、プロトタイプ・チェーンのどこにもプロパティが見つからない場合、ターゲット・オブジェクトにプロパティを作成します。</target>
        </trans-unit>
        <trans-unit id="caa724d08d862109a2da38689f2332f1ce655618" translate="yes" xml:space="preserve">
          <source>To clarify see the following code:</source>
          <target state="translated">明確にするには、以下のコードを参照してください。</target>
        </trans-unit>
        <trans-unit id="6fa3de1fe95879c2e0e06bbcc67ffb2a5a9cacd6" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;this&lt;/code&gt; in the above cases refer to someObject you can pass a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; instead of the function directly:</source>
          <target state="translated">上記の場合にsomeObjectを参照するには、関数の代わりに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;クロージャー&lt;/a&gt;を直接渡すことができます。</target>
        </trans-unit>
        <trans-unit id="95908275067ede0cb508056464f5d825f362df1f" translate="yes" xml:space="preserve">
          <source>To override a Parent (=Hamster) method you do the same but don't do Hamster.prototype.parentMethod.call(this,....</source>
          <target state="translated">親(=Hamster)メソッドをオーバーライドするには、Hamster.prototype.parentMethod.call(this,.....)をしないようにします。</target>
        </trans-unit>
        <trans-unit id="30981a69967a6193b8f04b92e8a40f2bd4f43877" translate="yes" xml:space="preserve">
          <source>Using a pattern some would call &quot;classical inheritance&quot;. If you are confused by the syntax I'll be happy to explain more or provide different patterns.</source>
          <target state="translated">古典的な継承」と呼ばれるパターンを使用しています。もし構文に混乱しているのであれば、私は喜んでより多くの説明をするか、別のパターンを提供します。</target>
        </trans-unit>
        <trans-unit id="9d15948c93f4b3b1f746c221caff8d64929f5020" translate="yes" xml:space="preserve">
          <source>What if we don't re assign but mutate the member? Mutating is (for example) changing sub properties of an Object or invoking functions that will change the object's value. For example:</source>
          <target state="translated">再割り当てではなく、メンバーをミューテートする場合はどうすればいいのでしょうか?変異とは、(例えば)オブジェクトのサブプロパティを変更したり、オブジェクトの値を変更する関数を呼び出したりすることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d72ec19dd58257fe3e8938b8afc236576f1071ab" translate="yes" xml:space="preserve">
          <source>When Child calls a Parent (&lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt;) we assume that Hamster uses the same arguments as RussionMini in the same order. For functions that call other functions I usually use another way to pass arguments.</source>
          <target state="translated">子が親を呼び出すとき（ &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; ）、ハムスターはRussionMiniと同じ引数を同じ順序で使用すると想定します。 他の関数を呼び出す関数の場合、通常は別の方法で引数を渡します。</target>
        </trans-unit>
        <trans-unit id="1a8948d65f6b2ed854bc435e20bd64c244a77252" translate="yes" xml:space="preserve">
          <source>When asking for bob.walk you'll get the Person.prototype.walk function because &lt;code&gt;walk&lt;/code&gt; could not be found on bob. Asking for ben.walk however will get you the value 22 because the member walk has been created on ben and since JavaScript found walk on ben it will not look in the Person.prototype.</source>
          <target state="translated">bob.walkを要求すると、bobで &lt;code&gt;walk&lt;/code&gt; が見つからなかったため、Person.prototype.walk関数を取得します。 ただし、メンバーwalkがbenで作成されており、JavaScriptがwalk on benを見つけたので、それがPerson.prototypeを調べないため、ben.walkを要求すると、値22が得られます。</target>
        </trans-unit>
        <trans-unit id="dbae9f24b1b441346037a1a711472938fe1b0cdb" translate="yes" xml:space="preserve">
          <source>When using Object.create with 2 arguments, Object.defineProperty or Object.defineProperties shadowing works a bit different. More info on that &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">2つの引数を指定してObject.createを使用する場合、Object.definePropertyまたはObject.definePropertiesのシャドウイングは少し異なります。 詳細は&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;こちら&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="944b2bf97bd3b09291debcbebf9c539ec6b669f8" translate="yes" xml:space="preserve">
          <source>With constructor functions you'll set the prototype in step 2 in the following code we set the prototype in step 3.</source>
          <target state="translated">コンストラクタ関数では、ステップ2でプロトタイプを設定し、以下のコードではステップ3でプロトタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="9298f1163ca32f5e167b7c0302b9ad1b3d88a666" translate="yes" xml:space="preserve">
          <source>With passing an object you could add currency to &lt;code&gt;args&lt;/code&gt; whenever it's available in the function chain and mutate/use it whenever you need it without changing the other functions (explicitly have to pass it in the function calls).</source>
          <target state="translated">オブジェクトを渡すと、関数チェーンで使用可能な場合はいつでも &lt;code&gt;args&lt;/code&gt; に通貨を追加でき、他の関数を変更せずに必要なときにいつでも変更/使用できます（関数呼び出しで明示的に渡す必要があります）。</target>
        </trans-unit>
        <trans-unit id="837db40af571b967b8c7124903cd4c716d0b7af4" translate="yes" xml:space="preserve">
          <source>You can implement private members through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; but instance specific private members can only be accessed by functions that are not on the prototype.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;クロージャー&lt;/a&gt;を介してプライベートメンバーを実装できますが、インスタンス固有のプライベートメンバーには、プロトタイプ上にない関数のみがアクセスできます。</target>
        </trans-unit>
        <trans-unit id="307959edcb48ff33b2f62e2ee949b4df46321abd" translate="yes" xml:space="preserve">
          <source>You can indicate to other programmers a member is meant to be private by naming it &lt;code&gt;_aPrivate&lt;/code&gt; or putting all the private variables in an object variable called &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">メンバーに &lt;code&gt;_aPrivate&lt;/code&gt; という名前を付けるか、すべてのプライベート変数を &lt;code&gt;_&lt;/code&gt; と呼ばれるオブジェクト変数に入れることにより、メンバーがプライベートであることを他のプログラマーに示すことができます。</target>
        </trans-unit>
        <trans-unit id="62d5c1874c396599b4b5ab6617f2c4fbfc040617" translate="yes" xml:space="preserve">
          <source>You can use a function as a constructor to create objects, if the constructor function is named Person then the object(s) created with that constructor are instances of Person.</source>
          <target state="translated">関数をコンストラクタとして使用してオブジェクトを作成することができます。コンストラクタ関数の名前が Person の場合、そのコンストラクタで作成されたオブジェクトは Person のインスタンスとなります。</target>
        </trans-unit>
        <trans-unit id="1e4718352a5ddbc9ba763c0a0a57cbf4ee7d57b4" translate="yes" xml:space="preserve">
          <source>You may come across similar patterns that are more robust to help with object creation and object definition.</source>
          <target state="translated">オブジェクトの作成やオブジェクトの定義に役立つ、より堅牢な類似のパターンに出くわすことがあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="03c004c041a8ade78e5fa468755470e910975a73" translate="yes" xml:space="preserve">
          <source>You want the 'child' (=RussionMini) to do something extra. When RussionMini can call the Hamster code to do something and then do something extra you don't need to copy and paste Hamster code to RussionMini.</source>
          <target state="translated">子」(=RussionMini)に余計なことをさせたいのですね。RussionMiniがHamsterコードを呼び出して何かをした後に余計なことをする場合は、HamsterコードをRussionMiniにコピー&amp;ペーストする必要はありません。</target>
        </trans-unit>
        <trans-unit id="ed3bcead2d06b24e9a79e412965282dc663fdf5e" translate="yes" xml:space="preserve">
          <source>we run &lt;code&gt;rabbit.eat&lt;/code&gt;, which changes &lt;code&gt;rabbit.full&lt;/code&gt;. &lt;code&gt;full&lt;/code&gt; property is nowhere to be found, so it should go up the prototype chain to (to object??), and well, I'm not sure what happens here. In this example the property &lt;code&gt;full&lt;/code&gt; of &lt;code&gt;rabbit&lt;/code&gt; is created and changed, while in the first example it goes up the prototype chain because it cannot find the property.</source>
          <target state="translated">&lt;code&gt;rabbit.eat&lt;/code&gt; を変更するrabbit.eatを実行します。 &lt;code&gt;full&lt;/code&gt; プロパティはどこにも見つからないので、プロトタイプチェーンを上って（異議を唱えますか??）、そしてここで何が起こるかわかりません。 この例では、 &lt;code&gt;rabbit&lt;/code&gt; で &lt;code&gt;full&lt;/code&gt; のプロパティが作成および変更されますが、最初の例では、プロパティが見つからないためプロトタイプチェーンが上がります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
