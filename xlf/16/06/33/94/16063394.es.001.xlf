<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/16063394">
    <body>
      <group id="16063394">
        <trans-unit id="74cf125fecd9be94bfb57de2381f05816742688b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Multiple inheritance&quot; with mix ins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;Herencia m&amp;uacute;ltiple&quot; con mix ins&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f60012486871de55c32083b7c52aef92ab1d2228" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function introduction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Introducci&amp;oacute;n a la funci&amp;oacute;n de constructor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="464c26fcf651c9497932220210a67991e239e32a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extending and overriding Parent functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ampliaci&amp;oacute;n y anulaci&amp;oacute;n de funciones principales&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7422920ac45432c6122783701aa363fe96aaf2b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Inheritance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091e6370d4f77a8fb1c6e19fd7ffd43862df251e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More about prototype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;aacute;s sobre prototipo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="905e17e869df8f106b1d829cc87a51393ce68750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object.create to set prototype part of inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Object.create para establecer parte prototipo de herencia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5cbcd9b4b225cb9887c626d6879881f3ae6eded" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing (constructor) arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pasar argumentos (constructor)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ee7541772d496e52c1e2bd3a4d436dc1e23236e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private variables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Variables privadas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b58eaa69cc21de153eaf2108e426b123ef846c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The this variable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La variable esta&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24127a0a55a2a41dda788b7ff3a0a8ecd74bbf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.constructor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2c84fbef3dfee70da18aa5795b9c02c1f412822" translate="yes" xml:space="preserve">
          <source>An object can inherit from another object through the use of prototype. You can set the prototype of any object with any other object using &lt;code&gt;Object.create&lt;/code&gt;. In the constructor function introduction we have seen that if a member can't be found on the object then JavaScript will look in the prototpe chain for it.</source>
          <target state="translated">Un objeto puede heredar de otro objeto mediante el uso del prototipo. Puede configurar el prototipo de cualquier objeto con cualquier otro objeto usando &lt;code&gt;Object.create&lt;/code&gt; . En la introducci&amp;oacute;n de la funci&amp;oacute;n del constructor, hemos visto que si no se puede encontrar un miembro en el objeto, JavaScript lo buscar&amp;aacute; en la cadena de prototipos.</target>
        </trans-unit>
        <trans-unit id="cbe7e26021ebaa520f3f0662be1d2cd9e0ac3e41" translate="yes" xml:space="preserve">
          <source>Another reason could be that to create a Hamster a lot of complicated calculations need be done on passed arguments that may be not available yet, again you could pass in dummy arguments but it could unnecessarily complicate your code.</source>
          <target state="translated">Otra razón podría ser que para crear un hámster hay que hacer muchos cálculos complicados con argumentos pasados que pueden no estar disponibles todavía,de nuevo podrías pasar argumentos falsos pero podría complicar innecesariamente tu código.</target>
        </trans-unit>
        <trans-unit id="b17fe45dfada0a306c0914b347e348b9ca0852b5" translate="yes" xml:space="preserve">
          <source>BUT in Example 1 something else happens:</source>
          <target state="translated">Pero en el ejemplo 1 ocurre algo más:</target>
        </trans-unit>
        <trans-unit id="4ee710d2c9f34cfc2049bc5cdbb2fb193e95ac12" translate="yes" xml:space="preserve">
          <source>Because walk() could not be found on bob directly JavaScript will look for it in the Person.prototype as this is the constructor of bob. If it can't be found there it'll look on Object.prototype. This is called the prototype chain. The prototype part of inheritance is done by lengthening this chain; for example bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (more on inheritance later).</source>
          <target state="translated">Debido a que walk () no se pudo encontrar en bob directamente, JavaScript lo buscar&amp;aacute; en el prototipo Person. ya que este es el constructor de bob. Si no se puede encontrar all&amp;iacute;, buscar&amp;aacute; en Object.prototype. Esto se llama la cadena prototipo. La parte prototipo de la herencia se realiza alargando esta cadena; por ejemplo bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (m&amp;aacute;s sobre la herencia m&amp;aacute;s adelante).</target>
        </trans-unit>
        <trans-unit id="b12c833356fce30b677bb5007b4eca7f1cf9586b" translate="yes" xml:space="preserve">
          <source>By using closures you do not give others a choice and by using the naming convention with documentation you do. This is not specific to JavaScript, in other languages you can decide not to use private members as you trust others to know what they are doing and give them the choice to do as they want (with risks involved).</source>
          <target state="translated">Usando los cierres no le das a otros una opción y usando la convención de nombres con la documentación lo haces.Esto no es específico de JavaScript,en otros lenguajes puedes decidir no usar miembros privados ya que confías en que los demás sepan lo que están haciendo y les das la opción de hacer lo que quieran (con los riesgos que ello implica).</target>
        </trans-unit>
        <trans-unit id="48e7bf94fdffad6556b22447c07ca6a043f61d30" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 1 and for objects that inherit have them run the Parent code as well (Hamster.apply(this,arguments);)</source>
          <target state="translated">Crear una instancia ejecutando el código en el paso 1 y para los objetos que heredan hacer que ejecuten el código padre también (Hamster.apply(this,arguments);)</target>
        </trans-unit>
        <trans-unit id="9cafc324364ac8f9b0b7fbc766cc44ec930d2327" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 2.</source>
          <target state="translated">Crear una instancia que ejecute el código en el paso 2.</target>
        </trans-unit>
        <trans-unit id="bab01f763c8928cbac3d62d6a5f840594c8f828b" translate="yes" xml:space="preserve">
          <source>Define an object that has members that will be same for many instances (person is a blueprint for bob and ben and can be for jilly, marie, clair ...)</source>
          <target state="translated">Definir un objeto que tiene miembros que serán iguales para muchas instancias (persona es un plano para Bob y Ben y puede ser para Jilly,Marie,Claire...)</target>
        </trans-unit>
        <trans-unit id="0369ebd98eda3b5d7bf11c618aea1f74bd1b7cd8" translate="yes" xml:space="preserve">
          <source>Define instance specific members of an object (functions Hamster and RussionMini).</source>
          <target state="translated">Definir los miembros específicos de un objeto (funciones Hamster y RussionMini).</target>
        </trans-unit>
        <trans-unit id="15a6e2970bdac2aa16360ffbe8c78946b52ff0eb" translate="yes" xml:space="preserve">
          <source>Define instance specific members that should be unique for instances (bob and ben).</source>
          <target state="translated">Definir los miembros específicos de la instancia que deben ser únicos para las instancias (Bob y Ben).</target>
        </trans-unit>
        <trans-unit id="f0566c177d01aa7ea879a7591493f45ebcd632b6" translate="yes" xml:space="preserve">
          <source>Define members that can be shared among instances.(Hamster.prototype and RussionMini.prototype)</source>
          <target state="translated">Definir los miembros que pueden ser compartidos entre las instancias.(Hamster.prototipo y RussionMini.prototipo)</target>
        </trans-unit>
        <trans-unit id="1cc64015257eb076b900848a79305e97c1168f09" translate="yes" xml:space="preserve">
          <source>Even though bob, ben and all other created Person instances share walk the function will behave differently per instance because in the walk function it uses &lt;code&gt;this&lt;/code&gt;. The value of &lt;code&gt;this&lt;/code&gt; will be the invoking object; for now let's say it's the current instance so for &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot; will be bob. (more on &quot;this&quot; and the invoking object later).</source>
          <target state="translated">Aunque bob, ben y todas las dem&amp;aacute;s instancias de Person creadas comparten walk, la funci&amp;oacute;n se comportar&amp;aacute; de manera diferente por instancia porque en la funci&amp;oacute;n walk usa &lt;code&gt;this&lt;/code&gt; . El valor de &lt;code&gt;this&lt;/code&gt; ser&amp;aacute; el objeto de invocaci&amp;oacute;n; por ahora digamos que es la instancia actual, as&amp;iacute; que para &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot; ser&amp;aacute; bob. (M&amp;aacute;s sobre &quot;esto&quot; y el objeto de invocaci&amp;oacute;n m&amp;aacute;s adelante).</target>
        </trans-unit>
        <trans-unit id="8829ee8adb882bc56fe22bb8afb9246c1e8abb66" translate="yes" xml:space="preserve">
          <source>Every instance of Hamster will share that array</source>
          <target state="translated">Cada instancia de Hamster compartirá ese arreglo</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">Ejemplo 1:</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">Ejemplo 2:</target>
        </trans-unit>
        <trans-unit id="d74d95fa8fca84cad0d34ec6afae31477e7ee53f" translate="yes" xml:space="preserve">
          <source>For Movable we have instance specific members (like &lt;code&gt;location&lt;/code&gt;). And we have members that are not instance specific (like the function move()). Instance specific members will be set by calling mxIns (added by mixin helper function) when creating an instance. Prototype members will be copied one by one on Cat.prototype from Movable.prototype using the mixin helper function.</source>
          <target state="translated">Para Movable tenemos miembros espec&amp;iacute;ficos de instancia (como &lt;code&gt;location&lt;/code&gt; ). Y tenemos miembros que no son espec&amp;iacute;ficos de la instancia (como la funci&amp;oacute;n move ()). Los miembros espec&amp;iacute;ficos de la instancia se establecer&amp;aacute;n llamando a mxIns (agregado por la funci&amp;oacute;n auxiliar mixin) al crear una instancia. Los miembros del prototipo se copiar&amp;aacute;n uno por uno en Cat.prototype de Movable.prototype utilizando la funci&amp;oacute;n auxiliar mixin.</target>
        </trans-unit>
        <trans-unit id="d4034236af5962aabc90bc340970cf5500bed73f" translate="yes" xml:space="preserve">
          <source>From this I understand, that when writing up and adding a new property which doesn't exist, the interpreter will go up the prototype chain until it finds the property, and THEN change it.</source>
          <target state="translated">A partir de esto entiendo,que al escribir y añadir una nueva propiedad que no existe,el intérprete subirá por la cadena del prototipo hasta encontrar la propiedad,y luego la cambiará.</target>
        </trans-unit>
        <trans-unit id="c6720ee66246445f87a7ba9b7c392e804525fab2" translate="yes" xml:space="preserve">
          <source>Here is the documentation about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;, it basically returns the second argument (not supported in the polyfil) with the first argument as the returned object's prototype.</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la documentaci&amp;oacute;n sobre &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; , b&amp;aacute;sicamente devuelve el segundo argumento (no admitido en el polyfil) con el primer argumento como el prototipo del objeto devuelto.</target>
        </trans-unit>
        <trans-unit id="e848ec5629ff1294871791ebbf63e38cc2338e10" translate="yes" xml:space="preserve">
          <source>I agree with the following: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; and personally have not used them.</source>
          <target state="translated">Estoy de acuerdo con lo siguiente: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; y personalmente no los he usado.</target>
        </trans-unit>
        <trans-unit id="cbe2e3d4e71526c44ee323b9c2c5afb89e673b0d" translate="yes" xml:space="preserve">
          <source>I like to define functions that return a function for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; on the prototype to have fine control over the variables that are included in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; scope.</source>
          <target state="translated">Me gusta definir funciones que devuelven una funci&amp;oacute;n para &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;cierres&lt;/a&gt; en el prototipo para tener un control preciso sobre las variables que se incluyen en el alcance del &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;cierre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51d29e872f0afd793829823b2b7b80ebb354988c" translate="yes" xml:space="preserve">
          <source>I usually pass one object to a function and have that function mutate whatever it needs (set defaults), then that function will pass it to another function that will do the same and so on and so on. Here is an example:</source>
          <target state="translated">Normalmente paso un objeto a una función y hago que esa función mute lo que necesite (establecer valores por defecto),luego esa función lo pasará a otra función que hará lo mismo y así sucesivamente.He aquí un ejemplo:</target>
        </trans-unit>
        <trans-unit id="3e1c56435bb8295e877cc0c85c18aa7f843177ad" translate="yes" xml:space="preserve">
          <source>I'm confused and cannot see why this happens.</source>
          <target state="translated">Estoy confundido y no puedo ver por qué sucede esto.</target>
        </trans-unit>
        <trans-unit id="fde27a0f508ac6064af12c4d8b939650e52d74e9" translate="yes" xml:space="preserve">
          <source>If after setting prototype part of inheritance you should have it point to the right function again.</source>
          <target state="translated">Si después de establecer el prototipo parte de la herencia debes hacer que apunte a la función correcta de nuevo.</target>
        </trans-unit>
        <trans-unit id="da522a6c41073e7a1c23b91110e0ce440840c41f" translate="yes" xml:space="preserve">
          <source>If ben was waiting for a red light and and bob was at a green light; then you'll invoke walk() on both ben and bob obviously something different would happen to ben and bob.</source>
          <target state="translated">Si Ben estaba esperando una luz roja y Bob estaba en una luz verde,entonces invocarás a Ben y Bob para que caminen,obviamente algo diferente les sucederá a Ben y Bob.</target>
        </trans-unit>
        <trans-unit id="11e4a4b87d427e615f87bbb7d7d0b5574e9d0999" translate="yes" xml:space="preserve">
          <source>If no second argument was given it'll return an empty object with first argument to be used as the returned object's prototype (the first object to be used in the returned object's prototype chain).</source>
          <target state="translated">Si no se ha dado un segundo argumento,devolverá un objeto vacío con el primer argumento para ser usado como el prototipo del objeto devuelto (el primer objeto a ser usado en la cadena de prototipos del objeto devuelto).</target>
        </trans-unit>
        <trans-unit id="45326f667c3b7dd729de1fff54fe465ea292ec6c" translate="yes" xml:space="preserve">
          <source>If you need (and you do in this case) separate instances of food collections for each Hamster, you need to create the property on the instance. For example:</source>
          <target state="translated">Si necesita (y lo hace en este caso)instancias separadas de recolección de alimentos para cada hámster,debe crear la propiedad en la instancia.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bf65b3d11ae75642ecded1c9d1c19caac84c3201" translate="yes" xml:space="preserve">
          <source>If you still insist on privates then the &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;following&lt;/a&gt; pattern may help. It doesn't implement private though but implements protected.</source>
          <target state="translated">Si a&amp;uacute;n insiste en lo privado, el &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;siguiente&lt;/a&gt; patr&amp;oacute;n puede ayudar. Sin embargo, no implementa privado, pero implementa protegido.</target>
        </trans-unit>
        <trans-unit id="b79b7554eff5c5557c88dc8d14f691a2491ed888" translate="yes" xml:space="preserve">
          <source>In all the example code you'll see &lt;code&gt;this&lt;/code&gt; referring to the current instance.</source>
          <target state="translated">En todo el c&amp;oacute;digo de ejemplo, ver&amp;aacute; &lt;code&gt;this&lt;/code&gt; haciendo referencia a la instancia actual.</target>
        </trans-unit>
        <trans-unit id="c51dd0d86d782b26cf283ada041cd94af0aa189e" translate="yes" xml:space="preserve">
          <source>In previous part we have seen that re assignment of members that come from an instance's prototype (ben.walk) will shadow that member (create walk on ben rather than changing Person.prototype.walk).</source>
          <target state="translated">En la parte anterior hemos visto que la reasignación de los miembros que provienen del prototipo de una instancia (ben.walk)hará sombra a ese miembro (crear paseo en ben en lugar de cambiar el paseo del prototipo de la persona).</target>
        </trans-unit>
        <trans-unit id="bd9ce7cacb78c648c9be29a9cf9471ae22e833f0" translate="yes" xml:space="preserve">
          <source>In the following example we assume that a Hamster can run 3km an hour but a Russion mini can only run half as fast. We can hard code 3/2 in RussionMini but if this value were to change we have multiple places in code where it needs changing. Here is how we use Hamster.prototype to get the parent (Hamster) speed.</source>
          <target state="translated">En el siguiente ejemplo asumimos que un hámster puede correr a 3 km por hora pero un mini de Russion sólo puede correr la mitad de rápido.Podemos codificar 32 en RussionMini,pero si este valor cambiara,tendríamos múltiples lugares en el código donde habría que cambiarlo.Así es como usamos el prototipo de Hamster para obtener la velocidad madre (de Hamster).</target>
        </trans-unit>
        <trans-unit id="968367429f9ee5051fb4a6a3e36c91706fe020f5" translate="yes" xml:space="preserve">
          <source>In this code I have removed name from prototype as well as food because you are most likely going to shadow this almost immediately when creating an instance anyway. Name is now an instance specific member with a default value set in the constructor function. Becaus the food member is also moved from prototype to instance specific member it will not affect bob.food when adding food to ben.</source>
          <target state="translated">En este código he eliminado el nombre del prototipo,así como la comida,porque lo más probable es que lo sombrees casi inmediatamente al crear una instancia de todos modos.El nombre es ahora un miembro específico de la instancia con un valor por defecto establecido en la función de construcción.Debido a que el miembro de la comida también se mueve del prototipo al miembro específico de la instancia,no afectará a Bob.food cuando añada comida a Ben.</target>
        </trans-unit>
        <trans-unit id="782c9829c985ba325100f3f912e7b73c3cc8a8d2" translate="yes" xml:space="preserve">
          <source>It's good because it enables you and others to mock certain members for testing easily. It gives others a chance to easily improve (patch) your code but this is also bad because there is no guarantee that a next version of your code has the same implementation and or private members.</source>
          <target state="translated">Es bueno porque le permite a usted y a otros burlarse de ciertos miembros para hacer pruebas fácilmente.Le da a otros la oportunidad de mejorar fácilmente (parchear)su código pero esto también es malo porque no hay garantía de que la próxima versión de su código tenga la misma implementación y/o miembros privados.</target>
        </trans-unit>
        <trans-unit id="8a6c3b4d25a0b9e7b9de12cbedcc883a943f7193" translate="yes" xml:space="preserve">
          <source>JavaScript doesn't have a private modifier.</source>
          <target state="translated">JavaScript no tiene un modificador privado.</target>
        </trans-unit>
        <trans-unit id="f4783878a60c2e2bedc9c4cb15e63c2cad8e91a8" translate="yes" xml:space="preserve">
          <source>Most of the patterns I've seen will either break when inheritance level is more than 2 levels (Child =&amp;gt; Parent =&amp;gt; GrandParent) or use more resources by implementing super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt;.</source>
          <target state="translated">La mayor&amp;iacute;a de los patrones que he visto se romper&amp;aacute;n cuando el nivel de herencia sea superior a 2 niveles (Child =&amp;gt; Parent =&amp;gt; GrandParent) o utilizar&amp;aacute;n m&amp;aacute;s recursos mediante la implementaci&amp;oacute;n de super a trav&amp;eacute;s de &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;cierres&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a86491f8b298b8b31ba2a6f4824cc3d924e08dba" translate="yes" xml:space="preserve">
          <source>Not implementing privates as closures would leak implementation and enable you or users extending your code to use members that are not part of your public API. This can be both good and bad.</source>
          <target state="translated">No implementar los privados como cierres filtraría la implementación y le permitiría a usted o a los usuarios que extienden su código utilizar miembros que no son parte de su API pública.Esto puede ser tanto bueno como malo.</target>
        </trans-unit>
        <trans-unit id="554811e64329329de8e99177229051265f514851" translate="yes" xml:space="preserve">
          <source>Person is the constructor function. When you create an instance using Person you have to use the new keyword:</source>
          <target state="translated">La persona es la función del constructor.Cuando se crea una instancia usando Person,hay que usar la nueva palabra clave:</target>
        </trans-unit>
        <trans-unit id="3d400767e83f5b3545ee60adf2bcccde144b2840" translate="yes" xml:space="preserve">
          <source>Prototypes are &lt;strong&gt;NOT&lt;/strong&gt; instantiated for each instance of an object.</source>
          <target state="translated">Los prototipos &lt;strong&gt;NO se&lt;/strong&gt; instancian para cada instancia de un objeto.</target>
        </trans-unit>
        <trans-unit id="cceb329f51a30a7a00183d2d4ed1d0655073e080" translate="yes" xml:space="preserve">
          <source>Prototypical inheritance - writing up</source>
          <target state="translated">Herencia prototípica-escribiendo</target>
        </trans-unit>
        <trans-unit id="64b8741afff5b09a35196deea479694b320fa7af" translate="yes" xml:space="preserve">
          <source>Set the prototype part of inheritance (RussionMini.prototype = Object.create(Hamster.prototype))</source>
          <target state="translated">Establecer el prototipo parte de la herencia (RussionMini.prototype=Object.create(Hamster.prototype))</target>
        </trans-unit>
        <trans-unit id="4b07cce27e263241a4a74f241d33c0a5433426cd" translate="yes" xml:space="preserve">
          <source>Shadowing members happens when we do something like &lt;code&gt;ben.walk=22&lt;/code&gt;, even though bob and ben share &lt;code&gt;walk&lt;/code&gt; the &lt;em&gt;assignment&lt;/em&gt; of 22 to ben.walk will not affect bob.walk. This is because that statement will create a member called &lt;code&gt;walk&lt;/code&gt; on ben directly and assign it a value of 22. There will be 2 different walk members: ben.walk and Person.prototype.walk.</source>
          <target state="translated">El sombreado de miembros ocurre cuando hacemos algo como &lt;code&gt;ben.walk=22&lt;/code&gt; , a pesar de que bob y ben comparten la &lt;em&gt;asignaci&amp;oacute;n&lt;/em&gt; de 22 a ben.walk no afectar&amp;aacute; a bob.walk. Esto se debe a que esa declaraci&amp;oacute;n crear&amp;aacute; un miembro llamado &lt;code&gt;walk&lt;/code&gt; on ben directamente y le asignar&amp;aacute; un valor de 22. Habr&amp;aacute; 2 miembros de caminata diferentes: ben.walk y Person.prototype.walk.</target>
        </trans-unit>
        <trans-unit id="525b7ccb7b92ac04a16fabaf6a882aee1fe90b3c" translate="yes" xml:space="preserve">
          <source>So I have these 2 examples, from javascript.info:</source>
          <target state="translated">Así que tengo estos 2 ejemplos,de javascript.info:</target>
        </trans-unit>
        <trans-unit id="1ea63f6cce56c9eca2d72522f3a7e51c6996b13a" translate="yes" xml:space="preserve">
          <source>Some things are better not to be inherited, if a Cat can move and then a Cat should not inherit from Movable. A Cat is not a Movable but rather a Cat can move. In a class based language Cat would have to implement Movable. In JavaScript we can define Movable and define implementation here, Cat can either override, extend it or us it's default implementation.</source>
          <target state="translated">Algunas cosas es mejor no heredarlas,si un Gato puede moverse y luego un Gato no debe heredarlas de Movible.Un gato no es un Movible,sino que un gato puede moverse.En un lenguaje basado en clases,el gato tendría que implementar Movible.En JavaScript podemos definir Movible y definir la implementación aquí,Cat puede anularlo,extenderlo o usar su implementación por defecto.</target>
        </trans-unit>
        <trans-unit id="ef53d380cd63d69c06e94e9adfd7ea3d789beae8" translate="yes" xml:space="preserve">
          <source>Some would set the prototype of RussionMini to an instance of Hamster (RussionMini.prototype = new Hamster()). This is not desirable because even though it accomplishes the same (RussionMini.prototype's prototype is Hamster.prototype) it also sets Hamster instance members as members of RussionMini.prototype. So RussionMini.prototype.food will exist but is a shared member (remember bob and ben in &quot;More about prototype&quot;?). The food member will be shadowed when creating a RussionMini because Hamster code is run with &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; that in turn runs &lt;code&gt;this.food = []&lt;/code&gt; but any Hamster members will still be members of RussionMini.prototype.</source>
          <target state="translated">Algunos establecer&amp;iacute;an el prototipo de RussionMini en una instancia de Hamster (RussionMini.prototype = new Hamster ()). Esto no es deseable porque aunque logra lo mismo (el prototipo de RussionMini.prototype es Hamster.prototype) tambi&amp;eacute;n establece a los miembros de la instancia de Hamster como miembros de RussionMini.prototype. Entonces RussionMini.prototype.food existir&amp;aacute; pero es un miembro compartido (&amp;iquest;recuerdan a Bob y Ben en &quot;M&amp;aacute;s sobre el prototipo&quot;?). El miembro de comida se sombrear&amp;aacute; al crear un RussionMini porque el c&amp;oacute;digo Hamster se ejecuta con &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; que a su vez ejecuta &lt;code&gt;this.food = []&lt;/code&gt; pero los miembros de Hamster seguir&amp;aacute;n siendo miembros de RussionMini.prototype.</target>
        </trans-unit>
        <trans-unit id="603053b2f1c406cdc9f1aba516ab35aa5644c02a" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;children&lt;/code&gt; need to extend &lt;code&gt;parent&lt;/code&gt; functions.</source>
          <target state="translated">Algunas veces los &lt;code&gt;children&lt;/code&gt; necesitan extender &lt;code&gt;parent&lt;/code&gt; funciones de los padres .</target>
        </trans-unit>
        <trans-unit id="dc46bcd4a8dbc5cd0a9473c19363d38ae051b890" translate="yes" xml:space="preserve">
          <source>Start from Example 2: when the code reaches &lt;code&gt;speedy.found&lt;/code&gt;, it finds no &lt;code&gt;found&lt;/code&gt; property in &lt;code&gt;speedy&lt;/code&gt;, and so it climbs up to the prototype and changes it there. That's why &lt;code&gt;food.length&lt;/code&gt; is equal for both hamsters, in other words they have the same stomach.</source>
          <target state="translated">Comience desde el Ejemplo 2: cuando el c&amp;oacute;digo alcanza &lt;code&gt;speedy.found&lt;/code&gt; , no encuentra ninguna propiedad &lt;code&gt;found&lt;/code&gt; en &lt;code&gt;speedy&lt;/code&gt; , por lo que sube al prototipo y lo cambia all&amp;iacute;. Es por eso que la &lt;code&gt;food.length&lt;/code&gt; es igual para ambos h&amp;aacute;msters, en otras palabras, tienen el mismo est&amp;oacute;mago.</target>
        </trans-unit>
        <trans-unit id="1c5ef60e0f791800e4f9fe96e6386ddd31add8b0" translate="yes" xml:space="preserve">
          <source>The above is a simple implementation that replaces same named functions with whatever mix in is mixed in last.</source>
          <target state="translated">Lo anterior es una simple implementación que reemplaza las funciones con el mismo nombre con cualquier mezcla que se mezcle en último lugar.</target>
        </trans-unit>
        <trans-unit id="91886ea4946327cd43e989ed9081a401237a0d2d" translate="yes" xml:space="preserve">
          <source>The code above shows that ben and bob share members from person. There is only one person, it is set as bob's and ben's prototype (person is used as the first object in the prototype chain to look up requested members that don't exist on the instance). The problem with the above code is that bob and ben should have their own &lt;code&gt;food&lt;/code&gt; member. This is where the constructor function comes in. It is used to create instance specific members. You could also pass arguments to it to set values of these instance specific members.</source>
          <target state="translated">El c&amp;oacute;digo anterior muestra que ben y bob comparten miembros de una persona. Solo hay una persona, se establece como prototipo de Bob y Ben (la persona se usa como el primer objeto en la cadena de prototipos para buscar los miembros solicitados que no existen en la instancia). El problema con el c&amp;oacute;digo anterior es que Bob y Ben deber&amp;iacute;an tener su propio miembro de &lt;code&gt;food&lt;/code&gt; . Aqu&amp;iacute; es donde entra la funci&amp;oacute;n constructora. Se utiliza para crear miembros espec&amp;iacute;ficos de instancia. Tambi&amp;eacute;n puede pasarle argumentos para establecer valores de estos miembros espec&amp;iacute;ficos de la instancia.</target>
        </trans-unit>
        <trans-unit id="ce16836f76cd9e02bb10ce77133484da4db12749" translate="yes" xml:space="preserve">
          <source>The constructor property is included in the prototype by JavaScript, you can change it but it should point to the constructor function. So &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; should point to Hamster.</source>
          <target state="translated">La propiedad del constructor est&amp;aacute; incluida en el prototipo por JavaScript, puede cambiarla pero debe apuntar a la funci&amp;oacute;n del constructor. Entonces &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; deber&amp;iacute;a apuntar a Hamster.</target>
        </trans-unit>
        <trans-unit id="ba2e7bfbfcc3ebee3a82668a2127dadc5a3a614c" translate="yes" xml:space="preserve">
          <source>The disadvantage is that you hard code Hamster.prototype. There may be patterns that will give you the advantage of &lt;code&gt;super&lt;/code&gt; as in Java.</source>
          <target state="translated">La desventaja es que codifica duro el prototipo Hamster. Puede haber patrones que le dar&amp;aacute;n la ventaja de &lt;code&gt;super&lt;/code&gt; como en Java.</target>
        </trans-unit>
        <trans-unit id="c0f31cb3709425be0a6f04c9d6a8e9bae7b0bdf4" translate="yes" xml:space="preserve">
          <source>The following code demonstrates the difference between prototype members and instance members by mutating members.</source>
          <target state="translated">El siguiente código demuestra la diferencia entre los miembros prototipo y los miembros instancia por los miembros mutantes.</target>
        </trans-unit>
        <trans-unit id="92d7047ac0b211ef42fa97b41187517206e5a323" translate="yes" xml:space="preserve">
          <source>The following code shows how to inherit. The tasks are basically the same as in code before with a little extra</source>
          <target state="translated">El siguiente código muestra cómo heredar.Las tareas son básicamente las mismas que en el código anterior con un pequeño extra</target>
        </trans-unit>
        <trans-unit id="b31cca01cbdf5bb975254cb59ea3db82b273ae80" translate="yes" xml:space="preserve">
          <source>The instances where this would refer to the wrong object are usually when attaching event listeners, callbacks or timeouts and intervals. In the next 2 lines of code we &lt;code&gt;pass&lt;/code&gt; the function, we don't invoke it. Passing the function is: &lt;code&gt;someObject.aFunction&lt;/code&gt; and invoking it is: &lt;code&gt;someObject.aFunction()&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value does not refer to the object the function was declared on but on the object that &lt;code&gt;invokes&lt;/code&gt; it.</source>
          <target state="translated">Los casos en los que esto se referir&amp;iacute;a al objeto incorrecto son generalmente cuando se conectan oyentes de eventos, devoluciones de llamada o tiempos de espera e intervalos. En las siguientes 2 l&amp;iacute;neas de c&amp;oacute;digo pasamos la funci&amp;oacute;n, no la invocamos. Pasar la funci&amp;oacute;n es: &lt;code&gt;someObject.aFunction&lt;/code&gt; e invocarla es: &lt;code&gt;someObject.aFunction()&lt;/code&gt; . El valor &lt;code&gt;this&lt;/code&gt; no se refiere al objeto en el que se declar&amp;oacute; la funci&amp;oacute;n, sino al objeto que lo &lt;code&gt;invokes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d633be38865f4cc00308b578d502e60cb128ba2" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;walk&lt;/code&gt; is part of Person.prototype and is shared for all instances bob and ben are instances of Person so they share the walk member (bob.walk===ben.walk).</source>
          <target state="translated">La &lt;code&gt;walk&lt;/code&gt; miembros es parte del prototipo Person.prototype y se comparte para todas las instancias, bob y ben son instancias de Person para que compartan el miembro de caminata (bob.walk === ben.walk).</target>
        </trans-unit>
        <trans-unit id="6b7f455cf9ed0f3eee5f17e212f56a94f50505d9" translate="yes" xml:space="preserve">
          <source>The next code shows another way to implement the constructor function, syntax is different but the idea is the same:</source>
          <target state="translated">El siguiente código muestra otra forma de implementar la función constructora,la sintaxis es diferente pero la idea es la misma:</target>
        </trans-unit>
        <trans-unit id="68b7a276695cb91b3cc1a5a46c42b89c5d2e1bc4" translate="yes" xml:space="preserve">
          <source>The property/member &lt;code&gt;name&lt;/code&gt; is instance specific, it's different for bob and ben</source>
          <target state="translated">El &lt;code&gt;name&lt;/code&gt; propiedad / miembro es espec&amp;iacute;fico de la instancia, es diferente para bob y ben</target>
        </trans-unit>
        <trans-unit id="34bac27fdaa771c107c0ae1ee0c876c8cccc0390" translate="yes" xml:space="preserve">
          <source>The this variable actually refers to the invoking object, it refers to the object that came before the function.</source>
          <target state="translated">Esta variable se refiere en realidad al objeto invocador,se refiere al objeto que vino antes de la función.</target>
        </trans-unit>
        <trans-unit id="dbeae5adf6a2e7873a50962c48c4d2650e1cad7a" translate="yes" xml:space="preserve">
          <source>This way of passing arguments in a function chain is useful in many cases. When you're working on code that would calculate a total of something and later you'd like to re factor the total of that something to be in a certain currency you may have to change a lot of functions to pass the value for currency. You could up scope a currency value (even to global like &lt;code&gt;window.currency='USD'&lt;/code&gt;) but that's a bad way to solve it.</source>
          <target state="translated">Esta forma de pasar argumentos en una cadena de funciones es &amp;uacute;til en muchos casos. Cuando trabaje en un c&amp;oacute;digo que calcule un total de algo y luego desee refactorizar el total de ese algo en una determinada moneda, es posible que tenga que cambiar muchas funciones para pasar el valor de la moneda. Puede aumentar el alcance de un valor de moneda (incluso global como &lt;code&gt;window.currency='USD'&lt;/code&gt; ), pero esa es una mala manera de resolverlo.</target>
        </trans-unit>
        <trans-unit id="881d70367fb2cb9071aabd702a8ddae76085a077" translate="yes" xml:space="preserve">
          <source>To answer your question about Example 1, if it doesn't find the property anywhere in the prototype chain, it creates the property on the target object.</source>
          <target state="translated">Para responder a su pregunta sobre el Ejemplo 1,si no encuentra la propiedad en ningún lugar de la cadena del prototipo,crea la propiedad en el objeto objetivo.</target>
        </trans-unit>
        <trans-unit id="caa724d08d862109a2da38689f2332f1ce655618" translate="yes" xml:space="preserve">
          <source>To clarify see the following code:</source>
          <target state="translated">Para aclarar,vea el siguiente código:</target>
        </trans-unit>
        <trans-unit id="6fa3de1fe95879c2e0e06bbcc67ffb2a5a9cacd6" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;this&lt;/code&gt; in the above cases refer to someObject you can pass a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; instead of the function directly:</source>
          <target state="translated">Para hacer &lt;code&gt;this&lt;/code&gt; en los casos anteriores, consulte someObject, puede pasar un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;cierre en&lt;/a&gt; lugar de la funci&amp;oacute;n directamente:</target>
        </trans-unit>
        <trans-unit id="95908275067ede0cb508056464f5d825f362df1f" translate="yes" xml:space="preserve">
          <source>To override a Parent (=Hamster) method you do the same but don't do Hamster.prototype.parentMethod.call(this,....</source>
          <target state="translated">Para anular un método Parent (=Hamster)haces lo mismo pero no haces Hamster.prototype.parentMethod.call(esto,...</target>
        </trans-unit>
        <trans-unit id="30981a69967a6193b8f04b92e8a40f2bd4f43877" translate="yes" xml:space="preserve">
          <source>Using a pattern some would call &quot;classical inheritance&quot;. If you are confused by the syntax I'll be happy to explain more or provide different patterns.</source>
          <target state="translated">Usando un patrón que algunos llamarían &quot;herencia clásica&quot;.Si está confundido por la sintaxis,estaré encantado de explicarle más o proporcionarle diferentes patrones.</target>
        </trans-unit>
        <trans-unit id="9d15948c93f4b3b1f746c221caff8d64929f5020" translate="yes" xml:space="preserve">
          <source>What if we don't re assign but mutate the member? Mutating is (for example) changing sub properties of an Object or invoking functions that will change the object's value. For example:</source>
          <target state="translated">¿Qué pasa si no asignamos sino que mutamos el miembro? Mutar es (por ejemplo)cambiar las sub-propiedades de un objeto o invocar funciones que cambien el valor del objeto.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d72ec19dd58257fe3e8938b8afc236576f1071ab" translate="yes" xml:space="preserve">
          <source>When Child calls a Parent (&lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt;) we assume that Hamster uses the same arguments as RussionMini in the same order. For functions that call other functions I usually use another way to pass arguments.</source>
          <target state="translated">Cuando Child llama a un padre ( &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; ) asumimos que Hamster usa los mismos argumentos que RussionMini en el mismo orden. Para las funciones que llaman a otras funciones, generalmente uso otra forma de pasar argumentos.</target>
        </trans-unit>
        <trans-unit id="1a8948d65f6b2ed854bc435e20bd64c244a77252" translate="yes" xml:space="preserve">
          <source>When asking for bob.walk you'll get the Person.prototype.walk function because &lt;code&gt;walk&lt;/code&gt; could not be found on bob. Asking for ben.walk however will get you the value 22 because the member walk has been created on ben and since JavaScript found walk on ben it will not look in the Person.prototype.</source>
          <target state="translated">Cuando solicite bob.walk obtendr&amp;aacute; la funci&amp;oacute;n Person.prototype.walk porque no se pudo encontrar &lt;code&gt;walk&lt;/code&gt; en bob. Sin embargo, si solicita ben.walk obtendr&amp;aacute; el valor 22 porque el miembro walk ha sido creado en ben y, dado que JavaScript encontr&amp;oacute; walk on ben, no se ver&amp;aacute; en el prototipo Person.prototype.</target>
        </trans-unit>
        <trans-unit id="dbae9f24b1b441346037a1a711472938fe1b0cdb" translate="yes" xml:space="preserve">
          <source>When using Object.create with 2 arguments, Object.defineProperty or Object.defineProperties shadowing works a bit different. More info on that &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Cuando se utiliza Object.create con 2 argumentos, el sombreado Object.defineProperty o Object.defineProperties funciona un poco diferente. M&amp;aacute;s informaci&amp;oacute;n sobre eso &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="944b2bf97bd3b09291debcbebf9c539ec6b669f8" translate="yes" xml:space="preserve">
          <source>With constructor functions you'll set the prototype in step 2 in the following code we set the prototype in step 3.</source>
          <target state="translated">Con las funciones de constructor se fijará el prototipo en el paso 2 en el siguiente código fijamos el prototipo en el paso 3.</target>
        </trans-unit>
        <trans-unit id="9298f1163ca32f5e167b7c0302b9ad1b3d88a666" translate="yes" xml:space="preserve">
          <source>With passing an object you could add currency to &lt;code&gt;args&lt;/code&gt; whenever it's available in the function chain and mutate/use it whenever you need it without changing the other functions (explicitly have to pass it in the function calls).</source>
          <target state="translated">Al pasar un objeto, puede agregar moneda a los &lt;code&gt;args&lt;/code&gt; cada vez que est&amp;eacute; disponible en la cadena de funciones y mutar / usar cuando lo necesite sin cambiar las otras funciones (expl&amp;iacute;citamente debe pasarlo en las llamadas a funciones).</target>
        </trans-unit>
        <trans-unit id="837db40af571b967b8c7124903cd4c716d0b7af4" translate="yes" xml:space="preserve">
          <source>You can implement private members through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; but instance specific private members can only be accessed by functions that are not on the prototype.</source>
          <target state="translated">Puede implementar miembros privados a trav&amp;eacute;s de &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;cierres,&lt;/a&gt; pero solo se puede acceder a miembros privados espec&amp;iacute;ficos de la instancia mediante funciones que no est&amp;aacute;n en el prototipo.</target>
        </trans-unit>
        <trans-unit id="307959edcb48ff33b2f62e2ee949b4df46321abd" translate="yes" xml:space="preserve">
          <source>You can indicate to other programmers a member is meant to be private by naming it &lt;code&gt;_aPrivate&lt;/code&gt; or putting all the private variables in an object variable called &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Puede indicar a otros programadores que un miembro debe ser privado nombr&amp;aacute;ndolo &lt;code&gt;_aPrivate&lt;/code&gt; o colocando todas las variables privadas en una variable de objeto llamada &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d5c1874c396599b4b5ab6617f2c4fbfc040617" translate="yes" xml:space="preserve">
          <source>You can use a function as a constructor to create objects, if the constructor function is named Person then the object(s) created with that constructor are instances of Person.</source>
          <target state="translated">Se puede utilizar una función como constructor para crear objetos,si la función de constructor se denomina Persona,entonces el objeto o los objetos creados con ese constructor son instancias de Persona.</target>
        </trans-unit>
        <trans-unit id="1e4718352a5ddbc9ba763c0a0a57cbf4ee7d57b4" translate="yes" xml:space="preserve">
          <source>You may come across similar patterns that are more robust to help with object creation and object definition.</source>
          <target state="translated">Puede que te encuentres con patrones similares que son más robustos para ayudar a la creación y definición de objetos.</target>
        </trans-unit>
        <trans-unit id="03c004c041a8ade78e5fa468755470e910975a73" translate="yes" xml:space="preserve">
          <source>You want the 'child' (=RussionMini) to do something extra. When RussionMini can call the Hamster code to do something and then do something extra you don't need to copy and paste Hamster code to RussionMini.</source>
          <target state="translated">Quieres que el &quot;niño&quot; (=RussionMini)haga algo extra.Cuando RussionMini puede llamar al código del hámster para hacer algo y luego hacer algo extra no necesitas copiar y pegar el código del hámster a RussionMini.</target>
        </trans-unit>
        <trans-unit id="ed3bcead2d06b24e9a79e412965282dc663fdf5e" translate="yes" xml:space="preserve">
          <source>we run &lt;code&gt;rabbit.eat&lt;/code&gt;, which changes &lt;code&gt;rabbit.full&lt;/code&gt;. &lt;code&gt;full&lt;/code&gt; property is nowhere to be found, so it should go up the prototype chain to (to object??), and well, I'm not sure what happens here. In this example the property &lt;code&gt;full&lt;/code&gt; of &lt;code&gt;rabbit&lt;/code&gt; is created and changed, while in the first example it goes up the prototype chain because it cannot find the property.</source>
          <target state="translated">ejecutamos &lt;code&gt;rabbit.eat&lt;/code&gt; , que cambia &lt;code&gt;rabbit.full&lt;/code&gt; . no se encuentra ninguna propiedad &lt;code&gt;full&lt;/code&gt; , por lo que deber&amp;iacute;a subir la cadena del prototipo a (&amp;iquest;objetar?), y bueno, no estoy seguro de lo que sucede aqu&amp;iacute;. En este ejemplo, la propiedad &lt;code&gt;full&lt;/code&gt; de &lt;code&gt;rabbit&lt;/code&gt; se crea y cambia, mientras que en el primer ejemplo sube por la cadena del prototipo porque no puede encontrar la propiedad.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
