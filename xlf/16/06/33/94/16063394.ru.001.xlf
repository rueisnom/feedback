<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/16063394">
    <body>
      <group id="16063394">
        <trans-unit id="74cf125fecd9be94bfb57de2381f05816742688b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Multiple inheritance&quot; with mix ins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;Множественное наследование&amp;raquo; с миксами&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f60012486871de55c32083b7c52aef92ab1d2228" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function introduction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Введение в конструктор функций&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="464c26fcf651c9497932220210a67991e239e32a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extending and overriding Parent functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Расширение и переопределение родительских функций&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7422920ac45432c6122783701aa363fe96aaf2b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Inheritance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091e6370d4f77a8fb1c6e19fd7ffd43862df251e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More about prototype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подробнее о прототипе&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="905e17e869df8f106b1d829cc87a51393ce68750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object.create to set prototype part of inheritance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Object.create для установки прототипа части наследования&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5cbcd9b4b225cb9887c626d6879881f3ae6eded" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing (constructor) arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача (конструктор) аргументов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ee7541772d496e52c1e2bd3a4d436dc1e23236e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private variables&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Частные переменные&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b58eaa69cc21de153eaf2108e426b123ef846c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The this variable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Эта переменная&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24127a0a55a2a41dda788b7ff3a0a8ecd74bbf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.constructor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2c84fbef3dfee70da18aa5795b9c02c1f412822" translate="yes" xml:space="preserve">
          <source>An object can inherit from another object through the use of prototype. You can set the prototype of any object with any other object using &lt;code&gt;Object.create&lt;/code&gt;. In the constructor function introduction we have seen that if a member can't be found on the object then JavaScript will look in the prototpe chain for it.</source>
          <target state="translated">Объект может наследоваться от другого объекта посредством использования прототипа. Вы можете установить прототип любого объекта с любым другим объектом, используя &lt;code&gt;Object.create&lt;/code&gt; . Во введении функции конструктора мы видели, что если элемент не может быть найден в объекте, тогда JavaScript будет искать его в цепочке прототипов.</target>
        </trans-unit>
        <trans-unit id="cbe7e26021ebaa520f3f0662be1d2cd9e0ac3e41" translate="yes" xml:space="preserve">
          <source>Another reason could be that to create a Hamster a lot of complicated calculations need be done on passed arguments that may be not available yet, again you could pass in dummy arguments but it could unnecessarily complicate your code.</source>
          <target state="translated">Другая причина может заключаться в том,что для создания хомячка необходимо выполнить множество сложных вычислений по переданным аргументам,которые могут быть еще недоступны,опять же можно передать фиктивные аргументы,но это может неоправданно усложнить ваш код.</target>
        </trans-unit>
        <trans-unit id="b17fe45dfada0a306c0914b347e348b9ca0852b5" translate="yes" xml:space="preserve">
          <source>BUT in Example 1 something else happens:</source>
          <target state="translated">Но в примере 1 происходит что-то другое:</target>
        </trans-unit>
        <trans-unit id="4ee710d2c9f34cfc2049bc5cdbb2fb193e95ac12" translate="yes" xml:space="preserve">
          <source>Because walk() could not be found on bob directly JavaScript will look for it in the Person.prototype as this is the constructor of bob. If it can't be found there it'll look on Object.prototype. This is called the prototype chain. The prototype part of inheritance is done by lengthening this chain; for example bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (more on inheritance later).</source>
          <target state="translated">Поскольку walk () не может быть найден непосредственно на bob, JavaScript будет искать его в Person.prototype, так как это конструктор bob. Если это не может быть найдено там, это будет смотреть на Object.prototype. Это называется прототипом цепи. Прототипная часть наследования осуществляется путем удлинения этой цепочки; например, bob =&amp;gt; Employee.prototype =&amp;gt; Person.prototype =&amp;gt; Object.prototype (подробнее о наследовании позже).</target>
        </trans-unit>
        <trans-unit id="b12c833356fce30b677bb5007b4eca7f1cf9586b" translate="yes" xml:space="preserve">
          <source>By using closures you do not give others a choice and by using the naming convention with documentation you do. This is not specific to JavaScript, in other languages you can decide not to use private members as you trust others to know what they are doing and give them the choice to do as they want (with risks involved).</source>
          <target state="translated">Используя замыкания,вы не предоставляете другим возможность выбора и,используя соглашение об именах с документацией,вы это делаете.Это не специфично для JavaScript,на других языках вы можете решить не использовать частных членов,так как вы доверяете другим,чтобы они знали,что они делают,и даёте им выбор делать то,что они хотят (с риском).</target>
        </trans-unit>
        <trans-unit id="48e7bf94fdffad6556b22447c07ca6a043f61d30" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 1 and for objects that inherit have them run the Parent code as well (Hamster.apply(this,arguments);)</source>
          <target state="translated">Создайте экземпляр,выполняющий код на шаге 1,а для объектов,которые наследуют,запустите также и Родительский код (Hamster.apply(this,arguments);)</target>
        </trans-unit>
        <trans-unit id="9cafc324364ac8f9b0b7fbc766cc44ec930d2327" translate="yes" xml:space="preserve">
          <source>Create an instance running the code in step 2.</source>
          <target state="translated">Создайте экземпляр,выполняющий код на шаге 2.</target>
        </trans-unit>
        <trans-unit id="bab01f763c8928cbac3d62d6a5f840594c8f828b" translate="yes" xml:space="preserve">
          <source>Define an object that has members that will be same for many instances (person is a blueprint for bob and ben and can be for jilly, marie, clair ...)</source>
          <target state="translated">Определите объект,который имеет членов,которые будут одинаковыми во многих случаях (человек является чертежом для Боба и Бена и может быть для jilly,Мари,Клэр ...).</target>
        </trans-unit>
        <trans-unit id="0369ebd98eda3b5d7bf11c618aea1f74bd1b7cd8" translate="yes" xml:space="preserve">
          <source>Define instance specific members of an object (functions Hamster and RussionMini).</source>
          <target state="translated">Определите конкретные экземпляры членов объекта (функции Hamster и RussionMini).</target>
        </trans-unit>
        <trans-unit id="15a6e2970bdac2aa16360ffbe8c78946b52ff0eb" translate="yes" xml:space="preserve">
          <source>Define instance specific members that should be unique for instances (bob and ben).</source>
          <target state="translated">Определите членов,относящихся к конкретным случаям,которые должны быть уникальными для случаев (bob и ben).</target>
        </trans-unit>
        <trans-unit id="f0566c177d01aa7ea879a7591493f45ebcd632b6" translate="yes" xml:space="preserve">
          <source>Define members that can be shared among instances.(Hamster.prototype and RussionMini.prototype)</source>
          <target state="translated">Определите члены,которые могут совместно использоваться экземплярами (Hamster.prototype и RussionMini.prototype).</target>
        </trans-unit>
        <trans-unit id="1cc64015257eb076b900848a79305e97c1168f09" translate="yes" xml:space="preserve">
          <source>Even though bob, ben and all other created Person instances share walk the function will behave differently per instance because in the walk function it uses &lt;code&gt;this&lt;/code&gt;. The value of &lt;code&gt;this&lt;/code&gt; will be the invoking object; for now let's say it's the current instance so for &lt;code&gt;bob.walk()&lt;/code&gt; &quot;this&quot; will be bob. (more on &quot;this&quot; and the invoking object later).</source>
          <target state="translated">Даже если bob, ben и все другие созданные экземпляры Person совместно используют walk, функция будет вести себя по-разному в каждом экземпляре, потому что в функции walk она использует &lt;code&gt;this&lt;/code&gt; . Значением &lt;code&gt;this&lt;/code&gt; будет вызывающий объект; сейчас скажем, что это текущий экземпляр, поэтому для &lt;code&gt;bob.walk()&lt;/code&gt; &amp;laquo;this&amp;raquo; будет bob. (подробнее об этом и вызывающем объекте позже).</target>
        </trans-unit>
        <trans-unit id="8829ee8adb882bc56fe22bb8afb9246c1e8abb66" translate="yes" xml:space="preserve">
          <source>Every instance of Hamster will share that array</source>
          <target state="translated">Каждый экземпляр Хомяка разделит этот массив</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">Пример 1:</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">Пример 2:</target>
        </trans-unit>
        <trans-unit id="d74d95fa8fca84cad0d34ec6afae31477e7ee53f" translate="yes" xml:space="preserve">
          <source>For Movable we have instance specific members (like &lt;code&gt;location&lt;/code&gt;). And we have members that are not instance specific (like the function move()). Instance specific members will be set by calling mxIns (added by mixin helper function) when creating an instance. Prototype members will be copied one by one on Cat.prototype from Movable.prototype using the mixin helper function.</source>
          <target state="translated">Для Movable у нас есть конкретные элементы экземпляра (например, &lt;code&gt;location&lt;/code&gt; ) И у нас есть члены, которые не являются специфичными для экземпляра (например, функция move ()). Специфичные члены экземпляра будут установлены с помощью вызова mxIns (добавленного вспомогательной функцией mixin) при создании экземпляра. Члены прототипа будут скопированы один за другим в Cat.prototype из Movable.prototype с помощью вспомогательной функции mixin.</target>
        </trans-unit>
        <trans-unit id="d4034236af5962aabc90bc340970cf5500bed73f" translate="yes" xml:space="preserve">
          <source>From this I understand, that when writing up and adding a new property which doesn't exist, the interpreter will go up the prototype chain until it finds the property, and THEN change it.</source>
          <target state="translated">Из этого я понимаю,что при написании и добавлении нового свойства,которого не существует,интерпретатор будет идти вверх по цепочке прототипов,пока не найдет это свойство,и НЕ изменит его.</target>
        </trans-unit>
        <trans-unit id="c6720ee66246445f87a7ba9b7c392e804525fab2" translate="yes" xml:space="preserve">
          <source>Here is the documentation about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;, it basically returns the second argument (not supported in the polyfil) with the first argument as the returned object's prototype.</source>
          <target state="translated">Вот документация по &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; , в основном он возвращает второй аргумент (не поддерживается в полифиле) с первым аргументом в качестве прототипа возвращаемого объекта.</target>
        </trans-unit>
        <trans-unit id="e848ec5629ff1294871791ebbf63e38cc2338e10" translate="yes" xml:space="preserve">
          <source>I agree with the following: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; and personally have not used them.</source>
          <target state="translated">Я согласен со следующим: &lt;a href=&quot;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&quot;&gt;http://blog.millermedeiros.com/a-case-against-private-variables-and-functions-in-javascript/&lt;/a&gt; и лично ими не пользовался.</target>
        </trans-unit>
        <trans-unit id="cbe2e3d4e71526c44ee323b9c2c5afb89e673b0d" translate="yes" xml:space="preserve">
          <source>I like to define functions that return a function for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; on the prototype to have fine control over the variables that are included in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; scope.</source>
          <target state="translated">Мне нравится определять функции, которые возвращают функцию для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;замыканий&lt;/a&gt; в прототипе, чтобы иметь точный контроль над переменными, включенными в область &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;замыканий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51d29e872f0afd793829823b2b7b80ebb354988c" translate="yes" xml:space="preserve">
          <source>I usually pass one object to a function and have that function mutate whatever it needs (set defaults), then that function will pass it to another function that will do the same and so on and so on. Here is an example:</source>
          <target state="translated">Обычно я передаю один объект в функцию и заставляю эту функцию мутировать все,что ей нужно (установить по умолчанию),затем эта функция передает его в другую функцию,которая будет делать то же самое,и так далее,и так далее.Вот пример:</target>
        </trans-unit>
        <trans-unit id="3e1c56435bb8295e877cc0c85c18aa7f843177ad" translate="yes" xml:space="preserve">
          <source>I'm confused and cannot see why this happens.</source>
          <target state="translated">Я в замешательстве и не могу понять,почему это происходит.</target>
        </trans-unit>
        <trans-unit id="fde27a0f508ac6064af12c4d8b939650e52d74e9" translate="yes" xml:space="preserve">
          <source>If after setting prototype part of inheritance you should have it point to the right function again.</source>
          <target state="translated">Если после установки прототипа часть наследования должна снова указывать на нужную функцию.</target>
        </trans-unit>
        <trans-unit id="da522a6c41073e7a1c23b91110e0ce440840c41f" translate="yes" xml:space="preserve">
          <source>If ben was waiting for a red light and and bob was at a green light; then you'll invoke walk() on both ben and bob obviously something different would happen to ben and bob.</source>
          <target state="translated">Если бы Бен ждал красного света,а Боб был на зеленом,то вы бы вызвали функцию walk()и на Бене,и на Бобе,очевидно,что с Беном и Бобом случилось бы что-то другое.</target>
        </trans-unit>
        <trans-unit id="11e4a4b87d427e615f87bbb7d7d0b5574e9d0999" translate="yes" xml:space="preserve">
          <source>If no second argument was given it'll return an empty object with first argument to be used as the returned object's prototype (the first object to be used in the returned object's prototype chain).</source>
          <target state="translated">Если второй аргумент не был указан,то возвращается пустой объект с первым аргументом,который будет использоваться в качестве прототипа возвращаемого объекта (первый объект,который будет использоваться в цепочке прототипов возвращаемого объекта).</target>
        </trans-unit>
        <trans-unit id="45326f667c3b7dd729de1fff54fe465ea292ec6c" translate="yes" xml:space="preserve">
          <source>If you need (and you do in this case) separate instances of food collections for each Hamster, you need to create the property on the instance. For example:</source>
          <target state="translated">Если вам нужно (и вы делаете в этом случае)отдельные экземпляры коллекций пищи для каждого хомяка,вам нужно создать свойство на экземпляр.Например:</target>
        </trans-unit>
        <trans-unit id="bf65b3d11ae75642ecded1c9d1c19caac84c3201" translate="yes" xml:space="preserve">
          <source>If you still insist on privates then the &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;following&lt;/a&gt; pattern may help. It doesn't implement private though but implements protected.</source>
          <target state="translated">Если вы все еще настаиваете на частных лицах, то может помочь &lt;a href=&quot;https://stackoverflow.com/a/21800194/1641941&quot;&gt;следующий&lt;/a&gt; шаблон. Это не реализует приватный, но реализует защищенный.</target>
        </trans-unit>
        <trans-unit id="b79b7554eff5c5557c88dc8d14f691a2491ed888" translate="yes" xml:space="preserve">
          <source>In all the example code you'll see &lt;code&gt;this&lt;/code&gt; referring to the current instance.</source>
          <target state="translated">Во всем примере кода вы увидите, что &lt;code&gt;this&lt;/code&gt; относится к текущему экземпляру.</target>
        </trans-unit>
        <trans-unit id="c51dd0d86d782b26cf283ada041cd94af0aa189e" translate="yes" xml:space="preserve">
          <source>In previous part we have seen that re assignment of members that come from an instance's prototype (ben.walk) will shadow that member (create walk on ben rather than changing Person.prototype.walk).</source>
          <target state="translated">В предыдущей части мы видели,что повторное назначение членов,которые приходят из прототипа экземпляра (ben.walk)будет тенью для этого члена (создайте walk on ben,а не меняйте Person.prototype.walk).</target>
        </trans-unit>
        <trans-unit id="bd9ce7cacb78c648c9be29a9cf9471ae22e833f0" translate="yes" xml:space="preserve">
          <source>In the following example we assume that a Hamster can run 3km an hour but a Russion mini can only run half as fast. We can hard code 3/2 in RussionMini but if this value were to change we have multiple places in code where it needs changing. Here is how we use Hamster.prototype to get the parent (Hamster) speed.</source>
          <target state="translated">В следующем примере мы предполагаем,что Хомяк может бегать 3 км в час,а Russion mini может бегать только наполовину быстрее.Мы можем работать с жестким кодом 32 в RussionMini,но если это значение изменится,у нас есть несколько мест в коде,где его нужно изменить.Вот как мы используем Hamster.prototype,чтобы получить скорость родителя (Hamster).</target>
        </trans-unit>
        <trans-unit id="968367429f9ee5051fb4a6a3e36c91706fe020f5" translate="yes" xml:space="preserve">
          <source>In this code I have removed name from prototype as well as food because you are most likely going to shadow this almost immediately when creating an instance anyway. Name is now an instance specific member with a default value set in the constructor function. Becaus the food member is also moved from prototype to instance specific member it will not affect bob.food when adding food to ben.</source>
          <target state="translated">В этом коде я удалил имя из прототипа,а также из еды,потому что вы,скорее всего,будете тениться почти сразу же при создании экземпляра в любом случае.Имя теперь является членом конкретного экземпляра со значением по умолчанию,заданным в функции конструктора.Becaus еда член также перемещается из прототипа в экземпляр конкретного члена он не будет влиять на bob.food при добавлении еды в ben.</target>
        </trans-unit>
        <trans-unit id="782c9829c985ba325100f3f912e7b73c3cc8a8d2" translate="yes" xml:space="preserve">
          <source>It's good because it enables you and others to mock certain members for testing easily. It gives others a chance to easily improve (patch) your code but this is also bad because there is no guarantee that a next version of your code has the same implementation and or private members.</source>
          <target state="translated">Это хорошо,потому что это позволяет вам и другим издеваться над некоторыми членами для тестирования легко.Это дает другим возможность легко улучшить (исправить)ваш код,но это также плохо,потому что нет гарантии,что следующая версия вашего кода имеет ту же реализацию и или частных членов.</target>
        </trans-unit>
        <trans-unit id="8a6c3b4d25a0b9e7b9de12cbedcc883a943f7193" translate="yes" xml:space="preserve">
          <source>JavaScript doesn't have a private modifier.</source>
          <target state="translated">В JavaScript нет частного модификатора.</target>
        </trans-unit>
        <trans-unit id="f4783878a60c2e2bedc9c4cb15e63c2cad8e91a8" translate="yes" xml:space="preserve">
          <source>Most of the patterns I've seen will either break when inheritance level is more than 2 levels (Child =&amp;gt; Parent =&amp;gt; GrandParent) or use more resources by implementing super through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt;.</source>
          <target state="translated">Большинство шаблонов, которые я видел, будут ломаться, когда уровень наследования превышает 2 уровня (Child =&amp;gt; Parent =&amp;gt; GrandParent), или использовать больше ресурсов, реализуя super через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;замыкания&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a86491f8b298b8b31ba2a6f4824cc3d924e08dba" translate="yes" xml:space="preserve">
          <source>Not implementing privates as closures would leak implementation and enable you or users extending your code to use members that are not part of your public API. This can be both good and bad.</source>
          <target state="translated">Отказ от реализации privates в качестве закрытия приведет к утечке реализации и позволит Вам или пользователям,расширяющим Ваш код,использовать членов,которые не являются частью Вашего публичного API.Это может быть как хорошо,так и плохо.</target>
        </trans-unit>
        <trans-unit id="554811e64329329de8e99177229051265f514851" translate="yes" xml:space="preserve">
          <source>Person is the constructor function. When you create an instance using Person you have to use the new keyword:</source>
          <target state="translated">Человек-это функция конструктора.Когда вы создаете экземпляр с помощью Person,вы должны использовать новое ключевое слово:</target>
        </trans-unit>
        <trans-unit id="3d400767e83f5b3545ee60adf2bcccde144b2840" translate="yes" xml:space="preserve">
          <source>Prototypes are &lt;strong&gt;NOT&lt;/strong&gt; instantiated for each instance of an object.</source>
          <target state="translated">Прототипы &lt;strong&gt;НЕ&lt;/strong&gt; создаются для каждого экземпляра объекта.</target>
        </trans-unit>
        <trans-unit id="cceb329f51a30a7a00183d2d4ed1d0655073e080" translate="yes" xml:space="preserve">
          <source>Prototypical inheritance - writing up</source>
          <target state="translated">Прототипное наследование-запись</target>
        </trans-unit>
        <trans-unit id="64b8741afff5b09a35196deea479694b320fa7af" translate="yes" xml:space="preserve">
          <source>Set the prototype part of inheritance (RussionMini.prototype = Object.create(Hamster.prototype))</source>
          <target state="translated">Установить часть наследования прототипа (RussionMini.prototype=Object.create(Hamster.prototype))</target>
        </trans-unit>
        <trans-unit id="4b07cce27e263241a4a74f241d33c0a5433426cd" translate="yes" xml:space="preserve">
          <source>Shadowing members happens when we do something like &lt;code&gt;ben.walk=22&lt;/code&gt;, even though bob and ben share &lt;code&gt;walk&lt;/code&gt; the &lt;em&gt;assignment&lt;/em&gt; of 22 to ben.walk will not affect bob.walk. This is because that statement will create a member called &lt;code&gt;walk&lt;/code&gt; on ben directly and assign it a value of 22. There will be 2 different walk members: ben.walk and Person.prototype.walk.</source>
          <target state="translated">Слежение за участниками происходит, когда мы делаем что-то вроде &lt;code&gt;ben.walk=22&lt;/code&gt; , хотя bob и ben share &lt;code&gt;walk&lt;/code&gt; &lt;em&gt;назначение&lt;/em&gt; 22 для ben.walk не повлияет на bob.walk. Это связано с тем, что этот оператор создаст элемент с именем &lt;code&gt;walk&lt;/code&gt; on ben напрямую и присвоит ему значение 22. Будет два разных элемента walk: ben.walk и Person.prototype.walk.</target>
        </trans-unit>
        <trans-unit id="525b7ccb7b92ac04a16fabaf6a882aee1fe90b3c" translate="yes" xml:space="preserve">
          <source>So I have these 2 examples, from javascript.info:</source>
          <target state="translated">Итак,у меня есть эти 2 примера,из javascript.info:</target>
        </trans-unit>
        <trans-unit id="1ea63f6cce56c9eca2d72522f3a7e51c6996b13a" translate="yes" xml:space="preserve">
          <source>Some things are better not to be inherited, if a Cat can move and then a Cat should not inherit from Movable. A Cat is not a Movable but rather a Cat can move. In a class based language Cat would have to implement Movable. In JavaScript we can define Movable and define implementation here, Cat can either override, extend it or us it's default implementation.</source>
          <target state="translated">Некоторые вещи лучше не наследовать,если кошка может двигаться,и тогда кошка не должна наследовать от Movable.Кошка не является Подвижным,а скорее может двигаться.В классе,основанном на языке,Кошка должна будет реализовать Подвижность.В JavaScript мы можем определить Movable и определить реализацию здесь,Cat может либо переопределить,либо расширить его,либо мы можем определить реализацию по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ef53d380cd63d69c06e94e9adfd7ea3d789beae8" translate="yes" xml:space="preserve">
          <source>Some would set the prototype of RussionMini to an instance of Hamster (RussionMini.prototype = new Hamster()). This is not desirable because even though it accomplishes the same (RussionMini.prototype's prototype is Hamster.prototype) it also sets Hamster instance members as members of RussionMini.prototype. So RussionMini.prototype.food will exist but is a shared member (remember bob and ben in &quot;More about prototype&quot;?). The food member will be shadowed when creating a RussionMini because Hamster code is run with &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; that in turn runs &lt;code&gt;this.food = []&lt;/code&gt; but any Hamster members will still be members of RussionMini.prototype.</source>
          <target state="translated">Некоторые установят прототип RussionMini для экземпляра Hamster (RussionMini.prototype = new Hamster ()). Это нежелательно, потому что, хотя он выполняет то же самое (прототипом RussionMini.prototype является Hamster.prototype), он также устанавливает члены экземпляра Hamster в качестве членов RussionMini.prototype. Таким образом, RussionMini.prototype.food будет существовать, но является общим членом (помните, Боб и Бен в &amp;laquo;Подробнее о прототипе&amp;raquo;?). Элемент питания будет скрыт при создании RussionMini, потому что код Hamster запускается с помощью &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; который, в свою очередь, запускает &lt;code&gt;this.food = []&lt;/code&gt; но все участники Hamster по-прежнему будут членами RussionMini.prototype.</target>
        </trans-unit>
        <trans-unit id="603053b2f1c406cdc9f1aba516ab35aa5644c02a" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;code&gt;children&lt;/code&gt; need to extend &lt;code&gt;parent&lt;/code&gt; functions.</source>
          <target state="translated">Иногда &lt;code&gt;children&lt;/code&gt; необходимо расширить &lt;code&gt;parent&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="dc46bcd4a8dbc5cd0a9473c19363d38ae051b890" translate="yes" xml:space="preserve">
          <source>Start from Example 2: when the code reaches &lt;code&gt;speedy.found&lt;/code&gt;, it finds no &lt;code&gt;found&lt;/code&gt; property in &lt;code&gt;speedy&lt;/code&gt;, and so it climbs up to the prototype and changes it there. That's why &lt;code&gt;food.length&lt;/code&gt; is equal for both hamsters, in other words they have the same stomach.</source>
          <target state="translated">Начнем с примера 2: когда код достигает &lt;code&gt;speedy.found&lt;/code&gt; , он не &lt;code&gt;found&lt;/code&gt; свойство found в &lt;code&gt;speedy&lt;/code&gt; , поэтому он поднимается до прототипа и изменяет его там. Вот почему &lt;code&gt;food.length&lt;/code&gt; одинакова для обоих хомяков, иными словами, у них одинаковый желудок.</target>
        </trans-unit>
        <trans-unit id="1c5ef60e0f791800e4f9fe96e6386ddd31add8b0" translate="yes" xml:space="preserve">
          <source>The above is a simple implementation that replaces same named functions with whatever mix in is mixed in last.</source>
          <target state="translated">Вышеуказанное является простой реализацией,которая заменяет те же самые именованные функции тем,что смешивается в последнем.</target>
        </trans-unit>
        <trans-unit id="91886ea4946327cd43e989ed9081a401237a0d2d" translate="yes" xml:space="preserve">
          <source>The code above shows that ben and bob share members from person. There is only one person, it is set as bob's and ben's prototype (person is used as the first object in the prototype chain to look up requested members that don't exist on the instance). The problem with the above code is that bob and ben should have their own &lt;code&gt;food&lt;/code&gt; member. This is where the constructor function comes in. It is used to create instance specific members. You could also pass arguments to it to set values of these instance specific members.</source>
          <target state="translated">Код выше показывает, что Бен и Боб разделяют участников от человека. Существует только один человек, он установлен как прототип Боба и Бена (человек используется в качестве первого объекта в цепочке прототипов для поиска запрошенных членов, которые не существуют в экземпляре). Проблема с приведенным выше кодом заключается в том, что у Боба и Бена должен быть свой член &lt;code&gt;food&lt;/code&gt; . Вот где приходит функция конструктора. Она используется для создания элементов, специфичных для экземпляра. Вы также можете передать ему аргументы, чтобы установить значения этих конкретных элементов экземпляра.</target>
        </trans-unit>
        <trans-unit id="ce16836f76cd9e02bb10ce77133484da4db12749" translate="yes" xml:space="preserve">
          <source>The constructor property is included in the prototype by JavaScript, you can change it but it should point to the constructor function. So &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; should point to Hamster.</source>
          <target state="translated">Свойство конструктора включено в прототип JavaScript, вы можете изменить его, но оно должно указывать на функцию конструктора. Таким образом, &lt;code&gt;Hamster.prototype.constructor&lt;/code&gt; должен указывать на Hamster.</target>
        </trans-unit>
        <trans-unit id="ba2e7bfbfcc3ebee3a82668a2127dadc5a3a614c" translate="yes" xml:space="preserve">
          <source>The disadvantage is that you hard code Hamster.prototype. There may be patterns that will give you the advantage of &lt;code&gt;super&lt;/code&gt; as in Java.</source>
          <target state="translated">Недостаток в том, что у вас жесткий код Hamster.prototype. Могут быть шаблоны, которые дадут вам преимущество &lt;code&gt;super&lt;/code&gt; как в Java.</target>
        </trans-unit>
        <trans-unit id="c0f31cb3709425be0a6f04c9d6a8e9bae7b0bdf4" translate="yes" xml:space="preserve">
          <source>The following code demonstrates the difference between prototype members and instance members by mutating members.</source>
          <target state="translated">Следующий код демонстрирует разницу между членами прототипа и членами экземпляра,мутируя членов.</target>
        </trans-unit>
        <trans-unit id="92d7047ac0b211ef42fa97b41187517206e5a323" translate="yes" xml:space="preserve">
          <source>The following code shows how to inherit. The tasks are basically the same as in code before with a little extra</source>
          <target state="translated">Следующий код показывает,как наследовать.Задачи в основном те же самые,что и в коде до этого,с небольшим дополнительным</target>
        </trans-unit>
        <trans-unit id="b31cca01cbdf5bb975254cb59ea3db82b273ae80" translate="yes" xml:space="preserve">
          <source>The instances where this would refer to the wrong object are usually when attaching event listeners, callbacks or timeouts and intervals. In the next 2 lines of code we &lt;code&gt;pass&lt;/code&gt; the function, we don't invoke it. Passing the function is: &lt;code&gt;someObject.aFunction&lt;/code&gt; and invoking it is: &lt;code&gt;someObject.aFunction()&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value does not refer to the object the function was declared on but on the object that &lt;code&gt;invokes&lt;/code&gt; it.</source>
          <target state="translated">Случаи, когда это относится к неправильному объекту, обычно происходят при подключении прослушивателей событий, обратных вызовов или тайм-аутов и интервалов. В следующих двух строках кода мы &lt;code&gt;pass&lt;/code&gt; функцию, мы не вызываем ее. Передача функции: &lt;code&gt;someObject.aFunction&lt;/code&gt; и ее &lt;code&gt;someObject.aFunction()&lt;/code&gt; : someObject.aFunction () . Значение &lt;code&gt;this&lt;/code&gt; относится не к объекту, для которого была объявлена ​​функция, а к объекту, который ее &lt;code&gt;invokes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d633be38865f4cc00308b578d502e60cb128ba2" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;walk&lt;/code&gt; is part of Person.prototype and is shared for all instances bob and ben are instances of Person so they share the walk member (bob.walk===ben.walk).</source>
          <target state="translated">&lt;code&gt;walk&lt;/code&gt; участника является частью Person.prototype и является общей для всех экземпляров. Bob и ben являются экземплярами Person, поэтому они разделяют элемент прогулки (bob.walk === ben.walk).</target>
        </trans-unit>
        <trans-unit id="6b7f455cf9ed0f3eee5f17e212f56a94f50505d9" translate="yes" xml:space="preserve">
          <source>The next code shows another way to implement the constructor function, syntax is different but the idea is the same:</source>
          <target state="translated">Следующий код показывает другой способ реализации функции конструктора,синтаксис другой,но идея та же:</target>
        </trans-unit>
        <trans-unit id="68b7a276695cb91b3cc1a5a46c42b89c5d2e1bc4" translate="yes" xml:space="preserve">
          <source>The property/member &lt;code&gt;name&lt;/code&gt; is instance specific, it's different for bob and ben</source>
          <target state="translated">Имя свойства / члена зависит от конкретного экземпляра, оно отличается от bob и ben</target>
        </trans-unit>
        <trans-unit id="34bac27fdaa771c107c0ae1ee0c876c8cccc0390" translate="yes" xml:space="preserve">
          <source>The this variable actually refers to the invoking object, it refers to the object that came before the function.</source>
          <target state="translated">Эта переменная на самом деле относится к вызывающему объекту,она относится к объекту,который приходил перед функцией.</target>
        </trans-unit>
        <trans-unit id="dbeae5adf6a2e7873a50962c48c4d2650e1cad7a" translate="yes" xml:space="preserve">
          <source>This way of passing arguments in a function chain is useful in many cases. When you're working on code that would calculate a total of something and later you'd like to re factor the total of that something to be in a certain currency you may have to change a lot of functions to pass the value for currency. You could up scope a currency value (even to global like &lt;code&gt;window.currency='USD'&lt;/code&gt;) but that's a bad way to solve it.</source>
          <target state="translated">Этот способ передачи аргументов в цепочке функций полезен во многих случаях. Когда вы работаете над кодом, который будет вычислять сумму чего-то, а затем вы захотите пересчитать сумму этого чего-либо в определенной валюте, вам, возможно, придется изменить множество функций, чтобы передать значение для валюты. Вы можете увеличить значение валюты (даже до глобального, например &lt;code&gt;window.currency='USD'&lt;/code&gt; ), но это плохой способ ее решения.</target>
        </trans-unit>
        <trans-unit id="881d70367fb2cb9071aabd702a8ddae76085a077" translate="yes" xml:space="preserve">
          <source>To answer your question about Example 1, if it doesn't find the property anywhere in the prototype chain, it creates the property on the target object.</source>
          <target state="translated">Чтобы ответить на вопрос о Примере 1,если он не находит свойство нигде в цепочке прототипов,он создает свойство на целевом объекте.</target>
        </trans-unit>
        <trans-unit id="caa724d08d862109a2da38689f2332f1ce655618" translate="yes" xml:space="preserve">
          <source>To clarify see the following code:</source>
          <target state="translated">Для пояснения смотрите следующий код:</target>
        </trans-unit>
        <trans-unit id="6fa3de1fe95879c2e0e06bbcc67ffb2a5a9cacd6" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;this&lt;/code&gt; in the above cases refer to someObject you can pass a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closure&lt;/a&gt; instead of the function directly:</source>
          <target state="translated">Чтобы сделать &lt;code&gt;this&lt;/code&gt; в приведенных выше случаях, обратитесь к someObject, вы можете передать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;закрытие&lt;/a&gt; вместо функции напрямую:</target>
        </trans-unit>
        <trans-unit id="95908275067ede0cb508056464f5d825f362df1f" translate="yes" xml:space="preserve">
          <source>To override a Parent (=Hamster) method you do the same but don't do Hamster.prototype.parentMethod.call(this,....</source>
          <target state="translated">Для переопределения метода Parent (=Hamster)вы делаете то же самое,но не делаете Hamster.prototype.parentMethod.call(this,......</target>
        </trans-unit>
        <trans-unit id="30981a69967a6193b8f04b92e8a40f2bd4f43877" translate="yes" xml:space="preserve">
          <source>Using a pattern some would call &quot;classical inheritance&quot;. If you are confused by the syntax I'll be happy to explain more or provide different patterns.</source>
          <target state="translated">Некоторые называют это &quot;классическим наследством&quot;.Если вы запутались в синтаксисе,я с удовольствием объясню больше или предоставлю различные шаблоны.</target>
        </trans-unit>
        <trans-unit id="9d15948c93f4b3b1f746c221caff8d64929f5020" translate="yes" xml:space="preserve">
          <source>What if we don't re assign but mutate the member? Mutating is (for example) changing sub properties of an Object or invoking functions that will change the object's value. For example:</source>
          <target state="translated">Что,если мы не назначаем,а мутируем члена? Мутация-это (например)изменение под-свойств объекта или вызов функций,которые изменят значение объекта.Например:</target>
        </trans-unit>
        <trans-unit id="d72ec19dd58257fe3e8938b8afc236576f1071ab" translate="yes" xml:space="preserve">
          <source>When Child calls a Parent (&lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt;) we assume that Hamster uses the same arguments as RussionMini in the same order. For functions that call other functions I usually use another way to pass arguments.</source>
          <target state="translated">Когда Child вызывает Parent ( &lt;code&gt;Hamster.apply(this,arguments);&lt;/code&gt; ), мы предполагаем, что Hamster использует те же аргументы, что и RussionMini, в том же порядке. Для функций, которые вызывают другие функции, я обычно использую другой способ передачи аргументов.</target>
        </trans-unit>
        <trans-unit id="1a8948d65f6b2ed854bc435e20bd64c244a77252" translate="yes" xml:space="preserve">
          <source>When asking for bob.walk you'll get the Person.prototype.walk function because &lt;code&gt;walk&lt;/code&gt; could not be found on bob. Asking for ben.walk however will get you the value 22 because the member walk has been created on ben and since JavaScript found walk on ben it will not look in the Person.prototype.</source>
          <target state="translated">При запросе bob.walk вы получите функцию Person.prototype.walk, потому что &lt;code&gt;walk&lt;/code&gt; не может быть найден на bob. Однако при запросе ben.walk вы получите значение 22, потому что обход участника был создан на ben, а поскольку JavaScript нашел прогулку на ben, он не будет выглядеть в Person.prototype.</target>
        </trans-unit>
        <trans-unit id="dbae9f24b1b441346037a1a711472938fe1b0cdb" translate="yes" xml:space="preserve">
          <source>When using Object.create with 2 arguments, Object.defineProperty or Object.defineProperties shadowing works a bit different. More info on that &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">При использовании Object.create с 2 аргументами теневое копирование Object.defineProperty или Object.defineProperties работает несколько иначе. Больше информации об этом &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md#setting--shadowing-properties&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="944b2bf97bd3b09291debcbebf9c539ec6b669f8" translate="yes" xml:space="preserve">
          <source>With constructor functions you'll set the prototype in step 2 in the following code we set the prototype in step 3.</source>
          <target state="translated">С помощью функций конструктора вы установите прототип в шаге 2 в следующем коде мы установим прототип в шаге 3.</target>
        </trans-unit>
        <trans-unit id="9298f1163ca32f5e167b7c0302b9ad1b3d88a666" translate="yes" xml:space="preserve">
          <source>With passing an object you could add currency to &lt;code&gt;args&lt;/code&gt; whenever it's available in the function chain and mutate/use it whenever you need it without changing the other functions (explicitly have to pass it in the function calls).</source>
          <target state="translated">С передачей объекта вы можете добавлять валюту к &lt;code&gt;args&lt;/code&gt; всякий раз, когда она доступна в цепочке функций, и изменять / использовать ее всякий раз, когда вам это нужно, без изменения других функций (явно необходимо передавать ее в вызовах функций).</target>
        </trans-unit>
        <trans-unit id="837db40af571b967b8c7124903cd4c716d0b7af4" translate="yes" xml:space="preserve">
          <source>You can implement private members through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;closures&lt;/a&gt; but instance specific private members can only be accessed by functions that are not on the prototype.</source>
          <target state="translated">Вы можете реализовать закрытые члены через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures&quot;&gt;замыкания,&lt;/a&gt; но частные экземпляры конкретного экземпляра могут быть доступны только с помощью функций, отсутствующих в прототипе.</target>
        </trans-unit>
        <trans-unit id="307959edcb48ff33b2f62e2ee949b4df46321abd" translate="yes" xml:space="preserve">
          <source>You can indicate to other programmers a member is meant to be private by naming it &lt;code&gt;_aPrivate&lt;/code&gt; or putting all the private variables in an object variable called &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Вы можете указать другим программистам, что член должен быть закрытым, назвав его &lt;code&gt;_aPrivate&lt;/code&gt; или поместив все приватные переменные в переменную объекта с именем &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d5c1874c396599b4b5ab6617f2c4fbfc040617" translate="yes" xml:space="preserve">
          <source>You can use a function as a constructor to create objects, if the constructor function is named Person then the object(s) created with that constructor are instances of Person.</source>
          <target state="translated">Вы можете использовать функцию в качестве конструктора для создания объектов,если функция конструктора называется Person,то объект(ы),созданный с помощью этого конструктора,являются экземплярами Person.</target>
        </trans-unit>
        <trans-unit id="1e4718352a5ddbc9ba763c0a0a57cbf4ee7d57b4" translate="yes" xml:space="preserve">
          <source>You may come across similar patterns that are more robust to help with object creation and object definition.</source>
          <target state="translated">Вы можете столкнуться с похожими паттернами,которые более надежны,чтобы помочь с созданием объекта и его определением.</target>
        </trans-unit>
        <trans-unit id="03c004c041a8ade78e5fa468755470e910975a73" translate="yes" xml:space="preserve">
          <source>You want the 'child' (=RussionMini) to do something extra. When RussionMini can call the Hamster code to do something and then do something extra you don't need to copy and paste Hamster code to RussionMini.</source>
          <target state="translated">Вы хотите,чтобы &quot;ребенок&quot; (=RussionMini)сделал что-нибудь лишнее.Когда RussionMini может вызвать код Хомяка,чтобы сделать что-то,а затем сделать что-то дополнительное,вам не нужно копировать и вставлять код Хомяка в RussionMini.</target>
        </trans-unit>
        <trans-unit id="ed3bcead2d06b24e9a79e412965282dc663fdf5e" translate="yes" xml:space="preserve">
          <source>we run &lt;code&gt;rabbit.eat&lt;/code&gt;, which changes &lt;code&gt;rabbit.full&lt;/code&gt;. &lt;code&gt;full&lt;/code&gt; property is nowhere to be found, so it should go up the prototype chain to (to object??), and well, I'm not sure what happens here. In this example the property &lt;code&gt;full&lt;/code&gt; of &lt;code&gt;rabbit&lt;/code&gt; is created and changed, while in the first example it goes up the prototype chain because it cannot find the property.</source>
          <target state="translated">мы запускаем &lt;code&gt;rabbit.eat&lt;/code&gt; , который изменяет &lt;code&gt;rabbit.full&lt;/code&gt; . &lt;code&gt;full&lt;/code&gt; свойство нигде не найдено, поэтому оно должно идти по цепочке прототипов к (объекту ??), и, ну, я не уверен, что здесь происходит. В этом примере свойство, &lt;code&gt;full&lt;/code&gt; &lt;code&gt;rabbit&lt;/code&gt; , создается и изменяется, в то время как в первом примере оно идет вверх по цепочке прототипов, потому что не может найти свойство.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
