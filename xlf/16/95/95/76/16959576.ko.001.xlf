<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/16959576">
    <body>
      <group id="16959576">
        <trans-unit id="a838e95c861b722e4d4150b9f6f1920e5169c62c" translate="yes" xml:space="preserve">
          <source>(anonymous) functions inside functions</source>
          <target state="translated">함수 내부의 (익명) 함수</target>
        </trans-unit>
        <trans-unit id="ab5b78942d8672ca80abd97cd7594c7910b40e16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$GLOBALS&lt;/code&gt; - All the global variables in the current script</source>
          <target state="translated">&lt;code&gt;$GLOBALS&lt;/code&gt; 현재 스크립트의 모든 글로벌 변수</target>
        </trans-unit>
        <trans-unit id="e447db7dd407c0465d263640675852f291dfb97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_COOKIE&lt;/code&gt; - Cookies passed with the current request</source>
          <target state="translated">&lt;code&gt;$_COOKIE&lt;/code&gt; 현재 요청과 함께 전달 된 쿠키</target>
        </trans-unit>
        <trans-unit id="23f8f9f798cae387bccb009c8570466e221ed320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_ENV&lt;/code&gt; - The environment variables of the current script</source>
          <target state="translated">&lt;code&gt;$_ENV&lt;/code&gt; 현재 스크립트의 환경 변수</target>
        </trans-unit>
        <trans-unit id="fe1c222af7a08d0d9c3ec4bb66ceb471334a1d2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_FILES&lt;/code&gt; - Files passed in an HTTP POST request with a &lt;code&gt;multipart/form-data&lt;/code&gt; MIME type</source>
          <target state="translated">&lt;code&gt;$_FILES&lt;/code&gt; - &lt;code&gt;multipart/form-data&lt;/code&gt; MIME 유형으로 HTTP POST 요청에 전달 된 파일</target>
        </trans-unit>
        <trans-unit id="3275cc5081faa33f360f5ef474b432441bcaa20f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_GET&lt;/code&gt; - Values passed in the query string of the URL, regardless of the HTTP method used for the request</source>
          <target state="translated">&lt;code&gt;$_GET&lt;/code&gt; 요청에 사용 된 HTTP 메소드에 관계없이 URL의 쿼리 문자열에 전달 된 값</target>
        </trans-unit>
        <trans-unit id="48134a27485958dd1da440984cdd0905a6e393d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_POST&lt;/code&gt; - Values passed in an HTTP POST request with &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; or &lt;code&gt;multipart/form-data&lt;/code&gt; MIME types</source>
          <target state="translated">&lt;code&gt;$_POST&lt;/code&gt; - &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 또는 &lt;code&gt;multipart/form-data&lt;/code&gt; MIME 유형으로 HTTP POST 요청에 전달 된 값</target>
        </trans-unit>
        <trans-unit id="6446cb3a90bcb73f4a0b18700333ae3ebffd3183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_REQUEST&lt;/code&gt; - Typically a combination of &lt;code&gt;$_GET&lt;/code&gt; and &lt;code&gt;$_POST&lt;/code&gt;, but sometimes &lt;code&gt;$_COOKIES&lt;/code&gt;. The content is determined by the &lt;a href=&quot;https://www.php.net/manual/en/ini.core.php#ini.request-order&quot;&gt;&lt;code&gt;request_order&lt;/code&gt; directive&lt;/a&gt; in &lt;code&gt;php.ini&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$_REQUEST&lt;/code&gt; 일반적으로 &lt;code&gt;$_GET&lt;/code&gt; 과 &lt;code&gt;$_POST&lt;/code&gt; 의 조합이지만 때로는 &lt;code&gt;$_COOKIES&lt;/code&gt; 입니다. 내용은 &lt;code&gt;php.ini&lt;/code&gt; 의 &lt;a href=&quot;https://www.php.net/manual/en/ini.core.php#ini.request-order&quot;&gt; &lt;code&gt;request_order&lt;/code&gt; 지시어&lt;/a&gt; 에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7c57ad330fea26b47817fd32122a481ce3485a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_SERVER&lt;/code&gt; - Information on the server and execution environment</source>
          <target state="translated">&lt;code&gt;$_SERVER&lt;/code&gt; 서버 및 실행 환경에 대한 정보</target>
        </trans-unit>
        <trans-unit id="06bfdc6ae6b40934570555d25de4ec53967c8a4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$_SESSION&lt;/code&gt; - Session variables stored internally by PHP</source>
          <target state="translated">&lt;code&gt;$_SESSION&lt;/code&gt; -PHP에 의해 내부적으로 저장된 세션 변수</target>
        </trans-unit>
        <trans-unit id="7a54fd83e265d890f6ebf01bc2fdf3d2c3e6969d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$foo&lt;/code&gt; is in the &lt;em&gt;global&lt;/em&gt; scope, &lt;code&gt;$baz&lt;/code&gt; is in a &lt;em&gt;local&lt;/em&gt; scope inside &lt;code&gt;myFunc&lt;/code&gt;. Only code inside &lt;code&gt;myFunc&lt;/code&gt; has access to &lt;code&gt;$baz&lt;/code&gt;. Only code &lt;em&gt;outside&lt;/em&gt;&lt;code&gt;myFunc&lt;/code&gt; has access to &lt;code&gt;$foo&lt;/code&gt;. Neither has access to the other:</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 는 &lt;em&gt;전역&lt;/em&gt; 범위에 있고 &lt;code&gt;$baz&lt;/code&gt; 는 &lt;code&gt;myFunc&lt;/code&gt; 내의 &lt;em&gt;로컬&lt;/em&gt; 범위에 있습니다. &lt;code&gt;myFunc&lt;/code&gt; 내부의 코드 만 &lt;code&gt;$baz&lt;/code&gt; 액세스 할 수 있습니다. &lt;code&gt;myFunc&lt;/code&gt; &lt;em&gt;외부의&lt;/em&gt; 코드 만 &lt;code&gt;$foo&lt;/code&gt; 액세스 할 수 있습니다. 어느 쪽도 다른쪽에 접근 할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="860f3738e06320b6aa3a5029bf8cabd8046b48e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a.php&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;a.php&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4906962156ed3cee35484627e34c88784c364e12" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;b.php&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;b.php&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="148c38c993db37ff964ae08c70d69d37223693b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;c.php&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;c.php&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee745f8274eea67c263f470c1a6b81cd56ebc429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Is static variable the only way to keep values between calls to a function?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정적 변수가 함수 호출간에 값을 유지하는 유일한 방법입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d16fd476d750bb2f2055776c40ba91b588355415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static variables use-cases&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정적 변수 사용 사례&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c8b0fdf7a7ff852b65f48f1feaeed776c9bf16d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tricks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tricks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4bac3cd12a4a22859cd13a8ef9ac8e413098752" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is it 'static variable'?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;'정적 변수'는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a74d4fc619243713656d431f8206726c097f47d" translate="yes" xml:space="preserve">
          <source>A list of current superglobals:</source>
          <target state="translated">현재 슈퍼 글로벌 목록 :</target>
        </trans-unit>
        <trans-unit id="2ebda5656975b8f33dec11db266353e84483083d" translate="yes" xml:space="preserve">
          <source>All the caller of this function sees is this:</source>
          <target state="translated">이 함수의 모든 호출자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f58e02d5845b0bfb45a72c39d1f6598fa7ed232b" translate="yes" xml:space="preserve">
          <source>Although variables defined inside of a function's scope can not be accessed from the outside that does not mean you can not use their values after that function completes. PHP has a well known &lt;code&gt;static&lt;/code&gt; keyword that is widely used in object-oriented PHP for defining static methods and properties but one should keep in mind that &lt;code&gt;static&lt;/code&gt; may also be used inside functions to define static variables.</source>
          <target state="translated">함수 범위 내에서 정의 된 변수는 외부에서 액세스 할 수 없지만 해당 함수가 완료된 후에는 해당 값을 사용할 수 없습니다. PHP는 정적 메소드와 속성을 정의하기 위해 객체 지향 PHP에서 널리 사용되는 잘 알려진 &lt;code&gt;static&lt;/code&gt; 키워드를 가지고 있지만 정적 변수를 정의하기 위해 함수 내에서 &lt;code&gt;static&lt;/code&gt; 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d37e56f52da019cf5be302a35cc6e102b1d3ea80" translate="yes" xml:space="preserve">
          <source>Another way to keep values between function calls is to use closures. Closures were introduced in PHP 5.3. In two words they allow you to limit access to some set of variables within a function scope to another anonymous function that will be the only way to access them. Being in closure variables may imitate (more or less successfully) OOP concepts like 'class constants' (if they were passed in closure by value) or 'private properties' (if passed by reference) in structured programming.</source>
          <target state="translated">함수 호출간에 값을 유지하는 또 다른 방법은 클로저를 사용하는 것입니다. 클로저는 PHP 5.3에서 도입되었습니다. 즉, 함수 범위 내의 일부 변수 집합에 대한 액세스 권한을 다른 익명 함수로 제한 할 수 있습니다. 클로저 변수에 있으면 구조화 된 프로그래밍에서 '클래스 상수'(값으로 클로저로 전달 된 경우) 또는 '개인 속성'(참조로 전달 된 경우)과 같은 OOP 개념을 모방 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81690f2d671c4f52561ea256066e3c802a3fde5" translate="yes" xml:space="preserve">
          <source>As said before, the global scope is somewhat special, and functions can explicitly import variables from it:</source>
          <target state="translated">앞에서 언급했듯이 전역 범위는 다소 특별하며 함수는 명시 적으로 변수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131355e4733c051ffbf0c276bc8ecd95e99a5ad2" translate="yes" xml:space="preserve">
          <source>But one subject that was missed was that of &lt;a href=&quot;https://php.net/manual/en/language.variables.superglobals.php&quot;&gt;superglobals&lt;/a&gt;, including the commonly used &lt;code&gt;$_POST&lt;/code&gt;, &lt;code&gt;$_GET&lt;/code&gt;, &lt;code&gt;$_SESSION&lt;/code&gt;, etc. These variables are arrays that are always available, in any scope, without a &lt;code&gt;global&lt;/code&gt; declaration.</source>
          <target state="translated">그러나 빠뜨린 한 가지 주제는 일반적으로 사용되는 &lt;code&gt;$_POST&lt;/code&gt; , &lt;code&gt;$_GET&lt;/code&gt; , &lt;code&gt;$_SESSION&lt;/code&gt; 등을 포함하여 &lt;a href=&quot;https://php.net/manual/en/language.variables.superglobals.php&quot;&gt;superglobals의&lt;/a&gt; 주제였습니다. 이러한 변수는 &lt;code&gt;global&lt;/code&gt; 선언없이 모든 범위에서 항상 사용 가능한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c1d90c3f28d82a888a53b5293c825c1fcbf61454" translate="yes" xml:space="preserve">
          <source>Crossing scope boundaries</source>
          <target state="translated">교차 범위 경계</target>
        </trans-unit>
        <trans-unit id="2936310739c388c59bd9b9ae7f91baa8826864e1" translate="yes" xml:space="preserve">
          <source>Dealing with scoping issues may seem annoying, but &lt;strong&gt;limited variable scope is essential to writing complex applications!&lt;/strong&gt; If every variable you declare would be available from everywhere else inside your application, you'd be stepping all over your variables with no real way to track what changes what. There are only so many sensible names you can give to your variables, you probably want to use the variable &quot;&lt;code&gt;$name&lt;/code&gt;&quot; in more than one place. If you could only have this unique variable name once in your app, you'd have to resort to really complicated naming schemes to make sure your variables are unique and that you're not changing the wrong variable from the wrong piece of code.</source>
          <target state="translated">범위 지정 문제를 다루는 것은 성가신 것처럼 보이지만 &lt;strong&gt;복잡한 응용 프로그램을 작성하려면 제한된 변수 범위가 필수적입니다!&lt;/strong&gt; 선언 한 모든 변수를 응용 프로그램 내 다른 곳에서 사용할 수 있다면 변경 내용을 추적하는 실제 방법없이 변수 전체를 단계별로 실행하게됩니다. 변수에 부여 할 수있는 현명한 이름이 너무 많으므로 &quot; &lt;code&gt;$name&lt;/code&gt; &quot;변수를 두 곳 이상에서 사용하고 싶을 것입니다. 앱에서이 고유 한 변수 이름을 한 번만 가질 수 있다면 변수의 고유성을 확인하고 잘못된 코드에서 잘못된 변수를 변경하지 않도록하기 위해 정말 복잡한 이름 지정 체계를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ad03cae3f3faeea070af78623a2e5a9f3c527ac" translate="yes" xml:space="preserve">
          <source>Every new &lt;code&gt;function&lt;/code&gt; declaration introduces a new scope, it's that simple.</source>
          <target state="translated">모든 새로운 &lt;code&gt;function&lt;/code&gt; 선언은 새로운 범위를 도입합니다. 그것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="12461211a8851c6382719dc0035a3df5bc1b39e7" translate="yes" xml:space="preserve">
          <source>Extending the scope of variables into anonymous functions</source>
          <target state="translated">변수의 범위를 익명 함수로 확장</target>
        </trans-unit>
        <trans-unit id="5d7a4224119faa0fd1a269c4341f2620d26f7167" translate="yes" xml:space="preserve">
          <source>File boundaries do &lt;em&gt;not separate&lt;/em&gt; scope:</source>
          <target state="translated">파일 경계는 범위를 &lt;em&gt;분리&lt;/em&gt; 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ae5429ab2e5c045bcac291b5854c96b21e0b41c1" translate="yes" xml:space="preserve">
          <source>For example, this function will print out the name of the user running the PHP script. The variable is available to the function without any problem.</source>
          <target state="translated">예를 들어,이 함수는 PHP 스크립트를 실행하는 사용자의 이름을 인쇄합니다. 변수는 문제없이 함수에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="652a40170ba8591c912f745feccf44afade5a2b1" translate="yes" xml:space="preserve">
          <source>How is a scope defined in PHP?</source>
          <target state="translated">PHP에서 범위는 어떻게 정의됩니까?</target>
        </trans-unit>
        <trans-unit id="922ea91a2ea4163e309e51776ea16ec24fecb388" translate="yes" xml:space="preserve">
          <source>I won't post a complete answer to the question, as the existing ones and the &lt;a href=&quot;https://www.php.net/manual/en/language.variables.scope.php&quot;&gt;PHP manual&lt;/a&gt; do a great job of explaining most of this.</source>
          <target state="translated">나는 기존의 것들과 &lt;a href=&quot;https://www.php.net/manual/en/language.variables.scope.php&quot;&gt;PHP 매뉴얼&lt;/a&gt; 이 이것의 대부분을 설명하는 훌륭한 일을하기 때문에 질문에 대한 완전한 대답을 게시하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1453b707e2be9fbe202d36fa790ada6cd6197ed" translate="yes" xml:space="preserve">
          <source>If there was no scope, what would the above function do? Where does &lt;code&gt;$bar&lt;/code&gt; come from? What state does it have? Is it even initialized? Do you have to check every time? This is not maintainable. Which brings us to...</source>
          <target state="translated">범위가 없으면 위의 기능은 무엇을합니까? &lt;code&gt;$bar&lt;/code&gt; 어디에서 오는가? 어떤 주가 있습니까? 심지어 초기화 되었습니까? 매번 확인해야합니까? 유지 관리 할 수 ​​없습니다. 어느 것이 우리를 ...</target>
        </trans-unit>
        <trans-unit id="3ea2c15205d5dc0df8889a788f44c499ed5daa89" translate="yes" xml:space="preserve">
          <source>If we'd defined &lt;code&gt;$counter&lt;/code&gt; without &lt;code&gt;static&lt;/code&gt; then each time echoed value would be the same as &lt;code&gt;$num&lt;/code&gt; parameter passed to the function. Using &lt;code&gt;static&lt;/code&gt; allows to build this simple counter without additional workaround.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 없이 &lt;code&gt;$counter&lt;/code&gt; 를 정의했다면 에코 된 값이 매번 함수에 전달 된 &lt;code&gt;$num&lt;/code&gt; 매개 변수와 같습니다. &lt;code&gt;static&lt;/code&gt; 을 사용하면 추가 해결 방법없이이 간단한 카운터를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="016571b21f01e1f2f3c21aa699a0d85d4dd6f082" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;a.php&lt;/code&gt; was included inside &lt;code&gt;myFunc&lt;/code&gt;, any variables inside &lt;code&gt;a.php&lt;/code&gt; only have local function scope. Just because they &lt;em&gt;appear&lt;/em&gt; to be in the global scope in &lt;code&gt;a.php&lt;/code&gt; doesn't necessarily mean they are, it actually depends on which context that code is included/executed in.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;a.php&lt;/code&gt; 는 &lt;code&gt;myFunc&lt;/code&gt; 안에 포함되었으며 a.php 안의 모든 변수에는 로컬 함수 범위 만 있습니다. 그것들 &lt;em&gt;이&lt;/em&gt; &lt;code&gt;a.php&lt;/code&gt; 의 전역 범위에 있다고해서 반드시 그 의미를 의미하는 것은 아니며 실제로 코드가 포함 / 실행되는 컨텍스트에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec554381014e42af1e8683e98f1aefa0c936c9ba" translate="yes" xml:space="preserve">
          <source>Note: This is a reference question for dealing with variable scope in PHP. Please close any of the many questions fitting this pattern as a duplicate of this one.</source>
          <target state="translated">참고 : 이것은 PHP에서 변수 범위를 다루기위한 참조 질문입니다. 이 패턴에 맞는 많은 질문 중 하나를이 질문의 복제본으로 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="61bbf9a337d819ea79646c2dcd315776ac0ab6f4" translate="yes" xml:space="preserve">
          <source>Observe:</source>
          <target state="translated">Observe:</target>
        </trans-unit>
        <trans-unit id="3b23157b44fc6889bccbe888ff20db2f5fe02bfd" translate="yes" xml:space="preserve">
          <source>Reference: What is variable scope, which variables are accessible from where and what are “undefined variable” errors</source>
          <target state="translated">참조 : 변수 범위는 무엇이며, &quot;정의되지 않은 변수&quot;오류의 위치 및 위치에서 액세스 할 수있는 변수</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="f8d3b96b00480366f537ded0d968e8049343afb0" translate="yes" xml:space="preserve">
          <source>Scope and included files</source>
          <target state="translated">범위 및 포함 된 파일</target>
        </trans-unit>
        <trans-unit id="32740030904056284188e1034478ed55d904fcdd" translate="yes" xml:space="preserve">
          <source>Static function is kinda 'shared' between methods of objects of the
    same class. It is easy to understand by viewing the following example:</source>
          <target state="translated">정적 함수는 같은 클래스의 객체의 메소드간에 '공유'됩니다. 다음 예제를 보면 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f9790900a624b27bf7e92850b9dfa1ef4cea7d80" translate="yes" xml:space="preserve">
          <source>Static variable differs from ordinary variable defined in function's scope in case that it does not loose value when program execution leaves this scope. Let's consider the following example of using static variables:</source>
          <target state="translated">정적 변수는 프로그램 실행이이 범위를 벗어날 때 값을 잃지 않는 경우 함수 범위에 정의 된 일반 변수와 다릅니다. 정적 변수를 사용하는 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="020d21b43c9e6b9b10c807da9b8098c7e835e866" translate="yes" xml:space="preserve">
          <source>Static variable exists only in a local function scope. It can not be
    accessed outside of the function it has been defined in. So you may 
    be sure that it will keep its value unchanged until the next call to
    that function.</source>
          <target state="translated">정적 변수는 로컬 함수 범위에만 존재합니다. 정의 된 함수 외부에서는 액세스 할 수 없습니다. 따라서 다음에 해당 함수를 호출 할 때까지 값이 변경되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e9f12b97dc60a216b26c5009a27702745a72b74" translate="yes" xml:space="preserve">
          <source>Static variable may only be defined as a scalar or as a scalar 
    expression (since PHP 5.6). Assigning other values to it inevitably 
    leads to a failure at least at the moment this article was written.
Nevertheless you are able to do so just on the next line of your code:</source>
          <target state="translated">정적 변수는 스칼라 또는 스칼라 식으로 만 정의 할 수 있습니다 (PHP 5.6부터). 여기에 다른 값을 지정하면이 기사가 작성된 시점에서 필연적으로 오류가 발생합니다. 그럼에도 불구하고 다음 코드 줄에서 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47934530c39e0bc54c73c188c5dd0204fa9de270" translate="yes" xml:space="preserve">
          <source>The anonymous function explicitly includes &lt;code&gt;$foo&lt;/code&gt; from its surrounding scope. Note that this is not the same as &lt;em&gt;global&lt;/em&gt; scope.</source>
          <target state="translated">익명 함수는 명시 적으로 주변 범위의 &lt;code&gt;$foo&lt;/code&gt; 를 포함합니다. 이것은 &lt;em&gt;전역&lt;/em&gt; 범위와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78945653e9206cea1434050a9d50d32f7de0e05e" translate="yes" xml:space="preserve">
          <source>The general rule of &quot;globals are bad&quot; is typically amended in PHP to &quot;globals are bad but superglobals are alright,&quot; as long as one is not misusing them. (All these variables are writable, so they could be used to avoid dependency injection if you were really terrible.)</source>
          <target state="translated">&quot;글로벌이 나쁘다&quot;라는 일반적인 규칙은 일반적으로 PHP에서 오용하지 않는 한 &quot;글로벌은 나쁘지만 슈퍼 글로벌은 괜찮습니다&quot;로 수정됩니다. (이러한 모든 변수는 쓰기 가능하므로 실제로 끔찍한 경우 종속성 주입을 피하는 데 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d2d45572c41369f79365e5e6f3eadd1968dffe83" translate="yes" xml:space="preserve">
          <source>The latter actually allows to use closures instead of static variables. What to use is always up to developer to decide but it should be mentioned that static variables are definitely useful when working with recursions and deserve to be noticed by devs.</source>
          <target state="translated">후자는 실제로 정적 변수 대신 클로저를 사용할 수 있습니다. 사용하는 것은 항상 개발자의 결정에 달려 있지만 정적 변수는 재귀 작업을 할 때 확실히 유용하며 개발자가 주목할 가치가 있음을 언급해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cc5dfbb24227901a1a1eb2cd1d96bd93f174b6c" translate="yes" xml:space="preserve">
          <source>The right way: passing variables in and out</source>
          <target state="translated">올바른 방법 : 변수 전달 및 전달</target>
        </trans-unit>
        <trans-unit id="c451255be5458efde09d08e0f66cadda0055ce56" translate="yes" xml:space="preserve">
          <source>The same rules apply to &lt;code&gt;include&lt;/code&gt;d code as applies to any other code: only &lt;code&gt;function&lt;/code&gt;s separate scope. For the purpose of scope, you may think of including files like copy and pasting code:</source>
          <target state="translated">다른 코드에 적용되는 것과 동일한 규칙이 d 코드를 &lt;code&gt;include&lt;/code&gt; 하는 데 적용됩니다. 범위 목적을 위해 복사 및 붙여 넣기 코드와 같은 파일을 포함하는 것을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071e971943c4d359bae69ff92a351fa2dbd377fb" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;$bar&lt;/code&gt; is explicitly coming into this scope as function argument. Just looking at this function it's clear where the values it works with originate from. It then explicitly &lt;em&gt;returns&lt;/em&gt; a value. The caller has the confidence to know what variables the function will work with and where its return values come from:</source>
          <target state="translated">변수 &lt;code&gt;$bar&lt;/code&gt; 는 명시 적으로 함수 범위로이 범위에 들어옵니다. 이 함수를 보면 작동하는 값의 출처가 명확합니다. 그런 다음 명시 적으로 값을 &lt;em&gt;반환&lt;/em&gt; 합니다. 호출자는 함수가 작동하는 변수와 반환 값의 위치를 ​​알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5466b5ce2738d42daa755eea4ae20e0eebbb561a" translate="yes" xml:space="preserve">
          <source>The wrong way: &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">잘못된 방법 : &lt;code&gt;global&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bcd77de6020f24f4c53057055534728b8eb52912" translate="yes" xml:space="preserve">
          <source>There's no indication that this function has any &lt;em&gt;side effects&lt;/em&gt;, yet it does. This very easily becomes a tangled mess as some functions keep modifying &lt;em&gt;and requiring&lt;/em&gt; some global state. You want functions to be &lt;em&gt;stateless&lt;/em&gt;, acting only on their inputs and returning defined output, however many times you call them.</source>
          <target state="translated">이 함수 &lt;em&gt;에 부작용&lt;/em&gt; 이 있다는 표시는 없지만 아직 있습니다. 일부 함수는 전역 상태를 계속 수정 &lt;em&gt;하고 필요로하므로&lt;/em&gt; 매우 쉽게 엉 키게됩니다. 함수는 &lt;em&gt;상태 비 저장&lt;/em&gt; 이되기를 원하며, 입력에 대해서만 작용하고 정의 된 출력을 반환하지만 여러 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2c7ad2ed688205af4b707f4b4e4cd61596a15526" translate="yes" xml:space="preserve">
          <source>These variables are not guaranteed to be present; an administrator can disable some or all of them using the &lt;a href=&quot;https://www.php.net/manual/en/ini.core.php#ini.variables-order&quot;&gt;&lt;code&gt;variables_order&lt;/code&gt; directive&lt;/a&gt; in &lt;code&gt;php.ini&lt;/code&gt;, but this is not common behaviour.</source>
          <target state="translated">이러한 변수는 존재하지 않을 수 있습니다. 관리자는 &lt;code&gt;php.ini&lt;/code&gt; 의 &lt;a href=&quot;https://www.php.net/manual/en/ini.core.php#ini.variables-order&quot;&gt; &lt;code&gt;variables_order&lt;/code&gt; 지시문&lt;/a&gt; 을 사용하여 일부 또는 전부를 비활성화 할 수 있지만 일반적인 동작은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="729a9879fbcdd4d85db86c6d1b36908bb5bf9949" translate="yes" xml:space="preserve">
          <source>This function uses and modifies the global variable &lt;code&gt;$foo&lt;/code&gt;. &lt;strong&gt;Do not do this!&lt;/strong&gt;&lt;sub&gt;(Unless you really really really really know what you're doing, and even then: don't!)&lt;/sub&gt;</source>
          <target state="translated">이 함수는 전역 변수 &lt;code&gt;$foo&lt;/code&gt; 사용하고 수정합니다. &lt;strong&gt;이러지 마!&lt;/strong&gt; &lt;sub&gt;(당신이 정말로 정말로 당신이하고있는 일을 알고 있지 않다면,하지 마십시오!)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5f2b6b1f3294c6b1b9b389bdda4e74e3dd5b76b5" translate="yes" xml:space="preserve">
          <source>This only works with objects of the same class. If objects are from different classes (even extending one another) behavior of static vars will be as expected.</source>
          <target state="translated">이것은 같은 클래스의 객체에서만 작동합니다. 객체가 다른 클래스 (다른 클래스로 확장)에서 온 경우 정적 변수의 동작은 예상대로입니다.</target>
        </trans-unit>
        <trans-unit id="93dce72d02933cfb02ef65e7b7d61dfcd89aefbc" translate="yes" xml:space="preserve">
          <source>To cache value which is normally better to retrieve once. For
example, result of reading immutable file on server.</source>
          <target state="translated">일반적으로 한 번 검색하는 것이 더 나은 값을 캐시합니다. 예를 들어, 서버에서 변경 불가능한 파일을 읽은 결과입니다.</target>
        </trans-unit>
        <trans-unit id="9366d1449ad260d48207a9d7c5869d5ac4aa8828" translate="yes" xml:space="preserve">
          <source>To store values between consequent calls to function.</source>
          <target state="translated">결과적인 함수 호출 사이에 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e070a653dbaac809338df34a78de0871495dad48" translate="yes" xml:space="preserve">
          <source>To store values between recursive calls when there is no way (or no
purpose) to pass them as params.</source>
          <target state="translated">매개 변수로 전달할 방법이 없거나 목적이없는 경우 재귀 호출간에 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f0653e4d69e68c99f3473e13c00ee9cce6be01a2" translate="yes" xml:space="preserve">
          <source>Variables have a limited &quot;scope&quot;, or &quot;places from which they are accessible&quot;. Just because you wrote &lt;code&gt;$foo = 'bar';&lt;/code&gt; once &lt;em&gt;somewhere&lt;/em&gt; in your application doesn't mean you can refer to &lt;code&gt;$foo&lt;/code&gt; from &lt;em&gt;everywhere&lt;/em&gt; else inside the application. The variable &lt;code&gt;$foo&lt;/code&gt; has a certain scope within which it is valid and only code in the same scope has access to the variable.</source>
          <target state="translated">변수에는 &quot;범위&quot;또는 &quot;액세스 할 수있는 위치&quot;가 제한되어 있습니다. 당신이 &lt;code&gt;$foo = 'bar';&lt;/code&gt; 를 썼기 때문에 ; 응용 프로그램의 &lt;em&gt;어딘가&lt;/em&gt; 가 응용 프로그램 내부의 다른 &lt;em&gt;곳&lt;/em&gt; 에서 &lt;code&gt;$foo&lt;/code&gt; 를 참조 할 수있는 것은 아닙니다. 변수 &lt;code&gt;$foo&lt;/code&gt; 는 유효한 특정 범위를 가지며 같은 범위의 코드 만 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec32b35eb769978685d4877ea5219c78f585a12" translate="yes" xml:space="preserve">
          <source>Very simple: PHP has &lt;em&gt;function scope&lt;/em&gt;. That's the only kind of scope separator that exists in PHP. Variables inside a function are only available inside that function. Variables outside of functions are available anywhere outside of functions, but not inside any function. This means there's one special scope in PHP: the &lt;em&gt;global&lt;/em&gt; scope. Any variable declared outside of any function is within this global scope.</source>
          <target state="translated">매우 간단합니다 : PHP는 &lt;em&gt;함수 범위를&lt;/em&gt; 가지고 &lt;em&gt;있습니다&lt;/em&gt; . 그것은 PHP에 존재하는 유일한 종류의 스코프 구분자입니다. 함수 내부의 변수는 해당 함수 내에서만 사용할 수 있습니다. 함수 외부의 변수는 함수 외부에서는 사용할 수 있지만 함수 내부에서는 사용할 수 없습니다. 이것은 PHP에 특별한 범위가 있다는 것을 의미합니다 : &lt;em&gt;글로벌&lt;/em&gt; 범위. 함수 외부에서 선언 된 모든 변수는이 전역 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1e7856d7ec0ce5f15615436c1ef95f0cf0aae6" translate="yes" xml:space="preserve">
          <source>What about functions inside functions and classes?</source>
          <target state="translated">함수와 클래스 내부의 함수는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="6254f2b5f8bf1ba12db135d773afffbbef9b6be2" translate="yes" xml:space="preserve">
          <source>What is &quot;variable scope&quot; in PHP? Are variables from one .php file accessible in another? Why do I sometimes get &lt;em&gt;&quot;undefined variable&quot;&lt;/em&gt; errors?</source>
          <target state="translated">PHP에서 &quot;가변 범위&quot;란 무엇입니까? 한 .php 파일의 변수는 다른 .php 파일에 액세스 할 수 있습니까? 때때로 &lt;em&gt;&quot;정의되지 않은 변수&quot;&lt;/em&gt; 오류가 발생하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bb6449bdee5b63295f7aa04798c75018ea21ef24" translate="yes" xml:space="preserve">
          <source>What is &quot;variable scope&quot;?</source>
          <target state="translated">&quot;가변 범위&quot;란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="96131e2666075b2978079441b07aa07043ed2fa4" translate="yes" xml:space="preserve">
          <source>What is scope good for?</source>
          <target state="translated">범위는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ac89234b35981829ff5582a0e47710a2abd12fb2" translate="yes" xml:space="preserve">
          <source>You should avoid using the global scope in any way as much as possible; most certainly you should not be &quot;pulling&quot; variables out of the global scope into a local scope.</source>
          <target state="translated">전역 범위를 가능한 한 많이 사용하지 않아야합니다. 가장 확실하게 전역 범위에서 변수를 로컬 범위로 &quot;풀링&quot;해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1adaa84dc07a16d34ede5b9a70713ff832a0f853" translate="yes" xml:space="preserve">
          <source>classes</source>
          <target state="translated">classes</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
