<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1628563">
    <body>
      <group id="1628563">
        <trans-unit id="6ca0548b1ae7d77cf8176a8562bef6c6ec1f4654" translate="yes" xml:space="preserve">
          <source>(if you prefer you can write &lt;code&gt;@{-1}&lt;/code&gt; - the previously checked out branch - instead of &lt;code&gt;oldbranch&lt;/code&gt;).</source>
          <target state="translated">（如果您愿意，可以编写 &lt;code&gt;@{-1}&lt;/code&gt; -先前签出的分支-代替 &lt;code&gt;oldbranch&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9f8435deadd1fe3bd0b7d1a92942e67a02ac6466" translate="yes" xml:space="preserve">
          <source>1) Create a new branch, which moves all your changes to new_branch.</source>
          <target state="translated">1)创建一个新的分支,将你所有的修改都移动到new_branch。</target>
        </trans-unit>
        <trans-unit id="67a880d1f38aa8e151836c7841725f2f5ce6ef07" translate="yes" xml:space="preserve">
          <source>1) make new branch where you want to commit you recent update.</source>
          <target state="translated">1)做一个新的分支,你想在哪里提交你最近的更新。</target>
        </trans-unit>
        <trans-unit id="e03e86c3388b7cf5555eb916dbba2967506aaeec" translate="yes" xml:space="preserve">
          <source>2)  Find  Recent Commit Id for commit on new branch.</source>
          <target state="translated">2)在新分支上找到最近提交的提交ID。</target>
        </trans-unit>
        <trans-unit id="ca6b48cf4285ff6ee19a338900c7ea56c23bd692" translate="yes" xml:space="preserve">
          <source>2) Then go back to old branch.</source>
          <target state="translated">2)然后回老支部。</target>
        </trans-unit>
        <trans-unit id="1a5ca855c4b43689641d35143dbafebcc3c36cb6" translate="yes" xml:space="preserve">
          <source>3)  Copy that commit id  note that Most Recent commit list take place on top. so you can find your commit. you also find this via message.</source>
          <target state="translated">3)复制该提交的id,注意最近的提交列表中的 &quot;最近的提交 &quot;放在最上面,这样你就可以找到你的提交。</target>
        </trans-unit>
        <trans-unit id="8879da991940a5e92a574b5dce3946ef8b03f6e3" translate="yes" xml:space="preserve">
          <source>3) Do git rebase</source>
          <target state="translated">3)做git rebase</target>
        </trans-unit>
        <trans-unit id="d4541ea89f937e9631ef09121301c9c25bafe06b" translate="yes" xml:space="preserve">
          <source>4) Then the opened editor contains last 3 commit information.</source>
          <target state="translated">4)然后打开的编辑器包含最后3个提交信息。</target>
        </trans-unit>
        <trans-unit id="364b0e5b207712eb15befa385fb7b8c9eb0a1ff1" translate="yes" xml:space="preserve">
          <source>5) Change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;drop&lt;/code&gt; in all those 3 commits. Then save and close the editor.</source>
          <target state="translated">5）更改 &lt;code&gt;pick&lt;/code&gt; 以 &lt;code&gt;drop&lt;/code&gt; 所有这3个提交。 然后保存并关闭编辑器。</target>
        </trans-unit>
        <trans-unit id="8d83cc370dffdf424de5b7fe3e77dc0739de448d" translate="yes" xml:space="preserve">
          <source>6) Now last 3 commits are removed from current branch (&lt;code&gt;master&lt;/code&gt;). Now push the branch forcefully, with &lt;code&gt;+&lt;/code&gt; sign before branch name.</source>
          <target state="translated">6）现在，最后3个提交已从当前分支（ &lt;code&gt;master&lt;/code&gt; ）中删除。 现在，用力推分支，在分支名称前加 &lt;code&gt;+&lt;/code&gt; 号。</target>
        </trans-unit>
        <trans-unit id="481f1e51dbb9650f3dec4ebcbee5bde1fa9e1998" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning: the reflog is enabled by default, but if you've manually disabled it (e.g. by using a &quot;bare&quot; git repository), you won't be able to get the 3 commits back after running &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;警告：默认情况下已启用reflog，但是如果您手动禁用了reflog（例如，通过使用&amp;ldquo;裸露&amp;rdquo;的git仓库），则在运行 &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt; 之后，您将无法取回3次提交--keep HEAD〜 3 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fecb2dc113e6f448810dffb1f5193fa5652bcaa2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git cherry-pick&lt;/em&gt; applies those three commits to newbranch.</source>
          <target state="translated">&lt;em&gt;git cherry-pick&lt;/em&gt;将这三个提交应用于newbranch。</target>
        </trans-unit>
        <trans-unit id="62c9092203459b0b2ebfe9d9dd2a6471c1dc910f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f225dd72b1ea2e11e4cc4f79ba9ce4e1e63b176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f25233cdf3d6a4bf94c9763c22b443736bd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="618e043fbabf5fb6ff301d8d6b97dd697c0e91af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git log&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f357915ce858ad1ed6fc9d6a133973f4b6bcd61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git push&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581e76256e26a6bb9eb3e8dde9619b387d8395e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do this if you pushed master's changes upstream&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您将主控的更改推到上游，请不要这样做&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c3b92d1806c6012b9c82785c86133828f8f9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead do this:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;而是这样做：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf1d482ca9e07ac50613f05ca0beacb0601807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It doesn't preserve the mistaken commit messages,&lt;/strong&gt; so you'll need to add a new commit message to this new commit</source>
          <target state="translated">&lt;strong&gt;它不会保留错误的提交消息，&lt;/strong&gt;因此您需要向此新提交添加新的提交消息。</target>
        </trans-unit>
        <trans-unit id="298a626f1e670a24eb99d1fb32033d364b917fc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use the first seven characters or
  the whole commit hash</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以使用前七个字符或整个提交哈希</target>
        </trans-unit>
        <trans-unit id="cb2a21cdd4aab0e9d2330b3c145c7c960afb328a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old version&lt;/strong&gt; - before I learned about &lt;code&gt;git branch -f&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;旧版本&lt;/strong&gt; -在我了解 &lt;code&gt;git branch -f&lt;/code&gt; 之前</target>
        </trans-unit>
        <trans-unit id="4a938097a5c19c110bf22c9137514e43948a3cab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; With Git version 2.0 and later, if you later &lt;code&gt;git rebase&lt;/code&gt; the new branch upon the original (&lt;code&gt;master&lt;/code&gt;) branch, you may need an explicit &lt;code&gt;--no-fork-point&lt;/code&gt; option during the rebase to avoid losing the commits you moved from the master branch.  Having &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; set makes this more likely.  See &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellor's answer&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在Git 2.0版及更高版本中，如果稍后 &lt;code&gt;git rebase&lt;/code&gt; 将新分支重新设置为原始（ &lt;code&gt;master&lt;/code&gt; ）分支，则在重新设置过程中可能需要显式的 &lt;code&gt;--no-fork-point&lt;/code&gt; 选项，以避免丢失从主分支。 &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; 设置branch.autosetuprebase使其更有可能。 有关详细信息，请参见&lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellor的答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fa271f29257aa3264a3cd5f63a031ba49701cc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 1 ]&lt;/strong&gt; Rename &lt;code&gt;master&lt;/code&gt; branch to your &lt;code&gt;newbranch&lt;/code&gt; (assuming you are on &lt;code&gt;master&lt;/code&gt; branch):</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;将 &lt;code&gt;master&lt;/code&gt; 分支重命名为您的 &lt;code&gt;newbranch&lt;/code&gt; （假设您位于 &lt;code&gt;master&lt;/code&gt; 分支上）：</target>
        </trans-unit>
        <trans-unit id="3e0a0ebd28accdae6ce3332752ece2864cfbf011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 2 ]&lt;/strong&gt; Create &lt;code&gt;master&lt;/code&gt; branch from the commit that you wish:</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;根据您希望的提交创建 &lt;code&gt;master&lt;/code&gt; 分支：</target>
        </trans-unit>
        <trans-unit id="08664a172af09c307beca0dc6e18e23b37792687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;create&lt;/strong&gt; a &lt;em&gt;new branch&lt;/em&gt; from the current one :&lt;code&gt;git branch new-branch-name&lt;/code&gt;</source>
          <target state="translated">从当前&lt;em&gt;分支&lt;/em&gt; &lt;strong&gt;创建&lt;/strong&gt;一个&lt;em&gt;新分支&lt;/em&gt; ： &lt;code&gt;git branch new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5abe106c34fb61d8ac5178b46edd8aa8e47234e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch -m master newbranch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;git branch -m主newbranch&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c7728f4e40b017c98351ed0201f96bbd435d95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch master B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;git分支主管B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19f154caa171db7ec34910e2d77c14361d0cc90e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;push&lt;/strong&gt; your &lt;em&gt;new branch&lt;/em&gt;: &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;推送&lt;/strong&gt;您的&lt;em&gt;新分支&lt;/em&gt; ： &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d24ea4762b706e087ecf25c1abf71b090074e6f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revert&lt;/strong&gt; your &lt;em&gt;old(current) branch&lt;/em&gt; to the last pushed/stable state: &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;将&lt;/strong&gt;您的&lt;em&gt;旧（当前）分支&lt;/em&gt; &lt;strong&gt;还原&lt;/strong&gt;到上一推送/稳定状态： &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="123bbeedc5451e39c60a89718d9fa034b768d3b3" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git branch newBranch&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;git branch newBranch&lt;/code&gt; 之后 ：</target>
        </trans-unit>
        <trans-unit id="4e03f1b09ddfb9fdb0690ffafc858190ba16f537" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; 之后：</target>
        </trans-unit>
        <trans-unit id="634bdd7acbc2bc8da73f2a0106b15811988287cd" translate="yes" xml:space="preserve">
          <source>An alternative that doesn't rely on the reflog is:</source>
          <target state="translated">一个不依赖回录的替代方案是:。</target>
        </trans-unit>
        <trans-unit id="4136e4007e2c8d131948d98078cb665d8a8d26f9" translate="yes" xml:space="preserve">
          <source>Another way to do this:</source>
          <target state="translated">另一种方法是:</target>
        </trans-unit>
        <trans-unit id="12b70b8d93639000b2abfedcfa890a9fd5664604" translate="yes" xml:space="preserve">
          <source>Applies the stashed changes to your working directory and clears the stash</source>
          <target state="translated">将隐藏的更改应用到工作目录中,并清除隐藏的更改。</target>
        </trans-unit>
        <trans-unit id="b1a8c702af2789b621b2ff6dadbe4bd16d08b257" translate="yes" xml:space="preserve">
          <source>As the next time you run &lt;code&gt;git rebase&lt;/code&gt; (or &lt;code&gt;git pull --rebase&lt;/code&gt;) those 3 commits would be silently discarded from &lt;code&gt;newbranch&lt;/code&gt;! (see explanation below)</source>
          <target state="translated">下次运行 &lt;code&gt;git rebase&lt;/code&gt; （或 &lt;code&gt;git pull --rebase&lt;/code&gt; ）时，这3个提交将从 &lt;code&gt;newbranch&lt;/code&gt; 中静默丢弃！ （请参阅下面的说明）</target>
        </trans-unit>
        <trans-unit id="be54a1922487f0812b743e1122c1ed8ffe2b82c1" translate="yes" xml:space="preserve">
          <source>Being able to &lt;code&gt;push&lt;/code&gt; to &lt;code&gt;.&lt;/code&gt; is a nice trick to know.</source>
          <target state="translated">能够 &lt;code&gt;push&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 是个不错的窍门。</target>
        </trans-unit>
        <trans-unit id="da835c0dac3fd92f1e22cae2225d07b3903d70b2" translate="yes" xml:space="preserve">
          <source>Both branches can then be pushed without force!</source>
          <target state="translated">这样一来,两个枝条都可以不用用力就能推开!</target>
        </trans-unit>
        <trans-unit id="95821c35a792c616eedf8f2cd2d313d1ec24a74b" translate="yes" xml:space="preserve">
          <source>But do make sure how many commits to go back. Alternatively, instead of &lt;code&gt;HEAD~3&lt;/code&gt;, you can simply provide the hash of the commit (or the reference like &lt;code&gt;origin/master&lt;/code&gt;) you want to revert back to, e.g:</source>
          <target state="translated">但是请确保要返回多少次提交。 另外，除了HEAD〜3之外，您还可以提供要还原回的提交（或引用，例如 &lt;code&gt;origin/master&lt;/code&gt; ）的哈希，例如：</target>
        </trans-unit>
        <trans-unit id="872296281e7b54043777ea01b0a4ce1a26fd3bae" translate="yes" xml:space="preserve">
          <source>But in this particular case we want those 3 commits to be considered as part of the topic branch. To achieve that, we need to fork off the upstream at the earlier revision that doesn't include the 3 commits. That's what my suggested solutions do, hence they both leave the reflog in the correct state.</source>
          <target state="translated">但在这个特殊情况下,我们希望这3个提交被视为主题分支的一部分。为了实现这个目标,我们需要在之前的版本中分叉掉不包括这3个提交的上游。这就是我所建议的解决方案,因此它们都能让 reflog 处于正确的状态。</target>
        </trans-unit>
        <trans-unit id="45d164dad0e050f5f56b5e4723f55131be5c697d" translate="yes" xml:space="preserve">
          <source>C commit: &lt;code&gt;9aa1233&lt;/code&gt;</source>
          <target state="translated">C提交： &lt;code&gt;9aa1233&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d816936e6f324d26f6ab09f218554c1eecfa223" translate="yes" xml:space="preserve">
          <source>D commit: &lt;code&gt;453ac3d&lt;/code&gt;</source>
          <target state="translated">D提交： &lt;code&gt;453ac3d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae3448d5927b150f67eddc7092cb244b9ff78e90" translate="yes" xml:space="preserve">
          <source>Do NOT do this:</source>
          <target state="translated">不要这样做。</target>
        </trans-unit>
        <trans-unit id="74a68f79450dfaeabfe28bb86d277f6c85b80d3b" translate="yes" xml:space="preserve">
          <source>E commit: &lt;code&gt;612ecb3&lt;/code&gt;</source>
          <target state="translated">E提交： &lt;code&gt;612ecb3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ea36ce8d4940505e9a2c8fea5db868cd8b3d440" translate="yes" xml:space="preserve">
          <source>Execute</source>
          <target state="translated">Execute</target>
        </trans-unit>
        <trans-unit id="41e182bcf630ddfdb2e208e80da988684106a169" translate="yes" xml:space="preserve">
          <source>First it discards the 3 most recent commits (&lt;code&gt;--keep&lt;/code&gt; is like &lt;code&gt;--hard&lt;/code&gt;, but safer, as fails rather than throw away uncommitted changes).</source>
          <target state="translated">首先，它丢弃最近的3次提交（ &lt;code&gt;--keep&lt;/code&gt; 就像 &lt;code&gt;--hard&lt;/code&gt; 一样，但更安全，因为失败而不是丢弃未提交的更改）。</target>
        </trans-unit>
        <trans-unit id="8747b9e113bf2cfb1c795971c93836c1bcf8efee" translate="yes" xml:space="preserve">
          <source>For more details, see the definition of &lt;code&gt;--fork-point&lt;/code&gt; in the &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt; and &lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt; docs.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt;和&lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt;文档中的 &lt;code&gt;--fork-point&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="e4cf258bb8c46ad329c853a1c1c69dd2a1158855" translate="yes" xml:space="preserve">
          <source>For those wondering why it works (as I was at first):</source>
          <target state="translated">对于那些想知道它为什么能用的人来说(就像我最初的时候一样)。</target>
        </trans-unit>
        <trans-unit id="48d8c627be3c12fac8a0a9ddb9ceaa5e126cf358" translate="yes" xml:space="preserve">
          <source>Goals</source>
          <target state="translated">Goals</target>
        </trans-unit>
        <trans-unit id="8b39b9dc5abd99e7d1c85da79f7f139aa247fe44" translate="yes" xml:space="preserve">
          <source>Had just this situation:</source>
          <target state="translated">就有这种情况。</target>
        </trans-unit>
        <trans-unit id="c7bba187055e411f54827bed15bc8e5745ca59e5" translate="yes" xml:space="preserve">
          <source>Here's a far simpler solution for commits to the wrong branch. Starting on branch &lt;code&gt;master&lt;/code&gt; that has three mistaken commits:</source>
          <target state="translated">这是提交错误分支的简单得多的解决方案。 从具有三个错误提交的分支 &lt;code&gt;master&lt;/code&gt; 节点开始：</target>
        </trans-unit>
        <trans-unit id="1de38d1d55e635d53f8816d378d4a458f286f03d" translate="yes" xml:space="preserve">
          <source>How can I go from this</source>
          <target state="translated">我怎么能从这一点出发</target>
        </trans-unit>
        <trans-unit id="13c47b488a3cc7d11dee9bd8d436360a945b32d2" translate="yes" xml:space="preserve">
          <source>I do this at least once a week when I accidentally make new commits to &lt;code&gt;master&lt;/code&gt; instead of &lt;code&gt;develop&lt;/code&gt;. Usually I have only one commit to rollback in which case using &lt;code&gt;git reset HEAD^&lt;/code&gt; on line 1 is a simpler way to rollback just one commit.</source>
          <target state="translated">当我不小心做出新的承诺而不是 &lt;code&gt;develop&lt;/code&gt; 时，我每周至少这样做一次。 通常我只有一个提交回滚，在这种情况下，在第1行使用 &lt;code&gt;git reset HEAD^&lt;/code&gt; 是回滚一个提交的更简单方法。</target>
        </trans-unit>
        <trans-unit id="e84261e078202fee3b7e1e26bd6f8e2ae8860322" translate="yes" xml:space="preserve">
          <source>I expected that commit I would be the HEAD, but commit L is it now...</source>
          <target state="translated">我以为提交I会是HEAD,但提交L是现在......</target>
        </trans-unit>
        <trans-unit id="b84b3d703ca68884c4afef2a54d5682f9ac70042" translate="yes" xml:space="preserve">
          <source>I performed:</source>
          <target state="translated">我的表演。</target>
        </trans-unit>
        <trans-unit id="108997d98177d91547a86ccb3b5ea4d361ecb4f7" translate="yes" xml:space="preserve">
          <source>I'd like to move the last several commits I've committed to master to a new branch and take master back to before those commits were made. Unfortunately, my Git-fu is not strong enough yet, any help?</source>
          <target state="translated">我想把最后几个提交到master的提交转移到一个新的分支,然后把master移回提交之前。不幸的是,我的 Git-fu 还不够强大,有什么帮助吗?</target>
        </trans-unit>
        <trans-unit id="55591bccd6c04d7d962a2f9c0483a3c06b6f73cd" translate="yes" xml:space="preserve">
          <source>I.e. How can I go from this</source>
          <target state="translated">即:我如何才能从这个</target>
        </trans-unit>
        <trans-unit id="bf2e448a40f1dc65cb033a53947f9de8ce03aa54" translate="yes" xml:space="preserve">
          <source>If you just need to move all your &lt;strong&gt;unpushed&lt;/strong&gt; commits to a &lt;em&gt;new branch&lt;/em&gt;,
then you just need to,</source>
          <target state="translated">如果您只需要将所有未&lt;strong&gt;推送的&lt;/strong&gt;提交移动到&lt;em&gt;新分支&lt;/em&gt; ，则只需，</target>
        </trans-unit>
        <trans-unit id="88e00813d5f261f8ce1b530d3691b5a28b42c071" translate="yes" xml:space="preserve">
          <source>If you want to move your commits to an &lt;strong&gt;existing branch&lt;/strong&gt;, it will look like this:</source>
          <target state="translated">如果要将提交移至&lt;strong&gt;现有分支&lt;/strong&gt; ，则它将如下所示：</target>
        </trans-unit>
        <trans-unit id="f035e6176ae12939244c0bc97fd3cb810b00f464" translate="yes" xml:space="preserve">
          <source>If your primary purpose is to roll back &lt;code&gt;master&lt;/code&gt;</source>
          <target state="translated">如果您的主要目的是回滚 &lt;code&gt;master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45214cae2612ebffc27b8fdd7a3cf49ee7b2d607" translate="yes" xml:space="preserve">
          <source>In General...</source>
          <target state="translated">一般来说.....</target>
        </trans-unit>
        <trans-unit id="bb3aac5782cb0bbb27f75a8309492054edae5ba4" translate="yes" xml:space="preserve">
          <source>It doesn't leave random temporary branches cluttering your tree</source>
          <target state="translated">它不会在你的树上留下随意的临时枝条,让你的树变得杂乱无章。</target>
        </trans-unit>
        <trans-unit id="3fb312821e41e79eddb3acf1856ed936ed86cc23" translate="yes" xml:space="preserve">
          <source>Most previous answers are dangerously wrong!</source>
          <target state="translated">前面的答案大多都是危险的错误!</target>
        </trans-unit>
        <trans-unit id="b5dd6415f61bdd41463af9d7a28d0cc83e851bc5" translate="yes" xml:space="preserve">
          <source>Move the most recent commit(s) to a new branch with Git</source>
          <target state="translated">将最近的提交转移到一个新的分支中,使用Git</target>
        </trans-unit>
        <trans-unit id="fcb037bf01a5547a6fe279d69a24f2cc40eff948" translate="yes" xml:space="preserve">
          <source>Moving to a new branch</source>
          <target state="translated">搬迁到新的分支机构</target>
        </trans-unit>
        <trans-unit id="e517c2d1898a39a840275eb62257a2eb65ff2bb0" translate="yes" xml:space="preserve">
          <source>Moving to an existing branch</source>
          <target state="translated">搬迁到现有的分支机构</target>
        </trans-unit>
        <trans-unit id="cb27ea29bb4e133aeb88457377055c14669e73ea" translate="yes" xml:space="preserve">
          <source>Much simpler solution using git stash</source>
          <target state="translated">更简单的解决方案是使用git stash</target>
        </trans-unit>
        <trans-unit id="2703bf326c4936a1698a52cb2adb33dd2c3e84f2" translate="yes" xml:space="preserve">
          <source>Note the hashes of (say 3) commits you want on &lt;code&gt;newbranch&lt;/code&gt;. Here I shall use:</source>
          <target state="translated">注意在 &lt;code&gt;newbranch&lt;/code&gt; 上想要的（假设3）提交的哈希值。 在这里我将使用：</target>
        </trans-unit>
        <trans-unit id="0120e6e8a7f3c7eeba72c03401b5bc9075b7ee5f" translate="yes" xml:space="preserve">
          <source>Now you can push your code</source>
          <target state="translated">现在你可以推送你的代码</target>
        </trans-unit>
        <trans-unit id="79254a5c1f0da46c3626c687b6c825c4976482aa" translate="yes" xml:space="preserve">
          <source>Now your job done. If you picked correct id and correct branch then you will success. So before do this be careful. else another problem can occur.</source>
          <target state="translated">现在你的工作完成了。如果你选择了正确的ID和正确的分支,那么你就成功了。所以在做这个之前要小心,否则会出现另一个问题。</target>
        </trans-unit>
        <trans-unit id="3bec58387fa9f82ca21a0aa4cda21ca1d8c4614f" translate="yes" xml:space="preserve">
          <source>OR (on Git 1.7.2+, use ranges)</source>
          <target state="translated">或(在Git 1.7.2以上版本中,使用范围)。</target>
        </trans-unit>
        <trans-unit id="525be0773878e709982a03e49a0ec254a3a98f15" translate="yes" xml:space="preserve">
          <source>Since a branch is just a pointer, &lt;em&gt;master&lt;/em&gt; pointed to the last commit.  When you made &lt;em&gt;newBranch&lt;/em&gt;, you simply made a new pointer to the last commit.  Then using &lt;code&gt;git reset&lt;/code&gt; you moved the &lt;em&gt;master&lt;/em&gt; pointer back two commits.  But since you didn't move &lt;em&gt;newBranch&lt;/em&gt;, it still points to the commit it originally did.</source>
          <target state="translated">由于分支只是一个指针，因此&lt;em&gt;master&lt;/em&gt;指向最后一次提交。 当您创建&lt;em&gt;newBranch时&lt;/em&gt; ，您仅创建了指向最后一次提交的新指针。 然后使用 &lt;code&gt;git reset&lt;/code&gt; 将&lt;em&gt;主&lt;/em&gt;指针移回两次提交。 但是由于您没有移动&lt;em&gt;newBranch&lt;/em&gt; ，它仍然指向它最初所做的提交。</target>
        </trans-unit>
        <trans-unit id="ecfc0ccc8476ea5a7bb72369f98104c559c1b775" translate="yes" xml:space="preserve">
          <source>So the reason that the following commands fail:</source>
          <target state="translated">所以,以下命令失败的原因。</target>
        </trans-unit>
        <trans-unit id="4f3738e8955364426af7ebf9eff26fbac099a3df" translate="yes" xml:space="preserve">
          <source>Some people also have other &lt;code&gt;upstreams&lt;/code&gt; rather than &lt;code&gt;origin&lt;/code&gt;, 
they should use appropriate &lt;code&gt;upstream&lt;/code&gt;</source>
          <target state="translated">有些人还有其他 &lt;code&gt;upstreams&lt;/code&gt; 而不是 &lt;code&gt;origin&lt;/code&gt; ，应该使用适当的 &lt;code&gt;upstream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="570a9b839cac572f5258c68ccdad0078fe34fbd3" translate="yes" xml:space="preserve">
          <source>Someone else may have pulled those changes. If you are only rewriting your local master there's no impact when it's pushed upstream, but pushing a rewritten history to collaborators can cause headaches.</source>
          <target state="translated">可能是别人把这些改动拉了出来。如果你只是改写本地的主程序,推送到上游时不会有什么影响,但把改写的历史推送给合作者会让人头疼。</target>
        </trans-unit>
        <trans-unit id="cda3722e5c6923b0d0f716f3f96cdbe49d7a3d51" translate="yes" xml:space="preserve">
          <source>Stashes away all the working file changes, making the &lt;code&gt;master&lt;/code&gt; working tree exactly equal to the HEAD~3 state</source>
          <target state="translated">整理所有工作文件的更改，使 &lt;code&gt;master&lt;/code&gt; 工作树与HEAD〜3状态完全相等</target>
        </trans-unit>
        <trans-unit id="f014c1b81acba76be319f6e06ad13c63babf8f9a" translate="yes" xml:space="preserve">
          <source>Step 1 - Note which commits from master you want on a &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">第1步-记下您想要在新 &lt;code&gt;newbranch&lt;/code&gt; 上提交的主提交</target>
        </trans-unit>
        <trans-unit id="77de30590bcc5eba20730cc3ce9edd805fdbea94" translate="yes" xml:space="preserve">
          <source>Step 2 - Put them on the &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">第2步-将它们放在新 &lt;code&gt;newbranch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ef7799a2cc92eeb984080cee231f2b1eb4552b6" translate="yes" xml:space="preserve">
          <source>Suppose you branched off origin/master when it contained commits M1, M2, M3, then made three commits yourself:</source>
          <target state="translated">假设你分出了原点管理员,当它包含了M1、M2、M3的提交,然后自己做了三个提交。</target>
        </trans-unit>
        <trans-unit id="78075e3598751ef549eca00dd9fd47aad1286c7f" translate="yes" xml:space="preserve">
          <source>Switches to an existing branch &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">切换到现有分支 &lt;code&gt;newbranch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef8a54cacfcff4a878e33b870f157418f27ef92d" translate="yes" xml:space="preserve">
          <source>Technical explanation</source>
          <target state="translated">技术解释</target>
        </trans-unit>
        <trans-unit id="8079b69aa99335d9f0a42877db1c34065d8e3e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--keep&lt;/code&gt; option preserves any uncommitted changes that you might have in unrelated files, or aborts if those changes would have to be overwritten -- similarly to what &lt;code&gt;git checkout&lt;/code&gt; does. If it aborts, &lt;code&gt;git stash&lt;/code&gt; your changes and retry, or use &lt;code&gt;--hard&lt;/code&gt; to lose the changes (even from files that didn't change between the commits!)</source>
          <target state="translated">&lt;code&gt;--keep&lt;/code&gt; 选项会保留您可能在不相关的文件中进行的所有未提交的更改，如果必须覆盖这些更改，则中止该操作&amp;ndash;与 &lt;code&gt;git checkout&lt;/code&gt; 所做的操作类似。 如果它中止， &lt;code&gt;git stash&lt;/code&gt; 您的更改 &lt;code&gt;--hard&lt;/code&gt; 试，或使用--hard来丢失更改（即使来自提交之间未更改的文件！）</target>
        </trans-unit>
        <trans-unit id="cb18d87d88bae1e920940bcec1aeb7ba8fe7699c" translate="yes" xml:space="preserve">
          <source>The OP stated the goal was to &quot;take master back to before those commits were made&quot; without losing changes and this solution does that.</source>
          <target state="translated">OP表示,目标是 &quot;在不丢失更改的情况下,将主控器收回到那些提交之前&quot;,而这个解决方案做到了这一点。</target>
        </trans-unit>
        <trans-unit id="62a1decf10bf015707d9b02585430c6f1322f604" translate="yes" xml:space="preserve">
          <source>The method exposed by sykora is the best option in this case. But sometimes is not the easiest and it's not a general method. For a general method use &lt;em&gt;git cherry-pick&lt;/em&gt;:</source>
          <target state="translated">在这种情况下，sykora公开的方法是最佳选择。 但是有时不是最简单的方法，也不是通用方法。 对于一般方法，请使用&lt;em&gt;git cherry-pick&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="2ac1f5122b2f0fe1bdf54429c44f6a7a914378e5" translate="yes" xml:space="preserve">
          <source>Then it cherry-picks those 3 commits back onto &lt;code&gt;newbranch&lt;/code&gt;. Since they're no longer referenced by a branch, it does that by using git's &lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt;: &lt;code&gt;HEAD@{2}&lt;/code&gt; is the commit that &lt;code&gt;HEAD&lt;/code&gt; used to refer to 2 operations ago, i.e. before we 1. checked out &lt;code&gt;newbranch&lt;/code&gt; and 2. used &lt;code&gt;git reset&lt;/code&gt; to discard the 3 commits.</source>
          <target state="translated">然后，将这3次提交重选到 &lt;code&gt;newbranch&lt;/code&gt; 。 由于它们不再被分支引用，因此通过使用git的&lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt;来做到这一点： &lt;code&gt;HEAD@{2}&lt;/code&gt; 是 &lt;code&gt;HEAD&lt;/code&gt; 之前用来引用2个操作的提交，即在我们1.检出 &lt;code&gt;newbranch&lt;/code&gt; 和2.使用 &lt;code&gt;git reset&lt;/code&gt; 以丢弃3次提交。</target>
        </trans-unit>
        <trans-unit id="b3be76dbc002a85c3ba3dbec4f3457261c1005e5" translate="yes" xml:space="preserve">
          <source>Then it forks off &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">然后它分叉 &lt;code&gt;newbranch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a1dfeaf50dd4725361f8f91dee54a77fac1fb01" translate="yes" xml:space="preserve">
          <source>This behavior makes sense, and is generally the right thing to do when rebasing.</source>
          <target state="translated">这种行为是有道理的,一般情况下,重新打基础的时候,这种行为是正确的。</target>
        </trans-unit>
        <trans-unit id="a289627f428a449d73d58b27d954331c780d0bb1" translate="yes" xml:space="preserve">
          <source>This doesn't &quot;move&quot; them in the technical sense but it has the same effect:</source>
          <target state="translated">这并不是技术意义上的 &quot;移动 &quot;他们,但效果是一样的。</target>
        </trans-unit>
        <trans-unit id="cf307f8136210a35158fbaf1577194155633a5a1" translate="yes" xml:space="preserve">
          <source>This method works by creating a new branch with the first command (&lt;code&gt;git branch newbranch&lt;/code&gt;) but not switching to it. Then we roll back the current branch (master) and switch to the new branch to continue working.</source>
          <target state="translated">此方法通过使用第一个命令（ &lt;code&gt;git branch newbranch&lt;/code&gt; ）创建一个新分支但不切换到该分支来起作用 。 然后，我们回滚当前分支（主节点）并切换到新分支以继续工作。</target>
        </trans-unit>
        <trans-unit id="d0e9c38f82188fee931c4f0a82882b530fe6aade" translate="yes" xml:space="preserve">
          <source>To achieve what OP wants, its a 2-step process:</source>
          <target state="translated">要达到OP的目的,需要一个2个步骤的过程。</target>
        </trans-unit>
        <trans-unit id="180ac7da64b802a0acc96a63a7f62f40267a005d" translate="yes" xml:space="preserve">
          <source>To be sure to land on the right spot in the history its easier to work with the hash of the commit</source>
          <target state="translated">为了确保在历史记录中找到正确的位置,使用提交的哈希值比较容易。</target>
        </trans-unit>
        <trans-unit id="16aeef47080440b48dad1867a2809500799144e9" translate="yes" xml:space="preserve">
          <source>To do this without rewriting history (i.e. if you've already pushed the commits):</source>
          <target state="translated">要做到不重写历史记录(即如果你已经推送了提交)。</target>
        </trans-unit>
        <trans-unit id="dfd4ca14b7084feb67d10a6a3b1a443b9cdff306" translate="yes" xml:space="preserve">
          <source>Undoes the last three commits (and their messages) to &lt;code&gt;master&lt;/code&gt;, yet leaves all working files intact</source>
          <target state="translated">撤消对 &lt;code&gt;master&lt;/code&gt; 的最后三次提交（及其消息），但所有工作文件保持不变</target>
        </trans-unit>
        <trans-unit id="b1a9571ab5fcd1563a9ab94e00d9b31a597a8833" translate="yes" xml:space="preserve">
          <source>Update! Use up-arrow to scroll through your command buffer to reapply the prior commit with its commit message (thanks @ARK)</source>
          <target state="translated">更新! 使用向上箭头滚动你的命令缓冲区,重新应用之前的提交信息(感谢@ARK)。</target>
        </trans-unit>
        <trans-unit id="777ff4167ef757e40b01ee27147ff5be2a96d312" translate="yes" xml:space="preserve">
          <source>Using your local reflog, &lt;code&gt;git rebase&lt;/code&gt; can see that you forked from an earlier incarnation of the origin/master branch, and hence that the M2 and M3 commits are not really part of your topic branch. Hence it reasonably assumes that since M2 was removed from the upstream branch, you no longer want it in your topic branch either once the topic branch is rebased:</source>
          <target state="translated">使用本地reflog， &lt;code&gt;git rebase&lt;/code&gt; 可以看到您是从origin / master分支的较早版本中派生的，因此M2和M3提交实际上不是您的主题分支的一部分。 因此，可以合理地假设由于M2已从上游分支中删除，因此一旦主题分支重新建立基础，您就不再希望在主题分支中使用它：</target>
        </trans-unit>
        <trans-unit id="22a1d6b1997c8096890ab17ef65190a74cf777f0" translate="yes" xml:space="preserve">
          <source>What this does, by line number</source>
          <target state="translated">按行号分,这是在做什么?</target>
        </trans-unit>
        <trans-unit id="3937db1b011d2fbca8cb7989edb73e13f8dee01f" translate="yes" xml:space="preserve">
          <source>What this doesn't do</source>
          <target state="translated">这并没有起到什么作用</target>
        </trans-unit>
        <trans-unit id="32b70d40f89c8426b134e72c00bb22ea189a3222" translate="yes" xml:space="preserve">
          <source>When to use this?</source>
          <target state="translated">什么时候用这个?</target>
        </trans-unit>
        <trans-unit id="2bc0f58c6ada69cc511b237a44108d2a2b976fea" translate="yes" xml:space="preserve">
          <source>Why would &lt;code&gt;git rebase&lt;/code&gt; discard the 3 commits after the first example? It's because &lt;code&gt;git rebase&lt;/code&gt; with no arguments enables the &lt;code&gt;--fork-point&lt;/code&gt; option by default, which uses the local reflog to try to be robust against the upstream branch being force-pushed.</source>
          <target state="translated">为什么 &lt;code&gt;git rebase&lt;/code&gt; 在第一个示例之后会丢弃3次提交？ 这是因为不带参数的 &lt;code&gt;git rebase&lt;/code&gt; 默认情况下会启用 &lt;code&gt;--fork-point&lt;/code&gt; 选项，该选项使用本地reflog来尝试对强行推入的上游分支保持鲁棒性。</target>
        </trans-unit>
        <trans-unit id="04789008eacc93f3bbeb6a094ce1ec4c64a422a0" translate="yes" xml:space="preserve">
          <source>With two commands</source>
          <target state="translated">有两个命令</target>
        </trans-unit>
        <trans-unit id="05b565ff31b4dbc1668f9ed425e0349b85c4df5a" translate="yes" xml:space="preserve">
          <source>Yet another way to do this, using just 2 commands. Also keeps your current working tree intact.</source>
          <target state="translated">然而另一种方法,只需使用2个命令就能完成。还可以保持你当前的工作树的完整。</target>
        </trans-unit>
        <trans-unit id="0050df2a380504a6a85fa9dc4941906d833964a3" translate="yes" xml:space="preserve">
          <source>You can do this is just 3  simple step that i used.</source>
          <target state="translated">你可以做到这一点,这只是3个简单的步骤,我使用的。</target>
        </trans-unit>
        <trans-unit id="2e0a33cd78ba4958dc622fc4118ce7ec3482322f" translate="yes" xml:space="preserve">
          <source>You can now use &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; as you normally would. All new commits will be added to &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">现在，您可以像平常一样使用 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 了 。 所有新的提交都将添加到 &lt;code&gt;newbranch&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="b09980a485be5652befdb8e0e423606cd0857bdf" translate="yes" xml:space="preserve">
          <source>You don't care about the messages on the mistaken commits</source>
          <target state="translated">你根本就不关心那些被误犯的信息</target>
        </trans-unit>
        <trans-unit id="76f63380152e0b12d34f1f53c663119b94ac180b" translate="yes" xml:space="preserve">
          <source>You don't want complications like temporary/new branches, finding and copying commit hashes, and other headaches</source>
          <target state="translated">你不希望出现时效性分支、查找和复制提交哈希等并发症,以及其他令人头疼的问题。</target>
        </trans-unit>
        <trans-unit id="0ddcf492d5268073f416e3cada6030e943e71240" translate="yes" xml:space="preserve">
          <source>You haven't pushed yet</source>
          <target state="translated">你还没推呢</target>
        </trans-unit>
        <trans-unit id="d7b0857d0c18b9ab571e5c305a90d96154e86fc6" translate="yes" xml:space="preserve">
          <source>You want this to be easy to memorize</source>
          <target state="translated">你想让这个东西容易记住</target>
        </trans-unit>
        <trans-unit id="75d5778d3600ba08394fe388f687f5156172c313" translate="yes" xml:space="preserve">
          <source>You want to go back to C, and move D and E to the new branch.  Here's what it looks like at first:</source>
          <target state="translated">你想回C,把D和E搬到新的分支上。下面是一开始的样子。</target>
        </trans-unit>
        <trans-unit id="d108fcb68849122d6885b5a131db74d96d3bf6d0" translate="yes" xml:space="preserve">
          <source>You want to keep file changes</source>
          <target state="translated">你想保持文件的变化</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4663caa7b2f5e911bdfb4cf441b4b09dc0759c64" translate="yes" xml:space="preserve">
          <source>but then someone rewrites history by force-pushing origin/master to remove M2:</source>
          <target state="translated">但后来有人通过强推 originmaster删除M2,改写了历史。</target>
        </trans-unit>
        <trans-unit id="6c8f9a168afb7fafa88d80cae6a23dac31c56379" translate="yes" xml:space="preserve">
          <source>giving</source>
          <target state="translated">giving</target>
        </trans-unit>
        <trans-unit id="d314ed7563a1b8a0b56a2edc1b1e809d2a66500b" translate="yes" xml:space="preserve">
          <source>is because they leave the reflog in the wrong state. Git sees &lt;code&gt;newbranch&lt;/code&gt; as having forked off the upstream branch at a revision that includes the 3 commits, then the &lt;code&gt;reset --hard&lt;/code&gt; rewrites the upstream's history to remove the commits, and so next time you run &lt;code&gt;git rebase&lt;/code&gt; it discards them like any other commit that has been removed from the upstream.</source>
          <target state="translated">是因为它们使reflog处于错误状态。 Git认为 &lt;code&gt;newbranch&lt;/code&gt; 在包含3个提交的修订版本中分叉了上游分支，然后 &lt;code&gt;reset --hard&lt;/code&gt; 重写了上游的历史记录以删除提交，因此，下次运行 &lt;code&gt;git rebase&lt;/code&gt; 时,它将像其他提交一样丢弃它们已从上游移除。</target>
        </trans-unit>
        <trans-unit id="ffd583141089c5adc863ae42b4a86dd7477a4031" translate="yes" xml:space="preserve">
          <source>to this?</source>
          <target state="translated">到这个?</target>
        </trans-unit>
        <trans-unit id="ad3f025daaa46c547e7ff3268c862cc219dcf84b" translate="yes" xml:space="preserve">
          <source>you can also provide some rang of commit id.</source>
          <target state="translated">你也可以提供一些rong的commit id。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
