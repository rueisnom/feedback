<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1628563">
    <body>
      <group id="1628563">
        <trans-unit id="6ca0548b1ae7d77cf8176a8562bef6c6ec1f4654" translate="yes" xml:space="preserve">
          <source>(if you prefer you can write &lt;code&gt;@{-1}&lt;/code&gt; - the previously checked out branch - instead of &lt;code&gt;oldbranch&lt;/code&gt;).</source>
          <target state="translated">(si lo prefiere, puede escribir &lt;code&gt;@{-1}&lt;/code&gt; , la rama desprotegida anteriormente, en lugar de &lt;code&gt;oldbranch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9f8435deadd1fe3bd0b7d1a92942e67a02ac6466" translate="yes" xml:space="preserve">
          <source>1) Create a new branch, which moves all your changes to new_branch.</source>
          <target state="translated">1)Crear una nueva rama,que mueva todos sus cambios a new_branch.</target>
        </trans-unit>
        <trans-unit id="67a880d1f38aa8e151836c7841725f2f5ce6ef07" translate="yes" xml:space="preserve">
          <source>1) make new branch where you want to commit you recent update.</source>
          <target state="translated">1)hacer una nueva sucursal en la que quieras enviar tu reciente actualización.</target>
        </trans-unit>
        <trans-unit id="e03e86c3388b7cf5555eb916dbba2967506aaeec" translate="yes" xml:space="preserve">
          <source>2)  Find  Recent Commit Id for commit on new branch.</source>
          <target state="translated">2)Encuentra la identificación de compromiso reciente para el compromiso en la nueva rama.</target>
        </trans-unit>
        <trans-unit id="ca6b48cf4285ff6ee19a338900c7ea56c23bd692" translate="yes" xml:space="preserve">
          <source>2) Then go back to old branch.</source>
          <target state="translated">2)Entonces vuelve a la vieja rama.</target>
        </trans-unit>
        <trans-unit id="1a5ca855c4b43689641d35143dbafebcc3c36cb6" translate="yes" xml:space="preserve">
          <source>3)  Copy that commit id  note that Most Recent commit list take place on top. so you can find your commit. you also find this via message.</source>
          <target state="translated">3)Copia ese ID de confirmación,nota que la lista de confirmaciones más recientes se encuentra en la parte superior,para que puedas encontrar tu confirmación.También puedes encontrarla a través de un mensaje.</target>
        </trans-unit>
        <trans-unit id="8879da991940a5e92a574b5dce3946ef8b03f6e3" translate="yes" xml:space="preserve">
          <source>3) Do git rebase</source>
          <target state="translated">3)Hacer git rebase</target>
        </trans-unit>
        <trans-unit id="d4541ea89f937e9631ef09121301c9c25bafe06b" translate="yes" xml:space="preserve">
          <source>4) Then the opened editor contains last 3 commit information.</source>
          <target state="translated">4)Luego el editor abierto contiene la información de los últimos 3 commits.</target>
        </trans-unit>
        <trans-unit id="364b0e5b207712eb15befa385fb7b8c9eb0a1ff1" translate="yes" xml:space="preserve">
          <source>5) Change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;drop&lt;/code&gt; in all those 3 commits. Then save and close the editor.</source>
          <target state="translated">5) Cambia la &lt;code&gt;pick&lt;/code&gt; para &lt;code&gt;drop&lt;/code&gt; todos esos 3 commits. Luego guarde y cierre el editor.</target>
        </trans-unit>
        <trans-unit id="8d83cc370dffdf424de5b7fe3e77dc0739de448d" translate="yes" xml:space="preserve">
          <source>6) Now last 3 commits are removed from current branch (&lt;code&gt;master&lt;/code&gt;). Now push the branch forcefully, with &lt;code&gt;+&lt;/code&gt; sign before branch name.</source>
          <target state="translated">6) Ahora se eliminan las &amp;uacute;ltimas 3 confirmaciones de la rama actual ( &lt;code&gt;master&lt;/code&gt; ). Ahora empuje la rama con fuerza, con el signo &lt;code&gt;+&lt;/code&gt; antes del nombre de la rama.</target>
        </trans-unit>
        <trans-unit id="481f1e51dbb9650f3dec4ebcbee5bde1fa9e1998" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning: the reflog is enabled by default, but if you've manually disabled it (e.g. by using a &quot;bare&quot; git repository), you won't be able to get the 3 commits back after running &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Advertencia: el reflog est&amp;aacute; habilitado de forma predeterminada, pero si lo ha deshabilitado manualmente (por ejemplo, utilizando un repositorio git &quot;desnudo&quot;), no podr&amp;aacute; recuperar los 3 commits despu&amp;eacute;s de ejecutar &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fecb2dc113e6f448810dffb1f5193fa5652bcaa2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git cherry-pick&lt;/em&gt; applies those three commits to newbranch.</source>
          <target state="translated">&lt;em&gt;git cherry-pick&lt;/em&gt; aplica esos tres commits a newbranch.</target>
        </trans-unit>
        <trans-unit id="62c9092203459b0b2ebfe9d9dd2a6471c1dc910f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f225dd72b1ea2e11e4cc4f79ba9ce4e1e63b176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f25233cdf3d6a4bf94c9763c22b443736bd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="618e043fbabf5fb6ff301d8d6b97dd697c0e91af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git log&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f357915ce858ad1ed6fc9d6a133973f4b6bcd61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git push&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581e76256e26a6bb9eb3e8dde9619b387d8395e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do this if you pushed master's changes upstream&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No hagas esto si empujaste los cambios del maestro hacia arriba&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c3b92d1806c6012b9c82785c86133828f8f9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead do this:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;En cambio, haz esto:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf1d482ca9e07ac50613f05ca0beacb0601807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It doesn't preserve the mistaken commit messages,&lt;/strong&gt; so you'll need to add a new commit message to this new commit</source>
          <target state="translated">&lt;strong&gt;No conserva los mensajes de confirmaci&amp;oacute;n err&amp;oacute;neos,&lt;/strong&gt; por lo que deber&amp;aacute; agregar un nuevo mensaje de confirmaci&amp;oacute;n a esta nueva confirmaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="298a626f1e670a24eb99d1fb32033d364b917fc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use the first seven characters or
  the whole commit hash</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Puede usar los primeros siete caracteres o el hash de confirmaci&amp;oacute;n completo</target>
        </trans-unit>
        <trans-unit id="cb2a21cdd4aab0e9d2330b3c145c7c960afb328a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old version&lt;/strong&gt; - before I learned about &lt;code&gt;git branch -f&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Versi&amp;oacute;n&lt;/strong&gt; anterior: antes de aprender sobre &lt;code&gt;git branch -f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a938097a5c19c110bf22c9137514e43948a3cab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; With Git version 2.0 and later, if you later &lt;code&gt;git rebase&lt;/code&gt; the new branch upon the original (&lt;code&gt;master&lt;/code&gt;) branch, you may need an explicit &lt;code&gt;--no-fork-point&lt;/code&gt; option during the rebase to avoid losing the commits you moved from the master branch.  Having &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; set makes this more likely.  See &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellor's answer&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;ADVERTENCIA:&lt;/strong&gt; con Git versi&amp;oacute;n 2.0 y posteriores, si luego &lt;code&gt;git rebase&lt;/code&gt; la nueva rama en la rama original ( &lt;code&gt;master&lt;/code&gt; ), es posible que necesite una &lt;code&gt;--no-fork-point&lt;/code&gt; expl&amp;iacute;cita sin punto de bifurcaci&amp;oacute;n durante la nueva versi&amp;oacute;n para evitar perder las confirmaciones que movi&amp;oacute; del rama maestra Tener &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; configurado hace que esto sea m&amp;aacute;s probable. Vea &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;la respuesta de John Mellor&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="2fa271f29257aa3264a3cd5f63a031ba49701cc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 1 ]&lt;/strong&gt; Rename &lt;code&gt;master&lt;/code&gt; branch to your &lt;code&gt;newbranch&lt;/code&gt; (assuming you are on &lt;code&gt;master&lt;/code&gt; branch):</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt; Cambie el nombre de la rama &lt;code&gt;master&lt;/code&gt; a su &lt;code&gt;newbranch&lt;/code&gt; rama (suponiendo que est&amp;eacute; en la rama &lt;code&gt;master&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="3e0a0ebd28accdae6ce3332752ece2864cfbf011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 2 ]&lt;/strong&gt; Create &lt;code&gt;master&lt;/code&gt; branch from the commit that you wish:</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt; Crea &lt;code&gt;master&lt;/code&gt; rama maestra a partir del commit que desees:</target>
        </trans-unit>
        <trans-unit id="08664a172af09c307beca0dc6e18e23b37792687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;create&lt;/strong&gt; a &lt;em&gt;new branch&lt;/em&gt; from the current one :&lt;code&gt;git branch new-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;crear&lt;/strong&gt; una &lt;em&gt;nueva rama&lt;/em&gt; de la actual: &lt;code&gt;git branch new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5abe106c34fb61d8ac5178b46edd8aa8e47234e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch -m master newbranch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;git branch -m master newbranch&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c7728f4e40b017c98351ed0201f96bbd435d95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch master B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;git branch master B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19f154caa171db7ec34910e2d77c14361d0cc90e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;push&lt;/strong&gt; your &lt;em&gt;new branch&lt;/em&gt;: &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;empuje&lt;/strong&gt; su &lt;em&gt;nueva sucursal&lt;/em&gt; : &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d24ea4762b706e087ecf25c1abf71b090074e6f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revert&lt;/strong&gt; your &lt;em&gt;old(current) branch&lt;/em&gt; to the last pushed/stable state: &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;revierta&lt;/strong&gt; su &lt;em&gt;rama anterior (actual)&lt;/em&gt; al &amp;uacute;ltimo estado de &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt; / estable: git reset --hard origin / old-branch-name</target>
        </trans-unit>
        <trans-unit id="123bbeedc5451e39c60a89718d9fa034b768d3b3" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git branch newBranch&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;git branch newBranch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e03f1b09ddfb9fdb0690ffafc858190ba16f537" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="634bdd7acbc2bc8da73f2a0106b15811988287cd" translate="yes" xml:space="preserve">
          <source>An alternative that doesn't rely on the reflog is:</source>
          <target state="translated">Una alternativa que no depende del reflog es:</target>
        </trans-unit>
        <trans-unit id="4136e4007e2c8d131948d98078cb665d8a8d26f9" translate="yes" xml:space="preserve">
          <source>Another way to do this:</source>
          <target state="translated">Otra forma de hacer esto:</target>
        </trans-unit>
        <trans-unit id="12b70b8d93639000b2abfedcfa890a9fd5664604" translate="yes" xml:space="preserve">
          <source>Applies the stashed changes to your working directory and clears the stash</source>
          <target state="translated">Aplica los cambios escondidos a tu directorio de trabajo y limpia el escondite.</target>
        </trans-unit>
        <trans-unit id="b1a8c702af2789b621b2ff6dadbe4bd16d08b257" translate="yes" xml:space="preserve">
          <source>As the next time you run &lt;code&gt;git rebase&lt;/code&gt; (or &lt;code&gt;git pull --rebase&lt;/code&gt;) those 3 commits would be silently discarded from &lt;code&gt;newbranch&lt;/code&gt;! (see explanation below)</source>
          <target state="translated">&amp;iexcl;Como la pr&amp;oacute;xima vez que ejecute &lt;code&gt;git rebase&lt;/code&gt; (o &lt;code&gt;git pull --rebase&lt;/code&gt; ), esas 3 confirmaciones se descartar&amp;aacute;n silenciosamente de &lt;code&gt;newbranch&lt;/code&gt; ! (ver explicaci&amp;oacute;n a continuaci&amp;oacute;n)</target>
        </trans-unit>
        <trans-unit id="be54a1922487f0812b743e1122c1ed8ffe2b82c1" translate="yes" xml:space="preserve">
          <source>Being able to &lt;code&gt;push&lt;/code&gt; to &lt;code&gt;.&lt;/code&gt; is a nice trick to know.</source>
          <target state="translated">Ser capaz de &lt;code&gt;push&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; Es un buen truco para saber.</target>
        </trans-unit>
        <trans-unit id="da835c0dac3fd92f1e22cae2225d07b3903d70b2" translate="yes" xml:space="preserve">
          <source>Both branches can then be pushed without force!</source>
          <target state="translated">¡Ambas ramas pueden ser empujadas sin fuerza!</target>
        </trans-unit>
        <trans-unit id="95821c35a792c616eedf8f2cd2d313d1ec24a74b" translate="yes" xml:space="preserve">
          <source>But do make sure how many commits to go back. Alternatively, instead of &lt;code&gt;HEAD~3&lt;/code&gt;, you can simply provide the hash of the commit (or the reference like &lt;code&gt;origin/master&lt;/code&gt;) you want to revert back to, e.g:</source>
          <target state="translated">Pero aseg&amp;uacute;rese de cu&amp;aacute;ntas confirmaciones para volver. Alternativamente, en lugar de &lt;code&gt;HEAD~3&lt;/code&gt; , simplemente puede proporcionar el hash de la confirmaci&amp;oacute;n (o la referencia como &lt;code&gt;origin/master&lt;/code&gt; ) a la que desea volver, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="872296281e7b54043777ea01b0a4ce1a26fd3bae" translate="yes" xml:space="preserve">
          <source>But in this particular case we want those 3 commits to be considered as part of the topic branch. To achieve that, we need to fork off the upstream at the earlier revision that doesn't include the 3 commits. That's what my suggested solutions do, hence they both leave the reflog in the correct state.</source>
          <target state="translated">Pero en este caso en particular queremos que esos 3 compromisos sean considerados como parte de la rama temática.Para lograrlo,necesitamos bifurcarnos en la revisión anterior que no incluye las 3 confirmaciones.Eso es lo que hacen mis soluciones sugeridas,por lo que ambas dejan el reflog en el estado correcto.</target>
        </trans-unit>
        <trans-unit id="45d164dad0e050f5f56b5e4723f55131be5c697d" translate="yes" xml:space="preserve">
          <source>C commit: &lt;code&gt;9aa1233&lt;/code&gt;</source>
          <target state="translated">C commit: &lt;code&gt;9aa1233&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d816936e6f324d26f6ab09f218554c1eecfa223" translate="yes" xml:space="preserve">
          <source>D commit: &lt;code&gt;453ac3d&lt;/code&gt;</source>
          <target state="translated">D commit: &lt;code&gt;453ac3d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae3448d5927b150f67eddc7092cb244b9ff78e90" translate="yes" xml:space="preserve">
          <source>Do NOT do this:</source>
          <target state="translated">No lo hagas:</target>
        </trans-unit>
        <trans-unit id="74a68f79450dfaeabfe28bb86d277f6c85b80d3b" translate="yes" xml:space="preserve">
          <source>E commit: &lt;code&gt;612ecb3&lt;/code&gt;</source>
          <target state="translated">E commit: &lt;code&gt;612ecb3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ea36ce8d4940505e9a2c8fea5db868cd8b3d440" translate="yes" xml:space="preserve">
          <source>Execute</source>
          <target state="translated">Execute</target>
        </trans-unit>
        <trans-unit id="41e182bcf630ddfdb2e208e80da988684106a169" translate="yes" xml:space="preserve">
          <source>First it discards the 3 most recent commits (&lt;code&gt;--keep&lt;/code&gt; is like &lt;code&gt;--hard&lt;/code&gt;, but safer, as fails rather than throw away uncommitted changes).</source>
          <target state="translated">Primero descarta los 3 commits m&amp;aacute;s recientes ( &lt;code&gt;--keep&lt;/code&gt; es como &lt;code&gt;--hard&lt;/code&gt; , pero m&amp;aacute;s seguro, ya que falla en lugar de descartar cambios no confirmados).</target>
        </trans-unit>
        <trans-unit id="8747b9e113bf2cfb1c795971c93836c1bcf8efee" translate="yes" xml:space="preserve">
          <source>For more details, see the definition of &lt;code&gt;--fork-point&lt;/code&gt; in the &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt; and &lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt; docs.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la definici&amp;oacute;n de &lt;code&gt;--fork-point&lt;/code&gt; en los documentos &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt; y &lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4cf258bb8c46ad329c853a1c1c69dd2a1158855" translate="yes" xml:space="preserve">
          <source>For those wondering why it works (as I was at first):</source>
          <target state="translated">Para aquellos que se preguntan por qué funciona (como yo al principio):</target>
        </trans-unit>
        <trans-unit id="48d8c627be3c12fac8a0a9ddb9ceaa5e126cf358" translate="yes" xml:space="preserve">
          <source>Goals</source>
          <target state="translated">Goals</target>
        </trans-unit>
        <trans-unit id="8b39b9dc5abd99e7d1c85da79f7f139aa247fe44" translate="yes" xml:space="preserve">
          <source>Had just this situation:</source>
          <target state="translated">Tenía esta situación:</target>
        </trans-unit>
        <trans-unit id="c7bba187055e411f54827bed15bc8e5745ca59e5" translate="yes" xml:space="preserve">
          <source>Here's a far simpler solution for commits to the wrong branch. Starting on branch &lt;code&gt;master&lt;/code&gt; that has three mistaken commits:</source>
          <target state="translated">Aqu&amp;iacute; hay una soluci&amp;oacute;n mucho m&amp;aacute;s simple para los compromisos con la rama incorrecta. Comenzando en la rama &lt;code&gt;master&lt;/code&gt; que tiene tres confirmaciones err&amp;oacute;neas:</target>
        </trans-unit>
        <trans-unit id="1de38d1d55e635d53f8816d378d4a458f286f03d" translate="yes" xml:space="preserve">
          <source>How can I go from this</source>
          <target state="translated">¿Cómo puedo pasar de esto</target>
        </trans-unit>
        <trans-unit id="13c47b488a3cc7d11dee9bd8d436360a945b32d2" translate="yes" xml:space="preserve">
          <source>I do this at least once a week when I accidentally make new commits to &lt;code&gt;master&lt;/code&gt; instead of &lt;code&gt;develop&lt;/code&gt;. Usually I have only one commit to rollback in which case using &lt;code&gt;git reset HEAD^&lt;/code&gt; on line 1 is a simpler way to rollback just one commit.</source>
          <target state="translated">Hago esto al menos una vez a la semana cuando accidentalmente realizo nuevos compromisos para &lt;code&gt;master&lt;/code&gt; lugar de &lt;code&gt;develop&lt;/code&gt; . Por lo general, solo tengo un commit para revertir, en cuyo caso usar &lt;code&gt;git reset HEAD^&lt;/code&gt; en la l&amp;iacute;nea 1 es una forma m&amp;aacute;s simple de revertir solo un commit.</target>
        </trans-unit>
        <trans-unit id="e84261e078202fee3b7e1e26bd6f8e2ae8860322" translate="yes" xml:space="preserve">
          <source>I expected that commit I would be the HEAD, but commit L is it now...</source>
          <target state="translated">Esperaba que el compromiso I fuera la CABEZA,pero el compromiso L es ahora...</target>
        </trans-unit>
        <trans-unit id="b84b3d703ca68884c4afef2a54d5682f9ac70042" translate="yes" xml:space="preserve">
          <source>I performed:</source>
          <target state="translated">He actuado:</target>
        </trans-unit>
        <trans-unit id="108997d98177d91547a86ccb3b5ea4d361ecb4f7" translate="yes" xml:space="preserve">
          <source>I'd like to move the last several commits I've committed to master to a new branch and take master back to before those commits were made. Unfortunately, my Git-fu is not strong enough yet, any help?</source>
          <target state="translated">Me gustaría trasladar los últimos compromisos que me he comprometido a dominar a una nueva rama y llevar al maestro de vuelta a antes de que se hicieran esos compromisos.Desafortunadamente,mi Git-fu no es lo suficientemente fuerte todavía,¿alguna ayuda?</target>
        </trans-unit>
        <trans-unit id="55591bccd6c04d7d962a2f9c0483a3c06b6f73cd" translate="yes" xml:space="preserve">
          <source>I.e. How can I go from this</source>
          <target state="translated">Es decir,¿cómo puedo pasar de esto</target>
        </trans-unit>
        <trans-unit id="bf2e448a40f1dc65cb033a53947f9de8ce03aa54" translate="yes" xml:space="preserve">
          <source>If you just need to move all your &lt;strong&gt;unpushed&lt;/strong&gt; commits to a &lt;em&gt;new branch&lt;/em&gt;,
then you just need to,</source>
          <target state="translated">Si solo necesita mover todas sus confirmaciones no &lt;strong&gt;apresuradas&lt;/strong&gt; a una &lt;em&gt;nueva sucursal&lt;/em&gt; , entonces solo necesita,</target>
        </trans-unit>
        <trans-unit id="88e00813d5f261f8ce1b530d3691b5a28b42c071" translate="yes" xml:space="preserve">
          <source>If you want to move your commits to an &lt;strong&gt;existing branch&lt;/strong&gt;, it will look like this:</source>
          <target state="translated">Si desea mover sus confirmaciones a una &lt;strong&gt;rama existente&lt;/strong&gt; , se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f035e6176ae12939244c0bc97fd3cb810b00f464" translate="yes" xml:space="preserve">
          <source>If your primary purpose is to roll back &lt;code&gt;master&lt;/code&gt;</source>
          <target state="translated">Si su prop&amp;oacute;sito principal es hacer retroceder al &lt;code&gt;master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45214cae2612ebffc27b8fdd7a3cf49ee7b2d607" translate="yes" xml:space="preserve">
          <source>In General...</source>
          <target state="translated">En general...</target>
        </trans-unit>
        <trans-unit id="bb3aac5782cb0bbb27f75a8309492054edae5ba4" translate="yes" xml:space="preserve">
          <source>It doesn't leave random temporary branches cluttering your tree</source>
          <target state="translated">No deja ramas temporales aleatorias desordenando tu árbol</target>
        </trans-unit>
        <trans-unit id="3fb312821e41e79eddb3acf1856ed936ed86cc23" translate="yes" xml:space="preserve">
          <source>Most previous answers are dangerously wrong!</source>
          <target state="translated">¡La mayoría de las respuestas anteriores están peligrosamente equivocadas!</target>
        </trans-unit>
        <trans-unit id="b5dd6415f61bdd41463af9d7a28d0cc83e851bc5" translate="yes" xml:space="preserve">
          <source>Move the most recent commit(s) to a new branch with Git</source>
          <target state="translated">Mover los compromisos más recientes a una nueva sucursal con Git</target>
        </trans-unit>
        <trans-unit id="fcb037bf01a5547a6fe279d69a24f2cc40eff948" translate="yes" xml:space="preserve">
          <source>Moving to a new branch</source>
          <target state="translated">Mudándose a una nueva sucursal</target>
        </trans-unit>
        <trans-unit id="e517c2d1898a39a840275eb62257a2eb65ff2bb0" translate="yes" xml:space="preserve">
          <source>Moving to an existing branch</source>
          <target state="translated">Mudarse a una sucursal existente</target>
        </trans-unit>
        <trans-unit id="cb27ea29bb4e133aeb88457377055c14669e73ea" translate="yes" xml:space="preserve">
          <source>Much simpler solution using git stash</source>
          <target state="translated">Una solución mucho más simple usando el alijo de git</target>
        </trans-unit>
        <trans-unit id="2703bf326c4936a1698a52cb2adb33dd2c3e84f2" translate="yes" xml:space="preserve">
          <source>Note the hashes of (say 3) commits you want on &lt;code&gt;newbranch&lt;/code&gt;. Here I shall use:</source>
          <target state="translated">Tenga en cuenta los hashes de (digamos 3) confirmaciones que desee en &lt;code&gt;newbranch&lt;/code&gt; . Aqu&amp;iacute; usar&amp;eacute;:</target>
        </trans-unit>
        <trans-unit id="0120e6e8a7f3c7eeba72c03401b5bc9075b7ee5f" translate="yes" xml:space="preserve">
          <source>Now you can push your code</source>
          <target state="translated">Ahora puedes presionar tu código</target>
        </trans-unit>
        <trans-unit id="79254a5c1f0da46c3626c687b6c825c4976482aa" translate="yes" xml:space="preserve">
          <source>Now your job done. If you picked correct id and correct branch then you will success. So before do this be careful. else another problem can occur.</source>
          <target state="translated">Ahora tu trabajo está hecho.Si eliges la identificación correcta y la rama correcta,entonces tendrás éxito.Así que antes de hacer esto ten cuidado.De lo contrario,puede ocurrir otro problema.</target>
        </trans-unit>
        <trans-unit id="3bec58387fa9f82ca21a0aa4cda21ca1d8c4614f" translate="yes" xml:space="preserve">
          <source>OR (on Git 1.7.2+, use ranges)</source>
          <target state="translated">O (en Git 1.7.2+,usar rangos)</target>
        </trans-unit>
        <trans-unit id="525be0773878e709982a03e49a0ec254a3a98f15" translate="yes" xml:space="preserve">
          <source>Since a branch is just a pointer, &lt;em&gt;master&lt;/em&gt; pointed to the last commit.  When you made &lt;em&gt;newBranch&lt;/em&gt;, you simply made a new pointer to the last commit.  Then using &lt;code&gt;git reset&lt;/code&gt; you moved the &lt;em&gt;master&lt;/em&gt; pointer back two commits.  But since you didn't move &lt;em&gt;newBranch&lt;/em&gt;, it still points to the commit it originally did.</source>
          <target state="translated">Como una rama es solo un puntero, el &lt;em&gt;maestro&lt;/em&gt; se&amp;ntilde;al&amp;oacute; la &amp;uacute;ltima confirmaci&amp;oacute;n. Cuando cre&amp;oacute; &lt;em&gt;newBranch&lt;/em&gt; , simplemente cre&amp;oacute; un nuevo puntero a la &amp;uacute;ltima confirmaci&amp;oacute;n. Luego, usando &lt;code&gt;git reset&lt;/code&gt; , movi&amp;oacute; el puntero &lt;em&gt;maestro&lt;/em&gt; hacia atr&amp;aacute;s dos commits. Pero como no movi&amp;oacute; &lt;em&gt;newBranch&lt;/em&gt; , todav&amp;iacute;a se&amp;ntilde;ala la confirmaci&amp;oacute;n que hizo originalmente.</target>
        </trans-unit>
        <trans-unit id="ecfc0ccc8476ea5a7bb72369f98104c559c1b775" translate="yes" xml:space="preserve">
          <source>So the reason that the following commands fail:</source>
          <target state="translated">Así que la razón por la que los siguientes comandos fallan:</target>
        </trans-unit>
        <trans-unit id="4f3738e8955364426af7ebf9eff26fbac099a3df" translate="yes" xml:space="preserve">
          <source>Some people also have other &lt;code&gt;upstreams&lt;/code&gt; rather than &lt;code&gt;origin&lt;/code&gt;, 
they should use appropriate &lt;code&gt;upstream&lt;/code&gt;</source>
          <target state="translated">Algunas personas tambi&amp;eacute;n tienen otras &lt;code&gt;upstreams&lt;/code&gt; lugar de &lt;code&gt;origin&lt;/code&gt; , deben usar &lt;code&gt;upstream&lt;/code&gt; apropiadas</target>
        </trans-unit>
        <trans-unit id="570a9b839cac572f5258c68ccdad0078fe34fbd3" translate="yes" xml:space="preserve">
          <source>Someone else may have pulled those changes. If you are only rewriting your local master there's no impact when it's pushed upstream, but pushing a rewritten history to collaborators can cause headaches.</source>
          <target state="translated">Alguien más puede haber hecho esos cambios.Si sólo estás reescribiendo tu maestro local no hay impacto cuando se empuja río arriba,pero empujar una historia reescrita a los colaboradores puede causar dolores de cabeza.</target>
        </trans-unit>
        <trans-unit id="cda3722e5c6923b0d0f716f3f96cdbe49d7a3d51" translate="yes" xml:space="preserve">
          <source>Stashes away all the working file changes, making the &lt;code&gt;master&lt;/code&gt; working tree exactly equal to the HEAD~3 state</source>
          <target state="translated">Guarda todos los cambios del archivo de trabajo, haciendo que el &amp;aacute;rbol de trabajo &lt;code&gt;master&lt;/code&gt; exactamente igual al estado HEAD ~ 3</target>
        </trans-unit>
        <trans-unit id="f014c1b81acba76be319f6e06ad13c63babf8f9a" translate="yes" xml:space="preserve">
          <source>Step 1 - Note which commits from master you want on a &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">Paso 1: &lt;code&gt;newbranch&lt;/code&gt; qu&amp;eacute; confirmaciones del maestro desea en una rama nueva</target>
        </trans-unit>
        <trans-unit id="77de30590bcc5eba20730cc3ce9edd805fdbea94" translate="yes" xml:space="preserve">
          <source>Step 2 - Put them on the &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">Paso 2: &lt;code&gt;newbranch&lt;/code&gt; en la rama nueva</target>
        </trans-unit>
        <trans-unit id="1ef7799a2cc92eeb984080cee231f2b1eb4552b6" translate="yes" xml:space="preserve">
          <source>Suppose you branched off origin/master when it contained commits M1, M2, M3, then made three commits yourself:</source>
          <target state="translated">Supongamos que te separaste del maestro de origen cuando contenía confirmaciones M1,M2,M3,y luego hiciste tres confirmaciones tú mismo:</target>
        </trans-unit>
        <trans-unit id="78075e3598751ef549eca00dd9fd47aad1286c7f" translate="yes" xml:space="preserve">
          <source>Switches to an existing branch &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">Cambia a una rama existente &lt;code&gt;newbranch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef8a54cacfcff4a878e33b870f157418f27ef92d" translate="yes" xml:space="preserve">
          <source>Technical explanation</source>
          <target state="translated">Explicación técnica</target>
        </trans-unit>
        <trans-unit id="8079b69aa99335d9f0a42877db1c34065d8e3e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--keep&lt;/code&gt; option preserves any uncommitted changes that you might have in unrelated files, or aborts if those changes would have to be overwritten -- similarly to what &lt;code&gt;git checkout&lt;/code&gt; does. If it aborts, &lt;code&gt;git stash&lt;/code&gt; your changes and retry, or use &lt;code&gt;--hard&lt;/code&gt; to lose the changes (even from files that didn't change between the commits!)</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;--keep&lt;/code&gt; conserva cualquier cambio no confirmado que pueda tener en archivos no relacionados, o aborta si esos cambios tuvieran que sobrescribirse, de manera similar a lo que hace &lt;code&gt;git checkout&lt;/code&gt; . Si aborta, &lt;code&gt;git stash&lt;/code&gt; sus cambios y &lt;code&gt;--hard&lt;/code&gt; a intentarlo, o use --hard para perder los cambios (&amp;iexcl;incluso de archivos que no cambiaron entre los commits!)</target>
        </trans-unit>
        <trans-unit id="cb18d87d88bae1e920940bcec1aeb7ba8fe7699c" translate="yes" xml:space="preserve">
          <source>The OP stated the goal was to &quot;take master back to before those commits were made&quot; without losing changes and this solution does that.</source>
          <target state="translated">La OP declaró que el objetivo era &quot;llevar al maestro de vuelta a antes de que se hicieran esos compromisos&quot; sin perder los cambios y esta solución hace eso.</target>
        </trans-unit>
        <trans-unit id="62a1decf10bf015707d9b02585430c6f1322f604" translate="yes" xml:space="preserve">
          <source>The method exposed by sykora is the best option in this case. But sometimes is not the easiest and it's not a general method. For a general method use &lt;em&gt;git cherry-pick&lt;/em&gt;:</source>
          <target state="translated">El m&amp;eacute;todo expuesto por sykora es la mejor opci&amp;oacute;n en este caso. Pero a veces no es lo m&amp;aacute;s f&amp;aacute;cil y no es un m&amp;eacute;todo general. Para un m&amp;eacute;todo general, use &lt;em&gt;git cherry-pick&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="2ac1f5122b2f0fe1bdf54429c44f6a7a914378e5" translate="yes" xml:space="preserve">
          <source>Then it cherry-picks those 3 commits back onto &lt;code&gt;newbranch&lt;/code&gt;. Since they're no longer referenced by a branch, it does that by using git's &lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt;: &lt;code&gt;HEAD@{2}&lt;/code&gt; is the commit that &lt;code&gt;HEAD&lt;/code&gt; used to refer to 2 operations ago, i.e. before we 1. checked out &lt;code&gt;newbranch&lt;/code&gt; and 2. used &lt;code&gt;git reset&lt;/code&gt; to discard the 3 commits.</source>
          <target state="translated">Luego, recoge los 3 commits de nuevo en &lt;code&gt;newbranch&lt;/code&gt; . Como ya no se hace referencia a ellos por una rama, lo hace mediante el uso del &lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt; de git: &lt;code&gt;HEAD@{2}&lt;/code&gt; es el commit que &lt;code&gt;HEAD&lt;/code&gt; sol&amp;iacute;a referirse a 2 operaciones hace, es decir, antes de que 1. comprob&amp;aacute;ramos &lt;code&gt;newbranch&lt;/code&gt; y 2. use &lt;code&gt;git reset&lt;/code&gt; para descartar las 3 confirmaciones.</target>
        </trans-unit>
        <trans-unit id="b3be76dbc002a85c3ba3dbec4f3457261c1005e5" translate="yes" xml:space="preserve">
          <source>Then it forks off &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">Luego se bifurca de &lt;code&gt;newbranch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a1dfeaf50dd4725361f8f91dee54a77fac1fb01" translate="yes" xml:space="preserve">
          <source>This behavior makes sense, and is generally the right thing to do when rebasing.</source>
          <target state="translated">Este comportamiento tiene sentido,y generalmente es lo correcto cuando se rebaja.</target>
        </trans-unit>
        <trans-unit id="a289627f428a449d73d58b27d954331c780d0bb1" translate="yes" xml:space="preserve">
          <source>This doesn't &quot;move&quot; them in the technical sense but it has the same effect:</source>
          <target state="translated">Esto no los &quot;mueve&quot; en el sentido técnico,pero tiene el mismo efecto:</target>
        </trans-unit>
        <trans-unit id="cf307f8136210a35158fbaf1577194155633a5a1" translate="yes" xml:space="preserve">
          <source>This method works by creating a new branch with the first command (&lt;code&gt;git branch newbranch&lt;/code&gt;) but not switching to it. Then we roll back the current branch (master) and switch to the new branch to continue working.</source>
          <target state="translated">Este m&amp;eacute;todo funciona creando una nueva rama con el primer comando ( &lt;code&gt;git branch newbranch&lt;/code&gt; ) pero sin cambiar a ella. Luego, retrocedemos la rama actual (maestra) y cambiamos a la nueva rama para continuar trabajando.</target>
        </trans-unit>
        <trans-unit id="d0e9c38f82188fee931c4f0a82882b530fe6aade" translate="yes" xml:space="preserve">
          <source>To achieve what OP wants, its a 2-step process:</source>
          <target state="translated">Para lograr lo que quiere OP,es un proceso de dos pasos:</target>
        </trans-unit>
        <trans-unit id="180ac7da64b802a0acc96a63a7f62f40267a005d" translate="yes" xml:space="preserve">
          <source>To be sure to land on the right spot in the history its easier to work with the hash of the commit</source>
          <target state="translated">Para asegurarse de aterrizar en el lugar correcto de la historia es más fácil trabajar con el hachís del compromiso</target>
        </trans-unit>
        <trans-unit id="16aeef47080440b48dad1867a2809500799144e9" translate="yes" xml:space="preserve">
          <source>To do this without rewriting history (i.e. if you've already pushed the commits):</source>
          <target state="translated">Hacer esto sin reescribir la historia (es decir,si ya has empujado los compromisos):</target>
        </trans-unit>
        <trans-unit id="dfd4ca14b7084feb67d10a6a3b1a443b9cdff306" translate="yes" xml:space="preserve">
          <source>Undoes the last three commits (and their messages) to &lt;code&gt;master&lt;/code&gt;, yet leaves all working files intact</source>
          <target state="translated">Deshace las &amp;uacute;ltimas tres confirmaciones (y sus mensajes) para &lt;code&gt;master&lt;/code&gt; , pero deja intactos todos los archivos de trabajo</target>
        </trans-unit>
        <trans-unit id="b1a9571ab5fcd1563a9ab94e00d9b31a597a8833" translate="yes" xml:space="preserve">
          <source>Update! Use up-arrow to scroll through your command buffer to reapply the prior commit with its commit message (thanks @ARK)</source>
          <target state="translated">¡Actualización! Use la flecha hacia arriba para desplazarse a través de su buffer de comandos para volver a aplicar la confirmación previa con su mensaje de confirmación (gracias @ARK)</target>
        </trans-unit>
        <trans-unit id="777ff4167ef757e40b01ee27147ff5be2a96d312" translate="yes" xml:space="preserve">
          <source>Using your local reflog, &lt;code&gt;git rebase&lt;/code&gt; can see that you forked from an earlier incarnation of the origin/master branch, and hence that the M2 and M3 commits are not really part of your topic branch. Hence it reasonably assumes that since M2 was removed from the upstream branch, you no longer want it in your topic branch either once the topic branch is rebased:</source>
          <target state="translated">Usando su reflog local, &lt;code&gt;git rebase&lt;/code&gt; puede ver que se bifurc&amp;oacute; de una encarnaci&amp;oacute;n anterior de la rama de origen / maestra, y por lo tanto, las confirmaciones de M2 ​​y M3 no son realmente parte de su rama de tema. Por lo tanto, se supone razonablemente que, dado que M2 se elimin&amp;oacute; de la rama ascendente, ya no lo desea en su rama tem&amp;aacute;tica ni una vez que la rama tem&amp;aacute;tica se haya modificado:</target>
        </trans-unit>
        <trans-unit id="22a1d6b1997c8096890ab17ef65190a74cf777f0" translate="yes" xml:space="preserve">
          <source>What this does, by line number</source>
          <target state="translated">Lo que esto hace,por número de línea</target>
        </trans-unit>
        <trans-unit id="3937db1b011d2fbca8cb7989edb73e13f8dee01f" translate="yes" xml:space="preserve">
          <source>What this doesn't do</source>
          <target state="translated">Lo que esto no hace</target>
        </trans-unit>
        <trans-unit id="32b70d40f89c8426b134e72c00bb22ea189a3222" translate="yes" xml:space="preserve">
          <source>When to use this?</source>
          <target state="translated">¿Cuándo usar esto?</target>
        </trans-unit>
        <trans-unit id="2bc0f58c6ada69cc511b237a44108d2a2b976fea" translate="yes" xml:space="preserve">
          <source>Why would &lt;code&gt;git rebase&lt;/code&gt; discard the 3 commits after the first example? It's because &lt;code&gt;git rebase&lt;/code&gt; with no arguments enables the &lt;code&gt;--fork-point&lt;/code&gt; option by default, which uses the local reflog to try to be robust against the upstream branch being force-pushed.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; &lt;code&gt;git rebase&lt;/code&gt; descarta los 3 commits despu&amp;eacute;s del primer ejemplo? Es porque &lt;code&gt;git rebase&lt;/code&gt; sin argumentos habilita la opci&amp;oacute;n &lt;code&gt;--fork-point&lt;/code&gt; por defecto, que usa el registro local para tratar de ser robusto contra la rama ascendente que se empuja a la fuerza.</target>
        </trans-unit>
        <trans-unit id="04789008eacc93f3bbeb6a094ce1ec4c64a422a0" translate="yes" xml:space="preserve">
          <source>With two commands</source>
          <target state="translated">Con dos comandos</target>
        </trans-unit>
        <trans-unit id="05b565ff31b4dbc1668f9ed425e0349b85c4df5a" translate="yes" xml:space="preserve">
          <source>Yet another way to do this, using just 2 commands. Also keeps your current working tree intact.</source>
          <target state="translated">Otra forma de hacer esto,usando sólo dos comandos.También mantiene intacto el árbol de trabajo actual.</target>
        </trans-unit>
        <trans-unit id="0050df2a380504a6a85fa9dc4941906d833964a3" translate="yes" xml:space="preserve">
          <source>You can do this is just 3  simple step that i used.</source>
          <target state="translated">Puedes hacer esto es sólo 3 simples pasos que yo usé.</target>
        </trans-unit>
        <trans-unit id="2e0a33cd78ba4958dc622fc4118ce7ec3482322f" translate="yes" xml:space="preserve">
          <source>You can now use &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; as you normally would. All new commits will be added to &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">Ahora puede usar &lt;code&gt;git add&lt;/code&gt; y &lt;code&gt;git commit&lt;/code&gt; como lo har&amp;iacute;a normalmente. Todos los nuevos commits se agregar&amp;aacute;n a &lt;code&gt;newbranch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b09980a485be5652befdb8e0e423606cd0857bdf" translate="yes" xml:space="preserve">
          <source>You don't care about the messages on the mistaken commits</source>
          <target state="translated">No te importan los mensajes de los compromisos equivocados</target>
        </trans-unit>
        <trans-unit id="76f63380152e0b12d34f1f53c663119b94ac180b" translate="yes" xml:space="preserve">
          <source>You don't want complications like temporary/new branches, finding and copying commit hashes, and other headaches</source>
          <target state="translated">No quieres complicaciones como las ramas temporales,encontrar y copiar cometer hashes,y otros dolores de cabeza.</target>
        </trans-unit>
        <trans-unit id="0ddcf492d5268073f416e3cada6030e943e71240" translate="yes" xml:space="preserve">
          <source>You haven't pushed yet</source>
          <target state="translated">No has presionado todavía</target>
        </trans-unit>
        <trans-unit id="d7b0857d0c18b9ab571e5c305a90d96154e86fc6" translate="yes" xml:space="preserve">
          <source>You want this to be easy to memorize</source>
          <target state="translated">Quieres que esto sea fácil de memorizar</target>
        </trans-unit>
        <trans-unit id="75d5778d3600ba08394fe388f687f5156172c313" translate="yes" xml:space="preserve">
          <source>You want to go back to C, and move D and E to the new branch.  Here's what it looks like at first:</source>
          <target state="translated">Quieres volver a C,y trasladar a D y E a la nueva sucursal.Esto es lo que parece al principio:</target>
        </trans-unit>
        <trans-unit id="d108fcb68849122d6885b5a131db74d96d3bf6d0" translate="yes" xml:space="preserve">
          <source>You want to keep file changes</source>
          <target state="translated">Quieres mantener los cambios en los archivos</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4663caa7b2f5e911bdfb4cf441b4b09dc0759c64" translate="yes" xml:space="preserve">
          <source>but then someone rewrites history by force-pushing origin/master to remove M2:</source>
          <target state="translated">pero entonces alguien reescribe la historia empujando a la fuerza al maestro de origen para eliminar el M2:</target>
        </trans-unit>
        <trans-unit id="6c8f9a168afb7fafa88d80cae6a23dac31c56379" translate="yes" xml:space="preserve">
          <source>giving</source>
          <target state="translated">giving</target>
        </trans-unit>
        <trans-unit id="d314ed7563a1b8a0b56a2edc1b1e809d2a66500b" translate="yes" xml:space="preserve">
          <source>is because they leave the reflog in the wrong state. Git sees &lt;code&gt;newbranch&lt;/code&gt; as having forked off the upstream branch at a revision that includes the 3 commits, then the &lt;code&gt;reset --hard&lt;/code&gt; rewrites the upstream's history to remove the commits, and so next time you run &lt;code&gt;git rebase&lt;/code&gt; it discards them like any other commit that has been removed from the upstream.</source>
          <target state="translated">es porque dejan el reflog en el estado incorrecto. Git ve a &lt;code&gt;newbranch&lt;/code&gt; como una bifurcaci&amp;oacute;n de la rama ascendente en una revisi&amp;oacute;n que incluye los 3 commits, luego el &lt;code&gt;reset --hard&lt;/code&gt; reescribe el historial del upstream para eliminar los commits, por lo que la pr&amp;oacute;xima vez que ejecute &lt;code&gt;git rebase&lt;/code&gt; los descarta como cualquier otro commit que ha sido eliminado de la corriente arriba.</target>
        </trans-unit>
        <trans-unit id="ffd583141089c5adc863ae42b4a86dd7477a4031" translate="yes" xml:space="preserve">
          <source>to this?</source>
          <target state="translated">a esto?</target>
        </trans-unit>
        <trans-unit id="ad3f025daaa46c547e7ff3268c862cc219dcf84b" translate="yes" xml:space="preserve">
          <source>you can also provide some rang of commit id.</source>
          <target state="translated">...también puedes proporcionar algún rango de identificación de compromiso.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
