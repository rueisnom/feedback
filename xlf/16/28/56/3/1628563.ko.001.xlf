<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1628563">
    <body>
      <group id="1628563">
        <trans-unit id="6ca0548b1ae7d77cf8176a8562bef6c6ec1f4654" translate="yes" xml:space="preserve">
          <source>(if you prefer you can write &lt;code&gt;@{-1}&lt;/code&gt; - the previously checked out branch - instead of &lt;code&gt;oldbranch&lt;/code&gt;).</source>
          <target state="translated">(원하는 경우 &lt;code&gt;oldbranch&lt;/code&gt; 대신 &lt;code&gt;@{-1}&lt;/code&gt; -이전에 체크 아웃 한 분기)를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f8435deadd1fe3bd0b7d1a92942e67a02ac6466" translate="yes" xml:space="preserve">
          <source>1) Create a new branch, which moves all your changes to new_branch.</source>
          <target state="translated">1) 새 브랜치를 작성하면 모든 변경 사항이 new_branch로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="67a880d1f38aa8e151836c7841725f2f5ce6ef07" translate="yes" xml:space="preserve">
          <source>1) make new branch where you want to commit you recent update.</source>
          <target state="translated">1) 최근 업데이트를 커밋하려는 지점을 새로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e03e86c3388b7cf5555eb916dbba2967506aaeec" translate="yes" xml:space="preserve">
          <source>2)  Find  Recent Commit Id for commit on new branch.</source>
          <target state="translated">2) 새로운 지점에서 커밋 할 최근 커밋 ID를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ca6b48cf4285ff6ee19a338900c7ea56c23bd692" translate="yes" xml:space="preserve">
          <source>2) Then go back to old branch.</source>
          <target state="translated">2) 그런 다음 오래된 지점으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="1a5ca855c4b43689641d35143dbafebcc3c36cb6" translate="yes" xml:space="preserve">
          <source>3)  Copy that commit id  note that Most Recent commit list take place on top. so you can find your commit. you also find this via message.</source>
          <target state="translated">3) 해당 커밋 ID를 복사하십시오. 가장 최근의 커밋 목록이 맨 위에 나타납니다. 커밋을 찾을 수 있습니다. 당신은 또한 메시지를 통해 이것을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8879da991940a5e92a574b5dce3946ef8b03f6e3" translate="yes" xml:space="preserve">
          <source>3) Do git rebase</source>
          <target state="translated">3) 자식 리베이스 수행</target>
        </trans-unit>
        <trans-unit id="d4541ea89f937e9631ef09121301c9c25bafe06b" translate="yes" xml:space="preserve">
          <source>4) Then the opened editor contains last 3 commit information.</source>
          <target state="translated">4) 그런 다음 열린 편집기에는 마지막 3 개의 커밋 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="364b0e5b207712eb15befa385fb7b8c9eb0a1ff1" translate="yes" xml:space="preserve">
          <source>5) Change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;drop&lt;/code&gt; in all those 3 commits. Then save and close the editor.</source>
          <target state="translated">5) 모든 3 개의 커밋에 &lt;code&gt;pick&lt;/code&gt; 을 변경하십시오. 그런 다음 편집기를 저장하고 닫습니다.</target>
        </trans-unit>
        <trans-unit id="8d83cc370dffdf424de5b7fe3e77dc0739de448d" translate="yes" xml:space="preserve">
          <source>6) Now last 3 commits are removed from current branch (&lt;code&gt;master&lt;/code&gt;). Now push the branch forcefully, with &lt;code&gt;+&lt;/code&gt; sign before branch name.</source>
          <target state="translated">6) 이제 마지막 분기 3 개의 커밋이 현재 분기 ( &lt;code&gt;master&lt;/code&gt; )에서 제거됩니다. 이제 지점 이름 앞에 &lt;code&gt;+&lt;/code&gt; 기호를 사용하여 지점을 강제로 밀어 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="481f1e51dbb9650f3dec4ebcbee5bde1fa9e1998" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning: the reflog is enabled by default, but if you've manually disabled it (e.g. by using a &quot;bare&quot; git repository), you won't be able to get the 3 commits back after running &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;경고 : reflog는 기본적으로 활성화되어 있지만 수동으로 비활성화하면 (예 : &quot;bare&quot;git 저장소를 사용하여) &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt; 실행 한 후 3 개의 커밋을 다시 가져올 수 없습니다. 3 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fecb2dc113e6f448810dffb1f5193fa5652bcaa2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git cherry-pick&lt;/em&gt; applies those three commits to newbranch.</source>
          <target state="translated">&lt;em&gt;git cherry-pick&lt;/em&gt; 은 세 가지 커밋을 newbranch에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="62c9092203459b0b2ebfe9d9dd2a6471c1dc910f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f225dd72b1ea2e11e4cc4f79ba9ce4e1e63b176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f25233cdf3d6a4bf94c9763c22b443736bd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="618e043fbabf5fb6ff301d8d6b97dd697c0e91af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git log&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f357915ce858ad1ed6fc9d6a133973f4b6bcd61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git push&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581e76256e26a6bb9eb3e8dde9619b387d8395e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do this if you pushed master's changes upstream&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;마스터 변경 사항을 업스트림으로 푸시 한 경우이 작업을 수행하지 마십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c3b92d1806c6012b9c82785c86133828f8f9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead do this:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;대신 이것을하십시오 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf1d482ca9e07ac50613f05ca0beacb0601807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It doesn't preserve the mistaken commit messages,&lt;/strong&gt; so you'll need to add a new commit message to this new commit</source>
          <target state="translated">&lt;strong&gt;잘못된 커밋 메시지를 보존하지 않으므로이&lt;/strong&gt; 새로운 커밋에 새로운 커밋 메시지를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="298a626f1e670a24eb99d1fb32033d364b917fc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use the first seven characters or
  the whole commit hash</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 처음 7 자 또는 전체 커밋 해시를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cb2a21cdd4aab0e9d2330b3c145c7c960afb328a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old version&lt;/strong&gt; - before I learned about &lt;code&gt;git branch -f&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;이전 버전&lt;/strong&gt; - &lt;code&gt;git branch -f&lt;/code&gt; 에 대해 배우기 전에 -f</target>
        </trans-unit>
        <trans-unit id="4a938097a5c19c110bf22c9137514e43948a3cab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; With Git version 2.0 and later, if you later &lt;code&gt;git rebase&lt;/code&gt; the new branch upon the original (&lt;code&gt;master&lt;/code&gt;) branch, you may need an explicit &lt;code&gt;--no-fork-point&lt;/code&gt; option during the rebase to avoid losing the commits you moved from the master branch.  Having &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; set makes this more likely.  See &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellor's answer&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; Git 버전 2.0 이상에서 나중에 새 브랜치를 원래 ( &lt;code&gt;master&lt;/code&gt; ) 브랜치에 리베이스하면, 리베이스 동안 이동 한 커밋을 잃지 않도록 명시적인 &lt;code&gt;--no-fork-point&lt;/code&gt; 옵션이 필요할 수 있습니다. 마스터 브랜치. &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; 설정하면이 가능성이 높아집니다. 자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellor의 답변&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fa271f29257aa3264a3cd5f63a031ba49701cc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 1 ]&lt;/strong&gt; Rename &lt;code&gt;master&lt;/code&gt; branch to your &lt;code&gt;newbranch&lt;/code&gt; (assuming you are on &lt;code&gt;master&lt;/code&gt; branch):</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt; &lt;code&gt;master&lt;/code&gt; 브랜치의 이름을 새 브랜치로 바꿉니다 ( 마스터 브랜치에 있다고 가정).</target>
        </trans-unit>
        <trans-unit id="3e0a0ebd28accdae6ce3332752ece2864cfbf011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 2 ]&lt;/strong&gt; Create &lt;code&gt;master&lt;/code&gt; branch from the commit that you wish:</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt; 원하는 커밋에서 &lt;code&gt;master&lt;/code&gt; 브랜치를 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="08664a172af09c307beca0dc6e18e23b37792687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;create&lt;/strong&gt; a &lt;em&gt;new branch&lt;/em&gt; from the current one :&lt;code&gt;git branch new-branch-name&lt;/code&gt;</source>
          <target state="translated">현재 &lt;em&gt;분기&lt;/em&gt; 에서 &lt;em&gt;새 분기&lt;/em&gt; 를 &lt;strong&gt;만듭니다&lt;/strong&gt; &lt;code&gt;git branch new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5abe106c34fb61d8ac5178b46edd8aa8e47234e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch -m master newbranch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자식 분기 -m 마스터 새 분기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c7728f4e40b017c98351ed0201f96bbd435d95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch master B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자식 분기 마스터 B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19f154caa171db7ec34910e2d77c14361d0cc90e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;push&lt;/strong&gt; your &lt;em&gt;new branch&lt;/em&gt;: &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;새 브랜치&lt;/em&gt; &lt;code&gt;git push origin new-branch-name&lt;/code&gt; : git push origin new-branch-name</target>
        </trans-unit>
        <trans-unit id="d24ea4762b706e087ecf25c1abf71b090074e6f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revert&lt;/strong&gt; your &lt;em&gt;old(current) branch&lt;/em&gt; to the last pushed/stable state: &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;이전 (현재) 브랜치&lt;/em&gt; 를 마지막으로 푸시 / 안정적인 상태로 되돌 &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt; : git reset --hard origin / old-branch-name</target>
        </trans-unit>
        <trans-unit id="123bbeedc5451e39c60a89718d9fa034b768d3b3" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git branch newBranch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git branch newBranch&lt;/code&gt; 후 :</target>
        </trans-unit>
        <trans-unit id="4e03f1b09ddfb9fdb0690ffafc858190ba16f537" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; 후 --hard HEAD ~ 2 :</target>
        </trans-unit>
        <trans-unit id="634bdd7acbc2bc8da73f2a0106b15811988287cd" translate="yes" xml:space="preserve">
          <source>An alternative that doesn't rely on the reflog is:</source>
          <target state="translated">reflog에 의존하지 않는 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4136e4007e2c8d131948d98078cb665d8a8d26f9" translate="yes" xml:space="preserve">
          <source>Another way to do this:</source>
          <target state="translated">이를 수행하는 다른 방법 :</target>
        </trans-unit>
        <trans-unit id="12b70b8d93639000b2abfedcfa890a9fd5664604" translate="yes" xml:space="preserve">
          <source>Applies the stashed changes to your working directory and clears the stash</source>
          <target state="translated">숨김 변경 사항을 작업 디렉토리에 적용하고 숨김을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="b1a8c702af2789b621b2ff6dadbe4bd16d08b257" translate="yes" xml:space="preserve">
          <source>As the next time you run &lt;code&gt;git rebase&lt;/code&gt; (or &lt;code&gt;git pull --rebase&lt;/code&gt;) those 3 commits would be silently discarded from &lt;code&gt;newbranch&lt;/code&gt;! (see explanation below)</source>
          <target state="translated">다음에 &lt;code&gt;git rebase&lt;/code&gt; (또는 &lt;code&gt;git pull --rebase&lt;/code&gt; )를 실행할 때,이 3 개의 commit은 &lt;code&gt;newbranch&lt;/code&gt; 에서 자동으로 폐기됩니다! (아래 설명 참조)</target>
        </trans-unit>
        <trans-unit id="be54a1922487f0812b743e1122c1ed8ffe2b82c1" translate="yes" xml:space="preserve">
          <source>Being able to &lt;code&gt;push&lt;/code&gt; to &lt;code&gt;.&lt;/code&gt; is a nice trick to know.</source>
          <target state="translated">로 &lt;code&gt;push&lt;/code&gt; 할 수 &lt;code&gt;.&lt;/code&gt; 알아두면 좋은 요령입니다.</target>
        </trans-unit>
        <trans-unit id="da835c0dac3fd92f1e22cae2225d07b3903d70b2" translate="yes" xml:space="preserve">
          <source>Both branches can then be pushed without force!</source>
          <target state="translated">그러면 두 가지를 강제로 밀 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="95821c35a792c616eedf8f2cd2d313d1ec24a74b" translate="yes" xml:space="preserve">
          <source>But do make sure how many commits to go back. Alternatively, instead of &lt;code&gt;HEAD~3&lt;/code&gt;, you can simply provide the hash of the commit (or the reference like &lt;code&gt;origin/master&lt;/code&gt;) you want to revert back to, e.g:</source>
          <target state="translated">그러나 얼마나 많은 커밋을 되돌릴 수 있는지 확인하십시오. 또는 &lt;code&gt;HEAD~3&lt;/code&gt; 대신에 되돌릴 커밋의 해시 (또는 &lt;code&gt;origin/master&lt;/code&gt; 와 같은 참조)를 간단히 제공 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="872296281e7b54043777ea01b0a4ce1a26fd3bae" translate="yes" xml:space="preserve">
          <source>But in this particular case we want those 3 commits to be considered as part of the topic branch. To achieve that, we need to fork off the upstream at the earlier revision that doesn't include the 3 commits. That's what my suggested solutions do, hence they both leave the reflog in the correct state.</source>
          <target state="translated">그러나이 특별한 경우에 우리는이 3 개의 커밋이 토픽 브랜치의 일부로 간주되기를 원합니다. 이를 위해서는 3 개의 커밋이 포함되지 않은 이전 수정 버전에서 업스트림을 분기해야합니다. 그것이 내가 제안한 솔루션이하는 일이므로 둘 다 reflog를 올바른 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="45d164dad0e050f5f56b5e4723f55131be5c697d" translate="yes" xml:space="preserve">
          <source>C commit: &lt;code&gt;9aa1233&lt;/code&gt;</source>
          <target state="translated">C 커밋 : &lt;code&gt;9aa1233&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d816936e6f324d26f6ab09f218554c1eecfa223" translate="yes" xml:space="preserve">
          <source>D commit: &lt;code&gt;453ac3d&lt;/code&gt;</source>
          <target state="translated">D 커밋 : &lt;code&gt;453ac3d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae3448d5927b150f67eddc7092cb244b9ff78e90" translate="yes" xml:space="preserve">
          <source>Do NOT do this:</source>
          <target state="translated">이 작업을 수행하지 마십시오 :</target>
        </trans-unit>
        <trans-unit id="74a68f79450dfaeabfe28bb86d277f6c85b80d3b" translate="yes" xml:space="preserve">
          <source>E commit: &lt;code&gt;612ecb3&lt;/code&gt;</source>
          <target state="translated">전자 커밋 : &lt;code&gt;612ecb3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ea36ce8d4940505e9a2c8fea5db868cd8b3d440" translate="yes" xml:space="preserve">
          <source>Execute</source>
          <target state="translated">Execute</target>
        </trans-unit>
        <trans-unit id="41e182bcf630ddfdb2e208e80da988684106a169" translate="yes" xml:space="preserve">
          <source>First it discards the 3 most recent commits (&lt;code&gt;--keep&lt;/code&gt; is like &lt;code&gt;--hard&lt;/code&gt;, but safer, as fails rather than throw away uncommitted changes).</source>
          <target state="translated">먼저 가장 최근의 커밋 3 개를 버립니다 ( &lt;code&gt;--keep&lt;/code&gt; 은 &lt;code&gt;--hard&lt;/code&gt; 와 비슷하지만 커밋되지 않은 변경 사항을 버리는 대신 실패하므로 더 안전합니다).</target>
        </trans-unit>
        <trans-unit id="8747b9e113bf2cfb1c795971c93836c1bcf8efee" translate="yes" xml:space="preserve">
          <source>For more details, see the definition of &lt;code&gt;--fork-point&lt;/code&gt; in the &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt; and &lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt; docs.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt; 및 &lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt; docs에서 &lt;code&gt;--fork-point&lt;/code&gt; 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4cf258bb8c46ad329c853a1c1c69dd2a1158855" translate="yes" xml:space="preserve">
          <source>For those wondering why it works (as I was at first):</source>
          <target state="translated">왜 그것이 효과가 있는지 궁금해하는 사람들을 위해 :</target>
        </trans-unit>
        <trans-unit id="48d8c627be3c12fac8a0a9ddb9ceaa5e126cf358" translate="yes" xml:space="preserve">
          <source>Goals</source>
          <target state="translated">Goals</target>
        </trans-unit>
        <trans-unit id="8b39b9dc5abd99e7d1c85da79f7f139aa247fe44" translate="yes" xml:space="preserve">
          <source>Had just this situation:</source>
          <target state="translated">이 상황 만 있었다 :</target>
        </trans-unit>
        <trans-unit id="c7bba187055e411f54827bed15bc8e5745ca59e5" translate="yes" xml:space="preserve">
          <source>Here's a far simpler solution for commits to the wrong branch. Starting on branch &lt;code&gt;master&lt;/code&gt; that has three mistaken commits:</source>
          <target state="translated">다음은 잘못된 브랜치에 대한 커밋을위한 훨씬 간단한 솔루션입니다. 세 가지 잘못된 커밋이있는 지점 &lt;code&gt;master&lt;/code&gt; 에서 시작 :</target>
        </trans-unit>
        <trans-unit id="1de38d1d55e635d53f8816d378d4a458f286f03d" translate="yes" xml:space="preserve">
          <source>How can I go from this</source>
          <target state="translated">이걸 어떻게 할 수 있습니까</target>
        </trans-unit>
        <trans-unit id="13c47b488a3cc7d11dee9bd8d436360a945b32d2" translate="yes" xml:space="preserve">
          <source>I do this at least once a week when I accidentally make new commits to &lt;code&gt;master&lt;/code&gt; instead of &lt;code&gt;develop&lt;/code&gt;. Usually I have only one commit to rollback in which case using &lt;code&gt;git reset HEAD^&lt;/code&gt; on line 1 is a simpler way to rollback just one commit.</source>
          <target state="translated">나는 일주일에 한 번 이상 &lt;code&gt;develop&lt;/code&gt; 대신 &lt;code&gt;master&lt;/code&gt; 새로운 커밋을 할 때이 작업을 수행합니다. 일반적으로 롤백 할 커밋은 하나뿐입니다.이 경우 1 행에서 &lt;code&gt;git reset HEAD^&lt;/code&gt; 를 사용하면 커밋을 롤백하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e84261e078202fee3b7e1e26bd6f8e2ae8860322" translate="yes" xml:space="preserve">
          <source>I expected that commit I would be the HEAD, but commit L is it now...</source>
          <target state="translated">커밋은 HEAD가 될 것이라고 기대했지만 L 커밋은 지금입니다 ...</target>
        </trans-unit>
        <trans-unit id="b84b3d703ca68884c4afef2a54d5682f9ac70042" translate="yes" xml:space="preserve">
          <source>I performed:</source>
          <target state="translated">나는 수행했다 :</target>
        </trans-unit>
        <trans-unit id="108997d98177d91547a86ccb3b5ea4d361ecb4f7" translate="yes" xml:space="preserve">
          <source>I'd like to move the last several commits I've committed to master to a new branch and take master back to before those commits were made. Unfortunately, my Git-fu is not strong enough yet, any help?</source>
          <target state="translated">마지막 브랜치 몇 가지 커밋을 새 브랜치로 마스터하고 커밋하기 전에 다시 마스터로 가져 가고 싶습니다. 불행히도 내 Git-fu는 아직 충분히 강력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55591bccd6c04d7d962a2f9c0483a3c06b6f73cd" translate="yes" xml:space="preserve">
          <source>I.e. How can I go from this</source>
          <target state="translated">즉, 나는 이것을 어떻게 갈 수 있습니까</target>
        </trans-unit>
        <trans-unit id="bf2e448a40f1dc65cb033a53947f9de8ce03aa54" translate="yes" xml:space="preserve">
          <source>If you just need to move all your &lt;strong&gt;unpushed&lt;/strong&gt; commits to a &lt;em&gt;new branch&lt;/em&gt;,
then you just need to,</source>
          <target state="translated">&lt;strong&gt;푸시되지 않은&lt;/strong&gt; 커밋을 모두 &lt;em&gt;새로운 브랜치&lt;/em&gt; 로 옮길 필요가 있다면,</target>
        </trans-unit>
        <trans-unit id="88e00813d5f261f8ce1b530d3691b5a28b42c071" translate="yes" xml:space="preserve">
          <source>If you want to move your commits to an &lt;strong&gt;existing branch&lt;/strong&gt;, it will look like this:</source>
          <target state="translated">커밋을 &lt;strong&gt;기존 브랜치&lt;/strong&gt; 로 옮기려면 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="f035e6176ae12939244c0bc97fd3cb810b00f464" translate="yes" xml:space="preserve">
          <source>If your primary purpose is to roll back &lt;code&gt;master&lt;/code&gt;</source>
          <target state="translated">주된 목적이 &lt;code&gt;master&lt;/code&gt; 를 롤백하는 경우</target>
        </trans-unit>
        <trans-unit id="45214cae2612ebffc27b8fdd7a3cf49ee7b2d607" translate="yes" xml:space="preserve">
          <source>In General...</source>
          <target state="translated">일반적으로 ...</target>
        </trans-unit>
        <trans-unit id="bb3aac5782cb0bbb27f75a8309492054edae5ba4" translate="yes" xml:space="preserve">
          <source>It doesn't leave random temporary branches cluttering your tree</source>
          <target state="translated">임의의 임시 가지가 나무를 혼란스럽게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fb312821e41e79eddb3acf1856ed936ed86cc23" translate="yes" xml:space="preserve">
          <source>Most previous answers are dangerously wrong!</source>
          <target state="translated">대부분의 이전 답변은 위험합니다!</target>
        </trans-unit>
        <trans-unit id="b5dd6415f61bdd41463af9d7a28d0cc83e851bc5" translate="yes" xml:space="preserve">
          <source>Move the most recent commit(s) to a new branch with Git</source>
          <target state="translated">Git을 사용하여 가장 최근의 커밋을 새로운 브랜치로 옮깁니다.</target>
        </trans-unit>
        <trans-unit id="fcb037bf01a5547a6fe279d69a24f2cc40eff948" translate="yes" xml:space="preserve">
          <source>Moving to a new branch</source>
          <target state="translated">새로운 지점으로 이동</target>
        </trans-unit>
        <trans-unit id="e517c2d1898a39a840275eb62257a2eb65ff2bb0" translate="yes" xml:space="preserve">
          <source>Moving to an existing branch</source>
          <target state="translated">기존 지점으로 이동</target>
        </trans-unit>
        <trans-unit id="cb27ea29bb4e133aeb88457377055c14669e73ea" translate="yes" xml:space="preserve">
          <source>Much simpler solution using git stash</source>
          <target state="translated">git stash를 사용하는 훨씬 간단한 솔루션</target>
        </trans-unit>
        <trans-unit id="2703bf326c4936a1698a52cb2adb33dd2c3e84f2" translate="yes" xml:space="preserve">
          <source>Note the hashes of (say 3) commits you want on &lt;code&gt;newbranch&lt;/code&gt;. Here I shall use:</source>
          <target state="translated">&lt;code&gt;newbranch&lt;/code&gt; 에서 원하는 (예를 들어 3) 커밋의 해시를 주목하십시오. 여기서는 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0120e6e8a7f3c7eeba72c03401b5bc9075b7ee5f" translate="yes" xml:space="preserve">
          <source>Now you can push your code</source>
          <target state="translated">이제 코드를 푸시 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="79254a5c1f0da46c3626c687b6c825c4976482aa" translate="yes" xml:space="preserve">
          <source>Now your job done. If you picked correct id and correct branch then you will success. So before do this be careful. else another problem can occur.</source>
          <target state="translated">이제 당신의 일이 끝났습니다. 올바른 ID와 올바른 지점을 선택하면 성공합니다. 따라서이 작업을 수행하기 전에주의하십시오. 다른 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bec58387fa9f82ca21a0aa4cda21ca1d8c4614f" translate="yes" xml:space="preserve">
          <source>OR (on Git 1.7.2+, use ranges)</source>
          <target state="translated">또는 (Git 1.7.2 이상에서 사용 범위)</target>
        </trans-unit>
        <trans-unit id="525be0773878e709982a03e49a0ec254a3a98f15" translate="yes" xml:space="preserve">
          <source>Since a branch is just a pointer, &lt;em&gt;master&lt;/em&gt; pointed to the last commit.  When you made &lt;em&gt;newBranch&lt;/em&gt;, you simply made a new pointer to the last commit.  Then using &lt;code&gt;git reset&lt;/code&gt; you moved the &lt;em&gt;master&lt;/em&gt; pointer back two commits.  But since you didn't move &lt;em&gt;newBranch&lt;/em&gt;, it still points to the commit it originally did.</source>
          <target state="translated">브랜치는 단지 포인터이기 때문에 &lt;em&gt;마스터&lt;/em&gt; 는 마지막 커밋을 가리 켰습니다. &lt;em&gt;newBranch&lt;/em&gt; 를 만들었을 때 마지막 커밋에 대한 새로운 포인터를 만들었습니다. 그런 다음 &lt;code&gt;git reset&lt;/code&gt; 을 사용하여 &lt;em&gt;마스터&lt;/em&gt; 포인터를 두 커밋으로 다시 이동했습니다. 그러나 &lt;em&gt;newBranch를&lt;/em&gt; 이동하지 않았 &lt;em&gt;으므로&lt;/em&gt; 여전히 원래 커밋을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="ecfc0ccc8476ea5a7bb72369f98104c559c1b775" translate="yes" xml:space="preserve">
          <source>So the reason that the following commands fail:</source>
          <target state="translated">따라서 다음 명령이 실패하는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f3738e8955364426af7ebf9eff26fbac099a3df" translate="yes" xml:space="preserve">
          <source>Some people also have other &lt;code&gt;upstreams&lt;/code&gt; rather than &lt;code&gt;origin&lt;/code&gt;, 
they should use appropriate &lt;code&gt;upstream&lt;/code&gt;</source>
          <target state="translated">일부 사람들은 &lt;code&gt;origin&lt;/code&gt; 아닌 다른 &lt;code&gt;upstreams&lt;/code&gt; 가지고 있기 때문에 적절한 &lt;code&gt;upstream&lt;/code&gt; 를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="570a9b839cac572f5258c68ccdad0078fe34fbd3" translate="yes" xml:space="preserve">
          <source>Someone else may have pulled those changes. If you are only rewriting your local master there's no impact when it's pushed upstream, but pushing a rewritten history to collaborators can cause headaches.</source>
          <target state="translated">다른 사람이 이러한 변경 사항을 가져 왔을 수 있습니다. 로컬 마스터 만 다시 작성하는 경우 업스트림으로 푸시해도 아무런 영향이 없지만 다시 작성된 기록을 공동 작업자에게 푸시하면 두통이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda3722e5c6923b0d0f716f3f96cdbe49d7a3d51" translate="yes" xml:space="preserve">
          <source>Stashes away all the working file changes, making the &lt;code&gt;master&lt;/code&gt; working tree exactly equal to the HEAD~3 state</source>
          <target state="translated">모든 작업 파일 변경 사항을 숨기고 &lt;code&gt;master&lt;/code&gt; 작업 트리를 HEAD ~ 3 상태와 정확히 동일하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f014c1b81acba76be319f6e06ad13c63babf8f9a" translate="yes" xml:space="preserve">
          <source>Step 1 - Note which commits from master you want on a &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">1 단계- &lt;code&gt;newbranch&lt;/code&gt; 원하는 마스터에서 커밋하는 메모</target>
        </trans-unit>
        <trans-unit id="77de30590bcc5eba20730cc3ce9edd805fdbea94" translate="yes" xml:space="preserve">
          <source>Step 2 - Put them on the &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">2 단계-새 가지에 놓으십시오</target>
        </trans-unit>
        <trans-unit id="1ef7799a2cc92eeb984080cee231f2b1eb4552b6" translate="yes" xml:space="preserve">
          <source>Suppose you branched off origin/master when it contained commits M1, M2, M3, then made three commits yourself:</source>
          <target state="translated">커밋 M1, M2, M3을 포함 할 때 출발지 / 마스터에서 분기 한 다음 세 개의 커밋을 스스로 수행했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="78075e3598751ef549eca00dd9fd47aad1286c7f" translate="yes" xml:space="preserve">
          <source>Switches to an existing branch &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">기존 지점 &lt;code&gt;newbranch&lt;/code&gt; 지점으로 전환</target>
        </trans-unit>
        <trans-unit id="ef8a54cacfcff4a878e33b870f157418f27ef92d" translate="yes" xml:space="preserve">
          <source>Technical explanation</source>
          <target state="translated">기술 설명</target>
        </trans-unit>
        <trans-unit id="8079b69aa99335d9f0a42877db1c34065d8e3e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--keep&lt;/code&gt; option preserves any uncommitted changes that you might have in unrelated files, or aborts if those changes would have to be overwritten -- similarly to what &lt;code&gt;git checkout&lt;/code&gt; does. If it aborts, &lt;code&gt;git stash&lt;/code&gt; your changes and retry, or use &lt;code&gt;--hard&lt;/code&gt; to lose the changes (even from files that didn't change between the commits!)</source>
          <target state="translated">&lt;code&gt;--keep&lt;/code&gt; 옵션은 관련없는 파일에서 발생할 수있는 커밋되지 않은 변경 사항을 유지하거나 &lt;code&gt;git checkout&lt;/code&gt; 과 마찬가지로 해당 변경 사항을 덮어 써야하는 경우 중단됩니다. 중단되면 &lt;code&gt;git stash&lt;/code&gt; 를 변경하고 다시 시도하거나 &lt;code&gt;--hard&lt;/code&gt; 를 사용하여 변경 사항을 잃어 버리 십시오 (커밋간에 변경되지 않은 파일에서도)!</target>
        </trans-unit>
        <trans-unit id="cb18d87d88bae1e920940bcec1aeb7ba8fe7699c" translate="yes" xml:space="preserve">
          <source>The OP stated the goal was to &quot;take master back to before those commits were made&quot; without losing changes and this solution does that.</source>
          <target state="translated">OP는 목표가 변경 사항을 잃지 않고 &quot;커밋하기 전에 마스터로 돌아가는 것&quot;이라고 목표를 밝혔으며이 솔루션은 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="62a1decf10bf015707d9b02585430c6f1322f604" translate="yes" xml:space="preserve">
          <source>The method exposed by sykora is the best option in this case. But sometimes is not the easiest and it's not a general method. For a general method use &lt;em&gt;git cherry-pick&lt;/em&gt;:</source>
          <target state="translated">이 경우 sykora에 의해 노출되는 방법이 가장 좋습니다. 그러나 때로는 가장 쉬운 방법이 아니며 일반적인 방법이 아닙니다. 일반적인 방법으로 &lt;em&gt;git cherry-pick을 사용하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2ac1f5122b2f0fe1bdf54429c44f6a7a914378e5" translate="yes" xml:space="preserve">
          <source>Then it cherry-picks those 3 commits back onto &lt;code&gt;newbranch&lt;/code&gt;. Since they're no longer referenced by a branch, it does that by using git's &lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt;: &lt;code&gt;HEAD@{2}&lt;/code&gt; is the commit that &lt;code&gt;HEAD&lt;/code&gt; used to refer to 2 operations ago, i.e. before we 1. checked out &lt;code&gt;newbranch&lt;/code&gt; and 2. used &lt;code&gt;git reset&lt;/code&gt; to discard the 3 commits.</source>
          <target state="translated">그런 다음 해당 3 개의 커밋을 &lt;code&gt;newbranch&lt;/code&gt; 로 다시 선택합니다. 그것들은 더 이상 브랜치에서 참조하지 않기 때문에 git의 &lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt; 를 사용하여 수행합니다. &lt;code&gt;HEAD@{2}&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 가 2 가지 작업을 참조하는 데 사용한 커밋입니다. 3 개의 커밋을 버리려면 &lt;code&gt;git reset&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b3be76dbc002a85c3ba3dbec4f3457261c1005e5" translate="yes" xml:space="preserve">
          <source>Then it forks off &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;newbranch&lt;/code&gt; 를 분기합니다.</target>
        </trans-unit>
        <trans-unit id="3a1dfeaf50dd4725361f8f91dee54a77fac1fb01" translate="yes" xml:space="preserve">
          <source>This behavior makes sense, and is generally the right thing to do when rebasing.</source>
          <target state="translated">이 동작은 의미가 있으며 일반적으로 리베이스 할 때해야 할 일입니다.</target>
        </trans-unit>
        <trans-unit id="a289627f428a449d73d58b27d954331c780d0bb1" translate="yes" xml:space="preserve">
          <source>This doesn't &quot;move&quot; them in the technical sense but it has the same effect:</source>
          <target state="translated">이것은 기술적 의미에서 &quot;이동&quot;하지 않지만 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf307f8136210a35158fbaf1577194155633a5a1" translate="yes" xml:space="preserve">
          <source>This method works by creating a new branch with the first command (&lt;code&gt;git branch newbranch&lt;/code&gt;) but not switching to it. Then we roll back the current branch (master) and switch to the new branch to continue working.</source>
          <target state="translated">이 방법은 첫 번째 명령 ( &lt;code&gt;git branch newbranch&lt;/code&gt; )으로 새 분기를 작성하지만 전환하지는 않습니다. 그런 다음 현재 지점 (마스터)을 롤백하고 새 지점으로 전환하여 작업을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="d0e9c38f82188fee931c4f0a82882b530fe6aade" translate="yes" xml:space="preserve">
          <source>To achieve what OP wants, its a 2-step process:</source>
          <target state="translated">OP가 원하는 것을 달성하기 위해 2 단계 프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="180ac7da64b802a0acc96a63a7f62f40267a005d" translate="yes" xml:space="preserve">
          <source>To be sure to land on the right spot in the history its easier to work with the hash of the commit</source>
          <target state="translated">커밋의 해시로 작업하기가 더 쉬운 역사의 올바른 지점에 도달하기 위해</target>
        </trans-unit>
        <trans-unit id="16aeef47080440b48dad1867a2809500799144e9" translate="yes" xml:space="preserve">
          <source>To do this without rewriting history (i.e. if you've already pushed the commits):</source>
          <target state="translated">기록을 다시 쓰지 않고이 작업을 수행하려면 (예 : 커밋을 이미 푸시 한 경우) :</target>
        </trans-unit>
        <trans-unit id="dfd4ca14b7084feb67d10a6a3b1a443b9cdff306" translate="yes" xml:space="preserve">
          <source>Undoes the last three commits (and their messages) to &lt;code&gt;master&lt;/code&gt;, yet leaves all working files intact</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 에 대한 마지막 3 개의 커밋 (및 해당 메시지)을 취소하지만 모든 작업 파일은 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="b1a9571ab5fcd1563a9ab94e00d9b31a597a8833" translate="yes" xml:space="preserve">
          <source>Update! Use up-arrow to scroll through your command buffer to reapply the prior commit with its commit message (thanks @ARK)</source>
          <target state="translated">최신 정보! 위쪽 화살표를 사용하여 명령 버퍼를 스크롤하여 이전 커밋을 커밋 메시지와 함께 다시 적용하십시오 (@ARK 덕분에)</target>
        </trans-unit>
        <trans-unit id="777ff4167ef757e40b01ee27147ff5be2a96d312" translate="yes" xml:space="preserve">
          <source>Using your local reflog, &lt;code&gt;git rebase&lt;/code&gt; can see that you forked from an earlier incarnation of the origin/master branch, and hence that the M2 and M3 commits are not really part of your topic branch. Hence it reasonably assumes that since M2 was removed from the upstream branch, you no longer want it in your topic branch either once the topic branch is rebased:</source>
          <target state="translated">로컬 reflog를 사용하여 &lt;code&gt;git rebase&lt;/code&gt; 는 원점 / 마스터 브랜치의 초기 화신에서 분기 된 것을 볼 수 있으므로 M2 및 M3 커밋은 실제로 토픽 브랜치의 일부가 아닙니다. 따라서 M2가 업스트림 브랜치에서 제거되었으므로 토픽 브랜치가 리베이스 된 후에는 더 이상 토픽 브랜치에서 원하지 않는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="22a1d6b1997c8096890ab17ef65190a74cf777f0" translate="yes" xml:space="preserve">
          <source>What this does, by line number</source>
          <target state="translated">이것이 행 번호로하는 일</target>
        </trans-unit>
        <trans-unit id="3937db1b011d2fbca8cb7989edb73e13f8dee01f" translate="yes" xml:space="preserve">
          <source>What this doesn't do</source>
          <target state="translated">이것이하지 않는 것</target>
        </trans-unit>
        <trans-unit id="32b70d40f89c8426b134e72c00bb22ea189a3222" translate="yes" xml:space="preserve">
          <source>When to use this?</source>
          <target state="translated">이것을 언제 사용합니까?</target>
        </trans-unit>
        <trans-unit id="2bc0f58c6ada69cc511b237a44108d2a2b976fea" translate="yes" xml:space="preserve">
          <source>Why would &lt;code&gt;git rebase&lt;/code&gt; discard the 3 commits after the first example? It's because &lt;code&gt;git rebase&lt;/code&gt; with no arguments enables the &lt;code&gt;--fork-point&lt;/code&gt; option by default, which uses the local reflog to try to be robust against the upstream branch being force-pushed.</source>
          <target state="translated">왜 &lt;code&gt;git rebase&lt;/code&gt; 가 첫 번째 예제 후에 3 개의 커밋을 버릴까요 ? &lt;code&gt;--fork-point&lt;/code&gt; 없는 &lt;code&gt;git rebase&lt;/code&gt; 는 기본적으로 --fork-point 옵션을 활성화합니다.이 옵션은 로컬 참조 로그 를 사용하여 강제 푸시되는 업스트림 브랜치에 견고합니다.</target>
        </trans-unit>
        <trans-unit id="04789008eacc93f3bbeb6a094ce1ec4c64a422a0" translate="yes" xml:space="preserve">
          <source>With two commands</source>
          <target state="translated">두 가지 명령으로</target>
        </trans-unit>
        <trans-unit id="05b565ff31b4dbc1668f9ed425e0349b85c4df5a" translate="yes" xml:space="preserve">
          <source>Yet another way to do this, using just 2 commands. Also keeps your current working tree intact.</source>
          <target state="translated">단 두 개의 명령을 사용하여이를 수행하는 또 다른 방법입니다. 또한 현재 작업 트리를 그대로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="0050df2a380504a6a85fa9dc4941906d833964a3" translate="yes" xml:space="preserve">
          <source>You can do this is just 3  simple step that i used.</source>
          <target state="translated">당신이 할 수있는 것은 내가 사용한 3 단계입니다.</target>
        </trans-unit>
        <trans-unit id="2e0a33cd78ba4958dc622fc4118ce7ec3482322f" translate="yes" xml:space="preserve">
          <source>You can now use &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; as you normally would. All new commits will be added to &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">이제 평상시처럼 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 을 사용할 수 있습니다. 모든 새로운 커밋이 &lt;code&gt;newbranch&lt;/code&gt; 에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b09980a485be5652befdb8e0e423606cd0857bdf" translate="yes" xml:space="preserve">
          <source>You don't care about the messages on the mistaken commits</source>
          <target state="translated">실수 한 커밋에 대한 메시지는 신경 쓰지 않습니다</target>
        </trans-unit>
        <trans-unit id="76f63380152e0b12d34f1f53c663119b94ac180b" translate="yes" xml:space="preserve">
          <source>You don't want complications like temporary/new branches, finding and copying commit hashes, and other headaches</source>
          <target state="translated">임시 / 새 브랜치, 커밋 해시 찾기 및 복사 및 기타 두통과 같은 합병증을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ddcf492d5268073f416e3cada6030e943e71240" translate="yes" xml:space="preserve">
          <source>You haven't pushed yet</source>
          <target state="translated">아직 밀지 않았습니다</target>
        </trans-unit>
        <trans-unit id="d7b0857d0c18b9ab571e5c305a90d96154e86fc6" translate="yes" xml:space="preserve">
          <source>You want this to be easy to memorize</source>
          <target state="translated">당신은 이것을 암기하기 쉽기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="75d5778d3600ba08394fe388f687f5156172c313" translate="yes" xml:space="preserve">
          <source>You want to go back to C, and move D and E to the new branch.  Here's what it looks like at first:</source>
          <target state="translated">C로 돌아가서 D와 E를 새 분기로 이동하려고합니다. 처음에는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d108fcb68849122d6885b5a131db74d96d3bf6d0" translate="yes" xml:space="preserve">
          <source>You want to keep file changes</source>
          <target state="translated">파일 변경 사항을 유지하려고합니다</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4663caa7b2f5e911bdfb4cf441b4b09dc0759c64" translate="yes" xml:space="preserve">
          <source>but then someone rewrites history by force-pushing origin/master to remove M2:</source>
          <target state="translated">그러나 누군가가 M2를 제거하기 위해 강제 푸시 원점 / 마스터로 기록을 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6c8f9a168afb7fafa88d80cae6a23dac31c56379" translate="yes" xml:space="preserve">
          <source>giving</source>
          <target state="translated">giving</target>
        </trans-unit>
        <trans-unit id="d314ed7563a1b8a0b56a2edc1b1e809d2a66500b" translate="yes" xml:space="preserve">
          <source>is because they leave the reflog in the wrong state. Git sees &lt;code&gt;newbranch&lt;/code&gt; as having forked off the upstream branch at a revision that includes the 3 commits, then the &lt;code&gt;reset --hard&lt;/code&gt; rewrites the upstream's history to remove the commits, and so next time you run &lt;code&gt;git rebase&lt;/code&gt; it discards them like any other commit that has been removed from the upstream.</source>
          <target state="translated">리플 로그를 잘못된 상태로두기 때문입니다. Git은 &lt;code&gt;newbranch&lt;/code&gt; 가 3 개의 커밋을 포함하는 개정판에서 업스트림 브랜치를 분기 한 것으로보고, &lt;code&gt;reset --hard&lt;/code&gt; 는 커밋을 제거하기 위해 업스트림의 히스토리를 다시 작성하므로 다음에 &lt;code&gt;git rebase&lt;/code&gt; 를 실행하면 다른 커밋처럼 버립니다. 업스트림에서 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="ffd583141089c5adc863ae42b4a86dd7477a4031" translate="yes" xml:space="preserve">
          <source>to this?</source>
          <target state="translated">이에?</target>
        </trans-unit>
        <trans-unit id="ad3f025daaa46c547e7ff3268c862cc219dcf84b" translate="yes" xml:space="preserve">
          <source>you can also provide some rang of commit id.</source>
          <target state="translated">커밋 ID를 제공 할 수도 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
