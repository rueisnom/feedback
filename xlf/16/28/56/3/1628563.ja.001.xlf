<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1628563">
    <body>
      <group id="1628563">
        <trans-unit id="6ca0548b1ae7d77cf8176a8562bef6c6ec1f4654" translate="yes" xml:space="preserve">
          <source>(if you prefer you can write &lt;code&gt;@{-1}&lt;/code&gt; - the previously checked out branch - instead of &lt;code&gt;oldbranch&lt;/code&gt;).</source>
          <target state="translated">（必要に応じて、 &lt;code&gt;oldbranch&lt;/code&gt; の代わりに、以前にチェックアウトしたブランチである &lt;code&gt;@{-1}&lt;/code&gt; 記述できます）。</target>
        </trans-unit>
        <trans-unit id="9f8435deadd1fe3bd0b7d1a92942e67a02ac6466" translate="yes" xml:space="preserve">
          <source>1) Create a new branch, which moves all your changes to new_branch.</source>
          <target state="translated">1)新しいブランチを作成し、すべての変更を new_branch に移動します。</target>
        </trans-unit>
        <trans-unit id="67a880d1f38aa8e151836c7841725f2f5ce6ef07" translate="yes" xml:space="preserve">
          <source>1) make new branch where you want to commit you recent update.</source>
          <target state="translated">1)最近のアップデートをコミットしたい場所に新しいブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="e03e86c3388b7cf5555eb916dbba2967506aaeec" translate="yes" xml:space="preserve">
          <source>2)  Find  Recent Commit Id for commit on new branch.</source>
          <target state="translated">2)新しいブランチのコミットの最近のコミットIDを探します。</target>
        </trans-unit>
        <trans-unit id="ca6b48cf4285ff6ee19a338900c7ea56c23bd692" translate="yes" xml:space="preserve">
          <source>2) Then go back to old branch.</source>
          <target state="translated">2)その後、旧枝に戻ります。</target>
        </trans-unit>
        <trans-unit id="1a5ca855c4b43689641d35143dbafebcc3c36cb6" translate="yes" xml:space="preserve">
          <source>3)  Copy that commit id  note that Most Recent commit list take place on top. so you can find your commit. you also find this via message.</source>
          <target state="translated">3)コミットIDをコピーして、一番上にある最新のコミットリストに注意してください。</target>
        </trans-unit>
        <trans-unit id="8879da991940a5e92a574b5dce3946ef8b03f6e3" translate="yes" xml:space="preserve">
          <source>3) Do git rebase</source>
          <target state="translated">3)git リベースを行う</target>
        </trans-unit>
        <trans-unit id="d4541ea89f937e9631ef09121301c9c25bafe06b" translate="yes" xml:space="preserve">
          <source>4) Then the opened editor contains last 3 commit information.</source>
          <target state="translated">4)開いたエディタには、最後の3つのコミット情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="364b0e5b207712eb15befa385fb7b8c9eb0a1ff1" translate="yes" xml:space="preserve">
          <source>5) Change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;drop&lt;/code&gt; in all those 3 commits. Then save and close the editor.</source>
          <target state="translated">5）これら3つのコミットすべてを &lt;code&gt;drop&lt;/code&gt; するように &lt;code&gt;pick&lt;/code&gt; を変更します 。 次に、エディターを保存して閉じます。</target>
        </trans-unit>
        <trans-unit id="8d83cc370dffdf424de5b7fe3e77dc0739de448d" translate="yes" xml:space="preserve">
          <source>6) Now last 3 commits are removed from current branch (&lt;code&gt;master&lt;/code&gt;). Now push the branch forcefully, with &lt;code&gt;+&lt;/code&gt; sign before branch name.</source>
          <target state="translated">6）最後の3つのコミットが現在のブランチ（ &lt;code&gt;master&lt;/code&gt; ）から削除されます。 ブランチ名の前に &lt;code&gt;+&lt;/code&gt; 記号を付けて、ブランチを強制的にプッシュします。</target>
        </trans-unit>
        <trans-unit id="481f1e51dbb9650f3dec4ebcbee5bde1fa9e1998" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning: the reflog is enabled by default, but if you've manually disabled it (e.g. by using a &quot;bare&quot; git repository), you won't be able to get the 3 commits back after running &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;警告：reflogはデフォルトで有効になっていますが、手動で無効にした場合（たとえば、「裸」のgitリポジトリを使用して）、 &lt;code&gt;git reset --keep HEAD~3&lt;/code&gt; 実行した後に3つのコミットを取得できなくなります--HEAD〜を維持してください〜 ３ 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fecb2dc113e6f448810dffb1f5193fa5652bcaa2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git cherry-pick&lt;/em&gt; applies those three commits to newbranch.</source>
          <target state="translated">&lt;em&gt;git cherry-pick&lt;/em&gt;はこれら3つのコミットをnewbranchに適用します。</target>
        </trans-unit>
        <trans-unit id="62c9092203459b0b2ebfe9d9dd2a6471c1dc910f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f225dd72b1ea2e11e4cc4f79ba9ce4e1e63b176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef...86d2aec&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f25233cdf3d6a4bf94c9763c22b443736bd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git cherry-pick d34bcef232f6c...&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="618e043fbabf5fb6ff301d8d6b97dd697c0e91af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git log&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f357915ce858ad1ed6fc9d6a133973f4b6bcd61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git push&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581e76256e26a6bb9eb3e8dde9619b387d8395e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do this if you pushed master's changes upstream&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;マスターの変更を上流にプッシュした場合は、これを行わないでください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c3b92d1806c6012b9c82785c86133828f8f9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead do this:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;代わりにこれを行います：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf1d482ca9e07ac50613f05ca0beacb0601807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It doesn't preserve the mistaken commit messages,&lt;/strong&gt; so you'll need to add a new commit message to this new commit</source>
          <target state="translated">&lt;strong&gt;誤ったコミットメッセージは保持されないため、&lt;/strong&gt;この新しいコミットに新しいコミットメッセージを追加する必要があります</target>
        </trans-unit>
        <trans-unit id="298a626f1e670a24eb99d1fb32033d364b917fc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use the first seven characters or
  the whole commit hash</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;最初の7文字またはコミットハッシュ全体を使用できます</target>
        </trans-unit>
        <trans-unit id="cb2a21cdd4aab0e9d2330b3c145c7c960afb328a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old version&lt;/strong&gt; - before I learned about &lt;code&gt;git branch -f&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;古いバージョン&lt;/strong&gt; &lt;code&gt;git branch -f&lt;/code&gt; について学ぶ前</target>
        </trans-unit>
        <trans-unit id="4a938097a5c19c110bf22c9137514e43948a3cab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; With Git version 2.0 and later, if you later &lt;code&gt;git rebase&lt;/code&gt; the new branch upon the original (&lt;code&gt;master&lt;/code&gt;) branch, you may need an explicit &lt;code&gt;--no-fork-point&lt;/code&gt; option during the rebase to avoid losing the commits you moved from the master branch.  Having &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; set makes this more likely.  See &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellor's answer&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; Gitバージョン2.0以降では、後で新しいブランチを元の（ &lt;code&gt;master&lt;/code&gt; ）ブランチに &lt;code&gt;git rebase&lt;/code&gt; する場合、リベース中に明示的な &lt;code&gt;--no-fork-point&lt;/code&gt; オプションが必要になる場合があります。マスターブランチ。 &lt;code&gt;branch.autosetuprebase always&lt;/code&gt; 設定すると、これが起こりやすくなります。 詳細については、 &lt;a href=&quot;https://stackoverflow.com/a/36463546/1256452&quot;&gt;John Mellorの回答&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2fa271f29257aa3264a3cd5f63a031ba49701cc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 1 ]&lt;/strong&gt; Rename &lt;code&gt;master&lt;/code&gt; branch to your &lt;code&gt;newbranch&lt;/code&gt; (assuming you are on &lt;code&gt;master&lt;/code&gt; branch):</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt; &lt;code&gt;master&lt;/code&gt; ブランチの名前を &lt;code&gt;newbranch&lt;/code&gt; ブランチに変更します（ マスターブランチにいると仮定します）：</target>
        </trans-unit>
        <trans-unit id="3e0a0ebd28accdae6ce3332752ece2864cfbf011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[ 2 ]&lt;/strong&gt; Create &lt;code&gt;master&lt;/code&gt; branch from the commit that you wish:</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;希望するコミットから &lt;code&gt;master&lt;/code&gt; ブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="08664a172af09c307beca0dc6e18e23b37792687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;create&lt;/strong&gt; a &lt;em&gt;new branch&lt;/em&gt; from the current one :&lt;code&gt;git branch new-branch-name&lt;/code&gt;</source>
          <target state="translated">現在の&lt;em&gt;ブランチ&lt;/em&gt;から&lt;em&gt;新しいブランチ&lt;/em&gt;を&lt;strong&gt;作成します&lt;/strong&gt; ： &lt;code&gt;git branch new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5abe106c34fb61d8ac5178b46edd8aa8e47234e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch -m master newbranch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;git branch -m master newbranch&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c7728f4e40b017c98351ed0201f96bbd435d95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git branch master B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;gitブランチマスターB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19f154caa171db7ec34910e2d77c14361d0cc90e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;push&lt;/strong&gt; your &lt;em&gt;new branch&lt;/em&gt;: &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;新しいブランチを&lt;/em&gt; &lt;strong&gt;プッシュ&lt;/strong&gt;する： &lt;code&gt;git push origin new-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d24ea4762b706e087ecf25c1abf71b090074e6f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revert&lt;/strong&gt; your &lt;em&gt;old(current) branch&lt;/em&gt; to the last pushed/stable state: &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;古い（現在の）ブランチ&lt;/em&gt;を最後にプッシュされた/安定した状態に&lt;strong&gt;戻し&lt;/strong&gt;ます： &lt;code&gt;git reset --hard origin/old-branch-name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="123bbeedc5451e39c60a89718d9fa034b768d3b3" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git branch newBranch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git branch newBranch&lt;/code&gt; 後：</target>
        </trans-unit>
        <trans-unit id="4e03f1b09ddfb9fdb0690ffafc858190ba16f537" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; 後：</target>
        </trans-unit>
        <trans-unit id="634bdd7acbc2bc8da73f2a0106b15811988287cd" translate="yes" xml:space="preserve">
          <source>An alternative that doesn't rely on the reflog is:</source>
          <target state="translated">リブログに頼らない代替案は</target>
        </trans-unit>
        <trans-unit id="4136e4007e2c8d131948d98078cb665d8a8d26f9" translate="yes" xml:space="preserve">
          <source>Another way to do this:</source>
          <target state="translated">もう一つの方法として</target>
        </trans-unit>
        <trans-unit id="12b70b8d93639000b2abfedcfa890a9fd5664604" translate="yes" xml:space="preserve">
          <source>Applies the stashed changes to your working directory and clears the stash</source>
          <target state="translated">隠した変更を作業ディレクトリに適用し、隠し場所をクリアします。</target>
        </trans-unit>
        <trans-unit id="b1a8c702af2789b621b2ff6dadbe4bd16d08b257" translate="yes" xml:space="preserve">
          <source>As the next time you run &lt;code&gt;git rebase&lt;/code&gt; (or &lt;code&gt;git pull --rebase&lt;/code&gt;) those 3 commits would be silently discarded from &lt;code&gt;newbranch&lt;/code&gt;! (see explanation below)</source>
          <target state="translated">次回 &lt;code&gt;git rebase&lt;/code&gt; （または &lt;code&gt;git pull --rebase&lt;/code&gt; ）を実行すると、これらの3つのコミットは &lt;code&gt;newbranch&lt;/code&gt; から自動的に破棄されます 。 （以下の説明を参照）</target>
        </trans-unit>
        <trans-unit id="be54a1922487f0812b743e1122c1ed8ffe2b82c1" translate="yes" xml:space="preserve">
          <source>Being able to &lt;code&gt;push&lt;/code&gt; to &lt;code&gt;.&lt;/code&gt; is a nice trick to know.</source>
          <target state="translated">に &lt;code&gt;push&lt;/code&gt; できること &lt;code&gt;.&lt;/code&gt; 知っておくと便利です。</target>
        </trans-unit>
        <trans-unit id="da835c0dac3fd92f1e22cae2225d07b3903d70b2" translate="yes" xml:space="preserve">
          <source>Both branches can then be pushed without force!</source>
          <target state="translated">そうすれば、両枝は力を入れずに押すことができます</target>
        </trans-unit>
        <trans-unit id="95821c35a792c616eedf8f2cd2d313d1ec24a74b" translate="yes" xml:space="preserve">
          <source>But do make sure how many commits to go back. Alternatively, instead of &lt;code&gt;HEAD~3&lt;/code&gt;, you can simply provide the hash of the commit (or the reference like &lt;code&gt;origin/master&lt;/code&gt;) you want to revert back to, e.g:</source>
          <target state="translated">ただし、戻すコミットの数を確認してください。 あるいは、 &lt;code&gt;HEAD~3&lt;/code&gt; 代わりに、元に戻したいコミットのハッシュ（または &lt;code&gt;origin/master&lt;/code&gt; のような参照）を提供することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="872296281e7b54043777ea01b0a4ce1a26fd3bae" translate="yes" xml:space="preserve">
          <source>But in this particular case we want those 3 commits to be considered as part of the topic branch. To achieve that, we need to fork off the upstream at the earlier revision that doesn't include the 3 commits. That's what my suggested solutions do, hence they both leave the reflog in the correct state.</source>
          <target state="translated">しかし、この特定のケースでは、これらの 3 つのコミットをトピックブランチの一部とみなしたいのです。そのためには、3 つのコミットを含まない以前のリビジョンのアップストリームをフォークオフする必要があります。これが私の提案する解決策です。</target>
        </trans-unit>
        <trans-unit id="45d164dad0e050f5f56b5e4723f55131be5c697d" translate="yes" xml:space="preserve">
          <source>C commit: &lt;code&gt;9aa1233&lt;/code&gt;</source>
          <target state="translated">Cコミット： &lt;code&gt;9aa1233&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d816936e6f324d26f6ab09f218554c1eecfa223" translate="yes" xml:space="preserve">
          <source>D commit: &lt;code&gt;453ac3d&lt;/code&gt;</source>
          <target state="translated">Dコミット： &lt;code&gt;453ac3d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae3448d5927b150f67eddc7092cb244b9ff78e90" translate="yes" xml:space="preserve">
          <source>Do NOT do this:</source>
          <target state="translated">絶対にやってはいけないことです。</target>
        </trans-unit>
        <trans-unit id="74a68f79450dfaeabfe28bb86d277f6c85b80d3b" translate="yes" xml:space="preserve">
          <source>E commit: &lt;code&gt;612ecb3&lt;/code&gt;</source>
          <target state="translated">Eコミット： &lt;code&gt;612ecb3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ea36ce8d4940505e9a2c8fea5db868cd8b3d440" translate="yes" xml:space="preserve">
          <source>Execute</source>
          <target state="translated">Execute</target>
        </trans-unit>
        <trans-unit id="41e182bcf630ddfdb2e208e80da988684106a169" translate="yes" xml:space="preserve">
          <source>First it discards the 3 most recent commits (&lt;code&gt;--keep&lt;/code&gt; is like &lt;code&gt;--hard&lt;/code&gt;, but safer, as fails rather than throw away uncommitted changes).</source>
          <target state="translated">最初に、最新の3つのコミットを破棄します（ &lt;code&gt;--keep&lt;/code&gt; は &lt;code&gt;--hard&lt;/code&gt; に似ていますが、コミットされていない変更を破棄するよりも失敗するため、より安全です）。</target>
        </trans-unit>
        <trans-unit id="8747b9e113bf2cfb1c795971c93836c1bcf8efee" translate="yes" xml:space="preserve">
          <source>For more details, see the definition of &lt;code&gt;--fork-point&lt;/code&gt; in the &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt; and &lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt; docs.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;git rebase&lt;/a&gt;および&lt;a href=&quot;https://git-scm.com/docs/git-merge-base&quot;&gt;git merge-base&lt;/a&gt;ドキュメントの &lt;code&gt;--fork-point&lt;/code&gt; の定義を参照してください。</target>
        </trans-unit>
        <trans-unit id="e4cf258bb8c46ad329c853a1c1c69dd2a1158855" translate="yes" xml:space="preserve">
          <source>For those wondering why it works (as I was at first):</source>
          <target state="translated">なぜ効果があるのか疑問に思っている方へ(最初は私もそうでしたが)。</target>
        </trans-unit>
        <trans-unit id="48d8c627be3c12fac8a0a9ddb9ceaa5e126cf358" translate="yes" xml:space="preserve">
          <source>Goals</source>
          <target state="translated">Goals</target>
        </trans-unit>
        <trans-unit id="8b39b9dc5abd99e7d1c85da79f7f139aa247fe44" translate="yes" xml:space="preserve">
          <source>Had just this situation:</source>
          <target state="translated">ちょうどこのような状況になっていました。</target>
        </trans-unit>
        <trans-unit id="c7bba187055e411f54827bed15bc8e5745ca59e5" translate="yes" xml:space="preserve">
          <source>Here's a far simpler solution for commits to the wrong branch. Starting on branch &lt;code&gt;master&lt;/code&gt; that has three mistaken commits:</source>
          <target state="translated">これは、間違ったブランチへのコミットのためのはるかに簡単な解決策です。 3つの誤ったコミットがあるブランチ &lt;code&gt;master&lt;/code&gt; から開始します。</target>
        </trans-unit>
        <trans-unit id="1de38d1d55e635d53f8816d378d4a458f286f03d" translate="yes" xml:space="preserve">
          <source>How can I go from this</source>
          <target state="translated">ここから先はどうすればいいのか</target>
        </trans-unit>
        <trans-unit id="13c47b488a3cc7d11dee9bd8d436360a945b32d2" translate="yes" xml:space="preserve">
          <source>I do this at least once a week when I accidentally make new commits to &lt;code&gt;master&lt;/code&gt; instead of &lt;code&gt;develop&lt;/code&gt;. Usually I have only one commit to rollback in which case using &lt;code&gt;git reset HEAD^&lt;/code&gt; on line 1 is a simpler way to rollback just one commit.</source>
          <target state="translated">これは、少なくとも週に1回、 &lt;code&gt;develop&lt;/code&gt; なく誤って &lt;code&gt;master&lt;/code&gt; に新しいコミットを行ったときに行います。 通常、ロールバックするコミットは1つだけです。その場合、1行目で &lt;code&gt;git reset HEAD^&lt;/code&gt; を使用すると、1つのコミットだけをロールバックする最も簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="e84261e078202fee3b7e1e26bd6f8e2ae8860322" translate="yes" xml:space="preserve">
          <source>I expected that commit I would be the HEAD, but commit L is it now...</source>
          <target state="translated">コミット I が HEAD になると思っていたのですが、コミット L になってしまいました・・・。</target>
        </trans-unit>
        <trans-unit id="b84b3d703ca68884c4afef2a54d5682f9ac70042" translate="yes" xml:space="preserve">
          <source>I performed:</source>
          <target state="translated">演技しました。</target>
        </trans-unit>
        <trans-unit id="108997d98177d91547a86ccb3b5ea4d361ecb4f7" translate="yes" xml:space="preserve">
          <source>I'd like to move the last several commits I've committed to master to a new branch and take master back to before those commits were made. Unfortunately, my Git-fu is not strong enough yet, any help?</source>
          <target state="translated">master にコミットした最後のいくつかのコミットを新しいブランチに移動して、master をそのコミットが行われる前の状態に戻したいと思います。残念ながら、私のGit-fuはまだ十分に強力ではありません。</target>
        </trans-unit>
        <trans-unit id="55591bccd6c04d7d962a2f9c0483a3c06b6f73cd" translate="yes" xml:space="preserve">
          <source>I.e. How can I go from this</source>
          <target state="translated">つまり、この状態からどのようにして</target>
        </trans-unit>
        <trans-unit id="bf2e448a40f1dc65cb033a53947f9de8ce03aa54" translate="yes" xml:space="preserve">
          <source>If you just need to move all your &lt;strong&gt;unpushed&lt;/strong&gt; commits to a &lt;em&gt;new branch&lt;/em&gt;,
then you just need to,</source>
          <target state="translated">&lt;strong&gt;プッシュされ&lt;/strong&gt;ていないすべてのコミットを&lt;em&gt;新しいブランチ&lt;/em&gt;に移動する必要があるだけの場合は、</target>
        </trans-unit>
        <trans-unit id="88e00813d5f261f8ce1b530d3691b5a28b42c071" translate="yes" xml:space="preserve">
          <source>If you want to move your commits to an &lt;strong&gt;existing branch&lt;/strong&gt;, it will look like this:</source>
          <target state="translated">コミットを&lt;strong&gt;既存のブランチ&lt;/strong&gt;に移動する場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f035e6176ae12939244c0bc97fd3cb810b00f464" translate="yes" xml:space="preserve">
          <source>If your primary purpose is to roll back &lt;code&gt;master&lt;/code&gt;</source>
          <target state="translated">主な目的が &lt;code&gt;master&lt;/code&gt; ロールバックである場合</target>
        </trans-unit>
        <trans-unit id="45214cae2612ebffc27b8fdd7a3cf49ee7b2d607" translate="yes" xml:space="preserve">
          <source>In General...</source>
          <target state="translated">一般的には...</target>
        </trans-unit>
        <trans-unit id="bb3aac5782cb0bbb27f75a8309492054edae5ba4" translate="yes" xml:space="preserve">
          <source>It doesn't leave random temporary branches cluttering your tree</source>
          <target state="translated">それはあなたの木を乱雑にしているランダムな一時的な枝を残しません。</target>
        </trans-unit>
        <trans-unit id="3fb312821e41e79eddb3acf1856ed936ed86cc23" translate="yes" xml:space="preserve">
          <source>Most previous answers are dangerously wrong!</source>
          <target state="translated">過去の回答のほとんどが危険なほど間違っています</target>
        </trans-unit>
        <trans-unit id="b5dd6415f61bdd41463af9d7a28d0cc83e851bc5" translate="yes" xml:space="preserve">
          <source>Move the most recent commit(s) to a new branch with Git</source>
          <target state="translated">Git で最新のコミットを新しいブランチに移動します。</target>
        </trans-unit>
        <trans-unit id="fcb037bf01a5547a6fe279d69a24f2cc40eff948" translate="yes" xml:space="preserve">
          <source>Moving to a new branch</source>
          <target state="translated">新しい支店への移転</target>
        </trans-unit>
        <trans-unit id="e517c2d1898a39a840275eb62257a2eb65ff2bb0" translate="yes" xml:space="preserve">
          <source>Moving to an existing branch</source>
          <target state="translated">既存の支店への移動</target>
        </trans-unit>
        <trans-unit id="cb27ea29bb4e133aeb88457377055c14669e73ea" translate="yes" xml:space="preserve">
          <source>Much simpler solution using git stash</source>
          <target state="translated">git stash を使うよりもずっとシンプルなソリューションです。</target>
        </trans-unit>
        <trans-unit id="2703bf326c4936a1698a52cb2adb33dd2c3e84f2" translate="yes" xml:space="preserve">
          <source>Note the hashes of (say 3) commits you want on &lt;code&gt;newbranch&lt;/code&gt;. Here I shall use:</source>
          <target state="translated">&lt;code&gt;newbranch&lt;/code&gt; で必要な（たとえば3つの）​​コミットのハッシュに注意してください。 ここで私は使用します：</target>
        </trans-unit>
        <trans-unit id="0120e6e8a7f3c7eeba72c03401b5bc9075b7ee5f" translate="yes" xml:space="preserve">
          <source>Now you can push your code</source>
          <target state="translated">これで、あなたのコードをプッシュすることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="79254a5c1f0da46c3626c687b6c825c4976482aa" translate="yes" xml:space="preserve">
          <source>Now your job done. If you picked correct id and correct branch then you will success. So before do this be careful. else another problem can occur.</source>
          <target state="translated">これであなたの仕事は完了です。正しいidと正しいブランチを選択した場合は成功です。だから、これを行う前に注意してください。</target>
        </trans-unit>
        <trans-unit id="3bec58387fa9f82ca21a0aa4cda21ca1d8c4614f" translate="yes" xml:space="preserve">
          <source>OR (on Git 1.7.2+, use ranges)</source>
          <target state="translated">OR (Git 1.7.2 以降では ranges を使用)</target>
        </trans-unit>
        <trans-unit id="525be0773878e709982a03e49a0ec254a3a98f15" translate="yes" xml:space="preserve">
          <source>Since a branch is just a pointer, &lt;em&gt;master&lt;/em&gt; pointed to the last commit.  When you made &lt;em&gt;newBranch&lt;/em&gt;, you simply made a new pointer to the last commit.  Then using &lt;code&gt;git reset&lt;/code&gt; you moved the &lt;em&gt;master&lt;/em&gt; pointer back two commits.  But since you didn't move &lt;em&gt;newBranch&lt;/em&gt;, it still points to the commit it originally did.</source>
          <target state="translated">ブランチは単なるポインタなので、 &lt;em&gt;マスター&lt;/em&gt;は最後のコミットをポイントしました。 &lt;em&gt;newBranch&lt;/em&gt;を作成したときは、最後のコミットへの新しいポインタを作成しただけです。 次に、 &lt;code&gt;git reset&lt;/code&gt; を使用して、 &lt;em&gt;マスター&lt;/em&gt;ポインターを2つのコミットに戻しました。 しかし、 &lt;em&gt;newBranchを&lt;/em&gt;移動しなかった&lt;em&gt;ので&lt;/em&gt; 、それは最初に行ったコミットをまだ指し示しています。</target>
        </trans-unit>
        <trans-unit id="ecfc0ccc8476ea5a7bb72369f98104c559c1b775" translate="yes" xml:space="preserve">
          <source>So the reason that the following commands fail:</source>
          <target state="translated">ということで、以下のコマンドが失敗する理由です。</target>
        </trans-unit>
        <trans-unit id="4f3738e8955364426af7ebf9eff26fbac099a3df" translate="yes" xml:space="preserve">
          <source>Some people also have other &lt;code&gt;upstreams&lt;/code&gt; rather than &lt;code&gt;origin&lt;/code&gt;, 
they should use appropriate &lt;code&gt;upstream&lt;/code&gt;</source>
          <target state="translated">一部の人々はまた、 &lt;code&gt;origin&lt;/code&gt; ではなく他の &lt;code&gt;upstreams&lt;/code&gt; 持っています、彼らは適切な &lt;code&gt;upstream&lt;/code&gt; を使うべきです</target>
        </trans-unit>
        <trans-unit id="570a9b839cac572f5258c68ccdad0078fe34fbd3" translate="yes" xml:space="preserve">
          <source>Someone else may have pulled those changes. If you are only rewriting your local master there's no impact when it's pushed upstream, but pushing a rewritten history to collaborators can cause headaches.</source>
          <target state="translated">他の誰かがその変更を引っ張ってきた可能性があります。ローカルマスターを書き換えているだけなら上流にプッシュされても影響はありませんが、書き換えた履歴を共同作業者にプッシュすると頭痛の種になります。</target>
        </trans-unit>
        <trans-unit id="cda3722e5c6923b0d0f716f3f96cdbe49d7a3d51" translate="yes" xml:space="preserve">
          <source>Stashes away all the working file changes, making the &lt;code&gt;master&lt;/code&gt; working tree exactly equal to the HEAD~3 state</source>
          <target state="translated">すべての作業ファイルの変更を隠し、 &lt;code&gt;master&lt;/code&gt; 作業ツリーをHEAD〜3状態と完全に一致させます</target>
        </trans-unit>
        <trans-unit id="f014c1b81acba76be319f6e06ad13c63babf8f9a" translate="yes" xml:space="preserve">
          <source>Step 1 - Note which commits from master you want on a &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">ステップ1- &lt;code&gt;newbranch&lt;/code&gt; マスターからどのコミットが必要かをメモします</target>
        </trans-unit>
        <trans-unit id="77de30590bcc5eba20730cc3ce9edd805fdbea94" translate="yes" xml:space="preserve">
          <source>Step 2 - Put them on the &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">ステップ2- &lt;code&gt;newbranch&lt;/code&gt; 置く</target>
        </trans-unit>
        <trans-unit id="1ef7799a2cc92eeb984080cee231f2b1eb4552b6" translate="yes" xml:space="preserve">
          <source>Suppose you branched off origin/master when it contained commits M1, M2, M3, then made three commits yourself:</source>
          <target state="translated">originmaster に M1,M2,M3 のコミットが含まれているときに originmaster を分岐させ、自分で 3 つのコミットを行ったとします。</target>
        </trans-unit>
        <trans-unit id="78075e3598751ef549eca00dd9fd47aad1286c7f" translate="yes" xml:space="preserve">
          <source>Switches to an existing branch &lt;code&gt;newbranch&lt;/code&gt;</source>
          <target state="translated">既存のブランチ &lt;code&gt;newbranch&lt;/code&gt; に切り替えます</target>
        </trans-unit>
        <trans-unit id="ef8a54cacfcff4a878e33b870f157418f27ef92d" translate="yes" xml:space="preserve">
          <source>Technical explanation</source>
          <target state="translated">技術的な説明</target>
        </trans-unit>
        <trans-unit id="8079b69aa99335d9f0a42877db1c34065d8e3e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--keep&lt;/code&gt; option preserves any uncommitted changes that you might have in unrelated files, or aborts if those changes would have to be overwritten -- similarly to what &lt;code&gt;git checkout&lt;/code&gt; does. If it aborts, &lt;code&gt;git stash&lt;/code&gt; your changes and retry, or use &lt;code&gt;--hard&lt;/code&gt; to lose the changes (even from files that didn't change between the commits!)</source>
          <target state="translated">&lt;code&gt;--keep&lt;/code&gt; オプションは、関係のないファイルにある可能性のあるコミットされていない変更を保持するか、それらの変更を上書きする必要がある場合は &lt;code&gt;git checkout&lt;/code&gt; と同様に中止します。 中止した場合は、 &lt;code&gt;git stash&lt;/code&gt; 変更を隠して再試行するか、-- &lt;code&gt;--hard&lt;/code&gt; を使用して変更を失います（コミット間で変更されなかったファイルからでも！）</target>
        </trans-unit>
        <trans-unit id="cb18d87d88bae1e920940bcec1aeb7ba8fe7699c" translate="yes" xml:space="preserve">
          <source>The OP stated the goal was to &quot;take master back to before those commits were made&quot; without losing changes and this solution does that.</source>
          <target state="translated">OPは、変更を失うことなく「マスターをコミット前の状態に戻す」ことを目標としていると述べていますが、このソリューションはそれを実現しています。</target>
        </trans-unit>
        <trans-unit id="62a1decf10bf015707d9b02585430c6f1322f604" translate="yes" xml:space="preserve">
          <source>The method exposed by sykora is the best option in this case. But sometimes is not the easiest and it's not a general method. For a general method use &lt;em&gt;git cherry-pick&lt;/em&gt;:</source>
          <target state="translated">この場合、sykoraによって公開されるメソッドが最良のオプションです。 しかし、これは最も簡単な方法ではなく、一般的な方法ではありません。 一般的な方法では、 &lt;em&gt;git cherry-pickを&lt;/em&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="2ac1f5122b2f0fe1bdf54429c44f6a7a914378e5" translate="yes" xml:space="preserve">
          <source>Then it cherry-picks those 3 commits back onto &lt;code&gt;newbranch&lt;/code&gt;. Since they're no longer referenced by a branch, it does that by using git's &lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt;: &lt;code&gt;HEAD@{2}&lt;/code&gt; is the commit that &lt;code&gt;HEAD&lt;/code&gt; used to refer to 2 operations ago, i.e. before we 1. checked out &lt;code&gt;newbranch&lt;/code&gt; and 2. used &lt;code&gt;git reset&lt;/code&gt; to discard the 3 commits.</source>
          <target state="translated">次に、それらの3つのコミットを &lt;code&gt;newbranch&lt;/code&gt; にチェリーピックします 。 それらはブランチによって参照されなくなったので、gitの&lt;a href=&quot;http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html&quot;&gt;reflog&lt;/a&gt;を使用してそれを行います。HEAD &lt;code&gt;HEAD@{2}&lt;/code&gt; は、 &lt;code&gt;HEAD&lt;/code&gt; が2つの操作を参照するために使用したコミットです。 &lt;code&gt;git reset&lt;/code&gt; して3つのコミットを破棄します。</target>
        </trans-unit>
        <trans-unit id="b3be76dbc002a85c3ba3dbec4f3457261c1005e5" translate="yes" xml:space="preserve">
          <source>Then it forks off &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;newbranch&lt;/code&gt; を分岐します 。</target>
        </trans-unit>
        <trans-unit id="3a1dfeaf50dd4725361f8f91dee54a77fac1fb01" translate="yes" xml:space="preserve">
          <source>This behavior makes sense, and is generally the right thing to do when rebasing.</source>
          <target state="translated">この動作は理にかなっており、一般的にはリベース時に行うのが正解です。</target>
        </trans-unit>
        <trans-unit id="a289627f428a449d73d58b27d954331c780d0bb1" translate="yes" xml:space="preserve">
          <source>This doesn't &quot;move&quot; them in the technical sense but it has the same effect:</source>
          <target state="translated">これでは技術的な意味で「動かす」ことはできませんが、同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="cf307f8136210a35158fbaf1577194155633a5a1" translate="yes" xml:space="preserve">
          <source>This method works by creating a new branch with the first command (&lt;code&gt;git branch newbranch&lt;/code&gt;) but not switching to it. Then we roll back the current branch (master) and switch to the new branch to continue working.</source>
          <target state="translated">この方法は、最初のコマンド（ &lt;code&gt;git branch newbranch&lt;/code&gt; ）で新しいブランチを作成することで機能しますが、それには切り替えません。 次に、現在のブランチ（マスター）をロールバックし、新しいブランチに切り替えて作業を続けます。</target>
        </trans-unit>
        <trans-unit id="d0e9c38f82188fee931c4f0a82882b530fe6aade" translate="yes" xml:space="preserve">
          <source>To achieve what OP wants, its a 2-step process:</source>
          <target state="translated">OPが欲しいものを実現するためには、2段階のプロセスが必要です。</target>
        </trans-unit>
        <trans-unit id="180ac7da64b802a0acc96a63a7f62f40267a005d" translate="yes" xml:space="preserve">
          <source>To be sure to land on the right spot in the history its easier to work with the hash of the commit</source>
          <target state="translated">コミットのハッシュを使って作業する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="16aeef47080440b48dad1867a2809500799144e9" translate="yes" xml:space="preserve">
          <source>To do this without rewriting history (i.e. if you've already pushed the commits):</source>
          <target state="translated">履歴を書き換えずにこれを行うには(つまり、すでにコミットをプッシュしている場合)。</target>
        </trans-unit>
        <trans-unit id="dfd4ca14b7084feb67d10a6a3b1a443b9cdff306" translate="yes" xml:space="preserve">
          <source>Undoes the last three commits (and their messages) to &lt;code&gt;master&lt;/code&gt;, yet leaves all working files intact</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; への最後の3つのコミット（およびそのメッセージ）を元に戻しますが、すべての作業ファイルはそのまま残します</target>
        </trans-unit>
        <trans-unit id="b1a9571ab5fcd1563a9ab94e00d9b31a597a8833" translate="yes" xml:space="preserve">
          <source>Update! Use up-arrow to scroll through your command buffer to reapply the prior commit with its commit message (thanks @ARK)</source>
          <target state="translated">更新しました。上矢印を使ってコマンドバッファをスクロールして、コミットメッセージと一緒に前のコミットを再適用する (ありがとう @ARK)</target>
        </trans-unit>
        <trans-unit id="777ff4167ef757e40b01ee27147ff5be2a96d312" translate="yes" xml:space="preserve">
          <source>Using your local reflog, &lt;code&gt;git rebase&lt;/code&gt; can see that you forked from an earlier incarnation of the origin/master branch, and hence that the M2 and M3 commits are not really part of your topic branch. Hence it reasonably assumes that since M2 was removed from the upstream branch, you no longer want it in your topic branch either once the topic branch is rebased:</source>
          <target state="translated">ローカルのreflogを使用すると、 &lt;code&gt;git rebase&lt;/code&gt; はorigin / masterブランチの以前のインカネーションから分岐したこと、したがってM2およびM3コミットは実際にはトピックブランチの一部ではないことを確認できます。 したがって、M2は上流のブランチから削除されたため、トピックブランチがリベースされると、トピックブランチでM2が不要になると合理的に想定しています。</target>
        </trans-unit>
        <trans-unit id="22a1d6b1997c8096890ab17ef65190a74cf777f0" translate="yes" xml:space="preserve">
          <source>What this does, by line number</source>
          <target state="translated">これが何をするかというと、行番号別に</target>
        </trans-unit>
        <trans-unit id="3937db1b011d2fbca8cb7989edb73e13f8dee01f" translate="yes" xml:space="preserve">
          <source>What this doesn't do</source>
          <target state="translated">これではできないこと</target>
        </trans-unit>
        <trans-unit id="32b70d40f89c8426b134e72c00bb22ea189a3222" translate="yes" xml:space="preserve">
          <source>When to use this?</source>
          <target state="translated">どんな時に使うの?</target>
        </trans-unit>
        <trans-unit id="2bc0f58c6ada69cc511b237a44108d2a2b976fea" translate="yes" xml:space="preserve">
          <source>Why would &lt;code&gt;git rebase&lt;/code&gt; discard the 3 commits after the first example? It's because &lt;code&gt;git rebase&lt;/code&gt; with no arguments enables the &lt;code&gt;--fork-point&lt;/code&gt; option by default, which uses the local reflog to try to be robust against the upstream branch being force-pushed.</source>
          <target state="translated">最初の例の後で &lt;code&gt;git rebase&lt;/code&gt; が3つのコミットを破棄するのはなぜですか？ これは、引数なしの &lt;code&gt;git rebase&lt;/code&gt; がデフォルトで &lt;code&gt;--fork-point&lt;/code&gt; オプションを有効にするためです。このオプションでは、ローカルのreflogを使用して、強制的にプッシュされる上流ブランチに対してロバストになるように試みます。</target>
        </trans-unit>
        <trans-unit id="04789008eacc93f3bbeb6a094ce1ec4c64a422a0" translate="yes" xml:space="preserve">
          <source>With two commands</source>
          <target state="translated">2つのコマンドで</target>
        </trans-unit>
        <trans-unit id="05b565ff31b4dbc1668f9ed425e0349b85c4df5a" translate="yes" xml:space="preserve">
          <source>Yet another way to do this, using just 2 commands. Also keeps your current working tree intact.</source>
          <target state="translated">2 つのコマンドを使用した別の方法もあります。また、現在の作業ツリーをそのままにしておくこともできます。</target>
        </trans-unit>
        <trans-unit id="0050df2a380504a6a85fa9dc4941906d833964a3" translate="yes" xml:space="preserve">
          <source>You can do this is just 3  simple step that i used.</source>
          <target state="translated">あなたはこれを行うことができますちょうど私が使用した3つの簡単なステップです。</target>
        </trans-unit>
        <trans-unit id="2e0a33cd78ba4958dc622fc4118ce7ec3482322f" translate="yes" xml:space="preserve">
          <source>You can now use &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; as you normally would. All new commits will be added to &lt;code&gt;newbranch&lt;/code&gt;.</source>
          <target state="translated">これで、通常どおりに &lt;code&gt;git add&lt;/code&gt; および &lt;code&gt;git commit&lt;/code&gt; を使用できます。 新しいコミットはすべて &lt;code&gt;newbranch&lt;/code&gt; に追加されます 。</target>
        </trans-unit>
        <trans-unit id="b09980a485be5652befdb8e0e423606cd0857bdf" translate="yes" xml:space="preserve">
          <source>You don't care about the messages on the mistaken commits</source>
          <target state="translated">勘違いコミュのメッセージを気にしない</target>
        </trans-unit>
        <trans-unit id="76f63380152e0b12d34f1f53c663119b94ac180b" translate="yes" xml:space="preserve">
          <source>You don't want complications like temporary/new branches, finding and copying commit hashes, and other headaches</source>
          <target state="translated">一時的に新しいブランチを作成したり、コミットハッシュを見つけてコピーしたり、その他の頭痛の種になるような複雑な作業は避けたいものです。</target>
        </trans-unit>
        <trans-unit id="0ddcf492d5268073f416e3cada6030e943e71240" translate="yes" xml:space="preserve">
          <source>You haven't pushed yet</source>
          <target state="translated">まだ押してないの?</target>
        </trans-unit>
        <trans-unit id="d7b0857d0c18b9ab571e5c305a90d96154e86fc6" translate="yes" xml:space="preserve">
          <source>You want this to be easy to memorize</source>
          <target state="translated">これを簡単に覚えたいのか</target>
        </trans-unit>
        <trans-unit id="75d5778d3600ba08394fe388f687f5156172c313" translate="yes" xml:space="preserve">
          <source>You want to go back to C, and move D and E to the new branch.  Here's what it looks like at first:</source>
          <target state="translated">Cに戻って、DとEを新しい枝に移動させたいのですね。最初はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="d108fcb68849122d6885b5a131db74d96d3bf6d0" translate="yes" xml:space="preserve">
          <source>You want to keep file changes</source>
          <target state="translated">ファイルの変更を保存したい場合</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4663caa7b2f5e911bdfb4cf441b4b09dc0759c64" translate="yes" xml:space="preserve">
          <source>but then someone rewrites history by force-pushing origin/master to remove M2:</source>
          <target state="translated">でも、誰かがオリジンマスターに無理やりM2を削除させて歴史を書き換えたんだよね。</target>
        </trans-unit>
        <trans-unit id="6c8f9a168afb7fafa88d80cae6a23dac31c56379" translate="yes" xml:space="preserve">
          <source>giving</source>
          <target state="translated">giving</target>
        </trans-unit>
        <trans-unit id="d314ed7563a1b8a0b56a2edc1b1e809d2a66500b" translate="yes" xml:space="preserve">
          <source>is because they leave the reflog in the wrong state. Git sees &lt;code&gt;newbranch&lt;/code&gt; as having forked off the upstream branch at a revision that includes the 3 commits, then the &lt;code&gt;reset --hard&lt;/code&gt; rewrites the upstream's history to remove the commits, and so next time you run &lt;code&gt;git rebase&lt;/code&gt; it discards them like any other commit that has been removed from the upstream.</source>
          <target state="translated">これは、reflogを間違った状態のままにするためです。 Gitは、3つのコミットを含むリビジョンでアップストリームブランチを分岐したものとして &lt;code&gt;newbranch&lt;/code&gt; を認識し、次に &lt;code&gt;reset --hard&lt;/code&gt; はアップストリームの履歴を書き直してコミットを削除します。そのため、次に &lt;code&gt;git rebase&lt;/code&gt; を実行すると、他のコミットと同様に破棄されます。アップストリームから削除されました。</target>
        </trans-unit>
        <trans-unit id="ffd583141089c5adc863ae42b4a86dd7477a4031" translate="yes" xml:space="preserve">
          <source>to this?</source>
          <target state="translated">これに?</target>
        </trans-unit>
        <trans-unit id="ad3f025daaa46c547e7ff3268c862cc219dcf84b" translate="yes" xml:space="preserve">
          <source>you can also provide some rang of commit id.</source>
          <target state="translated">コミットIDを指定することもできます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
