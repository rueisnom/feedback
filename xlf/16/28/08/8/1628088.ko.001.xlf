<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1628088">
    <body>
      <group id="1628088">
        <trans-unit id="b7c5dd599473b7bd24bbf278876639d88d886c8e" translate="yes" xml:space="preserve">
          <source>* assumes your .git files aren't corrupt</source>
          <target state="translated">* .git 파일이 손상되지 않은 것으로 가정</target>
        </trans-unit>
        <trans-unit id="2b80e53a3cbe88a91abd4c1aea24c7d121a3b629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clean -d --force&lt;/code&gt;&lt;sub&gt;&lt;sup&gt;Removes untracked files and directories which hinder git to say &amp;ldquo;working directory clean&amp;rdquo;.&lt;/sup&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;git clean -d --force&lt;/code&gt; &lt;sub&gt;&lt;sup&gt;추적 할 수없는 파일과 디렉토리를 제거하여 git이&amp;ldquo;작업 디렉토리 정리&amp;rdquo;라고 말하지 못하게합니다.&lt;/sup&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5a06f9fea91d79966b1435341d11edca8243c9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch --prune&lt;/code&gt;&lt;sub&gt;&lt;sup&gt;(optional) Updates the local snapshot of the remote repo. Further commands are local only.&lt;/sup&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;git fetch --prune&lt;/code&gt; &lt;sub&gt;&lt;sup&gt;(선택 사항) 원격 저장소의 로컬 스냅 샷을 업데이트합니다.&lt;/sup&gt;&lt;/sub&gt; &lt;sub&gt;&lt;sup&gt;추가 명령은 로컬 전용입니다.&lt;/sup&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ca7d14a2015105f8e76bd9806be5cec9a42c111e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch origin&lt;/code&gt; downloads the latest from remote without trying to merge or rebase anything.</source>
          <target state="translated">&lt;code&gt;git fetch origin&lt;/code&gt; 은 아무것도 병합하거나 리베이스하지 않고 원격에서 최신 버전을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="a86a9e9ddeb3946c72874be0d7c53e98bbf4c6df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard @{upstream}&lt;/code&gt;&lt;sub&gt;&lt;sup&gt;Puts the local branch pointer to where the snapshot of the remote is, as well as set the index and the working directory to the files of that commit.&lt;/sup&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;git reset --hard @{upstream}&lt;/code&gt; &lt;sub&gt;&lt;sup&gt;로컬 브랜치 포인터를 리모트의 스냅 샷이있는 위치에두고 인덱스 및 작업 디렉토리를 해당 커밋 파일로 설정합니다.&lt;/sup&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f66d6d1ea03f90db50e2727159826a8c090a1c9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard HEAD&lt;/code&gt; actually only resets to the last committed state. In this case HEAD refers to the HEAD of your branch.</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD&lt;/code&gt; 는 실제로 마지막 커밋 된 상태로만 재설정합니다. 이 경우 HEAD는 지점의 HEAD를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="87b9d88918c5866a66ff7131a43ad669fceb1830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작동 방식 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dce57b9082e7a1425f18ee70331d2033b230ea48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The one-stop-answer is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;원 스톱 답변은 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3104ad444d46bf10a4ba85ab26694ef63154971b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The question mixes two issues here:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;질문은 두 가지 문제를 혼합합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91e47202f9d714a74f39bd1c83e48ec081f2b8a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;git clean -x -d -f&lt;/code&gt; is &lt;em&gt;irreversible&lt;/em&gt; and you may lose files and data (e.g. things you have ignored using &lt;code&gt;.gitignore&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;git clean -x -d -f&lt;/code&gt; 는 &lt;em&gt;되돌릴 수 없으며&lt;/em&gt; 파일과 데이터를 잃을 수 있습니다 (예 : &lt;code&gt;.gitignore&lt;/code&gt; 사용하여 무시한 것).</target>
        </trans-unit>
        <trans-unit id="1cfd1982343cecfe6ecc8b1adfda0e01ca27d467" translate="yes" xml:space="preserve">
          <source>All of the above suggests are right, but often to &lt;em&gt;really&lt;/em&gt; reset your project, you also need to remove even files that are in your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">위의 모든 제안은 옳지 만 종종 프로젝트를 &lt;em&gt;실제로&lt;/em&gt; 재설정하려면 &lt;code&gt;.gitignore&lt;/code&gt; 에 있는 파일조차 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="86bda52590b1e52b365b3f4160556578ba1a63a8" translate="yes" xml:space="preserve">
          <source>Also, you go for reset the current branch of &lt;code&gt;origin&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">또한 현재 &lt;code&gt;origin&lt;/code&gt; 을 &lt;code&gt;HEAD&lt;/code&gt; 로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="c8316cb5450ca7f337bb3c6698e131ffa516f787" translate="yes" xml:space="preserve">
          <source>As for your specific question as to why those files appear in the status as modified, it looks like perhaps you did a soft reset instead of a hard reset.  This will cause the files that were changed in the &lt;code&gt;HEAD&lt;/code&gt; commit to appear as if they were staged, which is likely what you are seeing here.</source>
          <target state="translated">해당 파일이 수정 된 상태로 나타나는 이유에 대한 특정 질문에 대해서는 하드 재설정 대신 소프트 재설정을 수행 한 것으로 보입니다. 그러면 &lt;code&gt;HEAD&lt;/code&gt; 커밋에서 변경된 파일이 마치 마치 마치 마치 마치 마치 보이는 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6376de0afc8a12bbf623e0a8165838bebd8c5778" translate="yes" xml:space="preserve">
          <source>BTW, this situation that you're in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it's not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular).</source>
          <target state="translated">BTW, 당신이 처한 상황은 현재 비 베어 리포지토리의 체크 아웃 된 분기로 푸시가 수행되는 일반적인 경우와 끔찍한 것처럼 보입니다. 최근에 지역 리포지토리로 밀었습니까? 그렇지 않은 경우 걱정할 필요가 없습니다. 다른 원인으로 인해 이러한 파일이 예기치 않게 수정되었습니다. 그렇지 않으면, 비베 어리 저장소 (특히 현재 체크 아웃 된 분기가 아닌)로 푸시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="38ebbdb0428983e332bf4bd6d6521d5ec20bedf3" translate="yes" xml:space="preserve">
          <source>Be careful though. Hard resets cannot easily be undone. It is better to do as Dan suggests, and branch off a copy of your changes before resetting.</source>
          <target state="translated">그래도 조심하십시오. 하드 리셋은 쉽게 취소 할 수 없습니다. Dan이 제안한대로 수행하고 재설정하기 전에 변경 사항 사본을 분기하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5c8b1ef19d77ab6304905a29da2c322cc95c1042" translate="yes" xml:space="preserve">
          <source>But when I run a &lt;code&gt;git status&lt;/code&gt;,</source>
          <target state="translated">하지만 &lt;code&gt;git status&lt;/code&gt; 를 실행하면</target>
        </trans-unit>
        <trans-unit id="76db3773a26afa2e3213b3eab913192a7120a272" translate="yes" xml:space="preserve">
          <source>Can you please tell me why I have these 'modified'? I haven't touched these files? If I did, I want to remove those.</source>
          <target state="translated">내가 왜 '수정 된'이유를 말씀해 주시겠습니까? 이 파일들을 건드리지 않았습니까? 내가 그랬다면, 그것들을 제거하고 싶다.</target>
        </trans-unit>
        <trans-unit id="e73bd79543051cc326d6ad174e0bdce1b82adfb4" translate="yes" xml:space="preserve">
          <source>Check your remotes, make sure your upstream and origin are what you expect, if not as expected then use &lt;code&gt;git remote add upstream &amp;lt;insert URL&amp;gt;&lt;/code&gt;, e.g. of the original GitHub repo that you forked from, and/or &lt;code&gt;git remote add origin &amp;lt;insert URL of the forked GitHub repo&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">리모컨을 확인하고 업스트림 및 오리진이 예상 한 것인지 확인하십시오. 예상하지 않은 경우 &lt;code&gt;git remote add upstream &amp;lt;insert URL&amp;gt;&lt;/code&gt; 을 사용하십시오 (예 : 포크 한 원래 GitHub 저장소 및 &lt;code&gt;git remote add origin &amp;lt;insert URL of the forked GitHub repo&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61446bcf307102157ed7dbb36eed7999ff90eb2f" translate="yes" xml:space="preserve">
          <source>Finally, as needed, get the latest changes:</source>
          <target state="translated">마지막으로 필요에 따라 최신 변경 사항을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="787b9668c0e9d9acfbb39a389226fa7d5e788beb" translate="yes" xml:space="preserve">
          <source>First, reset to the previously fetched &lt;code&gt;HEAD&lt;/code&gt; of the corresponding upstream branch:</source>
          <target state="translated">먼저 해당 업스트림 분기의 이전에 가져온 &lt;code&gt;HEAD&lt;/code&gt; 로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e3104999f51b9b30d33823de15a7ea27480d5e5f" translate="yes" xml:space="preserve">
          <source>Followed by:</source>
          <target state="translated">뒤에 :</target>
        </trans-unit>
        <trans-unit id="be64a46da1cd2aacb95a11143fd2908f0922ad72" translate="yes" xml:space="preserve">
          <source>Fortunately I didn't have any other branches I cared about.</source>
          <target state="translated">다행스럽게도 제가 관심을 갖고있는 다른 지점은 없었습니다.</target>
        </trans-unit>
        <trans-unit id="896f6fda05f984da67c66c3ac56ddf5d4500d262" translate="yes" xml:space="preserve">
          <source>Have you forgotten to create a feature-branch and have committed directly on master by mistake?</source>
          <target state="translated">기능 분기를 작성하지 않고 실수로 마스터에 직접 커미트 한 적이 있습니까?</target>
        </trans-unit>
        <trans-unit id="438d3f87a07443d5e97c2ea6ce1c740d7ee3d4e6" translate="yes" xml:space="preserve">
          <source>Here is a script that automates what the most popular answer suggests ...
See &lt;a href=&quot;https://stackoverflow.com/a/13308579/1497139&quot;&gt;https://stackoverflow.com/a/13308579/1497139&lt;/a&gt; for an improved version that supports branches</source>
          <target state="translated">다음은 가장 인기있는 답변이 제안하는 것을 자동화하는 스크립트입니다 ... 분기를 지원하는 개선 된 버전은 &lt;a href=&quot;https://stackoverflow.com/a/13308579/1497139&quot;&gt;https://stackoverflow.com/a/13308579/1497139&lt;/a&gt; 를 참조 하십시오</target>
        </trans-unit>
        <trans-unit id="430ef6313973a77582ba0a013ca6d7b1dd95cd62" translate="yes" xml:space="preserve">
          <source>How do I reset my local branch to be just like the branch on the remote repository?</source>
          <target state="translated">로컬 저장소를 원격 저장소의 분기와 동일하게 재설정하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="dbd131e78f7989788308807f5cc0a6e882f2ae79" translate="yes" xml:space="preserve">
          <source>I also added an &quot;are you sure&quot; prompt, &amp;amp; some feedback output</source>
          <target state="translated">또한 &quot;확인 하시겠습니까?&quot;프롬프트와 일부 피드백 출력을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="8b23435297d06f0f532540f5ebfe3115401eca74" translate="yes" xml:space="preserve">
          <source>I did:</source>
          <target state="translated">나는했다 :</target>
        </trans-unit>
        <trans-unit id="4a95767b928637e8e79611b706d6f812f23455e1" translate="yes" xml:space="preserve">
          <source>I had 2 not needed commits, hence the number 2. You can change it to your own number of commits to reset.</source>
          <target state="translated">커밋이 필요하지 않은 2 개가 있으므로 2 번 커밋을 커밋 수로 변경하여 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0fa2991b071e50a7c1e93d04a5f06d9f740313a" translate="yes" xml:space="preserve">
          <source>I needed to do (the solution in the accepted answer):</source>
          <target state="translated">나는해야했다 (허용 된 답변의 해결책) :</target>
        </trans-unit>
        <trans-unit id="76be46a31f9b3aeca7508d0c72b4e06a1ea3c728" translate="yes" xml:space="preserve">
          <source>If branch &quot;mybranch&quot; is &lt;strong&gt;not&lt;/strong&gt; currently checked out, to reset it to remote branch &quot;myremote/mybranch&quot;'s head, you can use this &lt;a href=&quot;http://schacon.github.io/git/git.html#_low_level_commands_plumbing&quot;&gt;low-level&lt;/a&gt; command:</source>
          <target state="translated">분기 &quot;mybranch&quot;가 현재 체크 아웃 &lt;strong&gt;되지 않은&lt;/strong&gt; 경우 원격 분기 &quot;myremote / mybranch&quot;의 헤드로 재설정하려면 다음 &lt;a href=&quot;http://schacon.github.io/git/git.html#_low_level_commands_plumbing&quot;&gt;하위 레벨&lt;/a&gt; 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68440e41acdb368524d7755f5a89e2ffaf1b724d" translate="yes" xml:space="preserve">
          <source>If you don't mind saving your local changes, yet still want to update your repository to match origin/HEAD, you can simply stash your local changes and then pull:</source>
          <target state="translated">로컬 변경 사항을 저장하지 않아도 원본 / HEAD와 일치하도록 리포지토리를 업데이트하려면 로컬 변경 사항을 숨기고 다음을 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="768505b684bb89cf7ddeded6078305cc207bfd5b" translate="yes" xml:space="preserve">
          <source>If you had a problem as me, that you have already committed some changes, but now, for any reason you want to get rid of it, the quickest way is to use &lt;code&gt;git reset&lt;/code&gt; like this:</source>
          <target state="translated">나와 같은 문제가 있었지만 이미 일부 변경 사항을 커밋했지만 지금은 어떤 이유로 든 제거하려는 경우 가장 빠른 방법은 다음과 같이 &lt;code&gt;git reset&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a77b296a2e0b8429914884cc43ffd630635fb5ee" translate="yes" xml:space="preserve">
          <source>If you have several commits, this won't work..</source>
          <target state="translated">커밋이 여러 개인 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fa501f9e5b0d7d83d708c4cfbc33dbd5c371072" translate="yes" xml:space="preserve">
          <source>If you want to go back to the &lt;code&gt;HEAD&lt;/code&gt; state for both the working directory and the index, then you should &lt;code&gt;git reset --hard HEAD&lt;/code&gt;, rather than to &lt;code&gt;HEAD^&lt;/code&gt;. (This may have been a typo, just like the single versus double dash for &lt;code&gt;--hard&lt;/code&gt;.)</source>
          <target state="translated">작업 디렉토리와 인덱스 모두에 대해 &lt;code&gt;HEAD&lt;/code&gt; 상태로 돌아가려면 &lt;code&gt;HEAD^&lt;/code&gt; 대신 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; 를 사용해야합니다. &lt;code&gt;--hard&lt;/code&gt; 에 대한 단일 대 이중 대시와 마찬가지로 오타 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc7d92448cccbeb6f525d9e0e157903b6d37c76" translate="yes" xml:space="preserve">
          <source>If you want to reset your local branch to the latest commit in the upstream branch, what works for me so far is:</source>
          <target state="translated">로컬 브랜치를 업스트림 브랜치의 최신 커밋으로 재설정하려는 경우 지금까지 효과적인 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8fc88c74d9df8ad8f192bbf2f68e255fe5176230" translate="yes" xml:space="preserve">
          <source>If you want to save your current branch's state before doing this (just in case), you can do:</source>
          <target state="translated">이 작업을 수행하기 전에 현재 브랜치의 상태를 저장하려는 경우 (만약의 경우)</target>
        </trans-unit>
        <trans-unit id="5d2984d4d5bb10b9f54763a52f2a0cb87a35b7b8" translate="yes" xml:space="preserve">
          <source>Next, as needed, remove untracked files, optionally also with &lt;code&gt;-x&lt;/code&gt;:</source>
          <target state="translated">그런 다음 필요에 따라 추적되지 않은 파일을 제거하고 선택적으로 &lt;code&gt;-x&lt;/code&gt; 를 사용 하여 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="92b5c14091994ef039439e4e9e6449bfef29b6f7" translate="yes" xml:space="preserve">
          <source>No amount of reset and cleaning seemed to have any effect on untracked and modified files in my local git repo (I tried all the options above). My only solution to this was to rm the local repo and re-clone it from the remote.</source>
          <target state="translated">로컬 git repo의 추적되지 않은 파일과 수정 된 파일에는 많은 양의 재설정 및 정리가 영향을 미치지 않는 것 같습니다 (위의 모든 옵션을 시도했습니다). 이것에 대한 유일한 해결책은 로컬 저장소를 rm하고 원격에서 복제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2051d2c3371377634ff95f72bc156f14b1946b9" translate="yes" xml:space="preserve">
          <source>Note that instead of upstream/develop you could use a commit hash, other branch name, etc. Use a CLI tool such as Oh My Zsh to check that your branch is green indicating that there is nothing to commit and the working directory is clean (which is confirmed or also verifiable by &lt;code&gt;git status&lt;/code&gt;). Note that this may actually add commits compared to upstream develop if there is anything automatically added by a commit, e.g. UML diagrams, license headers, etc., so in that case, you could then pull the changes on &lt;code&gt;origin develop&lt;/code&gt; to &lt;code&gt;upstream develop&lt;/code&gt;, if needed.</source>
          <target state="translated">업스트림 / 개발 대신 커밋 해시, 다른 분기 이름 등을 사용할 수 있습니다. Oh My Zsh와 같은 CLI 도구를 사용하여 분기가 녹색인지 확인하여 커밋 할 것이 없으며 작업 디렉토리가 깨끗하다는 것을 확인하십시오 ( &lt;code&gt;git status&lt;/code&gt; 로 확인하거나 확인할 수 있습니다). UML 다이어그램, 라이센스 헤더 등과 같이 커밋에 의해 자동으로 추가되는 것이 있으면 업스트림 개발에 비해 커밋을 실제로 추가 할 수 있으므로이 경우 &lt;code&gt;origin develop&lt;/code&gt; 의 변경 사항을 &lt;code&gt;upstream develop&lt;/code&gt; 로 끌어 올 수 있습니다. 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9e11e9c96afe5a79ffc753908539e02eb805353f" translate="yes" xml:space="preserve">
          <source>Note that it is good practice not to make changes to your local master/develop branch, but instead checkout to another branch for any change, with the branch name prepended by the type of change, e.g. &lt;code&gt;feat/&lt;/code&gt;, &lt;code&gt;chore/&lt;/code&gt;, &lt;code&gt;fix/&lt;/code&gt;, etc. Thus you only need to pull changes, not push any changes from master. Same thing for other branches that others contribute to. So the above should only be used if you have happened to commit changes to a branch that others have committed to, and need to reset. Otherwise in future avoid pushing to a branch that others push to, instead checkout and push to the said branch via the checked out branch.</source>
          <target state="translated">&lt;code&gt;feat/&lt;/code&gt; , &lt;code&gt;chore/&lt;/code&gt; , &lt;code&gt;fix/&lt;/code&gt; 등과 같이 변경 유형 앞에 붙은 브랜치 이름을 사용하여 로컬 마스터 / 개발 브랜치를 변경하지 말고 변경을 위해 다른 브랜치를 체크 아웃하는 것이 좋습니다. 따라서 마스터에서 변경 사항을 푸시하지 않고 변경 사항 만 가져와야합니다. 다른 사람들이 기여하는 다른 지점들도 마찬가지입니다. 따라서 위의 내용은 다른 사람이 커밋 한 분기에 변경 사항을 커밋하고 재설정해야하는 경우에만 사용해야합니다. 그렇지 않으면 나중에 다른 사람들이 푸시하는 브랜치로 푸시하지 말고 체크 아웃하고 체크 아웃 된 브랜치를 통해 해당 브랜치를 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="01ef3d499838982aa13f175969bfe29c96ab7c4f" translate="yes" xml:space="preserve">
          <source>Note that the first example assumes that the remote repo's name is &quot;origin&quot; and that the branch named &quot;master&quot; in the remote repo matches the currently checked-out branch in your local repo.</source>
          <target state="translated">첫 번째 예에서는 원격 리포지토리 이름이 &quot;origin&quot;이고 원격 리포지토리에서 &quot;master&quot;라는 분기가 로컬 리포지토리에서 현재 체크 아웃 된 분기와 일치한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9e27e83a26c5015a0895d4462a7317368d6883ba" translate="yes" xml:space="preserve">
          <source>Notice that you will lose the changes you've made, so be careful!</source>
          <target state="translated">변경 한 내용이 손실되므로주의하십시오!</target>
        </trans-unit>
        <trans-unit id="7cd4b3d709ccbc7c50e91ae8854babd3e7e20936" translate="yes" xml:space="preserve">
          <source>Now your work is saved on the branch &quot;my-saved-work&quot; in case you decide you want it back (or want to look at it later or diff it against your updated branch).</source>
          <target state="translated">이제 작업을 다시 원할 경우 (또는 나중에 보거나 업데이트 된 지점과 비교하기를 원할 경우) &quot;my-saved-work&quot;분기에 작업이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="602e8545f6a99d1bc5dd567a5a5cd759d60d91c5" translate="yes" xml:space="preserve">
          <source>On GitHub, you can also checkout the branch with the same name as the local one, in order to save the work there, although this isn't necessary if origin develop has the same changes as the local saved-work branch. I'm using the develop branch as an example, but it can be any existing branch name.</source>
          <target state="translated">GitHub에서 작업을 저장하기 위해 로컬 이름과 동일한 이름으로 지점을 체크 아웃 할 수도 있습니다. 그러나 원산지 개발이 로컬 저장된 작업 브랜치와 동일한 변경 사항이있는 경우 필요하지 않지만. 개발 브랜치를 예로 사용하고 있지만 기존 브랜치 이름이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f407dfa1340086653b5547fde530651270310b2f" translate="yes" xml:space="preserve">
          <source>Only 3 commands will make it work</source>
          <target state="translated">3 개의 명령 만 작동합니다</target>
        </trans-unit>
        <trans-unit id="0bbef6306bd32f4bf914905e62f9fa8b92ceaddc" translate="yes" xml:space="preserve">
          <source>Previous answers assume that the branch to be reset is the current branch (checked out). In comments, OP &lt;em&gt;hap497&lt;/em&gt; clarified that the branch is indeed checked out, but this is not explicitly required by the original question. Since there is at least one &quot;duplicate&quot; question, &lt;a href=&quot;https://stackoverflow.com/questions/27385949/reset-branch-completely-to-repository-state&quot;&gt;Reset branch completely to repository state&lt;/a&gt;, which does not assume that the branch is checked out, here's an alternative:</source>
          <target state="translated">이전 답변에서는 재설정 할 분기가 현재 분기 (체크 아웃 됨)라고 가정합니다. 의견에서 OP &lt;em&gt;hap497&lt;/em&gt; 은 브랜치가 실제로 체크 아웃되어 있지만 명확하게 요구하지는 않습니다. 최소한 하나의 &quot;중복&quot;질문이 있기 때문에 &lt;a href=&quot;https://stackoverflow.com/questions/27385949/reset-branch-completely-to-repository-state&quot;&gt;분기를 완전히 저장소 상태로 재설정&lt;/a&gt; 합니다. 분기는 체크 아웃되었다고 가정하지 않습니다. 다음은 대안입니다.</target>
        </trans-unit>
        <trans-unit id="b75a75ff8e26600ed9036663a14b65f172230cda" translate="yes" xml:space="preserve">
          <source>Provided that the remote repository is &lt;code&gt;origin&lt;/code&gt;, and that you're interested in &lt;code&gt;branch_name&lt;/code&gt;:</source>
          <target state="translated">원격 저장소가 &lt;code&gt;origin&lt;/code&gt; 이고 &lt;code&gt;branch_name&lt;/code&gt; 에 관심이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="80dadf8fcd42d7c5ddbd03379233401ea5695869" translate="yes" xml:space="preserve">
          <source>Reset local repository branch to be just like remote repository HEAD</source>
          <target state="translated">로컬 저장소 분기를 원격 저장소 HEAD와 동일하게 재설정</target>
        </trans-unit>
        <trans-unit id="625739de9bebf7312edde965ac2eed3b668854d8" translate="yes" xml:space="preserve">
          <source>Setting your branch to exactly match the remote branch can be done in two steps:</source>
          <target state="translated">원격 지사와 정확히 일치하도록 지사를 설정하려면 다음 두 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="60597c753da58007b9e191a77c1c8691c688da5d" translate="yes" xml:space="preserve">
          <source>So answering your question - if you're 5 commits ahead of remote repository HEAD, you should run this command:</source>
          <target state="translated">따라서 귀하의 질문에 대답하십시오-원격 저장소 HEAD보다 5 커밋 한 경우 다음 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa63791c5a7e17e45766502882e3d598e0f7154a" translate="yes" xml:space="preserve">
          <source>The advantage of specifying &lt;code&gt;@{u}&lt;/code&gt; or its verbose form &lt;code&gt;@{upstream}&lt;/code&gt; is that the name of the remote repo and branch don't have to be explicitly specified.</source>
          <target state="translated">&lt;code&gt;@{u}&lt;/code&gt; 또는 자세한 형태 인 &lt;code&gt;@{upstream}&lt;/code&gt; 을 지정하면 원격 저장소 및 분기 이름을 명시 적으로 지정할 필요가 없다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7011b1a621a67e63735eb77a3fab573aef5632e9" translate="yes" xml:space="preserve">
          <source>The answer</source>
          <target state="translated">대답</target>
        </trans-unit>
        <trans-unit id="478ec521620e94b78b3dbf05a935ced75c024b4e" translate="yes" xml:space="preserve">
          <source>The only solution that works in all cases that I've seen is to delete and reclone. Maybe there's another way, but obviously this way leaves no chance of old state being left there, so I prefer it. Bash one-liner you can set as a macro if you often mess things up in git:</source>
          <target state="translated">내가 본 모든 경우에 작동하는 유일한 솔루션은 삭제하고 복제하는 것입니다. 어쩌면 다른 방법이있을 수도 있지만 분명히이 방법은 오래된 상태가 남아있을 가능성이 없으므로 선호합니다. git에서 일을 망치면 매크로로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4bffe98bea1e26ae0e9bc219a8f0bd4361abe7b" translate="yes" xml:space="preserve">
          <source>Then if you need to merge these changes with another branch while where there are any conflicts, preserving the changes in develop, use:</source>
          <target state="translated">그런 다음 개발의 변경 사항을 유지하면서 충돌이있는 동안 이러한 변경 사항을 다른 지점과 병합 해야하는 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f5e26b4bfa8027e36854328a818c244fcf88dbce" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;git reset&lt;/code&gt; resets the &lt;code&gt;&amp;lt;branch_name&amp;gt;&lt;/code&gt; branch to what you just fetched. The &lt;code&gt;--hard&lt;/code&gt; option changes all the files in your working tree to match the files in &lt;code&gt;origin/branch_name&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;&amp;lt;branch_name&amp;gt;&lt;/code&gt; 분기를 방금 가져온 항목으로 재설정 합니다. &lt;code&gt;--hard&lt;/code&gt; 옵션은 작업 트리의 모든 파일을 &lt;code&gt;origin/branch_name&lt;/code&gt; 의 파일과 일치하도록 변경합니다.</target>
        </trans-unit>
        <trans-unit id="10a7a1773daed55900a270a1a0e5d89cf69e4009" translate="yes" xml:space="preserve">
          <source>This is something I face regularly, &amp;amp; I've generalised the script Wolfgang provided above to work with any branch</source>
          <target state="translated">이것은 내가 정기적으로 직면하는 것입니다. 그리고 나는 모든 지점과 함께 작업하기 위해 위에 제공된 Wolfgang 스크립트를 일반화했습니다.</target>
        </trans-unit>
        <trans-unit id="6eeef0f736ac579a6b450054c7672ceda745a237" translate="yes" xml:space="preserve">
          <source>This is what I use often:</source>
          <target state="translated">이것이 내가 자주 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad001485ea4d9b1f48db4108cba9c62f0c2e9392" translate="yes" xml:space="preserve">
          <source>This method leaves the checked out branch as it is, and the working tree untouched. It simply moves mybranch's head to another commit, whatever is given as the second argument. This is especially helpful if multiple branches need to be updated to new remote heads.</source>
          <target state="translated">이 방법은 체크 아웃 된 분기를 그대로두고 작업 트리를 건드리지 않습니다. 그것은 단지 mybranch의 머리를 다른 커밋으로 이동시킵니다. 여러 분기를 새 원격 헤드로 업데이트해야하는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e67802e913f3b5fa7586ca4ccb855a327977675b" translate="yes" xml:space="preserve">
          <source>To get the moral equivalent of &lt;strong&gt;erasing your project directory and re-cloning&lt;/strong&gt; from the remote is:</source>
          <target state="translated">&lt;strong&gt;프로젝트 디렉토리&lt;/strong&gt; 를 &lt;strong&gt;지우고&lt;/strong&gt; 원격에서 &lt;strong&gt;다시 복제&lt;/strong&gt; 하는 것과 같은 도덕적 가치를 얻으려면 다음을 수행 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="818127423f55d63b873083f1566cd3f2db3afe69" translate="yes" xml:space="preserve">
          <source>To see what files will be removed (without actually removing them):</source>
          <target state="translated">실제로 제거하지 않고 제거 할 파일을 보려면 :</target>
        </trans-unit>
        <trans-unit id="0447d23b709f2a826d65e08a1bd1cac55b55adc6" translate="yes" xml:space="preserve">
          <source>Use caution when doing this, though, and use &lt;code&gt;gitk&lt;/code&gt; or a similar tool to double check source and destination. If you accidentally do this on the current branch (and git will not keep you from this), you may become confused, because the new branch content does not match the working tree, which did not change (to fix, update the branch again, to where it was before).</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; 작업을 수행 할 때는주의를 기울이고 gitk 또는 이와 유사한 도구를 사용하여 소스 및 대상을 다시 확인하십시오. 실수로 현재 브랜치 에서이 작업을 수행하고 git 이이 작업을 방해하지 않으면 새 브랜치 내용이 변경되지 않은 작업 트리와 일치하지 않기 때문에 혼란 스러울 수 있습니다 (수정, 다시 업데이트하기 위해, 이전의 위치로).</target>
        </trans-unit>
        <trans-unit id="f02f2d8e58d78f59a49b6704d9118a6266ccd033" translate="yes" xml:space="preserve">
          <source>Use the commands below. These commands will remove all untracked files from local git too</source>
          <target state="translated">아래 명령을 사용하십시오. 이 명령은 로컬 git에서도 추적되지 않은 모든 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2b7736c160c48fb317cd027ac0a3b44faa7230de" translate="yes" xml:space="preserve">
          <source>What you probably want to do, is reset to the head of origin or whatever you remote repository is called. I'd probably just do something like</source>
          <target state="translated">아마도 원한다면 헤드 오브 오리진 또는 원격 리포지토리가 무엇이든 재설정됩니다. 아마 그냥 뭔가를 할 것입니다</target>
        </trans-unit>
        <trans-unit id="14899b864f4a68fa56157694f1b6e1b6f6b78bb8" translate="yes" xml:space="preserve">
          <source>While use</source>
          <target state="translated">사용하는 동안</target>
        </trans-unit>
        <trans-unit id="6742ff1e473a30661dbb7554a0c504dc807dd0b2" translate="yes" xml:space="preserve">
          <source>With all the changes together:</source>
          <target state="translated">모든 변경 사항이 함께 :</target>
        </trans-unit>
        <trans-unit id="aaf6e5cb4bcd222906fc7ade9bb3cd536bfbddd0" translate="yes" xml:space="preserve">
          <source>You can create the feature branch now and set master back without affecting the &lt;em&gt;worktree&lt;/em&gt; (local filesystem) to avoid triggering builds, tests and trouble with file-locks:</source>
          <target state="translated">이제 기능 분기를 작성하고 작업 트리 (로컬 파일 시스템)에 영향을주지 않고 마스터를 설정하여 빌드, 테스트 및 파일 잠금 문제 발생을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07954d7adf15cacdc17060e2475de642bdcb6986" translate="yes" xml:space="preserve">
          <source>how to clear your staging area (and possibly the working directory), so that &lt;code&gt;git status&lt;/code&gt; says &lt;code&gt;nothing to commit, working directory clean.&lt;/code&gt;</source>
          <target state="translated">준비 영역 (및 작업 디렉토리)을 지우는 방법으로 &lt;code&gt;git status&lt;/code&gt; &lt;code&gt;nothing to commit, working directory clean.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c3a6fb0b81301b8711d3817cf6da231fac77e24" translate="yes" xml:space="preserve">
          <source>how to reset a local branch to the point where the remote is</source>
          <target state="translated">원격 지점이있는 지점으로 로컬 지점을 재설정하는 방법</target>
        </trans-unit>
        <trans-unit id="50e14edbe7ca0ce2634b3291f85a47aa1d9c7968" translate="yes" xml:space="preserve">
          <source>note, you should checkout to another branch to be able to delete required branch</source>
          <target state="translated">필요한 지점을 삭제할 수 있도록 다른 지점에 체크 아웃해야합니다.</target>
        </trans-unit>
        <trans-unit id="44a2d30638b452855a13d4f2a43c8d4aa05f6e0e" translate="yes" xml:space="preserve">
          <source>to preserve branch_name's conflicting changes. Otherwise use a mergetool with &lt;code&gt;git mergetool&lt;/code&gt;.</source>
          <target state="translated">branch_name의 충돌하는 변경 사항을 보존합니다. 그렇지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 과 함께 mergetool을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="12b13d31e8066018bcde449f67345b7bfcf52de0" translate="yes" xml:space="preserve">
          <source>to remove local files</source>
          <target state="translated">로컬 파일을 제거하려면</target>
        </trans-unit>
        <trans-unit id="d110ecc4bf5aa685f91d30ec3d951d336ba2b9a9" translate="yes" xml:space="preserve">
          <source>to totally reset branch</source>
          <target state="translated">지점을 완전히 재설정</target>
        </trans-unit>
        <trans-unit id="14a4e920d1a119c78726be84a2502584abc89313" translate="yes" xml:space="preserve">
          <source>was underrated (&lt;strong&gt;-d&lt;/strong&gt; to remove directories).
Thanks!</source>
          <target state="translated">과소 평가되었습니다 (디렉토리를 제거하려면 &lt;strong&gt;-d&lt;/strong&gt; ). 감사!</target>
        </trans-unit>
        <trans-unit id="7212db004bf9a51e42dafe5bd156f27109417202" translate="yes" xml:space="preserve">
          <source>xkcd: Git</source>
          <target state="translated">xkcd : 힘내</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
