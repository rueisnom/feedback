<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1628088">
    <body>
      <group id="1628088">
        <trans-unit id="b7c5dd599473b7bd24bbf278876639d88d886c8e" translate="yes" xml:space="preserve">
          <source>* assumes your .git files aren't corrupt</source>
          <target state="translated">*假设你的.git文件没有损坏。</target>
        </trans-unit>
        <trans-unit id="2b80e53a3cbe88a91abd4c1aea24c7d121a3b629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clean -d --force&lt;/code&gt;&lt;sub&gt;&lt;sup&gt;Removes untracked files and directories which hinder git to say &amp;ldquo;working directory clean&amp;rdquo;.&lt;/sup&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;git clean -d --force&lt;/code&gt; &lt;sub&gt;&lt;sup&gt;删除妨碍git说&amp;ldquo;工作目录干净&amp;rdquo;的未跟踪文件和目录。&lt;/sup&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5a06f9fea91d79966b1435341d11edca8243c9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch --prune&lt;/code&gt;&lt;sub&gt;&lt;sup&gt;(optional) Updates the local snapshot of the remote repo. Further commands are local only.&lt;/sup&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;git fetch --prune&lt;/code&gt; &lt;sub&gt;&lt;sup&gt;（可选）更新远程存储库的本地快照。&lt;/sup&gt;&lt;/sub&gt; &lt;sub&gt;&lt;sup&gt;其他命令仅在本地。&lt;/sup&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ca7d14a2015105f8e76bd9806be5cec9a42c111e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch origin&lt;/code&gt; downloads the latest from remote without trying to merge or rebase anything.</source>
          <target state="translated">&lt;code&gt;git fetch origin&lt;/code&gt; 可以从远程下载最新版本，而无需尝试合并或重新设置任何内容。</target>
        </trans-unit>
        <trans-unit id="a86a9e9ddeb3946c72874be0d7c53e98bbf4c6df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard @{upstream}&lt;/code&gt;&lt;sub&gt;&lt;sup&gt;Puts the local branch pointer to where the snapshot of the remote is, as well as set the index and the working directory to the files of that commit.&lt;/sup&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;git reset --hard @{upstream}&lt;/code&gt; &lt;sub&gt;&lt;sup&gt;将本地分支指针放置到远程快照的位置，并将索引和工作目录设置为该提交的文件。&lt;/sup&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f66d6d1ea03f90db50e2727159826a8c090a1c9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard HEAD&lt;/code&gt; actually only resets to the last committed state. In this case HEAD refers to the HEAD of your branch.</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD&lt;/code&gt; 实际上仅重置为最后的提交状态。 在这种情况下，HEAD是指分支的HEAD。</target>
        </trans-unit>
        <trans-unit id="87b9d88918c5866a66ff7131a43ad669fceb1830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;怎么运行的：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dce57b9082e7a1425f18ee70331d2033b230ea48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The one-stop-answer is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一站式答案是：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3104ad444d46bf10a4ba85ab26694ef63154971b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The question mixes two issues here:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这个问题在这里混合了两个问题：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91e47202f9d714a74f39bd1c83e48ec081f2b8a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;git clean -x -d -f&lt;/code&gt; is &lt;em&gt;irreversible&lt;/em&gt; and you may lose files and data (e.g. things you have ignored using &lt;code&gt;.gitignore&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ： &lt;code&gt;git clean -x -d -f&lt;/code&gt; 是&lt;em&gt;不可逆的&lt;/em&gt; ，您可能会丢失文件和数据（例如，使用 &lt;code&gt;.gitignore&lt;/code&gt; 忽略的内容 ）。</target>
        </trans-unit>
        <trans-unit id="1cfd1982343cecfe6ecc8b1adfda0e01ca27d467" translate="yes" xml:space="preserve">
          <source>All of the above suggests are right, but often to &lt;em&gt;really&lt;/em&gt; reset your project, you also need to remove even files that are in your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">以上所有建议均是正确的，但是通常要&lt;em&gt;真正&lt;/em&gt;重置项目，甚至还需要删除 &lt;code&gt;.gitignore&lt;/code&gt; 中的文件。</target>
        </trans-unit>
        <trans-unit id="86bda52590b1e52b365b3f4160556578ba1a63a8" translate="yes" xml:space="preserve">
          <source>Also, you go for reset the current branch of &lt;code&gt;origin&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">此外，您还需要将当前的 &lt;code&gt;origin&lt;/code&gt; 分支重置为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8316cb5450ca7f337bb3c6698e131ffa516f787" translate="yes" xml:space="preserve">
          <source>As for your specific question as to why those files appear in the status as modified, it looks like perhaps you did a soft reset instead of a hard reset.  This will cause the files that were changed in the &lt;code&gt;HEAD&lt;/code&gt; commit to appear as if they were staged, which is likely what you are seeing here.</source>
          <target state="translated">至于关于这些文件为何以修改后的状态显示的特定问题，似乎您进行了软重置而不是硬重置。 这将导致在 &lt;code&gt;HEAD&lt;/code&gt; 提交中更改的文件看起来像是已暂存的，这很可能是您在此处看到的。</target>
        </trans-unit>
        <trans-unit id="6376de0afc8a12bbf623e0a8165838bebd8c5778" translate="yes" xml:space="preserve">
          <source>BTW, this situation that you're in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it's not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular).</source>
          <target state="translated">BTW,你现在的这种情况看起来很像一个常见的情况,即推送到一个非独立仓库的分支中。你最近有没有推送到你的本地版本库?如果没有,那么不用担心--一定是有其他原因导致这些文件意外地被修改了。否则,你应该知道,不建议推送到非裸仓库(尤其是当前已签出的分支)。</target>
        </trans-unit>
        <trans-unit id="38ebbdb0428983e332bf4bd6d6521d5ec20bedf3" translate="yes" xml:space="preserve">
          <source>Be careful though. Hard resets cannot easily be undone. It is better to do as Dan suggests, and branch off a copy of your changes before resetting.</source>
          <target state="translated">虽然要小心翼翼。硬重置不能轻易被撤销。最好按照Dan的建议,在重置之前,先把你的更改的副本分支下来,然后再重置。</target>
        </trans-unit>
        <trans-unit id="5c8b1ef19d77ab6304905a29da2c322cc95c1042" translate="yes" xml:space="preserve">
          <source>But when I run a &lt;code&gt;git status&lt;/code&gt;,</source>
          <target state="translated">但是当我运行 &lt;code&gt;git status&lt;/code&gt; 时 ，</target>
        </trans-unit>
        <trans-unit id="76db3773a26afa2e3213b3eab913192a7120a272" translate="yes" xml:space="preserve">
          <source>Can you please tell me why I have these 'modified'? I haven't touched these files? If I did, I want to remove those.</source>
          <target state="translated">能否请你告诉我,我为什么会有这些'修改'?我没有碰过这些文件?如果有,我想删除这些文件。</target>
        </trans-unit>
        <trans-unit id="e73bd79543051cc326d6ad174e0bdce1b82adfb4" translate="yes" xml:space="preserve">
          <source>Check your remotes, make sure your upstream and origin are what you expect, if not as expected then use &lt;code&gt;git remote add upstream &amp;lt;insert URL&amp;gt;&lt;/code&gt;, e.g. of the original GitHub repo that you forked from, and/or &lt;code&gt;git remote add origin &amp;lt;insert URL of the forked GitHub repo&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">检查您的远程服务器，确保您的上游和原始服务器符合您的期望，如果不符合预期，则使用 &lt;code&gt;git remote add upstream &amp;lt;insert URL&amp;gt;&lt;/code&gt; ，例如您从其分叉的原始GitHub存储库，和/或 &lt;code&gt;git remote add origin &amp;lt;insert URL of the forked GitHub repo&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61446bcf307102157ed7dbb36eed7999ff90eb2f" translate="yes" xml:space="preserve">
          <source>Finally, as needed, get the latest changes:</source>
          <target state="translated">最后,根据需要,获取最新变化。</target>
        </trans-unit>
        <trans-unit id="787b9668c0e9d9acfbb39a389226fa7d5e788beb" translate="yes" xml:space="preserve">
          <source>First, reset to the previously fetched &lt;code&gt;HEAD&lt;/code&gt; of the corresponding upstream branch:</source>
          <target state="translated">首先，将其重置为相应上游分支的先前获取的 &lt;code&gt;HEAD&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e3104999f51b9b30d33823de15a7ea27480d5e5f" translate="yes" xml:space="preserve">
          <source>Followed by:</source>
          <target state="translated">随后是:</target>
        </trans-unit>
        <trans-unit id="be64a46da1cd2aacb95a11143fd2908f0922ad72" translate="yes" xml:space="preserve">
          <source>Fortunately I didn't have any other branches I cared about.</source>
          <target state="translated">幸运的是,我没有任何其他我关心的分支。</target>
        </trans-unit>
        <trans-unit id="896f6fda05f984da67c66c3ac56ddf5d4500d262" translate="yes" xml:space="preserve">
          <source>Have you forgotten to create a feature-branch and have committed directly on master by mistake?</source>
          <target state="translated">你是否忘记了创建一个功能分支,误打误撞直接在主站上提交了?</target>
        </trans-unit>
        <trans-unit id="438d3f87a07443d5e97c2ea6ce1c740d7ee3d4e6" translate="yes" xml:space="preserve">
          <source>Here is a script that automates what the most popular answer suggests ...
See &lt;a href=&quot;https://stackoverflow.com/a/13308579/1497139&quot;&gt;https://stackoverflow.com/a/13308579/1497139&lt;/a&gt; for an improved version that supports branches</source>
          <target state="translated">这是一个脚本，可自动执行最流行的答案所建议的内容...有关支持分支的改进版本，请参见&lt;a href=&quot;https://stackoverflow.com/a/13308579/1497139&quot;&gt;https://stackoverflow.com/a/13308579/1497139&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="430ef6313973a77582ba0a013ca6d7b1dd95cd62" translate="yes" xml:space="preserve">
          <source>How do I reset my local branch to be just like the branch on the remote repository?</source>
          <target state="translated">如何重置我的本地分支,使其与远程仓库上的分支一样?</target>
        </trans-unit>
        <trans-unit id="dbd131e78f7989788308807f5cc0a6e882f2ae79" translate="yes" xml:space="preserve">
          <source>I also added an &quot;are you sure&quot; prompt, &amp;amp; some feedback output</source>
          <target state="translated">我还添加了&amp;ldquo;您确定&amp;rdquo;提示，以及一些反馈输出</target>
        </trans-unit>
        <trans-unit id="8b23435297d06f0f532540f5ebfe3115401eca74" translate="yes" xml:space="preserve">
          <source>I did:</source>
          <target state="translated">是的</target>
        </trans-unit>
        <trans-unit id="4a95767b928637e8e79611b706d6f812f23455e1" translate="yes" xml:space="preserve">
          <source>I had 2 not needed commits, hence the number 2. You can change it to your own number of commits to reset.</source>
          <target state="translated">我有2个不需要提交,因此数字2。你可以改成自己的提交数来重置。</target>
        </trans-unit>
        <trans-unit id="f0fa2991b071e50a7c1e93d04a5f06d9f740313a" translate="yes" xml:space="preserve">
          <source>I needed to do (the solution in the accepted answer):</source>
          <target state="translated">我需要做(接受答案中的解决方案)。</target>
        </trans-unit>
        <trans-unit id="76be46a31f9b3aeca7508d0c72b4e06a1ea3c728" translate="yes" xml:space="preserve">
          <source>If branch &quot;mybranch&quot; is &lt;strong&gt;not&lt;/strong&gt; currently checked out, to reset it to remote branch &quot;myremote/mybranch&quot;'s head, you can use this &lt;a href=&quot;http://schacon.github.io/git/git.html#_low_level_commands_plumbing&quot;&gt;low-level&lt;/a&gt; command:</source>
          <target state="translated">如果当前&lt;strong&gt;未&lt;/strong&gt;检出分支&amp;ldquo; mybranch&amp;rdquo;，则要将其重置为远程分支&amp;ldquo; myremote / mybranch&amp;rdquo;的头，可以使用以下&lt;a href=&quot;http://schacon.github.io/git/git.html#_low_level_commands_plumbing&quot;&gt;底层&lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="68440e41acdb368524d7755f5a89e2ffaf1b724d" translate="yes" xml:space="preserve">
          <source>If you don't mind saving your local changes, yet still want to update your repository to match origin/HEAD, you can simply stash your local changes and then pull:</source>
          <target state="translated">如果你不介意保存你的本地修改,但仍想更新你的版本库以匹配 originHEAD,你可以简单地存储你的本地修改,然后拉。</target>
        </trans-unit>
        <trans-unit id="768505b684bb89cf7ddeded6078305cc207bfd5b" translate="yes" xml:space="preserve">
          <source>If you had a problem as me, that you have already committed some changes, but now, for any reason you want to get rid of it, the quickest way is to use &lt;code&gt;git reset&lt;/code&gt; like this:</source>
          <target state="translated">如果您遇到我的问题，那么您已经进行了一些更改，但是现在，出于任何原因想要摆脱它，最快的方法是使用 &lt;code&gt;git reset&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="a77b296a2e0b8429914884cc43ffd630635fb5ee" translate="yes" xml:space="preserve">
          <source>If you have several commits, this won't work..</source>
          <target state="translated">如果你有好几个承诺,这个是不行的。</target>
        </trans-unit>
        <trans-unit id="3fa501f9e5b0d7d83d708c4cfbc33dbd5c371072" translate="yes" xml:space="preserve">
          <source>If you want to go back to the &lt;code&gt;HEAD&lt;/code&gt; state for both the working directory and the index, then you should &lt;code&gt;git reset --hard HEAD&lt;/code&gt;, rather than to &lt;code&gt;HEAD^&lt;/code&gt;. (This may have been a typo, just like the single versus double dash for &lt;code&gt;--hard&lt;/code&gt;.)</source>
          <target state="translated">如果要同时返回工作目录和索引的 &lt;code&gt;HEAD&lt;/code&gt; 状态，则应 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; ，而不是 &lt;code&gt;HEAD^&lt;/code&gt; 。 （这可能是一个错字，就像 &lt;code&gt;--hard&lt;/code&gt; 的单破折号和双破折号一样。）</target>
        </trans-unit>
        <trans-unit id="4dc7d92448cccbeb6f525d9e0e157903b6d37c76" translate="yes" xml:space="preserve">
          <source>If you want to reset your local branch to the latest commit in the upstream branch, what works for me so far is:</source>
          <target state="translated">如果你想将你的本地分支重置为上游分支中的最新提交,目前对我有效的方法是:</target>
        </trans-unit>
        <trans-unit id="8fc88c74d9df8ad8f192bbf2f68e255fe5176230" translate="yes" xml:space="preserve">
          <source>If you want to save your current branch's state before doing this (just in case), you can do:</source>
          <target state="translated">如果你想在做这件事之前保存当前分支的状态(以防万一),你可以这样做。</target>
        </trans-unit>
        <trans-unit id="5d2984d4d5bb10b9f54763a52f2a0cb87a35b7b8" translate="yes" xml:space="preserve">
          <source>Next, as needed, remove untracked files, optionally also with &lt;code&gt;-x&lt;/code&gt;:</source>
          <target state="translated">接下来，根据需要，删除未跟踪的文件，也可以使用 &lt;code&gt;-x&lt;/code&gt; 删除：</target>
        </trans-unit>
        <trans-unit id="92b5c14091994ef039439e4e9e6449bfef29b6f7" translate="yes" xml:space="preserve">
          <source>No amount of reset and cleaning seemed to have any effect on untracked and modified files in my local git repo (I tried all the options above). My only solution to this was to rm the local repo and re-clone it from the remote.</source>
          <target state="translated">重置和清理似乎对我的本地git repo中未被跟踪和修改的文件没有任何影响(我试过上面所有的选项)。我唯一的解决方法是将本地的repo重置并从远程重新克隆。</target>
        </trans-unit>
        <trans-unit id="e2051d2c3371377634ff95f72bc156f14b1946b9" translate="yes" xml:space="preserve">
          <source>Note that instead of upstream/develop you could use a commit hash, other branch name, etc. Use a CLI tool such as Oh My Zsh to check that your branch is green indicating that there is nothing to commit and the working directory is clean (which is confirmed or also verifiable by &lt;code&gt;git status&lt;/code&gt;). Note that this may actually add commits compared to upstream develop if there is anything automatically added by a commit, e.g. UML diagrams, license headers, etc., so in that case, you could then pull the changes on &lt;code&gt;origin develop&lt;/code&gt; to &lt;code&gt;upstream develop&lt;/code&gt;, if needed.</source>
          <target state="translated">请注意，您可以使用提交哈希，其他分支名称等代替上游/开发。使用CLI工具（例如Oh My Zsh）检查您的分支是否为绿色，指示没有要提交的内容并且工作目录是干净的（可以通过 &lt;code&gt;git status&lt;/code&gt; 确认或验证）。 请注意，如果提交自动添加了任何内容（例如，UML图，许可证标头等），那么与上游开发相比，这实际上可能会添加提交，因此在这种情况下，您可以将 &lt;code&gt;origin develop&lt;/code&gt; 的更改拉到 &lt;code&gt;upstream develop&lt;/code&gt; ，如果需要。</target>
        </trans-unit>
        <trans-unit id="9e11e9c96afe5a79ffc753908539e02eb805353f" translate="yes" xml:space="preserve">
          <source>Note that it is good practice not to make changes to your local master/develop branch, but instead checkout to another branch for any change, with the branch name prepended by the type of change, e.g. &lt;code&gt;feat/&lt;/code&gt;, &lt;code&gt;chore/&lt;/code&gt;, &lt;code&gt;fix/&lt;/code&gt;, etc. Thus you only need to pull changes, not push any changes from master. Same thing for other branches that others contribute to. So the above should only be used if you have happened to commit changes to a branch that others have committed to, and need to reset. Otherwise in future avoid pushing to a branch that others push to, instead checkout and push to the said branch via the checked out branch.</source>
          <target state="translated">请注意，最好不要对本地master / develop分支进行更改，而应签到其他分支以进行任何更改，分支名称以更改类型开头，例如 &lt;code&gt;feat/&lt;/code&gt; ， &lt;code&gt;chore/&lt;/code&gt; ， &lt;code&gt;fix/&lt;/code&gt; 等。因此，您只需要拉出更改，而无需从master推送任何更改。 对于其他人贡献的其他分支机构也是如此。 因此，仅当您碰巧将更改提交给其他人已提交并需要重置的分支时，才应使用以上内容。 否则，将来避免推到其他人推到的分支，而是签出并通过签出的分支推到所述分支。</target>
        </trans-unit>
        <trans-unit id="01ef3d499838982aa13f175969bfe29c96ab7c4f" translate="yes" xml:space="preserve">
          <source>Note that the first example assumes that the remote repo's name is &quot;origin&quot; and that the branch named &quot;master&quot; in the remote repo matches the currently checked-out branch in your local repo.</source>
          <target state="translated">请注意,第一个例子假设远程repo的名字是 &quot;origin&quot;,并且远程repo中名为 &quot;master &quot;的分支与本地repo中的当前已签出的分支一致。</target>
        </trans-unit>
        <trans-unit id="9e27e83a26c5015a0895d4462a7317368d6883ba" translate="yes" xml:space="preserve">
          <source>Notice that you will lose the changes you've made, so be careful!</source>
          <target state="translated">注意,你会失去你所做的改变,所以要小心翼翼!</target>
        </trans-unit>
        <trans-unit id="7cd4b3d709ccbc7c50e91ae8854babd3e7e20936" translate="yes" xml:space="preserve">
          <source>Now your work is saved on the branch &quot;my-saved-work&quot; in case you decide you want it back (or want to look at it later or diff it against your updated branch).</source>
          <target state="translated">现在,你的工作被保存在分支 &quot;my-saved-work &quot;中,以备你决定要回它(或者以后再看它,或者与你更新的分支对比)。</target>
        </trans-unit>
        <trans-unit id="602e8545f6a99d1bc5dd567a5a5cd759d60d91c5" translate="yes" xml:space="preserve">
          <source>On GitHub, you can also checkout the branch with the same name as the local one, in order to save the work there, although this isn't necessary if origin develop has the same changes as the local saved-work branch. I'm using the develop branch as an example, but it can be any existing branch name.</source>
          <target state="translated">在 GitHub 上,你也可以查看与本地分支名称相同的分支,以便将工作保存在那里,不过如果 origin develop 与本地保存的工作分支有相同的改动,则不需要这样做。我以开发分支为例,但它可以是任何现有的分支名称。</target>
        </trans-unit>
        <trans-unit id="f407dfa1340086653b5547fde530651270310b2f" translate="yes" xml:space="preserve">
          <source>Only 3 commands will make it work</source>
          <target state="translated">只有3个命令就能让它工作</target>
        </trans-unit>
        <trans-unit id="0bbef6306bd32f4bf914905e62f9fa8b92ceaddc" translate="yes" xml:space="preserve">
          <source>Previous answers assume that the branch to be reset is the current branch (checked out). In comments, OP &lt;em&gt;hap497&lt;/em&gt; clarified that the branch is indeed checked out, but this is not explicitly required by the original question. Since there is at least one &quot;duplicate&quot; question, &lt;a href=&quot;https://stackoverflow.com/questions/27385949/reset-branch-completely-to-repository-state&quot;&gt;Reset branch completely to repository state&lt;/a&gt;, which does not assume that the branch is checked out, here's an alternative:</source>
          <target state="translated">先前的答案假定要重置的分支是当前分支（已签出）。 在评论中，OP &lt;em&gt;hap497&lt;/em&gt;阐明了确实已检出该分支，但这不是原始问题明确要求的。 由于存在至少一个&amp;ldquo;重复&amp;rdquo;问题，因此将&lt;a href=&quot;https://stackoverflow.com/questions/27385949/reset-branch-completely-to-repository-state&quot;&gt;分支完全重置为存储库状态&lt;/a&gt; ，而不假定分支已签出，这里是一种替代方法：</target>
        </trans-unit>
        <trans-unit id="b75a75ff8e26600ed9036663a14b65f172230cda" translate="yes" xml:space="preserve">
          <source>Provided that the remote repository is &lt;code&gt;origin&lt;/code&gt;, and that you're interested in &lt;code&gt;branch_name&lt;/code&gt;:</source>
          <target state="translated">假设远程存储库是 &lt;code&gt;origin&lt;/code&gt; ，并且您对 &lt;code&gt;branch_name&lt;/code&gt; 感兴趣：</target>
        </trans-unit>
        <trans-unit id="80dadf8fcd42d7c5ddbd03379233401ea5695869" translate="yes" xml:space="preserve">
          <source>Reset local repository branch to be just like remote repository HEAD</source>
          <target state="translated">重置本地存储库分支,使其与远程存储库的HEAD一样。</target>
        </trans-unit>
        <trans-unit id="625739de9bebf7312edde965ac2eed3b668854d8" translate="yes" xml:space="preserve">
          <source>Setting your branch to exactly match the remote branch can be done in two steps:</source>
          <target state="translated">将你的分支设置为完全匹配的远程分支,可以分两步完成。</target>
        </trans-unit>
        <trans-unit id="60597c753da58007b9e191a77c1c8691c688da5d" translate="yes" xml:space="preserve">
          <source>So answering your question - if you're 5 commits ahead of remote repository HEAD, you should run this command:</source>
          <target state="translated">所以回答你的问题--如果你比远程版本库head提前5个提交,你应该运行这个命令。</target>
        </trans-unit>
        <trans-unit id="fa63791c5a7e17e45766502882e3d598e0f7154a" translate="yes" xml:space="preserve">
          <source>The advantage of specifying &lt;code&gt;@{u}&lt;/code&gt; or its verbose form &lt;code&gt;@{upstream}&lt;/code&gt; is that the name of the remote repo and branch don't have to be explicitly specified.</source>
          <target state="translated">指定 &lt;code&gt;@{u}&lt;/code&gt; 或其详细形式 &lt;code&gt;@{upstream}&lt;/code&gt; 的优点是不必明确指定远程仓库和分支的名称。</target>
        </trans-unit>
        <trans-unit id="7011b1a621a67e63735eb77a3fab573aef5632e9" translate="yes" xml:space="preserve">
          <source>The answer</source>
          <target state="translated">答案是</target>
        </trans-unit>
        <trans-unit id="478ec521620e94b78b3dbf05a935ced75c024b4e" translate="yes" xml:space="preserve">
          <source>The only solution that works in all cases that I've seen is to delete and reclone. Maybe there's another way, but obviously this way leaves no chance of old state being left there, so I prefer it. Bash one-liner you can set as a macro if you often mess things up in git:</source>
          <target state="translated">在我所见过的所有情况下,唯一可行的解决方案是删除并重新定位。也许还有其他的方法,但显然这种方法不会让旧状态留在那里,所以我更喜欢这种方法。Bash单行本,如果你经常在git中搞乱,可以设置为宏。</target>
        </trans-unit>
        <trans-unit id="e4bffe98bea1e26ae0e9bc219a8f0bd4361abe7b" translate="yes" xml:space="preserve">
          <source>Then if you need to merge these changes with another branch while where there are any conflicts, preserving the changes in develop, use:</source>
          <target state="translated">然后,如果你需要将这些变化与另一个分支合并,而哪里有任何冲突,保留在开发中的变化,使用。</target>
        </trans-unit>
        <trans-unit id="f5e26b4bfa8027e36854328a818c244fcf88dbce" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;git reset&lt;/code&gt; resets the &lt;code&gt;&amp;lt;branch_name&amp;gt;&lt;/code&gt; branch to what you just fetched. The &lt;code&gt;--hard&lt;/code&gt; option changes all the files in your working tree to match the files in &lt;code&gt;origin/branch_name&lt;/code&gt;.</source>
          <target state="translated">然后 &lt;code&gt;git reset&lt;/code&gt; 将 &lt;code&gt;&amp;lt;branch_name&amp;gt;&lt;/code&gt; 分支重置为您刚获取的分支。 &lt;code&gt;--hard&lt;/code&gt; 选项更改工作树中的所有文件，以匹配 &lt;code&gt;origin/branch_name&lt;/code&gt; 中的文件。</target>
        </trans-unit>
        <trans-unit id="10a7a1773daed55900a270a1a0e5d89cf69e4009" translate="yes" xml:space="preserve">
          <source>This is something I face regularly, &amp;amp; I've generalised the script Wolfgang provided above to work with any branch</source>
          <target state="translated">这是我经常要面对的事情，并且我已经概括了上面提供的与任何分支一起使用的Wolfgang脚本</target>
        </trans-unit>
        <trans-unit id="6eeef0f736ac579a6b450054c7672ceda745a237" translate="yes" xml:space="preserve">
          <source>This is what I use often:</source>
          <target state="translated">这是我经常使用的方法。</target>
        </trans-unit>
        <trans-unit id="ad001485ea4d9b1f48db4108cba9c62f0c2e9392" translate="yes" xml:space="preserve">
          <source>This method leaves the checked out branch as it is, and the working tree untouched. It simply moves mybranch's head to another commit, whatever is given as the second argument. This is especially helpful if multiple branches need to be updated to new remote heads.</source>
          <target state="translated">这个方法可以让已勾选的分支保持原样,工作树不被触动。它只需将mybranch的分支头移动到另一个提交中,无论第二个参数是什么。如果多个分支需要更新到新的远程头,这个方法特别有用。</target>
        </trans-unit>
        <trans-unit id="e67802e913f3b5fa7586ca4ccb855a327977675b" translate="yes" xml:space="preserve">
          <source>To get the moral equivalent of &lt;strong&gt;erasing your project directory and re-cloning&lt;/strong&gt; from the remote is:</source>
          <target state="translated">从道德上讲， &lt;strong&gt;擦除项目目录并&lt;/strong&gt;从远程&lt;strong&gt;重新克隆&lt;/strong&gt;是：</target>
        </trans-unit>
        <trans-unit id="818127423f55d63b873083f1566cd3f2db3afe69" translate="yes" xml:space="preserve">
          <source>To see what files will be removed (without actually removing them):</source>
          <target state="translated">要查看将删除哪些文件(没有实际删除)。</target>
        </trans-unit>
        <trans-unit id="0447d23b709f2a826d65e08a1bd1cac55b55adc6" translate="yes" xml:space="preserve">
          <source>Use caution when doing this, though, and use &lt;code&gt;gitk&lt;/code&gt; or a similar tool to double check source and destination. If you accidentally do this on the current branch (and git will not keep you from this), you may become confused, because the new branch content does not match the working tree, which did not change (to fix, update the branch again, to where it was before).</source>
          <target state="translated">但是，在执行此操作时请小心，并使用 &lt;code&gt;gitk&lt;/code&gt; 或类似工具仔细检查源和目标。 如果您不小心在当前分支上执行此操作（并且git不会阻止您这样做），您可能会感到困惑，因为新分支内容与未更改的工作树不匹配（要修复，请再次更新分支，到之前的位置）。</target>
        </trans-unit>
        <trans-unit id="f02f2d8e58d78f59a49b6704d9118a6266ccd033" translate="yes" xml:space="preserve">
          <source>Use the commands below. These commands will remove all untracked files from local git too</source>
          <target state="translated">使用下面的命令。这些命令也将从本地git中删除所有未被跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="2b7736c160c48fb317cd027ac0a3b44faa7230de" translate="yes" xml:space="preserve">
          <source>What you probably want to do, is reset to the head of origin or whatever you remote repository is called. I'd probably just do something like</source>
          <target state="translated">你可能要做的,就是重置到源头或者是你的远程存储库的名称。我可能只是做一些像</target>
        </trans-unit>
        <trans-unit id="14899b864f4a68fa56157694f1b6e1b6f6b78bb8" translate="yes" xml:space="preserve">
          <source>While use</source>
          <target state="translated">在使用过程中</target>
        </trans-unit>
        <trans-unit id="6742ff1e473a30661dbb7554a0c504dc807dd0b2" translate="yes" xml:space="preserve">
          <source>With all the changes together:</source>
          <target state="translated">随着所有的变化一起。</target>
        </trans-unit>
        <trans-unit id="aaf6e5cb4bcd222906fc7ade9bb3cd536bfbddd0" translate="yes" xml:space="preserve">
          <source>You can create the feature branch now and set master back without affecting the &lt;em&gt;worktree&lt;/em&gt; (local filesystem) to avoid triggering builds, tests and trouble with file-locks:</source>
          <target state="translated">您现在可以创建功能分支并重新设置master而不影响工作&lt;em&gt;树&lt;/em&gt; （本地文件系统），以避免触发构建，测试和文件锁定问题：</target>
        </trans-unit>
        <trans-unit id="07954d7adf15cacdc17060e2475de642bdcb6986" translate="yes" xml:space="preserve">
          <source>how to clear your staging area (and possibly the working directory), so that &lt;code&gt;git status&lt;/code&gt; says &lt;code&gt;nothing to commit, working directory clean.&lt;/code&gt;</source>
          <target state="translated">如何清除暂存区（可能还有工作目录），以便 &lt;code&gt;git status&lt;/code&gt; &lt;code&gt;nothing to commit, working directory clean.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c3a6fb0b81301b8711d3817cf6da231fac77e24" translate="yes" xml:space="preserve">
          <source>how to reset a local branch to the point where the remote is</source>
          <target state="translated">如何将本地分支重置到远程的位置上</target>
        </trans-unit>
        <trans-unit id="50e14edbe7ca0ce2634b3291f85a47aa1d9c7968" translate="yes" xml:space="preserve">
          <source>note, you should checkout to another branch to be able to delete required branch</source>
          <target state="translated">注意,你应该结账到另一个分支,以便能够删除所需的分支。</target>
        </trans-unit>
        <trans-unit id="44a2d30638b452855a13d4f2a43c8d4aa05f6e0e" translate="yes" xml:space="preserve">
          <source>to preserve branch_name's conflicting changes. Otherwise use a mergetool with &lt;code&gt;git mergetool&lt;/code&gt;.</source>
          <target state="translated">保留branch_name冲突的更改。 否则，请使用带有 &lt;code&gt;git mergetool&lt;/code&gt; 的mergetool 。</target>
        </trans-unit>
        <trans-unit id="12b13d31e8066018bcde449f67345b7bfcf52de0" translate="yes" xml:space="preserve">
          <source>to remove local files</source>
          <target state="translated">移除本地文件</target>
        </trans-unit>
        <trans-unit id="d110ecc4bf5aa685f91d30ec3d951d336ba2b9a9" translate="yes" xml:space="preserve">
          <source>to totally reset branch</source>
          <target state="translated">重设分支</target>
        </trans-unit>
        <trans-unit id="14a4e920d1a119c78726be84a2502584abc89313" translate="yes" xml:space="preserve">
          <source>was underrated (&lt;strong&gt;-d&lt;/strong&gt; to remove directories).
Thanks!</source>
          <target state="translated">被低估了（ &lt;strong&gt;-d&lt;/strong&gt;删除目录）。 谢谢！</target>
        </trans-unit>
        <trans-unit id="7212db004bf9a51e42dafe5bd156f27109417202" translate="yes" xml:space="preserve">
          <source>xkcd: Git</source>
          <target state="translated">xkcd:Git</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
