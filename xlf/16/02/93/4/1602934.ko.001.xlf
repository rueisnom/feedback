<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1602934">
    <body>
      <group id="1602934">
        <trans-unit id="591133f53078cffc847dc0eb75e14301e71ff3a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/reference/expressions.html#membership-test-operations&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; is the intended way to test for the existence of a key in a &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/reference/expressions.html#membership-test-operations&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; 에&lt;/a&gt; 키가 있는지 테스트하는 의도 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6963ef6ef133fe63667bae98c4e406849bc2b0b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/1835756/using-try-vs-if-in-python&quot;&gt;Using try vs if in python&lt;/a&gt; or</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/1835756/using-try-vs-if-in-python&quot;&gt;파이썬에서 try vs if 사용&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37b6a58bff6459d250b5618cc7f15d7cf23b5741" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'key' in mydict&lt;/code&gt; elapsed time 1.07 sec</source>
          <target state="translated">&lt;code&gt;'key' in mydict&lt;/code&gt; 경과 시간 1.07 초</target>
        </trans-unit>
        <trans-unit id="fd392cfe1ec3c98a6d2529fdab4d41b86b354b19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mydefaultdict['key']&lt;/code&gt; elapsed time 1.07 sec</source>
          <target state="translated">&lt;code&gt;mydefaultdict['key']&lt;/code&gt; 경과 시간 1.07 초</target>
        </trans-unit>
        <trans-unit id="b29aa702799125fbd0589e7ef5d2e064481139d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mydict.get('key')&lt;/code&gt; elapsed time 1.84 sec</source>
          <target state="translated">&lt;code&gt;mydict.get('key')&lt;/code&gt; 경과 시간 1.84 초</target>
        </trans-unit>
        <trans-unit id="f6212b6b8989c362a666b41eb2f00aad1c711918" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dbbced910ce854ef29e677d7d9fe10e6bc54a9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The ways in which you can get the results are:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;결과를 얻는 방법은 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25c6f0ca130fb1ad84b8dd117a322ea04fa9daa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Which is better is dependent on 3 things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어느 쪽이 더 좋은지 3 가지에 달려 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a5f8bb504046f62fd121ff29978b6d94fa221f7" translate="yes" xml:space="preserve">
          <source>A common use for checking the existence of a key in a dictionary before mutating it is to default-initialize the value (e.g. if your values are lists, for example, and you want to ensure that there is an empty list to which you can append when inserting the first value for a key). In cases such as those, you may find the &lt;a href=&quot;https://docs.python.org/2/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;collections.defaultdict()&lt;/code&gt;&lt;/a&gt; type to be of interest.</source>
          <target state="translated">키를 변경하기 전에 사전에 키가 있는지 확인하는 일반적인 용도는 값을 기본값으로 초기화하는 것입니다 (예 : 값이 목록 인 경우 추가 할 수있는 빈 목록이 있는지 확인하려는 경우). 키의 첫 번째 값을 삽입 할 때). 그러한 경우 &lt;a href=&quot;https://docs.python.org/2/library/collections.html#collections.defaultdict&quot;&gt; &lt;code&gt;collections.defaultdict()&lt;/code&gt; &lt;/a&gt; 유형이 관심을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="986783231c059d9ed27a2c92fbece3a44392d398" translate="yes" xml:space="preserve">
          <source>But if we switch the order &lt;code&gt;1/0&lt;/code&gt; is evaluated first and raises an exception:</source>
          <target state="translated">그러나 스위치를 &lt;code&gt;1/0&lt;/code&gt; 순서가 먼저 평가되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db389597cb0d96c4bc635cdf63b287dc51ef4eee" translate="yes" xml:space="preserve">
          <source>Check if a given key already exists in a dictionary</source>
          <target state="translated">주어진 키가 사전에 이미 존재하는지 확인</target>
        </trans-unit>
        <trans-unit id="3394968f476faed3131c00e48a0c1e7a6b9f966a" translate="yes" xml:space="preserve">
          <source>Checking for member existence in Python</source>
          <target state="translated">파이썬에서 멤버 존재 확인</target>
        </trans-unit>
        <trans-unit id="d85116e736c56c2c067bdfa4d989248051196be9" translate="yes" xml:space="preserve">
          <source>Dictionary in python has a get('key', default) method. So you can just set a default value in case there is no key.</source>
          <target state="translated">파이썬의 사전에는 get ( 'key', default) 메소드가 있습니다. 따라서 키가없는 경우 기본값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597258f905b6cbfadef9e590bf4094627436fcd4" translate="yes" xml:space="preserve">
          <source>Do you intend to use conditions like if...else...elseif...else?</source>
          <target state="translated">if ... else ... elseif ... else와 같은 조건을 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="45f145997d62a4abb975be326b0c4cc692e411f0" translate="yes" xml:space="preserve">
          <source>Does the dictionary 'normally has the key' or 'normally does not have the key'.</source>
          <target state="translated">사전에 '일반적으로 키가 있습니다'또는 '일반적으로 키가 없습니다'</target>
        </trans-unit>
        <trans-unit id="ec93c8dd4fefc64c37ffb2971b2fb28f6625471a" translate="yes" xml:space="preserve">
          <source>First you should know that in Python, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt;, or objects with zero length evaluate to &lt;code&gt;False&lt;/code&gt;. Everything else evaluates to &lt;code&gt;True&lt;/code&gt;. Boolean operations are evaluated left to right and return the operand not True or False.</source>
          <target state="translated">먼저 파이썬에서 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 또는 길이가 0 인 객체는 &lt;code&gt;False&lt;/code&gt; 로 평가됩니다. 다른 모든 것은 &lt;code&gt;True&lt;/code&gt; 로 평가됩니다. 부울 연산은 왼쪽에서 오른쪽으로 평가되며 True 또는 False가 아닌 피연산자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cb3c2b1adb4fd7a61c8aedca10b82c1b2246fc5" translate="yes" xml:space="preserve">
          <source>For additional info on speed execution of the accepted answer's proposed methods (10m loops):</source>
          <target state="translated">허용 된 답변의 제안 된 방법 (10m 루프)의 실행 속도에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="1f55b895719e821df4e24a8718fb9c2d6b3f0a02" translate="yes" xml:space="preserve">
          <source>How big is dictionary?</source>
          <target state="translated">사전은 얼마나 큽니까?</target>
        </trans-unit>
        <trans-unit id="44007472c1a02e9d9e51e304d75c2b7f0839aa16" translate="yes" xml:space="preserve">
          <source>However, this is at best a cosmetic improvement. Why do you believe this is not the best way?</source>
          <target state="translated">그러나 이것은 외관상으로는 개선입니다. 이것이 최선의 방법이 아니라고 왜 생각하십니까?</target>
        </trans-unit>
        <trans-unit id="3eb163b93c81be2eb82b5902f369e06977660d2a" translate="yes" xml:space="preserve">
          <source>I think this is not the best way to accomplish this task. Is there a better way to test for a key in the dictionary?</source>
          <target state="translated">이것이이 작업을 수행하는 가장 좋은 방법은 아니라고 생각합니다. 사전에서 키를 테스트하는 더 좋은 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="f19123e3b7e09f32bea0ab8fc1b66aec7f6582c3" translate="yes" xml:space="preserve">
          <source>I wanted to test if a key exists in a dictionary before updating the value for the key.
I wrote the following code:</source>
          <target state="translated">키 값을 업데이트하기 전에 사전에 키가 있는지 테스트하고 싶었습니다. 다음 코드를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="0ab009ba67ac8d9c77d1dca6bbfd97ddf9830903" translate="yes" xml:space="preserve">
          <source>I would recommend using the &lt;code&gt;setdefault&lt;/code&gt; method instead.  It sounds like it will do everything you want.</source>
          <target state="translated">대신 &lt;code&gt;setdefault&lt;/code&gt; 메소드를 사용하는 것이 좋습니다. 그것은 당신이 원하는 모든 것을 할 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f8257c264f760967737186d45bc0e3ad7219721" translate="yes" xml:space="preserve">
          <source>If you wanted a default, you can always use &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#dict.get&quot;&gt;&lt;code&gt;dict.get()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본값을 원하면 항상 &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#dict.get&quot;&gt; &lt;code&gt;dict.get()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ddfb8843f832ad1bb60ea13075731e0f75356d" translate="yes" xml:space="preserve">
          <source>In older code, you may also find some uses of &lt;code&gt;has_key()&lt;/code&gt;, a deprecated method for checking the existence of keys in dictionaries (just use &lt;code&gt;key_name in dict_name&lt;/code&gt;, instead).</source>
          <target state="translated">이전 코드에서는 사전에 키의 존재를 확인하는 데 사용되지 않는 &lt;code&gt;has_key()&lt;/code&gt; 사용이 있습니다 (대신 &lt;code&gt;key_name in dict_name&lt;/code&gt; 에서 key_name 사용).</target>
        </trans-unit>
        <trans-unit id="acf951feab09154bb41a958d736dbe4d074e6f27" translate="yes" xml:space="preserve">
          <source>Just an FYI adding to Chris. B (best answer):</source>
          <target state="translated">크리스에 덧붙이는 것만으로 B (최고의 답변) :</target>
        </trans-unit>
        <trans-unit id="c6b2adcaea916728f52e79fb66215b5050684050" translate="yes" xml:space="preserve">
          <source>Leading that &lt;code&gt;get()&lt;/code&gt; method is not reliable in case some values may be &lt;code&gt;None&lt;/code&gt;.
This story should have a happier ending. If we use the &lt;code&gt;in&lt;/code&gt; comparator:</source>
          <target state="translated">일부 값이 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;code&gt;get()&lt;/code&gt; 메소드를 신뢰할 수 없습니다 . 이 이야기는 더 행복한 결말을 가져야합니다. &lt;code&gt;in&lt;/code&gt; 비교기를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7be4a4f8fe8c136ea1812aa5ff5433b439cc6d5a" translate="yes" xml:space="preserve">
          <source>Let's see an example:</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="993d8f252026b3dea07d43c4267889099c7bd84f" translate="yes" xml:space="preserve">
          <source>Printing shows the key we don't have will return &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">인쇄하지 않은 키는 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="38f76c76e34de8eb1621bdb354a4c109e558159c" translate="yes" xml:space="preserve">
          <source>Python 2 only: (and python 2.7 supports &lt;code&gt;in&lt;/code&gt; already)</source>
          <target state="translated">파이썬 2 만 : (그리고 파이썬 2.7은 이미 지원합니다)</target>
        </trans-unit>
        <trans-unit id="080797e8a082de132d48286d667c038b33d8e9d7" translate="yes" xml:space="preserve">
          <source>Python dictionary has the method called &lt;code&gt;__contains__&lt;/code&gt;. This method will return True if the dictionary has the key else returns False.</source>
          <target state="translated">파이썬 사전에는 &lt;code&gt;__contains__&lt;/code&gt; 라는 메소드가 있습니다 . 사전에 키가 있으면이 메소드는 True를 리턴하고 그렇지 않으면 False를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="49610401a99726c011a79d7137edab7af0d3aab3" translate="yes" xml:space="preserve">
          <source>Read More: &lt;a href=&quot;http://paltman.com/try-except-performance-in-python-a-simple-test/&quot;&gt;http://paltman.com/try-except-performance-in-python-a-simple-test/&lt;/a&gt;</source>
          <target state="translated">더 읽기 : &lt;a href=&quot;http://paltman.com/try-except-performance-in-python-a-simple-test/&quot;&gt;http://paltman.com/try-except-performance-in-python-a-simple-test/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="959839b5e07b00dff497613be230a572d05b3cd7" translate="yes" xml:space="preserve">
          <source>See other SO posts:</source>
          <target state="translated">다른 SO 게시물보기 :</target>
        </trans-unit>
        <trans-unit id="0833f8d908412fdbaea4b03ab31dbc79c781e880" translate="yes" xml:space="preserve">
          <source>Sharing one more way of checking if a key exists using boolean operators.</source>
          <target state="translated">부울 연산자를 사용하여 키가 있는지 확인하는 또 다른 방법을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="9f9da45eb445a1f8a9232e3da98c666643520ad1" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;'Some string'&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, the rest of the &lt;code&gt;or&lt;/code&gt; is not evaluated and there is no division by zero error raised.</source>
          <target state="translated">&lt;code&gt;'Some string'&lt;/code&gt; 은 &lt;code&gt;True&lt;/code&gt; 로 평가되므로 &lt;code&gt;or&lt;/code&gt; 의 나머지 부분은 평가되지 않으며 0으로 나누기 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81600a48b25d678645efb38986980180321afdda" translate="yes" xml:space="preserve">
          <source>That will be much &lt;a href=&quot;https://stackoverflow.com/a/30527984/452708&quot;&gt;faster&lt;/a&gt; as it uses the dictionary's hashing as opposed to doing a linear search, which calling keys would do.</source>
          <target state="translated">호출 키가 수행하는 선형 검색을 수행하는 대신 사전의 해싱을 사용하므로 훨씬 &lt;a href=&quot;https://stackoverflow.com/a/30527984/452708&quot;&gt;빠릅니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb8d1e6235c48f2b9fc10152fef4fe7a0107f3f" translate="yes" xml:space="preserve">
          <source>The brutal method to check if the key already exists may be the &lt;code&gt;get()&lt;/code&gt; method:</source>
          <target state="translated">키가 이미 있는지 확인하는 잔인한 메소드는 &lt;code&gt;get()&lt;/code&gt; 메소드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8af6196482458212eb3bbdeb73e052d378f1c8a" translate="yes" xml:space="preserve">
          <source>The other two &lt;em&gt;interesting&lt;/em&gt; methods &lt;code&gt;items()&lt;/code&gt; and &lt;code&gt;keys()&lt;/code&gt; sounds like too much of work. So let's examine if &lt;code&gt;get()&lt;/code&gt; is the right method for us. We have our dict &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">다른 두 가지 &lt;em&gt;재미있는&lt;/em&gt; 메소드 &lt;code&gt;items()&lt;/code&gt; 및 &lt;code&gt;keys()&lt;/code&gt; 는 너무 많은 작업처럼 들립니다. &lt;code&gt;get()&lt;/code&gt; 이 우리에게 적합한 방법인지 살펴 보자. 우리는 우리의 dict &lt;code&gt;d&lt;/code&gt; 를 가진다 :</target>
        </trans-unit>
        <trans-unit id="2515071735ea713c92dc72d142b87e9dc2f70cb7" translate="yes" xml:space="preserve">
          <source>Therefore using &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;defaultdict&lt;/code&gt; are recommended against &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;defaultdict&lt;/code&gt; 또는 defaultdict를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32f82939a7bf703c0f0f37c6aeb1bb86ba05c657" translate="yes" xml:space="preserve">
          <source>This already returns the correct result if the key exists, but we want it to print 'boo' when it doesn't. So, we take the result and &lt;code&gt;or&lt;/code&gt; it with &lt;code&gt;'boo'&lt;/code&gt;</source>
          <target state="translated">키가 존재하면 이미 올바른 결과를 반환하지만 그렇지 않은 경우 'boo'를 인쇄하려고합니다. 따라서 결과를 가져 &lt;code&gt;or&lt;/code&gt; &lt;code&gt;'boo'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0da9aa61c73d25f489970427f2fef58028ae1332" translate="yes" xml:space="preserve">
          <source>This returns</source>
          <target state="translated">이 반환</target>
        </trans-unit>
        <trans-unit id="21c7fc5c32908dd98a28d125a39c2e97f43e40c3" translate="yes" xml:space="preserve">
          <source>This shows that &lt;code&gt;in&lt;/code&gt; compare operator is not just more reliable but even faster than &lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">이것은 비교 연산자가 &lt;code&gt;get()&lt;/code&gt; 보다 더 안정적 일뿐만 아니라 더 빠르다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="784a92c5855dcd7bc19f620b812fc2a93c5f4d9c" translate="yes" xml:space="preserve">
          <source>To get the idea how to do that we first inspect what methods we can call on dictionary. 
Here are the methods:</source>
          <target state="translated">이를 수행하는 방법을 이해하려면 먼저 사전에서 호출 할 수있는 메소드를 검사하십시오. 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0e6cbf4ab0d570d019e9935381dd23e4e25aeb3" translate="yes" xml:space="preserve">
          <source>Use of try/block instead of 'in' or 'if':</source>
          <target state="translated">'in'또는 'if'대신 try / block 사용 :</target>
        </trans-unit>
        <trans-unit id="dd538b76338c3923d174ce59c61689b16b2b7666" translate="yes" xml:space="preserve">
          <source>Using ternary operator:</source>
          <target state="translated">삼항 연산자 사용 :</target>
        </trans-unit>
        <trans-unit id="4b8581247344e93f156dff6ff29725a4fd4c9abb" translate="yes" xml:space="preserve">
          <source>We &lt;strike&gt;may&lt;/strike&gt; use that to get the info if the key is present or no.
But consider this if we create a dict with a single &lt;code&gt;key:None&lt;/code&gt;:</source>
          <target state="translated">키가 있거나없는 경우 정보를 얻기 위해 사용할 &lt;strike&gt;수&lt;/strike&gt; 있습니다. 그러나 하나의 &lt;code&gt;key:None&lt;/code&gt; dict를 만들면 이것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7553a658793106d4d6cddd5b9191049f46bd231c" translate="yes" xml:space="preserve">
          <source>We can use this for pattern for checking if a key exists.</source>
          <target state="translated">키가 있는지 확인하기 위해 패턴에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a10209f0453ba456711a491938cc4be7a0cfbe" translate="yes" xml:space="preserve">
          <source>We get the correct results.
We may examine the Python byte code:</source>
          <target state="translated">올바른 결과를 얻습니다. 파이썬 바이트 코드를 살펴볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f2238e9d8603a636e603f54f0a3a44b2fd4a4444" translate="yes" xml:space="preserve">
          <source>What about using EAFP (easier to ask forgiveness than permission):</source>
          <target state="translated">EAFP를 사용하는 것은 어떻습니까 (허가보다 용서를 구하는 것이 더 쉬움)</target>
        </trans-unit>
        <trans-unit id="b04b9520c2509e7702cdd5d418566569a968c827" translate="yes" xml:space="preserve">
          <source>Works as well; the reason is that calling &lt;code&gt;int()&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt; which is what &lt;code&gt;defaultdict&lt;/code&gt; does behind the scenes (when constructing a dictionary), hence the name &quot;Factory Function&quot; in the documentation.</source>
          <target state="translated">잘 작동합니다. 그 이유는 &lt;code&gt;int()&lt;/code&gt; 를 호출하면 &lt;code&gt;defaultdict&lt;/code&gt; 가 씬 뒤에서 (사전을 구성 할 때) 수행하는 &lt;code&gt;0&lt;/code&gt; 을 반환하므로 문서에서 &quot;Factory Function&quot;이라는 이름이 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="520e8e00a3b3d87e7647d8bcea9edffedf68d4f2" translate="yes" xml:space="preserve">
          <source>You can shorten this:</source>
          <target state="translated">이것을 줄일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9ed54184f5a6ef98cc59b61b34b4cb0ced213ea7" translate="yes" xml:space="preserve">
          <source>You can test for the presence of a key in a dictionary, using the &lt;b&gt;in&lt;/b&gt; keyword:</source>
          <target state="translated">&lt;b&gt;in&lt;/b&gt; 키워드를 사용하여 사전에 키가 있는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65dfdbf567991222587b5a44ca8a9c9ed717131c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;for&lt;/code&gt; loop to iterate over the dictionary and get the name of key you want to find in the dictionary, after that check if it exist or not using &lt;code&gt;if&lt;/code&gt; condition:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프를 사용하여 사전을 반복하고 사전에서 찾으려는 키 이름을 가져온 다음 &lt;code&gt;if&lt;/code&gt; 조건을 사용 하는지 확인한 후 사전에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64db6e76183d314faddc5c2fc7cf9a2d4a26c2ba" translate="yes" xml:space="preserve">
          <source>You don't have to call keys:</source>
          <target state="translated">키를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c170f5dffece2e3429d2c4755d32ab7c1e743125" translate="yes" xml:space="preserve">
          <source>and if you wanted to always ensure a default value for any key you can either use &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#dict.setdefault&quot;&gt;&lt;code&gt;dict.setdefault()&lt;/code&gt;&lt;/a&gt; repeatedly or &lt;a href=&quot;https://docs.python.org/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;defaultdict&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://docs.python.org/library/collections.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module, like so:</source>
          <target state="translated">그리고 항상 모든 키의 기본값을 유지하려면 &lt;a href=&quot;https://docs.python.org/library/stdtypes.html#dict.setdefault&quot;&gt; &lt;code&gt;dict.setdefault()&lt;/code&gt; &lt;/a&gt; 반복적으로 사용하거나 &lt;a href=&quot;https://docs.python.org/library/collections.html&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈에서 &lt;a href=&quot;https://docs.python.org/library/collections.html#collections.defaultdict&quot;&gt; &lt;code&gt;defaultdict&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1363255c883a43efc82e3f7cd7da252ef14831" translate="yes" xml:space="preserve">
          <source>but in general, the &lt;code&gt;in&lt;/code&gt; keyword is the best way to do it.</source>
          <target state="translated">그러나 일반적으로 &lt;code&gt;in&lt;/code&gt; 키워드가 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a588f054b06e774ef540898967245cf42a31de55" translate="yes" xml:space="preserve">
          <source>does the same as</source>
          <target state="translated">와 동일</target>
        </trans-unit>
        <trans-unit id="666c6917b6725a9873afc00e1a7d06a7735106bb" translate="yes" xml:space="preserve">
          <source>if key in your_dict</source>
          <target state="translated">your_dict의 키가</target>
        </trans-unit>
        <trans-unit id="586132887331bf673c22801c8949d0629ccede8a" translate="yes" xml:space="preserve">
          <source>if your_dict.has_key(key) &lt;a href=&quot;https://docs.python.org/3.1/whatsnew/3.0.html#builtins&quot;&gt;Removed in Python 3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.1/whatsnew/3.0.html#builtins&quot;&gt;파이썬 3에서&lt;/a&gt; your_dict.has_key (key)가 제거 된 경우</target>
        </trans-unit>
        <trans-unit id="efd3e0cfee814627e24cdcfb5f19dda53a7728b7" translate="yes" xml:space="preserve">
          <source>try/except block</source>
          <target state="translated">시도 / 제외 블록</target>
        </trans-unit>
        <trans-unit id="c518722a87413e94197bd3998aa67b5f598adede" translate="yes" xml:space="preserve">
          <source>you can use the has_key() method:</source>
          <target state="translated">has_key () 메소드를 사용할 수 있습니다 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
