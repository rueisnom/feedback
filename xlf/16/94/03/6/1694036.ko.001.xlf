<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1694036">
    <body>
      <group id="1694036">
        <trans-unit id="e97568ea4e112041c0cb6599eb15f6a2a791148f" translate="yes" xml:space="preserve">
          <source>&amp;sect;6.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">&amp;sect;6.5.4.1 &lt;code&gt;gets_s&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="17518df0b5ea550ff0f27d57a4b252bf26d11988" translate="yes" xml:space="preserve">
          <source>(.text+0x34): warning: the `gets' function is dangerous and should not be used.</source>
          <target state="translated">(.text + 0x34) : 경고 :`gets '함수는 위험하므로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c800bf27a5a07d0fefadb5b1a5ecd4f9f2ac70f1" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;fgets&lt;/code&gt;, if it reads an entire line, will leave the &lt;code&gt;'\n'&lt;/code&gt; in the string; you'll have to deal with that.)</source>
          <target state="translated">( &lt;code&gt;fgets&lt;/code&gt; 는 전체 행을 읽으면 문자열에 &lt;code&gt;'\n'&lt;/code&gt; 을 남겨 둡니다. 그러면 처리해야합니다.)</target>
        </trans-unit>
        <trans-unit id="6bc1be7c21ad64a2f919728d4a8f72e29bd67349" translate="yes" xml:space="preserve">
          <source>3 If there is a runtime-constraint violation, &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and characters
  are read and discarded from &lt;code&gt;stdin&lt;/code&gt; until a new-line character is read, or end-of-file or a
  read error occurs.</source>
          <target state="translated">3 런타임 제약 조건 위반이있는 경우 &lt;code&gt;s[0]&lt;/code&gt; 이 널 문자로 설정되고 개행 문자를 읽거나 파일 끝 또는 읽기 오류가 발생할 때까지 문자를 &lt;code&gt;stdin&lt;/code&gt; 에서 읽고 버립니다.</target>
        </trans-unit>
        <trans-unit id="2c6b11246694e0a53c8eaef6d402a2f6d483a210" translate="yes" xml:space="preserve">
          <source>4 The &lt;code&gt;gets_s&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt;
  from the stream pointed to by &lt;code&gt;stdin&lt;/code&gt;, into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional
  characters are read after a new-line character (which is discarded) or after end-of-file.
  The discarded new-line character does not count towards number of characters read. A
  null character is written immediately after the last character read into the array.</source>
          <target state="translated">4 &lt;code&gt;gets_s&lt;/code&gt; 함수는 &lt;code&gt;stdin&lt;/code&gt; 에 의해 지시 된 스트림에서 &lt;code&gt;s&lt;/code&gt; 에 의해 지시 된 배열로 &lt;code&gt;n&lt;/code&gt; 에 의해 지정된 문자 수보다 최대 1 개 적은 문자를 읽습니다. 줄 바꿈 문자 (폐기) 이후 또는 파일 끝 이후에는 추가 문자를 읽을 수 없습니다. 버려진 개행 문자는 읽은 문자 수에 포함되지 않습니다. 널 문자는 마지막 문자를 배열로 읽은 직후에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="871d5200809b27e3005fc171c5add16863eb429c" translate="yes" xml:space="preserve">
          <source>5 If end-of-file is encountered and no characters have been read into the array, or if a read
  error occurs during the operation, then &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and the other
  elements of &lt;code&gt;s&lt;/code&gt; take unspecified values.</source>
          <target state="translated">5 파일 끝이 발견되고 배열로 읽은 문자가 없거나 조작 중에 읽기 오류가 발생하면 &lt;code&gt;s[0]&lt;/code&gt; 이 널 문자로 설정되고 &lt;code&gt;s&lt;/code&gt; 의 다른 요소는 지정되지 않은 값을 갖습니다. .</target>
        </trans-unit>
        <trans-unit id="ed163a0ef4f509855327416f1f2b9ccda77aeeb8" translate="yes" xml:space="preserve">
          <source>6 The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">6 &lt;code&gt;fgets&lt;/code&gt; 기능을 사용하면 올바르게 작성된 프로그램이 입력 배열을 너무 길어 결과 배열에 저장하기에 너무 안전하게 처리 할 수 ​​있습니다. 일반적으로 &lt;code&gt;fgets&lt;/code&gt; 호출자는 결과 배열에 개행 문자가 있는지 여부에주의를 기울여야합니다. &lt;code&gt;gets_s&lt;/code&gt; 대신 &lt;code&gt;fgets&lt;/code&gt; 를 사용하십시오 (줄 바꾸기 문자를 기반으로 필요한 처리와 함께).</target>
        </trans-unit>
        <trans-unit id="d0d48e496596a430fc0e8ae6d905f708329be4d7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c82c7b8bf8ffe3eb68fdc9b9a00c4519c5ff30ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fgets()&lt;/code&gt; allows you to specify how many characters are taken out of the standard input buffer, so they don't overrun the variable.</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; 사용하면 표준 입력 버퍼에서 몇 개의 문자를 가져 와서 변수를 오버런하지 않도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bf95efd9191a7a3774dd9d7416afbf3b8c75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</source>
          <target state="translated">&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</target>
        </trans-unit>
        <trans-unit id="8159d16eefb5f350c2e02c79e3cecfbaf46ad0cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gets()&lt;/code&gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can't detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person's name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 는 사용자가 프롬프트에 너무 많이 입력하여 프로그램을 중단시킬 수 있기 때문에 위험합니다. 사용 가능한 메모리의 끝을 감지 할 수 없으므로 목적에 비해 너무 적은 양의 메모리를 할당하면 세그먼트 오류 및 충돌이 발생할 수 있습니다. 때때로 사용자가 사람의 이름을 알리는 프롬프트에 1000자를 입력 할 가능성은 거의 없지만 프로그래머는 프로그램을 방탄으로 만들어야합니다. (사용자가 너무 많은 데이터를 보내 시스템 프로그램을 중단시킬 수있는 경우 보안 위험이있을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="6adcc51eed96f7c3fbc2eba2e501ef8ab2436d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; shall not be a null pointer. &lt;code&gt;n&lt;/code&gt; shall neither be equal to zero nor be greater than
  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading
  &lt;code&gt;n-1&lt;/code&gt; characters from &lt;code&gt;stdin&lt;/code&gt;.&lt;sup&gt;25)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 는 널 포인터가 아니어야합니다. &lt;code&gt;n&lt;/code&gt; 은 0과 같거나 RSIZE_MAX보다 크지 않아야합니다. 개행 문자, 파일 끝 또는 읽기 오류는 &lt;code&gt;stdin&lt;/code&gt; 에서 &lt;code&gt;n-1&lt;/code&gt; 문자를 읽을 때 발생합니다. &lt;sup&gt;25)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32999174ab5c86638eab236eddb300aaa124ae76" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;25)&lt;/sup&gt; The &lt;code&gt;gets_s&lt;/code&gt; function, unlike &lt;code&gt;gets&lt;/code&gt;, makes it a runtime-constraint violation for a line of input to
  overflow the buffer to store it. Unlike &lt;code&gt;fgets&lt;/code&gt;, &lt;code&gt;gets_s&lt;/code&gt; maintains a one-to-one relationship between
  input lines and successful calls to &lt;code&gt;gets_s&lt;/code&gt;. Programs that use &lt;code&gt;gets&lt;/code&gt; expect such a relationship.</source>
          <target state="translated">&lt;sup&gt;25)&lt;/sup&gt; &lt;code&gt;gets_s&lt;/code&gt; 함수는 &lt;code&gt;gets&lt;/code&gt; 와 달리 입력 라인이 버퍼를 오버플로하여 저장하기 위해 런타임 제약 조건 위반을 만듭니다. &lt;code&gt;fgets&lt;/code&gt; 와 달리 &lt;code&gt;gets_s&lt;/code&gt; 는 입력 라인과 &lt;code&gt;gets_s&lt;/code&gt; 에 대한 성공적인 호출 간의 일대일 관계를 유지합니다. 사용하는 프로그램은 그러한 관계를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="d47deb2fa418026ef69328b4feb307c797055743" translate="yes" xml:space="preserve">
          <source>Also, as &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; points out in a comment and &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; shows in his answer, with &lt;code&gt;fgets()&lt;/code&gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:</source>
          <target state="translated">또한 &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; 가 주석에서 지적하고 &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; 가 그의 대답에 표시하는 것처럼 &lt;code&gt;fgets()&lt;/code&gt; 하면 줄에 데이터가 남아있을 수 있습니다. 래퍼 코드는 다음에 해당 데이터를 읽습니다. 원하는 경우 나머지 데이터 라인을 고치기 위해 쉽게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a577c69baeea75db56ec2bf55a2c47ccbe72969" translate="yes" xml:space="preserve">
          <source>Alternatives to &lt;code&gt;gets()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 대안</target>
        </trans-unit>
        <trans-unit id="dacdb797ba8e8e112d387210f5fd7a4b54c331cd" translate="yes" xml:space="preserve">
          <source>As everyone else said, the canonical alternative to &lt;code&gt;gets()&lt;/code&gt; is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; specifying &lt;code&gt;stdin&lt;/code&gt; as the file stream.</source>
          <target state="translated">다른 사람들이 말했듯이 &lt;code&gt;gets()&lt;/code&gt; 대한 표준 대안은 &lt;code&gt;stdin&lt;/code&gt; 을 파일 스트림으로 지정하는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt; &lt;code&gt;fgets()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="276cab09e51e47a855dc9b87ab1220f1023257fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;gets&lt;/code&gt; doesn't do any kind of check while getting bytes from &lt;em&gt;stdin&lt;/em&gt; and putting them somewhere. A simple example:</source>
          <target state="translated">&lt;code&gt;gets&lt;/code&gt; 는 &lt;em&gt;stdin&lt;/em&gt; 에서 바이트를 가져 와서 어딘가에 두는 동안 어떤 종류의 검사도 수행하지 않기 때문입니다. 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="f2c96493dd9f7f0a24eaac18c571948408967130" translate="yes" xml:space="preserve">
          <source>But this also has its problems such as:</source>
          <target state="translated">그러나 이것은 또한 다음과 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="375f5f535aa6378b6f0ddc609d99ec61fd2fc369" translate="yes" xml:space="preserve">
          <source>C11 K.3.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">C11 K.3.5.4.1 &lt;code&gt;gets_s&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e0e37d77940442881c3ecdeeb4e63ff793130daf" translate="yes" xml:space="preserve">
          <source>Feel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)</source>
          <target state="translated">당신이 원하는대로 자유롭게 사용하십시오, 나는 &quot;당신이 원하는 것을하세요&quot;라이센스하에 배포합니다 :-)</target>
        </trans-unit>
        <trans-unit id="24320b942db7d03958da6d14023db94004c68712" translate="yes" xml:space="preserve">
          <source>Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I'd be prepared to add an error message:</source>
          <target state="translated">어쨌든 코드가 조만간 충돌 할 수 있으므로 문제를 빨리 해결하는 것이 좋습니다. 오류 메시지를 추가 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b2a1c70a047d18fa7bb41b678bcbfccc91d6d372" translate="yes" xml:space="preserve">
          <source>Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of 'programmer freedom'.</source>
          <target state="translated">잘하면 이것이 전체 대화에 대한 당신의 식욕을 자극 할 것입니다. 이것은 우리가 언어로보다 공식적인 정확성 증명이 필요한 방법과 언어 디자이너가 프로그래머가 아닌 그들의 언어로 인한 실수에 대해 비난받는 방법에주의를 기울입니다. 이것은 나쁜 언어의 설계자들이 프로그래머의 책임을 '프로그래머의 자유'라는 시각으로 프로그래머에게 전가해야하는 모호한 이유 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="271cb448109ee99e001bef107a8f3bc50b2b6f84" translate="yes" xml:space="preserve">
          <source>How can I remove this warning and why is there such a warning about using &lt;code&gt;gets()&lt;/code&gt;?</source>
          <target state="translated">이 경고를 어떻게 제거 할 수 있습니까? 왜 &lt;code&gt;gets()&lt;/code&gt; 사용에 대한 경고 가 있습니까?</target>
        </trans-unit>
        <trans-unit id="e4ba164e3701105ccec7d9eab6ba69fc62d2fc45" translate="yes" xml:space="preserve">
          <source>However, in the &lt;em&gt;Recommended practice&lt;/em&gt; section, &lt;code&gt;fgets()&lt;/code&gt; is still preferred.</source>
          <target state="translated">그러나 &lt;em&gt;권장 연습&lt;/em&gt; 섹션에서 &lt;code&gt;fgets()&lt;/code&gt; 가 여전히 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="d5f1326537bd1a67f425e3007ee099675175abbb" translate="yes" xml:space="preserve">
          <source>I read recently, in a &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;USENET post to &lt;code&gt;comp.lang.c&lt;/code&gt;&lt;/a&gt;, that &lt;code&gt;gets()&lt;/code&gt; is getting removed from the Standard. &lt;strong&gt;WOOHOO&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt; &lt;code&gt;comp.lang.c&lt;/code&gt; &lt;/a&gt; 의 USENET 게시물 에서 최근에 &lt;code&gt;gets()&lt;/code&gt; 가 표준에서 제거되고 있습니다. &lt;strong&gt;우 호우&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eceb5f707de5da0dab443da03e3e6e5e41328764" translate="yes" xml:space="preserve">
          <source>I remember this has something to do with stack protection and security, but I'm not sure exactly why.</source>
          <target state="translated">나는 이것이 스택 보호 및 보안과 관련이 있다는 것을 기억하지만 정확히 왜 그런지 잘 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="9a0c616272856956300d35a22b16fc991d07f8ca" translate="yes" xml:space="preserve">
          <source>I would like to extend an earnest invitation to any C library maintainers out there who are still including &lt;code&gt;gets&lt;/code&gt; in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of</source>
          <target state="translated">&quot;아직도 라이브러리에 의존하는 경우를 위해&quot;라이브러리에 여전히 포함되어있는 C 라이브러리 관리자에게 진지한 초대를하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7bf781506125edfc033141ab72812799f2999203" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gets()&lt;/code&gt; is so dangerous then why can't we remove it?</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 가 너무 위험한 경우 왜 제거 할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="2225f53902789cdbd60c62ef1ae2f7be501676f7" translate="yes" xml:space="preserve">
          <source>In C11(ISO/IEC 9899:201x), &lt;code&gt;gets()&lt;/code&gt; has been removed. (It's deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))</source>
          <target state="translated">C11 (ISO / IEC 9899 : 201x)에서 &lt;code&gt;gets()&lt;/code&gt; 가 제거되었습니다. (ISO / IEC 9899 : 1999 / Cor.3 : 2007 (E)에서 사용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="84611e142406e2872460af2270761a3dcd9aedd8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;fgets()&lt;/code&gt;, C11 introduces a new safe alternative &lt;code&gt;gets_s()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; 외에도 C11에는 새로운 안전한 대안 &lt;code&gt;gets_s()&lt;/code&gt; 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="5163be8673258f548a47017b937adce7bc283e33" translate="yes" xml:space="preserve">
          <source>In fact, ISO have actually taken the step of &lt;em&gt;removing&lt;/em&gt;&lt;code&gt;gets&lt;/code&gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.</source>
          <target state="translated">실제로 ISO는 실제로 C 표준에서 &lt;code&gt;gets&lt;/code&gt; 오기를 &lt;em&gt;제거&lt;/em&gt; 하는 단계를 &lt;em&gt;밟았&lt;/em&gt; 습니다 (C99에서는 더 이상 사용되지 않지만 C99에서는 더 이상 사용되지 않음). 이전 버전과의 호환성이 얼마나 높은지에 따라 해당 기능이 얼마나 나쁜지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fc19320a49a091fc199629c4ede2786469111688" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;gets&lt;/code&gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.</source>
          <target state="translated">안전하게 사용하기 위해서는 읽을 문자 수를 정확히 알아야 버퍼를 충분히 크게 만들 수 있습니다. 어떤 데이터를 읽을 것인지 정확히 아는 경우에만 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fde1f90e44e07a8abd3fce0c7724c0e1eae3b60" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;gets&lt;/code&gt;, you want to use &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt;&lt;code&gt;fgets&lt;/code&gt;&lt;/a&gt;, which has the signature</source>
          <target state="translated">&lt;code&gt;gets&lt;/code&gt; 를 사용하는 대신 서명이있는 &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;/a&gt; 를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="98bc71dac689b4fcfc909ec3933e5b117578f4fe" translate="yes" xml:space="preserve">
          <source>It provides the same protections as &lt;code&gt;fgets&lt;/code&gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.</source>
          <target state="translated">버퍼 오버플로를 방지한다는 점에서 &lt;code&gt;fgets&lt;/code&gt; 와 동일한 보호 기능을 제공하지만 호출자에게 발생한 상황에 대해 알리고 초과 문자를 지워 다음 입력 작업에 영향을 미치지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="e1c25818b614ad4886532bcde8537de5f9306656" translate="yes" xml:space="preserve">
          <source>It remained an official part of the language up to the 1999 ISO C standard, but
it was officially removed by the 2011 standard. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.</source>
          <target state="translated">이 언어는 1999 ISO C 표준까지 언어의 공식적인 부분으로 유지되었지만 2011 표준에 의해 공식적으로 제거되었습니다. 대부분의 C 구현은 여전히 ​​그것을 지원하지만 적어도 gcc는 그것을 사용하는 코드에 대해 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="42a5c3d9526dc8085da2abd8478f2b40b7ae031d" translate="yes" xml:space="preserve">
          <source>Modern versions of the Linux compilation system generates warnings if you link &lt;code&gt;gets()&lt;/code&gt; &amp;mdash; and also for some other functions that also have security problems (&lt;code&gt;mktemp()&lt;/code&gt;, &amp;hellip;).</source>
          <target state="translated">최신 버전의 Linux 컴파일 시스템 &lt;code&gt;gets()&lt;/code&gt; 를 링크 하면 보안 문제가있는 다른 함수 ( &lt;code&gt;mktemp()&lt;/code&gt; ,&amp;hellip;)에 대해 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b4f2b34526a68d26a3bc4d9dfd62c538c97d08f6" translate="yes" xml:space="preserve">
          <source>Now, first of all you are allowed to input how many characters you want, &lt;code&gt;gets&lt;/code&gt; won't care about it. Secondly the bytes over the size of the array in which you put them (in this case &lt;code&gt;array1&lt;/code&gt;) will overwrite whatever they find in memory because &lt;code&gt;gets&lt;/code&gt; will write them. In the previous example this means that if you input &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; maybe, unpredictably, it will overwrite also &lt;code&gt;array2&lt;/code&gt; or whatever.</source>
          <target state="translated">이제, 당신이 원하는 수의 문자를 입력 할 수 있습니다. 두 번째로 배열의 크기를 초과하는 바이트 (이 경우 &lt;code&gt;array1&lt;/code&gt; )는 메모리에서 찾은 모든 것을 덮어 씁니다. 앞의 예에서 이것은 &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; 를 입력하면 예상치 &lt;code&gt;array2&lt;/code&gt; 을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="198ebb642096c9df4b79446052ed1fe43d6543be" translate="yes" xml:space="preserve">
          <source>Or, better:</source>
          <target state="translated">또는 더 나은 :</target>
        </trans-unit>
        <trans-unit id="9c7dd7546662103cca27c658f26b4a018c8beaa4" translate="yes" xml:space="preserve">
          <source>POSIX 2008 also provides a safe alternative to &lt;code&gt;gets()&lt;/code&gt; called &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/a&gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or &lt;code&gt;-1&lt;/code&gt; (and not &lt;code&gt;EOF&lt;/code&gt;!), which means that null bytes in the input can be handled reliably.  There is also a 'choose your own single-character delimiter' variation called &lt;code&gt;getdelim()&lt;/code&gt;; this can be useful if you are dealing with the output from &lt;code&gt;find -print0&lt;/code&gt; where the ends of the file names are marked with an ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; character, for example.</source>
          <target state="translated">POSIX 2008은 &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt; &lt;code&gt;getline()&lt;/code&gt; &lt;/a&gt; 이라는 gets () 대신 안전한 대안을 제공합니다. 라인을위한 공간을 동적으로 할당하므로 결국이를 해제해야합니다. 따라서 줄 길이에 대한 제한을 제거합니다. 또한 읽은 데이터의 길이 또는 &lt;code&gt;-1&lt;/code&gt; ( &lt;code&gt;EOF&lt;/code&gt; ! 아님)을 리턴합니다. 즉, 입력의 널 바이트를 안정적으로 처리 할 수 ​​있습니다. &lt;code&gt;getdelim()&lt;/code&gt; 이라는 '자신의 단일 문자 구분 기호 선택'변형도 있습니다. 예를 들어 파일 이름의 끝 부분에 ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; 문자가 표시되는 &lt;code&gt;find -print0&lt;/code&gt; 의 출력을 처리 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c0983051c063b5fe2f2d2af2af6a0cd45f15bfda" translate="yes" xml:space="preserve">
          <source>Reading a line that overflows the
  array pointed to by s results in
  undefined behavior. The use of fgets()
  is recommended.</source>
          <target state="translated">에 의해 지정된 배열을 오버플로하는 행을 읽으면 정의되지 않은 동작이 발생합니다. fgets ()를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c3ab3ad6eec1bd2048a1df66a1a4b7763d342532" translate="yes" xml:space="preserve">
          <source>Recommended practice</source>
          <target state="translated">권장 연습</target>
        </trans-unit>
        <trans-unit id="7bafc3df8bbe7113ca4bf95bc8fbacdf935c49b9" translate="yes" xml:space="preserve">
          <source>Runtime-constraints</source>
          <target state="translated">Runtime-constraints</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="9eb32d7bd20a4fdf0d3574611c1fa45b36a0d5f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; 기능을 사용하면 올바르게 작성된 프로그램이 입력 배열을 너무 길어서 결과 배열에 저장하기에 안전하게 처리 할 수 ​​있습니다. 일반적으로 &lt;code&gt;fgets&lt;/code&gt; 호출자는 결과 배열에 개행 문자가 있는지 여부에주의를 기울여야합니다. &lt;code&gt;gets_s&lt;/code&gt; 대신 &lt;code&gt;fgets&lt;/code&gt; 를 사용하십시오 (줄 바꾸기 문자를 기반으로 필요한 처리와 함께).</target>
        </trans-unit>
        <trans-unit id="9893bc4b020b6f22d145585b4fbf57f8568424a9" translate="yes" xml:space="preserve">
          <source>The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:</source>
          <target state="translated">C gets 함수는 위험하며 매우 비용이 많이 드는 실수였습니다. Tony Hoare는 그의 연설 &quot;Null References : Billion Dollar Mistake&quot;에서 구체적으로 언급하기 위해 그것을 인용합니다.</target>
        </trans-unit>
        <trans-unit id="7244dce292e5a67e56330c3ae3ac70115d04c857" translate="yes" xml:space="preserve">
          <source>The C11 standard ISO/IEC 9899:2011 eliminated &lt;code&gt;gets()&lt;/code&gt; as a standard function, which is A Good Thing&amp;trade; (it was formally marked as 'obsolescent' and 'deprecated' in ISO/IEC 9899:1999/Cor.3:2007 &amp;mdash; Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning 'decades') for reasons of backwards compatibility. If it were up to me, the implementation of &lt;code&gt;gets()&lt;/code&gt; would become:</source>
          <target state="translated">C11 표준 ISO / IEC 9899 : 2011은 표준 함수 인 &lt;code&gt;gets()&lt;/code&gt; 를 A Good Thing &amp;trade; (ISO / IEC 9899 : 1999 / Cor.3 : 2007에서 공식적으로 '폐기'및 '더 이상 사용되지 않음'으로 표시)로 제거했습니다. &amp;mdash; C99 용 기술 강령 3, C11에서 제거됨). 안타깝게도 이전 버전과의 호환성으로 인해 수년 동안 라이브러리에 남아있을 것입니다 ( '수십 년'). 그것이 나에게 달려 있다면 &lt;code&gt;gets()&lt;/code&gt; 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84ef67f2688a48e7b376c4ba61e40d505a890822" translate="yes" xml:space="preserve">
          <source>The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.</source>
          <target state="translated">C11 표준 ISO / IEC 9899-2011에는 라이브러리의 선택적 부분으로 Annex K의 TR24731이 포함되어 있습니다. 불행히도 유닉스 계열 시스템에서는 거의 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d47e50860bf8076ed169f41d7a85c4359380205" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.</source>
          <target state="translated">Microsoft Visual Studio 컴파일러는 TR 24731-1 표준에 대한 근사치를 구현하지만 Microsoft에서 구현 한 서명과 TR의 서명 간에는 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a01dba31dbdea116f56ac87ed8248da7b6c77c" translate="yes" xml:space="preserve">
          <source>The correct thing to do is to use the &lt;code&gt;fgets&lt;/code&gt; function with the &lt;code&gt;stdin&lt;/code&gt; file handle since you can limit the characters read from the user.</source>
          <target state="translated">사용자가 읽는 문자를 제한 할 수 있으므로 &lt;code&gt;stdin&lt;/code&gt; 파일 핸들에 &lt;code&gt;fgets&lt;/code&gt; 함수를 사용하는 것이 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f1dcc2d6f194f7526b03d578ac0939cdcf19025f" translate="yes" xml:space="preserve">
          <source>The first internet worm (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt;) escaped about 30 years ago (1988-11-02), and it used &lt;code&gt;gets()&lt;/code&gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.</source>
          <target state="translated">첫 번째 인터넷 웜 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Morris Worm&lt;/a&gt; )은 약 30 년 전 (1988-11-02) 탈출했으며 시스템에서 시스템으로 전파하는 방법 중 하나로 &lt;code&gt;gets()&lt;/code&gt; 및 버퍼 오버플로를 사용했습니다. 기본적인 문제는 함수가 버퍼의 크기를 알지 못하므로 줄 바꿈을 찾거나 EOF를 발견 할 때까지 계속 읽으며 주어진 버퍼의 범위를 오버플로 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7eff3cb60315bcf695059c295657cc7a122f7959" translate="yes" xml:space="preserve">
          <source>The function is unsafe because it assumes consistent input. &lt;strong&gt;NEVER USE IT!&lt;/strong&gt;</source>
          <target state="translated">함수는 일관된 입력을 가정하기 때문에 안전하지 않습니다. &lt;strong&gt;절대 사용하지 마십시오!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750bcf656f3974181d5e1a76edf73ad2e124ad0b" translate="yes" xml:space="preserve">
          <source>The residual problem is how to report the three different result states &amp;mdash; EOF or error, line read and not truncated, and partial line read but data was truncated.</source>
          <target state="translated">잔차 문제는 EOF 또는 오류, 줄 읽기 및 잘리지 않음 및 부분 줄 읽기이지만 데이터가 잘린 세 가지 결과 상태를보고하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6fc9f99af3e43c7167d5846fb446313e960c6292" translate="yes" xml:space="preserve">
          <source>The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.</source>
          <target state="translated">한 시간 내내 볼 가치가 있지만 그의 의견에 대해서는 30 분부터 특정 39 분에 대한 비평을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9fd85043992102449a1a070298d3a4921c88db31" translate="yes" xml:space="preserve">
          <source>There is also the &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including &lt;code&gt;gets()&lt;/code&gt;:</source>
          <target state="translated">또한 &lt;code&gt;gets()&lt;/code&gt; 포함한 다양한 기능에 대한 안전한 대안을 제공하는 &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (C 표준위원회의 기술 보고서 )이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4868f32615e852c069d3803b180101b92668998" translate="yes" xml:space="preserve">
          <source>This is the reason that &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;one reference&lt;/a&gt; gives:</source>
          <target state="translated">이것이 &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;하나의 참조가&lt;/a&gt; 제공하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="7db094300ea01e073164a5ea03e10bb13a54db69" translate="yes" xml:space="preserve">
          <source>This problem doesn't arise with &lt;code&gt;gets()&lt;/code&gt; because it doesn't know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea &amp;mdash; they epitomize the phrase 'undefined behaviour`.</source>
          <target state="translated">이 문제는 &lt;code&gt;gets()&lt;/code&gt; 발생하지 않습니다. 버퍼가 끝나는 곳을 모르고 끝까지 즐겁게 짓밟는 것을 알지 못하기 때문에 아름답게 꾸며진 메모리 레이아웃을 혼란스럽게 만들고 종종 버퍼가 반환 스택 ( &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;스택 오버플로&lt;/a&gt; )을 엉망으로 만듭니다 버퍼에 동적으로 할당 된 경우 스택에 할당되거나 제어 정보를 짓밟거나 버퍼가 정적으로 할당 된 경우 다른 중요한 전역 (또는 모듈) 변수를 통해 데이터를 복사합니다. 이것들 중 어느 것도 좋은 생각이 아닙니다. '정의되지 않은 행동'이라는 문구를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="adf290c1c7f6be3057acb6bea5e471efc8f43c4c" translate="yes" xml:space="preserve">
          <source>This will help make sure nobody is still depending on it.  Thank you.</source>
          <target state="translated">이것은 아무도 그것에 의존하지 않도록하는 데 도움이됩니다. 감사합니다.</target>
        </trans-unit>
        <trans-unit id="4753e2e49fc858e5a2b2e5fbdd4113a97feee0cb" translate="yes" xml:space="preserve">
          <source>To read from the stdin:</source>
          <target state="translated">stdin에서 읽으려면 :</target>
        </trans-unit>
        <trans-unit id="4d6321faea3b1611f6eebc8bb7ca88b9b78860d8" translate="yes" xml:space="preserve">
          <source>To that end, almost every C coder at some point in their career will write a more useful wrapper around &lt;code&gt;fgets&lt;/code&gt; as well. Here's mine:</source>
          <target state="translated">이를 위해 커리어의 어느 시점에서든 거의 모든 C 코더는 &lt;code&gt;fgets&lt;/code&gt; 주위에 더 유용한 래퍼를 작성할 것입니다. 내 꺼야 :</target>
        </trans-unit>
        <trans-unit id="ecd90ca1824950ce8dafea2df6b494288f14f8c1" translate="yes" xml:space="preserve">
          <source>What no-one else yet mentioned is that &lt;code&gt;gets()&lt;/code&gt; does not include the newline but &lt;code&gt;fgets()&lt;/code&gt; does.  So, you might need to use a wrapper around &lt;code&gt;fgets()&lt;/code&gt; that deletes the newline:</source>
          <target state="translated">아무도 아직 언급하지 않은 것은 &lt;code&gt;gets()&lt;/code&gt; 는 개행을 포함하지 않지만 &lt;code&gt;fgets()&lt;/code&gt; 는 포함한다는 것입니다. 따라서 개행을 삭제하는 &lt;code&gt;fgets()&lt;/code&gt; 주위에 래퍼를 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="08444532e7c4d0762fa2b5391bf997ac96aef445" translate="yes" xml:space="preserve">
          <source>When I try to compile C code that uses the &lt;code&gt;gets()&lt;/code&gt; function with GCC, I get this warning:</source>
          <target state="translated">GCC와 함께 &lt;code&gt;gets()&lt;/code&gt; 함수를 사용하는 C 코드를 컴파일하려고하면 다음 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6b52ac0a4e8ac7a4e4655813bedaec02b2f479" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;gets()&lt;/code&gt; dangerous</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 위험한 이유</target>
        </trans-unit>
        <trans-unit id="49394cee4f62a9a31d7d725e85adf763e37ad711" translate="yes" xml:space="preserve">
          <source>Why is the gets function so dangerous that it should not be used</source>
          <target state="translated">gets 함수가 너무 위험한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="dd864ec14dc44123c407eae349765bb2dc5e0f85" translate="yes" xml:space="preserve">
          <source>You can't remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.</source>
          <target state="translated">API를 중단하지 않으면 API 함수를 제거 할 수 없습니다. 그렇다면 많은 응용 프로그램이 더 이상 컴파일되거나 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e49543b808f0e06f0c85a5661cdf85f9286f402" translate="yes" xml:space="preserve">
          <source>You should forget you ever heard that &lt;code&gt;gets()&lt;/code&gt; existed.</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 존재한다는 말을 잊었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6ff7c3689e3c944d79918636d39dc0ec7c04f02" translate="yes" xml:space="preserve">
          <source>You should not use &lt;code&gt;gets&lt;/code&gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.</source>
          <target state="translated">버퍼 오버 플로우를 중지 할 방법이 없으므로 &lt;code&gt;gets&lt;/code&gt; 를 사용하지 않아야합니다. 사용자가 버퍼에 넣을 수있는 것보다 많은 데이터를 입력하면 손상이 발생하거나 더 악화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166a2a738c30b8a8caff252f1c9b03400dafc933" translate="yes" xml:space="preserve">
          <source>You'll be happy to know that the
  committee just voted (unanimously, as
  it turns out) to remove gets() from
  the draft as well.</source>
          <target state="translated">위원회가 드래프트에서 gets ()를 제거하기 위해 방금 투표했다는 사실을 알게되어 기쁩니다.</target>
        </trans-unit>
        <trans-unit id="04897e3a7e24331cc83197a34a7f070c6b5ba1a8" translate="yes" xml:space="preserve">
          <source>extra characters entered by the user will be picked up the next time around.</source>
          <target state="translated">다음에 사용자가 입력 한 추가 문자가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="4aafe66faf6e18737060606cf1f4058a26b65c75" translate="yes" xml:space="preserve">
          <source>fgets()</source>
          <target state="translated">fgets()</target>
        </trans-unit>
        <trans-unit id="d0b0a098660d5321e56ce33e74f19c73bce34754" translate="yes" xml:space="preserve">
          <source>there's no quick notification that the user entered too much data.</source>
          <target state="translated">사용자가 너무 많은 데이터를 입력했다는 빠른 알림이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fec03664be6d0484ac4cd6fbcac08352b5cb407" translate="yes" xml:space="preserve">
          <source>with some test code:</source>
          <target state="translated">몇 가지 테스트 코드 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
