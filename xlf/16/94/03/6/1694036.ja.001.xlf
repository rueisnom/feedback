<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1694036">
    <body>
      <group id="1694036">
        <trans-unit id="e97568ea4e112041c0cb6599eb15f6a2a791148f" translate="yes" xml:space="preserve">
          <source>&amp;sect;6.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">&amp;sect;6.5.4.1gets_s関数</target>
        </trans-unit>
        <trans-unit id="17518df0b5ea550ff0f27d57a4b252bf26d11988" translate="yes" xml:space="preserve">
          <source>(.text+0x34): warning: the `gets' function is dangerous and should not be used.</source>
          <target state="translated">(.text+0x34):warning:`gets' 関数は危険であり、使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="c800bf27a5a07d0fefadb5b1a5ecd4f9f2ac70f1" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;fgets&lt;/code&gt;, if it reads an entire line, will leave the &lt;code&gt;'\n'&lt;/code&gt; in the string; you'll have to deal with that.)</source>
          <target state="translated">（ &lt;code&gt;fgets&lt;/code&gt; は 、行全体を読み取る場合、文字列に &lt;code&gt;'\n'&lt;/code&gt; を残します。これに対処する必要があります。）</target>
        </trans-unit>
        <trans-unit id="6bc1be7c21ad64a2f919728d4a8f72e29bd67349" translate="yes" xml:space="preserve">
          <source>3 If there is a runtime-constraint violation, &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and characters
  are read and discarded from &lt;code&gt;stdin&lt;/code&gt; until a new-line character is read, or end-of-file or a
  read error occurs.</source>
          <target state="translated">3実行時制約違反がある場合、 &lt;code&gt;s[0]&lt;/code&gt; はヌル文字に設定され、改行文字が読み取られるか、ファイルの終わりまたは読み取りエラーが発生するまで、文字が読み取られて &lt;code&gt;stdin&lt;/code&gt; から破棄されます。</target>
        </trans-unit>
        <trans-unit id="2c6b11246694e0a53c8eaef6d402a2f6d483a210" translate="yes" xml:space="preserve">
          <source>4 The &lt;code&gt;gets_s&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt;
  from the stream pointed to by &lt;code&gt;stdin&lt;/code&gt;, into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional
  characters are read after a new-line character (which is discarded) or after end-of-file.
  The discarded new-line character does not count towards number of characters read. A
  null character is written immediately after the last character read into the array.</source>
          <target state="translated">4 &lt;code&gt;gets_s&lt;/code&gt; 関数は、 &lt;code&gt;stdin&lt;/code&gt; が指すストリームから、 &lt;code&gt;s&lt;/code&gt; が指す配列に、 &lt;code&gt;n&lt;/code&gt; で指定された文字数より多くても1つ少ない値を読み込みます。 改行文字（破棄される）の後、またはファイルの終わりの後は、追加の文字は読み取られません。 破棄された改行文字は、読み取られた文字数にはカウントされません。 配列に読み込まれた最後の文字の直後にnull文字が書き込まれます。</target>
        </trans-unit>
        <trans-unit id="871d5200809b27e3005fc171c5add16863eb429c" translate="yes" xml:space="preserve">
          <source>5 If end-of-file is encountered and no characters have been read into the array, or if a read
  error occurs during the operation, then &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and the other
  elements of &lt;code&gt;s&lt;/code&gt; take unspecified values.</source>
          <target state="translated">5ファイルの終わりが検出され、配列に文字が読み込まれていない場合、または操作中に読み込みエラーが発生した場合、 &lt;code&gt;s[0]&lt;/code&gt; はnull文字に設定され、 &lt;code&gt;s&lt;/code&gt; の他の要素は未指定の値をとります。</target>
        </trans-unit>
        <trans-unit id="ed163a0ef4f509855327416f1f2b9ccda77aeeb8" translate="yes" xml:space="preserve">
          <source>6 The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">6 &lt;code&gt;fgets&lt;/code&gt; 関数を使用すると、適切に作成されたプログラムで、結果の配列に格納するには長すぎる入力行を安全に処理できます。 一般に、これには &lt;code&gt;fgets&lt;/code&gt; の呼び出し元が結果配列内の改行文字の有無に注意を払う必要があります。 &lt;code&gt;gets_s&lt;/code&gt; の代わりに &lt;code&gt;fgets&lt;/code&gt; （改行文字に基づく必要な処理とともに）の使用を検討してください 。</target>
        </trans-unit>
        <trans-unit id="d0d48e496596a430fc0e8ae6d905f708329be4d7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c82c7b8bf8ffe3eb68fdc9b9a00c4519c5ff30ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fgets()&lt;/code&gt; allows you to specify how many characters are taken out of the standard input buffer, so they don't overrun the variable.</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; を使用すると、標準入力バッファーから取り出す文字数を指定できるため、変数がオーバーランすることはありません。</target>
        </trans-unit>
        <trans-unit id="8bf95efd9191a7a3774dd9d7416afbf3b8c75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</source>
          <target state="translated">&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</target>
        </trans-unit>
        <trans-unit id="8159d16eefb5f350c2e02c79e3cecfbaf46ad0cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gets()&lt;/code&gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can't detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person's name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; は、ユーザーがプロンプトに入力しすぎるとプログラムをクラッシュさせる可能性があるため、危険です。 使用可能なメモリの終わりを検出できないため、目的に対して小さすぎる量のメモリを割り当てると、セグメンテーション違反とクラッシュが発生する可能性があります。 ユーザーが人の名前を示すプロンプトに1000文字を入力することはほとんどありそうにありませんが、プログラマーとして、プログラムを完全なものにする必要があります。 （また、ユーザーが大量のデータを送信してシステムプログラムをクラッシュさせる可能性がある場合は、セキュリティリスクになる可能性もあります）。</target>
        </trans-unit>
        <trans-unit id="6adcc51eed96f7c3fbc2eba2e501ef8ab2436d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; shall not be a null pointer. &lt;code&gt;n&lt;/code&gt; shall neither be equal to zero nor be greater than
  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading
  &lt;code&gt;n-1&lt;/code&gt; characters from &lt;code&gt;stdin&lt;/code&gt;.&lt;sup&gt;25)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; はnullポインタであってはなりません。 &lt;code&gt;n&lt;/code&gt; はゼロに等しくなく、RSIZE_MAXより大きくてはなりません。 &lt;code&gt;stdin&lt;/code&gt; から &lt;code&gt;n-1&lt;/code&gt; 文字を読み取るときに、改行文字、ファイルの終わり、または読み取りエラーが発生します。 &lt;sup&gt;25）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32999174ab5c86638eab236eddb300aaa124ae76" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;25)&lt;/sup&gt; The &lt;code&gt;gets_s&lt;/code&gt; function, unlike &lt;code&gt;gets&lt;/code&gt;, makes it a runtime-constraint violation for a line of input to
  overflow the buffer to store it. Unlike &lt;code&gt;fgets&lt;/code&gt;, &lt;code&gt;gets_s&lt;/code&gt; maintains a one-to-one relationship between
  input lines and successful calls to &lt;code&gt;gets_s&lt;/code&gt;. Programs that use &lt;code&gt;gets&lt;/code&gt; expect such a relationship.</source>
          <target state="translated">&lt;sup&gt;25）&lt;/sup&gt; &lt;code&gt;gets_s&lt;/code&gt; 関数は、 &lt;code&gt;gets&lt;/code&gt; とは異なり、それを格納するためにバッファをオーバーフローさせるために、入力行が実行時制約違反になります。 &lt;code&gt;fgets&lt;/code&gt; とは異なり、 &lt;code&gt;gets_s&lt;/code&gt; は入力行と &lt;code&gt;gets_s&lt;/code&gt; の正常な呼び出しとの1対1の関係を維持します。 getを使用するプログラム &lt;code&gt;gets&lt;/code&gt; 、このような関係を期待しています。</target>
        </trans-unit>
        <trans-unit id="d47deb2fa418026ef69328b4feb307c797055743" translate="yes" xml:space="preserve">
          <source>Also, as &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; points out in a comment and &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; shows in his answer, with &lt;code&gt;fgets()&lt;/code&gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:</source>
          <target state="translated">また、 &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;caf&lt;/a&gt;がコメントで指摘し、 paxdiabloが彼の回答で示しているように、 &lt;code&gt;fgets()&lt;/code&gt; を使用すると、行にデータが残っている可能性があります。 私のラッパーコードは、そのデータを次回読み取るために残します。 必要に応じて、簡単に変更して残りのデータ行を取得することができます。</target>
        </trans-unit>
        <trans-unit id="3a577c69baeea75db56ec2bf55a2c47ccbe72969" translate="yes" xml:space="preserve">
          <source>Alternatives to &lt;code&gt;gets()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; の代替</target>
        </trans-unit>
        <trans-unit id="dacdb797ba8e8e112d387210f5fd7a4b54c331cd" translate="yes" xml:space="preserve">
          <source>As everyone else said, the canonical alternative to &lt;code&gt;gets()&lt;/code&gt; is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; specifying &lt;code&gt;stdin&lt;/code&gt; as the file stream.</source>
          <target state="translated">他の誰もが言ったように、 &lt;code&gt;gets()&lt;/code&gt; の標準的な代替案は、ファイルストリームとして &lt;code&gt;stdin&lt;/code&gt; を指定する&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt; &lt;code&gt;fgets()&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="276cab09e51e47a855dc9b87ab1220f1023257fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;gets&lt;/code&gt; doesn't do any kind of check while getting bytes from &lt;em&gt;stdin&lt;/em&gt; and putting them somewhere. A simple example:</source>
          <target state="translated">なぜなら、 &lt;code&gt;gets&lt;/code&gt; は、 &lt;em&gt;stdin&lt;/em&gt;からバイトを取得してそれらをどこかに置く間、いかなる種類のチェックも行わないからです。 簡単な例：</target>
        </trans-unit>
        <trans-unit id="f2c96493dd9f7f0a24eaac18c571948408967130" translate="yes" xml:space="preserve">
          <source>But this also has its problems such as:</source>
          <target state="translated">しかし、これには次のような問題点もあります。</target>
        </trans-unit>
        <trans-unit id="375f5f535aa6378b6f0ddc609d99ec61fd2fc369" translate="yes" xml:space="preserve">
          <source>C11 K.3.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">C11 K.3.5.4.1 &lt;code&gt;gets_s&lt;/code&gt; 関数</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e0e37d77940442881c3ecdeeb4e63ff793130daf" translate="yes" xml:space="preserve">
          <source>Feel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)</source>
          <target state="translated">お好きなように自由にお使いください。)</target>
        </trans-unit>
        <trans-unit id="24320b942db7d03958da6d14023db94004c68712" translate="yes" xml:space="preserve">
          <source>Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I'd be prepared to add an error message:</source>
          <target state="translated">あなたのコードはいずれにせよ、遅かれ早かれクラッシュすることを考えると、トラブルを回避するためには、遅かれ早かれ対処した方が良いでしょう。私はエラーメッセージを追加する準備をしています。</target>
        </trans-unit>
        <trans-unit id="b2a1c70a047d18fa7bb41b678bcbfccc91d6d372" translate="yes" xml:space="preserve">
          <source>Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of 'programmer freedom'.</source>
          <target state="translated">この講演では、言語におけるより正式な正しさの証明が必要であることや、言語設計者はプログラマではなく、その言語の誤りの責任を負うべきであることに注意を喚起しています。これは、悪い言語の設計者が「プログラマの自由」という名目でプログラマに責任を押し付けようとする怪しげな理由のように思えます。</target>
        </trans-unit>
        <trans-unit id="271cb448109ee99e001bef107a8f3bc50b2b6f84" translate="yes" xml:space="preserve">
          <source>How can I remove this warning and why is there such a warning about using &lt;code&gt;gets()&lt;/code&gt;?</source>
          <target state="translated">この警告を削除するにはどうすればよいですか。また、 &lt;code&gt;gets()&lt;/code&gt; の使用に関する警告が表示されるのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="e4ba164e3701105ccec7d9eab6ba69fc62d2fc45" translate="yes" xml:space="preserve">
          <source>However, in the &lt;em&gt;Recommended practice&lt;/em&gt; section, &lt;code&gt;fgets()&lt;/code&gt; is still preferred.</source>
          <target state="translated">ただし、「 &lt;em&gt;推奨されるプラクティス」&lt;/em&gt;セクションでは、 &lt;code&gt;fgets()&lt;/code&gt; が推奨されています。</target>
        </trans-unit>
        <trans-unit id="d5f1326537bd1a67f425e3007ee099675175abbb" translate="yes" xml:space="preserve">
          <source>I read recently, in a &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;USENET post to &lt;code&gt;comp.lang.c&lt;/code&gt;&lt;/a&gt;, that &lt;code&gt;gets()&lt;/code&gt; is getting removed from the Standard. &lt;strong&gt;WOOHOO&lt;/strong&gt;</source>
          <target state="translated">最近読んだ、 &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt; &lt;code&gt;comp.lang.c&lt;/code&gt; へのUSENETの投稿&lt;/a&gt;で、 &lt;code&gt;gets()&lt;/code&gt; が標準から削除されています。 &lt;strong&gt;うん&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eceb5f707de5da0dab443da03e3e6e5e41328764" translate="yes" xml:space="preserve">
          <source>I remember this has something to do with stack protection and security, but I'm not sure exactly why.</source>
          <target state="translated">これはスタックの保護とセキュリティに関係があると記憶していますが、はっきりとした理由はわかりません。</target>
        </trans-unit>
        <trans-unit id="9a0c616272856956300d35a22b16fc991d07f8ca" translate="yes" xml:space="preserve">
          <source>I would like to extend an earnest invitation to any C library maintainers out there who are still including &lt;code&gt;gets&lt;/code&gt; in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of</source>
          <target state="translated">「だれかがまだそれに依存している場合に備えて」、ライブラリにまだgetを含めているCライブラリのメンテナに真剣な招待を送りたいと思います。実装を同等のものに置き換えてください</target>
        </trans-unit>
        <trans-unit id="7bf781506125edfc033141ab72812799f2999203" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gets()&lt;/code&gt; is so dangerous then why can't we remove it?</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; が非常に危険な場合、それを削除できないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="2225f53902789cdbd60c62ef1ae2f7be501676f7" translate="yes" xml:space="preserve">
          <source>In C11(ISO/IEC 9899:201x), &lt;code&gt;gets()&lt;/code&gt; has been removed. (It's deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))</source>
          <target state="translated">C11（ISO / IEC 9899：201x）では、 &lt;code&gt;gets()&lt;/code&gt; が削除されました。 （ISO / IEC 9899：1999 / Cor.3：2007（E）では非推奨）</target>
        </trans-unit>
        <trans-unit id="84611e142406e2872460af2270761a3dcd9aedd8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;fgets()&lt;/code&gt;, C11 introduces a new safe alternative &lt;code&gt;gets_s()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; に加えて、C11は新しい安全な代替物 &lt;code&gt;gets_s()&lt;/code&gt; を導入します：</target>
        </trans-unit>
        <trans-unit id="5163be8673258f548a47017b937adce7bc283e33" translate="yes" xml:space="preserve">
          <source>In fact, ISO have actually taken the step of &lt;em&gt;removing&lt;/em&gt;&lt;code&gt;gets&lt;/code&gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.</source>
          <target state="translated">実際、ISOは実際にC標準からgetを&lt;em&gt;削除&lt;/em&gt;するステップを踏んでいます（C99では非推奨になりましたが、C11以降）。これは、下位互換性の評価の高さを考えると、その機能がどれほど悪かったかを示すものです。</target>
        </trans-unit>
        <trans-unit id="fc19320a49a091fc199629c4ede2786469111688" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;gets&lt;/code&gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.</source>
          <target state="translated">安全に使用 &lt;code&gt;gets&lt;/code&gt; には、バッファを十分な大きさにできるように、読み取る文字数を正確に把握する必要があります。 どのデータを読み取るかが正確にわかっている場合にのみ、そのことがわかります。</target>
        </trans-unit>
        <trans-unit id="8fde1f90e44e07a8abd3fce0c7724c0e1eae3b60" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;gets&lt;/code&gt;, you want to use &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt;&lt;code&gt;fgets&lt;/code&gt;&lt;/a&gt;, which has the signature</source>
          <target state="translated">getを使用 &lt;code&gt;gets&lt;/code&gt; 代わりに、シグネチャを持つ&lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;/a&gt;を使用したい</target>
        </trans-unit>
        <trans-unit id="98bc71dac689b4fcfc909ec3933e5b117578f4fe" translate="yes" xml:space="preserve">
          <source>It provides the same protections as &lt;code&gt;fgets&lt;/code&gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.</source>
          <target state="translated">バッファーオーバーフローを防ぐという点で &lt;code&gt;fgets&lt;/code&gt; と同じ保護を提供しますが、何が起こったのかを呼び出し元に通知し、余分な文字をクリアして、次の入力操作に影響を与えないようにします。</target>
        </trans-unit>
        <trans-unit id="e1c25818b614ad4886532bcde8537de5f9306656" translate="yes" xml:space="preserve">
          <source>It remained an official part of the language up to the 1999 ISO C standard, but
it was officially removed by the 2011 standard. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.</source>
          <target state="translated">1999年のISO C標準までは公式に言語の一部として使われていましたが、2011年の標準で公式に削除されました。ほとんどの C の実装ではまだサポートされていますが、少なくとも gcc はそれを使用するコードに対して警告を発します。</target>
        </trans-unit>
        <trans-unit id="42a5c3d9526dc8085da2abd8478f2b40b7ae031d" translate="yes" xml:space="preserve">
          <source>Modern versions of the Linux compilation system generates warnings if you link &lt;code&gt;gets()&lt;/code&gt; &amp;mdash; and also for some other functions that also have security problems (&lt;code&gt;mktemp()&lt;/code&gt;, &amp;hellip;).</source>
          <target state="translated">最新バージョンのLinuxコンパイルシステムでは、 &lt;code&gt;gets()&lt;/code&gt; をリンクすると警告が生成されます。また、セキュリティ上の問題がある他のいくつかの関数（ &lt;code&gt;mktemp()&lt;/code&gt; 、&amp;hellip;）も警告されます。</target>
        </trans-unit>
        <trans-unit id="b4f2b34526a68d26a3bc4d9dfd62c538c97d08f6" translate="yes" xml:space="preserve">
          <source>Now, first of all you are allowed to input how many characters you want, &lt;code&gt;gets&lt;/code&gt; won't care about it. Secondly the bytes over the size of the array in which you put them (in this case &lt;code&gt;array1&lt;/code&gt;) will overwrite whatever they find in memory because &lt;code&gt;gets&lt;/code&gt; will write them. In the previous example this means that if you input &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; maybe, unpredictably, it will overwrite also &lt;code&gt;array2&lt;/code&gt; or whatever.</source>
          <target state="translated">さて、まず第一にあなたはあなたが望む何文字を入力することを許されます、それは気 &lt;code&gt;gets&lt;/code&gt; なりません。 次に、 &lt;code&gt;gets&lt;/code&gt; がそれらを書き込むため、それらを配置した配列（この場合は &lt;code&gt;array1&lt;/code&gt; ）のサイズを超えるバイトが、メモリ内で見つかったものを上書きします。 前の例では、これは、 &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; を入力した場合、おそらく、予期せず、 &lt;code&gt;array2&lt;/code&gt; なども上書きすることを意味します。</target>
        </trans-unit>
        <trans-unit id="198ebb642096c9df4b79446052ed1fe43d6543be" translate="yes" xml:space="preserve">
          <source>Or, better:</source>
          <target state="translated">というか、もっといい。</target>
        </trans-unit>
        <trans-unit id="9c7dd7546662103cca27c658f26b4a018c8beaa4" translate="yes" xml:space="preserve">
          <source>POSIX 2008 also provides a safe alternative to &lt;code&gt;gets()&lt;/code&gt; called &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/a&gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or &lt;code&gt;-1&lt;/code&gt; (and not &lt;code&gt;EOF&lt;/code&gt;!), which means that null bytes in the input can be handled reliably.  There is also a 'choose your own single-character delimiter' variation called &lt;code&gt;getdelim()&lt;/code&gt;; this can be useful if you are dealing with the output from &lt;code&gt;find -print0&lt;/code&gt; where the ends of the file names are marked with an ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; character, for example.</source>
          <target state="translated">POSIX 2008は、 &lt;code&gt;gets()&lt;/code&gt; の安全な代替手段として&lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt; &lt;code&gt;getline()&lt;/code&gt; &lt;/a&gt;も提供しています。 それはラインにスペースを動的に割り当てます、それであなたはそれを解放する必要があることになります。 したがって、行の長さの制限がなくなります。 また、読み取られたデータの長さ、または &lt;code&gt;-1&lt;/code&gt; （ &lt;code&gt;EOF&lt;/code&gt; ではなく！）も返します。つまり、入力のnullバイトを確実に処理できます。 &lt;code&gt;getdelim()&lt;/code&gt; と呼ばれる「独自の単一文字区切り文字を選択する」バリエーションもあります。 これは、 &lt;code&gt;find -print0&lt;/code&gt; 、ファイル名の末尾がASCII NUL &lt;code&gt;'\0'&lt;/code&gt; 文字でマークされているfind -print0からの出力を処理する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="c0983051c063b5fe2f2d2af2af6a0cd45f15bfda" translate="yes" xml:space="preserve">
          <source>Reading a line that overflows the
  array pointed to by s results in
  undefined behavior. The use of fgets()
  is recommended.</source>
          <target state="translated">s が指す配列をオーバーフローさせた行を読み込むと、未定義の動作になります。fgets()の使用を推奨します。</target>
        </trans-unit>
        <trans-unit id="c3ab3ad6eec1bd2048a1df66a1a4b7763d342532" translate="yes" xml:space="preserve">
          <source>Recommended practice</source>
          <target state="translated">おすすめの練習方法</target>
        </trans-unit>
        <trans-unit id="7bafc3df8bbe7113ca4bf95bc8fbacdf935c49b9" translate="yes" xml:space="preserve">
          <source>Runtime-constraints</source>
          <target state="translated">Runtime-constraints</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="9eb32d7bd20a4fdf0d3574611c1fa45b36a0d5f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; 関数を使用すると、適切に作成されたプログラムで、結果の配列に格納するには長すぎる入力行を安全に処理できます。 一般に、これには &lt;code&gt;fgets&lt;/code&gt; の呼び出し元が結果配列内の改行文字の有無に注意を払う必要があります。 &lt;code&gt;gets_s&lt;/code&gt; の代わりに &lt;code&gt;fgets&lt;/code&gt; （改行文字に基づく必要な処理とともに）の使用を検討してください 。</target>
        </trans-unit>
        <trans-unit id="9893bc4b020b6f22d145585b4fbf57f8568424a9" translate="yes" xml:space="preserve">
          <source>The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:</source>
          <target state="translated">C get 関数は危険であり、非常にコストのかかる間違いです。Tony Hoare氏の講演「Null References.10億ドルの間違い」の中で具体的に言及しています。</target>
        </trans-unit>
        <trans-unit id="7244dce292e5a67e56330c3ae3ac70115d04c857" translate="yes" xml:space="preserve">
          <source>The C11 standard ISO/IEC 9899:2011 eliminated &lt;code&gt;gets()&lt;/code&gt; as a standard function, which is A Good Thing&amp;trade; (it was formally marked as 'obsolescent' and 'deprecated' in ISO/IEC 9899:1999/Cor.3:2007 &amp;mdash; Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning 'decades') for reasons of backwards compatibility. If it were up to me, the implementation of &lt;code&gt;gets()&lt;/code&gt; would become:</source>
          <target state="translated">C11標準ISO / IEC 9899：2011は、get &lt;code&gt;gets()&lt;/code&gt; を標準関数として削除しました。これはA Good Thing&amp;trade;です（ISO / IEC 9899：1999 / Cor.3：2007では正式に「廃止」および「非推奨」とマークされていました） &amp;mdash; C99の技術的正誤表3。C11で削除されました。 悲しいことに、下位互換性の理由から、ライブラリは何年​​も（「数十年」を意味する）ライブラリに残ります。 それが私次第だったら、 &lt;code&gt;gets()&lt;/code&gt; の実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="84ef67f2688a48e7b376c4ba61e40d505a890822" translate="yes" xml:space="preserve">
          <source>The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.</source>
          <target state="translated">C11規格であるISOIEC 9899-2011では、TR24731をライブラリのオプションの一部として附属書Kに含んでいます。残念ながら、Unix ライクなシステムではほとんど実装されていません。</target>
        </trans-unit>
        <trans-unit id="9d47e50860bf8076ed169f41d7a85c4359380205" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.</source>
          <target state="translated">Microsoft Visual Studio コンパイラは TR 24731-1 標準に近似したシグネチャを実装していますが、Microsoft が実装したシグネチャと TR のシグネチャには違いがあります。</target>
        </trans-unit>
        <trans-unit id="98a01dba31dbdea116f56ac87ed8248da7b6c77c" translate="yes" xml:space="preserve">
          <source>The correct thing to do is to use the &lt;code&gt;fgets&lt;/code&gt; function with the &lt;code&gt;stdin&lt;/code&gt; file handle since you can limit the characters read from the user.</source>
          <target state="translated">ユーザーから読み取られる文字を制限できるため、正しいことは、 &lt;code&gt;fgets&lt;/code&gt; 関数を &lt;code&gt;stdin&lt;/code&gt; ファイルハンドルで使用することです。</target>
        </trans-unit>
        <trans-unit id="f1dcc2d6f194f7526b03d578ac0939cdcf19025f" translate="yes" xml:space="preserve">
          <source>The first internet worm (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt;) escaped about 30 years ago (1988-11-02), and it used &lt;code&gt;gets()&lt;/code&gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.</source>
          <target state="translated">最初のインターネットワーム（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt; ）は約30年前（1988-11-02）にエスケープし、 &lt;code&gt;gets()&lt;/code&gt; とバッファオーバーフローをシステムからシステムへの伝播方法の1つとして使用しました。 基本的な問題は、関数がバッファーの大きさを認識しないため、改行が見つかるか、EOFに遭遇するまで読み取りを続け、指定されたバッファーの境界をオーバーフローする可能性があることです。</target>
        </trans-unit>
        <trans-unit id="7eff3cb60315bcf695059c295657cc7a122f7959" translate="yes" xml:space="preserve">
          <source>The function is unsafe because it assumes consistent input. &lt;strong&gt;NEVER USE IT!&lt;/strong&gt;</source>
          <target state="translated">関数は一貫した入力を想定しているため、安全ではありません。 &lt;strong&gt;絶対に使用しないでください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750bcf656f3974181d5e1a76edf73ad2e124ad0b" translate="yes" xml:space="preserve">
          <source>The residual problem is how to report the three different result states &amp;mdash; EOF or error, line read and not truncated, and partial line read but data was truncated.</source>
          <target state="translated">残りの問題は、3つの異なる結果の状態（EOFまたはエラー、行が切り捨てられていない、および行が部分的に読み込まれたがデータが切り捨てられた）を報告する方法です。</target>
        </trans-unit>
        <trans-unit id="6fc9f99af3e43c7167d5846fb446313e960c6292" translate="yes" xml:space="preserve">
          <source>The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.</source>
          <target state="translated">全体の時間は見る価値がありますが、彼のコメントビューのために特定の上で30分から39分の周りに批判を取得します。</target>
        </trans-unit>
        <trans-unit id="9fd85043992102449a1a070298d3a4921c88db31" translate="yes" xml:space="preserve">
          <source>There is also the &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including &lt;code&gt;gets()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;get&lt;/a&gt; （）を含むさまざまな関数のより安全な代替手段を提供するTR 24731-1 （C標準委員会からの技術レポート）もあります。</target>
        </trans-unit>
        <trans-unit id="a4868f32615e852c069d3803b180101b92668998" translate="yes" xml:space="preserve">
          <source>This is the reason that &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;one reference&lt;/a&gt; gives:</source>
          <target state="translated">これが、 &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;1つのリファレンス&lt;/a&gt;が与える理由です。</target>
        </trans-unit>
        <trans-unit id="7db094300ea01e073164a5ea03e10bb13a54db69" translate="yes" xml:space="preserve">
          <source>This problem doesn't arise with &lt;code&gt;gets()&lt;/code&gt; because it doesn't know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea &amp;mdash; they epitomize the phrase 'undefined behaviour`.</source>
          <target state="translated">この問題は、 &lt;code&gt;gets()&lt;/code&gt; では発生しません。バッファがどこで終了しているのかがわからないため、最後から楽に踏みにじって、美しく手入れされたメモリレイアウトに大混乱を引き起こし、多くの場合バッファがリターンスタック（ &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;スタックオーバーフロー&lt;/a&gt; ）スタックに割り当てられているか、バッファが動的に割り当てられている場合は制御情報を踏みつけ、静的に割り当てられている場合は他の貴重なグローバル（またはモジュール）変数にデータをコピーします。 これらはどれも良いアイデアではありません。「未定義の動作」というフレーズの典型です。</target>
        </trans-unit>
        <trans-unit id="adf290c1c7f6be3057acb6bea5e471efc8f43c4c" translate="yes" xml:space="preserve">
          <source>This will help make sure nobody is still depending on it.  Thank you.</source>
          <target state="translated">これでまだ誰も依存していないことを確認できます。ありがとうございます。</target>
        </trans-unit>
        <trans-unit id="4753e2e49fc858e5a2b2e5fbdd4113a97feee0cb" translate="yes" xml:space="preserve">
          <source>To read from the stdin:</source>
          <target state="translated">stdinから読み込むには</target>
        </trans-unit>
        <trans-unit id="4d6321faea3b1611f6eebc8bb7ca88b9b78860d8" translate="yes" xml:space="preserve">
          <source>To that end, almost every C coder at some point in their career will write a more useful wrapper around &lt;code&gt;fgets&lt;/code&gt; as well. Here's mine:</source>
          <target state="translated">そのために、キャリアのある時点でのほとんどすべてのCコーダーは、 &lt;code&gt;fgets&lt;/code&gt; のより便利なラッパーも作成します。 これが私のものです：</target>
        </trans-unit>
        <trans-unit id="ecd90ca1824950ce8dafea2df6b494288f14f8c1" translate="yes" xml:space="preserve">
          <source>What no-one else yet mentioned is that &lt;code&gt;gets()&lt;/code&gt; does not include the newline but &lt;code&gt;fgets()&lt;/code&gt; does.  So, you might need to use a wrapper around &lt;code&gt;fgets()&lt;/code&gt; that deletes the newline:</source>
          <target state="translated">他に誰も言及していないのは、 &lt;code&gt;gets()&lt;/code&gt; には改行が含まれていませんが、 &lt;code&gt;fgets()&lt;/code&gt; には含まれていることです。 したがって、改行を削除する &lt;code&gt;fgets()&lt;/code&gt; のラッパーを使用する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="08444532e7c4d0762fa2b5391bf997ac96aef445" translate="yes" xml:space="preserve">
          <source>When I try to compile C code that uses the &lt;code&gt;gets()&lt;/code&gt; function with GCC, I get this warning:</source>
          <target state="translated">GCCで &lt;code&gt;gets()&lt;/code&gt; 関数を使用するCコードをコンパイルしようとすると、次の警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="3b6b52ac0a4e8ac7a4e4655813bedaec02b2f479" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;gets()&lt;/code&gt; dangerous</source>
          <target state="translated">get &lt;code&gt;gets()&lt;/code&gt; 危険な理由</target>
        </trans-unit>
        <trans-unit id="49394cee4f62a9a31d7d725e85adf763e37ad711" translate="yes" xml:space="preserve">
          <source>Why is the gets function so dangerous that it should not be used</source>
          <target state="translated">なぜ gets 関数は使用してはいけないほど危険なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="dd864ec14dc44123c407eae349765bb2dc5e0f85" translate="yes" xml:space="preserve">
          <source>You can't remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.</source>
          <target state="translated">APIを壊さずにAPI関数を削除することはできません。もしそうすれば、多くのアプリケーションがコンパイルされなくなったり、全く実行されなくなったりします。</target>
        </trans-unit>
        <trans-unit id="9e49543b808f0e06f0c85a5661cdf85f9286f402" translate="yes" xml:space="preserve">
          <source>You should forget you ever heard that &lt;code&gt;gets()&lt;/code&gt; existed.</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; が存在したと聞いたことは忘れてください。</target>
        </trans-unit>
        <trans-unit id="f6ff7c3689e3c944d79918636d39dc0ec7c04f02" translate="yes" xml:space="preserve">
          <source>You should not use &lt;code&gt;gets&lt;/code&gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.</source>
          <target state="translated">バッファオーバーフローを停止する方法 &lt;code&gt;gets&lt;/code&gt; ないため、 getsを使用しないでください。 ユーザーがバッファーに収まりきらないほど多くのデータを入力すると、破損またはさらに悪い結果になる可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="166a2a738c30b8a8caff252f1c9b03400dafc933" translate="yes" xml:space="preserve">
          <source>You'll be happy to know that the
  committee just voted (unanimously, as
  it turns out) to remove gets() from
  the draft as well.</source>
          <target state="translated">委員会が(結果的には満場一致で)草案から gets()を削除するように投票したことを知っていると、あなたは喜ぶでしょう。</target>
        </trans-unit>
        <trans-unit id="04897e3a7e24331cc83197a34a7f070c6b5ba1a8" translate="yes" xml:space="preserve">
          <source>extra characters entered by the user will be picked up the next time around.</source>
          <target state="translated">ユーザーが入力した余分な文字は、次回以降にピックアップされます。</target>
        </trans-unit>
        <trans-unit id="4aafe66faf6e18737060606cf1f4058a26b65c75" translate="yes" xml:space="preserve">
          <source>fgets()</source>
          <target state="translated">fgets()</target>
        </trans-unit>
        <trans-unit id="d0b0a098660d5321e56ce33e74f19c73bce34754" translate="yes" xml:space="preserve">
          <source>there's no quick notification that the user entered too much data.</source>
          <target state="translated">ユーザーが入力したデータが多すぎるというクイック通知はありません。</target>
        </trans-unit>
        <trans-unit id="2fec03664be6d0484ac4cd6fbcac08352b5cb407" translate="yes" xml:space="preserve">
          <source>with some test code:</source>
          <target state="translated">テストコードを使って</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
