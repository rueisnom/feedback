<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1694036">
    <body>
      <group id="1694036">
        <trans-unit id="e97568ea4e112041c0cb6599eb15f6a2a791148f" translate="yes" xml:space="preserve">
          <source>&amp;sect;6.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;gets_s&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="17518df0b5ea550ff0f27d57a4b252bf26d11988" translate="yes" xml:space="preserve">
          <source>(.text+0x34): warning: the `gets' function is dangerous and should not be used.</source>
          <target state="translated">(.text+0x34):警告:&quot;gets &quot;函数很危险,不应使用。</target>
        </trans-unit>
        <trans-unit id="c800bf27a5a07d0fefadb5b1a5ecd4f9f2ac70f1" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;fgets&lt;/code&gt;, if it reads an entire line, will leave the &lt;code&gt;'\n'&lt;/code&gt; in the string; you'll have to deal with that.)</source>
          <target state="translated">（ &lt;code&gt;fgets&lt;/code&gt; 如果读取整行，将在字符串中保留 &lt;code&gt;'\n'&lt;/code&gt; ；您将不得不处理该问题。）</target>
        </trans-unit>
        <trans-unit id="6bc1be7c21ad64a2f919728d4a8f72e29bd67349" translate="yes" xml:space="preserve">
          <source>3 If there is a runtime-constraint violation, &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and characters
  are read and discarded from &lt;code&gt;stdin&lt;/code&gt; until a new-line character is read, or end-of-file or a
  read error occurs.</source>
          <target state="translated">3如果存在运行时约束冲突，则将 &lt;code&gt;s[0]&lt;/code&gt; 设置为空字符，然后从 &lt;code&gt;stdin&lt;/code&gt; 读取并丢弃字符，直到读取换行符，或者出现文件结尾或读取错误。</target>
        </trans-unit>
        <trans-unit id="2c6b11246694e0a53c8eaef6d402a2f6d483a210" translate="yes" xml:space="preserve">
          <source>4 The &lt;code&gt;gets_s&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt;
  from the stream pointed to by &lt;code&gt;stdin&lt;/code&gt;, into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional
  characters are read after a new-line character (which is discarded) or after end-of-file.
  The discarded new-line character does not count towards number of characters read. A
  null character is written immediately after the last character read into the array.</source>
          <target state="translated">4 &lt;code&gt;gets_s&lt;/code&gt; 函数从 &lt;code&gt;stdin&lt;/code&gt; 指向的流中读取最多比 &lt;code&gt;n&lt;/code&gt; 指定的字符数少1的字符到 &lt;code&gt;s&lt;/code&gt; 指向的数组中。 在换行符（已被丢弃）之后或文件结尾之后，不会再读取其他字符。 丢弃的换行符不计入读取的字符数。 在将最后一个字符读入数组后，立即写入一个空字符。</target>
        </trans-unit>
        <trans-unit id="871d5200809b27e3005fc171c5add16863eb429c" translate="yes" xml:space="preserve">
          <source>5 If end-of-file is encountered and no characters have been read into the array, or if a read
  error occurs during the operation, then &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and the other
  elements of &lt;code&gt;s&lt;/code&gt; take unspecified values.</source>
          <target state="translated">5如果遇到文件结尾，并且没有字符读入数组，或者在操作期间发生读取错误，则 &lt;code&gt;s[0]&lt;/code&gt; 设置为空字符，而 &lt;code&gt;s&lt;/code&gt; 的其他元素采用未指定的值。</target>
        </trans-unit>
        <trans-unit id="ed163a0ef4f509855327416f1f2b9ccda77aeeb8" translate="yes" xml:space="preserve">
          <source>6 The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">6 &lt;code&gt;fgets&lt;/code&gt; 函数允许正确编写的程序安全地处理过长的行，以至于无法存储在结果数组中。 通常，这要求 &lt;code&gt;fgets&lt;/code&gt; 调用者注意结果数组中是否存在换行符。 考虑使用 &lt;code&gt;fgets&lt;/code&gt; （以及基于换行符的所有必要处理）代替 &lt;code&gt;gets_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0d48e496596a430fc0e8ae6d905f708329be4d7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c82c7b8bf8ffe3eb68fdc9b9a00c4519c5ff30ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fgets()&lt;/code&gt; allows you to specify how many characters are taken out of the standard input buffer, so they don't overrun the variable.</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; 允许您指定从标准输入缓冲区中取出多少个字符，因此它们不会超出变量。</target>
        </trans-unit>
        <trans-unit id="8bf95efd9191a7a3774dd9d7416afbf3b8c75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</source>
          <target state="translated">&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</target>
        </trans-unit>
        <trans-unit id="8159d16eefb5f350c2e02c79e3cecfbaf46ad0cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gets()&lt;/code&gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can't detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person's name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 很危险，因为用户可能会在提示中输入过多内容而使程序崩溃。 它无法检测到可用内存的结束，因此，如果为此目的分配的内存太小，则可能导致段错误和崩溃。 有时，用户似乎不太可能在提示一个人名字的提示符下键入1000个字母，但是作为程序员，我们需要使程序防弹。 （如果用户通过发送太多数据而使系统程序崩溃，也可能会带来安全隐患）。</target>
        </trans-unit>
        <trans-unit id="6adcc51eed96f7c3fbc2eba2e501ef8ab2436d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; shall not be a null pointer. &lt;code&gt;n&lt;/code&gt; shall neither be equal to zero nor be greater than
  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading
  &lt;code&gt;n-1&lt;/code&gt; characters from &lt;code&gt;stdin&lt;/code&gt;.&lt;sup&gt;25)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 不能为空指针。 &lt;code&gt;n&lt;/code&gt; 既不等于零也不大于RSIZE_MAX。 从 &lt;code&gt;stdin&lt;/code&gt; 读取 &lt;code&gt;n-1&lt;/code&gt; 个字符时，将出现换行符，文件结尾或读取错误。 &lt;sup&gt;25）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32999174ab5c86638eab236eddb300aaa124ae76" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;25)&lt;/sup&gt; The &lt;code&gt;gets_s&lt;/code&gt; function, unlike &lt;code&gt;gets&lt;/code&gt;, makes it a runtime-constraint violation for a line of input to
  overflow the buffer to store it. Unlike &lt;code&gt;fgets&lt;/code&gt;, &lt;code&gt;gets_s&lt;/code&gt; maintains a one-to-one relationship between
  input lines and successful calls to &lt;code&gt;gets_s&lt;/code&gt;. Programs that use &lt;code&gt;gets&lt;/code&gt; expect such a relationship.</source>
          <target state="translated">&lt;sup&gt;25）&lt;/sup&gt;与 &lt;code&gt;gets&lt;/code&gt; 不同， &lt;code&gt;gets_s&lt;/code&gt; 函数使它违反了运行时约束，导致一行输入溢出缓冲区来存储它。 与 &lt;code&gt;fgets&lt;/code&gt; 不同， &lt;code&gt;gets_s&lt;/code&gt; 在输入行和对 &lt;code&gt;gets_s&lt;/code&gt; 的成功调用之间保持一对一的关系。 使用 &lt;code&gt;gets&lt;/code&gt; 程序期望这种关系。</target>
        </trans-unit>
        <trans-unit id="d47deb2fa418026ef69328b4feb307c797055743" translate="yes" xml:space="preserve">
          <source>Also, as &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; points out in a comment and &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; shows in his answer, with &lt;code&gt;fgets()&lt;/code&gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:</source>
          <target state="translated">另外，正如&lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;caf&lt;/a&gt;在评论中指出， paxdiablo在他的答案中显示的那样，使用 &lt;code&gt;fgets()&lt;/code&gt; 可能会将数据遗留在一行上。 我的包装器代码使该数据下次可以读取； 您可以根据需要随时对其进行修改，以吞噬其余数据行：</target>
        </trans-unit>
        <trans-unit id="3a577c69baeea75db56ec2bf55a2c47ccbe72969" translate="yes" xml:space="preserve">
          <source>Alternatives to &lt;code&gt;gets()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 的替代方法</target>
        </trans-unit>
        <trans-unit id="dacdb797ba8e8e112d387210f5fd7a4b54c331cd" translate="yes" xml:space="preserve">
          <source>As everyone else said, the canonical alternative to &lt;code&gt;gets()&lt;/code&gt; is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; specifying &lt;code&gt;stdin&lt;/code&gt; as the file stream.</source>
          <target state="translated">就像其他人所说的， &lt;code&gt;gets()&lt;/code&gt; 的典型替代方法是&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt; &lt;code&gt;fgets()&lt;/code&gt; ,&lt;/a&gt;将 &lt;code&gt;stdin&lt;/code&gt; 指定为文件流。</target>
        </trans-unit>
        <trans-unit id="276cab09e51e47a855dc9b87ab1220f1023257fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;gets&lt;/code&gt; doesn't do any kind of check while getting bytes from &lt;em&gt;stdin&lt;/em&gt; and putting them somewhere. A simple example:</source>
          <target state="translated">因为从&lt;em&gt;stdin&lt;/em&gt;获取字节并将它们放在某个地方时， &lt;code&gt;gets&lt;/code&gt; 不会做任何形式的检查。 一个简单的例子：</target>
        </trans-unit>
        <trans-unit id="f2c96493dd9f7f0a24eaac18c571948408967130" translate="yes" xml:space="preserve">
          <source>But this also has its problems such as:</source>
          <target state="translated">但这也有其问题,如。</target>
        </trans-unit>
        <trans-unit id="375f5f535aa6378b6f0ddc609d99ec61fd2fc369" translate="yes" xml:space="preserve">
          <source>C11 K.3.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">C11 K.3.5.4.1 &lt;code&gt;gets_s&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e0e37d77940442881c3ecdeeb4e63ff793130daf" translate="yes" xml:space="preserve">
          <source>Feel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)</source>
          <target state="translated">你可以随意使用它,我在此发布 &quot;为所欲为 &quot;的许可下使用它:-)</target>
        </trans-unit>
        <trans-unit id="24320b942db7d03958da6d14023db94004c68712" translate="yes" xml:space="preserve">
          <source>Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I'd be prepared to add an error message:</source>
          <target state="translated">考虑到你的代码迟早都会崩溃,还是早晚都会崩溃,所以还是早点把问题解决掉比较好。我会准备好添加错误信息。</target>
        </trans-unit>
        <trans-unit id="b2a1c70a047d18fa7bb41b678bcbfccc91d6d372" translate="yes" xml:space="preserve">
          <source>Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of 'programmer freedom'.</source>
          <target state="translated">希望这篇文章能让你对整场讲座的内容有兴趣,因为它让你注意到我们如何在语言中需要更多正式的正确性证明,以及语言设计者应该为语言中的错误负责,而不是程序员。这似乎是不好的语言设计者以 &quot;程序员自由 &quot;为幌子,把责任推给程序员的原因。</target>
        </trans-unit>
        <trans-unit id="271cb448109ee99e001bef107a8f3bc50b2b6f84" translate="yes" xml:space="preserve">
          <source>How can I remove this warning and why is there such a warning about using &lt;code&gt;gets()&lt;/code&gt;?</source>
          <target state="translated">如何删除此警告，为什么会有关于使用 &lt;code&gt;gets()&lt;/code&gt; 的警告？</target>
        </trans-unit>
        <trans-unit id="e4ba164e3701105ccec7d9eab6ba69fc62d2fc45" translate="yes" xml:space="preserve">
          <source>However, in the &lt;em&gt;Recommended practice&lt;/em&gt; section, &lt;code&gt;fgets()&lt;/code&gt; is still preferred.</source>
          <target state="translated">但是，在&amp;ldquo; &lt;em&gt;推荐做法&amp;rdquo;&lt;/em&gt;部分，仍然首选 &lt;code&gt;fgets()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5f1326537bd1a67f425e3007ee099675175abbb" translate="yes" xml:space="preserve">
          <source>I read recently, in a &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;USENET post to &lt;code&gt;comp.lang.c&lt;/code&gt;&lt;/a&gt;, that &lt;code&gt;gets()&lt;/code&gt; is getting removed from the Standard. &lt;strong&gt;WOOHOO&lt;/strong&gt;</source>
          <target state="translated">我最近在&lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;USENET的 &lt;code&gt;comp.lang.c&lt;/code&gt; 帖子中阅读到&lt;/a&gt; ， &lt;code&gt;gets()&lt;/code&gt; 已从标准中删除。 &lt;strong&gt;OH&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eceb5f707de5da0dab443da03e3e6e5e41328764" translate="yes" xml:space="preserve">
          <source>I remember this has something to do with stack protection and security, but I'm not sure exactly why.</source>
          <target state="translated">我记得这和堆栈保护和安全有关,但我不太清楚具体原因。</target>
        </trans-unit>
        <trans-unit id="9a0c616272856956300d35a22b16fc991d07f8ca" translate="yes" xml:space="preserve">
          <source>I would like to extend an earnest invitation to any C library maintainers out there who are still including &lt;code&gt;gets&lt;/code&gt; in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of</source>
          <target state="translated">我谨向所有仍在库中包含 &lt;code&gt;gets&lt;/code&gt; C库维护者致以诚挚的邀请：&amp;ldquo;以防万一仍然有人依赖它&amp;rdquo;：请用</target>
        </trans-unit>
        <trans-unit id="7bf781506125edfc033141ab72812799f2999203" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gets()&lt;/code&gt; is so dangerous then why can't we remove it?</source>
          <target state="translated">如果 &lt;code&gt;gets()&lt;/code&gt; 如此危险，那么为什么我们不能删除它呢？</target>
        </trans-unit>
        <trans-unit id="2225f53902789cdbd60c62ef1ae2f7be501676f7" translate="yes" xml:space="preserve">
          <source>In C11(ISO/IEC 9899:201x), &lt;code&gt;gets()&lt;/code&gt; has been removed. (It's deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))</source>
          <target state="translated">在C11（ISO / IEC 9899：201x）中， &lt;code&gt;gets()&lt;/code&gt; 已被删除。 （在ISO / IEC 9899：1999 / Cor.3：2007（E）中已弃用）</target>
        </trans-unit>
        <trans-unit id="84611e142406e2872460af2270761a3dcd9aedd8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;fgets()&lt;/code&gt;, C11 introduces a new safe alternative &lt;code&gt;gets_s()&lt;/code&gt;:</source>
          <target state="translated">除了 &lt;code&gt;fgets()&lt;/code&gt; 之外 ，C11还引入了新的安全替代方法 &lt;code&gt;gets_s()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5163be8673258f548a47017b937adce7bc283e33" translate="yes" xml:space="preserve">
          <source>In fact, ISO have actually taken the step of &lt;em&gt;removing&lt;/em&gt;&lt;code&gt;gets&lt;/code&gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.</source>
          <target state="translated">实际上，ISO实际上已经采取了从C标准中&lt;em&gt;删除&lt;/em&gt; &lt;code&gt;gets&lt;/code&gt; 的步骤（从C11开始，尽管在C99中已弃用），鉴于它们对向后兼容性的评价很高，这应该表明该功能有多糟糕。</target>
        </trans-unit>
        <trans-unit id="fc19320a49a091fc199629c4ede2786469111688" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;gets&lt;/code&gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.</source>
          <target state="translated">为了安全使用，您必须确切地知道将要读取多少个字符，以便可以使缓冲区足够大。 您只会知道，如果您确切知道将要读取的数据。</target>
        </trans-unit>
        <trans-unit id="8fde1f90e44e07a8abd3fce0c7724c0e1eae3b60" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;gets&lt;/code&gt;, you want to use &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt;&lt;code&gt;fgets&lt;/code&gt;&lt;/a&gt;, which has the signature</source>
          <target state="translated">您要使用具有签名的&lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;/a&gt;而不是使用 &lt;code&gt;gets&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98bc71dac689b4fcfc909ec3933e5b117578f4fe" translate="yes" xml:space="preserve">
          <source>It provides the same protections as &lt;code&gt;fgets&lt;/code&gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.</source>
          <target state="translated">它提供了与 &lt;code&gt;fgets&lt;/code&gt; 相同的保护，它可以防止缓冲区溢出，而且还可以通知调用者发生了什么并清除多余的字符，以免它们影响您的下一个输入操作。</target>
        </trans-unit>
        <trans-unit id="e1c25818b614ad4886532bcde8537de5f9306656" translate="yes" xml:space="preserve">
          <source>It remained an official part of the language up to the 1999 ISO C standard, but
it was officially removed by the 2011 standard. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.</source>
          <target state="translated">在1999年ISO C标准之前,它一直是C语言的官方部分,但在2011年的标准中正式删除了它。大多数C语言的实现仍然支持它,但至少gcc会对任何使用它的代码发出警告。</target>
        </trans-unit>
        <trans-unit id="42a5c3d9526dc8085da2abd8478f2b40b7ae031d" translate="yes" xml:space="preserve">
          <source>Modern versions of the Linux compilation system generates warnings if you link &lt;code&gt;gets()&lt;/code&gt; &amp;mdash; and also for some other functions that also have security problems (&lt;code&gt;mktemp()&lt;/code&gt;, &amp;hellip;).</source>
          <target state="translated">如果您链接 &lt;code&gt;gets()&lt;/code&gt; 以及其他一些也存在安全问题的函数（ &lt;code&gt;mktemp()&lt;/code&gt; &amp;hellip;），则现代版本的Linux编译系统会生成警告。</target>
        </trans-unit>
        <trans-unit id="b4f2b34526a68d26a3bc4d9dfd62c538c97d08f6" translate="yes" xml:space="preserve">
          <source>Now, first of all you are allowed to input how many characters you want, &lt;code&gt;gets&lt;/code&gt; won't care about it. Secondly the bytes over the size of the array in which you put them (in this case &lt;code&gt;array1&lt;/code&gt;) will overwrite whatever they find in memory because &lt;code&gt;gets&lt;/code&gt; will write them. In the previous example this means that if you input &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; maybe, unpredictably, it will overwrite also &lt;code&gt;array2&lt;/code&gt; or whatever.</source>
          <target state="translated">现在，首先您可以输入想要的字符个数， &lt;code&gt;gets&lt;/code&gt; 不必担心。 其次，超过放置它们的数组大小的字节（在本例中为 &lt;code&gt;array1&lt;/code&gt; ）将覆盖它们在内存中找到的所有内容，因为 &lt;code&gt;gets&lt;/code&gt; 会写入它们。 在上一个示例中，这意味着，如果您输入 &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; 可能会不可预测地将覆盖 &lt;code&gt;array2&lt;/code&gt; 或其他内容。</target>
        </trans-unit>
        <trans-unit id="198ebb642096c9df4b79446052ed1fe43d6543be" translate="yes" xml:space="preserve">
          <source>Or, better:</source>
          <target state="translated">或者说,更好。</target>
        </trans-unit>
        <trans-unit id="9c7dd7546662103cca27c658f26b4a018c8beaa4" translate="yes" xml:space="preserve">
          <source>POSIX 2008 also provides a safe alternative to &lt;code&gt;gets()&lt;/code&gt; called &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/a&gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or &lt;code&gt;-1&lt;/code&gt; (and not &lt;code&gt;EOF&lt;/code&gt;!), which means that null bytes in the input can be handled reliably.  There is also a 'choose your own single-character delimiter' variation called &lt;code&gt;getdelim()&lt;/code&gt;; this can be useful if you are dealing with the output from &lt;code&gt;find -print0&lt;/code&gt; where the ends of the file names are marked with an ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; character, for example.</source>
          <target state="translated">POSIX 2008还为 &lt;code&gt;gets()&lt;/code&gt; 提供了一个安全的替代方法，称为&lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt; &lt;code&gt;getline()&lt;/code&gt; &lt;/a&gt; 。 它为该行动态分配空间，因此最终需要释放它。 因此，它消除了对线长的限制。 它还返回读取的数据长度，或者为 &lt;code&gt;-1&lt;/code&gt; （而不是 &lt;code&gt;EOF&lt;/code&gt; ！），这意味着可以可靠地处理输入中的空字节。 还有一个名为&amp;ldquo;选择您自己的单字符定界符&amp;rdquo;的变体，称为 &lt;code&gt;getdelim()&lt;/code&gt; ； 例如，在处理 &lt;code&gt;find -print0&lt;/code&gt; 的输出时，这很有用，在该输出中文件名的末尾用ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; 字符标记。</target>
        </trans-unit>
        <trans-unit id="c0983051c063b5fe2f2d2af2af6a0cd45f15bfda" translate="yes" xml:space="preserve">
          <source>Reading a line that overflows the
  array pointed to by s results in
  undefined behavior. The use of fgets()
  is recommended.</source>
          <target state="translated">读取一个由s指向的数组溢出的行会导致未定义的行为。建议使用fgets()。</target>
        </trans-unit>
        <trans-unit id="c3ab3ad6eec1bd2048a1df66a1a4b7763d342532" translate="yes" xml:space="preserve">
          <source>Recommended practice</source>
          <target state="translated">建议的做法</target>
        </trans-unit>
        <trans-unit id="7bafc3df8bbe7113ca4bf95bc8fbacdf935c49b9" translate="yes" xml:space="preserve">
          <source>Runtime-constraints</source>
          <target state="translated">Runtime-constraints</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="9eb32d7bd20a4fdf0d3574611c1fa45b36a0d5f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; 函数允许正确编写的程序安全地处理输入行太长而无法存储在结果数组中的行。 通常，这要求 &lt;code&gt;fgets&lt;/code&gt; 调用者注意结果数组中是否存在换行符。 考虑使用 &lt;code&gt;fgets&lt;/code&gt; （以及基于换行符的所有必要处理）代替 &lt;code&gt;gets_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9893bc4b020b6f22d145585b4fbf57f8568424a9" translate="yes" xml:space="preserve">
          <source>The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:</source>
          <target state="translated">C得到函数是危险的,而且是一个代价很高的错误。Tony Hoare在他的演讲《Null References》中特别提到了它。十亿美金的错误&quot;。</target>
        </trans-unit>
        <trans-unit id="7244dce292e5a67e56330c3ae3ac70115d04c857" translate="yes" xml:space="preserve">
          <source>The C11 standard ISO/IEC 9899:2011 eliminated &lt;code&gt;gets()&lt;/code&gt; as a standard function, which is A Good Thing&amp;trade; (it was formally marked as 'obsolescent' and 'deprecated' in ISO/IEC 9899:1999/Cor.3:2007 &amp;mdash; Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning 'decades') for reasons of backwards compatibility. If it were up to me, the implementation of &lt;code&gt;gets()&lt;/code&gt; would become:</source>
          <target state="translated">C11标准ISO / IEC 9899：2011取消了 &lt;code&gt;gets()&lt;/code&gt; 作为标准功能，这是A Good Thing&amp;trade;（在ISO / IEC 9899：1999 / Cor.3：2007中正式标记为&amp;ldquo;过时&amp;rdquo;和&amp;ldquo;弃用&amp;rdquo; &amp;mdash; C99的技术勘误3，然后在C11中删除）。 可悲的是，由于向后兼容的原因，它将在图书馆中保留很多年（意思是&amp;ldquo;十年&amp;rdquo;）。 如果由我决定， &lt;code&gt;gets()&lt;/code&gt; 的实现将变为：</target>
        </trans-unit>
        <trans-unit id="84ef67f2688a48e7b376c4ba61e40d505a890822" translate="yes" xml:space="preserve">
          <source>The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.</source>
          <target state="translated">C11标准,ISOIEC 9899-2011,在附件K中包含了TR24731作为库的可选部分。不幸的是,它很少在类似Unix的系统中实现。</target>
        </trans-unit>
        <trans-unit id="9d47e50860bf8076ed169f41d7a85c4359380205" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.</source>
          <target state="translated">Microsoft Visual Studio 编译器实现了对 TR 24731-1 标准的近似值,但 Microsoft 实现的签名与 TR 中的签名之间存在差异。</target>
        </trans-unit>
        <trans-unit id="98a01dba31dbdea116f56ac87ed8248da7b6c77c" translate="yes" xml:space="preserve">
          <source>The correct thing to do is to use the &lt;code&gt;fgets&lt;/code&gt; function with the &lt;code&gt;stdin&lt;/code&gt; file handle since you can limit the characters read from the user.</source>
          <target state="translated">正确的做法是将 &lt;code&gt;fgets&lt;/code&gt; 函数与 &lt;code&gt;stdin&lt;/code&gt; 文件句柄一起使用，因为您可以限制从用户读取的字符。</target>
        </trans-unit>
        <trans-unit id="f1dcc2d6f194f7526b03d578ac0939cdcf19025f" translate="yes" xml:space="preserve">
          <source>The first internet worm (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt;) escaped about 30 years ago (1988-11-02), and it used &lt;code&gt;gets()&lt;/code&gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.</source>
          <target state="translated">第一个Internet蠕虫（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt; ）大约在30年前（1988-11-02）逃脱了，它使用 &lt;code&gt;gets()&lt;/code&gt; 和缓冲区溢出作为其在系统之间传播的方法之一。 基本问题是该函数不知道缓冲区有多大，因此它会继续读取直到找到换行符或遇到EOF为止，并且可能会溢出给定缓冲区的范围。</target>
        </trans-unit>
        <trans-unit id="7eff3cb60315bcf695059c295657cc7a122f7959" translate="yes" xml:space="preserve">
          <source>The function is unsafe because it assumes consistent input. &lt;strong&gt;NEVER USE IT!&lt;/strong&gt;</source>
          <target state="translated">该函数不安全，因为它假定输入一致。 &lt;strong&gt;永远不要使用它！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750bcf656f3974181d5e1a76edf73ad2e124ad0b" translate="yes" xml:space="preserve">
          <source>The residual problem is how to report the three different result states &amp;mdash; EOF or error, line read and not truncated, and partial line read but data was truncated.</source>
          <target state="translated">剩余的问题是如何报告三种不同的结果状态-EOF或错误，行读取但未截断，部分行读取但数据被截断。</target>
        </trans-unit>
        <trans-unit id="6fc9f99af3e43c7167d5846fb446313e960c6292" translate="yes" xml:space="preserve">
          <source>The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.</source>
          <target state="translated">整个小时是值得观看,但对于他的评论视图从30分钟的具体得到批评39分钟左右。</target>
        </trans-unit>
        <trans-unit id="9fd85043992102449a1a070298d3a4921c88db31" translate="yes" xml:space="preserve">
          <source>There is also the &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including &lt;code&gt;gets()&lt;/code&gt;:</source>
          <target state="translated">还有&lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; （C标准委员会的技术报告），它为各种功能（包括 &lt;code&gt;gets()&lt;/code&gt; ）提供了更安全的替代方法：</target>
        </trans-unit>
        <trans-unit id="a4868f32615e852c069d3803b180101b92668998" translate="yes" xml:space="preserve">
          <source>This is the reason that &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;one reference&lt;/a&gt; gives:</source>
          <target state="translated">这就是&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;一个参考&lt;/a&gt;给出的原因：</target>
        </trans-unit>
        <trans-unit id="7db094300ea01e073164a5ea03e10bb13a54db69" translate="yes" xml:space="preserve">
          <source>This problem doesn't arise with &lt;code&gt;gets()&lt;/code&gt; because it doesn't know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea &amp;mdash; they epitomize the phrase 'undefined behaviour`.</source>
          <target state="translated">使用 &lt;code&gt;gets()&lt;/code&gt; 不会出现此问题，因为它不知道缓冲区的结束位置并快乐地践踏缓冲区的末尾，从而对漂亮的内存布局造成严重破坏，如果缓冲区经常弄乱返回堆栈（ &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt; ）是在堆栈上分配的；如果动态分配了缓冲区，则践踏控制信息；如果静态分配了缓冲区，则通过其他宝贵的全局（或模块）变量复制数据。 这些都不是一个好主意-它们概括了&amp;ldquo;未定义的行为&amp;rdquo;一词。</target>
        </trans-unit>
        <trans-unit id="adf290c1c7f6be3057acb6bea5e471efc8f43c4c" translate="yes" xml:space="preserve">
          <source>This will help make sure nobody is still depending on it.  Thank you.</source>
          <target state="translated">这将有助于确保没有人还在依赖它。谢谢你的帮助</target>
        </trans-unit>
        <trans-unit id="4753e2e49fc858e5a2b2e5fbdd4113a97feee0cb" translate="yes" xml:space="preserve">
          <source>To read from the stdin:</source>
          <target state="translated">要从stdin中读取。</target>
        </trans-unit>
        <trans-unit id="4d6321faea3b1611f6eebc8bb7ca88b9b78860d8" translate="yes" xml:space="preserve">
          <source>To that end, almost every C coder at some point in their career will write a more useful wrapper around &lt;code&gt;fgets&lt;/code&gt; as well. Here's mine:</source>
          <target state="translated">为此，几乎每个C程序员在其职业生涯中的某个时候都将为 &lt;code&gt;fgets&lt;/code&gt; 编写一个更有用的包装器。 这是我的：</target>
        </trans-unit>
        <trans-unit id="ecd90ca1824950ce8dafea2df6b494288f14f8c1" translate="yes" xml:space="preserve">
          <source>What no-one else yet mentioned is that &lt;code&gt;gets()&lt;/code&gt; does not include the newline but &lt;code&gt;fgets()&lt;/code&gt; does.  So, you might need to use a wrapper around &lt;code&gt;fgets()&lt;/code&gt; that deletes the newline:</source>
          <target state="translated">还没有人提到的是， &lt;code&gt;gets()&lt;/code&gt; 不包括换行符，而 &lt;code&gt;fgets()&lt;/code&gt; 包括了换行符。 因此，您可能需要在 &lt;code&gt;fgets()&lt;/code&gt; 周围使用包装器，以删除换行符：</target>
        </trans-unit>
        <trans-unit id="08444532e7c4d0762fa2b5391bf997ac96aef445" translate="yes" xml:space="preserve">
          <source>When I try to compile C code that uses the &lt;code&gt;gets()&lt;/code&gt; function with GCC, I get this warning:</source>
          <target state="translated">当我尝试使用GCC编译使用 &lt;code&gt;gets()&lt;/code&gt; 函数的C代码时，出现以下警告：</target>
        </trans-unit>
        <trans-unit id="3b6b52ac0a4e8ac7a4e4655813bedaec02b2f479" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;gets()&lt;/code&gt; dangerous</source>
          <target state="translated">为什么 &lt;code&gt;gets()&lt;/code&gt; 很危险</target>
        </trans-unit>
        <trans-unit id="49394cee4f62a9a31d7d725e85adf763e37ad711" translate="yes" xml:space="preserve">
          <source>Why is the gets function so dangerous that it should not be used</source>
          <target state="translated">为什么GETES功能如此危险,不应该使用它?</target>
        </trans-unit>
        <trans-unit id="dd864ec14dc44123c407eae349765bb2dc5e0f85" translate="yes" xml:space="preserve">
          <source>You can't remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.</source>
          <target state="translated">你不能在不破坏API的情况下删除API函数。如果你这样做的话,很多应用程序就会不再编译或运行。</target>
        </trans-unit>
        <trans-unit id="9e49543b808f0e06f0c85a5661cdf85f9286f402" translate="yes" xml:space="preserve">
          <source>You should forget you ever heard that &lt;code&gt;gets()&lt;/code&gt; existed.</source>
          <target state="translated">您应该忘记曾经听说过 &lt;code&gt;gets()&lt;/code&gt; 存在。</target>
        </trans-unit>
        <trans-unit id="f6ff7c3689e3c944d79918636d39dc0ec7c04f02" translate="yes" xml:space="preserve">
          <source>You should not use &lt;code&gt;gets&lt;/code&gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.</source>
          <target state="translated">您不应该使用 &lt;code&gt;gets&lt;/code&gt; ,因为它无法停止缓冲区溢出。 如果用户输入的数据超出缓冲区的容量，则很可能会导致损坏甚至更糟。</target>
        </trans-unit>
        <trans-unit id="166a2a738c30b8a8caff252f1c9b03400dafc933" translate="yes" xml:space="preserve">
          <source>You'll be happy to know that the
  committee just voted (unanimously, as
  it turns out) to remove gets() from
  the draft as well.</source>
          <target state="translated">你会很高兴地知道,委员会刚刚投票(一致同意)将GETES()也从草案中删除。</target>
        </trans-unit>
        <trans-unit id="04897e3a7e24331cc83197a34a7f070c6b5ba1a8" translate="yes" xml:space="preserve">
          <source>extra characters entered by the user will be picked up the next time around.</source>
          <target state="translated">用户输入的额外字符将在下一次输入时被捡起。</target>
        </trans-unit>
        <trans-unit id="4aafe66faf6e18737060606cf1f4058a26b65c75" translate="yes" xml:space="preserve">
          <source>fgets()</source>
          <target state="translated">fgets()</target>
        </trans-unit>
        <trans-unit id="d0b0a098660d5321e56ce33e74f19c73bce34754" translate="yes" xml:space="preserve">
          <source>there's no quick notification that the user entered too much data.</source>
          <target state="translated">没有快速通知用户输入的数据太多。</target>
        </trans-unit>
        <trans-unit id="2fec03664be6d0484ac4cd6fbcac08352b5cb407" translate="yes" xml:space="preserve">
          <source>with some test code:</source>
          <target state="translated">加上一些测试代码。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
