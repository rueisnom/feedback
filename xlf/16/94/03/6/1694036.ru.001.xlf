<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1694036">
    <body>
      <group id="1694036">
        <trans-unit id="e97568ea4e112041c0cb6599eb15f6a2a791148f" translate="yes" xml:space="preserve">
          <source>&amp;sect;6.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">&amp;sect;6.5.4.1 Функция &lt;code&gt;gets_s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17518df0b5ea550ff0f27d57a4b252bf26d11988" translate="yes" xml:space="preserve">
          <source>(.text+0x34): warning: the `gets' function is dangerous and should not be used.</source>
          <target state="translated">(.text+0x34):предупреждение:функция `gets' опасна и не должна использоваться.</target>
        </trans-unit>
        <trans-unit id="c800bf27a5a07d0fefadb5b1a5ecd4f9f2ac70f1" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;fgets&lt;/code&gt;, if it reads an entire line, will leave the &lt;code&gt;'\n'&lt;/code&gt; in the string; you'll have to deal with that.)</source>
          <target state="translated">( &lt;code&gt;fgets&lt;/code&gt; , если он читает всю строку, оставит &lt;code&gt;'\n'&lt;/code&gt; в строке; вам придется с этим справиться.)</target>
        </trans-unit>
        <trans-unit id="6bc1be7c21ad64a2f919728d4a8f72e29bd67349" translate="yes" xml:space="preserve">
          <source>3 If there is a runtime-constraint violation, &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and characters
  are read and discarded from &lt;code&gt;stdin&lt;/code&gt; until a new-line character is read, or end-of-file or a
  read error occurs.</source>
          <target state="translated">3 Если есть нарушение ограничения времени выполнения, для &lt;code&gt;s[0]&lt;/code&gt; устанавливается нулевой символ, и символы считываются и отбрасываются из стандартного &lt;code&gt;stdin&lt;/code&gt; до тех пор, пока не будет прочитан символ новой строки, не произойдет конец файла или ошибка чтения.</target>
        </trans-unit>
        <trans-unit id="2c6b11246694e0a53c8eaef6d402a2f6d483a210" translate="yes" xml:space="preserve">
          <source>4 The &lt;code&gt;gets_s&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt;
  from the stream pointed to by &lt;code&gt;stdin&lt;/code&gt;, into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional
  characters are read after a new-line character (which is discarded) or after end-of-file.
  The discarded new-line character does not count towards number of characters read. A
  null character is written immediately after the last character read into the array.</source>
          <target state="translated">4 Функция &lt;code&gt;gets_s&lt;/code&gt; считывает самое большее на единицу меньше числа символов, указанного в &lt;code&gt;n&lt;/code&gt; , из потока, на который указывает &lt;code&gt;stdin&lt;/code&gt; , в массив, на который указывает &lt;code&gt;s&lt;/code&gt; . Никакие дополнительные символы не читаются после символа новой строки (который отбрасывается) или после конца файла. Выброшенный символ новой строки не учитывается в количестве прочитанных символов. Нулевой символ записывается сразу после последнего прочитанного символа в массив.</target>
        </trans-unit>
        <trans-unit id="871d5200809b27e3005fc171c5add16863eb429c" translate="yes" xml:space="preserve">
          <source>5 If end-of-file is encountered and no characters have been read into the array, or if a read
  error occurs during the operation, then &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and the other
  elements of &lt;code&gt;s&lt;/code&gt; take unspecified values.</source>
          <target state="translated">5 Если обнаружен конец файла, и в массив не было прочитано ни одного символа, или если во время операции возникла ошибка чтения, то для &lt;code&gt;s[0]&lt;/code&gt; устанавливается нулевой символ, а другие элементы &lt;code&gt;s&lt;/code&gt; принимают неопределенные значения ,</target>
        </trans-unit>
        <trans-unit id="ed163a0ef4f509855327416f1f2b9ccda77aeeb8" translate="yes" xml:space="preserve">
          <source>6 The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">6 Функция &lt;code&gt;fgets&lt;/code&gt; позволяет правильно написанным программам безопасно обрабатывать строки ввода, слишком длинные для хранения в массиве результатов. В общем случае это требует, чтобы вызывающие функции &lt;code&gt;fgets&lt;/code&gt; обращали внимание на наличие или отсутствие символа новой строки в массиве результатов. Попробуйте использовать &lt;code&gt;fgets&lt;/code&gt; (вместе с любой необходимой обработкой, основанной на символах новой строки) вместо &lt;code&gt;gets_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0d48e496596a430fc0e8ae6d905f708329be4d7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c82c7b8bf8ffe3eb68fdc9b9a00c4519c5ff30ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fgets()&lt;/code&gt; allows you to specify how many characters are taken out of the standard input buffer, so they don't overrun the variable.</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; позволяет вам указать, сколько символов вынимается из стандартного входного буфера, чтобы они не выходили за пределы переменной.</target>
        </trans-unit>
        <trans-unit id="8bf95efd9191a7a3774dd9d7416afbf3b8c75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</source>
          <target state="translated">&lt;code&gt;getline()&lt;/code&gt; - POSIX</target>
        </trans-unit>
        <trans-unit id="8159d16eefb5f350c2e02c79e3cecfbaf46ad0cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gets()&lt;/code&gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can't detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person's name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; опасен, потому что пользователь может аварийно завершить работу программы, набрав слишком много в приглашении. Он не может определить конец доступной памяти, поэтому, если вы выделите слишком мало памяти для этой цели, это может вызвать сбой сегмента и сбой. Иногда кажется маловероятным, чтобы пользователь набрал 1000 букв в приглашении, предназначенном для имени человека, но как программисты мы должны сделать наши программы пуленепробиваемыми. (это также может представлять угрозу безопасности, если пользователь может завершить работу системной программы, отправив слишком много данных).</target>
        </trans-unit>
        <trans-unit id="6adcc51eed96f7c3fbc2eba2e501ef8ab2436d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; shall not be a null pointer. &lt;code&gt;n&lt;/code&gt; shall neither be equal to zero nor be greater than
  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading
  &lt;code&gt;n-1&lt;/code&gt; characters from &lt;code&gt;stdin&lt;/code&gt;.&lt;sup&gt;25)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; не должен быть нулевым указателем. &lt;code&gt;n&lt;/code&gt; не должно быть равно нулю или быть больше RSIZE_MAX. Символ новой строки, конец файла или ошибка чтения должны возникать при чтении &lt;code&gt;n-1&lt;/code&gt; символов из &lt;code&gt;stdin&lt;/code&gt; . &lt;sup&gt;25)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32999174ab5c86638eab236eddb300aaa124ae76" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;25)&lt;/sup&gt; The &lt;code&gt;gets_s&lt;/code&gt; function, unlike &lt;code&gt;gets&lt;/code&gt;, makes it a runtime-constraint violation for a line of input to
  overflow the buffer to store it. Unlike &lt;code&gt;fgets&lt;/code&gt;, &lt;code&gt;gets_s&lt;/code&gt; maintains a one-to-one relationship between
  input lines and successful calls to &lt;code&gt;gets_s&lt;/code&gt;. Programs that use &lt;code&gt;gets&lt;/code&gt; expect such a relationship.</source>
          <target state="translated">&lt;sup&gt;25)&lt;/sup&gt; Функция &lt;code&gt;gets_s&lt;/code&gt; , в отличие от &lt;code&gt;gets&lt;/code&gt; , делает нарушение ограничения времени выполнения для строки ввода переполнением буфера для ее хранения. В отличие от &lt;code&gt;fgets&lt;/code&gt; , &lt;code&gt;gets_s&lt;/code&gt; поддерживает взаимно-однозначное соотношение между строками ввода и успешными вызовами &lt;code&gt;gets_s&lt;/code&gt; . Программы, которые используют, ожидают таких отношений.</target>
        </trans-unit>
        <trans-unit id="d47deb2fa418026ef69328b4feb307c797055743" translate="yes" xml:space="preserve">
          <source>Also, as &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; points out in a comment and &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; shows in his answer, with &lt;code&gt;fgets()&lt;/code&gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:</source>
          <target state="translated">Кроме того, как отмечает &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; в комментарии, а &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; показывает в своем ответе, с помощью &lt;code&gt;fgets()&lt;/code&gt; вас могут остаться данные в строке. Мой код оболочки оставляет эти данные для чтения в следующий раз; вы можете легко изменить его, чтобы поглотить остальную часть строки данных, если вы предпочитаете:</target>
        </trans-unit>
        <trans-unit id="3a577c69baeea75db56ec2bf55a2c47ccbe72969" translate="yes" xml:space="preserve">
          <source>Alternatives to &lt;code&gt;gets()&lt;/code&gt;</source>
          <target state="translated">Альтернативы &lt;code&gt;gets()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dacdb797ba8e8e112d387210f5fd7a4b54c331cd" translate="yes" xml:space="preserve">
          <source>As everyone else said, the canonical alternative to &lt;code&gt;gets()&lt;/code&gt; is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; specifying &lt;code&gt;stdin&lt;/code&gt; as the file stream.</source>
          <target state="translated">Как и все остальные, каноническая альтернатива &lt;code&gt;gets()&lt;/code&gt; - это &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt; &lt;code&gt;fgets()&lt;/code&gt; &lt;/a&gt; указывающая &lt;code&gt;stdin&lt;/code&gt; в качестве файлового потока.</target>
        </trans-unit>
        <trans-unit id="276cab09e51e47a855dc9b87ab1220f1023257fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;gets&lt;/code&gt; doesn't do any kind of check while getting bytes from &lt;em&gt;stdin&lt;/em&gt; and putting them somewhere. A simple example:</source>
          <target state="translated">Потому что &lt;code&gt;gets&lt;/code&gt; не выполняет никаких проверок при получении байтов из &lt;em&gt;stdin&lt;/em&gt; и их размещении где-либо. Простой пример:</target>
        </trans-unit>
        <trans-unit id="f2c96493dd9f7f0a24eaac18c571948408967130" translate="yes" xml:space="preserve">
          <source>But this also has its problems such as:</source>
          <target state="translated">Но у этого есть и свои проблемы:</target>
        </trans-unit>
        <trans-unit id="375f5f535aa6378b6f0ddc609d99ec61fd2fc369" translate="yes" xml:space="preserve">
          <source>C11 K.3.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">C11 K.3.5.4.1 Функция &lt;code&gt;gets_s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e0e37d77940442881c3ecdeeb4e63ff793130daf" translate="yes" xml:space="preserve">
          <source>Feel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)</source>
          <target state="translated">Не стесняйтесь использовать его по своему усмотрению,настоящим я выпускаю его под лицензией &quot;делайте то,что вы,черт возьми,хотите&quot; :-).</target>
        </trans-unit>
        <trans-unit id="24320b942db7d03958da6d14023db94004c68712" translate="yes" xml:space="preserve">
          <source>Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I'd be prepared to add an error message:</source>
          <target state="translated">Учитывая,что ваш код все равно рано или поздно рухнет,лучше рано или поздно устранить проблему.Я буду готов добавить сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="b2a1c70a047d18fa7bb41b678bcbfccc91d6d372" translate="yes" xml:space="preserve">
          <source>Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of 'programmer freedom'.</source>
          <target state="translated">Надеюсь,это подогреет аппетит на весь разговор,что привлекает внимание к тому,как нужны более формальные доказательства корректности в языках и как винить дизайнеров языка в ошибках в их языках,а не программиста.Похоже,что это и есть та самая сомнительная причина,по которой дизайнеры плохих языков перекладывают вину на программистов под видом &quot;свободы программиста&quot;.</target>
        </trans-unit>
        <trans-unit id="271cb448109ee99e001bef107a8f3bc50b2b6f84" translate="yes" xml:space="preserve">
          <source>How can I remove this warning and why is there such a warning about using &lt;code&gt;gets()&lt;/code&gt;?</source>
          <target state="translated">Как я могу удалить это предупреждение и почему появляется такое предупреждение об использовании &lt;code&gt;gets()&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e4ba164e3701105ccec7d9eab6ba69fc62d2fc45" translate="yes" xml:space="preserve">
          <source>However, in the &lt;em&gt;Recommended practice&lt;/em&gt; section, &lt;code&gt;fgets()&lt;/code&gt; is still preferred.</source>
          <target state="translated">Тем не менее, в разделе &lt;em&gt;Рекомендуемая практика&lt;/em&gt; &lt;code&gt;fgets()&lt;/code&gt; по-прежнему предпочтительнее.</target>
        </trans-unit>
        <trans-unit id="d5f1326537bd1a67f425e3007ee099675175abbb" translate="yes" xml:space="preserve">
          <source>I read recently, in a &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;USENET post to &lt;code&gt;comp.lang.c&lt;/code&gt;&lt;/a&gt;, that &lt;code&gt;gets()&lt;/code&gt; is getting removed from the Standard. &lt;strong&gt;WOOHOO&lt;/strong&gt;</source>
          <target state="translated">Я недавно прочитал в &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;посте USENET для &lt;code&gt;comp.lang.c&lt;/code&gt; &lt;/a&gt; , что &lt;code&gt;gets()&lt;/code&gt; удаляется из Стандарта. &lt;strong&gt;WooHoo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eceb5f707de5da0dab443da03e3e6e5e41328764" translate="yes" xml:space="preserve">
          <source>I remember this has something to do with stack protection and security, but I'm not sure exactly why.</source>
          <target state="translated">Я помню,что это как-то связано с защитой и безопасностью стека,но я не совсем понимаю,почему.</target>
        </trans-unit>
        <trans-unit id="9a0c616272856956300d35a22b16fc991d07f8ca" translate="yes" xml:space="preserve">
          <source>I would like to extend an earnest invitation to any C library maintainers out there who are still including &lt;code&gt;gets&lt;/code&gt; in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of</source>
          <target state="translated">Я хотел бы направить искреннее приглашение всем сопровождающим библиотек C, которые все еще включают в свои библиотеки &amp;laquo;на всякий случай, если кто-то еще полагается на это&amp;raquo;: пожалуйста, замените вашу реализацию эквивалентом</target>
        </trans-unit>
        <trans-unit id="7bf781506125edfc033141ab72812799f2999203" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gets()&lt;/code&gt; is so dangerous then why can't we remove it?</source>
          <target state="translated">Если &lt;code&gt;gets()&lt;/code&gt; настолько опасен, то почему мы не можем его удалить?</target>
        </trans-unit>
        <trans-unit id="2225f53902789cdbd60c62ef1ae2f7be501676f7" translate="yes" xml:space="preserve">
          <source>In C11(ISO/IEC 9899:201x), &lt;code&gt;gets()&lt;/code&gt; has been removed. (It's deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))</source>
          <target state="translated">В C11 (ISO / IEC 9899: 201x) функция &lt;code&gt;gets()&lt;/code&gt; была удалена. (Это устарело в ISO / IEC 9899: 1999 / Cor.3: 2007 (E))</target>
        </trans-unit>
        <trans-unit id="84611e142406e2872460af2270761a3dcd9aedd8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;fgets()&lt;/code&gt;, C11 introduces a new safe alternative &lt;code&gt;gets_s()&lt;/code&gt;:</source>
          <target state="translated">В дополнение к &lt;code&gt;fgets()&lt;/code&gt; , C11 представляет новую безопасную альтернативу &lt;code&gt;gets_s()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5163be8673258f548a47017b937adce7bc283e33" translate="yes" xml:space="preserve">
          <source>In fact, ISO have actually taken the step of &lt;em&gt;removing&lt;/em&gt;&lt;code&gt;gets&lt;/code&gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.</source>
          <target state="translated">Фактически, ISO фактически предпринял шаг, &lt;em&gt;удалив&lt;/em&gt; &lt;code&gt;gets&lt;/code&gt; из стандарта C (начиная с C11, хотя в C99 он был признан устаревшим), который, учитывая, насколько высоко они оценивают обратную совместимость, должен указывать на то, насколько плохой была эта функция.</target>
        </trans-unit>
        <trans-unit id="fc19320a49a091fc199629c4ede2786469111688" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;gets&lt;/code&gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.</source>
          <target state="translated">Чтобы безопасно использовать get, вы должны точно знать, сколько символов вы будете читать, чтобы вы могли сделать свой буфер достаточно большим. Вы будете знать это только в том случае, если точно знаете, какие данные вы будете читать.</target>
        </trans-unit>
        <trans-unit id="8fde1f90e44e07a8abd3fce0c7724c0e1eae3b60" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;gets&lt;/code&gt;, you want to use &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt;&lt;code&gt;fgets&lt;/code&gt;&lt;/a&gt;, which has the signature</source>
          <target state="translated">Вместо использования &lt;code&gt;gets&lt;/code&gt; вы хотите использовать &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;/a&gt; с подписью</target>
        </trans-unit>
        <trans-unit id="98bc71dac689b4fcfc909ec3933e5b117578f4fe" translate="yes" xml:space="preserve">
          <source>It provides the same protections as &lt;code&gt;fgets&lt;/code&gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.</source>
          <target state="translated">Он обеспечивает ту же защиту, что и &lt;code&gt;fgets&lt;/code&gt; , в том смысле, что он предотвращает переполнение буфера, но также уведомляет вызывающую сторону о том, что произошло, и удаляет лишние символы, чтобы они не влияли на вашу следующую операцию ввода.</target>
        </trans-unit>
        <trans-unit id="e1c25818b614ad4886532bcde8537de5f9306656" translate="yes" xml:space="preserve">
          <source>It remained an official part of the language up to the 1999 ISO C standard, but
it was officially removed by the 2011 standard. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.</source>
          <target state="translated">Он оставался официальной частью языка вплоть до стандарта ИСО С 1999 года,но был официально удален стандартом 2011 года.Большинство реализаций С по-прежнему поддерживают его,но,по крайней мере,gcc выдает предупреждение на любой код,который его использует.</target>
        </trans-unit>
        <trans-unit id="42a5c3d9526dc8085da2abd8478f2b40b7ae031d" translate="yes" xml:space="preserve">
          <source>Modern versions of the Linux compilation system generates warnings if you link &lt;code&gt;gets()&lt;/code&gt; &amp;mdash; and also for some other functions that also have security problems (&lt;code&gt;mktemp()&lt;/code&gt;, &amp;hellip;).</source>
          <target state="translated">Современные версии системы компиляции Linux генерируют предупреждения при ссылке &lt;code&gt;gets()&lt;/code&gt; а также для некоторых других функций, которые также имеют проблемы с безопасностью ( &lt;code&gt;mktemp()&lt;/code&gt; ,&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="b4f2b34526a68d26a3bc4d9dfd62c538c97d08f6" translate="yes" xml:space="preserve">
          <source>Now, first of all you are allowed to input how many characters you want, &lt;code&gt;gets&lt;/code&gt; won't care about it. Secondly the bytes over the size of the array in which you put them (in this case &lt;code&gt;array1&lt;/code&gt;) will overwrite whatever they find in memory because &lt;code&gt;gets&lt;/code&gt; will write them. In the previous example this means that if you input &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; maybe, unpredictably, it will overwrite also &lt;code&gt;array2&lt;/code&gt; or whatever.</source>
          <target state="translated">Теперь, во-первых, вам разрешено вводить, сколько символов вы хотите, &lt;code&gt;gets&lt;/code&gt; не будет заботиться об этом. Во-вторых, байты по размеру массива, в который вы их помещаете (в данном случае &lt;code&gt;array1&lt;/code&gt; ), будут перезаписывать все, что они находят в памяти, потому что get будет их записывать. В предыдущем примере это означает, что если вы &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; возможно, непредсказуемо, он будет перезаписывать также &lt;code&gt;array2&lt;/code&gt; или что-то еще.</target>
        </trans-unit>
        <trans-unit id="198ebb642096c9df4b79446052ed1fe43d6543be" translate="yes" xml:space="preserve">
          <source>Or, better:</source>
          <target state="translated">Или,лучше:</target>
        </trans-unit>
        <trans-unit id="9c7dd7546662103cca27c658f26b4a018c8beaa4" translate="yes" xml:space="preserve">
          <source>POSIX 2008 also provides a safe alternative to &lt;code&gt;gets()&lt;/code&gt; called &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/a&gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or &lt;code&gt;-1&lt;/code&gt; (and not &lt;code&gt;EOF&lt;/code&gt;!), which means that null bytes in the input can be handled reliably.  There is also a 'choose your own single-character delimiter' variation called &lt;code&gt;getdelim()&lt;/code&gt;; this can be useful if you are dealing with the output from &lt;code&gt;find -print0&lt;/code&gt; where the ends of the file names are marked with an ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; character, for example.</source>
          <target state="translated">POSIX 2008 также предоставляет безопасную альтернативу &lt;code&gt;gets()&lt;/code&gt; называемую &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt; &lt;code&gt;getline()&lt;/code&gt; &lt;/a&gt; . Он динамически распределяет пространство для строки, поэтому вам, в конечном итоге, придется ее освободить. Таким образом, он снимает ограничение на длину строки. Он также возвращает длину прочитанных данных или &lt;code&gt;-1&lt;/code&gt; (а не &lt;code&gt;EOF&lt;/code&gt; !), Что означает, что нулевые байты на входе могут быть надежно обработаны. Существует также вариант &amp;laquo;выберите свой собственный односимвольный разделитель&amp;raquo;, называемый &lt;code&gt;getdelim()&lt;/code&gt; ; это может быть полезно, если вы имеете дело с выводом команды &lt;code&gt;find -print0&lt;/code&gt; , где, например, концы имен файлов помечены символом ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0983051c063b5fe2f2d2af2af6a0cd45f15bfda" translate="yes" xml:space="preserve">
          <source>Reading a line that overflows the
  array pointed to by s results in
  undefined behavior. The use of fgets()
  is recommended.</source>
          <target state="translated">Чтение строки,перекрывающей массив,на который указывает s,приводит к неопределенному поведению.Рекомендуется использовать функцию fgets().</target>
        </trans-unit>
        <trans-unit id="c3ab3ad6eec1bd2048a1df66a1a4b7763d342532" translate="yes" xml:space="preserve">
          <source>Recommended practice</source>
          <target state="translated">Рекомендуемая практика</target>
        </trans-unit>
        <trans-unit id="7bafc3df8bbe7113ca4bf95bc8fbacdf935c49b9" translate="yes" xml:space="preserve">
          <source>Runtime-constraints</source>
          <target state="translated">Runtime-constraints</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="9eb32d7bd20a4fdf0d3574611c1fa45b36a0d5f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;fgets&lt;/code&gt; позволяет правильно написанным программам безопасно обрабатывать входные строки, слишком длинные для хранения в массиве результатов. В общем случае это требует, чтобы вызывающие функции &lt;code&gt;fgets&lt;/code&gt; обращали внимание на наличие или отсутствие символа новой строки в массиве результатов. Попробуйте использовать &lt;code&gt;fgets&lt;/code&gt; (вместе с любой необходимой обработкой, основанной на символах новой строки) вместо &lt;code&gt;gets_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9893bc4b020b6f22d145585b4fbf57f8568424a9" translate="yes" xml:space="preserve">
          <source>The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:</source>
          <target state="translated">C получает функцию опасна и была очень дорогостоящей ошибкой.Тони Хоар выделяет его для конкретного упоминания в своем докладе &quot;Null References:Ошибка на миллиард долларов&quot;:</target>
        </trans-unit>
        <trans-unit id="7244dce292e5a67e56330c3ae3ac70115d04c857" translate="yes" xml:space="preserve">
          <source>The C11 standard ISO/IEC 9899:2011 eliminated &lt;code&gt;gets()&lt;/code&gt; as a standard function, which is A Good Thing&amp;trade; (it was formally marked as 'obsolescent' and 'deprecated' in ISO/IEC 9899:1999/Cor.3:2007 &amp;mdash; Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning 'decades') for reasons of backwards compatibility. If it were up to me, the implementation of &lt;code&gt;gets()&lt;/code&gt; would become:</source>
          <target state="translated">Стандарт C11 ISO / IEC 9899: 2011 исключает &lt;code&gt;gets()&lt;/code&gt; в качестве стандартной функции, которая называется A Good Thing &amp;trade; (она была официально помечена как &amp;laquo;устаревшая&amp;raquo; и &amp;laquo;устарела&amp;raquo; в ISO / IEC 9899: 1999 / Cor.3: 2007). - Техническое исправление 3 для C99, а затем удалено в C11). К сожалению, из-за обратной совместимости он будет храниться в библиотеках в течение многих лет (что означает &amp;laquo;десятилетия&amp;raquo;). Если бы это было до меня, реализация &lt;code&gt;gets()&lt;/code&gt; стала бы:</target>
        </trans-unit>
        <trans-unit id="84ef67f2688a48e7b376c4ba61e40d505a890822" translate="yes" xml:space="preserve">
          <source>The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.</source>
          <target state="translated">Стандарт C11,ISOIEC 9899-2011,включает TR24731 в приложение K в качестве факультативной части библиотеки.К сожалению,он редко реализуется на Unix-подобных системах.</target>
        </trans-unit>
        <trans-unit id="9d47e50860bf8076ed169f41d7a85c4359380205" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.</source>
          <target state="translated">Компиляторы Microsoft Visual Studio реализуют приближение к стандарту TR 24731-1,однако есть различия между сигнатурами,реализованными Microsoft и TR.</target>
        </trans-unit>
        <trans-unit id="98a01dba31dbdea116f56ac87ed8248da7b6c77c" translate="yes" xml:space="preserve">
          <source>The correct thing to do is to use the &lt;code&gt;fgets&lt;/code&gt; function with the &lt;code&gt;stdin&lt;/code&gt; file handle since you can limit the characters read from the user.</source>
          <target state="translated">Правильнее всего использовать функцию &lt;code&gt;fgets&lt;/code&gt; с дескриптором файла &lt;code&gt;stdin&lt;/code&gt; , поскольку вы можете ограничить число символов, читаемых пользователем.</target>
        </trans-unit>
        <trans-unit id="f1dcc2d6f194f7526b03d578ac0939cdcf19025f" translate="yes" xml:space="preserve">
          <source>The first internet worm (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt;) escaped about 30 years ago (1988-11-02), and it used &lt;code&gt;gets()&lt;/code&gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.</source>
          <target state="translated">Первый интернет-червь ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt; ) сбежал около 30 лет назад (1988-11-02), и он использовал get &lt;code&gt;gets()&lt;/code&gt; и переполнение буфера в качестве одного из методов распространения от системы к системе. Основная проблема заключается в том, что функция не знает, насколько велик буфер, поэтому она продолжает чтение, пока не найдет новую строку или не встретит EOF, и может переполнить границы заданного буфера.</target>
        </trans-unit>
        <trans-unit id="7eff3cb60315bcf695059c295657cc7a122f7959" translate="yes" xml:space="preserve">
          <source>The function is unsafe because it assumes consistent input. &lt;strong&gt;NEVER USE IT!&lt;/strong&gt;</source>
          <target state="translated">Функция небезопасна, потому что предполагает согласованный ввод. &lt;strong&gt;НИКОГДА НЕ ИСПОЛЬЗУЙТЕ ЕГО!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750bcf656f3974181d5e1a76edf73ad2e124ad0b" translate="yes" xml:space="preserve">
          <source>The residual problem is how to report the three different result states &amp;mdash; EOF or error, line read and not truncated, and partial line read but data was truncated.</source>
          <target state="translated">Остаточная проблема заключается в том, как сообщать о трех различных состояниях результата - EOF или ошибке, чтение строки не усечено, а частично прочитано, но данные были усечены.</target>
        </trans-unit>
        <trans-unit id="6fc9f99af3e43c7167d5846fb446313e960c6292" translate="yes" xml:space="preserve">
          <source>The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.</source>
          <target state="translated">Весь час стоит посмотреть,но за его комментарии вид из 30 минут с учетом специфики подвергается критике около 39 минут.</target>
        </trans-unit>
        <trans-unit id="9fd85043992102449a1a070298d3a4921c88db31" translate="yes" xml:space="preserve">
          <source>There is also the &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including &lt;code&gt;gets()&lt;/code&gt;:</source>
          <target state="translated">Существует также &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Технический отчет от Стандартного комитета C), который предоставляет более безопасные альтернативы множеству функций, включая &lt;code&gt;gets()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a4868f32615e852c069d3803b180101b92668998" translate="yes" xml:space="preserve">
          <source>This is the reason that &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;one reference&lt;/a&gt; gives:</source>
          <target state="translated">Это причина того, что &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;одна ссылка&lt;/a&gt; дает:</target>
        </trans-unit>
        <trans-unit id="7db094300ea01e073164a5ea03e10bb13a54db69" translate="yes" xml:space="preserve">
          <source>This problem doesn't arise with &lt;code&gt;gets()&lt;/code&gt; because it doesn't know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea &amp;mdash; they epitomize the phrase 'undefined behaviour`.</source>
          <target state="translated">Эта проблема не возникает с &lt;code&gt;gets()&lt;/code&gt; потому что она не знает, где заканчивается ваш буфер, и весело растоптывает за ее пределами, нанося ущерб вашей красиво улаженной структуре памяти, часто путая возвращаемый стек ( &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;переполнение стека&lt;/a&gt; ), если буфер выделяется в стеке, либо попирает управляющую информацию, если буфер динамически распределяется, либо копирует данные в другие важные глобальные (или модульные) переменные, если буфер статически распределен. Ничто из этого не является хорошей идеей - они воплощают фразу &amp;laquo;неопределенное поведение&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="adf290c1c7f6be3057acb6bea5e471efc8f43c4c" translate="yes" xml:space="preserve">
          <source>This will help make sure nobody is still depending on it.  Thank you.</source>
          <target state="translated">Это поможет убедиться,что никто от этого не зависит.Спасибо.</target>
        </trans-unit>
        <trans-unit id="4753e2e49fc858e5a2b2e5fbdd4113a97feee0cb" translate="yes" xml:space="preserve">
          <source>To read from the stdin:</source>
          <target state="translated">Читать из венецианского:</target>
        </trans-unit>
        <trans-unit id="4d6321faea3b1611f6eebc8bb7ca88b9b78860d8" translate="yes" xml:space="preserve">
          <source>To that end, almost every C coder at some point in their career will write a more useful wrapper around &lt;code&gt;fgets&lt;/code&gt; as well. Here's mine:</source>
          <target state="translated">С этой целью почти каждый C-кодер в какой-то момент своей карьеры также напишет более полезную оболочку для &lt;code&gt;fgets&lt;/code&gt; . Вот мой:</target>
        </trans-unit>
        <trans-unit id="ecd90ca1824950ce8dafea2df6b494288f14f8c1" translate="yes" xml:space="preserve">
          <source>What no-one else yet mentioned is that &lt;code&gt;gets()&lt;/code&gt; does not include the newline but &lt;code&gt;fgets()&lt;/code&gt; does.  So, you might need to use a wrapper around &lt;code&gt;fgets()&lt;/code&gt; that deletes the newline:</source>
          <target state="translated">Что еще никто не упомянул, так это то, что &lt;code&gt;gets()&lt;/code&gt; не включает символ новой строки, а &lt;code&gt;fgets()&lt;/code&gt; . Таким образом, вам может понадобиться обертка вокруг &lt;code&gt;fgets()&lt;/code&gt; которая удаляет символ новой строки:</target>
        </trans-unit>
        <trans-unit id="08444532e7c4d0762fa2b5391bf997ac96aef445" translate="yes" xml:space="preserve">
          <source>When I try to compile C code that uses the &lt;code&gt;gets()&lt;/code&gt; function with GCC, I get this warning:</source>
          <target state="translated">Когда я пытаюсь скомпилировать код C, который использует функцию &lt;code&gt;gets()&lt;/code&gt; с GCC, я получаю это предупреждение:</target>
        </trans-unit>
        <trans-unit id="3b6b52ac0a4e8ac7a4e4655813bedaec02b2f479" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;gets()&lt;/code&gt; dangerous</source>
          <target state="translated">Почему &lt;code&gt;gets()&lt;/code&gt; опасным</target>
        </trans-unit>
        <trans-unit id="49394cee4f62a9a31d7d725e85adf763e37ad711" translate="yes" xml:space="preserve">
          <source>Why is the gets function so dangerous that it should not be used</source>
          <target state="translated">Почему функция get настолько опасна,что ее не следует использовать.</target>
        </trans-unit>
        <trans-unit id="dd864ec14dc44123c407eae349765bb2dc5e0f85" translate="yes" xml:space="preserve">
          <source>You can't remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.</source>
          <target state="translated">Нельзя удалить функции API,не взломав API.Если бы вы это сделали,многие приложения перестали бы компилироваться или запускаться вообще.</target>
        </trans-unit>
        <trans-unit id="9e49543b808f0e06f0c85a5661cdf85f9286f402" translate="yes" xml:space="preserve">
          <source>You should forget you ever heard that &lt;code&gt;gets()&lt;/code&gt; existed.</source>
          <target state="translated">Вы должны забыть, что когда-либо слышали, что &lt;code&gt;gets()&lt;/code&gt; существует.</target>
        </trans-unit>
        <trans-unit id="f6ff7c3689e3c944d79918636d39dc0ec7c04f02" translate="yes" xml:space="preserve">
          <source>You should not use &lt;code&gt;gets&lt;/code&gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.</source>
          <target state="translated">Вы не должны использовать &lt;code&gt;gets&lt;/code&gt; поскольку он не может остановить переполнение буфера. Если пользователь вводит больше данных, чем может поместиться в вашем буфере, вы, скорее всего, в конечном итоге будете повреждены или хуже.</target>
        </trans-unit>
        <trans-unit id="166a2a738c30b8a8caff252f1c9b03400dafc933" translate="yes" xml:space="preserve">
          <source>You'll be happy to know that the
  committee just voted (unanimously, as
  it turns out) to remove gets() from
  the draft as well.</source>
          <target state="translated">Вы будете рады узнать,что комитет только что проголосовал (единогласно,как оказалось)за то,чтобы убрать get()из проекта.</target>
        </trans-unit>
        <trans-unit id="04897e3a7e24331cc83197a34a7f070c6b5ba1a8" translate="yes" xml:space="preserve">
          <source>extra characters entered by the user will be picked up the next time around.</source>
          <target state="translated">Дополнительные символы,введенные пользователем,будут отображаться в следующий раз.</target>
        </trans-unit>
        <trans-unit id="4aafe66faf6e18737060606cf1f4058a26b65c75" translate="yes" xml:space="preserve">
          <source>fgets()</source>
          <target state="translated">fgets()</target>
        </trans-unit>
        <trans-unit id="d0b0a098660d5321e56ce33e74f19c73bce34754" translate="yes" xml:space="preserve">
          <source>there's no quick notification that the user entered too much data.</source>
          <target state="translated">нет быстрого уведомления о том,что пользователь ввел слишком много данных.</target>
        </trans-unit>
        <trans-unit id="2fec03664be6d0484ac4cd6fbcac08352b5cb407" translate="yes" xml:space="preserve">
          <source>with some test code:</source>
          <target state="translated">с каким-то тестовым кодом:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
