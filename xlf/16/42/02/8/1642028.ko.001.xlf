<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1642028">
    <body>
      <group id="1642028">
        <trans-unit id="65a0c1838b070466053e907605ce7058494f48e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; obey the &quot;maximum munch&quot; rule. The same way a---b is translated to &lt;code&gt;(a--) - b&lt;/code&gt;, in your case  &lt;code&gt;x--&amp;gt;0&lt;/code&gt; translates to &lt;code&gt;(x--)&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt; 는 &quot;최대 뭉크&quot;규칙을 따릅니다. a --- b가 &lt;code&gt;(a--) - b&lt;/code&gt; b로 변환되는 것과 같은 방식으로, 귀하의 경우 &lt;code&gt;x--&amp;gt;0&lt;/code&gt; 은 &lt;code&gt;(x--)&amp;gt;0&lt;/code&gt; 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="474934e5c57f3c9ec09a4a98ec8d90587f15124f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(x --&amp;gt; 0)&lt;/code&gt; means &lt;code&gt;(x-- &amp;gt; 0)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(x --&amp;gt; 0)&lt;/code&gt; 은 (x--&amp;gt; 0)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="262abdc514266d81aaa36903024d9fb5740f0ae2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&amp;gt;&lt;/code&gt; is not an operator. It is in fact two separate operators, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&amp;gt;&lt;/code&gt; 는 연산자가 아닙니다. 실제로 두 개의 별도 연산자 인 &lt;code&gt;--&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="613d74405937bc963fb1c26b8207c810c368c5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; is the &lt;strong&gt;decrement&lt;/strong&gt; operator and &lt;code&gt;&amp;gt;&lt;/code&gt; is the &lt;strong&gt;greater-than&lt;/strong&gt; operator.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 는 &lt;strong&gt;감소&lt;/strong&gt; 연산자이고 &lt;code&gt;&amp;gt;&lt;/code&gt; 는 &lt;strong&gt;보다 큼&lt;/strong&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="d682ac29a8e11ac3ac552b5d2c678aade25e9c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x--&lt;/code&gt; (post decrement) is equivalent to &lt;code&gt;x = x-1&lt;/code&gt; so, the code transforms to:</source>
          <target state="translated">&lt;code&gt;x--&lt;/code&gt; (포스트 감소)는 &lt;code&gt;x = x-1&lt;/code&gt; 과 동일하므로 코드는 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="04906c892c48d262a6ee8f54d5645f1aa5c3923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; can go to zero even faster in the opposite direction:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 반대 방향으로 더 빨리 0으로 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c445d6bd1b64e90993378e42da434dd274ec4d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The same rule&lt;/strong&gt; applies to this expression:</source>
          <target state="translated">이 표현식에도 &lt;strong&gt;동일한 규칙이&lt;/strong&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="245836dbc9ce8839d802c798c246a55d62658561" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To better understand, the statement could be written as follows:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이해를 돕기 위해 다음과 같이 진술을 작성할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53c645d36d2a22094156da525b49a2497a65e898" translate="yes" xml:space="preserve">
          <source>Actually, &lt;code&gt;x&lt;/code&gt; is post-decrementing and with that condition is being checked. It's not &lt;code&gt;--&amp;gt;&lt;/code&gt;, it's &lt;code&gt;(x--) &amp;gt; 0&lt;/code&gt;</source>
          <target state="translated">실제로, &lt;code&gt;x&lt;/code&gt; 는 감소 후이고 그 상태를 점검하고 있습니다. &lt;code&gt;--&amp;gt;&lt;/code&gt; 이 아니며 (x -- &lt;code&gt;(x--) &amp;gt; 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f65db2ed72e6d7051fbad69d36948d2061678376" translate="yes" xml:space="preserve">
          <source>After parse:</source>
          <target state="translated">파싱 ​​후 :</target>
        </trans-unit>
        <trans-unit id="f1c7ac9e45fb109f8b3dc12cbef1cdbc2e9df59b" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20&quot;&gt;Hidden Features and Dark Corners of C++/STL&lt;/a&gt; on &lt;code&gt;comp.lang.c++.moderated&lt;/code&gt;, I was completely surprised that the following snippet compiled and worked in both Visual Studio 2008 and G++ 4.4.</source>
          <target state="translated">&lt;code&gt;comp.lang.c++.moderated&lt;/code&gt; 에서 &lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20&quot;&gt;C ++ / STL의 숨겨진 기능 및 다크 코너를&lt;/a&gt; 읽은 후 다음 스 니펫이 Visual Studio 2008 및 G ++ 4.4에서 컴파일되고 작동한다는 사실에 완전히 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="c305144767584cd0c8d54e35382a393106d5b858" translate="yes" xml:space="preserve">
          <source>Anyway, we have a &quot;goes to&quot; operator now. &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; is easy to be remembered as a direction, and &quot;while x goes to zero&quot; is meaning-straight.</source>
          <target state="translated">어쨌든, 우리는 지금 &quot;가는&quot;연산자가 있습니다. &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; 는 방향으로 기억하기 쉽고 &quot;x가 0이되는 동안&quot;은 곧바로 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94b9b84d8f2edb6e95694b219798719d8eb79dd" translate="yes" xml:space="preserve">
          <source>As expected. The &lt;code&gt;while( x-- &amp;gt; 0 )&lt;/code&gt; actually means &lt;code&gt;while( x &amp;gt; 0)&lt;/code&gt;. The &lt;code&gt;x--&lt;/code&gt; post decrements &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">예상대로. &lt;code&gt;while( x &amp;gt; 0)&lt;/code&gt; 은 실제로 while (x&amp;gt; 0)을 의미 합니다. &lt;code&gt;x--&lt;/code&gt; post는 &lt;code&gt;x&lt;/code&gt; 를 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="c329173da481eeafb50def6385ebfd48d65c3519" translate="yes" xml:space="preserve">
          <source>Both ways, we do the same thing and achieve the same goals.</source>
          <target state="translated">두 가지 방법으로, 우리는 같은 일을하고 같은 목표를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="9d84dedffbf33217d897abb4f5218470e4a96ce3" translate="yes" xml:space="preserve">
          <source>Conventionally, it would be like:</source>
          <target state="translated">일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb7fb4df1d6b244855acddd6f0855c61f32c7801" translate="yes" xml:space="preserve">
          <source>Does the same thing. Not saying you should do it like this, but it does the same thing and would have answered the question in one post.</source>
          <target state="translated">같은 일을합니다. 당신이 이렇게해야한다고 말하지는 않지만 같은 일을하고 한 게시물에서 질문에 대답했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adfa2ebada4983d5dccf616c123fee5cf44ff092" translate="yes" xml:space="preserve">
          <source>Furthermore, it is a little more efficient than &lt;code&gt;&quot;for (x = 10; x &amp;gt; 0; x --)&quot;&lt;/code&gt; on some platforms.</source>
          <target state="translated">또한 일부 플랫폼에서는 &lt;code&gt;&quot;for (x = 10; x &amp;gt; 0; x --)&quot;&lt;/code&gt; 보다 약간 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a03484b928c0da9bedd64e0a0288a309474941ad" translate="yes" xml:space="preserve">
          <source>I hope this helps to understand the complicated expression ^^</source>
          <target state="translated">나는 이것이 복잡한 표현을 이해하는 데 도움이되기를 바랍니다 ^^</target>
        </trans-unit>
        <trans-unit id="42beb1723992bad347a6d50c76196675e8a3b268" translate="yes" xml:space="preserve">
          <source>I'd assume this is C, since it works in GCC as well. Where is this defined in the standard, and where has it come from?</source>
          <target state="translated">GCC에서도 작동하기 때문에 이것이 C라고 가정합니다. 이것은 표준에서 어디에 정의되어 있으며 어디에서 왔습니까?</target>
        </trans-unit>
        <trans-unit id="787c5c3af55dc07e458b6935d8673aaa749f819f" translate="yes" xml:space="preserve">
          <source>If we want to first decrement and then compare, use this code:</source>
          <target state="translated">먼저 감소시키고 비교하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="592c1426ab4129d1ad141d0cf2a42322687a88a8" translate="yes" xml:space="preserve">
          <source>In the conventional way we would define a condition in the &lt;code&gt;while&lt;/code&gt; loop parenthesis &lt;code&gt;()&lt;/code&gt; and a terminating condition inside the braces &lt;code&gt;{}&lt;/code&gt;, but &lt;code&gt;--&amp;gt;&lt;/code&gt; defines both at once.</source>
          <target state="translated">일반적인 방식으로 &lt;code&gt;while&lt;/code&gt; 루프 괄호 &lt;code&gt;()&lt;/code&gt; 로 조건을 정의하고 중괄호 ( &lt;code&gt;{}&lt;/code&gt; ) 로 끝나는 조건을 정의하지만 &lt;code&gt;--&amp;gt;&lt;/code&gt; 는 한 번에 둘 다를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d9a03f9043e5a70dd8375201b6259b70ba338791" translate="yes" xml:space="preserve">
          <source>In this case, the expression:</source>
          <target state="translated">이 경우 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="371ce284dba18ad4033df1fc1ea59b1d751a86ac" translate="yes" xml:space="preserve">
          <source>It is nice that the original looks like &quot;while x goes to 0&quot; though.</source>
          <target state="translated">그래도 원본은 &quot;x는 0에 가까워지는&quot;것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="8f0fdd044874efda2aa1f7d7efd3a0b02aed9694" translate="yes" xml:space="preserve">
          <source>It's</source>
          <target state="translated">It's</target>
        </trans-unit>
        <trans-unit id="1c6845bf23e1468e3a3e5d765e78abf9eef7d612" translate="yes" xml:space="preserve">
          <source>It's a combination of two operators. First &lt;code&gt;--&lt;/code&gt; is for decrementing the value, and &lt;code&gt;&amp;gt;&lt;/code&gt; is for checking whether the value is greater than the right-hand operand.</source>
          <target state="translated">두 연산자의 조합입니다. 첫 번째는 값을 낮추기위한 것이고, &lt;code&gt;&amp;gt;&lt;/code&gt; 는 값이 오른쪽 피연산자보다 큰지를 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="42aa1a3b93ccfead932718cb189ab4439887f84c" translate="yes" xml:space="preserve">
          <source>It's equivalent to</source>
          <target state="translated">그것은 동등하다</target>
        </trans-unit>
        <trans-unit id="d62e9c6688e19cf99106b6a390e1b8eaf338107e" translate="yes" xml:space="preserve">
          <source>Joking aside, they are two different operators: &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; described respectively in &amp;sect;5.2.6/2 and &amp;sect;5.9 of the C++03 Standard.</source>
          <target state="translated">농담은 두 가지 다른 연산자입니다 &lt;code&gt;--&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 는 각각 C ++ 03 표준의 &amp;sect;5.2.6 / 2 및 &amp;sect;5.9에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a181b2b0f9b315ee1c3a1cafa162a8f3d8dfe43a" translate="yes" xml:space="preserve">
          <source>Just the space make the things look funny, &lt;code&gt;--&lt;/code&gt; decrements and &lt;code&gt;&amp;gt;&lt;/code&gt; compares.</source>
          <target state="translated">공간만으로도 재미 있고, 감소하고 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f114502268d1ba142e4af16a242db09c092c43dd" translate="yes" xml:space="preserve">
          <source>My compiler will print out 9876543210 when I run this code.</source>
          <target state="translated">이 코드를 실행하면 컴파일러에서 9876543210을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="32c3d879d5f921ff17068925658364c66f898b90" translate="yes" xml:space="preserve">
          <source>Not so mathematical, but... every picture paints a thousand words...</source>
          <target state="translated">수학적으로는 아니지만 모든 그림은 천 단어를 그립니다.</target>
        </trans-unit>
        <trans-unit id="be75b66a83a9a6c282dfda85038e441f08215cd1" translate="yes" xml:space="preserve">
          <source>Note: value of &lt;code&gt;x&lt;/code&gt; is changed after the condition is checked, because it post-decrementing. Some similar cases can also occur, for example:</source>
          <target state="translated">참고 : &lt;code&gt;x&lt;/code&gt; 값은 사후 감소 때문에 조건을 확인한 후에 변경됩니다. 다음과 같은 몇 가지 유사한 경우도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4492fef97e306f5e6a7750a5098d41060a367f2e" translate="yes" xml:space="preserve">
          <source>One book I read (I don't remember correctly which book) stated: &lt;strong&gt;Compilers try to parse expressions to the biggest token&lt;/strong&gt; by using the left right rule.</source>
          <target state="translated">내가 읽은 한 권의 책 (어떤 책을 정확하게 기억하지 못하고 있는지)은 다음과 같이 말했습니다. &lt;strong&gt;컴파일러&lt;/strong&gt; 는 왼쪽 오른쪽 규칙을 사용하여 &lt;strong&gt;표현식을 가장 큰 토큰&lt;/strong&gt; 으로 &lt;strong&gt;구문 분석하려고합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c891aeb3b944c960aea8d83baaf5029a92528c61" translate="yes" xml:space="preserve">
          <source>Or for something completely different... &lt;code&gt;x&lt;/code&gt; slides to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">또는 완전히 다른 무언가를 위해 ... &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 으로 슬라이드합니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="fb0e7fe70350dc0ee7e89bae44cc3d7053cb2456" translate="yes" xml:space="preserve">
          <source>Parses to biggest tokens:</source>
          <target state="translated">가장 큰 토큰으로 구문 분석 :</target>
        </trans-unit>
        <trans-unit id="5c2e2a4c1dd777244739d3d74e88a1d64dd3e338" translate="yes" xml:space="preserve">
          <source>That output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe2de0e311e0f569cff446ee744366a4a53af1e7" translate="yes" xml:space="preserve">
          <source>That's a very complicated operator, so even &lt;a href=&quot;https://isocpp.org/std/the-committee&quot;&gt;ISO/IEC JTC1 (Joint Technical Committee 1)&lt;/a&gt; placed its description in two different parts of the C++ Standard.</source>
          <target state="translated">이는 매우 복잡한 연산자이므로 &lt;a href=&quot;https://isocpp.org/std/the-committee&quot;&gt;ISO / IEC JTC1 (Joint Technical Committee 1)&lt;/a&gt; 조차도 C ++ 표준의 두 부분에 설명을 배치했습니다.</target>
        </trans-unit>
        <trans-unit id="6a3e454331cc168ce95ec0435482700ac07772a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x--&lt;/code&gt; is just shorthand for the above, and &lt;code&gt;&amp;gt;&lt;/code&gt; is just a normal greater-than &lt;code&gt;operator&lt;/code&gt;. No big mystery!</source>
          <target state="translated">&lt;code&gt;x--&lt;/code&gt; 는 위의 약어이며 &lt;code&gt;&amp;gt;&lt;/code&gt; 는 일반적인보다 큰 &lt;code&gt;operator&lt;/code&gt; 입니다. 큰 수수께끼가 없습니다!</target>
        </trans-unit>
        <trans-unit id="38a3c4d40e0d9d6eaa04c3f5bafa59304236b693" translate="yes" xml:space="preserve">
          <source>The conditional's code decrements &lt;code&gt;x&lt;/code&gt;, while returning &lt;code&gt;x&lt;/code&gt;'s original (not decremented) value, and then compares the original value with &lt;code&gt;0&lt;/code&gt; using the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">조건부 코드는 &lt;code&gt;x&lt;/code&gt; 를 감소시키면서 &lt;code&gt;x&lt;/code&gt; 의 원래 (감소되지 않은) 값을 반환 한 다음 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자를 사용하여 원래 값을 &lt;code&gt;0&lt;/code&gt; 과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7fc0a9d5b5419a56cbdcfeb72d5ca4b49fa2a41" translate="yes" xml:space="preserve">
          <source>The simple answer to the original question is just :</source>
          <target state="translated">원래 질문에 대한 간단한 답변은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="274e30a07dfa3be55e06b8637fa836ab4f72f9e9" translate="yes" xml:space="preserve">
          <source>The two operators are applied as a single one like &lt;code&gt;--&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">두 연산자는 &lt;code&gt;--&amp;gt;&lt;/code&gt; 와 같은 단일 연산자로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="583eee04876cc001642e2dc5fcbe58a387c0a79e" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;--&amp;gt;&lt;/code&gt; has historical relevance. Decrementing was (and still is in some cases), faster than incrementing on the x86 architecture. Using &lt;code&gt;--&amp;gt;&lt;/code&gt; suggests that &lt;code&gt;x&lt;/code&gt; is going to &lt;code&gt;0&lt;/code&gt;, and appeals to those with mathematical backgrounds.</source>
          <target state="translated">&lt;code&gt;--&amp;gt;&lt;/code&gt; 사용법은 역사적으로 관련이 있습니다. 감소는 x86 아키텍처에서 증가하는 것보다 빠르며 (어떤 경우에도 여전히) 빠릅니다. &lt;code&gt;--&amp;gt;&lt;/code&gt; 사용하면 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이되고 수학적 배경을 가진 사람들에게 호소합니다.</target>
        </trans-unit>
        <trans-unit id="a41e07b190735f13b8c8f226a7c07932f29ad807" translate="yes" xml:space="preserve">
          <source>There is a space missing between &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; is post decremented, that is, decremented after checking the condition &lt;code&gt;x&amp;gt;0 ?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&lt;/code&gt; 사이에 공백이 없습니다. &lt;code&gt;x&lt;/code&gt; 는 사후 감소합니다. 즉, 조건 &lt;code&gt;x&amp;gt;0 ?&lt;/code&gt; 확인한 후에 감소합니다 . .</target>
        </trans-unit>
        <trans-unit id="ae513c6a479c2914407c63dba820b333670806d2" translate="yes" xml:space="preserve">
          <source>There's too much people making simple things complicated nowadays  ;)</source>
          <target state="translated">요즘 간단한 일을 복잡하게 만드는 사람들이 너무 많습니다.)</target>
        </trans-unit>
        <trans-unit id="fe617ca6c05209786b22537250d91cdd94a7d5c6" translate="yes" xml:space="preserve">
          <source>This code first compares x and 0 and then decrements x. (Also said in the first answer: You're post-decrementing x and then comparing x and 0 with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.) See the output of this code:</source>
          <target state="translated">이 코드는 먼저 x와 0을 비교 한 다음 x를 줄입니다. (첫 번째 답변에서도 언급했습니다 : x를 후 감소시킨 다음 x와 0을 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자와 비교합니다.)이 코드의 출력을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fdd0c1a586388838384d21dc219d0bedc0c35e79" translate="yes" xml:space="preserve">
          <source>This decrements &lt;code&gt;a&lt;/code&gt; and runs the loop while &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 보다 큰 동안 이것은 &lt;code&gt;a&lt;/code&gt; 를 감소시키고 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0c7d65c36c618306d64889ea3f79503c773bdcfb" translate="yes" xml:space="preserve">
          <source>This is exactly the same as</source>
          <target state="translated">이것은 정확히 동일</target>
        </trans-unit>
        <trans-unit id="5fca315ea349fd587d69947d17025e9497c43b11" translate="yes" xml:space="preserve">
          <source>Utterly geek, but I will be using this:</source>
          <target state="translated">완전히 괴짜이지만, 이것을 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="3158e58b5cf6b5f2711f7810f6a17103939310cc" translate="yes" xml:space="preserve">
          <source>We now first compare and then decrement by seeing 0 in the output.</source>
          <target state="translated">먼저 출력에서 ​​0을 확인하여 비교 한 다음 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="201dbbc9354917294fe21c8112c0cd74cf7a1b6f" translate="yes" xml:space="preserve">
          <source>What is the “--&gt;” operator in C++</source>
          <target state="translated">C ++에서&amp;ldquo;-&amp;gt;&amp;rdquo;연산자는 무엇입니까</target>
        </trans-unit>
        <trans-unit id="4414fdc413292863025ed75b865c6afbf2896906" translate="yes" xml:space="preserve">
          <source>What the rule says essentially is that going left to right, expressions are formed by taking the maximum of characters which will form an valid expression.</source>
          <target state="translated">규칙에서 말하는 것은 기본적으로 왼쪽에서 오른쪽으로 갈 때 유효한 표현을 형성하는 최대 문자 수를 취함으로써 표현이 형성된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ebdd513546a401baa9f7c18ad9791e0c3ab99a08" translate="yes" xml:space="preserve">
          <source>Why all the complication?</source>
          <target state="translated">왜 모든 합병증?</target>
        </trans-unit>
        <trans-unit id="0824e28269d2b949dbfc74c104a616d227ba28f2" translate="yes" xml:space="preserve">
          <source>You can control speed with an arrow!</source>
          <target state="translated">화살표로 속도를 조절할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="e6b3d08ee852f5636c485d74a9bb7e8c4e876248" translate="yes" xml:space="preserve">
          <source>for non-negative numbers</source>
          <target state="translated">음수가 아닌 숫자</target>
        </trans-unit>
        <trans-unit id="69ba6013958a2967dce565d71e0f051c168537d7" translate="yes" xml:space="preserve">
          <source>is a different way of writing the same thing.</source>
          <target state="translated">같은 것을 쓰는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5d4175275bc109c4f4c7d4ea25b181242faf5853" translate="yes" xml:space="preserve">
          <source>is how that's parsed.</source>
          <target state="translated">그것이 파싱되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5df6a56f889c275389ceeca1ac44625c492375d9" translate="yes" xml:space="preserve">
          <source>likewise, You can try lot of methods to execute this command successfully</source>
          <target state="translated">마찬가지로이 명령을 성공적으로 실행하기 위해 많은 방법을 시도 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="70ee325ce781c11df127a1b7b6cbdd5f37e10130" translate="yes" xml:space="preserve">
          <source>you can use</source>
          <target state="translated">당신이 사용할 수있는</target>
        </trans-unit>
        <trans-unit id="fe2409909e4874b5b7ee2daff8f857121bcf3202" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;(-- x &amp;gt; 0)&lt;/code&gt;  It's mean &lt;code&gt;(--x &amp;gt; 0)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(-- x &amp;gt; 0)&lt;/code&gt; 사용할 수 있습니다. 평균 &lt;code&gt;(--x &amp;gt; 0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd0efe433e7d7920971ee004f14ccfa8d0b6539f" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;(x --&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">사용할 수 있습니다 &lt;code&gt;(x --&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9219d915d274a80b39669881c580f43dcba49f7a" translate="yes" xml:space="preserve">
          <source>you can use also</source>
          <target state="translated">당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
