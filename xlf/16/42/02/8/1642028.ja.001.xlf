<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1642028">
    <body>
      <group id="1642028">
        <trans-unit id="65a0c1838b070466053e907605ce7058494f48e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; obey the &quot;maximum munch&quot; rule. The same way a---b is translated to &lt;code&gt;(a--) - b&lt;/code&gt;, in your case  &lt;code&gt;x--&amp;gt;0&lt;/code&gt; translates to &lt;code&gt;(x--)&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;および&lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt;は、「最大のムンク」ルールに従います。 a --- bが &lt;code&gt;(a--) - b&lt;/code&gt; に変換されるのと同じように、 &lt;code&gt;x--&amp;gt;0&lt;/code&gt; は &lt;code&gt;(x--)&amp;gt;0&lt;/code&gt; 変換されます 。</target>
        </trans-unit>
        <trans-unit id="474934e5c57f3c9ec09a4a98ec8d90587f15124f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(x --&amp;gt; 0)&lt;/code&gt; means &lt;code&gt;(x-- &amp;gt; 0)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(x --&amp;gt; 0)&lt;/code&gt; は（x--&amp;gt; 0）を意味します</target>
        </trans-unit>
        <trans-unit id="262abdc514266d81aaa36903024d9fb5740f0ae2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&amp;gt;&lt;/code&gt; is not an operator. It is in fact two separate operators, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&amp;gt;&lt;/code&gt; は演算子ではありません。 実際には、2つの別個の演算子 &lt;code&gt;--&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="613d74405937bc963fb1c26b8207c810c368c5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; is the &lt;strong&gt;decrement&lt;/strong&gt; operator and &lt;code&gt;&amp;gt;&lt;/code&gt; is the &lt;strong&gt;greater-than&lt;/strong&gt; operator.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; は&lt;strong&gt;デクリメント&lt;/strong&gt;演算子であり、 &lt;code&gt;&amp;gt;&lt;/code&gt; は&lt;strong&gt;大なり&lt;/strong&gt;演算子です。</target>
        </trans-unit>
        <trans-unit id="d682ac29a8e11ac3ac552b5d2c678aade25e9c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x--&lt;/code&gt; (post decrement) is equivalent to &lt;code&gt;x = x-1&lt;/code&gt; so, the code transforms to:</source>
          <target state="translated">&lt;code&gt;x = x-1&lt;/code&gt; （デクリメント後）はx = x-1と同等であるため、コードは次のように変換されます。</target>
        </trans-unit>
        <trans-unit id="04906c892c48d262a6ee8f54d5645f1aa5c3923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; can go to zero even faster in the opposite direction:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は、反対方向により速くゼロに行くことができます。</target>
        </trans-unit>
        <trans-unit id="1c445d6bd1b64e90993378e42da434dd274ec4d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The same rule&lt;/strong&gt; applies to this expression:</source>
          <target state="translated">&lt;strong&gt;同じルール&lt;/strong&gt;がこの式に適用されます。</target>
        </trans-unit>
        <trans-unit id="245836dbc9ce8839d802c798c246a55d62658561" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To better understand, the statement could be written as follows:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;よりよく理解するために、ステートメントは次のように書くことができます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53c645d36d2a22094156da525b49a2497a65e898" translate="yes" xml:space="preserve">
          <source>Actually, &lt;code&gt;x&lt;/code&gt; is post-decrementing and with that condition is being checked. It's not &lt;code&gt;--&amp;gt;&lt;/code&gt;, it's &lt;code&gt;(x--) &amp;gt; 0&lt;/code&gt;</source>
          <target state="translated">実際には、 &lt;code&gt;x&lt;/code&gt; は後退しており、その状態でチェックされています。 それは &lt;code&gt;--&amp;gt;&lt;/code&gt; ではなく、 &lt;code&gt;(x--) &amp;gt; 0&lt;/code&gt; -- ）&amp;gt; 0です。</target>
        </trans-unit>
        <trans-unit id="f65db2ed72e6d7051fbad69d36948d2061678376" translate="yes" xml:space="preserve">
          <source>After parse:</source>
          <target state="translated">パースの後。</target>
        </trans-unit>
        <trans-unit id="f1c7ac9e45fb109f8b3dc12cbef1cdbc2e9df59b" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20&quot;&gt;Hidden Features and Dark Corners of C++/STL&lt;/a&gt; on &lt;code&gt;comp.lang.c++.moderated&lt;/code&gt;, I was completely surprised that the following snippet compiled and worked in both Visual Studio 2008 and G++ 4.4.</source>
          <target state="translated">&lt;code&gt;comp.lang.c++.moderated&lt;/code&gt; &lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20&quot;&gt;でC ++ / STLの非表示の機能とダークコーナーを&lt;/a&gt;読んだ後、次のスニペットがVisual Studio 2008とG ++ 4.4の両方でコンパイルおよび機能したことに完全に驚きました。</target>
        </trans-unit>
        <trans-unit id="c305144767584cd0c8d54e35382a393106d5b858" translate="yes" xml:space="preserve">
          <source>Anyway, we have a &quot;goes to&quot; operator now. &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; is easy to be remembered as a direction, and &quot;while x goes to zero&quot; is meaning-straight.</source>
          <target state="translated">とにかく、これで「移動先」オペレーターができました。 &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; は方向として覚えやすく、「xがゼロになる間」は意味がまっすぐです。</target>
        </trans-unit>
        <trans-unit id="c94b9b84d8f2edb6e95694b219798719d8eb79dd" translate="yes" xml:space="preserve">
          <source>As expected. The &lt;code&gt;while( x-- &amp;gt; 0 )&lt;/code&gt; actually means &lt;code&gt;while( x &amp;gt; 0)&lt;/code&gt;. The &lt;code&gt;x--&lt;/code&gt; post decrements &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">予想通り。 &lt;code&gt;while( x &amp;gt; 0)&lt;/code&gt; &lt;code&gt;while( x-- &amp;gt; 0 )&lt;/code&gt; 実際にはwhile（x&amp;gt; 0）を意味します。 &lt;code&gt;x--&lt;/code&gt; ポストは &lt;code&gt;x&lt;/code&gt; をデクリメントします。</target>
        </trans-unit>
        <trans-unit id="c329173da481eeafb50def6385ebfd48d65c3519" translate="yes" xml:space="preserve">
          <source>Both ways, we do the same thing and achieve the same goals.</source>
          <target state="translated">どちらの方法でも、同じことをして同じ目標を達成する。</target>
        </trans-unit>
        <trans-unit id="9d84dedffbf33217d897abb4f5218470e4a96ce3" translate="yes" xml:space="preserve">
          <source>Conventionally, it would be like:</source>
          <target state="translated">従来であればこんな感じです。</target>
        </trans-unit>
        <trans-unit id="bb7fb4df1d6b244855acddd6f0855c61f32c7801" translate="yes" xml:space="preserve">
          <source>Does the same thing. Not saying you should do it like this, but it does the same thing and would have answered the question in one post.</source>
          <target state="translated">同じことをする。このようにすべきだとは言っていませんが、同じことをしていますし、1つの投稿で質問に答えられたでしょう。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="adfa2ebada4983d5dccf616c123fee5cf44ff092" translate="yes" xml:space="preserve">
          <source>Furthermore, it is a little more efficient than &lt;code&gt;&quot;for (x = 10; x &amp;gt; 0; x --)&quot;&lt;/code&gt; on some platforms.</source>
          <target state="translated">さらに、一部のプラットフォームでは、 &lt;code&gt;&quot;for (x = 10; x &amp;gt; 0; x --)&quot;&lt;/code&gt; よりも少し効率的です。</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">これがコードだ</target>
        </trans-unit>
        <trans-unit id="a03484b928c0da9bedd64e0a0288a309474941ad" translate="yes" xml:space="preserve">
          <source>I hope this helps to understand the complicated expression ^^</source>
          <target state="translated">これでややこしい表現が理解できるといいですね^^。</target>
        </trans-unit>
        <trans-unit id="42beb1723992bad347a6d50c76196675e8a3b268" translate="yes" xml:space="preserve">
          <source>I'd assume this is C, since it works in GCC as well. Where is this defined in the standard, and where has it come from?</source>
          <target state="translated">GCCでも動作するので、これはCだと思います。これは標準ではどこで定義されていて、どこから来ているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="787c5c3af55dc07e458b6935d8673aaa749f819f" translate="yes" xml:space="preserve">
          <source>If we want to first decrement and then compare, use this code:</source>
          <target state="translated">最初にデクリメントしてから比較したい場合は、このコードを使用します。</target>
        </trans-unit>
        <trans-unit id="592c1426ab4129d1ad141d0cf2a42322687a88a8" translate="yes" xml:space="preserve">
          <source>In the conventional way we would define a condition in the &lt;code&gt;while&lt;/code&gt; loop parenthesis &lt;code&gt;()&lt;/code&gt; and a terminating condition inside the braces &lt;code&gt;{}&lt;/code&gt;, but &lt;code&gt;--&amp;gt;&lt;/code&gt; defines both at once.</source>
          <target state="translated">従来の方法では、 &lt;code&gt;while&lt;/code&gt; ループの括弧 &lt;code&gt;()&lt;/code&gt; で条件を定義し、中括弧 &lt;code&gt;{}&lt;/code&gt; 内で終了条件を定義していましたが、 &lt;code&gt;--&amp;gt;&lt;/code&gt; は両方を同時に定義します。</target>
        </trans-unit>
        <trans-unit id="d9a03f9043e5a70dd8375201b6259b70ba338791" translate="yes" xml:space="preserve">
          <source>In this case, the expression:</source>
          <target state="translated">この場合は、式</target>
        </trans-unit>
        <trans-unit id="371ce284dba18ad4033df1fc1ea59b1d751a86ac" translate="yes" xml:space="preserve">
          <source>It is nice that the original looks like &quot;while x goes to 0&quot; though.</source>
          <target state="translated">元が「while x goes to 0」のように見えるのはいいんだけどね。</target>
        </trans-unit>
        <trans-unit id="8f0fdd044874efda2aa1f7d7efd3a0b02aed9694" translate="yes" xml:space="preserve">
          <source>It's</source>
          <target state="translated">It's</target>
        </trans-unit>
        <trans-unit id="1c6845bf23e1468e3a3e5d765e78abf9eef7d612" translate="yes" xml:space="preserve">
          <source>It's a combination of two operators. First &lt;code&gt;--&lt;/code&gt; is for decrementing the value, and &lt;code&gt;&amp;gt;&lt;/code&gt; is for checking whether the value is greater than the right-hand operand.</source>
          <target state="translated">2つの演算子の組み合わせです。 最初 &lt;code&gt;--&lt;/code&gt; は値をデクリメントするためのものであり、 &lt;code&gt;&amp;gt;&lt;/code&gt; は値が右側のオペランドより大きいかどうかをチェックするためのものです。</target>
        </trans-unit>
        <trans-unit id="42aa1a3b93ccfead932718cb189ab4439887f84c" translate="yes" xml:space="preserve">
          <source>It's equivalent to</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="d62e9c6688e19cf99106b6a390e1b8eaf338107e" translate="yes" xml:space="preserve">
          <source>Joking aside, they are two different operators: &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; described respectively in &amp;sect;5.2.6/2 and &amp;sect;5.9 of the C++03 Standard.</source>
          <target state="translated">冗談はさておき、これらは2つの異なる演算子です。-と &lt;code&gt;&amp;gt;&lt;/code&gt; は、C ++ 03標準の&amp;sect;5.2.6/ 2と&amp;sect;5.9でそれぞれ説明されています。</target>
        </trans-unit>
        <trans-unit id="a181b2b0f9b315ee1c3a1cafa162a8f3d8dfe43a" translate="yes" xml:space="preserve">
          <source>Just the space make the things look funny, &lt;code&gt;--&lt;/code&gt; decrements and &lt;code&gt;&amp;gt;&lt;/code&gt; compares.</source>
          <target state="translated">スペースだけで物事をおもしろく見せます &lt;code&gt;--&lt;/code&gt; デクリメントと &lt;code&gt;&amp;gt;&lt;/code&gt; 比較。</target>
        </trans-unit>
        <trans-unit id="f114502268d1ba142e4af16a242db09c092c43dd" translate="yes" xml:space="preserve">
          <source>My compiler will print out 9876543210 when I run this code.</source>
          <target state="translated">このコードを実行すると、私のコンパイラは9876543210を出力します。</target>
        </trans-unit>
        <trans-unit id="32c3d879d5f921ff17068925658364c66f898b90" translate="yes" xml:space="preserve">
          <source>Not so mathematical, but... every picture paints a thousand words...</source>
          <target state="translated">数学的ではないが...絵は千の言葉を描く...</target>
        </trans-unit>
        <trans-unit id="be75b66a83a9a6c282dfda85038e441f08215cd1" translate="yes" xml:space="preserve">
          <source>Note: value of &lt;code&gt;x&lt;/code&gt; is changed after the condition is checked, because it post-decrementing. Some similar cases can also occur, for example:</source>
          <target state="translated">注： &lt;code&gt;x&lt;/code&gt; の値は、条件がチェックされた後で変更されます。 同様のケースがいくつか発生する可能性があります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="4492fef97e306f5e6a7750a5098d41060a367f2e" translate="yes" xml:space="preserve">
          <source>One book I read (I don't remember correctly which book) stated: &lt;strong&gt;Compilers try to parse expressions to the biggest token&lt;/strong&gt; by using the left right rule.</source>
          <target state="translated">私が読んだ1冊の本（私はどの本を正確に覚えていない）は次のように述べてい&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c891aeb3b944c960aea8d83baaf5029a92528c61" translate="yes" xml:space="preserve">
          <source>Or for something completely different... &lt;code&gt;x&lt;/code&gt; slides to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">または、完全に異なる何かの場合... &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; にスライドします 。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="fb0e7fe70350dc0ee7e89bae44cc3d7053cb2456" translate="yes" xml:space="preserve">
          <source>Parses to biggest tokens:</source>
          <target state="translated">最大のトークンまでパースします。</target>
        </trans-unit>
        <trans-unit id="5c2e2a4c1dd777244739d3d74e88a1d64dd3e338" translate="yes" xml:space="preserve">
          <source>That output is:</source>
          <target state="translated">その出力は</target>
        </trans-unit>
        <trans-unit id="fe2de0e311e0f569cff446ee744366a4a53af1e7" translate="yes" xml:space="preserve">
          <source>That's a very complicated operator, so even &lt;a href=&quot;https://isocpp.org/std/the-committee&quot;&gt;ISO/IEC JTC1 (Joint Technical Committee 1)&lt;/a&gt; placed its description in two different parts of the C++ Standard.</source>
          <target state="translated">これは非常に複雑な演算子であるため、 &lt;a href=&quot;https://isocpp.org/std/the-committee&quot;&gt;ISO / IEC JTC1（合同技術委員会1）で&lt;/a&gt;さえ、その説明をC ++標準の2つの異なる部分に配置しました。</target>
        </trans-unit>
        <trans-unit id="6a3e454331cc168ce95ec0435482700ac07772a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x--&lt;/code&gt; is just shorthand for the above, and &lt;code&gt;&amp;gt;&lt;/code&gt; is just a normal greater-than &lt;code&gt;operator&lt;/code&gt;. No big mystery!</source>
          <target state="translated">&lt;code&gt;x--&lt;/code&gt; は上記の省略形であり、 &lt;code&gt;&amp;gt;&lt;/code&gt; は通常の大なり &lt;code&gt;operator&lt;/code&gt; です。 大きな謎はありません！</target>
        </trans-unit>
        <trans-unit id="38a3c4d40e0d9d6eaa04c3f5bafa59304236b693" translate="yes" xml:space="preserve">
          <source>The conditional's code decrements &lt;code&gt;x&lt;/code&gt;, while returning &lt;code&gt;x&lt;/code&gt;'s original (not decremented) value, and then compares the original value with &lt;code&gt;0&lt;/code&gt; using the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">条件のコードは &lt;code&gt;x&lt;/code&gt; をデクリメントし、 &lt;code&gt;x&lt;/code&gt; の元の（デクリメントされていない）値を返し、 &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子を使用して元の値を &lt;code&gt;0&lt;/code&gt; と比較します。</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">出力されます。</target>
        </trans-unit>
        <trans-unit id="b7fc0a9d5b5419a56cbdcfeb72d5ca4b49fa2a41" translate="yes" xml:space="preserve">
          <source>The simple answer to the original question is just :</source>
          <target state="translated">元の質問へのシンプルな答えは、ただ.</target>
        </trans-unit>
        <trans-unit id="274e30a07dfa3be55e06b8637fa836ab4f72f9e9" translate="yes" xml:space="preserve">
          <source>The two operators are applied as a single one like &lt;code&gt;--&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">2つの演算子は、 &lt;code&gt;--&amp;gt;&lt;/code&gt; ように1つの演算子として適用されます。</target>
        </trans-unit>
        <trans-unit id="583eee04876cc001642e2dc5fcbe58a387c0a79e" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;--&amp;gt;&lt;/code&gt; has historical relevance. Decrementing was (and still is in some cases), faster than incrementing on the x86 architecture. Using &lt;code&gt;--&amp;gt;&lt;/code&gt; suggests that &lt;code&gt;x&lt;/code&gt; is going to &lt;code&gt;0&lt;/code&gt;, and appeals to those with mathematical backgrounds.</source>
          <target state="translated">&lt;code&gt;--&amp;gt;&lt;/code&gt; の使用には歴史的な関連性があります。 x86アーキテクチャでのインクリメントよりも、デクリメントの方が高速でした（場合によっては、それでも同じです）。 &lt;code&gt;--&amp;gt;&lt;/code&gt; を使用すると、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; になることが示唆され、数学的な背景を持つ人にアピールします。</target>
        </trans-unit>
        <trans-unit id="a41e07b190735f13b8c8f226a7c07932f29ad807" translate="yes" xml:space="preserve">
          <source>There is a space missing between &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; is post decremented, that is, decremented after checking the condition &lt;code&gt;x&amp;gt;0 ?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; の間にスペースがありません。 &lt;code&gt;x&lt;/code&gt; はポストデクリメントされます。つまり、条件 &lt;code&gt;x&amp;gt;0 ?&lt;/code&gt; チェックした後にデクリメントされますか？ 。</target>
        </trans-unit>
        <trans-unit id="ae513c6a479c2914407c63dba820b333670806d2" translate="yes" xml:space="preserve">
          <source>There's too much people making simple things complicated nowadays  ;)</source>
          <target state="translated">最近は簡単なことを複雑にしている人が多すぎます。)</target>
        </trans-unit>
        <trans-unit id="fe617ca6c05209786b22537250d91cdd94a7d5c6" translate="yes" xml:space="preserve">
          <source>This code first compares x and 0 and then decrements x. (Also said in the first answer: You're post-decrementing x and then comparing x and 0 with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.) See the output of this code:</source>
          <target state="translated">このコードは、最初にxと0を比較し、次にxをデクリメントします。 （最初の回答でも述べたように、xをデクリメントしてから、xと0を &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子で比較しています。）このコードの出力を参照してください。</target>
        </trans-unit>
        <trans-unit id="fdd0c1a586388838384d21dc219d0bedc0c35e79" translate="yes" xml:space="preserve">
          <source>This decrements &lt;code&gt;a&lt;/code&gt; and runs the loop while &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;a&lt;/code&gt; をデクリメントし、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; より大きい間ループを実行します。</target>
        </trans-unit>
        <trans-unit id="0c7d65c36c618306d64889ea3f79503c773bdcfb" translate="yes" xml:space="preserve">
          <source>This is exactly the same as</source>
          <target state="translated">と全く同じです。</target>
        </trans-unit>
        <trans-unit id="5fca315ea349fd587d69947d17025e9497c43b11" translate="yes" xml:space="preserve">
          <source>Utterly geek, but I will be using this:</source>
          <target state="translated">全くのオタクですが、これを使うことにします。</target>
        </trans-unit>
        <trans-unit id="3158e58b5cf6b5f2711f7810f6a17103939310cc" translate="yes" xml:space="preserve">
          <source>We now first compare and then decrement by seeing 0 in the output.</source>
          <target state="translated">ここでは、まず比較して、出力の0を見てデクリメントします。</target>
        </trans-unit>
        <trans-unit id="201dbbc9354917294fe21c8112c0cd74cf7a1b6f" translate="yes" xml:space="preserve">
          <source>What is the “--&gt;” operator in C++</source>
          <target state="translated">C++の&quot;--&gt;&quot;演算子とは</target>
        </trans-unit>
        <trans-unit id="4414fdc413292863025ed75b865c6afbf2896906" translate="yes" xml:space="preserve">
          <source>What the rule says essentially is that going left to right, expressions are formed by taking the maximum of characters which will form an valid expression.</source>
          <target state="translated">このルールが本質的に言っていることは、左から右に向かって、有効な式を形成する最大の文字を取ることによって式が形成されるということです。</target>
        </trans-unit>
        <trans-unit id="ebdd513546a401baa9f7c18ad9791e0c3ab99a08" translate="yes" xml:space="preserve">
          <source>Why all the complication?</source>
          <target state="translated">なぜ複雑なのか?</target>
        </trans-unit>
        <trans-unit id="0824e28269d2b949dbfc74c104a616d227ba28f2" translate="yes" xml:space="preserve">
          <source>You can control speed with an arrow!</source>
          <target state="translated">矢印でスピードをコントロールできる!</target>
        </trans-unit>
        <trans-unit id="e6b3d08ee852f5636c485d74a9bb7e8c4e876248" translate="yes" xml:space="preserve">
          <source>for non-negative numbers</source>
          <target state="translated">非負数の場合</target>
        </trans-unit>
        <trans-unit id="69ba6013958a2967dce565d71e0f051c168537d7" translate="yes" xml:space="preserve">
          <source>is a different way of writing the same thing.</source>
          <target state="translated">は、同じことを書いても書き方が違います。</target>
        </trans-unit>
        <trans-unit id="5d4175275bc109c4f4c7d4ea25b181242faf5853" translate="yes" xml:space="preserve">
          <source>is how that's parsed.</source>
          <target state="translated">というのは、それがどのように解析されているかということです。</target>
        </trans-unit>
        <trans-unit id="5df6a56f889c275389ceeca1ac44625c492375d9" translate="yes" xml:space="preserve">
          <source>likewise, You can try lot of methods to execute this command successfully</source>
          <target state="translated">同様に、このコマンドを実行するために多くの方法を試すことができます。</target>
        </trans-unit>
        <trans-unit id="70ee325ce781c11df127a1b7b6cbdd5f37e10130" translate="yes" xml:space="preserve">
          <source>you can use</source>
          <target state="translated">使える</target>
        </trans-unit>
        <trans-unit id="fe2409909e4874b5b7ee2daff8f857121bcf3202" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;(-- x &amp;gt; 0)&lt;/code&gt;  It's mean &lt;code&gt;(--x &amp;gt; 0)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(-- x &amp;gt; 0)&lt;/code&gt; を使用できます（ &lt;code&gt;(--x &amp;gt; 0)&lt;/code&gt; 意味します</target>
        </trans-unit>
        <trans-unit id="bd0efe433e7d7920971ee004f14ccfa8d0b6539f" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;(x --&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(x --&amp;gt;)&lt;/code&gt; 使用できます</target>
        </trans-unit>
        <trans-unit id="9219d915d274a80b39669881c580f43dcba49f7a" translate="yes" xml:space="preserve">
          <source>you can use also</source>
          <target state="translated">また使用することができます</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
