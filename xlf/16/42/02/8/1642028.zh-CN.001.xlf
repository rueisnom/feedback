<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1642028">
    <body>
      <group id="1642028">
        <trans-unit id="65a0c1838b070466053e907605ce7058494f48e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; obey the &quot;maximum munch&quot; rule. The same way a---b is translated to &lt;code&gt;(a--) - b&lt;/code&gt;, in your case  &lt;code&gt;x--&amp;gt;0&lt;/code&gt; translates to &lt;code&gt;(x--)&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt;遵循&amp;ldquo;最大嚼数&amp;rdquo;规则。 将a --- b转换为 &lt;code&gt;(a--) - b&lt;/code&gt; ，在您的情况下 &lt;code&gt;x--&amp;gt;0&lt;/code&gt; 转换为 &lt;code&gt;(x--)&amp;gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="474934e5c57f3c9ec09a4a98ec8d90587f15124f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(x --&amp;gt; 0)&lt;/code&gt; means &lt;code&gt;(x-- &amp;gt; 0)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(x --&amp;gt; 0)&lt;/code&gt; 表示 &lt;code&gt;(x-- &amp;gt; 0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="262abdc514266d81aaa36903024d9fb5740f0ae2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&amp;gt;&lt;/code&gt; is not an operator. It is in fact two separate operators, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&amp;gt;&lt;/code&gt; 不是运算符。 实际上，它是两个单独的运算符 &lt;code&gt;--&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="613d74405937bc963fb1c26b8207c810c368c5bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; is the &lt;strong&gt;decrement&lt;/strong&gt; operator and &lt;code&gt;&amp;gt;&lt;/code&gt; is the &lt;strong&gt;greater-than&lt;/strong&gt; operator.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 是&lt;strong&gt;减量&lt;/strong&gt;运算符，而 &lt;code&gt;&amp;gt;&lt;/code&gt; 是&lt;strong&gt;大于&lt;/strong&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="d682ac29a8e11ac3ac552b5d2c678aade25e9c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x--&lt;/code&gt; (post decrement) is equivalent to &lt;code&gt;x = x-1&lt;/code&gt; so, the code transforms to:</source>
          <target state="translated">&lt;code&gt;x--&lt;/code&gt; （后减量）等效于 &lt;code&gt;x = x-1&lt;/code&gt; ，因此代码转换为：</target>
        </trans-unit>
        <trans-unit id="04906c892c48d262a6ee8f54d5645f1aa5c3923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; can go to zero even faster in the opposite direction:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 可以在相反的方向更快地变为零：</target>
        </trans-unit>
        <trans-unit id="1c445d6bd1b64e90993378e42da434dd274ec4d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The same rule&lt;/strong&gt; applies to this expression:</source>
          <target state="translated">&lt;strong&gt;相同的规则&lt;/strong&gt;适用于此表达式：</target>
        </trans-unit>
        <trans-unit id="245836dbc9ce8839d802c798c246a55d62658561" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To better understand, the statement could be written as follows:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为了更好地理解，该语句可以编写如下：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53c645d36d2a22094156da525b49a2497a65e898" translate="yes" xml:space="preserve">
          <source>Actually, &lt;code&gt;x&lt;/code&gt; is post-decrementing and with that condition is being checked. It's not &lt;code&gt;--&amp;gt;&lt;/code&gt;, it's &lt;code&gt;(x--) &amp;gt; 0&lt;/code&gt;</source>
          <target state="translated">实际上， &lt;code&gt;x&lt;/code&gt; 是递减的，并且正在检查该条件。 不是 &lt;code&gt;--&amp;gt;&lt;/code&gt; ，而是 &lt;code&gt;(x--) &amp;gt; 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f65db2ed72e6d7051fbad69d36948d2061678376" translate="yes" xml:space="preserve">
          <source>After parse:</source>
          <target state="translated">解析后。</target>
        </trans-unit>
        <trans-unit id="f1c7ac9e45fb109f8b3dc12cbef1cdbc2e9df59b" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20&quot;&gt;Hidden Features and Dark Corners of C++/STL&lt;/a&gt; on &lt;code&gt;comp.lang.c++.moderated&lt;/code&gt;, I was completely surprised that the following snippet compiled and worked in both Visual Studio 2008 and G++ 4.4.</source>
          <target state="translated">在阅读完 &lt;code&gt;comp.lang.c++.moderated&lt;/code&gt; 上&lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20&quot;&gt;的C ++ / STL的隐藏功能和&amp;ldquo;黑暗角落&amp;rdquo;后&lt;/a&gt; ，我完全惊讶于以下代码段在Visual Studio 2008和G ++ 4.4中均已编译并正常工作。</target>
        </trans-unit>
        <trans-unit id="c305144767584cd0c8d54e35382a393106d5b858" translate="yes" xml:space="preserve">
          <source>Anyway, we have a &quot;goes to&quot; operator now. &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; is easy to be remembered as a direction, and &quot;while x goes to zero&quot; is meaning-straight.</source>
          <target state="translated">无论如何，我们现在有一个&amp;ldquo;转到&amp;rdquo;运算符。 容易记住 &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; 是一个方向，&amp;ldquo; x趋于零时&amp;rdquo;是直截了当的。</target>
        </trans-unit>
        <trans-unit id="c94b9b84d8f2edb6e95694b219798719d8eb79dd" translate="yes" xml:space="preserve">
          <source>As expected. The &lt;code&gt;while( x-- &amp;gt; 0 )&lt;/code&gt; actually means &lt;code&gt;while( x &amp;gt; 0)&lt;/code&gt;. The &lt;code&gt;x--&lt;/code&gt; post decrements &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如预期的那样。 &lt;code&gt;while( x-- &amp;gt; 0 )&lt;/code&gt; 实际上意味着 &lt;code&gt;while( x &amp;gt; 0)&lt;/code&gt; 。 &lt;code&gt;x--&lt;/code&gt; 后减 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c329173da481eeafb50def6385ebfd48d65c3519" translate="yes" xml:space="preserve">
          <source>Both ways, we do the same thing and achieve the same goals.</source>
          <target state="translated">两种方式,我们做同样的事情,实现同样的目标。</target>
        </trans-unit>
        <trans-unit id="9d84dedffbf33217d897abb4f5218470e4a96ce3" translate="yes" xml:space="preserve">
          <source>Conventionally, it would be like:</source>
          <target state="translated">按照惯例,这将是像。</target>
        </trans-unit>
        <trans-unit id="bb7fb4df1d6b244855acddd6f0855c61f32c7801" translate="yes" xml:space="preserve">
          <source>Does the same thing. Not saying you should do it like this, but it does the same thing and would have answered the question in one post.</source>
          <target state="translated">做同样的事情。不是说你应该这样做,但它做了同样的事情,而且会在一个帖子里回答这个问题。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="adfa2ebada4983d5dccf616c123fee5cf44ff092" translate="yes" xml:space="preserve">
          <source>Furthermore, it is a little more efficient than &lt;code&gt;&quot;for (x = 10; x &amp;gt; 0; x --)&quot;&lt;/code&gt; on some platforms.</source>
          <target state="translated">此外，在某些平台上，它比 &lt;code&gt;&quot;for (x = 10; x &amp;gt; 0; x --)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">代码是这样的。</target>
        </trans-unit>
        <trans-unit id="a03484b928c0da9bedd64e0a0288a309474941ad" translate="yes" xml:space="preserve">
          <source>I hope this helps to understand the complicated expression ^^</source>
          <target state="translated">希望这对理解复杂的表达方式有帮助^^^^</target>
        </trans-unit>
        <trans-unit id="42beb1723992bad347a6d50c76196675e8a3b268" translate="yes" xml:space="preserve">
          <source>I'd assume this is C, since it works in GCC as well. Where is this defined in the standard, and where has it come from?</source>
          <target state="translated">我想这是C语言,因为它在GCC中也是如此。这个在标准中是怎么定义的,它从哪里来的?</target>
        </trans-unit>
        <trans-unit id="787c5c3af55dc07e458b6935d8673aaa749f819f" translate="yes" xml:space="preserve">
          <source>If we want to first decrement and then compare, use this code:</source>
          <target state="translated">如果我们要先减法再比较,就用这个代码。</target>
        </trans-unit>
        <trans-unit id="592c1426ab4129d1ad141d0cf2a42322687a88a8" translate="yes" xml:space="preserve">
          <source>In the conventional way we would define a condition in the &lt;code&gt;while&lt;/code&gt; loop parenthesis &lt;code&gt;()&lt;/code&gt; and a terminating condition inside the braces &lt;code&gt;{}&lt;/code&gt;, but &lt;code&gt;--&amp;gt;&lt;/code&gt; defines both at once.</source>
          <target state="translated">以常规方式，我们将在 &lt;code&gt;while&lt;/code&gt; 循环括号 &lt;code&gt;()&lt;/code&gt; 中定义一个条件，并在括号 &lt;code&gt;{}&lt;/code&gt; 中定义一个终止条件，但是 &lt;code&gt;--&amp;gt;&lt;/code&gt; 定义两者。</target>
        </trans-unit>
        <trans-unit id="d9a03f9043e5a70dd8375201b6259b70ba338791" translate="yes" xml:space="preserve">
          <source>In this case, the expression:</source>
          <target state="translated">在这种情况下,表达方式:</target>
        </trans-unit>
        <trans-unit id="371ce284dba18ad4033df1fc1ea59b1d751a86ac" translate="yes" xml:space="preserve">
          <source>It is nice that the original looks like &quot;while x goes to 0&quot; though.</source>
          <target state="translated">原本看起来像 &quot;而X去0 &quot;虽然很好。</target>
        </trans-unit>
        <trans-unit id="8f0fdd044874efda2aa1f7d7efd3a0b02aed9694" translate="yes" xml:space="preserve">
          <source>It's</source>
          <target state="translated">It's</target>
        </trans-unit>
        <trans-unit id="1c6845bf23e1468e3a3e5d765e78abf9eef7d612" translate="yes" xml:space="preserve">
          <source>It's a combination of two operators. First &lt;code&gt;--&lt;/code&gt; is for decrementing the value, and &lt;code&gt;&amp;gt;&lt;/code&gt; is for checking whether the value is greater than the right-hand operand.</source>
          <target state="translated">它是两个运算符的组合。 首先 &lt;code&gt;--&lt;/code&gt; 用于减小值，而 &lt;code&gt;&amp;gt;&lt;/code&gt; 用于检查该值是否大于右侧操作数。</target>
        </trans-unit>
        <trans-unit id="42aa1a3b93ccfead932718cb189ab4439887f84c" translate="yes" xml:space="preserve">
          <source>It's equivalent to</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="d62e9c6688e19cf99106b6a390e1b8eaf338107e" translate="yes" xml:space="preserve">
          <source>Joking aside, they are two different operators: &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; described respectively in &amp;sect;5.2.6/2 and &amp;sect;5.9 of the C++03 Standard.</source>
          <target state="translated">除了开玩笑，它们是两个不同的运算符： &lt;code&gt;--&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 分别在C ++ 03标准的第5.2.6 / 2节和第5.9节中进行了描述。</target>
        </trans-unit>
        <trans-unit id="a181b2b0f9b315ee1c3a1cafa162a8f3d8dfe43a" translate="yes" xml:space="preserve">
          <source>Just the space make the things look funny, &lt;code&gt;--&lt;/code&gt; decrements and &lt;code&gt;&amp;gt;&lt;/code&gt; compares.</source>
          <target state="translated">只是空间使事情看起来很有趣，即递减并进行比较。</target>
        </trans-unit>
        <trans-unit id="f114502268d1ba142e4af16a242db09c092c43dd" translate="yes" xml:space="preserve">
          <source>My compiler will print out 9876543210 when I run this code.</source>
          <target state="translated">当我运行这个代码时,我的编译器会打印出9876543210。</target>
        </trans-unit>
        <trans-unit id="32c3d879d5f921ff17068925658364c66f898b90" translate="yes" xml:space="preserve">
          <source>Not so mathematical, but... every picture paints a thousand words...</source>
          <target state="translated">不是数学上的问题,但是.....每幅画都是千言万语....</target>
        </trans-unit>
        <trans-unit id="be75b66a83a9a6c282dfda85038e441f08215cd1" translate="yes" xml:space="preserve">
          <source>Note: value of &lt;code&gt;x&lt;/code&gt; is changed after the condition is checked, because it post-decrementing. Some similar cases can also occur, for example:</source>
          <target state="translated">注意：检查条件后， &lt;code&gt;x&lt;/code&gt; 的值会更改，因为它会递减。 也会发生一些类似的情况，例如：</target>
        </trans-unit>
        <trans-unit id="4492fef97e306f5e6a7750a5098d41060a367f2e" translate="yes" xml:space="preserve">
          <source>One book I read (I don't remember correctly which book) stated: &lt;strong&gt;Compilers try to parse expressions to the biggest token&lt;/strong&gt; by using the left right rule.</source>
          <target state="translated">我读过的一本书（我不记得是哪本书）说： &lt;strong&gt;编译器尝试&lt;/strong&gt;使用左右规则&lt;strong&gt;将表达式解析为最大标记&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c891aeb3b944c960aea8d83baaf5029a92528c61" translate="yes" xml:space="preserve">
          <source>Or for something completely different... &lt;code&gt;x&lt;/code&gt; slides to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">或者对于完全不同的东西... &lt;code&gt;x&lt;/code&gt; 滑到 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="fb0e7fe70350dc0ee7e89bae44cc3d7053cb2456" translate="yes" xml:space="preserve">
          <source>Parses to biggest tokens:</source>
          <target state="translated">解析到最大的令牌。</target>
        </trans-unit>
        <trans-unit id="5c2e2a4c1dd777244739d3d74e88a1d64dd3e338" translate="yes" xml:space="preserve">
          <source>That output is:</source>
          <target state="translated">这个输出是:</target>
        </trans-unit>
        <trans-unit id="fe2de0e311e0f569cff446ee744366a4a53af1e7" translate="yes" xml:space="preserve">
          <source>That's a very complicated operator, so even &lt;a href=&quot;https://isocpp.org/std/the-committee&quot;&gt;ISO/IEC JTC1 (Joint Technical Committee 1)&lt;/a&gt; placed its description in two different parts of the C++ Standard.</source>
          <target state="translated">这是一个非常复杂的运算符，因此即使是&lt;a href=&quot;https://isocpp.org/std/the-committee&quot;&gt;ISO / IEC JTC1（联合技术委员会1）也&lt;/a&gt;将其描述放在C ++标准的两个不同部分中。</target>
        </trans-unit>
        <trans-unit id="6a3e454331cc168ce95ec0435482700ac07772a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x--&lt;/code&gt; is just shorthand for the above, and &lt;code&gt;&amp;gt;&lt;/code&gt; is just a normal greater-than &lt;code&gt;operator&lt;/code&gt;. No big mystery!</source>
          <target state="translated">&lt;code&gt;x--&lt;/code&gt; 只是上述的简写，而 &lt;code&gt;&amp;gt;&lt;/code&gt; 只是一个普通的大于 &lt;code&gt;operator&lt;/code&gt; 。 没什么大不了的！</target>
        </trans-unit>
        <trans-unit id="38a3c4d40e0d9d6eaa04c3f5bafa59304236b693" translate="yes" xml:space="preserve">
          <source>The conditional's code decrements &lt;code&gt;x&lt;/code&gt;, while returning &lt;code&gt;x&lt;/code&gt;'s original (not decremented) value, and then compares the original value with &lt;code&gt;0&lt;/code&gt; using the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">条件代码减少 &lt;code&gt;x&lt;/code&gt; ，同时返回 &lt;code&gt;x&lt;/code&gt; 的原始（不减少）值，然后使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符将原始值与 &lt;code&gt;0&lt;/code&gt; 比较。</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">输出将是。</target>
        </trans-unit>
        <trans-unit id="b7fc0a9d5b5419a56cbdcfeb72d5ca4b49fa2a41" translate="yes" xml:space="preserve">
          <source>The simple answer to the original question is just :</source>
          <target state="translated">原本问题的简单答案是.....。</target>
        </trans-unit>
        <trans-unit id="274e30a07dfa3be55e06b8637fa836ab4f72f9e9" translate="yes" xml:space="preserve">
          <source>The two operators are applied as a single one like &lt;code&gt;--&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这两个运算符像 &lt;code&gt;--&amp;gt;&lt;/code&gt; 一样应用为一个。</target>
        </trans-unit>
        <trans-unit id="583eee04876cc001642e2dc5fcbe58a387c0a79e" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;--&amp;gt;&lt;/code&gt; has historical relevance. Decrementing was (and still is in some cases), faster than incrementing on the x86 architecture. Using &lt;code&gt;--&amp;gt;&lt;/code&gt; suggests that &lt;code&gt;x&lt;/code&gt; is going to &lt;code&gt;0&lt;/code&gt;, and appeals to those with mathematical backgrounds.</source>
          <target state="translated">&lt;code&gt;--&amp;gt;&lt;/code&gt; 的用法具有历史意义。 减少（在某些情况下仍然是）比在x86架构上增加要快。 使用 &lt;code&gt;--&amp;gt;&lt;/code&gt; 表示 &lt;code&gt;x&lt;/code&gt; 将变为 &lt;code&gt;0&lt;/code&gt; ，并且吸引那些具有数学背景的人。</target>
        </trans-unit>
        <trans-unit id="a41e07b190735f13b8c8f226a7c07932f29ad807" translate="yes" xml:space="preserve">
          <source>There is a space missing between &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; is post decremented, that is, decremented after checking the condition &lt;code&gt;x&amp;gt;0 ?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 之间缺少空格。 &lt;code&gt;x&lt;/code&gt; 是递减的，也就是说，在检查条件 &lt;code&gt;x&amp;gt;0 ?&lt;/code&gt; 之后递减？ 。</target>
        </trans-unit>
        <trans-unit id="ae513c6a479c2914407c63dba820b333670806d2" translate="yes" xml:space="preserve">
          <source>There's too much people making simple things complicated nowadays  ;)</source>
          <target state="translated">现在有太多人把简单的事情弄得太复杂了;)</target>
        </trans-unit>
        <trans-unit id="fe617ca6c05209786b22537250d91cdd94a7d5c6" translate="yes" xml:space="preserve">
          <source>This code first compares x and 0 and then decrements x. (Also said in the first answer: You're post-decrementing x and then comparing x and 0 with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.) See the output of this code:</source>
          <target state="translated">此代码首先将x与0进行比较，然后将x减1。 （也请在第一个答案中说：先递减x，然后将x和0与 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符进行比较。）请参见以下代码的输出：</target>
        </trans-unit>
        <trans-unit id="fdd0c1a586388838384d21dc219d0bedc0c35e79" translate="yes" xml:space="preserve">
          <source>This decrements &lt;code&gt;a&lt;/code&gt; and runs the loop while &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">这将使 &lt;code&gt;a&lt;/code&gt; 减小并在 &lt;code&gt;a&lt;/code&gt; 大于 &lt;code&gt;0&lt;/code&gt; 时运行循环。</target>
        </trans-unit>
        <trans-unit id="0c7d65c36c618306d64889ea3f79503c773bdcfb" translate="yes" xml:space="preserve">
          <source>This is exactly the same as</source>
          <target state="translated">这一点和</target>
        </trans-unit>
        <trans-unit id="5fca315ea349fd587d69947d17025e9497c43b11" translate="yes" xml:space="preserve">
          <source>Utterly geek, but I will be using this:</source>
          <target state="translated">完全是个怪胎,但我会用这个。</target>
        </trans-unit>
        <trans-unit id="3158e58b5cf6b5f2711f7810f6a17103939310cc" translate="yes" xml:space="preserve">
          <source>We now first compare and then decrement by seeing 0 in the output.</source>
          <target state="translated">我们现在先比较一下,然后通过看到输出中的0,再进行递减。</target>
        </trans-unit>
        <trans-unit id="201dbbc9354917294fe21c8112c0cd74cf7a1b6f" translate="yes" xml:space="preserve">
          <source>What is the “--&gt;” operator in C++</source>
          <target state="translated">C++中的&quot;--&gt;&quot;操作符是什么?</target>
        </trans-unit>
        <trans-unit id="4414fdc413292863025ed75b865c6afbf2896906" translate="yes" xml:space="preserve">
          <source>What the rule says essentially is that going left to right, expressions are formed by taking the maximum of characters which will form an valid expression.</source>
          <target state="translated">这条规则的本质是:从左到右,表达式是通过取最大的字符组成有效的表达式。</target>
        </trans-unit>
        <trans-unit id="ebdd513546a401baa9f7c18ad9791e0c3ab99a08" translate="yes" xml:space="preserve">
          <source>Why all the complication?</source>
          <target state="translated">为什么这么复杂?</target>
        </trans-unit>
        <trans-unit id="0824e28269d2b949dbfc74c104a616d227ba28f2" translate="yes" xml:space="preserve">
          <source>You can control speed with an arrow!</source>
          <target state="translated">你可以用箭头控制速度!</target>
        </trans-unit>
        <trans-unit id="e6b3d08ee852f5636c485d74a9bb7e8c4e876248" translate="yes" xml:space="preserve">
          <source>for non-negative numbers</source>
          <target state="translated">为非负数</target>
        </trans-unit>
        <trans-unit id="69ba6013958a2967dce565d71e0f051c168537d7" translate="yes" xml:space="preserve">
          <source>is a different way of writing the same thing.</source>
          <target state="translated">是一种不同的写法。</target>
        </trans-unit>
        <trans-unit id="5d4175275bc109c4f4c7d4ea25b181242faf5853" translate="yes" xml:space="preserve">
          <source>is how that's parsed.</source>
          <target state="translated">是这样解析的。</target>
        </trans-unit>
        <trans-unit id="5df6a56f889c275389ceeca1ac44625c492375d9" translate="yes" xml:space="preserve">
          <source>likewise, You can try lot of methods to execute this command successfully</source>
          <target state="translated">同样,你可以尝试很多方法来成功地执行这个命令</target>
        </trans-unit>
        <trans-unit id="70ee325ce781c11df127a1b7b6cbdd5f37e10130" translate="yes" xml:space="preserve">
          <source>you can use</source>
          <target state="translated">可以用</target>
        </trans-unit>
        <trans-unit id="fe2409909e4874b5b7ee2daff8f857121bcf3202" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;(-- x &amp;gt; 0)&lt;/code&gt;  It's mean &lt;code&gt;(--x &amp;gt; 0)&lt;/code&gt;</source>
          <target state="translated">您可以使用 &lt;code&gt;(-- x &amp;gt; 0)&lt;/code&gt; 表示 &lt;code&gt;(--x &amp;gt; 0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd0efe433e7d7920971ee004f14ccfa8d0b6539f" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;(x --&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">您可以使用 &lt;code&gt;(x --&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9219d915d274a80b39669881c580f43dcba49f7a" translate="yes" xml:space="preserve">
          <source>you can use also</source>
          <target state="translated">也可以用</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
