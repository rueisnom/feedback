<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1641957">
    <body>
      <group id="1641957">
        <trans-unit id="a65b63696c33e0257a6a7d898695f32a537f1f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; contains space for seven integers, and you can put a value in one of them with an assignment, like this:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含七个整数的空间，您可以通过赋值在其中一个中放置一个值，如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8af120010556eba3c3b2a7bad71ae9d8d645b402" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; doesn't contain any spaces for integers, but it can point to a space for an integer. We can, for example, set it to point to one of the places in the array &lt;code&gt;a&lt;/code&gt;, such as the first one:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不包含任何用于整数的空格，但是它可以指向整数的空格。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，我们可以将其设置为指向数组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个位置&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，例如第一个：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0a0e3f2feb92d1b5feba526fda2d2ab318506af4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36c71ee593be8556de149c97168c4774739f6dca" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;li&gt;Which *may* affect how the address value is interpreted - depends on the machine.&lt;/li&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3b1981349530961f711b6dde2175785818e28c8e" translate="yes" xml:space="preserve">
          <source>A pointer like this allocates memory for just the pointer &lt;code&gt;p&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样的指针仅为指针&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配内存&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da1c1c9d22ab49cd630b97c63360a180e96b79e6" translate="yes" xml:space="preserve">
          <source>An array declared like this</source>
          <target state="translated">一个像这样声明的数组</target>
        </trans-unit>
        <trans-unit id="f2d1d4b464535d85f938c9fc1b4cfdac71b16845" translate="yes" xml:space="preserve">
          <source>An array is a collection of secuential and contiguous elements in memory. In C an array's name is the index to the first element, and applying an offset you can access the rest of elements.
An &quot;index to the first element&quot; is indeed a pointer to a memory direction.</source>
          <target state="translated">数组是一个由内存中的间隔和毗连元素组成的集合。在C语言中,数组的名称是第一个元素的索引,应用一个偏移量就可以访问其余的元素。一个 &quot;第一个元素的索引 &quot;确实是一个指向内存方向的指针。</target>
        </trans-unit>
        <trans-unit id="49216096309a8b134d13a16eff464e7b50905513" translate="yes" xml:space="preserve">
          <source>An array is an array and a pointer is a pointer, but in most cases array names are &lt;em&gt;converted&lt;/em&gt; to pointers. A term often used is that they &lt;em&gt;decay&lt;/em&gt; to pointers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组是数组，指针是指针，但是在大多数情况下，数组名称会&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;经常使用的术语是它们&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;衰减&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到指针。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb191b43cbfa05cc8f4b650113cdbb910d1d8f8e" translate="yes" xml:space="preserve">
          <source>And other nifty stuff you can do to pointer (e.g. adding/substracting an offset), you can also do to an array:</source>
          <target state="translated">还有其他一些你可以对指针做的有趣的事情(比如添加偏移量(addingsubstracting an offset),你也可以对数组做。</target>
        </trans-unit>
        <trans-unit id="4acf022bcade8c95cfb9c03697ff65b8d99428f5" translate="yes" xml:space="preserve">
          <source>Answering the question in the comment:</source>
          <target state="translated">回答了评论中的问题。</target>
        </trans-unit>
        <trans-unit id="27a6c0b546c4d3c425a0ab9158f3517403572a6f" translate="yes" xml:space="preserve">
          <source>Array name is the address of 1st element of an array. So yes array name is a const pointer.</source>
          <target state="translated">数组名是数组的第1个元素的地址。所以是的,数组名是一个 const 指针。</target>
        </trans-unit>
        <trans-unit id="f74a5048a36b59f77a0535c2113470eb8139cba4" translate="yes" xml:space="preserve">
          <source>Both the print statements will give exactly same output for a machine. In my system it gave:</source>
          <target state="translated">这两条打印语句都会给出完全相同的机器输出。在我的系统中,它给出的结果是:</target>
        </trans-unit>
        <trans-unit id="3e980bf5df5a6b0791e7999f54355eb789d75f96" translate="yes" xml:space="preserve">
          <source>C was derived from an earlier language called B, and in B &lt;code&gt;a&lt;/code&gt;&lt;em&gt;was&lt;/em&gt; a separate pointer object from the array elements &lt;code&gt;a[0]&lt;/code&gt;, &lt;code&gt;a[1]&lt;/code&gt;, etc.  Ritchie wanted to keep B's array semantics, but he didn't want to mess with storing the separate pointer object.  So he got rid of it.  Instead, the compiler will convert array expressions to pointer expressions during translation as necessary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C是从一种叫做B的早期语言派生而来的，在B中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个与数组元素&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分开的指针对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。Ritchie希望保留B的数组语义，但他不想这样做。混乱与存储单独的指针对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以他摆脱了它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相反，编译器将在转换过程中根据需要将数组表达式转换为指针表达式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="785394bb3c2dd7a2e69abfa10c8f6b5f9a143f13" translate="yes" xml:space="preserve">
          <source>C++ refuses any such attempts with errors in compile-time.</source>
          <target state="translated">C++在编译时拒绝任何此类错误的尝试。</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="dc832d2b81bf05bf8b249d7318841b3f1d696256" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; &quot;point&quot; to the same memory, you can obtain address of the &lt;code&gt;c&lt;/code&gt; pointer, but you cannot obtain the address of the &lt;code&gt;a&lt;/code&gt; pointer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;ldquo;点&amp;rdquo;指向相同的内存，您也可以获取&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;地址&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但不能获取&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的地址&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff4533c11ca4835b8de0c93a3bff2a5c686d812b" translate="yes" xml:space="preserve">
          <source>For this to work with a normal array, such as our &lt;code&gt;a&lt;/code&gt;, the name &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a[3]&lt;/code&gt; must first be converted to a pointer (to the first element in &lt;code&gt;a&lt;/code&gt;). Then we step 3 elements forward, and take whatever is there. In other words: take the element at position 3 in the array. (Which is the fourth element in the array, since the first one is numbered 0.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了做到这与正常的阵列，工作，例如我们的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，名称&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[3]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先必须（在到第一元件转换为一个指针&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。然后，我们将3个元素向前移动，并采用其中的任何内容。换句话说：将元素放在数组中的位置3。 （这是数组中的第四个元素，因为第一个元素的编号为0。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04d0043ae1c3750d8c0596233e2b3a656c8cc9dc" translate="yes" xml:space="preserve">
          <source>Here is a pointer:</source>
          <target state="translated">这里有一个指针。</target>
        </trans-unit>
        <trans-unit id="4f58e12c03f35b97de868fb6ccbc823b9cf25d84" translate="yes" xml:space="preserve">
          <source>Here is an array:</source>
          <target state="translated">这里是一个阵列。</target>
        </trans-unit>
        <trans-unit id="26fdb55537479116b8bb70c902712035182e615d" translate="yes" xml:space="preserve">
          <source>I think this example sheds some light on the issue:</source>
          <target state="translated">我想这个例子可以说明一些问题。</target>
        </trans-unit>
        <trans-unit id="e52fdc0c02ae77c45834fad2bc8b942e05d4df6c" translate="yes" xml:space="preserve">
          <source>If I use sizeof, do i count the size of only the elements of the array? Then the array &amp;ldquo;head&amp;rdquo; also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我使用sizeof，是否只计算数组元素的大小？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，数组&amp;ldquo; head&amp;rdquo;还占用了有关长度和指针的信息的空间（这意味着它比普通指针要占用更多的空间）？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43bba69b9ac50d749365e68162dec25883d49421" translate="yes" xml:space="preserve">
          <source>If an expression of array type (such as the array name) appears in a larger expression and it isn't the operand of either the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;sizeof&lt;/code&gt; operators, then the type of the array expression is converted from &quot;N-element array of T&quot; to &quot;pointer to T&quot;, and the value of the expression is the address of the first element in the array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果数组类型的表达式（例如数组名​​称）出现在较大的表达式中，并且不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的操作数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则该数组表达式的类型将从&amp;ldquo; T的N元素数组&amp;rdquo;转换为到&amp;ldquo;指向T的指针&amp;rdquo;，表达式的值是数组中第一个元素的地址。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba70f7455ba6c29acbc8157772437ec33ae3725d" translate="yes" xml:space="preserve">
          <source>In short, the array name is not a pointer, but in most contexts it is treated &lt;em&gt;as though&lt;/em&gt; it were a pointer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总之，数组名不是指针，但在多数情况下它被视为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好像&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它是一个指针。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82d89c2db0d03b410e54277f35b6ed4060a4a4c1" translate="yes" xml:space="preserve">
          <source>Is an array name a pointer</source>
          <target state="translated">数组名称是指针吗?</target>
        </trans-unit>
        <trans-unit id="91ff9a612f00efc43ff0f917fc5e022bc26f334b" translate="yes" xml:space="preserve">
          <source>Is an array's name a pointer in C?
If not, what is the difference between an array's name and a pointer variable?</source>
          <target state="translated">在C语言中,数组的名称是指针吗?如果不是,数组的名称和指针变量有什么区别?</target>
        </trans-unit>
        <trans-unit id="f3589d6cb1b7dd7cd7a26de719cc0c00d35826d4" translate="yes" xml:space="preserve">
          <source>It compiles fine (with 2 warnings) in gcc 4.9.2, and prints the following:</source>
          <target state="translated">它在gcc 4.9.2中编译得很好(有两个警告),并打印出以下信息。</target>
        </trans-unit>
        <trans-unit id="cecbc4d4228ef8dc9341b6c96bc5124fd89d0558" translate="yes" xml:space="preserve">
          <source>It doesn't allocate any &lt;code&gt;int&lt;/code&gt;s. You can modify it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它不分配任何&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以修改它：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16e33fca2cdd522181cf0b7ca8357efed7b62cd6" translate="yes" xml:space="preserve">
          <source>Language-wise, if C didn't expose the array as just &lt;strong&gt;some sort of &quot;pointer&quot;&lt;/strong&gt;(pedantically it's just a memory location. It cannot point to arbitrary location in memory, nor can be controlled by the programmer). We always need to code this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从语言角度&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来看&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，如果C不会将数组仅作为&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某种&amp;ldquo;指针&amp;rdquo;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;公开&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（从学上来说，它只是一个内存位置。它不能指向内存中的任意位置，也不能由程序员控制）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们总是需要编写以下代码：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31097b34416d6851880556b2b66e2b1ec0639d1" translate="yes" xml:space="preserve">
          <source>Now you can use &lt;code&gt;p&lt;/code&gt; in a similar way to an array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以类似于数组的方式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23ea9fbffbc95378d5bdc4a84ac145cf46be1d5e" translate="yes" xml:space="preserve">
          <source>Remember that I said arrays don't store any metadata about their size.  As soon as that array expression &quot;decays&quot; to a pointer, all you have is a pointer to a single element.  That element may be the first of a sequence of elements, or it may be a single object.  There's no way to know based on the pointer itself.</source>
          <target state="translated">记住,我说过数组不存储任何关于其大小的元数据。一旦那个数组表达式 &quot;衰减 &quot;为一个指针,你所拥有的就是一个指向单个元素的指针。这个元素可能是一个元素序列中的第一个,也可能是一个单一的对象。根据指针本身是没有办法知道的。</target>
        </trans-unit>
        <trans-unit id="d0197e59f6275d6a2efafeb51fd00878e52c3b85" translate="yes" xml:space="preserve">
          <source>So the answer is kinda 'yes'.</source>
          <target state="translated">所以,答案是有点 &quot;是&quot;。</target>
        </trans-unit>
        <trans-unit id="a97d455d32e853de61af180cec9ac7cd1fdea184" translate="yes" xml:space="preserve">
          <source>So, in summary, array names in a C program are (in most cases) converted to pointers. One exception is when we use the &lt;code&gt;sizeof&lt;/code&gt; operator on an array. If &lt;code&gt;a&lt;/code&gt; was converted to a pointer in this context, &lt;code&gt;sizeof a&lt;/code&gt; would give the size of a pointer and not of the actual array, which would be rather useless, so in that case &lt;code&gt;a&lt;/code&gt; means the array itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，总而言之，在大多数情况下，C程序中的数组名称都将转换为指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个例外是在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在该上下文中转换为指针，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将给出指针的大小，而不是实际的数组，这将是相当无用的，所以在这种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;装置的阵列本身。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3289ed5abacd7b3f3180f45fb3dd0700fbc360e8" translate="yes" xml:space="preserve">
          <source>So, the conclusion is no, the array is not a pointer, it is not stored in memory (not even read-only one) as a pointer, even though it looks like it is, since you can obtain its address with the &amp;amp; operator. But - oops - that operator does not work :-)), either way, you've been warned:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，结论是否定的，数组不是指针，即使看起来像数组，它也不作为指针存储在内存中（甚至不是只读的），因为您可以使用＆运算符获取其地址。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是-糟糕-该运算符不起作用:-)），无论哪种方式，都已警告您：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9ca93754d462229b1356c3197d92508ff9c9fc7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;expression&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; refers to the entire array, but there's no &lt;em&gt;object&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; separate from the array elements themselves.  Thus, &lt;code&gt;sizeof a&lt;/code&gt; gives you the size (in bytes) of the entire array.  The expression &lt;code&gt;&amp;amp;a&lt;/code&gt; gives you the address of the array, &lt;em&gt;which is the same as the address of the first element&lt;/em&gt;.  The difference between &lt;code&gt;&amp;amp;a&lt;/code&gt; and &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; is the type of the result&lt;sup&gt;1&lt;/sup&gt; - &lt;code&gt;char (*)[10]&lt;/code&gt; in the first case and &lt;code&gt;char *&lt;/code&gt; in the second.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所述&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指的是整个阵列，但没有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从数组元素本身分离。因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了整个数组的大小（以字节为单位）。表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为您提供数组&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的地址，该地址与第一个元素的地址相同&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之间的区别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是结果&lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一种情况下为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char (*)[10]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第二种&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况下为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char *&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d28329fda7a89d1cc1685169ae04c78242090a3" translate="yes" xml:space="preserve">
          <source>The array name behaves like a pointer and points to the first element of the array. Example:</source>
          <target state="translated">数组名称的行为就像一个指针,指向数组的第一个元素。例子。</target>
        </trans-unit>
        <trans-unit id="98874795f3a895dfe9b213af066d8f4073e1fff5" translate="yes" xml:space="preserve">
          <source>The array name by itself yields a memory location, so you can treat the array name like a pointer:</source>
          <target state="translated">数组名本身就会产生一个内存位置,所以你可以把数组名当成指针来对待。</target>
        </trans-unit>
        <trans-unit id="0dcc422ff08a279a1e2d5cef7e653f8170067200" translate="yes" xml:space="preserve">
          <source>The difference with pointer variables is that you cannot change the location the array's name is pointing to, so is similar to a const pointer (it's similar, not the same. See Mark's comment). But also that you don't need to dereference the array name to get the value if you use pointer aritmetic:</source>
          <target state="translated">指针变量的区别在于,你不能改变数组名所指向的位置,所以类似于 const 指针(类似,不一样,见 Mark 的评论)。但同样的是,如果你使用指针aritmetic的话,你不需要对数组名进行引申来获取值。</target>
        </trans-unit>
        <trans-unit id="a9db9c418a7e3247f03dea45dae15f851902b4e2" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;a&lt;/code&gt; isn't a pointer or an address - it's the entire array object.  Thus, the rule in C that whenever the compiler sees an expression of array type (such as &lt;code&gt;a&lt;/code&gt;, which has type &lt;code&gt;char [10]&lt;/code&gt;) &lt;em&gt;and&lt;/em&gt; that expression isn't the operand of the &lt;code&gt;sizeof&lt;/code&gt; or unary &lt;code&gt;&amp;amp;&lt;/code&gt; operators, the type of that expression is converted (&quot;decays&quot;) to a pointer type (&lt;code&gt;char *&lt;/code&gt;), and the value of the expression is the address of the first element of the array.  Therefore, the &lt;em&gt;expression&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; has the same type and value as the expression &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; (and by extension, the expression &lt;code&gt;*a&lt;/code&gt; has the same type and value as the expression &lt;code&gt;a[0]&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题在于，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是指针或地址，而是整个数组对象。因此，C语言中的规则是，只要编译器看到数组类型的表达式（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其类型为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char [10]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该表达式不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或一元&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的操作数，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该表达式的类型被转换（&amp;ldquo;衰减&amp;rdquo;）为指针类型（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char *&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），表达式的值是数组第一个元素的地址。因此，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有相同的类型和值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（并且扩展为表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有与表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同的类型和值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f548972fa36ac45779003bea107dfbb76d2d488" translate="yes" xml:space="preserve">
          <source>The reason that this works is that the array dereferencing operator in C, &lt;code&gt;[ ]&lt;/code&gt;, is defined in terms of pointers. &lt;code&gt;x[y]&lt;/code&gt; means: start with the pointer &lt;code&gt;x&lt;/code&gt;, step &lt;code&gt;y&lt;/code&gt; elements forward after what the pointer points to, and then take whatever is there. Using pointer arithmetic syntax, &lt;code&gt;x[y]&lt;/code&gt; can also be written as &lt;code&gt;*(x+y)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之所以起作用，是因为C &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[ ]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的数组解引用运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是根据指针定义的。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x[y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;装置：开始与指针&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，步骤&lt;/font&gt;&lt;/font&gt; &lt;code&gt;y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元件后向前什么指针指向，然后采取任何是存在的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用指针算术语法，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x[y]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也可以写为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(x+y)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f2dcef49a0db01e0a7c12be52a715974b939123" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; copy the contents of the array &lt;code&gt;a&lt;/code&gt; into the pointer &lt;code&gt;p&lt;/code&gt; (whatever that would mean). Instead, the array name &lt;code&gt;a&lt;/code&gt; is converted to a pointer to its first element. So that assignment does the same as the previous one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这并&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组的内容复制&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到指针&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（无论这将意味着）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而是将数组名称&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换为指向其第一个元素的指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此该分配与上一个分配相同。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97720397d9de5f7776ab7b47e7a8bfd49701b55a" translate="yes" xml:space="preserve">
          <source>This is what I meant to demonstrate:</source>
          <target state="translated">这就是我想证明的意思。</target>
        </trans-unit>
        <trans-unit id="6cb72e404bfa6e3beb3f71ca01eb21c970c483b3" translate="yes" xml:space="preserve">
          <source>What can be confusing is that you can also write this:</source>
          <target state="translated">可能让人困惑的是,你也可以这样写。</target>
        </trans-unit>
        <trans-unit id="80283cb84d242a672f9326e918eb292aa25e03a1" translate="yes" xml:space="preserve">
          <source>When an array is not used as a value its name represents the whole array.</source>
          <target state="translated">当一个数组不作为值时,它的名字代表整个数组。</target>
        </trans-unit>
        <trans-unit id="e71642da6d1b01725d37461218c15ebb74996fb8" translate="yes" xml:space="preserve">
          <source>When an array is used as a value, its name represents the address of the first element.</source>
          <target state="translated">当数组被用作值时,其名称代表第一个元素的地址。</target>
        </trans-unit>
        <trans-unit id="8f799144b5aa153b1336a4c4f5cce1a7ac1be330" translate="yes" xml:space="preserve">
          <source>When you create an array, the only space that's allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata.  Given</source>
          <target state="translated">当你创建一个数组时,唯一被分配的空间是元素本身的空间,没有单独的指针或任何元数据的存储空间。给出</target>
        </trans-unit>
        <trans-unit id="433ebd018ce79b88da18999315449f05dc8d71b1" translate="yes" xml:space="preserve">
          <source>When you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the &lt;code&gt;gets&lt;/code&gt; function was such a menace and was eventually removed from the library).  For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您将数组表达式传递给函数时，所有接收到的函数都是指向第一个元素的指针-它不知道数组有多大（这就是为什么&lt;/font&gt;&lt;/font&gt; &lt;code&gt;gets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数如此危险并最终从库中删除） 。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了使函数知道数组有多少个元素，必须使用哨兵值（例如C字符串中的0终止符），或者必须将元素数作为单独的参数传递。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="444cd2ba614efe0a40a0f07d2e8b928989698ac1" translate="yes" xml:space="preserve">
          <source>Where things get weird is when you want to access individual elements - the expression &lt;code&gt;a[i]&lt;/code&gt; is defined as the result of &lt;code&gt;*(a + i)&lt;/code&gt; - given an address value &lt;code&gt;a&lt;/code&gt;, offset &lt;code&gt;i&lt;/code&gt; elements (&lt;em&gt;not bytes&lt;/em&gt;) from that address and dereference the result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您要访问单个元素时，事情变得很奇怪-表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(a + i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -给定一个地址值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从该地址&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;偏移&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; 个&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元素（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是bytes&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）并取消引用结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce975dab7db08d876a488028d14f674ddd0355a7" translate="yes" xml:space="preserve">
          <source>allocates memory for 10 &lt;code&gt;int&lt;/code&gt;s. You can't modify &lt;code&gt;a&lt;/code&gt; but you can do pointer arithmetic with &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配10 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您不能修改&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但你可以做指针算法有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8183efb0be6881053c90b57f32320ef2303983c" translate="yes" xml:space="preserve">
          <source>and use array subscripts as you can with a:</source>
          <target state="translated">并像使用数组子项一样使用数组子项。</target>
        </trans-unit>
        <trans-unit id="bd65de0a4b51328a21a99edd332b685d63966d06" translate="yes" xml:space="preserve">
          <source>oops :-)</source>
          <target state="translated">哎哟)</target>
        </trans-unit>
        <trans-unit id="c4fcaf9177247fe669b7a709778a547acbac41d5" translate="yes" xml:space="preserve">
          <source>what you get in memory is</source>
          <target state="translated">记忆中的东西是</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
