<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/164194">
    <body>
      <group id="164194">
        <trans-unit id="7369f1dbbb13c0f5b1914ae576611fabf3d5a20a" translate="yes" xml:space="preserve">
          <source>&quot;str&quot; is an array allocated on the stack and can be modified freely.</source>
          <target state="translated">&quot;str &quot;是堆栈上分配的数组,可以自由修改。</target>
        </trans-unit>
        <trans-unit id="6f4f9823718a35a3ce0df5bf6d6359ac144110be" translate="yes" xml:space="preserve">
          <source>5 In translation phase 7, a byte or code of value zero is appended to each multibyte
  character sequence that results from a string literal or literals. The multibyte character
  sequence is then used to initialize an array of static storage duration and length just
  sufficient to contain the sequence. For character string literals, the array elements have
  type char, and are initialized with the individual bytes of the multibyte character
  sequence [...]</source>
          <target state="translated">5 在翻译阶段7中,将一个值为0的字节或代码附加到每个由字符串字段或字面符号产生的多字节字符序列上。然后,这个多字节字符序列被用来初始化一个静态存储时间和长度刚好足够包含该序列的数组。对于字符串字元,数组元素的类型为char,用多字节字符序列的单个字节初始化[...]。</target>
        </trans-unit>
        <trans-unit id="cd7322bb185146ef549f5a00c1243d9e4faecc12" translate="yes" xml:space="preserve">
          <source>6 It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values. If the program attempts to modify such an array, the behavior is
  undefined.</source>
          <target state="translated">6 如果这些数组的元素具有适当的值,那么这些数组是否是独立的,这一点没有说明。如果程序试图修改这样的数组,行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="fac3ed3a23c3121f9d9408f6549bff597dc35ee0" translate="yes" xml:space="preserve">
          <source>6.7.8/32 &quot;Initialization&quot; gives a direct example:</source>
          <target state="translated">6.7.832 &quot;初始化 &quot;给出了一个直接的例子。</target>
        </trans-unit>
        <trans-unit id="8b695488b8249b4a46f3f5b555499d55486b4d72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char *str&lt;/code&gt; is a pointer to a string which is non modifiable(the reason for getting seg fault)..</source>
          <target state="translated">&lt;code&gt;char *str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是指向不可修改的字符串的指针（导致段错误的原因）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e645b13168dcb6a2c365f5127c101d353a93e2aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A&lt;/strong&gt;: A string literal (the formal term
  for a double-quoted string in C
  source) can be used in two slightly
  different ways:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：字符串文字（C源代码中双引号字符串的正式术语）可以以两种略有不同的方式使用：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="989caef3a70ec06f60e066ab0e2e395d4de66975" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 N1256 draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 N1256草案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7c1aaf324c090633cc6b151399499e5ec81a78b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GCC 4.8 x86-64 ELF implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC 4.8 x86-64 ELF实施&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49f8d9a28773b6bc3930685952238d28afd5aee5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q&lt;/strong&gt;: What is the difference between these initializations?</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：这些初始化之间有什么区别？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3c7f722e91108fa4fcb25941a0310cb3b603976" translate="yes" xml:space="preserve">
          <source>Also, printing the size of &lt;code&gt;str&lt;/code&gt; in the second example will show you that the compiler has allocated 7 bytes for it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二个示例中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;打印&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的大小&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将显示编译器已为其分配7个字节：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cbd97cb6ba42b992540a09774cb2c6478490196a" translate="yes" xml:space="preserve">
          <source>An array of character type may be initialized by a character string literal, optionally
  enclosed in braces. Successive characters of the character string literal (including the
  terminating null character if there is room or if the array is of unknown size) initialize the
  elements of the array.</source>
          <target state="translated">字符类型的数组可以由一个字符串字元来初始化,可选择用括号括起来。字符串字段的连续字符(如果有空间或数组的大小未知,包括终止的空字符)将初始化数组的元素。</target>
        </trans-unit>
        <trans-unit id="24944353ecb56980e9abe0eb848367d1bbe16eec" translate="yes" xml:space="preserve">
          <source>Anywhere else, it turns into an unnamed, static array of characters,
  and this unnamed array may be stored
  in read-only memory, and which
  therefore cannot necessarily be
  modified. In an expression context,
  the array is converted at once to a
  pointer, as usual (see section 6), so
  the second declaration initializes p
  to point to the unnamed array's first
  element.</source>
          <target state="translated">在任何地方,它都会变成一个未命名的、静态的字符数组,而这个未命名的数组可以存储在只读存储器中,因此不一定能被修改。在表达式上下文中,数组会像往常一样,一次性转换为指针(见第6节),所以第二个声明初始化p指向未命名数组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="08626871d2cc92f267c8fd80fc601794cef57016" translate="yes" xml:space="preserve">
          <source>As the initializer for an array of char, as in the declaration of &lt;code&gt;char a[]&lt;/code&gt; , it specifies the initial values
  of the characters in that array (and,
  if necessary, its size).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为char数组的初始化程序，如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char a[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的声明中一样&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它指定该数组中字符的初始值（并在必要时指定其大小）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f2ac90e5ac860abf9685d09d6b4fbd7022d39d8" translate="yes" xml:space="preserve">
          <source>As we all know  pointer points to memory location in memory ,
uninitialized pointer points to random memory location so and after initialization points to particular memory location</source>
          <target state="translated">我们都知道指针指向内存中的内存位置,未初始化的指针指向内存中的随机内存位置,所以和初始化后的指针指向特定的内存位置。</target>
        </trans-unit>
        <trans-unit id="53f7bb1d4edd3ccbef6d448faa7bc39cbca32ee8" translate="yes" xml:space="preserve">
          <source>Assume the strings are,</source>
          <target state="translated">假设字符串是:</target>
        </trans-unit>
        <trans-unit id="0a9b511b34e15ea2b692a64eadb322d81b287abf" translate="yes" xml:space="preserve">
          <source>Because the type of &lt;code&gt;&quot;whatever&quot;&lt;/code&gt; in the context of the 1st example is &lt;code&gt;const char *&lt;/code&gt; (even if you assign it to a non-const char*), which means you shouldn't try and write to it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一个示例的上下文&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;whatever&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char *&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即使您将其分配给非const char *），这也意味着您不应尝试对其进行写入。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25b5fe8d44d915ccc40ac69a9cf6c6ac4e5b0299" translate="yes" xml:space="preserve">
          <source>But ptr can be initialised to other string value directly since it is just pointer so it can be point to any memory address of variable of its data type</source>
          <target state="translated">但是ptr可以直接初始化为其他字符串值,因为它只是一个指针,所以可以指向任何数据类型的变量的内存地址。</target>
        </trans-unit>
        <trans-unit id="8646ef6ae439093b3a509c848a73e94716034cd4" translate="yes" xml:space="preserve">
          <source>Compile and decompile:</source>
          <target state="translated">编译和反编译。</target>
        </trans-unit>
        <trans-unit id="88ec39701a0c4df5266196b2dee36c3fa2c11fef" translate="yes" xml:space="preserve">
          <source>Conclusion: GCC stores &lt;code&gt;char*&lt;/code&gt; it in &lt;code&gt;.rodata&lt;/code&gt; section, not in &lt;code&gt;.text&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结论：GCC将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存储&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.rodata&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;节中，而不存储在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.text&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64ca5ab0ff194c61c227c75f16866d610381468c" translate="yes" xml:space="preserve">
          <source>EXAMPLE 8: The declaration</source>
          <target state="translated">例子8:宣言</target>
        </trans-unit>
        <trans-unit id="3b35a62bda88de385c42aaf857d1210eaf12a76e" translate="yes" xml:space="preserve">
          <source>Everywhere else: it generates an:</source>
          <target state="translated">其他地方:它产生了一个。</target>
        </trans-unit>
        <trans-unit id="46e39defeb634a812d739b9ddcfc21883259a655" translate="yes" xml:space="preserve">
          <source>First is one constant string which can't be modified. Second is an array with initialized value, so it can be modified.</source>
          <target state="translated">首先是一个不能修改的常数字符串。二是一个数组,有初始化值,所以可以修改。</target>
        </trans-unit>
        <trans-unit id="fcf9bd7f6f632d83d63a2a6cecbb14e0e50ea42e" translate="yes" xml:space="preserve">
          <source>If we do the same for &lt;code&gt;char[]&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做同样的事情&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f59390f0a45c1b4712554097c095cc344081aa9e" translate="yes" xml:space="preserve">
          <source>In memory array is stored in continuous memory cells, stored as &lt;code&gt;[h][e][l][l][o][\0] =&amp;gt;[]&lt;/code&gt; is 1 char byte size memory cell ,and this continuous memory cells can be access by name named strarray here.so here string array &lt;code&gt;strarray&lt;/code&gt; itself containing all characters of string initialized to it.in this case here &lt;code&gt;&quot;hello&quot;&lt;/code&gt;
so we can easily change its memory content by accessing each character by its index value</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在内存阵列中存储在连续存储单元中，存储为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[h][e][l][l][o][\0] =&amp;gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是1个字符字节大小的存储单元，并且此连续存储单元可以是通过名为strarray的名称进行访问。这里，字符串数组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;strarray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本身包含初始化为它的字符串的所有字符。在这种情况下，此处为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 因此我们可以通过按索引值访问每个字符来轻松更改其内存内容&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4337c1da9ceb238dfadf01362b0e7aaea46cc2b6" translate="yes" xml:space="preserve">
          <source>In the first case, the literal is to be copied when 'a' comes into scope. Here 'a' is an array defined on stack. It means the string will be created on the stack and its data is copied from code (text) memory, which is typically read-only (this is implementation specific, a compiler can place this read-only program data in read-writable memory also).</source>
          <target state="translated">在第一种情况下,当'a'进入作用域时,要复制这个字面符号。这里的'a'是堆栈上定义的数组。这意味着字符串将在堆栈上创建,它的数据将从代码(文本)内存中复制,而代码(文本)内存通常是只读的(这是特定的实现,编译器也可以将这种只读的程序数据放在可读可写的内存中)。</target>
        </trans-unit>
        <trans-unit id="c000469e8149dce9f4db193ab1d1c419c544bc92" translate="yes" xml:space="preserve">
          <source>In the first code, &quot;string&quot; is a string constant, and string constants should never be modified because they are often placed into read only memory.  &quot;str&quot; is a pointer being used to modify the constant.</source>
          <target state="translated">在第一段代码中,&quot;string &quot;是一个字符串常数,字符串常数永远不应该被修改,因为它们经常被放置在只读存储器中。&quot;str &quot;是一个被用来修改常量的指针。</target>
        </trans-unit>
        <trans-unit id="97ea0635da2a3e86ec6d0d79f1cfbaee517b1039" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;code&gt;str&lt;/code&gt; is a pointer that points at &lt;code&gt;&quot;string&quot;&lt;/code&gt;.  The compiler is allowed to put string literals in places in memory that you cannot write to, but can only read.  (This really should have triggered a warning, since you're assigning a &lt;code&gt;const char *&lt;/code&gt; to a &lt;code&gt;char *&lt;/code&gt;.  Did you have warnings disabled, or did you just ignore them?)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个指向&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;string&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许编译器将字符串文字放在不能写入但只能读取的内存中。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（这真的应该触发警告，因为你分配&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char *&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char *&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。你有警告无效，还是你只是忽略它们？）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff20b6a5219ae768033783979a87d2390005f2e7" translate="yes" xml:space="preserve">
          <source>In the second case, p is a pointer defined on stack (local scope) and referring a string literal (program data or text) stored else where. Usually modifying such memory is not good practice nor encouraged.</source>
          <target state="translated">在第二种情况下,p是一个定义在堆栈(本地范围)上的指针,并引用存储在其他地方的字符串字段(程序数据或文本)。通常情况下,修改这样的内存并不是好的做法,也不鼓励。</target>
        </trans-unit>
        <trans-unit id="1838ffd28fb512b277c85a385ef6b7802941bd8e" translate="yes" xml:space="preserve">
          <source>In the second code, &quot;string&quot; is an array initializer, sort of short hand for</source>
          <target state="translated">在第二段代码中,&quot;string &quot;是一个数组的初始化器,有点类似于简笔画中的</target>
        </trans-unit>
        <trans-unit id="c5aa22fba1b64b02c810315d7188a316eef98093" translate="yes" xml:space="preserve">
          <source>In the second example, the string &lt;code&gt;&quot;string&quot;&lt;/code&gt; is &lt;em&gt;copied&lt;/em&gt; by the compiler from its read-only home to the &lt;code&gt;str[]&lt;/code&gt; array. Then changing the first character is permitted. You can check this by printing the address of each:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二个例子中，字符串&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;string&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从其只读家编译到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后允许更改第一个字符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以通过打印每个地址来进行检查：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea00e14bcd6a402dfaf6f0f35e2ce17d7c1d0e5a" translate="yes" xml:space="preserve">
          <source>In the second place, you're creating an array, which is memory that you've got full access to, and initializing it with &lt;code&gt;&quot;string&quot;&lt;/code&gt;.  You're creating a &lt;code&gt;char[7]&lt;/code&gt; (six for the letters, one for the terminating '\0'), and you do whatever you like with it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其次，您要创建一个数组，该数组是您具有完全访问权限的内存，并使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;string&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对其进行初始化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您正在创建一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char[7]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（六个代表字母，一个代表终止字母'\ 0'），然后您可以随便使用它。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bff6151bb1c52734e7b864d94be02cc2901c7e76" translate="yes" xml:space="preserve">
          <source>In your first example, you're getting a pointer to that const data.  In your second example, you're initializing an array of 7 characters with a copy of the const data.</source>
          <target state="translated">在你的第一个例子中,你得到了一个指向这个 const 数据的指针。在第二个例子中,你正在用 const 数据的副本初始化一个 7 个字符的数组。</target>
        </trans-unit>
        <trans-unit id="10fd75efad3719fe3bb4eb8209929e181c321d6b" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;char[]&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71621f4c0ca35b4b447632316c08b9f646620f62" translate="yes" xml:space="preserve">
          <source>Like any other regular array, &lt;code&gt;c&lt;/code&gt; can be modified.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;像任何其他常规数组一样，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以修改&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f0cb45122635efbac7d2998e31e4b524f1c810c9" translate="yes" xml:space="preserve">
          <source>Most of these answers are correct, but just to add a little more clarity...</source>
          <target state="translated">这些答案大部分都是正确的,但只是为了增加一点清晰度......</target>
        </trans-unit>
        <trans-unit id="ab87e7164433d13846cff22c0a5731378c323d7e" translate="yes" xml:space="preserve">
          <source>My program crashes if I try to assign a new value to &lt;code&gt;p[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果尝试为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配新值，程序将崩溃&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e46d81bdcd2425d26c847ea2d5d64bbe3b1cb583" translate="yes" xml:space="preserve">
          <source>Normally, string literals are stored in read-only memory when the program is run. This is to prevent you from accidentally changing a string constant. In your first example, &lt;code&gt;&quot;string&quot;&lt;/code&gt; is stored in read-only memory and &lt;code&gt;*str&lt;/code&gt; points to the first character. The segfault happens when you try to change the first character to &lt;code&gt;'z'&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常，程序运行时，字符串文字会存储在只读存储器中。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是为了防止您意外更改字符串常量。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第一个示例中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;string&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存储在只读存储器中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向第一个字符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您尝试将第一个字符更改为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;'z'&lt;/code&gt; 时,将发生段错误&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ac69938cb0651b2d6b8ce2d43bf3af47cb99539" translate="yes" xml:space="preserve">
          <source>Note however that the default linker script puts &lt;code&gt;.rodata&lt;/code&gt; and &lt;code&gt;.text&lt;/code&gt; in the same segment, which has execute but no write permission. This can be observed with:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是请注意，默认的链接描述文件将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.rodata&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.text&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;放在同一段中，该段具有执行权限但没有写权限。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这可以通过以下方式观察到：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4e329055872d3c12f2cc484b260a44f643d9971" translate="yes" xml:space="preserve">
          <source>Note the implicit cast from &lt;code&gt;char[]&lt;/code&gt; to &lt;code&gt;char *&lt;/code&gt;, which is always legal.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char *&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的隐式强制&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这始终是合法的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="86546a25fe2d8c85ef2156d6bfee43929dbe1777" translate="yes" xml:space="preserve">
          <source>Output contains:</source>
          <target state="translated">产出包括:</target>
        </trans-unit>
        <trans-unit id="bc5de071a8adc9ea913c6f9e5f0005a2d40cc14d" translate="yes" xml:space="preserve">
          <source>Pointer</source>
          <target state="translated">Pointer</target>
        </trans-unit>
        <trans-unit id="79e5360bcf55c6212f0b1414e9099c15ef47ee22" translate="yes" xml:space="preserve">
          <source>Program:</source>
          <target state="translated">Program:</target>
        </trans-unit>
        <trans-unit id="26bd51102e586ff70bb0587551dbc67bec7fc0ad" translate="yes" xml:space="preserve">
          <source>See the C FAQ, &lt;a href=&quot;http://c-faq.com/decl/strlitinit.html&quot;&gt;Question 1.32&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅C FAQ，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://c-faq.com/decl/strlitinit.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题1.32&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b9a3011e9aa306b196ebd07257ac293bbdbd232" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;str[0]=&lt;/code&gt; is attempting to write to the read-only code of the application.  I would guess this is probably compiler dependent though.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str[0]=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;试图写入应用程序的只读代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我想这可能是编译器依赖的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1332c2aeb09d0c1817fe85b41907f9631446a288" translate="yes" xml:space="preserve">
          <source>So this is just a shortcut for:</source>
          <target state="translated">所以,这只是一个捷径。</target>
        </trans-unit>
        <trans-unit id="b5698d0895816d08e306d72f3fb561310cfca67f" translate="yes" xml:space="preserve">
          <source>So when you write:</source>
          <target state="translated">所以当你写的时候。</target>
        </trans-unit>
        <trans-unit id="b4f5fa445d8872f4d54fec5b7f0c287426411c5a" translate="yes" xml:space="preserve">
          <source>Some compilers have a switch
  controlling whether string literals
  are writable or not (for compiling old
  code), and some may have options to
  cause string literals to be formally
  treated as arrays of const char (for
  better error catching).</source>
          <target state="translated">有些编译器有一个开关来控制字符串字元是否可写(用于编译旧代码),有些编译器可能有选项使字符串字元被正式处理成 const char 的数组(为了更好地捕捉错误)。</target>
        </trans-unit>
        <trans-unit id="bcfac5632b1f0c9485944d083e902221ab174657" translate="yes" xml:space="preserve">
          <source>String literals like &quot;string&quot; are probably allocated in your executable's address space as read-only data (give or take your compiler).  When you go to touch it, it freaks out that you're in its bathing suit area and lets you know with a seg fault.</source>
          <target state="translated">像 &quot;string &quot;这样的字符串字元很可能在你的可执行文件的地址空间中被分配为只读数据(不管你的编译器是否允许)。当你去触摸它的时候,它就会因为你在它的泳衣区里而抓狂,然后用seg故障让你知道。</target>
        </trans-unit>
        <trans-unit id="65ee6b0cdf5b4fc22f771b21a56a4d300a3a3bfe" translate="yes" xml:space="preserve">
          <source>Tested with MSVC and GCC.</source>
          <target state="translated">用MSVC和GCC测试。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="7f018e4fa7f9467f75ae0f3445107e843a7ea140" translate="yes" xml:space="preserve">
          <source>The &quot;read only memory&quot; that people are referring to is the text segment in ASM terms. It's the same place in memory where the instructions are loaded. This is read-only for obvious reasons like security. When you create a char* initialized to a string, the string data is compiled into the text segment and the program initializes the pointer to point into the text segment. So if you try to change it, kaboom. Segfault.</source>
          <target state="translated">人们所说的 &quot;只读存储器 &quot;是指ASM术语中的文本段。它是内存中加载指令的地方。出于安全等明显的原因,这里是只读存储器。当你创建一个初始化为字符串的char*时,字符串数据被编译到文本段中,程序初始化指针指向文本段。因此,如果你试图改变它,kaboom。Segfault。</target>
        </trans-unit>
        <trans-unit id="db2526ed7b3f0955d3ba159e7158dc450975f890" translate="yes" xml:space="preserve">
          <source>The C FAQ that @matli linked to mentions it, but no one else here has yet, so for clarification: if a string literal (double-quoted string in your source) is used anywhere &lt;em&gt;other than&lt;/em&gt; to initialize a character array (ie: @Mark's second example, which works correctly), that string is stored by the compiler in a special &lt;em&gt;static string table&lt;/em&gt;, which is akin to creating a global static variable (read-only, of course) that is essentially anonymous (has no variable &quot;name&quot;). The &lt;em&gt;read-only&lt;/em&gt; part is the important part, and is why the @Mark's first code example segfaults.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的C常见问题是@matli挂提到它，但没有一个人在这里还没有，所以澄清：如果一个字符串（在源双引号字符串）用于任何地方&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以外&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化字符数组（即：@ Mark的第二个示例正确运行），该字符串由编译器存储在一个特殊的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静态字符串表中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，类似于创建一个基本上是匿名的全局静态变量（当然是只读的）（没有变量&amp;ldquo; name&amp;rdquo;） &amp;rdquo;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只读&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;部分是重要组成部分，也是为什么@马克的第一个代码示例段错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="153d6e82c56945ee94a9b46f97146ff737c5a61d" translate="yes" xml:space="preserve">
          <source>The above sets &lt;code&gt;str&lt;/code&gt; to point to the literal value &lt;code&gt;&quot;string&quot;&lt;/code&gt; which is hard-coded in the program's binary image, which is probably flagged as read-only in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的设置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向文字值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;string&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该文字值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在程序的二进制映像中进行了硬编码，可能在内存中标记为只读。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b40d2b2f20d0458f25ede06c4f5dd644c7b2ba9f" translate="yes" xml:space="preserve">
          <source>The compiler has enforced this by putting the string in a read-only part of memory, hence writing to it generates a segfault.</source>
          <target state="translated">编译器通过将字符串放在内存的只读部分强制执行,因此写到它会产生一个segfault。</target>
        </trans-unit>
        <trans-unit id="af5b4181887adb17c079d2ba90c26ce6b8194e5b" translate="yes" xml:space="preserve">
          <source>The contents of the arrays are modifiable. On the other hand, the declaration</source>
          <target state="translated">数组的内容是可以修改的。另一方面,声明中的</target>
        </trans-unit>
        <trans-unit id="7eabf5eb08cf7d0aa68f14acaece18add4ee544d" translate="yes" xml:space="preserve">
          <source>The following code receives seg fault on line 2:</source>
          <target state="translated">下面的代码在第2行收到seg故障。</target>
        </trans-unit>
        <trans-unit id="38b874fa8a4a12a55bfe752327cc1339971672a4" translate="yes" xml:space="preserve">
          <source>The line:</source>
          <target state="translated">这条线。</target>
        </trans-unit>
        <trans-unit id="51a8d743261763d0c5ba6a3d8400bee365d6b7e1" translate="yes" xml:space="preserve">
          <source>Then if you modify &lt;code&gt;c[0]&lt;/code&gt;, you also modify &lt;code&gt;__unnamed&lt;/code&gt;, which is UB.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，如果您修改&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么您还将修改&lt;/font&gt;&lt;/font&gt; &lt;code&gt;__unnamed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它是UB。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04c2442ba0cb356bca376365107aaf0cde3ee082" translate="yes" xml:space="preserve">
          <source>There are two different uses of character string literals:</source>
          <target state="translated">字符串识字法有两种不同的用法。</target>
        </trans-unit>
        <trans-unit id="8e34f037d3b8729159339c78ec31107ef278d97a" translate="yes" xml:space="preserve">
          <source>This declaration is identical to</source>
          <target state="translated">这一声明与</target>
        </trans-unit>
        <trans-unit id="f06c9be022ff454489265524b61c1f9972fefa06" translate="yes" xml:space="preserve">
          <source>This is &quot;more magic&quot;, and described at 6.7.8/14 &quot;Initialization&quot;:</source>
          <target state="translated">这是 &quot;更有魔力&quot;,在6.7.814 &quot;初始化 &quot;中描述。</target>
        </trans-unit>
        <trans-unit id="33114f84c8b259a7d360bf056480d7a655a4fe82" translate="yes" xml:space="preserve">
          <source>This is documented at 6.4.5 &quot;String literals&quot;:</source>
          <target state="translated">这一点在6.4.5 &quot;String literals &quot;中有所记载。</target>
        </trans-unit>
        <trans-unit id="21b0b9815b988cab4a0b05332115eaf25e71b859" translate="yes" xml:space="preserve">
          <source>This is similar to:</source>
          <target state="translated">这类似于。</target>
        </trans-unit>
        <trans-unit id="fee34be18f8766afae1debba6298fcb27f068cec" translate="yes" xml:space="preserve">
          <source>To understand this error or problem you should first know difference b/w the pointer and array
  so here firstly i have explain you differences b/w them</source>
          <target state="translated">要理解这个错误或问题,你应该首先知道指针和数组的区别,所以在这里我首先向你解释一下它们之间的区别</target>
        </trans-unit>
        <trans-unit id="a478f8da6e515e2fe6dd6cf28c5c4f51c92040d9" translate="yes" xml:space="preserve">
          <source>When written as an array, the compiler places the initialized string data in the data segment instead, which is the same place that your global variables and such live. This memory is mutable, since there are no instructions in the data segment. This time when the compiler initializes the character array (which is still just a char*) it's pointing into the data segment rather than the text segment, which you can safely alter at run-time.</source>
          <target state="translated">当写成数组时,编译器会把初始化的字符串数据放到数据段中,而数据段就是你的全局变量之类的地方。这个内存是可变的,因为数据段中没有指令。这时,当编译器初始化字符数组(仍然只是一个char*)时,它指向的是数据段,而不是文本段,你可以在运行时安全地改变它。</target>
        </trans-unit>
        <trans-unit id="43057d0685a9d16e1cc0b2587f6e1f0f9008dd5b" translate="yes" xml:space="preserve">
          <source>While this works perfectly well:</source>
          <target state="translated">虽然这样做的效果非常好。</target>
        </trans-unit>
        <trans-unit id="0ba0bb95ffdcd69d1d7712168e6a876a3d9f0af4" translate="yes" xml:space="preserve">
          <source>Why do I get a segmentation fault when writing to a string initialized with “char *s” but not “char s[]”</source>
          <target state="translated">为什么我在写入初始化为 &quot;char *s &quot;而不是 &quot;char s[]&quot;的字符串时,会出现分段故障?</target>
        </trans-unit>
        <trans-unit id="97dfcf15090fe7931b0df660cee46dcc110c2899" translate="yes" xml:space="preserve">
          <source>Why do I get a segmentation fault when writing to a string?</source>
          <target state="translated">为什么我在写到一个字符串时,会出现分段故障?</target>
        </trans-unit>
        <trans-unit id="84a6f36914b097f4069d48b0b519d0c189fa5de1" translate="yes" xml:space="preserve">
          <source>allocates a pointer to a string literal, which the compiler is putting in a non-modifiable part of your executable;</source>
          <target state="translated">分配一个指向字符串字段的指针,编译器将其放在可执行文件的不可修改部分中。</target>
        </trans-unit>
        <trans-unit id="4eb2c39a057f022d979f91705d518db79edb0bf8" translate="yes" xml:space="preserve">
          <source>allocates an array of characters and &lt;strong&gt;copies&lt;/strong&gt; the literal string into that array, which is fully writable, so the subsequent update is no problem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配一个字符数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并将文字字符串&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到该数组中，这是完全可写的，因此后续更新没有问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2214b85c01a8d4edbc6eff4ad1019b49b487aa9" translate="yes" xml:space="preserve">
          <source>allocates and initializes a local array which is modifiable</source>
          <target state="translated">分配和初始化一个本地数组,该数组是可以修改的。</target>
        </trans-unit>
        <trans-unit id="d5b239ccd2177ae46d581df782b5594c7a0d9837" translate="yes" xml:space="preserve">
          <source>and its value changed to &lt;code&gt;'m'&lt;/code&gt; so strarray value changed to &lt;code&gt;&quot;mello&quot;&lt;/code&gt;;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且其值更改为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;'m'&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此strarray的值更改为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;mello&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d331ecd74f69ad7ca2e044d44238d690431a55f6" translate="yes" xml:space="preserve">
          <source>and ptr is stored in stack section and pointing to constant string &lt;code&gt;&quot;hello&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ptr存储在堆栈部分中，并指向常量字符串&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="938eeebcc6d366c0b191b2f834fbc620432d9112" translate="yes" xml:space="preserve">
          <source>array of char &lt;a href=&quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c&quot;&gt;What is the type of string literals in C and C++?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;char数组&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C和C ++中的字符串文字类型是什么？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f64bf1221a6ac522194ae0c7ab90762fb2e7ca99" translate="yes" xml:space="preserve">
          <source>defines &quot;plain&quot; char array objects &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; whose elements are initialized with character string literals.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义&amp;ldquo;普通&amp;rdquo;字符数组对象&lt;/font&gt;&lt;/font&gt; &lt;code&gt;s&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其元素用字符串文字初始化。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9173e3cc5a32f0d4ae02383bf750ccb501d24de" translate="yes" xml:space="preserve">
          <source>defines &lt;code&gt;p&lt;/code&gt; with type &quot;pointer to char&quot; and initializes it to point to an object with type &quot;array of char&quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use &lt;code&gt;p&lt;/code&gt; to modify the contents of the array, the behavior is undefined.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型为&amp;ldquo; char的指针&amp;rdquo;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并将其初始化为指向长度为4的类型为&amp;ldquo; char的数组&amp;rdquo;的对象，该对象的元素使用字符串文字进行初始化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果试图使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来修改数组的内容，则该行为是不确定的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="af637eef49d7eacafd71fda4b5594f52ab24f683" translate="yes" xml:space="preserve">
          <source>here pointer ptr is initialized to string &lt;code&gt;&quot;hello&quot;&lt;/code&gt; which is  constant string stored in read only memory (ROM) so &lt;code&gt;&quot;hello&quot;&lt;/code&gt; can not be changed as it is stored in ROM</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里指针ptr初始化为字符串&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它是存储在只读存储器（ROM）中的常量字符串，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能更改，因为它存储在ROM中&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43d341a6f1c4cea8b8f1e09a5ce91bcfa5b9e857" translate="yes" xml:space="preserve">
          <source>line defines a pointer and points it to a literal string.  The literal string is not writable so when you do:</source>
          <target state="translated">行定义了一个指针,并将其指向一个直译字符串。字符串是不可写的,所以当你做的时候。</target>
        </trans-unit>
        <trans-unit id="ff74309b3859b009b29964a766f21e44f0016a02" translate="yes" xml:space="preserve">
          <source>one point to note here that we can change the content of string array by changing character by character but can not initialized other string directly to it like &lt;code&gt;strarray=&quot;new string&quot;&lt;/code&gt; is invalid</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要注意的一点是，我们可以通过逐个字符地更改字符串数组的内容，但是不能像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;strarray=&quot;new string&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一样直接将其他字符串初始化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为无效&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="215d031429d1b7843b753e6f1d83e313eba91b16" translate="yes" xml:space="preserve">
          <source>segmentation fault is caused when you tyr to access the memory which is non accessible.</source>
          <target state="translated">当你访问不可访问的内存时,会出现分段故障。</target>
        </trans-unit>
        <trans-unit id="b54d50ef4ba8196181cb1705327251659b50884e" translate="yes" xml:space="preserve">
          <source>so it gets stored in the stack (relative to &lt;code&gt;%rbp&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此它被存储在堆栈中（相对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%rbp&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="feb09f52e5024b791dd6ebc8ee7d24c1b947d9b6" translate="yes" xml:space="preserve">
          <source>so ptr[0]='m' is invalid since you can not access read only memory</source>
          <target state="translated">所以ptr[0]='m'是无效的,因为你不能访问只读存储器。</target>
        </trans-unit>
        <trans-unit id="e70a97412ee866c25a7972ced744e63de9f7f87a" translate="yes" xml:space="preserve">
          <source>string array</source>
          <target state="translated">字符串数组</target>
        </trans-unit>
        <trans-unit id="d5607fe56fc2010bb7d690790ccafa089c8db902" translate="yes" xml:space="preserve">
          <source>that gives UB if modified</source>
          <target state="translated">如果修改了,就会有UB</target>
        </trans-unit>
        <trans-unit id="867b9a00623e417b4844f0dffcffb808848bad58" translate="yes" xml:space="preserve">
          <source>unnamed</source>
          <target state="translated">unnamed</target>
        </trans-unit>
        <trans-unit id="82b76e320e6a246cb2b9c19bd7c16502ea374dee" translate="yes" xml:space="preserve">
          <source>we obtain:</source>
          <target state="translated">我们得到:</target>
        </trans-unit>
        <trans-unit id="cb2a656c582155d38c9effe568399734a250635b" translate="yes" xml:space="preserve">
          <source>whereas &lt;code&gt;char str[]&lt;/code&gt; is an array and can be modifiable..</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char str[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个数组，可以修改。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b30fcd4fae496a47d73de21913c424b6de7ef0a5" translate="yes" xml:space="preserve">
          <source>which contains:</source>
          <target state="translated">其中包括:</target>
        </trans-unit>
        <trans-unit id="6dcfd341c68e6a635162413a9b37b77231e5afb8" translate="yes" xml:space="preserve">
          <source>with static storage</source>
          <target state="translated">带静态存储</target>
        </trans-unit>
        <trans-unit id="c378582dd3e8fcd41744e8aa9b969d86fc2cbf4a" translate="yes" xml:space="preserve">
          <source>you get a seg fault.  On some platforms, the literal might be in writable memory so you won't see a segfault, but it's invalid code (resulting in undefined behavior) regardless.</source>
          <target state="translated">你会得到一个seg故障。在某些平台上,这个字段可能是在可写的内存中,所以你不会看到seg故障,但它是无效的代码(导致未定义的行为)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
