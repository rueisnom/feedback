<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/16047306">
    <body>
      <group id="16047306">
        <trans-unit id="1542e91684ce086bf89edc832e9a12e68917d0bd" translate="yes" xml:space="preserve">
          <source>&quot;Why is deploying software to a docker image easier than simply
  deploying to a consistent production environment ?&quot;</source>
          <target state="translated">&quot;일관된 프로덕션 환경에 단순히 배포하는 것보다 소프트웨어를 Docker 이미지에 쉽게 배포하는 이유는 무엇입니까?&quot;</target>
        </trans-unit>
        <trans-unit id="1d737b3b8cc6837fe64e3c75b0a1c0df5030c48c" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Traditional server&lt;/strong&gt; stack consist of a physical server that runs an operating system and your application.</source>
          <target state="translated">1) &lt;strong&gt;기존 서버&lt;/strong&gt; 스택은 운영 체제와 응용 프로그램을 실행하는 실제 서버로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="077bf232fbda32be3b9c0ab79f72fec0ccb8d9e3" translate="yes" xml:space="preserve">
          <source>1. Lightweight</source>
          <target state="translated">1. 경량</target>
        </trans-unit>
        <trans-unit id="71d09371a22fe78dc0de04cc920e874384c82810" translate="yes" xml:space="preserve">
          <source>2) The &lt;strong&gt;VM stack&lt;/strong&gt; consist of a physical server which runs an operating system and a hypervisor that manages your virtual machine, shared resources, and networking interface. Each Vm runs a Guest Operating System, an application or set of applications.</source>
          <target state="translated">2) &lt;strong&gt;VM 스택&lt;/strong&gt; 은 운영 체제를 실행하는 물리적 서버와 가상 시스템, 공유 리소스 및 네트워킹 인터페이스를 관리하는 하이퍼 바이저로 구성됩니다. 각 Vm은 게스트 운영 체제, 응용 프로그램 또는 응용 프로그램 집합을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f4d7c4a101bb829d6ed36e595aa3142e9a5ffa6b" translate="yes" xml:space="preserve">
          <source>2. Layered File System</source>
          <target state="translated">2. 계층 파일 시스템</target>
        </trans-unit>
        <trans-unit id="8770d6a677830b5217dd912f5ec099a51998f621" translate="yes" xml:space="preserve">
          <source>3) The &lt;strong&gt;Container Setup&lt;/strong&gt;, the key difference with other stack is container-based virtualization uses the kernel of the host OS to rum multiple isolated guest instances. These guest instances are called as containers. The host can be either a physical server or VM.</source>
          <target state="translated">3) &lt;strong&gt;컨테이너 설정&lt;/strong&gt; 은 다른 스택과의 주요 차이점은 컨테이너 기반 가상화는 호스트 OS의 커널을 사용하여 여러 개의 격리 된 게스트 인스턴스를 럼주로 만드는 것입니다. 이러한 게스트 인스턴스를 컨테이너라고합니다. 호스트는 물리적 서버 또는 VM 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f675ab8f3566b687071343481ea9fc44b56715" translate="yes" xml:space="preserve">
          <source>3. Shared OS Kernel</source>
          <target state="translated">3. 공유 OS 커널</target>
        </trans-unit>
        <trans-unit id="31685e3d48621a28b58dd2cd05e5db872f4854fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;# uname -a
Linux linuxkit-025000000001 4.9.93-linuxkit-aufs #1 SMP Wed Jun 6 16:86_64 Linux&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;# uname -a Linux linuxkit-025000000001 4.9.93-linuxkit-aufs #1 SMP Wed Jun 6 16:86_64 Linux&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db614d06449b37f5ad288477a28799e03dc9b933" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="142e735c59804464a6da15ca8105687fa120d79a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;P.S. Meanwhile Docker uses its own implementation &quot;libcontainer&quot; instead of LXC. But LXC is still usable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PS While Docker는 LXC 대신 자체 구현 &quot;libcontainer&quot;를 사용합니다.&lt;/em&gt; &lt;em&gt;그러나 LXC는 여전히 사용 가능합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96829e303b9c7ac4c207907619fd8a78876e2fb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32eaa8b2035633536d9f24ca2887aff163749024" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Container-based Virtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨테이너 기반 가상화&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db5599f735e2a2500c32124da79ac1b874f9d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Containers vs Virtual Machines&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨테이너 대 가상 머신&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22a17ffbbec3938d78f7dede48285ca33d145bb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Disadvantages:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1210c3169b4fa074a2e3c489001d1a1b1d8641ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker containers&lt;/strong&gt; on the other hand, are slightly different. We have the server. We have the host operating system. But &lt;strong&gt;instead a hypervisor&lt;/strong&gt;, we have the &lt;strong&gt;Docker engine&lt;/strong&gt;, in this case. In this case, we're not bringing a whole guest operating system with us. &lt;strong&gt;We're bringing a very thin layer of the operating system&lt;/strong&gt;, and the container can talk down into the host OS in order to get to the kernel functionality there. And that allows us to have a very lightweight container.</source>
          <target state="translated">반면 &lt;strong&gt;Docker 컨테이너&lt;/strong&gt; 는 약간 다릅니다. 서버가 있습니다. 호스트 운영 체제가 있습니다. 그러나 &lt;strong&gt;하이퍼 바이저 대신&lt;/strong&gt; 이 경우 &lt;strong&gt;Docker 엔진&lt;/strong&gt; 이 있습니다. 이 경우 전체 게스트 운영 체제를 제공하지 않습니다. &lt;strong&gt;우리는 운영 체제의 매우 얇은 계층을 가져오고 있으며&lt;/strong&gt; 컨테이너는 커널 기능을 얻기 위해 호스트 OS와 통신 할 수 있습니다. 그리고 우리는 매우 가벼운 컨테이너를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a8ae3356972a5874b5d32602a6ac41e683d87a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Emulation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Emulation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae64e762702e7238eb615f129fe6646d7df6d223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How containers works at low level?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨테이너가 낮은 수준에서 어떻게 작동합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cba3211b30b4294611bb6ea91489a1d00653523" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does Docker run containers in non-Linux systems?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Docker는 Linux 이외의 시스템에서 컨테이너를 어떻게 실행합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="041068c8237a3813ea49d52d6e51404b0e89980d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How virtualization works at low level?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가상화가 낮은 수준에서 어떻게 작동합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e0bc44a9e608ef3585c6d58d928f09910c03729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hypervisor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hypervisor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7372d7558096b8ae97739046d3fde3ac50229425" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Docker, the containers share the kernel&lt;/strong&gt; with the host; hence it is lightweight and can start and stop quickly.</source>
          <target state="translated">&lt;strong&gt;Docker에서 컨테이너는 커널&lt;/strong&gt; 을 호스트와 &lt;strong&gt;공유합니다&lt;/strong&gt; . 따라서 가볍고 빠르게 시작하고 멈출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fdf40f7f0dc77381f5f20369656158a3494158f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LXC&lt;/strong&gt;s:</source>
          <target state="translated">&lt;strong&gt;LXC&lt;/strong&gt;s:</target>
        </trans-unit>
        <trans-unit id="c3dedd742cecc6cd5d1a8cbac5f59953031f91af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paravirtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Paravirtualization&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b21d70651265dcd079d0ebae89422c38b3fd9409" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Think of containers as processes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨테이너를 프로세스로 생각하십시오!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c76a69be324057355bbf0c801aa45a367c1705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Types of Virtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가상화 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0635560c3d8658f5a265d9aaa0a2b08757d22a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;VM&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;VM&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="04abd370cd085bed90eeed217f1681cbd37bf6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Virtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Virtualization&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d578b69a5047755d5db94a2927a4a2b1fc905cf" translate="yes" xml:space="preserve">
          <source>A Docker container is just a process (and its children) that is compartmentalized using &lt;a href=&quot;https://en.wikipedia.org/wiki/Cgroups&quot;&gt;cgroups&lt;/a&gt; inside the host system's kernel from the rest of the processes. You can actually see your Docker container processes by running &lt;code&gt;ps aux&lt;/code&gt; on the host. For example, starting &lt;code&gt;apache2&lt;/code&gt; &quot;in a container&quot; is just starting &lt;code&gt;apache2&lt;/code&gt; as a special process on the host. It's just been compartmentalized from other processes on the machine. It is important to note that your containers do not exist outside of your containerized process' lifetime. When your process dies, your container dies. That's because Docker replaces &lt;code&gt;pid 1&lt;/code&gt; inside your container with your application (&lt;code&gt;pid 1&lt;/code&gt; is normally the init system). This last point about &lt;code&gt;pid 1&lt;/code&gt; is very important.</source>
          <target state="translated">Docker 컨테이너는 프로세스 (및 그 자식) 일 뿐이며 나머지 프로세스에서 호스트 시스템 커널 내부의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cgroups&quot;&gt;cgroup을&lt;/a&gt; 사용하여 구획화됩니다. 실제로 호스트에서 &lt;code&gt;ps aux&lt;/code&gt; 를 실행하여 Docker 컨테이너 프로세스를 볼 수 있습니다. 예를 들어, &quot;컨테이너에서&quot; &lt;code&gt;apache2&lt;/code&gt; 를 시작하는 것은 호스트에서 특별한 프로세스로 apache2 를 시작하는 것입니다. 컴퓨터의 다른 프로세스에서 구획화되었습니다. 컨테이너는 컨테이너화 된 프로세스 수명 밖에서는 존재하지 않습니다. 프로세스가 죽으면 컨테이너가 죽습니다. Docker는 컨테이너 내부의 &lt;code&gt;pid 1&lt;/code&gt; 을 응용 프로그램으로 대체하기 때문입니다 ( pid 1 은 일반적으로 init 시스템입니다). &lt;code&gt;pid 1&lt;/code&gt; 에 대한 마지막 요점은 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="78eeb92cd87dde74faca433458994016f4decd02" translate="yes" xml:space="preserve">
          <source>A container image is a lightweight, stand-alone, executable package of
  a piece of software that includes everything needed to run it: code,
  runtime, system tools, system libraries, settings. Available for both
  Linux and Windows based apps, containerized software will always run
  the same, regardless of the environment. Containers isolate software
  from its surroundings, for example differences between development and
  staging environments and help reduce conflicts between teams running
  different software on the same infrastructure.</source>
          <target state="translated">컨테이너 이미지는 코드, 런타임, 시스템 도구, 시스템 라이브러리, 설정 등 실행에 필요한 모든 것을 포함하는 경량의 독립형 실행 가능 소프트웨어 패키지입니다. Linux 및 Windows 기반 앱 모두에서 사용할 수있는 컨테이너화 된 소프트웨어는 환경에 관계없이 항상 동일하게 실행됩니다. 컨테이너는 개발 환경과 준비 환경의 차이와 같이 주변 환경에서 소프트웨어를 격리하고 동일한 인프라에서 다른 소프트웨어를 실행하는 팀 간의 충돌을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7be30e300596f0ba9bc71be0ee7f62418bc87c8b" translate="yes" xml:space="preserve">
          <source>A full virtualized system gets its own set of resources allocated to it, and does minimal sharing. You get more isolation, but it is much heavier (requires more resources). With Docker you get less isolation, but the containers are lightweight (require fewer resources). So you could easily run thousands of containers on a host, and it won't even blink. Try doing that with Xen, and unless you have a really big host, I don't think it is possible.</source>
          <target state="translated">완전 가상화 시스템은 자체 리소스 세트를 할당받으며 최소한의 공유를 수행합니다. 더 많은 격리를 얻지 만 훨씬 더 무겁습니다 (더 많은 리소스가 필요함). Docker를 사용하면 격리가 줄어들지 만 컨테이너는 가벼워집니다 (더 적은 리소스 필요). 따라서 호스트에서 수천 개의 컨테이너를 쉽게 실행할 수 있으며 깜박 거리지 않습니다. Xen을 사용하여 시도해보십시오. 정말로 큰 호스트가 없다면 가능하지 않다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="608fbdee4c4148887ee88283fec33bc794754b17" translate="yes" xml:space="preserve">
          <source>A full virtualized system usually takes minutes to start, whereas Docker/LXC/runC containers take seconds, and often even less than a second.</source>
          <target state="translated">전체 가상화 시스템은 일반적으로 시작하는 데 몇 분이 걸리지 만 Docker / LXC / runC 컨테이너는 몇 초가 걸리며 종종 1 초도 채 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4b2e429639e6886f8411056dda3847c82546562" translate="yes" xml:space="preserve">
          <source>A normal VM (for example, VirtualBox and VMware) uses a hypervisor, and related technologies either have dedicated firmware that becomes the first layer for the first OS (host OS, or guest OS 0) or a software that runs on the host OS to provide hardware emulation such as CPU, USB/accessories, memory, network, etc., to the guest OSes. VMs are still (as of 2015) popular in high security multi-tenant environment.</source>
          <target state="translated">일반적인 VM (예 : VirtualBox 및 VMware)은 하이퍼 바이저를 사용하며 관련 기술에는 첫 번째 OS (호스트 OS 또는 게스트 OS 0)의 첫 번째 계층이되는 전용 펌웨어 또는 호스트 OS에서 실행되는 소프트웨어가 있습니다. CPU, USB / 액세서리, 메모리, 네트워크 등과 같은 하드웨어 에뮬레이션을 게스트 OS에 제공합니다. VM은 여전히 ​​높은 보안 다중 테넌트 환경에서 인기가 있습니다 (2015 년 기준).</target>
        </trans-unit>
        <trans-unit id="94101e1c748c27249505148a47df8530a21b42ed" translate="yes" xml:space="preserve">
          <source>A virtual machine emulates a physical computing environment, but requests for CPU, memory, hard disk, network and other hardware resources are managed by a virtualization layer which translates these requests to the underlying physical hardware.</source>
          <target state="translated">가상 시스템은 물리적 컴퓨팅 환경을 에뮬레이트하지만 CPU, 메모리, 하드 디스크, 네트워크 및 기타 하드웨어 리소스에 대한 요청은 가상화 계층에서 관리하여 이러한 요청을 기본 물리적 하드웨어로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d923b7473237dcd6ea141e8da0b0dc01d79023e1" translate="yes" xml:space="preserve">
          <source>A virtualizer encapsulates an OS that can run any applications it can normally run on a bare metal machine.</source>
          <target state="translated">가상화는 베어 메탈 머신에서 일반적으로 실행할 수있는 모든 애플리케이션을 실행할 수있는 OS를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="6d59a769d8037c795aa06bba1ef20f7fb8148382" translate="yes" xml:space="preserve">
          <source>Abandoning VMs is not practical as of now. So both VMs and LXCs have their own individual existence and importance.</source>
          <target state="translated">VM을 포기하는 것은 현재로서는 실용적이지 않습니다. 따라서 VM과 LXC는 각자 고유 한 존재와 중요성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9f1e587c930b5eec7c7112c3c5c48f8660cb1e" translate="yes" xml:space="preserve">
          <source>All containers on a host machine share the scheduler of the host machine saving need of extra resources.</source>
          <target state="translated">호스트 시스템의 모든 컨테이너는 호스트 시스템의 스케줄러를 공유하므로 추가 자원이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12541b433287714758ede775818e5b65a743a10e" translate="yes" xml:space="preserve">
          <source>All containers run inside this VM.</source>
          <target state="translated">모든 컨테이너는이 VM 내에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="54b4b640aadb7cfc9c96aa084587f5b6a81007c9" translate="yes" xml:space="preserve">
          <source>All containers running on a host is indeed a bunch of processes with different file systems. They share the same OS kernel, only encapsulates system library and dependencies.</source>
          <target state="translated">호스트에서 실행되는 모든 컨테이너는 실제로 다른 파일 시스템을 가진 많은 프로세스입니다. 이들은 동일한 OS 커널을 공유하며 시스템 라이브러리 및 종속성 만 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="1242f984643238195d2560e484817f61f78a1183" translate="yes" xml:space="preserve">
          <source>All it has in there is the application code and any binaries and libraries that it requires. And those binaries and libraries can actually be shared across different containers if you want them to be as well. And what this enables us to do, is a number of things. They have &lt;strong&gt;much faster startup time&lt;/strong&gt;. You can't stand up a single VM in a few seconds like that. And equally, taking them down as quickly.. so we can scale up and down very quickly and we'll look at that later on.</source>
          <target state="translated">응용 프로그램 코드와 필요한 이진 및 라이브러리 만 있으면됩니다. 또한이 바이너리와 라이브러리는 원하는 경우 다른 컨테이너에서 공유 할 수 있습니다. 그리고 이것이 우리를 가능하게하는 것은 많은 것들입니다. &lt;strong&gt;시작 시간&lt;/strong&gt; 이 &lt;strong&gt;훨씬 빠릅니다&lt;/strong&gt; . 몇 초 안에 단일 VM을 견딜 수 없습니다. 똑같이, 그것들을 빨리 줄이십시오. 그래서 우리는 매우 빠르게 확장 및 축소 할 수 있으며, 나중에 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="f836b6bbddefb5d4fc7275c8e4836939cd0b1d3c" translate="yes" xml:space="preserve">
          <source>All these seem like improvements, not revolution. Well, &lt;em&gt;quantitative accumulation leads to qualitative transformation&lt;/em&gt;.</source>
          <target state="translated">이 모든 것이 혁명이 아니라 개선 된 것처럼 보입니다. 음, &lt;em&gt;양적 축적은 질적 변환으로 이어집니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a3b5f0368363469d9d80cc687e706a23e041424b" translate="yes" xml:space="preserve">
          <source>And finally you will even often be able to reproduce complex production environments even on your Linux laptop (don't call me if doesn't work in your case ;))</source>
          <target state="translated">그리고 마지막으로 Linux 랩톱에서도 복잡한 프로덕션 환경을 재현 할 수도 있습니다 (귀하의 경우 작동하지 않으면 전화하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="4f108d5a48660532c28d2ad4f3d3edba0268d0ae" translate="yes" xml:space="preserve">
          <source>And of course you can start Docker containers in VMs (it's a good idea). Reduce your server provisioning on the VM level. All the above could be managed by Docker.</source>
          <target state="translated">물론 VM에서 Docker 컨테이너를 시작할 수 있습니다 (좋은 아이디어). VM 수준에서 서버 프로비저닝을 줄입니다. 위의 모든 내용은 Docker에서 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ad81be781ce70f499768e24f3435d23637132329" translate="yes" xml:space="preserve">
          <source>And yes there are issues with containers including managing them although tools like Kubernetes or Docker Swarm greatly simplify the task.</source>
          <target state="translated">Kubernetes 또는 Docker Swarm과 같은 도구가 작업을 크게 단순화하지만 컨테이너 관리와 관련된 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="72a1b17c5906a7f20ce9ae99d036afd244eb15c1" translate="yes" xml:space="preserve">
          <source>Another important issue regarding Docker is Docker Hub and its community.
For example, I implemented an ecosystem for monitoring kafka using Prometheus, Grafana, Prometheus-JMX-Exporter, and Docker.</source>
          <target state="translated">Docker와 관련된 또 다른 중요한 문제는 Docker Hub 및 해당 커뮤니티입니다. 예를 들어 Prometheus, Grafana, Prometheus-JMX-Exporter 및 Docker를 사용하여 kafka를 모니터링하기위한 에코 시스템을 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="2621c6fd51a58e1d1d5c491aac71488647b20224" translate="yes" xml:space="preserve">
          <source>Archive</source>
          <target state="translated">Archive</target>
        </trans-unit>
        <trans-unit id="57f80354947d66e1556a5eca93c5ebe70343ca99" translate="yes" xml:space="preserve">
          <source>Around &lt;a href=&quot;http://blog.differential.com/the-story-behind-meteors-next-big-move/&quot;&gt;2006&lt;/a&gt;, people including some of the employees at Google implemented new kernel level feature called &lt;em&gt;namespaces&lt;/em&gt; (however the idea &lt;a href=&quot;http://rhelblog.redhat.com/2015/08/28/the-history-of-containers/&quot;&gt;long&lt;/a&gt; before &lt;a href=&quot;https://www.linux.com/component/content/article/186-virtualization/300057-containers-vs-hypervisors-choosing-the-best-virtualization-technology-&quot;&gt;existed in FreeBSD&lt;/a&gt;). One function of the OS is to allow sharing of global resources like network and disk to processes. What if these global resources were wrapped in namespaces so that they are visible only to those processes that run in the same namespace? Say, you can get a chunk of disk and put that in namespace X and then processes running in namespace Y can't see or access it. Similarly, processes in namespace X can't access anything in memory that is allocated to namespace Y. Of course, processes in X can't see or talk to processes in namespace Y. This provides kind of virtualization and isolation for global resources. This is how docker works: Each container runs in its own namespace but uses exactly the &lt;em&gt;same&lt;/em&gt; kernel as all other containers. The isolation happens because kernel knows the namespace that was assigned to the process and during API calls it makes sure that process can only access resources in its own namespace.</source>
          <target state="translated">&lt;a href=&quot;http://blog.differential.com/the-story-behind-meteors-next-big-move/&quot;&gt;2006&lt;/a&gt; 년경 Google 직원 일부를 포함하여 사람들은 &lt;em&gt;네임 스페이스&lt;/em&gt; 라는 새로운 커널 레벨 기능을 구현했습니다 (그러나 그 아이디어 &lt;a href=&quot;https://www.linux.com/component/content/article/186-virtualization/300057-containers-vs-hypervisors-choosing-the-best-virtualization-technology-&quot;&gt;는 FreeBSD에&lt;/a&gt; &lt;a href=&quot;http://rhelblog.redhat.com/2015/08/28/the-history-of-containers/&quot;&gt;오래&lt;/a&gt; 전부터 존재했습니다 ). OS의 기능 중 하나는 네트워크 및 디스크와 같은 글로벌 리소스를 프로세스와 공유 할 수 있도록하는 것입니다. 이러한 전역 리소스가 네임 스페이스로 래핑되어 동일한 네임 스페이스에서 실행되는 프로세스에만 표시되도록하려면 어떻게해야합니까? 디스크 덩어리를 가져 와서 네임 스페이스 X에 넣은 다음 네임 스페이스 Y에서 실행중인 프로세스는 볼 수 없거나 액세스 할 수 없습니다. 마찬가지로 네임 스페이스 X의 프로세스는 네임 스페이스 Y에 할당 된 메모리의 어떤 것도 액세스 할 수 없습니다. 물론 X의 프로세스는 네임 스페이스 Y의 프로세스를 보거나 대화 할 수 없습니다. 이는 전역 리소스에 대한 일종의 가상화 및 격리를 제공합니다. 도커 작동 방식은 다음과 같습니다. 각 컨테이너는 자체 네임 스페이스에서 실행되지만 다른 모든 컨테이너 &lt;em&gt;와&lt;/em&gt; 정확히 &lt;em&gt;동일한&lt;/em&gt; 커널을 사용합니다. 커널은 프로세스에 할당 된 네임 스페이스를 알고 있기 때문에 API 호출 중에 프로세스가 자체 네임 스페이스의 리소스에만 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5d01eda27cef34d23b355ad375a9bb0b4eb5ebbb" translate="yes" xml:space="preserve">
          <source>As a general rule there is only one application per container which simplifies configuration.</source>
          <target state="translated">일반적으로 컨테이너 당 하나의 응용 프로그램 만 있으므로 구성이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="598b72a60140d7f35d63c4ce17f4d2a21404bafd" translate="yes" xml:space="preserve">
          <source>As far as the filesystem used by each of those container processes, Docker uses &lt;a href=&quot;https://en.wikipedia.org/wiki/UnionFS&quot;&gt;UnionFS&lt;/a&gt;-backed images, which is what you're downloading when you do a &lt;code&gt;docker pull ubuntu&lt;/code&gt;. Each &quot;image&quot; is just a series of layers and related metadata. The concept of layering is very important here. Each layer is just a change from the layer underneath it. For example, when you delete a file in your Dockerfile while building a Docker container, you're actually just creating a layer on top of the last layer which says &quot;this file has been deleted&quot;. Incidentally, this is why you can delete a big file from your filesystem, but the image still takes up the same amount of disk space. The file is still there, in the layers underneath the current one. Layers themselves are just tarballs of files. You can test this out with &lt;code&gt;docker save --output /tmp/ubuntu.tar ubuntu&lt;/code&gt; and then &lt;code&gt;cd /tmp &amp;amp;&amp;amp; tar xvf ubuntu.tar&lt;/code&gt;. Then you can take a look around. All those directories that look like long hashes are actually the individual layers. Each one contains files (&lt;code&gt;layer.tar&lt;/code&gt;) and metadata (&lt;code&gt;json&lt;/code&gt;) with information about that particular layer. Those layers just describe changes to the filesystem which are saved as a layer &quot;on top of&quot; its original state. When reading the &quot;current&quot; data, the filesystem reads data as though it were looking only at the top-most layers of changes. That's why the file appears to be deleted, even though it still exists in &quot;previous&quot; layers, because the filesystem is only looking at the top-most layers. This allows completely different containers to share their filesystem layers, even though some significant changes may have happened to the filesystem on the top-most layers in each container. This can save you a ton of disk space, when your containers share their base image layers. However, when you mount directories and files from the host system into your container by way of volumes, those volumes &quot;bypass&quot; the UnionFS, so changes are not stored in layers.</source>
          <target state="translated">Docker는 각 컨테이너 프로세스에서 사용하는 파일 시스템에 이르기까지 &lt;a href=&quot;https://en.wikipedia.org/wiki/UnionFS&quot;&gt;UnionFS&lt;/a&gt; 지원 이미지를 사용합니다.이 이미지는 &lt;code&gt;docker pull ubuntu&lt;/code&gt; 를 수행 할 때 다운로드하는 이미지입니다. 각 &quot;이미지&quot;는 일련의 레이어 및 관련 메타 데이터입니다. 레이어링의 개념은 여기서 매우 중요합니다. 각 레이어는 그 아래 레이어에서 변경된 것입니다. 예를 들어 Docker 컨테이너를 빌드하는 동안 Dockerfile에서 파일을 삭제하면 실제로는 마지막 레이어 위에 &quot;이 파일이 삭제되었습니다&quot;라는 레이어가 생성됩니다. 또한 파일 시스템에서 큰 파일을 삭제할 수는 있지만 이미지는 여전히 같은 양의 디스크 공간을 차지합니다. 파일은 여전히 ​​현재 레이어 아래에 있습니다. 레이어 자체는 단지 파일의 tarball입니다. &lt;code&gt;docker save --output /tmp/ubuntu.tar ubuntu&lt;/code&gt; 와 &lt;code&gt;cd /tmp &amp;amp;&amp;amp; tar xvf ubuntu.tar&lt;/code&gt; 이것을 테스트 할 수 있습니다. 그런 다음 둘러 볼 수 있습니다. 긴 해시처럼 보이는 모든 디렉토리는 실제로 개별 레이어입니다. 각 파일에는 해당 특정 레이어에 대한 정보가 포함 된 파일 ( &lt;code&gt;layer.tar&lt;/code&gt; ) 및 메타 데이터 ( &lt;code&gt;json&lt;/code&gt; )가 있습니다. 이러한 계층은 파일 시스템에 대한 변경 사항 만 설명하며 원래의 &quot;상위&quot;에 계층으로 저장됩니다. &quot;현재&quot;데이터를 읽을 때 파일 시스템은 최상위 계층의 변경 사항 만보고있는 것처럼 데이터를 읽습니다. 파일 시스템이 최상위 계층 만보고 있기 때문에 파일이 여전히 &quot;이전&quot;계층에 존재하더라도 파일이 삭제 된 것처럼 보입니다. 이렇게하면 각 컨테이너의 최상위 레이어에서 파일 시스템에 약간의 변경이 있었더라도 완전히 다른 컨테이너가 파일 시스템 레이어를 공유 할 수 있습니다. 이는 컨테이너가 기본 이미지 레이어를 공유 할 때 많은 디스크 공간을 절약 할 수 있습니다. 그러나 볼륨을 통해 호스트 시스템의 디렉토리와 파일을 컨테이너에 마운트 할 때 해당 볼륨은 UnionFS를 &quot;우회&quot;하므로 변경 사항은 계층에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a90c96cd22c443750dcd37a720eff4fed88c89c" translate="yes" xml:space="preserve">
          <source>As you can see the extrapolated total number of servers for an organisation is rarely in single figures, is very often in triple figures and can easily be significantly higher still.</source>
          <target state="translated">보시다시피 조직의 외삽 된 총 서버 수는 단일 수치에는 거의없고 3 배 수치에 불과하며 여전히 훨씬 더 높을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81f5b5d7fb019e7f4ae5f8b5f55e80d3576c41bd" translate="yes" xml:space="preserve">
          <source>AuFS is a layered file system, so you can have a read only part and a write part which are merged together. One could have the common parts of the operating system as read only (and shared amongst all of your containers) and then give each container its own mount for writing.</source>
          <target state="translated">AuFS는 계층 파일 시스템이므로 함께 병합 된 읽기 전용 부분과 쓰기 부분을 가질 수 있습니다. 하나는 운영 체제의 공통 부분을 읽기 전용 (모든 컨테이너간에 공유)으로 설정 한 다음 각 컨테이너에 쓰기를위한 자체 마운트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cfd99ba34f608f70161df11d9d7991016760ff2" translate="yes" xml:space="preserve">
          <source>Backout consists of stopping and deleting the container.</source>
          <target state="translated">제거는 컨테이너 중지 및 삭제로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="351e46cacb0525510c6af44a48e0b695b9063feb" translate="yes" xml:space="preserve">
          <source>Backout requires undoing changes in the VM. Or restoring it if possible.</source>
          <target state="translated">백 아웃을하려면 VM에서 변경 사항을 취소해야합니다. 또는 가능하면 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="d851c9a4f97cb1a71d6b2be6463bab52ea582fa4" translate="yes" xml:space="preserve">
          <source>Besides that, they are very light-weight and flexible thanks to the dockerFile configuration.</source>
          <target state="translated">또한 dockerFile 구성 덕분에 매우 가볍고 유연합니다.</target>
        </trans-unit>
        <trans-unit id="e9df9aab39e6b2e3d5e433a04b4d06ee5e827531" translate="yes" xml:space="preserve">
          <source>Besides the Docker Hub site there is another site called quay.io that you can use to have your own Docker images dashboard there and pull/push to/from it. You can even import Docker images from Docker Hub to quay then running them from quay on your own machine.</source>
          <target state="translated">Docker Hub 사이트 외에도 quay.io라는 또 다른 사이트가 있습니다.이 사이트에는 고유 한 Docker 이미지 대시 보드를 가져 와서 가져 오거나 푸시 할 수 있습니다. Docker Hub에서 Docker 이미지를 quay로 가져 와서 자신의 컴퓨터에서 quay에서 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f47b682df45612c96346dc99122be39bdc7654" translate="yes" xml:space="preserve">
          <source>But I want to add additional point of view, not covered in detail here. In my opinion Docker differs also in whole process. In contrast to VMs, Docker is not (only) about optimal resource sharing of hardware, moreover it provides a &quot;system&quot; for packaging application (preferable, but not a must, as a set of microservices).</source>
          <target state="translated">그러나 여기에 자세히 다루지 않은 추가 관점을 추가하고 싶습니다. 제 생각에는 Docker는 전체 프로세스에서도 다릅니다. VM과는 달리 Docker는 하드웨어의 최적의 자원 공유에 관한 것만이 아니라 응용 프로그램 패키징을위한 &quot;시스템&quot;을 제공합니다 (마이크로 서비스 세트로서 바람직하지만 필수는 아님).</target>
        </trans-unit>
        <trans-unit id="2246070647f40bdc0a60270679c1fd264e82ae9e" translate="yes" xml:space="preserve">
          <source>But the big question is, is it feasible?, will it be sensible?</source>
          <target state="translated">그러나 가장 큰 문제는 실현 가능합니까?</target>
        </trans-unit>
        <trans-unit id="467036aef2189670c83d3de39dc33422063e461b" translate="yes" xml:space="preserve">
          <source>By comparing the container setup with its predecessors, we can conclude that containerization is the fastest, most resource effective, and most secure setup we know to date. Containers are isolated instances that run your application. &lt;strong&gt;Docker spin up the container in a way, layers get run time memory with default storage drivers(Overlay drivers) those run within seconds and copy-on-write layer created on top of it once we commit into the container, that powers the execution of containers.&lt;/strong&gt; In case of VM's that will take around a minute to load everything into the virtualize environment. These lightweight instances can be replaced, rebuild, and moved around easily. This allows us to mirror the production and development environment and is tremendous help in CI/CD processes. The advantages containers can provide are so compelling that they're definitely here to stay.</source>
          <target state="translated">컨테이너 설정과 이전 설정을 비교하면 컨테이너화가 현재까지 가장 빠르고, 가장 효율적이며, 가장 효과적인 설정이라는 결론을 내릴 수 있습니다. 컨테이너는 응용 프로그램을 실행하는 격리 된 인스턴스입니다. &lt;strong&gt;도커는 컨테이너를 어떤 식 으로든 가동시킵니다. 레이어는 몇 초 안에 실행되는 기본 스토리지 드라이버 (오버레이 드라이버)와 컨테이너에 커밋 한 후 쓰기 위의 복사 레이어로 런타임 메모리를 얻습니다. 용기.&lt;/strong&gt; VM의 경우 모든 것을 가상화 환경에로드하는 데 약 1 분이 걸립니다. 이 경량 인스턴스는 쉽게 교체, 재 구축 및 이동할 수 있습니다. 이를 통해 프로덕션 및 개발 환경을 미러링 할 수 있으며 CI / CD 프로세스에 큰 도움이됩니다. 컨테이너가 제공 할 수있는 장점은 매우 매력적입니다.</target>
        </trans-unit>
        <trans-unit id="2218fd115399d11f4e43b078ba742fac667ff0de" translate="yes" xml:space="preserve">
          <source>Complex configuration</source>
          <target state="translated">복잡한 구성</target>
        </trans-unit>
        <trans-unit id="ba8780a743531027156a18a445e7af93055ec46f" translate="yes" xml:space="preserve">
          <source>Container states (Docker or LXC images) are small in size compared to virtual machine images, so container images are easy to distribute.</source>
          <target state="translated">컨테이너 상태 (Docker 또는 LXC 이미지)는 가상 머신 이미지에 비해 크기가 작으므로 컨테이너 이미지를 쉽게 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ce7e45cb65773b9965d5fad315cc3119faab36" translate="yes" xml:space="preserve">
          <source>Container-based virtualization</source>
          <target state="translated">컨테이너 기반 가상화</target>
        </trans-unit>
        <trans-unit id="598df2f164e7aaa8e067a8c319cc0e57e541f468" translate="yes" xml:space="preserve">
          <source>Container-based virtualization, also known as operating system-level virtualization, enables multiple isolated executions within a single operating system kernel. It has the best possible performance and density and features dynamic resource management. The isolated virtual execution environment provided by this type of virtualization is called a container and can be viewed as a traced group of processes.</source>
          <target state="translated">운영 체제 수준 가상화라고도하는 컨테이너 기반 가상화는 단일 운영 체제 커널 내에서 여러 격리 된 실행을 가능하게합니다. 최상의 성능과 밀도를 가지며 동적 리소스 관리 기능이 있습니다. 이 유형의 가상화에서 제공하는 격리 된 가상 실행 환경을 컨테이너라고하며 추적 된 프로세스 그룹으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d4c3cdeb8073372b70957b9b2f3cd7fe34f32eb" translate="yes" xml:space="preserve">
          <source>Cost efficiency</source>
          <target state="translated">비용 효율성</target>
        </trans-unit>
        <trans-unit id="735a54b02db689eb4f4e57bf659a737787c87afb" translate="yes" xml:space="preserve">
          <source>Deploying a consistent production environment is easier said than done. Even if you use tools like &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_%28software%29&quot;&gt;Chef&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt;, there are always OS updates and other things that change between hosts and environments.</source>
          <target state="translated">일관된 프로덕션 환경을 배포하는 것이 말하는 것보다 쉽습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_%28software%29&quot;&gt;Chef&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt; 과 같은 도구를 사용하더라도 호스트와 환경간에 변경되는 OS 업데이트 및 기타 사항이 항상 있습니다.</target>
        </trans-unit>
        <trans-unit id="943c1d3d450b735a762475a53fbc3f3845e18058" translate="yes" xml:space="preserve">
          <source>Developers can often develop on PCs beyond the control of corporate or business standardisation rules (e.g. freelancers who develop on their own machines (often remotely) or contributors to open source projects who are not 'employed' or 'contracted' to configure their PCs a certain way)</source>
          <target state="translated">개발자는 종종 회사 또는 비즈니스 표준화 규칙 (예 : 자신의 컴퓨터에서 원격으로 개발하는 프리랜서) 또는 PC를 특정 '구성'하기 위해 '고용'또는 '계약'하지 않은 오픈 소스 프로젝트에 기여한 프리랜서가 통제 할 수없는 PC에서 개발할 수 있습니다. 방법)</target>
        </trans-unit>
        <trans-unit id="648c9952f3e90ecd09eb98e62fc5b9803514288d" translate="yes" xml:space="preserve">
          <source>Developers, and indeed testers, will all have either subtlely or vastly different PC configurations, by the very nature of the job</source>
          <target state="translated">개발자와 실제로 테스터는 작업의 본질에 따라 미묘하거나 전혀 다른 PC 구성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d58e3f21c27fd593809010f14d9f9baa0486da85" translate="yes" xml:space="preserve">
          <source>Difficult to migrate</source>
          <target state="translated">마이그레이션하기 어려움</target>
        </trans-unit>
        <trans-unit id="02c9786ecd26345d0f7e906cc555a19e98790432" translate="yes" xml:space="preserve">
          <source>Difficult to scale</source>
          <target state="translated">확장하기 어려움</target>
        </trans-unit>
        <trans-unit id="2437715c53b48152d323d9cdffd1153b925cb3c8" translate="yes" xml:space="preserve">
          <source>Docker and LXC is meant more for sandboxing, containerization, and resource isolation. It uses the host OS's (currently only Linux kernel) clone API which provides namespacing for IPC, NS (mount), network, PID, UTS, etc.</source>
          <target state="translated">Docker 및 LXC는 샌드 박싱, 컨테이너화 및 리소스 격리에 더 적합합니다. IPC, NS (마운트), 네트워크, PID, UTS 등에 네임 스페이스를 제공하는 호스트 OS (현재 Linux 커널 만) 클론 API를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0670367a7dd49858e74261aabd50689718ce92d8" translate="yes" xml:space="preserve">
          <source>Docker containers are isolated environments. You can see it when you issue the &lt;code&gt;top&lt;/code&gt; command in a Docker container that has been created from a Docker image.</source>
          <target state="translated">도커 컨테이너는 격리 된 환경입니다. Docker 이미지에서 생성 된 Docker 컨테이너에서 &lt;code&gt;top&lt;/code&gt; 명령을 실행할 때 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39db408285c6798b78a9365ee4e90c59857f3a5e" translate="yes" xml:space="preserve">
          <source>Docker encapsulates an application with all its dependencies.</source>
          <target state="translated">Docker는 모든 종속성으로 응용 프로그램을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="973f8f76caeb9718bdc472542aacfb07e2e84af9" translate="yes" xml:space="preserve">
          <source>Docker for Mac uses &lt;a href=&quot;https://github.com/moby/hyperkit&quot;&gt;https://github.com/moby/hyperkit&lt;/a&gt; to emulate the hypervisor capabilities and Hyperkit uses hypervisor.framework in its core. Hypervisor.framework is Mac's native hypervisor solution. Hyperkit also uses VPNKit and DataKit to namespace network and filesystem respectively.</source>
          <target state="translated">Mac 용 Docker는 &lt;a href=&quot;https://github.com/moby/hyperkit&quot;&gt;https://github.com/moby/hyperkit&lt;/a&gt; 을 사용하여 하이퍼 바이저 기능을 에뮬레이트하고 Hyperkit은 코어에서 hypervisor.framework를 사용합니다. Hypervisor.framework는 Mac의 기본 하이퍼 바이저 솔루션입니다. Hyperkit은 또한 VPNKit과 DataKit을 사용하여 네임 스페이스 네트워크와 파일 시스템을 각각 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3414abcd2e979a63ae859b5dbc68d077ef1b7ab6" translate="yes" xml:space="preserve">
          <source>Docker gives you the ability to snapshot the OS into a shared image, and makes it easy to deploy on other Docker hosts. Locally, dev, qa, prod, etc.: all the same image. Sure you can do this with other tools, but not nearly as easily or fast.</source>
          <target state="translated">Docker를 사용하면 OS를 공유 이미지로 스냅 샷 할 수 있으며 다른 Docker 호스트에 쉽게 배포 할 수 있습니다. 로컬로 dev, qa, prod 등 : 모두 동일한 이미지. 물론 다른 도구를 사용하여이 작업을 수행 할 수 있지만, 쉽고 빠르지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d5d7812c058dbb0c86c05605da9d9d304ccab2a" translate="yes" xml:space="preserve">
          <source>Docker has been developed based on LXC (Linux Container) and works perfectly in many Linux distributions, especially Ubuntu.</source>
          <target state="translated">Docker는 LXC (Linux Container)를 기반으로 개발되었으며 많은 Linux 배포판, 특히 Ubuntu에서 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e635f7c85d8f012e88161b22bf2e6522d0f921ac" translate="yes" xml:space="preserve">
          <source>Docker is container based technology and containers are just user space of the operating system. 
1:At the low level, a container is just a set of processes that are isolated from the rest of the system, running from a distinct image that provides all files necessary to support the processes.
2: It is built for running applications. In Docker, the containers running share the host OS kernel.
&lt;strong&gt;VIRTUAL MACHINE&lt;/strong&gt;
a:A Virtual Machine, on the other hand, is not based on container technology. They are made up of user space plus kernel space of an operating system.
b: Under VMs, server hardware is virtualized. Each VM has Operating system (OS) &amp;amp; apps. It shares hardware resource from the host.
&lt;strong&gt;VM &amp;amp; DOCKER&lt;/strong&gt;
A: VMs &amp;amp; Docker &amp;ndash; each comes with benefits and demerits. Under a VM environment, each workload needs a complete OS.
B: But with a container environment, multiple workloads can run with 1 OS. The bigger the OS footprint, the more environment benefits from containers. With this, it brings further benefits like Reduced IT management resources, reduced size of snapshots, quicker spinning up apps, reduced &amp;amp; simplified security updates, less code to transfer, migrate and upload workloads.</source>
          <target state="translated">Docker는 컨테이너 기반 기술이며 컨테이너는 운영 체제의 사용자 공간입니다. 1 : 저수준에서 컨테이너는 프로세스를 지원하는 데 필요한 모든 파일을 제공하는 고유 한 이미지에서 실행되는 나머지 시스템과 격리 된 일련의 프로세스입니다. 2 : 응용 프로그램을 실행하도록 설계되었습니다. Docker에서 실행되는 컨테이너는 호스트 OS 커널을 공유합니다. &lt;strong&gt;가상 머신&lt;/strong&gt; a : 반면 가상 머신은 컨테이너 기술을 기반으로하지 않습니다. 이들은 운영 체제의 사용자 공간과 커널 공간으로 구성됩니다. b : VM에서 서버 하드웨어가 가상화됩니다. 각 VM에는 운영 체제 (OS) 및 앱이 있습니다. 호스트에서 하드웨어 리소스를 공유합니다. &lt;strong&gt;VM &amp;amp; DOCKER&lt;/strong&gt; A : VM과 Docker는 각각 장점과 단점이 있습니다. VM 환경에서 각 워크로드에는 완전한 OS가 필요합니다. B : 그러나 컨테이너 환경에서는 1 개의 OS로 여러 워크로드를 실행할 수 있습니다. OS 풋 프린트가 클수록 컨테이너의 환경 이점이 커집니다. 이를 통해 IT 관리 리소스 감소, 스냅 샷 크기 감소, 앱 회전 속도 향상, 보안 업데이트 감소 및 단순화, 전송 코드 마이그레이션, 마이그레이션 및 업로드와 같은 추가적인 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b421c171d242c8170806930398752966ab85b44" translate="yes" xml:space="preserve">
          <source>Docker is just a fancy way to run a process, not a virtual machine.</source>
          <target state="translated">Docker는 가상 머신이 아닌 프로세스를 실행하는 멋진 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c84bdd2076394c3c27e65f730787ccf2624b38d1" translate="yes" xml:space="preserve">
          <source>Docker is moving very fast. Its &lt;a href=&quot;https://docs.docker.com/&quot;&gt;documentation&lt;/a&gt; is some of the best documentation I've ever seen. It is generally well-written, concise, and accurate. I recommend you check the documentation available for more information, and trust the documentation over anything else you read online, including Stack Overflow. If you have specific questions, I highly recommend joining &lt;code&gt;#docker&lt;/code&gt; on Freenode IRC and asking there (you can even use Freenode's &lt;a href=&quot;https://webchat.freenode.net/&quot;&gt;webchat&lt;/a&gt; for that!).</source>
          <target state="translated">Docker는 매우 빠르게 움직이고 있습니다. 그 &lt;a href=&quot;https://docs.docker.com/&quot;&gt;문서&lt;/a&gt; 는 내가 본 최고의 문서 중 일부입니다. 일반적으로 잘 작성되고 간결하며 정확합니다. 자세한 내용은 사용 가능한 설명서를 확인하고 Stack Overflow를 포함하여 온라인에서 읽은 내용에 대한 설명서를 신뢰하는 것이 좋습니다. 구체적인 질문이 있으시면 Freenode IRC에서 &lt;code&gt;#docker&lt;/code&gt; 에 가입하여 문의하십시오 ( Freenode의 웹챗 을 사용해도됩니다).</target>
        </trans-unit>
        <trans-unit id="73b8cae18034650b6584789ec0b6826a36a4969b" translate="yes" xml:space="preserve">
          <source>Docker is the company driving the container movement and the only
  container platform provider to address every application across the
  hybrid cloud. Today&amp;rsquo;s businesses are under pressure to digitally
  transform but are constrained by existing applications and
  infrastructure while rationalizing an increasingly diverse portfolio
  of clouds, datacenters and application architectures. Docker enables
  true independence between applications and infrastructure and
  developers and IT ops to unlock their potential and creates a model
  for better collaboration and innovation.</source>
          <target state="translated">Docker는 컨테이너 이동을 주도하는 회사이며 하이브리드 클라우드 전체의 모든 애플리케이션을 처리 할 수있는 유일한 컨테이너 플랫폼 제공 업체입니다. 오늘날의 비즈니스는 디지털 혁신에 대한 압박을 받고 있지만 기존 애플리케이션과 인프라에 의해 제약을받는 동시에 점점 더 다양한 클라우드, 데이터 센터 및 애플리케이션 아키텍처 포트폴리오를 합리화하고 있습니다. Docker는 응용 프로그램과 인프라, 개발자 및 IT 운영 부서 간의 진정한 독립성을 통해 잠재력을 발휘하고 더 나은 협업 및 혁신을위한 모델을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4ac745d6259187beaf5143c3a366b5e962516e92" translate="yes" xml:space="preserve">
          <source>Docker isn't a virtualization methodology. It relies on other tools that actually implement container-based virtualization or operating system level virtualization. For that, Docker was initially using LXC driver, then moved to libcontainer which is now renamed as runc. Docker primarily focuses on automating the deployment of applications inside application containers. Application containers are designed to package and run a single service, whereas system containers are designed to run multiple processes, like virtual machines. So, Docker is considered as a container management or application deployment tool on containerized systems.</source>
          <target state="translated">Docker는 가상화 방법이 아닙니다. 실제로 컨테이너 기반 가상화 또는 운영 체제 수준 가상화를 구현하는 다른 도구를 사용합니다. 이를 위해 Docker는 처음에 LXC 드라이버를 사용하고 libcontainer로 이동했으며 이제는 runc로 이름이 변경되었습니다. Docker는 주로 응용 프로그램 컨테이너 내부의 응용 프로그램 배포 자동화에 중점을 둡니다. 응용 프로그램 컨테이너는 단일 서비스를 패키지화하고 실행하도록 설계되었지만 시스템 컨테이너는 가상 시스템과 같은 여러 프로세스를 실행하도록 설계되었습니다. 따라서 Docker는 컨테이너화 된 시스템에서 컨테이너 관리 또는 응용 프로그램 배포 도구로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="50c82cb7fe6266a82e2fb9c3452a93b0098b144f" translate="yes" xml:space="preserve">
          <source>Docker originally used &lt;a href=&quot;https://linuxcontainers.org/lxc/&quot;&gt;LinuX Containers&lt;/a&gt; (LXC), but later switched to &lt;a href=&quot;https://github.com/opencontainers/runc&quot;&gt;runC&lt;/a&gt; (formerly known as &lt;strong&gt;libcontainer&lt;/strong&gt;), which runs in the same operating system as its host. This allows it to share a lot of the host operating system resources. Also, it uses a layered filesystem (&lt;a href=&quot;http://aufs.sourceforge.net/&quot;&gt;AuFS&lt;/a&gt;) and manages networking.</source>
          <target state="translated">Docker는 원래 &lt;a href=&quot;https://linuxcontainers.org/lxc/&quot;&gt;LinuX Containers&lt;/a&gt; (LXC)를 사용했지만 나중에 호스트와 동일한 운영 체제에서 실행되는 &lt;a href=&quot;https://github.com/opencontainers/runc&quot;&gt;runC&lt;/a&gt; (이전의 &lt;strong&gt;libcontainer&lt;/strong&gt; )로 전환했습니다. 이를 통해 많은 호스트 운영 체제 리소스를 공유 할 수 있습니다. 또한 계층 파일 시스템 ( &lt;a href=&quot;http://aufs.sourceforge.net/&quot;&gt;AuFS&lt;/a&gt; )을 사용하고 네트워킹을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="41fa7729ec5381ee8638f255f1cb4f7a87c60789" translate="yes" xml:space="preserve">
          <source>Docker uses &lt;strong&gt;UNION File system&lt;/strong&gt; .. Docker uses a copy-on-write technology to reduce the memory space consumed by containers. &lt;a href=&quot;https://medium.com/@nagarwal/docker-containers-filesystem-demystified-b6ed8112a04a&quot;&gt;Read more here&lt;/a&gt;</source>
          <target state="translated">Docker는 &lt;strong&gt;UNION File system을&lt;/strong&gt; 사용 &lt;strong&gt;합니다&lt;/strong&gt; . Docker는 copy-on-write 기술을 사용하여 컨테이너가 사용하는 메모리 공간을 줄입니다. &lt;a href=&quot;https://medium.com/@nagarwal/docker-containers-filesystem-demystified-b6ed8112a04a&quot;&gt;자세한 내용은 여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7a3c15391c182ccba309a3b738b4b90db0a222a" translate="yes" xml:space="preserve">
          <source>Docker, basically containers, supports &lt;strong&gt;OS virtualization&lt;/strong&gt; i.e. your application feels that it has a complete instance of an OS whereas VM supports &lt;strong&gt;hardware virtualization&lt;/strong&gt;. You feel like it is a physical machine in which you can boot any OS.</source>
          <target state="translated">Docker, 기본적으로 컨테이너는 &lt;strong&gt;OS 가상화를&lt;/strong&gt; 지원합니다. 즉, 응용 프로그램은 &lt;strong&gt;OS&lt;/strong&gt; 의 완전한 인스턴스가 있다고 생각하는 반면 VM은 &lt;strong&gt;하드웨어 가상화를&lt;/strong&gt; 지원 &lt;strong&gt;합니다&lt;/strong&gt; . OS를 부팅 할 수있는 실제 머신 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="d01409177152f353bc55c371b17b74ce19db744e" translate="yes" xml:space="preserve">
          <source>Docker/LXC can almost be run on any cheap hardware (less than 1&amp;nbsp;GB of memory is also OK as long as you have newer kernel) vs. normal VMs need at least 2&amp;nbsp;GB of memory, etc., to do anything meaningful with it. But Docker support on the host OS is not available in OS such as Windows (as of Nov 2014) where as may types of VMs can be run on windows, Linux, and Macs.</source>
          <target state="translated">Docker / LXC는 저렴한 하드웨어에서 거의 실행될 수 있습니다 (최신 커널이있는 한 1GB 미만의 메모리도 괜찮습니다) 대 일반 VM은 적어도 2GB의 메모리 등이 필요합니다. . 그러나 Windows, Linux 및 Mac에서 VM 유형을 실행할 수있는 Windows (2014 년 11 월 기준)와 같은 OS에서는 호스트 OS에 대한 Docker 지원을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebfbe47546638c4d6b8bdeb4c1ec1c246b7d5294" translate="yes" xml:space="preserve">
          <source>Easy to backup and migrate</source>
          <target state="translated">간편한 백업 및 마이그레이션</target>
        </trans-unit>
        <trans-unit id="0c1056b52b083ad21229bce5ba26be5a9f188426" translate="yes" xml:space="preserve">
          <source>Easy to migrate</source>
          <target state="translated">손쉬운 마이그레이션</target>
        </trans-unit>
        <trans-unit id="eb1268b1c2d91c12e10a36edb55ad7aef75453d5" translate="yes" xml:space="preserve">
          <source>Easy to scale</source>
          <target state="translated">손쉬운 확장</target>
        </trans-unit>
        <trans-unit id="3a0cc42ee3658aa395a2138d4f579703ec830c67" translate="yes" xml:space="preserve">
          <source>Emulation</source>
          <target state="translated">Emulation</target>
        </trans-unit>
        <trans-unit id="3dd6632b998842cf74b5b1b92cd5f5820e9f7c7a" translate="yes" xml:space="preserve">
          <source>Emulation, also known as full virtualization runs the virtual machine OS kernel entirely in software. The hypervisor used in this type is known as Type 2 hypervisor. It is installed on the top of the host operating system which is responsible for translating guest OS kernel code to software instructions. The translation is done entirely in software and requires no hardware involvement. Emulation makes it possible to run any non-modified operating system that supports the environment being emulated.  The downside of this type of virtualization is an additional system resource overhead that leads to a decrease in performance compared to other types of virtualizations.</source>
          <target state="translated">전체 가상화라고도하는 에뮬레이션은 소프트웨어에서 가상 머신 OS 커널을 완전히 실행합니다. 이 유형에 사용 된 하이퍼 바이저를 유형 2 하이퍼 바이저라고합니다. 게스트 운영 체제 커널 코드를 소프트웨어 명령으로 변환하는 호스트 운영 체제의 맨 위에 설치됩니다. 번역은 전적으로 소프트웨어로 수행되며 하드웨어가 필요하지 않습니다. 에뮬레이션을 통해 에뮬레이션되는 환경을 지원하는 수정되지 않은 운영 체제를 실행할 수 있습니다. 이 유형의 가상화의 단점은 다른 유형의 가상화에 비해 성능이 저하되는 추가 시스템 리소스 오버 헤드입니다.</target>
        </trans-unit>
        <trans-unit id="ebd505d115bab776dbdc74d1e0b12be11fd82172" translate="yes" xml:space="preserve">
          <source>Every container thinks that it&amp;rsquo;s running on its own copy of the operating system. It&amp;rsquo;s got its own file system, own registry, etc. which is a kind of a lie. It&amp;rsquo;s actually being virtualized.</source>
          <target state="translated">모든 컨테이너는 자체 운영 체제 복사본에서 실행되고 있다고 생각합니다. 자체 파일 시스템, 자체 레지스트리 등이 있습니다. 일종의 거짓말입니다. 실제로 가상화되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="831cc80cb718c03f5246360107237ef746f0d7b0" translate="yes" xml:space="preserve">
          <source>Examples in this category include VMware Player, VirtualBox, QEMU, Bochs, Parallels, etc.</source>
          <target state="translated">이 범주의 예로는 VMware Player, VirtualBox, QEMU, Bochs, Parallels 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ccb86e59e4fe3bd2ef073e88fbef7553e61cfd6" translate="yes" xml:space="preserve">
          <source>Examples in this category include Xen, KVM, etc.</source>
          <target state="translated">이 범주의 예에는 Xen, KVM 등이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="06c824bd1974bf568c9573060edb42e84b34bdb2" translate="yes" xml:space="preserve">
          <source>Except for the kernel the patches and libraries are identical.</source>
          <target state="translated">커널을 제외하고 패치와 라이브러리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b0a3481e61f709c1e0d790c0b774bd27b9d58b69" translate="yes" xml:space="preserve">
          <source>Expensive</source>
          <target state="translated">Expensive</target>
        </trans-unit>
        <trans-unit id="7619f9abbfa1d6d7042c32f920ff5830700c00a0" translate="yes" xml:space="preserve">
          <source>First, docker images are usually smaller than VM images, makes it easy to build, copy, share.</source>
          <target state="translated">첫째, 도커 이미지는 일반적으로 VM 이미지보다 작으므로 쉽게 빌드, 복사, 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef8e6da45d2dd081d16f57b855fc793cd8acd72" translate="yes" xml:space="preserve">
          <source>Flexibility</source>
          <target state="translated">Flexibility</target>
        </trans-unit>
        <trans-unit id="f074c945bdbec9e8558ac4215dcfd8927703d79f" translate="yes" xml:space="preserve">
          <source>For container-based virtualization, no additional software is required, unlike other virtualizations.</source>
          <target state="translated">컨테이너 기반 가상화의 경우 다른 가상화와 달리 추가 소프트웨어가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cca4ac54f6253ba97d3664e73ad0e4adc922b5c9" translate="yes" xml:space="preserve">
          <source>For doing that, I downloaded configured Docker containers for zookeeper, kafka, Prometheus, Grafana and jmx-collector then mounted my own configuration for some of them using YAML files, or for others, I changed some files and configuration in the Docker container and I build a whole system for monitoring kafka using multi-container Dockers on a single machine with isolation and scalability and resiliency that this architecture can be easily moved into multiple servers.</source>
          <target state="translated">이를 위해 zookeeper, kafka, Prometheus, Grafana 및 jmx-collector에 대해 구성된 Docker 컨테이너를 다운로드 한 다음 YAML 파일을 사용하여 일부 구성 요소를 마운트하거나 Docker 컨테이너에서 일부 파일 및 구성을 변경했습니다. 이 아키텍처를 여러 서버로 쉽게 옮길 수있는 격리 및 확장 성 및 복원력을 갖춘 단일 시스템에서 다중 컨테이너 Docker를 사용하여 kafka를 모니터링하기위한 전체 시스템을 구축합니다.</target>
        </trans-unit>
        <trans-unit id="a16d59c76a3c563866745fba874d4ab0bc26bd0d" translate="yes" xml:space="preserve">
          <source>For example, if you develop a web server that runs on port 4000, when you deploy it to your &quot;testing&quot; environment, that port is already used by some other program, so it stops working. In containers there are layers; all the changes you have made to the OS would be saved in one or more layers and those layers would be part of image, so wherever the image goes the dependencies would be present as well.</source>
          <target state="translated">예를 들어, 포트 4000에서 실행되는 웹 서버를 개발하는 경우 &quot;테스트&quot;환경에 배치하면 해당 포트가 이미 다른 프로그램에서 사용되므로 작동이 중지됩니다. 컨테이너에는 레이어가 있습니다. OS에 대한 모든 변경 사항은 하나 이상의 레이어에 저장되며 해당 레이어는 이미지의 일부가되므로 이미지가있는 곳마다 종속성이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8fd88484152d1d51a4c2b9238da4fbff000d9c47" translate="yes" xml:space="preserve">
          <source>For example, you can create a Docker image and configure a DockerFile and tell that for example when it is running then wget 'this', apt-get 'that', run 'some shell script', setting environment variables and so on.</source>
          <target state="translated">예를 들어 Docker 이미지를 만들고 DockerFile을 구성하고 예를 들어 실행 중일 때 wthis 'this', apt-get 'that', 'some shell script'실행, 환경 변수 설정 등을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ccf43916b47b800017e7e72b2ae9d3454e3634" translate="yes" xml:space="preserve">
          <source>For me the fundamental difference between VMs and Docker is how you manage the promotion of your application.</source>
          <target state="translated">저에게 VM과 Docker의 근본적인 차이점은 애플리케이션 프로모션을 관리하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="776e7b08ef6cc416f71526ab137e5b888e2ab3f4" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;http://web.archive.org/web/20150326185901/http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part&quot;&gt;this set of blog posts&lt;/a&gt; which do a good job of explaining how LXC works.</source>
          <target state="translated">자세한 내용은 LXC 작동 방식을 잘 설명하는 &lt;a href=&quot;http://web.archive.org/web/20150326185901/http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part&quot;&gt;이 블로그 게시물&lt;/a&gt; 을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="207193724c4e247fd644cf605f559f47a466119b" translate="yes" xml:space="preserve">
          <source>From comments...</source>
          <target state="translated">댓글에서 ...</target>
        </trans-unit>
        <trans-unit id="b06a12c7f453ec1b3e1d2a287db5fb38b0d6cf5d" translate="yes" xml:space="preserve">
          <source>Good answers. Just to get an image representation of container vs VM, have a look at the one below.</source>
          <target state="translated">좋은 답변입니다. 컨테이너와 VM의 이미지 표현을 얻으려면 아래 이미지를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="8e3f53c59ab99fe6412b74f105c5c18faeaa1818" translate="yes" xml:space="preserve">
          <source>Good use of resources</source>
          <target state="translated">좋은 자원 사용</target>
        </trans-unit>
        <trans-unit id="08a92012d1091230dec3a68bf46755967d46a604" translate="yes" xml:space="preserve">
          <source>Here is a pic from docker/rightscale :</source>
          <target state="translated">다음은 docker / rightscale의 사진입니다.</target>
        </trans-unit>
        <trans-unit id="3fff53bba4a212150784b2d3bc45d5918d2667bb" translate="yes" xml:space="preserve">
          <source>How is Docker different from a virtual machine</source>
          <target state="translated">Docker와 가상 시스템의 차이점</target>
        </trans-unit>
        <trans-unit id="01e97b6e84b72f7278d2e92841cdf0e0b3dea0d1" translate="yes" xml:space="preserve">
          <source>Hyper-v is the native hypervisor in Windows. They are also trying to leverage Windows 10's capabilities to run Linux systems natively.</source>
          <target state="translated">Hyper-v는 Windows의 기본 하이퍼 바이저입니다. 또한 Linux 시스템을 기본적으로 실행하기 위해 Windows 10의 기능을 활용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a670e3e7b00b3a4ef5c8133d5ecd66b4bfeeef4d" translate="yes" xml:space="preserve">
          <source>I have used Docker in production environments and staging very much. When you get used to it you will find it very powerful for building a multi container and isolated environments.</source>
          <target state="translated">프로덕션 환경에서 Docker를 사용하고 준비했습니다. 익숙해지면 멀티 컨테이너 및 격리 된 환경을 구축하는 데 매우 강력합니다.</target>
        </trans-unit>
        <trans-unit id="efcbb2db7ed5cea3f886bf3b808eaf0e3defaa70" translate="yes" xml:space="preserve">
          <source>I keep rereading &lt;a href=&quot;https://docs.docker.com/&quot;&gt;the Docker documentation&lt;/a&gt; to try to understand the difference between Docker and a full VM. How does it manage to provide a full filesystem, isolated networking environment, etc. without being as heavy?</source>
          <target state="translated">Docker와 전체 VM의 차이점을 이해하기 위해 &lt;a href=&quot;https://docs.docker.com/&quot;&gt;Docker 설명서&lt;/a&gt; 를 계속 읽으 십시오 . 무겁지 않고 완전한 파일 시스템, 격리 된 네트워킹 환경 등을 제공하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="093768d5bf451d254a63bac21dc211f910523f56" translate="yes" xml:space="preserve">
          <source>I like Ken Cochrane's answer.</source>
          <target state="translated">나는 Ken Cochrane의 대답을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="4bb2f313e29c46ff50d3965c64f2fe9b6022da18" translate="yes" xml:space="preserve">
          <source>I remember the first days of working with Docker when I issued the wrong commands or removing my containers and all of data and configurations mistakenly.</source>
          <target state="translated">잘못된 명령을 실행하거나 컨테이너와 모든 데이터 및 구성을 실수로 제거했을 때 Docker로 작업 한 첫 날을 기억합니다.</target>
        </trans-unit>
        <trans-unit id="403c51801e9b7a0dc50d8fe7fa451ec8a190d37e" translate="yes" xml:space="preserve">
          <source>If all containers use Ubuntu as their base images, not every image has its own file system, but share the same underline ubuntu files, and only differs in their own application data.</source>
          <target state="translated">모든 컨테이너가 Ubuntu를 기본 이미지로 사용하는 경우 모든 이미지에 고유 한 파일 시스템이있는 것은 아니지만 동일한 밑줄 우분투 파일을 공유하며 자체 응용 프로그램 데이터 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c2cbe8ffc804cbfc335c751353c0f43e1aee5926" translate="yes" xml:space="preserve">
          <source>If containers are possible because of the features available in the Linux kernel, then the obvious question is how do non-Linux systems run containers. Both Docker for Mac and Windows use Linux VMs to run the containers. Docker Toolbox used to run containers in Virtual Box VMs. But, the latest Docker uses Hyper-V in Windows and Hypervisor.framework in Mac.</source>
          <target state="translated">Linux 커널에서 사용 가능한 기능으로 인해 컨테이너가 가능한 경우 Linux 이외의 시스템에서 컨테이너를 실행하는 방법에 대한 분명한 질문이 있습니다. Mac 및 Windows 용 Docker는 모두 Linux VM을 사용하여 컨테이너를 실행합니다. Docker Toolbox는 Virtual Box VM에서 컨테이너를 실행하는 데 사용됩니다. 그러나 최신 Docker는 Windows에서는 Hyper-V를 사용하고 Mac에서는 Hypervisor.framework를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bcd1a4739b8857179aa5e6b1af17202af30a8962" translate="yes" xml:space="preserve">
          <source>If you understand containers, you get what Docker is and how it's different from &lt;strong&gt;VM&lt;/strong&gt;s...</source>
          <target state="translated">컨테이너를 이해하면 Docker가 무엇인지, &lt;strong&gt;VM&lt;/strong&gt; 과 어떻게 다른지 알 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="9a0091353dc39035f55d81e29dc485c96d1a5e17" translate="yes" xml:space="preserve">
          <source>In Docker, the containers running share the host OS kernel, whereas in VMs they have their own OS files. The environment (the OS) in which you develop an application would be same when you deploy it to various serving environments, such as &quot;testing&quot; or &quot;production&quot;.</source>
          <target state="translated">Docker에서 실행되는 컨테이너는 호스트 OS 커널을 공유하는 반면 VM에서는 자체 OS 파일이 있습니다. 응용 프로그램을 개발하는 환경 (OS)은 &quot;테스트&quot;또는 &quot;제작&quot;과 같은 다양한 서비스 환경에 배포 할 때 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6deaafede88ba1c4b8741704f71788bd3ac121a1" translate="yes" xml:space="preserve">
          <source>In Virtualization, the resources are allocated in the beginning of set up and hence the resources are not fully utilized when the virtual machine is idle during many of the times. 
In Docker, the containers are not allocated with fixed amount of hardware resources and is free to use the resources depending on the requirements and hence it is highly scalable.</source>
          <target state="translated">가상화에서 리소스는 설정 시작시 할당되므로 여러 시간 동안 가상 머신이 유휴 상태 일 때 리소스가 완전히 활용되지 않습니다. Docker에서 컨테이너에는 고정 된 양의 하드웨어 리소스가 할당되지 않으며 요구 사항에 따라 리소스를 자유롭게 사용할 수 있으므로 확장 성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="a36afb4e82e762415de7cc7df8fe48984cdb88af" translate="yes" xml:space="preserve">
          <source>In its conceived form, it was considered a method of logically dividing mainframes to allow multiple applications to run simultaneously. However, the scenario drastically changed when companies and open source communities were able to provide a method of handling the privileged instructions in one way or another and allow for multiple operating systems to be run simultaneously on a single x86 based system.</source>
          <target state="translated">고안된 형태로, 여러 애플리케이션을 동시에 실행할 수 있도록 메인 프레임을 논리적으로 나누는 방법으로 간주되었습니다. 그러나 회사와 오픈 소스 커뮤니티가 권한있는 명령을 다른 방식으로 처리하는 방법을 제공하고 단일 x86 기반 시스템에서 여러 운영 체제를 동시에 실행할 수있게되면서 시나리오가 크게 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="95a26c3741ab3acfcb8e62da771360a922f4e4a5" translate="yes" xml:space="preserve">
          <source>In micro-services projects and architecture Docker is a very viable asset. You can achieve scalability, resiliency and elasticity with Docker, Docker swarm, Kubernetes and Docker Compose.</source>
          <target state="translated">마이크로 서비스 프로젝트 및 아키텍처에서 Docker는 매우 실행 가능한 자산입니다. Docker, Docker swarm, Kubernetes 및 Docker Compose를 사용하여 확장 성, 탄력성 및 탄력성을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd3d8676713c9b794181157ecb2b5681479e937a" translate="yes" xml:space="preserve">
          <source>In order to know how it is different from other virtualizations, let's go through virtualization and its types. Then, it would be easier to understand what's the difference there.</source>
          <target state="translated">다른 가상화와 어떻게 다른지 알기 위해 가상화와 유형을 살펴 보겠습니다. 그렇다면 차이점이 무엇인지 이해하는 것이 더 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="7444a60831088da7523f35412aa42209e5751c6f" translate="yes" xml:space="preserve">
          <source>In relation to:-</source>
          <target state="translated">다음과 관련하여 :-</target>
        </trans-unit>
        <trans-unit id="2c53360e73a433169fe66dad84215306aea76ab4" translate="yes" xml:space="preserve">
          <source>In the example shown below, the host machine has three VMs. In order to provide the applications in the VMs complete isolation, they each have their own copies of OS files, libraries and application code, along with a full in-memory instance of an OS. 
Whereas the figure below shows the same scenario with containers. Here, containers simply share the host operating system, including the kernel and libraries, so they don&amp;rsquo;t need to boot an OS, load libraries or pay a private memory cost for those files. The only incremental space they take is any memory and disk space necessary for the application to run in the container. While the application&amp;rsquo;s environment feels like a dedicated OS, the application deploys just like it would onto a dedicated host. The containerized application starts in seconds and many more instances of the application can fit onto the machine than in the VM case.</source>
          <target state="translated">아래에 표시된 예에서 호스트 시스템에는 3 개의 VM이 있습니다. VM에서 완벽한 격리를 제공하기 위해 각각 OS의 전체 메모리 인스턴스와 함께 자체 OS 파일, 라이브러리 및 응용 프로그램 코드 사본이 있습니다. 아래 그림은 컨테이너와 동일한 시나리오를 보여줍니다. 여기서 컨테이너는 커널과 라이브러리를 포함하여 호스트 운영 체제를 공유하기 때문에 OS를 부팅하거나 라이브러리를로드하거나 해당 파일의 개인 메모리 비용을 지불 할 필요가 없습니다. 이들이 차지하는 유일한 증분 공간은 응용 프로그램을 컨테이너에서 실행하는 데 필요한 메모리 및 디스크 공간입니다. 응용 프로그램 환경은 전용 OS처럼 느껴지지만 응용 프로그램은 전용 호스트에있는 것처럼 배포됩니다. 컨테이너화 된 응용 프로그램은 몇 초 안에 시작되며 VM의 경우보다 더 많은 응용 프로그램 인스턴스가 컴퓨터에 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a02c937cff75730610767b134b6093b42b4a323" translate="yes" xml:space="preserve">
          <source>In this case VM manager takes over the CPU ring 0 (or the &quot;root mode&quot; in newer CPUs) and intercepts all privileged calls made by guest OS to create illusion that guest OS has its own hardware. Fun fact: Before 1998 it was thought to be impossible to achieve this in x86 architecture because there was no way to do this kind of interception. The folks at VMWare &lt;a href=&quot;http://web.archive.org/web/20160324005530/https://www.vmware.com/files/pdf/VMware_paravirtualization.pdf&quot;&gt;were the first&lt;/a&gt; who had an idea to rewrite the executable bytes in memory for privileged calls of guest OS to achieve this.</source>
          <target state="translated">이 경우 VM 관리자는 CPU 링 0 (또는 최신 CPU의 &quot;루트 모드&quot;)을 인계 받아 게스트 OS가 수행 한 모든 권한있는 호출을 가로 채서 게스트 OS에 자체 하드웨어가 있다는 환상을 만듭니다. 재미있는 사실 : 1998 년 이전에는 이런 종류의 가로 채기를 수행 할 방법이 없었기 때문에 x86 아키텍처에서는이를 달성하는 것이 불가능하다고 생각되었습니다. VMWare의 사람들은이를 위해 게스트 OS의 특권 호출을 위해 실행 가능 바이트를 메모리에 다시 쓰는 아이디어를 가진 사람이 &lt;a href=&quot;http://web.archive.org/web/20160324005530/https://www.vmware.com/files/pdf/VMware_paravirtualization.pdf&quot;&gt;처음&lt;/a&gt; 이었습니다.</target>
        </trans-unit>
        <trans-unit id="cd2aef3c71aeb2c97a66235336032b37b431c611" translate="yes" xml:space="preserve">
          <source>In this context the VM is called as the Guest while the environment it runs on is called the host.</source>
          <target state="translated">이 컨텍스트에서 VM은 게스트라고하며 VM은 실행되는 환경을 호스트라고합니다.</target>
        </trans-unit>
        <trans-unit id="82a4c2503fc2e5f7a632dc3f96dfb783c40b9f38" translate="yes" xml:space="preserve">
          <source>Individual developer PC(s)</source>
          <target state="translated">개별 개발자 PC</target>
        </trans-unit>
        <trans-unit id="27fc6b21a62b9c0827a8225ea34de499da6cbcef" translate="yes" xml:space="preserve">
          <source>Individual tester PC(s)</source>
          <target state="translated">개별 테스터 PC</target>
        </trans-unit>
        <trans-unit id="b56d385feffaad558cd2b71a3f57768499156008" translate="yes" xml:space="preserve">
          <source>Interesting! I suppose I'm still confused by the notion of &quot;snapshot[ting] the OS&quot;. How does one do that without, well, making an image of the OS?</source>
          <target state="translated">흥미 롭습니다! 나는 여전히 &quot;OS 스냅 샷 [ting]&quot;이라는 개념에 혼란스러워하고 있다고 생각한다. OS의 이미지를 만들지 않고도 어떻게 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="6517c7a6e6193973c0f8ab38bf987e800ec76e5b" translate="yes" xml:space="preserve">
          <source>It is not uncommon for multiple applications to share a VM. This requires managing configuration and dependencies for all the applications.</source>
          <target state="translated">여러 응용 프로그램이 VM을 공유하는 것은 드문 일이 아닙니다. 이를 위해서는 모든 응용 프로그램의 구성 및 종속성 관리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="53435c6c21589588f560d23914d042b67451eac0" translate="yes" xml:space="preserve">
          <source>It might be helpful to understand how virtualization and containers work at low level. That will clear up lot of things.</source>
          <target state="translated">가상화 및 컨테이너가 낮은 수준에서 작동하는 방식을 이해하면 도움이 될 수 있습니다. 그것은 많은 것들을 정리할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5fddae4874740f164d9fcc188953498de0b99dc" translate="yes" xml:space="preserve">
          <source>It transforms how services are delivered. We want applications, but have to maintain VMs(which is a pain and has little to do with our applications). Docker makes you focus on applications and smooths everything.</source>
          <target state="translated">서비스 제공 방식을 변화시킵니다. 우리는 응용 프로그램을 원하지만 VM을 유지 관리해야합니다 (이는 고통스럽고 응용 프로그램과 거의 관련이 없음). Docker는 응용 프로그램에 집중하고 모든 것을 부드럽게합니다.</target>
        </trans-unit>
        <trans-unit id="7e704fdab84afa725450d8c5989d78446095b4fa" translate="yes" xml:space="preserve">
          <source>Lightweight</source>
          <target state="translated">Lightweight</target>
        </trans-unit>
        <trans-unit id="9c36a1882d9df03003965a7776f2968d11b22b1d" translate="yes" xml:space="preserve">
          <source>Linux Containers (LXC) are operating system-level capabilities that make it possible to run multiple isolated Linux containers, on one control host (the LXC host). Linux Containers serve as a lightweight alternative to VMs as they don&amp;rsquo;t require the hypervisors viz. Virtualbox, KVM, Xen, etc.</source>
          <target state="translated">Linux Containers (LXC)는 하나의 제어 호스트 (LXC 호스트)에서 여러 개의 격리 된 Linux 컨테이너를 실행할 수있는 운영 체제 수준 기능입니다. Linux Containers는 하이퍼 바이저 viz가 필요하지 않으므로 VM에 대한 간단한 대안으로 사용됩니다. Virtualbox, KVM, Xen 등</target>
        </trans-unit>
        <trans-unit id="5a7b9cdeda076b8b5cdbf26437184f641208efe6" translate="yes" xml:space="preserve">
          <source>Live staging</source>
          <target state="translated">라이브 스테이징</target>
        </trans-unit>
        <trans-unit id="093da4223ce1c3507aba3a3ccde4d3735447aaff" translate="yes" xml:space="preserve">
          <source>Load / performance testing</source>
          <target state="translated">부하 / 성능 테스트</target>
        </trans-unit>
        <trans-unit id="3105c333e001f39668ce814586d31eef54a76c34" translate="yes" xml:space="preserve">
          <source>Low overhead</source>
          <target state="translated">낮은 오버 헤드</target>
        </trans-unit>
        <trans-unit id="af2e2a00277338f6ad4722a9a32d84ecb974e9e9" translate="yes" xml:space="preserve">
          <source>Many production environments will have cloud-based servers dynamically (or 'elastically') created and destroyed depending on traffic levels</source>
          <target state="translated">많은 프로덕션 환경에는 트래픽 수준에 따라 클라우드 기반 서버가 동적으로 (또는 '탄력적으로') 생성 및 파괴됩니다</target>
        </trans-unit>
        <trans-unit id="13266882dcd8e5ddad5d2a8b2d17cb63fe5b62a8" translate="yes" xml:space="preserve">
          <source>Mirror production and development environment</source>
          <target state="translated">미러 생산 및 개발 환경</target>
        </trans-unit>
        <trans-unit id="9c4e706d04054700b966e6ff5969974a660024f7" translate="yes" xml:space="preserve">
          <source>Most of the answers here talk about virtual machines. I'm going to give you a one-liner response to this question that has helped me the most over the last couple years of using Docker. It's this:</source>
          <target state="translated">여기에있는 대부분의 답변은 가상 머신에 대한 것입니다. Docker를 사용하는 지난 몇 년 동안 가장 도움이 된이 질문에 대한 한 줄짜리 응답을 제공 할 것입니다. 이것입니다 :</target>
        </trans-unit>
        <trans-unit id="e30e5ce298639ebdf7ed418d577fdba1453de3e9" translate="yes" xml:space="preserve">
          <source>Most software is deployed to many environments, typically a minimum of three of the following:</source>
          <target state="translated">대부분의 소프트웨어는 여러 환경에 배포되며 일반적으로 다음 중 3 가지 이상입니다.</target>
        </trans-unit>
        <trans-unit id="b938883ea89a8af2b42e1f7fa1fcb02625173674" translate="yes" xml:space="preserve">
          <source>Namespaces can be used in many different ways, but the most common approach is to create an isolated container that has no visibility or access to objects outside the container. Processes running inside the container appear to be running on a normal Linux system although they are sharing the underlying kernel with processes located in other namespaces, same for other kinds of objects. For instance, when using namespaces, the root user inside the container is not treated as root outside the container, adding additional security.</source>
          <target state="translated">네임 스페이스는 다양한 방법으로 사용될 수 있지만 가장 일반적인 방법은 컨테이너 외부의 객체에 대한 가시성이나 액세스 권한이없는 격리 된 컨테이너를 만드는 것입니다. 컨테이너 내부에서 실행되는 프로세스는 다른 종류의 객체와 마찬가지로 다른 네임 스페이스에있는 프로세스와 기본 커널을 공유하지만 일반 Linux 시스템에서 실행중인 것으로 보입니다. 예를 들어 네임 스페이스를 사용할 때 컨테이너 내부의 루트 사용자는 컨테이너 외부의 루트로 처리되지 않으므로 보안이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c18158689f952c79b7e5a35cdb844ea37ad2a0c" translate="yes" xml:space="preserve">
          <source>Networking and security issues.</source>
          <target state="translated">네트워킹 및 보안 문제.</target>
        </trans-unit>
        <trans-unit id="09a3a2ea2407302c3e099a5cfd61ce10c643c0b2" translate="yes" xml:space="preserve">
          <source>Networking in Docker is achieved by using an ethernet bridge (called &lt;code&gt;docker0&lt;/code&gt; on the host), and virtual interfaces for every container on the host. It creates a virtual subnet in &lt;code&gt;docker0&lt;/code&gt; for your containers to communicate &quot;between&quot; one another. There are many options for networking here, including creating custom subnets for your containers, and the ability to &quot;share&quot; your host's networking stack for your container to access directly.</source>
          <target state="translated">Docker의 네트워킹은 이더넷 브리지 (호스트의 &lt;code&gt;docker0&lt;/code&gt; 이라고 함)와 호스트의 모든 컨테이너에 대한 가상 인터페이스를 사용하여 수행됩니다. 컨테이너가 서로 &quot;통신&quot;할 수 있도록 &lt;code&gt;docker0&lt;/code&gt; 에 가상 서브넷을 만듭니다. 컨테이너에 대한 사용자 정의 서브넷 생성 및 컨테이너가 직접 액세스 할 수 있도록 호스트의 네트워킹 스택을 &quot;공유&quot;하는 기능을 포함하여 네트워킹에 대한 많은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0a854b60507a34251037996f11a19fa6b85b4fc" translate="yes" xml:space="preserve">
          <source>Note: I'm simplifying a bit in describing below. See references for more information.</source>
          <target state="translated">참고 : 아래 설명에서 약간 단순화하고 있습니다. 자세한 내용은 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e227acd21027a7bfb5a25200ef887511d8c3044f" translate="yes" xml:space="preserve">
          <source>Note: Learning Docker in the first place seems complex and hard, but when you get used to it then you can not work without it.</source>
          <target state="translated">참고 : 처음에는 학습 독 커가 복잡하고 어려워 보이지만 익숙해지면 학습 독 퍼가 없으면 일할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b35f91a80d652f56b4de5cd1f0c19e887566e0f" translate="yes" xml:space="preserve">
          <source>Now unless you were drugged by Alan (Zach Galifianakis- from the Hangover series) and have been in Vegas for the last year, you will be pretty aware about the tremendous spurt of interest for Linux containers technology, and if I will be specific one container project which has created a buzz around the world in last few months is &amp;ndash; Docker leading to some echoing opinions that cloud computing environments should abandon virtual machines (VMs) and replace them with containers due to their lower overhead and potentially better performance.</source>
          <target state="translated">Alan (행 아웃 시리즈의 Zach Galifianakis-)에 의해 마약을 받고 작년에 라스베가스에 가본 적이 없다면 Linux 컨테이너 기술에 대한 엄청난 관심이 집중 될 것입니다. 지난 몇 달 동안 전 세계에 붐을 일으킨 프로젝트는 다음과 같습니다. Docker는 클라우드 컴퓨팅 환경이 가상 머신 (VM)을 버리고 더 낮은 오버 헤드와 잠재적으로 더 나은 성능으로 인해 컨테이너로 대체해야한다는 반향을 불러 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="1cc4dd6084579a024d65281292fa705d78118079" translate="yes" xml:space="preserve">
          <source>Now, let me describe how Docker for Mac runs containers in detail.</source>
          <target state="translated">이제 Docker for Mac이 어떻게 컨테이너를 실행하는지 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d95736c0ea29fafbe8447df33be6ba007df4db2e" translate="yes" xml:space="preserve">
          <source>Now, let me explain a bit more about what that means. Virtual machines are their own beast. I feel like explaining what &lt;em&gt;Docker&lt;/em&gt; is will help you understand this more than explaining what a virtual machine is. Especially because there are many fine answers here telling you exactly what someone means when they say &quot;virtual machine&quot;. So...</source>
          <target state="translated">이제 그 의미에 대해 좀 더 설명하겠습니다. 가상 머신은 자신의 짐승입니다. &lt;em&gt;Docker&lt;/em&gt; 가 무엇인지 설명하면 가상 머신이 무엇인지 설명하는 것보다 이것을 이해하는 데 도움이됩니다. 특히 여기에 누군가가 &quot;가상 머신&quot;이라고 할 때의 의미를 정확하게 알려주는 많은 훌륭한 답변이 있기 때문입니다. 그래서...</target>
        </trans-unit>
        <trans-unit id="f9c01df341a52960ca7d89828bb10132f64f1861" translate="yes" xml:space="preserve">
          <source>Now, we can even check the Kernel version of this VM:</source>
          <target state="translated">이제이 VM의 커널 버전을 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da8e0058a0738225418564045636c65cb055e65e" translate="yes" xml:space="preserve">
          <source>Often these VM's will have different patches and libraries.</source>
          <target state="translated">종종 이러한 VM에는 다른 패치와 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e71ee38b37eca2eb89212fc31c65b9278bf446b5" translate="yes" xml:space="preserve">
          <source>One important difference is that &lt;strong&gt;VMs use a separate kernel to run the OS&lt;/strong&gt;. That's the reason it is heavy and takes time to boot, consuming more system resources.</source>
          <target state="translated">한 가지 중요한 차이점은 &lt;strong&gt;VM이 별도의 커널을 사용하여 OS를 실행한다는 것&lt;/strong&gt; 입니다. 이것이 무겁고 부팅하는 데 시간이 걸리고 더 많은 시스템 리소스를 소비하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="7a8dd4987551f233b360a5fc92cb1bb1746b7917" translate="yes" xml:space="preserve">
          <source>Paravirtualization</source>
          <target state="translated">Paravirtualization</target>
        </trans-unit>
        <trans-unit id="adce3fd9cada4bbcbaf7cc96e519bf01a1c74244" translate="yes" xml:space="preserve">
          <source>Paravirtualization, also known as Type 1 hypervisor, runs directly on the hardware, or &amp;ldquo;bare-metal&amp;rdquo;, and provides virtualization services directly to the virtual machines running on it. It helps the operating system, the virtualized hardware, and the real hardware to collaborate to achieve optimal performance. These hypervisors typically have a rather small footprint and do not, themselves, require extensive resources.</source>
          <target state="translated">유형 1 하이퍼 바이저라고도하는 반 가상화는 하드웨어 또는 &quot;베어 메탈 (bare-metal)&quot;에서 직접 실행되며 가상화 서비스를 실행하는 가상 머신에 직접 가상화 서비스를 제공합니다. 운영 체제, 가상화 된 하드웨어 및 실제 하드웨어가 협업하여 최적의 성능을 달성하도록 도와줍니다. 이러한 하이퍼 바이저는 일반적으로 설치 공간이 다소 작으며 자체적으로 광범위한 리소스가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df70fc7991d3f1476ee9b62f9991c5a0f2c589e0" translate="yes" xml:space="preserve">
          <source>Production</source>
          <target state="translated">Production</target>
        </trans-unit>
        <trans-unit id="5967e86a2955722a7f8ed81334c26c41f18d6224" translate="yes" xml:space="preserve">
          <source>QA environment</source>
          <target state="translated">품질 관리 환경</target>
        </trans-unit>
        <trans-unit id="0c9cc3ad60910561ffeb418bc8d54f5af0b9a011" translate="yes" xml:space="preserve">
          <source>Resource allocation is problematic</source>
          <target state="translated">리소스 할당에 문제가 있습니다</target>
        </trans-unit>
        <trans-unit id="77c420eb32b9c8491f76038181f5b86a3e24e538" translate="yes" xml:space="preserve">
          <source>Resource effective</source>
          <target state="translated">효과적인 자원</target>
        </trans-unit>
        <trans-unit id="608c40f49e84a55f3c9bf3ec53b700f446d8db26" translate="yes" xml:space="preserve">
          <source>Resource heavy apps</source>
          <target state="translated">리소스가 많은 앱</target>
        </trans-unit>
        <trans-unit id="116306d52eca48b72c61412f9a8a3bf366f2ef97" translate="yes" xml:space="preserve">
          <source>Resource management in containers is achieved through cgroups. Cgroups does not allow containers to consume more resources than allocated to them. However, as of now, all resources of host machine are visible in virtual machines, but can't be used. This can be realized by running &lt;code&gt;top&lt;/code&gt; or &lt;code&gt;htop&lt;/code&gt; on containers and host machine at the same time. The output across all environments will look similar.</source>
          <target state="translated">컨테이너의 리소스 관리는 cgroup을 통해 수행됩니다. Cgroup은 컨테이너가 할당 된 것보다 더 많은 리소스를 소비하도록 허용하지 않습니다. 그러나 현재 호스트 시스템의 모든 리소스는 가상 시스템에서 볼 수 있지만 사용할 수는 없습니다. 컨테이너와 호스트 시스템에서 &lt;code&gt;top&lt;/code&gt; 또는 &lt;code&gt;htop&lt;/code&gt; 을 동시에 실행하여이를 실현할 수 있습니다. 모든 환경에서 출력이 비슷하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="6b18033d6dea5b85354c3d03959788e129270bf4" translate="yes" xml:space="preserve">
          <source>Same Architecture</source>
          <target state="translated">동일한 아키텍처</target>
        </trans-unit>
        <trans-unit id="46a5925b85bd943c275f26f441853ee795bed5f3" translate="yes" xml:space="preserve">
          <source>Second, Docker containers can start in several milliseconds, while VM starts in seconds.</source>
          <target state="translated">둘째, Docker 컨테이너는 몇 밀리 초 안에 시작할 수 있지만 VM은 몇 초 안에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="e4ebdf5ee0ef67069c239e4fb3c830a512c382fb" translate="yes" xml:space="preserve">
          <source>Several management tools are available for Linux containers, including LXC, LXD, systemd-nspawn, lmctfy, Warden, Linux-VServer, OpenVZ, Docker, etc.</source>
          <target state="translated">LXC, LXD, systemd-nspawn, lmctfy, Warden, Linux-VServer, OpenVZ, Docker 등을 포함하여 Linux 컨테이너에 여러 관리 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="570ab3452aa5a143cf20e06ea321480b66db25c3" translate="yes" xml:space="preserve">
          <source>Shared developer environment</source>
          <target state="translated">공유 개발자 환경</target>
        </trans-unit>
        <trans-unit id="61bedc66f5a3328063134c8ea3e6e152aaef9029" translate="yes" xml:space="preserve">
          <source>Shared test environment</source>
          <target state="translated">공유 테스트 환경</target>
        </trans-unit>
        <trans-unit id="7354636285d06d12dea48164a79d3d742fc7c195" translate="yes" xml:space="preserve">
          <source>Since container-based virtualization adds little or no overhead to the host machine, container-based virtualization has near-native performance</source>
          <target state="translated">컨테이너 기반 가상화는 호스트 시스템에 오버 헤드를 거의 또는 전혀 추가하지 않기 때문에 컨테이너 기반 가상화는 거의 기본 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b693b9c5091d8989c71e9ec8d579006be287551" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;Docker&lt;/strong&gt; is container based, meaning you have images and containers which can be run on your current machine. It's not including the operating system like &lt;strong&gt;VM&lt;/strong&gt;s, but like a pack of different working packs like Java, Tomcat, etc.</source>
          <target state="translated">따라서 &lt;strong&gt;Docker&lt;/strong&gt; 는 컨테이너 기반이므로 현재 컴퓨터에서 실행할 수있는 이미지와 컨테이너가 있습니다. &lt;strong&gt;VM&lt;/strong&gt; 과 같은 운영 체제는 포함하지 않지만 Java, Tomcat 등과 같은 다른 작업 팩 팩과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f629b2b816b977719f8c2fb6bff1b98fcde405a" translate="yes" xml:space="preserve">
          <source>So as you see in the image below, each container has a separate pack and running on a single machine share that machine's operating system... They are secure and easy to ship...</source>
          <target state="translated">아래 이미지에서 볼 수 있듯이 각 컨테이너에는 별도의 팩이 있으며 시스템 운영 체제와 동일한 단일 시스템 공유에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="227609777cb955b8caea44cd8f88d923f1796181" translate="yes" xml:space="preserve">
          <source>So at the most fundamental level with VMs you promote the application and its dependencies as discrete components whereas with Docker you promote everything in one hit.</source>
          <target state="translated">따라서 VM을 사용하는 가장 기본적인 수준에서는 응용 프로그램 및 해당 종속성을 개별 구성 요소로 홍보하는 반면 Docker를 사용하면 모든 것을 한 번에 홍보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff915c53a18d5d8d6016816967896435630356c6" translate="yes" xml:space="preserve">
          <source>So the best approach is the cloud infrastructure providers should advocate an appropriate use of the VMs and LXC, as they are each suited to handle specific workloads and scenarios.</source>
          <target state="translated">따라서 가장 좋은 방법은 클라우드 인프라 스트럭처 제공 업체가 각각 특정 워크로드 및 시나리오를 처리하기에 적합한 VM 및 LXC의 적절한 사용을 옹호해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="08008913ec3ffaa51bf434648223231d2fc4660c" translate="yes" xml:space="preserve">
          <source>So there is a known pattern to avoid this, the so called &lt;strong&gt;&lt;a href=&quot;http://martinfowler.com/bliki/ImmutableServer.html&quot;&gt;immutable server&lt;/a&gt;&lt;/strong&gt;. But the immutable server pattern was not loved. Mostly because of the limitations of VMs that were used before Docker. Dealing with several gigabytes big images, moving those big images around, just to change some fields in the application, was very very laborious. Understandable...</source>
          <target state="translated">이를 피하기 위해 알려진 &lt;strong&gt;&lt;a href=&quot;http://martinfowler.com/bliki/ImmutableServer.html&quot;&gt;불변의 서버&lt;/a&gt;&lt;/strong&gt; 패턴이 있습니다. 그러나 불변의 서버 패턴은 사랑받지 못했습니다. 대부분 Docker 이전에 사용 된 VM의 한계 때문입니다. 응용 프로그램에서 일부 필드를 변경하기 위해 몇 기가 바이트의 큰 이미지를 다루고 큰 이미지를 옮기는 것은 매우 힘들었습니다. 이해할 수 있는...</target>
        </trans-unit>
        <trans-unit id="5c86260516f20093dca5e32f9125464a1baa7668" translate="yes" xml:space="preserve">
          <source>So think of your question more like this &lt;em&gt;&quot;Given the extreme difficulty of keeping all environments consistent, is it easier to deploying software to a docker image, even when taking the learning curve into account ?&quot;&lt;/em&gt;. I think you'll find the answer will invariably be &quot;yes&quot; - but there's only one way to find out, post this new question on Stack Overflow.</source>
          <target state="translated">따라서 &lt;em&gt;&quot;모든 환경의 일관성을 유지하기가 매우 어려워지고 학습 곡선을 고려할 때도 도커 이미지에 소프트웨어를 쉽게 배포 할 수 있습니까?&quot;&lt;/em&gt; 와 같은 질문을 생각해보십시오. . 나는 당신이 대답이 항상 &quot;예&quot;라고 생각할 것이라고 생각합니다. 그러나 알아낼 수있는 유일한 방법은 스택 오버플로에 새로운 질문을 게시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9326b586a7a12df9aff5d242d06b41b390d95f84" translate="yes" xml:space="preserve">
          <source>So, let's say you have a 1&amp;nbsp;GB container image; if you wanted to use a full VM, you would need to have 1&amp;nbsp;GB x number of VMs you want. With Docker and AuFS you can share the bulk of the 1&amp;nbsp;GB between all the containers and if you have 1000 containers you still might only have a little over 1&amp;nbsp;GB of space for the containers OS (assuming they are all running the same OS image).</source>
          <target state="translated">따라서 1GB 컨테이너 이미지가 있다고 가정하겠습니다. 전체 VM을 사용하려면 원하는 1GB x 개수의 VM이 있어야합니다. Docker와 AuFS를 사용하면 모든 컨테이너간에 1GB의 대량을 공유 할 수 있으며 컨테이너가 1000 개인 경우 컨테이너 OS에 대해 1GB 이상의 공간이 남아있을 수 있습니다 (모두 동일한 OS 이미지를 실행한다고 가정) .</target>
        </trans-unit>
        <trans-unit id="c4b2519a746129c9e47ca0cef9cadb6c9f7e5df6" translate="yes" xml:space="preserve">
          <source>So, what's a container?</source>
          <target state="translated">컨테이너 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7845675b0fb1d13fc83e85f884c455a9662b5aca" translate="yes" xml:space="preserve">
          <source>Some environments will consist of a fixed number of multiple machines in a load balanced configuration</source>
          <target state="translated">일부 환경은로드 밸런싱 구성에서 고정 된 수의 여러 시스템으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="7f45e2789d413f8919ac75cdce2d0fbf3782d453" translate="yes" xml:space="preserve">
          <source>Source:  Kubernetes in Action.</source>
          <target state="translated">출처 : 쿠 버네 티스의 행동.</target>
        </trans-unit>
        <trans-unit id="17a6edd967825b56170eea6956f4662a04ce71a3" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&quot;&gt;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&quot;&gt;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbcc415ac4b86e9e443eaba129d222639a5d0758" translate="yes" xml:space="preserve">
          <source>The Linux Control Groups (cgroups) subsystem, the next major component to enable container-based virtualization, is used to group processes and manage their aggregate resource consumption. It is commonly used to limit the memory and CPU consumption of containers.  Since a containerized Linux system has only one kernel and the kernel has full visibility into the containers, there is only one level of resource allocation and scheduling.</source>
          <target state="translated">컨테이너 기반 가상화를 가능하게하는 다음 주요 구성 요소 인 Linux 제어 그룹 (cgroup) 서브 시스템은 프로세스를 그룹화하고 총 자원 소비를 관리하는 데 사용됩니다. 일반적으로 컨테이너의 메모리 및 CPU 소비를 제한하는 데 사용됩니다. 컨테이너화 된 Linux 시스템에는 커널이 하나만 있고 커널은 컨테이너에 대한 완전한 가시성을 갖기 때문에 한 수준의 리소스 할당 및 스케줄링이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce96b44823b14e37c5df5e5f90416de0de743cb" translate="yes" xml:space="preserve">
          <source>The Linux VM that Docker runs in Mac is read-only. However, you can bash into it by running:</source>
          <target state="translated">Docker가 Mac에서 실행하는 Linux VM은 읽기 전용입니다. 그러나 다음을 실행하여 bash를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e43599638071b0ea790ce9862f106845b607e30" translate="yes" xml:space="preserve">
          <source>The concept of a container is made possible by the namespaces feature added to Linux kernel version 2.6.24. The container adds its ID to every process and adding new access control checks to every system call. It is accessed by the &lt;em&gt;clone()&lt;/em&gt; system call that allows creating separate instances of previously-global namespaces.</source>
          <target state="translated">컨테이너 개념은 Linux 커널 버전 2.6.24에 추가 된 네임 스페이스 기능으로 가능합니다. 컨테이너는 모든 프로세스에 ID를 추가하고 모든 시스템 호출에 새로운 액세스 제어 검사를 추가합니다. 이전의 전역 네임 스페이스의 개별 인스턴스를 만들 수있는 &lt;em&gt;clone ()&lt;/em&gt; 시스템 호출로 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="9f78c499ac4ec737f9afafb8130b0e54fbeb1e6b" translate="yes" xml:space="preserve">
          <source>The hypervisor handles creating the virtual environment on which the guest virtual machines operate. It supervises the guest systems and makes sure that resources are allocated to the guests as necessary. The hypervisor sits in between the physical machine and virtual machines and provides virtualization services to the virtual machines. To realize it, it intercepts the guest operating system operations on the virtual machines and emulates the operation on the host machine's operating system.</source>
          <target state="translated">하이퍼 바이저는 게스트 가상 머신이 작동하는 가상 환경 작성을 처리합니다. 게스트 시스템을 감독하고 필요에 따라 리소스가 게스트에 할당되도록합니다. 하이퍼 바이저는 실제 머신과 가상 머신 사이에 있으며 가상 머신에 가상화 서비스를 제공합니다. 이를 실현하기 위해 가상 머신에서 게스트 운영 체제 조작을 인터셉트하고 호스트 머신 운영 체제에서 조작을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="5db2da245693c67f36d9159ddb40dedcbe69437d" translate="yes" xml:space="preserve">
          <source>The limitations of containers vs VM should be obvious now: You can't run completely different OS in containers like in VMs. However you &lt;em&gt;can&lt;/em&gt; run different distros of Linux because they do share the same kernel. The isolation level is not as strong as in VM. In fact, there was a way for &quot;guest&quot; container to take over host in early implementations. Also you can see that when you load new container, the entire new copy of OS doesn't start like it does in VM. All containers &lt;a href=&quot;https://stackoverflow.com/questions/25444099/why-docker-has-ability-to-run-different-linux-distribution&quot;&gt;share same kernel&lt;/a&gt;. This is why containers are light weight. Also unlike VM, you don't have to pre-allocate significant chunk of memory to containers because we are not running new copy of OS. This enables to run thousands of containers on one OS while sandboxing them which might not be possible to do if we were running separate copy of OS in its own VM.</source>
          <target state="translated">컨테이너와 VM의 한계는 이제 분명해집니다. VM과 같은 컨테이너에서 완전히 다른 OS를 실행할 수는 없습니다. 그러나 동일한 커널을 공유하기 때문에 Linux의 다른 배포판을 실행할 수 &lt;em&gt;있습니다&lt;/em&gt; . 격리 수준은 VM만큼 강력하지 않습니다. 실제로 &quot;게스트&quot;컨테이너가 초기 구현에서 호스트를 인수 할 수있는 방법이있었습니다. 또한 새 컨테이너를로드 할 때 VM 에서처럼 새 OS의 전체 사본이 시작되지 않음을 알 수 있습니다. 모든 컨테이너 &lt;a href=&quot;https://stackoverflow.com/questions/25444099/why-docker-has-ability-to-run-different-linux-distribution&quot;&gt;는 동일한 커널을 공유합니다&lt;/a&gt; . 이것이 용기의 무게가 가벼운 이유입니다. 또한 VM과 달리 새로운 OS 사본을 실행하지 않기 때문에 컨테이너에 상당한 양의 메모리를 사전 할당 할 필요가 없습니다. 이를 통해 하나의 OS에서 수천 개의 컨테이너를 샌드 박스 처리하는 동안 자체 VM에서 별도의 OS 사본을 실행하는 경우 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d20ba5621c8e203d326e322bfc921c09b73e08c" translate="yes" xml:space="preserve">
          <source>The net effect is that virtualization allows you to run two completely different OS on same hardware. Each guest OS goes through all the process of bootstrapping, loading kernel etc. You can have very tight security, for example, guest OS can't get full access to host OS or other guests and mess things up.</source>
          <target state="translated">결과적으로 가상화를 통해 동일한 하드웨어에서 완전히 다른 두 개의 OS를 실행할 수 있습니다. 각 게스트 OS는 부트 스트랩, 커널로드 등의 모든 프로세스를 거칩니다. 예를 들어 게스트 OS는 호스트 OS 또는 다른 게스트에 대한 전체 액세스 권한을 얻지 못하고 엉망이되는 등 매우 엄격한 보안을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f1a43bc5e4e52d6c576f48ac9f9fc0fe34ba83" translate="yes" xml:space="preserve">
          <source>The rapid development of virtualization technologies, primarily in cloud, has driven the use of virtualization further by allowing multiple virtual servers to be created on a single physical server with the help of hypervisors, such as Xen, VMware Player, KVM, etc., and incorporation of hardware support in commodity processors, such as Intel VT and AMD-V.</source>
          <target state="translated">주로 클라우드에서 가상화 기술의 빠른 개발로 인해 Xen, VMware Player, KVM 등과 같은 하이퍼 바이저의 도움으로 단일 물리적 서버에서 여러 가상 서버를 생성 할 수있어 가상화 사용이 더욱 확대되었습니다. Intel VT 및 AMD-V와 같은 상용 프로세서에 하드웨어 지원 통합</target>
        </trans-unit>
        <trans-unit id="e3ca9c66efd7b9b6e24c69bfb9517fc0ceb4f39e" translate="yes" xml:space="preserve">
          <source>The virtualization method can be categorized based on how it mimics hardware to a guest operating system and emulates a guest operating environment. Primarily, there are three types of virtualization:</source>
          <target state="translated">가상화 방법은 게스트 운영 체제에서 하드웨어를 모방하고 게스트 운영 환경을 에뮬레이션하는 방법에 따라 분류 할 수 있습니다. 기본적으로 가상화에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17d15b32708f824d9d732b4782c422545cf7355f" translate="yes" xml:space="preserve">
          <source>There are a lot of nice technical answers here that clearly discuss the differences between VMs and containers as well as the origins of Docker.</source>
          <target state="translated">여기에는 Docker의 기원뿐만 아니라 VM과 컨테이너의 차이점을 명확하게 설명하는 훌륭한 기술 답변이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f210a60c1f7d3832db36975249cfff8562fb7e57" translate="yes" xml:space="preserve">
          <source>There are also the following factors to consider:</source>
          <target state="translated">고려해야 할 다음과 같은 요소도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2770cedf26cf0e5354ae03381bebad859035e4c" translate="yes" xml:space="preserve">
          <source>There are many answers which explain more detailed on the differences, but here is my very brief explanation.</source>
          <target state="translated">차이점에 대해 더 자세히 설명하는 많은 답변이 있지만 여기에 간단한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c9370d40a8245a0298684bdaa2bd8a89c0e765" translate="yes" xml:space="preserve">
          <source>There are pros and cons for each type of virtualized system. If you want full isolation with guaranteed resources, a full VM is the way to go. If you just want to isolate processes from each other and want to run a ton of them on a reasonably sized host, then Docker/LXC/runC seems to be the way to go.</source>
          <target state="translated">각 가상화 시스템 유형마다 장단점이 있습니다. 보장 된 리소스로 완벽한 격리를 원한다면 완전한 VM이 필요합니다. 프로세스를 서로 분리하고 합리적인 크기의 호스트에서 수많은 프로세스를 실행하려면 Docker / LXC / runC가 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="195131b2f88fc1d6c353a7dfa429c08668a79774" translate="yes" xml:space="preserve">
          <source>There are some limitations to hypervisor.framework. Because of that Docker doesn't expose &lt;code&gt;docker0&lt;/code&gt; network interface in Mac. So, you can't access containers from the host. As of now, &lt;code&gt;docker0&lt;/code&gt; is only available inside the VM.</source>
          <target state="translated">hypervisor.framework에는 몇 가지 제한 사항이 있습니다. Docker는 Mac에서 &lt;code&gt;docker0&lt;/code&gt; 네트워크 인터페이스를 노출시키지 않습니다. 따라서 호스트에서 컨테이너에 액세스 할 수 없습니다. 현재 &lt;code&gt;docker0&lt;/code&gt; 은 VM 내부에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5a00b08e8dc5b45bb77295463740b58d4846f5" translate="yes" xml:space="preserve">
          <source>There are three different setups that providing a stack to run an application on (This will help us to recognize what a container is and what makes it so much powerful than other solutions):</source>
          <target state="translated">응용 프로그램을 실행할 스택을 제공하는 세 가지 설정이 있습니다 (컨테이너가 무엇인지, 컨테이너가 다른 솔루션보다 훨씬 강력하다는 것을 인식하는 데 도움이 됨).</target>
        </trans-unit>
        <trans-unit id="57d7d07e5e5a197279c393db8c8a7bf936c4f254" translate="yes" xml:space="preserve">
          <source>They both are very different. Docker is lightweight and uses LXC/libcontainer (which relies on kernel namespacing and cgroups) and does not have machine/hardware emulation such as hypervisor, KVM. Xen which are heavy.</source>
          <target state="translated">둘 다 매우 다릅니다. Docker는 가볍고 LXC / libcontainer (커널 네임 스페이스 및 cgroup에 의존)를 사용하며 하이퍼 바이저, KVM과 같은 시스템 / 하드웨어 에뮬레이션이 없습니다. 무거운 젠.</target>
        </trans-unit>
        <trans-unit id="e7721054f84b71ff4a04f7fe87da45240450c562" translate="yes" xml:space="preserve">
          <source>Think about application deployment. If we want to deploy a new software(service) or upgrade one, it is better to change the config files and processes instead of creating a new VM. Because Creating a VM with updated service, testing it(share between Dev &amp;amp; QA), deploying to production takes hours, even days. If anything goes wrong, you got to start again, wasting even more time. So, use configuration management tool(puppet, saltstack, chef etc.) to install new software, download new files is preferred.</source>
          <target state="translated">응용 프로그램 배포에 대해 생각해보십시오. 새 소프트웨어 (서비스)를 배포하거나 업그레이드하려는 경우 새 VM을 만드는 대신 구성 파일과 프로세스를 변경하는 것이 좋습니다. 업데이트 된 서비스로 VM을 생성하므로 테스트 (데브와 QA 간 공유)로 프로덕션 환경에 배포하는 데 몇 시간, 심지어 며칠이 걸립니다. 문제가 발생하면 다시 시작하여 더 많은 시간을 낭비해야합니다. 따라서 구성 관리 도구 (인형, saltstack, chef 등)를 사용하여 새 소프트웨어를 설치하고 새 파일을 다운로드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="04b9cd989db4ab4d1dc8d3dcfd400f18f4b8c3ec" translate="yes" xml:space="preserve">
          <source>This all means that creating consistent environments in the first place is hard enough just because of sheer volume (even in a green field scenario), but &lt;strong&gt;keeping them consistent is all but impossible&lt;/strong&gt; given the high number of servers, addition of new servers (dynamically or manually), automatic updates from o/s vendors, anti-virus vendors, browser vendors and the like, manual software installs or configuration changes performed by developers or server technicians, etc. Let me repeat that - it's virtually (no pun intended) impossible to keep environments consistent (okay, for the purist, it can be done, but it involves a huge amount of time, effort and discipline, which is precisely why VMs and containers (e.g. Docker) were devised in the first place).</source>
          <target state="translated">즉, 처음에는 일관된 환경을 만드는 것이 볼륨이 크기 때문에 (그린 필드 시나리오에서도) 충분하지는 않지만 서버 수가 많고 새 서버를 추가 할 때 (동적 또는 수동), o / s 공급 업체, 안티 바이러스 공급 업체, 브라우저 공급 업체 등의 자동 업데이트, 개발자 또는 서버 기술자가 수행 한 수동 소프트웨어 설치 또는 구성 변경 등 반복 할 수 있습니다. 사실상 불가능합니다. 환경을 일관되게 유지하기 위해 (순수한 자에게는 할 수 있지만 많은 시간과 노력과 훈련이 필요하기 때문에 VM과 컨테이너 (예 : Docker)가 처음에 고안된 이유입니다).</target>
        </trans-unit>
        <trans-unit id="ca19d7c471047ac8eb382f2e9dcc26820a0be902" translate="yes" xml:space="preserve">
          <source>This is a powerful feature where the base images are typically readonly and only when the container modifies something in the layer will it write something to read-write partition (a.k.a. copy on write). It also provides many other wrappers such as registry and versioning of images.</source>
          <target state="translated">이것은 기본 이미지가 일반적으로 읽기 전용이고 컨테이너가 레이어의 무언가를 수정할 때만 읽기-쓰기 파티션 (일명 복사시 복사)에 무언가를 쓸 수있는 강력한 기능입니다. 또한 레지스트리 및 이미지 버전 관리와 같은 다른 많은 래퍼도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1317aef78ad8c3de842b2ef9be30259400a3f9ad" translate="yes" xml:space="preserve">
          <source>This is another key feature of Docker. Images have layers, and different images can share layers, make it even more space-saving and faster to build.</source>
          <target state="translated">이것은 Docker의 또 다른 주요 기능입니다. 이미지에는 레이어가 있으며 다른 이미지는 레이어를 공유 할 수있어 공간을 절약하고 더 빠르게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5310e23583447dfd453271c88af2f6fed24876c8" translate="yes" xml:space="preserve">
          <source>This is good for most cases(no extra OS kernel maintains) but can be a problem if strict isolations are necessary between containers.</source>
          <target state="translated">이것은 여분의 OS 커널이 유지되지 않는 대부분의 경우에 좋지만 컨테이너간에 엄격한 격리가 필요한 경우 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b171c2b5faed3f4d2aeebc48f92139a7b66526fa" translate="yes" xml:space="preserve">
          <source>This is great for testing; let's say you have thousands of tests that need to connect to a database, and each test needs a pristine copy of the database and will make changes to the data. The classic approach to this is to reset the database after every test either with custom code or with tools like &lt;a href=&quot;https://flywaydb.org/&quot;&gt;Flyway&lt;/a&gt; - this can be very time-consuming and means that tests must be run serially. However, with Docker you could create an image of your database and run up one instance per test, and then run all the tests in parallel since you know they will all be running against the same snapshot of the database. Since the tests are running in parallel and in Docker containers they could run all on the same box at the same time and should finish much faster. Try doing that with a full VM.</source>
          <target state="translated">이것은 테스트에 좋습니다. 데이터베이스에 연결해야하는 수천 개의 테스트가 있고 각 테스트에는 데이터베이스의 원시 복사본이 필요하며 데이터를 변경한다고 가정 해 봅시다. 이에 대한 고전적인 접근 방식은 모든 테스트 후에 사용자 지정 코드 또는 &lt;a href=&quot;https://flywaydb.org/&quot;&gt;Flyway&lt;/a&gt; 와 같은 도구를 사용하여 데이터베이스를 재설정하는 것입니다. 시간이 많이 걸리고 테스트를 연속적으로 실행해야합니다. 그러나 Docker를 사용하면 데이터베이스 이미지를 생성하고 테스트 당 하나의 인스턴스를 실행 한 다음 모든 테스트가 동시에 동일한 데이터베이스 스냅 샷에 대해 실행될 것이므로 모든 테스트를 병렬로 실행할 수 있습니다. 테스트가 병렬로 실행되고 Docker 컨테이너에서 실행되므로 동일한 상자에서 모두 동시에 실행할 수 있으며 훨씬 빠르게 완료됩니다. 완전한 VM을 사용하여 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="7d04a3f43a0c2b52ecde6a7b7f97a221a6a3bf98" translate="yes" xml:space="preserve">
          <source>This is how &lt;strong&gt;Docker&lt;/strong&gt; introduces itself:</source>
          <target state="translated">이것이 &lt;strong&gt;Docker&lt;/strong&gt; 가 자체적으로 소개하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7afd8335fea67bc51f7938e0f38757c976265b55" translate="yes" xml:space="preserve">
          <source>This is probably the first impression for many docker learners.</source>
          <target state="translated">이것은 아마도 많은 도커 학습자들에게 첫 인상입니다.</target>
        </trans-unit>
        <trans-unit id="02c4ced0e5d01676f226fba6cc68700d33c41832" translate="yes" xml:space="preserve">
          <source>Through this post we are going to draw some lines of differences between VMs and LXCs. Let's first define them.</source>
          <target state="translated">이 게시물을 통해 VM과 LXC의 차이점을 몇 가지 살펴 보겠습니다. 먼저 정의 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a15a4722078ffc617f05f86021440c12e51d4b45" translate="yes" xml:space="preserve">
          <source>To keep this in sync you'll start to use something like Puppet, &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_(software)&quot;&gt;Chef&lt;/a&gt; or your own provisioning scripts, unpublished rules and/or lot of documentation... In theory servers can run indefinitely, and be kept completely consistent and up to date. Practice fails to manage a server's configuration completely, so there is considerable scope for configuration drift, and unexpected changes to running servers.</source>
          <target state="translated">이를 동기화하려면 Puppet, &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_(software)&quot;&gt;Chef&lt;/a&gt; 또는 자체 프로비저닝 스크립트, 게시되지 않은 규칙 및 / 또는 많은 문서와 같은 것을 사용하기 시작할 것입니다. 이론상 서버는 무기한으로 실행될 수 있으며 완전히 일관성 있고 최신 상태를 유지할 수 있습니다. 실습에서는 서버 구성을 완전히 관리하지 못하므로 구성 드리프트에 대한 범위가 넓고 실행중인 서버에 대한 예기치 않은 변경이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ea3f21662e019eb1e5105bae6861333f3ab291" translate="yes" xml:space="preserve">
          <source>To me it fits in the gap between developer-oriented tools like rpm, &lt;a href=&quot;http://en.wikipedia.org/wiki/Debian&quot;&gt;Debian&lt;/a&gt; packages, &lt;a href=&quot;http://en.wikipedia.org/wiki/Apache_Maven&quot;&gt;Maven&lt;/a&gt;, npm + Git on one side and ops tools like &lt;a href=&quot;http://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt;, VMware, Xen, you name it...</source>
          <target state="translated">필자는 rpm, &lt;a href=&quot;http://en.wikipedia.org/wiki/Debian&quot;&gt;Debian&lt;/a&gt; 패키지, &lt;a href=&quot;http://en.wikipedia.org/wiki/Apache_Maven&quot;&gt;Maven&lt;/a&gt; , npm + Git과 같은 개발자 중심 도구와 &lt;a href=&quot;http://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt; , VMware, Xen과 같은 ops 도구 사이의 간격에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5889b10f645756a05ce05d3b6d6208500c002851" translate="yes" xml:space="preserve">
          <source>UAT environment</source>
          <target state="translated">UAT 환경</target>
        </trans-unit>
        <trans-unit id="3181001e23737667962f1fc2a88fdb8fffabc3a6" translate="yes" xml:space="preserve">
          <source>Unlike a virtual machine, a container does not need to boot the operating system kernel, so containers can be created in less than a second. This feature makes container-based virtualization unique and desirable than other virtualization approaches.</source>
          <target state="translated">가상 머신과 달리 컨테이너는 운영 체제 커널을 부팅 할 필요가 없으므로 컨테이너를 1 초 이내에 만들 수 있습니다. 이 기능은 컨테이너 기반 가상화를 다른 가상화 방식보다 독특하고 바람직하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="b0ebc020284774b80187ae89c024cbc009582af0" translate="yes" xml:space="preserve">
          <source>Utilization of raw resources</source>
          <target state="translated">원자재 활용</target>
        </trans-unit>
        <trans-unit id="77b0430e1891dadfc3b08483480a6f1953f57349" translate="yes" xml:space="preserve">
          <source>Vendor lockin</source>
          <target state="translated">공급 업체 잠금</target>
        </trans-unit>
        <trans-unit id="6bb2ba4c680f5e6a3053c09883389d034fc8f0ce" translate="yes" xml:space="preserve">
          <source>Very slow deployment time</source>
          <target state="translated">매우 느린 배포 시간</target>
        </trans-unit>
        <trans-unit id="3a92642eb344d1e06c9e86038a0d64c11c33d1fa" translate="yes" xml:space="preserve">
          <source>Wasted resources</source>
          <target state="translated">낭비 된 자원</target>
        </trans-unit>
        <trans-unit id="bf8ef838532e25fda6b4e3a08fa9f32dcc1f7e04" translate="yes" xml:space="preserve">
          <source>Well, let's see if I can explain. You start with a base image, and then make your changes, and commit those changes using docker, and it creates an image. This image contains only the differences from the base. When you want to run your image, you also need the base, and it layers your image on top of the base using a layered file system: as mentioned above, Docker uses AuFS. AuFS merges the different layers together and you get what you want; you just need to run it. You can keep adding more and more images (layers) and it will continue to only save the diffs. Since Docker typically builds on top of ready-made images from a &lt;a href=&quot;https://registry.hub.docker.com/&quot;&gt;registry&lt;/a&gt;, you rarely have to &quot;snapshot&quot; the whole OS yourself.</source>
          <target state="translated">글쎄, 내가 설명 할 수 있는지 보자. 기본 이미지로 시작한 다음 변경하고 docker를 사용하여 변경 사항을 커밋하면 이미지가 생성됩니다. 이 이미지에는 밑면과의 차이점 만 포함되어 있습니다. 이미지를 실행하려면 기본도 필요하며 계층 파일 시스템을 사용하여 기본 위에 이미지를 계층화합니다. 위에서 언급 한 것처럼 Docker는 AuFS를 사용합니다. AuFS는 서로 다른 레이어를 병합하여 원하는 것을 얻습니다. 당신은 그것을 실행해야합니다. 점점 더 많은 이미지 (레이어)를 계속 추가 할 수 있으며 diff 만 계속 저장합니다. Docker는 일반적으로 &lt;a href=&quot;https://registry.hub.docker.com/&quot;&gt;레지스트리&lt;/a&gt; 에서 기성품 이미지 위에 빌드하므로 전체 OS를 &quot;스냅 샷&quot;할 필요가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="fad0b8f4568c8371bb2c483d1a404dc95e0c664a" translate="yes" xml:space="preserve">
          <source>What about memory, I/O, CPU, etc.? That is controlled using cgroups where you can create groups with certain resource (CPU, memory, etc.) specification/restriction and put your processes in there. On top of LXC, Docker provides a storage backend (&lt;a href=&quot;http://www.projectatomic.io/docs/filesystems/&quot;&gt;http://www.projectatomic.io/docs/filesystems/&lt;/a&gt;) e.g., union mount filesystem where you can add layers and share layers between different mount namespaces.</source>
          <target state="translated">메모리, I / O, CPU 등은 어떻습니까? 특정 리소스 (CPU, 메모리 등) 사양 / 제한이있는 그룹을 생성하고 프로세스를 거기에 넣을 수있는 cgroup을 사용하여 제어됩니다. Docker는 LXC 외에도 스토리지 백엔드 ( &lt;a href=&quot;http://www.projectatomic.io/docs/filesystems/&quot;&gt;http://www.projectatomic.io/docs/filesystems/&lt;/a&gt; )를 제공합니다. 예를 들어 다른 마운트 네임 스페이스간에 레이어를 추가하고 공유 할 수있는 통합 마운트 파일 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="06378e98591d7039cf2647e79565650d0d5d78a4" translate="yes" xml:space="preserve">
          <source>When it comes to docker, it's impossible to use a newly created docker container to replace the old one. Maintainance is much easier!Building a new image, share it with QA, testing it, deploying it only takes minutes(if everything is automated), hours in the worst case. This is called &lt;strong&gt;immutable infrastructure&lt;/strong&gt;: do not maintain(upgrade) software, create a new one instead.</source>
          <target state="translated">도커와 관련하여 새로 만든 도커 컨테이너를 사용하여 이전 컨테이너를 교체하는 것은 불가능합니다. 유지 관리가 훨씬 쉬워집니다! 새로운 이미지를 구축하고 QA와 공유하고 테스트하고 몇 분 (모든 것이 자동화 된 경우)에 배치하면 최악의 경우 몇 시간이 걸립니다. 이를 &lt;strong&gt;불변 인프라&lt;/strong&gt; 라고 부릅니다. 소프트웨어를 유지 (업그레이드)하지 말고 새 소프트웨어를 만드십시오.</target>
        </trans-unit>
        <trans-unit id="0d6d6cf1b29e9134acdcff3a62facc67c9694493" translate="yes" xml:space="preserve">
          <source>Why is deploying software to a Docker image (if that's the right term) easier than simply deploying to a consistent production environment?</source>
          <target state="translated">일관된 프로덕션 환경에 단순히 배포하는 것보다 소프트웨어를 Docker 이미지에 배포하는 것이 왜 쉬운가?</target>
        </trans-unit>
        <trans-unit id="76737419ccfacbafbd0f525710c6a3a42ae7dd7b" translate="yes" xml:space="preserve">
          <source>Why is deploying software to a docker image (if that's the right term) easier than simply deploying to a consistent production environment?</source>
          <target state="translated">일관된 프로덕션 환경에 단순히 배포하는 것보다 소프트웨어를 도커 이미지 (적절한 경우)에 배포하는 것이 더 쉬운 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f9cdfffebc66514c02f674beb799818dedbc3a6f" translate="yes" xml:space="preserve">
          <source>Why it matters?</source>
          <target state="translated">왜 중요한가요?</target>
        </trans-unit>
        <trans-unit id="99b4b35b78f8a91f025d97adbdc54bc7764bd29d" translate="yes" xml:space="preserve">
          <source>With Docker the idea is that you bundle up your application inside its own container along with the libraries it needs and then promote the &lt;strong&gt;whole&lt;/strong&gt; container as a single unit.</source>
          <target state="translated">Docker를 사용하면 필요한 라이브러리와 함께 자체 컨테이너 안에 응용 프로그램을 묶은 다음 &lt;strong&gt;전체&lt;/strong&gt; 컨테이너를 단일 단위로 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9093ae28c2ccd6692d394066fe08bfdc8d561258" translate="yes" xml:space="preserve">
          <source>With VMs you promote your application and its dependencies from one VM to the next DEV to UAT to PRD.</source>
          <target state="translated">VM을 사용하면 한 VM에서 다음 DEV로, UAT에서 PRD로 응용 프로그램 및 해당 종속성을 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cfb5ab13b910e2d7461b73b8aacfb4481e486d" translate="yes" xml:space="preserve">
          <source>With a &lt;strong&gt;virtual machine&lt;/strong&gt;, we have a server, we have a host operating system on that server, and then we have a hypervisor. And then running on top of that hypervisor, we have any number of guest operating systems with an application and its dependent binaries, and libraries on that server. It brings a whole guest operating system with it. It's quite heavyweight. Also there's a limit to how much you can actually put on each physical machine.</source>
          <target state="translated">&lt;strong&gt;가상 머신&lt;/strong&gt; 에는 서버가 있고 해당 서버에 호스트 운영 체제가 있으며 하이퍼 바이저가 있습니다. 그런 다음 해당 하이퍼 바이저 위에서 실행하면 해당 서버에 응용 프로그램과 종속 바이너리 및 라이브러리가있는 게스트 운영 체제가 얼마든지 있습니다. 게스트 운영 체제 전체를 제공합니다. 꽤 무겁습니다. 또한 각 물리적 시스템에 실제로 얼마나 많이 넣을 수 있는지에 대한 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45beaa5cc8f09acdd19ce70bb6c9300c62eddcc" translate="yes" xml:space="preserve">
          <source>With a Docker ecosystem, you will never need to move around gigabytes on &quot;small changes&quot; (thanks aufs and Registry) and you don't need to worry about losing performance by packaging applications into a Docker container at runtime. You don't need to worry about versions of that image.</source>
          <target state="translated">Docker 에코 시스템을 사용하면 &quot;소규모 변경 사항&quot;(aus 및 Registry 덕분)을 기가 바이트 단위로 이동할 필요가 없으며 런타임시 응용 프로그램을 Docker 컨테이너에 패키징하여 성능을 잃을 염려가 없습니다. 해당 이미지의 버전에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e3c7818924ae9d8fcbb0934d2f7637cfd7088fd" translate="yes" xml:space="preserve">
          <source>With normal LXC you need to come with some rootfs or share the rootfs and when shared, and the changes are reflected on other containers. Due to lot of these added features, Docker is more popular than LXC. LXC is popular in embedded environments for implementing security around processes exposed to external entities such as network and UI. Docker is popular in cloud multi-tenancy environment where consistent production environment is expected.</source>
          <target state="translated">일반적인 LXC에서는 일부 rootfs와 함께 제공되거나 rootfs를 공유하고 공유 할 때 변경 사항이 다른 컨테이너에 반영됩니다. 이러한 추가 기능으로 인해 Docker는 LXC보다 인기가 있습니다. LXC는 네트워크 및 UI와 같은 외부 엔터티에 노출 된 프로세스에 대한 보안을 구현하기 위해 임베디드 환경에서 널리 사용됩니다. Docker는 일관된 프로덕션 환경이 필요한 클라우드 다중 테넌시 환경에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7972c83547259b5e2dd725e515d3075919647cbe" translate="yes" xml:space="preserve">
          <source>Your question assumes some consistent production environment. &lt;em&gt;But how to keep it consistent?&lt;/em&gt;
Consider some amount (&amp;gt;10) of servers and applications, stages in the pipeline.</source>
          <target state="translated">귀하의 질문은 일관된 생산 환경을 가정합니다. &lt;em&gt;그러나 어떻게 일관성을 유지 하는가?&lt;/em&gt; 파이프 라인의 일부 단계 (&amp;gt; 10)의 서버 및 애플리케이션을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a08d179e776e577daf8ff6f5c184b673a0bb8d8d" translate="yes" xml:space="preserve">
          <source>a. LXCs are scoped to an instance of Linux. It might be different flavors of Linux (e.g. a Ubuntu container on a CentOS host but it&amp;rsquo;s still Linux.) Similarly, Windows-based containers are scoped to an instance of Windows now if we look at VMs they have a pretty broader scope and using the hypervisors you are not limited to operating systems Linux or Windows.</source>
          <target state="translated">ㅏ. LXC는 Linux 인스턴스에 적용됩니다. Linux의 풍미가 다를 수 있습니다 (예 : CentOS 호스트의 Ubuntu 컨테이너이지만 여전히 Linux 임). VM을 살펴보면 Windows 기반 컨테이너의 범위가 넓어지고 하이퍼 바이저 Linux 또는 Windows 운영 체제로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df46babbf9059013283e3dd3304e2a5f7fa7aa93" translate="yes" xml:space="preserve">
          <source>b. LXCs have low overheads and have better performance as compared to VMs. Tools viz. Docker which are built on the shoulders of LXC technology have provided developers with a platform to run their applications and at the same time have empowered operations people with a tool that will allow them to deploy the same container on production servers or data centers. It tries to make the experience between a developer running an application, booting and testing an application and an operations person deploying that application seamless, because this is where all the friction lies in and purpose of DevOps is to break down those silos.</source>
          <target state="translated">비. LXC는 VM에 비해 오버 헤드가 낮고 성능이 더 좋습니다. 도구 즉. LXC 기술을 기반으로하는 Docker는 개발자에게 응용 프로그램을 실행할 수있는 플랫폼을 제공했으며 동시에 운영 직원에게 프로덕션 서버 또는 데이터 센터에 동일한 컨테이너를 배포 할 수있는 도구를 제공했습니다. 개발자가 응용 프로그램을 실행하고, 응용 프로그램을 부팅 및 테스트하는 개발자와 해당 응용 프로그램을 완벽하게 배포하는 운영 담당자 사이에 경험을 쌓으려고 노력합니다. 이는 모든 마찰이 존재하고 DevOps의 목적이 이러한 사일로를 분해하기 때문입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
