<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/16047306">
    <body>
      <group id="16047306">
        <trans-unit id="1542e91684ce086bf89edc832e9a12e68917d0bd" translate="yes" xml:space="preserve">
          <source>&quot;Why is deploying software to a docker image easier than simply
  deploying to a consistent production environment ?&quot;</source>
          <target state="translated">&quot;为什么将软件部署到docker镜像上比简单地部署到一致的生产环境更容易?&quot;</target>
        </trans-unit>
        <trans-unit id="1d737b3b8cc6837fe64e3c75b0a1c0df5030c48c" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Traditional server&lt;/strong&gt; stack consist of a physical server that runs an operating system and your application.</source>
          <target state="translated">1） &lt;strong&gt;传统的服务器&lt;/strong&gt;堆栈由运行操作系统和您的应用程序的物理服务器组成。</target>
        </trans-unit>
        <trans-unit id="077bf232fbda32be3b9c0ab79f72fec0ccb8d9e3" translate="yes" xml:space="preserve">
          <source>1. Lightweight</source>
          <target state="translated">1.轻量级</target>
        </trans-unit>
        <trans-unit id="71d09371a22fe78dc0de04cc920e874384c82810" translate="yes" xml:space="preserve">
          <source>2) The &lt;strong&gt;VM stack&lt;/strong&gt; consist of a physical server which runs an operating system and a hypervisor that manages your virtual machine, shared resources, and networking interface. Each Vm runs a Guest Operating System, an application or set of applications.</source>
          <target state="translated">2） &lt;strong&gt;VM堆栈&lt;/strong&gt;由运行操作系统的物理服务器和管理虚拟机，共享资源和网络接口的管理程序组成。 每个Vm运行一个来宾操作系统，一个应用程序或一组应用程序。</target>
        </trans-unit>
        <trans-unit id="f4d7c4a101bb829d6ed36e595aa3142e9a5ffa6b" translate="yes" xml:space="preserve">
          <source>2. Layered File System</source>
          <target state="translated">2.分层文件系统</target>
        </trans-unit>
        <trans-unit id="8770d6a677830b5217dd912f5ec099a51998f621" translate="yes" xml:space="preserve">
          <source>3) The &lt;strong&gt;Container Setup&lt;/strong&gt;, the key difference with other stack is container-based virtualization uses the kernel of the host OS to rum multiple isolated guest instances. These guest instances are called as containers. The host can be either a physical server or VM.</source>
          <target state="translated">3） &lt;strong&gt;Container Setup&lt;/strong&gt;与其他堆栈的主要区别在于基于容器的虚拟化使用主机OS的内核来朗读多个隔离的来宾实例。 这些来宾实例称为容器。 主机可以是物理服务器或VM。</target>
        </trans-unit>
        <trans-unit id="89f675ab8f3566b687071343481ea9fc44b56715" translate="yes" xml:space="preserve">
          <source>3. Shared OS Kernel</source>
          <target state="translated">3.共享的操作系统内核</target>
        </trans-unit>
        <trans-unit id="31685e3d48621a28b58dd2cd05e5db872f4854fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;# uname -a
Linux linuxkit-025000000001 4.9.93-linuxkit-aufs #1 SMP Wed Jun 6 16:86_64 Linux&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;# uname -a Linux linuxkit-025000000001 4.9.93-linuxkit-aufs #1 SMP Wed Jun 6 16:86_64 Linux&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db614d06449b37f5ad288477a28799e03dc9b933" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="142e735c59804464a6da15ca8105687fa120d79a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;P.S. Meanwhile Docker uses its own implementation &quot;libcontainer&quot; instead of LXC. But LXC is still usable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PS同时，Docker使用自己的实现&amp;ldquo; libcontainer&amp;rdquo;而不是LXC。&lt;/em&gt; &lt;em&gt;但是LXC仍然可用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96829e303b9c7ac4c207907619fd8a78876e2fb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32eaa8b2035633536d9f24ca2887aff163749024" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Container-based Virtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基于容器的虚拟化&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db5599f735e2a2500c32124da79ac1b874f9d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Containers vs Virtual Machines&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;容器与虚拟机&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22a17ffbbec3938d78f7dede48285ca33d145bb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Disadvantages:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1210c3169b4fa074a2e3c489001d1a1b1d8641ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker containers&lt;/strong&gt; on the other hand, are slightly different. We have the server. We have the host operating system. But &lt;strong&gt;instead a hypervisor&lt;/strong&gt;, we have the &lt;strong&gt;Docker engine&lt;/strong&gt;, in this case. In this case, we're not bringing a whole guest operating system with us. &lt;strong&gt;We're bringing a very thin layer of the operating system&lt;/strong&gt;, and the container can talk down into the host OS in order to get to the kernel functionality there. And that allows us to have a very lightweight container.</source>
          <target state="translated">另一方面， &lt;strong&gt;Docker容器&lt;/strong&gt;略有不同。 我们有服务器。 我们有主机操作系统。 但是在这种情况下，我们使用&lt;strong&gt;Docker引擎&lt;/strong&gt; &lt;strong&gt;代替了hypervisor&lt;/strong&gt; 。 在这种情况下，我们不会带来整个客户操作系统。 &lt;strong&gt;我们带来了非常薄的操作系统层，&lt;/strong&gt;容器可以与主机OS进行对话，以获取那里的内核功能。 这样我们就可以拥有一个非常轻巧的容器。</target>
        </trans-unit>
        <trans-unit id="5a8ae3356972a5874b5d32602a6ac41e683d87a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Emulation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Emulation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae64e762702e7238eb615f129fe6646d7df6d223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How containers works at low level?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;容器如何在低级别工作？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cba3211b30b4294611bb6ea91489a1d00653523" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does Docker run containers in non-Linux systems?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Docker如何在非Linux系统中运行容器？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="041068c8237a3813ea49d52d6e51404b0e89980d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How virtualization works at low level?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;虚拟化如何在低层工作？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e0bc44a9e608ef3585c6d58d928f09910c03729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hypervisor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hypervisor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7372d7558096b8ae97739046d3fde3ac50229425" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Docker, the containers share the kernel&lt;/strong&gt; with the host; hence it is lightweight and can start and stop quickly.</source>
          <target state="translated">&lt;strong&gt;在Docker中，容器&lt;/strong&gt;与主机&lt;strong&gt;共享内核&lt;/strong&gt; 。 因此，它很轻巧，可以快速启动和停止。</target>
        </trans-unit>
        <trans-unit id="9fdf40f7f0dc77381f5f20369656158a3494158f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LXC&lt;/strong&gt;s:</source>
          <target state="translated">&lt;strong&gt;LXC&lt;/strong&gt;s:</target>
        </trans-unit>
        <trans-unit id="c3dedd742cecc6cd5d1a8cbac5f59953031f91af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paravirtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Paravirtualization&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b21d70651265dcd079d0ebae89422c38b3fd9409" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Think of containers as processes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;将容器视为流程！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c76a69be324057355bbf0c801aa45a367c1705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Types of Virtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;虚拟化类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0635560c3d8658f5a265d9aaa0a2b08757d22a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;VM&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;VM&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="04abd370cd085bed90eeed217f1681cbd37bf6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Virtualization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Virtualization&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d578b69a5047755d5db94a2927a4a2b1fc905cf" translate="yes" xml:space="preserve">
          <source>A Docker container is just a process (and its children) that is compartmentalized using &lt;a href=&quot;https://en.wikipedia.org/wiki/Cgroups&quot;&gt;cgroups&lt;/a&gt; inside the host system's kernel from the rest of the processes. You can actually see your Docker container processes by running &lt;code&gt;ps aux&lt;/code&gt; on the host. For example, starting &lt;code&gt;apache2&lt;/code&gt; &quot;in a container&quot; is just starting &lt;code&gt;apache2&lt;/code&gt; as a special process on the host. It's just been compartmentalized from other processes on the machine. It is important to note that your containers do not exist outside of your containerized process' lifetime. When your process dies, your container dies. That's because Docker replaces &lt;code&gt;pid 1&lt;/code&gt; inside your container with your application (&lt;code&gt;pid 1&lt;/code&gt; is normally the init system). This last point about &lt;code&gt;pid 1&lt;/code&gt; is very important.</source>
          <target state="translated">Docker容器只是一个进程（及其子进程），使用主机系统内核中的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cgroups&quot;&gt;cgroup&lt;/a&gt;与其余进程进行分隔。 您实际上可以通过在主机上运行 &lt;code&gt;ps aux&lt;/code&gt; 来查看Docker容器进程。 例如，&amp;ldquo;在容器中&amp;rdquo;启动 &lt;code&gt;apache2&lt;/code&gt; 只是作为主机上的特殊过程启动apache2 。 它只是从计算机上的其他进程中分离出来的。 重要的是要注意，在容器化过程的生命周期之外，容器不存在。 进程死亡时，容器死亡。 那是因为Docker用您的应用程序替换了容器内部的 &lt;code&gt;pid 1&lt;/code&gt; （ pid 1通常是init系统）。 关于 &lt;code&gt;pid 1&lt;/code&gt; 的最后一点非常重要。</target>
        </trans-unit>
        <trans-unit id="78eeb92cd87dde74faca433458994016f4decd02" translate="yes" xml:space="preserve">
          <source>A container image is a lightweight, stand-alone, executable package of
  a piece of software that includes everything needed to run it: code,
  runtime, system tools, system libraries, settings. Available for both
  Linux and Windows based apps, containerized software will always run
  the same, regardless of the environment. Containers isolate software
  from its surroundings, for example differences between development and
  staging environments and help reduce conflicts between teams running
  different software on the same infrastructure.</source>
          <target state="translated">容器映像是一个轻量级的、独立的、可执行的软件包,包含了运行软件所需的一切:代码、运行时、系统工具、系统库、设置。基于Linux和Windows的应用程序都可以使用,容器化的软件无论在什么环境下运行都是一样的。容器将软件与周围的环境隔离开来,例如开发环境和暂存环境之间的差异,有助于减少在同一基础架构上运行不同软件的团队之间的冲突。</target>
        </trans-unit>
        <trans-unit id="7be30e300596f0ba9bc71be0ee7f62418bc87c8b" translate="yes" xml:space="preserve">
          <source>A full virtualized system gets its own set of resources allocated to it, and does minimal sharing. You get more isolation, but it is much heavier (requires more resources). With Docker you get less isolation, but the containers are lightweight (require fewer resources). So you could easily run thousands of containers on a host, and it won't even blink. Try doing that with Xen, and unless you have a really big host, I don't think it is possible.</source>
          <target state="translated">一个完整的虚拟化系统会得到自己的资源分配给它,并做最小的共享。你会得到更多的隔离,但它更重(需要更多的资源)。使用Docker,你可以得到更少的隔离,但容器是轻量级的(需要更少的资源)。所以你可以轻松地在一台主机上运行成千上万的容器,它甚至不会眨眼。试着用Xen来做,除非你有一个非常大的主机,否则我认为这是不可能的。</target>
        </trans-unit>
        <trans-unit id="608fbdee4c4148887ee88283fec33bc794754b17" translate="yes" xml:space="preserve">
          <source>A full virtualized system usually takes minutes to start, whereas Docker/LXC/runC containers take seconds, and often even less than a second.</source>
          <target state="translated">一个完整的虚拟化系统通常需要几分钟的时间来启动,而DockerLXCrunC容器则需要几秒钟,甚至往往不到一秒钟。</target>
        </trans-unit>
        <trans-unit id="a4b2e429639e6886f8411056dda3847c82546562" translate="yes" xml:space="preserve">
          <source>A normal VM (for example, VirtualBox and VMware) uses a hypervisor, and related technologies either have dedicated firmware that becomes the first layer for the first OS (host OS, or guest OS 0) or a software that runs on the host OS to provide hardware emulation such as CPU, USB/accessories, memory, network, etc., to the guest OSes. VMs are still (as of 2015) popular in high security multi-tenant environment.</source>
          <target state="translated">一般的虚拟机(例如VirtualBox和VMware)使用的是hypervisor,相关技术要么有专用的固件,成为第一层操作系统(主机操作系统,或者说是客机操作系统0)的第一层,要么有运行在主机操作系统上的软件,为客机操作系统提供CPU、USBaccessories、内存、网络等硬件仿真。在高安全的多租户环境中,虚拟机仍然是(截至2015年)流行的。</target>
        </trans-unit>
        <trans-unit id="94101e1c748c27249505148a47df8530a21b42ed" translate="yes" xml:space="preserve">
          <source>A virtual machine emulates a physical computing environment, but requests for CPU, memory, hard disk, network and other hardware resources are managed by a virtualization layer which translates these requests to the underlying physical hardware.</source>
          <target state="translated">虚拟机模拟物理计算环境,但对CPU、内存、硬盘、网络和其他硬件资源的请求由虚拟化层管理,该层将这些请求转化为底层物理硬件。</target>
        </trans-unit>
        <trans-unit id="d923b7473237dcd6ea141e8da0b0dc01d79023e1" translate="yes" xml:space="preserve">
          <source>A virtualizer encapsulates an OS that can run any applications it can normally run on a bare metal machine.</source>
          <target state="translated">虚拟化器封装了一个操作系统,它可以在裸机上运行任何可以正常运行的应用程序。</target>
        </trans-unit>
        <trans-unit id="6d59a769d8037c795aa06bba1ef20f7fb8148382" translate="yes" xml:space="preserve">
          <source>Abandoning VMs is not practical as of now. So both VMs and LXCs have their own individual existence and importance.</source>
          <target state="translated">放弃VM,从目前来看是不现实的。所以VM和LXC都有各自的存在和重要性。</target>
        </trans-unit>
        <trans-unit id="9b9f1e587c930b5eec7c7112c3c5c48f8660cb1e" translate="yes" xml:space="preserve">
          <source>All containers on a host machine share the scheduler of the host machine saving need of extra resources.</source>
          <target state="translated">主机上的所有容器共享主机的调度器,节省了额外的资源需求。</target>
        </trans-unit>
        <trans-unit id="12541b433287714758ede775818e5b65a743a10e" translate="yes" xml:space="preserve">
          <source>All containers run inside this VM.</source>
          <target state="translated">所有的容器都在这个 VM 中运行。</target>
        </trans-unit>
        <trans-unit id="54b4b640aadb7cfc9c96aa084587f5b6a81007c9" translate="yes" xml:space="preserve">
          <source>All containers running on a host is indeed a bunch of processes with different file systems. They share the same OS kernel, only encapsulates system library and dependencies.</source>
          <target state="translated">所有运行在主机上的容器确实是一堆不同文件系统的进程。它们共享同一个操作系统内核,只是封装了系统库和依赖关系。</target>
        </trans-unit>
        <trans-unit id="1242f984643238195d2560e484817f61f78a1183" translate="yes" xml:space="preserve">
          <source>All it has in there is the application code and any binaries and libraries that it requires. And those binaries and libraries can actually be shared across different containers if you want them to be as well. And what this enables us to do, is a number of things. They have &lt;strong&gt;much faster startup time&lt;/strong&gt;. You can't stand up a single VM in a few seconds like that. And equally, taking them down as quickly.. so we can scale up and down very quickly and we'll look at that later on.</source>
          <target state="translated">它包含的全部是应用程序代码以及所需的任何二进制文件和库。 如果您也希望这些二进制文件和库也可以在不同容器之间共享。 这使我们能够做很多事情。 它们具有&lt;strong&gt;更快的启动时间&lt;/strong&gt; 。 像这样的几秒钟内您无法站立单个VM。 同样，将它们快速删除..这样我们就可以快速放大和缩小，我们稍后再讨论。</target>
        </trans-unit>
        <trans-unit id="f836b6bbddefb5d4fc7275c8e4836939cd0b1d3c" translate="yes" xml:space="preserve">
          <source>All these seem like improvements, not revolution. Well, &lt;em&gt;quantitative accumulation leads to qualitative transformation&lt;/em&gt;.</source>
          <target state="translated">所有这些似乎都是改进，而不是革命。 好吧， &lt;em&gt;定量积累会导致质变&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3b5f0368363469d9d80cc687e706a23e041424b" translate="yes" xml:space="preserve">
          <source>And finally you will even often be able to reproduce complex production environments even on your Linux laptop (don't call me if doesn't work in your case ;))</source>
          <target state="translated">最后,你甚至可以经常在你的Linux笔记本上重现复杂的生产环境(如果在你的情况下无法正常工作,请不要给我打电话;)</target>
        </trans-unit>
        <trans-unit id="4f108d5a48660532c28d2ad4f3d3edba0268d0ae" translate="yes" xml:space="preserve">
          <source>And of course you can start Docker containers in VMs (it's a good idea). Reduce your server provisioning on the VM level. All the above could be managed by Docker.</source>
          <target state="translated">当然你也可以在VM中启动Docker容器(这是个好主意)。在VM层面减少你的服务器配置。以上这些都可以由Docker来管理。</target>
        </trans-unit>
        <trans-unit id="ad81be781ce70f499768e24f3435d23637132329" translate="yes" xml:space="preserve">
          <source>And yes there are issues with containers including managing them although tools like Kubernetes or Docker Swarm greatly simplify the task.</source>
          <target state="translated">是的,虽然像Kubernetes或Docker Swarm这样的工具大大简化了任务,但是容器的问题包括管理容器也是有的。</target>
        </trans-unit>
        <trans-unit id="72a1b17c5906a7f20ce9ae99d036afd244eb15c1" translate="yes" xml:space="preserve">
          <source>Another important issue regarding Docker is Docker Hub and its community.
For example, I implemented an ecosystem for monitoring kafka using Prometheus, Grafana, Prometheus-JMX-Exporter, and Docker.</source>
          <target state="translated">关于Docker的另一个重要问题是Docker Hub及其社区。例如,我用Prometheus、Grafana、Prometheus-JMX-Exporter和Docker实现了一个监控kafka的生态系统。</target>
        </trans-unit>
        <trans-unit id="2621c6fd51a58e1d1d5c491aac71488647b20224" translate="yes" xml:space="preserve">
          <source>Archive</source>
          <target state="translated">Archive</target>
        </trans-unit>
        <trans-unit id="57f80354947d66e1556a5eca93c5ebe70343ca99" translate="yes" xml:space="preserve">
          <source>Around &lt;a href=&quot;http://blog.differential.com/the-story-behind-meteors-next-big-move/&quot;&gt;2006&lt;/a&gt;, people including some of the employees at Google implemented new kernel level feature called &lt;em&gt;namespaces&lt;/em&gt; (however the idea &lt;a href=&quot;http://rhelblog.redhat.com/2015/08/28/the-history-of-containers/&quot;&gt;long&lt;/a&gt; before &lt;a href=&quot;https://www.linux.com/component/content/article/186-virtualization/300057-containers-vs-hypervisors-choosing-the-best-virtualization-technology-&quot;&gt;existed in FreeBSD&lt;/a&gt;). One function of the OS is to allow sharing of global resources like network and disk to processes. What if these global resources were wrapped in namespaces so that they are visible only to those processes that run in the same namespace? Say, you can get a chunk of disk and put that in namespace X and then processes running in namespace Y can't see or access it. Similarly, processes in namespace X can't access anything in memory that is allocated to namespace Y. Of course, processes in X can't see or talk to processes in namespace Y. This provides kind of virtualization and isolation for global resources. This is how docker works: Each container runs in its own namespace but uses exactly the &lt;em&gt;same&lt;/em&gt; kernel as all other containers. The isolation happens because kernel knows the namespace that was assigned to the process and during API calls it makes sure that process can only access resources in its own namespace.</source>
          <target state="translated">在&lt;a href=&quot;http://blog.differential.com/the-story-behind-meteors-next-big-move/&quot;&gt;2006年&lt;/a&gt;左右，包括Google的一些员工在内的人们实现了新的内核级功能，即&lt;em&gt;名称空间&lt;/em&gt; （但是早&lt;a href=&quot;https://www.linux.com/component/content/article/186-virtualization/300057-containers-vs-hypervisors-choosing-the-best-virtualization-technology-&quot;&gt;在FreeBSD中&lt;/a&gt;就已经存在 ）。 操作系统的一项功能是允许将网络和磁盘等全局资源共享给进程。 如果将这些全局资源包装在名称空间中，以便它们仅对在相同名称空间中运行的那些进程可见，该怎么办？ 假设您可以获取一块磁盘并将其放入命名空间X中，然后在命名空间Y中运行的进程将无法看到或访问它。 同样，名称空间X中的进程无法访问分配给名称空间Y的内存中的任何内容。当然，X中的进程无法查看或与名称空间Y中的进程对话。这为全局资源提供了一种虚拟化和隔离。 docker的工作方式是这样的：每个容器都在自己的命名空间中运行，但使用的内核与其他所有容器完全相同。 发生隔离是因为内核知道分配给进程的名称空间，并且在API调用期间它确保进程只能访问其自己的名称空间中的资源。</target>
        </trans-unit>
        <trans-unit id="5d01eda27cef34d23b355ad375a9bb0b4eb5ebbb" translate="yes" xml:space="preserve">
          <source>As a general rule there is only one application per container which simplifies configuration.</source>
          <target state="translated">一般来说,每个容器只有一个应用程序,这就简化了配置。</target>
        </trans-unit>
        <trans-unit id="598b72a60140d7f35d63c4ce17f4d2a21404bafd" translate="yes" xml:space="preserve">
          <source>As far as the filesystem used by each of those container processes, Docker uses &lt;a href=&quot;https://en.wikipedia.org/wiki/UnionFS&quot;&gt;UnionFS&lt;/a&gt;-backed images, which is what you're downloading when you do a &lt;code&gt;docker pull ubuntu&lt;/code&gt;. Each &quot;image&quot; is just a series of layers and related metadata. The concept of layering is very important here. Each layer is just a change from the layer underneath it. For example, when you delete a file in your Dockerfile while building a Docker container, you're actually just creating a layer on top of the last layer which says &quot;this file has been deleted&quot;. Incidentally, this is why you can delete a big file from your filesystem, but the image still takes up the same amount of disk space. The file is still there, in the layers underneath the current one. Layers themselves are just tarballs of files. You can test this out with &lt;code&gt;docker save --output /tmp/ubuntu.tar ubuntu&lt;/code&gt; and then &lt;code&gt;cd /tmp &amp;amp;&amp;amp; tar xvf ubuntu.tar&lt;/code&gt;. Then you can take a look around. All those directories that look like long hashes are actually the individual layers. Each one contains files (&lt;code&gt;layer.tar&lt;/code&gt;) and metadata (&lt;code&gt;json&lt;/code&gt;) with information about that particular layer. Those layers just describe changes to the filesystem which are saved as a layer &quot;on top of&quot; its original state. When reading the &quot;current&quot; data, the filesystem reads data as though it were looking only at the top-most layers of changes. That's why the file appears to be deleted, even though it still exists in &quot;previous&quot; layers, because the filesystem is only looking at the top-most layers. This allows completely different containers to share their filesystem layers, even though some significant changes may have happened to the filesystem on the top-most layers in each container. This can save you a ton of disk space, when your containers share their base image layers. However, when you mount directories and files from the host system into your container by way of volumes, those volumes &quot;bypass&quot; the UnionFS, so changes are not stored in layers.</source>
          <target state="translated">至于每个容器进程使用的文件系统，Docker使用由&lt;a href=&quot;https://en.wikipedia.org/wiki/UnionFS&quot;&gt;UnionFS&lt;/a&gt;支持的映像，这是在执行docker &lt;code&gt;docker pull ubuntu&lt;/code&gt; 时要下载的映像。 每个&amp;ldquo;图像&amp;rdquo;只是一系列图层和相关的元数据。 分层的概念在这里非常重要。 每层只是其下一层的变化。 例如，当您在构建Docker容器时删除Dockerfile中的文件时，实际上您实际上是在最后一层之上创建一个表示&amp;ldquo;此文件已被删除&amp;rdquo;的层。 顺便说一句，这就是为什么您可以从文件系统中删除大文件，但是映像仍占用相同数量的磁盘空间的原因。 该文件仍然位于当前文件所在层中。 图层本身只是文件的压缩文件。 您可以使用 &lt;code&gt;docker save --output /tmp/ubuntu.tar ubuntu&lt;/code&gt; 然后使用 &lt;code&gt;cd /tmp &amp;amp;&amp;amp; tar xvf ubuntu.tar&lt;/code&gt; 。 然后，您可以环顾四周。 所有那些看起来像长哈希的目录实际上都是单独的层。 每个文件都包含文件（ &lt;code&gt;layer.tar&lt;/code&gt; ）和元数据（ &lt;code&gt;json&lt;/code&gt; ），以及有关该特定图层的信息。 这些层仅描述对文件系统的更改，这些更改保存为原始状态&amp;ldquo;之上&amp;rdquo;的一层。 当读取&amp;ldquo;当前&amp;rdquo;数据时，文件系统将读取数据，就好像它只是在查看更改的最顶层。 这就是为什么即使文件仍然存在于&amp;ldquo;上一个&amp;rdquo;层中的情况下，该文件也似乎被删除的原因，因为文件系统仅查看最顶层。 这允许完全不同的容器共享其文件系统层，即使每个容器中最顶层的文件系统可能发生了一些重大更改。 当您的容器共享其基本映像层时，可以节省大量磁盘空间。 但是，当您通过卷将主机系统中的目录和文件安装到容器中时，这些卷会&amp;ldquo;绕过&amp;rdquo; UnionFS，因此更改不会存储在层中。</target>
        </trans-unit>
        <trans-unit id="5a90c96cd22c443750dcd37a720eff4fed88c89c" translate="yes" xml:space="preserve">
          <source>As you can see the extrapolated total number of servers for an organisation is rarely in single figures, is very often in triple figures and can easily be significantly higher still.</source>
          <target state="translated">正如你所看到的,一个组织的服务器总数很少是个位数,往往是三位数,而且很容易就会大大增加。</target>
        </trans-unit>
        <trans-unit id="81f5b5d7fb019e7f4ae5f8b5f55e80d3576c41bd" translate="yes" xml:space="preserve">
          <source>AuFS is a layered file system, so you can have a read only part and a write part which are merged together. One could have the common parts of the operating system as read only (and shared amongst all of your containers) and then give each container its own mount for writing.</source>
          <target state="translated">AuFS是一个分层文件系统,所以你可以有一个只读部分和一个写部分合并在一起。可以将操作系统的公用部分作为只读部分(并在所有的容器中共享),然后给每个容器都有自己的挂载,用于写入。</target>
        </trans-unit>
        <trans-unit id="4cfd99ba34f608f70161df11d9d7991016760ff2" translate="yes" xml:space="preserve">
          <source>Backout consists of stopping and deleting the container.</source>
          <target state="translated">回出包括停止和删除容器。</target>
        </trans-unit>
        <trans-unit id="351e46cacb0525510c6af44a48e0b695b9063feb" translate="yes" xml:space="preserve">
          <source>Backout requires undoing changes in the VM. Or restoring it if possible.</source>
          <target state="translated">Backout需要撤销VM中的更改。如果可能的话,或者恢复它。</target>
        </trans-unit>
        <trans-unit id="d851c9a4f97cb1a71d6b2be6463bab52ea582fa4" translate="yes" xml:space="preserve">
          <source>Besides that, they are very light-weight and flexible thanks to the dockerFile configuration.</source>
          <target state="translated">除此之外,由于dockerFile的配置,它们非常轻巧灵活。</target>
        </trans-unit>
        <trans-unit id="e9df9aab39e6b2e3d5e433a04b4d06ee5e827531" translate="yes" xml:space="preserve">
          <source>Besides the Docker Hub site there is another site called quay.io that you can use to have your own Docker images dashboard there and pull/push to/from it. You can even import Docker images from Docker Hub to quay then running them from quay on your own machine.</source>
          <target state="translated">除了Docker Hub网站之外,还有一个叫quay.io的网站,你可以用它来拥有自己的Docker映像仪表盘,然后从它里面拉动推送。你甚至可以从Docker Hub导入Docker映像到quay,然后在自己的机器上运行。</target>
        </trans-unit>
        <trans-unit id="00f47b682df45612c96346dc99122be39bdc7654" translate="yes" xml:space="preserve">
          <source>But I want to add additional point of view, not covered in detail here. In my opinion Docker differs also in whole process. In contrast to VMs, Docker is not (only) about optimal resource sharing of hardware, moreover it provides a &quot;system&quot; for packaging application (preferable, but not a must, as a set of microservices).</source>
          <target state="translated">但我想补充一点,这里不详细介绍。在我看来,Docker在整个过程中也有区别。与VM不同的是,Docker并不是(仅仅是)优化硬件的资源共享,更多的是它提供了一个打包应用的 &quot;系统&quot;(作为一组微服务,最好是,但不是必须的)。</target>
        </trans-unit>
        <trans-unit id="2246070647f40bdc0a60270679c1fd264e82ae9e" translate="yes" xml:space="preserve">
          <source>But the big question is, is it feasible?, will it be sensible?</source>
          <target state="translated">但最大的问题是,这是否可行,是否合理?</target>
        </trans-unit>
        <trans-unit id="467036aef2189670c83d3de39dc33422063e461b" translate="yes" xml:space="preserve">
          <source>By comparing the container setup with its predecessors, we can conclude that containerization is the fastest, most resource effective, and most secure setup we know to date. Containers are isolated instances that run your application. &lt;strong&gt;Docker spin up the container in a way, layers get run time memory with default storage drivers(Overlay drivers) those run within seconds and copy-on-write layer created on top of it once we commit into the container, that powers the execution of containers.&lt;/strong&gt; In case of VM's that will take around a minute to load everything into the virtualize environment. These lightweight instances can be replaced, rebuild, and moved around easily. This allows us to mirror the production and development environment and is tremendous help in CI/CD processes. The advantages containers can provide are so compelling that they're definitely here to stay.</source>
          <target state="translated">通过将容器设置与其之前的版本进行比较，我们可以得出结论：迄今为止，容器化是最快，最节省资源和最安全的设置。 容器是运行您的应用程序的隔离实例。 &lt;strong&gt;Docker以某种方式旋转容器，各层通过默认存储驱动程序（覆盖驱动程序）在几秒钟内运行即可获得运行时内存，并在我们提交到容器后在其之上创建写时复制层，从而为执行提供动力。容器。&lt;/strong&gt; 如果是VM，则需要大约一分钟才能将所有内容加载到虚拟化环境中。 这些轻量级实例可以轻松替换，重建和移动。 这使我们能够反映生产和开发环境，并且在CI / CD流程中提供了巨大帮助。 容器可以提供的优势是如此引人注目，以至于它们肯定会留下来。</target>
        </trans-unit>
        <trans-unit id="2218fd115399d11f4e43b078ba742fac667ff0de" translate="yes" xml:space="preserve">
          <source>Complex configuration</source>
          <target state="translated">复杂的配置</target>
        </trans-unit>
        <trans-unit id="ba8780a743531027156a18a445e7af93055ec46f" translate="yes" xml:space="preserve">
          <source>Container states (Docker or LXC images) are small in size compared to virtual machine images, so container images are easy to distribute.</source>
          <target state="translated">容器状态(Docker或LXC映像)与虚拟机映像相比,容器状态(Docker或LXC映像)的体积较小,所以容器映像很容易分发。</target>
        </trans-unit>
        <trans-unit id="25ce7e45cb65773b9965d5fad315cc3119faab36" translate="yes" xml:space="preserve">
          <source>Container-based virtualization</source>
          <target state="translated">基于容器的虚拟化</target>
        </trans-unit>
        <trans-unit id="598df2f164e7aaa8e067a8c319cc0e57e541f468" translate="yes" xml:space="preserve">
          <source>Container-based virtualization, also known as operating system-level virtualization, enables multiple isolated executions within a single operating system kernel. It has the best possible performance and density and features dynamic resource management. The isolated virtual execution environment provided by this type of virtualization is called a container and can be viewed as a traced group of processes.</source>
          <target state="translated">基于容器的虚拟化,又称操作系统级虚拟化,可以在一个操作系统内核内实现多个孤立的执行。它具有最佳的性能和密度,并具有动态资源管理的特点。这种虚拟化所提供的隔离的虚拟执行环境被称为容器,可以看成是一个可追踪的进程组。</target>
        </trans-unit>
        <trans-unit id="5d4c3cdeb8073372b70957b9b2f3cd7fe34f32eb" translate="yes" xml:space="preserve">
          <source>Cost efficiency</source>
          <target state="translated">成本效益</target>
        </trans-unit>
        <trans-unit id="735a54b02db689eb4f4e57bf659a737787c87afb" translate="yes" xml:space="preserve">
          <source>Deploying a consistent production environment is easier said than done. Even if you use tools like &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_%28software%29&quot;&gt;Chef&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt;, there are always OS updates and other things that change between hosts and environments.</source>
          <target state="translated">部署一致的生产环境说起来容易做起来难。 即使您使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_%28software%29&quot;&gt;Chef&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet之&lt;/a&gt;类的工具，也始终会在主机和环境之间进行OS更新以及其他更改。</target>
        </trans-unit>
        <trans-unit id="943c1d3d450b735a762475a53fbc3f3845e18058" translate="yes" xml:space="preserve">
          <source>Developers can often develop on PCs beyond the control of corporate or business standardisation rules (e.g. freelancers who develop on their own machines (often remotely) or contributors to open source projects who are not 'employed' or 'contracted' to configure their PCs a certain way)</source>
          <target state="translated">开发人员往往可以在企业或业务标准化规则之外的PC上进行开发(例如,自由职业者在自己的机器上进行开发(通常是远程开发),或者是开放源码项目的贡献者,他们并没有 &quot;受雇于 &quot;或 &quot;签约 &quot;以某种方式配置他们的PC)。</target>
        </trans-unit>
        <trans-unit id="648c9952f3e90ecd09eb98e62fc5b9803514288d" translate="yes" xml:space="preserve">
          <source>Developers, and indeed testers, will all have either subtlely or vastly different PC configurations, by the very nature of the job</source>
          <target state="translated">开发人员,甚至是测试人员,都会有微妙的或巨大的PC配置,从工作性质上看,都会有不同的PC配置。</target>
        </trans-unit>
        <trans-unit id="d58e3f21c27fd593809010f14d9f9baa0486da85" translate="yes" xml:space="preserve">
          <source>Difficult to migrate</source>
          <target state="translated">难于迁移</target>
        </trans-unit>
        <trans-unit id="02c9786ecd26345d0f7e906cc555a19e98790432" translate="yes" xml:space="preserve">
          <source>Difficult to scale</source>
          <target state="translated">难于缩放</target>
        </trans-unit>
        <trans-unit id="2437715c53b48152d323d9cdffd1153b925cb3c8" translate="yes" xml:space="preserve">
          <source>Docker and LXC is meant more for sandboxing, containerization, and resource isolation. It uses the host OS's (currently only Linux kernel) clone API which provides namespacing for IPC, NS (mount), network, PID, UTS, etc.</source>
          <target state="translated">Docker和LXC更多是为了沙盒化、容器化和资源隔离。它使用主机操作系统(目前只有Linux内核)的克隆API,提供IPC、NS(挂载)、网络、PID、UTS等命名空间。</target>
        </trans-unit>
        <trans-unit id="0670367a7dd49858e74261aabd50689718ce92d8" translate="yes" xml:space="preserve">
          <source>Docker containers are isolated environments. You can see it when you issue the &lt;code&gt;top&lt;/code&gt; command in a Docker container that has been created from a Docker image.</source>
          <target state="translated">Docker容器是隔离的环境。 在从Docker映像创建的Docker容器中发出 &lt;code&gt;top&lt;/code&gt; 命令时，可以看到它。</target>
        </trans-unit>
        <trans-unit id="39db408285c6798b78a9365ee4e90c59857f3a5e" translate="yes" xml:space="preserve">
          <source>Docker encapsulates an application with all its dependencies.</source>
          <target state="translated">Docker封装了一个应用程序及其所有的依赖关系。</target>
        </trans-unit>
        <trans-unit id="973f8f76caeb9718bdc472542aacfb07e2e84af9" translate="yes" xml:space="preserve">
          <source>Docker for Mac uses &lt;a href=&quot;https://github.com/moby/hyperkit&quot;&gt;https://github.com/moby/hyperkit&lt;/a&gt; to emulate the hypervisor capabilities and Hyperkit uses hypervisor.framework in its core. Hypervisor.framework is Mac's native hypervisor solution. Hyperkit also uses VPNKit and DataKit to namespace network and filesystem respectively.</source>
          <target state="translated">用于Mac的Docker使用&lt;a href=&quot;https://github.com/moby/hyperkit&quot;&gt;https://github.com/moby/hyperkit&lt;/a&gt;来模拟虚拟机监控程序功能，而Hyperkit在其核心中使用hypervisor.framework。 Hypervisor.framework是Mac的本机虚拟机管理程序解决方案。 Hyperkit还使用VPNKit和DataKit分别命名网络和文件系统的名称空间。</target>
        </trans-unit>
        <trans-unit id="3414abcd2e979a63ae859b5dbc68d077ef1b7ab6" translate="yes" xml:space="preserve">
          <source>Docker gives you the ability to snapshot the OS into a shared image, and makes it easy to deploy on other Docker hosts. Locally, dev, qa, prod, etc.: all the same image. Sure you can do this with other tools, but not nearly as easily or fast.</source>
          <target state="translated">Docker给你提供了将操作系统快照到共享映像的能力,让你在其他Docker主机上部署也很方便。本地、dev、qa、prod等:都是同一个映像。当然,你可以用其他工具来做这个,但几乎没有那么容易和快速。</target>
        </trans-unit>
        <trans-unit id="8d5d7812c058dbb0c86c05605da9d9d304ccab2a" translate="yes" xml:space="preserve">
          <source>Docker has been developed based on LXC (Linux Container) and works perfectly in many Linux distributions, especially Ubuntu.</source>
          <target state="translated">Docker是基于LXC(Linux容器)开发的,在许多Linux发行版,特别是Ubuntu中都能完美地运行。</target>
        </trans-unit>
        <trans-unit id="e635f7c85d8f012e88161b22bf2e6522d0f921ac" translate="yes" xml:space="preserve">
          <source>Docker is container based technology and containers are just user space of the operating system. 
1:At the low level, a container is just a set of processes that are isolated from the rest of the system, running from a distinct image that provides all files necessary to support the processes.
2: It is built for running applications. In Docker, the containers running share the host OS kernel.
&lt;strong&gt;VIRTUAL MACHINE&lt;/strong&gt;
a:A Virtual Machine, on the other hand, is not based on container technology. They are made up of user space plus kernel space of an operating system.
b: Under VMs, server hardware is virtualized. Each VM has Operating system (OS) &amp;amp; apps. It shares hardware resource from the host.
&lt;strong&gt;VM &amp;amp; DOCKER&lt;/strong&gt;
A: VMs &amp;amp; Docker &amp;ndash; each comes with benefits and demerits. Under a VM environment, each workload needs a complete OS.
B: But with a container environment, multiple workloads can run with 1 OS. The bigger the OS footprint, the more environment benefits from containers. With this, it brings further benefits like Reduced IT management resources, reduced size of snapshots, quicker spinning up apps, reduced &amp;amp; simplified security updates, less code to transfer, migrate and upload workloads.</source>
          <target state="translated">Docker是基于容器的技术，容器只是操作系统的用户空间。 1：在底层，容器只是与系统其余部分隔离的一组进程，它们从一个独特的映像运行，该映像提供了支持这些进程所需的所有文件。 2：它是为运行应用程序而构建的。 在Docker中，运行中的容器共享主机OS内核。 虚拟机a：另一方面，虚拟机不基于容器技术。 它们由用户空间加上操作系统的内核空间组成。 b：在VM下，服务器硬件已虚拟化。 每个VM都有操作系统（OS）和应用程序。 它共享来自主机的硬件资源。 &lt;strong&gt;VM和DOCKER&lt;/strong&gt; A：VM和Docker &amp;ndash;每种都有优点和缺点。 在VM环境下，每个工作负载都需要一个完整的OS。 B：但是在容器环境中，多个工作负载可以在1个OS上运行。 操作系统占用空间越大，容器从中受益的环境越多。 这样，它带来了更多的好处，例如减少了IT管理资源，减小了快照的大小，加快了应用的旋转速度，减少和简化了安全更新，减少了用于传输，迁移和上载工作负载的代码。</target>
        </trans-unit>
        <trans-unit id="7b421c171d242c8170806930398752966ab85b44" translate="yes" xml:space="preserve">
          <source>Docker is just a fancy way to run a process, not a virtual machine.</source>
          <target state="translated">Docker只是运行进程的一种花哨的方式,而不是虚拟机。</target>
        </trans-unit>
        <trans-unit id="c84bdd2076394c3c27e65f730787ccf2624b38d1" translate="yes" xml:space="preserve">
          <source>Docker is moving very fast. Its &lt;a href=&quot;https://docs.docker.com/&quot;&gt;documentation&lt;/a&gt; is some of the best documentation I've ever seen. It is generally well-written, concise, and accurate. I recommend you check the documentation available for more information, and trust the documentation over anything else you read online, including Stack Overflow. If you have specific questions, I highly recommend joining &lt;code&gt;#docker&lt;/code&gt; on Freenode IRC and asking there (you can even use Freenode's &lt;a href=&quot;https://webchat.freenode.net/&quot;&gt;webchat&lt;/a&gt; for that!).</source>
          <target state="translated">Docker的发展非常迅速。 它的&lt;a href=&quot;https://docs.docker.com/&quot;&gt;文档&lt;/a&gt;是我见过的最好的文档。 它通常是精心编写，简洁且准确的。 我建议您查看可用的文档以获取更多信息，并信任您在线上阅读的所有文档，包括Stack Overflow。 如果您有特定问题，我强烈建议在Freenode IRC上加入 &lt;code&gt;#docker&lt;/code&gt; 并询问（您甚至可以使用Freenode的网络&lt;a href=&quot;https://webchat.freenode.net/&quot;&gt;聊天&lt;/a&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="73b8cae18034650b6584789ec0b6826a36a4969b" translate="yes" xml:space="preserve">
          <source>Docker is the company driving the container movement and the only
  container platform provider to address every application across the
  hybrid cloud. Today&amp;rsquo;s businesses are under pressure to digitally
  transform but are constrained by existing applications and
  infrastructure while rationalizing an increasingly diverse portfolio
  of clouds, datacenters and application architectures. Docker enables
  true independence between applications and infrastructure and
  developers and IT ops to unlock their potential and creates a model
  for better collaboration and innovation.</source>
          <target state="translated">Docker是推动容器发展的公司，并且是唯一可解决混合云中每个应用程序问题的容器平台提供商。 当今的企业面临着进行数字化转型的压力，但受到现有应用程序和基础架构的限制，同时使越来越多样化的云，数据中心和应用程序体系结构合理化。 Docker使应用程序和基础架构之间真正的独立性得以实现，开发人员和IT运营者可以发挥其潜力，并为更好的协作和创新创建模型。</target>
        </trans-unit>
        <trans-unit id="4ac745d6259187beaf5143c3a366b5e962516e92" translate="yes" xml:space="preserve">
          <source>Docker isn't a virtualization methodology. It relies on other tools that actually implement container-based virtualization or operating system level virtualization. For that, Docker was initially using LXC driver, then moved to libcontainer which is now renamed as runc. Docker primarily focuses on automating the deployment of applications inside application containers. Application containers are designed to package and run a single service, whereas system containers are designed to run multiple processes, like virtual machines. So, Docker is considered as a container management or application deployment tool on containerized systems.</source>
          <target state="translated">Docker并不是一种虚拟化方法论。它依赖于其他工具,真正实现基于容器的虚拟化或操作系统级别的虚拟化。为此,Docker最初使用的是LXC驱动,后来转到libcontainer,现在已经改名为runc。Docker主要专注于在应用容器内实现应用的自动化部署。应用容器是为了打包和运行单一服务而设计的,而系统容器则是为了运行多个进程,比如虚拟机。所以,Docker被认为是作为容器管理或应用部署工具在容器化系统中的容器管理或应用部署工具。</target>
        </trans-unit>
        <trans-unit id="50c82cb7fe6266a82e2fb9c3452a93b0098b144f" translate="yes" xml:space="preserve">
          <source>Docker originally used &lt;a href=&quot;https://linuxcontainers.org/lxc/&quot;&gt;LinuX Containers&lt;/a&gt; (LXC), but later switched to &lt;a href=&quot;https://github.com/opencontainers/runc&quot;&gt;runC&lt;/a&gt; (formerly known as &lt;strong&gt;libcontainer&lt;/strong&gt;), which runs in the same operating system as its host. This allows it to share a lot of the host operating system resources. Also, it uses a layered filesystem (&lt;a href=&quot;http://aufs.sourceforge.net/&quot;&gt;AuFS&lt;/a&gt;) and manages networking.</source>
          <target state="translated">Docker最初使用&lt;a href=&quot;https://linuxcontainers.org/lxc/&quot;&gt;LinuX容器&lt;/a&gt; （LXC），但后来切换到了&lt;a href=&quot;https://github.com/opencontainers/runc&quot;&gt;runC&lt;/a&gt; （以前称为&lt;strong&gt;libcontainer&lt;/strong&gt; ），后者与主机运行在相同的操作系统中。 这使它可以共享许多主机操作系统资源。 此外，它使用分层文件系统（ &lt;a href=&quot;http://aufs.sourceforge.net/&quot;&gt;AuFS&lt;/a&gt; ）并管理网络。</target>
        </trans-unit>
        <trans-unit id="41fa7729ec5381ee8638f255f1cb4f7a87c60789" translate="yes" xml:space="preserve">
          <source>Docker uses &lt;strong&gt;UNION File system&lt;/strong&gt; .. Docker uses a copy-on-write technology to reduce the memory space consumed by containers. &lt;a href=&quot;https://medium.com/@nagarwal/docker-containers-filesystem-demystified-b6ed8112a04a&quot;&gt;Read more here&lt;/a&gt;</source>
          <target state="translated">Docker使用&lt;strong&gt;UNION File&lt;/strong&gt; system。Docker使用写时复制技术来减少容器占用的内存空间。 &lt;a href=&quot;https://medium.com/@nagarwal/docker-containers-filesystem-demystified-b6ed8112a04a&quot;&gt;在这里阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7a3c15391c182ccba309a3b738b4b90db0a222a" translate="yes" xml:space="preserve">
          <source>Docker, basically containers, supports &lt;strong&gt;OS virtualization&lt;/strong&gt; i.e. your application feels that it has a complete instance of an OS whereas VM supports &lt;strong&gt;hardware virtualization&lt;/strong&gt;. You feel like it is a physical machine in which you can boot any OS.</source>
          <target state="translated">Docker基本上是容器，它支持&lt;strong&gt;OS虚拟化，&lt;/strong&gt;即您的应用程序感觉它具有OS的完整实例，而VM支持&lt;strong&gt;硬件虚拟化&lt;/strong&gt; 。 您会觉得这是一台可以在其中引导任何OS的物理机。</target>
        </trans-unit>
        <trans-unit id="d01409177152f353bc55c371b17b74ce19db744e" translate="yes" xml:space="preserve">
          <source>Docker/LXC can almost be run on any cheap hardware (less than 1&amp;nbsp;GB of memory is also OK as long as you have newer kernel) vs. normal VMs need at least 2&amp;nbsp;GB of memory, etc., to do anything meaningful with it. But Docker support on the host OS is not available in OS such as Windows (as of Nov 2014) where as may types of VMs can be run on windows, Linux, and Macs.</source>
          <target state="translated">Docker / LXC几乎可以在任何便宜的硬件上运行（只要您有较新的内核，少于1 GB的内存也是可以的），而普通VM至少需要2 GB的内存等，以便对其进行有意义的操作。 但是在Windows之类的操作系统（截至2014年11月）中，主机操作系统上的Docker支持不可用，其中可能在Windows，Linux和Mac上运行多种类型的VM。</target>
        </trans-unit>
        <trans-unit id="ebfbe47546638c4d6b8bdeb4c1ec1c246b7d5294" translate="yes" xml:space="preserve">
          <source>Easy to backup and migrate</source>
          <target state="translated">易于备份和迁移</target>
        </trans-unit>
        <trans-unit id="0c1056b52b083ad21229bce5ba26be5a9f188426" translate="yes" xml:space="preserve">
          <source>Easy to migrate</source>
          <target state="translated">易于迁移</target>
        </trans-unit>
        <trans-unit id="eb1268b1c2d91c12e10a36edb55ad7aef75453d5" translate="yes" xml:space="preserve">
          <source>Easy to scale</source>
          <target state="translated">便于缩放</target>
        </trans-unit>
        <trans-unit id="3a0cc42ee3658aa395a2138d4f579703ec830c67" translate="yes" xml:space="preserve">
          <source>Emulation</source>
          <target state="translated">Emulation</target>
        </trans-unit>
        <trans-unit id="3dd6632b998842cf74b5b1b92cd5f5820e9f7c7a" translate="yes" xml:space="preserve">
          <source>Emulation, also known as full virtualization runs the virtual machine OS kernel entirely in software. The hypervisor used in this type is known as Type 2 hypervisor. It is installed on the top of the host operating system which is responsible for translating guest OS kernel code to software instructions. The translation is done entirely in software and requires no hardware involvement. Emulation makes it possible to run any non-modified operating system that supports the environment being emulated.  The downside of this type of virtualization is an additional system resource overhead that leads to a decrease in performance compared to other types of virtualizations.</source>
          <target state="translated">仿真,也称为完全虚拟化,完全在软件中运行虚拟机操作系统内核。这种类型中使用的管理程序被称为2型管理程序。它安装在主机操作系统的顶部,负责将客机操作系统内核代码翻译成软件指令。这个翻译完全是在软件中完成的,不需要硬件的参与。仿真使它可以运行任何支持被仿真环境的非修改的操作系统。这种类型的虚拟化的缺点是额外的系统资源开销,与其他类型的虚拟化相比,导致性能下降。</target>
        </trans-unit>
        <trans-unit id="ebd505d115bab776dbdc74d1e0b12be11fd82172" translate="yes" xml:space="preserve">
          <source>Every container thinks that it&amp;rsquo;s running on its own copy of the operating system. It&amp;rsquo;s got its own file system, own registry, etc. which is a kind of a lie. It&amp;rsquo;s actually being virtualized.</source>
          <target state="translated">每个容器都认为它在自己的操作系统副本上运行。 它有自己的文件系统，自己的注册表等，这是一种谎言。 实际上是虚拟化的。</target>
        </trans-unit>
        <trans-unit id="831cc80cb718c03f5246360107237ef746f0d7b0" translate="yes" xml:space="preserve">
          <source>Examples in this category include VMware Player, VirtualBox, QEMU, Bochs, Parallels, etc.</source>
          <target state="translated">这个类别的例子包括VMware Player、VirtualBox、QEMU、Bochs、Parallels等。</target>
        </trans-unit>
        <trans-unit id="1ccb86e59e4fe3bd2ef073e88fbef7553e61cfd6" translate="yes" xml:space="preserve">
          <source>Examples in this category include Xen, KVM, etc.</source>
          <target state="translated">这一类的例子包括Xen、KVM等。</target>
        </trans-unit>
        <trans-unit id="06c824bd1974bf568c9573060edb42e84b34bdb2" translate="yes" xml:space="preserve">
          <source>Except for the kernel the patches and libraries are identical.</source>
          <target state="translated">除了内核之外,补丁和库都是一样的。</target>
        </trans-unit>
        <trans-unit id="b0a3481e61f709c1e0d790c0b774bd27b9d58b69" translate="yes" xml:space="preserve">
          <source>Expensive</source>
          <target state="translated">Expensive</target>
        </trans-unit>
        <trans-unit id="7619f9abbfa1d6d7042c32f920ff5830700c00a0" translate="yes" xml:space="preserve">
          <source>First, docker images are usually smaller than VM images, makes it easy to build, copy, share.</source>
          <target state="translated">首先,docker镜像通常比VM镜像更小,使得构建、复制、共享更容易。</target>
        </trans-unit>
        <trans-unit id="1ef8e6da45d2dd081d16f57b855fc793cd8acd72" translate="yes" xml:space="preserve">
          <source>Flexibility</source>
          <target state="translated">Flexibility</target>
        </trans-unit>
        <trans-unit id="f074c945bdbec9e8558ac4215dcfd8927703d79f" translate="yes" xml:space="preserve">
          <source>For container-based virtualization, no additional software is required, unlike other virtualizations.</source>
          <target state="translated">对于基于容器的虚拟化,与其他虚拟化不同,不需要额外的软件。</target>
        </trans-unit>
        <trans-unit id="cca4ac54f6253ba97d3664e73ad0e4adc922b5c9" translate="yes" xml:space="preserve">
          <source>For doing that, I downloaded configured Docker containers for zookeeper, kafka, Prometheus, Grafana and jmx-collector then mounted my own configuration for some of them using YAML files, or for others, I changed some files and configuration in the Docker container and I build a whole system for monitoring kafka using multi-container Dockers on a single machine with isolation and scalability and resiliency that this architecture can be easily moved into multiple servers.</source>
          <target state="translated">为此,我为zookeeper、kafka、Prometheus、Grafana和jmx-collector下载了配置好的Docker容器,然后用YAML文件挂载了其中的一些配置,或者对其他的配置,我在Docker容器中修改了一些文件和配置,我在单机上使用多容器Docker构建了一个监控kafka的整个系统,具有隔离性和可扩展性以及弹性,这种架构可以很容易地转移到多个服务器上。</target>
        </trans-unit>
        <trans-unit id="a16d59c76a3c563866745fba874d4ab0bc26bd0d" translate="yes" xml:space="preserve">
          <source>For example, if you develop a web server that runs on port 4000, when you deploy it to your &quot;testing&quot; environment, that port is already used by some other program, so it stops working. In containers there are layers; all the changes you have made to the OS would be saved in one or more layers and those layers would be part of image, so wherever the image goes the dependencies would be present as well.</source>
          <target state="translated">例如,如果你开发了一个在4000端口上运行的Web服务器,当你把它部署到你的 &quot;测试 &quot;环境中时,这个端口已经被其他程序使用,所以它就停止工作了。在容器中,有层;你对操作系统的所有改动都会被保存在一个或多个层中,而这些层也是映像的一部分,所以无论映像到哪里,依赖关系也会存在。</target>
        </trans-unit>
        <trans-unit id="8fd88484152d1d51a4c2b9238da4fbff000d9c47" translate="yes" xml:space="preserve">
          <source>For example, you can create a Docker image and configure a DockerFile and tell that for example when it is running then wget 'this', apt-get 'that', run 'some shell script', setting environment variables and so on.</source>
          <target state="translated">例如,你可以创建一个Docker镜像,并配置一个DockerFile,并告诉,例如当它运行时,然后wget'this',apt-get'that',运行'一些shell脚本',设置环境变量等等。</target>
        </trans-unit>
        <trans-unit id="35ccf43916b47b800017e7e72b2ae9d3454e3634" translate="yes" xml:space="preserve">
          <source>For me the fundamental difference between VMs and Docker is how you manage the promotion of your application.</source>
          <target state="translated">对我来说,VM和Docker的根本区别在于你如何管理应用的推广。</target>
        </trans-unit>
        <trans-unit id="776e7b08ef6cc416f71526ab137e5b888e2ab3f4" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;http://web.archive.org/web/20150326185901/http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part&quot;&gt;this set of blog posts&lt;/a&gt; which do a good job of explaining how LXC works.</source>
          <target state="translated">有关更多信息，请查看&lt;a href=&quot;http://web.archive.org/web/20150326185901/http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part&quot;&gt;这组博客文章&lt;/a&gt; ，它们可以很好地解释LXC的工作原理。</target>
        </trans-unit>
        <trans-unit id="207193724c4e247fd644cf605f559f47a466119b" translate="yes" xml:space="preserve">
          <source>From comments...</source>
          <target state="translated">从评论中.....</target>
        </trans-unit>
        <trans-unit id="b06a12c7f453ec1b3e1d2a287db5fb38b0d6cf5d" translate="yes" xml:space="preserve">
          <source>Good answers. Just to get an image representation of container vs VM, have a look at the one below.</source>
          <target state="translated">很好的答案。只是想了解一下容器与虚拟机的形象代表,看一下下面这个。</target>
        </trans-unit>
        <trans-unit id="8e3f53c59ab99fe6412b74f105c5c18faeaa1818" translate="yes" xml:space="preserve">
          <source>Good use of resources</source>
          <target state="translated">善用资源</target>
        </trans-unit>
        <trans-unit id="08a92012d1091230dec3a68bf46755967d46a604" translate="yes" xml:space="preserve">
          <source>Here is a pic from docker/rightscale :</source>
          <target state="translated">这里有一张来自dockerrightscale的图片。</target>
        </trans-unit>
        <trans-unit id="3fff53bba4a212150784b2d3bc45d5918d2667bb" translate="yes" xml:space="preserve">
          <source>How is Docker different from a virtual machine</source>
          <target state="translated">Docker和虚拟机有什么不同?</target>
        </trans-unit>
        <trans-unit id="01e97b6e84b72f7278d2e92841cdf0e0b3dea0d1" translate="yes" xml:space="preserve">
          <source>Hyper-v is the native hypervisor in Windows. They are also trying to leverage Windows 10's capabilities to run Linux systems natively.</source>
          <target state="translated">Hyper-v是Windows中的原生管理程序。他们也在尝试利用Windows 10的功能来原生运行Linux系统。</target>
        </trans-unit>
        <trans-unit id="a670e3e7b00b3a4ef5c8133d5ecd66b4bfeeef4d" translate="yes" xml:space="preserve">
          <source>I have used Docker in production environments and staging very much. When you get used to it you will find it very powerful for building a multi container and isolated environments.</source>
          <target state="translated">我在生产环境和暂存环境中使用Docker非常多。当你习惯了它,你会发现它在构建多容器和隔离环境时非常强大。</target>
        </trans-unit>
        <trans-unit id="efcbb2db7ed5cea3f886bf3b808eaf0e3defaa70" translate="yes" xml:space="preserve">
          <source>I keep rereading &lt;a href=&quot;https://docs.docker.com/&quot;&gt;the Docker documentation&lt;/a&gt; to try to understand the difference between Docker and a full VM. How does it manage to provide a full filesystem, isolated networking environment, etc. without being as heavy?</source>
          <target state="translated">我不断阅读&lt;a href=&quot;https://docs.docker.com/&quot;&gt;Docker文档，&lt;/a&gt;以尝试了解Docker和完整VM之间的区别。 它如何提供完整的文件系统，隔离的网络环境等而又不那么繁重？</target>
        </trans-unit>
        <trans-unit id="093768d5bf451d254a63bac21dc211f910523f56" translate="yes" xml:space="preserve">
          <source>I like Ken Cochrane's answer.</source>
          <target state="translated">我喜欢Ken Cochrane的回答。</target>
        </trans-unit>
        <trans-unit id="4bb2f313e29c46ff50d3965c64f2fe9b6022da18" translate="yes" xml:space="preserve">
          <source>I remember the first days of working with Docker when I issued the wrong commands or removing my containers and all of data and configurations mistakenly.</source>
          <target state="translated">我记得刚开始使用Docker工作的时候,我发出错误的命令或删除容器时,所有的数据和配置都是错误的。</target>
        </trans-unit>
        <trans-unit id="403c51801e9b7a0dc50d8fe7fa451ec8a190d37e" translate="yes" xml:space="preserve">
          <source>If all containers use Ubuntu as their base images, not every image has its own file system, but share the same underline ubuntu files, and only differs in their own application data.</source>
          <target state="translated">如果所有的容器都使用Ubuntu作为基础映像,那么不是每个映像都有自己的文件系统,而是共享相同的下划线ubuntu文件,只是在自己的应用数据上有所区别。</target>
        </trans-unit>
        <trans-unit id="c2cbe8ffc804cbfc335c751353c0f43e1aee5926" translate="yes" xml:space="preserve">
          <source>If containers are possible because of the features available in the Linux kernel, then the obvious question is how do non-Linux systems run containers. Both Docker for Mac and Windows use Linux VMs to run the containers. Docker Toolbox used to run containers in Virtual Box VMs. But, the latest Docker uses Hyper-V in Windows and Hypervisor.framework in Mac.</source>
          <target state="translated">如果因为Linux内核中的可用功能,容器是可能的,那么很明显的问题是,非Linux系统如何运行容器。Docker for Mac和Windows都是使用Linux VM来运行容器。Docker Toolbox过去是在Virtual Box VM中运行容器。但是,最新的Docker在Windows中使用Hyper-V,在Mac中使用Hypervisor.framework。</target>
        </trans-unit>
        <trans-unit id="bcd1a4739b8857179aa5e6b1af17202af30a8962" translate="yes" xml:space="preserve">
          <source>If you understand containers, you get what Docker is and how it's different from &lt;strong&gt;VM&lt;/strong&gt;s...</source>
          <target state="translated">如果您了解容器，那么您将了解Docker是什么以及它与&lt;strong&gt;VM&lt;/strong&gt;的区别...</target>
        </trans-unit>
        <trans-unit id="9a0091353dc39035f55d81e29dc485c96d1a5e17" translate="yes" xml:space="preserve">
          <source>In Docker, the containers running share the host OS kernel, whereas in VMs they have their own OS files. The environment (the OS) in which you develop an application would be same when you deploy it to various serving environments, such as &quot;testing&quot; or &quot;production&quot;.</source>
          <target state="translated">在Docker中,运行的容器共享主机操作系统内核,而在VM中,它们有自己的操作系统文件。当你把一个应用程序部署到不同的服务环境中,比如 &quot;测试 &quot;或 &quot;生产 &quot;时,你开发应用程序的环境(操作系统)是一样的。</target>
        </trans-unit>
        <trans-unit id="6deaafede88ba1c4b8741704f71788bd3ac121a1" translate="yes" xml:space="preserve">
          <source>In Virtualization, the resources are allocated in the beginning of set up and hence the resources are not fully utilized when the virtual machine is idle during many of the times. 
In Docker, the containers are not allocated with fixed amount of hardware resources and is free to use the resources depending on the requirements and hence it is highly scalable.</source>
          <target state="translated">在虚拟化中,资源是在设置之初就分配好的,因此当虚拟机在很多时候处于空闲状态时,资源并没有得到充分利用。在Docker中,容器没有固定数量的硬件资源分配,可以根据需求自由使用资源,因此具有很强的可扩展性。</target>
        </trans-unit>
        <trans-unit id="a36afb4e82e762415de7cc7df8fe48984cdb88af" translate="yes" xml:space="preserve">
          <source>In its conceived form, it was considered a method of logically dividing mainframes to allow multiple applications to run simultaneously. However, the scenario drastically changed when companies and open source communities were able to provide a method of handling the privileged instructions in one way or another and allow for multiple operating systems to be run simultaneously on a single x86 based system.</source>
          <target state="translated">在其设想的形式下,它被认为是一种逻辑上划分主机的方法,允许多个应用程序同时运行。然而,当公司和开源社区能够提供一种处理特权指令的方法,并允许在一个基于x86的系统上同时运行多个操作系统时,情况发生了巨大的变化。</target>
        </trans-unit>
        <trans-unit id="95a26c3741ab3acfcb8e62da771360a922f4e4a5" translate="yes" xml:space="preserve">
          <source>In micro-services projects and architecture Docker is a very viable asset. You can achieve scalability, resiliency and elasticity with Docker, Docker swarm, Kubernetes and Docker Compose.</source>
          <target state="translated">在微服务项目和架构中,Docker是一个非常可行的资产。你可以通过Docker、Docker swarm、Kubernetes和Docker Compose实现可扩展性、弹性和弹性。</target>
        </trans-unit>
        <trans-unit id="fd3d8676713c9b794181157ecb2b5681479e937a" translate="yes" xml:space="preserve">
          <source>In order to know how it is different from other virtualizations, let's go through virtualization and its types. Then, it would be easier to understand what's the difference there.</source>
          <target state="translated">为了知道它和其他虚拟化有什么不同,我们先来了解一下虚拟化及其类型。然后,就会更容易理解那里有什么区别了。</target>
        </trans-unit>
        <trans-unit id="7444a60831088da7523f35412aa42209e5751c6f" translate="yes" xml:space="preserve">
          <source>In relation to:-</source>
          <target state="translated">关于:-</target>
        </trans-unit>
        <trans-unit id="2c53360e73a433169fe66dad84215306aea76ab4" translate="yes" xml:space="preserve">
          <source>In the example shown below, the host machine has three VMs. In order to provide the applications in the VMs complete isolation, they each have their own copies of OS files, libraries and application code, along with a full in-memory instance of an OS. 
Whereas the figure below shows the same scenario with containers. Here, containers simply share the host operating system, including the kernel and libraries, so they don&amp;rsquo;t need to boot an OS, load libraries or pay a private memory cost for those files. The only incremental space they take is any memory and disk space necessary for the application to run in the container. While the application&amp;rsquo;s environment feels like a dedicated OS, the application deploys just like it would onto a dedicated host. The containerized application starts in seconds and many more instances of the application can fit onto the machine than in the VM case.</source>
          <target state="translated">在下面显示的示例中，主机具有三个VM。 为了使VM中的应用程序完全隔离，它们每个都有自己的OS文件，库和应用程序代码副本，以及OS的完整内存实例。 下图显示了使用容器的相同情况。 在这里，容器仅共享主机操作系统，包括内核和库，因此它们无需启动操作系统，加载库或为这些文件支付专用内存成本。 它们仅占用的增量空间是应用程序在容器中运行所需的任何内存和磁盘空间。 虽然应用程序的环境感觉像是专用的OS，但应用程序的部署就像在专用主机上一样。 容器化的应用程序在几秒钟内启动，与VM相比，该应用程序实例可以在计算机上安装的更多。</target>
        </trans-unit>
        <trans-unit id="0a02c937cff75730610767b134b6093b42b4a323" translate="yes" xml:space="preserve">
          <source>In this case VM manager takes over the CPU ring 0 (or the &quot;root mode&quot; in newer CPUs) and intercepts all privileged calls made by guest OS to create illusion that guest OS has its own hardware. Fun fact: Before 1998 it was thought to be impossible to achieve this in x86 architecture because there was no way to do this kind of interception. The folks at VMWare &lt;a href=&quot;http://web.archive.org/web/20160324005530/https://www.vmware.com/files/pdf/VMware_paravirtualization.pdf&quot;&gt;were the first&lt;/a&gt; who had an idea to rewrite the executable bytes in memory for privileged calls of guest OS to achieve this.</source>
          <target state="translated">在这种情况下，VM管理器将接管CPU环0（或较新的CPU中的&amp;ldquo;根模式&amp;rdquo;），并拦截来宾OS进行的所有特权调用，从而产生一种幻觉，即来宾OS具有自己的硬件。 有趣的事实：在1998年之前，人们认为在x86架构中不可能实现这一目标，因为没有办法进行这种拦截。 VMWare的&lt;a href=&quot;http://web.archive.org/web/20160324005530/https://www.vmware.com/files/pdf/VMware_paravirtualization.pdf&quot;&gt;人是第&lt;/a&gt;一个想到重写内存中的可执行字节以供来宾OS进行特权调用的想法的人。</target>
        </trans-unit>
        <trans-unit id="cd2aef3c71aeb2c97a66235336032b37b431c611" translate="yes" xml:space="preserve">
          <source>In this context the VM is called as the Guest while the environment it runs on is called the host.</source>
          <target state="translated">在这种情况下,虚拟机被称为Guest,而它所运行的环境被称为主机。</target>
        </trans-unit>
        <trans-unit id="82a4c2503fc2e5f7a632dc3f96dfb783c40b9f38" translate="yes" xml:space="preserve">
          <source>Individual developer PC(s)</source>
          <target state="translated">个人开发者电脑</target>
        </trans-unit>
        <trans-unit id="27fc6b21a62b9c0827a8225ea34de499da6cbcef" translate="yes" xml:space="preserve">
          <source>Individual tester PC(s)</source>
          <target state="translated">个别测试仪</target>
        </trans-unit>
        <trans-unit id="b56d385feffaad558cd2b71a3f57768499156008" translate="yes" xml:space="preserve">
          <source>Interesting! I suppose I'm still confused by the notion of &quot;snapshot[ting] the OS&quot;. How does one do that without, well, making an image of the OS?</source>
          <target state="translated">有意思!我想我还是对 &quot;快照操作系统 &quot;这个概念感到困惑。我想我还是对 &quot;快照操作系统 &quot;这个概念感到困惑。如果不制作操作系统的图像,如何做到这一点呢?</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="6517c7a6e6193973c0f8ab38bf987e800ec76e5b" translate="yes" xml:space="preserve">
          <source>It is not uncommon for multiple applications to share a VM. This requires managing configuration and dependencies for all the applications.</source>
          <target state="translated">多个应用程序共享一个虚拟机的情况并不少见。这需要管理所有应用程序的配置和依赖关系。</target>
        </trans-unit>
        <trans-unit id="53435c6c21589588f560d23914d042b67451eac0" translate="yes" xml:space="preserve">
          <source>It might be helpful to understand how virtualization and containers work at low level. That will clear up lot of things.</source>
          <target state="translated">了解虚拟化和容器是如何在低层工作的,这可能会有帮助。这将澄清很多事情。</target>
        </trans-unit>
        <trans-unit id="f5fddae4874740f164d9fcc188953498de0b99dc" translate="yes" xml:space="preserve">
          <source>It transforms how services are delivered. We want applications, but have to maintain VMs(which is a pain and has little to do with our applications). Docker makes you focus on applications and smooths everything.</source>
          <target state="translated">它改变了服务的交付方式。我们想要应用,但又不得不维护VM(这很痛苦,与我们的应用关系不大)。Docker让你专注于应用,让一切变得更加顺畅。</target>
        </trans-unit>
        <trans-unit id="7e704fdab84afa725450d8c5989d78446095b4fa" translate="yes" xml:space="preserve">
          <source>Lightweight</source>
          <target state="translated">Lightweight</target>
        </trans-unit>
        <trans-unit id="9c36a1882d9df03003965a7776f2968d11b22b1d" translate="yes" xml:space="preserve">
          <source>Linux Containers (LXC) are operating system-level capabilities that make it possible to run multiple isolated Linux containers, on one control host (the LXC host). Linux Containers serve as a lightweight alternative to VMs as they don&amp;rsquo;t require the hypervisors viz. Virtualbox, KVM, Xen, etc.</source>
          <target state="translated">Linux容器（LXC）是操作系统级别的功能，可以在一个控制主机（LXC主机）上运行多个隔离的Linux容器。 Linux容器不需要VM虚拟机监控程序，因此可以作为VM的轻型替代方案。 Virtualbox，KVM，Xen等</target>
        </trans-unit>
        <trans-unit id="5a7b9cdeda076b8b5cdbf26437184f641208efe6" translate="yes" xml:space="preserve">
          <source>Live staging</source>
          <target state="translated">现场分期</target>
        </trans-unit>
        <trans-unit id="093da4223ce1c3507aba3a3ccde4d3735447aaff" translate="yes" xml:space="preserve">
          <source>Load / performance testing</source>
          <target state="translated">负载性能测试</target>
        </trans-unit>
        <trans-unit id="3105c333e001f39668ce814586d31eef54a76c34" translate="yes" xml:space="preserve">
          <source>Low overhead</source>
          <target state="translated">低开销</target>
        </trans-unit>
        <trans-unit id="af2e2a00277338f6ad4722a9a32d84ecb974e9e9" translate="yes" xml:space="preserve">
          <source>Many production environments will have cloud-based servers dynamically (or 'elastically') created and destroyed depending on traffic levels</source>
          <target state="translated">许多生产环境将根据流量水平动态地(或 &quot;弹性地&quot;)创建和销毁基于云计算的服务器。</target>
        </trans-unit>
        <trans-unit id="13266882dcd8e5ddad5d2a8b2d17cb63fe5b62a8" translate="yes" xml:space="preserve">
          <source>Mirror production and development environment</source>
          <target state="translated">镜像生产和开发环境</target>
        </trans-unit>
        <trans-unit id="9c4e706d04054700b966e6ff5969974a660024f7" translate="yes" xml:space="preserve">
          <source>Most of the answers here talk about virtual machines. I'm going to give you a one-liner response to this question that has helped me the most over the last couple years of using Docker. It's this:</source>
          <target state="translated">这里大部分的回答都是在谈虚拟机。下面我就给大家一个单行的回答,这个问题在过去几年的使用Docker的过程中,对我帮助最大的就是这个问题。是这样的。</target>
        </trans-unit>
        <trans-unit id="e30e5ce298639ebdf7ed418d577fdba1453de3e9" translate="yes" xml:space="preserve">
          <source>Most software is deployed to many environments, typically a minimum of three of the following:</source>
          <target state="translated">大多数软件部署在许多环境中,通常至少要有以下三种情况:</target>
        </trans-unit>
        <trans-unit id="b938883ea89a8af2b42e1f7fa1fcb02625173674" translate="yes" xml:space="preserve">
          <source>Namespaces can be used in many different ways, but the most common approach is to create an isolated container that has no visibility or access to objects outside the container. Processes running inside the container appear to be running on a normal Linux system although they are sharing the underlying kernel with processes located in other namespaces, same for other kinds of objects. For instance, when using namespaces, the root user inside the container is not treated as root outside the container, adding additional security.</source>
          <target state="translated">命名空间可以用许多不同的方式来使用,但最常见的方法是创建一个孤立的容器,它没有可见性,也不能访问容器外的对象。容器内运行的进程似乎是在正常的Linux系统中运行,尽管它们与位于其他命名空间中的进程共享底层内核,其他类型的对象也是如此。例如,在使用命名空间时,容器内的根用户在容器外不被视为根用户,这就增加了额外的安全性。</target>
        </trans-unit>
        <trans-unit id="2c18158689f952c79b7e5a35cdb844ea37ad2a0c" translate="yes" xml:space="preserve">
          <source>Networking and security issues.</source>
          <target state="translated">联网和安全问题。</target>
        </trans-unit>
        <trans-unit id="09a3a2ea2407302c3e099a5cfd61ce10c643c0b2" translate="yes" xml:space="preserve">
          <source>Networking in Docker is achieved by using an ethernet bridge (called &lt;code&gt;docker0&lt;/code&gt; on the host), and virtual interfaces for every container on the host. It creates a virtual subnet in &lt;code&gt;docker0&lt;/code&gt; for your containers to communicate &quot;between&quot; one another. There are many options for networking here, including creating custom subnets for your containers, and the ability to &quot;share&quot; your host's networking stack for your container to access directly.</source>
          <target state="translated">Docker中的网络是通过使用以太网桥（主机上称为 &lt;code&gt;docker0&lt;/code&gt; ）和主机上每个容器的虚拟接口来实现的。 它将在 &lt;code&gt;docker0&lt;/code&gt; 中创建一个虚拟子网， 以使您的容器彼此之间&amp;ldquo;相互通信&amp;rdquo;。 这里有许多用于联网的选项，包括为容器创建自定义子网，以及&amp;ldquo;共享&amp;rdquo;主机的网络堆栈以供容器直接访问的功能。</target>
        </trans-unit>
        <trans-unit id="a0a854b60507a34251037996f11a19fa6b85b4fc" translate="yes" xml:space="preserve">
          <source>Note: I'm simplifying a bit in describing below. See references for more information.</source>
          <target state="translated">注:下面我在描述时稍微简化了一下。详情请看参考资料。</target>
        </trans-unit>
        <trans-unit id="e227acd21027a7bfb5a25200ef887511d8c3044f" translate="yes" xml:space="preserve">
          <source>Note: Learning Docker in the first place seems complex and hard, but when you get used to it then you can not work without it.</source>
          <target state="translated">注意:一开始学习Docker似乎很复杂,也很难,但是当你习惯了之后,你就会发现没有Docker是无法工作的。</target>
        </trans-unit>
        <trans-unit id="0b35f91a80d652f56b4de5cd1f0c19e887566e0f" translate="yes" xml:space="preserve">
          <source>Now unless you were drugged by Alan (Zach Galifianakis- from the Hangover series) and have been in Vegas for the last year, you will be pretty aware about the tremendous spurt of interest for Linux containers technology, and if I will be specific one container project which has created a buzz around the world in last few months is &amp;ndash; Docker leading to some echoing opinions that cloud computing environments should abandon virtual machines (VMs) and replace them with containers due to their lower overhead and potentially better performance.</source>
          <target state="translated">现在，除非您被Alan（来自Hangover系列的Zach Galifianakis）迷住了，并且去年去过拉斯维加斯，否则您将非常清楚Linux容器技术的巨大兴趣，如果我要专门介绍一个容器过去几个月在全球引起轰动的项目是&amp;ndash; Docker引起了一些共鸣的观点，即云计算环境应该放弃虚拟机（VM），而用容器代替它们，因为它们的开销较低且可能具有更好的性能。</target>
        </trans-unit>
        <trans-unit id="1cc4dd6084579a024d65281292fa705d78118079" translate="yes" xml:space="preserve">
          <source>Now, let me describe how Docker for Mac runs containers in detail.</source>
          <target state="translated">现在,让我详细介绍一下Docker for Mac如何运行容器。</target>
        </trans-unit>
        <trans-unit id="d95736c0ea29fafbe8447df33be6ba007df4db2e" translate="yes" xml:space="preserve">
          <source>Now, let me explain a bit more about what that means. Virtual machines are their own beast. I feel like explaining what &lt;em&gt;Docker&lt;/em&gt; is will help you understand this more than explaining what a virtual machine is. Especially because there are many fine answers here telling you exactly what someone means when they say &quot;virtual machine&quot;. So...</source>
          <target state="translated">现在，让我解释一下这意味着什么。 虚拟机是他们自己的野兽。 我想解释&lt;em&gt;Docker&lt;/em&gt;是什么，而不是解释虚拟机是什么，它可以帮助您更多地了解这一点。 尤其是因为这里有许多很好的答案，可以准确地告诉您某人说&amp;ldquo;虚拟机&amp;rdquo;时的意思。 所以...</target>
        </trans-unit>
        <trans-unit id="f9c01df341a52960ca7d89828bb10132f64f1861" translate="yes" xml:space="preserve">
          <source>Now, we can even check the Kernel version of this VM:</source>
          <target state="translated">现在,我们甚至可以检查这个VM的内核版本。</target>
        </trans-unit>
        <trans-unit id="da8e0058a0738225418564045636c65cb055e65e" translate="yes" xml:space="preserve">
          <source>Often these VM's will have different patches and libraries.</source>
          <target state="translated">通常情况下,这些VM会有不同的补丁和库。</target>
        </trans-unit>
        <trans-unit id="e71ee38b37eca2eb89212fc31c65b9278bf446b5" translate="yes" xml:space="preserve">
          <source>One important difference is that &lt;strong&gt;VMs use a separate kernel to run the OS&lt;/strong&gt;. That's the reason it is heavy and takes time to boot, consuming more system resources.</source>
          <target state="translated">一个重要的区别是&lt;strong&gt;VM使用单独的内核来运行OS&lt;/strong&gt; 。 这就是它很重的原因，并且需要花费一些时间来启动，从而消耗更多的系统资源。</target>
        </trans-unit>
        <trans-unit id="7a8dd4987551f233b360a5fc92cb1bb1746b7917" translate="yes" xml:space="preserve">
          <source>Paravirtualization</source>
          <target state="translated">Paravirtualization</target>
        </trans-unit>
        <trans-unit id="adce3fd9cada4bbcbaf7cc96e519bf01a1c74244" translate="yes" xml:space="preserve">
          <source>Paravirtualization, also known as Type 1 hypervisor, runs directly on the hardware, or &amp;ldquo;bare-metal&amp;rdquo;, and provides virtualization services directly to the virtual machines running on it. It helps the operating system, the virtualized hardware, and the real hardware to collaborate to achieve optimal performance. These hypervisors typically have a rather small footprint and do not, themselves, require extensive resources.</source>
          <target state="translated">半虚拟化也称为Type 1虚拟机管理程序，直接在硬件或&amp;ldquo;裸机&amp;rdquo;上运行，并直接向其上运行的虚拟机提供虚拟化服务。 它可以帮助操作系统，虚拟化硬件和实际硬件进行协作以实现最佳性能。 这些虚拟机管理程序通常占用的资源很小，它们本身并不需要大量的资源。</target>
        </trans-unit>
        <trans-unit id="df70fc7991d3f1476ee9b62f9991c5a0f2c589e0" translate="yes" xml:space="preserve">
          <source>Production</source>
          <target state="translated">Production</target>
        </trans-unit>
        <trans-unit id="5967e86a2955722a7f8ed81334c26c41f18d6224" translate="yes" xml:space="preserve">
          <source>QA environment</source>
          <target state="translated">QA环境</target>
        </trans-unit>
        <trans-unit id="0c9cc3ad60910561ffeb418bc8d54f5af0b9a011" translate="yes" xml:space="preserve">
          <source>Resource allocation is problematic</source>
          <target state="translated">资源分配有问题</target>
        </trans-unit>
        <trans-unit id="77c420eb32b9c8491f76038181f5b86a3e24e538" translate="yes" xml:space="preserve">
          <source>Resource effective</source>
          <target state="translated">有效资源</target>
        </trans-unit>
        <trans-unit id="608c40f49e84a55f3c9bf3ec53b700f446d8db26" translate="yes" xml:space="preserve">
          <source>Resource heavy apps</source>
          <target state="translated">资源密集型应用</target>
        </trans-unit>
        <trans-unit id="116306d52eca48b72c61412f9a8a3bf366f2ef97" translate="yes" xml:space="preserve">
          <source>Resource management in containers is achieved through cgroups. Cgroups does not allow containers to consume more resources than allocated to them. However, as of now, all resources of host machine are visible in virtual machines, but can't be used. This can be realized by running &lt;code&gt;top&lt;/code&gt; or &lt;code&gt;htop&lt;/code&gt; on containers and host machine at the same time. The output across all environments will look similar.</source>
          <target state="translated">容器中的资源管理是通过cgroups实现的。 Cgroup不允许容器消耗比分配给它们更多的资源。 但是，到目前为止，主机的所有资源在虚拟机中都是可见的，但无法使用。 这可以通过在容器和主机上同时运行 &lt;code&gt;top&lt;/code&gt; 或 &lt;code&gt;htop&lt;/code&gt; 来实现。 在所有环境中的输出将看起来相似。</target>
        </trans-unit>
        <trans-unit id="6b18033d6dea5b85354c3d03959788e129270bf4" translate="yes" xml:space="preserve">
          <source>Same Architecture</source>
          <target state="translated">相同的结构</target>
        </trans-unit>
        <trans-unit id="46a5925b85bd943c275f26f441853ee795bed5f3" translate="yes" xml:space="preserve">
          <source>Second, Docker containers can start in several milliseconds, while VM starts in seconds.</source>
          <target state="translated">其次,Docker容器可以在几毫秒内启动,而VM的启动时间是几秒钟。</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="e4ebdf5ee0ef67069c239e4fb3c830a512c382fb" translate="yes" xml:space="preserve">
          <source>Several management tools are available for Linux containers, including LXC, LXD, systemd-nspawn, lmctfy, Warden, Linux-VServer, OpenVZ, Docker, etc.</source>
          <target state="translated">Linux容器的管理工具有多种,包括LXC、LXD、systemd-nspawn、lmctfy、Warden、Linux-VServer、OpenVZ、Docker等。</target>
        </trans-unit>
        <trans-unit id="570ab3452aa5a143cf20e06ea321480b66db25c3" translate="yes" xml:space="preserve">
          <source>Shared developer environment</source>
          <target state="translated">共享的开发环境</target>
        </trans-unit>
        <trans-unit id="61bedc66f5a3328063134c8ea3e6e152aaef9029" translate="yes" xml:space="preserve">
          <source>Shared test environment</source>
          <target state="translated">共享测试环境</target>
        </trans-unit>
        <trans-unit id="7354636285d06d12dea48164a79d3d742fc7c195" translate="yes" xml:space="preserve">
          <source>Since container-based virtualization adds little or no overhead to the host machine, container-based virtualization has near-native performance</source>
          <target state="translated">由于基于容器的虚拟化几乎不会给主机增加任何开销,因此基于容器的虚拟化具有近乎原生的性能。</target>
        </trans-unit>
        <trans-unit id="8b693b9c5091d8989c71e9ec8d579006be287551" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;Docker&lt;/strong&gt; is container based, meaning you have images and containers which can be run on your current machine. It's not including the operating system like &lt;strong&gt;VM&lt;/strong&gt;s, but like a pack of different working packs like Java, Tomcat, etc.</source>
          <target state="translated">因此， &lt;strong&gt;Docker&lt;/strong&gt;基于容器，这意味着您拥有可以在当前计算机上运行的映像和容器。 它不包括像&lt;strong&gt;VM&lt;/strong&gt;这样的操作系统，而是像一堆不同的工作包，例如Java，Tomcat等。</target>
        </trans-unit>
        <trans-unit id="1f629b2b816b977719f8c2fb6bff1b98fcde405a" translate="yes" xml:space="preserve">
          <source>So as you see in the image below, each container has a separate pack and running on a single machine share that machine's operating system... They are secure and easy to ship...</source>
          <target state="translated">所以,正如你在下面的图片中看到的,每个集装箱都有一个独立的包装,并在一台机器上运行,共享该机器的操作系统。它们既安全又方便运输....。</target>
        </trans-unit>
        <trans-unit id="227609777cb955b8caea44cd8f88d923f1796181" translate="yes" xml:space="preserve">
          <source>So at the most fundamental level with VMs you promote the application and its dependencies as discrete components whereas with Docker you promote everything in one hit.</source>
          <target state="translated">因此,在最基本的层面上,对于虚拟机来说,你把应用和它的依赖关系作为离散组件来推广,而对于Docker来说,你把所有的东西都集中在一个个的打击中。</target>
        </trans-unit>
        <trans-unit id="ff915c53a18d5d8d6016816967896435630356c6" translate="yes" xml:space="preserve">
          <source>So the best approach is the cloud infrastructure providers should advocate an appropriate use of the VMs and LXC, as they are each suited to handle specific workloads and scenarios.</source>
          <target state="translated">所以,最好的办法是云计算基础设施提供商应该提倡合理使用VM和LXC,因为它们各自适合处理特定的工作负载和场景。</target>
        </trans-unit>
        <trans-unit id="08008913ec3ffaa51bf434648223231d2fc4660c" translate="yes" xml:space="preserve">
          <source>So there is a known pattern to avoid this, the so called &lt;strong&gt;&lt;a href=&quot;http://martinfowler.com/bliki/ImmutableServer.html&quot;&gt;immutable server&lt;/a&gt;&lt;/strong&gt;. But the immutable server pattern was not loved. Mostly because of the limitations of VMs that were used before Docker. Dealing with several gigabytes big images, moving those big images around, just to change some fields in the application, was very very laborious. Understandable...</source>
          <target state="translated">因此，有一种避免这种情况的已知模式，即所谓的&lt;strong&gt;&lt;a href=&quot;http://martinfowler.com/bliki/ImmutableServer.html&quot;&gt;不可变服务器&lt;/a&gt;&lt;/strong&gt; 。 但是不喜欢不变的服务器模式。 主要是由于Docker之前使用的VM的局限性。 处理几个千兆字节的大图像，移动这些大图像，只是为了更改应用程序中的某些字段，非常费力。 可以理解的...</target>
        </trans-unit>
        <trans-unit id="5c86260516f20093dca5e32f9125464a1baa7668" translate="yes" xml:space="preserve">
          <source>So think of your question more like this &lt;em&gt;&quot;Given the extreme difficulty of keeping all environments consistent, is it easier to deploying software to a docker image, even when taking the learning curve into account ?&quot;&lt;/em&gt;. I think you'll find the answer will invariably be &quot;yes&quot; - but there's only one way to find out, post this new question on Stack Overflow.</source>
          <target state="translated">因此，更像这样思考您的问题： &lt;em&gt;&amp;ldquo;考虑到保持所有环境一致的极端困难，即使考虑到学习曲线，将软件部署到Docker映像是否更容易？&amp;rdquo;&lt;/em&gt; 。 我认为您会发现答案总是&amp;ldquo;是&amp;rdquo;-但是只有一种方法可以找到答案，将这个新问题发布在Stack Overflow上。</target>
        </trans-unit>
        <trans-unit id="9326b586a7a12df9aff5d242d06b41b390d95f84" translate="yes" xml:space="preserve">
          <source>So, let's say you have a 1&amp;nbsp;GB container image; if you wanted to use a full VM, you would need to have 1&amp;nbsp;GB x number of VMs you want. With Docker and AuFS you can share the bulk of the 1&amp;nbsp;GB between all the containers and if you have 1000 containers you still might only have a little over 1&amp;nbsp;GB of space for the containers OS (assuming they are all running the same OS image).</source>
          <target state="translated">因此，假设您有一个1 GB的容器映像； 如果要使用完整的VM，则需要具有1 GB x所需数量的VM。 使用Docker和AuFS，您可以在所有容器之间共享1 GB的大部分空间；如果您有1000个容器，则容器OS的空间可能仍然只有1 GB以上（假设它们都运行相同的OS映像） 。</target>
        </trans-unit>
        <trans-unit id="c4b2519a746129c9e47ca0cef9cadb6c9f7e5df6" translate="yes" xml:space="preserve">
          <source>So, what's a container?</source>
          <target state="translated">那么,什么是集装箱?</target>
        </trans-unit>
        <trans-unit id="7845675b0fb1d13fc83e85f884c455a9662b5aca" translate="yes" xml:space="preserve">
          <source>Some environments will consist of a fixed number of multiple machines in a load balanced configuration</source>
          <target state="translated">有些环境将由固定数量的多台机器组成,在负载平衡配置中,多台机器的数量是固定的。</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="7f45e2789d413f8919ac75cdce2d0fbf3782d453" translate="yes" xml:space="preserve">
          <source>Source:  Kubernetes in Action.</source>
          <target state="translated">来源:《Kubernetes in Action》。Kubernetes in Action。</target>
        </trans-unit>
        <trans-unit id="17a6edd967825b56170eea6956f4662a04ce71a3" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&quot;&gt;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/&quot;&gt;https&lt;/a&gt; : //azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/</target>
        </trans-unit>
        <trans-unit id="bbcc415ac4b86e9e443eaba129d222639a5d0758" translate="yes" xml:space="preserve">
          <source>The Linux Control Groups (cgroups) subsystem, the next major component to enable container-based virtualization, is used to group processes and manage their aggregate resource consumption. It is commonly used to limit the memory and CPU consumption of containers.  Since a containerized Linux system has only one kernel and the kernel has full visibility into the containers, there is only one level of resource allocation and scheduling.</source>
          <target state="translated">Linux控制组(cgroups)子系统是实现基于容器虚拟化的下一个主要组件,用于对进程进行分组并管理其总资源消耗。它通常被用来限制容器的内存和CPU消耗。由于一个容器化的Linux系统只有一个内核,而且内核对容器有完全的可见性,因此只有一个级别的资源分配和调度。</target>
        </trans-unit>
        <trans-unit id="1ce96b44823b14e37c5df5e5f90416de0de743cb" translate="yes" xml:space="preserve">
          <source>The Linux VM that Docker runs in Mac is read-only. However, you can bash into it by running:</source>
          <target state="translated">Docker在Mac中运行的Linux VM是只读的。但是,你可以通过运行它来实现。</target>
        </trans-unit>
        <trans-unit id="5e43599638071b0ea790ce9862f106845b607e30" translate="yes" xml:space="preserve">
          <source>The concept of a container is made possible by the namespaces feature added to Linux kernel version 2.6.24. The container adds its ID to every process and adding new access control checks to every system call. It is accessed by the &lt;em&gt;clone()&lt;/em&gt; system call that allows creating separate instances of previously-global namespaces.</source>
          <target state="translated">通过添加到Linux内核版本2.6.24的名称空间功能，可以使容器的概念成为可能。 容器将其ID添加到每个进程，并将新的访问控制检查添加到每个系统调用。 它由&lt;em&gt;clone（）&lt;/em&gt;系统调用访问，该系统调用允许创建先前全局名称空间的单独实例。</target>
        </trans-unit>
        <trans-unit id="9f78c499ac4ec737f9afafb8130b0e54fbeb1e6b" translate="yes" xml:space="preserve">
          <source>The hypervisor handles creating the virtual environment on which the guest virtual machines operate. It supervises the guest systems and makes sure that resources are allocated to the guests as necessary. The hypervisor sits in between the physical machine and virtual machines and provides virtualization services to the virtual machines. To realize it, it intercepts the guest operating system operations on the virtual machines and emulates the operation on the host machine's operating system.</source>
          <target state="translated">Hypervisor负责创建虚拟环境,在此基础上运行客机虚拟机。它监督来宾系统,并确保必要时将资源分配给来宾。Hypervisor坐在物理机和虚拟机之间,为虚拟机提供虚拟化服务。为了实现它,它拦截虚拟机上的来宾操作系统的操作,并在主机的操作系统上进行仿真操作。</target>
        </trans-unit>
        <trans-unit id="5db2da245693c67f36d9159ddb40dedcbe69437d" translate="yes" xml:space="preserve">
          <source>The limitations of containers vs VM should be obvious now: You can't run completely different OS in containers like in VMs. However you &lt;em&gt;can&lt;/em&gt; run different distros of Linux because they do share the same kernel. The isolation level is not as strong as in VM. In fact, there was a way for &quot;guest&quot; container to take over host in early implementations. Also you can see that when you load new container, the entire new copy of OS doesn't start like it does in VM. All containers &lt;a href=&quot;https://stackoverflow.com/questions/25444099/why-docker-has-ability-to-run-different-linux-distribution&quot;&gt;share same kernel&lt;/a&gt;. This is why containers are light weight. Also unlike VM, you don't have to pre-allocate significant chunk of memory to containers because we are not running new copy of OS. This enables to run thousands of containers on one OS while sandboxing them which might not be possible to do if we were running separate copy of OS in its own VM.</source>
          <target state="translated">容器与VM的局限性现在应该很明显：您不能像VM中那样在容器中运行完全不同的OS。 但是，您&lt;em&gt;可以&lt;/em&gt;运行不同的Linux发行版，因为它们确实共享相同的内核。 隔离级别不如VM中强。 实际上，在早期的实现中，有一种&amp;ldquo;来宾&amp;rdquo;容器接管主机的方法。 您还可以看到，加载新容器时，操作系统的整个新副本不会像在VM中那样启动。 所有容器&lt;a href=&quot;https://stackoverflow.com/questions/25444099/why-docker-has-ability-to-run-different-linux-distribution&quot;&gt;共享相同的内核&lt;/a&gt; 。 这就是为什么容器重量轻的原因。 与VM不同的是，您不必为容器预先分配大量内存，因为我们没有运行新的OS副本。 这样一来，就可以在一个操作系统上运行数千个容器，同时对它们进行沙箱处理，如果我们在自己的VM中运行单独的OS副本，则可能无法做到。</target>
        </trans-unit>
        <trans-unit id="2d20ba5621c8e203d326e322bfc921c09b73e08c" translate="yes" xml:space="preserve">
          <source>The net effect is that virtualization allows you to run two completely different OS on same hardware. Each guest OS goes through all the process of bootstrapping, loading kernel etc. You can have very tight security, for example, guest OS can't get full access to host OS or other guests and mess things up.</source>
          <target state="translated">净效果是,虚拟化允许你在同一硬件上运行两个完全不同的操作系统。每个客座操作系统都要经历所有的启动、加载内核等过程。你可以有非常严格的安全性,比如说,客座操作系统不能完全访问主机操作系统或其他客座操作系统并把事情搞砸。</target>
        </trans-unit>
        <trans-unit id="f0f1a43bc5e4e52d6c576f48ac9f9fc0fe34ba83" translate="yes" xml:space="preserve">
          <source>The rapid development of virtualization technologies, primarily in cloud, has driven the use of virtualization further by allowing multiple virtual servers to be created on a single physical server with the help of hypervisors, such as Xen, VMware Player, KVM, etc., and incorporation of hardware support in commodity processors, such as Intel VT and AMD-V.</source>
          <target state="translated">虚拟化技术的快速发展,主要是在云计算领域,在Xen、VMware Player、KVM等管理程序的帮助下,在一台物理服务器上创建多个虚拟服务器,并在商品处理器中加入硬件支持,如Intel VT和AMD-V等,推动了虚拟化技术的进一步应用。</target>
        </trans-unit>
        <trans-unit id="e3ca9c66efd7b9b6e24c69bfb9517fc0ceb4f39e" translate="yes" xml:space="preserve">
          <source>The virtualization method can be categorized based on how it mimics hardware to a guest operating system and emulates a guest operating environment. Primarily, there are three types of virtualization:</source>
          <target state="translated">虚拟化的方法可以根据其如何模仿硬件到来宾操作系统,模拟来宾操作环境来进行分类。主要有三种类型的虚拟化方式。</target>
        </trans-unit>
        <trans-unit id="17d15b32708f824d9d732b4782c422545cf7355f" translate="yes" xml:space="preserve">
          <source>There are a lot of nice technical answers here that clearly discuss the differences between VMs and containers as well as the origins of Docker.</source>
          <target state="translated">这里有很多不错的技术答案,明确讨论了虚拟机和容器的区别以及Docker的起源。</target>
        </trans-unit>
        <trans-unit id="f210a60c1f7d3832db36975249cfff8562fb7e57" translate="yes" xml:space="preserve">
          <source>There are also the following factors to consider:</source>
          <target state="translated">还需要考虑以下因素:</target>
        </trans-unit>
        <trans-unit id="e2770cedf26cf0e5354ae03381bebad859035e4c" translate="yes" xml:space="preserve">
          <source>There are many answers which explain more detailed on the differences, but here is my very brief explanation.</source>
          <target state="translated">有很多答案都有详细的解释,但下面是我非常简单的解释。</target>
        </trans-unit>
        <trans-unit id="33c9370d40a8245a0298684bdaa2bd8a89c0e765" translate="yes" xml:space="preserve">
          <source>There are pros and cons for each type of virtualized system. If you want full isolation with guaranteed resources, a full VM is the way to go. If you just want to isolate processes from each other and want to run a ton of them on a reasonably sized host, then Docker/LXC/runC seems to be the way to go.</source>
          <target state="translated">每种类型的虚拟化系统都有其优点和缺点。如果你想在保证资源的情况下实现完全隔离,那么完整的虚拟机就是最好的选择。如果你只是想将进程相互隔离,并想在一个合理大小的主机上运行一吨的进程,那么DockerLXCrunC似乎是个不错的选择。</target>
        </trans-unit>
        <trans-unit id="195131b2f88fc1d6c353a7dfa429c08668a79774" translate="yes" xml:space="preserve">
          <source>There are some limitations to hypervisor.framework. Because of that Docker doesn't expose &lt;code&gt;docker0&lt;/code&gt; network interface in Mac. So, you can't access containers from the host. As of now, &lt;code&gt;docker0&lt;/code&gt; is only available inside the VM.</source>
          <target state="translated">hypervisor.framework有一些限制。 因此，Docker不会在Mac中公开 &lt;code&gt;docker0&lt;/code&gt; 网络接口。 因此，您无法从主机访问容器。 到目前为止， &lt;code&gt;docker0&lt;/code&gt; 仅在虚拟机内部可用。</target>
        </trans-unit>
        <trans-unit id="ed5a00b08e8dc5b45bb77295463740b58d4846f5" translate="yes" xml:space="preserve">
          <source>There are three different setups that providing a stack to run an application on (This will help us to recognize what a container is and what makes it so much powerful than other solutions):</source>
          <target state="translated">有三种不同的设置,提供一个堆栈来运行应用程序(这将帮助我们认识到什么是容器,以及它比其他解决方案更强大的原因)。</target>
        </trans-unit>
        <trans-unit id="57d7d07e5e5a197279c393db8c8a7bf936c4f254" translate="yes" xml:space="preserve">
          <source>They both are very different. Docker is lightweight and uses LXC/libcontainer (which relies on kernel namespacing and cgroups) and does not have machine/hardware emulation such as hypervisor, KVM. Xen which are heavy.</source>
          <target state="translated">它们都有很大的区别。Docker是轻量级的,使用LXClibcontainer(依赖内核命名间隔和cgroups),没有机器硬件仿真,如hypervisor、KVM。Xen这些都很重。</target>
        </trans-unit>
        <trans-unit id="e7721054f84b71ff4a04f7fe87da45240450c562" translate="yes" xml:space="preserve">
          <source>Think about application deployment. If we want to deploy a new software(service) or upgrade one, it is better to change the config files and processes instead of creating a new VM. Because Creating a VM with updated service, testing it(share between Dev &amp;amp; QA), deploying to production takes hours, even days. If anything goes wrong, you got to start again, wasting even more time. So, use configuration management tool(puppet, saltstack, chef etc.) to install new software, download new files is preferred.</source>
          <target state="translated">考虑一下应用程序部署。 如果我们要部署新软件（服务）或升级软件（服务），最好更改配置文件和流程，而不要创建新的VM。 因为创建具有更新服务的VM，对其进行测试（在Dev和QA之间共享），部署到生产需要数小时甚至数天的时间。 如果有任何问题，您必须重新开始，浪费更多时间。 因此，请使用配置管理工具（木偶，saltstack，chef等）来安装新软件，最好下载新文件。</target>
        </trans-unit>
        <trans-unit id="04b9cd989db4ab4d1dc8d3dcfd400f18f4b8c3ec" translate="yes" xml:space="preserve">
          <source>This all means that creating consistent environments in the first place is hard enough just because of sheer volume (even in a green field scenario), but &lt;strong&gt;keeping them consistent is all but impossible&lt;/strong&gt; given the high number of servers, addition of new servers (dynamically or manually), automatic updates from o/s vendors, anti-virus vendors, browser vendors and the like, manual software installs or configuration changes performed by developers or server technicians, etc. Let me repeat that - it's virtually (no pun intended) impossible to keep environments consistent (okay, for the purist, it can be done, but it involves a huge amount of time, effort and discipline, which is precisely why VMs and containers (e.g. Docker) were devised in the first place).</source>
          <target state="translated">这一切都意味着，仅仅因为数量庞大（即使在绿地场景中），首先要创建一致的环境也足够困难，但是鉴于服务器数量众多，添加新服务器（动态或动态）， &lt;strong&gt;保持一致是几乎不可能&lt;/strong&gt;的。手动），来自操作系统供应商，防病毒软件供应商，浏览器供应商等的自动更新，由开发人员或服务器技术人员执行的手动软件安装或配置更改等。让我重复一遍-实际上（不可能是双关语）保持环境一致（可以，对于纯粹主义者而言，这是可以做到的，但是它涉及大量的时间，精力和纪律，这正是为什么首先设计VM和容器（例如Docker）的原因）。</target>
        </trans-unit>
        <trans-unit id="ca19d7c471047ac8eb382f2e9dcc26820a0be902" translate="yes" xml:space="preserve">
          <source>This is a powerful feature where the base images are typically readonly and only when the container modifies something in the layer will it write something to read-write partition (a.k.a. copy on write). It also provides many other wrappers such as registry and versioning of images.</source>
          <target state="translated">这是一个强大的功能,在这里,基础映像通常是只读的,只有当容器修改层中的东西时,它才会把东西写到读写分区(又名写时复制)。它还提供了许多其他的封装器,比如注册表和图像的版本化。</target>
        </trans-unit>
        <trans-unit id="1317aef78ad8c3de842b2ef9be30259400a3f9ad" translate="yes" xml:space="preserve">
          <source>This is another key feature of Docker. Images have layers, and different images can share layers, make it even more space-saving and faster to build.</source>
          <target state="translated">这也是Docker的另一个重要特点。图片有图层,不同的图片可以共享图层,使其更加节省空间,构建速度更快。</target>
        </trans-unit>
        <trans-unit id="5310e23583447dfd453271c88af2f6fed24876c8" translate="yes" xml:space="preserve">
          <source>This is good for most cases(no extra OS kernel maintains) but can be a problem if strict isolations are necessary between containers.</source>
          <target state="translated">这对大多数情况下是很好的(不需要额外的操作系统内核维护),但如果容器之间需要严格的隔离,就会有问题。</target>
        </trans-unit>
        <trans-unit id="b171c2b5faed3f4d2aeebc48f92139a7b66526fa" translate="yes" xml:space="preserve">
          <source>This is great for testing; let's say you have thousands of tests that need to connect to a database, and each test needs a pristine copy of the database and will make changes to the data. The classic approach to this is to reset the database after every test either with custom code or with tools like &lt;a href=&quot;https://flywaydb.org/&quot;&gt;Flyway&lt;/a&gt; - this can be very time-consuming and means that tests must be run serially. However, with Docker you could create an image of your database and run up one instance per test, and then run all the tests in parallel since you know they will all be running against the same snapshot of the database. Since the tests are running in parallel and in Docker containers they could run all on the same box at the same time and should finish much faster. Try doing that with a full VM.</source>
          <target state="translated">这非常适合测试； 假设您有数千个需要连接到数据库的测试，并且每个测试都需要数据库的原始副本，并将对数据进行更改。 经典的方法是在每次测试后使用自定义代码或使用&lt;a href=&quot;https://flywaydb.org/&quot;&gt;Flyway之类的&lt;/a&gt;工具重置数据库-这可能非常耗时，并且意味着必须串行运行测试。 但是，使用Docker可以创建数据库的映像并为每个测试运行一个实例，然后并行运行所有测试，因为您知道它们将针对数据库的同一快照运行。 由于测试是在Docker容器中并行运行的，因此它们可以同时在同一盒子上运行，并且应该更快地完成。 尝试使用完整的VM进行操作。</target>
        </trans-unit>
        <trans-unit id="7d04a3f43a0c2b52ecde6a7b7f97a221a6a3bf98" translate="yes" xml:space="preserve">
          <source>This is how &lt;strong&gt;Docker&lt;/strong&gt; introduces itself:</source>
          <target state="translated">&lt;strong&gt;Docker&lt;/strong&gt;就是这样自我介绍的：</target>
        </trans-unit>
        <trans-unit id="7afd8335fea67bc51f7938e0f38757c976265b55" translate="yes" xml:space="preserve">
          <source>This is probably the first impression for many docker learners.</source>
          <target state="translated">这可能是很多docker学习者的第一印象。</target>
        </trans-unit>
        <trans-unit id="02c4ced0e5d01676f226fba6cc68700d33c41832" translate="yes" xml:space="preserve">
          <source>Through this post we are going to draw some lines of differences between VMs and LXCs. Let's first define them.</source>
          <target state="translated">通过这篇帖子,我们将划出VM和LXC的一些区别线。我们先来定义一下它们的区别。</target>
        </trans-unit>
        <trans-unit id="a15a4722078ffc617f05f86021440c12e51d4b45" translate="yes" xml:space="preserve">
          <source>To keep this in sync you'll start to use something like Puppet, &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_(software)&quot;&gt;Chef&lt;/a&gt; or your own provisioning scripts, unpublished rules and/or lot of documentation... In theory servers can run indefinitely, and be kept completely consistent and up to date. Practice fails to manage a server's configuration completely, so there is considerable scope for configuration drift, and unexpected changes to running servers.</source>
          <target state="translated">为了保持同步，您将开始使用Puppet， &lt;a href=&quot;https://en.wikipedia.org/wiki/Chef_(software)&quot;&gt;Chef&lt;/a&gt;或您自己的配置脚本，未发布的规则和/或大量文档等内容。理论上，服务器可以无限期地运行，并且可以保持完全一致和最新。 实践无法完全管理服务器的配置，因此存在很大的配置漂移范围以及正在运行的服务器的意外更改。</target>
        </trans-unit>
        <trans-unit id="e8ea3f21662e019eb1e5105bae6861333f3ab291" translate="yes" xml:space="preserve">
          <source>To me it fits in the gap between developer-oriented tools like rpm, &lt;a href=&quot;http://en.wikipedia.org/wiki/Debian&quot;&gt;Debian&lt;/a&gt; packages, &lt;a href=&quot;http://en.wikipedia.org/wiki/Apache_Maven&quot;&gt;Maven&lt;/a&gt;, npm + Git on one side and ops tools like &lt;a href=&quot;http://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt;, VMware, Xen, you name it...</source>
          <target state="translated">对我来说，它适合一方面面向rpm， &lt;a href=&quot;http://en.wikipedia.org/wiki/Debian&quot;&gt;Debian&lt;/a&gt;软件包， &lt;a href=&quot;http://en.wikipedia.org/wiki/Apache_Maven&quot;&gt;Maven&lt;/a&gt; ，npm + Git等面向开发人员的工具与诸如&lt;a href=&quot;http://en.wikipedia.org/wiki/Puppet_%28software%29&quot;&gt;Puppet&lt;/a&gt; ，VMware，Xen之类的ops工具之间的鸿沟，您可以将其命名为...</target>
        </trans-unit>
        <trans-unit id="5889b10f645756a05ce05d3b6d6208500c002851" translate="yes" xml:space="preserve">
          <source>UAT environment</source>
          <target state="translated">UAT环境</target>
        </trans-unit>
        <trans-unit id="3181001e23737667962f1fc2a88fdb8fffabc3a6" translate="yes" xml:space="preserve">
          <source>Unlike a virtual machine, a container does not need to boot the operating system kernel, so containers can be created in less than a second. This feature makes container-based virtualization unique and desirable than other virtualization approaches.</source>
          <target state="translated">与虚拟机不同的是,容器不需要启动操作系统内核,所以容器可以在一秒钟内创建。这一特点使得基于容器的虚拟化比其他虚拟化方法更独特、更可取。</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="b0ebc020284774b80187ae89c024cbc009582af0" translate="yes" xml:space="preserve">
          <source>Utilization of raw resources</source>
          <target state="translated">原始资源的利用</target>
        </trans-unit>
        <trans-unit id="77b0430e1891dadfc3b08483480a6f1953f57349" translate="yes" xml:space="preserve">
          <source>Vendor lockin</source>
          <target state="translated">供应商锁定</target>
        </trans-unit>
        <trans-unit id="6bb2ba4c680f5e6a3053c09883389d034fc8f0ce" translate="yes" xml:space="preserve">
          <source>Very slow deployment time</source>
          <target state="translated">部署时间很慢</target>
        </trans-unit>
        <trans-unit id="3a92642eb344d1e06c9e86038a0d64c11c33d1fa" translate="yes" xml:space="preserve">
          <source>Wasted resources</source>
          <target state="translated">浪费资源</target>
        </trans-unit>
        <trans-unit id="bf8ef838532e25fda6b4e3a08fa9f32dcc1f7e04" translate="yes" xml:space="preserve">
          <source>Well, let's see if I can explain. You start with a base image, and then make your changes, and commit those changes using docker, and it creates an image. This image contains only the differences from the base. When you want to run your image, you also need the base, and it layers your image on top of the base using a layered file system: as mentioned above, Docker uses AuFS. AuFS merges the different layers together and you get what you want; you just need to run it. You can keep adding more and more images (layers) and it will continue to only save the diffs. Since Docker typically builds on top of ready-made images from a &lt;a href=&quot;https://registry.hub.docker.com/&quot;&gt;registry&lt;/a&gt;, you rarely have to &quot;snapshot&quot; the whole OS yourself.</source>
          <target state="translated">好吧，让我们看看是否可以解释。 您从基本映像开始，然后进行更改，然后使用docker提交这些更改，然后创建一个映像。 该图像仅包含与基准的差异。 当您要运行映像时，您还需要基础，它使用分层的文件系统在基础之上分层映像：如上所述，Docker使用AuFS。 AuFS将不同的层合并在一起，您将获得所需的内容。 您只需要运行它。 您可以继续添加越来越多的图像（图层），它将继续仅保存差异。 由于Docker通常基于&lt;a href=&quot;https://registry.hub.docker.com/&quot;&gt;注册表中&lt;/a&gt;的现成映像构建，因此您几乎不必自己&amp;ldquo;快照&amp;rdquo;整个操作系统。</target>
        </trans-unit>
        <trans-unit id="fad0b8f4568c8371bb2c483d1a404dc95e0c664a" translate="yes" xml:space="preserve">
          <source>What about memory, I/O, CPU, etc.? That is controlled using cgroups where you can create groups with certain resource (CPU, memory, etc.) specification/restriction and put your processes in there. On top of LXC, Docker provides a storage backend (&lt;a href=&quot;http://www.projectatomic.io/docs/filesystems/&quot;&gt;http://www.projectatomic.io/docs/filesystems/&lt;/a&gt;) e.g., union mount filesystem where you can add layers and share layers between different mount namespaces.</source>
          <target state="translated">内存，I / O，CPU等如何？ 这可以使用cgroups进行控制，在cgroups中，您可以创建具有特定资源（CPU，内存等）规范/限制的组，并将进程放入其中。 在LXC之上，Docker提供了一个存储后端（ &lt;a href=&quot;http://www.projectatomic.io/docs/filesystems/&quot;&gt;http://www.projectatomic.io/docs/filesystems/&lt;/a&gt; ），例如，联合安装文件系统，您可以在其中添加层并在不同的安装名称空间之间共享层。</target>
        </trans-unit>
        <trans-unit id="06378e98591d7039cf2647e79565650d0d5d78a4" translate="yes" xml:space="preserve">
          <source>When it comes to docker, it's impossible to use a newly created docker container to replace the old one. Maintainance is much easier!Building a new image, share it with QA, testing it, deploying it only takes minutes(if everything is automated), hours in the worst case. This is called &lt;strong&gt;immutable infrastructure&lt;/strong&gt;: do not maintain(upgrade) software, create a new one instead.</source>
          <target state="translated">当涉及到docker时，不可能使用新创建的docker容器来替换旧的Docker容器。 维护更加容易！构建新映像，与质量检查共享，进行测试，部署，只需几分钟（如果一切都是自动化的），在最坏的情况下只需几个小时。 这被称为&lt;strong&gt;不可变基础架构&lt;/strong&gt; ：不要维护（升级）软件，而是创建一个新的。</target>
        </trans-unit>
        <trans-unit id="0d6d6cf1b29e9134acdcff3a62facc67c9694493" translate="yes" xml:space="preserve">
          <source>Why is deploying software to a Docker image (if that's the right term) easier than simply deploying to a consistent production environment?</source>
          <target state="translated">为什么将软件部署到Docker镜像(如果这是个正确的术语的话)比简单地部署到一致的生产环境更容易?</target>
        </trans-unit>
        <trans-unit id="76737419ccfacbafbd0f525710c6a3a42ae7dd7b" translate="yes" xml:space="preserve">
          <source>Why is deploying software to a docker image (if that's the right term) easier than simply deploying to a consistent production environment?</source>
          <target state="translated">为什么将软件部署到docker镜像(如果这是个正确的术语的话)比简单地部署到一致的生产环境更容易?</target>
        </trans-unit>
        <trans-unit id="f9cdfffebc66514c02f674beb799818dedbc3a6f" translate="yes" xml:space="preserve">
          <source>Why it matters?</source>
          <target state="translated">为什么要这么做?</target>
        </trans-unit>
        <trans-unit id="99b4b35b78f8a91f025d97adbdc54bc7764bd29d" translate="yes" xml:space="preserve">
          <source>With Docker the idea is that you bundle up your application inside its own container along with the libraries it needs and then promote the &lt;strong&gt;whole&lt;/strong&gt; container as a single unit.</source>
          <target state="translated">使用Docker的想法是，将应用程序与所需的库一起捆绑在其自己的容器中，然后将&lt;strong&gt;整个&lt;/strong&gt;容器提升为一个单元。</target>
        </trans-unit>
        <trans-unit id="9093ae28c2ccd6692d394066fe08bfdc8d561258" translate="yes" xml:space="preserve">
          <source>With VMs you promote your application and its dependencies from one VM to the next DEV to UAT to PRD.</source>
          <target state="translated">通过虚拟机,您可以将您的应用程序及其依赖关系从一个虚拟机推广到下一个虚拟机DEV到UAT到PRD。</target>
        </trans-unit>
        <trans-unit id="a6cfb5ab13b910e2d7461b73b8aacfb4481e486d" translate="yes" xml:space="preserve">
          <source>With a &lt;strong&gt;virtual machine&lt;/strong&gt;, we have a server, we have a host operating system on that server, and then we have a hypervisor. And then running on top of that hypervisor, we have any number of guest operating systems with an application and its dependent binaries, and libraries on that server. It brings a whole guest operating system with it. It's quite heavyweight. Also there's a limit to how much you can actually put on each physical machine.</source>
          <target state="translated">使用&lt;strong&gt;虚拟机&lt;/strong&gt; ，我们有一个服务器，在该服务器上有一个主机操作系统，然后有一个虚拟机监控程序。 然后，在该虚拟机监控程序之上运行，我们可以使用任意数量的来宾操作系统，以及一个应用程序及其从属二进制文件以及该服务器上的库。 它带来了一个完整的客户操作系统。 它是重量级的。 此外，每台物理计算机上实际可以放置的数量也有限制。</target>
        </trans-unit>
        <trans-unit id="a45beaa5cc8f09acdd19ce70bb6c9300c62eddcc" translate="yes" xml:space="preserve">
          <source>With a Docker ecosystem, you will never need to move around gigabytes on &quot;small changes&quot; (thanks aufs and Registry) and you don't need to worry about losing performance by packaging applications into a Docker container at runtime. You don't need to worry about versions of that image.</source>
          <target state="translated">有了Docker生态系统,你永远不需要在 &quot;小改动 &quot;上移动千兆字节(感谢aufs和注册表),你也不需要担心在运行时将应用程序打包到Docker容器中,从而损失性能。你不需要担心该镜像的版本问题。</target>
        </trans-unit>
        <trans-unit id="1e3c7818924ae9d8fcbb0934d2f7637cfd7088fd" translate="yes" xml:space="preserve">
          <source>With normal LXC you need to come with some rootfs or share the rootfs and when shared, and the changes are reflected on other containers. Due to lot of these added features, Docker is more popular than LXC. LXC is popular in embedded environments for implementing security around processes exposed to external entities such as network and UI. Docker is popular in cloud multi-tenancy environment where consistent production environment is expected.</source>
          <target state="translated">使用普通的LXC,你需要自带一些rootfs,或者共享rootfs,共享后的变化会反映到其他容器上。由于很多这些附加的功能,Docker比LXC更受欢迎。LXC在嵌入式环境中很受欢迎,因为它可以围绕着暴露在外部实体(如网络和UI)的进程实现安全。而Docker在云端多租户环境中比较受欢迎,因为在云端多租户环境中,需要一致的生产环境。</target>
        </trans-unit>
        <trans-unit id="7972c83547259b5e2dd725e515d3075919647cbe" translate="yes" xml:space="preserve">
          <source>Your question assumes some consistent production environment. &lt;em&gt;But how to keep it consistent?&lt;/em&gt;
Consider some amount (&amp;gt;10) of servers and applications, stages in the pipeline.</source>
          <target state="translated">您的问题假设一个一致的生产环境。 &lt;em&gt;但是如何保持一致呢？&lt;/em&gt; 考虑流水线中某些数量的服务器和应用程序（&amp;gt; 10）。</target>
        </trans-unit>
        <trans-unit id="a08d179e776e577daf8ff6f5c184b673a0bb8d8d" translate="yes" xml:space="preserve">
          <source>a. LXCs are scoped to an instance of Linux. It might be different flavors of Linux (e.g. a Ubuntu container on a CentOS host but it&amp;rsquo;s still Linux.) Similarly, Windows-based containers are scoped to an instance of Windows now if we look at VMs they have a pretty broader scope and using the hypervisors you are not limited to operating systems Linux or Windows.</source>
          <target state="translated">一个。 LXC适用于Linux实例。 可能是不同风格的Linux（例如，CentOS主机上的Ubuntu容器，但仍是Linux。）类似地，如果我们查看基于VM的虚拟机，它们的范围更广，并且使用管理程序，您不仅限于Linux或Windows操作系统。</target>
        </trans-unit>
        <trans-unit id="df46babbf9059013283e3dd3304e2a5f7fa7aa93" translate="yes" xml:space="preserve">
          <source>b. LXCs have low overheads and have better performance as compared to VMs. Tools viz. Docker which are built on the shoulders of LXC technology have provided developers with a platform to run their applications and at the same time have empowered operations people with a tool that will allow them to deploy the same container on production servers or data centers. It tries to make the experience between a developer running an application, booting and testing an application and an operations person deploying that application seamless, because this is where all the friction lies in and purpose of DevOps is to break down those silos.</source>
          <target state="translated">b.LXC与虚拟机相比,开销较低,性能较好。建立在LXC技术基础上的Docker工具为开发者提供了一个运行应用程序的平台,同时也为运维人员提供了一个工具,使他们能够在生产服务器或数据中心部署相同的容器。它试图让开发者在运行应用、启动和测试应用和部署应用的运维人员之间的体验是无缝的,因为这是所有摩擦的地方,而DevOps的目的就是要打破这些孤岛。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
